name: HumanEval_6_parse_nested_parens
language: jl
results:
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    level_vector = []\n    depth = 0\n    for paren in paren_string\n    \
    \    if paren == '('\n            depth += 1\n        elseif paren == ')'\n  \
    \          level_vector = [level_vector; depth]\n            depth -= 1\n    \
    \    end\n    end\n    return level_vector\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_5vtz93_.jl:26\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_5vtz93_.jl:26 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_5vtz93_.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp_5vtz93_.jl:27\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_5vtz93_.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_5vtz93_.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp_5vtz93_.jl:28\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [2, 3, 2, 4, 3, 2, 1] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_5vtz93_.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_5vtz93_.jl:25\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_5vtz93_.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector of zeros.\n    levels = zeros(Int64, count(isspace,\
    \ paren_string))\n    # Initialize a counter for the group and a counter for the\
    \ current level of nesting.\n    group_count = 1\n    level_count = 0\n    # Loop\
    \ through the string.\n    for i = 1:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            # If an open paren, increment the level.\n            level_count\
    \ += 1\n        elseif paren_string[i] == ')'\n            # If a closed paren,\
    \ increment the level.\n            level_count -= 1\n        elseif paren_string[i]\
    \ == ' '\n            # If a space, store the level and reset it to zero.\n  \
    \          levels[group_count] = level_count\n            level_count = 0\n  \
    \          group_count += 1\n        end\n    end\n    return levels\nend\nlevels\
    \ = parse_nested_parens(\"(()()) ((())) () ((())()())\")\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8__mnnkr.jl:37\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8__mnnkr.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8__mnnkr.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp8__mnnkr.jl:38\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8__mnnkr.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8__mnnkr.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp8__mnnkr.jl:39\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8__mnnkr.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8__mnnkr.jl:36\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8__mnnkr.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_strings = split(paren_string, \" \")\n    return [find_max_paren_depth(paren_str)\
    \ for paren_str in paren_strings]\nend\n    \n# We loop through a string and keep\
    \ track of the current level of nesting and the max seen so far.\n# In the for\
    \ loop, we check the next parentheses and increment our level of nesting if the\
    \ current char is an open paren and the next char is a close paren.\n# Otherwise,\
    \ we increment the current level of nesting by 1 if we see an open paren, and\
    \ decrement it by 1 if we see a close paren.\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp15nbvh_d.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ find_max_paren_depth not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(paren_str::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp15nbvh_d.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp15nbvh_d.jl:21 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp15nbvh_d.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp15nbvh_d.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: find_max_paren_depth\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(paren_str::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp15nbvh_d.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp15nbvh_d.jl:22 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp15nbvh_d.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp15nbvh_d.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: find_max_paren_depth\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(paren_str::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(i"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp15nbvh_d.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_split = split(paren_string, \" \")\n    max_paren_depth = Vector{Int64}(length(paren_split))\n\
    \    for i in eachindex(paren_split)\n        parens = paren_split[i]\n      \
    \  depth = Int64(0)\n        max_depth = Int64(0)\n        for c in parens\n \
    \           if c == '('\n                depth += 1\n            elseif c == ')'\n\
    \                depth -= 1\n            end\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        end\n        max_paren_depth[i]\
    \ = max_depth\n    end\n    return max_paren_depth\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpnaty9p2e.jl:34\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpnaty9p2e.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnaty9p2e.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnaty9p2e.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpnaty9p2e.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpnaty9p2e.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnaty9p2e.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnaty9p2e.jl:33\ntest set:\
    \ Error During Test at /"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnaty9p2e.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = Int64[] # a stack for storing the count of parens for each group\n\
    \    current_group_count = 0 # the deepest level of parens for the current group\n\
    \    for c in paren_string\n        if c == '('\n            current_group_count\
    \ += 1\n        elseif c == ')'\n            current_group_count -= 1\n      \
    \  elseif c == ' '\n            # we've reached the end of a group; save its count\
    \ and start a new one\n            push!(stack, current_group_count)\n       \
    \     current_group_count = 0\n        end\n    end\n    return stack\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp906tjowx.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp906tjowx.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp906tjowx.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp906tjowx.jl:30\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp906tjowx.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp906tjowx.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp906tjowx.jl:31\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp906tjowx.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp906tjowx.jl:28\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp906tjowx.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    parsed_nested_levels = Vector{Int64}()\n    \n    for g in split(paren_string,\
    \ \" \")\n        curr_level = 0\n        max_level = 0\n        for p in g\n\
    \            if p == '('\n                curr_level += 1\n            elseif\
    \ p == ')'\n                curr_level -= 1\n            end\n            if curr_level\
    \ > max_level\n                max_level = curr_level\n            end\n     \
    \   end\n        push!(parsed_nested_levels, max_level)\n    end\n    return parsed_nested_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string)\n    max_nest_levels = zeros(length(paren_groups))\n\
    \    for (i, paren_group) in enumerate(paren_groups)\n        paren_group_len\
    \ = length(paren_group)\n        paren_stack = []\n        curr_max_nest_level\
    \ = 0\n        curr_nest_level = 0\n        for k = 1:paren_group_len\n      \
    \      curr_char = paren_group[k]\n            if curr_char == '('\n         \
    \       push!(paren_stack, curr_char)\n                curr_nest_level += 1\n\
    \                if curr_nest_level > curr_max_nest_level\n                  \
    \  curr_max_nest_level = curr_nest_level\n                end\n            elseif\
    \ curr_char == ')'\n                pop!(paren_stack)\n                curr_nest_level\
    \ -= 1\n            end\n        end\n        max_nest_levels[i] = curr_max_nest_level\n\
    \    end\n    return max_nest_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # base case is empty string (no input)\n    if paren_string == \"\"\n\
    \        return []\n    end\n    \n    # remove space between groups and split\
    \ using space\n    space_removed = replace(paren_string, \" \" => \"\")\n    split_parens\
    \ = split(space_removed, \"\")\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3il2nhwj.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3il2nhwj.jl:1\n\
    in expression starting at /tmp/tmp3il2nhwj.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    n_parens_list = []\n    for paren_group in split(paren_string, \" \")\n\
    \        n_parens = 0\n        n_parens_list_len = length(n_parens_list)\n   \
    \     for paren in paren_group\n            if paren == '('\n                push!(n_parens_list,\
    \ n_parens)\n                n_parens += 1\n            elseif paren == ')'\n\
    \                n_parens = pop!(n_parens_list)\n            end\n        end\n\
    \        push!(n_parens_list, n_parens)\n    end\n    if length(n_parens_list)\
    \ > n_parens_list_len\n        return n_parens_list[(n_parens_list_len+1):end]\n\
    \    else\n        return []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpd1w_c9r5.jl:34\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ n_parens_list_len not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpd1w_c9r5.jl:23\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd1w_c9r5.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd1w_c9r5.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpd1w_c9r5.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: n_parens_list_len\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpd1w_c9r5.jl:23\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd1w_c9r5.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd1w_c9r5.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpd1w_c9r5.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: n_parens_list_len not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n \
    \    @ Main /tmp/tmpd1w_c9r5.jl:23\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd1w_c9r5.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd1w_c9r5.jl:33\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd1w_c9r5.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    output = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        group =\
    \ paren_groups[i]\n        depth = 0\n        max_depth = 0\n        for paren\
    \ in group\n            if paren == '('\n                depth += 1\n        \
    \    elseif paren == ')'\n                depth -= 1\n            end\n      \
    \      max_depth = max(max_depth, depth)\n        end\n        output[i] = max_depth\n\
    \    end\n    return output\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    # Create an array of the splitted string\n    paren_groups = split(paren_string,\
    \ \" \")\n    \n    # Array to hold the depth values\n    depth_values = []\n\
    \    \n    # Iterate over the groups to find the deepest level of nesting\n  \
    \  for group in paren_groups\n        depth = 0\n        depth_temp = 0\n    \
    \    for character in group\n            if character == '('\n               \
    \ depth_temp += 1\n            elseif character == ')'\n                depth_temp\
    \ -= 1\n            end\n            if depth_temp > depth\n                depth\
    \ = depth_temp\n            end\n        end\n        push!(depth_values, depth)\n\
    \    end\n    \n    return depth_values\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    results = Vector{Int64}()\n\
    \    for paren in paren_list\n        level = 0\n        max_level = 0\n     \
    \   for i in 1:length(paren)\n            if paren[i] == '('\n               \
    \ level += 1\n            elseif paren[i] == ')'\n                level -= 1\n\
    \            end\n            if level > max_level\n                max_level\
    \ = level\n            end\n        end\n        push!(results, max_level)\n \
    \   end\n    return results\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    parse_nested_parens(paren_string) = map(group -> sum(map(paren -> paren\
    \ == '(' ? 1 : -1, group)), \n                                             split(paren_string,\
    \ r\"[ ]+\"))\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpctw_xjwv.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type var\"#parse_nested_parens#3\" to an object\
    \ of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpctw_xjwv.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpctw_xjwv.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpctw_xjwv.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpctw_xjwv.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: Cannot\
    \ `convert` an object of type var\"#parse_nested_parens#3\" to an object of type\
    \ Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpctw_xjwv.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpctw_xjwv.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_levels = Vector{Int64}()\n    open_paren_positions = Stack{Int64}()\n\
    \    for i in 1:length(paren_string)\n        if paren_string[i] == '('\n    \
    \        push!(open_paren_positions, i)\n        elseif paren_string[i] == ')'\n\
    \            open_paren_index = pop!(open_paren_positions)\n            max_levels\
    \ = [max_levels; i - open_paren_index]\n        end\n    end\n    return max_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpbw8mxant.jl:26\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ Stack not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpbw8mxant.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbw8mxant.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbw8mxant.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpbw8mxant.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: Stack\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpbw8mxant.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbw8mxant.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbw8mxant.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpbw8mxant.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: Stack not defined\n \
    \ Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmpbw8mxant.jl:10\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbw8mxant.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbw8mxant.jl:25\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbw8mxant.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Vector to hold the max depth for each group\n    depths = Int64[]\n\
    \    depth = 0  # intital depth\n    # Go through each character of the string\n\
    \    for i = 1:length(paren_string)\n        # If char is open paren, increase\
    \ depth \n        if paren_string[i] == '('\n            depth += 1\n        #\
    \ If char is close paren, decrease depth and append to the vector of depths\n\
    \        elseif paren_string[i] == ')'\n            depth -= 1\n            push!(depths,\
    \ depth)\n        # If char is space, reset depth to 0\n        else\n       \
    \     depth = 0\n        end\n    end\n    return depths\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp59ilczmz.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 1, 0, 2, 1,\
    \ 0, 0, 2, 1, 1, 1, 0] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp59ilczmz.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp59ilczmz.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp59ilczmz.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 1, 0, 2, 1, 0, 3, 2, 1, 0] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp59ilczmz.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp59ilczmz.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp59ilczmz.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 0] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp59ilczmz.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp59ilczmz.jl:32\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp59ilczmz.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_array = split(paren_string, \" \")\n    depth_array = Vector{Int64}(length(paren_array))\n\
    \    for i in 1:length(paren_array)\n        depth_array[i] = max_depth(paren_array[i])\n\
    \    end\n    return depth_array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxpwpk1ml.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpxpwpk1ml.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxpwpk1ml.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxpwpk1ml.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpxpwpk1ml.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpxpwpk1ml.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxpwpk1ml.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxpwpk1ml.jl:20\ntest set:\
    \ Error During Test at /"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxpwpk1ml.jl:18\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # get the individual input string for each of the group\n    input_groups\
    \ = split(paren_string, \" \")\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpucm5p3_4.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpucm5p3_4.jl:1\n\
    in expression starting at /tmp/tmpucm5p3_4.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    return [max_depth(g) for g in\
    \ groups]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzb_wqad1.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_depth not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(g::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpzb_wqad1.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpzb_wqad1.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpzb_wqad1.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpzb_wqad1.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_depth\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(g::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmpzb_wqad1.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpzb_wqad1.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpzb_wqad1.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpzb_wqad1.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: max_depth not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(g::SubString{String})\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"})"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzb_wqad1.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = strip(paren_string)\n    paren_arr = split(paren_string,\
    \ \" \")\n    result = zeros(Int64, length(paren_arr))\n    for i in 1:length(paren_arr)\n\
    \        paren_vec = collect(paren_arr[i])\n        if paren_vec[1] != '('\n \
    \           continue\n        end\n        depth = 0\n        max_depth = 0\n\
    \        for j in 1:length(paren_vec)\n            if paren_vec[j] == '('\n  \
    \              depth += 1\n            elseif paren_vec[j] == ')'\n          \
    \      depth -= 1\n            end\n            if depth > max_depth\n       \
    \         max_depth = depth\n            end\n        end\n        result[i] =\
    \ max_depth\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    3      3\n"
  exit_code: 0
  status: OK
- program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # create a list of all the parens\n    paren_list = split(paren_string,\
    \ ' ')\n    # for each paren_group in paren_list\n    paren_length = map(x ->\
    \ length(x), paren_list)\n    vals = map(x -> parse_one_paren(x), paren_list)\n\
    \    return vals\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpotsws6tc.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_one_paren not defined\n  Stacktrace:\n    [1] (::var\"#2#4\")(x::SubString{String})\n\
    \      @ Main /tmp/tmpotsws6tc.jl:13\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#2#4\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmpotsws6tc.jl:13\n    [7] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpotsws6tc.jl:21 [inlined]\n\
    \    [9] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpotsws6tc.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpotsws6tc.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_one_paren\
    \ not defined\n  Stacktrace:\n    [1] (::var\"#2#4\")(x::SubString{String})\n\
    \      @ Main /tmp/tmpotsws6tc.jl:13\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#2#4\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmpotsws6tc.jl:13\n    [7] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpotsws6tc.jl:22 [inlined]\n\
    \    [9] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/std"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpotsws6tc.jl:18\n"
  exit_code: 1
  status: SyntaxError
