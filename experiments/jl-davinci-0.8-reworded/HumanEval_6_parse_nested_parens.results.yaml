language: jl
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    level_vector = []\n    depth = 0\n    for paren in paren_string\n    \
    \    if paren == '('\n            depth += 1\n        elseif paren == ')'\n  \
    \          level_vector = [level_vector; depth]\n            depth -= 1\n    \
    \    end\n    end\n    return level_vector\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp_5vtz93_.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmp_5vtz93_.jl:26\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_5vtz93_.jl:26 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_5vtz93_.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp_5vtz93_.jl:27\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_5vtz93_.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_5vtz93_.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp_5vtz93_.jl:28\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [2, 3, 2, 4, 3, 2, 1] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_5vtz93_.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_5vtz93_.jl:25\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector of zeros.\n    levels = zeros(Int64, count(isspace,\
    \ paren_string))\n    # Initialize a counter for the group and a counter for the\
    \ current level of nesting.\n    group_count = 1\n    level_count = 0\n    # Loop\
    \ through the string.\n    for i = 1:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            # If an open paren, increment the level.\n            level_count\
    \ += 1\n        elseif paren_string[i] == ')'\n            # If a closed paren,\
    \ increment the level.\n            level_count -= 1\n        elseif paren_string[i]\
    \ == ' '\n            # If a space, store the level and reset it to zero.\n  \
    \          levels[group_count] = level_count\n            level_count = 0\n  \
    \          group_count += 1\n        end\n    end\n    return levels\nend\nlevels\
    \ = parse_nested_parens(\"(()()) ((())) () ((())()())\")\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8__mnnkr.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmp8__mnnkr.jl:37\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8__mnnkr.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8__mnnkr.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp8__mnnkr.jl:38\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8__mnnkr.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8__mnnkr.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp8__mnnkr.jl:39\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8__mnnkr.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8__mnnkr.jl:36\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_strings = split(paren_string, \" \")\n    return [find_max_paren_depth(paren_str)\
    \ for paren_str in paren_strings]\nend\n    \n# We loop through a string and keep\
    \ track of the current level of nesting and the max seen so far.\n# In the for\
    \ loop, we check the next parentheses and increment our level of nesting if the\
    \ current char is an open paren and the next char is a close paren.\n# Otherwise,\
    \ we increment the current level of nesting by 1 if we see an open paren, and\
    \ decrement it by 1 if we see a close paren.\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp15nbvh_d.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmp15nbvh_d.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ find_max_paren_depth not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(paren_str::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp15nbvh_d.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp15nbvh_d.jl:21 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp15nbvh_d.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp15nbvh_d.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: find_max_paren_depth\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(paren_str::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp15nbvh_d.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp15nbvh_d.jl:22 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp15nbvh_d.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp15nbvh_d.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: find_max_paren_depth\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(paren_str::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(i"
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_split = split(paren_string, \" \")\n    max_paren_depth = Vector{Int64}(length(paren_split))\n\
    \    for i in eachindex(paren_split)\n        parens = paren_split[i]\n      \
    \  depth = Int64(0)\n        max_depth = Int64(0)\n        for c in parens\n \
    \           if c == '('\n                depth += 1\n            elseif c == ')'\n\
    \                depth -= 1\n            end\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        end\n        max_paren_depth[i]\
    \ = max_depth\n    end\n    return max_paren_depth\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpnaty9p2e.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpnaty9p2e.jl:34\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpnaty9p2e.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnaty9p2e.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnaty9p2e.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpnaty9p2e.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpnaty9p2e.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnaty9p2e.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnaty9p2e.jl:33\ntest set:\
    \ Error During Test at /"
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = Int64[] # a stack for storing the count of parens for each group\n\
    \    current_group_count = 0 # the deepest level of parens for the current group\n\
    \    for c in paren_string\n        if c == '('\n            current_group_count\
    \ += 1\n        elseif c == ')'\n            current_group_count -= 1\n      \
    \  elseif c == ' '\n            # we've reached the end of a group; save its count\
    \ and start a new one\n            push!(stack, current_group_count)\n       \
    \     current_group_count = 0\n        end\n    end\n    return stack\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp906tjowx.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmp906tjowx.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp906tjowx.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp906tjowx.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp906tjowx.jl:30\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp906tjowx.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp906tjowx.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp906tjowx.jl:31\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp906tjowx.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp906tjowx.jl:28\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    parsed_nested_levels = Vector{Int64}()\n    \n    for g in split(paren_string,\
    \ \" \")\n        curr_level = 0\n        max_level = 0\n        for p in g\n\
    \            if p == '('\n                curr_level += 1\n            elseif\
    \ p == ')'\n                curr_level -= 1\n            end\n            if curr_level\
    \ > max_level\n                max_level = curr_level\n            end\n     \
    \   end\n        push!(parsed_nested_levels, max_level)\n    end\n    return parsed_nested_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string)\n    max_nest_levels = zeros(length(paren_groups))\n\
    \    for (i, paren_group) in enumerate(paren_groups)\n        paren_group_len\
    \ = length(paren_group)\n        paren_stack = []\n        curr_max_nest_level\
    \ = 0\n        curr_nest_level = 0\n        for k = 1:paren_group_len\n      \
    \      curr_char = paren_group[k]\n            if curr_char == '('\n         \
    \       push!(paren_stack, curr_char)\n                curr_nest_level += 1\n\
    \                if curr_nest_level > curr_max_nest_level\n                  \
    \  curr_max_nest_level = curr_nest_level\n                end\n            elseif\
    \ curr_char == ')'\n                pop!(paren_stack)\n                curr_nest_level\
    \ -= 1\n            end\n        end\n        max_nest_levels[i] = curr_max_nest_level\n\
    \    end\n    return max_nest_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # base case is empty string (no input)\n    if paren_string == \"\"\n\
    \        return []\n    end\n    \n    # remove space between groups and split\
    \ using space\n    space_removed = replace(paren_string, \" \" => \"\")\n    split_parens\
    \ = split(space_removed, \"\")\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp3il2nhwj.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp3il2nhwj.jl:1\n\
    in expression starting at /tmp/tmp3il2nhwj.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    n_parens_list = []\n    for paren_group in split(paren_string, \" \")\n\
    \        n_parens = 0\n        n_parens_list_len = length(n_parens_list)\n   \
    \     for paren in paren_group\n            if paren == '('\n                push!(n_parens_list,\
    \ n_parens)\n                n_parens += 1\n            elseif paren == ')'\n\
    \                n_parens = pop!(n_parens_list)\n            end\n        end\n\
    \        push!(n_parens_list, n_parens)\n    end\n    if length(n_parens_list)\
    \ > n_parens_list_len\n        return n_parens_list[(n_parens_list_len+1):end]\n\
    \    else\n        return []\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpd1w_c9r5.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpd1w_c9r5.jl:34\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ n_parens_list_len not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpd1w_c9r5.jl:23\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd1w_c9r5.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd1w_c9r5.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpd1w_c9r5.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: n_parens_list_len\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpd1w_c9r5.jl:23\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd1w_c9r5.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd1w_c9r5.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpd1w_c9r5.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: n_parens_list_len not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n \
    \    @ Main /tmp/tmpd1w_c9r5.jl:23\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd1w_c9r5.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd1w_c9r5.jl:33\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    output = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        group =\
    \ paren_groups[i]\n        depth = 0\n        max_depth = 0\n        for paren\
    \ in group\n            if paren == '('\n                depth += 1\n        \
    \    elseif paren == ')'\n                depth -= 1\n            end\n      \
    \      max_depth = max(max_depth, depth)\n        end\n        output[i] = max_depth\n\
    \    end\n    return output\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    # Create an array of the splitted string\n    paren_groups = split(paren_string,\
    \ \" \")\n    \n    # Array to hold the depth values\n    depth_values = []\n\
    \    \n    # Iterate over the groups to find the deepest level of nesting\n  \
    \  for group in paren_groups\n        depth = 0\n        depth_temp = 0\n    \
    \    for character in group\n            if character == '('\n               \
    \ depth_temp += 1\n            elseif character == ')'\n                depth_temp\
    \ -= 1\n            end\n            if depth_temp > depth\n                depth\
    \ = depth_temp\n            end\n        end\n        push!(depth_values, depth)\n\
    \    end\n    \n    return depth_values\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    results = Vector{Int64}()\n\
    \    for paren in paren_list\n        level = 0\n        max_level = 0\n     \
    \   for i in 1:length(paren)\n            if paren[i] == '('\n               \
    \ level += 1\n            elseif paren[i] == ')'\n                level -= 1\n\
    \            end\n            if level > max_level\n                max_level\
    \ = level\n            end\n        end\n        push!(results, max_level)\n \
    \   end\n    return results\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    parse_nested_parens(paren_string) = map(group -> sum(map(paren -> paren\
    \ == '(' ? 1 : -1, group)), \n                                             split(paren_string,\
    \ r\"[ ]+\"))\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpctw_xjwv.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpctw_xjwv.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type var\"#parse_nested_parens#3\" to an object\
    \ of type Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpctw_xjwv.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpctw_xjwv.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpctw_xjwv.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpctw_xjwv.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: Cannot\
    \ `convert` an object of type var\"#parse_nested_parens#3\" to an object of type\
    \ Vector{Int64}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpctw_xjwv.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/jul"
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_levels = Vector{Int64}()\n    open_paren_positions = Stack{Int64}()\n\
    \    for i in 1:length(paren_string)\n        if paren_string[i] == '('\n    \
    \        push!(open_paren_positions, i)\n        elseif paren_string[i] == ')'\n\
    \            open_paren_index = pop!(open_paren_positions)\n            max_levels\
    \ = [max_levels; i - open_paren_index]\n        end\n    end\n    return max_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpbw8mxant.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpbw8mxant.jl:26\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ Stack not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpbw8mxant.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbw8mxant.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbw8mxant.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpbw8mxant.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: Stack\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpbw8mxant.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbw8mxant.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbw8mxant.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpbw8mxant.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: Stack not defined\n \
    \ Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmpbw8mxant.jl:10\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbw8mxant.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbw8mxant.jl:25\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Vector to hold the max depth for each group\n    depths = Int64[]\n\
    \    depth = 0  # intital depth\n    # Go through each character of the string\n\
    \    for i = 1:length(paren_string)\n        # If char is open paren, increase\
    \ depth \n        if paren_string[i] == '('\n            depth += 1\n        #\
    \ If char is close paren, decrease depth and append to the vector of depths\n\
    \        elseif paren_string[i] == ')'\n            depth -= 1\n            push!(depths,\
    \ depth)\n        # If char is space, reset depth to 0\n        else\n       \
    \     depth = 0\n        end\n    end\n    return depths\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp59ilczmz.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmp59ilczmz.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 1, 0, 2, 1,\
    \ 0, 0, 2, 1, 1, 1, 0] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp59ilczmz.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp59ilczmz.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp59ilczmz.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 1, 0, 2, 1, 0, 3, 2, 1, 0] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp59ilczmz.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp59ilczmz.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp59ilczmz.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 0] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp59ilczmz.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp59ilczmz.jl:32\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_array = split(paren_string, \" \")\n    depth_array = Vector{Int64}(length(paren_array))\n\
    \    for i in 1:length(paren_array)\n        depth_array[i] = max_depth(paren_array[i])\n\
    \    end\n    return depth_array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpxpwpk1ml.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmpxpwpk1ml.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpxpwpk1ml.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxpwpk1ml.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxpwpk1ml.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpxpwpk1ml.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpxpwpk1ml.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxpwpk1ml.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxpwpk1ml.jl:20\ntest set:\
    \ Error During Test at /"
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # get the individual input string for each of the group\n    input_groups\
    \ = split(paren_string, \" \")\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpucm5p3_4.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpucm5p3_4.jl:1\n\
    in expression starting at /tmp/tmpucm5p3_4.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    return [max_depth(g) for g in\
    \ groups]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpzb_wqad1.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpzb_wqad1.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_depth not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(g::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpzb_wqad1.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpzb_wqad1.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpzb_wqad1.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpzb_wqad1.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_depth\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(g::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmpzb_wqad1.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpzb_wqad1.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpzb_wqad1.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpzb_wqad1.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: max_depth not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(g::SubString{String})\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"})"
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = strip(paren_string)\n    paren_arr = split(paren_string,\
    \ \" \")\n    result = zeros(Int64, length(paren_arr))\n    for i in 1:length(paren_arr)\n\
    \        paren_vec = collect(paren_arr[i])\n        if paren_vec[1] != '('\n \
    \           continue\n        end\n        depth = 0\n        max_depth = 0\n\
    \        for j in 1:length(paren_vec)\n            if paren_vec[j] == '('\n  \
    \              depth += 1\n            elseif paren_vec[j] == ')'\n          \
    \      depth -= 1\n            end\n            if depth > max_depth\n       \
    \         max_depth = depth\n            end\n        end\n        result[i] =\
    \ max_depth\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # create a list of all the parens\n    paren_list = split(paren_string,\
    \ ' ')\n    # for each paren_group in paren_list\n    paren_length = map(x ->\
    \ length(x), paren_list)\n    vals = map(x -> parse_one_paren(x), paren_list)\n\
    \    return vals\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpotsws6tc.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmpotsws6tc.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_one_paren not defined\n  Stacktrace:\n    [1] (::var\"#2#4\")(x::SubString{String})\n\
    \      @ Main /tmp/tmpotsws6tc.jl:13\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#2#4\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmpotsws6tc.jl:13\n    [7] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpotsws6tc.jl:21 [inlined]\n\
    \    [9] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpotsws6tc.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpotsws6tc.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_one_paren\
    \ not defined\n  Stacktrace:\n    [1] (::var\"#2#4\")(x::SubString{String})\n\
    \      @ Main /tmp/tmpotsws6tc.jl:13\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#2#4\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmpotsws6tc.jl:13\n    [7] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpotsws6tc.jl:22 [inlined]\n\
    \    [9] macro expansion\n      @ /shared/centos7/julia/1.7.3/share/julia/std"
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    return paren_string\n        |> split\n        |> map(x -> max(1, find_nested_parens(x)))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: \"|>\" is not a unary operator\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp05msuli8.jl:10\nin expression starting at\
    \ /tmp/tmp05msuli8.jl:10\n"
  stdout: ''
  timestamp: 1659979663
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    return count_levels(split(paren_string, \" \"))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpworz9db9.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpworz9db9.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_levels not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpworz9db9.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpworz9db9.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpworz9db9.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpworz9db9.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_levels\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpworz9db9.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpworz9db9.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpworz9db9.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpworz9db9.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_levels not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpworz9db9.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpworz9db9.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpworz9db9.jl:15\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979664
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_strs = split(paren_string, \" \")\n    return [parse_single_parens(p)\
    \ for p in paren_strs]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpne3_ngm2.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpne3_ngm2.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_single_parens not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(p::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpne3_ngm2.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpne3_ngm2.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpne3_ngm2.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpne3_ngm2.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_single_parens\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(p::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmpne3_ngm2.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpne3_ngm2.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpne3_ngm2.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpne3_ngm2.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_single_parens not\
    \ defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(p::SubString{String})\n     @\
    \ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ v"
  timestamp: 1659979664
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    (max_depth = 0, depth = 0, max_depths = []) = (0, 0, [])\n    for paren\
    \ in paren_string\n        if paren == '('\n            depth += 1\n         \
    \   max_depth = max(max_depth, depth)\n        elseif paren == ')'\n         \
    \   depth -= 1\n        else\n            push!(max_depths, max_depth)\n     \
    \       (max_depth, depth) = (0, 0)\n        end\n    end\n    return max_depths\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid assignment location \"max_depth = 0\"\
    \ around /tmp/tmpl2tkfwwg.jl:9\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpl2tkfwwg.jl:1\n\
    in expression starting at /tmp/tmpl2tkfwwg.jl:1\n"
  stdout: ''
  timestamp: 1659979663
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Vector{Int64} to store the maximum level of nesting of parentheses\n\
    \    paren_levels = Int64[]\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpeapm2rr6.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpeapm2rr6.jl:1\n\
    in expression starting at /tmp/tmpeapm2rr6.jl:1\n"
  stdout: ''
  timestamp: 1659979663
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    return [deepest_parens(i) for i in split(paren_string, \" \")]\nend\n\
    #Test\nparse_nested_parens(\"(()()) ((())) () ((())()())\")\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: UndefVarError: deepest_parens not defined\nStacktrace:\n\
    \ [1] (::var\"#1#2\")(i::SubString{String})\n   @ Main ./none:0\n [2] iterate\n\
    \   @ ./generator.jl:47 [inlined]\n [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"})\n   @ Base ./array.jl:724\n [4] parse_nested_parens(paren_string::String)\n\
    \   @ Main /tmp/tmpogsndujq.jl:9\n [5] top-level scope\n   @ /tmp/tmpogsndujq.jl:12\n\
    in expression starting at /tmp/tmpogsndujq.jl:12\n"
  stdout: ''
  timestamp: 1659979663
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_strings = split(paren_string, ' ')\n    return [depth_nested_parens(s)\
    \ for s in paren_strings]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp8tei3nj4.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmp8tei3nj4.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ depth_nested_parens not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(s::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp8tei3nj4.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8tei3nj4.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8tei3nj4.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp8tei3nj4.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: depth_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(s::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmp8tei3nj4.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8tei3nj4.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8tei3nj4.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp8tei3nj4.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: depth_nested_parens not\
    \ defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(s::SubString{String})\n     @\
    \ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ v"
  timestamp: 1659979664
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    n = length(paren_string)\n    paren_count = 0\n    max_nesting = 0\n \
    \   nesting_arr = zeros(Int64, length(paren_string))\n    paren_cnt = 0\n    for\
    \ i = 1:n\n        if paren_string[i] == '('\n            paren_cnt += 1\n   \
    \         if paren_cnt > max_nesting\n                max_nesting = paren_cnt\n\
    \            end\n        elseif paren_string[i] == ')'\n            paren_cnt\
    \ -= 1\n        end\n        nesting_arr[i] = paren_cnt\n    end\n    #println(max_nesting)\n\
    \    #println(nesting_arr)\n    return nesting_arr\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpl9wiw13u.jl:31

    '
  stdout: "test set: Test Failed at /tmp/tmpl9wiw13u.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 2, 1, 2, 1,\
    \ 0, 0, 1, 2, 3  \u2026  1, 2, 3, 2, 1, 2, 1, 2, 1, 0] == [2, 3, 1, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpl9wiw13u.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl9wiw13u.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpl9wiw13u.jl:35\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 0, 0, 1, 2, 1, 0, 0, 1, 2  \u2026  0, 0,\
    \ 1, 2, 3, 4, 3, 2, 1, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpl9wiw13u.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpl9wiw13u.jl:33\ntest set: Test Failed at /tmp/tmpl9wiw13u.jl:36\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [1, 2, 1, 2,\
    \ 3, 2, 1, 2, 3, 4, 3, 2, 1, 0] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpl9wiw13u.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpl9wiw13u.jl:33\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979663
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    for paren_group in paren_groups\n\
    \        println(parse_nested_parens_helper(paren_group))\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp7jwc7q2z.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmp7jwc7q2z.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp7jwc7q2z.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7jwc7q2z.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7jwc7q2z.jl:18\ntest set:\
    \ Error During Test at /tmp/tmp7jwc7q2z.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp7jwc7q2z.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7jwc7q2z.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7jwc7q2z.jl:18\ntest set:\
    \ Error During Test at /tmp/tmp7jwc7q2z.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp7jwc7q2z.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7jwc7q2z.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7jwc7q2z.jl:18\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979664
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    n = length(paren_string)\n    current_level = 0 # current level of nested\
    \ parentheses\n    max_level = 0 # maximum level of nested parentheses so far\n\
    \    max_level_list = Vector{Int64}() # to store the maximum level of nested parentheses\
    \ for each group\n    for i in 1:n\n        if paren_string[i] == '('\n      \
    \      current_level += 1\n            if current_level > max_level\n        \
    \        max_level = current_level\n            end\n        elseif paren_string[i]\
    \ == ')'\n            current_level -= 1\n        elseif paren_string[i] == '\
    \ '\n            push!(max_level_list, max_level)\n            max_level = 0\n\
    \            current_level = 0\n        end\n    end\n    push!(max_level_list,\
    \ max_level)\n    return max_level_list\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979662
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = Int64[] # stack to store the group number\n    res = Vector{Int64}()\
    \ # contains the deepnest value for each group\n    level = 0 # the depth of current\
    \ group\n    for s in paren_string\n        if s == '('\n            push!(stack,\
    \ level + 1)\n            level += 1\n        elseif s == ')'\n            pop!(stack)\n\
    \            level -= 1\n        elseif s == ' '\n            push!(res, level)\n\
    \            level = 0\n        end\n    end\n    push!(res, level)\n    return\
    \ res\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8ac0ai4x.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmp8ac0ai4x.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8ac0ai4x.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8ac0ai4x.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp8ac0ai4x.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8ac0ai4x.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8ac0ai4x.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp8ac0ai4x.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8ac0ai4x.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8ac0ai4x.jl:31\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979664
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    depth = 0\n    max_depth = 0\n    paren_depth = []\n    append!(paren_depth,\
    \ 0)\n    for paren in paren_string\n        if paren == '('\n            depth\
    \ += 1\n            if depth > max_depth\n                max_depth = depth\n\
    \            end\n        elseif paren == ')'\n            append!(paren_depth,\
    \ max_depth)\n            depth -= 1\n        end\n    end\n    paren_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8_j2yl2c.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp8_j2yl2c.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 2, 2, 2, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8_j2yl2c.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8_j2yl2c.jl:30\ntest set: Test Failed at /tmp/tmp8_j2yl2c.jl:32\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8_j2yl2c.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8_j2yl2c.jl:30\ntest set: Test Failed at /tmp/tmp8_j2yl2c.jl:33\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [0, 2, 3, 3,\
    \ 4, 4, 4, 4] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8_j2yl2c.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8_j2yl2c.jl:30\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979664
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = 0\n    nesting_levels\
    \ = zeros(Int64, length(paren_groups))\n    for i in 1:length(paren_groups)\n\
    \        group = paren_groups[i]\n        group_max_nesting = 0\n        paren_stack\
    \ = Array{Any}(0)\n        for c in group\n            if c == '('\n         \
    \       push!(paren_stack, '(')\n                group_max_nesting += 1\n    \
    \        elseif c == ')'\n                pop!(paren_stack)\n                group_max_nesting\
    \ -= 1\n            end\n        end\n        nesting_levels[i] = group_max_nesting\n\
    \    end\n    return nesting_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpra_q23a9.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpra_q23a9.jl:34\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching (Array{Any})(::Int64)\n  Closest candidates are:\n    (Array{T})(!Matched::LinearAlgebra.UniformScaling,\
    \ !Matched::Tuple{Int64, Int64}) where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\n\
    \    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\n\
    \    (Array{T})(!Matched::LinearAlgebra.LQPackedQ{T, S} where S<:AbstractMatrix{T})\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/lq.jl:168\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpra_q23a9.jl:15\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpra_q23a9.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpra_q23a9.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpra_q23a9.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching (Array{Any})(::Int64)\n  Closest candidates are:\n    (Array{T})(!Matched::LinearAlgebra.UniformScaling,\
    \ !Matched::Tuple{Int64, Int64}) where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\n\
    \    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\n\
    \    (Array{T})(!Matched::LinearAlgebra.LQPackedQ{T, S} where S<:AbstractMatrix{T})\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/lq.jl:168\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::St"
  timestamp: 1659979665
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    levels_vec = Int64[] #vector to store the max nesting level of each group\n\
    \    paren_string = paren_string * \" \" #create a space between groups\n    level\
    \ = 0 #current level of nesting\n    for i = 1:length(paren_string)\n        if\
    \ paren_string[i] == '('\n            level += 1\n        elseif paren_string[i]\
    \ == ')'\n            level -= 1\n        elseif paren_string[i] == ' '\n    \
    \        push!(levels_vec, level)\n            level = 0\n        end\n    end\n\
    \    return levels_vec\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpgxaj_m47.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmpgxaj_m47.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgxaj_m47.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgxaj_m47.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpgxaj_m47.jl:30\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgxaj_m47.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgxaj_m47.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpgxaj_m47.jl:31\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgxaj_m47.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgxaj_m47.jl:28\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979664
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # create a stack\n    paren_stack = Stack()\n    nest_levels = Vector{Int64}()\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpp46lx898.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpp46lx898.jl:1\n\
    in expression starting at /tmp/tmpp46lx898.jl:1\n"
  stdout: ''
  timestamp: 1659979663
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    v = Vector{Int64}()\n    for p in split(paren_string)\n        v = push!(v,\
    \ parse_nested_parens_helper(p))\n    end\n    return v\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmphyapr5at.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmphyapr5at.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmphyapr5at.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphyapr5at.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphyapr5at.jl:19\ntest set:\
    \ Error During Test at /tmp/tmphyapr5at.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmphyapr5at.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphyapr5at.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphyapr5at.jl:19\ntest set:\
    \ Error During Test at /tmp/tmphyapr5at.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmphyapr5at.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphyapr5at.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphyapr5at.jl:19\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979664
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_array = split(paren_string, \" \")\n    paren_levels = Vector{Int64}(undef,\
    \ length(paren_array))\n    for (index, group) in enumerate(paren_array)\n   \
    \     group_level = 0\n        for character in group\n            if character\
    \ == '('\n                group_level += 1\n            elseif character == ')'\n\
    \                group_level -= 1\n            end\n        end\n        paren_levels[index]\
    \ = group_level\n    end\n    return paren_levels\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpd7xx899h.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmpd7xx899h.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd7xx899h.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd7xx899h.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpd7xx899h.jl:30\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd7xx899h.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd7xx899h.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpd7xx899h.jl:31\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd7xx899h.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd7xx899h.jl:28\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979664
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    matches = split(paren_string, \" \")\n    return [find_max_nested_parens(match)\
    \ for match in matches]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpsccsp588.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpsccsp588.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ find_max_nested_parens not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(match::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpsccsp588.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpsccsp588.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpsccsp588.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpsccsp588.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: find_max_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(match::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpsccsp588.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpsccsp588.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpsccsp588.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpsccsp588.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: find_max_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(match::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{"
  timestamp: 1659979664
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ size(paren_groups, 1))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        start_paren_idx = findfirst(isopen_paren, paren_group)\n        curr_nesting\
    \ = 1\n        for char in paren_group[start_paren_idx+1:end]\n            if\
    \ isopen_paren(char)\n                curr_nesting += 1\n            elseif isclose_paren(char)\n\
    \                curr_nesting -= 1\n            end\n        end\n        max_nesting[i]\
    \ = curr_nesting\n    end\n    return max_nesting\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpmuirwa_d.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpmuirwa_d.jl:30\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ isopen_paren not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpmuirwa_d.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmuirwa_d.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmuirwa_d.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpmuirwa_d.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: isopen_paren\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpmuirwa_d.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmuirwa_d.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmuirwa_d.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpmuirwa_d.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: isopen_paren not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpmuirwa_d.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmuirwa_d.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmuirwa_d.jl:29\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979664
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string)\n    levels = Vector{Int64}(undef, length(paren_list))\n\
    \    for (i, item) in enumerate(paren_list)\n        paren_stack = Int64[]\n \
    \       for ch in item\n            if ch == '('\n                push!(paren_stack,\
    \ ch)\n            elseif ch == ')'\n                if isempty(paren_stack)\n\
    \                    push!(paren_stack, 0)\n                else\n           \
    \         pop!(paren_stack)\n                end\n            end\n        end\n\
    \        levels[i] = length(paren_stack)\n    end\n    return levels\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpugyb4mty.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmpugyb4mty.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpugyb4mty.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpugyb4mty.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpugyb4mty.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpugyb4mty.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpugyb4mty.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpugyb4mty.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpugyb4mty.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpugyb4mty.jl:32\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979664
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    n = length(paren_string)\n    max_level = Vector{Int64}(undef, length(split(paren_string,\
    \ \" \")))\n    level = 0\n    i = 1\n    j = 1\n    while i <= n \n        if\
    \ paren_string[i] == '('\n            level += 1\n        elseif paren_string[i]\
    \ == ')'\n            level -= 1\n        end\n        if level > max_level[j]\n\
    \            max_level[j] = level\n        end\n        if paren_string[i] ==\
    \ ' '\n            j += 1\n        end\n        i += 1\n    end\n    return max_level\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979662
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    pairs = split(paren_string) # Split the string into multiple groups separated\
    \ by spaces\n    depth = zeros(Int64, length(pairs)) # Create an array with the\
    \ same length as the number of groups in the string\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp0mgbbql9.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp0mgbbql9.jl:1\n\
    in expression starting at /tmp/tmp0mgbbql9.jl:1\n"
  stdout: ''
  timestamp: 1659979663
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: string\n    Output: vector of integer\n    \"\"\"\n\
    \    processed_parens = [process_parens(paren_group) for paren_group in split(paren_string,\
    \ \" \")]\n    return [maximum([max(i) for i in processed_parens[j]]) for j in\
    \ 1:length(processed_parens)]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpjobkkiqn.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmpjobkkiqn.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ process_parens not defined\n  Stacktrace:\n   [1] (::var\"#1#4\")(paren_group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#4\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpjobkkiqn.jl:13\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpjobkkiqn.jl:21 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpjobkkiqn.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpjobkkiqn.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: process_parens\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#4\")(paren_group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#4\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpjobkkiqn.jl:13\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpjobkkiqn.jl:22 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpjobkkiqn.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpjobkkiqn.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: process_parens not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#4\")(paren_group::SubString{String})\n     @\
    \ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubStr"
  timestamp: 1659979664
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    depth_vector = []\n    paren_vector = split(paren_string)\n    for item\
    \ in paren_vector\n        depth = 0\n        max_depth = 0\n        for i in\
    \ item\n            if i == '('\n                depth += 1\n            elseif\
    \ i == ')'\n                depth -= 1\n            end\n            if depth\
    \ > max_depth\n                max_depth = depth\n            end\n        end\n\
    \        push!(depth_vector, max_depth)\n    end\n    return depth_vector\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979662
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # count the number of opening parentheses we've encountered so far, but\
    \ not yet closed\n    # keep adding 1 to this count for each open paren encountered,\
    \ and subtract 1 for each close paren encountered\n    # the maximum of this count\
    \ will be the maximum nesting of parens encountered\n    curr_nest_count = 0\n\
    \    deepest_nest_count = 0\n    deepest_nest_counts = []\n    for ch in paren_string\n\
    \        if ch == '('\n            curr_nest_count += 1\n            if curr_nest_count\
    \ > deepest_nest_count\n                deepest_nest_count = curr_nest_count\n\
    \            end\n        elseif ch == ')'\n            curr_nest_count -= 1\n\
    \        elseif ch == ' '\n            deepest_nest_counts = vcat(deepest_nest_counts,\
    \ deepest_nest_count)\n            deepest_nest_count = 0\n            curr_nest_count\
    \ = 0\n        end\n    end\n    # add the last group of parens\n    deepest_nest_counts\
    \ = vcat(deepest_nest_counts, deepest_nest_count)\n    return deepest_nest_counts\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979662
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_levels = Vector{Int64}(undef, length(paren_string))\n    j = 1\n\
    \    for i in 1:length(paren_string)\n        if paren_string[i] == '('\n    \
    \        paren_levels[j] += 1\n        elseif paren_string[i] == ')'\n       \
    \     j += 1\n        end\n    end\n    paren_levels[1:j-1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmplsnqcr2c.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmplsnqcr2c.jl:25\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 1, 0, 3, 0,\
    \ 0, 1, 3, 0, 1, 1, 0] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmplsnqcr2c.jl:25 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmplsnqcr2c.jl:24\ntest set: Test Failed at /tmp/tmplsnqcr2c.jl:26\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [47477987881793, 47477987881810, 47477987881824, 47477987881843, 47477987881856,\
    \ 47477987881872, 47477987881892, 47477987881904, 47477987881920, 47477987884928]\
    \ == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplsnqcr2c.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplsnqcr2c.jl:24\ntest set: Test\
    \ Failed at /tmp/tmplsnqcr2c.jl:27\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [47478014226642, 47478014226674, 47478008123536, 47478014226739,\
    \ 47478014226768, 47478014113040, 47478154359760] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplsnqcr2c.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplsnqcr2c.jl:24\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979665
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    depths = []\n    for i in 1:length(groups)\n\
    \        depths[i] = parse_nested_parens_helper(groups[i])\n    end\n    return\
    \ depths\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpy1qy66a4.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmpy1qy66a4.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpy1qy66a4.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpy1qy66a4.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpy1qy66a4.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpy1qy66a4.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpy1qy66a4.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpy1qy66a4.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpy1qy66a4.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpy1qy66a4.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpy1qy66a4.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpy1qy66a4.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpy1qy66a4.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979666
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    num_layers_per_group = []\n    for group in split(paren_string, \" \"\
    )\n        num_layers = 0\n        open_parens = 0\n        for c in group\n \
    \           if c == '('\n                open_parens += 1\n                num_layers\
    \ = max(num_layers, open_parens)\n            elseif c == ')'\n              \
    \  open_parens -= 1\n            end\n        end\n        push!(num_layers_per_group,\
    \ num_layers)\n    end\n    return num_layers_per_group\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979663
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\" The basic idea is to use the index of the first and last character\
    \ of the string to represent \n        the beginning and end of the string. The\
    \ length of the string is the level of nesting.\n    \"\"\"\n    if isempty(paren_string)\n\
    \        return Int64[]\n    end\n    levels = Vector{Int64}()\n    begin = 1\n\
    \    for i in 1:length(paren_string)\n        if paren_string[i] == ' '\n    \
    \        push!(levels, i - begin)\n            begin = i + 1\n        end\n  \
    \  end\n    push!(levels, length(paren_string) - begin + 1)\n    return levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"=\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpft6520c2.jl:16\nin expression starting at /tmp/tmpft6520c2.jl:16\n"
  stdout: ''
  timestamp: 1659979664
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = Int64[]\n    max_depth = Int64[]\n    depth = 0\n    for paren\
    \ in paren_string\n        if paren == '('\n            push!(stack, 1)\n    \
    \        depth += 1\n        elseif paren == ')'\n            pop!(stack)\n  \
    \          if isempty(stack)\n                push!(max_depth, depth)\n      \
    \          depth = 0\n            end\n        end\n    end\n    return max_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp55s0ni6p.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp55s0ni6p.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [3, 3, 1, 5] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp55s0ni6p.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp55s0ni6p.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp55s0ni6p.jl:33\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [7] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp55s0ni6p.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp55s0ni6p.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     2      3\n"
  timestamp: 1659979665
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    n = length(paren_string)\n    paren_vec = zeros(Int64, n)\n    # Loop\
    \ through the string from left to right\n    # Keep track of the number of unclosed\
    \ parentheses \n    # Paren_vec is the deepest level of nesting\n    level = 0\n\
    \    for i = 1:n\n        ch = paren_string[i]\n        if ch == '('\n       \
    \     level += 1\n        elseif ch == ')'\n            level -= 1\n        end\n\
    \        if level > paren_vec[i]\n            paren_vec[i] = level\n        end\n\
    \    end\n    return paren_vec\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp07rqpkk6.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmp07rqpkk6.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 2, 1, 2, 1,\
    \ 0, 0, 1, 2, 3  \u2026  1, 2, 3, 2, 1, 2, 1, 2, 1, 0] == [2, 3, 1, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp07rqpkk6.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp07rqpkk6.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp07rqpkk6.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 0, 0, 1, 2, 1, 0, 0, 1, 2  \u2026  0, 0,\
    \ 1, 2, 3, 4, 3, 2, 1, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp07rqpkk6.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp07rqpkk6.jl:32\ntest set: Test Failed at /tmp/tmp07rqpkk6.jl:35\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [1, 2, 1, 2,\
    \ 3, 2, 1, 2, 3, 4, 3, 2, 1, 0] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp07rqpkk6.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp07rqpkk6.jl:32\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979665
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    return map(s -> count_nested_parens(s), split(paren_string, r\"\\s+\"\
    ))\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t\
    @test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpep6c7fgt.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpep6c7fgt.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_nested_parens not defined\n  Stacktrace:\n    [1] (::var\"#1#2\")(s::SubString{String})\n\
    \      @ Main /tmp/tmpep6c7fgt.jl:9\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmpep6c7fgt.jl:9\n    [7] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpep6c7fgt.jl:16 [inlined]\n\
    \    [9] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpep6c7fgt.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpep6c7fgt.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_nested_parens\
    \ not defined\n  Stacktrace:\n    [1] (::var\"#1#2\")(s::SubString{String})\n\
    \      @ Main /tmp/tmpep6c7fgt.jl:9\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmpep6c7fgt.jl:9\n    [7] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpep6c7fgt.jl:17 [inlined]\n\
    \    [9] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/sr"
  timestamp: 1659979666
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    return map(find_nested_parens, split(paren_string, \" \"))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpth6brjjy.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpth6brjjy.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ find_nested_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpth6brjjy.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpth6brjjy.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpth6brjjy.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpth6brjjy.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: find_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpth6brjjy.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpth6brjjy.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpth6brjjy.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpth6brjjy.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: find_nested_parens not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n \
    \    @ Main /tmp/tmpth6brjjy.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpth6brjjy.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpth6brjjy.jl:15\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979666
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    N = length(paren_string)\n    open_parens = [0]\n    levels = Array{Int64}(length(paren_string))\n\
    \    levels[1] = 0\n    for (i, char) in enumerate(paren_string)\n        if char\
    \ == '('\n            push!(open_parens, 0)\n            levels[i+1] = levels[i]\
    \ + 1\n        elseif char == ')'\n            pop!(open_parens)\n           \
    \ levels[i+1] = levels[i] - 1\n        elseif char == ' '\n            levels[i+1]\
    \ = levels[i]\n        end\n    end\n    levels[N]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpf40c__zi.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmpf40c__zi.jl:31\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching (Array{Int64})(::Int64)\n  Closest candidates are:\n    (Array{T})(!Matched::LinearAlgebra.UniformScaling,\
    \ !Matched::Tuple{Int64, Int64}) where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\n\
    \    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\n\
    \    (Array{T})(!Matched::LinearAlgebra.LQPackedQ{T, S} where S<:AbstractMatrix{T})\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/lq.jl:168\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpf40c__zi.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpf40c__zi.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpf40c__zi.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpf40c__zi.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching (Array{Int64})(::Int64)\n  Closest candidates are:\n    (Array{T})(!Matched::LinearAlgebra.UniformScaling,\
    \ !Matched::Tuple{Int64, Int64}) where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\n\
    \    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\n\
    \    (Array{T})(!Matched::LinearAlgebra.LQPackedQ{T, S} where S<:AbstractMatrix{T})\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/lq.jl:168\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string"
  timestamp: 1659979667
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Vector for storing the parse\n    v = []\n    # levels of parentheses\n\
    \    level = 0\n    for i = 1:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            level += 1\n        elseif paren_string[i] == ')'\n    \
    \        push!(v, level)\n            level -= 1\n        end\n    end\n    v\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbpf442vj.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpbpf442vj.jl:28\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbpf442vj.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbpf442vj.jl:27\ntest set: Test Failed at /tmp/tmpbpf442vj.jl:29\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbpf442vj.jl:29 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbpf442vj.jl:27\ntest set: Test Failed at /tmp/tmpbpf442vj.jl:30\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [2, 3, 2, 4,\
    \ 3, 2, 1] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbpf442vj.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbpf442vj.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979666
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # split the string at spaces\n    group_arr = split(paren_string)\n  \
    \  # initialize output\n    levels = Vector{Int64}(length(group_arr))\n    # for\
    \ each of the nested paren group in input, output the deepest level of nesting\n\
    \    for (index, group) in enumerate(group_arr)\n        level = 0\n        max_level\
    \ = 0\n        for (index, char) in enumerate(group)\n            if char == '('\n\
    \                level += 1\n            elseif char == ')'\n                level\
    \ -= 1\n            end\n            max_level = max(max_level, level)\n     \
    \   end\n        levels[index] = max_level\n    end\n    return levels\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpeok41klt.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpeok41klt.jl:34\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at ~/.conda/envs/polyglot/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at ~/.conda/envs/polyglot/share/julia/base/bitarray.jl:494\n\
    \    Vector{T}(!Matched::Core.Compiler.AbstractRange{T}) where T at ~/.conda/envs/polyglot/share/julia/base/range.jl:1286\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpeok41klt.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeok41klt.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeok41klt.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpeok41klt.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at ~/.conda/envs/polyglot/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at ~/.conda/envs/polyglot/share/julia/base/bitarray.jl:494\n\
    \    Vector{T}(!Matched::Core.Compiler.AbstractRange{T}) where T at ~/.conda/envs/polyglot/share/julia/base/range.jl:1286\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpeok41klt.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeok41klt.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeok41klt.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpeok41klt.jl:36\n  Test t"
  timestamp: 1659979668
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    return [get_depth(i) for i in split(paren_string)]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmps9622vmj.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmps9622vmj.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_depth not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(i::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmps9622vmj.jl:9\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmps9622vmj.jl:16 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmps9622vmj.jl:15\ntest set:\
    \ Error During Test at /tmp/tmps9622vmj.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_depth\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(i::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmps9622vmj.jl:9\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmps9622vmj.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmps9622vmj.jl:15\ntest set:\
    \ Error During Test at /tmp/tmps9622vmj.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: get_depth not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(i::SubString{String})\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"})\n     @ Base ./array.j"
  timestamp: 1659979667
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    depths = []\n    current_depth = 0\n    for paren in paren_string\n  \
    \      if paren == '('\n            current_depth += 1\n        elseif paren ==\
    \ ')'\n            current_depth -= 1\n        elseif paren == ' '\n         \
    \   push!(depths, current_depth)\n            current_depth = 0\n        end\n\
    \    end\n    push!(depths, current_depth)\n    return depths\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpilhocn5d.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmpilhocn5d.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilhocn5d.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilhocn5d.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpilhocn5d.jl:30\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilhocn5d.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilhocn5d.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpilhocn5d.jl:31\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpilhocn5d.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpilhocn5d.jl:28\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979667
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    num_parens = length(paren_string)\n    paren_stack = Int64[]\n    curr_stack_size\
    \ = 0\n    group_paren_level = Int64[]\n    for i in 1:num_parens\n        # if\
    \ the current character is a left paren, increment the stack length and\n    \
    \    # add to the end of stack.\n        if paren_string[i] == '('\n         \
    \   push!(paren_stack, 1)\n            curr_stack_size += 1\n        # else, if\
    \ the current character is a right paren, decrement the stack length.\n      \
    \  # if the stack is empty, this was the end of a group, so append the current\n\
    \        # stack length to the end of group_paren_level.\n        elseif paren_string[i]\
    \ == ')'\n            curr_stack_size -= 1\n            if isempty(paren_stack)\n\
    \                push!(group_paren_level, curr_stack_size)\n            else\n\
    \                pop!(paren_stack)\n            end\n        end\n    end\n  \
    \  group_paren_level\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpiw4cn625.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmpiw4cn625.jl:38\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: Int64[] == [2, 3,\
    \ 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiw4cn625.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiw4cn625.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpiw4cn625.jl:39\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: Int64[] == [1, 2, 3, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiw4cn625.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiw4cn625.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpiw4cn625.jl:40\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpiw4cn625.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpiw4cn625.jl:37\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979666
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    return [parse_nested_parens_single(p) for p in split(paren_string)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpg02odlf5.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpg02odlf5.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_single not defined\n  Stacktrace:\n   [1] (::var\"#1#2\"\
    )(p::SubString{String})\n     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47\
    \ [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"\
    #1#2\"})\n     @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpg02odlf5.jl:9\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpg02odlf5.jl:16 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpg02odlf5.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpg02odlf5.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_single\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(p::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmpg02odlf5.jl:9\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpg02odlf5.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpg02odlf5.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpg02odlf5.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_single\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(p::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{Su"
  timestamp: 1659979667
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # to store the max-depth for each group\n    max_depth_vector = Int64[]\n\
    \    # to store the current depth for each group\n    stack = Int64[]\n    for\
    \ (i, c) in enumerate(paren_string)\n        if c == '('\n            push!(stack,\
    \ 1)\n        elseif c == ')'\n            depth = pop!(stack)\n            while\
    \ depth != 1\n                depth = pop!(stack)\n            end\n         \
    \   if !isempty(stack)\n                depth = pop!(stack)\n                depth\
    \ += 1\n                push!(stack, depth)\n            end\n        elseif c\
    \ == ' ' && !isempty(stack)\n            depth = pop!(stack)\n            push!(max_depth_vector,\
    \ depth)\n        end\n    end\n    # in case there are no spaces after the last\
    \ group\n    if !isempty(stack)\n        depth = pop!(stack)\n        push!(max_depth_vector,\
    \ depth)\n    end\n    return max_depth_vector\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpkvoqiqag.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpkvoqiqag.jl:43\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  ArgumentError:\
    \ array must be non-empty\n  Stacktrace:\n   [1] pop!\n     @ ./array.jl:1251\
    \ [inlined]\n   [2] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmpkvoqiqag.jl:19\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpkvoqiqag.jl:43 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpkvoqiqag.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpkvoqiqag.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  ArgumentError: array\
    \ must be non-empty\n  Stacktrace:\n   [1] pop!\n     @ ./array.jl:1251 [inlined]\n\
    \   [2] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmpkvoqiqag.jl:19\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpkvoqiqag.jl:44 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpkvoqiqag.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpkvoqiqag.jl:45\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  ArgumentError: array must be non-empty\n\
    \  Stacktrace:\n   [1] pop!\n     @ ./array.jl:1251 [inlined]\n   [2] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpkvoqiqag.jl:19\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpkvoqiqag.jl:45 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpkvoqiqag.jl:42\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979667
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    counter_list = Int64[]\n    for paren in split(paren_string)\n       \
    \ counter = Int64(0)\n        max_counter = Int64(0)\n        for letter in paren\n\
    \            if letter == '('\n                counter += 1\n            elseif\
    \ letter == ')'\n                counter -= 1\n            end\n            if\
    \ counter > max_counter\n                max_counter = counter\n            end\n\
    \        end\n        push!(counter_list, max_counter)\n    end\n    return counter_list\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979665
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    end\n \n@test parse_nested_parens(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3]\n@test parse_nested_parens(\"(()((())))\") == [4]\n@test parse_nested_parens(\"\
    (())\") == [2]\n@test parse_nested_parens(\"()\") == [1]\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: UndefVarError: @test not defined

    in expression starting at /tmp/tmpsshqn1r_.jl:11

    in expression starting at /tmp/tmpsshqn1r_.jl:11

    '
  stdout: ''
  timestamp: 1659979666
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_array = split(paren_string, \" \")\n    max_levels = []\n    for\
    \ group in paren_array\n        max_lvl = 0\n        for c in group\n        \
    \    if c == '('\n                max_lvl += 1\n            elseif c == ')'\n\
    \                max_lvl -= 1\n            end\n        end\n        push!(max_levels,\
    \ max_lvl)\n    end\n    return max_levels\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpo32_ibta.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmpo32_ibta.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo32_ibta.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo32_ibta.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpo32_ibta.jl:30\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo32_ibta.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo32_ibta.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpo32_ibta.jl:31\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpo32_ibta.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpo32_ibta.jl:28\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979667
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_array = split(paren_string, \" \")\n    return map(x -> _paren_depth(x),\
    \ paren_array)\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt9ux33bm.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpt9ux33bm.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ _paren_depth not defined\n  Stacktrace:\n    [1] (::var\"#1#2\")(x::SubString{String})\n\
    \      @ Main /tmp/tmpt9ux33bm.jl:10\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmpt9ux33bm.jl:10\n    [7] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpt9ux33bm.jl:17 [inlined]\n\
    \    [9] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpt9ux33bm.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpt9ux33bm.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: _paren_depth\
    \ not defined\n  Stacktrace:\n    [1] (::var\"#1#2\")(x::SubString{String})\n\
    \      @ Main /tmp/tmpt9ux33bm.jl:10\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmpt9ux33bm.jl:10\n    [7] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpt9ux33bm.jl:18 [inlined]\n\
    \    [9] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659979667
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # for every group in paren_string\n    res = Int64[]\n    group_cnt =\
    \ 0\n    for group in split(paren_string, \" \")\n        max_depth = 0\n    \
    \    depth = 0\n        for c in group\n            if c == '('\n            \
    \    depth += 1\n            elseif c == ')'\n                depth -= 1\n   \
    \         end\n            if depth > max_depth\n                max_depth = depth\n\
    \            end\n        end\n        push!(res, max_depth)\n    end\n    return\
    \ res\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979665
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Split the string into groups\n    groups = split(paren_string, \" \"\
    )\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpf7vot9dj.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpf7vot9dj.jl:1\n\
    in expression starting at /tmp/tmpf7vot9dj.jl:1\n"
  stdout: ''
  timestamp: 1659979666
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    lst = split(paren_string, \" \")\n    max_levels = Vector{Int64}(undef,\
    \ length(lst))\n    for i in 1:length(lst)\n        max_levels[i] = find_nested_parens(lst[i])\n\
    \    end\n    return max_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpuoh31oab.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmpuoh31oab.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ find_nested_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpuoh31oab.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpuoh31oab.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpuoh31oab.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpuoh31oab.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: find_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpuoh31oab.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpuoh31oab.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpuoh31oab.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpuoh31oab.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: find_nested_parens not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n \
    \    @ Main /tmp/tmpuoh31oab.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpuoh31oab.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpuoh31oab.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979668
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # To solve this problem, I'll use a stack to store all the levels that\
    \ we encounter.\n    stack = Int64[]\n    output = Int64[]\n    for i in 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            push!(stack, 0)\n        elseif\
    \ paren_string[i] == ')'\n            if length(stack) > 0\n                value\
    \ = pop!(stack)\n                push!(output, value)\n                for k in\
    \ 1:length(stack)\n                    stack[k] += 1\n                end\n  \
    \          else\n                push!(output, 0)\n            end\n        end\n\
    \    end\n    return output\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpm690jvg6.jl:31

    '
  stdout: "test set: Test Failed at /tmp/tmpm690jvg6.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 2, 0, 1,\
    \ 2, 0, 0, 1, 0, 0, 4] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpm690jvg6.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpm690jvg6.jl:33\ntest set: Test Failed at /tmp/tmpm690jvg6.jl:35\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [0, 0, 1, 0, 1, 2, 0, 1, 2, 3] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpm690jvg6.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpm690jvg6.jl:33\ntest set: Test Failed at /tmp/tmpm690jvg6.jl:36\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [0, 0, 1, 0,\
    \ 1, 2, 6] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm690jvg6.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm690jvg6.jl:33\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979667
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    depth = 0\n    out = []\n    for p in paren_string\n        if p == '('\n\
    \            depth += 1\n        elseif p == ')'\n            push!(out, depth)\n\
    \            depth -= 1\n        end\n    end\n    return out\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkypguu57.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpkypguu57.jl:26\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkypguu57.jl:26 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkypguu57.jl:25\ntest set: Test Failed at /tmp/tmpkypguu57.jl:27\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkypguu57.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkypguu57.jl:25\ntest set: Test Failed at /tmp/tmpkypguu57.jl:28\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [2, 3, 2, 4,\
    \ 3, 2, 1] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkypguu57.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkypguu57.jl:25\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979668
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string)\n    return [max_paren_depth(group) for group\
    \ in groups]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpsy5mgq5z.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpsy5mgq5z.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_paren_depth not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpsy5mgq5z.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpsy5mgq5z.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpsy5mgq5z.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpsy5mgq5z.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_paren_depth\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpsy5mgq5z.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpsy5mgq5z.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpsy5mgq5z.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpsy5mgq5z.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: max_paren_depth not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n     @ Main\
    \ ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ v"
  timestamp: 1659979669
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    n = length(paren_string)\n    j = 1\n    k = 1\n    result = Vector{Int64}()\n\
    \    while j <= n\n        for i in 1:n\n            if paren_string[i] == '('\n\
    \                k = k + 1\n            elseif paren_string[i] == ')'\n      \
    \          k = k - 1\n            end\n            if k == 0\n               \
    \ push!(result, k)\n                j = i\n                break\n           \
    \ end\n        end\n        j = j + 1\n    end\n    return result\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp4gvd3o0a.jl:32

    '
  stdout: "test set: Test Failed at /tmp/tmp4gvd3o0a.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: Int64[] == [2, 3,\
    \ 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4gvd3o0a.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4gvd3o0a.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp4gvd3o0a.jl:36\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: Int64[] == [1, 2, 3, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4gvd3o0a.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4gvd3o0a.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp4gvd3o0a.jl:37\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp4gvd3o0a.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp4gvd3o0a.jl:34\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979668
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    results = []\n    for g in split(paren_string, \" \")\n        result\
    \ = 0\n        depth = 0\n        for c in g\n            if c == '('\n      \
    \          depth += 1\n            elseif c == ')'\n                depth -= 1\n\
    \            end\n            result = max(result, depth)\n        end\n     \
    \   push!(results, result)\n    end\n    return results\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979666
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    group_string = split(paren_string, \" \") \n    n = length(group_string)\n\
    \    max_nest_level = Vector{Int64}(undef, n)\n    for i in 1:n\n        max_nest_level[i]\
    \ = 0\n        nest_level = 0\n        for j in 1:length(group_string[i])\n  \
    \          if group_string[i][j] == '('\n                nest_level += 1\n   \
    \         elseif group_string[i][j] == ')'\n                nest_level -= 1\n\
    \            end\n            if nest_level > max_nest_level[i]\n            \
    \    max_nest_level[i] = nest_level\n            end\n        end\n    end\n \
    \   return max_nest_level\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979666
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # our outputs will be integers representing the deepest levels of nesting.\n\
    \    # these output levels will be stored in a vector\n    level_vec = Int64[]\n\
    \    # now we will iterate through each element of the string using a for loop\n\
    \    for paren_group in split(paren_string, \" \")\n        # find the length\
    \ of the string. We need to know this for our for loop\n        n = length(paren_group)\n\
    \        # for each element in the string, we need to keep track of how many levels\
    \ of nesting we are at.\n        level = 0\n        # now, our for loop. Remember,\
    \ we need to use `for i in 1:n` to iterate through the string\n        for i in\
    \ 1:n\n            # now we need to check if the i-th letter is a \"(\"\n    \
    \        if paren_group[i] == \"(\"\n                # If it is, we need to increase\
    \ the level by 1\n                level += 1\n            # now we need to check\
    \ if the i-th letter is a \")\"\n            elseif paren_group[i] == \")\"\n\
    \                # If it is, we need to decrease the level by 1\n            \
    \    level -= 1\n            end\n        end\n        # if our level is not zero,\
    \ we will get an error. We need to handle this\n        if level != 0\n      \
    \      # error(\"Our parens are not balanced\")\n            # We can just ignore\
    \ groups with unbalanced parens\n            continue\n        end\n        #\
    \ now we need to find the maximum level\n        max_level = 0\n        # Keep\
    \ track of the level as you iterate\n        level = 0\n        # Now do the same\
    \ for loop as before, but also keep track of the maximum level we see.\n     \
    \   for i in 1:n\n            if paren_group[i] == \"(\"\n                level\
    \ += 1\n                # now we need to check if this is greater than the current\
    \ max level\n                if level > max_level\n                    # if it\
    \ is, update the max level\n                    max_level = level\n          \
    \      end\n            elseif paren_group[i] == \")\"\n                level\
    \ -= 1\n            end\n        end\n        # now we need to add the max level\
    \ to our vector\n        push!(level_\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgjo4b9od.jl:55\nin expression starting at\
    \ /tmp/tmpgjo4b9od.jl:55\n"
  stdout: ''
  timestamp: 1659979667
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    levels = []\n    level = 0\n    for ch in paren_string\n       \
    \ if ch == '('\n            level += 1\n        elseif ch == ')'\n           \
    \ push!(levels, level)\n            level -= 1\n        end\n    end\n    return\
    \ levels\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpje3gvpkf.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpje3gvpkf.jl:27\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpje3gvpkf.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpje3gvpkf.jl:26\ntest set: Test Failed at /tmp/tmpje3gvpkf.jl:28\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpje3gvpkf.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpje3gvpkf.jl:26\ntest set: Test Failed at /tmp/tmpje3gvpkf.jl:29\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [2, 3, 2, 4,\
    \ 3, 2, 1] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpje3gvpkf.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpje3gvpkf.jl:26\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979669
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    nested_parens = split(paren_string, \" \")\n    levels = []\n    for nested_paren\
    \ in nested_parens\n        max_nesting = 0\n        nesting = 0\n        for\
    \ letter in nested_paren\n            if letter == '('\n                nesting\
    \ += 1\n            elseif letter == ')'\n                nesting -= 1\n     \
    \       end\n            if nesting > max_nesting\n                max_nesting\
    \ = nesting\n            end\n        end\n        push!(levels, max_nesting)\n\
    \    end\n    return levels\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979667
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_strings = split(paren_string, \" \")\n    parsed_parens = []\n \
    \   for i in paren_strings\n        parsed_parens = [find_nested_parens(i)]\n\
    \    end\n    return parsed_parens\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpinsdgjp9.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmpinsdgjp9.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ find_nested_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpinsdgjp9.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpinsdgjp9.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpinsdgjp9.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpinsdgjp9.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: find_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpinsdgjp9.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpinsdgjp9.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpinsdgjp9.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpinsdgjp9.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: find_nested_parens not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n \
    \    @ Main /tmp/tmpinsdgjp9.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpinsdgjp9.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpinsdgjp9.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979669
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    group_nested_parens = String[] # create a string array to save the groups\
    \ of parentheses\n    max_nested_parens = Int64[] # create an array to save maximum\
    \ level of nested parens for each group\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpalqd_lvl.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpalqd_lvl.jl:1\n\
    in expression starting at /tmp/tmpalqd_lvl.jl:1\n"
  stdout: ''
  timestamp: 1659979668
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    final_vec = []\n    for paren in split(paren_string, \" \")\n        temp_paren\
    \ = paren\n        level = 0\n        max_level = 0\n        for i in 1:length(temp_paren)\n\
    \            if temp_paren[i] == '('\n                level += 1\n           \
    \ elseif temp_paren[i] == ')'\n                level -= 1\n            end\n \
    \           if level > max_level\n                max_level = level\n        \
    \    end\n        end\n        push!(final_vec, max_level)\n    end\n    return\
    \ final_vec\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979667
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize to appropriate output vector\n    depths = zeros(Int64, length(split(paren_string,\
    \ \" \")))\n    # Iterate through each paren group in the string\n    for (ind,\
    \ paren) in enumerate(split(paren_string, \" \"))\n        # Initialize the stack\n\
    \        stack = []\n        max_depth = 0\n        # Iterate through each character\
    \ in the group\n        for c in paren\n            # If the character is an open\
    \ paren, add it to the stack\n            if c == '('\n                push!(stack,\
    \ '(')\n            # If the character is a close paren, pop a paren off the stack\n\
    \            elseif c == ')'\n                pop!(stack)\n            end\n \
    \           # Update the max depth\n            max_depth = max(max_depth, length(stack))\n\
    \        end\n        # Update the depths\n        depths[ind] = max_depth\n \
    \   end\n    return depths\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979667
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_group = split(paren_string)\n    max_depth = zeros(length(paren_group))\n\
    \    current_depth = 0\n    for (i, paren) in enumerate(paren_group)\n       \
    \ for c in paren\n            if c == '('\n                current_depth += 1\n\
    \            elseif c == ')'\n                current_depth -= 1\n           \
    \ end\n            max_depth[i] = max(max_depth[i], current_depth)\n        end\n\
    \    end\n    return max_depth\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979667
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    groups = split(paren_string,\
    \ \")\")\n    groups = filter(x -> length(x) > 0, groups)\n    num_nest = []\n\
    \    for group in groups\n        open = findfirst(i -> i == '(', group)\n   \
    \     if open != nothing\n            push!(num_nest, open)\n        else\n  \
    \          push!(num_nest, 0)\n        end\n    end\n    return num_nest\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp18jjf6gn.jl:25

    '
  stdout: "test set: Error During Test at /tmp/tmp18jjf6gn.jl:28\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp18jjf6gn.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp18jjf6gn.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp18jjf6gn.jl:27\ntest set:\
    \ Error During Test at /tmp/tmp18jjf6gn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp18jjf6gn.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp18jjf6gn.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/"
  timestamp: 1659979671
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = []\n    results = []\n    for paren in paren_string\n        if\
    \ paren == '('\n            push!(stack, 1)\n        elseif paren == ')'\n   \
    \         push!(stack, -1)\n        elseif paren == ' '\n            results =\
    \ [sum(stack) |> abs |> max]\n            stack = []\n        end\n    end\n \
    \   return results\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmplpu9rbc6.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmplpu9rbc6.jl:28\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0] == [2, 3, 1,\
    \ 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplpu9rbc6.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplpu9rbc6.jl:27\ntest set: Test\
    \ Failed at /tmp/tmplpu9rbc6.jl:29\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0] == [1, 2, 3, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplpu9rbc6.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplpu9rbc6.jl:27\ntest set: Test\
    \ Failed at /tmp/tmplpu9rbc6.jl:30\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmplpu9rbc6.jl:30 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmplpu9rbc6.jl:27\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979669
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    n_groups = length(split(paren_string,\
    \ \"()\"))-1\n    paren_nest_levels = Vector{Int64}(undef, n_groups)\n    start_ind\
    \ = Int64[]\n    end_ind = Int64[]\n    for i in 1:length(paren_string)\n    \
    \    if paren_string[i] == '('\n            push!(start_ind, i)\n        elseif\
    \ paren_string[i] == ')'\n            push!(end_ind, i)\n        end\n    end\n\
    \    ind_str = 1\n    ind_end = 1\n    for i in 1:n_groups\n        count = 0\n\
    \        while ind_end <= length(end_ind) && end_ind[ind_end] < start_ind[ind_str+1]\n\
    \            ind_end += 1\n            count += 1\n        end\n        paren_nest_levels[i]\
    \ = count\n        ind_str += 1\n    end\n    return paren_nest_levels\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp2n158dkj.jl:36

    '
  stdout: "test set: Error During Test at /tmp/tmp2n158dkj.jl:39\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp2n158dkj.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2n158dkj.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2n158dkj.jl:38\ntest set:\
    \ Error During Test at /tmp/tmp2n158dkj.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp2n158dkj.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2n158dkj.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/"
  timestamp: 1659979671
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return [find_nested_parens(x)\
    \ for x in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp4zuvjp_1.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmp4zuvjp_1.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ find_nested_parens not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp4zuvjp_1.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp4zuvjp_1.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp4zuvjp_1.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp4zuvjp_1.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: find_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmp4zuvjp_1.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp4zuvjp_1.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp4zuvjp_1.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp4zuvjp_1.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: find_nested_parens not\
    \ defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n     @\
    \ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\""
  timestamp: 1659979670
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    idx = 1\n    result = []\n    while idx <= length(paren_string)\n    \
    \    if paren_string[idx] == '('\n            close_idx = find_closing_paren(paren_string,\
    \ idx)\n            result = [result; parse_nested_parens(paren_string[idx+1:close_idx-1])]\n\
    \            idx = close_idx\n        elseif paren_string[idx] == ')'\n      \
    \      return result\n        else\n            idx += 1\n        end\n    end\n\
    \    return maximum(result)\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpeumoj6r0.jl:26

    '
  stdout: "test set: Error During Test at /tmp/tmpeumoj6r0.jl:29\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ find_closing_paren not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpeumoj6r0.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeumoj6r0.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeumoj6r0.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpeumoj6r0.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: find_closing_paren\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpeumoj6r0.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeumoj6r0.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeumoj6r0.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpeumoj6r0.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: find_closing_paren not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n \
    \    @ Main /tmp/tmpeumoj6r0.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeumoj6r0.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeumoj6r0.jl:28\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979670
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_parens = 0\n    depth = 0\n    max_depth = 0\n    output = zeros(Int64,\
    \ length(split(paren_string)))\n    for i in 1:length(split(paren_string))\n \
    \       for letter in split(paren_string)[i]\n            if letter == '('\n \
    \               open_parens += 1\n                depth += 1\n               \
    \ if depth > max_depth\n                    max_depth = depth\n              \
    \  end\n            elseif letter == ')'\n                depth -= 1\n       \
    \     end\n        end\n        output[i] = max_depth\n        max_depth = 0\n\
    \        depth = 0\n    end\n    return output\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979668
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    return [get_max_paren_depth(x)\
    \ for x in paren_list]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp6r1z11v1.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmp6r1z11v1.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_max_paren_depth not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp6r1z11v1.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp6r1z11v1.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp6r1z11v1.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp6r1z11v1.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_max_paren_depth\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmp6r1z11v1.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp6r1z11v1.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp6r1z11v1.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp6r1z11v1.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: get_max_paren_depth not\
    \ defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n     @\
    \ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ v"
  timestamp: 1659979671
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_nesting_level = zeros(Int64, length(split(paren_string, \" \")))\n\
    \    for i in 1:length(max_nesting_level)\n        current_nesting_level = 0\n\
    \        for c in split(paren_string, \" \")[i]\n            if c == '('\n   \
    \             current_nesting_level += 1\n            elseif c == ')'\n      \
    \          current_nesting_level -= 1\n            end\n        end\n        max_nesting_level[i]\
    \ = current_nesting_level\n    end\n    return max_nesting_level\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpxjm5dwa2.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpxjm5dwa2.jl:28\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxjm5dwa2.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxjm5dwa2.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpxjm5dwa2.jl:29\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxjm5dwa2.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxjm5dwa2.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpxjm5dwa2.jl:30\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxjm5dwa2.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxjm5dwa2.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979670
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\" to do this we are going to use a stack data structure. There are\
    \ many implementations but we are going to use a Vector.\n    We will push items\
    \ onto the stack and check if the last item on the stack is a matching paranthesis.\
    \ If it is we \n    pop the stack, if it is not we push the new parentheses. We\
    \ will maintain a max variable that will store the deepest\n    level of nesting\
    \ throughout the process.\n    \"\"\"\n    max_level = 0\n    current_level =\
    \ 0\n    levels = Array{Int64}(undef, 0)\n    stack = Array{Char}(undef, 0)\n\
    \    for i in paren_string\n        if i == '('\n            push!(stack, i)\n\
    \            current_level += 1\n            if current_level > max_level\n  \
    \              max_level = current_level\n            end\n        elseif i ==\
    \ ')'\n            if length(stack) == 0\n                push!(levels, 0)\n \
    \               max_level = 0\n                current_level = 0\n           \
    \ else\n                pop!(stack)\n                current_level -= 1\n    \
    \        end\n        elseif i == ' '\n            push!(levels, max_level)\n\
    \            max_level = 0\n            current_level = 0\n        end\n    end\n\
    \    return levels\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpa0nh2p_7.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpa0nh2p_7.jl:47\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 3, 1] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa0nh2p_7.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa0nh2p_7.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpa0nh2p_7.jl:48\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 3] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa0nh2p_7.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa0nh2p_7.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpa0nh2p_7.jl:49\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpa0nh2p_7.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpa0nh2p_7.jl:46\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979670
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_chars = strip(paren_string)\n    paren_indices = findall(x -> x\
    \ == '(' || x == ')', paren_chars)\n    max_nesting = zeros(Int64, length(paren_indices))\n\
    \    current_nesting = 0\n    paren_idx = 1\n    while paren_idx <= length(paren_indices)\n\
    \        if paren_chars[paren_indices[paren_idx]] == '('\n            current_nesting\
    \ += 1\n            max_nesting[paren_idx] = current_nesting\n        else\n \
    \           max_nesting[paren_idx] = current_nesting\n            current_nesting\
    \ -= 1\n        end\n        paren_idx += 1\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpcnrvfjb2.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpcnrvfjb2.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 2, 2, 2, 2,\
    \ 1, 1, 2, 3, 3  \u2026  1, 2, 3, 3, 2, 2, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcnrvfjb2.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcnrvfjb2.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpcnrvfjb2.jl:32\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 1, 1, 2, 2, 1, 1, 2, 3, 3, 2, 1, 1, 2, 3,\
    \ 4, 4, 3, 2, 1] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcnrvfjb2.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcnrvfjb2.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpcnrvfjb2.jl:33\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [1, 2, 2, 2, 3, 3, 2, 2, 3, 4, 4, 3, 2, 1] == [4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcnrvfjb2.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcnrvfjb2.jl:30\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979670
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    result = Vector{Int64}()\n    for i in split(paren_string)\n        maximum\
    \ = 0\n        temp = 0\n        for j in i\n            if j == '('\n       \
    \         temp += 1\n            elseif j == ')'\n                if temp > maximum\n\
    \                    maximum = temp\n                end\n                temp\
    \ -= 1\n            end\n        end\n        push!(result, maximum)\n    end\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979668
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\" Initialize a vector of zero integers to store the number of nested\
    \ parentheses for each group.\n        The maximum level of nesting is the same\
    \ as the number of opening parenthesis.\n    \"\"\"\n    max_level_nesting = zeros(Int64,\
    \ length(paren_string))\n    \"\"\" Initialize a counter for counting the number\
    \ of opening parentheses and the index for storing\n        the max level of nesting\
    \ for the current group.\n    \"\"\"\n    opening_p = 0\n    index = 1\n    \"\
    \"\" Loop through the string and count the number of opening parentheses.\n  \
    \      If current character is a closing parenthesis, make sure that it is not\
    \ the first character in the current group.\n        If it is not the first character,\
    \ decrease the number of opening parentheses by 1 and check whether the number\n\
    \        of opening parentheses so far is larger than the current max level of\
    \ nesting. If so, update the max level of \n        nesting.\n    \"\"\"\n   \
    \ for p in paren_string\n        if p == '('\n            opening_p += 1\n   \
    \     elseif p == ')' && index != 1\n            opening_p -= 1\n            if\
    \ opening_p > max_level_nesting[index]\n                max_level_nesting[index]\
    \ = opening_p\n            end\n        elseif p == ' '\n            index +=\
    \ 1\n        end\n    end\n    return max_level_nesting\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmprpthi2lk.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmprpthi2lk.jl:43\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 5, 3, 5, 0,\
    \ 0, 0, 0, 0, 0  \u2026  0, 0, 0, 0, 0, 0, 0, 0, 0, 0] == [2, 3, 1, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprpthi2lk.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprpthi2lk.jl:42\ntest set: Test\
    \ Failed at /tmp/tmprpthi2lk.jl:44\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 2, 3, 4, 0, 0, 0, 0, 0, 0  \u2026  0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprpthi2lk.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprpthi2lk.jl:42\ntest set: Test Failed at /tmp/tmprpthi2lk.jl:45\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprpthi2lk.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprpthi2lk.jl:42\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979670
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_strings = split(paren_string, \" \")\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpwy4y7hmb.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwy4y7hmb.jl:1\n\
    in expression starting at /tmp/tmpwy4y7hmb.jl:1\n"
  stdout: ''
  timestamp: 1659979669
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_grps = split(paren_string, \" \")\n    depth_of_nesting = zeros(Int64,\
    \ length(paren_grps))\n    for i = 1:length(paren_grps)\n        depth_of_nesting[i]\
    \ = parse_parens(paren_grps[i])\n    end\n    return depth_of_nesting\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp_zg7heu5.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmp_zg7heu5.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp_zg7heu5.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_zg7heu5.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_zg7heu5.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp_zg7heu5.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp_zg7heu5.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_zg7heu5.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_zg7heu5.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp_zg7heu5.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmp_zg7heu5.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_zg7heu5.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_zg7heu5.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979671
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    start_parens = paren_string.count('(')\n    stop_parens = paren_string.count(')')\n\
    \    if start_parens != stop_parens\n        throw(DomainError(\"Input string\
    \ doesn't have the same number of open and closed parentheses.\"))\n    end\n\
    \    result = Int64[]\n    paren_pair = false\n    paren_count = 0\n    for char\
    \ in paren_string\n        if char == '('\n            paren_pair = true\n   \
    \         paren_count += 1\n        elseif char == ')'\n            paren_count\
    \ -= 1\n        elseif char == ' '\n            if paren_pair\n              \
    \  push!(result, paren_count)\n                paren_pair = false\n          \
    \      paren_count = 0\n            end\n        end\n    end\n    if paren_pair\n\
    \        push!(result, paren_count)\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmplw8vvigx.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmplw8vvigx.jl:41\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  type\
    \ String has no field count\n  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42\
    \ [inlined]\n   [2] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmplw8vvigx.jl:9\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmplw8vvigx.jl:41 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmplw8vvigx.jl:40\ntest set:\
    \ Error During Test at /tmp/tmplw8vvigx.jl:42\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  type String has no\
    \ field count\n  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n\
    \   [2] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmplw8vvigx.jl:9\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmplw8vvigx.jl:42 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmplw8vvigx.jl:40\ntest set:\
    \ Error During Test at /tmp/tmplw8vvigx.jl:43\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  type String has no field count\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmplw8vvigx.jl:9\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmplw8vvigx.jl:43 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmplw8vvigx.jl:40\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979671
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = []\n    max_stack = []\n    for c in paren_string\n        if\
    \ c == '('\n            push!(stack, c)\n        elseif c == ')'\n           \
    \ pop!(stack)\n        end\n        if length(stack) > length(max_stack)\n   \
    \         max_stack = stack\n        end\n    end\n    [length(max_stack) for\
    \ _ in eachindex(paren_string) if paren_string[i] == ' ']\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpm3iw00gs.jl:25

    '
  stdout: "test set: Error During Test at /tmp/tmpm3iw00gs.jl:28\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ i not defined\n  Stacktrace:\n    [1] (::var\"#2#4\"{String})(#unused#::Int64)\n\
    \      @ Main ./none:0\n    [2] iterate(::Base.Iterators.Filter{var\"#2#4\"{String},\
    \ Base.EachStringIndex{String}})\n      @ Base.Iterators ./iterators.jl:447\n\
    \    [3] iterate\n      @ ./generator.jl:44 [inlined]\n    [4] grow_to!(dest::Vector{Any},\
    \ itr::Base.Generator{Base.Iterators.Filter{var\"#2#4\"{String}, Base.EachStringIndex{String}},\
    \ var\"#1#3\"})\n      @ Base ./array.jl:797\n    [5] collect\n      @ ./array.jl:721\
    \ [inlined]\n    [6] parse_nested_parens(paren_string::String)\n      @ Main /tmp/tmpm3iw00gs.jl:21\n\
    \    [7] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpm3iw00gs.jl:28 [inlined]\n\
    \    [9] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpm3iw00gs.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpm3iw00gs.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: i not\
    \ defined\n  Stacktrace:\n    [1] (::var\"#2#4\"{String})(#unused#::Int64)\n \
    \     @ Main ./none:0\n    [2] iterate(::Base.Iterators.Filter{var\"#2#4\"{String},\
    \ Base.EachStringIndex{String}})\n      @ Base.Iterators ./iterators.jl:447\n\
    \    [3] iterate\n      @ ./generator.jl:44 [inlined]\n    [4] grow_to!(dest::Vector{Any},\
    \ itr::Base.Generator{Base.Iterators.Filter{var\"#2#4\"{String}, Base.EachStringIndex{String}},\
    \ var\"#1#3\"})\n      @ Base ./array.jl:797\n    [5] collect\n      @ ./array.jl:721\
    \ [inlined]\n    [6] parse_nested_parens(paren_string::String)\n      @ Main /tmp/tmpm3iw00gs.jl:21\n\
    \    [7] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpm3iw00gs.jl:29 [inlined]\n\
    \    [9] macro expansion\n      @ ~/.con"
  timestamp: 1659979671
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    depth_array = zeros(Int64,1) \n    max_nesting = 0 \n    index = 1\n \
    \   for paren in paren_string \n        if paren == '(' \n            max_nesting\
    \ += 1 \n            depth_array[index] = max_nesting \n        elseif paren ==\
    \ ')'\n            max_nesting -= 1 \n            depth_array[index] = max_nesting\
    \ \n        elseif paren == ' '\n            index += 1 \n            depth_array\
    \ = push!(depth_array, 0) \n        end\n    end\n    depth_array\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpm6t1er9n.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpm6t1er9n.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm6t1er9n.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm6t1er9n.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpm6t1er9n.jl:32\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm6t1er9n.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm6t1er9n.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpm6t1er9n.jl:33\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm6t1er9n.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm6t1er9n.jl:30\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979670
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    first_char = paren_string[1]\n    current_depth = 1\n    max_depth = 1\n\
    \    depth_group = Vector{Int64}(1)\n    depth_group[1] = max_depth\n    i = 2\n\
    \    while i < length(paren_string)\n        if paren_string[i] == ' '\n     \
    \       push!(depth_group, max_depth)\n            max_depth = 1\n           \
    \ current_depth = 1\n        elseif paren_string[i] == first_char\n          \
    \  current_depth += 1\n            if current_depth > max_depth\n            \
    \    max_depth = current_depth\n            end\n        elseif paren_string[i]\
    \ == opposite_paren(first_char)\n            current_depth -= 1\n        end\n\
    \        i += 1\n    end\n    return depth_group\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpullt8dnf.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmpullt8dnf.jl:37\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at ~/.conda/envs/polyglot/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at ~/.conda/envs/polyglot/share/julia/base/bitarray.jl:494\n\
    \    Vector{T}(!Matched::Core.Compiler.AbstractRange{T}) where T at ~/.conda/envs/polyglot/share/julia/base/range.jl:1286\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpullt8dnf.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpullt8dnf.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpullt8dnf.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpullt8dnf.jl:38\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at ~/.conda/envs/polyglot/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at ~/.conda/envs/polyglot/share/julia/base/bitarray.jl:494\n\
    \    Vector{T}(!Matched::Core.Compiler.AbstractRange{T}) where T at ~/.conda/envs/polyglot/share/julia/base/range.jl:1286\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpullt8dnf.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpullt8dnf.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpullt8dnf.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpullt8dnf.jl:39\n  Test t"
  timestamp: 1659979672
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # create an empty list\n    parsed_parens = Int64[]\n    # for each group\n\
    \    for group in split(paren_string)\n        # create a counter to store the\
    \ maximum nested level \n        max_level = 0\n        # create a counter to\
    \ store the current nested level \n        current_level = 0\n        # for each\
    \ character in the group\n        for c in group\n            # if it is an opening\
    \ paren\n            if c == '('\n                # increase the current level\n\
    \                current_level += 1\n                # if the current level is\
    \ greater than the max level\n                if current_level > max_level\n \
    \                   # set the max level to the current level\n               \
    \     max_level = current_level\n                end\n            # if it is a\
    \ closing paren\n            elseif c == ')'\n                # decrease the current\
    \ level\n                current_level -= 1\n            end\n        end\n  \
    \      # add the max level to the list\n        push!(parsed_parens, max_level)\n\
    \    end\n    # return the list\n    return parsed_parens\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979669
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    depths = []\n    for paren\
    \ in paren_list\n        depth = 0\n        for c in paren\n            if c ==\
    \ '('\n                depth += 1\n            elseif c == ')'\n             \
    \   depth -= 1\n            end\n        end\n        push!(depths, depth)\n \
    \   end\n    return depths\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp12qk_6zr.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmp12qk_6zr.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp12qk_6zr.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp12qk_6zr.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp12qk_6zr.jl:30\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp12qk_6zr.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp12qk_6zr.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp12qk_6zr.jl:31\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp12qk_6zr.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp12qk_6zr.jl:28\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979671
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    n_parens = length(paren_string)\n    depths = zeros(Int64, n_parens)\n\
    \    depth = 0\n    for (i, paren) in enumerate(paren_string)\n        if paren\
    \ == '('\n            depth += 1\n        elseif paren == ')'\n            depth\
    \ -= 1\n        end\n        depths[i] = depth\n    end\n    return depths\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpatxrzxz3.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpatxrzxz3.jl:27\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 2, 1, 2, 1,\
    \ 0, 0, 1, 2, 3  \u2026  1, 2, 3, 2, 1, 2, 1, 2, 1, 0] == [2, 3, 1, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpatxrzxz3.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpatxrzxz3.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpatxrzxz3.jl:28\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 0, 0, 1, 2, 1, 0, 0, 1, 2  \u2026  0, 0,\
    \ 1, 2, 3, 4, 3, 2, 1, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpatxrzxz3.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpatxrzxz3.jl:26\ntest set: Test Failed at /tmp/tmpatxrzxz3.jl:29\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [1, 2, 1, 2,\
    \ 3, 2, 1, 2, 3, 4, 3, 2, 1, 0] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpatxrzxz3.jl:29 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpatxrzxz3.jl:26\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979671
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_idx = findall(x -> x == '(', paren_string)\n    closed_idx = findall(x\
    \ -> x == ')', paren_string)\n    open_idx = parse_idx(open_idx)\n    closed_idx\
    \ = parse_idx(closed_idx)\n    max_depth = zeros(Int64, length(open_idx))\n  \
    \  for i in eachindex(open_idx)\n        max_depth[i] = abs(open_idx[i] - closed_idx[i])\n\
    \    end\n    return max_depth\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpb_qq5qic.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpb_qq5qic.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_idx not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpb_qq5qic.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpb_qq5qic.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpb_qq5qic.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpb_qq5qic.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_idx\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpb_qq5qic.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpb_qq5qic.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpb_qq5qic.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpb_qq5qic.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_idx not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpb_qq5qic.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpb_qq5qic.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpb_qq5qic.jl:23\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979672
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    n = length(paren_list)\n\
    \    max_nesting = zeros(Int64, n)\n    for (i, paren) in enumerate(paren_list)\n\
    \        max_nesting[i] = sum(paren .== \"(\") - sum(paren .== \")\")\n    end\n\
    \    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpfz9lmt4w.jl:19

    '
  stdout: "test set: Test Failed at /tmp/tmpfz9lmt4w.jl:22\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfz9lmt4w.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfz9lmt4w.jl:21\ntest set: Test\
    \ Failed at /tmp/tmpfz9lmt4w.jl:23\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfz9lmt4w.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfz9lmt4w.jl:21\ntest set: Test\
    \ Failed at /tmp/tmpfz9lmt4w.jl:24\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfz9lmt4w.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfz9lmt4w.jl:21\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979671
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    levels = Vector{Int64}()\n    level = 0\n    for c in paren_string\n \
    \       if c == '('\n            level += 1\n        elseif c == ')'\n       \
    \     level -= 1\n        elseif c == ' '\n            push!(levels, level)\n\
    \            level = 0\n        end\n    end\n    if level != 0\n        error(\"\
    Malformed string\")\n    end\n    return levels\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbo6j1e2s.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpbo6j1e2s.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbo6j1e2s.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbo6j1e2s.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpbo6j1e2s.jl:32\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbo6j1e2s.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbo6j1e2s.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpbo6j1e2s.jl:33\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbo6j1e2s.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbo6j1e2s.jl:30\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979671
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    output = Vector{Int64}(length(paren_string))\n\
    \    for i in 1:length(paren_string)\n        parse_nested_parens_helper(paren_string[i],\
    \ 0, output, i)\n    end\n    return output\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp5l_x5goq.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmp5l_x5goq.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp5l_x5goq.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5l_x5goq.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5l_x5goq.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp5l_x5goq.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp5l_x5goq.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5l_x5goq.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/"
  timestamp: 1659979673
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_arr = split(paren_string, \" \")\n    paren_count = []\n    for\
    \ paren_group in paren_arr\n        curr_count = 0\n        max_count = 0\n  \
    \      for paren in paren_group\n            if paren == '('\n               \
    \ curr_count += 1\n            elseif paren == ')'\n                curr_count\
    \ -= 1\n            end\n            if curr_count > max_count\n             \
    \   max_count = curr_count\n            end\n        end\n        push!(paren_count,\
    \ max_count)\n    end\n    return paren_count\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979670
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    stack = Int[]\n    max_depth = Int[]\n    current_depth = 0\n  \
    \  \n    for paren in paren_string\n        if paren == '('\n            push!(stack,\
    \ paren)\n            current_depth += 1\n        elseif paren == ')'\n      \
    \      pop!(stack)\n            current_depth -= 1\n        end\n        \n  \
    \      if current_depth > length(max_depth)\n            push!(max_depth, current_depth)\n\
    \        end\n    end\n    return max_depth\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmppl166fou.jl:31

    '
  stdout: "test set: Test Failed at /tmp/tmppl166fou.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 2, 3] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppl166fou.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppl166fou.jl:33\ntest set: Test\
    \ Failed at /tmp/tmppl166fou.jl:36\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [1, 2, 3, 4] == [4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppl166fou.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmppl166fou.jl:33\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    1     2      3\n"
  timestamp: 1659979672
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    parse_nested_parens(s) = map(x -> _nest_count(x), split(s, \" \"))\n \
    \   parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    # TODO: implement\
    \ this!\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp5v750k2t.jl:15

    '
  stdout: "test set: Error During Test at /tmp/tmp5v750k2t.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ _nest_count not defined\n  Stacktrace:\n    [1] (::var\"#1#3\")(x::SubString{String})\n\
    \      @ Main /tmp/tmp5v750k2t.jl:9\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#3\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens\n\
    \      @ /tmp/tmp5v750k2t.jl:9 [inlined]\n    [7] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmp5v750k2t.jl:10\n    [8] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [9] macro expansion\n      @ /tmp/tmp5v750k2t.jl:18 [inlined]\n\
    \   [10] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [11] top-level scope\n      @ /tmp/tmp5v750k2t.jl:17\ntest set:\
    \ Error During Test at /tmp/tmp5v750k2t.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: _nest_count\
    \ not defined\n  Stacktrace:\n    [1] (::var\"#1#3\")(x::SubString{String})\n\
    \      @ Main /tmp/tmp5v750k2t.jl:9\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#3\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens\n\
    \      @ /tmp/tmp5v750k2t.jl:9 [inlined]\n    [7] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmp5v750k2t.jl:10\n    [8] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [9] macro expansion\n     "
  timestamp: 1659979673
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_arr = split(paren_string, \" \")\n    return [parse_nested_parens_helper(x)\
    \ for x in paren_arr]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpw2390hvt.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpw2390hvt.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] (::var\"#1#2\"\
    )(x::SubString{String})\n     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47\
    \ [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"\
    #1#2\"})\n     @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpw2390hvt.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpw2390hvt.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpw2390hvt.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpw2390hvt.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmpw2390hvt.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpw2390hvt.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpw2390hvt.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpw2390hvt.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{"
  timestamp: 1659979673
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    n = length(paren_string)\n    stack = Int64[]\n    counter = 0\n    max_level\
    \ = 0\n    open_bracket = \"(\"\n    close_bracket = \")\"\n    result = Int64[]\n\
    \    for i in 1:n\n        c = paren_string[i]\n        if c == open_bracket\n\
    \            counter += 1\n            push!(stack, counter)\n        elseif c\
    \ == close_bracket\n            max_level = max(max_level, counter)\n        \
    \    counter -= 1\n            pop!(stack)\n        elseif c == \" \"\n      \
    \      if !isempty(stack)\n                push!(result, max_level)\n        \
    \    end\n            max_level = 0\n        end\n    end\n    if !isempty(stack)\n\
    \        push!(result, max_level)\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpugb5rpfz.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmpugb5rpfz.jl:42\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: Int64[] == [2, 3,\
    \ 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpugb5rpfz.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpugb5rpfz.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpugb5rpfz.jl:43\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: Int64[] == [1, 2, 3, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpugb5rpfz.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpugb5rpfz.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpugb5rpfz.jl:44\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpugb5rpfz.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpugb5rpfz.jl:41\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979673
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Base cases:\n    if paren_string == \"\"\n        return Int64[]\n \
    \   end\n    if length(paren_string) == 1\n        error(\"String is not valid,\
    \ only one character given\")\n    end\n    if paren_string[1] != '('\n      \
    \  error(\"String is not valid, first character is not (\")\n    end\n    if paren_string[end]\
    \ != ')'\n        error(\"String is not valid, last character is not )\")\n  \
    \  end\n    \n    paren_levels = [0]\n    start_ind = 1\n    end_ind = length(paren_string)\n\
    \    max_level = 0\n    level = 0\n    for i in 1:length(paren_string)\n     \
    \   if paren_string[i] == '('\n            level += 1\n            if level >\
    \ max_level\n                max_level = level\n            end\n        elseif\
    \ paren_string[i] == ')'\n            level -= 1\n        end\n    end\n    level\
    \ = 0\n    if max_level > 1\n        while end_ind > start_ind\n            #\
    \ Left Paren\n            level += 1\n            if level == max_level - 1\n\
    \                start_ind = end_ind + 1\n                end_ind = length(paren_string)\n\
    \                level = 0\n            end\n            # Right Paren\n     \
    \       level -= 1\n            if level == 0\n                push!(paren_levels,\
    \ max_level)\n                end_ind -= 1\n            end\n        end\n   \
    \ end\n    push!(paren_levels, 1)\n    return paren_levels\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp6na4dk0h.jl:61

    '
  stdout: "test set: Test Failed at /tmp/tmp6na4dk0h.jl:64\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3  \u2026  3, 3, 3, 3, 3, 3, 3, 3, 3, 1] == [2, 3, 1, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6na4dk0h.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6na4dk0h.jl:63\ntest set: Test\
    \ Failed at /tmp/tmp6na4dk0h.jl:65\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 4, 4, 4, 4, 4, 4, 4, 4, 4  \u2026  4, 4,\
    \ 4, 4, 4, 4, 4, 4, 4, 1] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6na4dk0h.jl:65 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6na4dk0h.jl:63\ntest set: Test Failed at /tmp/tmp6na4dk0h.jl:66\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [0, 4, 4, 4,\
    \ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1] == [4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6na4dk0h.jl:66 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6na4dk0h.jl:63\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979673
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    levels = Vector{Int64}()\n    current_level = 0\n    \n    for token\
    \ in split(paren_string)\n        if token == \"(\"\n            current_level\
    \ += 1\n        elseif token == \")\"\n            push!(levels, current_level)\n\
    \            current_level -= 1\n        end\n    end\n    return levels\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpneimvon1.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpneimvon1.jl:28\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: Int64[] == [2, 3,\
    \ 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpneimvon1.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpneimvon1.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpneimvon1.jl:29\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: Int64[] == [1, 2, 3, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpneimvon1.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpneimvon1.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpneimvon1.jl:30\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpneimvon1.jl:30 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpneimvon1.jl:27\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979673
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    # For each nested parentheses\
    \ group, iterate through and count the nesting levels\n    # of the parens\n \
    \   num_nested_parens = []\n    for paren_group in paren_groups\n        level\
    \ = 0\n        max_level = 0\n        for paren in paren_group\n            if\
    \ paren == '('\n                level += 1\n            elseif paren == ')'\n\
    \                level -= 1\n            end\n            max_level = max(max_level,\
    \ level)\n        end\n        push!(num_nested_parens, max_level)\n    end\n\
    \    return num_nested_parens\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979671
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    # Vector of max number of nested parentheses in each group\n   \
    \ max_nested_parens = Vector{Int64}()\n    \n    # For each of the parenthesis\
    \ groups in the input string\n    for i in split(paren_string, \" \")\n      \
    \  # Initialize a stack to keep track of ( and )\n        stack = []\n       \
    \ # Initialize counter and max counter of each individual parenthesis group\n\
    \        counter = 0\n        max_counter = 0\n        \n        # For each of\
    \ the parentheses in i\n        for char in i\n            # If we encounter an\
    \ opening parentheses, push that value to the stack and increase counter by 1\n\
    \            if char == '('\n                push!(stack, char)\n            \
    \    counter += 1\n            # If we encounter a closing parentheses, pop the\
    \ last value of the stack and decrease counter by 1\n            elseif char ==\
    \ ')'\n                pop!(stack)\n                counter -= 1\n           \
    \ end\n            \n            # Check if current counter is greater than max\
    \ counter\n            if counter > max_counter\n                # If so, update\
    \ max counter to current counter\n                max_counter = counter\n    \
    \        end\n        end\n        \n        # Once we finish iterating through\
    \ each of the parentheses in i, push max counter to max_nested_parens vector\n\
    \        push!(max_nested_parens, max_counter)\n    end\n    \n    # Return the\
    \ vector of max number of nested parentheses in each group\n    return max_nested_parens\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979671
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize output vector\n    levels = zeros(Int64, length(split(paren_string)))\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2kprrux3.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2kprrux3.jl:1\n\
    in expression starting at /tmp/tmp2kprrux3.jl:1\n"
  stdout: ''
  timestamp: 1659979672
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    if paren_string == \"\"\n        return Vector{Int64}([])\n    end\n \
    \   paren_groups = split(paren_string, \" \")\n    # First, we need to remove\
    \ the outer parentheses in each string\n    nested_parens = map(s -> s[2:end-1],\
    \ paren_groups)\n    # Now we will find the maximum depth of nested parentheses\n\
    \    # Here we use the insight that a nested parenthesis only adds to the depth\
    \ when we see an open parenthesis\n    # and subtracts to the depth when we see\
    \ a close parenthesis.\n    # This way, we don't need to keep track of what pair\
    \ we are nesting in.\n    max_depth = map(s -> maximum(cumsum(parse.(Int64, s))),\
    \ nested_parens)\n    return max_depth\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpn0_9vlgr.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmpn0_9vlgr.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  ArgumentError:\
    \ invalid base 10 digit '(' in \"()()\"\n  Stacktrace:\n    [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::SubString{String}, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n\
    \      @ Base ./parse.jl:137\n    [2] parse(::Type{Int64}, s::SubString{String};\
    \ base::Nothing)\n      @ Base ./parse.jl:241\n    [3] parse\n      @ ./parse.jl:241\
    \ [inlined]\n    [4] _broadcast_getindex_evalf\n      @ ./broadcast.jl:670 [inlined]\n\
    \    [5] _broadcast_getindex\n      @ ./broadcast.jl:653 [inlined]\n    [6] getindex\n\
    \      @ ./broadcast.jl:597 [inlined]\n    [7] copy\n      @ ./broadcast.jl:875\
    \ [inlined]\n    [8] materialize\n      @ ./broadcast.jl:860 [inlined]\n    [9]\
    \ #2\n      @ /tmp/tmpn0_9vlgr.jl:19 [inlined]\n   [10] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n   [11] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#2#4\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n   [12] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \   [13] map\n      @ ./abstractarray.jl:2867 [inlined]\n   [14] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmpn0_9vlgr.jl:19\n   [15] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [16] macro expansion\n      @ /tmp/tmpn0_9vlgr.jl:27 [inlined]\n\
    \   [17] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [18] top-level scope\n      @ /tmp/tmpn0_9vlgr.jl:26\ntest set:\
    \ Error During Test at /tmp/tmpn0_9vlgr.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  ArgumentError: input\
    \ string is empty or only contains whitespace\n  Stacktrace:\n    [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::SubString{String}, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n\
    \      @ Base ./parse.jl:109\n    [2] parse(::Type{Int6"
  timestamp: 1659979674
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    paren_list = split(paren_string, \" \")\n    max_nesting = []\n\
    \    \n    for s in paren_list\n        count = 0\n        max_nest = 0\n    \
    \    for i in 1:length(s)\n            if s[i] == '('\n                count +=\
    \ 1\n            elseif s[i] == ')'\n                count -= 1\n            end\n\
    \            if count > max_nest\n                max_nest = count\n         \
    \   end\n        end\n        push!(max_nesting, max_nest)\n    end\n    \n  \
    \  return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979671
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # initialize an output vector\n    level = Int64[]\n    # initialize a\
    \ group of parentheses\n    group = String[]\n    # initialize temporary variable\
    \ to calculate the level\n    t_level = 0\n    # initialize a group flag\n   \
    \ group_flag = false\n    # loop over each character of the string\n    for i\
    \ = 1:length(paren_string)\n        if paren_string[i] == '('\n            push!(group,\
    \ paren_string[i])\n            t_level += 1\n            group_flag = true\n\
    \        elseif paren_string[i] == ')'\n            push!(group, paren_string[i])\n\
    \            t_level -= 1\n        elseif paren_string[i] == ' ' && group_flag\n\
    \            group_flag = false\n            push!(level, t_level)\n         \
    \   t_level = 0\n            group = String[]\n        end\n    end\n    # if\
    \ the level remains unchanged, we need to process the last group of parentheses\n\
    \    if t_level != 0\n        push!(level, t_level)\n    end\n    return level\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpqdgcythm.jl:41

    '
  stdout: "test set: Error During Test at /tmp/tmpqdgcythm.jl:44\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Char to an object of type String\n  Closest\
    \ candidates are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{String}, item::Char)\n     @ Base\
    \ ./array.jl:994\n   [2] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpqdgcythm.jl:20\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpqdgcythm.jl:44 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpqdgcythm.jl:43\ntest set:\
    \ Error During Test at /tmp/tmpqdgcythm.jl:45\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: Cannot\
    \ `convert` an object of type Char to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{String}, item::Char)\n     @ Base\
    \ ./array.jl:994\n   [2] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpqdgcythm.jl:20\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] "
  timestamp: 1659979675
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_depth = 0\n    max_depth_vec = Vector{Int64}(undef, 0)\n    for i\
    \ in 1:length(paren_string)\n        if paren_string[i] == '('\n            max_depth\
    \ += 1\n        elseif paren_string[i] == ')'\n            push!(max_depth_vec,\
    \ max_depth)\n            max_depth -= 1\n        end\n    end\n    return max_depth_vec\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp33hu58r1.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmp33hu58r1.jl:26\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp33hu58r1.jl:26 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp33hu58r1.jl:25\ntest set: Test Failed at /tmp/tmp33hu58r1.jl:27\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp33hu58r1.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp33hu58r1.jl:25\ntest set: Test Failed at /tmp/tmp33hu58r1.jl:28\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [2, 3, 2, 4,\
    \ 3, 2, 1] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp33hu58r1.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp33hu58r1.jl:25\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979674
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    n_groups = length(groups)\n \
    \   result = Vector{Int64}(undef, n_groups)\n    for i = 1:n_groups\n        group\
    \ = groups[i]\n        depth = 0\n        max_depth = 0\n        for c in group\n\
    \            if c == '('\n                depth += 1\n            elseif c ==\
    \ ')'\n                depth -= 1\n            end\n            max_depth = max(max_depth,\
    \ depth)\n        end\n        result[i] = max_depth\n    end\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979671
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_stack = []\n    curr_max = 0\n    result = []\n    for char in paren_string\n\
    \        if char == '('\n            # update maximum nesting depth\n        \
    \    push!(paren_stack,char)\n            curr_max = max(curr_max, length(paren_stack))\n\
    \        elseif char == ')'\n            pop!(paren_stack)\n        elseif char\
    \ == ' '\n            push!(result, curr_max)\n            curr_max = 0\n    \
    \    end\n    end\n    push!(result, curr_max)\n    return result\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979671
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_parens = 0\n    max_open_parens = 0\n    output = zeros(Int64, 0)\n\
    \    curr_index = 1\n    while curr_index <= length(paren_string)\n        curr_char\
    \ = paren_string[curr_index]\n        if curr_char == '('\n            open_parens\
    \ += 1\n            if open_parens > max_open_parens\n                max_open_parens\
    \ = open_parens\n            end\n        elseif curr_char == ')'\n          \
    \  open_parens -= 1\n        else\n            # it is a space\n            push!(output,\
    \ max_open_parens)\n            max_open_parens = 0\n            open_parens =\
    \ 0\n        end\n        curr_index += 1\n    end\n    push!(output, max_open_parens)\n\
    \    return output\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979671
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    paren_list = [parse_nested_parens_helper(paren_group)\
    \ for paren_group in paren_list]\n    return paren_list\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpslm1thpq.jl:15

    '
  stdout: "test set: Error During Test at /tmp/tmpslm1thpq.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] (::var\"#1#2\"\
    )(paren_group::SubString{String})\n     @ Main ./none:0\n   [2] iterate\n    \
    \ @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"})\n     @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpslm1thpq.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpslm1thpq.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpslm1thpq.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpslm1thpq.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(paren_group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpslm1thpq.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpslm1thpq.jl:19 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpslm1thpq.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpslm1thpq.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(paren_group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] colle"
  timestamp: 1659979675
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string)\n    N = length(paren_groups)\n   \
    \ paren_levels = zeros(Int64, N)\n    for i = 1:N\n        current_level = 0\n\
    \        paren_list = string(paren_groups[i])\n        for j = 1:length(paren_list)\n\
    \            if paren_list[j] == '('\n                current_level += 1\n   \
    \         elseif paren_list[j] == ')'\n                current_level -= 1\n  \
    \          end\n            paren_levels[i] = max(paren_levels[i], current_level)\n\
    \        end\n    end\n    return paren_levels\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979672
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    str_arr = split(paren_string, \" \")\n    count_arr = Vector{Int64}()\n\
    \    for i = 1:length(str_arr)\n        paren_count = 0\n        max_paren_count\
    \ = 0\n        for c in str_arr[i]\n            if c == '('\n                paren_count\
    \ += 1\n            elseif c == ')'\n                paren_count -= 1\n      \
    \      end\n            if paren_count > max_paren_count\n                max_paren_count\
    \ = paren_count\n            end\n        end\n        push!(count_arr, max_paren_count)\n\
    \    end\n    return count_arr\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979672
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_parens = 0\n    max_open_parens = 0\n    paren_string = filter(x\
    \ -> x !=' ', paren_string)\n    depths = Int64[]\n    for i in 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            open_parens += 1\n           \
    \ max_open_parens = max(max_open_parens, open_parens)\n        elseif paren_string[i]\
    \ == ')'\n            open_parens -= 1\n            if open_parens == 0\n    \
    \            push!(depths, max_open_parens)\n                max_open_parens =\
    \ 0\n            end\n        end\n    end\n    return depths\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979672
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_levels = Int64[]\n    paren_split = split(paren_string, \" \")\n \
    \   for paren in paren_split\n        level = 0\n        max_level = 0\n     \
    \   for c in paren\n            if c == '('\n                level += 1\n    \
    \        elseif c == ')'\n                level -= 1\n            end\n      \
    \      if level > max_level\n                max_level = level\n            end\n\
    \        end\n        push!(max_levels, max_level)\n    end\n    return max_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979672
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    result = Int64[]\n    paren_stack = Char[]\n    for c in paren_string\n\
    \        if c in \"()\"\n            push!(paren_stack, c)\n        end\n    end\n\
    \    balanced_paren_stack = Char[]\n    for c in paren_stack\n        if c ==\
    \ '('\n            push!(balanced_paren_stack, c)\n        elseif c == ')'\n \
    \           pop!(balanced_paren_stack)\n        end\n    end\n    n = length(balanced_paren_stack)\n\
    \    if n > 0\n        println(\"WARNING: Unbalanced parentheses\")\n    end\n\
    \    push!(result, n)\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp_etg3xji.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmp_etg3xji.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0] == [2, 3, 1,\
    \ 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_etg3xji.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_etg3xji.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp_etg3xji.jl:37\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0] == [1, 2, 3, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_etg3xji.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_etg3xji.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp_etg3xji.jl:38\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_etg3xji.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_etg3xji.jl:35\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979674
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    return map(paren_groups)\
    \ do gp\n        pos_count, neg_count = 0, 0\n        max_count = 0\n        for\
    \ s in gp\n            if s == '('\n                pos_count += 1\n         \
    \   elseif s == ')'\n                neg_count += 1\n            end\n       \
    \     if pos_count < neg_count\n                return -1\n            end\n \
    \           max_count = max(max_count, pos_count - neg_count)\n        end\n \
    \       if pos_count != neg_count\n            return -1\n        end\n      \
    \  return max_count\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979672
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_depth = 0\n    max_depth_vec = []\n    max_depth_vec = []\n    depth\
    \ = 0\n    for i in 1:length(paren_string)\n        ch = paren_string[i]\n   \
    \     if ch == '('\n            depth += 1\n        elseif ch == ')'\n       \
    \     depth -= 1\n        end\n        if depth > max_depth\n            max_depth\
    \ = depth\n        end\n        if ch == ' '\n            push!(max_depth_vec,\
    \ max_depth)\n            max_depth = 0\n        end\n    end\n    push!(max_depth_vec,\
    \ max_depth)\n    return max_depth_vec\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979672
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    max_depth = 0\n    max_depth_start = 0\n    max_depth_end = 0\n    start_idx\
    \ = 0\n    end_idx = 0\n    counts = zeros(length(paren_string))\n    i = 1\n\
    \    for c in paren_string\n        if c == '('\n            counts[i] = counts[i-1]\
    \ + 1\n        elseif c == ')'\n            counts[i] = counts[i-1] - 1\n    \
    \    else\n            counts[i] = counts[i-1]\n        end\n        if counts[i]\
    \ > max_depth\n            max_depth = counts[i]\n            max_depth_start\
    \ = i\n        end\n        if counts[i] == max_depth_start - 1\n            max_depth_end\
    \ = i\n        end\n        i += 1\n    end\n    println(paren_string)\n    println(max_depth)\n\
    \    println(max_depth_start)\n    println(max_depth_end)\n    println(counts)\n\
    \    return counts\nend\nparse_nested_parens(\"(()()) ((())) () ((())()())\")\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: BoundsError: attempt to access 27-element Vector{Float64}\
    \ at index [0]\nStacktrace:\n [1] getindex\n   @ ./array.jl:861 [inlined]\n [2]\
    \ parse_nested_parens(paren_string::String)\n   @ Main /tmp/tmp64663ckq.jl:18\n\
    \ [3] top-level scope\n   @ /tmp/tmp64663ckq.jl:40\nin expression starting at\
    \ /tmp/tmp64663ckq.jl:40\n"
  stdout: ''
  timestamp: 1659979675
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # assign the nested depth level to be 0 and a open bracket count to be\
    \ 1\n    depth_level = 0\n    count = 1\n    # create a new array of nested_depth\
    \ to store the maximum depth level for each element\n    nested_depth = Array{Int64}(undef,\
    \ length(paren_string))\n    i = 1\n    # iterate through every character in the\
    \ given paren_string\n    for c = paren_string\n        # add 1 to count each\
    \ time you see a '('\n        if c == '('\n            count += 1\n        # subract\
    \ 1 from count each time you see a ')'\n        elseif c == ')'\n            count\
    \ -= 1\n        end\n        # if count is bigger than the current depth level,\
    \ change the current depth level to be the new count\n        if count > depth_level\n\
    \            depth_level = count\n        end\n        # change the value of nested_depth[i]\
    \ to be the depth level to store the max depth level for this group\n        nested_depth[i]\
    \ = depth_level\n        # increase i by 1\n        i += 1\n    end\n    # return\
    \ the nested_depth which store the max depth level for each group\n    return\
    \ nested_depth\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp4d532o5x.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmp4d532o5x.jl:41\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 4  \u2026  4, 4, 4, 4, 4, 4, 4, 4, 4, 4] == [2, 3, 1, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4d532o5x.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4d532o5x.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp4d532o5x.jl:42\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [2, 2, 2, 2, 3, 3, 3, 3, 3, 3  \u2026  4, 4,\
    \ 4, 4, 4, 5, 5, 5, 5, 5] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp4d532o5x.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp4d532o5x.jl:40\ntest set: Test Failed at /tmp/tmp4d532o5x.jl:43\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [2, 3, 3, 3,\
    \ 4, 4, 4, 4, 4, 5, 5, 5, 5, 5] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp4d532o5x.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp4d532o5x.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979674
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_blocks = split(paren_string)\n    paren_counts = Vector{Int64}(undef,\
    \ length(paren_blocks))\n    for i in 1:length(paren_blocks)\n        current_count\
    \ = 0\n        current_max = 0\n        for j in 1:length(paren_blocks[i])\n \
    \           if paren_blocks[i][j] == '('\n                current_count += 1\n\
    \                if current_count > current_max\n                    current_max\
    \ = current_count\n                end\n            elseif paren_blocks[i][j]\
    \ == ')'\n                current_count -= 1\n            end\n        end\n \
    \       paren_counts[i] = current_max\n    end\n    return paren_counts\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979672
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    l = length(paren_string)\n    current_level = Int64[]\n    max_levels\
    \ = Int64[]\n    for i in 1:l\n        current_paren = paren_string[i]\n     \
    \   if current_paren == '('\n            push!(current_level, 1)\n        elseif\
    \ current_paren == ')'\n            if !isempty(current_level)\n             \
    \   push!(max_levels, pop!(current_level))\n            else\n               \
    \ push!(max_levels, 0)\n            end\n        end\n    end\n    return max_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpirhhk5ce.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpirhhk5ce.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpirhhk5ce.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpirhhk5ce.jl:30\ntest set: Test Failed at /tmp/tmpirhhk5ce.jl:32\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpirhhk5ce.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpirhhk5ce.jl:30\ntest set: Test Failed at /tmp/tmpirhhk5ce.jl:33\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [1, 1, 1, 1,\
    \ 1, 1, 1] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpirhhk5ce.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpirhhk5ce.jl:30\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979675
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_vector = split(paren_string)\n    max_levels = Vector{Int64}()\n\
    \    for group in paren_vector\n        open_count = 0\n        max_level = 0\n\
    \        for char in group\n            if char == '('\n                open_count\
    \ += 1\n                if open_count > max_level\n                    max_level\
    \ = open_count\n                end\n            elseif char == ')'\n        \
    \        open_count -= 1\n            end\n        end\n        push!(max_levels,\
    \ max_level)\n    end\n    return max_levels\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979673
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    str_vec = split(paren_string, \" \")\n    paren_vec = []\n    for str\
    \ in str_vec\n        level = 0\n        for ch in str\n            if ch == '('\n\
    \                level += 1\n            elseif ch == ')'\n                level\
    \ -= 1\n            end\n        end\n        push!(paren_vec, level)\n    end\n\
    \    return paren_vec\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpsx3ttk0y.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmpsx3ttk0y.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsx3ttk0y.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsx3ttk0y.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpsx3ttk0y.jl:30\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsx3ttk0y.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsx3ttk0y.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpsx3ttk0y.jl:31\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsx3ttk0y.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsx3ttk0y.jl:28\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979675
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_parens_stack = []\n    nesting_levels = []\n    for ch in paren_string\n\
    \        if ch == '('\n            push!(open_parens_stack, ch)\n        elseif\
    \ ch == ')'\n            isempty(open_parens_stack) && continue\n            pop!(open_parens_stack)\n\
    \        elseif ch == ' '\n            if isempty(open_parens_stack)\n       \
    \         push!(nesting_levels, 0)\n            else\n                push!(nesting_levels,\
    \ length(open_parens_stack))\n            end\n        end\n    end\n    return\
    \ nesting_levels\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpjzncvkqd.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpjzncvkqd.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjzncvkqd.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjzncvkqd.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpjzncvkqd.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjzncvkqd.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjzncvkqd.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpjzncvkqd.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpjzncvkqd.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpjzncvkqd.jl:31\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979675
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_arr = split(paren_string, \" \")\n    levels = [0]\n    level =\
    \ 0\n    for group in paren_arr\n        for char in group\n            if char\
    \ == '('\n                level += 1\n            elseif char == ')'\n       \
    \         level -= 1\n            end\n        end\n        push!(levels, level)\n\
    \        level = 0\n    end\n    return levels[2:end]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mbten4c.jl:27

    '
  stdout: "test set: Test Failed at /tmp/tmp3mbten4c.jl:30\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mbten4c.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mbten4c.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp3mbten4c.jl:31\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mbten4c.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mbten4c.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp3mbten4c.jl:32\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mbten4c.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mbten4c.jl:29\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979675
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    n = length(paren_string)\n\
    \    depth_vec = zeros(Int64, n)\n    paren_stack = Stack{Char}()\n    for i in\
    \ 1:n\n        c = paren_string[i]\n        if c == '('\n            push!(paren_stack,\
    \ c)\n        elseif c == ')'\n            pop!(paren_stack)\n        end\n  \
    \      depth_vec[i] = length(paren_stack)\n    end\n    return depth_vec\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp96as2q7n.jl:26

    '
  stdout: "test set: Error During Test at /tmp/tmp96as2q7n.jl:29\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp96as2q7n.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp96as2q7n.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp96as2q7n.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp96as2q7n.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp96as2q7n.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp96as2q7n.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/"
  timestamp: 1659979676
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_count = Vector{Int64}(undef, length(split(paren_string, \" \")))\n\
    \    for (index, paren_group) in enumerate(split(paren_string, \" \"))\n     \
    \   paren_count[index] = parse_nested_parens_indiv(paren_group)\n    end\n   \
    \ return paren_count\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpga9k_1nj.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmpga9k_1nj.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_indiv not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpga9k_1nj.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpga9k_1nj.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpga9k_1nj.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpga9k_1nj.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_indiv\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpga9k_1nj.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpga9k_1nj.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpga9k_1nj.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpga9k_1nj.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_indiv\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpga9k_1nj.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpga9k_1nj.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpga9k_1nj.jl:19\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979676
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Replace all the whitespaces with \"|\"\n    paren_string = replace(paren_string,\
    \ r\"\\s+\" => \"|\")\n    # Split the string based on \"|\" to get the various\
    \ groups for nested parentheses\n    groups = split(paren_string, \"|\")\n   \
    \ # Initialize maximum nesting level as 0.\n    max_nest_level = 0\n    # Initialize\
    \ current level of nesting as 0.\n    current_nest_level = 0\n    # Initialize\
    \ a vector to hold the maximum level of nesting for each group.\n    vec = Vector{Int64}()\n\
    \    # Loop through the groups\n    for group in groups\n        # Loop through\
    \ the characters in each group\n        for character in group\n            #\
    \ If the character is '(' then increment the current level of nesting by 1.\n\
    \            if character == '('\n                current_nest_level += 1\n  \
    \          elseif character == ')'\n                # Else if the character is\
    \ ')' then decrement the current level of nesting by 1.\n                current_nest_level\
    \ -= 1\n            end\n            # Update the maximum level of nesting if\
    \ current level is greater than max.\n            if current_nest_level > max_nest_level\n\
    \                max_nest_level = current_nest_level\n            end\n      \
    \  end\n        # At the end of each group append the maximum level of nesting\
    \ to the vector.\n        push!(vec, max_nest_level)\n        # Reset the current\
    \ level of nesting for the next group.\n        current_nest_level = 0\n     \
    \   # Reset the maximum level of nesting for the next group.\n        max_nest_level\
    \ = 0\n    end\n    # Return the vector.\n    return vec\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979673
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # your code here\nend\n \n# test\n@test parse_nested_parens(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3]\n@test parse_nested_parens(\"( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )\"\
    ) == [24]\n \n \n \n\"\"\" When working with lots of text data, it is helpful\
    \ to look at the distribution of words in the text.\n    Here, we'll use a histogram\
    \ to describe the distribution of words.\n    We have a text and a dictionary\
    \ of stop words. Stop words are words that we do not want to include in our histogram.\n\
    \    Please write a function that takes this text and stop words, and returns\
    \ a histogram, which is a Dictionary{String,Int64},\n    mapping a word to the\
    \ count of its occurrence in the text.\n    Please ignore the case of a word (use\
    \ only lower-case) and ignore punctuation.\n    Please do not use any external\
    \ libraries to implement the histogram.\n \n    >>> histogram(\"It is the east\
    \ and Juliet is the sun.\", [\"is\", \"the\", \"and\"])\n    Dict(\"it\" => 1,\
    \ \"east\" => 1, \"juliet\" => 1, \"sun\" => 1)\n \n    >>> histogram(\"The sky\
    \ has given over \\n the stony rage that she \\n had when I first \\n looked up\
    \ lying on the grass \\n and the first star I \\n saw and the fact that I \\n\
    \ thought of tree-lined streets \\n dooryards and driveways \\n where children\
    \ buckled \\n in their car seats travel \\n home.  The sky goes black, \\n blank,\
    \ and the fields open \\n deep and brown.\", [\"i\", \"and\", \"that\", \"first\"\
    , \"sky\", \"looked\", \"had\", \"up\", \"black\", \"has\", \"travel\", \"been\"\
    , \"opened\", \"goes\", \"blank\", \"deep\", \"grass\", \"brown\", \"when\", \"\
    open\", \"stony\", \"the\", \"star\", \"home\", \"fields\", \"so\", \"you\", \"\
    streets\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t\
    @test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: UndefVarError: @test not defined

    in expression starting at /tmp/tmp0dnwz4py.jl:13

    in expression starting at /tmp/tmp0dnwz4py.jl:13

    '
  stdout: ''
  timestamp: 1659979674
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_depth = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, group) in enumerate(paren_groups)\n     \
    \   curr_depth = 0\n        max_depth[i] = 0\n        for paren in group\n   \
    \         if paren == '('\n                curr_depth += 1\n            elseif\
    \ paren == ')'\n                curr_depth -= 1\n            end\n           \
    \ max_depth[i] = max(max_depth[i], curr_depth)\n        end\n    end\n    return\
    \ max_depth\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979673
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    max_nesting = Int64[]\n \
    \   for paren in paren_list\n        level = 0\n        max_level = 0\n      \
    \  for character in paren\n            if character == '('\n                level\
    \ += 1\n            elseif character == ')'\n                level -= 1\n    \
    \        end\n            if level > max_level\n                max_level = level\n\
    \            end\n        end\n        push!(max_nesting, max_level)\n    end\n\
    \    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979673
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to hold the nested depths of all groups\n    depths\
    \ = []\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpfv763u9x.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpfv763u9x.jl:1\n\
    in expression starting at /tmp/tmpfv763u9x.jl:1\n"
  stdout: ''
  timestamp: 1659979674
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    for group in groups\n       \
    \ print(group)\n    end\n    return groups\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpra9cb3hj.jl:17

    '
  stdout: "(()())((()))()((())()())test set: Error During Test at /tmp/tmpra9cb3hj.jl:20\n\
    \  Test threw exception\n  Expression: candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3]\n  MethodError: Cannot `convert` an object of type SubString{String}\
    \ to an object of type Int64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::Ptr) where T<:Integer at ~/.conda/envs/polyglot/share/julia/base/pointer.jl:23\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n\
    \    convert(::Type{T}, !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n\
    \    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{Int64}, x::SubString{String},\
    \ i1::Int64)\n      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{Int64},\
    \ doffs::Int64, src::Vector{SubString{String}}, soffs::Int64, n::Int64)\n    \
    \  @ Base ./array.jl:253\n    [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n\
    \    [4] _copyto_impl!\n      @ ./array.jl:331 [inlined]\n    [5] copyto!\n  \
    \    @ ./array.jl:317 [inlined]\n    [6] copyto!\n      @ ./array.jl:343 [inlined]\n\
    \    [7] copyto_axcheck!\n      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{Int64}(x::Vector{SubString{String}})\n\
    \      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n\
    \   [10] parse_nested_parens(paren_string::String)\n      @ Main /tmp/tmpra9cb3hj.jl:13\n\
    \   [11] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [12] macro expansion\n      @ /tmp/tmpra9cb3hj.jl:20 [inlined]\n\
    \   [13] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [14] top-level scope\n      @ /tmp/tmpra9cb3hj.jl:19\n()(())((()))(((())))test\
    \ set: Error During Test at /tmp/tmpra9cb3hj.jl:21\n  Test threw exception\n \
    \ Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError:\
    \ Cannot `convert` an object of type SubString{String} to an object of type Int64\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::Ptr) where T<"
  timestamp: 1659979678
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    depths = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, group) in enumerate(paren_groups)\n     \
    \   depth = 0\n        max_depth = 0\n        for c in group\n            if c\
    \ == '('\n                depth += 1\n            elseif c == ')'\n          \
    \      depth -= 1\n            end\n            max_depth = max(max_depth, depth)\n\
    \        end\n        depths[i] = max_depth\n    end\n    return depths\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979674
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    level_vec = Vector{Int64}()\n    start_paren_count = 0\n    end_paren_count\
    \ = 0\n    num_levels = 0\n    for i = 1:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            start_paren_count += 1\n            if start_paren_count\
    \ > end_paren_count\n                num_levels += 1\n            end\n      \
    \  elseif paren_string[i] == ')'\n            end_paren_count += 1\n        elseif\
    \ paren_string[i] == ' '\n            if start_paren_count == end_paren_count\n\
    \                # Append num_levels for each group to level_vec\n           \
    \     push!(level_vec, num_levels)\n                num_levels = 0\n         \
    \       start_paren_count = 0\n                end_paren_count = 0\n         \
    \   end\n        end\n    end\n    return level_vec\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpocq_v5ys.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmpocq_v5ys.jl:38\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [3, 3, 1] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpocq_v5ys.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpocq_v5ys.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpocq_v5ys.jl:39\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 3] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpocq_v5ys.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpocq_v5ys.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpocq_v5ys.jl:40\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpocq_v5ys.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpocq_v5ys.jl:37\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979676
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Split the string on space to get each group\n    groups = split(paren_string,\
    \ \" \")\n    # To store the maximum level of nesting for each group\n    nesting_levels\
    \ = Vector{Int64}(undef, length(groups))\n    # For each group, find the maximum\
    \ level of nesting\n    for i in 1:length(groups)\n        # current level of\
    \ nesting is 0\n        level = 0\n        # To store the maximum level of nesting\n\
    \        max_level = 0\n        # Iterate over all the characters in the group\n\
    \        for char in groups[i]\n            # If the character is '(' then increase\
    \ the level by 1\n            if char == '('\n                level += 1\n   \
    \         # If the character is ')' then decrease the level by 1\n           \
    \ elseif char == ')'\n                level -= 1\n            end\n          \
    \  # If the level is greater than max_level, update the max_level\n          \
    \  if level > max_level\n                max_level = level\n            end\n\
    \        end\n        # Store the max_level for the current group in the output\
    \ vector\n        nesting_levels[i] = max_level\n    end\n    # Return the vector\
    \ of maximum levels of nesting for each group\n    return nesting_levels\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979674
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    levels = split(paren_string, \" \")\n    level_counts = []\n    for level\
    \ in levels\n        level_count = 0\n        curr_nesting = 0\n        for paren\
    \ in level\n            if paren == '('\n                curr_nesting += 1\n \
    \           elseif paren == ')'\n                curr_nesting -= 1\n         \
    \   end\n            if curr_nesting > level_count\n                level_count\
    \ = curr_nesting\n            end\n        end\n        push!(level_counts, level_count)\n\
    \    end\n    return level_counts\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979674
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    strlist = split(paren_string, \" \")\n    output_list = zeros(length(strlist))\n\
    \    for i = 1:length(strlist)\n        output_list[i] = _parse_nested_parens(strlist[i])\n\
    \    end\n    return output_list\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp8f1uqw4z.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmp8f1uqw4z.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ _parse_nested_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp8f1uqw4z.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8f1uqw4z.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8f1uqw4z.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp8f1uqw4z.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: _parse_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp8f1uqw4z.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8f1uqw4z.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8f1uqw4z.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp8f1uqw4z.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: _parse_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp8f1uqw4z.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8f1uqw4z.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8f1uqw4z.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979677
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_stack = Int64[]\n    nested_parens = Int64[]\n    for paren in paren_string\n\
    \        if paren == '('\n            push!(paren_stack, 1)\n        elseif paren\
    \ == ')'\n            push!(nested_parens, length(paren_stack))\n            pop!(paren_stack)\n\
    \        end\n    end\n    return nested_parens\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpc9ncdviv.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpc9ncdviv.jl:26\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpc9ncdviv.jl:26 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpc9ncdviv.jl:25\ntest set: Test Failed at /tmp/tmpc9ncdviv.jl:27\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpc9ncdviv.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpc9ncdviv.jl:25\ntest set: Test Failed at /tmp/tmpc9ncdviv.jl:28\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [2, 3, 2, 4,\
    \ 3, 2, 1] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc9ncdviv.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc9ncdviv.jl:25\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979676
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    to_return = []\n    for s in split(paren_string, \" \")\n        num_open_parens\
    \ = 0\n        max_num_open_parens = 0\n        for c in s\n            if c ==\
    \ '('\n                num_open_parens += 1\n                if num_open_parens\
    \ > max_num_open_parens\n                    max_num_open_parens = num_open_parens\n\
    \                end\n            elseif c == ')'\n                num_open_parens\
    \ -= 1\n            end\n        end\n        push!(to_return, max_num_open_parens)\n\
    \    end\n    return to_return\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979674
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Split to get the groups\n    groups = split(paren_string, \" \")\n \
    \   return [deepest_nesting(x) for x in groups]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpoce7tx9s.jl:15

    '
  stdout: "test set: Error During Test at /tmp/tmpoce7tx9s.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ deepest_nesting not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpoce7tx9s.jl:11\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpoce7tx9s.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpoce7tx9s.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpoce7tx9s.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: deepest_nesting\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmpoce7tx9s.jl:11\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpoce7tx9s.jl:19 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpoce7tx9s.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpoce7tx9s.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: deepest_nesting not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"})\n "
  timestamp: 1659979677
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    result = []\n    groups = split(paren_string, \" \")\n    for group in\
    \ groups\n        max_level = 0\n        level = 0\n        for c in group\n \
    \           if c == '('\n                level += 1\n            elseif c == ')'\n\
    \                level -= 1\n            end\n            if level > max_level\n\
    \                max_level = level\n            end\n        end\n        push!(result,\
    \ max_level)\n    end\n    return result\nend\n \nparse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n \nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979675
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string)\n    parse_list = [parse_parens(s) for\
    \ s in paren_list]\n    return parse_list\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmplm5ltizt.jl:15

    '
  stdout: "test set: Error During Test at /tmp/tmplm5ltizt.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(s::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmplm5ltizt.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmplm5ltizt.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmplm5ltizt.jl:17\ntest set:\
    \ Error During Test at /tmp/tmplm5ltizt.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(s::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmplm5ltizt.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmplm5ltizt.jl:19 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmplm5ltizt.jl:17\ntest set:\
    \ Error During Test at /tmp/tmplm5ltizt.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(s::SubString{String})\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"})\n     @ Bas"
  timestamp: 1659979677
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_counts = []\n    for paren_group in split(paren_string, \" \")\n\
    \        open_count = 0\n        max_open_count = 0\n        for paren in paren_group\n\
    \            if paren == '('\n                open_count += 1\n              \
    \  max_open_count = max(max_open_count, open_count)\n            elseif paren\
    \ == ')'\n                open_count -= 1\n            end\n        end\n    \
    \    push!(open_counts, max_open_count)\n    end\n    return open_counts\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979675
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    lvl = 0\n    lvls = []\n    for p in paren_string\n        if p == '('\n\
    \            lvl += 1\n        elseif p == ')'\n            lvl -= 1\n       \
    \ elseif p == ' '\n            push!(lvls, lvl)\n        end\n    end\n    return\
    \ lvls\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpoov_dxaz.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpoov_dxaz.jl:27\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpoov_dxaz.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpoov_dxaz.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpoov_dxaz.jl:28\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpoov_dxaz.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpoov_dxaz.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpoov_dxaz.jl:29\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpoov_dxaz.jl:29 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpoov_dxaz.jl:26\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979677
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    nest_levels = Vector{Int64}()\n    count = 0\n    for paren in paren_string\n\
    \        if paren == '('\n            count += 1\n        elseif paren == ')'\n\
    \            push!(nest_levels, count)\n            count = 0\n        end\n \
    \   end\n    return nest_levels\nend\nparse_nested_parens(\"(()()) ((())) () ((())()())\"\
    )\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2xlkdphs.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmp2xlkdphs.jl:27\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 1, 0, 3, 0,\
    \ 0, 1, 3, 0, 1, 1, 0] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2xlkdphs.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2xlkdphs.jl:26\ntest set: Test Failed at /tmp/tmp2xlkdphs.jl:28\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [1, 2, 0, 3, 0, 0, 4, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2xlkdphs.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2xlkdphs.jl:26\ntest set: Test Failed at /tmp/tmp2xlkdphs.jl:29\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [2, 2, 0, 3,\
    \ 0, 0, 0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2xlkdphs.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2xlkdphs.jl:26\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979677
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Maintain a stack to store the opening parenthesis for any\n    # open\
    \ groups of parentheses.\n    stack = Stack{Int64}()\n    # Output will be a vector\
    \ of maximum depth of nesting\n    # for each group of parenthesis.\n    max_depth\
    \ = zeros(Int64, count(paren_string, ' ') + 1)\n    group_index = 1\n    group_depth\
    \ = 0\n    for c in paren_string\n        if c == '('\n            push!(stack,\
    \ c)\n            group_depth += 1\n        elseif c == ')'\n            pop!(stack)\n\
    \            group_depth -= 1\n        elseif c == ' '\n            max_depth[group_index]\
    \ = group_depth\n            group_index += 1\n            group_depth = 0\n \
    \       end\n    end\n    max_depth[group_index] = group_depth\n    return max_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp2v8sp70a.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmp2v8sp70a.jl:38\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ Stack not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp2v8sp70a.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2v8sp70a.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2v8sp70a.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp2v8sp70a.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: Stack\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp2v8sp70a.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2v8sp70a.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2v8sp70a.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp2v8sp70a.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: Stack not defined\n \
    \ Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmp2v8sp70a.jl:11\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2v8sp70a.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2v8sp70a.jl:37\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979677
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    i = 1\n    max_depth = 0\n    depths = []\n    while i <= length(paren_string)\n\
    \        letter = paren_string[i]\n        if letter == '('\n            max_depth\
    \ += 1\n        elseif letter == ')'\n            depths = vcat(depths, max_depth)\n\
    \            max_depth -= 1\n        end\n        i += 1\n    end\n    return\
    \ depths\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpblzjk5ou.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmpblzjk5ou.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpblzjk5ou.jl:29 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpblzjk5ou.jl:28\ntest set: Test Failed at /tmp/tmpblzjk5ou.jl:30\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n   Evaluated:\
    \ [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpblzjk5ou.jl:30 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpblzjk5ou.jl:28\ntest set: Test Failed at /tmp/tmpblzjk5ou.jl:31\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [2, 3, 2, 4,\
    \ 3, 2, 1] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpblzjk5ou.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpblzjk5ou.jl:28\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979677
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_array = split(paren_string, \" \")\n    output = Int64[]\n    for\
    \ paren in paren_array\n        count = 0\n        max_count = 0\n        for\
    \ char in paren\n            if char == '('\n                count += 1\n    \
    \        elseif char == ')'\n                if count > max_count\n          \
    \          max_count = count\n                end\n                count -= 1\n\
    \            end\n        end\n        push!(output, max_count)\n    end\n   \
    \ return output\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979675
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = []\n    result = []\n    for c in paren_string\n        if c ==\
    \ '('\n            push!(stack, c)\n        elseif c == ')'\n            if isempty(stack)\n\
    \                push!(result, 0)\n            else\n                depth = 0\n\
    \                while peek(stack) == '('\n                    pop!(stack)\n \
    \                   depth += 1\n                end\n                push!(result,\
    \ depth)\n            end\n        end\n    end\n    return result\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp8l21lhvr.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmp8l21lhvr.jl:34\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching peek(::Vector{Any}, ::Type{UInt8})\n  Closest candidates\
    \ are:\n    peek(!Matched::Base.Iterators.Stateful, ::Any) at ~/.conda/envs/polyglot/share/julia/base/iterators.jl:1330\n\
    \    peek(!Matched::Base.GenericIOBuffer, ::Type{UInt8}) at ~/.conda/envs/polyglot/share/julia/base/iobuffer.jl:224\n\
    \    peek(!Matched::Base.LibuvStream, ::Type{T}) where T at ~/.conda/envs/polyglot/share/julia/base/stream.jl:1395\n\
    \    ...\n  Stacktrace:\n   [1] peek(s::Vector{Any})\n     @ Base ./io.jl:267\n\
    \   [2] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmp8l21lhvr.jl:19\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp8l21lhvr.jl:34 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp8l21lhvr.jl:33\ntest set:\
    \ Error During Test at /tmp/tmp8l21lhvr.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching peek(::Vector{Any}, ::Type{UInt8})\n  Closest candidates are:\n   \
    \ peek(!Matched::Base.Iterators.Stateful, ::Any) at ~/.conda/envs/polyglot/share/julia/base/iterators.jl:1330\n\
    \    peek(!Matched::Base.GenericIOBuffer, ::Type{UInt8}) at ~/.conda/envs/polyglot/share/julia/base/iobuffer.jl:224\n\
    \    peek(!Matched::Base.LibuvStream, ::Type{T}) where T at ~/.conda/envs/polyglot/share/julia/base/stream.jl:1395\n\
    \    ...\n  Stacktrace:\n   [1] peek(s::Vector{Any})\n     @ Base ./io.jl:267\n\
    \   [2] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmp8l21lhvr.jl:19\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp8l21lhvr.jl:35 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia"
  timestamp: 1659979679
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    return map(c -> parse_nested_parens_1(c), split(paren_string, \" \"))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpbikjv_e4.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpbikjv_e4.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_1 not defined\n  Stacktrace:\n    [1] (::var\"#1#2\")(c::SubString{String})\n\
    \      @ Main /tmp/tmpbikjv_e4.jl:9\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmpbikjv_e4.jl:9\n    [7] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpbikjv_e4.jl:16 [inlined]\n\
    \    [9] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpbikjv_e4.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpbikjv_e4.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_1\
    \ not defined\n  Stacktrace:\n    [1] (::var\"#1#2\")(c::SubString{String})\n\
    \      @ Main /tmp/tmpbikjv_e4.jl:9\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmpbikjv_e4.jl:9\n    [7] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpbikjv_e4.jl:17 [inlined]\n\
    \    [9] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659979678
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    n_groups = length(groups)\n \
    \   deepest_levels = zeros(Int64, n_groups)\n    for i in 1:n_groups\n       \
    \ group = groups[i]\n        max_deep = 0\n        current_deep = 0\n        for\
    \ paren in group\n            if paren == '('\n                current_deep +=\
    \ 1\n            elseif paren == ')'\n                if current_deep > max_deep\n\
    \                    max_deep = current_deep\n                end\n          \
    \      current_deep -= 1\n            end\n        end\n        deepest_levels[i]\
    \ = max_deep\n    end\n    return deepest_levels\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979675
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    return [count_nesting(s) for s in split(paren_string, \" \")]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpw5cbu86e.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpw5cbu86e.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_nesting not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(s::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpw5cbu86e.jl:9\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpw5cbu86e.jl:16 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpw5cbu86e.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpw5cbu86e.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_nesting\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(s::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmpw5cbu86e.jl:9\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpw5cbu86e.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpw5cbu86e.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpw5cbu86e.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_nesting not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(s::SubString{String})\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"})\n     @ Ba"
  timestamp: 1659979678
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_depth = zeros(Int64, length(split(paren_string)))\n    counter =\
    \ 0\n    for (i, g) in enumerate(split(paren_string))\n        if g == \"(\"\n\
    \            counter += 1\n        elseif g == \")\"\n            counter -= 1\n\
    \        end\n        paren_depth[i] = counter\n    end\n    return paren_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpu3d2ionn.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpu3d2ionn.jl:26\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu3d2ionn.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu3d2ionn.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpu3d2ionn.jl:27\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu3d2ionn.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu3d2ionn.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpu3d2ionn.jl:28\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu3d2ionn.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu3d2ionn.jl:25\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979678
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, ' ' => '')\n    group_nums = findall(r\"\
    \\(+\\)+\", paren_string)\n    max_levels = [Int(length(findall(r\"\\(\", i))/2)\
    \ for i in group_nums]\n    return max_levels\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid empty character literal\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp45ogx587.jl:9\nin expression starting at /tmp/tmp45ogx587.jl:9\n"
  stdout: ''
  timestamp: 1659979677
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    return [find_max_level(x)\
    \ for x in paren_list]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpzgnq48jt.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpzgnq48jt.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ find_max_level not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpzgnq48jt.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpzgnq48jt.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpzgnq48jt.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpzgnq48jt.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: find_max_level\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmpzgnq48jt.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpzgnq48jt.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpzgnq48jt.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpzgnq48jt.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: find_max_level not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"})\n    "
  timestamp: 1659979678
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open = 0\n    max_depth = 0\n    max_depth_list = Vector{Int64}()\n  \
    \  for p in paren_string\n        if p == '('\n            open += 1\n       \
    \     if open > max_depth\n                max_depth = open\n            end\n\
    \        elseif p == ')'\n            open -= 1\n        elseif p == ' '\n   \
    \         push!(max_depth_list, max_depth)\n            max_depth = 0\n      \
    \  end\n    end\n    max_depth_list\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp1g8ocmra.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmp1g8ocmra.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 3, 1] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1g8ocmra.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1g8ocmra.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp1g8ocmra.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 3] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1g8ocmra.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1g8ocmra.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp1g8ocmra.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1g8ocmra.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp1g8ocmra.jl:31\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979678
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \n    # Store the indices and levels of the parentheses\n    ind::Vector{Int64}\
    \ = []\n    lev::Vector{Int64} = []\n    \n    # Iterate over each string of parentheses\n\
    \    for paren_group in split(paren_string, \" \")\n        \n        # Initialize\
    \ variables\n        max_lev = 0\n        cur_lev = 0\n        \n        # Iterate\
    \ over the characters of the string\n        for i in 1:length(paren_group)\n\
    \            \n            # Increment the level if we find a ( and decrement\
    \ if we find a )\n            if paren_group[i] == '('\n                cur_lev\
    \ += 1\n            elseif paren_group[i] == ')'\n                cur_lev -= 1\n\
    \            end\n            \n            # Update the current maximum level\n\
    \            if cur_lev > max_lev\n                max_lev = cur_lev\n       \
    \     end\n        end\n        \n        # Append the maximum level to the vector\
    \ of max levels\n        push!(lev, max_lev)\n    end\n    \n    # Return the\
    \ vector of max levels\n    return lev\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979676
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Using a stack to track all parentheses in string,\n    # and another\
    \ vector to track the nesting level for each parens\n    paren_stack = [] # Vector{Char}()\n\
    \    paren_level = [] # Vector{Int64}()\n    result = [] # Vector{Int64}()\n \
    \   for char_idx in 1:length(paren_string)\n        c = paren_string[char_idx]\n\
    \        if c == '('\n            push!(paren_stack, c)\n            push!(paren_level,\
    \ 1)\n        elseif c == ')'\n            if length(paren_stack) > 0\n      \
    \          # Remove the most recent \"(\" from the stack and add one to level\n\
    \                # of the current \")\"\n                pop!(paren_stack)\n \
    \               paren_level[end] += 1\n            else\n                # Current\
    \ \")\" matches no \"(\" in the stack\n                # This is considered as\
    \ an invalid input to this function\n                println(\"Invalid input string:\
    \ \", paren_string)\n                return []\n            end\n        elseif\
    \ c == ' '\n            # If the most recent paren is \")\", push it to the result\n\
    \            if length(paren_stack) == 0\n                push!(result, paren_level[end])\n\
    \                pop!(paren_level)\n            end\n        else\n          \
    \  # This is considered as an invalid input to this function\n            println(\"\
    Invalid input string: \", paren_string)\n            return []\n        end\n\
    \    end\n    # Handle the last part of the string that is not separated by space\n\
    \    if length(paren_stack) == 0\n        push!(result, paren_level[end])\n  \
    \  else\n        println(\"Invalid input string: \", paren_string)\n        return\
    \ []\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpd_7l229m.jl:54

    '
  stdout: "test set: Test Failed at /tmp/tmpd_7l229m.jl:57\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [3, 4, 2, 3] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd_7l229m.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd_7l229m.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpd_7l229m.jl:58\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [2, 3, 4, 5] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd_7l229m.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd_7l229m.jl:56\ntest set: Test\
    \ Failed at /tmp/tmpd_7l229m.jl:59\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [5] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd_7l229m.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd_7l229m.jl:56\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979678
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_vec = map(x -> length(x), split(paren_string, \" \"))\n    return\
    \ paren_vec\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3kzt153k.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmp3kzt153k.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [6, 6, 2, 10] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3kzt153k.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3kzt153k.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp3kzt153k.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [2, 4, 6, 8] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3kzt153k.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3kzt153k.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp3kzt153k.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [14] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3kzt153k.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3kzt153k.jl:16\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979678
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    depths = [count_depth(x) for\
    \ x in groups]\n    return depths\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpdi3m7xqi.jl:15

    '
  stdout: "test set: Error During Test at /tmp/tmpdi3m7xqi.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_depth not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpdi3m7xqi.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpdi3m7xqi.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpdi3m7xqi.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpdi3m7xqi.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_depth\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n \
    \    @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3]\
    \ collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n     @\
    \ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n    \
    \ @ Main /tmp/tmpdi3m7xqi.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpdi3m7xqi.jl:19 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpdi3m7xqi.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpdi3m7xqi.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_depth not defined\n\
    \  Stacktrace:\n   [1] (::var\"#1#2\")(x::SubString{String})\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"})\n     @ Base ."
  timestamp: 1659979679
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    count_levels(p) = maximum(cumsum(map(d -> 1 - 2*(d == ')'), p)))\n   \
    \ return map(count_levels, split(paren_string, \" \"))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmptjq8eig4.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmptjq8eig4.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  ArgumentError:\
    \ map(f, s::AbstractString) requires f to return AbstractChar; try map(f, collect(s))\
    \ or a comprehension instead\n  Stacktrace:\n    [1] map(f::var\"#1#3\", s::SubString{String})\n\
    \      @ Base ./strings/basic.jl:611\n    [2] (::var\"#count_levels#2\")(p::SubString{String})\n\
    \      @ Main /tmp/tmptjq8eig4.jl:9\n    [3] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [4] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#count_levels#2\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n\
    \      @ Base ./array.jl:744\n    [5] collect_similar\n      @ ./array.jl:653\
    \ [inlined]\n    [6] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [7] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmptjq8eig4.jl:10\n    [8] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [9] macro expansion\n      @ /tmp/tmptjq8eig4.jl:17 [inlined]\n\
    \   [10] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [11] top-level scope\n      @ /tmp/tmptjq8eig4.jl:16\ntest set:\
    \ Error During Test at /tmp/tmptjq8eig4.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  ArgumentError: map(f,\
    \ s::AbstractString) requires f to return AbstractChar; try map(f, collect(s))\
    \ or a comprehension instead\n  Stacktrace:\n    [1] map(f::var\"#1#3\", s::SubString{String})\n\
    \      @ Base ./strings/basic.jl:611\n    [2] (::var\"#count_levels#2\")(p::SubString{String})\n\
    \      @ Main /tmp/tmptjq8eig4.jl:9\n    [3] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [4] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#count_levels#2\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n\
    \      @ Base ./array.jl:744\n    [5] collect_similar\n      @ ./array.jl:653\
    \ [inlined]\n    [6] map\n      @ ./abstrac"
  timestamp: 1659979679
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Extract the individual groups of parens separated by spaces\n    paren_str_arr\
    \ = split(paren_string, \" \")\n    # Create empty array to store the levels of\
    \ nesting for each group\n    levels = Int64[]\n    # Loop through each group\n\
    \    for paren_str in paren_str_arr\n        num_open = 0\n        level = 0\n\
    \        # Loop through each character in the group\n        for char in paren_str\n\
    \            # Increment level of nesting for every open bracket\n           \
    \ if char == '('\n                num_open += 1\n                level = max(level,\
    \ num_open)\n            # Decrement level of nesting for every close bracket\n\
    \            elseif char == ')'\n                num_open -= 1\n            end\n\
    \        end\n        # Append the level of nesting for that group\n        push!(levels,\
    \ level)\n    end\n    return levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979677
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    num_parens = length(paren_string)\n    # Initialize a vector of zeros\
    \ representing the deepest nesting\n    # for each group of parentheses\n    max_nesting\
    \ = zeros(Int64, num_parens)\n    # Iterate through every character in the string\n\
    \    for i in 1:num_parens\n        # Check if the current character is an opening\
    \ parenthesis\n        if paren_string[i] == '('\n            # If so, increase\
    \ the nesting depth by 1\n            max_nesting[i] += 1\n            # Record\
    \ the maximum value\n            max_nesting[i+1] = max(max_nesting[i+1], max_nesting[i])\n\
    \        # Check if the current character is a closing parenthesis\n        elseif\
    \ paren_string[i] == ')'\n            # If so, decrease the nesting depth by 1\n\
    \            max_nesting[i] -= 1\n            # Record the maximum value\n   \
    \         max_nesting[i+1] = max(max_nesting[i+1], max_nesting[i])\n        #\
    \ If the current character is not a parenthesis,\n        # do nothing\n     \
    \   end\n    end\n    # Return the maximum nested value for each group of parentheses\n\
    \    return max_nesting[1:num_parens]\nend;\n \nparen_string = \"(()()) ((()))\
    \ () ((())()())\";\nparse_nested_parens(paren_string)\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: BoundsError: attempt to access 27-element Vector{Int64}\
    \ at index [28]\nStacktrace:\n [1] getindex\n   @ ./array.jl:861 [inlined]\n [2]\
    \ parse_nested_parens(paren_string::String)\n   @ Main /tmp/tmp77wg1uwf.jl:26\n\
    \ [3] top-level scope\n   @ /tmp/tmp77wg1uwf.jl:36\nin expression starting at\
    \ /tmp/tmp77wg1uwf.jl:36\n"
  stdout: ''
  timestamp: 1659979679
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    open_parens = 0\n    max_open_parens = 0\n    result = zeros(Int64, length(paren_string))\n\
    \    current_word = 1\n    # parse each character and update the depth\n    for\
    \ i in 1:length(paren_string)\n        current_char = paren_string[i]\n      \
    \  if current_char == '('\n            open_parens += 1\n            max_open_parens\
    \ = max(max_open_parens, open_parens)\n        elseif current_char == ')'\n  \
    \          open_parens -= 1\n        elseif current_char == ' '\n            result[current_word]\
    \ = max_open_parens\n            current_word += 1\n            max_open_parens\
    \ = 0\n        end\n    end\n    # don't forget to parse the last word as well!\n\
    \    result[current_word] = max_open_parens\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpp6n82qxa.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmpp6n82qxa.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 3, 1, 3, 0,\
    \ 0, 0, 0, 0, 0  \u2026  0, 0, 0, 0, 0, 0, 0, 0, 0, 0] == [2, 3, 1, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpp6n82qxa.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpp6n82qxa.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpp6n82qxa.jl:37\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 3, 4, 0, 0, 0, 0, 0, 0  \u2026  0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpp6n82qxa.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpp6n82qxa.jl:35\ntest set: Test Failed at /tmp/tmpp6n82qxa.jl:38\n\
    \  Expression: candidate(\"(()(())((())))\") == [4]\n   Evaluated: [4, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpp6n82qxa.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpp6n82qxa.jl:35\nTest Summary: | Fail  Total\n\
    test set      |    3      3\n"
  timestamp: 1659979679
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\" get list of positions of each pair of parentheses in the string\n\
    \    \"\"\"\n    paren_list = positions(paren_string, r\"\\(|\\)\")\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpyd92b1p_.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpyd92b1p_.jl:1\n\
    in expression starting at /tmp/tmpyd92b1p_.jl:1\n"
  stdout: ''
  timestamp: 1659979678
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    nested_count = []\n    for group in split(paren_string, ' ')\n       \
    \ current_count = 0\n        max_count = 0\n        for letter in group\n    \
    \        if letter == '('\n                current_count += 1\n            elseif\
    \ letter == ')'\n                current_count -= 1\n            end\n       \
    \     if current_count > max_count\n                max_count = current_count\n\
    \            end\n        end\n        push!(nested_count, max_count)\n    end\n\
    \    return nested_count\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979677
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_levels = Array{Int64}(undef, length(split(paren_string)))\n    for\
    \ (i, group) in enumerate(split(paren_string))\n        paren_levels[i] = compute_nested_parens(group)\n\
    \    end\n    return paren_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpfq9t4xe3.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmpfq9t4xe3.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ compute_nested_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpfq9t4xe3.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfq9t4xe3.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfq9t4xe3.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpfq9t4xe3.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: compute_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpfq9t4xe3.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfq9t4xe3.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfq9t4xe3.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpfq9t4xe3.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: compute_nested_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpfq9t4xe3.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfq9t4xe3.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfq9t4xe3.jl:19\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979680
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string, \" \")\n    depth = Vector{Int64}(undef,\
    \ length(groups))\n    for (i,g) in enumerate(groups)\n        open_parens = 0\n\
    \        max_open_parens = 0\n        for p in g\n            if p == '('\n  \
    \              open_parens += 1\n                max_open_parens = max(max_open_parens,\
    \ open_parens)\n            elseif p == ')'\n                open_parens -= 1\n\
    \            end\n        end\n        depth[i] = max_open_parens\n    end\n \
    \   return depth\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979677
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # For each group, the deepest level of nesting of parentheses.\n    levels\
    \ = Vector{Int64}()\n    paren_groups = split(paren_string, \" \")\n    for paren_group\
    \ in paren_groups\n        # Open parenthesis add 1 to the counter\n        #\
    \ Close parenthesis subtract 1 from the counter\n        level = 0 \n        max_level\
    \ = 0\n        for letter in paren_group\n            level += (letter == '(')\
    \ ? 1 : -1\n            if max_level < level\n                max_level = level\n\
    \            end\n        end\n        push!(levels, max_level)\n    end\n   \
    \ return levels\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979678
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, ' ')\n    for paren in paren_list\n \
    \       depth = 0\n        max_depth = 0\n        for char in paren\n        \
    \    if char == '('\n                depth += 1\n            elseif char == ')'\n\
    \                depth -= 1\n            end\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        end\n        push!(return_vector,\
    \ max_depth)\n    end\n    return return_vector\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpzzlxzk07.jl:29

    '
  stdout: "test set: Error During Test at /tmp/tmpzzlxzk07.jl:32\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ return_vector not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpzzlxzk07.jl:23\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzzlxzk07.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzzlxzk07.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpzzlxzk07.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: return_vector\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpzzlxzk07.jl:23\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzzlxzk07.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzzlxzk07.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpzzlxzk07.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: return_vector not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpzzlxzk07.jl:23\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzzlxzk07.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzzlxzk07.jl:31\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979681
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    return map(x -> find_max_level(x), split(paren_string, \" \"))\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpf495g52y.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpf495g52y.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ find_max_level not defined\n  Stacktrace:\n    [1] (::var\"#1#2\")(x::SubString{String})\n\
    \      @ Main /tmp/tmpf495g52y.jl:9\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmpf495g52y.jl:9\n    [7] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpf495g52y.jl:16 [inlined]\n\
    \    [9] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [10] top-level scope\n      @ /tmp/tmpf495g52y.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpf495g52y.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: find_max_level\
    \ not defined\n  Stacktrace:\n    [1] (::var\"#1#2\")(x::SubString{String})\n\
    \      @ Main /tmp/tmpf495g52y.jl:9\n    [2] iterate\n      @ ./generator.jl:47\
    \ [inlined]\n    [3] _collect(c::Vector{SubString{String}}, itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"}, #unused#::Base.EltypeUnknown, isz::Base.HasShape{1})\n      @\
    \ Base ./array.jl:744\n    [4] collect_similar\n      @ ./array.jl:653 [inlined]\n\
    \    [5] map\n      @ ./abstractarray.jl:2867 [inlined]\n    [6] parse_nested_parens(paren_string::String)\n\
    \      @ Main /tmp/tmpf495g52y.jl:9\n    [7] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n    [8] macro expansion\n      @ /tmp/tmpf495g52y.jl:17 [inlined]\n\
    \    [9] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659979680
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    groups = split(paren_string)\n    max_nesting = Array{Int64}(undef, length(groups))\n\
    \    for i in 1:length(groups)\n        g = groups[i]\n        n = 0\n       \
    \ m = 0\n        for c in g\n            if c == '('\n                n += 1\n\
    \                m = max(m, n)\n            elseif c == ')'\n                n\
    \ -= 1\n            end\n        end\n        max_nesting[i] = m\n    end\n  \
    \  return max_nesting\nend;\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979678
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    stack = Int64[]\n    max_level = Int64[]\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"(\", \"( \")\n    paren_string\
    \ = replace(paren_string, \")\", \" )\")\n    temp = split(paren_string)\n   \
    \ i = 0\n    while i < length(temp)\n        if temp[i] == \"(\"\n           \
    \ push!(stack, 1)\n        elseif temp[i] == \")\"\n            push!(max_level,\
    \ length(stack))\n            pop!(stack)\n        end\n        i += 1\n    end\n\
    \    return max_level\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpd2vq5gr4.jl:29

    '
  stdout: "test set: Error During Test at /tmp/tmpd2vq5gr4.jl:32\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpd2vq5gr4.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd2vq5gr4.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd2vq5gr4.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpd2vq5gr4.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpd2vq5gr4.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd2vq5gr4.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tm"
  timestamp: 1659979681
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    counter = [0 for i in 1:length(paren_list)]\n\
    \    for (i, s) in enumerate(paren_list)\n        level = 0\n        for c in\
    \ s\n            if c == '('\n                level += 1\n            elseif c\
    \ == ')'\n                counter[i] = max(counter[i], level)\n              \
    \  level -= 1\n            end\n        end\n    end\n    return counter\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979678
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    inner_parens = split(paren_string, \" \")\n    inner_parens = map(x ->\
    \ x[2:end-1], inner_parens)\n    paren_depth = []\n    for n in inner_parens\n\
    \        paren_depth = push!(paren_depth, parser(n))\n    end\n    return paren_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmphfjkh2c3.jl:19

    '
  stdout: "test set: Error During Test at /tmp/tmphfjkh2c3.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parser not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmphfjkh2c3.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphfjkh2c3.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphfjkh2c3.jl:21\ntest set:\
    \ Error During Test at /tmp/tmphfjkh2c3.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parser\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmphfjkh2c3.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphfjkh2c3.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphfjkh2c3.jl:21\ntest set:\
    \ Error During Test at /tmp/tmphfjkh2c3.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parser not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmphfjkh2c3.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphfjkh2c3.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphfjkh2c3.jl:21\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979681
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # output vector of max level of nesting of each group\n    depth = Vector{Int64}(undef,\
    \ length(split(paren_string, \" \")))\n    # depth of current group\n    depth_current\
    \ = 0\n    # index of current group\n    group_num = 1\n    # iterate through\
    \ groups\n    for group in split(paren_string, \" \")\n        # iterate through\
    \ parentheses of current group\n        for paren in group\n            if paren\
    \ == '('\n                depth_current += 1\n            elseif paren == ')'\n\
    \                depth_current -= 1\n            end\n        end\n        depth[group_num]\
    \ = depth_current\n        depth_current = 0\n        group_num += 1\n    end\n\
    \    return depth\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmper4ipvbk.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmper4ipvbk.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmper4ipvbk.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmper4ipvbk.jl:35\ntest set: Test\
    \ Failed at /tmp/tmper4ipvbk.jl:37\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmper4ipvbk.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmper4ipvbk.jl:35\ntest set: Test\
    \ Failed at /tmp/tmper4ipvbk.jl:38\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmper4ipvbk.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmper4ipvbk.jl:35\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979680
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # remove spaces from the string\n    paren_string = replace(paren_string,\
    \ \" \" => \"\")\n    n_groups = length(split(paren_string, \")\"))\n    max_nest\
    \ = Vector{Int64}(undef, n_groups)\n    paren_level = 0\n    current_group = 1\n\
    \    # we iterate over each character in the string\n    for i in 1:length(paren_string)\n\
    \        # if we encounter an opening bracket, the level increases by 1\n    \
    \    if paren_string[i] == '('\n            paren_level += 1\n        # if we\
    \ encounter a closing bracket, the level decreases by 1\n        elseif paren_string[i]\
    \ == ')'\n            paren_level -= 1\n        # if we encounter a closing bracket,\
    \ we assign the parenthesis level to the corresponding group\n        if paren_string[i]\
    \ == ')'\n            max_nest[current_group] = paren_level\n            current_group\
    \ += 1\n        end\n    end\n    return max_nest\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp5yawh6qn.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp5yawh6qn.jl:1\n\
    in expression starting at /tmp/tmp5yawh6qn.jl:1\n"
  stdout: ''
  timestamp: 1659979679
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    nest_counts = zeros(Int64,\
    \ length(paren_string))\n    current_nest_count = 0\n    for i in 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            current_nest_count += 1\n    \
    \    elseif paren_string[i] == ')'\n            current_nest_count -= 1\n    \
    \    end\n        nest_counts[i] = current_nest_count\n    end\n    out = []\n\
    \    for i in 1:length(paren_string)\n        if paren_string[i] == '('\n    \
    \        for j in i:length(paren_string)\n                if paren_string[j] ==\
    \ ')'\n                    push!(out, max(nest_counts[i:j]))\n               \
    \     break\n                end\n            end\n        end\n    end\n    return\
    \ out\nend\n \nparse_nested_parens(\"(()()) ((())) () ((())()())\")\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: MethodError: no method matching replace(::String, ::String,\
    \ ::String)\nClosest candidates are:\n  replace(!Matched::Union{Function, Type},\
    \ ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n  replace(::String,\
    \ !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \  replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \  ...\nStacktrace:\n [1] parse_nested_parens(paren_string::String)\n   @ Main\
    \ /tmp/tmpygcrd2o0.jl:9\n [2] top-level scope\n   @ /tmp/tmpygcrd2o0.jl:34\nin\
    \ expression starting at /tmp/tmpygcrd2o0.jl:34\n"
  stdout: ''
  timestamp: 1659979683
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    count_array = Vector{Int64}(undef, length(paren_string))\n    open_paren_count\
    \ = 0\n    close_paren_count = 0\n    index = 1\n    for paren in paren_string\n\
    \        if paren == '('\n            open_paren_count += 1\n        elseif paren\
    \ == ')'\n            close_paren_count += 1\n        else\n            count_array[index]\
    \ = open_paren_count - close_paren_count\n            index += 1\n           \
    \ open_paren_count = 0\n            close_paren_count = 0\n        end\n    end\n\
    \    return count_array\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpq5e466b4.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpq5e466b4.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0  \u2026  0, 0, 0, 0, 0, 0, 0, 0, 0, 0] == [2, 3, 1, 3]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq5e466b4.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq5e466b4.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpq5e466b4.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 47873021352112, 47873000379280, 47873021352176,\
    \ 47873021352208, 47873021352240, 47873021352272, 47873159308240  \u2026  47873000379344,\
    \ 47873020493904, 47873020493872, 47873021352528, 47873021352560, 47873021352592,\
    \ 47873021352624, 47873020044496, 47873021352688, 47873000381264] == [1, 2, 3,\
    \ 4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq5e466b4.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq5e466b4.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpq5e466b4.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [47873035033552, 47873035033600, 47873035033648, 47873035033696,\
    \ 47873035034224, 47873035034272, 47873035034320, 47873035034368, 47873035034416,\
    \ 47873035034464, 47873035034512, 47873035034560, 47873035034608, 47873035034656]\
    \ == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq5e466b4.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq5e466b4.jl:31\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979680
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # String -> Vector{Int64}\n    # Function to count maximum level of nesting\
    \ of parentheses\n    # Input is a string of multiple groups of parenthesis\n\
    \    # Output is a vector of the level of the deepest nesting of each group\n\
    \    paren_string = split(paren_string, \" \")\n    max_depth = Vector{Int64}(length(paren_string))\n\
    \    @inbounds for i in 1:length(paren_string)\n        level = 0\n        max_level\
    \ = 0\n        for j in 1:length(paren_string[i])\n            if paren_string[i][j]\
    \ == '('\n                level += 1\n            elseif paren_string[i][j] ==\
    \ ')'\n                level -= 1\n            end\n            if level > max_level\n\
    \                max_level = level\n            end\n        end\n        max_depth[i]\
    \ = max_level\n    end\n    return max_depth\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmprwoquqri.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmprwoquqri.jl:37\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at ~/.conda/envs/polyglot/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at ~/.conda/envs/polyglot/share/julia/base/bitarray.jl:494\n\
    \    Vector{T}(!Matched::Core.Compiler.AbstractRange{T}) where T at ~/.conda/envs/polyglot/share/julia/base/range.jl:1286\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmprwoquqri.jl:14\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprwoquqri.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprwoquqri.jl:36\ntest set:\
    \ Error During Test at /tmp/tmprwoquqri.jl:38\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at ~/.conda/envs/polyglot/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at ~/.conda/envs/polyglot/share/julia/base/bitarray.jl:494\n\
    \    Vector{T}(!Matched::Core.Compiler.AbstractRange{T}) where T at ~/.conda/envs/polyglot/share/julia/base/range.jl:1286\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmprwoquqri.jl:14\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprwoquqri.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprwoquqri.jl:36\ntest set:\
    \ Error During Test at /tmp/tmprwoquqri.jl:39\n  Test t"
  timestamp: 1659979681
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    n_paren_list = length(paren_list)\n\
    \    max_nest_list = zeros(Int64, n_paren_list)\n    for i in 1:n_paren_list\n\
    \        max_nest_list[i] = calculate_max_nest(paren_list[i])\n    end\n    return\
    \ max_nest_list\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmplvzokax6.jl:19

    '
  stdout: "test set: Error During Test at /tmp/tmplvzokax6.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ calculate_max_nest not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmplvzokax6.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplvzokax6.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplvzokax6.jl:21\ntest set:\
    \ Error During Test at /tmp/tmplvzokax6.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: calculate_max_nest\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmplvzokax6.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplvzokax6.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplvzokax6.jl:21\ntest set:\
    \ Error During Test at /tmp/tmplvzokax6.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: calculate_max_nest not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n \
    \    @ Main /tmp/tmplvzokax6.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplvzokax6.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplvzokax6.jl:21\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979681
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    res = Vector{Int64}(undef, length(split(paren_string)))\n    for (i, group)\
    \ in enumerate(split(paren_string))\n        depth = 0\n        for char in group\n\
    \            if char == '('\n                depth += 1\n            elseif char\
    \ == ')'\n                depth -= 1\n            end\n        end\n        res[i]\
    \ = depth\n    end\n    return res\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpigwtpx70.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpigwtpx70.jl:28\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpigwtpx70.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpigwtpx70.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpigwtpx70.jl:29\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpigwtpx70.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpigwtpx70.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpigwtpx70.jl:30\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpigwtpx70.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpigwtpx70.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659979680
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    group_list = split(paren_string, \" \")\n    max_depth_list = Int64[]\n\
    \    for group in group_list\n        group_stack = Int64[]\n        max_depth\
    \ = 0\n        for i in 1:length(group)\n            if group[i] == '('\n    \
    \            push!(group_stack, 1)\n                if length(group_stack) > max_depth\n\
    \                    max_depth = length(group_stack)\n                end\n  \
    \          elseif group[i] == ')'\n                pop!(group_stack)\n       \
    \     end\n        end\n        push!(max_depth_list, max_depth)\n    end\n  \
    \  return max_depth_list\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659979679
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens(\"\
    (()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n    \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = paren_string |> split\n    paren_counts = zeros(Int64,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        paren_counts[i] = count_parens(paren_group)\n    end\n    return paren_counts\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpit2g6t41.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmpit2g6t41.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpit2g6t41.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpit2g6t41.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpit2g6t41.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpit2g6t41.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpit2g6t41.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpit2g6t41.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpit2g6t41.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpit2g6t41.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpit2g6t41.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpit2g6t41.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpit2g6t41.jl:20\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659979681
