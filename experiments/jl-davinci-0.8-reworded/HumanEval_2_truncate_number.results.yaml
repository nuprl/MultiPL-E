language: jl
name: HumanEval_2_truncate_number
results:
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    if number < 0\n        return truncate_number(-number)\n    end\n    return\
    \ number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    integer_part = trunc(number)\n    return number - integer_part\nend\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    #\n    if number < 0 \n        println(\"\\ntruncate_number: Number should\
    \ be positive!\")\n        return\n    end\n    #\n    return (number - floor(number))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return mod(number, 1)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\" Return the decimal part of the number.\n    \"\"\"\n    return\
    \ round(number - floor(number), digits=4)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return  number % trunc(number)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    integer_part, decimal_part = trunc(number), number - trunc(number)\n\
    \    \n    return decimal_part\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return  number - floor(number)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return (number - trunc(number))\nend\nusing Test\n\n@testset begin\n\n\
    candidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return mod(number, 1)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return (number - trunc(number))\nend\nusing Test\n\n@testset begin\n\n\
    candidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n  return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    if number >= 0\n        return number - floor(number)\n    else\n    \
    \    return number - ceil(number)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: -1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number(number::Float64) = number - floor(number)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: "test set: Error During Test at /tmp/tmp9puiwfde.jl:17\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  MethodError: Cannot `convert` an object\
    \ of type var\"#truncate_number#1\" to an object of type Float64\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n\
    \    convert(::Type{T}, !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n\
    \    convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/twiceprecision.jl:262\n\
    \    ...\n  Stacktrace:\n   [1] truncate_number(number::Float64)\n     @ Main\
    \ /tmp/tmp9puiwfde.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9puiwfde.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9puiwfde.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp9puiwfde.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(1.25) == 0.25\n  MethodError: Cannot `convert` an object of type var\"\
    #truncate_number#1\" to an object of type Float64\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n\
    \    convert(::Type{T}, !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n\
    \    convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/twiceprecision.jl:262\n\
    \    ...\n  Stacktrace:\n   [1] truncate_number(number::Float64)\n     @ Main\
    \ /tmp/tmp9puiwfde.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9puiwfde.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9puiwfde."
  timestamp: 1660009166
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    # truncate number to integer\n    number = floor(number)\n    # subtract\
    \ number by integer\n    number = number - number\n    return number\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp51ufxs70.jl:18

    '
  stdout: "test set: Test Failed at /tmp/tmp51ufxs70.jl:21\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 0.0 == 0.5\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp51ufxs70.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp51ufxs70.jl:20\ntest set: Test\
    \ Failed at /tmp/tmp51ufxs70.jl:22\n  Expression: candidate(1.25) == 0.25\n  \
    \ Evaluated: 0.0 == 0.25\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp51ufxs70.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp51ufxs70.jl:20\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     2      3\n"
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    decimal = number - trunc(number)\n    return decimal\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    if number < 0.0\n        return -(truncate_number(-number))\n    end\n\
    \    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: -1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"NOTE: this function must be implemented\"\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: "test set: Error During Test at /tmp/tmpo2ufuxz8.jl:17\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  MethodError: Cannot `convert` an object\
    \ of type String to an object of type Float64\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n\
    \    convert(::Type{T}, !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n\
    \    convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/twiceprecision.jl:262\n\
    \    ...\n  Stacktrace:\n   [1] truncate_number(number::Float64)\n     @ Main\
    \ /tmp/tmpo2ufuxz8.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpo2ufuxz8.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpo2ufuxz8.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpo2ufuxz8.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(1.25) == 0.25\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Float64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n\
    \    convert(::Type{T}, !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n\
    \    convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/twiceprecision.jl:262\n\
    \    ...\n  Stacktrace:\n   [1] truncate_number(number::Float64)\n     @ Main\
    \ /tmp/tmpo2ufuxz8.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpo2ufuxz8.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpo2ufuxz8.jl:16\ntest set:\
    \ Error During Test "
  timestamp: 1660009166
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    #return number - floor(number)\n    \n    return rem(number, 1)\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpvewz0f4g.jl:9\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpvewz0f4g.jl:1\n\
    in expression starting at /tmp/tmpvewz0f4g.jl:1\n"
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    decimal = number - trunc(number)\n    return decimal\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return Float64(number - floor(number))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate(number) - Int(number)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp4jru5ju3.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmp4jru5ju3.jl:17\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  MethodError: no method matching truncate(::Float64)\n\
    \  Closest candidates are:\n    truncate(!Matched::Base.GenericIOBuffer, !Matched::Integer)\
    \ at ~/.conda/envs/polyglot/share/julia/base/iobuffer.jl:268\n    truncate(!Matched::IOStream,\
    \ !Matched::Integer) at ~/.conda/envs/polyglot/share/julia/base/iostream.jl:106\n\
    \  Stacktrace:\n   [1] truncate_number(number::Float64)\n     @ Main /tmp/tmp4jru5ju3.jl:10\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4jru5ju3.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4jru5ju3.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp4jru5ju3.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(1.25) == 0.25\n  MethodError: no method matching truncate(::Float64)\n\
    \  Closest candidates are:\n    truncate(!Matched::Base.GenericIOBuffer, !Matched::Integer)\
    \ at ~/.conda/envs/polyglot/share/julia/base/iobuffer.jl:268\n    truncate(!Matched::IOStream,\
    \ !Matched::Integer) at ~/.conda/envs/polyglot/share/julia/base/iostream.jl:106\n\
    \  Stacktrace:\n   [1] truncate_number(number::Float64)\n     @ Main /tmp/tmp4jru5ju3.jl:10\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4jru5ju3.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4jru5ju3.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp4jru5ju3.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(123.0) == 0.0\n  MethodError: no method matching truncate(::Float64)\n\
    \  Closest candidates are:\n    truncate(!Matched::Base.GenericIOBuffer, !Matched::Integer)\
    \ at ~/.conda/envs/polyglot/share/julia/base/iobuffer.jl:268\n    truncate(!Matched::IOStrea"
  timestamp: 1660009166
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\"Return decimal part of number\"\"\"\n    decimal, integer = modf(number)\n\
    \    return decimal\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1.0\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) ==\
    \ 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    if number >= 0 \n        return number - trunc(number)\n    else\n   \
    \     return number - trunc(number) - 1\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    integer_part, decimals = divrem(number, 1)\n    return decimals\nend\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    if number >= 0\n        return number - trunc(number)\n    else\n    \
    \    return number - trunc(number) + 1\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    # Integer part\n    temp_number = floor(number)\n    return number - temp_number\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    j = number - floor(number)\n    return j\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    @assert number >= 0\n    @assert number < Inf\n    integer_part, decimals\
    \ = divrem(number, 1)\n    return decimals\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    if (number <= 1)\n        return number\n    else\n        return truncate_number(number\
    \ - 1)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp_n_r7qte.jl:18

    '
  stdout: "test set: Test Failed at /tmp/tmp_n_r7qte.jl:23\n  Expression: candidate(123.0)\
    \ == 0.0\n   Evaluated: 1.0 == 0.0\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_n_r7qte.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_n_r7qte.jl:20\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     1      3\n"
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return mod(number, 1)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - (floor(number))\nend\nusing Test\n\n@testset begin\n\n\
    candidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    frac, int = modf(number)\n    return frac\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    remainder = mod(number, 1)\n    return remainder\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    # decimals of number\n    decimals = number - floor(number)\n  \
    \  return decimals\nend\n \nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009163
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\" Floating point absolute value. \nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp2rnq6fdn.jl:1\nin expression starting at /tmp/tmp2rnq6fdn.jl:1\n"
  stdout: ''
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n  remainder, truncate = modf(number)\n  return remainder\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return rem(number, floor(number))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return \nend\n```\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid \"`\" syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpw260asph.jl:12\nin expression starting at\
    \ /tmp/tmpw260asph.jl:12\n"
  stdout: ''
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return mod(number, 1)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - Int(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmp0602lucq.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmp0602lucq.jl:17\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  InexactError: Int64(3.5)\n  Stacktrace:\n\
    \   [1] Int64\n     @ ./float.jl:812 [inlined]\n   [2] truncate_number(number::Float64)\n\
    \     @ Main /tmp/tmp0602lucq.jl:10\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp0602lucq.jl:17 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp0602lucq.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp0602lucq.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(1.25) == 0.25\n  InexactError: Int64(1.25)\n  Stacktrace:\n   [1]\
    \ Int64\n     @ ./float.jl:812 [inlined]\n   [2] truncate_number(number::Float64)\n\
    \     @ Main /tmp/tmp0602lucq.jl:10\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp0602lucq.jl:18 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp0602lucq.jl:16\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    1      2      3\n"
  timestamp: 1660009166
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    quotient, remainder = divrem(number, 1)\n    return remainder\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    number -= trunc(number)\n    return number\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    if number >= 0\n        return number - trunc(number)\n    else\n    \
    \    return number - trunc(number) - 1\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    remainder = rem(number, 1)\n    return remainder\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) ==\
    \ 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    # If a number is closer to its ceiling then its floor,\n    # it means\
    \ that it is closer to the ceiling,\n    # and the remainder should be taken.\n\
    \    # Otherwise, the number is closer to the floor and the integer part\n   \
    \ # and the remainder should be taken.\n    # This way, the remainder is always\
    \ non-negative and smaller than 1.\n    if number - trunc(number) >= ceil(number)\
    \ - number\n        return number - trunc(number)\n    else\n        return number\
    \ - floor(number)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    parts = split(string(number), \".\")\n    decimals = parts[2]\n    return\
    \ float(decimals)\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpr7_fiwgh.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmpr7_fiwgh.jl:19\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  MethodError: no method matching AbstractFloat(::SubString{String})\n\
    \  Closest candidates are:\n    (::Type{T})(!Matched::AbstractChar) where T<:Union{AbstractChar,\
    \ Number} at ~/.conda/envs/polyglot/share/julia/base/char.jl:50\n    (::Type{T})(!Matched::Base.TwicePrecision)\
    \ where T<:Number at ~/.conda/envs/polyglot/share/julia/base/twiceprecision.jl:255\n\
    \    (::Type{T})(!Matched::Complex) where T<:Real at ~/.conda/envs/polyglot/share/julia/base/complex.jl:44\n\
    \    ...\n  Stacktrace:\n   [1] float(x::SubString{String})\n     @ Base ./float.jl:269\n\
    \   [2] truncate_number(number::Float64)\n     @ Main /tmp/tmpr7_fiwgh.jl:12\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpr7_fiwgh.jl:19 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpr7_fiwgh.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpr7_fiwgh.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(1.25) == 0.25\n  MethodError: no method matching AbstractFloat(::SubString{String})\n\
    \  Closest candidates are:\n    (::Type{T})(!Matched::AbstractChar) where T<:Union{AbstractChar,\
    \ Number} at ~/.conda/envs/polyglot/share/julia/base/char.jl:50\n    (::Type{T})(!Matched::Base.TwicePrecision)\
    \ where T<:Number at ~/.conda/envs/polyglot/share/julia/base/twiceprecision.jl:255\n\
    \    (::Type{T})(!Matched::Complex) where T<:Real at ~/.conda/envs/polyglot/share/julia/base/complex.jl:44\n\
    \    ...\n  Stacktrace:\n   [1] float(x::SubString{String})\n     @ Base ./float.jl:269\n\
    \   [2] truncate_number(number::Float64)\n     @ Main /tmp/tmpr7_fiwgh.jl:12\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpr7_fiwgh.jl:20 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/T"
  timestamp: 1660009166
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    left_part, right_part = split(Float64, number)\n    return parse(Float64,\
    \ \"0.\" * right_part)\nend\n\"\"\" Given a positive floating point number, it\
    \ can be decomposed into\n    and integer part (largest integer smaller than given\
    \ number) and decimals\n    (leftover part always smaller than 1).\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp7ht5gq24.jl:13\nin expression starting at\
    \ /tmp/tmp7ht5gq24.jl:13\n"
  stdout: ''
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    if isinteger(number) == false\n        return number - trunc(number)\n\
    \    else\n        return 0\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    # YOUR CODE HERE\n    return number - floor(number)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    leftover = number - floor(number)\n    return leftover\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    if number >= 0.0\n        return number - trunc(number)\n    else\n  \
    \      return number - (trunc(number) + 1)\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return modf(number)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return mod(number, 1)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    quotient = int(number)\n    return (number - quotient)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpjf8dfi57.jl:15

    '
  stdout: "test set: Error During Test at /tmp/tmpjf8dfi57.jl:18\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  UndefVarError: int not defined\n  Stacktrace:\n\
    \   [1] truncate_number(number::Float64)\n     @ Main /tmp/tmpjf8dfi57.jl:10\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjf8dfi57.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjf8dfi57.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpjf8dfi57.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(1.25) == 0.25\n  UndefVarError: int not defined\n  Stacktrace:\n \
    \  [1] truncate_number(number::Float64)\n     @ Main /tmp/tmpjf8dfi57.jl:10\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjf8dfi57.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjf8dfi57.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpjf8dfi57.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(123.0) == 0.0\n  UndefVarError: int not defined\n  Stacktrace:\n \
    \  [1] truncate_number(number::Float64)\n     @ Main /tmp/tmpjf8dfi57.jl:10\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjf8dfi57.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjf8dfi57.jl:17\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1660009166
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return mod(number, 1)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    #TODO\n    return(0)\nend\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7wg3n9it.jl:264

    '
  stdout: "test set: Test Failed at /tmp/tmp7wg3n9it.jl:267\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 0.0 == 0.5\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7wg3n9it.jl:267 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7wg3n9it.jl:266\ntest set: Test\
    \ Failed at /tmp/tmp7wg3n9it.jl:268\n  Expression: candidate(1.25) == 0.25\n \
    \  Evaluated: 0.0 == 0.25\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7wg3n9it.jl:268 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7wg3n9it.jl:266\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     2      3\n"
  timestamp: 1660009165
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    # return (number % 1)\n    integer_part, decimals = modf(number)\n   \
    \ return decimals\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpju4nggyi.jl:16

    '
  stdout: "test set: Test Failed at /tmp/tmpju4nggyi.jl:19\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpju4nggyi.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpju4nggyi.jl:18\ntest set: Test\
    \ Failed at /tmp/tmpju4nggyi.jl:20\n  Expression: candidate(1.25) == 0.25\n  \
    \ Evaluated: 1.0 == 0.25\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpju4nggyi.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpju4nggyi.jl:18\ntest set: Test\
    \ Failed at /tmp/tmpju4nggyi.jl:21\n  Expression: candidate(123.0) == 0.0\n  \
    \ Evaluated: 123.0 == 0.0\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpju4nggyi.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpju4nggyi.jl:18\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1660009166
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    decimal = number % 1\n    return decimal\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    leftover_part = mod(number, 1)\n    return leftover_part\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    for i in eachindex(number)\n        if i == \".\"\n            return(parse(Float64,\
    \ number[i+1:end]))\n        end\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpdkyikbqq.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmpdkyikbqq.jl:21\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type Float64\n  Closest candidates are:\n  \
    \  convert(::Type{T}, !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n\
    \    convert(::Type{T}, !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n\
    \    convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/twiceprecision.jl:262\n\
    \    ...\n  Stacktrace:\n   [1] truncate_number(number::Float64)\n     @ Main\
    \ /tmp/tmpdkyikbqq.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdkyikbqq.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdkyikbqq.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpdkyikbqq.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(1.25) == 0.25\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Float64\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:6\n\
    \    convert(::Type{T}, !Matched::Number) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/number.jl:7\n\
    \    convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at ~/.conda/envs/polyglot/share/julia/base/twiceprecision.jl:262\n\
    \    ...\n  Stacktrace:\n   [1] truncate_number(number::Float64)\n     @ Main\
    \ /tmp/tmpdkyikbqq.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdkyikbqq.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdkyikbqq.jl:20\ntest set:\
    \ Error During Tes"
  timestamp: 1660009167
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    # We use the type of the number to ensure it is positive\n    #\
    \ So we can use a floor function\n    integer_part = trunc(number)\n    decimal_part\
    \ = number - integer_part\n    \n    return decimal_part\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    decimals = mod(number, Int(number))\n    return decimals\nend\n \nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmpiwocq4pc.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmpiwocq4pc.jl:19\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  InexactError: Int64(3.5)\n  Stacktrace:\n\
    \   [1] Int64\n     @ ./float.jl:812 [inlined]\n   [2] truncate_number(number::Float64)\n\
    \     @ Main /tmp/tmpiwocq4pc.jl:10\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpiwocq4pc.jl:19 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpiwocq4pc.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpiwocq4pc.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(1.25) == 0.25\n  InexactError: Int64(1.25)\n  Stacktrace:\n   [1]\
    \ Int64\n     @ ./float.jl:812 [inlined]\n   [2] truncate_number(number::Float64)\n\
    \     @ Main /tmp/tmpiwocq4pc.jl:10\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpiwocq4pc.jl:20 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpiwocq4pc.jl:18\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    1      2      3\n"
  timestamp: 1660009166
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009164
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \n    \"\"\"\n    The number is converted to a string and the decimals\
    \ are grabbed. \n    These are then converted back to a float. \n    \"\"\"\n\
    \    decimals = parse(Float64, split(string(number), \".\")[2])\nusing Test\n\n\
    @testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw7m300ch.jl:9\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw7m300ch.jl:1\n\
    in expression starting at /tmp/tmpw7m300ch.jl:1\n"
  stdout: ''
  timestamp: 1660009165
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\" Truncate decimals of given number. \n        Return the decimal\
    \ part of the number.\n    \"\"\"\n    return number - Int(number)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmpgvugnjuz.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmpgvugnjuz.jl:20\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  InexactError: Int64(3.5)\n  Stacktrace:\n\
    \   [1] Int64\n     @ ./float.jl:812 [inlined]\n   [2] truncate_number(number::Float64)\n\
    \     @ Main /tmp/tmpgvugnjuz.jl:13\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpgvugnjuz.jl:20 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpgvugnjuz.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpgvugnjuz.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(1.25) == 0.25\n  InexactError: Int64(1.25)\n  Stacktrace:\n   [1]\
    \ Int64\n     @ ./float.jl:812 [inlined]\n   [2] truncate_number(number::Float64)\n\
    \     @ Main /tmp/tmpgvugnjuz.jl:13\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpgvugnjuz.jl:21 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpgvugnjuz.jl:19\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    1      2      3\n"
  timestamp: 1660009167
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\n \nusing Test\n\n@testset begin\n\n\
    candidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    integer_part = convert(Int64, floor(number))\n    return number - integer_part\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    i, f = divrem(number, 1)\n    return f\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009164
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n     return number-trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009165
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    integer_part, decimals = modf(number) \n    return decimals\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5mvwk7ag.jl:15

    '
  stdout: "test set: Test Failed at /tmp/tmp5mvwk7ag.jl:18\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5mvwk7ag.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5mvwk7ag.jl:17\ntest set: Test\
    \ Failed at /tmp/tmp5mvwk7ag.jl:19\n  Expression: candidate(1.25) == 0.25\n  \
    \ Evaluated: 1.0 == 0.25\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5mvwk7ag.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5mvwk7ag.jl:17\ntest set: Test\
    \ Failed at /tmp/tmp5mvwk7ag.jl:20\n  Expression: candidate(123.0) == 0.0\n  \
    \ Evaluated: 123.0 == 0.0\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5mvwk7ag.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5mvwk7ag.jl:17\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1660009167
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\"\n    I am assuming that user will always provide a positive number.\n\
    \    \"\"\"\n    return number - Int(number)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmp5dqziaj8.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmp5dqziaj8.jl:20\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  InexactError: Int64(3.5)\n  Stacktrace:\n\
    \   [1] Int64\n     @ ./float.jl:812 [inlined]\n   [2] truncate_number(number::Float64)\n\
    \     @ Main /tmp/tmp5dqziaj8.jl:13\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp5dqziaj8.jl:20 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp5dqziaj8.jl:19\ntest set:\
    \ Error During Test at /tmp/tmp5dqziaj8.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(1.25) == 0.25\n  InexactError: Int64(1.25)\n  Stacktrace:\n   [1]\
    \ Int64\n     @ ./float.jl:812 [inlined]\n   [2] truncate_number(number::Float64)\n\
    \     @ Main /tmp/tmp5dqziaj8.jl:13\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp5dqziaj8.jl:21 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp5dqziaj8.jl:19\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    1      2      3\n"
  timestamp: 1660009167
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    # HINT: You can use the \"div\" function for integer division and \"\\\
    %\" \n    # for modulo operations on integers.\n    # HINT: Use the \"floor\"\
    \ function from the \"Math\" module to round down\n    # the number to the nearest\
    \ integer\n    return 0.0\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpopasb8do.jl:18

    '
  stdout: "test set: Test Failed at /tmp/tmpopasb8do.jl:21\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 0.0 == 0.5\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpopasb8do.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpopasb8do.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpopasb8do.jl:22\n  Expression: candidate(1.25) == 0.25\n  \
    \ Evaluated: 0.0 == 0.25\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpopasb8do.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpopasb8do.jl:20\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     2      3\n"
  timestamp: 1660009167
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    # If the number is positive, divide by 1\n    # If the number is negative,\
    \ divide by -1 to invert it, then take the abs to change it back to positive\n\
    \    # If the number is zero, then just take the abs to make it positive\n   \
    \ if number > 0 \n        return number % 1\n    elseif number < 0\n        return\
    \ abs(number % -1)\n    else\n        return abs(number)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009165
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    remainder = mod(number, 1)\n    return remainder\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009163
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return (number % 1)\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) ==\
    \ 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009165
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\" Return the number without its integer part. \"\"\"\n    if number\
    \ == trunc(number)\n        return 0.0\n    else\n        return number - trunc(number)\n\
    \    end\nend\n# test of truncate_number\nprintln(\"number: 3.5, truncated: \"\
    , truncate_number(3.5))\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'number: 3.5, truncated: 0.5

    Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009165
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    integer, decimals = divrem(number, 1)\n    return decimals\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009165
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n  return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) ==\
    \ 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpa7wc8qt1.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpa7wc8qt1.jl:17\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: 3.0 == 0.5\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa7wc8qt1.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa7wc8qt1.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpa7wc8qt1.jl:18\n  Expression: candidate(1.25) == 0.25\n  \
    \ Evaluated: 1.0 == 0.25\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa7wc8qt1.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa7wc8qt1.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpa7wc8qt1.jl:19\n  Expression: candidate(123.0) == 0.0\n  \
    \ Evaluated: 123.0 == 0.0\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa7wc8qt1.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa7wc8qt1.jl:16\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1660009167
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    decimal = number - floor(number)\n    return decimal\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009165
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    truncate_number(n::Float64) = number - trunc(number)\nend;\n\"\"\"returns\
    \ the integer part of a number\"\"\"\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmp6lnq_kxs.jl:12\nin expression starting at /tmp/tmp6lnq_kxs.jl:12\n"
  stdout: ''
  timestamp: 1660009166
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    #Solution\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1wql2ij6.jl:9\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1wql2ij6.jl:1\n\
    in expression starting at /tmp/tmp1wql2ij6.jl:1\n"
  stdout: ''
  timestamp: 1660009166
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % 1\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009162
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - convert(Int64, number)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmpcmth_fmy.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpcmth_fmy.jl:17\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  InexactError: Int64(3.5)\n  Stacktrace:\n\
    \   [1] Int64\n     @ ./float.jl:812 [inlined]\n   [2] convert\n     @ ./number.jl:7\
    \ [inlined]\n   [3] truncate_number(number::Float64)\n     @ Main /tmp/tmpcmth_fmy.jl:10\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpcmth_fmy.jl:17 [inlined]\n\
    \   [6] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpcmth_fmy.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpcmth_fmy.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(1.25) == 0.25\n  InexactError: Int64(1.25)\n  Stacktrace:\n   [1]\
    \ Int64\n     @ ./float.jl:812 [inlined]\n   [2] convert\n     @ ./number.jl:7\
    \ [inlined]\n   [3] truncate_number(number::Float64)\n     @ Main /tmp/tmpcmth_fmy.jl:10\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpcmth_fmy.jl:18 [inlined]\n\
    \   [6] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpcmth_fmy.jl:16\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    1      2      3\n"
  timestamp: 1660009168
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    if number < 0\n        sign, number = -1, -number\n    else\n        sign\
    \ = 1\n    end\n    integer_part = floor(number)\n    return (number - integer_part)\
    \ * sign\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t\
    @test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009166
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    retval = number - trunc(number)\n    return retval\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009166
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    # Return decimal part of the number\n    remainder(number, 1)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpdk1t20dp.jl:15

    '
  stdout: "test set: Error During Test at /tmp/tmpdk1t20dp.jl:18\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  UndefVarError: remainder not defined\n\
    \  Stacktrace:\n   [1] truncate_number(number::Float64)\n     @ Main /tmp/tmpdk1t20dp.jl:11\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdk1t20dp.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdk1t20dp.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpdk1t20dp.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(1.25) == 0.25\n  UndefVarError: remainder not defined\n  Stacktrace:\n\
    \   [1] truncate_number(number::Float64)\n     @ Main /tmp/tmpdk1t20dp.jl:11\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdk1t20dp.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdk1t20dp.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpdk1t20dp.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(123.0) == 0.0\n  UndefVarError: remainder not defined\n  Stacktrace:\n\
    \   [1] truncate_number(number::Float64)\n     @ Main /tmp/tmpdk1t20dp.jl:11\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdk1t20dp.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdk1t20dp.jl:17\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1660009168
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\" \n    Truncate the number by getting its fractional part.\n   \
    \ \"\"\"\n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009166
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    quotient, remainder = divrem(number, 1) \n    return remainder\nend\n\
    using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
    \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009166
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    \"\"\" given a number return the left over part (always smaller than 1)\
    \ \"\"\"\n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009166
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return mod(number, 1)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return mod(number,1)\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) ==\
    \ 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009166
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - round(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpd9mj3z2p.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpd9mj3z2p.jl:17\n  Expression: candidate(3.5)\
    \ == 0.5\n   Evaluated: -0.5 == 0.5\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd9mj3z2p.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd9mj3z2p.jl:16\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     1      3\n"
  timestamp: 1660009168
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    @assert number >= 0.0 \"Argument must be a positive number\"\nusing Test\n\
    \n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\
    \t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpo7ofe664.jl:9\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpo7ofe664.jl:1\n\
    in expression starting at /tmp/tmpo7ofe664.jl:1\n"
  stdout: ''
  timestamp: 1660009167
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number % trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009166
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return mod(number, 1)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    decimals = number % 1.0\n    return decimals\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009166
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    # The modulo operator returns the remainder of a division\n    return\
    \ number % 1\nend\nusing Test\n\n@testset begin\n\ncandidate = truncate_number;\n\
    \t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0)\
    \ == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1660009167
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return mod(number, 1)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return mod(number, 1)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - floor(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 0
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    return number - trunc(number)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
    \    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).\n\n    Return the decimal part of\
    \ the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
    \ \n    if number > 0\n        integer_part = Int(number)\n        decimals =\
    \ number - integer_part\n        return decimals\n    else\n        print(\"Truncate\
    \ error: invalid number.\")\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = truncate_number;\n\t@test(candidate(3.5) == 0.5)\n\t@test(candidate(1.25)\
    \ == 0.25)\n\t@test(candidate(123.0) == 0.0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 2 errored,
    0 broken.

    in expression starting at /tmp/tmpqbeexpa7.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpqbeexpa7.jl:23\n  Test threw exception\n\
    \  Expression: candidate(3.5) == 0.5\n  InexactError: Int64(3.5)\n  Stacktrace:\n\
    \   [1] Int64\n     @ ./float.jl:812 [inlined]\n   [2] truncate_number(number::Float64)\n\
    \     @ Main /tmp/tmpqbeexpa7.jl:11\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpqbeexpa7.jl:23 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpqbeexpa7.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpqbeexpa7.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(1.25) == 0.25\n  InexactError: Int64(1.25)\n  Stacktrace:\n   [1]\
    \ Int64\n     @ ./float.jl:812 [inlined]\n   [2] truncate_number(number::Float64)\n\
    \     @ Main /tmp/tmpqbeexpa7.jl:11\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpqbeexpa7.jl:24 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpqbeexpa7.jl:22\nTest Summary:\
    \ | Pass  Error  Total\ntest set      |    1      2      3\n"
  timestamp: 1660009169
