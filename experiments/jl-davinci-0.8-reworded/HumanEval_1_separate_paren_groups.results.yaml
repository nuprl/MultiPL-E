language: jl
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_matches = [match(r\"\\(+\\)+\", paren_string) for paren_string in\
    \ split(paren_string, \" \")]\n    paren_matches = filter(x -> x != nothing, paren_matches)\n\
    \    return map(x -> x.match, paren_matches)\nend\n@testset \"parens\" begin\n\
    \    @test separate_paren_groups(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\"\
    , \"(()())\"]\n    @test separate_paren_groups(\"( ) (( )) (( )( ))\") != [\"\
    ()\", \"(())\", \"(()())\", \"()()()()\"]\n    @test separate_paren_groups(\"\
    ( ) (( )) (( )( ))\") != [\"(())\", \"(()())\", \"()\"]\n    @test separate_paren_groups(\"\
    ( ) (( )) (( )( ))\") != [\"()\", \"(())\", \"(()())\", \"()()()()\"]\n    @test\
    \ separate_paren_groups(\"\") == []\n    @test separate_paren_groups(\"(())\"\
    ) == [\"(())\"]\n    @test separate_paren_groups(\"(((((((())))))))\") == [\"\
    (((((((())))))))\" ]\n    @test separate_paren_groups(\"( ((((((())))))) )\")\
    \ == [\"( ((((((())))))) )\"]\n    @test separate_paren_groups(\"()()()\") ==\
    \ [\"()()()\"]\n    @test separate_paren_groups(\"(())()()()\") == [\"(())()()()\"\
    ]\n    @test separate_paren_groups(\"()()()(())\") == [\"()()()(())\"]\n    @test\
    \ separate_paren_groups(\"(())()()()(())\") == [\"(())()()()(())\"]\n    @test\
    \ separate_paren_groups(\"(())(())(())\") == [\"(())(())(())\"]\n    @test separate_paren_groups(\"\
    (())()()()(())\") == [\"(())()()()(())\"]\n    @test separate_paren_groups(\"\
    (()()()()()()())\") == [\"(()()()()()()())\"]\n    @test separate_paren_groups(\"\
    (()(())(())(())(()\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \"(\" not allowed in \"\"(()(())(())(())(()\\\
    nusing Test\\n\\n@testset begin\\n\\ncandidate = separate_paren_groups;\\n\\t@test(candidate(\"\
    (()()) (\" at /tmp/tmp7fz_nvwp.jl:35\nStacktrace:\n [1] top-level scope\n   @\
    \ /tmp/tmp7fz_nvwp.jl:35\nin expression starting at /tmp/tmp7fz_nvwp.jl:35\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp_lcb2vx6.jl:12

    '
  stdout: "test set: Error During Test at /tmp/tmp_lcb2vx6.jl:15\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp_lcb2vx6.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_lcb2vx6.jl:15 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_lcb2vx6.jl:14\ntest set:\
    \ Error During Test at /tmp/tmp_lcb2vx6.jl:16\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp_lcb2vx6.jl:9"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\") # remove spaces in\
    \ the string\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkz6b6aai.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkz6b6aai.jl:1\n\
    in expression starting at /tmp/tmpkz6b6aai.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    #Vector for storing separated paren groups\n    separate_groups = []\n\
    \    #Compute the total number of parens in the input string.\n    count_total_parens\
    \ = length(findall(r\"\\(|\\)\", paren_string))\n    #Compute the number of paren\
    \ groups in the input string.\n    count_paren_groups = count_total_parens/2\n\
    \    #This is the index of the last paren group in the string.\n    last_group_idx\
    \ = count_paren_groups\n    #Create a temporary string that is the same as paren_string\
    \ but without spaces.\n    temp_string = replace(paren_string, \" \" => \"\")\n\
    \    #Create a temporary string that has the first paren group removed.\n    temp_string2\
    \ = replace(temp_string, r\"\\(.*\\)\", \"\")\n    #Add the first paren group\
    \ to separate_groups\n    push!(separate_groups, replace(temp_string, r\"\\(.*\\\
    )\", \"\"))\n    #Iterate over the input string and locate the indices of the\
    \ paren groups.\n    for i in 1:count_paren_groups-1\n        #Assemble a regex\
    \ to find all paren groups after the first.\n        temp_string3 = r\"(\\()(.*)\"\
    *string(last_group_idx-i)*r\"(\\))\"\n        push!(separate_groups, replace(temp_string2,\
    \ temp_string3, \"\"))\n        temp_string2 = replace(temp_string2, temp_string3,\
    \ \"\")\n    end\n    #Return the vector of separate paren groups.\n    return\
    \ separate_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp8ve8prb3.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmp8ve8prb3.jl:38\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching replace(::String,\
    \ ::Regex, ::String)\n  Closest candidates are:\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp8ve8prb3.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8ve8prb3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8ve8prb3.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp8ve8prb3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching replace(::String, ::Regex, ::String)\n\
    \  Closest candidates are:\n    replace(!Matched::Union{Function, Type}, ::Any;\
    \ count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n    replace(::String,\
    \ !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp8ve8prb3.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8ve8prb3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/cento"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    \"\"\" Initialize an array that will store all the seperate parenthesis\
    \ groups\"\"\"\n    seperate_groups = []\n    \n    \"\"\" Initialize a counter\
    \ that will count the number of open parenthesis\"\"\"\n    open_paren = 0\n \
    \   \n    \"\"\" Initialize a counter that will count the number of closed parenthesis\"\
    \"\"\n    closed_paren = 0\n    \n    \"\"\" Initialize a string that will store\
    \ the starting index\"\"\"\n    group_start = \"\"\n    \n    \"\"\" Loop through\
    \ each character in the string and use conditional statements \n        to determine\
    \ whether it is a parenthesis or a space \"\"\"\n    for char in paren_string\n\
    \        if char == \"(\"\n            open_paren += 1\n        elseif char ==\
    \ \")\"\n            closed_paren += 1\n        elseif char == \" \"\n       \
    \     nothing\n        end\n    end\n    \n    \"\"\" Check to see if the number\
    \ of open parenthesis is equal to the number of closed parenthesis \"\"\"\n  \
    \  if open_paren != closed_paren\n        print(\"No\")\n        return\n    end\n\
    \    \n    \"\"\" Determine the starting index for each group of parenthesis,\
    \ and the length of each group \"\"\"\n    for (i, char) in enumerate(paren_string)\n\
    \        if char == \"(\"\n            group_start = i\n        elseif char ==\
    \ \")\"\n            push!(seperate_groups, String(paren_string[group_start:i]))\n\
    \        end\n    end\n    return seperate_groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpgtn9oayt.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmpgtn9oayt.jl:55\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgtn9oayt.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgtn9oayt.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgtn9oayt.jl:56\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgtn9oayt.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgtn9oayt.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgtn9oayt.jl:57\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgtn9oayt.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgtn9oayt.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgtn9oayt.jl:58\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgtn9oayt.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_list = split(strip(paren_string), \" \")\n    paren_list = paren_list[paren_list\
    \ .!= \"\"] # Get rid of empty strings in list\n    valid_string = [\"(\" for\
    \ i in 1:length(paren_list)]\n    for i in 1:length(paren_list)\n        valid_string[i]\
    \ = valid_string[i] * \"(\" ^ length(paren_list[i])\n    end\n    return paren_list\
    \ .== valid_string\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpr2lh4q8l.jl:19

    '
  stdout: "test set: Error During Test at /tmp/tmpr2lh4q8l.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Bool\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] setindex!(A::Vector{String}, x::Bool, i1::Int64)\n\
    \     @ Base ./array.jl:903\n   [2] Array\n     @ ./bitarray.jl:498 [inlined]\n\
    \   [3] convert\n     @ ./array.jl:554 [inlined]\n   [4] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr2lh4q8l.jl:15\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpr2lh4q8l.jl:22 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpr2lh4q8l.jl:21\ntest set:\
    \ Error During Test at /tmp/tmpr2lh4q8l.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Bool to an object\
    \ of type String\n  Closest candidates are:\n    convert(::Type{String}, !Matched::String)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] setindex!(A::Vector{String}, x::Bool, i1::Int64)\n\
    \     @ Base ."
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Start your code after this line\n \nend\n \n \n \n@testset \"Separate\
    \ groups of nested parentheses\" begin\n    @test separate_paren_groups(\"( )\
    \ (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n    @test separate_paren_groups(\"\
    ( )( ) ( ( ) )\") == [\"()\", \"()\", \"(())\"]\n    @test separate_paren_groups(\"\
    ( ) (( ) ) ( ( ) )\") == [\"()\", \"(())\", \"(())\"]\n    @test separate_paren_groups(\"\
    ( ( ( ) ) )\") == [\"((()))\"]\n    @test separate_paren_groups(\"((((( )))(((((\
    \ ))))))\") == [\"((((( )))))\", \"((((( )))))\"]\n    @test separate_paren_groups(\"\
    ( ( ( ) (( )) ) )\") == [\"(((()(()))))\"]\n    @test separate_paren_groups(\"\
    ( ( ( ) (( )) (( )) ) )\") == [\"(((()(())(()))))\"]\n    @test separate_paren_groups(\"\
    ( ( ( ) (( (( )) )) ) )\") == [\"(((()(((()))))))\"]\n    @test separate_paren_groups(\"\
    ( ( ( ) (( (( (( (( (( )) ((( )) ) ) ) ) (( (( (( (( )) ) ) ) ) ) ) )) )) ) )\
    \ )\") == [\"(((()((((((((((((((((())))))))(((((((((((((()))))))))))))))))))))))\"\
    ]\nend\n \n \n \n\"\"\" Your task is to implement an autocomplete feature for\
    \ an input field.\n    You will be given a dictionary of words, and a query string.\n\
    \    You should return a list of words that start with the query string,\n   \
    \ and are the shortest possible completions. (If there are multiple words that\
    \ match,\n    return the word that would appear first in the dictionary.)\n \n\
    \    Note: You should match from the beginning of the string,\n    rather than\
    \ anywhere in the string.\n \n    >>> complete(\"abc\", [\"abce\", \"abcd\", \"\
    abcde\", \"abcdef\"])\n    [\"abcd\", \"abce\"]\n    >>> complete(\"abc\", [\"\
    abce\", \"abcd\", \"\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: UndefVarError: @testset not defined

    in expression starting at /tmp/tmp2eqjcbad.jl:15

    in expression starting at /tmp/tmp2eqjcbad.jl:15

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, r\"\\s\", \"\")\n    paren_groups\
    \ = []\n    start = 1\n    i = 1\n    while i <= length(paren_string)\n      \
    \  if paren_string[i] == '('\n            push!(paren_groups, paren_string[start:i])\n\
    \            start = i\n        elseif paren_string[i] == ')'\n            push!(paren_groups,\
    \ paren_string[start:i])\n            start = i + 1\n        end\n        i +=\
    \ 1\n    end\n    # here we want to iterate over paren_groups and delete the empty\
    \ strings\n    # this is a compact way to do that in Julia\n    # http://stackoverflow.com/questions/20344932/python-delete-empty-strings-from-a-list-of-strings\n\
    \    paren_groups = [x for x in paren_groups if x != \"\"]\n    return paren_groups\n\
    end\nseparate_paren_groups(\"( ) (( )) (( )( ))\")\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: MethodError: no method matching replace(::String, ::Regex,\
    \ ::String)\nClosest candidates are:\n  replace(!Matched::Union{Function, Type},\
    \ ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n \
    \ replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \  replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \  ...\nStacktrace:\n [1] separate_paren_groups(paren_string::String)\n   @ Main\
    \ /tmp/tmp1zum70hk.jl:9\n [2] top-level scope\n   @ /tmp/tmp1zum70hk.jl:29\nin\
    \ expression starting at /tmp/tmp1zum70hk.jl:29\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    output = []\n    temp = \"\"\n    open_paren = 0\n\
    \    close_paren = 0\n    for i in paren_string\n        if i != \" \"\n     \
    \       if i == \"(\"\n                open_paren += 1\n            else\n   \
    \             close_paren += 1\n            end\n            temp *= i\n     \
    \   end\n        if open_paren == close_paren\n            push!(output, temp)\n\
    \            temp = \"\"\n            open_paren = 0\n            close_paren\
    \ = 0\n        end\n    end\n    return output\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwrcgxgxt.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpwrcgxgxt.jl:37\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwrcgxgxt.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwrcgxgxt.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpwrcgxgxt.jl:38\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwrcgxgxt.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwrcgxgxt.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpwrcgxgxt.jl:39\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwrcgxgxt.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwrcgxgxt.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpwrcgxgxt.jl:40\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwrcgxgxt.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = filter(x -> x != ' ', paren_string)\n    stack = ' '\n\
    \    prev = ' '\n    start = 1\n    stop = 1\n    res = Vector{String}()\n   \
    \ for i in 1:length(paren_string)\n        if paren_string[i] == '('\n       \
    \     if prev == ')'\n                push!(res, paren_string[start:stop])\n \
    \               start = i\n            end\n            push!(stack, '(')\n  \
    \      elseif paren_string[i] == ')'\n            pop!(stack)\n            if\
    \ isempty(stack)\n                stop = i\n            end\n        end\n   \
    \     prev = paren_string[i]\n    end\n    push!(res, paren_string[start:stop])\n\
    \    return res\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpcnemxwoj.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmpcnemxwoj.jl:38\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching push!(::Char, ::Char)\n\
    \  Closest candidates are:\n    push!(::Any, ::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpcnemxwoj.jl:21\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcnemxwoj.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcnemxwoj.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpcnemxwoj.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching push!(::Char, ::Char)\n  Closest\
    \ candidates are:\n    push!(::Any, ::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpcnemxwoj.jl:21\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcnemxwoj.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/jul"
- exit_code: -1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    results = []\n    current_string = \"\"\n    open_paren_count = 0\n  \
    \  close_paren_count = 0\n    for (i,c) in enumerate(paren_string)\n        if\
    \ c != ' '\n            current_string *= c\n            if c == '('\n       \
    \         open_paren_count += 1\n            elseif c == ')'\n               \
    \ close_paren_count += 1\n            end\n            if open_paren_count ==\
    \ close_paren_count\n                results *= current_string\n             \
    \   current_string = \"\"\n                open_paren_count = 0\n            \
    \    close_paren_count = 0\n            end\n        end\n    end\n    return\
    \ results\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmpk18ut43r.jl:36\n  Test threw
    exception\n  Expression: candidate("(()()) ((())) () ((())()())") == ["(()())",
    "((()))", "()", "((())()())"]\n  MethodError: no method matching *(::Vector{Any},
    ::String)\n  Closest candidates are:\n    *(::Any, ::Any, !Matched::Any, !Matched::Any...)
    at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\n    *(!Matched::Union{AbstractChar,
    AbstractString}, ::Union{AbstractChar, AbstractString}...) at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:260\n    *(::StridedVecOrMat,
    !Matched::LinearAlgebra.Adjoint{<:Any, <:LinearAlgebra.LQPackedQ}) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/lq.jl:266\n    ...\n  Stacktrace:\n   [1]
    separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpk18ut43r.jl:22\n   [2]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpk18ut43r.jl:36 [inlined]\n   [4]
    macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpk18ut43r.jl:35\n'''
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # what are your inputs, what is your output?\n    # your code here\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpmibyzzxx.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpmibyzzxx.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpmibyzzxx.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmibyzzxx.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmibyzzxx.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpmibyzzxx.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpmibyzzxx.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp8i_3c61e.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmp8i_3c61e.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp8i_3c61e.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8i_3c61e.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8i_3c61e.jl:15\ntest set:\
    \ Error During Test at /tmp/tmp8i_3c61e.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp8i_3c61e.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    current_group = \"\"\n    groups = []\n    current_parens = 0\n    for\
    \ c in paren_string\n        if c == '('\n            current_parens += 1\n  \
    \      elseif c == ')'\n            current_parens -= 1\n        end\n       \
    \ if current_parens == 0\n            push!(groups, current_group)\n         \
    \   current_group = \"\"\n        else\n            current_group *= c\n     \
    \   end\n    end\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp0mdzh7nz.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmp0mdzh7nz.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0mdzh7nz.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0mdzh7nz.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp0mdzh7nz.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \"\"\
    , \"(()\", \"\", \"((())\", \"\", \"(((()))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0mdzh7nz.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0mdzh7nz.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp0mdzh7nz.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()(())((()))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0mdzh7nz.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0mdzh7nz.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp0mdzh7nz.jl:35\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( \", \"\", \"(( )\"\
    , \"\", \"(( )( )\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0mdzh7nz.jl:35 [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    in_parens = false\n    paren_group = \"\"\n    paren_groups = []\n   \
    \ for c in paren_string\n        if c == '('\n            in_parens = true\n \
    \       elseif c == ')'\n            in_parens = false\n            push!(paren_groups,\
    \ paren_group)\n            paren_group = \"\"\n        elseif c != ' '\n    \
    \        if in_parens\n                paren_group *= c\n            end\n   \
    \     end\n    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpzr0m0gza.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpzr0m0gza.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\
    \ \"\", \"\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzr0m0gza.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzr0m0gza.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpzr0m0gza.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"\",\
    \ \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzr0m0gza.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzr0m0gza.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpzr0m0gza.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"\", \"\", \"\", \"\", \"\", \"\",\
    \ \"\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzr0m0gza.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzr0m0gza.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpzr0m0gza.jl:35\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \"\", \"\", \"\
    \", \"\", \"\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzr0m0gza.jl:35 [inline"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    i = 1\n    open = 0\n    result = String[]\n    to_remove = String[]\n\
    \    for c in paren_string\n        if c == '('\n            open += 1\n     \
    \   elseif c == ')'\n            open -= 1\n        elseif c == ' '\n        \
    \    push!(to_remove, i)\n        end\n        if open == 0\n            push!(result,\
    \ paren_string[1:i])\n            paren_string = paren_string[i+1:end]\n     \
    \       paren_string = replace(paren_string, to_remove, \"\")\n            i =\
    \ 1\n            open = 0\n            to_remove = String[]\n        else\n  \
    \          i += 1\n        end\n    end\n    return result\nend\nseparate_paren_groups(\"\
    ( ) (( )) (( )( ))\")\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: MethodError: Cannot `convert` an object of type Int64\
    \ to an object of type String\nClosest candidates are:\n  convert(::Type{String},\
    \ !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \  convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \  convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \  ...\nStacktrace:\n [1] push!(a::Vector{String}, item::Int64)\n   @ Base ./array.jl:994\n\
    \ [2] separate_paren_groups(paren_string::String)\n   @ Main /tmp/tmpojhu2iiy.jl:19\n\
    \ [3] top-level scope\n   @ /tmp/tmpojhu2iiy.jl:34\nin expression starting at\
    \ /tmp/tmpojhu2iiy.jl:34\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    groups = String[]\n\
    \    start = 1\n    i = 1\n    while i <= length(paren_string)\n        if paren_string[i]\
    \ == '('\n            start = i\n        elseif paren_string[i] == ')'\n     \
    \       push!(groups, paren_string[start:i])\n        end\n        i += 1\n  \
    \  end\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp_rqt8hem.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp_rqt8hem.jl:28\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"()\", \"()\", \"())\", \"()\", \"())\", \"()))\", \"()\",\
    \ \"()\", \"())\", \"()\", \"()\", \"())\"] == [\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_rqt8hem.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_rqt8hem.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp_rqt8hem.jl:29\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"()\"\
    , \"())\", \"()\", \"())\", \"()))\", \"()\", \"())\", \"()))\", \"())))\"] ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_rqt8hem.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_rqt8hem.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp_rqt8hem.jl:30\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"()\", \"()\", \"())\", \"()\", \"\
    ())\", \"()))\", \"())))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_rqt8hem.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_rqt8hem.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp_rqt8hem.jl:31\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"()\", \"())\"\
    , \"()\", \"()\", \"())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdl"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n  # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmprjtt0c2k.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmprjtt0c2k.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmprjtt0c2k.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprjtt0c2k.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprjtt0c2k.jl:15\ntest set:\
    \ Error During Test at /tmp/tmprjtt0c2k.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmprjtt0c2k.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    s=split(paren_string, \" \")\n    v=[]\n    for i in s\n        if i!=\"\
    \"\n            push!(v, i)\n        end\n    end\n    v\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpes3ydz1t.jl:20

    '
  stdout: "test set: Test Failed at /tmp/tmpes3ydz1t.jl:26\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"(\"\
    , \")\", \"((\", \"))\", \"((\", \")(\", \"))\"] == [\"()\", \"(())\", \"(()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpes3ydz1t.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpes3ydz1t.jl:22\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     1      4\n"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # ...\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmprrzc4fkq.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmprrzc4fkq.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmprrzc4fkq.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprrzc4fkq.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprrzc4fkq.jl:15\ntest set:\
    \ Error During Test at /tmp/tmprrzc4fkq.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmprrzc4fkq.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_vec = split(strip(paren_string))\n    i = 0\n    new_vec = []\n\
    \    while i <= length(paren_vec)\n        if length(paren_vec[i]) > 1\n     \
    \       if get(paren_vec[i], 2) == '('\n                if get(paren_vec[i], end)\
    \ == ')'\n                    push!(new_vec, join(paren_vec[i], ''))\n       \
    \         elseif get(paren_vec[i], 3) == '('\n                    j = i\n    \
    \                while j < length(paren_vec)\n                        if get(paren_vec[j],\
    \ end) == ')'\n                            push!(new_vec, join(paren_vec[i:j],\
    \ ''))\n                            i = j\n                            break\n\
    \                        end\n                        j += 1\n               \
    \     end\n                end\n            end\n        else\n            if\
    \ get(paren_vec[i], 1) == '('\n                if get(paren_vec[i], end) == ')'\n\
    \                    push!(new_vec, join(paren_vec[i], ''))\n                elseif\
    \ get(paren_vec[i+1], 1) == '('\n                    j = i\n                 \
    \   while j < length(paren_vec)\n                        if get(paren_vec[j],\
    \ end) == ')'\n                            push!(new_vec, join(paren_vec[i:j],\
    \ ''))\n                            i = j\n                            break\n\
    \                        end\n                        j += 1\n               \
    \     end\n                end\n            end\n        end\n        i += 1\n\
    \    end\n    return new_vec\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"end\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpo_3je_11.jl:15\nin expression starting at /tmp/tmpo_3je_11.jl:15\n"
  stdout: ''
  timestamp: 1659979115
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = [c for c in paren_string if c != ' ']\n    paren_string\
    \ = paren_string .* join([\"(\", \")\"])\n    return [j for j in [join(split(i,\
    \ \")(\")[j]) for j in 1:2] if length(j) > 0]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp5m4zv62o.jl:15

    '
  stdout: "test set: Error During Test at /tmp/tmp5m4zv62o.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: i not defined\n  Stacktrace:\n   [1]\
    \ (::var\"#3#6\")(j::Int64)\n     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47\
    \ [inlined]\n   [3] collect(itr::Base.Generator{UnitRange{Int64}, var\"#3#6\"\
    })\n     @ Base ./array.jl:724\n   [4] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp5m4zv62o.jl:11\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp5m4zv62o.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp5m4zv62o.jl:17\ntest set:\
    \ Error During Test at /tmp/tmp5m4zv62o.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: i not defined\n  Stacktrace:\n   [1] (::var\"#3#6\"\
    )(j::Int64)\n     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n\
    \   [3] collect(itr::Base.Generator{UnitRange{Int64}, var\"#3#6\"})\n     @ Base\
    \ ./array.jl:724\n   [4] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmp5m4zv62o.jl:11\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp5m4zv62o.jl:19 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp5m4zv62o.jl:17\ntest set:\
    \ Error During Test at /tmp/tmp5m4zv62o.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: i not\
    \ defined\n  Stacktrace:\n   [1] (::var\"#3#6\")(j::Int64)\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{UnitRange{Int64},\
    \ var\"#3#6\"})\n     @ Base ./array.jl:724\n   [4] s"
  timestamp: 1659979117
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpztmwi7bd.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpztmwi7bd.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpztmwi7bd.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpztmwi7bd.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpztmwi7bd.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpztmwi7bd.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpztmwi7bd.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659979118
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_groups\
    \ = String[]\n    group = String[]\n    sum = 0\n    for (i, char) in enumerate(paren_string)\n\
    \        if char == '('\n            sum += 1\n        elseif char == ')'\n  \
    \          sum -= 1\n        end\n        push!(group, char)\n        if sum ==\
    \ 0\n            push!(paren_groups, join(group, \"\"))\n            group = String[]\n\
    \        end\n    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpdb8eocir.jl:29

    '
  stdout: "test set: Error During Test at /tmp/tmpdb8eocir.jl:32\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Char\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{String}, item::Char)\n     @ Base\
    \ ./array.jl:994\n   [2] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmpdb8eocir.jl:19\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpdb8eocir.jl:32 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpdb8eocir.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpdb8eocir.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Char to an object\
    \ of type String\n  Closest candidates are:\n    convert(::Type{String}, !Matched::String)\
    \ at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{String}, item::Char)\n     @ Base\
    \ ./array.jl:994\n   [2] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmpdb8eocir.jl:19\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/"
  timestamp: 1659979118
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = paren_string \n    paren_string = replace(paren_string,r\"\
    \\s+\"=>\"\")\n    paren_string = replace(paren_string,r\"\\s+\"=>\"\")\n    paren_string\
    \ = replace(paren_string,r\"(\\(\\))+\"=>\",\")\n    paren_string = split(paren_string,\
    \ \",\")\n    return paren_string\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpq4r8sepf.jl:18

    '
  stdout: "test set: Test Failed at /tmp/tmpq4r8sepf.jl:21\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(\", \")((\", \"))\", \"((\", \")\", \")\"] == [\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpq4r8sepf.jl:21 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpq4r8sepf.jl:20\ntest set: Test Failed at /tmp/tmpq4r8sepf.jl:22\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"(\", \")((\", \"))(((\", \")))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpq4r8sepf.jl:22 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpq4r8sepf.jl:20\ntest set: Test Failed at /tmp/tmpq4r8sepf.jl:23\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"(\", \"(\", \")((\", \")))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq4r8sepf.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq4r8sepf.jl:20\ntest set: Test\
    \ Failed at /tmp/tmpq4r8sepf.jl:24\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \"(\", \")(\"\
    , \")\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpq4r8sepf.jl:24 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1659979116
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_brackets = 0 \n    open_brackets_index = 0 \n    close_brackets_index\
    \ = 0 \n    paren_groups = [] \n    inside_paren_group = false\n    for i in eachindex(paren_string)\n\
    \        if paren_string[i] == '('\n            open_brackets_index = i\n    \
    \        open_brackets += 1\n            inside_paren_group = true\n        elseif\
    \ paren_string[i] == ')'\n            open_brackets -= 1\n            if open_brackets\
    \ == 0\n                close_brackets_index = i\n                inside_paren_group\
    \ = false\n                push!(paren_groups, paren_string[open_brackets_index:close_brackets_index])\n\
    \            end\n        end\n    end\n    return paren_groups\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmppj7040s6.jl:32

    '
  stdout: "test set: Test Failed at /tmp/tmppj7040s6.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"())\", \"()))\", \"()\", \"())\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppj7040s6.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppj7040s6.jl:34\ntest set: Test\
    \ Failed at /tmp/tmppj7040s6.jl:36\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"())\"\
    , \"()))\", \"())))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppj7040s6.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppj7040s6.jl:34\ntest set: Test\
    \ Failed at /tmp/tmppj7040s6.jl:37\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"())))\"] == [\"(()(())((())))\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppj7040s6.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppj7040s6.jl:34\ntest set: Test\
    \ Failed at /tmp/tmppj7040s6.jl:38\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \"( ))\", \"\
    ( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppj7040s6.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/"
  timestamp: 1659979116
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    all_opened = findall(paren_string, \"\\\\(\")\n    all_closed = findall(paren_string,\
    \ \"\\\\)\")\n    groups = []\n    current_group = \"\"\n    curr_opened = 0\n\
    \    curr_closed = 0\n    for char in paren_string\n        if char == '('\n \
    \           curr_opened += 1\n        elseif char == ')'\n            curr_closed\
    \ += 1\n        end\n        current_group *= char\n        if (curr_opened ==\
    \ curr_closed) && curr_opened != 0\n            push!(groups, current_group)\n\
    \            current_group = \"\"\n            curr_opened = 0\n            curr_closed\
    \ = 0\n        end\n    end\n    return groups\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8o5wuhu3.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmp8o5wuhu3.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"] == [\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8o5wuhu3.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8o5wuhu3.jl:35\ntest set: Test Failed at /tmp/tmp8o5wuhu3.jl:37\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" (())\", \" ((()))\", \" (((())))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8o5wuhu3.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8o5wuhu3.jl:35\ntest set: Test Failed at /tmp/tmp8o5wuhu3.jl:39\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"( )\", \" (( ))\", \" (( )( ))\"] == [\"()\", \"(())\", \"\
    (()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8o5wuhu3.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8o5wuhu3.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979116
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    res = String[]\n\
    \    p = 1\n    p_last = 1\n    for i in 1:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            p += 1\n        elseif paren_string[i] == ')'\n        \
    \    p -= 1\n        end\n        if p == 0\n            push!(res, paren_string[p_last:i])\n\
    \            p = 1\n            p_last = i + 1\n        end\n    end\n    return\
    \ res\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmph_1owlr_.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmph_1owlr_.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph_1owlr_.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph_1owlr_.jl:31\ntest set: Test\
    \ Failed at /tmp/tmph_1owlr_.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmph_1owlr_.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmph_1owlr_.jl:31\ntest set: Test Failed at /tmp/tmph_1owlr_.jl:34\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph_1owlr_.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph_1owlr_.jl:31\ntest set: Test\
    \ Failed at /tmp/tmph_1owlr_.jl:35\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph_1owlr_.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph"
  timestamp: 1659979116
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    @assert paren_string != \"\"\n    groups = Vector{String}()\n    current_group\
    \ = \"\"\n    paren_count = 0\n    is_group_started = false\n    for ch in paren_string\n\
    \        if ch == ' '\n            continue\n        end\n        if ch == '('\n\
    \            paren_count += 1\n            is_group_started = true\n        elseif\
    \ ch == ')'\n            paren_count -= 1\n        end\n        if paren_count\
    \ > 0\n            current_group *= ch\n        elseif paren_count == 0\n    \
    \        push!(groups, current_group)\n            current_group = \"\"\n    \
    \        is_group_started = false\n        else\n            error(\"Parentheses\
    \ mismatch. More closing than opening parentheses\")\n        end\n    end\n \
    \   if is_group_started\n        error(\"Error: some opening parentheses are missing\
    \ a closing parentheses\")\n    end\n    return groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpd3i2ut3_.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmpd3i2ut3_.jl:44\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()\", \"((())\", \"(\", \"((())()()\"] == [\"(()())\",\
    \ \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpd3i2ut3_.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpd3i2ut3_.jl:43\ntest set: Test Failed at /tmp/tmpd3i2ut3_.jl:45\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \"(()\", \"((())\", \"(((()))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpd3i2ut3_.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpd3i2ut3_.jl:43\ntest set: Test Failed at /tmp/tmpd3i2ut3_.jl:46\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"(()(())((()))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpd3i2ut3_.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpd3i2ut3_.jl:43\ntest set: Test Failed at /tmp/tmpd3i2ut3_.jl:47\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"(\", \"(()\", \"(()()\"] == [\"()\", \"(())\", \"(()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd3i2ut3_.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdli"
  timestamp: 1659979116
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    openers = [\"(\"]\n    closers = [\")\"]\n    groups = []\n    current_group\
    \ = \"\"\n    paren_string = replace(paren_string, \" \" => \"\")\n    for c in\
    \ paren_string\n        if c in openers\n            push!(current_group, c)\n\
    \        elseif c in closers\n            push!(current_group, c)\n          \
    \  if is_balanced(current_group)\n                push!(groups, current_group)\n\
    \                current_group = \"\"\n            end\n        end\n    end\n\
    \    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp0g8kchck.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmp0g8kchck.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0g8kchck.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0g8kchck.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp0g8kchck.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0g8kchck.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0g8kchck.jl:31\ntest set: Test Failed at /tmp/tmp0g8kchck.jl:34\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0g8kchck.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0g8kchck.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp0g8kchck.jl:35\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0g8kchck.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0"
  timestamp: 1659979116
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # This vector will be populated with the answers to the problem\n    answer\
    \ = []\n    # We need to keep track of the current parentheses stack\n    paren_stack\
    \ = Stack()\n    # The current string we are building\n    current_string = \"\
    \"\n    # Loop through the input string\n    for character in paren_string\n \
    \       # If it is an open parenthesis, push onto the stack\n        if character\
    \ == '('\n            push!(paren_stack, character)\n        # If it is a close\
    \ parenthesis, pop off the stack, add it to the current string\n        elseif\
    \ character == ')'\n            pop!(paren_stack)\n            current_string\
    \ *= character\n        # If it is a space, do nothing\n        elseif character\
    \ == ' '\n            continue\n        # If it is not a space or a parenthesis,\
    \ add it to the current string\n        else\n            current_string *= character\n\
    \        end\n        # Once we have popped off the same number of parentheses\
    \ as we have pushed on, we know we are done with\n        # this string.\n   \
    \     if empty!(paren_stack)\n            push!(answer, current_string)\n    \
    \        current_string = \"\"\n        end\n    end\n    return answer\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpkxw6izw0.jl:42

    '
  stdout: "test set: Error During Test at /tmp/tmpkxw6izw0.jl:45\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: Stack not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpkxw6izw0.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkxw6izw0.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkxw6izw0.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpkxw6izw0.jl:46\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: Stack not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpkxw6izw0.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkxw6izw0.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkxw6izw0.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpkxw6izw0.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: Stack\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpkxw6izw0.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkxw6izw0.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkxw6izw0.jl:44\ntest set:\
    \ Error During Test at /tmp/tmpkxw6izw0.jl:48\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  UndefV"
  timestamp: 1659979117
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open = 0\n    close = 0\n    parens = []\n    words = []\n    for i in\
    \ 1:length(paren_string)\n        if paren_string[i] == '('\n            open\
    \ += 1\n        elseif paren_string[i] == ')'\n            close += 1\n      \
    \  end\n        push!(parens, paren_string[i])\n        if open == close\n   \
    \         push!(words, join(parens))\n            parens = []\n            open\
    \ = 0\n            close = 0\n        end\n    end\n    return words\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp6dv9z8b5.jl:31

    '
  stdout: "test set: Test Failed at /tmp/tmp6dv9z8b5.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6dv9z8b5.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6dv9z8b5.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp6dv9z8b5.jl:35\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" \"\
    , \"(())\", \" \", \"((()))\", \" \", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6dv9z8b5.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6dv9z8b5.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp6dv9z8b5.jl:37\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \" \", \"((\
    \ ))\", \" \", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6dv9z8b5.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6dv9z8b5.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979116
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Start with a list of strings\n    # If we get a '(' then append to the\
    \ current string\n    # If we get a ')' then append to the current string and\
    \ pop to the output list\n    # If we get a space then do nothing\n    # If we\
    \ get something else, throw an error\n    # We assume balanced strings (and no\
    \ nested groups)\n    # This is not a very efficient implementation (uses recursion),\
    \ but it's easy to understand\n    current_string = \"\"\n    output_list = []\n\
    \    for (i,c) in enumerate(paren_string)\n        if c == '('\n            current_string\
    \ *= c\n        elseif c == ')'\n            current_string *= c\n           \
    \ push!(output_list,current_string)\n            current_string = \"\"\n     \
    \   elseif c == ' '\n            continue\n        else\n            error(\"\
    Unexpected character \\\"$c\\\" in string.\\n\\\"$paren_string\\\"\")\n      \
    \  end\n    end\n    return output_list\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqjtf3fyw.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmpqjtf3fyw.jl:38\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"()\", \")\", \"((()\", \")\", \")\", \"()\", \"((()\"\
    , \")\", \"()\", \"()\", \")\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqjtf3fyw.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqjtf3fyw.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpqjtf3fyw.jl:39\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(()\"\
    , \")\", \"((()\", \")\", \")\", \"(((()\", \")\", \")\", \")\"] == [\"()\", \"\
    (())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqjtf3fyw.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqjtf3fyw.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpqjtf3fyw.jl:40\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"(()\", \")\", \"((()\", \"\
    )\", \")\", \")\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqjtf3fyw.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqjtf3fyw.jl:37\ntest set: Test Failed at /tmp/tmpqjtf3fyw.jl:41\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"()\", \"(()\", \")\", \"(()\", \"()\", \")\"] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n"
  timestamp: 1659979116
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = replace(paren_string, r\"\\s+\"=>\"\
    \")\n    groups = matchall(r\"\\(.*?\\)\", paren_string)\n    return [x.match\
    \ for x in groups]\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpqltuzw3v.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmpqltuzw3v.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: matchall not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpqltuzw3v.jl:11\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqltuzw3v.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqltuzw3v.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpqltuzw3v.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: matchall not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpqltuzw3v.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqltuzw3v.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqltuzw3v.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpqltuzw3v.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: matchall\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpqltuzw3v.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqltuzw3v.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqltuzw3v.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpqltuzw3v.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]"
  timestamp: 1659979117
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    #Delete Spaces\n    paren_string = delete(paren_string,\
    \ \" \")\n    #temp string\n    s_string = \"\"\n    #output vector\n    s_vector\
    \ = []\n    #Open Close Variables\n    o, c = 0, 0\n    #iterate through input\
    \ string\n    for c in paren_string\n        #check if the char is a open paren\n\
    \        if c == '('\n            #increment open paren counter\n            o\
    \ += 1\n        #check if the char is a close paren\n        elseif c == ')'\n\
    \            #increment close paren counter\n            c += 1\n        end\n\
    \        #push the char to temp string\n        push!(s_string, c)\n        #check\
    \ if open paren counter equals close paren counter\n        if o == c\n      \
    \      #push temp string to output vector\n            push!(s_vector, s_string)\n\
    \            #reset counters\n            o, c = 0, 0\n            #reset temp\
    \ string\n            s_string = \"\"\n        end\n    end\n    #return output\
    \ vector\n    return s_vector\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpikbvvyn4.jl:46

    '
  stdout: "test set: Error During Test at /tmp/tmpikbvvyn4.jl:49\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: delete not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpikbvvyn4.jl:11\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpikbvvyn4.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpikbvvyn4.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpikbvvyn4.jl:50\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: delete not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpikbvvyn4.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpikbvvyn4.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpikbvvyn4.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpikbvvyn4.jl:51\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: delete\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpikbvvyn4.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpikbvvyn4.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpikbvvyn4.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpikbvvyn4.jl:52\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  Und"
  timestamp: 1659979117
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    temp = []\n    result = []\n    for c in paren_string\n        if c ==\
    \ '('\n            push!(temp, c)\n        elseif c == ')'\n            pop!(temp)\n\
    \            if isempty(temp)\n                push!(result, join(temp, \"\"))\n\
    \                temp = []\n            end\n        end\n    end\n    return\
    \ result\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp0z60tjz9.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmp0z60tjz9.jl:29\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"\", \"\", \"\", \"\"] == [\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0z60tjz9.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0z60tjz9.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp0z60tjz9.jl:30\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"\",\
    \ \"\", \"\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0z60tjz9.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0z60tjz9.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp0z60tjz9.jl:31\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"\"] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0z60tjz9.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0z60tjz9.jl:28\ntest set: Test\
    \ Failed at /tmp/tmp0z60tjz9.jl:32\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \"\", \"\"] ==\
    \ [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0z60tjz9.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scop"
  timestamp: 1659979116
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpn248n4t0.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpn248n4t0.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpn248n4t0.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpn248n4t0.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpn248n4t0.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpn248n4t0.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpn248n4t0.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659979118
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # we will use a stack to keep track of groups we need to separate\n  \
    \  open_paren_stack = Stack{String}(undef, 0)\n    # this will hold the groups\n\
    \    groups = Vector{String}(undef, 0)\n    for c in paren_string\n        # if\
    \ the current character is an open paren, push it to the stack\n        if c ==\
    \ '('\n            push!(open_paren_stack, string(c))\n        # if its a closed\
    \ paren, we know it belongs to the last group in the stack\n        elseif c ==\
    \ ')'\n            group = pop!(open_paren_stack)\n            push!(group, c)\n\
    \            push!(groups, group)\n        end\n    end\n    # groups with matching\
    \ open and closed parens are in the vector\n    return groups\nend\nseparate_paren_groups(\"\
    ( ) (( )) (( )( ))\")\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: UndefVarError: Stack not defined\nStacktrace:\n [1] separate_paren_groups(paren_string::String)\n\
    \   @ Main /tmp/tmp54r8mkqp.jl:10\n [2] top-level scope\n   @ /tmp/tmp54r8mkqp.jl:27\n\
    in expression starting at /tmp/tmp54r8mkqp.jl:27\n"
  stdout: ''
  timestamp: 1659979116
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    #TODO: your code here\n    return [\" () \", \" (()) \", \" (()()) \"\
    ]\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t\
    @test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpjnpyg3ot.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpjnpyg3ot.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\" () \", \" (()) \", \" (()()) \"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjnpyg3ot.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjnpyg3ot.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjnpyg3ot.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\" () \", \"\
    \ (()) \", \" (()()) \"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjnpyg3ot.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjnpyg3ot.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjnpyg3ot.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\" () \", \" (()) \", \" (()()) \"]\
    \ == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjnpyg3ot.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjnpyg3ot.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjnpyg3ot.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\" () \", \" (()) \"\
    , \" (()()) \"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpjnpyg3ot.jl:20 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/sha"
  timestamp: 1659979116
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    start = 1\n    end = 1\n    res = []\n    tmp = \"\"\n    while end <=\
    \ length(paren_string)\n        while paren_string[end] == ' '\n            end\
    \ += 1\n        end\n        tmp = paren_string[start:end]\n        while end\
    \ <= length(paren_string) && paren_string[end] != ' '\n            tmp = paren_string[start:end]\n\
    \            end += 1\n        end\n        res = [res; tmp]\n        start =\
    \ end\n    end\n    res\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid assignment location \"function separate_paren_groups(paren_string::String)::Vector{String}\n\
    \    # /tmp/tmps0zar_9v.jl, line 8\n    # /tmp/tmps0zar_9v.jl, line 9\n    start\
    \ = 1\nend\" around /tmp/tmps0zar_9v.jl:1\nStacktrace:\n [1] top-level scope\n\
    \   @ /tmp/tmps0zar_9v.jl:1\nin expression starting at /tmp/tmps0zar_9v.jl:1\n"
  stdout: ''
  timestamp: 1659979115
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_stack = [] # We use a stack to keep track of which groups we have\
    \ encountered\n    group_size = 0\n    return_vec = []\n    for i in 1:length(paren_string)\n\
    \        char = paren_string[i]\n        if char == '('\n            push!(paren_stack,\
    \ char)\n            group_size += 1\n        elseif char == ')'\n           \
    \ if length(paren_stack) == 0\n                error(\"Encountered mismatched\
    \ parentheses\")\n            end\n            pop!(paren_stack)\n           \
    \ group_size += 1\n        elseif char == ' '\n            if length(paren_stack)\
    \ == 0 && group_size > 0\n                push!(return_vec, paren_string[i-group_size+1:i-1])\n\
    \                group_size = 0\n            end\n        end\n    end\n    return\
    \ return_vec\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpu6abkdte.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpu6abkdte.jl:37\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"()())\", \"(()))\", \")\"] == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu6abkdte.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu6abkdte.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpu6abkdte.jl:38\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\")\", \"())\"\
    , \"(()))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu6abkdte.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu6abkdte.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpu6abkdte.jl:39\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu6abkdte.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu6abkdte.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpu6abkdte.jl:40\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\")\", \" ))\"] == [\"\
    ()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu6abkdte.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4"
  timestamp: 1659979116
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    count = 0\n    temp = \"\"\n    index = 1\n    token = Vector{String}()\n\
    \    for i in paren_string\n        if i == '('\n            count = count + 1\n\
    \        elseif i == ')'\n            count = count - 1\n        end\n       \
    \ if count == 0 && i == ' '\n            token[index] = temp\n            index\
    \ = index + 1\n            temp = \"\"\n        elseif count == 0 && i != ' '\n\
    \            token[index] = temp\n            index = index + 1\n            temp\
    \ = \"\"\n        else\n            temp = temp * i\n        end\n    end\n  \
    \  return token\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp4083sty0.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmp4083sty0.jl:38\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  BoundsError: attempt to access 0-element Vector{String}\
    \ at index [1]\n  Stacktrace:\n   [1] setindex!\n     @ ./array.jl:903 [inlined]\n\
    \   [2] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmp4083sty0.jl:24\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4083sty0.jl:38 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp4083sty0.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp4083sty0.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  BoundsError: attempt to access 0-element Vector{String} at index\
    \ [1]\n  Stacktrace:\n   [1] setindex!\n     @ ./array.jl:903 [inlined]\n   [2]\
    \ separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmp4083sty0.jl:24\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4083sty0.jl:39 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp4083sty0.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp4083sty0.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  BoundsError: attempt\
    \ to access 0-element Vector{String} at index [1]\n  Stacktrace:\n   [1] setindex!\n\
    \     @ ./array.jl:903 [inlined]\n   [2] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp4083sty0.jl:24\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4083sty0.jl:40 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1659979117
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    #raise NotImplementedError()\n    paren = \"\"\n\
    \    final_list = []\n    count = 0\n    for i = 1:length(paren_string)\n    \
    \    if paren_string[i] != ' '\n            paren = string(paren,paren_string[i])\n\
    \        end\n        if paren_string[i] == '('\n            count += 1\n    \
    \    end\n        if paren_string[i] == ')'\n            count -= 1\n        end\n\
    \        if count == 0\n            push!(final_list,paren)\n            paren\
    \ = \"\"\n        end\n    end\n    return final_list\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpaxu_ijcq.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmpaxu_ijcq.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpaxu_ijcq.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaxu_ijcq.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpaxu_ijcq.jl:37\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"\"\
    , \"(())\", \"\", \"((()))\", \"\", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpaxu_ijcq.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaxu_ijcq.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpaxu_ijcq.jl:39\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"\", \"(())\"\
    , \"\", \"(()())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpaxu_ijcq.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaxu_ijcq.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979116
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    group_strings = []\n    group_string = \"\"\n    group_count = 0\n   \
    \ for letter in paren_string\n        if letter == '('\n            group_count\
    \ += 1\n            group_string = group_string * letter\n        elseif letter\
    \ == ')'\n            group_count -= 1\n            group_string = group_string\
    \ * letter\n        end\n        if group_count == 0 && length(group_string) >\
    \ 0\n            push!(group_strings, group_string)\n            group_string\
    \ = \"\"\n        end\n    end\n    return group_strings\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659979116
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\" Separate groups are balanced (each open brace is properly closed)\
    \ and not nested within each other. \n        Ignore any spaces in the input string.\
    \ \"\"\"\n    vector_paren_string = split(paren_string, \" \")\n    vector_paren_string\
    \ = join(vector_paren_string, \"\")\n    vectors_paren = []\n    current_paren\
    \ = \"\"\n    current_open_paren = 0\n    current_close_paren = 0\n    for i in\
    \ 1:length(vector_paren_string)\n        if vector_paren_string[i] == \"(\"\n\
    \            current_open_paren += 1\n        elseif vector_paren_string[i] ==\
    \ \")\"\n            current_close_paren += 1\n        end\n        current_paren\
    \ = current_paren * vector_paren_string[i]\n        if current_open_paren == current_close_paren\n\
    \            push!(vectors_paren, current_paren)\n            current_paren =\
    \ \"\"\n            current_open_paren = 0\n            current_close_paren =\
    \ 0\n        end\n    end\n    return vectors_paren\nend\nseparate_paren_groups(\"\
    ( ) (( )) (( )( ))\")\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmppl8mxbed.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmppl8mxbed.jl:39\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(\", \"(\", \")\", \"(\", \")\", \")\", \"(\", \"(\", \"(\"\
    , \")\"  \u2026  \"(\", \"(\", \"(\", \")\", \")\", \"(\", \")\", \"(\", \")\"\
    , \")\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppl8mxbed.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppl8mxbed.jl:38\ntest set: Test\
    \ Failed at /tmp/tmppl8mxbed.jl:40\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \")\"\
    , \"(\", \"(\", \")\", \")\", \"(\", \"(\", \"(\", \")\", \")\", \")\", \"(\"\
    , \"(\", \"(\", \"(\", \")\", \")\", \")\", \")\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppl8mxbed.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppl8mxbed.jl:38\ntest set: Test\
    \ Failed at /tmp/tmppl8mxbed.jl:41\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(\", \"(\", \")\", \"(\", \"(\", \"\
    )\", \")\", \"(\", \"(\", \"(\", \")\", \")\", \")\", \")\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppl8mxbed.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppl8mxbed.jl:38\ntest set: Test\
    \ Failed at /tmp/tmppl8mxbed.jl:42\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"(\", \")\", \"(\"\
    , \"(\", \")\", \")\", \"(\", \"(\", \")\", \"(\", \")\", \")\"] == [\"()\", \"\
    (())\", \"(()())\"]\nStacktrace:\n ["
  timestamp: 1659979118
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    open_count =\
    \ 0\n    closed_count = 0\n    str = \"\"\n    group_vec = []\n    for c in paren_string\n\
    \        if c == '('\n            open_count += 1\n        elseif c == ')'\n \
    \           closed_count += 1\n        end\n        str = str * c\n        if\
    \ open_count == closed_count\n            push!(group_vec, str)\n            str\
    \ = \"\"\n            open_count = 0\n            closed_count = 0\n        end\n\
    \    end\n    return group_vec\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659979116
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    return [x for x in split(join(replace(paren_string, \" \", \"\"),\")\"\
    ), \")\") if x != \"\"]\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpxtanv9l3.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpxtanv9l3.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching replace(::String,\
    \ ::String, ::String)\n  Closest candidates are:\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpxtanv9l3.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxtanv9l3.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxtanv9l3.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpxtanv9l3.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching replace(::String, ::String, ::String)\n\
    \  Closest candidates are:\n    replace(!Matched::Union{Function, Type}, ::Any;\
    \ count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n    replace(::String,\
    \ !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpxtanv9l3.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxtanv9l3.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te"
  timestamp: 1659979120
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    for i in eachindex(paren_string)\n        if (paren_string[i]=='(')\n\
    \            if (paren_string[i]==')')\n                return []\n          \
    \  end\n        end\n    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp27_x0wv2.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp27_x0wv2.jl:1\n\
    in expression starting at /tmp/tmp27_x0wv2.jl:1\n"
  stdout: ''
  timestamp: 1659979118
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpt4xggxyp.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpt4xggxyp.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpt4xggxyp.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt4xggxyp.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt4xggxyp.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpt4xggxyp.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpt4xggxyp.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659979121
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Write the function\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp6ra1euww.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmp6ra1euww.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp6ra1euww.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6ra1euww.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6ra1euww.jl:15\ntest set:\
    \ Error During Test at /tmp/tmp6ra1euww.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp6ra1euww.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659979120
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\n    ret=Vector{String}(undef,0)\n\
    \    start=0\n    for i=1:length(paren_string)\n        if paren_string[i]=='('\n\
    \            start=i\n        elseif paren_string[i]==')'\n            push!(ret,paren_string[start:i])\n\
    \        end\n    end\n    return ret\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpdseov1by.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpdseov1by.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"()\", \"()\", \"())\", \"()\", \"())\", \"()))\", \"()\",\
    \ \"()\", \"())\", \"()\", \"()\", \"())\"] == [\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdseov1by.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdseov1by.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpdseov1by.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"()\"\
    , \"())\", \"()\", \"())\", \"()))\", \"()\", \"())\", \"()))\", \"())))\"] ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdseov1by.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdseov1by.jl:31\ntest set: Test Failed at /tmp/tmpdseov1by.jl:34\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"()\", \"()\", \"())\", \"()\", \"())\", \"()))\", \"())))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdseov1by.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdseov1by.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpdseov1by.jl:35\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \"( )\", \"\
    ( ))\", \"( )\", \"( )\", \"( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 "
  timestamp: 1659979119
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = replace(paren_string, r\"\\s+\",\
    \ \"\")\n    n = length(paren_string)\n    paren_stack = Char[]\n    paren_groups\
    \ = Vector{String}()\n    # println(paren_string)\n    for i in 1:n\n        #\
    \ println(i)\n        if paren_string[i] == '('\n            push!(paren_stack,\
    \ '(')\n        elseif paren_string[i] == ')'\n            if length(paren_stack)\
    \ == 0\n                continue\n            else\n                push!(paren_stack,\
    \ ')')\n                if length(paren_stack) == 2 && isempty(findall(x -> x\
    \ == '(', paren_stack)) == false\n                    push!(paren_groups, join(reverse(paren_stack)))\n\
    \                    # println(paren_groups)\n                    paren_stack\
    \ = Char[]\n                end\n            end\n        end\n    end\n    return\
    \ paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpm55b35f7.jl:36

    '
  stdout: "test set: Error During Test at /tmp/tmpm55b35f7.jl:39\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching replace(::String,\
    \ ::Regex, ::String)\n  Closest candidates are:\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpm55b35f7.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpm55b35f7.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpm55b35f7.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpm55b35f7.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching replace(::String, ::Regex, ::String)\n\
    \  Closest candidates are:\n    replace(!Matched::Union{Function, Type}, ::Any;\
    \ count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n    replace(::String,\
    \ !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpm55b35f7.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpm55b35f7.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te"
  timestamp: 1659979120
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_group = \"\"\n    paren_groups = []\n    nested_level = 0\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2k5ivp1d.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2k5ivp1d.jl:1\n\
    in expression starting at /tmp/tmp2k5ivp1d.jl:1\n"
  stdout: ''
  timestamp: 1659979118
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    ...\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid identifier name \"...\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5uf507c1.jl:9\nin expression starting at /tmp/tmp5uf507c1.jl:9\n"
  stdout: ''
  timestamp: 1659979118
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # separate the string into separate characters\n    chars = collect(paren_string)\n\
    \    char_len = length(chars)\n    # initialize the output string\n    output\
    \ = \"\"\n    # first, determine how many groups there are\n    num_groups = 0\n\
    \    for i in 1:char_len\n        if chars[i] == \"(\"\n            num_groups\
    \ += 1\n        end\n    end\n    # initialize a vector of strings to hold the\
    \ groups\n    groups = Vector{String}(num_groups)\n    # initialize the group\
    \ index\n    group_index = 1\n    # loop through the string again\n    for i in\
    \ 1:char_len\n        if chars[i] == \"(\"\n            # start a new group\n\
    \            output = \"\"\n        elseif chars[i] == \")\"\n            # end\
    \ the current group\n            groups[group_index] = output\n            group_index\
    \ += 1\n        elseif chars[i] == \" \"\n            # ignore spaces\n      \
    \  else\n            # add the character to the output string\n            output\
    \ = string(output, chars[i])\n        end\n    end\n    # return the groups\n\
    \    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpai9935xz.jl:46

    '
  stdout: "test set: Error During Test at /tmp/tmpai9935xz.jl:49\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching Vector{String}(::Int64)\n\
    \  Closest candidates are:\n    Vector{T}() where T at ~/.conda/envs/polyglot/share/julia/base/boot.jl:476\n\
    \    Array{T, N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at ~/.conda/envs/polyglot/share/julia/base/bitarray.jl:494\n\
    \    Vector{T}(!Matched::Core.Compiler.AbstractRange{T}) where T at ~/.conda/envs/polyglot/share/julia/base/range.jl:1286\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpai9935xz.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpai9935xz.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpai9935xz.jl:48\ntest set:\
    \ Error During Test at /tmp/tmpai9935xz.jl:50\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching Vector{String}(::Int64)\n  Closest\
    \ candidates are:\n    Vector{T}() where T at ~/.conda/envs/polyglot/share/julia/base/boot.jl:476\n\
    \    Array{T, N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at ~/.conda/envs/polyglot/share/julia/base/bitarray.jl:494\n\
    \    Vector{T}(!Matched::Core.Compiler.AbstractRange{T}) where T at ~/.conda/envs/polyglot/share/julia/base/range.jl:1286\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpai9935xz.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpai9935xz.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpai9935xz.jl:48\ntest"
  timestamp: 1659979120
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n \n     group_vector=Vector{String}() \n     # Stack of open braces\n    \
    \ stack=Vector{Char}()\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw5fumgdm.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw5fumgdm.jl:1\n\
    in expression starting at /tmp/tmpw5fumgdm.jl:1\n"
  stdout: ''
  timestamp: 1659979118
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = filter(isnumeric, paren_string)\n    groups = []\n    paren_stack\
    \ = Stack()\n    start_index = 1\n    for i in 1:length(paren_string)\n      \
    \  if paren_string[i] == '('\n            push!(paren_stack, paren_string[i])\n\
    \        elseif paren_string[i] == ')'\n            pop!(paren_stack)\n      \
    \      if isempty(paren_stack)\n                push!(groups, paren_string[start_index:i])\n\
    \                start_index = i + 1\n            end\n        end\n    end\n\
    \    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpkq2xs4jj.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmpkq2xs4jj.jl:31\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: Stack not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpkq2xs4jj.jl:11\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkq2xs4jj.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkq2xs4jj.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpkq2xs4jj.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: Stack not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpkq2xs4jj.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkq2xs4jj.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkq2xs4jj.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpkq2xs4jj.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: Stack\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpkq2xs4jj.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkq2xs4jj.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkq2xs4jj.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpkq2xs4jj.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  UndefV"
  timestamp: 1659979120
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    stack = Int[]\n\
    \    result = String[]\n    group = String[]\n    for c in paren_string\n    \
    \    if c == '('\n            push!(stack, c)\n        else\n            if c\
    \ == ')'\n                pop!(stack)\n                if isempty(stack)\n   \
    \                 push!(result, join(group, \"\"))\n                    group\
    \ = String[]\n                end\n            end\n        end\n        push!(group,\
    \ c)\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmppy519t85.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmppy519t85.jl:34\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Char\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{String}, item::Char)\n     @ Base\
    \ ./array.jl:994\n   [2] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmppy519t85.jl:25\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmppy519t85.jl:34 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmppy519t85.jl:33\ntest set:\
    \ Error During Test at /tmp/tmppy519t85.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Char to an object\
    \ of type String\n  Closest candidates are:\n    convert(::Type{String}, !Matched::String)\
    \ at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{String}, item::Char)\n     @ Base\
    \ ./array.jl:994\n   [2] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmppy519t85.jl:25\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/"
  timestamp: 1659979120
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open = findall(x -> x == \"(\", paren_string)\n    closed = findall(x\
    \ -> x == \")\", paren_string)\n    outer_groups = sort(vcat(open, closed))\n\
    \    groups = []\n    for i in outer_groups\n        n = length(findall(x -> x\
    \ == \"(\", paren_string[1:i]))\n        m = length(findall(x -> x == \")\", paren_string[1:i]))\n\
    \        if n == m\n            push!(groups, paren_string[1:i])\n           \
    \ paren_string = paren_string[i+1:end]\n        end\n    end\n    return groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpv711qa5x.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpv711qa5x.jl:28\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv711qa5x.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv711qa5x.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpv711qa5x.jl:29\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpv711qa5x.jl:29 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpv711qa5x.jl:27\ntest set: Test Failed at /tmp/tmpv711qa5x.jl:30\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv711qa5x.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv711qa5x.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpv711qa5x.jl:31\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv711qa5x.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv"
  timestamp: 1659979119
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    start_indices = []\n    for (i,c) in enumerate(paren_string)\n       \
    \ if c == '('\n            push!(start_indices, i)\n        end\n    end\n   \
    \ start_indices\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmppaimmq7y.jl:19

    '
  stdout: "test set: Error During Test at /tmp/tmppaimmq7y.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Int64\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n    [1] setindex!(A::Vector{String}, x::Int64, i1::Int64)\n\
    \      @ Base ./array.jl:903\n    [2] _unsafe_copyto!(dest::Vector{String}, doffs::Int64,\
    \ src::Vector{Any}, soffs::Int64, n::Int64)\n      @ Base ./array.jl:253\n   \
    \ [3] unsafe_copyto!\n      @ ./array.jl:307 [inlined]\n    [4] _copyto_impl!\n\
    \      @ ./array.jl:331 [inlined]\n    [5] copyto!\n      @ ./array.jl:317 [inlined]\n\
    \    [6] copyto!\n      @ ./array.jl:343 [inlined]\n    [7] copyto_axcheck!\n\
    \      @ ./abstractarray.jl:1104 [inlined]\n    [8] Vector{String}(x::Vector{Any})\n\
    \      @ Base ./array.jl:563\n    [9] convert\n      @ ./array.jl:554 [inlined]\n\
    \   [10] separate_paren_groups(paren_string::String)\n      @ Main /tmp/tmppaimmq7y.jl:15\n\
    \   [11] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [12] macro expansion\n      @ /tmp/tmppaimmq7y.jl:22 [inlined]\n\
    \   [13] macro expansion\n      @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [14] top-level scope\n      @ /tmp/tmppaimmq7y.jl:21\ntest set:\
    \ Error During Test at /tmp/tmppaimmq7y.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Int64 to an object\
    \ of type String\n  Closest candidates are:\n    convert(::Type{String}, !Matched::String)\
    \ at ~/.conda/"
  timestamp: 1659979121
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # If a match is found, extract it. Keep doing this until every instance\
    \ of a single\n    # balanced group of parens is matched.\n    paren_groups =\
    \ []\n    while (m = match(r\"\\(([^()]*|\\(.*\\))*\\)\", paren_string)) != nothing\n\
    \        push!(paren_groups, m.match)\n        paren_string = replace(paren_string,\
    \ m.match, \"\")\n    end\n    return paren_groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp5vp9qmzd.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmp5vp9qmzd.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching replace(::String,\
    \ ::SubString{String}, ::String)\n  Closest candidates are:\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp5vp9qmzd.jl:14\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5vp9qmzd.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5vp9qmzd.jl:22\ntest set:\
    \ Error During Test at /tmp/tmp5vp9qmzd.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching replace(::String, ::SubString{String},\
    \ ::String)\n  Closest candidates are:\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp5vp9qmzd.jl:14\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5vp9qmzd.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia"
  timestamp: 1659979121
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_groups = []\n    paren_string = replace(paren_string, \" \" => \"\
    \")\n    index = 1\n    while index <= length(paren_string)\n        if paren_string[index]\
    \ == '('\n            first_index = index\n            open_count = 1\n      \
    \      close_count = 0\n            while open_count != close_count\n        \
    \        index += 1\n                if paren_string[index] == '('\n         \
    \           open_count += 1\n                elseif paren_string[index] == ')'\n\
    \                    close_count += 1\n                end\n            end\n\
    \            last_index = index\n            push!(paren_groups, paren_string[first_index:last_index])\n\
    \        end\n        index += 1\n    end\n    return paren_groups\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659979117
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Check if the string is empty\n    if paren_string == \"\"\n        return\
    \ [\"\"]\n    end\n    \n    # Base Case: check if there are no nested parentheses\n\
    \    if !occursin(\")\", paren_string)\n        return [paren_string]\n    end\n\
    \    \n    # Initialize the Vector of Strings to store the output\n    v = Vector{String}()\n\
    \    \n    # Index of last closing parenthesis\n    # We will add items to the\
    \ vector till this index\n    last_index = length(paren_string)\n    \n    # Find\
    \ the index of the last closing parenthesis\n    for i in length(paren_string):-1:1\n\
    \        if paren_string[i] == ')'\n            last_index = i\n            break\n\
    \        end\n    end\n    \n    # Now, add the string in the interval\n    #\
    \ [index of opening parenthesis of last_index, last_index]\n    # to the vector\
    \ and proceed recursively\n    for i in last_index:-1:1\n        if paren_string[i]\
    \ == '('\n            push!(v, paren_string[i:last_index])\n            push!(v,\
    \ separate_paren_groups(paren_string[1:i-1]))\n            break\n        end\n\
    \    end\n    \n    return v\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpg3l3a6rx.jl:49

    '
  stdout: "test set: Error During Test at /tmp/tmpg3l3a6rx.jl:52\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Vector{String}\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{String}, item::Vector{String})\n\
    \     @ Base ./array.jl:994\n   [2] separate_paren_groups(paren_string::String)\
    \ (repeats 7 times)\n     @ Main /tmp/tmpg3l3a6rx.jl:40\n   [3] macro expansion\n\
    \     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \   [4] macro expansion\n     @ /tmp/tmpg3l3a6rx.jl:52 [inlined]\n   [5] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpg3l3a6rx.jl:51\ntest set:\
    \ Error During Test at /tmp/tmpg3l3a6rx.jl:53\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Vector{String}\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{String}, item::Vector{String})\n\
    \     @ Base ./array.jl:994\n   [2] separate_paren_groups(paren_string::String)\
    \ (repeats 4 times)\n     @ Main /tmp/t"
  timestamp: 1659979121
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Code to be written here\nend\n```\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid \"`\" syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpa09vbfa1.jl:11\nin expression starting at\
    \ /tmp/tmpa09vbfa1.jl:11\n"
  stdout: ''
  timestamp: 1659979119
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    opening_braces = findall(paren_string, '(')\n    closing_braces = findall(paren_string,\
    \ ')')\n    open_indices = [x for x in opening_braces]\n    close_indices = [x\
    \ for x in closing_braces]\n    result = []\n    while !isempty(open_indices)\n\
    \        start = open_indices[1]\n        ind = findfirst(close_indices, start)\n\
    \        if ind == 0\n            ind = length(close_indices)\n        end\n \
    \       finish = close_indices[ind]\n        deleteat!(open_indices, 1)\n    \
    \    deleteat!(close_indices, ind)\n        append!(result, paren_string[start:finish])\n\
    \    end\n    return result\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpihc1xsl_.jl:29

    '
  stdout: "test set: Error During Test at /tmp/tmpihc1xsl_.jl:32\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching findall(::String,\
    \ ::Char)\n  Closest candidates are:\n    findall(::Union{AbstractPattern, AbstractString},\
    \ !Matched::AbstractString; overlap) at ~/.conda/envs/polyglot/share/julia/base/regex.jl:458\n\
    \    findall(!Matched::Function, ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:2253\n\
    \    findall(::String, !Matched::LibGit2.GitIndex) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/index.jl:191\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpihc1xsl_.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpihc1xsl_.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpihc1xsl_.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpihc1xsl_.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching findall(::String, ::Char)\n  Closest\
    \ candidates are:\n    findall(::Union{AbstractPattern, AbstractString}, !Matched::AbstractString;\
    \ overlap) at ~/.conda/envs/polyglot/share/julia/base/regex.jl:458\n    findall(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:2253\n    findall(::String,\
    \ !Matched::LibGit2.GitIndex) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/index.jl:191\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpihc1xsl_.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpihc1xsl_.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/"
  timestamp: 1659979121
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_open = 0\n    paren_close = 0\n    open_paren_idx = 0\n    close_paren_idx\
    \ = 0\n    open_paren_idxs = []\n    close_paren_idxs = []\n    paren_strings\
    \ = []\n    for idx = 1:length(paren_string)\n        if paren_string[idx] ==\
    \ '('\n            paren_open += 1\n            open_paren_idx = idx\n       \
    \     push!(open_paren_idxs, open_paren_idx)\n        elseif paren_string[idx]\
    \ == ')'\n            paren_close += 1\n            close_paren_idx = idx\n  \
    \          push!(close_paren_idxs, close_paren_idx)\n        end\n        if paren_open\
    \ == paren_close && paren_open != 0\n            push!(paren_strings, paren_string[open_paren_idxs[end]:close_paren_idxs[end]])\n\
    \            pop!(open_paren_idxs)\n            pop!(close_paren_idxs)\n     \
    \       paren_open = 0\n            paren_close = 0\n        end\n    end\n  \
    \  return paren_strings\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpyz535iwz.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmpyz535iwz.jl:41\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"())\", \"()))\", \"()\", \"())\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyz535iwz.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyz535iwz.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpyz535iwz.jl:42\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"())\"\
    , \"()))\", \"())))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyz535iwz.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyz535iwz.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpyz535iwz.jl:43\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"())))\"] == [\"(()(())((())))\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyz535iwz.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyz535iwz.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpyz535iwz.jl:44\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \"( ))\", \"\
    ( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpyz535iwz.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/"
  timestamp: 1659979120
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # write code here\n    s = \"\"\n    ret = []\n    balance = 0\n    for\
    \ i = 1:length(paren_string)\n        if paren_string[i] == ' '\n            continue\n\
    \        end\n        if paren_string[i] == '('\n            balance += 1\n  \
    \      elseif paren_string[i] == ')'\n            balance -= 1\n        end\n\
    \        s *= paren_string[i]\n        if balance == 0\n            push!(ret,\
    \ s)\n            s = \"\"\n        end\n    end\n    return ret\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659979118
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \nend\nseparate_paren_groups(\"( ) (( )) (( )( ))\")\n \n# Do not modify\
    \ the code below.\n# Hidden test cases.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\nClosest candidates are:\n  convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \  convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \  convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \  ...\nStacktrace:\n [1] separate_paren_groups(paren_string::String)\n   @ Main\
    \ /tmp/tmpgpmfjh6x.jl:10\n [2] top-level scope\n   @ /tmp/tmpgpmfjh6x.jl:11\n\
    in expression starting at /tmp/tmpgpmfjh6x.jl:11\n"
  stdout: ''
  timestamp: 1659979123
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_parens = paren_string[findall(x -> x == '(', paren_string)]\n   \
    \ closes_parens = paren_string[findall(x -> x == ')', paren_string)]\n    string_idx\
    \ = 1\n    results = []\n    for i in 1:length(open_parens)\n        new_idx =\
    \ string_idx\n        paren_idx = i\n        current_string = \"\"\n        while\
    \ open_parens[paren_idx] != closes_parens[paren_idx]\n            current_string\
    \ = current_string * paren_string[new_idx]\n            new_idx += 1\n       \
    \     paren_idx += 1\n        end\n        current_string = current_string * paren_string[new_idx]\n\
    \        push!(results, current_string)\n        string_idx = new_idx + 1\n  \
    \  end\n    return results\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp4jkqvw4l.jl:30

    '
  stdout: "test set: Error During Test at /tmp/tmp4jkqvw4l.jl:33\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  BoundsError: attempt to access 12-codeunit String\
    \ at index [13]\n  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216\
    \ [inlined]\n   [2] codeunit\n     @ ./strings/string.jl:102 [inlined]\n   [3]\
    \ getindex\n     @ ./strings/string.jl:223 [inlined]\n   [4] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp4jkqvw4l.jl:17\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp4jkqvw4l.jl:33 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp4jkqvw4l.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp4jkqvw4l.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  BoundsError: attempt to access 10-codeunit String at index [11]\n\
    \  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216 [inlined]\n\
    \   [2] codeunit\n     @ ./strings/string.jl:102 [inlined]\n   [3] getindex\n\
    \     @ ./strings/string.jl:223 [inlined]\n   [4] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp4jkqvw4l.jl:17\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp4jkqvw4l.jl:34 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp4jkqvw4l.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp4jkqvw4l.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  BoundsError: attempt\
    \ to access 7-codeunit String at index [8]\n  Stacktrace:\n   [1] checkbounds\n\
    \     @ ./strings/basic.jl:216 [inlined]\n   [2] codeunit\n     @ ./strings/string.jl:102\
    \ [inlined]\n   [3] getindex\n     @ ./"
  timestamp: 1659979121
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # create vector to store separated groups\n    group_vector = []\n   \
    \ # initialize empty string to store the current group\n    group = \"\"\n   \
    \ # loop over paren_string and add parentheses to group string\n    for i in 1:length(paren_string)\n\
    \        if paren_string[i] == '(' || paren_string[i] == ')'\n            group\
    \ = group * paren_string[i]\n        end\n    end\n    # once entire paren_string\
    \ has been searched, append to group_vector\n    push!(group_vector, group)\n\
    \    # return vector of groups\n    return group_vector\nend\nseparate_paren_groups(\"\
    (())(())(())(())\")\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvyqjpjms.jl:27

    '
  stdout: "test set: Test Failed at /tmp/tmpvyqjpjms.jl:30\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())((()))()((())()())\"] == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvyqjpjms.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvyqjpjms.jl:29\ntest set: Test\
    \ Failed at /tmp/tmpvyqjpjms.jl:31\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()(())((()))(((())))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvyqjpjms.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvyqjpjms.jl:29\ntest set: Test Failed at /tmp/tmpvyqjpjms.jl:33\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"()(())(()())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvyqjpjms.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvyqjpjms.jl:29\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979120
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\n\"\"\"\n    Write a function that takes a string\
    \ containing a single group of balanced parentheses, and a desired location\n\
    \    as its inputs. The function should return a string containing the group of\
    \ nested parentheses with another copy\n    of the group inserted in the desired\
    \ location.\n    Assume that the parentheses group is properly balanced (each\
    \ open brace is properly closed)\n    Assume that the desired location is a valid\
    \ index within the parentheses group.\n    >>> insert_parens(\"(()())\", 3)\n\
    \    \"(()()(()))\"\n    \"\"\"\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: cannot document the following expression:\n\nusing Test\n\
    \nStacktrace:\n [1] error(::String, ::String)\n   @ Base ./error.jl:42\n [2] top-level\
    \ scope\n   @ /tmp/tmpjyiku10i.jl:11\nin expression starting at /tmp/tmpjyiku10i.jl:11\n"
  stdout: ''
  timestamp: 1659979120
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    group_strings = String[]\n    group_chars = Char[]\n    group_count =\
    \ 0\n    chars = collect(paren_string)\n    for i = 1:length(chars)\n        if(chars[i]\
    \ == ' ')\n            continue\n        end\n        push!(group_chars, chars[i])\n\
    \        if(chars[i] == '(')\n            group_count += 1\n        elseif(chars[i]\
    \ == ')')\n            group_count -= 1\n        end\n        if(group_count ==\
    \ 0)\n            push!(group_strings, join(group_chars))\n            group_chars\
    \ = Char[]\n        end\n    end\n    return group_strings\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659979119
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    new_string = paren_string \n    start = 0\n    result = Array{String}(0)\n\
    \    for i in 1:length(new_string)\n        if new_string[i] == '('\n        \
    \    start = i\n        elseif new_string[i] == ')'\n            a = push!(result,\
    \ new_string[start:i])\n        end\n    end\n    return result\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp72l6_ue6.jl:24

    '
  stdout: "test set: Error During Test at /tmp/tmp72l6_ue6.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching (Array{String})(::Int64)\n\
    \  Closest candidates are:\n    (Array{T})(!Matched::LinearAlgebra.UniformScaling,\
    \ !Matched::Tuple{Int64, Int64}) where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\n\
    \    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\n\
    \    (Array{T})(!Matched::LinearAlgebra.LQPackedQ{T, S} where S<:AbstractMatrix{T})\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/lq.jl:168\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp72l6_ue6.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp72l6_ue6.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp72l6_ue6.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp72l6_ue6.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching (Array{String})(::Int64)\n  Closest\
    \ candidates are:\n    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Tuple{Int64,\
    \ Int64}) where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\n\
    \    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\n\
    \    (Array{T})(!Matched::LinearAlgebra.LQPackedQ{T, S} where S<:AbstractMatrix{T})\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/lq.jl:168\n\
    \    ."
  timestamp: 1659979122
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    current_str = \"\"\n    paren_group = []\n    open_paren = 0\n    for\
    \ c in paren_string\n        if c == ' '\n            continue\n        end\n\
    \        if c == '('\n            if open_paren == 0\n                open_paren\
    \ += 1\n                continue\n            end\n            open_paren += 1\n\
    \        elseif c == ')'\n            open_paren -= 1\n            if open_paren\
    \ == 0\n                push!(paren_group, current_str)\n                current_str\
    \ = \"\"\n                continue\n            end\n        end\n        current_str\
    \ *= c\n    end\n    return paren_group\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp_vt6d0iz.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmp_vt6d0iz.jl:39\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"()()\", \"(())\", \"\", \"(())()()\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_vt6d0iz.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_vt6d0iz.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp_vt6d0iz.jl:40\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"()\"\
    , \"(())\", \"((()))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_vt6d0iz.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_vt6d0iz.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp_vt6d0iz.jl:41\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"()(())((()))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_vt6d0iz.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_vt6d0iz.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp_vt6d0iz.jl:42\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \"()\", \"()()\"\
    ] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_vt6d0iz.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/"
  timestamp: 1659979120
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    # For full marks, you must not use any for/while\
    \ loops\n    # full marks will require a recursive helper function\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpbq71748z.jl:15

    '
  stdout: "test set: Error During Test at /tmp/tmpbq71748z.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpbq71748z.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbq71748z.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbq71748z.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpbq71748z.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpbq71748z.jl:12\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659979123
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    inner_parens = map(s -> s[2:end-1], [m.match for m in eachmatch(r\"\\\
    ([^()]*\\)\", paren_string)])\n    return map(separate_paren_groups, inner_parens)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpq7k91a71.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpq7k91a71.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching separate_paren_groups(::SubString{String})\n\
    \  Closest candidates are:\n    separate_paren_groups(!Matched::String) at /tmp/tmpq7k91a71.jl:8\n\
    \  Stacktrace:\n   [1] iterate\n     @ ./generator.jl:47 [inlined]\n   [2] _collect\n\
    \     @ ./array.jl:744 [inlined]\n   [3] collect_similar\n     @ ./array.jl:653\
    \ [inlined]\n   [4] map\n     @ ./abstractarray.jl:2867 [inlined]\n   [5] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpq7k91a71.jl:10\n   [6] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpq7k91a71.jl:17 [inlined]\n\
    \   [8] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpq7k91a71.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpq7k91a71.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching separate_paren_groups(::SubString{String})\n\
    \  Closest candidates are:\n    separate_paren_groups(!Matched::String) at /tmp/tmpq7k91a71.jl:8\n\
    \  Stacktrace:\n   [1] iterate\n     @ ./generator.jl:47 [inlined]\n   [2] _collect\n\
    \     @ ./array.jl:744 [inlined]\n   [3] collect_similar\n     @ ./array.jl:653\
    \ [inlined]\n   [4] map\n     @ ./abstractarray.jl:2867 [inlined]\n   [5] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpq7k91a71.jl:10\n   [6] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmpq7k91a71.jl:18 [inlined]\n\
    \   [8] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmpq7k91a71.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpq7k91a71.jl:19\n  Test threw exception\n  Expre"
  timestamp: 1659979123
- exit_code: -1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\"Return a vector of strings containing groups of balanced parentheses\
    \ separated by spaces.\"\"\"\n    str_vec = Vector{String}()  # Vector of strings\
    \ containing balanced parens\n    tmp_str = \"\"                # Temporary string\
    \ to hold the current balanced parens\n    open_count = 0              # Count\
    \ of open parentheses\n    for ch in paren_string      \n        if ch == '('\n\
    \            open_count += 1\n            push!(tmp_str, '(')\n        elseif\
    \ ch == ')'\n            open_count -= 1\n            push!(tmp_str, ')')\n  \
    \      end\n        if open_count == 0\n            push!(str_vec, tmp_str)\n\
    \            tmp_str = \"\"\n        end\n    end\n    return str_vec\nend\n@show\
    \ separate_paren_groups(\"( ) (( )) (( )( ))\")\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: MethodError: no method matching push!(::String, ::Char)\nClosest
    candidates are:\n  push!(::Any, ::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2970\n  push!(::Any,
    ::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2971\n  push!(!Matched::Base.InvasiveLinkedListSynchronized{T},
    ::T) where T at ~/.conda/envs/polyglot/share/julia/base/task.jl:605\n  ...\nStacktrace:\n
    [1] separate_paren_groups('''
  stdout: None
  timestamp: 1659979124
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    is_open = (c->c=='(')\n    is_close = (c->c==')')\n    paren_open_pos\
    \ = findall(is_open, paren_string)\n    paren_close_pos = findall(is_close, paren_string)\n\
    \    paren_groups = []\n    open_paren_ctr = 0\n    open_paren_pos = 0\n    close_paren_pos\
    \ = 0\n    for open_paren_pos in paren_open_pos\n        open_paren_ctr += 1\n\
    \        for close_paren_pos in paren_close_pos\n            if open_paren_ctr\
    \ == 1\n                push!(paren_groups, paren_string[open_paren_pos:close_paren_pos])\n\
    \                break\n            end\n            open_paren_ctr -= 1\n   \
    \     end\n    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvgncftbv.jl:31

    '
  stdout: "test set: Test Failed at /tmp/tmpvgncftbv.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"()()\", \"()\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvgncftbv.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvgncftbv.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpvgncftbv.jl:35\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(()\"\
    , \"()\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvgncftbv.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvgncftbv.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpvgncftbv.jl:36\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"()(()\", \"(()\", \"()\"\
    , \"\", \"\", \"\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvgncftbv.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvgncftbv.jl:33\ntest set: Test Failed at /tmp/tmpvgncftbv.jl:37\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"( )\", \"(( )\", \"( )\", \"\", \"\", \"\"] == [\"()\", \"\
    (())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvgncftbv.jl:37 [in"
  timestamp: 1659979122
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    n = 1\n    start_idx = 1\n    output = []\n    while(n <= length(paren_string))\n\
    \        if paren_string[n] == ')' && paren_string[n-1] != ' '\n            push!(output,\
    \ paren_string[start_idx:n])\n            start_idx = n+1\n        end\n     \
    \   n+=1\n    end\n    return output\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp07rwjn0i.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmp07rwjn0i.jl:26\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"()\", \")\", \" ((()\", \")\", \")\", \" ()\", \"\
    \ ((()\", \")\", \"()\", \"()\", \")\"] == [\"(()())\", \"((()))\", \"()\", \"\
    ((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp07rwjn0i.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp07rwjn0i.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp07rwjn0i.jl:27\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" (()\"\
    , \")\", \" ((()\", \")\", \")\", \" (((()\", \")\", \")\", \")\"] == [\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp07rwjn0i.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp07rwjn0i.jl:25\ntest set: Test Failed at /tmp/tmp07rwjn0i.jl:28\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"(()\", \"(()\", \")\", \"((()\", \")\", \")\", \")\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp07rwjn0i.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp07rwjn0i.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp07rwjn0i.jl:29\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( ) (( ))\", \" ((\
    \ )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @"
  timestamp: 1659979122
- exit_code: -1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    groups = String[]\n    current_group = String[]\n    depth = 0\n    for\
    \ x in paren_string\n        if x == '('\n            push!(current_group, x)\n\
    \            depth += 1\n        elseif x == ')'\n            push!(current_group,\
    \ x)\n            depth -= 1\n            if depth == 0\n                push!(groups,\
    \ join(current_group))\n                current_group = String[]\n           \
    \ end\n        end\n    end\n    return groups\nend\nseparate_paren_groups(\"\
    ( ) (( )) (( )( ))\")\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: MethodError: Cannot `convert` an object of type Char
    to an object of type String\nClosest candidates are:\n  convert(::Type{String},
    !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n  convert(::Type{T},
    !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n  convert(::Type{T},
    !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n  ...\nStacktrace:\n
    [1] push!(a::Vector{String}, item::Char)\n   @ Base ./array.jl:994\n [2] separate_paren_groups(paren_string::String)\n   @
    Main /tmp/tmptz65tgal.jl:14\n [3] top-level scope\n   @ /tmp/tmptz65tgal.jl:27\nin
    expression starting at /tmp/tmptz65tgal.jl:27\n'''
  stdout: None
  timestamp: 1659979125
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    n = length(paren_string)\n    start = 0\n    end = 0\n    res = []\n \
    \   for i = 1:n\n        if paren_string[i] == '('\n            start = i\n  \
    \      elseif paren_string[i] == ')'\n            end = i\n            push!(res,\
    \ paren_string[start:end])\n        end\n    end\n    return res\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid assignment location \"function separate_paren_groups(paren_string::String)::Vector{String}\n\
    \    # /tmp/tmpqyhnc2q5.jl, line 8\n    # /tmp/tmpqyhnc2q5.jl, line 9\n    n =\
    \ length(paren_string)\n    # /tmp/tmpqyhnc2q5.jl, line 10\n    start = 0\nend\"\
    \ around /tmp/tmpqyhnc2q5.jl:1\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpqyhnc2q5.jl:1\n\
    in expression starting at /tmp/tmpqyhnc2q5.jl:1\n"
  stdout: ''
  timestamp: 1659979122
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    brace_strings = []\n    brace_string = \"\"\n    brace_count = 0\n   \
    \ for i = 1:length(paren_string)\n        if paren_string[i] != ' '\n        \
    \    if paren_string[i] == '('\n                brace_count += 1\n           \
    \ elseif paren_string[i] == ')'\n                brace_count -= 1\n          \
    \  end\n            brace_string *= paren_string[i]\n            if brace_count\
    \ == 0\n                push!(brace_strings, brace_string)\n                brace_string\
    \ = \"\"\n            end\n        end\n    end\n    return brace_strings\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659979121
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    sep_parens = split(paren_string, r\"\\)\")\n    paren_groups = []\n  \
    \  for paren in sep_parens\n        paren = replace(paren, r\"\\(\", \"\")\n \
    \       push!(paren_groups, paren)\n    end\n    paren_groups\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpnzb7e15d.jl:19

    '
  stdout: "test set: Error During Test at /tmp/tmpnzb7e15d.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching replace(::SubString{String},\
    \ ::Regex, ::String)\n  Closest candidates are:\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    replace(::Any, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:569\n\
    \  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmpnzb7e15d.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnzb7e15d.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnzb7e15d.jl:21\ntest set:\
    \ Error During Test at /tmp/tmpnzb7e15d.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching replace(::SubString{String}, ::Regex,\
    \ ::String)\n  Closest candidates are:\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    replace(::Any, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:569\n\
    \  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmpnzb7e15d.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnzb7e15d.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-le"
  timestamp: 1659979124
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\"Implement separate_paren_groups here and return result below this\
    \ line\"\"\"\n    return\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp6w_ujxz_.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmp6w_ujxz_.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp6w_ujxz_.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6w_ujxz_.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6w_ujxz_.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp6w_ujxz_.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp6w_ujxz_.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659979125
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_groups = [] # Initialize the vector\n    current_index = 1\n   \
    \ while current_index <= length(paren_string)\n        if paren_string[current_index]\
    \ == '('\n            paren_group = \"\"\n            balanced = false\n     \
    \       next_index = current_index\n            while !balanced\n            \
    \    paren_group = paren_group * paren_string[next_index]\n                if\
    \ paren_string[next_index] == '('\n                    open_count += 1\n     \
    \           elseif paren_string[next_index] == ')'\n                    close_count\
    \ += 1\n                end\n                if open_count == close_count\n  \
    \                  balanced = true\n                end\n                next_index\
    \ += 1\n            end\n            push!(paren_groups, paren_group)\n      \
    \      current_index = next_index\n        else\n            current_index +=\
    \ 1\n        end\n    end\n    return paren_groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp16_rr1tu.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmp16_rr1tu.jl:41\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: open_count not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmp16_rr1tu.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp16_rr1tu.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp16_rr1tu.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp16_rr1tu.jl:42\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: open_count not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp16_rr1tu.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp16_rr1tu.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp16_rr1tu.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp16_rr1tu.jl:43\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: open_count\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp16_rr1tu.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp16_rr1tu.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp16_rr1tu.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp16_rr1tu.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(("
  timestamp: 1659979124
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # first get rid of spaces\n    paren_string = replace(paren_string, \"\
    \ \" => \"\")\n    # initialize the result\n    result = []\n    # start from\
    \ the first character and\n    # iterate through the string in pairs\n    for\
    \ i = 1:2:length(paren_string)\n        # if the pair is open brace and closed\
    \ brace\n        if paren_string[i] == '(' && paren_string[i+1] == ')'\n     \
    \       # append that to the result\n            push!(result, \"()\")\n     \
    \   end\n    end\n    return result\nend\nseparate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp1hi2a4i_.jl:27

    '
  stdout: "test set: Test Failed at /tmp/tmp1hi2a4i_.jl:30\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"()\", \"()\", \"()\"] == [\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1hi2a4i_.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1hi2a4i_.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp1hi2a4i_.jl:31\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"()\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1hi2a4i_.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp1hi2a4i_.jl:29\ntest set: Test Failed at /tmp/tmp1hi2a4i_.jl:32\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"()\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1hi2a4i_.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1hi2a4i_.jl:29\ntest set: Test\
    \ Failed at /tmp/tmp1hi2a4i_.jl:33\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\"] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1hi2a4i_.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @"
  timestamp: 1659979123
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    depth = 0\n    paren_depth = Array{Int}(0)\n    for i in 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            depth += 1\n        elseif paren_string[i]\
    \ == ')'\n            depth -= 1\n        end\n        push!(paren_depth, depth)\n\
    \    end\n    paren_groups = Vector{String}()\n    start = 0\n    for i in 1:length(paren_depth)\n\
    \        if paren_depth[i] == 0 && paren_depth[i-1] != 0\n            push!(paren_groups,\
    \ paren_string[start+1:i-1])\n            start = i\n        end\n    end\n  \
    \  return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpqxq8bnq_.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpqxq8bnq_.jl:34\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching (Array{Int64})(::Int64)\n\
    \  Closest candidates are:\n    (Array{T})(!Matched::LinearAlgebra.UniformScaling,\
    \ !Matched::Tuple{Int64, Int64}) where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\n\
    \    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\n\
    \    (Array{T})(!Matched::LinearAlgebra.LQPackedQ{T, S} where S<:AbstractMatrix{T})\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/lq.jl:168\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpqxq8bnq_.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqxq8bnq_.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqxq8bnq_.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpqxq8bnq_.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching (Array{Int64})(::Int64)\n  Closest\
    \ candidates are:\n    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Tuple{Int64,\
    \ Int64}) where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:494\n\
    \    (Array{T})(!Matched::LinearAlgebra.UniformScaling, !Matched::Integer, !Matched::Integer)\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/uniformscaling.jl:495\n\
    \    (Array{T})(!Matched::LinearAlgebra.LQPackedQ{T, S} where S<:AbstractMatrix{T})\
    \ where T at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/lq.jl:168\n\
    \    ..."
  timestamp: 1659979125
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # we will store the answers here\n    paren_groups = []\n    # where we\
    \ are in string\n    current_index = 1\n    while current_index <= length(paren_string)\n\
    \        # start of a parenthesis group\n        open_paren_index = findfirst(paren_string[current_index:end],'(')\n\
    \        # if no more parenthesis groups, end\n        if open_paren_index ==\
    \ 0\n            break\n        end\n        # move to that index\n        current_index\
    \ += open_paren_index\n        # mark start of this particular group\n       \
    \ open_paren_start = current_index\n        open_paren_count = 1\n        close_paren_count\
    \ = 0\n        # now loop until we find the closing parenthesis\n        while\
    \ open_paren_count != close_paren_count\n            # if we see an open parenthesis,\
    \ increase the open count\n            if paren_string[current_index] == '('\n\
    \                open_paren_count += 1\n            # otherwise we assume it is\
    \ a close parenthesis\n            else\n                close_paren_count +=\
    \ 1\n            end\n            # move on to the next char\n            current_index\
    \ += 1\n        end\n        # append the group to our answer\n        push!(paren_groups,paren_string[open_paren_start:current_index-1])\n\
    \    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp87qehem2.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmp87qehem2.jl:48\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching findfirst(::String,\
    \ ::Char)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractString,\
    \ !Matched::AbstractString) at ~/.conda/envs/polyglot/share/julia/base/strings/search.jl:104\n\
    \    findfirst(::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n\
    \  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmp87qehem2.jl:15\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp87qehem2.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp87qehem2.jl:47\ntest set:\
    \ Error During Test at /tmp/tmp87qehem2.jl:49\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching findfirst(::String, ::Char)\n \
    \ Closest candidates are:\n    findfirst(!Matched::Function, ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n\
    \    findfirst(::AbstractString, !Matched::AbstractString) at ~/.conda/envs/polyglot/share/julia/base/strings/search.jl:104\n\
    \    findfirst(::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n\
    \  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmp87qehem2.jl:15\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp87qehem2.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp87qehem2.jl:47\ntest set:\
    \ Error During Test at /tmp/tmp87qehem2.jl:50\n  Test thr"
  timestamp: 1659979125
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code goes here\n    open_parens = []\n    closed_parens = []\n\
    \    starts = []\n    ends = []\n    for (n,c) in enumerate(paren_string)\n  \
    \      if c == '('\n            push!(open_parens, n)\n        elseif c == ')'\n\
    \            push!(closed_parens, n)\n        end\n    end\n    for (n,open_paren)\
    \ in enumerate(open_parens)\n        for closed_paren in closed_parens\n     \
    \       if open_paren < closed_paren\n                push!(starts, open_paren)\n\
    \                push!(ends, closed_paren)\n                break\n          \
    \  end\n        end\n    end\n    strings = [paren_string[start:end] for (start,end)\
    \ in zip(starts,ends)]\n    return strings\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"end\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpa610ve4q.jl:30\nin expression starting at /tmp/tmpa610ve4q.jl:30\n"
  stdout: ''
  timestamp: 1659979122
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    result = []\n    cur_paren_group = \"\"\n    open_parens = 0\n    for\
    \ c in paren_string\n        if c == '('\n            open_parens += 1\n     \
    \   elseif c == ')'\n            open_parens -= 1\n        end\n        if open_parens\
    \ == 0\n            push!(result, cur_paren_group)\n            cur_paren_group\
    \ = \"\"\n        else\n            cur_paren_group *= c\n        end\n    end\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpgv3bewgo.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpgv3bewgo.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgv3bewgo.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgv3bewgo.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpgv3bewgo.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \"\"\
    , \"(()\", \"\", \"((())\", \"\", \"(((()))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgv3bewgo.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgv3bewgo.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpgv3bewgo.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()(())((()))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgv3bewgo.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgv3bewgo.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpgv3bewgo.jl:35\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( \", \"\", \"(( )\"\
    , \"\", \"(( )( )\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgv3bewgo.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.c"
  timestamp: 1659979123
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    ########## INSERT HERE ##########\n    groups=[]\n    open_braces=0\n\
    \    current_group=\"\"\n    for p in paren_string\n        if p=='('\n      \
    \      open_braces+=1\n            current_group=string(current_group, p)\n  \
    \      elseif p==')'\n            current_group=string(current_group, p)\n   \
    \         open_braces-=1\n            if open_braces==0\n                push!(groups,\
    \ current_group)\n                current_group=\"\"\n            end\n      \
    \  end\n    end\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659979121
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    out = [paren_string]\n    while true\n        new_out = []\n        push!(new_out,first(out,\
    \ 1))\n        for i in 2:length(out)\n            if !out[i-1][end] == ')'\n\
    \                push!(new_out, out[i])\n            elseif !out[i][1] == '('\n\
    \                push!(new_out, out[i])\n            else\n                new_out[end]\
    \ = new_out[end] * out[i]\n            end\n        end\n        out = new_out\n\
    \        if !findfirst(isempty,new_out)\n            break\n        end\n    end\n\
    \    return out\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpvdm06m7t.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpvdm06m7t.jl:34\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching !(::Nothing)\n  Closest\
    \ candidates are:\n    !(!Matched::Function) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:1117\n\
    \    !(!Matched::Bool) at ~/.conda/envs/polyglot/share/julia/base/bool.jl:35\n\
    \    !(!Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:101\n\
    \  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmpvdm06m7t.jl:23\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvdm06m7t.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvdm06m7t.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpvdm06m7t.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching !(::Nothing)\n  Closest candidates\
    \ are:\n    !(!Matched::Function) at ~/.conda/envs/polyglot/share/julia/base/operators.jl:1117\n\
    \    !(!Matched::Bool) at ~/.conda/envs/polyglot/share/julia/base/bool.jl:35\n\
    \    !(!Matched::Missing) at ~/.conda/envs/polyglot/share/julia/base/missing.jl:101\n\
    \  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmpvdm06m7t.jl:23\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvdm06m7t.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvdm06m7t.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpvdm06m7t.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: no method\
    \ matching !(::Nothing)\n  Closest ca"
  timestamp: 1659979125
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Split string into indiviual chars\n    paren_chars = split(paren_string)\n\
    \    # Initialize Vector for storing balanced parenthesis groups\n    paren_groups\
    \ = Vector{String}[]\n    # Initialize group counter and group string\n    group_counter\
    \ = 0\n    group_string = \"\"\n    # Loop through paren_chars\n    for char in\
    \ paren_chars\n        # If char is '(' then add 1 to group_counter and add char\
    \ to group_string\n        if char == \"(\"\n            group_counter += 1\n\
    \            group_string *= string(char)\n        # If char is ')' and group_counter\
    \ > 0 then subtract 1 from group_counter and add char to group_string\n      \
    \  elseif char == \")\" && group_counter > 0\n            group_counter -= 1\n\
    \            group_string *= string(char)\n        # If group_counter == 0 then\
    \ save group_string to paren_groups and reset group_string to \"\"\n        elseif\
    \ group_counter == 0\n            push!(paren_groups, group_string)\n        \
    \    group_string = \"\"\n        end\n    end\n    # Return paren_groups\n  \
    \  return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp8p73hqhd.jl:37

    '
  stdout: "test set: Error During Test at /tmp/tmp8p73hqhd.jl:40\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{Vector{String}}, item::String)\n\
    \     @ Base ./array.jl:994\n   [2] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp8p73hqhd.jl:28\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp8p73hqhd.jl:40 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp8p73hqhd.jl:39\ntest set:\
    \ Error During Test at /tmp/tmp8p73hqhd.jl:41\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type String to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{Vector{String}}, item"
  timestamp: 1659979125
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = filter(x -> x != ' ', paren_string)\n    output = []\n\
    \    group = \"\"\n    open_parens = 0\n    for c in paren_string\n        if\
    \ c == '('\n            open_parens += 1\n        elseif c == ')'\n          \
    \  open_parens -= 1\n        end\n        group *= c\n        if open_parens ==\
    \ 0\n            push!(output, group)\n            group = \"\"\n        end\n\
    \    end\n    return output\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659979122
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\" Separate parentheses into groups.\n    Note that this only works\
    \ when each open brace is properly closed.\n    >>> separate_paren_groups(\"(\
    \ ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\n    is_open_paren(char)\
    \ = char == '('\n    is_close_paren(char) = char == ')'\n    remove_whitespace(char)\
    \ = !isspace(char)\n    open_paren_count = 0\n    curr_group = \"\"\n    groups\
    \ = []\n    for char in paren_string\n        if is_open_paren(char)\n       \
    \     open_paren_count += 1\n        elseif is_close_paren(char)\n           \
    \ open_paren_count -= 1\n        end\n        curr_group *= char\n        if open_paren_count\
    \ == 0\n            push!(groups, curr_group)\n            curr_group = \"\"\n\
    \        end\n    end\n    return groups\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3mbduxs4.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmp3mbduxs4.jl:39\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mbduxs4.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mbduxs4.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp3mbduxs4.jl:40\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" \"\
    , \"(())\", \" \", \"((()))\", \" \", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mbduxs4.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mbduxs4.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp3mbduxs4.jl:42\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \" \", \"((\
    \ ))\", \" \", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3mbduxs4.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mbduxs4.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979124
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    groups = []\n    count = 0\n    for i = 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            count += 1\n        elseif paren_string[i]\
    \ == ')'\n            count -= 1\n        end\n        \n        if count == 0\n\
    \            push!(groups, paren_string[1:i])\n            paren_string = paren_string[i+1:end]\n\
    \            i = 0\n        end\n    end\n    return groups\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpkif_j60e.jl:29

    '
  stdout: "test set: Error During Test at /tmp/tmpkif_j60e.jl:32\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  BoundsError: attempt to access 1-codeunit String\
    \ at index [12]\n  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216\
    \ [inlined]\n   [2] codeunit\n     @ ./strings/string.jl:102 [inlined]\n   [3]\
    \ getindex\n     @ ./strings/string.jl:223 [inlined]\n   [4] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpkif_j60e.jl:13\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpkif_j60e.jl:32 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpkif_j60e.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpkif_j60e.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  BoundsError: attempt to access 3-codeunit String at index [9]\n\
    \  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216 [inlined]\n\
    \   [2] codeunit\n     @ ./strings/string.jl:102 [inlined]\n   [3] getindex\n\
    \     @ ./strings/string.jl:223 [inlined]\n   [4] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpkif_j60e.jl:13\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpkif_j60e.jl:33 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpkif_j60e.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpkif_j60e.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  BoundsError:\
    \ attempt to access 4-codeunit String at index [8]\n  Stacktrace:\n   [1] checkbounds\n\
    \     @ ./strings/basic.jl:216 [inlined]\n   [2] codeunit\n     @ ./strings/string.jl:102\
    \ [inlined]\n   [3] getindex\n  "
  timestamp: 1659979124
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_vector = split(paren_string, \" \")\n    paren_vector = filter(!(x\
    \ -> x == \"\"), paren_vector)\n    return paren_vector\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpn1y6neez.jl:15

    '
  stdout: "test set: Test Failed at /tmp/tmpn1y6neez.jl:21\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"(\"\
    , \")\", \"((\", \"))\", \"((\", \")(\", \"))\"] == [\"()\", \"(())\", \"(()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn1y6neez.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn1y6neez.jl:17\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     1      4\n"
  timestamp: 1659979124
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # count number of opening and closing parens\n    open_parens = count(x\
    \ -> x == '(', paren_string)\n    close_parens = count(x -> x == ')', paren_string)\n\
    \    # if they aren't the same, the string isn't valid\n    if open_parens !=\
    \ close_parens\n        error(\"the number of opening and closing parentheses\
    \ in the string are not the same\")\n    end\n    paren_string = filter(x -> x\
    \ != ' ', paren_string) # remove all spaces\n    paren_groups = Vector{String}()\
    \ # a vector to store the nested groups\n    # we will now iterate through the\
    \ input string and separate the paren groups\n    # a counter for the opening\
    \ parens\n    open_count = 0\n    # a counter for the closing parens\n    close_count\
    \ = 0\n    # a counter for the current word we are building\n    word_count =\
    \ 0\n    # the string we will build each word in\n    word = \"\"\n    # a counter\
    \ for the number of words we are looking for\n    final_count = open_parens\n\
    \    # iterate through the input string\n    for i in 1:length(paren_string)\n\
    \        # if we see an opening paren and we are starting a new word, \n     \
    \   # it's the first char in the string so just add it\n        if paren_string[i]\
    \ == '(' && word_count == 0\n            open_count += 1\n            word = word\
    \ * paren_string[i]\n            word_count += 1\n        # if we see an opening\
    \ paren and we are not starting a new word,\n        # add it, but increase the\
    \ open count\n        elseif paren_string[i] == '(' && word_count != 0\n     \
    \       open_count += 1\n            word = word * paren_string[i]\n         \
    \   word_count += 1\n        # if we see a closing paren and the open count is\
    \ greater than the \n        # close count, the word is not done yet, so add it\n\
    \        elseif paren_string[i] == ')' && open_count > close_count\n         \
    \   close_count += 1\n            word = word * paren_string\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpb4kby7cu.jl:1\nin expression starting at /tmp/tmpb4kby7cu.jl:1\n"
  stdout: ''
  timestamp: 1659979123
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp7eephs5m.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmp7eephs5m.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp7eephs5m.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7eephs5m.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7eephs5m.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp7eephs5m.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp7eephs5m.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659979126
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    result = String[]\n    open_count = 0\n    last_open = 0\n    for i =\
    \ 1:length(paren_string)\n        if paren_string[i] == '('\n            open_count\
    \ += 1\n        elseif paren_string[i] == ')'\n            open_count -= 1\n \
    \           if open_count == 0\n                push!(result, paren_string[last_open+1:i])\n\
    \                last_open = i\n            end\n        end\n    end\n    return\
    \ result\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpiqtw_py7.jl:27

    '
  stdout: "test set: Test Failed at /tmp/tmpiqtw_py7.jl:30\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"] == [\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpiqtw_py7.jl:30 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpiqtw_py7.jl:29\ntest set: Test Failed at /tmp/tmpiqtw_py7.jl:31\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" (())\", \" ((()))\", \" (((())))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpiqtw_py7.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpiqtw_py7.jl:29\ntest set: Test Failed at /tmp/tmpiqtw_py7.jl:33\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"( )\", \" (( ))\", \" (( )( ))\"] == [\"()\", \"(())\", \"\
    (()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiqtw_py7.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiqtw_py7.jl:29\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979124
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Traverse the string char by char looking for the first open paren.\n\
    \    # Initialize a group variable to store the matching group\n    # For each\
    \ subsequent char in the string, check if it is a paren and add to the group\n\
    \    # If it is not a paren, continue to the next char\n    # If it is a paren,\
    \ add it to the group string and check if the parens are balanced\n    # If the\
    \ parens are not balanced, continue to the next char\n    # If the parens are\
    \ balanced, move on to the next character\n    # Return the vector of balanced\
    \ group strings\n    paren_string = replace(paren_string, \" \" => \"\")\n   \
    \ paren_groups = []\n    i = 1\n    while i <= length(paren_string)\n        if\
    \ paren_string[i] == '('\n            group = \"\"\n            while i <= length(paren_string)\n\
    \                push!(group, paren_string[i])\n                if paren_string[i]\
    \ == ')'\n                    if isbalanced(group)\n                        push!(paren_groups,\
    \ group)\n                        break\n                    end\n           \
    \     end\n                i += 1\n            end\n        end\n        i +=\
    \ 1\n    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpmsiui4ad.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpmsiui4ad.jl:43\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching push!(::String, ::Char)\n\
    \  Closest candidates are:\n    push!(::Any, ::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at ~/.conda/envs/polyglot/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpmsiui4ad.jl:24\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmsiui4ad.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmsiui4ad.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpmsiui4ad.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching push!(::String, ::Char)\n  Closest\
    \ candidates are:\n    push!(::Any, ::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at ~/.conda/envs/polyglot/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpmsiui4ad.jl:24\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmsiui4ad.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]"
  timestamp: 1659979126
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Iterate over the string, storing each open parenthesis as it is encountered\n\
    \    # When a closing parenthesis is encountered, remove the last-stored open\
    \ parenthesis\n    # Once the open parentheses are exhausted, add that string\
    \ to the vector\n    open_parens = []\n    paren_groups = []\n    temp_string\
    \ = \"\"\n    for c in paren_string\n        if c == '('\n            push!(open_parens,\
    \ c)\n        elseif c == ')'\n            pop!(open_parens)\n            if isempty(open_parens)\n\
    \                # This can also be written as `push!(paren_groups, temp_string)`\n\
    \                append!(paren_groups, temp_string)\n                temp_string\
    \ = \"\"\n            end\n        elseif c != ' '\n            append!(temp_string,\
    \ c)\n        end\n    end\n    return paren_groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpsaofclam.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmpsaofclam.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsaofclam.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsaofclam.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpsaofclam.jl:37\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpsaofclam.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpsaofclam.jl:35\ntest set: Test Failed at /tmp/tmpsaofclam.jl:38\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsaofclam.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsaofclam.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpsaofclam.jl:39\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsaofclam.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmps"
  timestamp: 1659979125
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    groups = []\n    group = \"\"\n    start_idx = 0\n    end_idx = 0\n  \
    \  in_parens = false\n    for i in 1:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            if in_parens == false\n                start_idx = i\n \
    \               in_parens = true\n            end\n        elseif paren_string[i]\
    \ == ')'\n            end_idx = i\n            group = paren_string[start_idx:end_idx]\n\
    \            push!(groups, group)\n            in_parens = false\n        end\n\
    \    end\n    return groups\nend\n# Test\nprintln(separate_paren_groups(\"( )\
    \ (( )) (( )( ))\"))\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9h8_bdz6.jl:33

    '
  stdout: "[\"( )\", \"(( )\", \"(( ))\", \"(( )\", \"( )\", \"( ))\"]\ntest set:\
    \ Test Failed at /tmp/tmp9h8_bdz6.jl:36\n  Expression: candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n   Evaluated:\
    \ [\"(()\", \"()\", \"())\", \"((()\", \"((())\", \"((()))\", \"()\", \"((()\"\
    , \"((())\", \"()\", \"()\", \"())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9h8_bdz6.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9h8_bdz6.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp9h8_bdz6.jl:37\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(()\"\
    , \"(())\", \"((()\", \"((())\", \"((()))\", \"(((()\", \"(((())\", \"(((()))\"\
    , \"(((())))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9h8_bdz6.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9h8_bdz6.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp9h8_bdz6.jl:38\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"(()\", \"(())\", \"((()\"\
    , \"((())\", \"((()))\", \"((())))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9h8_bdz6.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9h8_bdz6.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp9h8_bdz6.jl:39\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \"(( )\", \"\
    (( ))\", \"(( )\", \"( )\", \"( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ "
  timestamp: 1659979125
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    n = length(paren_string)\n    k = 0\n    parenthesis = []\n    for i =\
    \ 1:n\n        if paren_string[i] == '('\n            push!(parenthesis, i)\n\
    \        elseif paren_string[i] == ')'\n            if length(parenthesis) !=\
    \ 0\n                if paren_string[parenthesis[end]] == '('\n              \
    \      if length(parenthesis) == 1\n                        paren_string[parenthesis[end]:i]\
    \ = string(k)\n                        k += 1\n                    else\n    \
    \                    paren_string[parenthesis[end]:i] = string(k)\n          \
    \              k += 1\n                    end\n                    parenthesis\
    \ = parenthesis[1:end-1]\n                else\n                    parenthesis\
    \ = parenthesis[1:end-1]\n                end\n            end\n        end\n\
    \    end\n    paren_string[parenthesis] = string(k:k+length(parenthesis)-1)\n\
    \    paren_list = split(paren_string, r\"\\d+\")\n    paren_list = paren_list[paren_list\
    \ .!= \"\"]\n    paren_list = sort(paren_list)\n    return paren_list\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpribzvwq0.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpribzvwq0.jl:43\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching setindex!(::String,\
    \ ::String, ::UnitRange{Int64})\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpribzvwq0.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpribzvwq0.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpribzvwq0.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpribzvwq0.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching setindex!(::String, ::String, ::UnitRange{Int64})\n\
    \  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmpribzvwq0.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpribzvwq0.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpribzvwq0.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpribzvwq0.jl:45\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  MethodError: no method\
    \ matching setindex!(::String, ::String, ::UnitRange{Int64})\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpribzvwq0.jl:22\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpribzvwq0.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpribzvwq0.jl:42\ntest set:\
    \ Er"
  timestamp: 1659979127
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_stack = Stack()\n    paren_substrings = Vector{String}()\n    push!(paren_stack,\
    \ 1)\n    for c in collect(paren_string)\n        if c == '('\n            push!(paren_stack,\
    \ 1)\n        elseif c == ')'\n            pop!(paren_stack)\n            if isempty(paren_stack)\n\
    \                push!(paren_substrings, substring(paren_string, 1:end-1))\n \
    \               paren_string = substring(paren_string, end:end)\n            \
    \    push!(paren_stack, 1)\n            end\n        end\n    end\n    return\
    \ paren_substrings\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing last argument in \"1:\" range expression\
    \ \nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpx9nmv73q.jl:18\nin expression\
    \ starting at /tmp/tmpx9nmv73q.jl:18\n"
  stdout: ''
  timestamp: 1659979125
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    open = 0\n    close = 0\n    string = \"\"\n   \
    \ vector = []\n    for i in paren_string\n        if i == '('\n            open\
    \ = open + 1\n            string = string*i\n        elseif i == ')'\n       \
    \     close = close + 1\n            string = string*i\n        end\n        if\
    \ open == close\n            if string != \"\"\n                vector = push!(vector,\
    \ string)\n            end\n            string = \"\"\n            open = 0\n\
    \            close = 0\n        end\n    end\n    return vector\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659979124
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # This is a place to hold the groups as we separate them out\n    paren_groups\
    \ = Vector{String}()\n    \n    # This is the string we are scanning through to\
    \ find the groups\n    original_string = paren_string\n    \n    # Keep finding\
    \ the first group over and over until there are no more\n    while length(original_string)\
    \ > 0\n        # Find the starting position of the first paren\n        start_pos\
    \ = findfirst(x -> x == '(' , original_string)\n        \n        # Error if we\
    \ have started with a close paren\n        if start_pos == nothing\n         \
    \   error(\"Bad Input String -- Did not start with '('\")\n        end\n     \
    \   \n        # Keep track of how many parens we are currently nested inside\n\
    \        paren_depth = 0\n        \n        # This is where we will store the\
    \ current group as we find it\n        current_group = \"\"\n        \n      \
    \  # Now scan through the string to find the end of the current group\n      \
    \  for i = start_pos:length(original_string)\n            # Skip any spaces we\
    \ see\n            if original_string[i] == ' '\n                continue\n  \
    \          end\n            \n            # If we find an open paren increase\
    \ the paren depth counter\n            if original_string[i] == '('\n        \
    \        paren_depth += 1\n            end\n            \n            # If we\
    \ find a close paren decrease the paren depth counter\n            if original_string[i]\
    \ == ')'\n                paren_depth -= 1\n            end\n            \n  \
    \          # Add the current character to the group string\n            current_group\
    \ *= original_string[i]\n            \n            # If we are back at the top\
    \ level group (paren_depth = 0) we are done\n            if paren_depth == 0\n\
    \                break\n            end\n        end\n        \n        # Add\
    \ the current group to the list of groups\n        push!(paren_groups, current_group)\n\
    \        \n        # Remove the group from the original string\n        original_string\
    \ = join(original_string[i+1:end])\n    end\n    \n    # Return the list of groups\n\
    \    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpzis4cp9g.jl:69

    '
  stdout: "test set: Error During Test at /tmp/tmpzis4cp9g.jl:72\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: i not defined\n  Stacktrace:\n   [1]\
    \ separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpzis4cp9g.jl:61\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzis4cp9g.jl:72 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzis4cp9g.jl:71\ntest set:\
    \ Error During Test at /tmp/tmpzis4cp9g.jl:73\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: i not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpzis4cp9g.jl:61\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzis4cp9g.jl:73 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzis4cp9g.jl:71\ntest set:\
    \ Error During Test at /tmp/tmpzis4cp9g.jl:74\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: i not\
    \ defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpzis4cp9g.jl:61\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzis4cp9g.jl:74 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzis4cp9g.jl:71\ntest set:\
    \ Error During Test at /tmp/tmpzis4cp9g.jl:75\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  UndefVarError:\
    \ i n"
  timestamp: 1659979126
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_paren_ixs = findall(isequal('('), paren_string)\n    close_paren_ixs\
    \ = findall(isequal(')'), paren_string)\n    group_strings = Vector{String}()\n\
    \    for i in 1:length(open_paren_ixs)\n        open_ix = open_paren_ixs[i]\n\
    \        close_ix = close_paren_ixs[findfirst(x -> x >= open_ix, close_paren_ixs)]\n\
    \        push!(group_strings, paren_string[open_ix:close_ix])\n    end\n    return\
    \ group_strings\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpgtguwpn9.jl:21

    '
  stdout: "test set: Test Failed at /tmp/tmpgtguwpn9.jl:24\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"()\", \"()\", \"((()\", \"(()\", \"()\", \"()\",\
    \ \"((()\", \"(()\", \"()\", \"()\", \"()\"] == [\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgtguwpn9.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgtguwpn9.jl:23\ntest set: Test\
    \ Failed at /tmp/tmpgtguwpn9.jl:25\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(()\"\
    , \"()\", \"((()\", \"(()\", \"()\", \"(((()\", \"((()\", \"(()\", \"()\"] ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgtguwpn9.jl:25 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpgtguwpn9.jl:23\ntest set: Test Failed at /tmp/tmpgtguwpn9.jl:26\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"(()\", \"()\", \"(()\", \"()\", \"((()\", \"(()\", \"()\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgtguwpn9.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgtguwpn9.jl:23\ntest set: Test\
    \ Failed at /tmp/tmpgtguwpn9.jl:27\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \"(( )\", \"\
    ( )\", \"(( )\", \"( )\", \"( )\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ ["
  timestamp: 1659979126
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    separations = Vector{String}()\n    paren_stack = []\n    temp_string\
    \ = \"\"\n    \n    for paren in paren_string\n        if paren != ' '\n     \
    \       push!(paren_stack, paren)\n        end\n    end\n    \n    for paren in\
    \ paren_stack\n        if paren == '('\n            temp_string = temp_string\
    \ * paren\n        elseif paren == ')'\n            temp_string = temp_string\
    \ * paren\n            push!(separations, temp_string)\n            temp_string\
    \ = \"\"\n        end\n    end\n    \n    return separations\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpxv17u9ro.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpxv17u9ro.jl:37\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"()\", \")\", \"((()\", \")\", \")\", \"()\", \"((()\"\
    , \")\", \"()\", \"()\", \")\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxv17u9ro.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxv17u9ro.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpxv17u9ro.jl:38\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(()\"\
    , \")\", \"((()\", \")\", \")\", \"(((()\", \")\", \")\", \")\"] == [\"()\", \"\
    (())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxv17u9ro.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxv17u9ro.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpxv17u9ro.jl:39\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"(()\", \")\", \"((()\", \"\
    )\", \")\", \")\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxv17u9ro.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpxv17u9ro.jl:36\ntest set: Test Failed at /tmp/tmpxv17u9ro.jl:40\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"()\", \"(()\", \")\", \"(()\", \"()\", \")\"] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n"
  timestamp: 1659979126
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: your code here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpxfavni0l.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpxfavni0l.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpxfavni0l.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxfavni0l.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxfavni0l.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpxfavni0l.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpxfavni0l.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659979128
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_braces = 0\n    current_group = \"\"\n    groups = []\n    for paren\
    \ in paren_string\n        if paren == '('\n            open_braces += 1\n   \
    \         current_group *= paren\n        elseif paren == ')'\n            open_braces\
    \ -= 1\n            current_group *= paren\n        end\n        if open_braces\
    \ == 0 && length(current_group) > 0\n            push!(groups, current_group)\n\
    \            current_group = \"\"\n        end\n    end\n    return groups\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659979124
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\"\n    all_parens = []\n    # do stuff\n    all_parens\n    \"\"\"\
    \n    pass\nend\n \n \nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpxw5haswt.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpxw5haswt.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: pass not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpxw5haswt.jl:14\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxw5haswt.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxw5haswt.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpxw5haswt.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: pass not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpxw5haswt.jl:14\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxw5haswt.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxw5haswt.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpxw5haswt.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: pass\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpxw5haswt.jl:14\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxw5haswt.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxw5haswt.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpxw5haswt.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  UndefVarE"
  timestamp: 1659979127
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_list = []\n    for c in paren_string\n        if c == '('\n    \
    \        push!(paren_list, c)\n        elseif c == ')'\n            if isempty(paren_list)\
    \ || (last(paren_list) != '(')\n                return false\n            else\n\
    \                pop!(paren_list)\n            end\n        end\n    end\n   \
    \ paren_string\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp79tcw9r5.jl:25

    '
  stdout: "test set: Error During Test at /tmp/tmp79tcw9r5.jl:28\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp79tcw9r5.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp79tcw9r5.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp79tcw9r5.jl:27\ntest set:\
    \ Error During Test at /tmp/tmp79tcw9r5.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type String to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp79tcw9r5.jl:21\n   [2] macro expansion\n     @ ~/.conda/"
  timestamp: 1659979128
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    separate_groups = [\"\"]\n    idx = 1\n    num_open = 0\n    num_close\
    \ = 0\n    while !end_of_string(paren_string, idx)\n        if paren_string[idx]\
    \ == '('\n            if num_open == 0 \n                idx += 1\n          \
    \  end\n            num_open += 1\n        elseif paren_string[idx] == ')'\n \
    \           num_close += 1\n        end\n        if num_open > 0 && num_open ==\
    \ num_close\n            separate_groups = [separate_groups; \"\"]\n         \
    \   num_open = 0\n            num_close = 0\n        else\n            separate_groups[end]\
    \ = join([separate_groups[end], paren_string[idx]])\n        end\n        idx\
    \ += 1\n    end\n    return separate_groups\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpdvrmvsa0.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmpdvrmvsa0.jl:38\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: end_of_string not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpdvrmvsa0.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdvrmvsa0.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdvrmvsa0.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpdvrmvsa0.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: end_of_string not defined\n  Stacktrace:\n   [1]\
    \ separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpdvrmvsa0.jl:13\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdvrmvsa0.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdvrmvsa0.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpdvrmvsa0.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: end_of_string\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpdvrmvsa0.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpdvrmvsa0.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpdvrmvsa0.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpdvrmvsa0.jl:41\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"("
  timestamp: 1659979127
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    # Initialize variables\n    groups = []                        \
    \                        # Vector of matched groups\n    balance = 0         \
    \                                       # How many open parentheses are we still\
    \ waiting to match\n    start_index = 1                                      \
    \      # Index where we last saw an open parenthesis\n    \n    # Loop through\
    \ the string\n    for (i, c) in enumerate(paren_string)\n        # If we find\
    \ an open parenthesis, increment the balance counter\n        if c == '('\n  \
    \          balance += 1\n        # If we find a closed parenthesis\n        elseif\
    \ c == ')'\n            # If the balance counter is 1, that is the last open parenthesis\n\
    \            if balance == 1\n                # Append the substring of paren_string\
    \ to groups\n                push!(groups, paren_string[start_index:i])\n    \
    \            # reset the balance counter and start_index counter\n           \
    \     balance = 0\n                start_index = i + 1\n            # If the balance\
    \ counter is not 1, then decrement it\n            else\n                balance\
    \ -= 1\n            end\n        end\n    end\n    \n    # Return the vector of\
    \ groups\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp6609i8lo.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmp6609i8lo.jl:44\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"] == [\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6609i8lo.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6609i8lo.jl:43\ntest set: Test Failed at /tmp/tmp6609i8lo.jl:45\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" (())\", \" ((()))\", \" (((())))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6609i8lo.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6609i8lo.jl:43\ntest set: Test Failed at /tmp/tmp6609i8lo.jl:47\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"( )\", \" (( ))\", \" (( )( ))\"] == [\"()\", \"(())\", \"\
    (()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6609i8lo.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6609i8lo.jl:43\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979127
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    op = []\n    for i in eachindex(paren_string)\n        if paren_string[i]\
    \ == '('\n            push!(op, i)\n        elseif paren_string[i] == ')'\n  \
    \          if length(op) > 0\n                pop!(op)\n            else\n   \
    \             error(\"Paren string is invalid.\")\n            end\n        end\n\
    \    end\n    if length(op) > 0\n        error(\"Paren string is invalid.\")\n\
    \    end\n    \n    groups = []\n    group = ''\n    parens = 0\n    for i in\
    \ eachindex(paren_string)\n        if paren_string[i] == '('\n            if parens\
    \ == 0\n                if length(group) > 0\n                    push!(groups,\
    \ group)\n                    group = ''\n                end\n            end\n\
    \            parens += 1\n        elseif paren_string[i] == ')'\n            parens\
    \ -= 1\n            if parens == 0\n                push!(groups, group)\n   \
    \             group = ''\n            end\n        elseif paren_string[i] != '\
    \ '\n            group = group * paren_string[i]\n        end\n    end\n    if\
    \ length(group) > 0\n        push!(groups, group)\n    end\n    return groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid empty character literal\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmprtlsm8je.jl:26\nin expression starting at\
    \ /tmp/tmprtlsm8je.jl:26\n"
  stdout: ''
  timestamp: 1659979126
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    stack = String[]\n    current_index = 1\n    paren_group = String[]\n\
    \    # for each char in the string\n    for c in paren_string\n        # if it's\
    \ a space, ignore\n        if c == ' '\n            continue\n        # if it's\
    \ an open parenthesis, add it to the current group\n        # and push it onto\
    \ the stack\n        elseif c == '('\n            append!(paren_group, c)\n  \
    \          push!(stack, c)\n        # if it's a close parenthesis\n        elseif\
    \ c == ')'\n            # check to see if there's something on the stack\n   \
    \         if isempty(stack)\n                error(\"Unbalanced parentheses\"\
    )\n            end\n            # if there is, pop from the stack, add close parenthesis\
    \ to group\n            pop!(stack)\n            append!(paren_group, c)\n   \
    \         # if the stack is empty after popping\n            if isempty(stack)\n\
    \                # add the paren group to the list of paren groups\n         \
    \       paren_group = join(paren_group, \"\")\n                # reset paren group\n\
    \                paren_group = String[]\n            end\n        else\n     \
    \       # you found an illegal character\n            error(\"Illegal character\
    \ found\")\n        end\n    end\n    # at the end, if the stack is not empty,\
    \ error, otherwise return the list of groups\n    if !isempty(stack)\n       \
    \ error(\"Unbalanced parentheses\")\n    end\n    return paren_group\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpzsxx327p.jl:51

    '
  stdout: "test set: Error During Test at /tmp/tmpzsxx327p.jl:54\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Char\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] setindex!(A::Vector{String}, x::Char, i1::Int64)\n\
    \     @ Base ./array.jl:903\n   [2] _append!\n     @ ./array.jl:1060 [inlined]\n\
    \   [3] append!\n     @ ./array.jl:1050 [inlined]\n   [4] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpzsxx327p.jl:20\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpzsxx327p.jl:54 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpzsxx327p.jl:53\ntest set:\
    \ Error During Test at /tmp/tmpzsxx327p.jl:55\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Char to an object\
    \ of type String\n  Closest candidates are:\n    convert(::Type{String}, !Matched::String)\
    \ at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] setindex!(A::Vector{String}, x::Char, i1::Int64)\n\
    \     @ Base ./array.jl:903\n   [2] _append!\n     @ ."
  timestamp: 1659979129
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    groups = []\n    balanced = false\n    paren_string = replace(paren_string,\
    \ \" \" => \"\")\n    for i in 1:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            if balanced\n                push!(groups, \"\")\n     \
    \       end\n            balanced = true\n        end\n        if balanced\n \
    \           groups[end] *= paren_string[i]\n        end\n        if paren_string[i]\
    \ == ')'\n            balanced = false\n        end\n    end\n    return groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp4_sc4lce.jl:30

    '
  stdout: "test set: Error During Test at /tmp/tmp4_sc4lce.jl:33\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  BoundsError: attempt to access 0-element Vector{Any}\
    \ at index [0]\n  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n\
    \   [2] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmp4_sc4lce.jl:20\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4_sc4lce.jl:33 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp4_sc4lce.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp4_sc4lce.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  BoundsError: attempt to access 0-element Vector{Any} at index [0]\n\
    \  Stacktrace:\n   [1] getindex\n     @ ./array.jl:861 [inlined]\n   [2] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp4_sc4lce.jl:20\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4_sc4lce.jl:34 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp4_sc4lce.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp4_sc4lce.jl:35\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  BoundsError: attempt\
    \ to access 0-element Vector{Any} at index [0]\n  Stacktrace:\n   [1] getindex\n\
    \     @ ./array.jl:861 [inlined]\n   [2] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp4_sc4lce.jl:20\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp4_sc4lce.jl:35 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/T"
  timestamp: 1659979128
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Split paren_string by spaces\n    paren_array = split(paren_string,\
    \ \" \")\n    paren_array = filter(x -> length(x) > 0, paren_array)\n    # print(paren_array)\n\
    \    paren_groups = []\n    for p in paren_array\n        if p[1] == '('\n   \
    \         paren_groups = push!(paren_groups, p)\n        end\n    end\n    return\
    \ paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp_fir29kr.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmp_fir29kr.jl:29\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"(\"\
    , \"((\", \"((\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_fir29kr.jl:29 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp_fir29kr.jl:25\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    3     1      4\n"
  timestamp: 1659979127
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_groups = split(paren_string, \") (\")\n    return [x[2:end-1] for\
    \ x in paren_groups]\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpy5iof7bw.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpy5iof7bw.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"()(\", \"()\", \"\", \"())()()\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy5iof7bw.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy5iof7bw.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpy5iof7bw.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"\",\
    \ \"()\", \"(()))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy5iof7bw.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy5iof7bw.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpy5iof7bw.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"()(())((()))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy5iof7bw.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy5iof7bw.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpy5iof7bw.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \" \", \" )( )\"\
    ] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy5iof7bw.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test."
  timestamp: 1659979127
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your Code Here\n    count = 0\n    paren = 0\n    ret = []\n    for\
    \ c in paren_string\n        if c == ' '\n            continue\n        end\n\
    \        if paren == 0\n            paren = 1\n            count = 0\n       \
    \ end\n        if c == '('\n            count += 1\n        elseif c == ')'\n\
    \            count -= 1\n        end\n        if count == 0\n            push!(ret,\
    \ paren_string[paren:length(paren_string)])\n            paren = 0\n        end\n\
    \    end\n    ret\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpufuh7xwn.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmpufuh7xwn.jl:38\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()) ((())) () ((())()())\", \"(()()) ((())) () ((())()())\"\
    , \"(()()) ((())) () ((())()())\", \"(()()) ((())) () ((())()())\"] == [\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpufuh7xwn.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpufuh7xwn.jl:37\ntest set: Test Failed at /tmp/tmpufuh7xwn.jl:39\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: [\"() (()) ((())) (((())))\", \"() (())\
    \ ((())) (((())))\", \"() (()) ((())) (((())))\", \"() (()) ((())) (((())))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpufuh7xwn.jl:39 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpufuh7xwn.jl:37\ntest set: Test Failed at /tmp/tmpufuh7xwn.jl:41\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"( ) (( )) (( )( ))\", \"( ) (( )) (( )( ))\", \"( ) (( ))\
    \ (( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpufuh7xwn.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpufuh7xwn.jl:37\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979127
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_indices = []\n    for (idx, char) in enumerate(paren_string)\n \
    \       if char == '(' || char == ')'\n            push!(paren_indices, idx)\n\
    \        end\n    end\n    num_paren_groups = (length(paren_indices) + 1) / 2\n\
    \    paren_groups = fill([\"\"], num_paren_groups)\n    next_group_index = 1\n\
    \    for i in 1:2:length(paren_indices)\n        paren_groups[next_group_index]\
    \ = paren_string[paren_indices[i]:paren_indices[i+1]]\n        next_group_index\
    \ += 1\n    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpgsc_f7zd.jl:26

    '
  stdout: "test set: Error During Test at /tmp/tmpgsc_f7zd.jl:29\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching fill(::Vector{String},\
    \ ::Float64)\n  Closest candidates are:\n    fill(::Any, !Matched::Union{Integer,\
    \ AbstractUnitRange}...) at ~/.conda/envs/polyglot/share/julia/base/array.jl:471\n\
    \    fill(::Any, !Matched::Tuple{}) at ~/.conda/envs/polyglot/share/julia/base/array.jl:474\n\
    \    fill(::Any, !Matched::Tuple{Vararg{Integer, N}}) where N at ~/.conda/envs/polyglot/share/julia/base/array.jl:473\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpgsc_f7zd.jl:16\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgsc_f7zd.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgsc_f7zd.jl:28\ntest set:\
    \ Error During Test at /tmp/tmpgsc_f7zd.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching fill(::Vector{String}, ::Float64)\n\
    \  Closest candidates are:\n    fill(::Any, !Matched::Union{Integer, AbstractUnitRange}...)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:471\n    fill(::Any, !Matched::Tuple{})\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:474\n    fill(::Any, !Matched::Tuple{Vararg{Integer,\
    \ N}}) where N at ~/.conda/envs/polyglot/share/julia/base/array.jl:473\n    ...\n\
    \  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmpgsc_f7zd.jl:16\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgsc_f7zd.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /"
  timestamp: 1659979129
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_stack = []\n    first_index = 0\n    result = []\n    for (index,\
    \ char) in enumerate(paren_string)\n        if char == '('\n            push!(paren_stack,\
    \ char)\n        elseif char == ')'\n            if length(paren_stack) == 0\n\
    \                error(\"Unmatched closing parenthesis found at index $index\"\
    )\n            end\n            pop!(paren_stack)\n            if length(paren_stack)\
    \ == 0\n                result = vcat(result, string(paren_string[first_index:index]))\n\
    \                first_index = index + 1\n            end\n        end\n    end\n\
    \    if length(paren_stack) > 0\n        error(\"Unmatched opening parenthesis\
    \ found at index $(paren_stack[1])\")\n    end\n    return result\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpkrtboerh.jl:33

    '
  stdout: "test set: Error During Test at /tmp/tmpkrtboerh.jl:36\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  BoundsError: attempt to access 27-codeunit String\
    \ at index [0:6]\n  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216\
    \ [inlined]\n   [2] getindex\n     @ ./strings/string.jl:261 [inlined]\n   [3]\
    \ separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpkrtboerh.jl:21\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpkrtboerh.jl:36 [inlined]\n\
    \   [6] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpkrtboerh.jl:35\ntest set:\
    \ Error During Test at /tmp/tmpkrtboerh.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  BoundsError: attempt to access 23-codeunit String at index [0:2]\n\
    \  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216 [inlined]\n\
    \   [2] getindex\n     @ ./strings/string.jl:261 [inlined]\n   [3] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpkrtboerh.jl:21\n   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpkrtboerh.jl:37 [inlined]\n\
    \   [6] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpkrtboerh.jl:35\ntest set:\
    \ Error During Test at /tmp/tmpkrtboerh.jl:38\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  BoundsError: attempt\
    \ to access 14-codeunit String at index [0:14]\n  Stacktrace:\n   [1] checkbounds\n\
    \     @ ./strings/basic.jl:216 [inlined]\n   [2] getindex\n     @ ./strings/string.jl:261\
    \ [inlined]\n   [3] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpkrtboerh.jl:21\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/pol"
  timestamp: 1659979128
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n   \n    # We use a stack to keep track of the parenthesis and then build\
    \ the \n    # groups as needed.\n    paren_groups = []\n    stack = []\n    curr_group\
    \ = \"\"\n    for c in paren_string\n        if c == '('\n            push!(stack,\
    \ c)\n        elseif c == ')'\n            if stack == []\n                # We\
    \ have encountered a ')' that doesn't have an open parenthesis. This means the\
    \ input string is invalid\n                error(\"Parenthesis group is not balanced!\"\
    )\n            end\n            pop!(stack)\n            curr_group *= \")\"\n\
    \        elseif c != ' '\n            # Ignore spaces\n            curr_group\
    \ *= c\n        end\n        if stack == []\n            # If the stack is empty,\
    \ we know we have found the end of a group. Add it to the vector and reset the\n\
    \            # group string.\n            push!(paren_groups, curr_group)\n  \
    \          curr_group = \"\"\n        end\n    end\n    if stack != []\n     \
    \   # If the stack is not empty, then the input string is invalid\n        error(\"\
    Parenthesis group is not balanced!\")\n    end\n    return paren_groups\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpza0ksogk.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpza0ksogk.jl:47\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\")))\", \"\", \")))\", \"\", \")\", \"\", \")))))\"] == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpza0ksogk.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpza0ksogk.jl:46\ntest set: Test Failed at /tmp/tmpza0ksogk.jl:48\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: [\")\", \"\", \"))\", \"\", \")))\", \"\
    \", \"))))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpza0ksogk.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpza0ksogk.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpza0ksogk.jl:49\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\")))))))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpza0ksogk.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpza0ksogk.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpza0ksogk.jl:50\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\")\", \"\", \"))\"\
    , \"\", \")))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpza0ksogk.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/ju"
  timestamp: 1659979127
- exit_code: -1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    n = length(paren_string)\n    out = Vector{String}()\n    i = 1\n    while\
    \ i <= n\n        if paren_string[i] == '('\n            j = i + 1\n         \
    \   stack = 0\n            while j <= n\n                if paren_string[j] ==\
    \ '('\n                    stack += 1\n                elseif paren_string[j]\
    \ == ')'\n                    stack -= 1\n                end\n              \
    \  if stack == 0\n                    push!(out, paren_string[i:j])\n        \
    \            i = j + 1\n                    break\n                end\n     \
    \           j += 1\n            end\n        else\n            i += 1\n      \
    \  end\n    end\n    return out\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Test Failed at /tmp/tmph2txdv3l.jl:40\n  Expression: candidate("(()())
    ((())) () ((())()())") == ["(()())", "((()))", "()", "((())()())"]\n   Evaluated:
    ["(()", "()) ((", "())) () (((", "()("] == ["(()())", "((()))", "()", "((())()())"]\nStacktrace:\n
    [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n [2] macro expansion\n   @ /tmp/tmph2txdv3l.jl:40 [inlined]\n [3] macro
    expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n [4] top-level scope\n   @ /tmp/tmph2txdv3l.jl:39\n'''
  timestamp: 1659979130
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    pass\nend\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp9d1d4e1a.jl:267

    '
  stdout: "test set: Error During Test at /tmp/tmp9d1d4e1a.jl:270\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: pass not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmp9d1d4e1a.jl:9\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9d1d4e1a.jl:270 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9d1d4e1a.jl:269\ntest set:\
    \ Error During Test at /tmp/tmp9d1d4e1a.jl:271\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: pass not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp9d1d4e1a.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9d1d4e1a.jl:271 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9d1d4e1a.jl:269\ntest set:\
    \ Error During Test at /tmp/tmp9d1d4e1a.jl:272\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: pass\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp9d1d4e1a.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9d1d4e1a.jl:272 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9d1d4e1a.jl:269\ntest set:\
    \ Error During Test at /tmp/tmp9d1d4e1a.jl:273\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  Un"
  timestamp: 1659979128
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # write your code here\n    n = length(paren_string)\n    string_list\
    \ = []\n    counter = 0\n    start = 1\n    for i = 1:n\n        if paren_string[i]\
    \ == '('\n            counter += 1\n        elseif paren_string[i] == ')'\n  \
    \          counter -= 1\n        end\n        if counter == 0 && i != n\n    \
    \        string_list = [string_list; paren_string[start:i]]\n            start\
    \ = i+1\n        end\n    end\n    string_list = [string_list; paren_string[start:n]]\n\
    \    return string_list\nend\nparen_string = \"( ) (( )) (( )( ))\"\nprintln(separate_paren_groups(paren_string))\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8zytzdcj.jl:32

    '
  stdout: "[\"( )\", \" \", \"(( ))\", \" \", \"(( )( ))\"]\ntest set: Test Failed\
    \ at /tmp/tmp8zytzdcj.jl:35\n  Expression: candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n   Evaluated: [\"(()())\"\
    , \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"] == [\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8zytzdcj.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8zytzdcj.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp8zytzdcj.jl:36\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" \"\
    , \"(())\", \" \", \"((()))\", \" \", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8zytzdcj.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8zytzdcj.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp8zytzdcj.jl:38\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \" \", \"((\
    \ ))\", \" \", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8zytzdcj.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8zytzdcj.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979128
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # initialize an empty string vector\n    groups = String[]\n    # initialize\
    \ the counter\n    counter = 0\n    # initialize empty string to append\n    temp_string\
    \ = \"\"\n    # loop through the string\n    for c in paren_string\n        #\
    \ if it is an open paren\n        if c == '('\n            # increment the counter\n\
    \            counter += 1\n            # append it to the temporary string\n \
    \           push!(temp_string, c)\n        # if it is a closed paren\n       \
    \ elseif c == ')'\n            # decrement the counter\n            counter -=\
    \ 1\n            # append it to the temporary string\n            push!(temp_string,\
    \ c)\n        end\n        # if the counter is zero\n        if counter == 0\n\
    \            # append the temporary string to the group\n            push!(groups,\
    \ temp_string)\n            # reinitialize the temporary string\n            temp_string\
    \ = \"\"\n        end\n    end\n    # return the groups\n    return groups\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpy3065atj.jl:43

    '
  stdout: "test set: Error During Test at /tmp/tmpy3065atj.jl:46\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching push!(::String, ::Char)\n\
    \  Closest candidates are:\n    push!(::Any, ::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at ~/.conda/envs/polyglot/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpy3065atj.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpy3065atj.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpy3065atj.jl:45\ntest set:\
    \ Error During Test at /tmp/tmpy3065atj.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching push!(::String, ::Char)\n  Closest\
    \ candidates are:\n    push!(::Any, ::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at ~/.conda/envs/polyglot/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpy3065atj.jl:22\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpy3065atj.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]"
  timestamp: 1659979130
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # left_paren = nothing\n    # right_paren = nothing\n    counter = 0\n\
    \    temp_string = \"\"\n    result = Vector{String}()\n    for i in 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            push!(result, paren_string[i])\n\
    \            counter += 1\n        elseif paren_string[i] == ')'\n           \
    \ push!(result, paren_string[i])\n            counter -= 1\n        end\n    end\n\
    \    return result\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp2wddww2s.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmp2wddww2s.jl:30\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Char\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{String}, item::Char)\n     @ Base\
    \ ./array.jl:994\n   [2] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmp2wddww2s.jl:16\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp2wddww2s.jl:30 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp2wddww2s.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp2wddww2s.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Char to an object\
    \ of type String\n  Closest candidates are:\n    convert(::Type{String}, !Matched::String)\
    \ at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{String}, item::Char)\n     @ Base\
    \ ./array.jl:994\n   [2] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmp2wddww2s.jl:16\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/"
  timestamp: 1659979130
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    open_paren = count(x -> x == '(', paren_string)\n    close_paren\
    \ = count(x -> x == ')', paren_string)\n    \n    if open_paren != close_paren\n\
    \        println(\"Parens do not match\")\n        return -1\n    end\n    \n\
    \    vec = Vector{String}[]\n    i = 1\n    temp = \"\"\n    while i <= length(paren_string)\n\
    \        if paren_string[i] == '('\n            temp = temp * paren_string[i]\n\
    \        elseif paren_string[i] == ')'\n            temp = temp * paren_string[i]\n\
    \            if (count(x -> x == '(', temp) == count(x -> x == ')', temp)) &&\
    \ (count(x -> x == '(', temp) != 0)\n                push!(vec, temp)\n      \
    \          temp = \"\"\n            end\n        end\n        i += 1\n    end\n\
    \    return vec\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpd3rgmqra.jl:37

    '
  stdout: "test set: Error During Test at /tmp/tmpd3rgmqra.jl:40\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type String\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{Vector{String}}, item::String)\n\
    \     @ Base ./array.jl:994\n   [2] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpd3rgmqra.jl:27\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpd3rgmqra.jl:40 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpd3rgmqra.jl:39\ntest set:\
    \ Error During Test at /tmp/tmpd3rgmqra.jl:41\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type String to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{Vector{String}}, item"
  timestamp: 1659979131
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    output = []\n    current_group = \"\"\n    opened = 0\n    for c in paren_string\n\
    \        if c == ' '\n            continue\n        end\n        if c == '('\n\
    \            opened += 1\n        elseif c == ')'\n            opened -= 1\n \
    \       end\n        current_group *= c\n        if opened == 0\n            push!(output,\
    \ current_group)\n            current_group = \"\"\n        end\n    end\n   \
    \ return output\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659979127
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\"\n    INPUT: a string with braces that are either open, balanced,\
    \ or nested.\n    OUTPUT: a Vector{String} with the same braces, but separated\
    \ into separate Strings.\n    ALGORITHM:\n    1. Remove spaces\n    2. Create\
    \ a stack with an empty String\n    3. Iterate through the String\n        If\
    \ the character is an open paren, push an empty String onto the stack.\n     \
    \   If the character is a close paren, pop the stack, push the popped String plus\
    \ the current character\n           onto the popped String, and push that new\
    \ String onto the stack.\n        If the character is not a paren, push the current\
    \ character onto the String on the top of the stack.\n    4. Pop the stack and\
    \ return the popped String, split by open parens.\n    \"\"\"\n    # remove spaces\n\
    \    no_spaces = string(replace(paren_string, \" \" => \"\"))\n    # create a\
    \ stack\n    stack = Vector{String}()\n    push!(stack, \"\")\n    # iterate through\
    \ the String\n    for i = 1:length(no_spaces)\n        # if the character is an\
    \ open paren, push an empty String onto the stack\n        if no_spaces[i] ==\
    \ '('\n            push!(stack, \"\")\n        # if the character is a close paren,\
    \ pop the stack, push the popped String plus the current character\n        #\
    \ onto the popped String, and push that new String onto the stack\n        elseif\
    \ no_spaces[i] == ')'\n            popped = pop!(stack)\n            push!(stack,\
    \ popped * string(no_spaces[i]))\n            # push!(stack, popped * string(no_spaces[i]))\n\
    \        # if the character is not a paren, push the current character onto the\
    \ String on the top of the stack\n        else\n            current = stack[end]\n\
    \            push!(stack, current * string(no_spaces[i]))\n        end\n    end\n\
    \    # pop the stack and return the popped String, split by open parens\n    return\
    \ split(stack[end], \"(\"; limit=length(stack[end]))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpnl8yoxbo.jl:49

    '
  stdout: "test set: Test Failed at /tmp/tmpnl8yoxbo.jl:52\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"))\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnl8yoxbo.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnl8yoxbo.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpnl8yoxbo.jl:53\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"))))\"] ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnl8yoxbo.jl:53 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnl8yoxbo.jl:51\ntest set: Test Failed at /tmp/tmpnl8yoxbo.jl:54\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"))))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnl8yoxbo.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnl8yoxbo.jl:51\ntest set: Test Failed at /tmp/tmpnl8yoxbo.jl:55\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnl8yoxbo.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnl8yo"
  timestamp: 1659979129
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = paren_string.replace(\" \", \"\"\
    )\n    open_brackets = [\"(\", \"[\", \"{\"]\n    close_brackets = [\")\", \"\
    ]\", \"}\"]\n    output = []\n    temp = \"\"\n    counter = 0\n    for i in 1:length(paren_string)\n\
    \        character = paren_string[i]\n        if character in open_brackets\n\
    \            push!(temp, character)\n            counter += 1\n        elseif\
    \ character in close_brackets\n            counter -= 1\n            push!(temp,\
    \ character)\n        end\n        if counter == 0\n            push!(output,\
    \ temp)\n            temp = \"\"\n        end\n    end\n    return output\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpobme7d8b.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmpobme7d8b.jl:37\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  type String has no field replace\n  Stacktrace:\n\
    \   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n   [2] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpobme7d8b.jl:10\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpobme7d8b.jl:37 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpobme7d8b.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpobme7d8b.jl:38\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  type String has no field replace\n  Stacktrace:\n   [1] getproperty\n\
    \     @ ./Base.jl:42 [inlined]\n   [2] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpobme7d8b.jl:10\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpobme7d8b.jl:38 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpobme7d8b.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpobme7d8b.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  type String has no\
    \ field replace\n  Stacktrace:\n   [1] getproperty\n     @ ./Base.jl:42 [inlined]\n\
    \   [2] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpobme7d8b.jl:10\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpobme7d8b.jl:39 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpobme7d8b.jl:36\ntest set:\
    \ Er"
  timestamp: 1659979129
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_paren_counter = 0\n    closed_paren_counter = 0\n    start_position\
    \ = 1\n    group_strings = Vector{String}()\n    for (i, char) in enumerate(paren_string)\n\
    \        if char == '('\n            open_paren_counter += 1\n        elseif char\
    \ == ')'\n            closed_paren_counter += 1\n        end\n        if open_paren_counter\
    \ == closed_paren_counter && i > 0\n            push!(group_strings, paren_string[start_position:i])\n\
    \            start_position = i + 1\n        end\n    end\n    return group_strings\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmph_yk5ai_.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmph_yk5ai_.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph_yk5ai_.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph_yk5ai_.jl:30\ntest set: Test\
    \ Failed at /tmp/tmph_yk5ai_.jl:32\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" \"\
    , \"(())\", \" \", \"((()))\", \" \", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph_yk5ai_.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph_yk5ai_.jl:30\ntest set: Test\
    \ Failed at /tmp/tmph_yk5ai_.jl:34\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \" \", \"((\
    \ ))\", \" \", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph_yk5ai_.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph_yk5ai_.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979129
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    paren_string = replace(paren_string, \" \" => \"\
    \")\n    length = size(paren_string,1)\n    paren_array = []\n    j = 1\n    for\
    \ i = 1:length\n        if paren_string[i] == '('\n            push!(paren_array,\
    \ j)\n            j += 1\n        elseif paren_string[i] == ')'\n            pop!(paren_array)\n\
    \        end\n    end\n    paren_string_temp = paren_string\n    paren_array_temp\
    \ = paren_array\n    result = []\n    while(size(paren_array_temp,1) > 0)\n  \
    \      paren_array_temp = paren_array\n        paren_string_temp = paren_string\n\
    \        temp = split(paren_string_temp, '(')[paren_array_temp[end]]\n       \
    \ temp = split(temp, ')')[1]\n        push!(result, temp)\n        for i = 1:size(temp,1)\n\
    \            paren_string_temp = replace(paren_string_temp,temp[i] => ' ')\n \
    \       end\n        pop!(paren_array_temp)\n    end\n    return result\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp1c1od3qk.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp1c1od3qk.jl:43\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching size(::String, ::Int64)\n\
    \  Closest candidates are:\n    size(!Matched::Union{LinearAlgebra.QR, LinearAlgebra.QRCompactWY,\
    \ LinearAlgebra.QRPivoted}, ::Integer) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/qr.jl:566\n\
    \    size(!Matched::Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T,\
    \ S}} where {T, S}, ::Any) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/symmetric.jl:201\n\
    \    size(!Matched::Union{LinearAlgebra.Cholesky, LinearAlgebra.CholeskyPivoted},\
    \ ::Integer) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/cholesky.jl:495\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp1c1od3qk.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1c1od3qk.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1c1od3qk.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp1c1od3qk.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching size(::String, ::Int64)\n  Closest\
    \ candidates are:\n    size(!Matched::Union{LinearAlgebra.QR, LinearAlgebra.QRCompactWY,\
    \ LinearAlgebra.QRPivoted}, ::Integer) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/qr.jl:566\n\
    \    size(!Matched::Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T,\
    \ S}} where {T, S}, ::Any) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/symmetric.jl:201\n\
    \    size(!Matched::Union{LinearAlgebra.Cholesky, LinearAlgebra.CholeskyPivoted},\
    \ ::Integer) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/cho"
  timestamp: 1659979131
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # i = 1\n    # open_paren = 0\n    # close_paren = 0\n    # start_ind\
    \ = 0\n    # end_ind = 0\n    # output = []\n    # while i <= length(paren_string)\n\
    \    #     if paren_string[i] == '('\n    #         open_paren += 1\n    #   \
    \      if open_paren == 1\n    #             start_ind = i\n    #         end\n\
    \    #     elseif paren_string[i] == ')'\n    #         close_paren += 1\n   \
    \ #         if close_paren == open_paren\n    #             end_ind = i\n    #\
    \             push!(output, paren_string[start_ind:end_ind])\n    #          \
    \   open_paren = 0\n    #             close_paren = 0\n    #         end\n   \
    \ #     end\n    #     i += 1\n    # end\n    # return output\n    # \n    split_string\
    \ = split(paren_string, \")\")\n    split_string = [x for x in split_string if\
    \ x != \"\"]\n    split_string = [x * \")\" for x in split_string]\n    valid_string\
    \ = [x for x in split_string if isvalid(x)]\n    return valid_string\n    \nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp1thjapox.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp1thjapox.jl:1\n\
    in expression starting at /tmp/tmp1thjapox.jl:1\n"
  stdout: ''
  timestamp: 1659979129
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Remove whitespace\n    paren_string = replace(paren_string, \" \" =>\
    \ \"\")\n    paren_starts = findall(Regex(\"\\\\(\"), paren_string)\n    paren_ends\
    \ = findall(Regex(\"\\\\)\"), paren_string)\n    nested_groups = 0\n    res =\
    \ []\n    cur_start = paren_starts[1]\n    for i in paren_ends\n        if i ==\
    \ cur_start\n            nested_groups += 1\n            push!(res, paren_string[cur_start:i])\n\
    \            cur_start = paren_starts[findnext(x -> x > i, paren_starts)]\n  \
    \      elseif nested_groups == 0\n            push!(res, paren_string[cur_start:i])\n\
    \            cur_start = paren_starts[findnext(x -> x > i, paren_starts)]\n  \
    \      else\n            nested_groups -= 1\n        end\n    end\n    return\
    \ res\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmptqok4lrs.jl:32

    '
  stdout: "test set: Error During Test at /tmp/tmptqok4lrs.jl:35\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Int64\
    \ to an object of type StepRangeLen{Int64, Int64, Int64, Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractRange) where T<:AbstractRange at ~/.conda/envs/polyglot/share/julia/base/range.jl:215\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] oftype(x::StepRangeLen{Int64, Int64, Int64, Int64},\
    \ y::Int64)\n     @ Base ./essentials.jl:396\n   [2] (::Colon)(start::UnitRange{Int64},\
    \ stop::UnitRange{Int64})\n     @ Base ./range.jl:7\n   [3] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmptqok4lrs.jl:0\n   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmptqok4lrs.jl:35 [inlined]\n\
    \   [6] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmptqok4lrs.jl:34\ntest set:\
    \ Error During Test at /tmp/tmptqok4lrs.jl:36\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Int64 to an object\
    \ of type StepRangeLen{Int64, Int64, Int64, Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractRange) where T<:AbstractRange at ~/.conda/envs/polyglot/share/julia/base/range.jl:215\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at "
  timestamp: 1659979132
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkynnjxu7.jl:13

    '
  stdout: "test set: Test Failed at /tmp/tmpkynnjxu7.jl:16\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkynnjxu7.jl:16 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkynnjxu7.jl:15\ntest set: Test\
    \ Failed at /tmp/tmpkynnjxu7.jl:17\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkynnjxu7.jl:17 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkynnjxu7.jl:15\ntest set: Test Failed at /tmp/tmpkynnjxu7.jl:18\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkynnjxu7.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkynnjxu7.jl:15\ntest set: Test\
    \ Failed at /tmp/tmpkynnjxu7.jl:19\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkynnjxu7.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk"
  timestamp: 1659979130
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7g06ubr_.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmp7g06ubr_.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7g06ubr_.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7g06ubr_.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp7g06ubr_.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7g06ubr_.jl:18 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7g06ubr_.jl:16\ntest set: Test Failed at /tmp/tmp7g06ubr_.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7g06ubr_.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7g06ubr_.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp7g06ubr_.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7g06ubr_.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7"
  timestamp: 1659979130
- exit_code: -1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    num_open = 0\n    num_close = 0\n    curr_paren = String()\n    paren_groups\
    \ = Vector{String}()\n    for c in paren_string\n        if c == '('\n       \
    \     push!(curr_paren, '(')\n            num_open += 1\n        elseif c == ')'\n\
    \            push!(curr_paren, ')')\n            num_close += 1\n        end\n\
    \        if num_open == num_close\n            push!(paren_groups, curr_paren)\n\
    \            curr_paren = String()\n            num_open = 0\n            num_close\
    \ = 0\n        end\n    end\n    return paren_groups\nend\nseparate_paren_groups(\"\
    ( ) (( )) (( )( ))\")\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: Timeout
  stderr: 'b''ERROR: LoadError: MethodError: no method matching String()\nClosest
    candidates are:\n  String(!Matched::String) at ~/.conda/envs/polyglot/share/julia/base/boot.jl:363\n  String(!Matched::Vector{UInt8})
    at ~/.conda/envs/polyglot/share/julia/base/strings/string.jl:53\n  String(!Matched::Symbol)
    at ~/.conda/envs/polyglot/share/julia/base/strings/string.jl:83\n  ...\nStacktrace:\n
    [1] '''
  stdout: None
  timestamp: 1659979132
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_parens = 0\n    group_str = \"\"\n    group_strs = Vector{String}()\n\
    \    paren_string = replace(paren_string, \" \" => \"\")\n    for (i,paren) in\
    \ enumerate(paren_string)\n        if paren == '('\n            open_parens +=\
    \ 1\n        elseif paren == ')'\n            open_parens -= 1\n        end\n\
    \        group_str *= paren\n        if open_parens == 0\n            push!(group_strs,\
    \ group_str)\n            group_str = \"\"\n        end\n    end\n    return group_strs\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659979128
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    groups = []\n    # get rid of spaces\n    paren_string = filter(paren_string)\
    \ do c\n        return c != ' '\n    end\n    # process string\n    open_count\
    \ = 0\n    for c in paren_string\n        if c == '('\n            open_count\
    \ += 1\n        elseif c == ')'\n            open_count -= 1\n        end\n  \
    \      if open_count == 0\n            # we've reached the end of a group\n  \
    \          push!(groups, paren_string[1:end])\n            paren_string = paren_string[end+1:end]\n\
    \        end\n    end\n    return groups\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpzjg42hw4.jl:32

    '
  stdout: "test set: Test Failed at /tmp/tmpzjg42hw4.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())((()))()((())()())\", \"\", \"\", \"\"] == [\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzjg42hw4.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzjg42hw4.jl:34\ntest set: Test Failed at /tmp/tmpzjg42hw4.jl:36\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: [\"()(())((()))(((())))\", \"\", \"\",\
    \ \"\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzjg42hw4.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzjg42hw4.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpzjg42hw4.jl:38\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()(())(()())\", \"\
    \", \"\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzjg42hw4.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzjg42hw4.jl:34\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979130
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    index = 1\n    open_parens = 0\n    closed_parens = 0\n    paren_groups\
    \ = Vector{String}()\n    while index <= length(paren_string)\n        if paren_string[index]\
    \ == '('\n            open_parens += 1\n        elseif paren_string[index] ==\
    \ ')'\n            closed_parens += 1\n        end\n        if closed_parens ==\
    \ open_parens && open_parens != 0\n            push!(paren_groups, paren_string[index\
    \ - closed_parens - open_parens + 1:index])\n            open_parens = 0\n   \
    \         closed_parens = 0\n        end\n        index += 1\n    end\n    return\
    \ paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpw1his75g.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmpw1his75g.jl:36\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\" )\"\
    , \"( ))\", \" )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw1his75g.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw1his75g.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     1      4\n"
  timestamp: 1659979131
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here \nend\n@test separate_paren_groups(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n \nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: UndefVarError: @test not defined

    in expression starting at /tmp/tmpzhz3478p.jl:11

    in expression starting at /tmp/tmpzhz3478p.jl:11

    '
  stdout: ''
  timestamp: 1659979130
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    output = Vector{String}()\n\
    \    i = 1\n    while i <= length(paren_string)\n        j = i\n        while\
    \ paren_string[j] != ')'\n            j += 1\n        end\n        push!(output,paren_string[i:j])\n\
    \        i = j + 1\n    end\n    return output\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpm9nbf8w4.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpm9nbf8w4.jl:27\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"()\", \")\", \"((()\", \")\", \")\", \"()\", \"((()\"\
    , \")\", \"()\", \"()\", \")\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm9nbf8w4.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm9nbf8w4.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpm9nbf8w4.jl:28\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(()\"\
    , \")\", \"((()\", \")\", \")\", \"(((()\", \")\", \")\", \")\"] == [\"()\", \"\
    (())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm9nbf8w4.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm9nbf8w4.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpm9nbf8w4.jl:29\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"(()\", \")\", \"((()\", \"\
    )\", \")\", \")\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpm9nbf8w4.jl:29 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpm9nbf8w4.jl:26\ntest set: Test Failed at /tmp/tmpm9nbf8w4.jl:30\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"()\", \"(()\", \")\", \"(()\", \"()\", \")\"] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n"
  timestamp: 1659979131
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    return sep(split(replace(paren_string, ' ' => \"\"), \")(\"))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpynbw23hh.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpynbw23hh.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: sep not defined\n  Stacktrace:\n \
    \  [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpynbw23hh.jl:9\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpynbw23hh.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpynbw23hh.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpynbw23hh.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: sep not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpynbw23hh.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpynbw23hh.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpynbw23hh.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpynbw23hh.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: sep\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpynbw23hh.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpynbw23hh.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpynbw23hh.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpynbw23hh.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  UndefVarError: "
  timestamp: 1659979131
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    new_string = replace(paren_string, \" \" => \"\")\n    paren_groups =\
    \ []\n    temp_string = \"\"\n    for i = 1:length(new_string)\n        if new_string[i]\
    \ == '('\n            push!(paren_groups, temp_string)\n            temp_string\
    \ = \"(\"\n        elseif new_string[i] == ')'\n            temp_string *= \"\
    )\"\n            push!(paren_groups, temp_string)\n            temp_string = \"\
    \"\n        else\n            temp_string *= new_string[i]\n        end\n    end\n\
    \    paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp001ypxqp.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp001ypxqp.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"\", \"(\", \"()\", \"\", \"()\", \")\", \"\", \"(\", \"(\"\
    , \"()\"  \u2026  \"\", \"(\", \"(\", \"()\", \")\", \"\", \"()\", \"\", \"()\"\
    , \")\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp001ypxqp.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp001ypxqp.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp001ypxqp.jl:32\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"()\"\
    , \"\", \"(\", \"()\", \")\", \"\", \"(\", \"(\", \"()\", \")\", \")\", \"\",\
    \ \"(\", \"(\", \"(\", \"()\", \")\", \")\", \")\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp001ypxqp.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp001ypxqp.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp001ypxqp.jl:33\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"\", \"(\", \"()\", \"\", \"(\", \"\
    ()\", \")\", \"\", \"(\", \"(\", \"()\", \")\", \")\", \")\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp001ypxqp.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp001ypxqp.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp001ypxqp.jl:34\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \"()\", \"\",\
    \ \"(\", \"()\", \")\", \"\", \"(\", \"()\", \"\", \"()\", \")\"] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n ["
  timestamp: 1659979131
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    n = length(paren_string)\n    paren_string = replace(paren_string,\
    \ \" \" => \"\")\n    i = 1\n    open_bracket = 0\n    close_bracket = 0\n   \
    \ start = 0\n    finish = 0\n    result = []\n    while i <= n\n        if paren_string[i]\
    \ == '('\n            open_bracket += 1\n            if start == 0\n         \
    \       start = i\n            end\n        elseif paren_string[i] == ')'\n  \
    \          close_bracket += 1\n            if close_bracket == open_bracket\n\
    \                finish = i\n                push!(result, paren_string[start:finish])\n\
    \                start = 0\n                finish = 0\n                open_bracket\
    \ = 0\n                close_bracket = 0\n            end\n        end\n     \
    \   i += 1\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpjwolp5n5.jl:41

    '
  stdout: "test set: Error During Test at /tmp/tmpjwolp5n5.jl:44\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  BoundsError: attempt to access 24-codeunit String\
    \ at index [25]\n  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216\
    \ [inlined]\n   [2] codeunit\n     @ ./strings/string.jl:102 [inlined]\n   [3]\
    \ getindex\n     @ ./strings/string.jl:223 [inlined]\n   [4] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpjwolp5n5.jl:19\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpjwolp5n5.jl:44 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpjwolp5n5.jl:43\ntest set:\
    \ Error During Test at /tmp/tmpjwolp5n5.jl:45\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  BoundsError: attempt to access 20-codeunit String at index [21]\n\
    \  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216 [inlined]\n\
    \   [2] codeunit\n     @ ./strings/string.jl:102 [inlined]\n   [3] getindex\n\
    \     @ ./strings/string.jl:223 [inlined]\n   [4] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpjwolp5n5.jl:19\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpjwolp5n5.jl:45 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpjwolp5n5.jl:43\ntest set:\
    \ Error During Test at /tmp/tmpjwolp5n5.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  BoundsError:\
    \ attempt to access 12-codeunit String at index [13]\n  Stacktrace:\n   [1] checkbounds\n\
    \     @ ./strings/basic.jl:216 [inlined]\n   [2] codeunit\n     @ ./strings/string.jl:102\
    \ [inlined]\n   [3] getind"
  timestamp: 1659979132
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_groups = []\n    i = 1\n    while i <= length(paren_string)\n  \
    \      group = \"\"\n        while i <= length(paren_string) && paren_string[i]\
    \ != ' '\n            group *= paren_string[i]\n            i += 1\n        end\n\
    \        if length(group) > 0\n            push!(paren_groups, group)\n      \
    \  end\n        i += 1\n    end\n    return paren_groups\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpgkfqx8jf.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmpgkfqx8jf.jl:32\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"(\"\
    , \")\", \"((\", \"))\", \"((\", \")(\", \"))\"] == [\"()\", \"(())\", \"(()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgkfqx8jf.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgkfqx8jf.jl:28\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     1      4\n"
  timestamp: 1659979131
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    return _separate_paren_groups(paren_string)\nend\n# Practice creating\
    \ a function that takes the string and returns a list of the separated groups\n\
    # Hint: keep track of how many open parenthesis you have\n# Hint: this is almost\
    \ the same as the last problem, how can you use that here?\n# Hint: try to add\
    \ parenthesis around the groups and remove them after they are separated\n# Hint:\
    \ while appending to a Vector is very inefficient, it is better than allocating\
    \ new memory\n#       for each new string\n# Hint: test your function with all\
    \ the examples for the docstring\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpor2ky11o.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpor2ky11o.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: _separate_paren_groups not defined\n\
    \  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmpor2ky11o.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpor2ky11o.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpor2ky11o.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpor2ky11o.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: _separate_paren_groups not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpor2ky11o.jl:9\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpor2ky11o.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpor2ky11o.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpor2ky11o.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: _separate_paren_groups\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpor2ky11o.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpor2ky11o.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpor2ky11o.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpor2ky11o.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( ))"
  timestamp: 1659979132
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    groups = []\n    group = \"\"\n    stack = 0\n    for c in paren_string\n\
    \        if c == '('\n            stack += 1\n        elseif c == ')'\n      \
    \      stack -= 1\n        end\n        if stack > 0\n            group *= c\n\
    \        elseif stack == 0\n            if c != ' '\n                push!(groups,\
    \ group)\n                group = \"\"\n            end\n        end\n    end\n\
    \    groups\nend\nseparate_paren_groups(\"( ) (( )) (( )( ))\")\nusing Test\n\n\
    @testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpypimt_9a.jl:32

    '
  stdout: "test set: Test Failed at /tmp/tmpypimt_9a.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()\", \"((())\", \"(\", \"((())()()\"] == [\"(()())\",\
    \ \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpypimt_9a.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpypimt_9a.jl:34\ntest set: Test Failed at /tmp/tmpypimt_9a.jl:36\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \"(()\", \"((())\", \"(((()))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpypimt_9a.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpypimt_9a.jl:34\ntest set: Test Failed at /tmp/tmpypimt_9a.jl:37\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"(()(())((()))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpypimt_9a.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpypimt_9a.jl:34\ntest set: Test Failed at /tmp/tmpypimt_9a.jl:38\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"( \", \"(( )\", \"(( )( )\"] == [\"()\", \"(())\", \"(()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpypimt_9a.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1659979131
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_groups = Vector{String}()\n    current_group = String()\n    for\
    \ char in paren_string\n        if char == '('\n            current_group = string(char)\n\
    \        elseif char == ')'\n            current_group = current_group * string(char)\n\
    \            push!(paren_groups, current_group)\n        elseif char != ' '\n\
    \            current_group = current_group * string(char)\n        end\n    end\n\
    \    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp58obp5k0.jl:25

    '
  stdout: "test set: Error During Test at /tmp/tmp58obp5k0.jl:28\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching String()\n  Closest\
    \ candidates are:\n    String(!Matched::String) at ~/.conda/envs/polyglot/share/julia/base/boot.jl:363\n\
    \    String(!Matched::Vector{UInt8}) at ~/.conda/envs/polyglot/share/julia/base/strings/string.jl:53\n\
    \    String(!Matched::Symbol) at ~/.conda/envs/polyglot/share/julia/base/strings/string.jl:83\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp58obp5k0.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp58obp5k0.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp58obp5k0.jl:27\ntest set:\
    \ Error During Test at /tmp/tmp58obp5k0.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching String()\n  Closest candidates\
    \ are:\n    String(!Matched::String) at ~/.conda/envs/polyglot/share/julia/base/boot.jl:363\n\
    \    String(!Matched::Vector{UInt8}) at ~/.conda/envs/polyglot/share/julia/base/strings/string.jl:53\n\
    \    String(!Matched::Symbol) at ~/.conda/envs/polyglot/share/julia/base/strings/string.jl:83\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp58obp5k0.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp58obp5k0.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp58obp5k0.jl:27\ntest set:\
    \ Error During Test at /tmp/tmp58obp5k0.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(()"
  timestamp: 1659979133
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    stack = Stack{Char}()\n    group_buffer = []\n    result = []\n    for\
    \ i in paren_string\n        if i == '('\n            push!(stack, i)\n      \
    \  elseif i == ')'\n            if isempty(stack)\n                #TODO: Throw\
    \ error\n            else\n                pop!(stack)\n                if isempty(stack)\n\
    \                    push!(result, join(group_buffer))\n                    group_buffer\
    \ = []\n                end\n            end\n        elseif i != ' '\n      \
    \      #TODO: Throw error\n        end\n    end\n    return result\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpbhmycxrd.jl:33

    '
  stdout: "test set: Error During Test at /tmp/tmpbhmycxrd.jl:36\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: Stack not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpbhmycxrd.jl:9\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbhmycxrd.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbhmycxrd.jl:35\ntest set:\
    \ Error During Test at /tmp/tmpbhmycxrd.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: Stack not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpbhmycxrd.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbhmycxrd.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbhmycxrd.jl:35\ntest set:\
    \ Error During Test at /tmp/tmpbhmycxrd.jl:38\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: Stack\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpbhmycxrd.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbhmycxrd.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbhmycxrd.jl:35\ntest set:\
    \ Error During Test at /tmp/tmpbhmycxrd.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  UndefVarE"
  timestamp: 1659979132
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    groups = []\n    ctr = 0\n    group = \"\"\n    paren_string = filter(paren_string,\
    \ (x -> !isspace(x)))\n    for i in 1:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            ctr += 1\n        elseif paren_string[i] == ')'\n      \
    \      ctr -= 1\n        end\n        if ctr == 0\n            push!(groups, group)\n\
    \            group = \"\"\n        else\n            group = string(group, paren_string[i])\n\
    \        end\n    end\n    return groups\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpbvy6wcav.jl:30

    '
  stdout: "test set: Error During Test at /tmp/tmpbvy6wcav.jl:33\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching filter(::String,\
    \ ::var\"#1#2\")\n  Closest candidates are:\n    filter(::Any, !Matched::Tuple)\
    \ at ~/.conda/envs/polyglot/share/julia/base/tuple.jl:363\n    filter(::Any, !Matched::Array{T,\
    \ N}) where {T, N} at ~/.conda/envs/polyglot/share/julia/base/array.jl:2479\n\
    \    filter(::Any, !Matched::AbstractDict) at ~/.conda/envs/polyglot/share/julia/base/abstractdict.jl:434\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpbvy6wcav.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbvy6wcav.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbvy6wcav.jl:32\ntest set:\
    \ Error During Test at /tmp/tmpbvy6wcav.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching filter(::String, ::var\"#1#2\"\
    )\n  Closest candidates are:\n    filter(::Any, !Matched::Tuple) at ~/.conda/envs/polyglot/share/julia/base/tuple.jl:363\n\
    \    filter(::Any, !Matched::Array{T, N}) where {T, N} at ~/.conda/envs/polyglot/share/julia/base/array.jl:2479\n\
    \    filter(::Any, !Matched::AbstractDict) at ~/.conda/envs/polyglot/share/julia/base/abstractdict.jl:434\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpbvy6wcav.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbvy6wcav.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbvy6wcav.jl:32\ntest set:\
    \ Error During Test "
  timestamp: 1659979134
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    string_array = []\n    temp_str = \"\"\n    open_paren\
    \ = 0\n    push!(string_array, temp_str)\n    for i in paren_string\n        if\
    \ i == '('\n            open_paren += 1\n            temp_str = temp_str * i\n\
    \        elseif i == ')'\n            if open_paren == 0\n                temp_str\
    \ = \"\"\n            else\n                open_paren -= 1\n                temp_str\
    \ = temp_str * i\n            end\n        elseif i == ' '\n            push!(string_array,\
    \ temp_str)\n            temp_str = \"\"\n        end\n    end\n    push!(string_array,\
    \ temp_str)\n    return string_array\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmphpwnqkru.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmphpwnqkru.jl:38\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"\", \"(()())\", \"((()))\", \"()\", \"((())()())\"] == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphpwnqkru.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmphpwnqkru.jl:37\ntest set: Test Failed at /tmp/tmphpwnqkru.jl:39\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"()\", \"(())\", \"((()))\", \"\
    (((())))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphpwnqkru.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphpwnqkru.jl:37\ntest set: Test\
    \ Failed at /tmp/tmphpwnqkru.jl:40\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"\", \"(()(())((())))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphpwnqkru.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphpwnqkru.jl:37\ntest set: Test\
    \ Failed at /tmp/tmphpwnqkru.jl:41\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \"(\", \")\",\
    \ \"((\", \"))\", \"((\", \")(\", \"))\"] == [\"()\", \"(())\", \"(()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphpwnqkru.jl:41 [inlined]\n [3]\
    \ macro expansion\n "
  timestamp: 1659979132
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, r\"\\s+\" => \"\")\n    stack = []\n\
    \    groups = []\n    for c in paren_string\n        push!(stack, c)\n       \
    \ if c == ')'\n            end_idx = length(stack)\n            while stack[end_idx]\
    \ != '('\n                pop!(stack)\n                end_idx -= 1\n        \
    \    end\n            push!(groups, join(stack[end_idx+1:end_idx-1]))\n      \
    \      stack = [stack[1:end_idx-1]]\n        end\n    end\n    return groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpt_vtymtr.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmpt_vtymtr.jl:31\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Char\
    \ to an object of type Vector{Any}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{Vector{Any}}, item::Char)\n  \
    \   @ Base ./array.jl:994\n   [2] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpt_vtymtr.jl:13\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpt_vtymtr.jl:31 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpt_vtymtr.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpt_vtymtr.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Char to an object\
    \ of type Vector{Any}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] push!(a::Vector{Vector{Any}}, item::Char)\n  \
    \   @ Base ./array.jl:994\n   [2] separate_paren_groups(pare"
  timestamp: 1659979135
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # create a vector of strings to store each individual string\n    out\
    \ = Vector{String}()\n    # create a counter to keep track of the number of opening\
    \ and closing parens, will be 0 if balanced\n    paren_count = 0\n    # create\
    \ a counter to keep track of the index of the start of the current paren group\n\
    \    start_index = 1\n    # iterate through each character in the string\n   \
    \ for (index,character) in enumerate(paren_string)\n        # ignore spaces\n\
    \        if character == \" \"\n            continue\n        # increment the\
    \ counter for each opening paren\n        elseif character == \"(\"\n        \
    \    paren_count += 1\n        # decrement the counter for each closing paren,\
    \ add the substring to the output vector if balanced\n        elseif character\
    \ == \")\"\n            paren_count -= 1\n            if paren_count == 0\n  \
    \              push!(out, paren_string[start_index:index])\n                start_index\
    \ = index + 1\n            end\n        # error if the parens are not balanced\n\
    \        else\n            error(\"bad input\")\n        end\n    end\n    return\
    \ out\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpsjtf_vs9.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmpsjtf_vs9.jl:42\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  bad input\n  Stacktrace:\n   [1] error(s::String)\n\
    \     @ Base ./error.jl:33\n   [2] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpsjtf_vs9.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpsjtf_vs9.jl:42 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpsjtf_vs9.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpsjtf_vs9.jl:43\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  bad input\n  Stacktrace:\n   [1] error(s::String)\n     @ Base\
    \ ./error.jl:33\n   [2] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmpsjtf_vs9.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpsjtf_vs9.jl:43 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpsjtf_vs9.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpsjtf_vs9.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  bad input\n  Stacktrace:\n\
    \   [1] error(s::String)\n     @ Base ./error.jl:33\n   [2] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpsjtf_vs9.jl:32\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpsjtf_vs9.jl:44 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpsjtf_vs9.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpsjtf_vs9.jl:45\n  Test threw exception\n "
  timestamp: 1659979133
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    group_counter = 0\n    group_starts = []\n    group_ends = []\n    group_strings\
    \ = []\n    for (i,paren) in enumerate(paren_string)\n        if paren == '('\n\
    \            group_counter += 1\n            if group_counter == 1\n         \
    \       push!(group_starts, i)\n            end\n        elseif paren == ')'\n\
    \            if group_counter == 1\n                push!(group_ends, i)\n   \
    \         end\n            group_counter -= 1\n        end\n    end\n    for (start,\
    \ end) in zip(group_starts, group_ends)\n        push!(group_strings, paren_string[start:end])\n\
    \    end\n    return group_strings\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: unexpected \"end\"\nStacktrace:\n [1] top-level\
    \ scope\n   @ /tmp/tmpqb6tsfje.jl:26\nin expression starting at /tmp/tmpqb6tsfje.jl:26\n"
  stdout: ''
  timestamp: 1659979132
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    ###########################################################################\n\
    \    # Implementation of the separate_paren_groups method is up to you.\n    ###########################################################################\n\
    \    paren_string = paren_string[ismatch(r\"\\(|\\)\", paren_string)]\n    groups\
    \ = Vector{String}()\n    group = String()\n    i = 1\n    while i <= length(paren_string)\n\
    \        if paren_string[i] == '('\n            push!(group, '(')\n        elseif\
    \ paren_string[i] == ')'\n            push!(group, ')')\n        end\n       \
    \ if group[end] == ')' && group[end-1] == '('\n            group = group[1:end-1]\n\
    \            if length(group) > 0\n                push!(groups, group)\n    \
    \        end\n            group = String()\n        end\n        i += 1\n    end\n\
    \    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp6qsydhx7.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmp6qsydhx7.jl:38\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: ismatch not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmp6qsydhx7.jl:12\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6qsydhx7.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6qsydhx7.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp6qsydhx7.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: ismatch not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp6qsydhx7.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6qsydhx7.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6qsydhx7.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp6qsydhx7.jl:40\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: ismatch\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp6qsydhx7.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6qsydhx7.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6qsydhx7.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp6qsydhx7.jl:41\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  "
  timestamp: 1659979133
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    clean_string = replace(paren_string, \" \" => \"\")\n    split_string\
    \ = split(clean_string, \")(\")\n    index = 0\n    for string in split_string\n\
    \        split_string[index] = \"(\" * string * \")\"\n        index += 1\n  \
    \  end\n    return split_string\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpb52l67e3.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpb52l67e3.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  BoundsError: attempt to access 7-element Vector{SubString{String}}\
    \ at index [0]\n  Stacktrace:\n   [1] setindex!\n     @ ./array.jl:903 [inlined]\n\
    \   [2] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpb52l67e3.jl:13\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpb52l67e3.jl:23 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpb52l67e3.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpb52l67e3.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  BoundsError: attempt to access 4-element Vector{SubString{String}}\
    \ at index [0]\n  Stacktrace:\n   [1] setindex!\n     @ ./array.jl:903 [inlined]\n\
    \   [2] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpb52l67e3.jl:13\n\
    \   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpb52l67e3.jl:24 [inlined]\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpb52l67e3.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpb52l67e3.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  BoundsError: attempt\
    \ to access 3-element Vector{SubString{String}} at index [0]\n  Stacktrace:\n\
    \   [1] setindex!\n     @ ./array.jl:903 [inlined]\n   [2] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpb52l67e3.jl:13\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpb52l67e3.jl:25 [inlined]\n\
    \   [5] macro expansion\n     @ ~/."
  timestamp: 1659979134
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpbydai1hj.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpbydai1hj.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpbydai1hj.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbydai1hj.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbydai1hj.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpbydai1hj.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpbydai1hj.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659979134
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Currently just split on space characters.\n    # Replace this code with\
    \ your own.\n    return split(paren_string, r\"\\s+\")\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp1rsbzxjh.jl:15

    '
  stdout: "test set: Test Failed at /tmp/tmp1rsbzxjh.jl:21\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"(\"\
    , \")\", \"((\", \"))\", \"((\", \")(\", \"))\"] == [\"()\", \"(())\", \"(()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1rsbzxjh.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1rsbzxjh.jl:17\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     1      4\n"
  timestamp: 1659979133
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Iterate the input string and identify\n    # start and end of the groups\n\
    \    parentheses = Dict{Int, String}()\n    i, n = 1, length(paren_string)\n \
    \   while i <= n\n        if paren_string[i] == '('\n            # Group starts\n\
    \            parentheses[i] = \"(\"\n        elseif paren_string[i] == ')'\n \
    \           # Group ends\n            group_start = findall(paren_string[i:-1],\
    \ r\"\\(\").last\n            parentheses[group_start] = \")\"\n        end\n\
    \        i += 1\n    end\n    # Iterate through the parentheses and find groups\n\
    \    groups = []\n    curr_start = 1\n    for i in sort(collect(keys(parentheses)))\n\
    \        if parentheses[i] == \"(\"\n            push!(groups, paren_string[curr_start:i-1])\n\
    \            curr_start = i\n        elseif parentheses[i] == \")\"\n        \
    \    push!(groups, paren_string[curr_start:i])\n            curr_start = i+1\n\
    \        end\n    end\n    # Return the groups vector\n    return groups\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp7os4krqz.jl:41

    '
  stdout: "test set: Error During Test at /tmp/tmp7os4krqz.jl:44\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching findall(::String,\
    \ ::Regex)\n  Closest candidates are:\n    findall(::Union{AbstractPattern, AbstractString},\
    \ !Matched::AbstractString; overlap) at ~/.conda/envs/polyglot/share/julia/base/regex.jl:458\n\
    \    findall(!Matched::Function, ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:2253\n\
    \    findall(::String, !Matched::LibGit2.GitIndex) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/index.jl:191\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp7os4krqz.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7os4krqz.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7os4krqz.jl:43\ntest set:\
    \ Error During Test at /tmp/tmp7os4krqz.jl:45\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching findall(::String, ::Regex)\n  Closest\
    \ candidates are:\n    findall(::Union{AbstractPattern, AbstractString}, !Matched::AbstractString;\
    \ overlap) at ~/.conda/envs/polyglot/share/julia/base/regex.jl:458\n    findall(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:2253\n    findall(::String,\
    \ !Matched::LibGit2.GitIndex) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/index.jl:191\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp7os4krqz.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7os4krqz.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/T"
  timestamp: 1659979135
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    #  Remove spaces\n    paren_string = replace(paren_string, \" \" => \"\
    \")\n    #  Get indices of open and close parens\n    start_inds = findfirst(paren_string,\
    \ \"(\");\n    end_inds = findfirst(paren_string, \")\");\n    #  Check they are\
    \ the same length\n    if length(start_inds) != length(end_inds)\n        return\
    \ \"error: unequal number of opening and closing parentheses\"\n    end\n    #\
    \  Initialize an array containing nested groups\n    groups = []\n    #  Cycle\
    \ through each group\n    for group_idx in 1:length(start_inds)\n        #  Initialize\
    \ an array for the current group\n        curr_group = []\n        #  Cycle through\
    \ each nested group\n        for paren_idx in 1:length(start_inds)\n         \
    \   #  Skip the group if we've already included it\n            if paren_idx <\
    \ group_idx\n                continue\n            end\n            #  Get the\
    \ position of the open paren\n            start_idx = start_inds[paren_idx]\n\
    \            #  Get the position of the close paren\n            end_idx = end_inds[paren_idx]\n\
    \            #  Add the current subgroup to the current group\n            push!(curr_group,\
    \ paren_string[start_idx:end_idx])\n        end\n        #  Add the current group\
    \ to the full list of groups\n        push!(groups, join(curr_group, \"\"))\n\
    \    end\n    #  Return the list of groups\n    return groups\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpp4_bw20o.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmpp4_bw20o.jl:48\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching length(::Nothing)\n\
    \  Closest candidates are:\n    length(!Matched::Union{Base.KeySet, Base.ValueIterator})\
    \ at ~/.conda/envs/polyglot/share/julia/base/abstractdict.jl:58\n    length(!Matched::Union{LinearAlgebra.Adjoint{T,\
    \ S}, LinearAlgebra.Transpose{T, S}} where {T, S}) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/adjtrans.jl:171\n\
    \    length(!Matched::Base.Iterators.Stateful) at ~/.conda/envs/polyglot/share/julia/base/iterators.jl:1338\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpp4_bw20o.jl:15\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp4_bw20o.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp4_bw20o.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpp4_bw20o.jl:49\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching length(::Nothing)\n  Closest candidates\
    \ are:\n    length(!Matched::Union{Base.KeySet, Base.ValueIterator}) at ~/.conda/envs/polyglot/share/julia/base/abstractdict.jl:58\n\
    \    length(!Matched::Union{LinearAlgebra.Adjoint{T, S}, LinearAlgebra.Transpose{T,\
    \ S}} where {T, S}) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/adjtrans.jl:171\n\
    \    length(!Matched::Base.Iterators.Stateful) at ~/.conda/envs/polyglot/share/julia/base/iterators.jl:1338\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpp4_bw20o.jl:15\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp4_bw20o.jl:49 [inlined"
  timestamp: 1659979135
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\"\n    Input: String of multiple groups of balanced parentheses\n\
    \    Output: Vector of strings of individual groups\n    >>> separate_paren_groups(\"\
    ( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\n    # Initialize\
    \ an array to store the different paren groups\n    paren_groups = String[]\n\
    \    # Go through each character of the string\n    for i in 1:length(paren_string)\n\
    \        # Substring for a particular pair\n        substring = \"\"\n       \
    \ # Find the opening '(' of the pair\n        if paren_string[i] == '('\n    \
    \        # Store the location of the opening paren\n            j = i\n      \
    \      # Go to the end of the pair\n            while paren_string[j] != ')'\n\
    \                # Add each character to substring\n                substring\
    \ = append!(substring, paren_string[j])\n                # Go to the next character\n\
    \                j += 1\n            end\n            # Add the closing paren\n\
    \            substring = append!(substring, ')')\n            # Add the substring\
    \ to the array\n            push!(paren_groups, substring)\n        end\n    end\n\
    \    # Return the array with all the paren groups\n    return paren_groups\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp2cgr9mix.jl:43

    '
  stdout: "test set: Error During Test at /tmp/tmp2cgr9mix.jl:46\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching append!(::String,\
    \ ::Char)\n  Closest candidates are:\n    append!(!Matched::BitVector, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/bitarray.jl:782\n    append!(!Matched::AbstractVector,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1050\n    append!(!Matched::AbstractVector,\
    \ ::Any...) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1053\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmp2cgr9mix.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2cgr9mix.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2cgr9mix.jl:45\ntest set:\
    \ Error During Test at /tmp/tmp2cgr9mix.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching append!(::String, ::Char)\n  Closest\
    \ candidates are:\n    append!(!Matched::BitVector, ::Any) at ~/.conda/envs/polyglot/share/julia/base/bitarray.jl:782\n\
    \    append!(!Matched::AbstractVector, ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1050\n\
    \    append!(!Matched::AbstractVector, ::Any...) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1053\n\
    \  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n     @ Main\
    \ /tmp/tmp2cgr9mix.jl:28\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2cgr9mix.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2cgr9mix.jl:45\ntest set:\
    \ Error During Test at /tmp/tmp2cgr9mix.jl:48\n"
  timestamp: 1659979135
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    #  Implement this function\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpqutusdhj.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpqutusdhj.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpqutusdhj.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqutusdhj.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqutusdhj.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpqutusdhj.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpqutusdhj.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659979135
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    groups = split(paren_string, \" \")\n    return [sub(\" \", \"\", group)\
    \ for group in groups]\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpgaiy2uru.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpgaiy2uru.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: sub not defined\n  Stacktrace:\n \
    \  [1] (::var\"#1#2\")(group::SubString{String})\n     @ Main ./none:0\n   [2]\
    \ iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"})\n     @ Base ./array.jl:724\n   [4] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpgaiy2uru.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpgaiy2uru.jl:17 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpgaiy2uru.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpgaiy2uru.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: sub not defined\n  Stacktrace:\n   [1] (::var\"\
    #1#2\")(group::SubString{String})\n     @ Main ./none:0\n   [2] iterate\n    \
    \ @ ./generator.jl:47 [inlined]\n   [3] collect(itr::Base.Generator{Vector{SubString{String}},\
    \ var\"#1#2\"})\n     @ Base ./array.jl:724\n   [4] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpgaiy2uru.jl:10\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpgaiy2uru.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpgaiy2uru.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpgaiy2uru.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: sub\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Gen"
  timestamp: 1659979134
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    groups = [\"\"\
    ]\n    group_ind = 1\n    for ch in paren_string\n        if ch == '('\n     \
    \       group_ind += 1\n            push!(groups, \"\")\n        elseif ch ==\
    \ ')'\n            group_ind -= 1\n            push!(groups[group_ind], \")\"\
    )\n        else\n            push!(groups[group_ind], ch)\n        end\n    end\n\
    \    return groups[1:end-1]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpeloko1xz.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpeloko1xz.jl:30\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching push!(::String, ::String)\n\
    \  Closest candidates are:\n    push!(::Any, ::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at ~/.conda/envs/polyglot/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpeloko1xz.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeloko1xz.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpeloko1xz.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpeloko1xz.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching push!(::String, ::String)\n  Closest\
    \ candidates are:\n    push!(::Any, ::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at ~/.conda/envs/polyglot/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpeloko1xz.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpeloko1xz.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  timestamp: 1659979135
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n  open_paren = 0\n  close_paren = 0\n  groups = []\n  for char in paren_string\n\
    \    if char == '('\n      open_paren += 1\n    elseif char == ')'\n      close_paren\
    \ += 1\n    end\n    if open_paren > 0 && open_paren == close_paren\n      push!(groups,\
    \ paren_string[1:open_paren+close_paren-1])\n      open_paren = 0\n      close_paren\
    \ = 0\n      paren_string = paren_string[open_paren+close_paren:]\n    end\n \
    \ end\n  return groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing last argument in \"(open_paren + close_paren):\"\
    \ range expression \nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpwqfeiiux.jl:22\n\
    in expression starting at /tmp/tmpwqfeiiux.jl:22\n"
  stdout: ''
  timestamp: 1659979133
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    skip_parens = paren_string |>  replace(\" \", \"\")\n    groups = []\n\
    \    for index in 1:length(skip_parens)\n        last_index = findlast(skip_parens,\
    \ \"(\")\n        first_index = findfirst(skip_parens, \")\")\n        push!(groups,\
    \ skip_parens[first_index:last_index])\n        skip_parens = skip_parens[first_index+1:last_index-1]\n\
    \    end\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpmfuqr6sh.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpmfuqr6sh.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching replace(::String,\
    \ ::String)\n  Closest candidates are:\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpmfuqr6sh.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmfuqr6sh.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmfuqr6sh.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpmfuqr6sh.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching replace(::String, ::String)\n \
    \ Closest candidates are:\n    replace(!Matched::Union{Function, Type}, ::Any;\
    \ count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n    replace(::String,\
    \ !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpmfuqr6sh.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmfuqr6sh.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]"
  timestamp: 1659979135
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Ignoring spaces, the string is composed of a series of open and closed\
    \ parentheses\n    # ( and ) respectively\n    # This function is meant to take\
    \ a string containing multiple groups of nested parentheses,\n    # separate them\
    \ out, and return an array of strings containing the different groups of\n   \
    \ # nested parentheses\n    # A valid group of nested parentheses will look like:\n\
    \    # ()\n    # (())\n    # (()())\n    # ((()))\n    # etc.\nusing Test\n\n\
    @testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw7uty0fb.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw7uty0fb.jl:1\n\
    in expression starting at /tmp/tmpw7uty0fb.jl:1\n"
  stdout: ''
  timestamp: 1659979133
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    seperate_paren_groups = Vector{String}()\n    closing_paren_count\
    \ = 0\n    current_string = \"\"\n    for c in paren_string\n        if c == '('\n\
    \            if closing_paren_count == 0\n                current_string = current_string*c\n\
    \            else\n                current_string = current_string*c\n       \
    \         closing_paren_count -= 1\n            end\n        elseif c == ')'\n\
    \            if closing_paren_count == 0\n                current_string = current_string*c\n\
    \                push!(seperate_paren_groups, current_string)\n              \
    \  current_string = \"\"\n            else\n                current_string = current_string*c\n\
    \                closing_paren_count += 1\n            end\n        end\n    end\n\
    \    return seperate_paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpjv7xgho8.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpjv7xgho8.jl:39\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"()\", \")\", \"((()\", \")\", \")\", \"()\", \"((()\"\
    , \")\", \"()\", \"()\", \")\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjv7xgho8.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjv7xgho8.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpjv7xgho8.jl:40\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(()\"\
    , \")\", \"((()\", \")\", \")\", \"(((()\", \")\", \")\", \")\"] == [\"()\", \"\
    (())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjv7xgho8.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjv7xgho8.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpjv7xgho8.jl:41\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"(()\", \")\", \"((()\", \"\
    )\", \")\", \")\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpjv7xgho8.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpjv7xgho8.jl:38\ntest set: Test Failed at /tmp/tmpjv7xgho8.jl:42\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"()\", \"(()\", \")\", \"(()\", \"()\", \")\"] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n"
  timestamp: 1659979134
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    assert(!contains(paren_string, \"(\"), \"the string cannot contain any\
    \ opening parens\")\n    paren_stack = []\n    paren_string = replace(paren_string,\
    \ \" \" => \"\")\n    paren_string = replace(paren_string, \")(\" => \");;\")\n\
    \    paren_stack = split(paren_string, \";;\")\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpzojc53du.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmpzojc53du.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: assert not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpzojc53du.jl:9\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzojc53du.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzojc53du.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpzojc53du.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: assert not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpzojc53du.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzojc53du.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzojc53du.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpzojc53du.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: assert\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpzojc53du.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzojc53du.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzojc53du.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpzojc53du.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  UndefV"
  timestamp: 1659979135
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    count = 0\n    stack = \"\"\n    out = []\n    for c in paren_string\n\
    \        if c == '('\n            count += 1\n        elseif c == ')'\n      \
    \      count -= 1\n        end\n        if count == 0\n            push!(out,\
    \ stack)\n            stack = \"\"\n        else\n            stack *= c\n   \
    \     end\n    end\n    return out\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpj5fgbjaq.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpj5fgbjaq.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj5fgbjaq.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj5fgbjaq.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpj5fgbjaq.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \"\"\
    , \"(()\", \"\", \"((())\", \"\", \"(((()))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj5fgbjaq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj5fgbjaq.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpj5fgbjaq.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()(())((()))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj5fgbjaq.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj5fgbjaq.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpj5fgbjaq.jl:35\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( \", \"\", \"(( )\"\
    , \"\", \"(( )( )\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj5fgbjaq.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.c"
  timestamp: 1659979134
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    # check if the whole string has the right amount of brackets\n \
    \   is_balanced(paren_string) == 0 && return paren_string\n    \n    # to store\
    \ the separate elements in\n    new_string = String[]\n    \n    # split the whole\
    \ string into individual characters\n    input_string = split(paren_string)\n\
    \    \n    # iterate over the vector of characters\n    for i = 1:length(input_string)\n\
    \        # if a open bracket is found, cut out all elements between the next open\
    \ and close bracket,\n        # and append that to the vector\n        if input_string[i]\
    \ == \"(\"\n            new_string = push!(new_string, join(input_string[i:findnext(x\
    \ -> x == \")\", input_string, i)]))\n        end\n    end\n    \n    # return\
    \ the vector of strings containing only one set of parens\n    return new_string\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp4q88375_.jl:33

    '
  stdout: "test set: Error During Test at /tmp/tmp4q88375_.jl:36\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmp4q88375_.jl:11\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4q88375_.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4q88375_.jl:35\ntest set:\
    \ Error During Test at /tmp/tmp4q88375_.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp4q88375_.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4q88375_.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4q88375_.jl:35\ntest set:\
    \ Error During Test at /tmp/tmp4q88375_.jl:38\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: is_balanced\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp4q88375_.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4q88375_.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4q88375_.jl:35\ntest set:\
    \ Error During Test at /tmp/tmp4q88375_.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", "
  timestamp: 1659979135
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    sep_string = split(paren_string,\" \")\n    k = 1\n    w = 1\n    u =1\n\
    \    gr = []\n    for i in 1:length(sep_string)\n        \n        if !isempty(sep_string[i])\n\
    \            new_string = sep_string[i]\n            if (new_string[1] == '(')\
    \ && (new_string[end] == ')')\n            elseif (new_string[1] == '(')\n   \
    \             for j in 2:length(new_string)\n                    if new_string[j]\
    \ == '('\n                        k = k+1\n                    elseif new_string[j]\
    \ == ')'\n                        k = k-1\n                    end\n         \
    \           if k == 0\n                        for m in 1:j\n                \
    \            gr[w] = new_string[m]\n                            w = w+1\n    \
    \                    end\n                        k = 1\n                    \
    \    u = u+1\n                        w = u\n                    end\n       \
    \         end\n                w = 1\n                u = 1\n            else\n\
    \                for j in 1:length(new_string)\n                    if new_string[j]\
    \ == '('\n                        k = k+1\n                    elseif new_string[j]\
    \ == ')'\n                        k = k-1\n                    end\n         \
    \           if k == 0\n                        for m in 1:j\n                \
    \            gr[w] = new_string[m]\n                            w = w+1\n    \
    \                    end\n                        k = 1\n                    \
    \    u = u+1\n                        w = u\n                    end\n       \
    \         end\n                w = 1\n                u = 1\n            end\n\
    \        end\n    end\n    gr\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 1 errored,
    0 broken.

    in expression starting at /tmp/tmpd3g2tsln.jl:64

    '
  stdout: "test set: Test Failed at /tmp/tmpd3g2tsln.jl:67\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd3g2tsln.jl:67 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd3g2tsln.jl:66\ntest set: Test\
    \ Failed at /tmp/tmpd3g2tsln.jl:68\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpd3g2tsln.jl:68 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpd3g2tsln.jl:66\ntest set: Test Failed at /tmp/tmpd3g2tsln.jl:69\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd3g2tsln.jl:69 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd3g2tsln.jl:66\ntest set: Error\
    \ During Test at /tmp/tmpd3g2tsln.jl:70\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  BoundsError:\
    \ attempt to access 0-element Vector{Any} at index [1]\n  Stacktrace:\n   [1]\
    \ setindex!\n     @ ./essentials.jl:479 [inlined]\n   [2] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpd3g2tsln.jl:47\n   [3] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] "
  timestamp: 1659979136
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # This is where you write your code\n    pass\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp43ujmuqu.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmp43ujmuqu.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: pass not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmp43ujmuqu.jl:10\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp43ujmuqu.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp43ujmuqu.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp43ujmuqu.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: pass not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp43ujmuqu.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp43ujmuqu.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp43ujmuqu.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp43ujmuqu.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: pass\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp43ujmuqu.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp43ujmuqu.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp43ujmuqu.jl:16\ntest set:\
    \ Error During Test at /tmp/tmp43ujmuqu.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  UndefVarE"
  timestamp: 1659979136
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    (\n      i::Int = 0 \n      depth::Int = 0 \n      open_indices::Vector{Int}\
    \ = Vector{Int}()\n      closed_indices::Vector{Int} = Vector{Int}()\n      last_open_index::Int\
    \ = 0\n      out_strings::Vector{String} = Vector{String}()\n    )\n    for ch\
    \ in paren_string\n        if ch == '('\n            push!(open_indices, i)\n\
    \            depth += 1\n        elseif ch == ')'\n            depth -= 1\n  \
    \          if depth == 0\n                last_open_index = open_indices[end]\n\
    \                push!(closed_indices, i)\n                push!(out_strings,\
    \ paren_string[last_open_index:i])\n            end\n        end\n        i +=\
    \ 1\n    end\n    return out_strings\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp5udyx0tg.jl:11\nin expression starting at\
    \ /tmp/tmp5udyx0tg.jl:11\n"
  stdout: ''
  timestamp: 1659979135
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    i = 0\n    l = length(paren_string)\n    n = Int64[]\n    p = 0\n    while\
    \ i < l\n        while (i < l) && (paren_string[i] == ' ')\n            i += 1\n\
    \        end\n        if (i < l) && (paren_string[i] == '(')\n            s =\
    \ i\n            i += 1\n            while (i < l) && (paren_string[i] != ' ')\n\
    \                if paren_string[i] == '('\n                    p += 1\n     \
    \           elseif paren_string[i] == ')'\n                    p -= 1\n      \
    \          end\n                i += 1\n            end\n            if p == 0\n\
    \                push!(n, s)\n                push!(n, i-1)\n            end\n\
    \        end\n    end\n    v = Vector{String}(undef, length(n) \xF7 2)\n    for\
    \ i in 1:2:length(n)\n        v[(i + 1) \xF7 2] = paren_string[n[i]:n[i+1]]\n\
    \    end\n    return v\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp969272cg.jl:42

    '
  stdout: "test set: Error During Test at /tmp/tmp969272cg.jl:45\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  BoundsError: attempt to access 27-codeunit String\
    \ at index [0]\n  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216\
    \ [inlined]\n   [2] codeunit\n     @ ./strings/string.jl:102 [inlined]\n   [3]\
    \ getindex\n     @ ./strings/string.jl:223 [inlined]\n   [4] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp969272cg.jl:14\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp969272cg.jl:45 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp969272cg.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp969272cg.jl:46\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  BoundsError: attempt to access 23-codeunit String at index [0]\n\
    \  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216 [inlined]\n\
    \   [2] codeunit\n     @ ./strings/string.jl:102 [inlined]\n   [3] getindex\n\
    \     @ ./strings/string.jl:223 [inlined]\n   [4] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp969272cg.jl:14\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp969272cg.jl:46 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp969272cg.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp969272cg.jl:47\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  BoundsError: attempt\
    \ to access 14-codeunit String at index [0]\n  Stacktrace:\n   [1] checkbounds\n\
    \     @ ./strings/basic.jl:216 [inlined]\n   [2] codeunit\n     @ ./strings/string.jl:102\
    \ [inlined]\n   [3] getindex\n     @ ./s"
  timestamp: 1659979136
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    stack = Vector{Char}()\n    groups = Vector{String}()\n    group = \"\"\
    \n    for c in paren_string\n        if c == ' '\n            continue\n     \
    \   end\n        if c == '('\n            push!(stack, c)\n        elseif c ==\
    \ ')'\n            pop!(stack)\n            group *= c\n            if isempty(stack)\n\
    \                push!(groups, group)\n                group = \"\"\n        \
    \    end\n        end\n    end\n    return groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpi4liyxbq.jl:31

    '
  stdout: "test set: Test Failed at /tmp/tmpi4liyxbq.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\")))\", \")))\", \")\", \")))))\"] == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi4liyxbq.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi4liyxbq.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpi4liyxbq.jl:35\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\")\", \"))\"\
    , \")))\", \"))))\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi4liyxbq.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi4liyxbq.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpi4liyxbq.jl:36\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\")))))))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi4liyxbq.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi4liyxbq.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpi4liyxbq.jl:37\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\")\", \"))\", \")))\"\
    ] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi4liyxbq.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl"
  timestamp: 1659979136
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"() (())\
    \ ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"\
    (()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpbydai1hj.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpbydai1hj.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpbydai1hj.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbydai1hj.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbydai1hj.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpbydai1hj.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpbydai1hj.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659979134
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    if length(paren_string) == 0\n        return []\n    end\n    open = 0\n\
    \    idx = 0\n    groups = []\n    for i in 1:length(paren_string)\n        if\
    \ paren_string[i] == '('\n            open += 1\n        elseif paren_string[i]\
    \ == ')'\n            open -= 1\n        end\n        if open == 0\n         \
    \   push!(groups,paren_string[idx+1:i])\n            idx = i\n        end\n  \
    \  end\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmplw06o2ok.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmplw06o2ok.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplw06o2ok.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplw06o2ok.jl:32\ntest set: Test\
    \ Failed at /tmp/tmplw06o2ok.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" \"\
    , \"(())\", \" \", \"((()))\", \" \", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplw06o2ok.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplw06o2ok.jl:32\ntest set: Test\
    \ Failed at /tmp/tmplw06o2ok.jl:36\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \" \", \"((\
    \ ))\", \" \", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplw06o2ok.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplw06o2ok.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979136
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_groups\
    \ = []\n    curr_paren_group = \"\"\n    open_parens = 0\n    for paren in paren_string\n\
    \        if paren == '('\n            open_parens += 1\n        elseif paren ==\
    \ ')'\n            open_parens -= 1\n        end\n        curr_paren_group *=\
    \ paren\n        if open_parens == 0\n            push!(paren_groups, curr_paren_group)\n\
    \            curr_paren_group = \"\"\n        end\n    end\n    return paren_groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659979134
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\n \n \n \nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpxvqkq54n.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmpxvqkq54n.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpxvqkq54n.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxvqkq54n.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxvqkq54n.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpxvqkq54n.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpxvqkq54n.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659979137
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # vector of paren_groups to return\n    paren_groups = Vector{String}()\n\
    \    # stack to keep track of the last open paren\n    paren_stack = Vector{Char}()\n\
    \    # store the current paren_group in a string\n    curr_group = \"\"\n    #\
    \ iterate through the input string\n    for char in paren_string\n        # if\
    \ char is not a parenthesis and not a space, throw error\n        if char != '('\
    \ && char != ')' && char != ' '\n            error(\"$(char) is not a paren or\
    \ space\")\n        end\n        # if char is a paren\n        if char == '('\
    \ || char == ')'\n            # push it to the stack\n            push!(paren_stack,\
    \ char)\n            # if the stack is length 2, pop the last value\n        \
    \    if length(paren_stack) == 2\n                pop!(paren_stack)\n        \
    \    end\n            # if the stack is not empty, add the current char to the\
    \ curr_group\n            if !isempty(paren_stack)\n                curr_group\
    \ *= string(char)\n            # if the stack is empty, push the current group\
    \ to the paren_groups vector\n            else\n                push!(paren_groups,\
    \ curr_group)\n                # clear the curr_group\n                curr_group\
    \ = \"\"\n            end\n        end\n    end\n    # return the paren_groups\
    \ vector\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpllysu33y.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmpllysu33y.jl:48\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpllysu33y.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpllysu33y.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpllysu33y.jl:49\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpllysu33y.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpllysu33y.jl:47\ntest set: Test Failed at /tmp/tmpllysu33y.jl:50\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpllysu33y.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpllysu33y.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpllysu33y.jl:51\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpllysu33y.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpl"
  timestamp: 1659979136
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    groups = split(paren_string, \")\")\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpml5r0ky0.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpml5r0ky0.jl:1\n\
    in expression starting at /tmp/tmpml5r0ky0.jl:1\n"
  stdout: ''
  timestamp: 1659979136
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, r\"\\s\", \"\")\n    splitted = split(paren_string,\
    \ r\"(?<=\\))(?=\\()\")\n    if splitted[end] == \"\"\n        return splitted[1:end-1]\n\
    \    else\n        return splitted\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp4xqahvsg.jl:19

    '
  stdout: "test set: Error During Test at /tmp/tmp4xqahvsg.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching replace(::String,\
    \ ::Regex, ::String)\n  Closest candidates are:\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp4xqahvsg.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4xqahvsg.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4xqahvsg.jl:21\ntest set:\
    \ Error During Test at /tmp/tmp4xqahvsg.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching replace(::String, ::Regex, ::String)\n\
    \  Closest candidates are:\n    replace(!Matched::Union{Function, Type}, ::Any;\
    \ count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n    replace(::String,\
    \ !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp4xqahvsg.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4xqahvsg.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test"
  timestamp: 1659979138
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # build a StringRegex\n    r = r\"[^() ]+\"\n    # search through the\
    \ string and return a vector of matches\n    match_vector = match(r, paren_string)\n\
    \    return [match_vector[i].match for i in 1:length(match_vector)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp0xb6wnzm.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmp0xb6wnzm.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching length(::Nothing)\n\
    \  Closest candidates are:\n    length(!Matched::Union{Base.KeySet, Base.ValueIterator})\
    \ at ~/.conda/envs/polyglot/share/julia/base/abstractdict.jl:58\n    length(!Matched::Union{LinearAlgebra.Adjoint{T,\
    \ S}, LinearAlgebra.Transpose{T, S}} where {T, S}) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/adjtrans.jl:171\n\
    \    length(!Matched::Base.Iterators.Stateful) at ~/.conda/envs/polyglot/share/julia/base/iterators.jl:1338\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp0xb6wnzm.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0xb6wnzm.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0xb6wnzm.jl:19\ntest set:\
    \ Error During Test at /tmp/tmp0xb6wnzm.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching length(::Nothing)\n  Closest candidates\
    \ are:\n    length(!Matched::Union{Base.KeySet, Base.ValueIterator}) at ~/.conda/envs/polyglot/share/julia/base/abstractdict.jl:58\n\
    \    length(!Matched::Union{LinearAlgebra.Adjoint{T, S}, LinearAlgebra.Transpose{T,\
    \ S}} where {T, S}) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/adjtrans.jl:171\n\
    \    length(!Matched::Base.Iterators.Stateful) at ~/.conda/envs/polyglot/share/julia/base/iterators.jl:1338\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp0xb6wnzm.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0xb6wnzm.jl:21 [inlined"
  timestamp: 1659979138
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Code your solution here\n    return Vector{String}()\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvlqbpr9d.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpvlqbpr9d.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvlqbpr9d.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvlqbpr9d.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpvlqbpr9d.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvlqbpr9d.jl:18 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvlqbpr9d.jl:16\ntest set: Test Failed at /tmp/tmpvlqbpr9d.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvlqbpr9d.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvlqbpr9d.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpvlqbpr9d.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvlqbpr9d.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv"
  timestamp: 1659979137
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    res = []\n    push!(res, \"\")\n    for i in paren_string\n        if\
    \ i != ' '\n            push!(res[end], i)\n        end\n    end\n    res\nend\n\
    \ \nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpl6rvvgzp.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpl6rvvgzp.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching push!(::String, ::Char)\n\
    \  Closest candidates are:\n    push!(::Any, ::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at ~/.conda/envs/polyglot/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpl6rvvgzp.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpl6rvvgzp.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpl6rvvgzp.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpl6rvvgzp.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching push!(::String, ::Char)\n  Closest\
    \ candidates are:\n    push!(::Any, ::Any, !Matched::Any) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at ~/.conda/envs/polyglot/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpl6rvvgzp.jl:13\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpl6rvvgzp.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]"
  timestamp: 1659979138
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    output = []\n    open_parens = 0\n    curr_substring = \"\"\n    for ch\
    \ in paren_string\n        if ch == '('\n            open_parens += 1\n      \
    \      curr_substring *= ch\n        elseif ch == ')'\n            open_parens\
    \ -= 1\n            curr_substring *= ch\n        end\n        if open_parens\
    \ == 0\n            push!(output, curr_substring)\n            curr_substring\
    \ = \"\"\n        end\n    end\n    return output\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpulis2nfw.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpulis2nfw.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpulis2nfw.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulis2nfw.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpulis2nfw.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"\"\
    , \"(())\", \"\", \"((()))\", \"\", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpulis2nfw.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulis2nfw.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpulis2nfw.jl:35\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"\", \"(())\"\
    , \"\", \"(()())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpulis2nfw.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpulis2nfw.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979137
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    ...\nend\n```\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: invalid identifier name \"...\"\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp9pq_4xky.jl:9\nin expression starting at /tmp/tmp9pq_4xky.jl:9\n"
  stdout: ''
  timestamp: 1659979136
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    bracket_stack = Stack{Char}()\n    paren_list = []\n    current_paren\
    \ = \"\"\n    for i in 1:length(paren_string)\n        char = paren_string[i]\n\
    \        if char == '('\n            push!(bracket_stack, char)\n        elseif\
    \ char == ')'\n            if isempty(bracket_stack)\n                continue\n\
    \            else\n                pop!(bracket_stack)\n            end\n    \
    \    end\n        current_paren *= char\n        if isempty(bracket_stack)\n \
    \           push!(paren_list, current_paren)\n            current_paren = \"\"\
    \n        end\n    end\n    return paren_list\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp6yaxgl6e.jl:33

    '
  stdout: "test set: Error During Test at /tmp/tmp6yaxgl6e.jl:36\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  UndefVarError: Stack not defined\n  Stacktrace:\n\
    \   [1] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmp6yaxgl6e.jl:9\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6yaxgl6e.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6yaxgl6e.jl:35\ntest set:\
    \ Error During Test at /tmp/tmp6yaxgl6e.jl:37\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  UndefVarError: Stack not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp6yaxgl6e.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6yaxgl6e.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6yaxgl6e.jl:35\ntest set:\
    \ Error During Test at /tmp/tmp6yaxgl6e.jl:38\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  UndefVarError: Stack\
    \ not defined\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp6yaxgl6e.jl:9\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6yaxgl6e.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6yaxgl6e.jl:35\ntest set:\
    \ Error During Test at /tmp/tmp6yaxgl6e.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n  UndefVarE"
  timestamp: 1659979138
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_parens = 0\n    for i in 1:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            open_parens += 1\n        elseif paren_string[i] == ')'\n\
    \            open_parens -= 1\n        end\n    end\n    if open_parens != 0\n\
    \        throw(ArgumentError(\"Number of opening and closing parens are not equal.\"\
    ))\n    end\n    # do stuff\n    paren_string = string(replace(paren_string, \"\
    \ \" => \"\"))\n    output = []\n    open_parens = 0\n    # Initialize with first\
    \ character\n    current_string = \"\"\n    current_string *= paren_string[1]\n\
    \    open_parens += 1\n    for i in 2:length(paren_string)\n        if paren_string[i]\
    \ == '('\n            open_parens += 1\n        elseif paren_string[i] == ')'\n\
    \            open_parens -= 1\n        end\n        current_string *= paren_string[i]\n\
    \        if open_parens == 0\n            push!(output, current_string)\n    \
    \        current_string = \"\"\n        end\n    end\n    output\nend\n@testset\
    \ \"separate_paren_groups\" begin\n    @test separate_paren_groups(\"( ) (( ))\
    \ (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n    @test separate_paren_groups(\"\
    (())()((()(())))\") == [\"(())\", \"()\", \"((()(())))\"]\n    @test separate_paren_groups(\"\
    ((()(())))()(())\") == [\"((()(())))\", \"()\", \"(())\"]\n    @test separate_paren_groups(\"\
    ()\") == [\"()\"]\n    @test separate_paren_groups(\"\") == []\n    @test_throws\
    \ ArgumentError separate_paren_groups(\"(\")\n    @test_throws ArgumentError separate_paren_groups(\"\
    )\")\n    @test_throws ArgumentError separate_paren_groups(\"())(()\")\n    @test_throws\
    \ ArgumentError separate_paren_groups(\"(((())(()\")\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: UndefVarError: @testset not defined

    in expression starting at /tmp/tmp10_k5eqo.jl:42

    in expression starting at /tmp/tmp10_k5eqo.jl:42

    '
  stdout: ''
  timestamp: 1659979136
- exit_code: -1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    nest_counter = 0\n    out_string = \"\"\n    out_strings = []\n    for\
    \ p in paren_string\n        if p == '('\n            nest_counter += 1\n    \
    \    elseif p == ')'\n            nest_counter -= 1\n        end\n        if nest_counter\
    \ > 0\n            out_string *= p\n        elseif nest_counter == 0\n       \
    \     out_strings *= out_string\n            out_string = \"\"\n        end\n\
    \    end\n    return out_strings\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: Timeout
  stderr: None
  stdout: 'b''test set: Error During Test at /tmp/tmpo8354dzc.jl:32\n  Test threw
    exception\n  Expression: candidate("(()()) ((())) () ((())()())") == ["(()())",
    "((()))", "()", "((())()())"]\n  MethodError: no method matching *(::Vector{Any},
    ::String)\n  Closest candidates are:\n    *(::Any, ::Any, !Matched::Any, !Matched::Any...)
    at ~/.conda/envs/polyglot/share/julia/base/operators.jl:655\n    *(!Matched::Union{AbstractChar,
    AbstractString}, ::Union{AbstractChar, AbstractString}...) at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:260\n    *(::StridedVecOrMat,
    !Matched::LinearAlgebra.Adjoint{<:Any, <:LinearAlgebra.LQPackedQ}) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/lq.jl:266\n    ...\n  Stacktrace:\n   [1]
    separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpo8354dzc.jl:21\n   [2]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445
    [inlined]\n   [3] macro expansion\n     @ /tmp/tmpo8354dzc.jl:32 [inlined]\n   [4]
    macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283
    [inlined]\n   [5] top-level scope\n     @ /tmp/tmpo8354dzc.jl:31\n'''
  timestamp: 1659979140
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    res = []\n    buf = \"\"\n    start_paren_cnt = 0\n    end_paren_cnt =\
    \ 0\n    for c in paren_string\n        if c == '('\n            start_paren_cnt\
    \ += 1\n        elseif c == ')'\n            end_paren_cnt += 1\n        end\n\
    \        if start_paren_cnt == end_paren_cnt\n            res = push!(res, buf)\n\
    \            buf = \"\"\n            start_paren_cnt = 0\n            end_paren_cnt\
    \ = 0\n        else\n            if c != ' '\n                buf = string(buf,\
    \ c)\n            end\n        end\n    end\n    return res\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp6tpbdr9k.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmp6tpbdr9k.jl:37\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6tpbdr9k.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6tpbdr9k.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp6tpbdr9k.jl:38\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \"\"\
    , \"(()\", \"\", \"((())\", \"\", \"(((()))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6tpbdr9k.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6tpbdr9k.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp6tpbdr9k.jl:39\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()(())((()))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6tpbdr9k.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6tpbdr9k.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp6tpbdr9k.jl:40\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"(\", \"\", \"(()\"\
    , \"\", \"(()()\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6tpbdr9k.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda"
  timestamp: 1659979137
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Fill out the function body\n    return [\"()\", \"(())\", \"(()())\"\
    ]\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t\
    @test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmo557w_t.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpmo557w_t.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"()\", \"(())\", \"(()())\"] == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmo557w_t.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmo557w_t.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpmo557w_t.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(())\"\
    , \"(()())\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmo557w_t.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmo557w_t.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpmo557w_t.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"()\", \"(())\", \"(()())\"] == [\"\
    (()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmo557w_t.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmo557w_t.jl:16\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979137
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpt4xggxyp.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpt4xggxyp.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpt4xggxyp.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt4xggxyp.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt4xggxyp.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpt4xggxyp.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpt4xggxyp.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659979121
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpt4xggxyp.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpt4xggxyp.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpt4xggxyp.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt4xggxyp.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt4xggxyp.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpt4xggxyp.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpt4xggxyp.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659979121
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    opening_braces = count(x -> x == '(' , paren_string)\n    closing_braces\
    \ = count(x -> x == ')' , paren_string)\n    if opening_braces != closing_braces\n\
    \        error(\"Imbalanced parens\")\n    end\n    balance = 0\n    paren_groups\
    \ = []\n    start_index = 1\n    for (index, char) in enumerate(paren_string)\n\
    \        if (char == '(')\n            balance += 1\n        elseif (char == ')')\n\
    \            balance -= 1\n        end\n        if (balance == 0)\n          \
    \  push!(paren_groups, paren_string[start_index:index])\n            start_index\
    \ = index + 1\n        end\n    end\n    return paren_groups\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpj9l7gecc.jl:32

    '
  stdout: "test set: Test Failed at /tmp/tmpj9l7gecc.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj9l7gecc.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj9l7gecc.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpj9l7gecc.jl:36\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \" \"\
    , \"(())\", \" \", \"((()))\", \" \", \"(((())))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj9l7gecc.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj9l7gecc.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpj9l7gecc.jl:38\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( )\", \" \", \"((\
    \ ))\", \" \", \"(( )( ))\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj9l7gecc.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj9l7gecc.jl:34\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659979137
