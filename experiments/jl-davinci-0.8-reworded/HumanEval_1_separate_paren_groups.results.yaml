name: HumanEval_1_separate_paren_groups
language: jl
results:
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_matches = [match(r\"\\(+\\)+\", paren_string) for paren_string in\
    \ split(paren_string, \" \")]\n    paren_matches = filter(x -> x != nothing, paren_matches)\n\
    \    return map(x -> x.match, paren_matches)\nend\n@testset \"parens\" begin\n\
    \    @test separate_paren_groups(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\"\
    , \"(()())\"]\n    @test separate_paren_groups(\"( ) (( )) (( )( ))\") != [\"\
    ()\", \"(())\", \"(()())\", \"()()()()\"]\n    @test separate_paren_groups(\"\
    ( ) (( )) (( )( ))\") != [\"(())\", \"(()())\", \"()\"]\n    @test separate_paren_groups(\"\
    ( ) (( )) (( )( ))\") != [\"()\", \"(())\", \"(()())\", \"()()()()\"]\n    @test\
    \ separate_paren_groups(\"\") == []\n    @test separate_paren_groups(\"(())\"\
    ) == [\"(())\"]\n    @test separate_paren_groups(\"(((((((())))))))\") == [\"\
    (((((((())))))))\" ]\n    @test separate_paren_groups(\"( ((((((())))))) )\")\
    \ == [\"( ((((((())))))) )\"]\n    @test separate_paren_groups(\"()()()\") ==\
    \ [\"()()()\"]\n    @test separate_paren_groups(\"(())()()()\") == [\"(())()()()\"\
    ]\n    @test separate_paren_groups(\"()()()(())\") == [\"()()()(())\"]\n    @test\
    \ separate_paren_groups(\"(())()()()(())\") == [\"(())()()()(())\"]\n    @test\
    \ separate_paren_groups(\"(())(())(())\") == [\"(())(())(())\"]\n    @test separate_paren_groups(\"\
    (())()()()(())\") == [\"(())()()()(())\"]\n    @test separate_paren_groups(\"\
    (()()()()()()())\") == [\"(()()()()()()())\"]\n    @test separate_paren_groups(\"\
    (()(())(())(())(()\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: space before \"(\" not allowed in \"\"(()(())(())(())(()\\\
    nusing Test\\n\\n@testset begin\\n\\ncandidate = separate_paren_groups;\\n\\t@test(candidate(\"\
    (()()) (\" at /tmp/tmp7fz_nvwp.jl:35\nStacktrace:\n [1] top-level scope\n   @\
    \ /tmp/tmp7fz_nvwp.jl:35\nin expression starting at /tmp/tmp7fz_nvwp.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_lcb2vx6.jl:15\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp_lcb2vx6.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_lcb2vx6.jl:15 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_lcb2vx6.jl:14\ntest set:\
    \ Error During Test at /tmp/tmp_lcb2vx6.jl:16\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp_lcb2vx6.jl:9"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_lcb2vx6.jl:12\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\") # remove spaces in\
    \ the string\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkz6b6aai.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkz6b6aai.jl:1\n\
    in expression starting at /tmp/tmpkz6b6aai.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    #Vector for storing separated paren groups\n    separate_groups = []\n\
    \    #Compute the total number of parens in the input string.\n    count_total_parens\
    \ = length(findall(r\"\\(|\\)\", paren_string))\n    #Compute the number of paren\
    \ groups in the input string.\n    count_paren_groups = count_total_parens/2\n\
    \    #This is the index of the last paren group in the string.\n    last_group_idx\
    \ = count_paren_groups\n    #Create a temporary string that is the same as paren_string\
    \ but without spaces.\n    temp_string = replace(paren_string, \" \" => \"\")\n\
    \    #Create a temporary string that has the first paren group removed.\n    temp_string2\
    \ = replace(temp_string, r\"\\(.*\\)\", \"\")\n    #Add the first paren group\
    \ to separate_groups\n    push!(separate_groups, replace(temp_string, r\"\\(.*\\\
    )\", \"\"))\n    #Iterate over the input string and locate the indices of the\
    \ paren groups.\n    for i in 1:count_paren_groups-1\n        #Assemble a regex\
    \ to find all paren groups after the first.\n        temp_string3 = r\"(\\()(.*)\"\
    *string(last_group_idx-i)*r\"(\\))\"\n        push!(separate_groups, replace(temp_string2,\
    \ temp_string3, \"\"))\n        temp_string2 = replace(temp_string2, temp_string3,\
    \ \"\")\n    end\n    #Return the vector of separate paren groups.\n    return\
    \ separate_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8ve8prb3.jl:38\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching replace(::String,\
    \ ::Regex, ::String)\n  Closest candidates are:\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp8ve8prb3.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8ve8prb3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8ve8prb3.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp8ve8prb3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching replace(::String, ::Regex, ::String)\n\
    \  Closest candidates are:\n    replace(!Matched::Union{Function, Type}, ::Any;\
    \ count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n    replace(::String,\
    \ !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp8ve8prb3.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8ve8prb3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/cento"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8ve8prb3.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \n    \"\"\" Initialize an array that will store all the seperate parenthesis\
    \ groups\"\"\"\n    seperate_groups = []\n    \n    \"\"\" Initialize a counter\
    \ that will count the number of open parenthesis\"\"\"\n    open_paren = 0\n \
    \   \n    \"\"\" Initialize a counter that will count the number of closed parenthesis\"\
    \"\"\n    closed_paren = 0\n    \n    \"\"\" Initialize a string that will store\
    \ the starting index\"\"\"\n    group_start = \"\"\n    \n    \"\"\" Loop through\
    \ each character in the string and use conditional statements \n        to determine\
    \ whether it is a parenthesis or a space \"\"\"\n    for char in paren_string\n\
    \        if char == \"(\"\n            open_paren += 1\n        elseif char ==\
    \ \")\"\n            closed_paren += 1\n        elseif char == \" \"\n       \
    \     nothing\n        end\n    end\n    \n    \"\"\" Check to see if the number\
    \ of open parenthesis is equal to the number of closed parenthesis \"\"\"\n  \
    \  if open_paren != closed_paren\n        print(\"No\")\n        return\n    end\n\
    \    \n    \"\"\" Determine the starting index for each group of parenthesis,\
    \ and the length of each group \"\"\"\n    for (i, char) in enumerate(paren_string)\n\
    \        if char == \"(\"\n            group_start = i\n        elseif char ==\
    \ \")\"\n            push!(seperate_groups, String(paren_string[group_start:i]))\n\
    \        end\n    end\n    return seperate_groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgtn9oayt.jl:55\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgtn9oayt.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgtn9oayt.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgtn9oayt.jl:56\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgtn9oayt.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgtn9oayt.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgtn9oayt.jl:57\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgtn9oayt.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgtn9oayt.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgtn9oayt.jl:58\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgtn9oayt.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgtn9oayt.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_list = split(strip(paren_string), \" \")\n    paren_list = paren_list[paren_list\
    \ .!= \"\"] # Get rid of empty strings in list\n    valid_string = [\"(\" for\
    \ i in 1:length(paren_list)]\n    for i in 1:length(paren_list)\n        valid_string[i]\
    \ = valid_string[i] * \"(\" ^ length(paren_list[i])\n    end\n    return paren_list\
    \ .== valid_string\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpr2lh4q8l.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Bool\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{String},\
    \ !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] setindex!(A::Vector{String}, x::Bool, i1::Int64)\n\
    \     @ Base ./array.jl:903\n   [2] Array\n     @ ./bitarray.jl:498 [inlined]\n\
    \   [3] convert\n     @ ./array.jl:554 [inlined]\n   [4] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr2lh4q8l.jl:15\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpr2lh4q8l.jl:22 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpr2lh4q8l.jl:21\ntest set:\
    \ Error During Test at /tmp/tmpr2lh4q8l.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Bool to an object\
    \ of type String\n  Closest candidates are:\n    convert(::Type{String}, !Matched::String)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] setindex!(A::Vector{String}, x::Bool, i1::Int64)\n\
    \     @ Base ."
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpr2lh4q8l.jl:19\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Start your code after this line\n \nend\n \n \n \n@testset \"Separate\
    \ groups of nested parentheses\" begin\n    @test separate_paren_groups(\"( )\
    \ (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n    @test separate_paren_groups(\"\
    ( )( ) ( ( ) )\") == [\"()\", \"()\", \"(())\"]\n    @test separate_paren_groups(\"\
    ( ) (( ) ) ( ( ) )\") == [\"()\", \"(())\", \"(())\"]\n    @test separate_paren_groups(\"\
    ( ( ( ) ) )\") == [\"((()))\"]\n    @test separate_paren_groups(\"((((( )))(((((\
    \ ))))))\") == [\"((((( )))))\", \"((((( )))))\"]\n    @test separate_paren_groups(\"\
    ( ( ( ) (( )) ) )\") == [\"(((()(()))))\"]\n    @test separate_paren_groups(\"\
    ( ( ( ) (( )) (( )) ) )\") == [\"(((()(())(()))))\"]\n    @test separate_paren_groups(\"\
    ( ( ( ) (( (( )) )) ) )\") == [\"(((()(((()))))))\"]\n    @test separate_paren_groups(\"\
    ( ( ( ) (( (( (( (( (( )) ((( )) ) ) ) ) (( (( (( (( )) ) ) ) ) ) ) )) )) ) )\
    \ )\") == [\"(((()((((((((((((((((())))))))(((((((((((((()))))))))))))))))))))))\"\
    ]\nend\n \n \n \n\"\"\" Your task is to implement an autocomplete feature for\
    \ an input field.\n    You will be given a dictionary of words, and a query string.\n\
    \    You should return a list of words that start with the query string,\n   \
    \ and are the shortest possible completions. (If there are multiple words that\
    \ match,\n    return the word that would appear first in the dictionary.)\n \n\
    \    Note: You should match from the beginning of the string,\n    rather than\
    \ anywhere in the string.\n \n    >>> complete(\"abc\", [\"abce\", \"abcd\", \"\
    abcde\", \"abcdef\"])\n    [\"abcd\", \"abce\"]\n    >>> complete(\"abc\", [\"\
    abce\", \"abcd\", \"\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: UndefVarError: @testset not defined\nin expression starting\
    \ at /tmp/tmp2eqjcbad.jl:15\nin expression starting at /tmp/tmp2eqjcbad.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, r\"\\s\", \"\")\n    paren_groups\
    \ = []\n    start = 1\n    i = 1\n    while i <= length(paren_string)\n      \
    \  if paren_string[i] == '('\n            push!(paren_groups, paren_string[start:i])\n\
    \            start = i\n        elseif paren_string[i] == ')'\n            push!(paren_groups,\
    \ paren_string[start:i])\n            start = i + 1\n        end\n        i +=\
    \ 1\n    end\n    # here we want to iterate over paren_groups and delete the empty\
    \ strings\n    # this is a compact way to do that in Julia\n    # http://stackoverflow.com/questions/20344932/python-delete-empty-strings-from-a-list-of-strings\n\
    \    paren_groups = [x for x in paren_groups if x != \"\"]\n    return paren_groups\n\
    end\nseparate_paren_groups(\"( ) (( )) (( )( ))\")\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: MethodError: no method matching replace(::String, ::Regex,\
    \ ::String)\nClosest candidates are:\n  replace(!Matched::Union{Function, Type},\
    \ ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n \
    \ replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \  replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \  ...\nStacktrace:\n [1] separate_paren_groups(paren_string::String)\n   @ Main\
    \ /tmp/tmp1zum70hk.jl:9\n [2] top-level scope\n   @ /tmp/tmp1zum70hk.jl:29\nin\
    \ expression starting at /tmp/tmp1zum70hk.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    output = []\n    temp = \"\"\n    open_paren = 0\n\
    \    close_paren = 0\n    for i in paren_string\n        if i != \" \"\n     \
    \       if i == \"(\"\n                open_paren += 1\n            else\n   \
    \             close_paren += 1\n            end\n            temp *= i\n     \
    \   end\n        if open_paren == close_paren\n            push!(output, temp)\n\
    \            temp = \"\"\n            open_paren = 0\n            close_paren\
    \ = 0\n        end\n    end\n    return output\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwrcgxgxt.jl:37\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwrcgxgxt.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwrcgxgxt.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpwrcgxgxt.jl:38\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwrcgxgxt.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwrcgxgxt.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpwrcgxgxt.jl:39\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwrcgxgxt.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwrcgxgxt.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpwrcgxgxt.jl:40\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwrcgxgxt.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwrcgxgxt.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = filter(x -> x != ' ', paren_string)\n    stack = ' '\n\
    \    prev = ' '\n    start = 1\n    stop = 1\n    res = Vector{String}()\n   \
    \ for i in 1:length(paren_string)\n        if paren_string[i] == '('\n       \
    \     if prev == ')'\n                push!(res, paren_string[start:stop])\n \
    \               start = i\n            end\n            push!(stack, '(')\n  \
    \      elseif paren_string[i] == ')'\n            pop!(stack)\n            if\
    \ isempty(stack)\n                stop = i\n            end\n        end\n   \
    \     prev = paren_string[i]\n    end\n    push!(res, paren_string[start:stop])\n\
    \    return res\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcnemxwoj.jl:38\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching push!(::Char, ::Char)\n\
    \  Closest candidates are:\n    push!(::Any, ::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpcnemxwoj.jl:21\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcnemxwoj.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcnemxwoj.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpcnemxwoj.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching push!(::Char, ::Char)\n  Closest\
    \ candidates are:\n    push!(::Any, ::Any, !Matched::Any) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2970\n\
    \    push!(::Any, ::Any, !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/abstractarray.jl:2971\n\
    \    push!(!Matched::Base.InvasiveLinkedListSynchronized{T}, ::T) where T at /shared/centos7/julia/1.7.3/share/julia/base/task.jl:605\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpcnemxwoj.jl:21\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcnemxwoj.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/jul"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcnemxwoj.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    results = []\n    current_string = \"\"\n    open_paren_count = 0\n  \
    \  close_paren_count = 0\n    for (i,c) in enumerate(paren_string)\n        if\
    \ c != ' '\n            current_string *= c\n            if c == '('\n       \
    \         open_paren_count += 1\n            elseif c == ')'\n               \
    \ close_paren_count += 1\n            end\n            if open_paren_count ==\
    \ close_paren_count\n                results *= current_string\n             \
    \   current_string = \"\"\n                open_paren_count = 0\n            \
    \    close_paren_count = 0\n            end\n        end\n    end\n    return\
    \ results\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpk18ut43r.jl:36\\n  Test threw\
    \ exception\\n  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]\\n  MethodError: no method matching\
    \ *(::Vector{Any}, ::String)\\n  Closest candidates are:\\n    *(::Any, ::Any,\
    \ !Matched::Any, !Matched::Any...) at /shared/centos7/julia/1.7.3/share/julia/base/operators.jl:655\\\
    n    *(!Matched::Union{AbstractChar, AbstractString}, ::Union{AbstractChar, AbstractString}...)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:260\\n    *(::StridedVecOrMat,\
    \ !Matched::LinearAlgebra.Adjoint{<:Any, <:LinearAlgebra.LQPackedQ}) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/lq.jl:266\\\
    n    ...\\n  Stacktrace:\\n   [1] separate_paren_groups(paren_string::String)\\\
    n     @ Main /tmp/tmpk18ut43r.jl:22\\n   [2] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\\n   [3] macro expansion\\n     @ /tmp/tmpk18ut43r.jl:36 [inlined]\\\
    n   [4] macro expansion\\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\\n   [5] top-level scope\\n     @ /tmp/tmpk18ut43r.jl:35\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # what are your inputs, what is your output?\n    # your code here\nend\n\
    using Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmibyzzxx.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpmibyzzxx.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmibyzzxx.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmibyzzxx.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpmibyzzxx.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpmibyzzxx.jl:"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmibyzzxx.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp8i_3c61e.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp8i_3c61e.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8i_3c61e.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8i_3c61e.jl:15\ntest set:\
    \ Error During Test at /tmp/tmp8i_3c61e.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp8i_3c61e.jl:"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8i_3c61e.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    current_group = \"\"\n    groups = []\n    current_parens = 0\n    for\
    \ c in paren_string\n        if c == '('\n            current_parens += 1\n  \
    \      elseif c == ')'\n            current_parens -= 1\n        end\n       \
    \ if current_parens == 0\n            push!(groups, current_group)\n         \
    \   current_group = \"\"\n        else\n            current_group *= c\n     \
    \   end\n    end\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0mdzh7nz.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0mdzh7nz.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0mdzh7nz.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp0mdzh7nz.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \"\"\
    , \"(()\", \"\", \"((())\", \"\", \"(((()))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0mdzh7nz.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0mdzh7nz.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp0mdzh7nz.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()(())((()))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0mdzh7nz.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0mdzh7nz.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp0mdzh7nz.jl:35\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( \", \"\", \"(( )\"\
    , \"\", \"(( )( )\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0mdzh7nz.jl:35 [inli"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0mdzh7nz.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    in_parens = false\n    paren_group = \"\"\n    paren_groups = []\n   \
    \ for c in paren_string\n        if c == '('\n            in_parens = true\n \
    \       elseif c == ')'\n            in_parens = false\n            push!(paren_groups,\
    \ paren_group)\n            paren_group = \"\"\n        elseif c != ' '\n    \
    \        if in_parens\n                paren_group *= c\n            end\n   \
    \     end\n    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzr0m0gza.jl:32\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\
    \ \"\", \"\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzr0m0gza.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzr0m0gza.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpzr0m0gza.jl:33\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"\", \"\",\
    \ \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzr0m0gza.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzr0m0gza.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpzr0m0gza.jl:34\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"\", \"\", \"\", \"\", \"\", \"\",\
    \ \"\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzr0m0gza.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzr0m0gza.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpzr0m0gza.jl:35\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"\", \"\", \"\", \"\
    \", \"\", \"\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzr0m0gza.jl:35 [inline"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzr0m0gza.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    i = 1\n    open = 0\n    result = String[]\n    to_remove = String[]\n\
    \    for c in paren_string\n        if c == '('\n            open += 1\n     \
    \   elseif c == ')'\n            open -= 1\n        elseif c == ' '\n        \
    \    push!(to_remove, i)\n        end\n        if open == 0\n            push!(result,\
    \ paren_string[1:i])\n            paren_string = paren_string[i+1:end]\n     \
    \       paren_string = replace(paren_string, to_remove, \"\")\n            i =\
    \ 1\n            open = 0\n            to_remove = String[]\n        else\n  \
    \          i += 1\n        end\n    end\n    return result\nend\nseparate_paren_groups(\"\
    ( ) (( )) (( )( ))\")\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: MethodError: Cannot `convert` an object of type Int64\
    \ to an object of type String\nClosest candidates are:\n  convert(::Type{String},\
    \ !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \  convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \  convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \  ...\nStacktrace:\n [1] push!(a::Vector{String}, item::Int64)\n   @ Base ./array.jl:994\n\
    \ [2] separate_paren_groups(paren_string::String)\n   @ Main /tmp/tmpojhu2iiy.jl:19\n\
    \ [3] top-level scope\n   @ /tmp/tmpojhu2iiy.jl:34\nin expression starting at\
    \ /tmp/tmpojhu2iiy.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    groups = String[]\n\
    \    start = 1\n    i = 1\n    while i <= length(paren_string)\n        if paren_string[i]\
    \ == '('\n            start = i\n        elseif paren_string[i] == ')'\n     \
    \       push!(groups, paren_string[start:i])\n        end\n        i += 1\n  \
    \  end\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_rqt8hem.jl:28\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"()\", \"()\", \"())\", \"()\", \"())\", \"()))\", \"()\",\
    \ \"()\", \"())\", \"()\", \"()\", \"())\"] == [\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_rqt8hem.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_rqt8hem.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp_rqt8hem.jl:29\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"()\"\
    , \"())\", \"()\", \"())\", \"()))\", \"()\", \"())\", \"()))\", \"())))\"] ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_rqt8hem.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_rqt8hem.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp_rqt8hem.jl:30\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"()\", \"()\", \"())\", \"()\", \"\
    ())\", \"()))\", \"())))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_rqt8hem.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_rqt8hem.jl:27\ntest set: Test\
    \ Failed at /tmp/tmp_rqt8hem.jl:31\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"()\", \"())\"\
    , \"()\", \"()\", \"())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdl"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_rqt8hem.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n  # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprjtt0c2k.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmprjtt0c2k.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprjtt0c2k.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprjtt0c2k.jl:15\ntest set:\
    \ Error During Test at /tmp/tmprjtt0c2k.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmprjtt0c2k.jl:"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprjtt0c2k.jl:13\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    s=split(paren_string, \" \")\n    v=[]\n    for i in s\n        if i!=\"\
    \"\n            push!(v, i)\n        end\n    end\n    v\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpes3ydz1t.jl:26\n  Expression: candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"(\"\
    , \")\", \"((\", \"))\", \"((\", \")(\", \"))\"] == [\"()\", \"(())\", \"(()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpes3ydz1t.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpes3ydz1t.jl:22\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     1      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpes3ydz1t.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the vector of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # ...\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  stdout: "test set: Error During Test at /tmp/tmprrzc4fkq.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmprrzc4fkq.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprrzc4fkq.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprrzc4fkq.jl:15\ntest set:\
    \ Error During Test at /tmp/tmprrzc4fkq.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmprrzc4fkq.jl:"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprrzc4fkq.jl:13\n"
  exit_code: 1
  status: SyntaxError
