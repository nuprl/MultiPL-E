name: HumanEval_58_common
language: jl
results:
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    temp = intersect(l1, l2)\n    temp[sortperm(temp)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    ll = zeros(Int64, min(length(l1), length(l2)))\n\
    \    k = 0\n    for e in l1\n        if e in l2\n            k += 1\n        \
    \    ll[k] = e\n        end\n    end\n    return ll[1:k]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpkbj4op3z.jl:24\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [1, 653, 5] == [1, 5, 653]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkbj4op3z.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkbj4op3z.jl:23\ntest set: Test\
    \ Failed at /tmp/tmpkbj4op3z.jl:25\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [3, 2] == [2, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkbj4op3z.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkbj4op3z.jl:23\ntest set: Test\
    \ Failed at /tmp/tmpkbj4op3z.jl:26\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 3, 2] == [2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkbj4op3z.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkbj4op3z.jl:23\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkbj4op3z.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    l = intersect(l1, l2)\n    sort!(l)\n\
    \    l\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    common_elements = intersect(l1, l2)\n\
    \    return sort(unique(common_elements))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2,\
    \ 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    #combine all the elements of l1 and\
    \ l2 in a single array\n    c = vcat(l1, l2)\n    #sort elements of combined array\n\
    \    s = sort(c)\n    #remove duplicates\n    v = unique(s)\n    #make a new array\
    \ to store common elements\n    a = []\n    #iterate over the unique elements\n\
    \    for i = 1:length(v)\n        #check how many times each element is in the\
    \ combined array\n        if count(c, v[i]) > 1\n            #if more than once,\
    \ it's a common element\n            #store the element in array 'a'\n       \
    \     push!(a, v[i])\n        end\n    end\n    #return the array of common elements\n\
    \    return a\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpov4z3f7f.jl:34\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: objects of type Vector{Int64} are not callable\n\
    \  Use square brackets [] for indexing an Array.\n  Stacktrace:\n   [1] _simple_count(pred::Vector{Int64},\
    \ itr::Int64, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::Vector{Int64},\
    \ itr::Int64; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::Vector{Int64},\
    \ itr::Int64)\n     @ Base ./reduce.jl:1201\n   [4] common(l1::Vector{Int64},\
    \ l2::Vector{Int64})\n     @ Main /tmp/tmpov4z3f7f.jl:20\n   [5] macro expansion\n\
    \     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpov4z3f7f.jl:34 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpov4z3f7f.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpov4z3f7f.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: objects of type Vector{Int64}\
    \ are not callable\n  Use square brackets [] for indexing an Array.\n  Stacktrace:\n\
    \   [1] _simple_count(pred::Vector{Int64}, itr::Int64, init::Int64)\n     @ Base\
    \ ./reduce.jl:1206\n   [2] count(f::Vector{Int64}, itr::Int64; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::Vector{Int64}, itr::Int64)\n  \
    \   @ Base ./reduce.jl:1201\n   [4] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpov4z3f7f.jl:20\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpov4z3f7f.jl:35 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpov4z3f7f.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpov4z3f7f.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2,"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpov4z3f7f.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    res = []\n    for i in l1\n        for\
    \ j in l2\n            if i == j\n                push!(res,i)\n            end\n\
    \        end\n    end\n    return sort(unique(res))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    # Use set for more speed since it has\
    \ O(1) access\n    l1, l2 = Set(l1), Set(l2)\n    return sort(intersect(l1, l2))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpgytmbof1.jl:18\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching sort(::Set{Int64})\n  Closest\
    \ candidates are:\n    sort(!Matched::AbstractUnitRange) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1304\n\
    \    sort(!Matched::AbstractRange) at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1307\n\
    \    sort(!Matched::SparseArrays.SparseVector{Tv, Ti}; kws...) where {Tv, Ti}\
    \ at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpgytmbof1.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgytmbof1.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgytmbof1.jl:17\ntest set:\
    \ Error During Test at /tmp/tmpgytmbof1.jl:19\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching\
    \ sort(::Set{Int64})\n  Closest candidates are:\n    sort(!Matched::AbstractUnitRange)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1304\n    sort(!Matched::AbstractRange)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/range.jl:1307\n    sort(!Matched::SparseArrays.SparseVector{Tv,\
    \ Ti}; kws...) where {Tv, Ti} at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/SparseArrays/src/sparsevector.jl:1968\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpgytmbof1.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgytmbof1.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgytmbof1.jl:15\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    ll = []\n    common_elements = unique(intersect(l1,\
    \ l2))\n    sort!(common_elements)\n    return common_elements\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3,\
    \ 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2,\
    \ 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    \"\"\"        \n    #Sorting\n    l1\
    \ = sort(l1)\n    l2 = sort(l2)\n    # Sorting doesn't work for the following\
    \ line because all elements are\n    # unique.\n    l1 = unique(l1)\n    l2 =\
    \ unique(l2)\n    \"\"\"\n    n = length(l1)\n    m = length(l2)\n    i1 = 1\n\
    \    i2 = 1\n    result = Vector{Int64}(0)\n    while i1 <= n && i2 <= m\n   \
    \     if l1[i1] == l2[i2]\n            push!(result, l1[i1])\n            i1 +=\
    \ 1\n            i2 += 1\n        elseif l1[i1] < l2[i2]\n            i1 += 1\n\
    \        else\n            i2 += 1\n        end\n    end\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpbu_b00br.jl:41\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  MethodError: no method matching Vector{Int64}(::Int64)\n \
    \ Closest candidates are:\n    Vector{T}() where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n\
    \    Array{T, N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpbu_b00br.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbu_b00br.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbu_b00br.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpbu_b00br.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  MethodError: no method matching\
    \ Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}() where T at\
    \ /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T, N}(!Matched::Core.Compiler.BitArray{N})\
    \ where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmpbu_b00br.jl:22\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbu_b00br.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbu_b00br.jl:40\ntest set:\
    \ Error "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbu_b00br.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    l1 = sort(unique(l1))\n    l2 = sort(unique(l2))\n\
    \    i1 = 1\n    i2 = 1\n    results = Int64[]\n    while i1 <= length(l1) &&\
    \ i2 <= length(l2)\n        if l1[i1] == l2[i2]\n            push!(results, l1[i1])\n\
    \            i1 += 1\n            i2 += 1\n        elseif l1[i1] < l2[i2]\n  \
    \          i1 += 1\n        else\n            i2 += 1\n        end\n    end\n\
    \    return results\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\
    \t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1,\
    \ 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    v = []\n    for i in l1\n        if\
    \ i in l2 && !(i in v)\n            append!(v, i)\n        end\n    end\n    sort(v)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    return unique(sort(intersect(l1, l2)))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    vec = Vector{Int64}()\n    for i in\
    \ l1 \n        for j in l2 \n            if i == j \n                push!(vec,\
    \ i)\n            end\n        end\n    end\n    vec\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5,\
    \ 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t\
    @test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8rkeeypd.jl:24\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [1, 653, 5, 5] == [1, 5, 653]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8rkeeypd.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8rkeeypd.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp8rkeeypd.jl:25\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: [3, 2] == [2, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8rkeeypd.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8rkeeypd.jl:23\ntest set: Test\
    \ Failed at /tmp/tmp8rkeeypd.jl:26\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4, 3, 2] == [2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8rkeeypd.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8rkeeypd.jl:23\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8rkeeypd.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    i = j = 1\n    s = Set()\n    while\
    \ i <= length(l1) && j <= length(l2)\n        if l1[i] < l2[j]\n            i\
    \ += 1\n        elseif l1[i] > l2[j]\n            j += 1\n        else\n     \
    \       push!(s, l1[i])\n            i += 1\n            j += 1\n        end\n\
    \    end\n    return sort(collect(s))\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t\
    @test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4,\
    \ 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmooa3cnf.jl:29\n  Expression: candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n   Evaluated:\
    \ [653] == [1, 5, 653]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmooa3cnf.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmooa3cnf.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpmooa3cnf.jl:30\n  Expression: candidate([5, 3, 2, 8], [3,\
    \ 2]) == [2, 3]\n   Evaluated: Int64[] == [2, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmooa3cnf.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmooa3cnf.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpmooa3cnf.jl:31\n  Expression: candidate([4, 3, 2, 8], [3,\
    \ 2, 4]) == [2, 3, 4]\n   Evaluated: [4] == [2, 3, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmooa3cnf.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmooa3cnf.jl:28\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmooa3cnf.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    l1_uniq = unique(l1)\n    l2_uniq =\
    \ unique(l2)\n    common_indices = intersect(l1_uniq, l2_uniq)\n    return l1_uniq[common_indices]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmptdnxnddy.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  BoundsError: attempt to access 7-element Vector{Int64} at\
    \ index [[1, 653, 5]]\n  Stacktrace:\n   [1] throw_boundserror(A::Vector{Int64},\
    \ I::Tuple{Vector{Int64}})\n     @ Base ./abstractarray.jl:691\n   [2] checkbounds\n\
    \     @ ./abstractarray.jl:656 [inlined]\n   [3] _getindex\n     @ ./multidimensional.jl:838\
    \ [inlined]\n   [4] getindex\n     @ ./abstractarray.jl:1218 [inlined]\n   [5]\
    \ common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmptdnxnddy.jl:12\n\
    \   [6] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [7] macro expansion\n     @ /tmp/tmptdnxnddy.jl:19 [inlined]\n\
    \   [8] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [9] top-level scope\n     @ /tmp/tmptdnxnddy.jl:18\ntest set:\
    \ Test Failed at /tmp/tmptdnxnddy.jl:21\n  Expression: candidate([4, 3, 2, 8],\
    \ [3, 2, 4]) == [2, 3, 4]\n   Evaluated: [8, 2, 3] == [2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptdnxnddy.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptdnxnddy.jl:18\nTest Summary:\
    \ | Pass  Fail  Error  Total\ntest set      |    2     1      1      4\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 1 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptdnxnddy.jl:16\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    res = Set()\n    for i in l1\n     \
    \   for j in l2\n            if i == j\n                push!(res, i)\n      \
    \      end\n        end\n    end\n    sort(collect(res))\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34, 653, 2,\
    \ 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5, 3, 2,\
    \ 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3,\
    \ 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    return sort(unique(intersect(l1, l2)))\n\
    end\n    \n    \n    \n\"\"\"Sum of squares of elements in a vector.\n    >>>\
    \ sum_of_squares([1, 4, 3, 34, 653, 2, 5])\n    44119\n    >>> sum_of_squares([5,\
    \ 3, 2, 8])\n    104\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t\
    @test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5,\
    \ 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpspjn572f.jl:14\nin expression starting at\
    \ /tmp/tmpspjn572f.jl:14\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    res = intersect(l1, l2)\n    sort!(res)\n\
    \    return res\nend\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t\
    @test(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5,\
    \ 653])\n\t@test(candidate([5, 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4,\
    \ 3, 2, 8], [3, 2, 4]) == [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([]))\
    \ == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    return sort(unique(intersect(l1, l2)))\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    4      4\n"
  exit_code: 0
  status: OK
- program: "\"\"\"Return sorted unique common elements for two vectors.\n    >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5,\
    \ 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\nfunction common(l1::Vector{Int64},\
    \ l2::Vector{Int64})::Vector{Int64} \n    c1 = Counter(l1)\n    c2 = Counter(l2)\n\
    \    c12 = c1 + c2\n    return sort(collect(keys(c12[c12 .> 1])))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = common;\n\t@test(candidate([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\n\t@test(candidate([5,\
    \ 3, 2, 8], [3, 2]) == [2, 3])\n\t@test(candidate([4, 3, 2, 8], [3, 2, 4]) ==\
    \ [2, 3, 4])\n\t@test(candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp65ssq0py.jl:19\n  Test threw exception\n\
    \  Expression: candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653]\n  UndefVarError: Counter not defined\n  Stacktrace:\n   [1]\
    \ common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main /tmp/tmp65ssq0py.jl:9\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp65ssq0py.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp65ssq0py.jl:18\ntest set:\
    \ Error During Test at /tmp/tmp65ssq0py.jl:20\n  Test threw exception\n  Expression:\
    \ candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n  UndefVarError: Counter not defined\n\
    \  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n     @ Main\
    \ /tmp/tmp65ssq0py.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp65ssq0py.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp65ssq0py.jl:18\ntest set:\
    \ Error During Test at /tmp/tmp65ssq0py.jl:21\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n  UndefVarError: Counter not\
    \ defined\n  Stacktrace:\n   [1] common(l1::Vector{Int64}, l2::Vector{Int64})\n\
    \     @ Main /tmp/tmp65ssq0py.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp65ssq0py.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp65ssq0py.jl:18\ntest set:\
    \ Error During Test at /tmp/tmp65ssq0py.jl:22\n  Test threw exception\n  Expression:\
    \ candidate([4, 3, 2, 8], Vector{Int64}([])) == Vector{Int64}([])\n  UndefVarEr"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp65ssq0py.jl:16\n"
  exit_code: 1
  status: SyntaxError
