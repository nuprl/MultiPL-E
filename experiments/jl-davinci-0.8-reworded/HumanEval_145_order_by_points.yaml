name: HumanEval_145_order_by_points
language: jl
prompt: "\"\"\"\n    Write a function which sorts the given vector of integers\n \
  \   in ascending order according to the sum of their digits.\n    Note: if there\
  \ are several items with similar sum of their digits,\n    order them based on their\
  \ index in original vector.\n\n    For example:\n    >>> order_by_points([1, 11,\
  \ -1, -11, -12])\n    [-1, -11, 1, -12, 11]\n    >>> order_by_points([])\n    []\n\
  \    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
  \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463,\
  \ 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423,\
  \ 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
  \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) ==\
  \ [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8,\
  \ 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6,\
  \ 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
completions: ["    sums = map(a -> sum(digits(a)), nums)\n    argsort(sums)\nend",
  "    return sortperm(sum.(nums), 1:length(nums))\nend", "    nums = sort(nums, lt\
    \ = x->sum(digits(x)) < sum(digits(y)), rev = false)\n    return nums\nend\norder_by_points([1,\
    \ 11, -1, -11, -12])", " \n    # sum all the numbers in the vector\n    if length(nums)\
    \ == 0\n        return nums\n    end\n    n = length(nums)\n    sums = zeros(n)\n\
    \    for i in 1:n\n        sums[i] = sum(digits(nums[i]))\n    end\n   \n    #\
    \ find the positions of the minimum value\n    # note there can be more than one\
    \ positions\n    minsum = minimum(sums)\n    minpos = find(sums .== minsum)\n\
    \   \n    # find all the values at the minimum positions\n    # in the original\
    \ vector\n    mins = nums[minpos]\n   \n    # find the positions of the minimum\
    \ value in the original vector\n    # using argmin() gives the first position\
    \ if there are several\n    # thus cannot use this\n    minposs = zeros(length(mins))\n\
    \    for i in 1:length(mins)\n        minposs[i] = findfirst(nums .== mins[i])\n\
    \    end\n    \n    # sort the positions in ascending order\n    sort!(minposs)\n\
    \    \n    # find the original position in the original vector\n    # and replace\
    \ the corresponding value in the new vector\n    # with the minimum values from\
    \ the original vector\n    newvec = nums\n    for i in 1:length(minposs)\n   \
    \     newvec[minposs[i]] = mins[i]\n    end\n   \n    # remove the minimum values\
    \ from the original vector\n    for i in 1:length(mins)\n        deleteat!(nums,\
    \ findfirst(nums .== mins[i]))\n    end\n   \n    # recursively keep finding the\
    \ new minimum values and\n    # append it to the vector in the same order until\
    \ the\n    # original vector is empty\n    return vcat(newvec, order_by_points(nums))\n\
    end", "    sums = Vector{Int64}(undef, length(nums))\n    for i = 1:length(nums)\n\
    \        sums[i] = sum(nums[i])\n    end\n    return nums[sortperm(sums)]\nend",
  "    lens = length(nums)\n    if lens == 0\n        return nums\n    end\n    sort(nums,\
    \ by=x-> sum(digits(x)))\nend", "    isempty(nums) && return []\n    sorted_index\
    \ = sortperm(sum.(digits.(nums)))\n    nums[sorted_index]\nend", "    nums_with_points\
    \ = [(n, sum(digits(n))) for n in nums]\n    nums_with_points = sort(nums_with_points,\
    \ by=x -> x[2])\n    return [p[1] for p in nums_with_points]\nend", "    digit_sums\
    \ = [sum(digits(n)) for n in nums]\n    return nums[sortperm(digit_sums)]\nend",
  "    \n    pts = []\n    for i in nums\n        pts = [pts; sum(digits(i))]\n  \
    \  end\n    \n    order = sortperm(pts)\n    return [nums[i] for i in order]\n\
    \    \nend", "    # Initialize a dictionary of sums\n    sums = Dict{Int64, Int64}()\n\
    \    # Get the sums of each number\n    # Store them in the dictionary\n    for\
    \ i in 1:length(nums)\n        key = sum(int2vec(nums[i]))\n        sums[key]\
    \ = nums[i]\n    end\n    # Sort the dictionary by keys\n    sorted_sums = sort(collect(sums))\n\
    \    # Get the sorted numbers\n    sorted_nums = [sorted_sums[i][2] for i in 1:length(sorted_sums)]\n\
    \    return sorted_nums\nend", "    return sortperm(sum(digits.(nums))[1], by=nums)\n\
    end", "    \n    sum_of_digits = map(s -> sum(digits(s)), nums)\n    index = sortperm(sum_of_digits)\n\
    \    sort(nums, alg=MergeSort, by=x->x[index])\nend", "    n = length(nums)\n\
    \    result = zeros(Int64, n)\n    arr_of_sum = zeros(Int64, n)\n    # get array\
    \ of sum of digits\n    for i in 1:n\n        num = nums[i]\n        abs_num =\
    \ abs(num)\n        sum_of_digit = 0\n        while abs_num != 0\n           \
    \ sum_of_digit += abs_num % 10\n            abs_num = abs_num // 10\n        end\n\
    \        arr_of_sum[i] = sum_of_digit\n    end\n    # sort array of sums\n   \
    \ sort!(arr_of_sum)\n    for i in 1:n\n        for j in 1:n\n            if arr_of_sum[i]\
    \ == nums[j]\n                result[i] = nums[j]\n                nums[j] = 0\n\
    \                break\n            end\n        end\n    end\n    return result\n\
    end", "    # sum the digits\n    digit_sum = [sum(digits(i)) for i in nums]\n\
    \    # return the indices of smallest sum to biggest sum\n    sortperm(digit_sum)\n\
    end", "    sorted = sort(nums, by=x->sum(digits(x)))\n    return sorted\nend",
  "    keys = []\n    for i in 1:length(nums)\n        key = 0\n        for j in digits(nums[i])\n\
    \            key += j\n        end\n        push!(keys, key)\n    end\n    sortperm(keys)\n\
    end", "    if nums == []\n        return []\n    end\n    indices_of_nums = Dict(key\
    \ => sum(digits(key)) for key in nums)\n    sorted_indices = sort(collect(keys(indices_of_nums)))\n\
    \    return sort(nums, by = i -> indices_of_nums[i])\nend", "    nums = sort(nums,\
    \ by=num -> sum(digits(num)))\n    return nums\nend", "    if length(nums) ==\
    \ 0\n        return []\n    end\n    points = zeros(Int64,length(nums))\n    for\
    \ i in range(1,length(nums))\n        points[i] = sumdigits(nums[i])\n    end\n\
    \    return sortperm(points)\nend", "    \n    #Your code here \n    \n    return\
    \ #", "    # your code goes here\nend\n\"\"\"\n    Write a function which receives\
    \ a vector of integers.\n    The function should return the pair of indices which\n\
    \    represent the shortest interval containing all the ones.\n    For example:\n\
    \    >>> shortest_ones_interval([1, 1, 0, 0, 1, 0, 1, 1, 0, 1])\n    (3, 6)\n\
    \    >>> shortest_ones_interval([1, 1, 1, 1, 1])\n    (1, 5)\n    >>> shortest_ones_interval([0,\
    \ 0, 0, 0, 0])\n    (1, 1)\n    \"\"\"", "    #Your code here\nend", "    index\
    \ = 1:length(nums)\n    sum_of_digits = get_digit_sum.(nums)\n    sortperm(sum_of_digits,\
    \ rev=false, by=index)\nend\n \norder_by_points([1, 11, -1, -11, -12])", "   \
    \ n = length(nums)\n    i = 1\n    while i < n\n        j = i\n        while j\
    \ > 0 && nums[j-1] > nums[j]\n            nums[j-1], nums[j] = nums[j], nums[j-1]\n\
    \            j = j - 1\n        end\n        i = i + 1\n    end\n    return nums\n\
    end", "    ret = []\n    for j in nums\n        if j < 0\n            ret = [j*-1;\
    \ ret]\n        else\n            ret = [j; ret]\n        end\n    end\n    sort(ret)\n\
    end", "    empty_vec = Vector{Int64}()\n    if isempty(nums)\n        return empty_vec\n\
    \    end\n    return sort(nums, by = x -> sum(digits(x)))\nend", "    order =\
    \ sort(nums, by = x -> sum(digits(x)))\n    return order\nend", "    nums_with_points\
    \ = []\n    for i in 1:length(nums)\n        num = nums[i]\n        nums_with_points\
    \ = push!(nums_with_points, (num, sum_digits(num), i))\n    end\n    nums_with_points\
    \ = sort(nums_with_points, by=x->(x[2], x[3]))\n    return map(x->x[1], nums_with_points)\n\
    end", "    if length(nums) == 0\n        return []\n    end\n    lens = length(nums)\n\
    \    res = zeros(Int64, lens)\n    sums = zeros(Int64, lens)\n    for i in 1:lens\n\
    \        num = nums[i]\n        if num < 0\n            num = -num\n        end\n\
    \        while num > 0\n            sums[i] += num % 10\n            num = div(num,\
    \ 10)\n        end\n    end\n    for i in 1:lens\n        if i == 1\n        \
    \    res[i] = sums[i]\n        else\n            index = i\n            for j\
    \ in 1:i-1\n                if sums[j] > sums[i]\n                    index =\
    \ j\n                end\n            end\n            for j in i:-1:index+1\n\
    \                res[j] = res[j-1]\n            end\n            res[index] =\
    \ sums[i]\n        end\n    end\n    #println(sums)\n    #println(res)\n    index\
    \ = zeros(Int64, lens)\n    for i in 1:lens\n        for j in 1:lens\n       \
    \     if sums[j] == res[i]\n                index[i] = j\n                break\n\
    \            end\n        end\n    end\n    #println(index)\n    result = zeros(Int64,\
    \ lens)\n    for i in 1:lens\n        result[i] = nums[index[i]]\n    end\n  \
    \  return result\nend", "    sort(nums, by=digit_sum)\nend", "    len = length(nums)\n\
    \    # output array\n    res = zeros(Int64, len)\n    # sums of digits\n    sums\
    \ = zeros(Int64, len)\n    # index\n    inds = zeros(Int64, len)\n    for i in\
    \ 1:len\n        tmp = nums[i]\n        sum = 0\n        while tmp != 0\n    \
    \        sum += tmp % 10\n            tmp = div(tmp, 10)\n        end\n      \
    \  sums[i] = sum\n        inds[i] = i\n    end\n    # sort sums and get the sorted\
    \ index\n    inds = sortperm(sums)\n    for i in 1:len\n        res[i] = nums[inds[i]]\n\
    \    end\n    return res\nend", "    sorted_sum = sort([sum(digits(n)) for n in\
    \ nums])\n    return [nums[searchsortedfirst(sorted_sum, sum(digits(n)))] for\
    \ n in nums]\nend", "    l = length(nums)\n    nums_ordered = copy(nums)\n   \
    \ for i = 1:l\n        sum_num = 0\n        while(nums[i] != 0)\n            sum_num\
    \ += nums[i] % 10\n            nums[i] = nums[i] \xF7 10\n        end\n      \
    \  nums[i] = sum_num\n    end\n    a = sortperm(nums)\n    nums_ordered = nums_ordered[a]\n\
    \    return nums_ordered\nend", "    k = sortperm(sum(digits(nums)...) + (1:length(nums))./1e6)\n\
    \    return nums[k]\nend", "    sums = map(i -> sum(digits(i)), nums)\n    sortperm(sums)\n\
    \    ordered = nums[sortperm(sums)]\n    return ordered\nend", "    num_sums =\
    \ zeros(Int64, length(nums))\n    for i in 1:length(nums)\n        num_sums[i]\
    \ = sum(digits(nums[i]))\n    end\n    order = sortperm(num_sums)\n    return\
    \ nums[order]\nend\n\"\"\"\n    Write a function which takes as input a vector\
    \ of integers\n    and a number K, and returns a vector of integers where the\n\
    \    item at index i is the product of all the items in the input\n    vector\
    \ except for the one at i.", "    inds = sortperm(sum.(digits.(nums)), by = x\
    \ -> x[1])\n    return nums[inds]\nend", "    indices = sortperm(sum.(abs.(digits.(nums))))\n\
    \    return nums[indices]\nend", "    if nums == [] \n        return []\n    end\n\
    \    # let's create a dictionary, where key is sum of digits in elements, \n \
    \   # and values are elements themselves\n    d = Dict()\n    for i in nums\n\
    \        if sum(digits(i)) in keys(d)\n            push!(d[sum(digits(i))], i)\n\
    \        else\n            d[sum(digits(i))] = [i]\n        end\n    end\n   \
    \ # let's create a vector of all keys of the d, sort it and delete duplicates\n\
    \    keys_vector = unique(sort(collect(keys(d))))\n    result = []\n    # let's\
    \ iterate over keys_vector and append elements from d to result vector\n    for\
    \ i in keys_vector\n        for j in d[i]\n            push!(result, j)\n    \
    \    end\n    end\n    return result\nend", "    if length(nums) == 0\n      \
    \  return nums\n    end\n    num_sum = collect(0:1:sum(nums))\n    num_new = zeros(Int64,\
    \ sum(nums) + 1)\n    for i in nums\n        num_new[sum(digits(i)) + 1] = i\n\
    \    end\n    num_sorted = zeros(Int64, length(nums))\n    idx = 1\n    for i\
    \ in num_sum\n        if num_new[i + 1] != 0\n            num_sorted[idx] = num_new[i\
    \ + 1]\n            idx += 1\n        end\n    end\n    return num_sorted\nend",
  "    sorted_nums = sort(nums, lt = (x,y) -> sum(digits(x)) < sum(digits(y)))\n \
    \   inds = indmax(sorted_nums)\n    for i in inds\n        sorted_nums = sorted_nums[i],\
    \ sorted_nums[end]\n    end\n    return sorted_nums\nend", "    sums = mapslices(sum,\
    \ [digits(n) for n in nums], dims = 1)\n    return sortperm(sums)[1]\nend", " \
    \   newvector = zeros(length(nums))\n    for i in 1:length(nums)\n        newvector[i]\
    \ = sum(digits(nums[i]))\n    end\n    sort(nums, by = newvector)\nend\n    \n\
    \"\"\"\n    Write a function which determines whether or not\n    the given vector\
    \ of integers has a duplicate entry.", "  sums = []\n  for num in nums\n    sum\
    \ = 0\n    for char in string(num)\n      sum += parse(Int64, char)\n    end\n\
    \    append!(sums, sum)\n  end\n  indices = sortperm(sums)\n  return nums[indices]\n\
    end", "    # do not change function name\n    # do not change function name\n\
    \    ordered_nums = deepcopy(nums)\n    sort!(ordered_nums, by = x -> sum(digits(x)))\n\
    \    return ordered_nums\nend", "    @assert length(nums) > 0\n    # your solution\
    \ goes here...\n    # I suggest you to create another vector first\n    # and\
    \ then sort this new vector, and then put its items\n    # back to the original\
    \ vector\n    new_v = zeros(Int64, length(nums))\n    for i in 1:length(nums)\n\
    \        new_v[i] = nums[i]\n    end\n    new_v = sort(new_v, by=x->sum(digits(x)))\n\
    \    return new_v\nend", "    vector_sum = zeros(Int64,length(nums))\n    for\
    \ i in 1:length(nums)\n        vector_sum[i] = sum_digits(nums[i])\n    end\n\
    \    sort!(zip(vector_sum,nums), by=x->x[1])\n    return collect(Int64,map(x->x[2],zip(vector_sum,nums)))\n\
    end", "    if nums == []\n        return []\n    end\n    a = Array{Tuple{Int64,\
    \ Int64}}(undef, length(nums))\n    for i = 1:length(nums)\n        a[i] = sum(digits(nums[i])),\
    \ i\n    end\n    sort!(a)\n    b = Array{Int64}(undef, length(nums))\n    for\
    \ i = 1:length(nums)\n        b[i] = nums[a[i][2]]\n    end\n    return b\nend",
  "    array = []\n    for i in 1:length(nums)\n        sum = 0\n        num = abs(nums[i])\n\
    \        while num != 0\n            sum += num % 10\n            num = div(num,\
    \ 10)\n        end\n        push!(array, (sum, nums[i]))\n    end\n    sorted_array\
    \ = sort(array, by = x -> x[1])\n    return [x[2] for x in sorted_array]\nend",
  "    if length(nums) == 0\n        return nums\n    end\n    sums = sum.(digits.(nums,\
    \ base=10))\n    indices = sortperm(sums)\n    return nums[indices]\nend", " \
    \   idx = [i for i=1:length(nums)]\n    sort!(sum(digits(nums)), idx)\n    idx\n\
    end", "    sort(nums, by=sum)\nend", "    # use decorate-sort-undecorate paradigm\n\
    \    if length(nums) == 0\n        return nums\n    end\n    # decorate\n    #\
    \ calculate the points of each integer\n    points_of_nums = [i=>get_points(nums[i])\
    \ for i in 1:length(nums)]\n    # sort the decorated vector\n    sorted_points_of_nums\
    \ = sort(points_of_nums, lt=(x,y)->x[2]<y[2])\n    # undecorate\n    return [sorted_points_of_nums[i][1]\
    \ for i in 1:length(sorted_points_of_nums)]\nend", "    # your code here\nend",
  "    sums = map(x -> sum(digits(x)), nums)\n    sortperm(sums)\n    sorted_nums\
    \ = nums[sortperm(sums)]\n    return sorted_nums\nend", "    sorter = []\n   \
    \ for (i, num) in enumerate(nums)\n        push!(sorter, (i, num, sum(digits(num))))\n\
    \    end\n    sort!(sorter, by=x->x[3])\n    return [x[2] for x in sorter]\nend",
  "    \n    points = Dict()\n    for (i, num) in enumerate(nums)\n        points[num]\
    \ = sum(digits(num))\n    end\n    \n    function compare(x, y)\n        a = points[x]\n\
    \        b = points[y]\n        if a == b\n            x < y\n        else\n \
    \           a < b\n        end\n    end\n    sorted = sort(nums, compare)\n  \
    \  return sorted\nend", "    # v2\n    # sort([nums[i] for i in order(sort(sum(digits(n)\
    \ for n in nums))))\n    sort(nums, by = x -> (sum(digits(x)), x))\nend", "  \
    \  \"\"\" \n    This function takes a vector of integers and returns a vector\
    \ of integers\n    sorted by the sum of the digits of each number.\n    \"\"\"\
    \n    sums = [sum(digits(num)) for num in nums]\n    order = sortperm(sums)\n\
    \    nums[order]\nend\n ", "    # calculating sums of digits\n    sums = [sum(digits(i))\
    \ for i in nums]\n    # sorting the arrays\n    sorted = sortperm(sums)\n    #\
    \ returning sorted result\n    return [nums[i] for i in sorted]\nend", "    #\
    \ YOUR CODE HERE\n    sorted_indices = sortperm(x -> sum(digits(x)), nums)\n \
    \   return nums[sorted_indices]\nend", "    \n    sorted_nums = sort(nums, by\
    \ = x -> sum(digits(x)))\n    return sorted_nums\nend", "    v = copy(nums)\n\
    \    sort!(v, by=x->sum(digits(x)))\n    return v\nend", "    s = Dict(i => sum(digits(i))\
    \ for i in nums)\n    sortperm(nums, by=s)\nend", "    return sortperm(sum(digitize.(collect(nums))),\
    \ alg=RadixSort)\nend", "    inds = [i for i=1:length(nums)]\n    inds_order_by_points\
    \ = sortperm(sum.(digits.(nums)),inds)\n    return nums[inds_order_by_points]\n\
    end", "    return sort(nums, by=x->sum(digits(x)))\nend", "    # YOUR CODE HERE\n\
    end\n@testset \"order_by_points\" begin\n    @test order_by_points([1, 11, -1,\
    \ -11, -12]) == [-1, -11, 1, -12, 11]\n    @test order_by_points([0, -3, -2, 3,\
    \ 2]) == [-3, 3, -2, 2, 0]\n    @test order_by_points([]) == []\nend\n \n \n\"\
    \"\"\n    Create a function which returns a copy of given vector,\n    but with\
    \ duplicates removed (i.e. in order of their first occurrence).", "    if (length(nums)\
    \ == 0) \n        return nums\n    end\n    v = [reduce(+, digits(nums[i])) for\
    \ i in 1:length(nums)]\n    v, ind = sort(v, by=identity)\n    return nums[ind]\n\
    end", "    (sum(Int.(digits(n))) for n in nums) |> sort |> @assert length(nums)\
    \ == length\nend", "    return sortperm(nums)\nend", "    # Your code here\nend\n\
    \ \norder_by_points([1, 11, -1, -11, -12])\nassert(order_by_points([1, 11, -1,\
    \ -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points([]) == [])\nassert(order_by_points([-1,\
    \ -20, 12, -11, -2]) == [-1, -2, -11, 12, -20])\nassert(order_by_points([-4, 100,\
    \ -4, 100, -4, 100]) == [-4, -4, -4, 100, 100, 100])\nassert(order_by_points([0,\
    \ 0, 0, 0, 0]) == [0, 0, 0, 0, 0])", "    if length(nums) == 0\n        return\
    \ []\n    end\n    new_nums = []\n    for i in 1:length(nums)\n        digits\
    \ = digits(nums[i])\n        new_nums = [new_nums[:], nums[i], sum(digits)]\n\
    \    end\n    sort(reshape(new_nums, (:, 2)))\nend\n@test order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n@test order_by_points([]) == []\n\
    \ ", "    #sorted list of tuples : (index,sum_of_digits)\n    list_of_tuples =\
    \ sort(zip(1:length(nums),[sum(int(x) for x in digits(abs(n))) for n in nums]))\n\
    \    #return list of elems according to order of elements in the list_of_tuples\n\
    \    return [nums[idx] for (idx,sum) in list_of_tuples]\nend", "    function total_digit(num::Int64)::Int64\n\
    \        total = 0\n        while num >= 10\n            total += mod(num, 10)\n\
    \            num = floor(Int64, num / 10)\n        end\n        total += num\n\
    \        return total\n    end\n    ordered = sort(nums, by = total_digit)\n \
    \   return ordered\nend", "    return sorted(nums, by = (i->sum(digits(i))), rev\
    \ = false)\nend", "    \n    x = zeros(Int64,length(nums))\n    y = zeros(Int64,length(nums))\n\
    \    z = zeros(Int64,length(nums))\n    for i = 1:length(nums)\n        while\
    \ nums[i] != 0\n            x[i] += nums[i] % 10\n            nums[i] = floor(nums[i]\
    \ / 10)\n        end\n        y[i] = i\n    end\n    for i = 1:length(nums)\n\
    \        for j = 1:length(nums)\n            if y[i] < y[j]\n                if\
    \ x[i] < x[j]\n                    swap!(x[i],x[j])\n                    swap!(y[i],y[j])\n\
    \                    swap!(nums[i],nums[j])\n                end\n           \
    \ end\n        end\n    end\n    return nums\nend", "    idx = sortperm(sum.(digits.(nums)))\n\
    \    return nums[idx]\nend", "    sorted_nums = sort(nums, by = function (x) \n\
    \        x = abs(x)\n        s = 0\n        while x > 0\n            s += x %\
    \ 10\n            x = div(x, 10)\n        end\n        return s\n    end)\n  \
    \  return sorted_nums\nend", "    return sort(nums, by = i -> sum(digits(i)))\n\
    end", "    # IMPLEMENT ME\nend", "    sort(nums, by=s->s != 0 ? (abs(s) - s) %\
    \ 10 + s % 10 : 0)\nend", "    sum_digits = Dict{Int64, Int64}()\n    for (i,\
    \ num) in enumerate(nums)\n        s = 0\n        for digit in string(num)\n \
    \           s += parse(Int64, digit)\n        end\n        if haskey(sum_digits,\
    \ s)\n            sum_digits[s] = [sum_digits[s], i]\n        else\n         \
    \   sum_digits[s] = i\n        end\n    end\n    ord = sortperm(collect(keys(sum_digits)))\n\
    \    ind = map(i -> sum_digits[i], ord)\n    new_ind = []\n    for inds in ind\n\
    \        if inds isa(Array)\n            push!(new_ind, inds)\n        else\n\
    \            push!(new_ind, [inds])\n        end\n    end\n    new_ind = reduce(vcat,\
    \ new_ind)\n    return nums[new_ind]\nend\nprintln(order_by_points([1, 11, -1,\
    \ -11, -12]))\nprintln(order_by_points([]))", "    newnums = sort(zip(nums, sum.(abs.(nums))),\
    \ by = x -> x[2])\n    return [item[1] for item in newnums]\nend", "    newvec\
    \ = zeros(length(nums))\n    for i in 1:length(nums)\n        r = nums[i]\n  \
    \      sum = 0\n        while r > 0\n            sum += r % 10\n            r\
    \ = div(r, 10)\n        end\n        newvec[i] = sum\n    end\n    out = sortperm(newvec)\n\
    \    return nums[out]\nend", "    # YOUR CODE HERE\n    error(\"Not implemented\
    \ yet\")\nend\n \n \n ", "    \"\"\"\n    Function that sorts the given vector\
    \ of integers\n    in ascending order according to the sum of their digits.\n\
    \    \"\"\"\n    return sort!(nums, by=x->sum_of_digits(x))\nend", "  return sort(nums,\
    \ by=sum)\nend\n@testset \"Testing order_by_points\" begin\n    @test order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    @test order_by_points([]) ==\
    \ []\nend\n \n \n\"\"\"\n    Write a function that sorts the given vector of integers\n\
    \    in ascending order according to the sum of their digits.\n    If there are\
    \ several items with similar sum of their digits,\n    order them based on their\
    \ absolute value.", "    return sort(nums, by=n -> (n, sum(digits(n))))\nend",
  "    sum_nums = [sum(digits(item)) for item in nums]\n    return nums[sortperm(sum_nums)]\n\
    end", "    sums = [sum(digits(n)) for n in nums]\n    return nums[sortperm(sums)]\n\
    end", "    vals = [sum(digits(x)) for x in nums]\n    vals, ind = sortperm(vals)\n\
    \    nums[ind]\nend", "    nums_with_index = collect(enumerate(nums))\n    nums_with_index\
    \ = sort(nums_with_index, by=x->sum(digits(x[2])))\n    return [x[2] for x in\
    \ nums_with_index]\nend\n \n \n \n\"\"\"\n    Write a function which checks if\
    \ the given two numbers\n    have the same first digit (of their exponent notation).\n\
    \    For example:\n    >>> same_first_digit(1, 1)\n    True\n    >>> same_first_digit(1,\
    \ 2)\n    False\n    >>> same_first_digit(1, 2)\n    False\n    >>> same_first_digit(0.1,\
    \ 10)\n    True\n    >>> same_first_digit(0.1, 100)\n    False\n    >>> same_first_digit(0.1,\
    \ 1)\n    False\n    >>> same_first_digit(0.01, 100)\n    True\n    >>> same_first_digit(0.01,\
    \ 101)\n    False\n    >>> same_first_digit(0.01, 0.1)\n    False\n    >>> same_first_digit(0.01,\
    \ 1)\n    False\n    >>> same_first_digit(100, 0.01)\n    True\n    >>> same_first_digit(100,\
    \ 0.0001)\n    False\n    >>> same_first_digit(100, 0.001)\n    False\n    >>>\
    \ same_first_digit(100, 100)\n    True\n    >>> same_first_digit(100, 101)\n \
    \   False\n    >>> same_first_digit(1, 1)\n    True\n    >>> same_first_digit(1,\
    \ 2)\n    False\n    >>> same_first_digit(1, 2)\n    False\n    >>> same_first_digit(10,\
    \ 1)\n    True\n    >>> same_first_digit(10, 2)\n    False\n    >>> same_first_digit(10,\
    \ 2)\n    False\n    >>> same_first_digit(100, 1)\n    True\n    >>> same_first_digit(100,\
    \ 2)\n    False\n    >>> same_first_digit(100, 2)\n", "    if length(nums) ==\
    \ 0\n        return nums\n    end\n    sums = zeros(Int64, length(nums))\n   \
    \ for i in 1:length(nums)\n        num = nums[i]\n        num = abs(num)\n   \
    \     while num >= 10\n            sums[i] += num % 10\n            num = num\
    \ / 10\n        end\n        sums[i] += num\n    end\n    sortind = sortperm(sums)\n\
    \    return nums[sortind]\nend", "    bucket_points = []\n    for i in nums\n\
    \        points = sum(digits(i))\n        push!(bucket_points, (i, points))\n\
    \    end\n    sort!(bucket_points, by = x -> x[2])\n    return [x[1] for x in\
    \ bucket_points]\nend", "    return sort(nums, by = (x -> sum(digits(x))))\nend",
  "    num_tuples = [(x, sum(digits(x))) for x in nums]\n    sort!(num_tuples, by=x->x[2])\n\
    \    return [x[1] for x in num_tuples]\nend", "    if isempty(nums)\n        return\
    \ Int64[]\n    end\n    sum_nums = [sum(digits(i)) for i in nums]\n    sorted_index\
    \ = sortperm(sum_nums)\n    return nums[sorted_index]\nend", "    v = [sum(map(Int64,\
    \ digits(x))) for x in nums]\n    for i = 1:length(nums)\n        m = i\n    \
    \    for j = i+1:length(nums)\n            if v[j] < v[m] || (v[j] == v[m] &&\
    \ nums[j] < nums[m])\n                m = j\n            end\n        end\n  \
    \      (v[i], v[m]) = (v[m], v[i])\n        (nums[i], nums[m]) = (nums[m], nums[i])\n\
    \    end\n    return nums\nend", "    n = length(nums)\n    if n == 0\n      \
    \  return nums\n    end\n    sorted!(nums, by=item->(item,sum(digits(item)),findfirst(nums,\
    \ item)))\n    return nums\nend", "    nums_aux = [sum(digits(nums[i])) for i\
    \ = 1:length(nums)]\n    sortperm(nums_aux, rev=true)\nend", "    if length(nums)\
    \ == 0\n        return nums\n    end\n    Nums = Array{Int64,2}(undef,length(nums),2)\n\
    \    for i in 1:length(nums)\n        Nums[i,1] = sum_digits(nums[i])\n      \
    \  Nums[i,2] = i\n    end\n    ans = sortrows(Nums, by = x -> x[1])\n    ans =\
    \ ans[:,2]\n    return nums[Int64.(ans)]\nend", "    sort(nums, by=x->(sum(digits(x))==sum(digits(y))\
    \ ? x : sum(digits(x))))\nend", "    return sortperm(digits(nums), sum)\nend",
  "    # TODO: function body\nend", "    if isempty(nums)\n        return nums\n \
    \   end\n    tuples = [(sum(digits(nums[i])), i, nums[i]) for i in 1:length(nums)]\n\
    \    sort!(tuples, by = x -> x[1])\n    return [tuples[i][3] for i in 1:length(tuples)]\n\
    end", "    function sum_digits(n::Int64)::Int64\n        if n == 0\n         \
    \   return 0\n        else\n            return (n % 10) + sum_digits(div(n, 10))\n\
    \        end\n    end\n    return sort(nums, by=sum_digits)\nend", "    sums =\
    \ []\n    index = []\n    for (i,num) in enumerate(nums)\n        temp = map(x->parse(Int64,x),split(string(num),\"\
    \"))\n        push!(sums,sum(temp))\n        push!(index,i)\n    end\n    sorted\
    \ = argsort(sums)\n    out = []\n    for i in sorted\n        push!(out,nums[index[i]])\n\
    \    end\n    return out\nend\norder_by_points([1, 11, -1, -11, -12])", "    #\
    \ TODO: write your code here\n    return nums\nend\n ", "    points = []\n   \
    \ for num in nums\n        push!(points, num)\n    end\n    sort!(points, by =\
    \ sum_digits)\n    return points\nend", "    return sortperm(digitsum.(nums))\n\
    end", "    #sort by its sum of digits\n    sorted_nums = sort(nums, by=x->sum(digits(x)));\n\
    \    # sort by index\n    indexed_nums = [(i, sorted_nums[i]) for i in 1:length(sorted_nums)];\n\
    \    sorted_indexed_nums = sort(indexed_nums, by=x->x[1]);\n    # get rid of index\n\
    \    sorted_nums = [x[2] for x in sorted_indexed_nums];\n    return sorted_nums\n\
    end", "    total = [sum([convert(Int64,digit) for digit in string(i)]) for i in\
    \ nums]\n    sortperm(total,nums)\nend", "    S = [sum(digits(n)) for n in nums]\n\
    \    return nums[sortperm(S)]\nend", "    sums = [sum(digits(i)) for i in nums]\n\
    \    idx_sort = sortperm(sums)\n    return nums[idx_sort]\nend", "    # if no\
    \ element in the vector\n    if (length(nums) == 0)\n        return nums\n   \
    \ end\n    # iterate through vector and calculate the sum of digits in each element\n\
    \    sums = zeros(Int64, length(nums))\n    for i in 1:length(nums)\n        num\
    \ = abs(nums[i])\n        while num > 0\n            sums[i] += num % 10\n   \
    \         num = num \xF7 10\n        end\n    end\n    # get the indices\n   \
    \ indices = sortperm(sums)\n    return nums[indices]\nend", "    sort(nums, by=sum)\n\
    end", "    # vector of pair (n, sum_of_digits)\n    new_nums = []\n    for i in\
    \ 1:length(nums)\n        digit_sum = 0\n        num = nums[i]\n        while\
    \ num != 0\n            digit_sum += num % 10\n            num = div(num, 10)\n\
    \        end\n        push!(new_nums, (nums[i], digit_sum))\n    end\n    new_nums\
    \ = sort(new_nums, by = x -> x[2])\n    ordered_nums = []\n    for i in 1:length(new_nums)\n\
    \        push!(ordered_nums, new_nums[i][1])\n    end\n    return ordered_nums\n\
    end\n# order_by_points([1, 11, -1, -11, -12])\n# order_by_points([])", '    #implementation
    goes here', "    indices = collect(1:length(nums))\n    custom_type = zip(nums,\
    \ indices)\n    sorted_type = sort(custom_type, by = x -> begin\n        x[1]\
    \ = abs(x[1])\n        result = 0\n        while x[1] > 0\n            result\
    \ += x[1] % 10\n            x[1] = div(x[1], 10)\n        end\n        result\
    \ = (result, x[2])\n    end)\n    return [x[1] for x in sorted_type]\nend", " \
    \   \n    points = [sum(digits(num)) for num in nums]\n    sorted = sortperm(points)\n\
    \    return nums[sorted]\nend", "    results = sort(nums, by=digit_sum)\n    return\
    \ results\nend", "    res = sort(nums,by=x->(x<0 ? -sum(digits(abs(x))) : sum(digits(x))),rev=true)\n\
    \    reverse!(res)\n    return res\nend", "    return sortperm(sum(digits(nums)))\n\
    end", "    # Find the sum of the digits in each number\n    sums = [(sum(digits(num)),\
    \ num) for num in nums]\n    # Sort the numbers by the sum of their digits\n \
    \   ordered = sort(sums, by = x -> x[1])\n    # Return the list of ordered numbers\n\
    \    ordered_nums = [ordered[num][2] for num in 1:length(ordered)]\n    return\
    \ ordered_nums\nend", "    # helper function\n    function sum_of_digits(n::Int64)::Int64\n\
    \        # check special case first\n        if n == 0\n            return 0\n\
    \        end\n        # initialize a sum\n        sum = 0\n        # if the number\
    \ is negative, we multiply it by -1 to avoid bugs.\n        if n < 0\n       \
    \     n = n * -1\n        end\n        # while the number is bigger than 0\n \
    \       while n > 0\n            # add the remainder of n % 10 to the sum\n  \
    \          sum += n % 10\n            # floor divide the number by 10 to get rid\
    \ of the last digit and continue\n            n = n\xF710\n        end\n     \
    \   # return the sum of the digits\n        return sum\n    end\n    # initialize\
    \ a dictionary with the keys being the sum of the digits and the values being\
    \ the number.\n    nums_dict = Dict()\n    # loop through each number in the vector\n\
    \    for n in nums\n        # calculate the sum of the digits and set that as\
    \ the key to the dictionary.\n        key = sum_of_digits(n)\n        # check\
    \ if the key is in the dictionary.\n        if haskey(nums_dict, key)\n      \
    \      # if it is, then we push the value to the array for that key.\n       \
    \     push!(nums_dict[key], n)\n        else\n            # if it is not, then\
    \ we make a new key value pair.\n            nums_dict[key] = [n]\n        end\n\
    \    end\n    # initialize a new array for the new integers\n    ordered_ints\
    \ = []\n    # we loop through the dictionary\n    for (key, value) in nums_dict\n\
    \        # loop through each item in the value\n        for item in value\n  \
    \          # push it to the new array.\n            push!(ordered_ints, item)\n\
    \        end\n    end\n    # return the new array\n    return ordered_ints\nend",
  "    return sortperm(sum.(collect(digits.(nums))) .+ length(nums)::Vector{Int64},\
    \ rev=true)\nend\n ", "    @assert length(nums) >= 0\n    return sortperm(sum.(Int64.(string.(nums))),nums)\n\
    end", "    tmp = []\n    for i in nums\n        push!(tmp, sum(digits(i)))\n \
    \   end\n    ind = sortperm(tmp)\n    return nums[ind]\nend", "    tmp1 = [sum(digits(nums[i]))\
    \ for i in eachindex(nums)]\n    tmp2 = sortperm(tmp1)\n    [nums[i] for i in\
    \ tmp2]\nend", "    sorted = sort(nums, by=x->sum(digits(x)))\n    return sorted\n\
    end", "    # TODO: implement me\n    return nums\nend", "    if nums == []\n \
    \       return []\n    end\n    n = length(nums)\n    points = zeros(n)\n    for\
    \ i in 1:n\n        for j in 1:length(num2digits(nums[i]))\n            points[i]\
    \ += num2digits(nums[i])[j]\n        end\n    end\n    sortindex = sortperm(points)\n\
    \    nums_sorted = zeros(n)\n    for i in 1:n\n        nums_sorted[i] = nums[sortindex[i]]\n\
    \    end\n    return nums_sorted\nend", "    sums = Vector{Int64}(undef, length(nums))\n\
    \    for i in 1:length(nums)\n        digits = get_digits(nums[i])\n        sums[i]\
    \ = sum(digits)\n    end\n    order = argsort(sums)\n    return nums[order]\n\
    end", "    if length(nums) == 0\n        return nums\n    end\n    ## Your code\
    \ is here\nend", "    sort(nums, by=sum)\nend", "    return sortperm(sum.(digits.(nums))\
    \ .+ length(nums)::Vector{Int64})\nend", "    # This solution cannot handle vectors\
    \ of more than 10 elements!\n    points = Int64[]\n    for i = 1:length(nums)\n\
    \        points = [points; sum(digits(nums[i]))]\n    end\n    tuple_arr = [(nums[i],\
    \ points[i]) for i = 1:length(nums)]\n    sorted_tuples = sort(tuple_arr, by =\
    \ x -> x[2])\n    new_vector = Int64[]\n    for i = 1:length(nums)\n        new_vector\
    \ = [new_vector; sorted_tuples[i][1]]\n    end\n    return new_vector\nend", " \
    \   indices = sortperm(sum.(digits.(nums)))\n    return nums[indices]\nend", " \
    \   sums = map(sum, [digits(i) for i in nums])\n    sorted = zeros(Int64, size(nums,\
    \ 1))\n    for i in 1:size(nums, 1)\n        if sums[i] == maximum(sums)\n   \
    \         sums[i] = minimum(sums) - 1\n        end\n    end\n    for i in 1:size(nums,\
    \ 1)\n        sorted[i] = nums[findfirst(sums, minimum(sums))]\n        sums[findfirst(sums,\
    \ minimum(sums))] = maximum(sums)\n    end\n    return sorted\nend\n    \n   \
    \ \n    ", "    sorted(zip(nums, [sum(digits(abs(n))) for n in nums]), by=x->x[2])\
    \ |>\n    x->collect(map(t->t[1], x))\nend", "    n = length(nums)\n    indices\
    \ = collect(1:n)\n    sortsum = zeros(n)\n    for i in 1:n\n        tempsum =\
    \ 0\n        while nums[i] != 0\n            tempsum += nums[i] % 10\n       \
    \     nums[i] = nums[i] / 10\n        end\n        sortsum[i] = tempsum\n    end\n\
    \    return [nums[i] for i in sortperm(sortsum, indices)]\nend", "    nums[sortperm(reduce(+,\
    \ digits.(nums)))]\nend", "  return sort(nums, by = x -> (sum(digits(x)), x))\n\
    end", "    return sort(nums, by = sum_of_digits)\nend", "    if isempty(nums)\n\
    \        return []\n    end\n    vec_of_points = [(n, i) for (i, n) in enumerate(nums)]\n\
    \    sort!(vec_of_points, by = x -> (sum(digits(x[1])), x[2]))\n    vec_of_points\
    \ = [x[1] for x in vec_of_points]\n    return vec_of_points\nend", "    a = sortperm(sum.(map(x\
    \ -> digits(x), nums)), rev=true)\n    return nums[a]\nend\nnums = [-1, -11, 1,\
    \ -12, 11]\norder_by_points(nums)", "    function sum_digits(n::Int64)::Int64\n\
    \        @inbounds sum = 0\n        while n != 0\n            sum += n % 10\n\
    \            n   /= 10\n        end\n        return sum\n    end\n    # extract\
    \ pairs of sum of digits and original index\n    sums_ixs = [sum_digits(num) for\
    \ num in nums]\n    sums_ixs = [(sums_ixs[ix], ix) for ix in eachindex(sums_ixs)]\n\
    \    # sort by sum of digits\n    sorted = sort(sums_ixs, by=x->x[1])\n    # extract\
    \ result\n    ordered = [nums[ix] for (_, ix) in sorted]\n    return ordered\n\
    end", "    if length(nums)==0\n        return []\n    end\n    points = Dict{Int64,\
    \ Vector{Int64}}()\n    for i in 1:length(nums)\n        x = nums[i]\n       \
    \ if x<0\n            x *= -1\n        end\n        dig = 0\n        while x>0\n\
    \            dig += rem(x, 10)\n            x = floor(x/10)\n        end\n   \
    \     if haskey(points, dig)\n            push!(points[dig], nums[i])\n      \
    \  else\n            points[dig] = [nums[i]]\n        end\n    end\n    ordered\
    \ = []\n    for i in sort(collect(keys(points)))\n        ordered = [ordered...,\
    \ points[i]]\n    end\n    return ordered\nend", "    # find the sum of the digits\
    \ in nums\n    # and store them together with index in a vector of tuples\n  \
    \  # sort vector of tuples based on sum of digits\n    # sort again based on index\n\
    \    # return vector of nums with sorted indices\n    \n    sums = Vector{Int64}(undef,\
    \ length(nums))\n    indices = Vector{Int64}(undef, length(nums))\n    for i =\
    \ 1:length(nums)\n        indices[i] = i\n        sums[i] = sum(digits(nums[i]))\n\
    \    end\n    sorted_indices = sortperm(sums)\n    new_indices = sortperm(indices[sorted_indices])\n\
    \    nums[sorted_indices[new_indices]]\nend", "    # your code here!\nend\n\"\"\
    \"\n    Write a function which takes a vector of integers and returns a map\n\
    \    where keys are integers from that vector and the value associated to\n  \
    \  each key is the sum of all integers from given vector that are greater\n  \
    \  than the key.", "    # nums should be a Vector{Int64}\n    sorted = sort(nums,\
    \ by=x->(sum(digits(x)) + \n                                1000*findfirst(nums,x)))\n\
    \    return sorted\nend", "    order = sortperm(sum.(num -> digits(num), nums))\n\
    \    return nums[order]\nend", "    a = [(digit_sum(nums[i]), i) for i in 1:length(nums)]\n\
    \    s = sort(a, by = x -> x[1])\n    return [nums[s[i][2]] for i in 1:length(s)]\n\
    end", "    return sortperm(collect(sum(digits(x)) for x in nums), rev=true)\n\
    end", "    return sortperm(sum.(Int64.(split(string(nums), \"\")), 2)) \nend",
  "    sorted_nums = sort(nums, by = x -> sum(digits(x)))\n    return sorted_nums\n\
    end", "    if nums == []\n        return []\n    end\n    idx = sortperm(sum.(digits.(nums)))\n\
    \    return nums[idx]\nend", "    return sortperm(digit_sum.(nums), by=nums)\n\
    end", "    newArray = sort(1:length(nums), by = x -> sum(digits(nums[x])))\n \
    \   return nums[newArray]\nend", "    # check if input is empty\n    if length(nums)\
    \ == 0\n        return nums\n    end\n    \n    if length(nums) == 1\n       \
    \ return nums\n    end\n    \n    # sort based on the sum of digits\n    sort(nums,\
    \ by=x->sum(digits(x)))\nend", "    # convert each number to a tuple of (sum of\
    \ digits, number)\n    digited = [(sum(digits(num)), num) for num in nums]\n \
    \   # sort the tuples\n    sort!(digited)\n    # return the sorted vector of digits\n\
    \    return [tuple[2] for tuple in digited]\nend", "    sorted = sort(nums, by=sum)\n\
    \    return sorted\nend", "    return sort(nums, by=digit_sum)\nend", "    len_vec\
    \ = length(nums)\n    indexes = []\n    for i in 1:len_vec\n        push!(indexes,i)\n\
    \    end\n    sort_indexes = sortperm(nums, by = index -> sum(digits(index)))\n\
    \    out = []\n    for i in sort_indexes\n        push!(out,nums[i])\n    end\n\
    \    return out\nend", "    if isempty(nums)\n        return []\n    end\n   \
    \ for i in 2:length(nums)\n        key = nums[i]\n        j = i - 1\n        while\
    \ j >= 1 && order_by_points_helper(nums[j]) > order_by_points_helper(key)\n  \
    \          nums[j + 1] = nums[j]\n            j -= 1\n        end\n        nums[j\
    \ + 1] = key\n    end\n    return nums\nend", "    if length(nums) == 0\n    \
    \    return nums\n    end\n    idx = sortperm(collect(zip(nums, map(sum, map(digits,\
    \ nums)))))\n    return nums[idx]\nend\norder_by_points([1, 11, -1, -11, -12])",
  "    \"\"\"\n    Use the function to find the median of the given vector of integers.\n\
    \    \"\"\"\n    # write your code here\nend", "    sum_nums = Dict()\n    key\
    \ = 1\n    for num in nums\n        sum_nums[key] = sum(digits(num))\n       \
    \ key += 1\n    end\n    ordered_nums = sort(collect(sum_nums), by=x->x[2])\n\
    \    result = zeros(length(nums))\n    for i in 1:length(ordered_nums)\n     \
    \   result[i] = nums[ordered_nums[i][1]]\n    end\n    return result\nend", " \
    \   nsums = sum.(nums)\n    index = sortperm(nsums)\n    newindex = sortperm(index)\n\
    \    newindex2 = sortperm(newindex)\n    return nums[newindex2]\nend", "    for\
    \ i = 2:length(nums) \n        j = i\n        while j > 1 && sum(digits(nums[j]))\
    \ < sum(digits(nums[j-1]))\n            nums[j], nums[j-1] = nums[j-1], nums[j]\n\
    \            j -= 1\n        end\n    end\n    return nums\nend", "    n = length(nums)\n\
    \    indices = collect(1:n)\n    indices = sort(indices, by=x->sum(digits(nums[x])))\n\
    \    return [nums[x] for x in indices]\nend", "    indices = map(i -> (i, sum(digits(i))),\
    \ 1:length(nums))\n    order(indices, by=x -> x[2])\n    reorder(nums, order(indices,\
    \ by=x -> x[2]))\nend", "    return sort(nums, by=x->(x<0 ? -1 : 1)*(sum(digits(abs(x)))))\n\
    end", "    sum_nums = [sum(digits(n)) for n in nums]\n    index = sortperm(sum_nums)\n\
    \    return nums[index]\nend", "    return sortperm(sum.(digits.(nums), dims=1),\
    \ rev=true)\nend", "    # we can not sort two vectors at the same time,\n    #\
    \ so calculate the sum of digits in every item and store in another vector,\n\
    \    # sort the new vector and then return the original vector\n    sums = [0]\n\
    \    for x in nums\n        # we use a simple helper function to compute the sum\
    \ of digits in the \n        # given integer\n        push!(sums, sum_of_digits(x))\n\
    \    end\n    # we sort the 'sums' vector and store the indices in an array\n\
    \    # then we use these indices to sort the original vector\n    indices = sortperm(sums)\n\
    \    res = []\n    for i in indices\n        push!(res, nums[i])\n    end\n  \
    \  return res\nend", "    s = collect(1:length(nums))\n    v = collect(1:length(nums))\n\
    \    j = 0\n    while j < length(nums)\n        j += 1\n        minval = nums[s[j]]\n\
    \        minind = j\n        i = j + 1\n        while i <= length(nums)\n    \
    \        if nums[s[i]] < minval\n                minval = nums[s[i]]\n       \
    \         minind = i\n            end\n            i += 1\n        end\n     \
    \   temp = s[j]\n        s[j] = s[minind]\n        s[minind] = temp\n    end\n\
    \    for i = 1:length(s)\n        v[i] = nums[s[i]]\n    end\n    return v\nend",
  "    lens = map(x -> length(digits(x)), nums)\n    sums = map(x -> sum(digits(x)),\
    \ nums)\n    sums_array = (sums, 1:length(sums))\n    sort!(sums_array, by = x\
    \ -> (x[1], x[2]))\n    return sortperm(nums, by = x -> (sums_array[1][x], sums_array[2][x]))\n\
    end\norder_by_points([1, 11, -1, -11, -12])", "    \n    # your code here\n  \
    \  \nend", "    n = size(nums, 1)\n    lens = zeros(Int64, n)\n    for i in 1:n\n\
    \        lens[i] = sum_digits(nums[i])\n    end\n    return sortperm(lens)\nend",
  "    vals = sort(nums)\n    for i in 1:length(vals)\n        sum=0\n        p=i\n\
    \        temp=vals[i]\n        while temp != 0\n            sum += mod(temp,10)\n\
    \            temp = div(temp,10)\n        end\n        for j in i+1:length(vals)\n\
    \            sum2=0\n            temp2=vals[j]\n            while temp2 != 0\n\
    \                sum2 += mod(temp2,10)\n                temp2 = div(temp2,10)\n\
    \            end\n            if sum2 < sum\n                p=j\n           \
    \     sum=sum2\n            end\n        end\n        vals[i],vals[p]=vals[p],vals[i]\n\
    \    end\n    return vals\nend", "    if length(nums) == 0\n        return nums\n\
    \    end\n    lens = length(nums)\n    points = zeros(Int64, lens)\n    for i\
    \ in 1:lens\n        point = 0\n        temp = abs(nums[i])\n        while temp\
    \ != 0\n            point += temp % 10\n            temp = div(temp, 10)\n   \
    \     end\n        points[i] = point\n    end\n    order = sortperm(points)\n\
    \    new_nums = zeros(Int64, lens)\n    for i in 1:lens\n        new_nums[i] =\
    \ nums[order[i]]\n    end\n    return new_nums\nend", "    if isempty(nums)\n\
    \        return nums\n    end\n    points = [sum(digits(abs(num))) for num in\
    \ nums]\n    idx = sortperm(points)\n    return nums[idx]\nend", "    if isempty(nums)\n\
    \        return []\n    end\n    index_values = sortperm(sum(digits.(nums)))\n\
    \    # return each value of nums based on its sorted index_values\n    return\
    \ nums[index_values]\nend", "    # sort by sum of digits in descending order,\
    \ then by index in ascending order\n    I = sortperm(nums, rev=true, by=x->(sum(digits(x)),\
    \ x))\n    return nums[I]\nend", "    sort(nums, by=x->(sum(digits(x)), x))\n\
    end", "    return sort(nums, by = x -> sum(digits(x)))\nend", "    if nums ==\
    \ []\n        return []\n    end\n    sums = []\n    for i in nums\n        sum\
    \ = 0\n        for j in digits(i)\n            sum += j\n        end\n       \
    \ push!(sums, sum)\n    end\n    return nums[sortperm(sums)]\nend", "    if nums\
    \ == []\n        return []\n    end\n    order = []\n    for (i, num) in enumerate(nums)\n\
    \        push!(order, (sum(digits(num)), i, num))\n    end\n    sort!(order)\n\
    \    return [x[3] for x in order]\nend", "    return sortperm(sum.(digit.(nums)),\
    \ rev=true)\nend", "    return sort(zip(nums, [sum(digits(i)) for i in nums]),\
    \ by=x->x[2])[:,1]\nend", "    if !isempty(nums)\n        v = sum_digits(nums)\n\
    \        order(v)\n    else \n        return nums\n    end\nend", "    digitsum_order\
    \ = sortperm(digit_sum.(nums))\n    return nums[digitsum_order]\nend", "    if\
    \ length(nums) == 0 \n        return nums\n    end \n    return sort(nums, by\
    \ = x -> sum(digits(x)))\nend", "    t = [sum(digits(i)) for i in nums]\n    t\
    \ = [i[1] for i in sort(zip(t,nums), rev=true)]\n    return t\nend\n# Tests",
  "    res = nums\n    lenght_nums = length(nums)\n    for i = 1:lenght_nums-1\n \
    \       for j = i+1:lenght_nums\n            if sum_of_digits(nums[i]) > sum_of_digits(nums[j])\n\
    \                res[i], res[j] = res[j], res[i]\n            end\n        end\n\
    \    end\n    return res\nend", "    order = sort(1:length(nums), by=x->sum(digits(nums[x])))\n\
    \    new_nums = zeros(Int64, length(nums))\n    for i in 1:length(nums)\n    \
    \    new_nums[i] = nums[order[i]]\n    end\n    return new_nums\nend", "    return\
    \ sort(nums, by = sum)\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
