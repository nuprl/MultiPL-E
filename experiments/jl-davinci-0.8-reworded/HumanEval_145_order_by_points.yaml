name: HumanEval_145_order_by_points
language: jl
prompt: "\"\"\"\n    Write a function which sorts the given vector of integers\n \
  \   in ascending order according to the sum of their digits.\n    Note: if there\
  \ are several items with similar sum of their digits,\n    order them based on their\
  \ index in original vector.\n\n    For example:\n    >>> order_by_points([1, 11,\
  \ -1, -11, -12])\n    [-1, -11, 1, -12, 11]\n    >>> order_by_points([])\n    []\n\
  \    \"\"\"\nfunction order_by_points(nums::Vector{Int64})::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = order_by_points;\n\t@test(candidate([1,\
  \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\t@test(candidate([1234, 423, 463,\
  \ 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423,\
  \ 423, 1234, 145, 37, 46, 56, 463, 3457])\n\t@test(candidate(Vector{Int64}([]))\
  \ == Vector{Int64}([]))\n\t@test(candidate([1, -11, -32, 43, 54, -98, 2, -3]) ==\
  \ [-3, -32, -98, -11, 1, 2, 43, 54])\n\t@test(candidate([1, 2, 3, 4, 5, 6, 7, 8,\
  \ 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\t@test(candidate([0, 6,\
  \ 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\nend\n"
completions: ["    sums = map(a -> sum(digits(a)), nums)\n    argsort(sums)\nend",
  "    return sortperm(sum.(nums), 1:length(nums))\nend", "    nums = sort(nums, lt\
    \ = x->sum(digits(x)) < sum(digits(y)), rev = false)\n    return nums\nend\norder_by_points([1,\
    \ 11, -1, -11, -12])", " \n    # sum all the numbers in the vector\n    if length(nums)\
    \ == 0\n        return nums\n    end\n    n = length(nums)\n    sums = zeros(n)\n\
    \    for i in 1:n\n        sums[i] = sum(digits(nums[i]))\n    end\n   \n    #\
    \ find the positions of the minimum value\n    # note there can be more than one\
    \ positions\n    minsum = minimum(sums)\n    minpos = find(sums .== minsum)\n\
    \   \n    # find all the values at the minimum positions\n    # in the original\
    \ vector\n    mins = nums[minpos]\n   \n    # find the positions of the minimum\
    \ value in the original vector\n    # using argmin() gives the first position\
    \ if there are several\n    # thus cannot use this\n    minposs = zeros(length(mins))\n\
    \    for i in 1:length(mins)\n        minposs[i] = findfirst(nums .== mins[i])\n\
    \    end\n    \n    # sort the positions in ascending order\n    sort!(minposs)\n\
    \    \n    # find the original position in the original vector\n    # and replace\
    \ the corresponding value in the new vector\n    # with the minimum values from\
    \ the original vector\n    newvec = nums\n    for i in 1:length(minposs)\n   \
    \     newvec[minposs[i]] = mins[i]\n    end\n   \n    # remove the minimum values\
    \ from the original vector\n    for i in 1:length(mins)\n        deleteat!(nums,\
    \ findfirst(nums .== mins[i]))\n    end\n   \n    # recursively keep finding the\
    \ new minimum values and\n    # append it to the vector in the same order until\
    \ the\n    # original vector is empty\n    return vcat(newvec, order_by_points(nums))\n\
    end", "    sums = Vector{Int64}(undef, length(nums))\n    for i = 1:length(nums)\n\
    \        sums[i] = sum(nums[i])\n    end\n    return nums[sortperm(sums)]\nend",
  "    lens = length(nums)\n    if lens == 0\n        return nums\n    end\n    sort(nums,\
    \ by=x-> sum(digits(x)))\nend", "    isempty(nums) && return []\n    sorted_index\
    \ = sortperm(sum.(digits.(nums)))\n    nums[sorted_index]\nend", "    nums_with_points\
    \ = [(n, sum(digits(n))) for n in nums]\n    nums_with_points = sort(nums_with_points,\
    \ by=x -> x[2])\n    return [p[1] for p in nums_with_points]\nend", "    digit_sums\
    \ = [sum(digits(n)) for n in nums]\n    return nums[sortperm(digit_sums)]\nend",
  "    \n    pts = []\n    for i in nums\n        pts = [pts; sum(digits(i))]\n  \
    \  end\n    \n    order = sortperm(pts)\n    return [nums[i] for i in order]\n\
    \    \nend", "    # Initialize a dictionary of sums\n    sums = Dict{Int64, Int64}()\n\
    \    # Get the sums of each number\n    # Store them in the dictionary\n    for\
    \ i in 1:length(nums)\n        key = sum(int2vec(nums[i]))\n        sums[key]\
    \ = nums[i]\n    end\n    # Sort the dictionary by keys\n    sorted_sums = sort(collect(sums))\n\
    \    # Get the sorted numbers\n    sorted_nums = [sorted_sums[i][2] for i in 1:length(sorted_sums)]\n\
    \    return sorted_nums\nend", "    return sortperm(sum(digits.(nums))[1], by=nums)\n\
    end", "    \n    sum_of_digits = map(s -> sum(digits(s)), nums)\n    index = sortperm(sum_of_digits)\n\
    \    sort(nums, alg=MergeSort, by=x->x[index])\nend", "    n = length(nums)\n\
    \    result = zeros(Int64, n)\n    arr_of_sum = zeros(Int64, n)\n    # get array\
    \ of sum of digits\n    for i in 1:n\n        num = nums[i]\n        abs_num =\
    \ abs(num)\n        sum_of_digit = 0\n        while abs_num != 0\n           \
    \ sum_of_digit += abs_num % 10\n            abs_num = abs_num // 10\n        end\n\
    \        arr_of_sum[i] = sum_of_digit\n    end\n    # sort array of sums\n   \
    \ sort!(arr_of_sum)\n    for i in 1:n\n        for j in 1:n\n            if arr_of_sum[i]\
    \ == nums[j]\n                result[i] = nums[j]\n                nums[j] = 0\n\
    \                break\n            end\n        end\n    end\n    return result\n\
    end", "    # sum the digits\n    digit_sum = [sum(digits(i)) for i in nums]\n\
    \    # return the indices of smallest sum to biggest sum\n    sortperm(digit_sum)\n\
    end", "    sorted = sort(nums, by=x->sum(digits(x)))\n    return sorted\nend",
  "    keys = []\n    for i in 1:length(nums)\n        key = 0\n        for j in digits(nums[i])\n\
    \            key += j\n        end\n        push!(keys, key)\n    end\n    sortperm(keys)\n\
    end", "    if nums == []\n        return []\n    end\n    indices_of_nums = Dict(key\
    \ => sum(digits(key)) for key in nums)\n    sorted_indices = sort(collect(keys(indices_of_nums)))\n\
    \    return sort(nums, by = i -> indices_of_nums[i])\nend", "    nums = sort(nums,\
    \ by=num -> sum(digits(num)))\n    return nums\nend", "    if length(nums) ==\
    \ 0\n        return []\n    end\n    points = zeros(Int64,length(nums))\n    for\
    \ i in range(1,length(nums))\n        points[i] = sumdigits(nums[i])\n    end\n\
    \    return sortperm(points)\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
