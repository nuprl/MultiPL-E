name: HumanEval_65_circular_shift
language: jl
prompt: "\"\"\"Circular shift the digits of the integer x, shift the digits right\
  \ by shift\n    and return the result as a string.\n    If shift > number of digits,\
  \ return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12,\
  \ 2)\n    \"12\"\n    \"\"\"\nfunction circular_shift(x::Int64, shift::Int64)::String\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = circular_shift;\n\t@test(candidate(100,\
  \ 2) == \"001\")\n\t@test(candidate(12, 2) == \"12\")\n\t@test(candidate(97, 8)\
  \ == \"79\")\n\t@test(candidate(12, 1) == \"21\")\n\t@test(candidate(11, 101) ==\
  \ \"11\")\nend\n"
completions: ["    x_str = string(x)\n    num_digits = length(x_str)\n    shift =\
    \ shift % num_digits\n    i = num_digits - shift\n    str_end = x_str[i:end]\n\
    \    str_begin = x_str[1:i]\n    return str_end * str_begin\nend", "    \n   \
    \ digits = num_digits(x)\n    if shift >= digits\n        return reverse(int_to_str(x))\n\
    \    end\n    \n    x_str = int_to_str(x)\n    x_str = x_str[shift+1:end] * x_str[1:shift]\n\
    \    return x_str\nend", "    shift = mod(shift, length(digits(x)))\n    s = string(x)\n\
    \    return s[end-shift+1:end] * s[1:end-shift]\nend", "    # Split the integer\
    \ into a vector of single digit strings\n    digits = split(x)\n    # Reverse\
    \ the digits\n    reverse!(digits)\n    # Replace the first n with last n, where\
    \ n = mod(shift, length(digits))\n    i = mod(shift, length(digits))\n    tmp\
    \ = copy(digits[1:i])\n    digits[1:i] = digits[end-i+1:end]\n    digits[end-i+1:end]\
    \ = tmp\n    # Reverse again and join\n    reverse!(digits)\n    return join(digits)\n\
    end;\n\"\"\"The length of a sequence. \n    >>> length(1:10)\n    10\n    \"\"\
    \"", "    x_str = string(x)\n    if length(x_str) < shift\n        shift = length(x_str)\n\
    \    end\n    z = zeros(Int64, 2)\n    for i = 1:length(x_str)\n        z[i] =\
    \ parse(Int64, x_str[i])\n    end\n    for i = 1:shift\n        z = pushfirst!(z,\
    \ last(z))\n        z = pop!(z)\n    end\n    z_str = \"\"\n    for i = 1:length(z)\n\
    \        z_str = z_str * string(z[i])\n    end\n    return z_str\nend", "    L\
    \ = number_of_digits(x)\n    if shift > L\n        return string(reverse(digits(x)))\n\
    \    end\n    return string(digits(x)[shift+1:L]..., digits(x)[1:shift]...)\n\
    end", "    x_str = string(x)\n    x_length = length(x_str)\n    if shift > x_length\n\
    \        return reverse(x_str)\n    else\n        return x_str[shift+1:x_length]\
    \ * x_str[1:shift]\n    end\nend\n\"\"\"Find the period of the decimal representation\
    \ of a/b.\"\"\"", "    #### TODO\n    #\n    return \"--\"\nend", "    digits\
    \ = string(x)\n    shift %= length(digits)\n    return string(digits[shift+1:end],\
    \ digits[1:shift])\nend", "    s = string(x)\n    l = length(s)\n    if shift\
    \ > l\n        return string(reverse(s))\n    else\n        return s[shift:l]\
    \ * s[1:shift-1]\n    end\nend", "    digits = digits(x)\n    if shift > length(digits)\n\
    \        return digits\n    end\n    shift_digits = digits[end-shift+1:end]\n\
    \    unshift_digits = digits[1:end-shift]\n    shift_digits * unshift_digits\n\
    end", "    digits = digits(x)\n    if shift > length(digits)\n        return string(reverse(digits))\n\
    \    end\n    # Circular shift\n    return string(digits[shift+1:end], digits[1:shift])\n\
    end", "    digits = div(x, 10)\n    remainder = mod(x, 10)\n    if digits != 0\n\
    \        return string(circular_shift(digits, shift), remainder)\n    else\n \
    \       return string(remainder)\n    end\nend", "    if shift == 0 \n       \
    \ return string(x)\n    end\n    # num_digits = int(log10(x)) + 1\n    # num_rotations\
    \ = shift % num_digits\n    # for i in 1:num_rotations\n    #     last_digit =\
    \ x % 10\n    #     x = div(x, 10)\n    #     x = 10^num_digits * last_digit +\
    \ x\n    # end\n    # return string(x)\n    \n    # more efficient solution\n\
    \    num_digits = int(log10(x)) + 1\n    if shift > num_digits\n        return\
    \ string(reverse(x))\n    end\n    num_rotations = shift % num_digits\n    first_part\
    \ = div(x, 10^num_rotations)\n    second_part = rem(x, 10^num_rotations)\n   \
    \ return string(second_part) * \"0\" * string(first_part)\n    \nend", "    if\
    \ shift > Int64(log10(x)):\n        return reverse(digits(x))\n    for i in 1:shift\n\
    \        x = 10*(x%10) + div(x,10)\n    end\n    return digits(x)\nend", "   \
    \ digits = string(x)\n    if shift > length(digits)\n        return reverse(digits)\n\
    \    else\n        return digits[shift:end] * digits[1:shift]\n    end\nend",
  "    s = string(x)\n    n = length(s)\n    c = shift % n\n    return string(s[c+1:n],\
    \ s[1:c])\nend", "    shift_string = string(x)\n    if shift >= ndigits(x) \n\
    \        return reverse(shift_string)\n    else \n        split_idx = length(shift_string)\
    \ - shift\n        return string(shift_string[split_idx+1:end], shift_string[1:split_idx])\n\
    \    end\nend", "    len = length(string(x))\n    if shift > len\n        return\
    \ string(reverse(string(x)))\n    else\n        for i in 1:shift\n           \
    \ x_str = string(x)\n            x_str = x_str[end:end] * x_str[1:end-1]\n   \
    \         x = parse(Int64, x_str)\n        end\n        return string(x)\n   \
    \ end\nend\n        \n\"\"\"String input is the number, shift is an integer, return\
    \ shifted number as string\n    >>> circular_shift_str(\"12\", 1)\n    \"21\"\n\
    \    >>> circular_shift_str(\"12\", 2)\n    \"12\"\n    \"\"\"", "    digits =\
    \ string(x)\n    num_digits = length(digits)\n    return digits[(num_digits -\
    \ shift + 1):num_digits] * digits[1:(num_digits - shift)]\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
