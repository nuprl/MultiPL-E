name: HumanEval_153_Strongest_Extension
language: jl
prompt: "\"\"\"You will be given the name of a class (a string) and a vector of extensions.\n\
  \    The extensions are to be used to load additional classes to the class. The\n\
  \    strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  \    letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n    in the extension's name, the strength is given by the fraction CAP - SM.\
  \ \n    You should find the strongest extension and return a string in this \n \
  \   format: ClassName.StrongestExtensionName.\n    If there are two or more extensions\
  \ with the same strength, you should\n    choose the one that comes first in the\
  \ vector.\n    For example, if you are given \"Slices\" as the class and a vector\
  \ of the\n    extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
  \    return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
  \ \n    (its strength is -1).\n    Example:\n    >>> Strongest_Extension(\"my_class\"\
  , [\"AA\", \"Be\", \"CC\"])\n    \"my_class.AA\"\n    \"\"\"\nfunction Strongest_Extension(class_name::String,\
  \ extensions::Vector{String})::String \n"
tests: "using Test\n\n@testset begin\n\ncandidate = Strongest_Extension;\n\t@test(candidate(\"\
  Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\n\t@test(candidate(\"\
  Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
  )\n\t@test(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
  , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\n\t@test(candidate(\"\
  K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\t@test(candidate(\"\
  __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\")\n\t@test(candidate(\"\
  YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
  YameRore.okIWILL123\")\n\t@test(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"\
  Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\n\t@test(candidate(\"_\", [\"Bb\", \"91245\"\
  ]) == \"_.Bb\")\n\t@test(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
  )\nend\n"
completions: ["  strengths = [(ext, count(isupper, ext) - count(islower, ext)) for\
    \ ext in extensions]\n  println(strengths)\n  return class_name * \".\" * maximum(strengths)[1]\n\
    end", "    strength_vec = []\n    for ext in extensions\n        strength_vec\
    \ = push!(strength_vec, Count_Strength(ext))\n    end\n    if length(strength_vec)\
    \ == 1\n        return class_name * \".\" * extensions[1]\n    else\n        index\
    \ = findmax(strength_vec)[2]\n        return class_name * \".\" * extensions[index]\n\
    \    end\nend", "    max_strength = 0\n    strongest_extension = \"\"\n    for\
    \ ext in extensions\n        strength = sum(isupper.(ext)) - sum(islower.(ext))\n\
    \        if strength > max_strength\n            max_strength = strength\n   \
    \         strongest_extension = ext\n        end\n    end\n    return \"$class_name.$strongest_extension\"\
    \nend", "    S = zeros(extensions)\n    for i in 1:length(extensions)\n      \
    \  for j in 1:length(extensions[i])\n            if isupper(extensions[i][j])\n\
    \                S[i] += 1\n            else\n                S[i] -= 1\n    \
    \        end\n        end\n    end\n    return class_name * \".\" * extensions[findmax(S)[2]]\n\
    end", "    strengths = 0\n    strongest_extension = \"\"\n    for extension in\
    \ extensions\n        capitals = sum(isupper.(extension))\n        small_letters\
    \ = sum(islower.(extension))\n        strength = capitals - small_letters\n  \
    \      if strength > strengths\n            strengths = strength\n           \
    \ strongest_extension = extension\n        end\n    end\n    return(class_name\
    \ * \".\" * strongest_extension)\nend", "    best_extension = \"\"\n    best_strength\
    \ = 0.0\n    for extension in extensions\n        strength = count_upper(extension)\
    \ - count_lower(extension)\n        if strength > best_strength\n            best_strength\
    \ = strength\n            best_extension = extension\n        end\n    end\n \
    \   return class_name * \".\" * best_extension\nend", "    # strongness of each\
    \ extension\n    strengths = map(extension -> count_upper(extension) - count_lower(extension),\
    \ extensions)\n    # index of strongest\n    strongest_idx = indmax(strengths)\n\
    \    return \"$class_name.$(extensions[strongest_idx])\"\nend", "    # YOUR CODE\
    \ HERE\nend", "    class_name = \".\"*class_name\n    strongest_ext = \"\"\n \
    \   max_strength = 0\n    for ext in extensions\n        strength = sum(string.isupper(ext))\
    \ - sum(string.islower(ext))\n        if strength > max_strength\n           \
    \ max_strength = strength\n            strongest_ext = ext\n        end\n    end\n\
    \    return class_name*\".\"*strongest_ext\nend", "    num_upper = x -> count(isupper,\
    \ x)\n    num_lower = x -> count(islower, x)\n    s_ext = x -> num_upper(x) -\
    \ num_lower(x)\n    curr_max = x -> (x[1], s_ext(x[1]))\n    strongest = foldl(curr_max,\
    \ (\"\", 0.0), extensions)\n    return class_name * \".\" * strongest[1]\nend\n\
    \ \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\"\"\"You will\
    \ be given a dictionary (hash) and a set of keys. The first value\n    in the\
    \ dictionary is the definition of the word. You should return the\n    definition\
    \ of the most words that appear in the set. If several definitions\n    appear\
    \ the same number of times then you should return the definition\n    that has\
    \ the most words.\n    For example, if you are given the dictionary\n    {\"function\"\
    : [\"A function is a relation or expression involving one or more variables\"\
    ,\n    \"A function is a named section of a program that performs a specific task\"\
    ],\n    \"name\": [\"A name is a noun, pronoun, or other language unit that signifies\
    \ a person or thing\",\n    \"A name is a word or term used for identification.\"\
    ]}\n    and the set [\"function\", \"name\", \"name\"] then you should return\n\
    \    \"A name is a noun, pronoun, or other language unit that signifies a person\
    \ or thing\"\n    since it appears in the set two times and it has the most words.\n\
    \    Example:\n    >>> Most_Common_Definition({\"A\": [\"a\", \"b\"], \"B\": [\"\
    a\"]}, [\"A\", \"B\"])\n    \"a\"\n    \"\"\"", "    # Your code here\nend", " \
    \   if length(extensions) == 0\n        return class_name\n    end\n    strength_vector\
    \ = zeros(Int64, length(extensions))\n    for i in 1:length(extensions)\n    \
    \    counter_upper = 0\n        counter_lower = 0\n        for j in 1:length(extensions[i])\n\
    \            if string(extensions[i][j]) == uppercase(string(extensions[i][j]))\n\
    \                counter_upper += 1\n            else\n                counter_lower\
    \ += 1\n            end\n        end\n        strength_vector[i] = round(Int64,\
    \ counter_upper - counter_lower)\n    end\n    return class_name * \".\" * extensions[findmax(strength_vector)[2]]\n\
    end\n# This cell will test your code.\n# You should not change anything below\
    \ this line.\n# Test Strongest_Extension\ntests = Test(\"Strongest_Extension\"\
    ,function=(Strongest_Extension, [\"class_name\",\"extensions\"]))\ntests.run()\n\
    \ ", "    idx_strongest_extension = index_of_the_strongest_extension(extensions)\n\
    \    return \"$class_name.$(extensions[idx_strongest_extension])\"\nend", "  \
    \  # your code here\nend\n@testset \"Strongest extension\" begin\n    @test Strongest_Extension(\"\
    Slices\", [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"]) == \"Slices.SErviNGSliCes\"\
    \n    @test Strongest_Extension(\"Sandwich\", [\"Paste\", \"Rice\", \"Cow\"])\
    \ == \"Sandwich.Rice\"\n    @test Strongest_Extension(\"Car\", [\"Lamborghini\"\
    , \"Tesla\", \"McLaren\"]) == \"Car.Lamborghini\"\n    @test Strongest_Extension(\"\
    Burger\", [\"Fries\", \"Drink\", \"Shake\"]) == \"Burger.Drink\"\n    @test Strongest_Extension(\"\
    Coffee\", [\"TEA\", \"LATTE\", \"cappuccino\"]) == \"Coffee.cappuccino\"\n   \
    \ @test Strongest_Extension(\"Milk\", [\"WATER\", \"DRINK\", \"SOY\"]) == \"Milk.WATER\"\
    \n    @test Strongest_Extension(\"Hamburger\", [\"Soda\", \"Salad\", \"Chips\"\
    ]) == \"Hamburger.Soda\"\n    @test Strongest_Extension(\"HotDog\", [\"BEER\"\
    , \"Chips\", \"Soda\"]) == \"HotDog.BEER\"\n    @test Strongest_Extension(\"drink\"\
    , [\"WATER\", \"JUICE\", \"coke\"]) == \"drink.WATER\"\n    @test Strongest_Extension(\"\
    Drink\", [\"BEER\", \"Coffee\", \"Soda\"]) == \"Drink.Coffee\"\n    @test Strongest_Extension(\"\
    Fruit\", [\"ORANGE\", \"Apple\", \"Avocado\"]) == \"Fruit.ORANGE\"\n    @test\
    \ Strongest_Extension(\"Cake\", [\"Cheese\", \"Cookie\", \"Soda\"]) == \"Cake.Cookie\"\
    \n    @test Strongest_Extension(\"Candy\", [\"Gummies\", \"Bar\", \"Cake\"]) ==\
    \ \"Candy.Gummies\"\n    @test Strongest_Extension(\"Bread\", [\"WHEAT\", \"Rye\"\
    , \"FREN", "    strength_extensions = [strength_extension(extension) for extension\
    \ in extensions]\n    strongest_extension = extensions[argmax(strength_extensions)]\n\
    \    return class_name * \".\" * strongest_extension\nend", "    sm = 0\n    cap\
    \ = 0\n    strength = 0\n    strongest_extension = \"\"\n    for e in extensions\n\
    \        cap = sum(isupper.(e))\n        sm = sum(islower.(e))\n        s = cap\
    \ - sm\n        if s >= strength\n            strength = s\n            strongest_extension\
    \ = e\n        end\n    end\n    return string(class_name, \".\", strongest_extension)\n\
    end", "    strength_data = []\n    for ext in extensions\n        uppercase_count\
    \ = sum(isuppercase.(ext))\n        lowercase_count = sum(islowercase.(ext))\n\
    \        push!(strength_data, (ext, uppercase_count - lowercase_count))\n    end\n\
    \    strength_data = sort(strength_data, by = x -> x[2])\n    return \"$class_name.$(strength_data[end][1])\"\
    \nend\n        \n ", "    # Write your code here\n    strength = 0\n    strength_key\
    \ = 0\n    for i in 1:length(extensions)\n        if count(extensions[i], \"A\"\
    ):!=0 || count(extensions[i], \"B\"):!=0 || \n            count(extensions[i],\
    \ \"C\"):!=0 || count(extensions[i], \"D\"):!=0 || \n            count(extensions[i],\
    \ \"E\"):!=0 || count(extensions[i], \"F\"):!=0 || \n            count(extensions[i],\
    \ \"G\"):!=0 || count(extensions[i], \"H\"):!=0 || \n            count(extensions[i],\
    \ \"I\"):!=0 || count(extensions[i], \"J\"):!=0 || \n            count(extensions[i],\
    \ \"K\"):!=0 || count(extensions[i], \"L\"):!=0 || \n            count(extensions[i],\
    \ \"M\"):!=0 || count(extensions[i], \"N\"):!=0 || \n            count(extensions[i],\
    \ \"O\"):!=0 || count(extensions[i], \"P\"):!=0 || \n            count(extensions[i],\
    \ \"Q\"):!=0 || count(extensions[i], \"R\"):!=0 || \n            count(extensions[i],\
    \ \"S\"):!=0 || count(extensions[i], \"T\"):!=0 || \n            count(extensions[i],\
    \ \"U\"):!=0 || count(extensions[i], \"V\"):!=0 || \n            count(extensions[i],\
    \ \"W\"):!=0 || count(extensions[i], \"X\"):!=0 || \n            count(extensions[i],\
    \ \"Y\"):!=0 || count(extensions[i], \"Z\"):!=0\n            strength_key += 1\n\
    \        end\n        if count(extensions[i], \"a\"):!=0 || count(extensions[i],\
    \ \"b\"):!=0 || \n            count(extensions[i],", "    cap, sm = 0, 0\n   \
    \ strength = 0.0\n    class_strength = 0.0\n    s = \"\"\n    for extension in\
    \ extensions\n        for letter in extension\n            if letter in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n                cap += 1\n            elseif letter in \"abcdefghijklmnopqrstuvwxyz\"\
    \n                sm += 1\n            end\n        end\n        class_strength\
    \ = cap - sm\n        if class_strength > strength\n            strength = class_strength\n\
    \            s = extension\n        end\n        cap, sm = 0, 0\n    end\n   \
    \ return class_name * \".\" * s\nend", "    \n    streng = 0\n    str_ext = \"\
    \"\n    for i in 1:length(extensions)\n        ext = extensions[i]\n        num_of_caps\
    \ = sum(isupper.(ext))\n        num_of_smalls = sum(islower.(ext))\n        if\
    \ streng < num_of_caps - num_of_smalls\n            streng = num_of_caps - num_of_smalls\n\
    \            str_ext = ext\n        end\n    end\n    return class_name * \".\"\
    \ * str_ext\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
