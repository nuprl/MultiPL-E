name: HumanEval_2_truncate_number
language: jl
prompt: "\"\"\" Given a positive floating point number, it can be decomposed into\n\
  \    and integer part (largest integer smaller than given number) and decimals\n\
  \    (leftover part always smaller than 1).\n\n    Return the decimal part of the\
  \ number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\nfunction truncate_number(number::Float64)::Float64\
  \ \n"
tests: "using Test\n\n@testset begin\n\ncandidate = truncate_number;\n\t@test(candidate(3.5)\
  \ == 0.5)\n\t@test(candidate(1.25) == 0.25)\n\t@test(candidate(123.0) == 0.0)\n\
  end\n"
completions: ["    if number < 0\n        return truncate_number(-number)\n    end\n\
    \    return number - floor(number)\nend", "    integer_part = trunc(number)\n\
    \    return number - integer_part\nend", "    return number - trunc(number)\n\
    end", "    return number - floor(number)\nend", "    #\n    if number < 0 \n \
    \       println(\"\\ntruncate_number: Number should be positive!\")\n        return\n\
    \    end\n    #\n    return (number - floor(number))\nend", "    return number\
    \ - trunc(number)\nend", "    return number - trunc(number)\nend", "    return\
    \ mod(number, 1)\nend", "    return number - floor(number)\nend", "    return\
    \ number - floor(number)\nend", "    \"\"\" Return the decimal part of the number.\n\
    \    \"\"\"\n    return round(number - floor(number), digits=4)\nend", "    return\
    \ number - trunc(number)\nend", "    return  number % trunc(number)\nend", " \
    \   return number - trunc(number)\nend", "    \n    integer_part, decimal_part\
    \ = trunc(number), number - trunc(number)\n    \n    return decimal_part\nend",
  "    return number - trunc(number)\nend", "    return  number - floor(number)\n\
    end", "    return (number - trunc(number))\nend", "    return mod(number, 1)\n\
    end", "    return (number - trunc(number))\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
