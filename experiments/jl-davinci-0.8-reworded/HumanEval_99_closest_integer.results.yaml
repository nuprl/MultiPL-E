name: HumanEval_99_closest_integer
language: jl
results:
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    n = parse(Float64, value)\n    if n - Int64(n) == 0.5\n        Int64(n)\
    \ >= 0 ? return Int64(n)+1 : return Int64(n)-1\n    else\n        return Int64(round(n))\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: colon expected in \"?\" expression\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp12horvyi.jl:22\nin expression starting at\
    \ /tmp/tmp12horvyi.jl:22\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    # if value is equidistant from two integers,\n    # should return the\
    \ one that is farthest from zero\n    if !contains(value, \".\") \n        return\
    \ parse(Int64, value)\n    else\n        value_float = parse(Float64, value)\n\
    \        return (ceil(value_float))*((ceil(value_float) - value_float) > (value_float\
    \ - floor(value_float))) + \n            (floor(value_float))*((floor(value_float)\
    \ - value_float) > (value_float - ceil(value_float)))\n    end\nend\n \nclosest_integer(\"\
    14.5\")\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpn_q5od61.jl:37\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 0 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpn_q5od61.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn_q5od61.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpn_q5od61.jl:38\n  Expression: candidate(\"-15.5\") == -16\n\
    \   Evaluated: 0 == -16\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn_q5od61.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn_q5od61.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpn_q5od61.jl:39\n  Expression: candidate(\"15.3\") == 15\n\
    \   Evaluated: 31 == 15\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpn_q5od61.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpn_q5od61.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     3      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn_q5od61.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    if num % 1 == 0\n        return num\n\
    \    elseif num < 0\n        return Int64(floor(num))\n    else\n        return\
    \ Int64(ceil(num))\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3mdjr5wz.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3mdjr5wz.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3mdjr5wz.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3mdjr5wz.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n  return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdxb7x6bl.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpdxb7x6bl.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpdxb7x6bl.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpdxb7x6bl.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpdxb7x6bl.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpdxb7x6bl.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpdxb7x6bl.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpdxb7x6bl.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpdxb7x6bl.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdxb7x6bl.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64,value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdxuw9ti7.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpdxuw9ti7.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpdxuw9ti7.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpdxuw9ti7.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpdxuw9ti7.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpdxuw9ti7.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpdxuw9ti7.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpdxuw9ti7.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpdxuw9ti7.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdxuw9ti7.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\n \nfor value in [\"10\", \"\
    15.3\", \"14.5\", \"-14.5\"]\n    println(closest_integer(value))\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "10\n15\n14\n-14\ntest set: Test Failed at /tmp/tmppzhfvb6f.jl:31\n  Expression:\
    \ candidate(\"14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppzhfvb6f.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppzhfvb6f.jl:29\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppzhfvb6f.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    n = parse(Float64, value)\n    int(round(n))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp3sog8acx.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"10\") == 10\n  UndefVarError: int not defined\n  Stacktrace:\n\
    \   [1] closest_integer(value::String)\n     @ Main /tmp/tmp3sog8acx.jl:20\n \
    \  [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3sog8acx.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3sog8acx.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp3sog8acx.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"14.5\") == 15\n  UndefVarError: int not defined\n  Stacktrace:\n\
    \   [1] closest_integer(value::String)\n     @ Main /tmp/tmp3sog8acx.jl:20\n \
    \  [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3sog8acx.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3sog8acx.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp3sog8acx.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  UndefVarError: int not defined\n  Stacktrace:\n\
    \   [1] closest_integer(value::String)\n     @ Main /tmp/tmp3sog8acx.jl:20\n \
    \  [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3sog8acx.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3sog8acx.jl:26\ntest set:\
    \ Error During Test at /tmp/tmp3sog8acx.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  UndefVarError: int not defined\n  Stacktrace:\n\
    \   [1] closest_integer(value::String)\n     @ Main /tmp/tmp3sog8acx.jl:20\n \
    \  [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3sog8acx.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == round(value)\n        value\
    \ = round(value)\n    else\n        value = round(value; digits=0)\n    end\n\
    \    return value\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp81vxnzqq.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp81vxnzqq.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp81vxnzqq.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp81vxnzqq.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmplicz62es.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmplicz62es.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmplicz62es.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmplicz62es.jl:25\ntest set:\
    \ Error During Test at /tmp/tmplicz62es.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmplicz62es.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmplicz62es.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmplicz62es.jl:25\ntest set:\
    \ Error During Test at /tmp/tmplicz62es.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplicz62es.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"-inf\" || value == \"+inf\"\n        throw(DomainError(\"\
    infinity is not a valid input\"))\n    end\n    num = parse(Float64, value)\n\
    \    floor(num) == ceil(num) ? num : Int64(round(num))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkql7tlmx.jl:31\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkql7tlmx.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkql7tlmx.jl:29\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkql7tlmx.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    # if the input is a number, convert it to a Float64\n    if value[end]\
    \ \u2208 '0123456789'\n        value = parse(Float64, value)\n    else\n     \
    \   # if input is a Float64, use it as is\n        value = parse(Float64, value[1:end-1])\n\
    \    end\n    # return value rounded away from zero\n    round(value)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: character literal contains multiple characters\n\
    Stacktrace:\n [1] top-level scope\n   @ /tmp/tmppfcxd9dr.jl:20\nin expression\
    \ starting at /tmp/tmppfcxd9dr.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    iseven(round(value)) ? round(value)\
    \ : trunc(Int64,value) + 1\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpekxqhhdu.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpekxqhhdu.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpekxqhhdu.jl:26\ntest set: Test\
    \ Failed at /tmp/tmpekxqhhdu.jl:30\n  Expression: candidate(\"15.3\") == 15\n\
    \   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpekxqhhdu.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpekxqhhdu.jl:26\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpekxqhhdu.jl:24\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = float(value)\n    x = round(value)\n    # if x <= value:\n   \
    \ #     return x\n    # else:\n    #     return x-1\n    return Int64(x)\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpjnst6fdh.jl:32\n  Test threw exception\n\
    \  Expression: candidate(\"10\") == 10\n  MethodError: no method matching AbstractFloat(::String)\n\
    \  Closest candidates are:\n    (::Type{T})(!Matched::AbstractChar) where T<:Union{AbstractChar,\
    \ Number} at /shared/centos7/julia/1.7.3/share/julia/base/char.jl:50\n    (::Type{T})(!Matched::Base.TwicePrecision)\
    \ where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:255\n\
    \    (::Type{T})(!Matched::Complex) where T<:Real at /shared/centos7/julia/1.7.3/share/julia/base/complex.jl:44\n\
    \    ...\n  Stacktrace:\n   [1] float(x::String)\n     @ Base ./float.jl:269\n\
    \   [2] closest_integer(value::String)\n     @ Main /tmp/tmpjnst6fdh.jl:19\n \
    \  [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpjnst6fdh.jl:32 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmpjnst6fdh.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpjnst6fdh.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"14.5\") == 15\n  MethodError: no method matching AbstractFloat(::String)\n\
    \  Closest candidates are:\n    (::Type{T})(!Matched::AbstractChar) where T<:Union{AbstractChar,\
    \ Number} at /shared/centos7/julia/1.7.3/share/julia/base/char.jl:50\n    (::Type{T})(!Matched::Base.TwicePrecision)\
    \ where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:255\n\
    \    (::Type{T})(!Matched::Complex) where T<:Real at /shared/centos7/julia/1.7.3/share/julia/base/complex.jl:44\n\
    \    ...\n  Stacktrace:\n   [1] float(x::String)\n     @ Base ./float.jl:269\n\
    \   [2] closest_integer(value::String)\n     @ Main /tmp/tmpjnst6fdh.jl:19\n \
    \  [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmpjnst6fdh.jl:33 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjnst6fdh.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    print(typeof(parse(Int64, value)))\n    println(typeof(Float64(value)))\n\
    \    return trunc(Float64(value))\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "Int64test set: Error During Test at /tmp/tmpn6ppzwqy.jl:28\n  Test threw\
    \ exception\n  Expression: candidate(\"10\") == 10\n  MethodError: no method matching\
    \ Float64(::String)\n  Closest candidates are:\n    (::Type{T})(!Matched::AbstractChar)\
    \ where T<:Union{AbstractChar, Number} at /shared/centos7/julia/1.7.3/share/julia/base/char.jl:50\n\
    \    (::Type{T})(!Matched::Base.TwicePrecision) where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:255\n\
    \    (::Type{T})(!Matched::Complex) where T<:Real at /shared/centos7/julia/1.7.3/share/julia/base/complex.jl:44\n\
    \    ...\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @ Main /tmp/tmpn6ppzwqy.jl:20\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpn6ppzwqy.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpn6ppzwqy.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpn6ppzwqy.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpn6ppzwqy.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpn6ppzwqy.jl:29 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpn6ppzwqy.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpn6ppzwqy.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn6ppzwqy.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    str_to_float(value) |> round |> floor |> Int64\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpadpezdjr.jl:26\n  Test threw exception\n\
    \  Expression: candidate(\"10\") == 10\n  UndefVarError: str_to_float not defined\n\
    \  Stacktrace:\n   [1] closest_integer(value::String)\n     @ Main /tmp/tmpadpezdjr.jl:19\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadpezdjr.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadpezdjr.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpadpezdjr.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(\"14.5\") == 15\n  UndefVarError: str_to_float not defined\n  Stacktrace:\n\
    \   [1] closest_integer(value::String)\n     @ Main /tmp/tmpadpezdjr.jl:19\n \
    \  [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadpezdjr.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadpezdjr.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpadpezdjr.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  UndefVarError: str_to_float not defined\n  Stacktrace:\n\
    \   [1] closest_integer(value::String)\n     @ Main /tmp/tmpadpezdjr.jl:19\n \
    \  [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadpezdjr.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadpezdjr.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpadpezdjr.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  UndefVarError: str_to_float not defined\n  Stacktrace:\n\
    \   [1] closest_integer(value::String)\n     @ Main /tmp/tmpadpezdjr.jl:19\n \
    \  [2] macro expansion\n     @ /shared/cento"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpadpezdjr.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    # Find the integer equidistant from zero\n    val = parse(Float64, value)\n\
    \    lower_bound = floor(val)\n    upper_bound = ceil(val)\n    if lower_bound\
    \ == upper_bound\n        return val\n    elseif val - lower_bound < upper_bound\
    \ - val\n        return floor(val)\n    elseif val - lower_bound > upper_bound\
    \ - val\n        return ceil(val)\n    else \n        return floor(val) if val\
    \ < 0 else ceil(val)\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: \"if\" at /tmp/tmpo5a6h168.jl:27 expected \"\
    end\", got \"if\"\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpo5a6h168.jl:30\n\
    in expression starting at /tmp/tmpo5a6h168.jl:30\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    val = parse(Float64, value)\n    floor_val = floor(val)\n    ceil_val\
    \ = ceil(val)\n    if abs(val - floor_val) < abs(val - ceil_val)\n        return\
    \ floor_val\n    else\n        return ceil_val\n    end\nend\n\"\"\"\n    Create\
    \ a function that takes an array of numbers as an argument and\n    returns the\
    \ same array with the first element moved to the end of\n    the array.\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpu0k4esmb.jl:28\nin expression starting at\
    \ /tmp/tmpu0k4esmb.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpub3551kz.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpub3551kz.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpub3551kz.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpub3551kz.jl:23\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    val = parse(Float64, value)\n    if val > 0\n        return round(ceil(val))\n\
    \    else\n        return round(floor(val))\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphogw2c2q.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphogw2c2q.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphogw2c2q.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphogw2c2q.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    A = Float64(value)\n    R = round(A)\n    return R\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpjzm5dmdl.jl:28\n  Test threw exception\n\
    \  Expression: candidate(\"10\") == 10\n  MethodError: no method matching Float64(::String)\n\
    \  Closest candidates are:\n    (::Type{T})(!Matched::AbstractChar) where T<:Union{AbstractChar,\
    \ Number} at /shared/centos7/julia/1.7.3/share/julia/base/char.jl:50\n    (::Type{T})(!Matched::Base.TwicePrecision)\
    \ where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:255\n\
    \    (::Type{T})(!Matched::Complex) where T<:Real at /shared/centos7/julia/1.7.3/share/julia/base/complex.jl:44\n\
    \    ...\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @ Main /tmp/tmpjzm5dmdl.jl:19\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjzm5dmdl.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjzm5dmdl.jl:27\ntest set:\
    \ Error During Test at /tmp/tmpjzm5dmdl.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"14.5\") == 15\n  MethodError: no method matching Float64(::String)\n\
    \  Closest candidates are:\n    (::Type{T})(!Matched::AbstractChar) where T<:Union{AbstractChar,\
    \ Number} at /shared/centos7/julia/1.7.3/share/julia/base/char.jl:50\n    (::Type{T})(!Matched::Base.TwicePrecision)\
    \ where T<:Number at /shared/centos7/julia/1.7.3/share/julia/base/twiceprecision.jl:255\n\
    \    (::Type{T})(!Matched::Complex) where T<:Real at /shared/centos7/julia/1.7.3/share/julia/base/complex.jl:44\n\
    \    ...\n  Stacktrace:\n   [1] closest_integer(value::String)\n     @ Main /tmp/tmpjzm5dmdl.jl:19\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpjzm5dmdl.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpjzm5dmdl.jl:27\ntest set:\
    \ Error During Test "
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjzm5dmdl.jl:25\n"
  exit_code: 1
  status: SyntaxError
