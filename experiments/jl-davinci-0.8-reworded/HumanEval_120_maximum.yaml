name: HumanEval_120_maximum
language: jl
prompt: "\"\"\"\n    Given a vector arr of integers and a positive integer k, return\
  \ a sorted vector \n    of length k with the maximum k numbers in arr.\n\n    Example\
  \ 1:\n\n    >>> maximum([-3, -4, 5], 3)\n    [-4, -3, 5]\n\n    Example 2:\n\n \
  \   >>> maximum([4, -4, 4], 2)\n    [4, 4]\n\n    Example 3:\n\n    >>> maximum([-3,\
  \ 2, 1, 2, -1, -2, 1], 1)\n    [2]\n\n    Note:\n        1. The length of the vector\
  \ will be in the range of [1, 1000].\n        2. The elements in the vector will\
  \ be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n\
  function maximum(arr::Vector{Int64}, k::Int64)::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = maximum;\n\t@test(candidate([-3,\
  \ -4, 5], 3) == [-4, -3, 5])\n\t@test(candidate([4, -4, 4], 2) == [4, 4])\n\t@test(candidate([-3,\
  \ 2, 1, 2, -1, -2, 1], 1) == [2])\n\t@test(candidate([123, -123, 20, 0, 1, 2, -3],\
  \ 3) == [2, 20, 123])\n\t@test(candidate([-123, 20, 0, 1, 2, -3], 4) == [0, 1, 2,\
  \ 20])\n\t@test(candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5,\
  \ 15])\n\t@test(candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5])\n\t@test(candidate([1,\
  \ 0, 5, -7], 1) == [5])\n\t@test(candidate([4, -4], 2) == [-4, 4])\n\t@test(candidate([-10,\
  \ 10], 2) == [-10, 10])\n\t@test(candidate([1, 2, 3, -23, 243, -400, 0], 0) == Vector{Int64}([]))\n\
  end\n"
completions: ["    heap = heapify(arr, k)\n    for i = k + 1:length(arr)\n       \
    \ if heap[1] < arr[i]\n            heap[1] = arr[i]\n            sift_down(heap,\
    \ 1, k)\n        end\n    end\n    sort(heap)\nend", "    # Initialize an empty\
    \ vector of length k\n    ans = zeros(Int64, k)\n    # Initialize k minimum number\
    \ in the vector to -inf\n    for i in 1:k\n        ans[i] = -typemax(Int64)\n\
    \    end\n    # Loop through all the elements in the vector\n    for i in 1:length(arr)\n\
    \        # If the current value is larger than the minimum element in the ans\
    \ vector\n        if arr[i] > minimum(ans)\n            # Find the index of the\
    \ minimum element in the ans vector\n            idx = findall(x -> x == minimum(ans),\
    \ ans)[1]\n            # Replace the minimum element in the ans vector with the\
    \ current value\n            ans[idx] = arr[i]\n        end\n    end\n    # Sory\
    \ the ans vector and return\n    sort!(ans)\n    return ans\nend", "    n::Int64\
    \ = length(arr)\n    # TODO\nend", "    # sort in descending order\n    isort(x->x>0\
    \ ? x : -x, arr)[1:k]\nend", "    if k == 0 \n        return []\n    end\n   \
    \ if k == 1\n        return sort(arr, rev=true)[1:k]\n    end\n    function heapify(v::Vector{Int64},\
    \ i::Int64)\n        while 2i + 1 <= length(v)\n            min = v[i]\n     \
    \       min_idx = i\n            if v[2i + 1] < min\n                min = v[2i\
    \ + 1]\n                min_idx = 2i + 1\n            end\n            if (2i\
    \ + 2 <= length(v)) && (v[2i + 2] < min)\n                min = v[2i + 2]\n  \
    \              min_idx = 2i + 2\n            end\n            if min_idx == i\n\
    \                break\n            end\n            v[i], v[min_idx] = v[min_idx],\
    \ v[i]\n            i = min_idx\n        end\n    end\n    function heapify(v::Vector{Int64},\
    \ i::Int64)\n        while 2i + 1 <= length(v)\n            min = v[i]\n     \
    \       min_idx = i\n            if v[2i + 1] < min\n                min = v[2i\
    \ + 1]\n                min_idx = 2i + 1\n            end\n            if (2i\
    \ + 2 <= length(v)) && (v[2i + 2] < min)\n                min = v[2i + 2]\n  \
    \              min_idx = 2i + 2\n            end\n            if min_idx == i\n\
    \                break\n            end\n            v[i], v[min_idx] = v[min_idx],\
    \ v[i]\n            i = min_idx\n        end\n    end\n    function build_heap(v::Vector{Int64})\n\
    \        for i in div(length(v) - 1, 2):-1:0\n            heapify(v, i)\n    \
    \    end\n    end\n    ans = zeros(Int64, k)\n    for i in 1:k\n        ans[i]\
    \ = arr[i]\n    end\n    build_heap(ans)\n    for i in k+", "    \n    # sort\
    \ vector into descending order\n    sort!(arr, rev=true)\n    \n    # Return first\
    \ k elements\n    return arr[1:k]\nend", "    # return sort(arr)[end-k+1:end]\n\
    \    last = 0\n    l = length(arr)\n    for i = 1:k\n        index = getIndex(arr,\
    \ i, l)\n        if index != 0\n            last = index\n            arr[i],\
    \ arr[index] = arr[index], arr[i]\n        end\n    end\n    sift(arr, k, last)\n\
    \    sort(arr)[end-k+1:end]\nend", "    n = length(arr)\n    for i in 1:k\n  \
    \      for j in i+1:n\n            if arr[i] < arr[j]\n                tmp = arr[i]\n\
    \                arr[i] = arr[j]\n                arr[j] = tmp\n            end\n\
    \        end\n    end\n    return arr[1:k]\nend", "    # Original Solution\n \
    \   # length(arr) > k && sort(arr, rev=true)[1:k] || sort(arr, rev=true)", " \
    \   arr[sortperm(arr)[end-k+1:end]]\nend", "    function quickselect(arr::Vector{Int64},\
    \ k::Int64, start::Int64, stop::Int64)::Int64\n        # TODO: fast pivot selection\n\
    \        pivot_idx = trunc(Int64, start + (stop - start) / 2)\n        pivot =\
    \ arr[pivot_idx]\n        i = start\n        j = stop\n        while i <= j\n\
    \            while arr[i] < pivot\n                i += 1\n            end\n \
    \           while arr[j] > pivot\n                j -= 1\n            end\n  \
    \          if i <= j\n                swap!(arr, i, j)\n                i += 1\n\
    \                j -= 1\n            end\n        end\n        if j >= k\n   \
    \         return quickselect(arr, k, start, j)\n        elseif i <= k\n      \
    \      return quickselect(arr, k, i, stop)\n        else\n            return pivot\n\
    \        end\n    end\n    @inbounds for i in 1:k\n        quickselect(arr, i,\
    \ 1, length(arr))\n    end\n    sort!(arr)\n    arr[1:k]\nend", "    #arr = sort(arr,\
    \ rev=true)\n    #return arr[1:k]\n    max_heap = PriorityQueue{Int64}()\n   \
    \ for element in arr \n        if max_heap.size < k \n            push!(max_heap,\
    \ element)\n        elseif max_heap.top > element \n            pop!(max_heap)\n\
    \            push!(max_heap, element)\n        end\n    end", "    n = length(arr)\n\
    \    heap = Array{Int64, 1}(undef, k)\n    heap_size = 0\n    for i in 1:k\n \
    \       push!(heap, arr[i])\n        heap_size += 1\n    end\n    for i in k+1:n\n\
    \        @inbounds if heap[1] < arr[i]\n            heap[1] = arr[i]\n       \
    \     heapify!(heap, heap_size, 1)\n        end\n    end\n    return sort(heap)\n\
    end", "    arr_max = []\n    arr_max = zeros(k)", "    \n    # create a new vector\
    \ to store the array with maximum k numbers\n    maximums = Vector{Int64}(undef,\
    \ k)\n    \n    # take the first k elements in the vector\n    for i in 1:k\n\
    \        maximums[i] = arr[i]\n    end\n    \n    # sort the array\n    sort!(maximums)\n\
    \    \n    # compare each element to the last element in the array\n    for i\
    \ in k+1:length(arr)\n        if maximums[k] < arr[i]\n            maximums[k]\
    \ = arr[i]\n            sort!(maximums)\n        end\n    end\n    \n    return\
    \ maximums\nend", '    i, j = 1, k', "    heap = MaxHeap()\n    for i = 1:length(arr)\n\
    \        push!(heap, arr[i])\n    end\n    val = Vector{Int64}(undef, k)\n   \
    \ for i = 1:k\n        val[i] = pop!(heap)\n    end\n    return val\nend", " \
    \   res = []\n    for (i, x) in enumerate(arr)\n        if length(res) == k\n\
    \            for i in 1:k-1\n                if x > res[i]\n                 \
    \   res[i] = x\n                    break\n                end\n            end\n\
    \        else\n            push!(res, x)\n        end\n    end\n    sort!(res)\n\
    \    res\nend\nmaximum([-3, -4, 5], 3) == [-4, -3, 5]\nmaximum([4, -4, 4], 2)\
    \ == [4, 4]\nmaximum([-3, 2, 1, 2, -1, -2, 1], 1) == [2]", "    n = length(arr)\n\
    \    # Keep track of the maximum k numbers in arr.\n    arr_max = zeros(Int64,\
    \ k)\n    # Initialize the maximum numbers to be the first k numbers in arr.\n\
    \    for i in 1:k\n        arr_max[i] = arr[i]\n    end\n    # For each number\
    \ in arr, replace the current numbers in arr_max with the next \n    # largest\
    \ numbers in arr if the number is larger than some number in arr_max.\n    for\
    \ i in (k+1):n\n        # Indices where arr_max[j] < arr[i]\n        inds = findall(arr_max\
    \ .< arr[i])\n        for j in inds\n            arr_max[j] = arr[i]\n       \
    \ end\n    end\n    # Sort the numbers in arr_max.\n    sort!(arr_max)\n    return\
    \ arr_max\nend", "    return sort(arr)[end-k+1:end]\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
