name: HumanEval_120_maximum
language: jl
prompt: "\"\"\"\n    Given a vector arr of integers and a positive integer k, return\
  \ a sorted vector \n    of length k with the maximum k numbers in arr.\n\n    Example\
  \ 1:\n\n    >>> maximum([-3, -4, 5], 3)\n    [-4, -3, 5]\n\n    Example 2:\n\n \
  \   >>> maximum([4, -4, 4], 2)\n    [4, 4]\n\n    Example 3:\n\n    >>> maximum([-3,\
  \ 2, 1, 2, -1, -2, 1], 1)\n    [2]\n\n    Note:\n        1. The length of the vector\
  \ will be in the range of [1, 1000].\n        2. The elements in the vector will\
  \ be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n\
  function maximum(arr::Vector{Int64}, k::Int64)::Vector{Int64} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = maximum;\n\t@test(candidate([-3,\
  \ -4, 5], 3) == [-4, -3, 5])\n\t@test(candidate([4, -4, 4], 2) == [4, 4])\n\t@test(candidate([-3,\
  \ 2, 1, 2, -1, -2, 1], 1) == [2])\n\t@test(candidate([123, -123, 20, 0, 1, 2, -3],\
  \ 3) == [2, 20, 123])\n\t@test(candidate([-123, 20, 0, 1, 2, -3], 4) == [0, 1, 2,\
  \ 20])\n\t@test(candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5,\
  \ 15])\n\t@test(candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5])\n\t@test(candidate([1,\
  \ 0, 5, -7], 1) == [5])\n\t@test(candidate([4, -4], 2) == [-4, 4])\n\t@test(candidate([-10,\
  \ 10], 2) == [-10, 10])\n\t@test(candidate([1, 2, 3, -23, 243, -400, 0], 0) == Vector{Int64}([]))\n\
  end\n"
completions: ["    heap = heapify(arr, k)\n    for i = k + 1:length(arr)\n       \
    \ if heap[1] < arr[i]\n            heap[1] = arr[i]\n            sift_down(heap,\
    \ 1, k)\n        end\n    end\n    sort(heap)\nend", "    # Initialize an empty\
    \ vector of length k\n    ans = zeros(Int64, k)\n    # Initialize k minimum number\
    \ in the vector to -inf\n    for i in 1:k\n        ans[i] = -typemax(Int64)\n\
    \    end\n    # Loop through all the elements in the vector\n    for i in 1:length(arr)\n\
    \        # If the current value is larger than the minimum element in the ans\
    \ vector\n        if arr[i] > minimum(ans)\n            # Find the index of the\
    \ minimum element in the ans vector\n            idx = findall(x -> x == minimum(ans),\
    \ ans)[1]\n            # Replace the minimum element in the ans vector with the\
    \ current value\n            ans[idx] = arr[i]\n        end\n    end\n    # Sory\
    \ the ans vector and return\n    sort!(ans)\n    return ans\nend", "    n::Int64\
    \ = length(arr)\n    # TODO\nend", "    # sort in descending order\n    isort(x->x>0\
    \ ? x : -x, arr)[1:k]\nend", "    if k == 0 \n        return []\n    end\n   \
    \ if k == 1\n        return sort(arr, rev=true)[1:k]\n    end\n    function heapify(v::Vector{Int64},\
    \ i::Int64)\n        while 2i + 1 <= length(v)\n            min = v[i]\n     \
    \       min_idx = i\n            if v[2i + 1] < min\n                min = v[2i\
    \ + 1]\n                min_idx = 2i + 1\n            end\n            if (2i\
    \ + 2 <= length(v)) && (v[2i + 2] < min)\n                min = v[2i + 2]\n  \
    \              min_idx = 2i + 2\n            end\n            if min_idx == i\n\
    \                break\n            end\n            v[i], v[min_idx] = v[min_idx],\
    \ v[i]\n            i = min_idx\n        end\n    end\n    function heapify(v::Vector{Int64},\
    \ i::Int64)\n        while 2i + 1 <= length(v)\n            min = v[i]\n     \
    \       min_idx = i\n            if v[2i + 1] < min\n                min = v[2i\
    \ + 1]\n                min_idx = 2i + 1\n            end\n            if (2i\
    \ + 2 <= length(v)) && (v[2i + 2] < min)\n                min = v[2i + 2]\n  \
    \              min_idx = 2i + 2\n            end\n            if min_idx == i\n\
    \                break\n            end\n            v[i], v[min_idx] = v[min_idx],\
    \ v[i]\n            i = min_idx\n        end\n    end\n    function build_heap(v::Vector{Int64})\n\
    \        for i in div(length(v) - 1, 2):-1:0\n            heapify(v, i)\n    \
    \    end\n    end\n    ans = zeros(Int64, k)\n    for i in 1:k\n        ans[i]\
    \ = arr[i]\n    end\n    build_heap(ans)\n    for i in k+", "    \n    # sort\
    \ vector into descending order\n    sort!(arr, rev=true)\n    \n    # Return first\
    \ k elements\n    return arr[1:k]\nend", "    # return sort(arr)[end-k+1:end]\n\
    \    last = 0\n    l = length(arr)\n    for i = 1:k\n        index = getIndex(arr,\
    \ i, l)\n        if index != 0\n            last = index\n            arr[i],\
    \ arr[index] = arr[index], arr[i]\n        end\n    end\n    sift(arr, k, last)\n\
    \    sort(arr)[end-k+1:end]\nend", "    n = length(arr)\n    for i in 1:k\n  \
    \      for j in i+1:n\n            if arr[i] < arr[j]\n                tmp = arr[i]\n\
    \                arr[i] = arr[j]\n                arr[j] = tmp\n            end\n\
    \        end\n    end\n    return arr[1:k]\nend", "    # Original Solution\n \
    \   # length(arr) > k && sort(arr, rev=true)[1:k] || sort(arr, rev=true)", " \
    \   arr[sortperm(arr)[end-k+1:end]]\nend", "    function quickselect(arr::Vector{Int64},\
    \ k::Int64, start::Int64, stop::Int64)::Int64\n        # TODO: fast pivot selection\n\
    \        pivot_idx = trunc(Int64, start + (stop - start) / 2)\n        pivot =\
    \ arr[pivot_idx]\n        i = start\n        j = stop\n        while i <= j\n\
    \            while arr[i] < pivot\n                i += 1\n            end\n \
    \           while arr[j] > pivot\n                j -= 1\n            end\n  \
    \          if i <= j\n                swap!(arr, i, j)\n                i += 1\n\
    \                j -= 1\n            end\n        end\n        if j >= k\n   \
    \         return quickselect(arr, k, start, j)\n        elseif i <= k\n      \
    \      return quickselect(arr, k, i, stop)\n        else\n            return pivot\n\
    \        end\n    end\n    @inbounds for i in 1:k\n        quickselect(arr, i,\
    \ 1, length(arr))\n    end\n    sort!(arr)\n    arr[1:k]\nend", "    #arr = sort(arr,\
    \ rev=true)\n    #return arr[1:k]\n    max_heap = PriorityQueue{Int64}()\n   \
    \ for element in arr \n        if max_heap.size < k \n            push!(max_heap,\
    \ element)\n        elseif max_heap.top > element \n            pop!(max_heap)\n\
    \            push!(max_heap, element)\n        end\n    end", "    n = length(arr)\n\
    \    heap = Array{Int64, 1}(undef, k)\n    heap_size = 0\n    for i in 1:k\n \
    \       push!(heap, arr[i])\n        heap_size += 1\n    end\n    for i in k+1:n\n\
    \        @inbounds if heap[1] < arr[i]\n            heap[1] = arr[i]\n       \
    \     heapify!(heap, heap_size, 1)\n        end\n    end\n    return sort(heap)\n\
    end", "    arr_max = []\n    arr_max = zeros(k)", "    \n    # create a new vector\
    \ to store the array with maximum k numbers\n    maximums = Vector{Int64}(undef,\
    \ k)\n    \n    # take the first k elements in the vector\n    for i in 1:k\n\
    \        maximums[i] = arr[i]\n    end\n    \n    # sort the array\n    sort!(maximums)\n\
    \    \n    # compare each element to the last element in the array\n    for i\
    \ in k+1:length(arr)\n        if maximums[k] < arr[i]\n            maximums[k]\
    \ = arr[i]\n            sort!(maximums)\n        end\n    end\n    \n    return\
    \ maximums\nend", '    i, j = 1, k', "    heap = MaxHeap()\n    for i = 1:length(arr)\n\
    \        push!(heap, arr[i])\n    end\n    val = Vector{Int64}(undef, k)\n   \
    \ for i = 1:k\n        val[i] = pop!(heap)\n    end\n    return val\nend", " \
    \   res = []\n    for (i, x) in enumerate(arr)\n        if length(res) == k\n\
    \            for i in 1:k-1\n                if x > res[i]\n                 \
    \   res[i] = x\n                    break\n                end\n            end\n\
    \        else\n            push!(res, x)\n        end\n    end\n    sort!(res)\n\
    \    res\nend\nmaximum([-3, -4, 5], 3) == [-4, -3, 5]\nmaximum([4, -4, 4], 2)\
    \ == [4, 4]\nmaximum([-3, 2, 1, 2, -1, -2, 1], 1) == [2]", "    n = length(arr)\n\
    \    # Keep track of the maximum k numbers in arr.\n    arr_max = zeros(Int64,\
    \ k)\n    # Initialize the maximum numbers to be the first k numbers in arr.\n\
    \    for i in 1:k\n        arr_max[i] = arr[i]\n    end\n    # For each number\
    \ in arr, replace the current numbers in arr_max with the next \n    # largest\
    \ numbers in arr if the number is larger than some number in arr_max.\n    for\
    \ i in (k+1):n\n        # Indices where arr_max[j] < arr[i]\n        inds = findall(arr_max\
    \ .< arr[i])\n        for j in inds\n            arr_max[j] = arr[i]\n       \
    \ end\n    end\n    # Sort the numbers in arr_max.\n    sort!(arr_max)\n    return\
    \ arr_max\nend", "    return sort(arr)[end-k+1:end]\nend", "    # create an empty\
    \ vector to return\n    res = Int64[]\n    # heapify the vector\n    @btime heapify(arr)\n\
    \    # while the k is greater than zero and the length of the arr is greater than\
    \ zero \n    while k > 0 && length(arr) > 0\n        # push the max item in the\
    \ vector to the array\n        push!(res, arr[1])\n        # pop the max item\
    \ in the vector\n        pop!(arr)\n        # decrease k by 1\n        k -= 1\n\
    \    end\n    # return the vector\n    return res\nend", "    r = sort(arr[1:k],\
    \ rev=true)\n    for i in arr[k+1:end]\n        r[1] > i && continue\n       \
    \ j = k-1\n        while j > 0 && r[j] < i\n            r[j+1] = r[j]\n      \
    \      j -= 1\n        end\n        r[j+1] = i\n    end\n    return r\nend", " \
    \   sarr = sort(arr; rev=true)\n    return sarr[1:k]\nend", "    sort(arr, rev=true)[1:k]\n\
    end", "    if length(arr) == k\n        return sort(arr)\n    end\n    @assert\
    \ k > 0 && k <= length(arr)\n    if k == 1\n        return sort(arr)[end]\n  \
    \  end\n    sort(arr)[(end-k+1):end]\nend", "    for i in 1:k\n        for j in\
    \ 1:size(arr)[1] - i\n            if arr[j] > arr[j + 1]\n                arr[j],\
    \ arr[j + 1] = arr[j + 1], arr[j]\n            end\n        end\n    end\n   \
    \ return arr[end - k + 1:end]\nend", "    pq = PriorityQueue{Int64, Tuple{Int64,\
    \ Int64}}() # priority, index\n    sorted_arr = Array{Int64}(undef, 0)\n    for\
    \ i = 1:length(arr)\n        push!(pq, (arr[i], i))\n    end\n    for _ = 1:k\n\
    \        pop!(pq)\n        push!(sorted_arr, pq.data[1][1])\n    end\n    return\
    \ sorted_arr\nend", "    sort(arr)[end-k+1:end]\nend", "    # TODO: find a way\
    \ to put this in a function\n    function partition(v::Vector{Int64}, a::Int64,\
    \ b::Int64)::Int64\n        pivot = a\n        for i in a+1:b\n            if\
    \ v[i] < v[a]\n                pivot += 1\n                v[i], v[pivot] = v[pivot],\
    \ v[i]\n            end\n        end\n        v[a], v[pivot] = v[pivot], v[a]\n\
    \        return pivot\n    end\n    \n    function quick_select(v::Vector{Int64},\
    \ k::Int64, a::Int64, b::Int64)::Int64\n        pivot = partition(v, a, b)\n \
    \       if pivot == k\n            return v[pivot]\n        elseif pivot > k\n\
    \            return quick_select(v, k, a, pivot-1)\n        else\n           \
    \ return quick_select(v, k, pivot+1, b)\n        end\n    end\n    \n    quick_select(arr,\
    \ k, 1, length(arr))\nend", "    largest_indices = findmax(arr)[2]\n    if (k\
    \ >= length(arr))\n        return arr\n    else\n        maximum_indices = largest_indices[end:-1:end-k+1]\n\
    \        return arr[maximum_indices]\n    end\nend", "    x = arr[findall(arr\
    \ .>= minimum(arr))]\n    return sort(x[1:k])\nend", "    @assert length(arr)\
    \ in 1:1000\n    @assert length(unique(arr)) in 1:1000\n    @assert k in 0:length(arr)\n\
    \    return sort(arr, rev=true)[1:k]\nend", "    arr_len = length(arr)\n    max_k\
    \ = maximum(arr)\n    min_k = minimum(arr)\n    if k == arr_len\n        return\
    \ sort(arr)\n    end\n    if k == 1\n        return [max_k]\n    end\n    if k\
    \ == 2\n        return sort([max_k, min_k])\n    end\n    if k == 3\n        max_val\
    \ = maximum(arr)\n        index_max = findfirst(arr .== max_val)\n        temp_arr\
    \ = copy(arr)\n        deleteat!(temp_arr, index_max)\n        max_val_two = maximum(temp_arr)\n\
    \        index_max_two = findfirst(temp_arr .== max_val_two)\n        deleteat!(temp_arr,\
    \ index_max_two)\n        min_val = minimum(temp_arr)\n        return sort([max_val,\
    \ max_val_two, min_val])\n    end\n    if k > 3\n        max_val = maximum(arr)\n\
    \        index_max = findfirst(arr .== max_val)\n        temp_arr = copy(arr)\n\
    \        deleteat!(temp_arr, index_max)\n        max_val_two = maximum(temp_arr)\n\
    \        index_max_two = findfirst(temp_arr .== max_val_two)\n        deleteat!(temp_arr,\
    \ index_max_two)\n        min_val = minimum(temp_arr)\n        index_min = findfirst(temp_arr\
    \ .== min_val)\n        deleteat!(temp_arr, index_min)\n        remaining_arr\
    \ = sort(temp_arr)\n        remaining_arr_len = length(remaining_arr)\n      \
    \  return vcat([max_val, max_val_two, min_val], remaining_arr[remaining_arr_len\
    \ - k + 3:end])\n    end\nend", "    heap = BinaryHeap()\n    for x in arr[1:k]\n\
    \        push!(heap, x)\n    end\n    for x in arr[k+1:end]\n        if x > peek(heap)\n\
    \            pop!(heap)\n            push!(heap, x)\n        end\n    end\n  \
    \  sort(collect(heap))\nend\n@testset \"maximum\" begin\n    @test maximum([-3,\
    \ -4, 5], 3) == [-4, -3, 5]\n    @test maximum([4, -4, 4], 2) == [4, 4]\n    @test\
    \ maximum([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\nend", "    @assert k <= length(arr)\
    \ \"`k` must be less than or equal to the length of `arr`\"\n    sorted = sort(arr,\
    \ rev=true)\n    return sorted[1:k]\nend", "    if k == 0\n        return Int64[]\n\
    \    end\n    if k >= length(arr)\n        return sort(arr)\n    end\n    heap\
    \ = BinaryHeap(arr[1:k])\n    for i in k+1:length(arr)\n        if arr[i] > heap.top()\n\
    \            pop!(heap)\n            push!(heap, arr[i])\n        end\n    end\n\
    \    return sort(collect(heap))\nend", "    return sort(arr, rev=true)[1:k]\n\
    end", "    #1. create priority queue, size = k\n    max_heap = PriorityQueue(k)",
  "    sort(arr, rev=true)[1:k]\nend", "    \n    arr_length = length(arr)\n    if\
    \ k >= arr_length\n        return sort(arr)\n    end\n    \n    if k == 1\n  \
    \      return [maximum(arr)]\n    end\n    \n    lhs = []\n    rhs = []\n    for\
    \ idx = 1:arr_length\n        if arr[idx] < maximum(arr)\n            push!(lhs,\
    \ arr[idx])\n        else\n            push!(rhs, arr[idx])\n        end\n   \
    \ end\n    \n    return vcat(maximum(lhs, k - length(rhs)), rhs)\nend\n \nmaximum([4,\
    \ -4, 4], 2)", "    n = length(arr)\n    sort(arr[n-k+1:n])\nend", "    return\
    \ sort(arr)[end - k + 1:end]\nend", "    n = length(arr)\n    return sortperm(arr,\
    \ 1:k, rev=true)[n-k+1:n]\nend", "    return sort(arr)[end - k + 1:end]\nend",
  "    # Make a min heap\n    h = MinHeap{Tuple{Int64, Int64}}(Tuple{Int64, Int64}[(i,\
    \ arr[i]) for i in 1:length(arr)])\n    k_largest = Vector{Int64}(undef, k)\n\
    \    for i in 1:k\n        root_index, root_value = pop!(h)\n        k_largest[i]\
    \ = root_value\n    end\n    k_largest\nend", "    arr[sortperm(arr)[end-k+1:end]]\n\
    end", "    \"\"\"\n    Given a vector arr of integers and a positive integer k,\
    \ return a sorted vector \n    of length k with the maximum k numbers in arr.",
  "    p = partition(arr,1,k) # \uD035\uC815\uB82C \uD30C\uD2F0\uC158\uC73C\uB85C\
    \ k\uBC88\uC9F8\uB97C \uAE30\uC900\uC73C\uB85C \uC7AC\uC815\uB82C \n    partition(arr,\
    \ p+1, length(arr))\n    arr[1:k]\nend", "    start = 1\n    stop = length(arr)\n\
    \    pivot = 0\n    temp = [arr[1]]\n    while pivot != k\n        start = 1\n\
    \        stop = length(arr)\n        while start <= stop\n            i = round(Int64,(start\
    \ + stop)/2)\n            if arr[i] > temp[1]\n                temp = [arr[i]]\n\
    \                pivot = 1\n                stop = i - 1\n            elseif arr[i]\
    \ < temp[1]\n                stop = i - 1\n            elseif arr[i] == temp[1]\n\
    \                break\n            end\n        end\n        pivot += 1\n   \
    \     temp = sort(vcat(temp,arr[1:i]),rev=true)\n        arr = arr[i+1:end]\n\
    \    end\n    return temp\nend\n \nmaximum([-3, 2, 1, 2, -1, -2, 1], 1)", "  \
    \  # sort arr in ascending order\n    sort!(arr)\n    return(arr[end-k+1:end])\n\
    end", "    if k == 1\n        maximum(arr)\n    else\n        push!(maximum(arr),\
    \ k)\n    end\nend", "    # Implementation 1\n    n = length(arr)\n    if n ==\
    \ k\n        return sort(arr)\n    end\n    if k == 1\n        return sort(arr)[end]\n\
    \    end\n    new_arr = []\n    while k > 0\n        if isempty(arr)\n       \
    \     return new_arr\n        end\n        push!(new_arr, sort(arr)[end])\n  \
    \      pop!(arr)\n        k -= 1\n    end\n    return new_arr\nend", "    res\
    \ = sorted(arr[1:k])\n    for i = k + 1:length(arr)\n        j = 1\n        while\
    \ j <= k\n            if res[j] < arr[i]\n                res[j] = arr[i]\n  \
    \              break\n            end\n            j += 1\n        end\n    end\n\
    \    return res\nend", "    sort(arr)[end-k+1:end]\nend", "    sort(arr, rev=true)[1:k]\n\
    end", "    # sort the array\n    arr = sort(arr)\n    # initialize empty vector\n\
    \    res = Vector{Int64}()\n    # for loop for slicing starting from end of array\n\
    \    for i in 1:k\n        # push to vector the max value(s)\n        push!(res,\
    \ arr[end - i + 1])\n    end\n    return res\nend", "    # Sort the vector in\
    \ decreasing order\n    # Return the first k elements\n    return sort(arr, rev=true)[1:k]\n\
    end", "    len = length(arr)\n    out = zeros(Int64, len)\n    last = 0\n    for\
    \ i = 1:len\n        while last > 0 && last + len - i >= k && arr[i] > out[last]\n\
    \            last -= 1\n        end\n        if last < k\n            last +=\
    \ 1\n            out[last] = arr[i]\n        end\n    end\n    return out[1:k]\n\
    end", '    num_elements = length(arr)', "    n = length(arr)\n    pq = Dict{Int64,\
    \ Bool}()\n    for i in arr[1:k]\n        pq[i] = true\n    end\n    for i in\
    \ arr[k+1:n]\n        if i in keys(pq)\n            continue\n        else\n \
    \           m = minimum(keys(pq))\n            if i > m\n                delete!(pq,\
    \ m)\n                pq[i] = true\n            end\n        end\n    end\n  \
    \  return sort(collect(keys(pq)))\nend", "    sorted_arr = sort(arr)\n    return\
    \ sorted_arr[end-k+1:end]\nend", "    min_idx = 1\n    result = Vector{Int64}(undef,\
    \ k)\n    for i in 1:k\n        result[i] = arr[i]\n        if result[i] < result[min_idx]\n\
    \            min_idx = i\n        end\n    end\n    for i in k+1:length(arr)\n\
    \        if arr[i] > result[min_idx]\n            result[min_idx] = arr[i]\n \
    \           min_idx = 1\n            for j in 2:k\n                if result[j]\
    \ < result[min_idx]\n                    min_idx = j\n                end\n  \
    \          end\n        end\n    end\n    return sort(result)\nend\n\"\"\"\n \
    \   Given a 2D board of characters and a word, find if the word exists in the\
    \ grid.", "    h = MaxHeap()\n    push!(h, arr[1:k])\n    for i in (k+1)::length(arr)\n\
    \        push!(h, arr[i])\n        if i > length(arr) - k\n            shift!(h)\n\
    \        end\n    end\n    return sort(h.heap, rev=true)\nend", "    maxVals =\
    \ zeros(Int64,k)\n    for i in 1:k\n        maxVals[i] = max(arr)\n        arr\
    \ = [x for x in arr if x < maxVals[i]]\n    end\n    return maxVals\nend", " \
    \   len = length(arr)\n    heap = HeapArray{Int64}(len)\n    for (i, val) in enumerate(arr)\n\
    \        insert!(heap, -val)\n    end\n    ans = Array{Int64}(k)\n    for i in\
    \ 1:k\n        ans[i] = -remove!(heap)\n    end\n    return ans\nend", "    quicksort!(arr)\n\
    \    return arr[1:k]\nend", "    arr_maxs = Int64[]\n    while length(arr_maxs)\
    \ < k\n        push!(arr_maxs, maximum(arr))\n        deleteat!(arr, indmax(arr))\n\
    \    end\n    return sort(arr_maxs)\nend", "    heap = MaxHeap(arr[1:k])\n   \
    \ for i = k+1:length(arr)\n        if arr[i] < heap.data[1]\n            continue\n\
    \        end\n        push!(heap, arr[i])\n        pop!(heap)\n    end\n    return\
    \ sort(heap.data)\nend", "    #push all elements into a min-heap\n    heap = MinHeap()\n\
    \    for element in arr\n        push!(heap, element)\n    end\n    solution =\
    \ Vector{Int64}()\n    #pop k elements off the heap, the next element will be\
    \ the largest one in the heap\n    #and add it to the solution\n    for i in 1:k\n\
    \        push!(solution, pop!(heap))\n    end\n    return solution\nend", "  \
    \  # Initialize an empty vector\n    out = []", "    if k == 0 \n        return\
    \ []\n    end\n    heap = maxheap()\n    for i=1:k \n        push!(heap, arr[i])\n\
    \    end\n    for i=k+1:length(arr)\n        if heap[1] < arr[i]\n           \
    \ pop!(heap)\n            push!(heap, arr[i])\n        end\n    end\n    sort(collect(heap))\n\
    end\n```", "    n = length(arr)\n    s = sort(arr)\n    return s[n-k+1:n]\nend",
  "    # add code here\nend", "    @assert k <= length(arr) && k >= 0 \n    return\
    \ [arr[i] for i in sortperm(arr, rev=true)[1:k]]\nend\n \n\"\"\"\n    Given a\
    \ vector arr of integers and a positive integer k, return a sorted vector \n \
    \   of length k with the minimum k numbers in arr.", "    # n = length(arr)\n\
    \    # k = min(k, n)\n    # heap = Array{Int64,1}(undef, k)\n    # heap[1] = arr[1]\n\
    \    # j = 2\n    # while j <= k\n    #     heap[j] = arr[j]\n    #     j += 1\n\
    \    # end\n    # heap = heapify(heap)\n    # for i = k+1:n\n    #     if heap[1]\
    \ < arr[i]\n    #         heap[1] = arr[i]\n    #         heap = heapify(heap)\n\
    \    #     end\n    # end\n    # sort(heap)\n    maximum(arr, k)\nend", "    N\
    \ = length(arr)\n    heap = zeros(Int64, k)\n    indices = zeros(Int64, k)\n \
    \   heap[1] = arr[1]\n    indices[1] = 1\n    for i = 2:k\n        heap[i] = arr[i]\n\
    \        indices[i] = i\n        heapify(heap, indices, i)\n    end\n    for i\
    \ = k+1:N\n        if arr[i] > heap[1]\n            heap[1] = arr[i]\n       \
    \     indices[1] = i\n            heapify(heap, indices, 1)\n        end\n   \
    \ end\n    sortperm(heap, indices, k)\n    sort(arr[indices[1:k]])\nend", "  \
    \  h = []\n    arr = sort(arr)\n    arr = arr[end:-1:1]\n    for i in 1:k\n  \
    \      push!(h, arr[i])\n    end\n    return sort(h)\nend", "    # Sort the array,\
    \ get k number of max elements\n    sort!(arr)\n    return arr[end-k+1:end]\n\
    end", "    # initialize an empty vector to store the maximum k numbers in arr\n\
    \    output = Vector{Int64}(undef, k)\n    # loop through arr\n    for i = 1:length(arr)\n\
    \        # if ith number in arr is larger than the minimum in output\n       \
    \ if arr[i] > minimum(output)\n            # replace the minimum with arr[i]\n\
    \            output[output .== minimum(output)] = arr[i]\n        end\n    end\n\
    \    # sort output in ascending order\n    sort!(output)\n    # return output\n\
    \    return output\nend", "    @assert k <= length(arr)\n    return sort(arr)[end\
    \ - k + 1:end]\nend", "    return []\nend", "    # k > length(arr)\n    if length(arr)\
    \ < k\n        println(\"k is larger than the length of arr\")\n        return\
    \ arr\n    end", "    sorted = sort(arr)\n    return sorted[end-k+1:end]\nend",
  "    n = length(arr)\n    quickselect!(arr, k)\n    return arr[n-k+1:n]\nend", " \
    \   idx = sortperm(arr)\n    return arr[idx[end-k+1:end]]\nend", "    #\n    #\
    \ YOUR CODE HERE\n    #\nend", "    \"\"\"\n    time complexity: O(n)\n    space\
    \ complexity: O(n)\n    \"\"\"\n    heap = Heap()\n    for i in 1:length(arr)\n\
    \        heap.push(arr[i])\n    end\n    res = []\n    for i in 1:k\n        push!(res,\
    \ heap.pop())\n    end\n    return res\nend", "    arr[sortperm(arr, rev=true)[1:k]]\n\
    end", "    if k == 1\n        maximum(arr)\n    else\n        push!(arr, maximum(arr))\n\
    \        maximum(arr[1:end-1], k-1)\n    end\nend", "    arr1 = sort(arr)\n  \
    \  arr2 = arr1[end-k+1:end]\n    return arr2\nend", "    @assert k <= length(arr)\n\
    \    sort(arr)[end - k + 1:end]\nend", "    arr2 = []\n    for i in arr\n    \
    \    push!(arr2, i)\n    end\n    sort!(arr2)\n    answer = []\n    for i in 1:k\n\
    \        push!(answer, arr2[i])\n    end\n    return answer\nend", "    if k >\
    \ length(arr)\n        return arr\n    end\n    if k == length(arr)\n        return\
    \ sort(arr)\n    end\n    push!(arr, -Inf)\n    sorted = []\n    for i in 1:k\n\
    \        index = argmax(arr)\n        push!(sorted, arr[index])\n        arr[index]\
    \ = -Inf\n    end\n    return sorted\nend", "    n = length(arr)\n    if n ==\
    \ k\n        return sort(arr)\n    end\n    left = 1\n    right = k\n    while\
    \ left < right\n        mid = (left + right) \xF7 2\n        if check(arr, mid,\
    \ k)\n            right = mid\n        else\n            left = mid + 1\n    \
    \    end\n    end\n    result = zeros(Int64, k)\n    idx = 0\n    for i = 1:n\n\
    \        if arr[i] > left - 1\n            result[idx + 1] = arr[i]\n        \
    \    idx += 1\n        end\n        if idx == k\n            break\n        end\n\
    \    end\n    sort(result)\nend", "    # convert to an array for more efficient\
    \ sorting\n    return sort(Array(arr))[end-k+1:end]\nend", "    k > 0 || throw(ArgumentError(\"\
    k must be positive integer\"))\n    k <= length(arr) || throw(ArgumentError(\"\
    k must be <= length(arr)\"))\n    arr = sort(arr, rev=true)\n    return arr[1:k]\n\
    end", "    sort(arr, rev=true)[1:k]\nend", "    n = length(arr)\n    # first sort\
    \ the array \n    sort!(arr)\n    # return last k elements\n    return arr[n-k+1:n]\n\
    end", "    arr_sorted = sort(arr)\n    return arr_sorted[end-k+1:end]\nend", " \
    \   return sort(arr)[end-k+1:end]\nend", "    n = length(arr)\n    n_v = n - k\n\
    \    indices = sortperm(arr, rev=true)[1:k]\n    return sort(arr[indices])\nend",
  "    @assert size(arr, 1) > 0\n    @assert k > 0\n    @assert size(arr, 1) >= k\n\
    \    # ----------------------------\n    # !!! TYPE YOUR SOLUTION HERE\n    @assert\
    \ false \n    # ----------------------------\nend\n\"\"\"\n    Given an integer\
    \ arr, you must increment every element in the array by 1.\n    Return the same\
    \ array after the change.", "    \"\"\"\n    Given a vector arr of integers and\
    \ a positive integer k, return a sorted vector \n    of length k with the maximum\
    \ k numbers in arr.", "    # Your Code Here\nend\n \n \n \n \n\"\"\"\n    Given\
    \ a 3 x 3 matrix named A, write a function to return a vector of size 3 \n   \
    \ containing the sum of values in each row of A.\n    \"\"\"", "    \"\"\"\n \
    \   arr, k: length of Vector arr, number of top numbers in arr\n    \"\"\"\n \
    \   n = length(arr)\n    sort!(arr)\n    if k == 0\n        return []\n    elseif\
    \ k == n\n        return arr\n    else\n        newarr = [arr[i] for i = 1:k]\n\
    \        for i = k+1:n\n            if arr[i] > newarr[1]\n                newarr[1]\
    \ = arr[i]\n                sort!(newarr)\n            end\n        end\n    \
    \    return newarr\n    end\nend", "    \"\"\"\n    Returns a sorted vector with\
    \ the maximum k numbers in arr.\n    \"\"\"\n    if k == 0\n        return []\n\
    \    end\n    i = 1\n    while k > 0 && i <= length(arr)\n        max = i\n  \
    \      j = i + 1\n        while j <= length(arr)\n            if arr[j] > arr[max]\n\
    \                max = j\n            end\n            j += 1\n        end\n \
    \       temp = arr[i]\n        arr[i] = arr[max]\n        arr[max] = temp\n  \
    \      k -= 1\n        i += 1\n    end\n    return arr[1:k]\nend", "    n = length(arr)\n\
    \    push!(arr, float(\"inf\"))\n    sort(arr[1:k])\nend\narr = [5, 6, 1, 2, 7,\
    \ 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3,\
    \ 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1,\
    \ 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4,\
    \ 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1,\
    \ 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3,\
    \ 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1,\
    \ 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4,\
    \ 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1,\
    \ 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3, 2, 1, 2, 4, 2, 1, 2, 3",
  "    sort(arr)[end-k+1:end]\nend", "    # Sorting the vector in place\n    sort!(arr)\n\
    \    # Return last k elements\n    return arr[end-k+1:end]\nend", "    # Init\
    \ of result vector with [-inf] * k\n    res = fill(-typemax(Int64), k)\n    for\
    \ i in 1:length(arr)\n        # If the max of the result vector is less than the\
    \ i'th element of arr\n        # Then modify the result vector to contain the\
    \ i'th element of arr, \n        # and make sure that the result vector is sorted\n\
    \        if res[end] < arr[i]\n            res[end] = arr[i]\n            res\
    \ = sort(res)\n        end\n    end\n    return res\nend", "    sort(arr)[end\
    \ - k + 1:end]\nend", "    k = min(k, length(arr)) # k cannot be larger than arr\
    \ length\n    # reverse sort and filter array\n    filter!(a -> a >= maximum(arr),\
    \ sort(arr, rev=true)[1:k])\nend", "    n = length(arr)\n    for i in k:n\n  \
    \      for j in 1:i-1\n            if arr[j] > arr[j+1]\n                tmp =\
    \ arr[j]\n                arr[j] = arr[j+1]\n                arr[j+1] = tmp\n\
    \            end\n        end\n    end\n    return arr[1:k]\nend", "    @assert\
    \ length(arr) >= 1 && length(arr) <= 1000\n    @assert all(e \u2208 -1000:1000\
    \ for e in arr)\n    @assert k >= 1 && k <= length(arr)\n    unique!(sort(arr,\
    \ rev=true)[1:k])\nend", "    idx = sortperm(arr, rev=true)\n    return arr[idx[1:k]]\n\
    end", '    heap = MinHeap()', "    sorted_arr = sort(arr; rev=true)\n    return\
    \ sorted_arr[1:k]\nend", "    #initialize a dictionary\n    freq = Dict()\n  \
    \  #iterate through the array and update the dictionary\n    for i = 1:length(arr)\n\
    \        if haskey(freq, arr[i])\n            freq[arr[i]] += 1\n        else\n\
    \            freq[arr[i]] = 1\n        end\n    end\n    #sort the dictionary\n\
    \    ordered = sort(collect(freq), by = x -> x[2], rev = true)\n    #initialize\
    \ a vector to store the max k elements\n    max_ele = Vector{Int64}()\n    #iterate\
    \ through the ordered dictionary \n    for i = 1:k\n        push!(max_ele, ordered[i][1])\n\
    \    end\n    return max_ele\nend", "    # initialize priority queue\n    pq =\
    \ PriorityQueue()\n    # push all elements into priority queue\n    for i in 1:length(arr)\n\
    \        push!(pq, (arr[i], i))\n    end\n    # pop k times\n    result = []\n\
    \    for i in 1:k\n        popped = pop!(pq)\n        push!(result, popped[1])\n\
    \    end\n    # return resulting array\n    return result\nend", "    return sort(arr)[end-k+1:end]\n\
    end", "    arr = sort(arr, rev=true)\n    return arr[1:k]\nend", "    arr = sort(arr)\n\
    \    return arr[length(arr) - k + 1:end]\nend", "    # Sort the array from largest\
    \ to smallest\n    sorted_arr = sort(arr, rev=true)\n    # Return the first k\
    \ items of the sorted array\n    return sorted_arr[1:k]\nend", "    # Sort the\
    \ array in descending order\n    sort!(arr, rev=true)\n    # Return the first\
    \ k values\n    return arr[1:k]\nend", "    # First we sort the array in ascending\
    \ order.\n    sorted_arr = sort(arr)\n    # Now we want to return the largest\
    \ k elements, so we return the last k elements.\n    return sorted_arr[end-k+1:end]\n\
    end", "    n = length(arr)\n    p = n - k + 1\n    temp = Vector{Int64}(undef,\
    \ p)\n    for i in 1:p\n        temp[i] = maximum(arr[i:i+k-1])\n    end\n   \
    \ return temp\nend", "    isempty(arr) && return arr\n    n = length(arr)\n  \
    \  n == k && return sort(arr)\n    k == 1 && return [maximum(arr)]\n    half_k\
    \ = k >> 1\n    left_vec = maximum(arr[1:half_k], half_k)\n    right_vec = maximum(arr[n-half_k+1:n],\
    \ half_k)\n    merge(left_vec, right_vec)\nend", "    return maximum_impl_2(arr,\
    \ k)\nend", "    s = sort(arr, rev=true)\n    return s[1:k]\nend", "    if k <\
    \ 1 \n        error(\"The value of k must be a positive integer.\")\n    end\n\
    \    if k >= length(arr)\n        return sort(arr, rev=true)\n    end\n    ind\
    \ = Vector{Int64}(undef, k)\n    ind[1] = 1\n    for i in 2:k\n        if arr[i]\
    \ > arr[ind[1]]\n            ind[1] = i\n        elseif arr[i] <= arr[ind[end]]\n\
    \            ind[end + 1] = i\n        else\n            l = 1\n            r\
    \ = length(ind)\n            while l < r\n                m = (l + r) >> 1\n \
    \               if arr[i] > arr[ind[m]]\n                    r = m\n         \
    \       else\n                    l = m + 1\n                end\n           \
    \ end\n            ind[l] = i\n        end\n    end\n    ans = Vector{Int64}(undef,\
    \ k)\n    for i in 1:k\n        ans[i] = arr[ind[i]]\n    end\n    return sort(ans,\
    \ rev=true)\nend", "    s = sort(arr, rev=true)\n    return s[1:k]\nend", "  \
    \  if k >= length(arr)\n        return sort(arr)\n    end\n    heap = Vector{Int64}(undef,\
    \ k)\n    for i in 1:k\n        heap[i] = arr[i]\n    end\n    sort!(heap)\n \
    \   for i in k+1:length(arr)\n        if arr[i] > heap[1]\n            heap[1]\
    \ = arr[i]\n            sort!(heap)\n        end\n    end\n    return heap\nend\n\
    maximum([-3, -4, 5], 3)\nmaximum([4, -4, 4], 2)\nmaximum([-3, 2, 1, 2, -1, -2,\
    \ 1], 1)", "    h = BinaryHeap()\n    for a in arr\n        if length(h) < k\n\
    \            push!(h, a)\n        elseif peek(h) < a\n            pop!(h)\n  \
    \          push!(h, a)\n        end\n    end\n    return sort(h, rev=true)\nend",
  "    # Insert your code here\nend", "    # @inbounds arr\n    # @inbounds k", " \
    \   # sort\n    arr = sort(arr)\n    # get the last k elements\n    return arr[(end-k+1):end]\n\
    end", "    heap = PriorityQueue()\n    for num in arr\n        if length(heap)\
    \ < k\n            push!(heap, num)\n        elseif num > peek(heap)\n       \
    \     pop!(heap)\n            push!(heap, num)\n        end\n    end\n    return\
    \ sort(heap)\nend", "    return sort(arr)[end - k + 1:end]\nend\nmaximum([-3,\
    \ -4, 5], 3)", "    arr[sortperm(arr)[end-k+1:end]]\nend", "    return sort(arr,\
    \ by=x->-x)[1:k]\nend", "    k = minimum(k, length(arr))\n    push!(arr, typemax(Int64))\n\
    \    @assert k > 0\n    r = @inbounds zeros(Int64, k)\n    pos = @inbounds zeros(Int64,\
    \ k)\n    mask = @inbounds zeros(Int64, length(arr))\n    for i = 1:k\n      \
    \  for j = 1:length(arr)\n            if mask[j] == 0 && arr[j] > r[i]\n     \
    \           r[i] = arr[j]\n                pos[i] = j\n            end\n     \
    \   end\n        mask[pos[i]] = 1\n    end\n    return r[1:k]\nend", "    n =\
    \ length(arr)\n    @assert n >= k\n    function _maximum(arr::Vector{Int64}, k::Int64)::Vector{Int64}\n\
    \        if k == 1\n            return [maximum(arr)]\n        else\n        \
    \    j = searchsortedlast(arr, maximum(arr[1:n-k+1]))\n            return [maximum(arr[1:j])]\
    \ * _maximum(arr[j+1:end], k-1)\n        end\n    end\n    return _maximum(arr,\
    \ k)\nend", "    # Sort the array and return the k elements from the end.\n  \
    \  sort(arr)[end-k+1:end]\nend", "    # Instantiate a vector of size k. Fill with\
    \ Inf to start.\n    maxVec = fill(Inf, k)\n    # Loop through arr.\n    for number\
    \ in arr\n        # Loop through maxVec.\n        for i in 1:k\n            #\
    \ If we find a larger number than current maxVec value, update it.\n         \
    \   if number > maxVec[i]\n                maxVec[i] = number\n              \
    \  # Break the loop.\n                break\n            end\n        end\n  \
    \  end\n    # Return the vector.\n    return sort(maxVec)\nend\nmaximum([-3, -4,\
    \ 5], 3)\nmaximum([4, -4, 4], 2)\nmaximum([-3, 2, 1, 2, -1, -2, 1], 1)", "   \
    \ n = length(arr)\n    return sort(arr)[n-k+1:n]\nend", "    arr = sort(arr)\n\
    \    len = length(arr)\n    new_arr = Array{Int64}(undef, k)\n    for i in 1:k\n\
    \        new_arr[i] = arr[len-i+1]\n    end\n    return new_arr\nend", "    arr[sortperm(arr,\
    \ rev=true)[1:k]]\nend", "    return sort(arr)[end-k+1:end]\nend", "    sorted_arr\
    \ = sort(arr, rev=true)\n    return sorted_arr[1:k]\nend", "    # Check for trivial\
    \ cases\n    if k == 0\n        return Int64[]\n    elseif k == 1\n        return\
    \ [maximum(arr)]\n    elseif k == length(arr)\n        return sort(arr)\n    end\n\
    \    \n    # Pick a pivot element\n    pivot_value = arr[rand(1:length(arr))]\n\
    \    \n    # Partition array into two, with one being greater than the pivot\n\
    \    partitioned_arr = [i for i in arr if i >= pivot_value]\n    \n    # If partitioned\
    \ array length is less than k, then we want another partition\n    if length(partitioned_arr)\
    \ < k\n        return maximum(arr, k)\n    elseif length(partitioned_arr) == k\n\
    \        return sort(partitioned_arr)\n    else # length(partitioned_arr) > k\n\
    \        return maximum(partitioned_arr, k)\n    end\nend", "    \n    # Create\
    \ empty list to store the maximum numbers\n    max_list = []\n    \n    # Iterate\
    \ through arr, keeping track of the last k elements seen\n    for i in 1:length(arr)\n\
    \        # If max_list isn't full, append the current number\n        if length(max_list)\
    \ < k\n            push!(max_list, arr[i])\n        # If max_list is full\n  \
    \      else\n            # Delete the first number in max_list\n            deleteat!(max_list,\
    \ 1)\n            # If current number is larger than the first element in max_list,\
    \ replace it\n            if max_list[1] < arr[i]\n                max_list[1]\
    \ = arr[i]\n            end\n        end\n    end\n    \n    # Return the sorted\
    \ vector\n    sort(max_list)\nend", "    n = length(arr)\n    k < n && quickselect!(arr,\
    \ n, k + 1)\n    return arr[1:k]\nend", "    # YOUR CODE HERE\n    k = min(k,\
    \ length(arr))\n    res = sort(arr)[end-k+1:end]\n    return res\nend", "    n\
    \ = length(arr)\n    if k < 1\n        return []\n    end\n    if k == 1\n   \
    \     return findmax(arr)[1]\n    end\n    heap = Base.BinaryHeap{Int64}(arr[1:k])\n\
    \    for i in (k+1):n\n        if arr[i] > heap.min\n            pop!(heap)\n\
    \            push!(heap, arr[i])\n        end\n    end\n    return sort(heap,\
    \ rev=true)\nend", "    # sort the array, then reverse it and return the first\
    \ k elements\n    sort(arr)[end-k+1:end]\nend", "    copy_arr = copy(arr)\n  \
    \  arr_length = length(copy_arr)\n    sort!(copy_arr)\n    if k >= arr_length\n\
    \        return copy_arr\n    else\n        return copy_arr[arr_length-k+1:arr_length]\n\
    \    end\nend", "    # your code here\nend\n ", "    #Possible to have Vector{Any}\
    \ as well \n    #But we'd like the return type to be Int64\n    sorted_vector\
    \ = sort(arr)\n    sorted_vector[end-k+1:end]\nend", "    return sort(arr)[end-k+1:end]\n\
    end", "    # Precondition: k <= length(arr)\n    # Initialize return vector\n\
    \    k_max = fill(Int64, k)\n    # Iterate through array and insert k largest\
    \ elements into return vector\n    for i in 1:length(arr)\n        # Shift all\
    \ elements larger than current element to the right\n        shift = k\n     \
    \   for j in 1:k\n            if arr[i] > k_max[j]\n                shift = j\n\
    \                break\n            end\n        end\n        # Insert the current\
    \ element into the appropriate position\n        for j in shift:k\n          \
    \  k_max[j+1] = k_max[j]\n        end\n        k_max[shift] = arr[i]\n    end\n\
    \    return k_max\nend\n\"\"\"\n    Given an integer array arr, return an array\
    \ of length 2 consisting of arr[0] \n    (the minimum value of arr) and arr[1]\
    \ (the maximum value of arr).", "    if k == 0\n        return []\n    end\n \
    \   n = length(arr)\n    push!(arr, typemax(Int64))\n    for i in k:n\n      \
    \  j = 1\n        while j <= k\n            if arr[j] > arr[i]\n             \
    \   j += 1\n            else\n                break\n            end\n       \
    \ end\n        for l in 1:(i-j)\n            arr[i-l+1] = arr[i-l]\n        end\n\
    \        arr[j] = arr[i]\n    end\n    return arr[1:k]\nend", "    # sort array\
    \ with negative numbers in front\n    sorted_arr = sort(arr, by=x->x < 0 ? x :\
    \ -x)\n    max_k = zeros(Int64, k)\n    for i in 1:k\n        max_k[i] = sorted_arr[i]\
    \ < 0 ? -sorted_arr[i] : sorted_arr[i]\n    end\n    return max_k\nend", '    """Return
    a vector with the maximum k numbers in arr.', "    max_idx = zeros(Int64, k)\n\
    \    max_arr = zeros(Int64, k)\n    arr_length = length(arr)\n    i = 1\n    while\
    \ i <= k\n        max_arr[i] = arr[i]\n        max_idx[i] = i\n        i += 1\n\
    \    end\n    while i <= arr_length\n        x = arr[i]\n        if x > max_arr[1]\n\
    \            max_arr[1] = x\n            max_idx[1] = i\n            j = 1\n \
    \           while j <= k\n                left = 2*j\n                right =\
    \ 2*j + 1\n                if left <= k\n                    if right <= k\n \
    \                       next_j = max_arr[left] > max_arr[right] ? left : right\n\
    \                    else\n                        next_j = left\n           \
    \         end\n                    if max_arr[j] > max_arr[next_j]\n         \
    \               tmp = max_arr[j]\n                        max_arr[j] = max_arr[next_j]\n\
    \                        max_arr[next_j] = tmp\n                        tmp =\
    \ max_idx[j]\n                        max_idx[j] = max_idx[next_j]\n         \
    \               max_idx[next_j] = tmp\n                        j = next_j\n  \
    \                  else\n                        break\n                    end\n\
    \                else\n                    break\n                end\n      \
    \      end\n        end\n        i += 1\n    end\n    res = sortperm(max_idx)\n\
    \    return max_arr[res]\nend", "    heap = Heap{(Int64, Int64)}()\n    result\
    \ = Vector{Int64}(undef, k)\n    for i in 1:k\n        push!(heap, (-arr[i], i))\n\
    \    end\n    for i in k+1:length(arr)\n        _, i_max = pop!(heap)\n      \
    \  result[i_max] = arr[i_max]\n        push!(heap, (-arr[i], i))\n    end\n  \
    \  for i in 1:k\n        _, i_max = pop!(heap)\n        result[i_max] = arr[i_max]\n\
    \    end\n    return result\nend", "    ans = sort(arr[1:k], rev=true)\n    for\
    \ i = k+1:length(arr)\n        for j = 1:k\n            if arr[i] > ans[j]\n \
    \               insert!(ans, j, arr[i])\n                popfirst!(ans)\n    \
    \            break\n            end\n        end\n    end\n    return ans\nend",
  "    @assert k >= 1 && k <= length(arr)\n    arr_copy = sort(arr[1:k])\n    for\
    \ (i, val) in enumerate(arr[k + 1:end])\n        if val > arr_copy[1]\n      \
    \      arr_copy[1] = val\n            arr_copy = sort(arr_copy)\n        end\n\
    \    end\n    return arr_copy\nend", "    \n    n = length(arr)\n    @assert k\
    \ <= n\n    \n    heap = MaxHeap(arr)\n    vector = Vector{Int64}(undef, k)\n\
    \    \n    for i in 1:k\n        vector[i] = pop!(heap)\n    end\n    \n    return\
    \ vector\nend", "    # sort the array first by value\n    sorted = sort(arr)\n\
    \    # reverse the sorted array\n    sorted_reversed = sorted[end:-1:1]\n    #\
    \ return the first k elements\n    return sorted_reversed[1:k]\nend", "    n =\
    \ length(arr)\n    s = zeros(Int64, n)\n    for i in 1:n\n        s[i] = sum(abs.(arr[i:n]))\n\
    \    end\n    res = []\n    for i in 1:k\n        max_val = -Inf\n        max_ind\
    \ = -1\n        for j in 1:n\n            if s[j] > max_val && j \u2209 res\n\
    \                max_val = s[j]\n                max_ind = j\n            end\n\
    \        end\n        push!(res, max_ind)\n    end\n    return sort(arr[res])\n\
    end", "    len = length(arr)\n    if k == len\n        return sort(arr)\n    end\n\
    \    inds = sortperm(arr)[end-k+1:end]\n    return sort(arr[inds])\nend", "  \
    \  #step 1: sort the vector in descending order\n    #step 2: return the vector\
    \ of length k\n    \n    #sort the array by value\n    sorted_arr = sort(arr,\
    \ rev=true)\n    \n    #return a vector of length k\n    return sorted_arr[1:k]\n\
    \    \nend", "    n = length(arr)\n    max_arr = []\n    max_k = maximum(arr)\n\
    \    first_max = max_k\n    push!(max_arr, max_k)\n    while length(max_arr) <\
    \ k\n        max_k = first_max\n        for i in 1:n\n            if arr[i] >\
    \ max_k\n                if isless(arr[i], first_max)\n                    max_k\
    \ = arr[i]\n                end\n            end\n        end\n        push!(max_arr,\
    \ max_k)\n    end\n    sort!(max_arr)\n    return max_arr\nend", "    @assert\
    \ k <= length(arr) \"k must be less than or equal to the length of the input vector\"\
    \n    if k == 0\n        return Int64[]\n    end\n    if k == 1\n        return\
    \ [maximum(arr)]\n    end\n    if k == length(arr)\n        return sort(arr)\n\
    \    end\n    # Create a binary tree and insert all elements of arr \n    # into\
    \ the binary tree.\n    # Initialize it with the first element.\n    # Once the\
    \ binary tree has k elements, each time you insert an element\n    # do a comparison\
    \ between the new element and the root node of the binary tree.\n    # If the\
    \ new element is greater than the root node, \n    # remove the root node from\
    \ the binary tree\n    # and insert the new element in the binary tree.\n    #\
    \ If the new element is not greater than the root node,\n    # simply insert the\
    \ new element in the binary tree.\n    root = MaxTreeNode(arr[1])\n    for i in\
    \ 2:length(arr)\n        if i <= k\n            tree_insert!(root, MaxTreeNode(arr[i]))\n\
    \        else\n            if arr[i] > root.val\n                root = tree_delete_max!(root)\n\
    \                tree_insert!(root, MaxTreeNode(arr[i]))\n            else\n \
    \               tree_insert!(root, MaxTreeNode(arr[i]))\n            end\n   \
    \     end\n    end\n    # Finally, do an in-order traversal of the binary tree\n\
    \    # to get a sorted array of length k.\n    tree_traverse_inorder(root)\nend",
  "    \n    # Sort array with insertion sort algorithm\n    @inbounds for i = 2:length(arr)\n\
    \        key = arr[i]\n        j = i - 1\n        while j >= 1 && arr[j] > key\n\
    \            arr[j + 1] = arr[j]\n            j -= 1\n        end\n        arr[j\
    \ + 1] = key\n    end\n    \n    arr[1:k]\nend", "    n = length(arr)\n    max_heap\
    \ = MaxHeap()\n    for i in 1:n\n        if i <= k\n            push!(max_heap,\
    \ arr[i])\n        else\n            x = get_max!(max_heap)\n            if x\
    \ < arr[i]\n                push!(max_heap, arr[i])\n            else\n      \
    \          push!(max_heap, x)\n            end\n        end\n    end\n    res\
    \ = Int64[]\n    for i in 1:k\n        push!(res, get_max!(max_heap))\n    end\n\
    \    return res\nend", "    \"\"\"\n    Given a vector arr of integers and a positive\
    \ integer k, return a sorted vector \n    of length k with the maximum k numbers\
    \ in arr.", "    \n    sort!(arr)\n    arr[end-k+1:end]\nend", "    if length(arr)\
    \ == k\n        return sort(arr)\n    end\n    # min in Julia is for minimum\n\
    \    min_heap = BinomialHeap()\n    for val in arr\n        insert!(min_heap,\
    \ val)\n        if length(min_heap) > k\n            extract!(min_heap)\n    \
    \    end\n    end\n    return to_array(min_heap)\nend", "    heap = BinaryHeap()\n\
    \    for num in arr\n        push!(heap, num)\n        if length(heap) > k\n \
    \           pop!(heap)\n        end\n    end\n    return sort(collect(heap))\n\
    end", "    \n    # Sort and select the maximum k elements \n    index = sortperm(arr)\n\
    \    final_arr = zeros(Int64, k)\n    for i in 1:k\n        final_arr[i] = arr[index[end\
    \ - i + 1]]\n    end\n    return final_arr\nend", "    length = Int64(minimum(k,\
    \ length(arr)))\n    output = Vector{Int64}(length)\n    for i in 1:length\n \
    \       output[i] = Int64(minimum(arr))\n        pop!(arr, findmin(arr)[2])\n\
    \    end\n    sort!(output)\n    return output\nend", "    #############################################################\n\
    \    ########### DO NOT MODIFY THE CODE BELOW THIS LINE ##########\n    #############################################################\n\
    \    n = length(arr)\n    heap = BinomialHeap()\n    for i in 1:n\n        push!(heap,\
    \ arr[i])\n    end\n    for i in 1:n-k\n        pop!(heap)\n    end\n    res =\
    \ Array{Int64}(k)\n    for i in 1:k\n        res[i] = pop!(heap)\n    end\n  \
    \  return res\nend", "    \n    N = length(arr)\n    arr = sort(arr, rev=true)\n\
    \    return arr[1:k]\nend", "    n = length(arr)\n    # put maximum integers in\
    \ front, minimum in back.\n    qsort!(arr, 1, n)\n    arr[1:k]\nend", "    heap\
    \ = MaxHeap()\n    push!(heap, arr[1:k])\n    for i in k+1:length(arr)\n     \
    \   if arr[i] > heap[1]\n            pop!(heap)\n            push!(heap, arr[i])\n\
    \        end\n    end\n    return sort(heap, rev=true)\nend\n ", "    arr_sorted\
    \ = sort(arr)\n    return reverse(arr_sorted[1:k])\nend", "    return sort(arr)[end-k+1:end]\n\
    end", "    sort(arr, rev=true)[1:k]\nend", "    @assert k <= length(arr) \"k cannot\
    \ be greater than length of array\"\n    arr_copy = copy(arr)\n    for i = 1:k\n\
    \        index = i\n        for j = i+1:length(arr_copy)\n            if arr_copy[j]\
    \ > arr_copy[index]\n                index = j\n            end\n        end\n\
    \        arr_copy[i], arr_copy[index] = arr_copy[index], arr_copy[i]\n    end\n\
    \    return arr_copy[1:k]\nend", "    # TODO\nend", "    sorted_arr = sort(arr)\n\
    \    i = k\n    while i <= length(sorted_arr) && sorted_arr[i] == sorted_arr[k]\n\
    \        i += 1\n    end\n    return sorted_arr[k:i-1]\nend", "    # return maximum(arr,\
    \ k)\n    # ordered = sort(arr)\n    # return ordered[1:k]\n    return sort(arr)[1:k]\n\
    end", "    # your code goes here\n    n = length(arr)\n    sort!(arr)\n    k ==\
    \ n ? arr : arr[end-k+1:end]\nend", "    # sort the vector using the built-in\
    \ merge sort\n    sort!(arr)", "    pq = MaxHeap{Int64}()\n    for (i, a) in enumerate(arr)\n\
    \        if i < k\n            push!(pq, a)\n        else\n            peek(pq)\
    \ < a && replace!(pq, 1, a)\n        end\n    end\n    sort(collect(pq))\nend",
  "    # Take a collection of values and return the top `k` values.\n    # Sort the\
    \ array.\n    # Grab the last k items.\n    # Return that array of values.\n \
    \   sort(arr)[end - k + 1:end]\nend", "    heap = Heap{Int64}()\n    for i in\
    \ 1:length(arr)\n        if length(heap) < k\n            push!(heap, arr[i])\n\
    \        elseif arr[i] > peek(heap)\n            pop!(heap)\n            push!(heap,\
    \ arr[i])\n        end\n    end\n    heap_to_vector(heap)\nend", "    n = length(arr)\n\
    \    if k == n\n        return arr\n    end\n    temp = Vector{Int64}(k)\n   \
    \ copy!(temp, arr[1:k])\n    sort!(temp)\n    j = 1\n    for i in (k+1):n\n  \
    \      if arr[i] > temp[j]\n            temp[j] = arr[i]\n            sort!(temp)\n\
    \            j = 1\n        elseif arr[i] < temp[j]\n            j += 1\n    \
    \    end\n    end\n    return temp\nend", "    # this is an example of a min priority\
    \ queue which uses a min heap to pop \n    # the smallest item\n    # https://github.com/JuliaCollections/PriorityQueues.jl/blob/master/src/PriorityQueues.jl\n\
    \    # an example of a max priority queue, I'd just reverse the compare function\n\
    \    # https://github.com/JuliaCollections/PriorityQueues.jl/blob/master/test/test_priority_queue.jl\n\
    \    # could also just sort the array and return the k last elements\n    # https://docs.julialang.org/en/v1/base/sort/#Base.sort-Tuple{AbstractArray{T,1}\
    \ where T}"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
