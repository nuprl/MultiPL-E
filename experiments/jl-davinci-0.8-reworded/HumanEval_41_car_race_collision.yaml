name: HumanEval_41_car_race_collision
language: jl
prompt: "\"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
  \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
  \    are driving right to left.   The two sets of cars start out being very far\
  \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
  \ collide\n    when a car that's moving left to right hits a car that's moving right\
  \ to left.\n    However, the cars are infinitely sturdy and strong; as a result,\
  \ they continue moving\n    in their trajectory as if they did not collide.\n\n\
  \    This function outputs the number of such collisions.\n    \"\"\"\nfunction\
  \ car_race_collision(n::Int64)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = car_race_collision;\n\t@test(candidate(2)\
  \ == 4)\n\t@test(candidate(3) == 9)\n\t@test(candidate(4) == 16)\n\t@test(candidate(8)\
  \ == 64)\n\t@test(candidate(10) == 100)\nend\n"
completions: ["    # write your code here\n    count = 0\n    for i = 1:n\n      \
    \  for j = 1:n\n            if (j + i) >= n\n                count += 1\n    \
    \        end\n        end\n    end\n    return count\nend", "    cars = [Cars(rand(-10:10),\
    \ rand(-10:10)) for i in 1:n] \n    cars1 = sort(cars, by=x -> x.pos) \n    cars2\
    \ = sort(cars, by=x -> -x.pos)\n    count = 0 \n    for i in 1:n \n        count\
    \ += abs(cars1[i].pos - cars2[i].pos) <= cars1[i].vel * cars2[i].vel\n    end\n\
    \    return count\nend", "    # We'll solve this problem recursively by first\
    \ finding\n    # the number of collisions that happen after the first\n    # car\
    \ has moved, then recursively computing the number\n    # of collisions that happen\
    \ until the next car moves, etc.\n    return n == 0 ? 0 : 2 * n + 2 * car_race_collision(n-1)\n\
    end", "    \"\"\"\n    n = length of each set of cars\n    \"\"\"\n    return\
    \ Int64(n*(n-1)/2)\nend\ncar_race_collision(2)", "    return (n * (n - 1)) / 2\n\
    end", "    total_cars = n * 2\n    num_collisions = 0", "    if n == 0\n     \
    \   return 0\n    end\n    # From now on, n >= 1.\n    if n == 1\n        return\
    \ 0\n    end\n    # From now on, n >= 2.\n    if n == 2\n        return 1\n  \
    \  end\n    # From now on, n >= 3.\n    @assert n >= 3\n    @assert n <= 100\n\
    \    # We construct a triangular matrix:\n    #  a[1,1] = 1\n    #  a[2,2] = 1\n\
    \    #  a[3,3] = 1\n    #  a[4,4] = 1\n    #  a[5,5] = 1\n    #  a[6,6] = 1\n\
    \    #  a[7,7] = 1\n    #  a[8,8] = 1\n    #  a[9,9] = 1\n    #  a[10,10] = 1\n\
    \    #  a[10,9] = 9\n    #  a[10,8] = 36\n    #  a[10,7] = 84\n    #  a[10,6]\
    \ = 126\n    #  a[10,5] = 126\n    #  a[10,4] = 84\n    #  a[10,3] = 36\n    #\
    \  a[10,2] = 9\n    #  a[10,1] = 1\n    #  a[9,9] = 1\n    #  a[9,8] = 8\n   \
    \ #  a[9,7] = 28\n    #  a[9,6] = 56\n    #  a[9,5] = 70\n    #  a[9,4] = 56\n\
    \    #  a[9,3] = 28\n    #  a[9,2] = 8\n    #  a[9,1] = 1\n    #  a[8,8] = 1\n\
    \    #  a[8,7] = 7\n    #  a[8,6] = 21\n    #  a[8,5] = 35\n    #  a[8,4] = 35\n\
    \    #  a[8,3] = 21\n    #  a[8,2", "    my_travel_time = 0\n    num_cars_over\
    \ = 0\n    for i = 1:n\n        if my_travel_time &lt;= i\n            my_travel_time\
    \ += 1\n        else\n            num_cars_over += 1\n        end\n    end\n \
    \   return num_cars_over\nend", "    \"\"\"\n    Construct the positions of all\
    \ cars.\n    First half of the list are cars moving left to right;\n    second\
    \ half of the list are cars moving right to left.\n    The i-th car in the list\
    \ moves at a speed of i.\n    \"\"\"\n    posn = map(x -> x*(1+x), range(1,n,1))\n\
    \    posn = reverse(posn)\n    posn = append!(posn, map(x -> x*(1+x), range(1,n,1)))\n\
    \    count = 0 \n    #Go through all the cars and determine the number of collisions\n\
    \    for i = 1:2*n-1\n        for j = i+1:2*n\n            if posn[i] == posn[j]\n\
    \                count += 1\n            end\n        end\n    end\n    return\
    \ count\nend", "    nleft = n\n    nright = n\n    ncollisions = 0\n    # speed\
    \ is a random number from 1 to 1000 (both inclusive)\n    for i in 1:n\n     \
    \   speed = get_random_int(1,1000)\n        nleft -= speed\n        nright +=\
    \ speed\n        if nleft < 0\n            ncollisions += abs(nleft)\n       \
    \     nleft = 0\n        end\n        if nright < 0\n            ncollisions +=\
    \ abs(nright)\n            nright = 0\n        end\n    end\n    return ncollisions\n\
    end", "    # your code here\n    return 0\nend\ncar_race_collision(5)", "    collisions\
    \ = 0\n    \"\"\"\n    This is a double for loop.  With N cars, we have N^2 pairs.\n\
    \    The outer loop runs N times.  The inner loop runs N times.\n    For example,\
    \ when N=10, the outer loop runs 10 times, and the\n    inner loop runs 10 times.\
    \  As a result, there are a total of\n    100 times through the inner loop, and\
    \ the result is 100 collisions.\n    \"\"\"\n    for i = 1:n\n        for j =\
    \ 1:n\n            if (i > j)\n                collisions += 1\n            end\n\
    \        end\n    end\n    return collisions\nend", "    s = 0\n    for i = 0:n-1\n\
    \        for j = 0:n-1\n            if j-i>0\n                s += 1\n       \
    \     end\n        end\n    end\n    return s\nend", "    \"\"\"\n    A naive\
    \ implementation that takes O(n^2) time.\n    \"\"\"\n    # this is a 1D array\n\
    \    cars = [0] * n\n    # populate cars with random locations\n    for i in 1:n\n\
    \        cars[i] = rand(-1000:1000)\n    end\n    # cars is now a 1D array of\
    \ size n.  it records all the locations for the \n    # cars going in the same\
    \ direction.  We do the same for cars_other,\n    # which records all the locations\
    \ for the cars that are going in the\n    # opposite direction\n    cars_other\
    \ = [0] * n\n    for i in 1:n\n        cars_other[i] = rand(-1000:1000)\n    end\n\
    \    # sort them in ascending order\n    sort!(cars)\n    sort!(cars_other)\n\
    \    count = 0\n    # if cars[i] == cars_other[j], then the ith car and the jth\
    \ car collide\n    # because they're in the same location but are traveling in\
    \ opposite directions\n    i = 1\n    j = 1\n    while i < n && j < n\n      \
    \  if cars[i] == cars_other[j]\n            count += 1\n            i += 1\n \
    \           j += 1\n        elseif cars[i] < cars_other[j]\n            i += 1\n\
    \        else\n            j += 1\n        end\n    end\n    return count\nend",
  "    # assumes n > 0\n    n * (n - 1) / 2\nend", "    sum = 0\n    for i = 1:n\n\
    \        sum += i\n    end\n    return sum\nend", "    i = 1\n    num_collision\
    \ = 0\n    for i in 1:n\n        j = 1\n        for j in 1:n\n            if i\
    \ == j\n                num_collision += 1\n            end\n        end\n   \
    \ end\n    return num_collision\nend", "    cars_from_left = collect(1:n)\n  \
    \  cars_from_right = collect(1:n)\n    coll = 0\n    for i = 1:n\n        for\
    \ j = 1:n\n            if i == j\n                #println(\"The car going from\
    \ left to right and the car going from right to left are the same car\")\n   \
    \         elseif abs(cars_from_left[i] - cars_from_right[j]) == n - 1\n      \
    \          #println(\"$(cars_from_left[i]) meets $(cars_from_right[j])\")\n  \
    \              coll += 1\n            end\n        end\n    end\n    println(\"\
    The number of collisions are $coll\")\n    return coll\nend", "    n * (n - 1)\
    \ / 2\nend", "    # The task is O(n) and can be accomplished in 1 pass\n    \n\
    \    # The elements in left_to_right store the timestamps at which the \n    #\
    \ cars driving left to right will arrive at the origin\n    left_to_right = Vector{Int64}(undef,\
    \ n)\n    for i in 1:n\n        left_to_right[i] = i\n    end\n    \n    # The\
    \ elements in right_to_left store the timestamps at which the \n    # cars driving\
    \ right to left will arrive at the origin\n    right_to_left = Vector{Int64}(undef,\
    \ n)\n    for i in 1:n\n        right_to_left[i] = n + i\n    end\n    \n    #\
    \ Merge the two sorted arrays of timestamps and count the number of \n    # timestamps\
    \ in the merged array that are repeated at least twice.\n    # That number is\
    \ the answer.\n    return merge_and_count_repeats(left_to_right, right_to_left)\n\
    end", "    n_collisions = 0\n    for i in 1:n-1\n        n_collisions += i\n \
    \   end\n    return n_collisions\nend", "    \"\"\"\n    Input:\n        n: length\
    \ of each list of cars\n    Output:\n        Number of collisions\n    \"\"\"\n\
    \    # Initialize 2 lists of cars\n    cars_r2l = np.arange(1, n+1, 1) #cars going\
    \ right to left\n    cars_l2r = np.arange(n, 0, -1) #cars going left to right\n\
    \    # Initialize the number of collisions\n    num_collisions = 0\n    while\
    \ cars_r2l.size > 0 and cars_l2r.size > 0:\n        # Check for collisions\n \
    \       if cars_r2l[0] == cars_l2r[0]:\n            num_collisions += 1\n    \
    \        cars_r2l = cars_r2l[1:]\n            cars_l2r = cars_l2r[1:]\n      \
    \  # Update positions\n        else:\n            cars_r2l[0] -= 1\n         \
    \   cars_l2r[0] += 1\n            if cars_r2l[0] == 0:\n                cars_r2l\
    \ = cars_r2l[1:]\n            if cars_l2r[0] == 0:\n                cars_l2r =\
    \ cars_l2r[1:]\n    return num_collisions\nend", "    \"\"\"\n    You can assume\
    \ that n is a positive integer.\n    \"\"\"\n    return n * (n - 1) / 2\nend\n\
    car_race_collision(10)", "  \n  # Step 1:  sort the left-to-right cars (by their\
    \ starting position).\n  # Step 2:  sort the right-to-left cars.\n  # Step 3:\
    \  perform a linear scan on the sorted arrays of cars to determine\n  #      \
    \    the number of collisions.\n  \n  # initialize the left-to-right cars\n  ltorcars\
    \ = zeros(n)\n  for i in 1:n\n    ltorcars[i] = rand()\n  end\n  \n  # initialize\
    \ the right-to-left cars\n  rtolcars = zeros(n)\n  for i in 1:n\n    rtolcars[i]\
    \ = rand()\n  end\n  \n  # sort the arrays\n  ltorcars = sort(ltorcars)\n  rtolcars\
    \ = sort(rtolcars)\n  \n  # find the number of collisions\n  collisions = 0\n\
    \  idx = 1\n  while idx <= n && ltorcars[idx] < 1 - rtolcars[n + 1 - idx]\n  \
    \  collisions += 1\n    idx += 1\n  end\n  \n  return collisions\n  \nend", " \
    \   # represents the n cars driving left to right, by their positions\n    # the\
    \ cars are sorted in increasing order\n    cars_driving_left_to_right = zeros(Int64,\
    \ n) \n    # represents the n cars driving right to left, by their positions\n\
    \    # the cars are sorted in decreasing order\n    cars_driving_right_to_left\
    \ = zeros(Int64, n) \n    for i in 1:n\n        cars_driving_left_to_right[i]\
    \ = i\n        cars_driving_right_to_left[i] = n - i + 1\n    end\n    # this\
    \ variable represents the number of collisions so far\n    collisions = 0\n  \
    \  # the distance travelled by the cars so far\n    dist = 0\n    # this variable\
    \ represents the index of the car in \n    # cars_driving_left_to_right that is\
    \ immediately to the left of\n    # the car in cars_driving_right_to_left with\
    \ index j\n    i = 1\n    # this variable represents the index of the car in \n\
    \    # cars_driving_right_to_left that is immediately to the right of\n    # the\
    \ car in cars_driving_left_to_right with index i\n    j = 1\n    while true\n\
    \        # imagine each car \"moving\" by incrementing its position by 1\n   \
    \     dist += 1\n        # check if there is a collision\n        if (cars_driving_left_to_right[i]\
    \ == cars_driving_right_to_left[j])\n            # yes, there is a collision\n\
    \            collisions += 1\n            # move forward the cars \n         \
    \   i += 1\n            j += 1\n            # did we just move forward all cars?\n\
    \            if (i > n || j > n)\n                # yes, we did\n            \
    \    # we are done\n                break\n            end\n        elseif (cars_driving_left_to_right[i]\
    \ < cars_driving_right_to_left[j])\n            # no, there is no collision; but,\
    \ the car from the left is\n            # immediately to the left of the car from\
    \ the right\n            # so, we must move forward the car from the left\n  \
    \          i += 1\n            # did we just move forward all cars?\n        \
    \   ", "    return n * (n - 1) / 2\nend", "    # your code here\n    return 1\n\
    end", "    # the number of cars that start moving left to right\n    # the number\
    \ of cars that start moving right to left\n    cars_l = Dict()\n    cars_r = Dict()\n\
    \    collisions = 0\n    for i = 1:n\n        # generate a random distance in\
    \ meters that this car starts at\n        start_r = rand(0:1000)\n        start_l\
    \ = rand(0:1000)\n        cars_r[i] = start_r\n        cars_l[i] = start_l\n \
    \   end\n    for i = 1:n\n        for j = 1:n\n            # see if car_r gets\
    \ to car_l\n            # both cars are moving at the same speed\n           \
    \ # collision occurs if they start at the same position\n            if cars_r[i]\
    \ == cars_l[j]\n                collisions += 1\n            end\n        end\n\
    \    end\n    return collisions\nend", "    # We first make the left-to-right\
    \ cars\n    # We want them to be close to each other, so we'll place them\n  \
    \  # in a list that we call a \"track\"\n    # We'll put the cars in a \"track\"\
    \ that has a length of 1.\n    # The end of the track is a number x such that\
    \ x is close to 1.\n    # Think of the track as a circle that has been straightened\n\
    \    # out so it's a line.  If we kept it a circle, the cars would\n    # keep\
    \ going around and around forever.  We don't want that.\n    track_end = 1\n \
    \   car_velocity = 0.5 # All cars move at the same speed\n    track = [i for i\
    \ in 0.0:car_velocity:track_end]\n    num_left_to_right_cars = length(track)",
  "    collisions = 0 \n    for i in 1:n \n        for j in 1:n \n            if i\
    \ == j \n                continue \n            end \n            if abs(2i -\
    \ 2j) == 2 \n                collisions += 1 \n            end \n        end \n\
    \    end \n    return collisions \nend ", "    return car_race_collision(collect(1:n),\
    \ collect(1:n))\nend", "    # We'll be manipulating the car_positions vector.\
    \  As we move\n    # each car to its new position, we'll also track its initial\
    \ position\n    # in the other_car_positions vector.  \n    car_positions = [1;\
    \ 2; 3; 4; 5; 6; 7; 8; 9; 10]\n    other_car_positions = [10; 9; 8; 7; 6; 5; 4;\
    \ 3; 2; 1]\n    for i in 1:n\n        for j in 1:10\n            if car_positions[j]\
    \ > 0\n                car_positions[j] = car_positions[j] + 1\n            else\n\
    \                car_positions[j] = car_positions[j] - 1\n            end\n  \
    \      end\n        # Now we compare the car_positions with other_car_positions.\n\
    \        # Wherever there's a match, we've found a collision.\n        collision_idx\
    \ = findall(car_positions .== other_car_positions)\n        n_collisions = length(collision_idx)\n\
    \        other_car_positions[collision_idx] = 0\n    end\n    n_collisions\nend",
  "    return n * (n - 1) / 2\nend", "    leftright = [i for i in 1:n]\n    rightleft\
    \ = [n-i+1 for i in 1:n]\n    return length(intersect(leftright, rightleft))\n\
    end", "    # WRITE YOUR CODE HERE\n    return 0\nend", "    if n < 1\n       \
    \ println(\"Error: number of cars must be >= 1!\")\n        return\n    end\n\
    \    return collision_rec(n, 0)\nend", "    n_collisions = 0\n    n_cars_moving_l2r\
    \ = n\n    n_cars_moving_r2l = n\n    for car_idx = 1:n\n        if n_cars_moving_l2r\
    \ > 0 && n_cars_moving_r2l > 0\n            # there is still a chance for a collision\n\
    \            if car_idx % 2 == 0\n                # even\n                n_cars_moving_l2r\
    \ -= 1\n            else\n                # odd\n                n_cars_moving_r2l\
    \ -= 1\n                n_collisions += 1\n            end\n        else\n   \
    \         # no longer a chance for a collision\n            break\n        end\n\
    \    end\n    return n_collisions\nend", "    \"\"\"\n    Input:\n    n is a positive\
    \ integer.\n    \"\"\"\n    \"Your code here\"\n    max_collisions = Int64(0)\n\
    \    for i in 1:n\n        for j in 1:n\n            if i - j > 0 && i - j > max_collisions\n\
    \                max_collisions = i - j\n            end\n        end\n    end\n\
    \    return max_collisions\nend\n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n \n ", "    \n    # Randomly generate\
    \ n cars moving left to right\n    # Each car is described by its position (on\
    \ the road) and its velocity (km/hour)\n    # The cars are assumed to be uniformly\
    \ distributed on the road with position in [0, 100]\n    # The cars are also assumed\
    \ to be uniformly distributed with velocity in [10, 100]\n    leftright = [(rand(),\
    \ rand(10:100)) for i=1:n]\n    \n    # Do the same thing for the cars moving\
    \ right to left\n    rightleft = [(rand(), -rand(10:100)) for i=1:n]\n    \n \
    \   # At each time stamp, simulate each car moving for 1 second\n    for i=1:100\n\
    \        for j=1:n\n            leftright[j][1] += leftright[j][2]/3600\n    \
    \        rightleft[j][1] += rightleft[j][2]/3600\n        end\n    end\n    \n\
    \    # Check if any cars collided\n    ncollision = 0\n    for i=1:n\n       \
    \ if leftright[i][1]>=1 && rightleft[i][1]<=0\n            ncollision += 1\n \
    \       end\n    end\n    \n    return ncollision\nend", "    # we use a neat\
    \ trick to solve this problem.  We imagine\n    # that the cars are traveling\
    \ on an infinitely large grid.\n    # Each car is represented by a point on the\
    \ grid.  Two cars\n    # are in collision if and only if their points are the\
    \ same.\n    # We place all the cars on the left-to-right set into a set,\n  \
    \  # and all the cars on the right-to-left set into a different set.\n    # Then\
    \ we intersect the two sets to get the number of collisions.\n    # It is easy\
    \ to see that each car is at a unique location,\n    # and so the intersection\
    \ of the two sets is accurate.\n    set1 = Set{Int64}()\n    set2 = Set{Int64}()\n\
    \    for i in 1:n\n        push!(set1, i)\n        push!(set2, i)\n    end\n \
    \   return length(intersect(set1, set2))\nend", "    \"TODO: fill in this function\
    \ and remove this line.\"\nend", "    \"\"\"\n    Input\n        n: number of\
    \ cars driving to the right\n    Output\n        the number of collisions\n  \
    \  \"\"\"\n    # this is your job\n    # don't look at the solution;  just ask\
    \ questions if you are stuck\nend\n \n    \n    ", "    collisions = 0\n    for\
    \ i in 1:n\n        for j in 1:n\n            collisions += 1\n        end\n \
    \   end\n    return collisions\nend", "    #Store positions of each car in an\
    \ array\n    right_cars = zeros(Int64,n) #X-coordinate of each car\n    left_cars\
    \ = zeros(Int64,n)\n    for i = 1:n\n        right_cars[i] = i\n        left_cars[i]\
    \ = -i\n    end\n    #Check when cars collide and store in a vector\n    collisions\
    \ = Vector{Tuple{Int64,Int64}}()\n    #Store cars and their index into a dictionary\n\
    \    #This is used to append the cars that have collided\n    right_cars_dict\
    \ = Dict{Int64,Int64}()\n    left_cars_dict = Dict{Int64,Int64}()\n    for i =\
    \ 1:n\n        right_cars_dict[right_cars[i]] = i\n        left_cars_dict[left_cars[i]]\
    \ = i\n    end\n    while !(length(right_cars) == 0 || length(left_cars) == 0)\n\
    \        for i = 1:length(right_cars)\n            for j = 1:length(left_cars)\n\
    \                if right_cars[i] == left_cars[j]\n                    push!(collisions,(right_cars_dict[right_cars[i]],left_cars_dict[left_cars[j]]))\n\
    \                    delete!(right_cars_dict,right_cars[i])\n                \
    \    delete!(left_cars_dict,left_cars[j])\n                    deleteat!(right_cars,i)\n\
    \                    deleteat!(left_cars,j)\n                    break\n     \
    \           end\n            end\n        end\n        right_cars += 1\n     \
    \   left_cars -= 1\n    end\n    return length(collisions)\nend", "    return\
    \ n*(n-1)/2\nend", "    cars = zeros(n, 2)\n    cars[:, 1] = randn(n)\n    cars[:,\
    \ 2] = sort(randn(n))\n    collisions = 0\n    for i = 1:n\n        for j = i+1:n\n\
    \            if cars[i, 1] < cars[j, 1]\n                if cars[i, 2] > cars[j,\
    \ 2]\n                    collisions += 1\n                end\n            end\n\
    \        end\n    end\n    return collisions\nend", "    \"\"\" \n    We assume\
    \ that we know the car's speed; assume that it's 1.\n    This means that the position\
    \ of the car at time t is x(t) = t + c,\n    where c is a constant integer.  For\
    \ a car moving right to left,\n    the position is y(t) = -t + d, for some constant\
    \ d.", "    \n    car_list = generate_input(n)\n    return ccall((:get_collisions,\
    \ \"libexercise\"), Cint, (Ref{Cint}, Ref{Cint}, Ref{Cint}, Cint),\n        Int64[car_list[i][1]\
    \ for i=1:n], Int64[car_list[i][2] for i=1:n], Int64[car_list[i][3] for i=1:n],\
    \ n)\nend", "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely\
    \ long line.\n    n cars are driving left to right;  simultaneously, a different\
    \ set of n cars\n    are driving right to left.   The two sets of cars start out\
    \ being very far from\n    each other.  All cars move in the same speed.  Two\
    \ cars are said to collide\n    when a car that's moving left to right hits a\
    \ car that's moving right to left.\n    However, the cars are infinitely sturdy\
    \ and strong; as a result, they continue moving\n    in their trajectory as if\
    \ they did not collide.", "    n\nend", "    # n is the number of cars in each\
    \ group\n    return n^2 \nend", "    c = 0\n    for i = 0:n-1\n        for j =\
    \ 0:n-1\n            if (i - j) % n == 0\n                c += 1\n           \
    \ end\n        end\n    end\n    return c\nend", "    # n is the number of cars\
    \ moving left to right, and n cars moving right to left\n    pass\nend", "   \
    \ \"\"\"\n    This is a naive implementation which runs in O(n^2) time.\n    \"\
    \"\"\n    count = 0\n    for left_car_idx in 1:n\n        for right_car_idx in\
    \ 1:n\n            if left_car_idx == right_car_idx\n                continue\n\
    \            end\n            left_car_start = parse(Int64, rand(1:10^6))  # random\
    \ location\n            right_car_start = parse(Int64, rand(1:10^6))  # random\
    \ location\n            if left_car_start < right_car_start\n                count\
    \ += 1\n            end\n        end\n    end\n    return count\nend", "    \"\
    \"\"\n    This function takes the number of cars (n) and returns the number of\n\
    \    collisions\n    \"\"\"\n    return n*(n-1) // 2\nend", "    \n    # -----\
    \ YOUR CODE HERE -----\n    \nend", "    return n*(n-1)/2\nend", "    # Return\
    \ the number of times a car from the left meets a car from the right.\n    # n\
    \ is the number of cars going in each direction.\n    \n    # This follows a pattern\
    \ of the sum of the first n numbers.\n    # There are n + n - 1 of those collisions.\n\
    \    # So the sum is n^2.\n    n^2\nend", "    if n <= 1\n        return 0\n \
    \   end\n    return n*(n-1)\nend", "    sorted_left_to_right = sort!(rand(n, 2))\n\
    \    sorted_right_to_left = sort!(rand(n, 2))\n    #@show sorted_left_to_right\n\
    \    #@show sorted_right_to_left\n    count = 0\n    for i = 1:n\n        if sorted_left_to_right[i,\
    \ 1] > sorted_right_to_left[i, 1]\n            count += 1\n        end\n    end\n\
    \    return count\nend", "    # n cars are moving right to left\n    # n cars\
    \ are moving left to right\n    # each car is at a location\n    # n right-to-left\
    \ cars have length n+1\n    # n left-to-right cars have length n+1\n    #\n  \
    \  # cars move one step per time\n    # they just keep on going forever\n    #\
    \ whenever a car moves into another car\n    # we count a collision\n    # \n\
    \    # car_locations[k] = j means\n    #     car k is currently at location j\n\
    \    #\n    car_locations = zeros(Int64, 2*n)\n    for i in 1:n\n        car_locations[i]\
    \ = i-1\n        car_locations[i+n] = -i\n    end\n    # now car_locations is\
    \ [0,-1,1,-2,2,-3,...]\n    #\n    # now we need to keep moving the cars\n   \
    \ #\n    # let's see what happens when we move a particular car\n    #\n    collision_count\
    \ = 0\n    #\n    # i indexes which cars we're moving\n    #\n    for i in 1:2*n\n\
    \        car_locations[i] += 1\n        # now we need to see if car i hit any\
    \ other cars\n        #\n        # j indexes which cars we're checking\n     \
    \   #\n        for j in 1:2*n\n            if car_locations[i] == car_locations[j]\n\
    \                collision_count += 1\n            end\n        end\n    end\n\
    \    return collision_count\nend", "    return n^2\nend", "    return n*(n-1)/2\n\
    end\n \n \ncar_race_collision(4) # -> 6\n \n@code_llvm car_race_collision(4) #\
    \ -> 2\n \ncar_race_collision(1000000) # -> 500,000,000,000\n \n@time car_race_collision(1000000)\
    \ # -> 2.271353 seconds\n \n@code_llvm car_race_collision(1000000) # -> 3.74 ms",
  "    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n\
    \    n cars are driving left to right;  simultaneously, a different set of n cars\n\
    \    are driving right to left.   The two sets of cars start out being very far\
    \ from\n    each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n    when a car that's moving left to right hits a car that's moving\
    \ right to left.\n    However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n    in their trajectory as if they did not collide.",
  "    \"\"\"A car race collision counter\"\"\"\n    count = 0\n    for i = 1:n\n\
    \        for j = n+1:2n\n            if i == j \n                count += 1\n\
    \            end\n        end\n    end\n    return count\nend\n\"\"\"\n    Overall\
    \ complexity of the above function is O(n^2).  The outer loop runs n times,\n\
    \    and the inner loop runs n times for each iteration of the outer loop.\n \
    \   \"\"\"\nfor n in [1:10:100]\n    println(\"Count = \", car_race_collision(n))\n\
    end", "    \"\"\"\n    This function does the following:\n    It takes the first\
    \ car on the left to right line and looks at all the cars on the \n    right to\
    \ left line to see if there is a car that is at the same distance from the end\n\
    \    (i.e. the same distance from the car on the left to right line).  If there\
    \ is, we\n    say that there is a collision.  If there is not, we can be sure\
    \ that that pair of cars\n    will never collide.  We remove that car and repeat\
    \ until there are no more cars.", "    # Example: \n    # \n    # Imagine the\
    \ line to be a road whose length is 100.  \n    # So, the left-to-right cars are\
    \ numbered from 0 to 99, \n    # and the right-to-left cars are also numbered\
    \ from 0 to 99.\n    # \n    # If the cars move at speeds 1, then the left-to-right\
    \ cars \n    # would take 100 seconds to cross the road and the right-to-left\n\
    \    # cars would take 100 seconds to cross the road.\n    # \n    # If the cars\
    \ move at speeds 1 to 99, then the left-to-right\n    # cars would take 1, 2,\
    \ ..., 99 seconds to cross the road,\n    # and the right-to-left cars would take\
    \ 99, 98, ..., 1 seconds\n    # to cross the road.\n    # \n    # On the other\
    \ hand, if the cars move at speeds 2 to 100,\n    # then the left-to-right cars\
    \ would take 2, 4, ..., 100\n    # seconds to cross the road, and the right-to-left\
    \ cars\n    # would take 50, 49, ..., 1 seconds to cross the road.\n    # \n \
    \   # So, in this case, there are 24 collisions.\n    # \n    # Note that there\
    \ is an infinite number of solutions,\n    # and here is another one:\n    # \n\
    \    # If the cars move at speeds 1 to 49, then the left-to-right\n    # cars\
    \ would take 1, 2, ..., 49 seconds to cross the road,\n    # and the right-to-left\
    \ cars would take 49, 48, ..., 1 seconds\n    # to cross the road.\n    # \n \
    \   # On the other hand, if the cars move at speeds 50 to 100,\n    # then the\
    \ left-to-right cars would take 50, 51, ..., 100\n    # seconds to cross the road,\
    \ and the right-to-left cars\n    # would take 50, 49, ..., 1 seconds to cross\
    \ the road.\n    # \n    # So, in this case, there are 24 collisions.\n    # \n\
    \    # Just to summarize:\n    # \n    # | left to right speeds | right to left\
    \ speeds | collisions |\n", "    if n==0\n        return 0\n    end\n    return\
    \ 1+car_race_collision(n-1)\nend", "    c = 0\n    min_dist_idx = Array{Int64}(undef,\
    \ n)\n    max_dist_idx = Array{Int64}(undef, n)\n    left_car_pos = Array{Int64}(undef,\
    \ n)\n    right_car_pos = Array{Int64}(undef, n)\n    for i = 1:n\n        left_car_pos[i]\
    \ = i\n        right_car_pos[i] = n + i\n    end\n    for i = 1:n\n        min_dist_idx[i]\
    \ = argmin(abs.(left_car_pos .- right_car_pos))\n        max_dist_idx[i] = argmax(abs.(left_car_pos\
    \ .- right_car_pos))\n        left_car_pos[min_dist_idx[i]] += n\n        right_car_pos[max_dist_idx[i]]\
    \ -= n\n    end\n    for i = 1:n\n        if min_dist_idx[i] == max_dist_idx[i]\n\
    \            c += 1\n        end\n    end\n    return c\nend", "    # TODO\nend\n\
    \ \n ", "    return n\nend", "    # Your code here\nend", "    \"\"\"\n    Imagine\
    \ a road that's a perfectly straight infinitely long line.\n    n cars are driving\
    \ left to right;  simultaneously, a different set of n cars\n    are driving right\
    \ to left.   The two sets of cars start out being very far from\n    each other.\
    \  All cars move in the same speed.  Two cars are said to collide\n    when a\
    \ car that's moving left to right hits a car that's moving right to left.\n  \
    \  However, the cars are infinitely sturdy and strong; as a result, they continue\
    \ moving\n    in their trajectory as if they did not collide.", "    # The following\
    \ code is buggy.  The function is intended to output the number of collisions.\n\
    \    # But, for some inputs, it outputs wrong results.\n    collisions = 0\n \
    \   for i in 1:n\n        for j in 1:n\n            collisions += 1\n        end\n\
    \    end\n    return collisions\nend", "    number_of_cars = n\n    initial_positions\
    \ = floor(2rand(number_of_cars))\n    left_to_right_cars = initial_positions[initial_positions\
    \ .== 0]\n    right_to_left_cars = initial_positions[initial_positions .== 1]\n\
    \    left_to_right_cars, right_to_left_cars = \n        sort(left_to_right_cars),\
    \ sort(right_to_left_cars, rev=true)\n    number_of_collisions = n - length(union(left_to_right_cars,\
    \ right_to_left_cars))\n    return number_of_collisions\nend", "    if n<2 return\
    \ 0 end\n    return n*(n-1)\nend\n@btime car_race_collision(10000)", "    num_of_collisions\
    \ = 0\n    cars_left_to_right = Set{Int64}()\n    cars_right_to_left = Set{Int64}()\n\
    \    for i = 1:n\n        push!(cars_left_to_right, i)\n        push!(cars_right_to_left,\
    \ n-i+1)\n    end\n    while length(cars_left_to_right) > 0 && length(cars_right_to_left)\
    \ > 0\n        if cars_left_to_right[1] < cars_right_to_left[1]\n            pop!(cars_left_to_right)\n\
    \            num_of_collisions += 1\n        else\n            pop!(cars_right_to_left)\n\
    \        end\n    end\n    return num_of_collisions\nend", "    if n == 0\n  \
    \      return 0\n    end\n    # @assert n > 0\n    # @assert n <= 2 * 10^9\n \
    \   return n * (n - 1) \xF7 2\nend", "    if n==0 return 0 end\n    if n==1 return\
    \ 0 end\n    collisions = 0\n    for i in 0:n-1\n        for j in 0:n-1\n    \
    \        if i != j\n                if abs(i-j) < n-abs(i-j)\n               \
    \     collisions = collisions + 1\n                end\n            end\n    \
    \    end\n    end\n    return collisions\nend", "    a = [x for x in 1:n]\n  \
    \  b = [x for x in n:-1:1]\n    counter = 0\n    for i in 1:n\n        for j in\
    \ 1:n\n            if a[i] == b[j]\n                counter += 1\n           \
    \ end\n        end\n    end\n    return counter\nend", "    # we call the cars\
    \ moving left to right set A, and the cars\n    # moving right to left set B\n\
    \    # Initially, we assume that all cars in set A are on the left of\n    # all\
    \ cars in set B.\n    # Each car in set A will move to the right at the same rate.\n\
    \    # Each car in set B will move to the left at the same rate.\n    # If a car\
    \ in set A is on the left of a car in set B, the leftmost car\n    # will surely\
    \ collide with the rightmost car.\n    # Notice that the leftmost car in set A\
    \ will always be in front of \n    # all other cars in set A. \n    # Similarly,\
    \ the rightmost car in set B will always be behind all\n    # other cars in set\
    \ B.\n    # Thus, we only need to check for collisions for these two extreme cars.\n\
    \    if n > 1\n        return n-1\n    else\n        return 0\n    end\nend",
  "  n*(n-1)/2\nend", "    num_collisions = 0\n    for i = 1:n\n        for j = 1:n\n\
    \            # there will be an infinite amount of collisions for this \n    \
    \        # car, so we make the number of collisions for this car infinite\n  \
    \          # and break\n            if i == j\n                num_collisions\
    \ = Inf\n                break\n            end\n            num_collisions +=\
    \ 1\n        end\n    end\n    return num_collisions\nend", "    d = Dict()\n\
    \    for i in 1:n\n        x = randn()\n        try\n            get!(d,x)\n \
    \       catch e\n            d[x] = 1\n        end\n    end\n    for i in 1:n\n\
    \        x = randn()\n        try\n            get!(d,x)\n        catch e\n  \
    \          d[x] = 1\n        end\n    end\n    sum = 0\n    for key in keys(d)\n\
    \        sum += d[key]\n    end\n    return sum\nend", "    \"\"\"\n    n = number\
    \ of cars moving left to right and right to left (there are 2n cars total)\n \
    \   \"\"\"\n    x = zeros(n)\n    y = zeros(n)\n    for i in 1:n\n        x[i]\
    \ = rand(1:10:1000)\n        y[i] = rand(1:10:1000)\n    end\n    return sum(abs.(x-y)\
    \ .<= 100)\nend", "    # Your code here\nend\n \n    ", "    # Build a random\
    \ list of left-to-right cars\n    l2r_cars = rand(n)\n    # Sort that list\n \
    \   # NOTE: \"sort\" sorts a list in O(nlogn) time.\n    #   You can speed up\
    \ this part by writing a function that sorts the list in O(n) time!\n    sort!(l2r_cars)\n\
    \    # Build a random list of right-to-left cars\n    r2l_cars = rand(n)\n   \
    \ # Sort that list too!\n    sort!(r2l_cars)\n    # Merge the two lists using\
    \ the O(n) algorithm that you wrote.\n    #   This is the most time-consuming\
    \ part of the algorithm,\n    #   and should be O(n) because the two lists are\
    \ already sorted.\n    #   Note that this algorithm is similar to the merge part\
    \ of MergeSort.\n    l2r_i = 1\n    r2l_i = 1\n    c = 0\n    # O(n) loop to iterate\
    \ through the merged list (of length 2n)\n    for i in 1:2n\n        if l2r_i\
    \ <= n && r2l_i <= n\n            if l2r_cars[l2r_i] <= r2l_cars[r2l_i]\n    \
    \            l2r_i += 1\n            else\n                r2l_i += 1\n      \
    \          c += n-l2r_i+1\n            end\n        end\n    end\n    return c\n\
    end", "    cars_left_to_right = zeros(Int64,n)\n    cars_right_to_left = zeros(Int64,n)\n\
    \    for i in 1:n\n        cars_left_to_right[i] = i\n        cars_right_to_left[i]\
    \ = i\n    end\n    collisions = 0\n    for i in 1:n\n        for j in 1:n\n \
    \           if cars_left_to_right[i] == cars_right_to_left[j]\n              \
    \  collisions += 1\n            end\n        end\n    end\n    return collisions\n\
    end", "    return Int64(1/2)n(n-1)\nend", "    r\"\"\"\n    Imagine a road that's\
    \ a perfectly straight infinitely long line.\n    n cars are driving left to right;\
    \  simultaneously, a different set of n cars\n    are driving right to left. \
    \  The two sets of cars start out being very far from\n    each other.  All cars\
    \ move in the same speed.  Two cars are said to collide\n    when a car that's\
    \ moving left to right hits a car that's moving right to left.\n    However, the\
    \ cars are infinitely sturdy and strong; as a result, they continue moving\n \
    \   in their trajectory as if they did not collide.", "    if n == 0\n       \
    \ return 0\n    end\n    if n < 0\n        error(\"car_race_collision: n cannot\
    \ be negative\")\n    end\n    if n == 1\n        return 0\n    end\n    if n\
    \ == 2\n        return 1\n    end\n    if n == 3\n        return 3\n    end\n\
    \    if n == 4\n        return 4\n    end\n    return n*(n-1)\nend", "    n_left2right\
    \ = n\n    n_right2left = n\n    n_collisions = 0\n    while n_left2right &gt;\
    \ 0 &amp;&amp; n_right2left &gt; 0\n        if rem(n_left2right, 2) == 0\n   \
    \         n_collisions += n_right2left\n            n_left2right -= 1\n      \
    \  else\n            n_right2left -= 1\n        end\n    end\n    return n_collisions\n\
    end\n</code>\nThis version is completely wrong.  I'm very confused.  I can't seem\
    \ to understand why my version is wrong, or how to fix it.  Please help!\nTo see\
    \ this, try running \n<code>car_race_collision(4)</code>\nwhich should output\
    \ \n<code>4</code>\nwhile my version outputs \n<code>0</code>", "    \"\"\"\n\
    \    A function to count the number of collisions in a car race.", "    # n is\
    \ the number of cars going left to right.\n    # the number of cars going right\
    \ to left is n.\n    # You do not need to worry about n being 0 or negative.\n\
    \    # You do not need to worry about n being bigger than 1e9.\n    #\n    #\n\
    \    # This is all you need to understand.\n    # The rest of the code below is\
    \ to generate random examples of \n    # left and right cars, and to test your\
    \ code.\n    # If you want to test your code, you do not need to read the\n  \
    \  # rest of the code below.\n    #\n    # The input of this function is n.\n\
    \    # If n = 1, then there's one car going left to right, \n    # and 1 car going\
    \ right to left.  When they meet, they will collide.\n    # If n = 2, then there's\
    \ two cars going left to right,\n    # and two cars going right to left.  When\
    \ they meet, they will collide.\n    # If n = 3, then there's three cars going\
    \ left to right,\n    # and three cars going right to left.  When they meet, they\
    \ will collide.\n    # ....\n    # If n = 13, then there's 13 cars going left\
    \ to right,\n    # and 13 cars going right to left.  When they meet, they will\
    \ collide.\n    # If n = 14, then there's 14 cars going left to right,\n    #\
    \ and 14 cars going right to left.  When they meet, they will collide.\n    #\
    \ ....\n    # Note that two cars that move in opposite directions will always\
    \ collide when they meet\n    # (infinitely strong cars collide and continue moving\
    \ forward).\n    #\n    # The output of this function is the number of such collisions.\n\
    \    # If n = 1, then the output is 1.\n    # If n = 2, then the output is 2.\n\
    \    # If n = 3, then the output is 3.\n    # ....\n    # If n = 13, then the\
    \ output is 13.\n    # If n = 14, then the output is 14.\n    # ....\n    # Note\
    \ that two cars that move in opposite directions will always collide when they\
    \ meet\n    # (infinitely strong cars collide and continue moving forward).\n\
    \    #", "    left_to_right = 1\n    right_to_left = n\n    collision = 0\n  \
    \  if n % 2 == 0\n        left_to_right = n / 2\n        right_to_left = n / 2\n\
    \    else\n        left_to_right = floor(Int64, n / 2) + 1\n        right_to_left\
    \ = n - left_to_right\n    end\n    collision = left_to_right * right_to_left\n\
    \    return collision\nend", "    \"\"\"\n    Input: \n        n: an integer,\
    \ the number of cars on the road.\n    Output: \n        an integer, the number\
    \ of collisions.\n    \"\"\"\n    ans = 0\n    for i in 1:n\n        ans += n-i\n\
    \    end\n    return ans\nend", "    # Randomly generate a single car's trajectory.\n\
    \    # The car starts at a random point on the road.\n    # The car's direction\
    \ can be either left to right or right to left.\n    # The car's speed is a random\
    \ number between 1 and 100 (inclusive).\n    function rand_car_trajectory()::Tuple{Int64,\
    \ Int64, Int64}\n        pos::Int64 = rand(-10^9:10^9)\n        dir::Int64 = (rand(0:1)\
    \ == 0 ? -1 : 1)\n        speed::Int64 = rand(1:100)\n        return (pos, dir,\
    \ speed)\n    end", "    v = zeros(n) # the speed of the car\n    t = zeros(n)\
    \ # the time when the car hits the origin\n    for i = 1:n\n        v[i] = rand()\n\
    \        t[i] = rand()/v[i]\n    end\n    sort!(t)\n    t_ev = zeros(2n)\n   \
    \ v_ev = zeros(2n)\n    for i = 1:n\n        t_ev[i] = t[i]\n        v_ev[i] =\
    \ v[i]\n    end\n    for i = 1:n\n        t_ev[n+i] = t[i]\n        v_ev[n+i]\
    \ = -v[i]\n    end\n    sort!(t_ev)\n    @assert v_ev[1] > 0\n    num_collisions\
    \ = 0\n    for i = 2:2n\n        if v_ev[i] < 0 && v_ev[i-1] > 0\n           \
    \ num_collisions += 1\n        end\n    end\n    return num_collisions\nend",
  "    t = 0\n    for i = 1:n\n        t += i\n    end\n    return t\nend", "    collisions\
    \ = 0\n    for i in 1:n\n        for j in 1:n\n            collisions += 1\n \
    \       end\n    end\n    return collisions\nend", "    \"\"\" n is the number\
    \ of cars driving each direction.  \n    \"\"\"\n    numcollisions = 0\n    lefttordist\
    \ = [-10000 for i in 1:n]\n    righttodist = [10000 for i in 1:n]\n    for i in\
    \ 1:n\n        for j in 1:n\n            if (lefttordist[i]>=righttodist[j]) &&\
    \ (lefttordist[i]<=(righttodist[j]+1))\n                numcollisions = numcollisions\
    \ + 1\n            end\n        end\n        lefttordist[i] = lefttordist[i] +\
    \ 1\n        righttodist[i] = righttodist[i] - 1\n    end\n    return numcollisions\n\
    end", "\nend", "    # First, sort all left-to-right cars and right-to-left cars\
    \ by their position.\n    # Obviously, the cars that are closer to the center\
    \ are more likely to collide.\n    # So, one can go through all possible pairs\
    \ of cars and count how many of them \n    # would collide.  Thus, the running\
    \ time is O(n^2).  This is not optimal. \n    # A more clever algorithm will have\
    \ running time O(n log n). \n    # A full solution is provided in [2].\n    \n\
    \    # This function computes the number of unique pairs of cars\n    # in an\
    \ array of n integers.\n    # For example, if the array is [1, 2, 2, 3, 3, 3,\
    \ 4], \n    # then the number of unique pairs is 3.\n    # This function is used\
    \ for computing the number of unique pairs in \n    # collisions.\n    function\
    \ unique_pairs(a::Array{Int64, 1})::Int64\n        # If the array is empty, then\
    \ return 0.\n        if size(a, 1) == 0\n            return 0\n        end\n \
    \       # If the array has only one element, then there are no pairs.\n      \
    \  if size(a, 1) == 1\n            return 0\n        end\n        # Recursive\
    \ call with the tail.\n        # Note that tail(a) returns a subarray that starts\
    \ at the second element.\n        # Note that the first element of a is a[1].\n\
    \        # Note that the first element of tail(a) is a[2].\n        # The number\
    \ of unique pairs is the number of pairs in the tail plus\n        # the number\
    \ of pairs formed by the first element with the rest of the tail.\n        return\
    \ unique_pairs(tail(a)) + size(a, 1) - size(tail(a), 1)\n    end", "    return\
    \ 0\nend", "    \"\"\"\n    Returns the number of collisions that happen during\
    \ a car race\n    between n cars going left to right and n cars going right to\
    \ left.\n    \"\"\"\n    return sum(1:n)\nend", "    if n<1\n        println(\"\
    error: the number of cars should be greater than 0\")\n        return 0\n    end\n\
    \    nn = 2*n\n    x = zeros(Int64, nn)\n    for i=1:n\n        x[i] = i\n   \
    \ end\n    for i=n+1:nn\n        x[i] = 2*n - i + 1\n    end\n    sc = sortperm(x)\n\
    \    res = 0\n    for i=1:n\n        if sc[i]<=n\n            res += i-1\n   \
    \     else\n            res += n - i + 1\n        end\n    end\n    return res\n\
    end", "    \"\"\" \n    Two cars collide if two integers i, j satisfy:\n    i\
    \ > j\n    i - j == a[i] - a[j]\n    \"\"\"\n    if n <= 1 \n        return 0\n\
    \    end\n    a = [rand(1:n) for i = 1:n]\n    ret = 0\n    for i = 1:n\n    \
    \    for j = i+1:n\n            if a[i] - a[j] == i - j\n                ret +=\
    \ 1\n            end\n        end\n    end\n    return ret\nend", "    \"\"\"\n\
    \    The cars are initially n apart.  To get any collision,\n    a car has to\
    \ reach the position of the other car, but then\n    the other car has to stay\
    \ put and not move any further.\n    \"\"\"\n    return n-1\nend", "    \"\"\"\
    \n    This function prints the number of car collisions.\n    \"\"\"\n    # Note:\
    \  for a car to collide with another car, it must first overtake that car\n  \
    \  # which in turn means its x-coordinate has to become greater than that of the\
    \ other car\n    # (because all cars move at the same speed).  Therefore, we can\
    \ imagine that \n    # the left-to-right moving cars are the \"positive\" cars\
    \ and the right-to-left moving cars\n    # are the \"negative\" cars.  \n    #\
    \ This function is designed to find the number of collisions between two lists\
    \ of\n    # numbers, where the elements in the first list are positive and the\
    \ elements in the\n    # second list are negative.\n    # We will denote the number\
    \ of positive numbers by n1, and the number of negative numbers\n    # by n2.\
    \  The algorithms are:\n    #\n    # n1 == 0  ||  n2 == 0  =>  0 collision\n \
    \   # n1 > n2   =>  n2 collisions (because there are n2 positive numbers, so that\
    \ is the upper bound)\n    # n1 < n2   =>  n1 collisions (because there are n1\
    \ negative numbers, so that is the upper bound)\n    # n1 == n2  =>  n1 collisions\
    \ (because of the symmetry between \"positive\" and \"negative\" lists)\n    #\n\
    \    # Note:  the algorithm above can be further improved to O(n) by using the\
    \ \"sweep line\" algorithm\n    # but we don't bother to do so.\n    #\n    #\n\
    \    # Therefore, let us sort the \"positive\" cars and the \"negative\" cars\
    \ separately and then count\n    # the number of collisions.  We do so by using\
    \ the merge sort algorithm.\n    #\n    # Finally, we also make a count of the\
    \ number of times a car overtakes another car but does not collide.\n    #\n \
    \   # Note:  the most obvious way to count the collisions is to use an O(n^2)\
    \ algorithm.  However, \n    # the number of tests that we are expected to execute\
    \ is very large.  Therefore, we do an O(n log n)\n    # algorithm instead.  In\
    \ fact, if we use the most obvious O(n^2) algorithm, we", "    for i in 1:n\n\
    \        for j in 1:n\n            if right_to_left[i] <= left_to_right[j]\n \
    \               collisions += 1\n            end\n        end\n    end\nend",
  "    # this is the fastest O(n) solution\n    # there is a better O(n log n) solution\
    \ as well\n    # both solutions are provided here\n    return car_race_collision_O_n(n)\n\
    \    # return car_race_collision_O_n_log_n(n)\nend", "    my_cars = sort(rand(n))\n\
    \    your_cars = sort(rand(n))\n    my_cars_2 = []\n    your_cars_2 = []\n   \
    \ for i in my_cars\n        for j in your_cars\n            if (i < j)\n     \
    \           my_cars_2 = vcat(my_cars_2,i)\n            else\n                your_cars_2\
    \ = vcat(your_cars_2,j)\n            end\n        end\n    end\n    return max(length(my_cars_2),length(your_cars_2))\n\
    end", "    #\n    # YOUR CODE HERE\n    #\nend\n ", "    ################\n  \
    \  # SOLUTION\n    ################\n    \n    collisions = 1\n    for i = 2:n\n\
    \        collisions += i\n    end\n    return collisions\nend", "    return (n\
    \ * (n - 1)) / 2\nend", "    # n represents the number of cars\n    # the first\
    \ set of cars is named car_left_to_right\n    # the second set of cars is named\
    \ car_right_to_left\n    # I want each car to be represented by a number;\n  \
    \  # this number is the distance of the car away from\n    # the origin\n    car_left_to_right\
    \ = [i for i in 1:n]\n    car_right_to_left = [i for i in 1:n]\n    # car_left_to_right[i]\
    \ and car_right_to_left[i] represent \n    # the distance the car is away from\
    \ the origin\n    num_collisions = 0\n    @show car_left_to_right\n    for i in\
    \ 1:n\n        for j in 1:n\n            if car_left_to_right[i] == car_right_to_left[j]\n\
    \                # the car has a collision\n                num_collisions +=\
    \ 1\n            end\n        end\n        car_left_to_right[i] += 1\n       \
    \ car_right_to_left[i] -= 1\n    end\n    return num_collisions\nend", "    \"\
    \"\"\n    This function finds the number of collisions in a car race of n cars\
    \ \n    moving in the same speed both left to right and right to left.\n    \"\
    \"\"\n    return Int64(n*(n-1)/2)\nend", "    \"\"\"\n    input:  n, where n>=0,\
    \ as above\n    output: the number of such collisions.\n    \"\"\"\n    collisions\
    \ = 0\n    # collision between cars i,k where i<k\n    for i=1:n-1\n        for\
    \ k=i+1:n\n            s = 2*abs(k-i)\n            if s%4 == 0\n             \
    \   collisions += 1\n            end\n        end\n    end\n    return collisions\n\
    end", "   \"\"\"\n   The number of cars moving left to right is a permutation\
    \ of the numbers 1, ..., n.\n   The number of cars moving right to left is another\
    \ permutation of the numbers 1, ..., n.\n   We represent this as a bijection s::Array{Int64,\
    \ 1} where s[i] is the index in the \n   right-to-left-moving array that is mapped\
    \ to i.\n   \"\"\"\n    s = collect(1:n)\n    shuffle!(s)\n    \"\"\"\n    We\
    \ now want to count the number of pairs (i, j) where i < j and s[i] > s[j].\n\
    \    This is the same as the number of inversions in the array s.  Here, we\n\
    \    count the number of inversions in s using the following O(n^2) time algorithm:\n\
    \    \"\"\"\n    num_inversions = 0\n    for i in 1:n-1\n        for j in i+1:n\n\
    \            if s[i] > s[j]\n                num_inversions += 1\n           \
    \ end\n        end\n    end\n    return num_inversions\nend", "    return n*(n-1)/2\n\
    end", "    return (n * (n - 1)) \xF7 2\nend", "    # sort the left-to-right set\
    \ of cars by position, same for right-to-left\n    left_cars = sorted(rand(Int64,n))\n\
    \    right_cars = sorted(rand(Int64,n))\n    len = length(left_cars)\n    i =\
    \ 1\n    j = 1\n    collisions = 0\n    while i <= len && j <= len\n        if\
    \ left_cars[i] < right_cars[j]\n            i += 1\n        elseif left_cars[i]\
    \ > right_cars[j]\n            j += 1\n        else\n            collisions +=\
    \ 1\n            i += 1\n            j += 1\n        end\n    end\n    return\
    \ collisions\nend", "    running_sum = 0\n    for i in 0:n-1\n        running_sum\
    \ += i\n    end\n    return running_sum\nend", "    return n * (n - 1) / 2\nend\n\
    car_race_collision(4)", "    r\"\"\"\n    Given a \"board\" $B$ consisting of\
    \ `n` rooks on a chessboard, return a matrix\n    with all zeros except the $i$-th\
    \ row and $j$-th column containing a one, corresponding\n    to the rook at position\
    \ $i,j$.", "    # YOUR CODE HERE\n    return 0\nend", "    \n    # count the number\
    \ of collisions\n    # by creating a 2D table that tracks\n    # the positions\
    \ of both sets of cars.\n    # Start by creating such a table.\n    position_table\
    \ = zeros(Int64,n,n)\n    \n    # For illustration purposes, let's say\n    #\
    \ the cars moving left to right\n    # have positions 1,2,3, ... n,\n    # and\
    \ the cars moving right to left\n    # have positions n,n-1, ... 1.\n    # More\
    \ formally, we can say that\n    # for each i,\n    # position_table[i,k] = k\
    \ + i.\n    for i = 1:n, k = 1:n\n        position_table[i,k] = k + i\n    end\n\
    \    \n    # count the number of collisions.\n    # For illustration purposes,\
    \ let's say\n    # the car moving from 1 to 2 collides\n    # with the car moving\
    \ from n to n-1.\n    # More formally, we can say that\n    # a collision occurs\n\
    \    # if there is some i such that\n    # position_table[i,k] = position_table[k,i].\n\
    \    # Here, we set k to be 1,2, ... n.\n    # More formally, we can say that\n\
    \    # a collision occurs\n    # if there is some i such that\n    # position_table[i,1]\
    \ = position_table[1,i]\n    # or position_table[i,2] = position_table[2,i]\n\
    \    # or position_table[i,3] = position_table[3,i]\n    # or ...\n    # or position_table[i,n]\
    \ = position_table[n,i].\n    # More formally, we can say that\n    # a collision\
    \ occurs\n    # if there is some i such that\n    # position_table[i,1:n] = position_table[1:n,i].\n\
    \    # Note that \"position_table[i,1:n] = position_table[1:n,i]\"\n    # is a\
    \ vectorized comparison.\n    return sum(sum(position_table[i,1:n] .== position_",
  "    return n^2\nend", "    #Write your code here\n    return 0\nend", "    return\
    \ div(n*(n-1), 2)\nend", "    return n * (n - 1)\nend", "    return Int64( n*(n-1)/2\
    \ ) \nend", "    cars_right_to_left = CarPosition[]\n    cars_left_to_right =\
    \ CarPosition[]\n    for i = 1:n\n        push!(cars_right_to_left, CarPosition(n\
    \ - i, 1))\n        push!(cars_left_to_right, CarPosition(i, -1))\n    end\n \
    \   if n == 1\n        return 0\n    end\n    car_race_collision_recursive(cars_right_to_left,\
    \ cars_left_to_right)\nend", " \n    # This function works by first sorting the\
    \ positions of the cars, then finding\n    # the midpoint, and then checking to\
    \ see whether there are cars on the left\n    # side that need to overtake cars\
    \ on the right side.", "    \"\"\"\n    Imagine a road that's a perfectly straight\
    \ infinitely long line.\n    n cars are driving left to right;  simultaneously,\
    \ a different set of n cars\n    are driving right to left.   The two sets of\
    \ cars start out being very far from\n    each other.  All cars move in the same\
    \ speed.  Two cars are said to collide\n    when a car that's moving left to right\
    \ hits a car that's moving right to left.\n    However, the cars are infinitely\
    \ sturdy and strong; as a result, they continue moving\n    in their trajectory\
    \ as if they did not collide.", "    lanes = Dict()\n    for i in 1:n\n      \
    \  lanes[i] = Array{Tuple{Int64,Int64}}()\n    end\n    for i in 1:n\n       \
    \ push!(lanes[i], (i,1))\n    end\n    for i in 1:n\n        push!(lanes[1], (i,\
    \ -1))\n    end\n    t = 0\n    collisions = 0\n    cur = Dict()\n    next = Dict()\n\
    \    while true\n        t += 1\n        for i in 1:n\n            cur[i] = lanes[i][1]\n\
    \        end\n        for i in 1:n\n            next[i] = lanes[i][2]\n      \
    \  end\n        for i in 1:n\n            val = cur[i]\n            if val[2]\
    \ == 1\n                # right to left car\n                if next[val[1]][2]\
    \ == -1\n                    collisions += 1\n                end\n          \
    \  else\n                # left to right car\n                if next[i][2] ==\
    \ 1\n                    collisions += 1\n                end\n            end\n\
    \        end\n        for i in 1:n\n            popfirst!(lanes[i])\n        end\n\
    \        for i in 1:n\n            val = cur[i]\n            push!(lanes[val[1]],\
    \ (val[1], val[2]))\n        end\n        if isempty(lanes[1])\n            break\n\
    \        end\n    end\n    return collisions\nend", "    collisions = 0\n    while\
    \ n > 0\n        collisions += n\n        n -= 1\n    end\n    return collisions\n\
    end", "    return n*(n-1)/2\nend\n@btime car_race_collision(300);", "    @inbounds\
    \ distance = 0\n    @inbounds counter = 0\n    for i in 1:n\n        distance\
    \ += 1\n        distance -= 1\n        counter += distance\n    end\n    return\
    \ counter\nend", "    a = rand(-1:1, n)\n    b = rand(-1:1, n)\n    collisions\
    \ = 0\n    for i in 1:n\n        for j in 1:n\n            collisions += (a[i]\
    \ > 0 && b[j] < 0) ? 1 : 0\n        end\n    end\n    return collisions\nend",
  "    pass \nend", "    return n*(n-1)/2\nend", "    if n <= 1\n        return 0\n\
    \    end\n    return n*(n-1)\nend", "    positions = 0 # assume that the cars\
    \ are numbered from 1 to n, and n is even\n    for i in 1:n\n        positions\
    \ += i\n    end\n    return positions\nend", "    \nend", "    # We do a first\
    \ pass to put the left-to-right cars in an ordered collection.\n    # Then we\
    \ do a second pass to sweep the right-to-left cars against the left-to-right cars\n\
    \    # and count the collisions.\n    # Time complexity is O(n log n) because\
    \ the sort is O(n log n) and the second sweep is O(n)\n    left_to_right_car_positions\
    \ = []\n    for i in 1:n\n        # position is a random number on the line between\
    \ 0 and 1\n        position = rand()\n        # put the cars in left-to-right\
    \ order\n        push!(left_to_right_car_positions, position)\n    end\n    sort!(left_to_right_car_positions)\n\
    \    num_collisions = 0\n    for i in 1:n\n        # position is a random number\
    \ on the line between 0 and 1\n        position = rand()\n        # We sweep the\
    \ right-to-left cars against the ordered left-to-right cars.\n        # It is\
    \ convenient to do this sweep in reverse order, i.e. from right to left.\n   \
    \     # This way, when we find a collision, we know all the subsequent cars in\
    \ the \n        # left-to-right ordered collection have no chance of colliding.\n\
    \        for j in (n-1):-1:0\n            if position <= left_to_right_car_positions[j]\n\
    \                num_collisions += 1\n                break # all subsequent cars\
    \ in left-to-right ordered collection have no chance of colliding\n          \
    \  end\n        end\n    end\n    return num_collisions\nend\ncar_race_collision(1000)",
  "    \"\"\"\n    # input: n, the number of cars in each direction\n    # output:\
    \ the number of collisions\n    # This assumes that the cars are driving from\
    \ -1 to 1, and that the cars have the following\n    # positions:\n        # Cars\
    \ 1 to n going from -1 to 1: x[i] = -1 + 2*i/(n-1) for i = 0:(n-1)\n        #\
    \ Cars n+1 to 2n going from 1 to -1: x[i] = 1 - 2*(i-n)/(n-1) for i = n:(2n-1)\n\
    \        # A car i collides with a car j, iff x[i] = x[j].\n        # A simple\
    \ computation shows that car i collides with car n+1-i.\n        # This results\
    \ in n/2 collisions, or 2*(n/2) collisions if n is even,\n        # or (n-1)/2\
    \ collisions if n is odd. \n    \"\"\"\n    if n%2 == 0 \n        return 2*(n/2)\n\
    \    else\n        return (n-1)/2\n    end\nend", "    new_index = zeros(Int64,\
    \ n)\n    for i in 1:n\n        index = n - i\n        new_index[index] = i\n\
    \    end\n    new_index\nend\n@show car_race_collision(4)\n@show car_race_collision(5)\n\
    @show car_race_collision(6)", "    # TODO: fill this in\n    return 0\nend\ncar_race_collision(10)",
  "    for i = 1:n\n        for j = 1:n\n            if i==j\n                pass\n\
    \            else\n                # this is the collision case \n           \
    \ end\n        end\n    end\nend", "    return n + n - 1\nend\n#q1", "    \"\"\
    \"\n    The result is the number of collisions in a car race with n cars.\n  \
    \  \"\"\"\n    coll = 0\n    c = n-1\n    while c > 0\n        coll += c\n   \
    \     c -= 1\n    end\n    return coll\nend\n    \n    ", "    positions = zeros(Int64,\
    \ n*2)\n    for i in 1:n\n        positions[i] = rand(Int64, -500000000:500000000)\n\
    \    end\n    for i in n+1:n*2\n        positions[i] = rand(Int64, -500000000:500000000)\n\
    \    end\n    positions = sort(positions)\n    x = 0\n    for i in n+1:n*2\n \
    \       x += count(positions[1:i], positions[i])\n    end\n    return x\nend",
  "\nend", "    # write your code here\n    return 0\nend", "    # YOU WILL FILL IN\
    \ THE DETAILS\n    n1 = rand(-2:2:2,n)\n    n2 = rand(-2:2:2,n)\n    n3 = sum(n1\
    \ .== n2)\n    return n3\nend", "    \"\"\"\n    We are going to use the following\
    \ algorithm:\n    - randomly choose the positions of all the cars (i.e. the two\
    \ sets of n cars).\n    - for each pair of cars (in the first set and in the second\
    \ set), check whether\n      they are close enough to collide.", "    \"\"\"\n\
    \    This function takes an integer n and returns the\n    number of possible\
    \ collision between the set of \n    n cars moving left to right and the set of\
    \ n\n    cars moving right to left.\n    \"\"\"\n    # There are n different collisions\
    \ for the set of cars\n    # moving left to right.  There are a different set\
    \ of n\n    # different collisions for the set of cars moving right to left.\n\
    \    # So there are a total of n+n = 2n collisions.  We subtract 1 because\n \
    \   # the cars that move left to right and the cars that move right to left\n\
    \    # can collide too.\n    return 2n - 1\nend", "    collision_count = 0\n \
    \   right_to_left_sorted = sort(rand(1:1_000_000, n), rev=true)\n    left_to_right_sorted\
    \ = sort(rand(1:1_000_000, n))\n    for i in 1:n\n        if right_to_left_sorted[i]\
    \ > left_to_right_sorted[i]\n            collision_count += 1\n        end\n \
    \   end\n    return collision_count\nend", "    collisions = 0\n    cars_left\
    \ = Set(1:n)\n    cars_right = Set(1:n)\n    for i in 1:n\n        if !isempty(intersect(cars_left,\
    \ cars_right))\n            collisions += 1\n        end\n        delete!(cars_left,\
    \ i)\n        delete!(cars_right, i)\n    end\n    return collisions\nend", " \
    \   # num_collisions = 0\n    # this is a naive algorithm\n    # n_left_right\
    \ = n\n    # n_right_left = n\n    # while n_left_right != 0 && n_right_left !=\
    \ 0\n    #     if rand(0:1) == 0\n    #         num_collisions += 1\n    #   \
    \      n_left_right -= 1\n    #     else\n    #         n_right_left -= 1\n  \
    \  #     end\n    # end\n    # num_collisions\n    n_left_right = n\n    n_right_left\
    \ = n\n    while n_left_right != 0 && n_right_left != 0\n        if rand(0:1)\
    \ == 0\n            n_left_right -= 1\n        else\n            n_right_left\
    \ -= 1\n        end\n    end\n    n - n_left_right - n_right_left\nend", "   \
    \ \"\"\"\n    Assume that the number of car pairs that are traveling in opposite\
    \ directions are\n    evenly divisible by two.  (For example, in the case of n\
    \ = 3,\n    i.e. 3 pairs of cars traveling in opposite directions,\n    each pair\
    \ will contain 2 cars.)\n    \"\"\"\n    if n == 0\n        return 0\n    else\n\
    \        return (n - 1) + car_race_collision(n - 1)\n    end\nend\ncar_race_collision(3)",
  "    # YOUR CODE HERE\n    if n==1\n        return 0\n    else\n        return n-1\n\
    \    end\nend", "    # write your code here\nend\n \n\"\"\"\n    Input: a list\
    \ of integers\n    Output: a tuple of two lists, one of odd and one of even integers\n\
    \    \"\"\"", "    # because the cars are infinitely sturdy, there can be no collisions\n\
    \    # between cars coming from opposite directions on the same road\n    return\
    \ 0\nend", "    collisions = 0\n    for r in 1:n\n        for l in r+1:n\n   \
    \         if r > l\n                collisions += 1\n            end\n       \
    \ end\n    end\n    return collisions\nend", "    # YOUR CODE HERE\n    return\
    \ 0\nend\n ", "    cars_moving_left_to_right = Array{Tuple{Int64,Int64},1}(n)\n\
    \    cars_moving_right_to_left = Array{Tuple{Int64,Int64},1}(n)\n    # You can\
    \ assume the coordinates of the cars moving left to right\n    # are stored in\
    \ cars_moving_left_to_right and the coordinates of the cars\n    # moving right\
    \ to left are stored in cars_moving_right_to_left.\n    # The ith element in each\
    \ array has the form (x, y), where x represents the x-coordinate\n    # of the\
    \ car and y represents the y-coordinate of the car.\n    # The x-coordinate of\
    \ the ith car moving left to right is always greater than 0.\n    # The x-coordinate\
    \ of the ith car moving right to left is always less than 0.\n    # The ith car\
    \ moving left to right is always moving right.\n    # The ith car moving right\
    \ to left is always moving left.\n    # The cars move 1 unit to the right or left\
    \ per minute.\n    # For example, a car moving left to right might have the coordinates\
    \ (3, 5).\n    # This means at t = 0, the car was at (3, 5).  One minute later,\
    \ at t = 1, the car is at (4, 5).\n    # And so on.\n    # For all i, 0 < cars_moving_left_to_right[i][1]\n\
    \    # For all i, cars_moving_right_to_left[i][1] < 0\n    # For all i, cars_moving_left_to_right[i][1]\
    \ > cars_moving_right_to_left[i][1]\n    # For all i, cars_moving_left_to_right[i][2]\
    \ == cars_moving_right_to_left[i][2]\n    # For all i, cars_moving_left_to_right[i][2]\
    \ is an integer\n    # For all i, cars_moving_right_to_left[i][2] is an integer\n\
    \    collisions = 0\n    for t in 1:Int64\n        for i in 1:n\n            if\
    \ cars_moving_left", "    \"find the number of collisions in a car race\"\n  \
    \  hit_count=0\n    #### INSERT CODE HERE TO SOLVE THIS PROBLEM\n    return hit_count\n\
    end\n ", "    A = n\n    B = n\n    count = 0\n    while A > 0 && B > 0\n    \
    \    if rand() < 0.5\n            A -= 1\n        else\n            B -= 1\n \
    \           count += 1\n        end\n    end\n    return count\nend", "    \"\"\
    \"\n    n: the number of cars in the race\n    \"\"\"\n    s = 0\n    for car1_idx\
    \ in 1:n\n        for car2_idx in 1:n\n            if car1_idx < car2_idx \n \
    \               if car1_idx == car2_idx + 1\n                    s += 1\n    \
    \            end\n            elseif car1_idx > car2_idx\n                if car1_idx\
    \ == car2_idx - 1\n                    s += 1\n                end\n         \
    \   end\n        end\n    end\n    return s\nend", "    return 0 \nend", "   \
    \ # Preliminary.  Make sure n is valid\n    if n < 0\n        return 0\n    end\n\
    \    \n    # Test if there is a collision\n    return 0\nend\n ", "  # dummy array\
    \ of positions.  Each i-th element holds the position of the i-th\n  # car that's\
    \ moving left to right.\n  pos_l2r = [1000 * i for i in 1:n]\n  # similarly, we\
    \ have an array for the positions of the cars moving right to left.\n  pos_r2l\
    \ = [1000 * i for i in 1:n]", "    # Give the number of collisions.\nend", " \
    \   n_cars = 2*n\n    car_positions = zeros(n_cars)\n    left_to_right_speeds\
    \ = zeros(n)\n    right_to_left_speeds = zeros(n)\n    for i = 1:n\n        left_to_right_speeds[i]\
    \ = rand()\n        right_to_left_speeds[i] = rand()\n    end\n    # end for\n\
    \    for i = 1:n\n        car_positions[i] = rand()\n        car_positions[i+n]\
    \ = rand()\n    end\n    # end for\n    collision_indices = sort(car_positions,\
    \ rev=true)[1:n]\n    return sum(collision_indices)\n    # end function", "  \
    \  a = sort(rand(n))\n    b = sort(rand(n))\n    c = 0\n    for i = 1:n\n    \
    \    for j = 1:n\n            if a[i] < b[j]\n                c += 1\n       \
    \     end\n        end\n    end\n    return c\nend", "    \"\"\"\n    >>> car_race_collision(2)\n\
    \    1\n    >>> car_race_collision(3)\n    4\n    >>> car_race_collision(4)\n\
    \    10\n    >>> car_race_collision(5)\n    20\n    >>> car_race_collision(6)\n\
    \    35\n    >>> car_race_collision(7)\n    56\n    >>> car_race_collision(8)\n\
    \    84\n    >>> car_race_collision(9)\n    120\n    >>> car_race_collision(10)\n\
    \    165\n    >>> car_race_collision(11)\n    220\n    >>> car_race_collision(12)\n\
    \    286\n    >>> car_race_collision(13)\n    364\n    >>> car_race_collision(14)\n\
    \    455\n    >>> car_race_collision(15)\n    560\n    >>> car_race_collision(16)\n\
    \    680\n    >>> car_race_collision(17)\n    816\n    >>> car_race_collision(18)\n\
    \    969\n    >>> car_race_collision(19)\n    1140\n    >>> car_race_collision(20)\n\
    \    1330\n    >>> car_race_collision(1000)\n    499955000\n    \"\"\"\n    if\
    \ n == 1\n        return 0\n    else\n        #Each car from the left moves past\
    \ n-1 cars from the right\n        #and each car from the right moves past n-1\
    \ cars from the left\n        return (n-1)*n + car_race_collision(n-1)\nend",
  "    num_collisions = 0\n    for i = 1:n\n        for j = 1:n\n            if i\
    \ != j\n                num_collisions += 1\n            end\n        end\n  \
    \  end\n    return num_collisions\nend", "    #n is an even number.  \n    cnt\
    \ = 0 \n    i = 1\n    while i <= n \n        j = n + 1\n        while j <= 2n\
    \ \n            if i + j == n + 1 \n                cnt += 1\n            end\n\
    \            j += 1\n        end\n        i += 1\n    end\n    return cnt\nend",
  "    # your code here\nend\n@testset \"car_race_collision\" begin\n    @test car_race_collision(1)\
    \ == 0\n    @test car_race_collision(2) == 1\n    @test car_race_collision(4)\
    \ == 6\n    @test car_race_collision(100) == 4950\nend", "    # [ 0 1 2 3 4 5\
    \ 6 7 8 9 ]\n    # [ 9 8 7 6 5 4 3 2 1 0 ]\n    # ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ \n    #\
    \   ^ ^ ^ ^ ^ ^ ^ ^ ^ ^\n    # n = 10\n    # n * n - n = 90\n    # n * (n - 1)\
    \ / 2 = 45\n    return n * (n - 1) / 2\nend", "    # TODO\n    # remember not\
    \ to use any loops\n    # you can use the sort! function on an array.\n    # see\
    \ https://docs.julialang.org/en/v1/stdlib/Sort/index.html#Sort.sort!\n    # it\
    \ is the same as Python's sort()\nend", "    n_collisions = 0\n    n_cars_p1 =\
    \ 0\n    n_cars_p2 = 0\n    while n_cars_p1 < n && n_cars_p2 < n\n        if distance(n_cars_p1,\
    \ n_cars_p2) == 0\n            n_collisions += 1\n        end\n        n_cars_p1\
    \ += 1\n        n_cars_p2 += 1\n    end\n    return n_collisions\nend", "    #solution:\
    \ \n    return Int64(n*(n-1)/2)\nend", "    distances = zeros(Int64, n, n)\n \
    \   n1 = Int64(floor(n/2))\n    n2 = n - n1\n    for i = 1:n1\n        for j =\
    \ 1:n2\n            distances[i, j] = (j - i)*2\n        end\n    end\n    for\
    \ i = 1:n1\n        for j = 1:n2\n            distances[i, j] = (j - i)*2\n  \
    \      end\n    end\n    return sum(sum(distances .<= 0))\nend", "    \"\"\"\n\
    \    A car can be thought of as a point on the number line.\n    \"\"\"\n    left_cars\
    \ = zeros(Int64, n) # left to right\n    right_cars = zeros(Int64, n) # right\
    \ to left\n    # 0 is the starting point\n    # 1:n are left to right\n    # -1:-n\
    \ are right to left\n    left_cars[:] = collect(1:n)\n    right_cars[:] = collect(-1:-n)\n\
    \    \"\"\"\n    A collision between two cars are equivalent to left_cars[i] ==\
    \ -right_cars[j]\n    for some i, j.\n    \"\"\"\n    num_collisions = 0\n   \
    \ for i = 1:n\n        for j = 1:n\n            if left_cars[i] == -right_cars[j]\n\
    \                num_collisions += 1\n            end\n        end\n    end\n\
    \    return num_collisions\nend", "    return (n*(n-1)) \xF7 2\nend", "    if\
    \ n % 2 == 0\n        return (n/2) * (n/2)\n    else\n        return (n/2) * (n/2\
    \ + 1)\n    end\nend", "    \"\"\"\n    The output is an integer\n    \"\"\"\n\
    \    if n < 1\n        throw(ArgumentError(\"n must be positive\"))\n    end\n\
    \    return n*(n-1)\nend", "    sum = 0 \n    for i in 1:n-1\n        sum += i\n\
    \    end\n    return sum\nend", "    \"\"\"\n    Input:\n    - n: number of cars\
    \ in each direction.  0 \u2264 n \u2264 10^9.\n    Output:\n    - number of collisions\
    \ between the cars.\n    \"\"\"\n    collisions = 0\n    max_value = n - 1\n \
    \   for i = 1:max_value \n        collisions += i\n    end\n    return collisions\
    \ * 2\nend", "    ## YOUR CODE HERE\nend", "  \"\"\"\n  A naive algorithm that\
    \ runs in O(n^2) time.", "    if n == 0; return 0 end\n    if n == 1; return 0\
    \ end\n    if n == 2; return 1 end\n    return n-1\nend", "    \"\"\"\n    Imagine\
    \ a road that's a perfectly straight infinitely long line.\n    n cars are driving\
    \ left to right;  simultaneously, a different set of n cars\n    are driving right\
    \ to left.   The two sets of cars start out being very far from\n    each other.\
    \  All cars move in the same speed.  Two cars are said to collide\n    when a\
    \ car that's moving left to right hits a car that's moving right to left.\n  \
    \  However, the cars are infinitely sturdy and strong; as a result, they continue\
    \ moving\n    in their trajectory as if they did not collide.", "    \"\"\"\n\
    \    pre: n >= 0\n    post: returns the number of collisions in a car race with\
    \ n cars.\n    \"\"\"\n    if n == 0 \n        return 0\n    else\n        return\
    \ n - 1 + car_race_collision(n - 1)\n    end\nend", "    # Write your code here\n\
    \    return 0\nend", "    k = 0\n    for i = 1:n\n        for j = 1:n\n      \
    \      if i > j\n                k += 1\n            end\n        end\n    end\n\
    \    return k\nend", "    return Int64(floor(n*(n-1)/2))\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
