name: HumanEval_49_modp
language: jl
prompt: "\"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n \
  \   3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3,\
  \ 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\nfunction modp(n::Int64,\
  \ p::Int64)::Int64 \n"
tests: "using Test\n\n@testset begin\n\ncandidate = modp;\n\t@test(candidate(3, 5)\
  \ == 3)\n\t@test(candidate(1101, 101) == 2)\n\t@test(candidate(0, 101) == 1)\n\t\
  @test(candidate(3, 11) == 8)\n\t@test(candidate(100, 101) == 1)\n\t@test(candidate(30,\
  \ 5) == 4)\n\t@test(candidate(31, 5) == 3)\nend\n"
completions: ["    r = 1\n    while n > 0\n        r = r*2\n        if r >= p\n  \
    \          r = r % p\n        end\n        n = n - 1\n    end\n    return r\n\
    end", "    if n == 0\n        return 1\n    else\n        a = modp(n \xF7 2, p)\n\
    \        a = mod(a * a, p)\n        if n % 2 == 1\n            a = mod(a * 2,\
    \ p)\n        end\n        return a\n    end\nend", "    if n == 0 \n        return\
    \ 1\n    elseif n % 2 == 0 \n        x = modp(n/2, p)\n        return mod(x*x,\
    \ p)\n    else \n        return mod(2*modp(n-1, p), p)\n    end\nend\nmodp(n::Int64,\
    \ p::Int64) = modp(n+1, p)\n \n \n \n    \"\"\"Count the number of trailing zeros\
    \ in the binary representation of a number.\n    >>> trailing_zeros(1)\n    0\n\
    \    >>> trailing_zeros(5)\n    1\n    >>> trailing_zeros(32)\n    5\n    >>>\
    \ trailing_zeros(1024)\n    10\n    \"\"\"", "    if n == 0\n        return 1\n\
    \    end\n    x = modp(div(n, 2), p)\n    x = mod(x * x, p)\n    if mod(n, 2)\
    \ == 1\n        x = mod(x * 2, p)\n    end\n    return x\nend", "    r = 1\n \
    \   for b in bitstring(n)\n        r = (r*r) % p\n        if b == '1'\n      \
    \      r = (r*2) % p\n        end\n    end\n    return r\nend", "    if n == 0\n\
    \        1\n    else\n        if n % 2 == 0\n            modp(n/2, p)^2 % p\n\
    \        else\n            2 * modp(n-1, p) % p\n        end\n    end\nend", " \
    \   #Works for p<2^63 and we assume that n<2*p\n    if n == 0\n        return\
    \ 1\n    end\n    #product = 1 \n    #while n > 0\n    #    product = (product*n)\
    \ % p\n    #    n -= 1\n    #end\n    #return product\n    if n <= 2\n       \
    \ return n\n    end\n    a = modp(n >> 1, p)\n    if iseven(n)\n        return\
    \ (a*a) % p\n    else\n        return (a*a*n) % p\n    end\nend", "    if n ==\
    \ 0\n        return 1\n    end\n    if n % 2 == 0\n        return modp(n/2, p)^2\
    \ % p\n    else\n        return (2 * modp(n-1, p)) % p\n    end\nend", "    if\
    \ n == 0\n        return 1\n    elseif n == 1\n        return 2\n    elseif n\
    \ == 2\n        return 4\n    else\n        m = 1\n        for i = 1:floor(Int64,\
    \ log2(n))\n            m = rem(m^2*2, p)\n        end\n        return m\n   \
    \ end\nend", "    if n < 0 \n        return modp(-n, p)\n    end\n    r = 1\n\
    \    while n > 0\n        if n % 2 == 1\n            r = (r * 2) % p\n       \
    \ end\n        n = div(n, 2)\n    end\n    return r\nend", "    a::Int64 = 1\n\
    \    for i in 1:n\n        a *= 2\n        a %= p\n    end\n    return a\nend",
  "    \"The algorithm is simple: we break the exponent into a sum of powers of 2\"\
    \n    a = 1\n    b = 2\n    i = 1\n    while i <= n\n        if (n >> i) & 1 ==\
    \ 1\n            a = mod(a * b, p)\n        end\n        b = mod(b * b, p)\n \
    \       i += 1\n    end\n    return a\nend", "    if n == 0\n        1\n    else\n\
    \        r = modp(div(n, 2), p)\n        if rem(n, 2) == 0\n            sqr(r)\n\
    \        else\n            r * sqr(r)\n        end\n    end\nend", "    if n ==\
    \ 0\n        return 1\n    elseif n == 1\n        return 2\n    else\n       \
    \ if n % 2 == 0\n            return (modp(n\xF72, p) * modp(n\xF72, p)) % p\n\
    \        else\n            return (modp(n\xF72, p) * modp(n\xF72, p) * 2) % p\n\
    \        end\n    end\nend", "    result = 1\n    for i in 1:n\n        result\
    \ = (result * 2) % p\n    end\n    return result\nend", "    if n == 0\n     \
    \   return 1\n    end\n    if n == 1\n        return 2\n    end\n    if n % 2\
    \ == 0\n        return mod2(n, p)\n    else\n        return mod2(n-1, p) * 2 %\
    \ p\n    end\nend", "    if n == 0\n        return 1\n    end\n    if n < 0 \n\
    \        return (p - 1) * modp(-n, p)\n    end\n    m = n % (p - 1)\n    if m\
    \ < (p - 1) / 2\n        return modp(2*m, p)\n    else\n        return p - modp(2*(p\
    \ - 1 - m), p)\n    end\nend", "    return mod(2^n, p)\nend", "    if n == 0\n\
    \        return 1\n    end\n    m = modp(n\xF72, p)\n    m = (m*m) % p\n    if\
    \ n\xF72 == 1\n        return (m*2) % p\n    else\n        return m\n    end\n\
    end", "    n = rem(n, p)\n    result = 1\n    if n == 0 return result end\n  \
    \  for i in 0:63\n        if bitand(n, 1<<i) != 0\n            result = rem(result\
    \ * modp(2, p)^i, p)\n        end\n    end\n    return result\nend\n \n \n \n\
    \ \n  \n\"\"\"Compute `q(i)` and `p(i)`:\n    q(i) = (2^i - 1) / 3\n    p(i) =\
    \ 2^i + 1\n    >>> qp(1)\n    (0, 3)\n    >>> qp(2)\n    (1, 5)\n    >>> qp(3)\n\
    \    (2, 9)\n    >>> qp(4)\n    (4, 17)\n    >>> qp(5)\n    (8, 33)\n    >>> qp(6)\n\
    \    (16, 65)\n    >>> qp(7)\n    (32, 129)\n    >>> qp(20)\n    (524288, 1048577)\n\
    \    \"\"\"", "    if n == 0 \n        return 1\n    else\n        return modp(2*n,\
    \ p) ^ n\n    end\nend", "    if n==0 return 1 end\n    if n==1 return 2 end\n\
    \    if n%2==0 return mod(2*modp(n\xF72, p), p) end\n    return mod(2*modp(n\xF7\
    2, p), p)\nend\n\"\"\"\n    >>> mod2(1)\n    2\n    >>> mod2(12)\n    2\n    >>>\
    \ mod2(34)\n    2\n    >>> mod2(123)\n    2\n    >>> mod2(0)\n    2\n    >>> mod2(1)\n\
    \    2\n    >>> mod2(2)\n    2\n    >>> mod2(3)\n    2\n    >>> mod2(4)\n    2\n\
    \    >>> mod2(11)\n    2\n    >>> mod2(18)\n    2\n    >>> mod2(23)\n    2\n \
    \   >>> mod2(24)\n    2\n    >>> mod2(100)\n    2\n    >>> mod2(120)\n    2\n\
    \    >>> mod2(1000)\n    2\n    >>> mod2(10000)\n    2\n    >>> mod2(100000)\n\
    \    2\n    >>> mod2(123456789)\n    2\n    >>> mod2(1234567890)\n    2\n    >>>\
    \ mod2(12345678901)\n    2\n    >>> mod2(123456789012)\n    2\n    >>> mod2(1234567890123)\n\
    \    2\n    >>> mod2(12345678901234)\n    2\n    >>> mod2(123456789012345)\n \
    \   2\n    >>> mod2(1234567890123456)\n    2\n    >>> mod2(12345678901234567)\n\
    \    2\n    >>> mod2(123456789012345678)\n    2\n    >>> mod2(1234567890123456789)\n\
    \    2\n    >>> mod2(12345678901234567890)\n    2\n    >>> mod2(123456789012345678901)\n\
    \    2\n    >>> mod2(1234567890123456789012)\n    2\n    >>> mod2(12345", "  \
    \  \n    # Note that this recursion is faster than naive\n    # if n == 0\n  \
    \  #     return 1\n    # else\n    #     return (2 * modp(n-1, p)) % p\n    \n\
    \    # This one is even faster\n    if n == 0\n        return 1\n    elseif n\
    \ == 1\n        return 2\n    else\n        m = modp(div(n, 2), p)\n        if\
    \ n % 2 == 0\n            return (m * m) % p\n        else\n            return\
    \ (2 * m * m) % p\n        end\n    end\nend", "    r = 1\n    b = 2\n    while\
    \ n > 0\n        if n % 2 == 1\n            r = mod(r * b, p)\n        end\n \
    \       n = div(n, 2)\n        b = mod(b^2, p)\n    end\n    return r\nend", " \
    \   n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n %= p\n    n\
    \ %= p\n    n %= p\n    n %= p\n    n %= p\n    return n\nend", "    p %= big(0)\n\
    \    if n == 0\n        return 1\n    end\n    n = n % p\n    t = floor(log2(n))\n\
    \    n0 = n - 2^t\n    r = modp(t, p)\n    r = ((r * r) % p) * modp(n0, p) % p\n\
    \    return r\nend", "    if n == 0\n        return 1\n    end\n    x = modp(n\
    \ \xF7 2, p)\n    x = (x * x) % p\n    if n % 2 == 1\n        x = (x * 2) % p\n\
    \    end\n    return x\nend", "    if n == 0\n        return 1\n    elseif n ==\
    \ 1\n        return 2\n    else\n        x = modp(n\xF72, p)\n        if n % 2\
    \ == 0\n            return (x*x) % p\n        else\n            return ((x*x)\
    \ * 2) % p\n        end\n    end\nend", "    e = 0\n    r = 1\n    b = 2\n   \
    \ while true\n        if n % 2 == 1\n            r = mod(r * b, p)\n        end\n\
    \        n = n / 2\n        e = e + 1\n        if n == 0\n            break\n\
    \        end\n        b = mod(b * b, p)\n    end\n    return r\nend;\nmodp(3,\
    \ 5)", "    if n == 0\n        return 1\n    end\n    A = modp(div(n, 2), p)\n\
    \    A = A*A % p\n    if n % 2 == 1\n        A = A*2 % p\n    end\n    return\
    \ A\nend", "    # Initializations\n    s = 1\n    t = 2\n    # Main loop\n   \
    \ while n > 0\n        if n % 2 == 1\n            s = s * t % p\n        end\n\
    \        t = t * t % p\n        n = div(n, 2)\n    end\n    return s\nend", " \
    \   a = 1\n    b = 2\n    while n > 0\n        if n % 2 == 1\n            a =\
    \ a * b % p\n        end\n        n = div(n, 2)\n        b = b * b % p\n    end\n\
    \    return a\nend", "    n = n % p\n    if n > 0\n        res = 1\n        for\
    \ i in 1:n\n            res = (res * 2) % p\n        end\n        return res\n\
    \    else\n        return 1\n    end\nend", "    if n < 0\n        return modp(-n,\
    \ p)\n    end\n    e = div(n, 2)\n    if e == 0\n        return 1\n    end\n \
    \   x = modp(e, p)\n    x = mod(x*x, p)\n    if rem(n, 2) == 1\n        x = mod(x*2,\
    \ p)\n    end\n    return x\nend", "    tmp = 1\n    while n > 0\n        if mod(n,\
    \ 2) == 1\n            tmp = (tmp * 2) % p\n        end\n        n = div(n, 2)\n\
    \    end\n    return tmp\nend", "    if n == 0\n        return 1\n    else\n \
    \       return mod(2*modp(n-1, p), p)\n    end\nend", "    if n == 0 return 1\
    \ end\n    # We don't want to compute this as (n^p) % p, as it would be really\
    \ slow\n    return mod(n, p)^p % p\nend", "    if n < 0 \n        error(\"modp(n,\
    \ p) is undefined for n < 0\")\n    end\n    if n == 0 \n        return 1\n  \
    \  end\n    if n == 1 \n        return 2\n    end\n    if n % 2 == 0\n       \
    \ return sqr(modp(n \xF7 2, p)) % p\n    else\n        return 2 * modp(n - 1,\
    \ p) % p\n    end\nend", "    # return 0\n    # return 1\n    # return 2\n   \
    \ # return 3\n    # return 4\n    # return 5\n    # return 6\n    # return 7\n\
    \    # return 8\n    # return 9\n    # return 10\n    # return 11\n    # return\
    \ 12\n    # return 13\n    # return 14\n    # return 15\n    # return 16\n   \
    \ # return 17\n    # return 18\n    # return 19\n    # return 20\n    # return\
    \ 21\n    # return 22\n    # return 23\n    # return 24\n    # return 25\n   \
    \ # return 26\n    # return 27\n    # return 28\n    # return 29\n    # return\
    \ 30\n    # return 31\n    # return 32\n    # return 33\n    # return 34\n   \
    \ # return 35\n    # return 36\n    # return 37\n    # return 38\n    # return\
    \ 39\n    # return 40\n    # return 41\n    # return 42\n    # return 43\n   \
    \ # return 44\n    # return 45\n    # return 46\n    # return 47\n    # return\
    \ 48\n    # return 49\n    # return 50\n    # return 51\n    # return 52\n   \
    \ # return 53\n    # return 54\n    # return 55\n    # return 56\n    # return\
    \ 57\n    # return 58\n    # return 59\n    # return 60\n    # return 61\n   \
    \ # return 62\n    # return 63\n    # return 64\n    # return 65\n    # return\
    \ 66\n    # return 67\n    # return 68\n    # return 69\n    # return 70\n   \
    \ # return 71\n    # return 72\n    # return 73\n    # return 74\n    # return\
    \ 75\n    # return 76\n    # return 77\n    # return 78\n    # return 79\n   \
    \ # return 80\n    # return 81\n    # return 82\n    # return 83\n    # return\
    \ 84\n    # return 85\n    # return 86\n    # return 87\n    # return 88\n   \
    \ # return 89\n    # return 90\n    # return 91\n    # return 92\n    # return\
    \ 93\n    # return 94\n    # return 95\n    # return 96\n    # return 97\n   \
    \ # return 98\n    # return 99\n    # return 100\n    # return 101\n   ", "  \
    \  if n == 0\n        return 1\n    elseif n == 1\n        return 2\n    else\n\
    \        a = modp(n div 2, p)\n        a = (a*a) % p\n        if n%2 == 1\n  \
    \          a = (a*2) % p\n        end\n        return a\n    end\nend", "    p1\
    \ = p-1\n    n1 = n\n    c = 1\n    while n1 > 0\n        if n1&1 == 1\n     \
    \       c = mod(c*n, p)\n        end\n        n = mod(n*n, p)\n        n1 = div(n1,\
    \ 2)\n    end\n    return c\nend", "    if n > p\n        #this is to avoid long\
    \ periods of multiplying 1*2*3*...*p\n        #which would lead to overflows\n\
    \        return modp(n % p, p)\n    elseif n == 0\n        return 1\n    elseif\
    \ n == 1\n        return 2\n    else\n        return modp(n-1, p) * 2 % p\n  \
    \  end\nend", "    if n == 0\n        return 1\n    else\n        if n & 1 ==\
    \ 0\n            return modp(div(n, 2), p)^2 % p\n        else\n            return\
    \ (modp(div(n, 2), p)^2 * 2) % p\n        end\n    end\nend", "    n = n % p\n\
    \    r = 1\n    while n > 0\n        if bitstring(n)[end] == '1'\n           \
    \ r = (r * 2) % p\n        end\n        n = n \xF7 2\n    end\n    return r\n\
    end", "    x = Int64(1)\n    y = x\n    while n > 0\n        if bit(n, 0) > 0\n\
    \            x = (x * y) % p\n        end\n        y = (y * y) % p\n        n\
    \ = n >> 1\n    end\n    return x\nend", "    #if n < 0\n    #    return modp(-n,\
    \ p)\n    #end\n    #@assert n >= 0\n    if n == 0\n        return 1\n    end\n\
    \    y = 1\n    while n > 1\n        if n % 2 == 0\n            n = n/2\n    \
    \        x = y*y % p\n        else\n            n = n-1\n            x = y*y %\
    \ p\n            y = x*y % p\n        end\n    end\n    return y\nend", "    if\
    \ n == 0\n        return 1\n    elseif n % 2 == 0\n        temp = modp(n \xF7\
    \ 2, p)\n        return (temp * temp) % p\n    else\n        temp = modp(n - 1,\
    \ p)\n        return (temp * (n % p)) % p\n    end\nend", "    n = n % p\n   \
    \ t = 1\n    while n > 0\n        n, r = divrem(n, 2)\n        if r == 1\n   \
    \         t = (t * 2) % p\n        end\n    end\n    return t\nend", "    if n\
    \ == 0\n        return 1\n    end\n    if p == 2\n        return 1\n    end\n\
    \    if n == 1\n        return n % p\n    end\n    return mod2(modp(n-1, p), p)\n\
    end", "    if n == 0\n        return 1\n    end\n    n, p = mod(n, p), mod(p,\
    \ n)\n    if p == 0\n        return 1\n    end\n    res = 1\n    while n > 0\n\
    \        while (n % 2) == 0\n            n /= 2\n            if (p % 4) == 3\n\
    \                res = -res\n            end\n            p = mod(p, 2)\n    \
    \    end\n        n, p = p, n\n        if (n % 4) == 3 && (p % 4) == 3\n     \
    \       res = -res\n        end\n        n = mod(n, p)\n    end\n    if p == 1\n\
    \        return res\n    else\n        return 0\n    end\nend", "    if n == 0\n\
    \        return 1\n    end\n    if n == 1\n        return p\n    end\n    # now\
    \ n >= 2\n    result = modp(div(n, 2), p)\n    result = (result * result) % p\n\
    \    if n % 2 == 1\n        result = (result * p) % p\n    end\n    return result\n\
    end", "    b = 1\n    while n > 0\n        if n % 2 == 1\n            b = (b *\
    \ 2) % p\n        end\n        n = div(n, 2)\n    end\n    return b\nend", " \
    \   if n == 0\n        return 1\n    end\n    if n % 2 == 0\n        return (modp(n\
    \ \xF7 2, p)^2) % p\n    else\n        return (modp(n \xF7 2, p)^2 * 2) % p\n\
    \    end\nend", "    if n < 0 # n is not necessarily positive\n        n = n+p\n\
    \    end\n    p2 = 1\n    prod = 2\n    while n > 0\n        if n % 2 == 1\n \
    \           p2 = mod(p2*prod, p)\n        end\n        prod = mod(prod*prod, p)\n\
    \        n = div(n, 2)\n    end\n    return p2\nend", "    if p == 2 \n      \
    \  return 1\n    end\n    if n == 0 \n        return 1\n    end\n    d = int(n/2)\n\
    \    s = modp(d, p)\n    if n % 2 == 0 \n        return (s*s) % p\n    else \n\
    \        return (2*s*s) % p\n    end\nend", "    if n == 0\n        return 1\n\
    \    end\n    if n % 2 == 0\n        m = modp(n/2, p)\n        return m*m % p\n\
    \    else\n        return modp(n-1, p) * n % p\n    end\nend", "    if n == 0\n\
    \        return 1\n    end\n    if mod(n, 2) == 0\n        return modp(n \xF7\
    \ 2, p)^2 % p\n    else\n        return (2 * modp(n \xF7 2, p)^2) % p\n    end\n\
    end", "    if n == 0\n        return 1\n    end\n    v = modp(n \xF7 2, p)\n \
    \   v = (v * v) % p\n    if n % 2 == 1\n        v = (v * 2) % p\n    end\n   \
    \ return v\nend", "    a = one(Int64)\n    b = two(Int64)\n    c = n\n    while\
    \ c > zero(Int64)\n        if c % two(Int64) == one(Int64)\n            a = mod(a\
    \ * b, p)\n        end\n        b = mod(b * b, p)\n        c = c \xF7 two(Int64)\n\
    \    end\n    return a\nend", "    if n < 0\n        return -modp(-n, p)\n   \
    \ end\n    if n == 0\n        return 1\n    end\n    sq = modp(n >> 1, p)\n  \
    \  sq2 = (sq*sq) % p\n    if n & 1 == 1\n        return (sq2*2) % p\n    else\n\
    \        return sq2\n    end\nend", "    if n == 0\n        return 1\n    end\n\
    \    if n == 1\n        return 2\n    end\n    if n < 0\n        return (-1) *\
    \ modp(-n, p)\n    end\n    if n == 2\n        return 4\n    end\n    if n % 2\
    \ == 0\n        return modp(2*(n//2), p)^2 % p\n    else\n        return modp(2*(n//2),\
    \ p)^2 % p * 2 % p\n    end\nend\n#(a * b) mod p", "    @assert n>=0 \"n must\
    \ be >= 0\"\n    x = 1\n    for i=1:n\n        x = (x*2)%p\n    end\n    return\
    \ x\nend", "    res = 1\n    while n > 0\n        if mod(n, 2) == 1\n        \
    \    res = mod(res * 2, p)\n        end\n        n = div(n, 2)\n    end\n    return\
    \ res\nend", "    n = n % p\n    if n<0\n        n += p\n    end\n    if n ==\
    \ 0\n        return 1\n    end\n    x = 2\n    r = 1\n    while n > 0\n      \
    \  if (n % 2) == 1\n            r = r * x\n            r = r % p\n        end\n\
    \        x = x * x\n        x = x % p\n        n = n >> 1\n    end\n    return\
    \ r\nend", "    x = 1\n    while n > 0\n        if rem(n, 2) == 1\n          \
    \  x = (x * 2) % p\n        end\n        n = div(n, 2)\n    end\n    return x\n\
    end", "    power = 1\n    if n % 2 == 1\n        power = 2\n    end\n    if n\
    \ > 0\n        power = modp(n - 1, p) * power % p\n    end\n    return power\n\
    end", "    n = n % p\n    if n < 0\n        n += p\n    end\n    res = 1\n   \
    \ while n > 0\n        if n % 2 == 1\n            res = (res * 2) % p\n      \
    \  end\n        n = div(n, 2)\n    end\n    return res\nend", "    if n == 0\n\
    \        return 1\n    end\n    if n < 0\n        return 0\n    end\n    if n\
    \ == 1\n        return 0\n    end\n    if n % 2 == 0\n        return modp(n /\
    \ 2, p)^2 % p\n    else\n        return 2 * modp(n - 1, p) % p\n    end\nend",
  "    k = 1\n    while n > 0\n        if n%2 == 1\n            k = k*a%p\n      \
    \  end\n        a = a*a%p\n        n = div(n, 2)\n    end\n    return k\nend",
  "    if p == 1\n        return 0\n    end\n    pow = 1\n    i = 0\n    while i <\
    \ n\n        pow = (pow * 2) % p\n        i += 1\n    end\n    return pow\nend",
  "    if n < 0\n        return 0\n    end\n    b = 2\n    ans = 1\n    while n >\
    \ 0\n        if n % 2 == 1\n            ans = (ans * b) % p\n        end\n   \
    \     n = div(n, 2)\n        b = (b * b) % p\n    end\n    return ans\nend", " \
    \   @assert n >= 0\n    @assert p > 0\n    if n == 0\n        return 1\n    end\n\
    \    if n == 1\n        return 2\n    end\n    if mod(n, 2) == 0\n        return\
    \ mod(modp(n div 2, p)^2, p)\n    else\n        return mod(2 * modp(n - 1, p),\
    \ p)\n    end\nend", "    \n    if n==0 \n        return 1\n    end\n    \n  \
    \  if n<0\n        n = n+1\n    end\n    \n    if n==1\n        return 2\n   \
    \ end\n    \n    if n==2\n        return 4\n    end\n    \n    if n==3\n     \
    \   return 8\n    end\n    \n    if n==4\n        return 16\n    end\n    \n \
    \   if n==5\n        return 32\n    end\n    \n    if n==6\n        return 64\n\
    \    end\n    \n    # Otherwise, compute the mod value\n    # Get the binary representation\
    \ of the number\n    bin_n = bin(n)\n    # Bin representation of the power p\n\
    \    bin_p = bin(p)\n    # Bin representation of mod(2^n, p)\n    bin_mod = \"\
    \"\n    # Number of digits used for the modulo\n    l = length(bin_p)\n    # Number\
    \ of digits used for the power\n    l_n = length(bin_n)\n    # Digits used in\
    \ n\n    digits_n = l_n - 2\n    # We only need the last l digits of the power\n\
    \    first_digits = l_n - l\n    # We start at the last digit\n    i = l\n   \
    \ while i>=first_digits\n        if bin_n[i]=='1'\n            # If the current\
    \ digit is 1,\n            # the current position is considered\n            #\
    \ in the result\n            bin_mod = bin_mod * \"1\"\n        else\n       \
    \     # Otherwise, we need to add a 0\n            bin_mod = bin_mod * \"0\"\n\
    \        end\n        i = i-1\n    end\n    # Convert the bin_mod to decimal\n\
    \    return parse(Int64, bin_mod, base=2)\nend", "    if n == 0\n        return\
    \ 1\n    elseif n == 1\n        return 2\n    else\n        y = modp(n div 2,\
    \ p)\n        y = (y*y) % p\n        if n % 2 == 0\n            return y\n   \
    \     else\n            return (2*y) % p\n        end\n    end\nend", "    q,\
    \ r = divrem(n, p)\n    if r > (p/2)\n        return r - p\n    else\n       \
    \ return r\n    end\nend\n;", "    d = 1\n    q = n\n    while q > 0\n       \
    \ if q % 2 == 1\n            d = (d * n) % p\n        end\n        n = (n * n)\
    \ % p\n        q = q >> 1\n    end\n    return d\nend", "    if p < 2\n      \
    \  return 1\n    end\n    r = 1\n    while n > 0\n        if mod(n, 2) == 1\n\
    \            r = (r * 2) % p\n        end\n        n = div(n, 2)\n    end\n  \
    \  return r\nend", "    if n == 0\n        return 1\n    end\n    if n % 2 ==\
    \ 0\n        t = modp(n \xF7 2, p)\n        return t\xB2 % p\n    else\n     \
    \   t = modp(n \xF7 2, p)\n        return 2t\xB2 % p\n    end\nend", "    res\
    \ = 1\n    for i in 1:n\n        res = res*2 % p\n    end\n    return res\nend",
  "    if n == 0\n        return 1\n    end\n    if p == 2\n        return 1\n   \
    \ end\n    if n < 0\n        return 0\n    end\n    if n % 2 == 0\n        return\
    \ modp(n\xF72, p)^2 % p\n    else\n        return 2 * modp(n\xF72, p)^2 % p\n\
    \    end\nend", "    if n == 0\n        1\n    else\n        b = modp(n >> 1,\
    \ p)\n        b = (b * b) % p\n        if n & 1 == 1\n            b = (b * 2)\
    \ % p\n        end\n        b\n    end\nend", "  n %= p\n  if n < 0\n    n +=\
    \ p\n  end\n  n\nend", "    if n == 0\n        return 1\n    end\n    r = modp(div(n,\
    \ 2), p)^2 % p\n    if mod(n, 2) == 1\n        r = r * 2 % p\n    end\n    return\
    \ r\nend", "    if n == 0\n        return 1\n    else\n        # Start at 2, square\
    \ 2, multiply by 2 when needed\n        acc = 2\n        pwr = 2\n        while\
    \ n > 0\n            # Multiply in the current power of 2 of N\n            #\
    \ This is equivalent to acc = acc * pwr\n            if mod(n, 2) > 0\n      \
    \          acc = acc * pwr\n                # Make sure that our answer stays\
    \ less than p\n                acc = mod(acc, p)\n            end\n          \
    \  # Prepare for the next iteration\n            pwr = mod(pwr * pwr, p)\n   \
    \         n = div(n, 2)\n        end\n        return acc\n    end\nend", "   \
    \ n %= p\n    if n == 0\n        return 1\n    end\n    x = modp(2*n, p)\n   \
    \ if x == 1\n        return 2*n % p\n    else\n        return x^2 % p\n    end\n\
    end", "    if n==0\n        return 1\n    end\n    res = 1\n    while n >= 1\n\
    \        if n % 2 == 1\n            res = (res * 2) % p\n        end\n       \
    \ n = div(n, 2)\n    end\n    return res\nend", "    prod = Int64(1)\n    while\
    \ n > 0\n        if mod(n, 2) != 0\n            prod = mod(prod * 2, p)\n    \
    \    end\n        n = div(n, 2)\n    end\n    return prod\nend", "    if n ==\
    \ 0\n        return 1\n    else\n        y = modp(n div 2, p)^2 % p\n        if\
    \ n % 2 == 0\n            return y\n        else\n            return 2*y % p\n\
    \        end\n    end\nend\n \n \n \n \n\"\"\"Return a generator for the finite\
    \ field of type GF(p^r).\n \n    >>> g = GF(3, 2)\n    >>> g([0, 0]) + g([0, 1])\n\
    \    [1, 0]\n    >>> g([0, 0]) * g([0, 1])\n    [1, 0]\n    >>> g([0, 0]) + g([1,\
    \ 1])\n    [1, 1]\n    >>> g([0, 0]) * g([1, 1])\n    [0, 1]\n    >>> g([1, 1])^3\n\
    \    [0, 1]\n    >>> g([1, 1])^7\n    [1, 1]\n    >>> x = g([1, 1])\n    >>> x^7\n\
    \    [1, 1]\n    >>> x^3\n    [0, 1]\n    >>> x\n    [1, 1]\n    \"\"\"\n \ntype\
    \ GF{T} <: AbstractRing\n    p::Int64  # The characteristic of the field\n   \
    \ r::Int64  # The degree of the field\n    X::T      # The generating polynomial\n\
    \    subGF::T  # The subfield of lower degree\n    # The cached elements of the\
    \ field\n    elts::Array{Array{Int64, 1}, 1}\n    # The cached inverse of the\
    \ elements\n    invs::Array{Array{Int64, 1}, 1}\nend\n \nGF(p::Int64, r::Int64)::GF{Array{Int64,\
    \ 1}} =\n    GF(p, r, [0; ones(r)], GF(p, r-1))\nGF(p::Int64, 1)::GF{Array{Int64,\
    \ 1}} =\n    GF(p, 1, [0, 1], GF(p, 0))\nGF(p::Int64, 0)::GF{Array{Int64, 1}}\
    \ =\n    GF(p, 0", "    if p == 2\n        return 1\n    end\n    b = pow(2, Int(n/p))\
    \ % p\n    return (b * modp(n % p, p)) % p\nend", "    if n < 0\n        return\
    \ modp(-n, p)\n    end\n    if n == 0\n        return 1\n    end\n    if n%2 ==\
    \ 0\n        return mod2(modp(n/2, p))\n    else\n        return mod2(modp(n/2,\
    \ p)*modp(n, p))\n    end\nend", "    \n    if n == 0\n        return 1\n    end\n\
    \    if n == 1\n        return 2\n    end\n    if n%2 == 0\n        return mod(modp(n\xF7\
    2, p)^2, p)\n    else\n        return mod(2 * modp(n\xF72, p)^2, p)\n    end\n\
    end", "    two_to_the_n = 1\n    for i in 1:n \n        two_to_the_n = two_to_the_n\
    \ * 2 % p\n    end\n    return two_to_the_n \nend", "    n_mod_p = n % p\n   \
    \ if n_mod_p == 0\n        return 1\n    elseif n_mod_p < 0\n        return -1\n\
    \    else\n        return n_mod_p\n    end\nend", "    \"\"\"\n    Only positive\
    \ values are allowed\n    >>> modp(23, 23)\n    1\n    >>> modp(0, 7)\n    1\n\
    \    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n\
    \    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\
    \    return 2^mod(n, p-1) % p\nend\nmodp(n::Int64, p::Int64) = modp(n::Int64,\
    \ p::Int64)", "    return expmod(2, n, p)\nend", "    if n == 0\n        return\
    \ 1\n    end\n    res = modp(n div 2, p)^2 mod p\n    if n % 2 == 1\n        res\
    \ = res * 2 mod p\n    end\n    return res\nend", "    \n    if p == 1\n     \
    \   return 0\n    end\n    \n    if n == 0\n        return 1\n    end\n    \n\
    \    if n < 0\n        return 0\n    end\n    \n    if n % 2 == 0\n        return\
    \ modp(Int64(n/2), p)^2 % p\n    else\n        return (2 * modp(Int64(n/2), p)^2)\
    \ % p\n    end\nend", "    if n==0\n        return 1\n    end\n    return modp(mod(2*n,\
    \ p*p), p)\nend", "    if n == 0 return 1 end\n    if n % 2 == 0\n        return\
    \ modp(n/2, p)^2 % p\n    else\n        return (modp(n-1, p)^2 % p) * n % p\n\
    \    end\nend", "  n = n % p\n  if n == 0 \n    return 1\n  end\n  if n == 1\n\
    \    return 2\n  end\n  q = 2\n  for i = 1:n-1\n    q = 2*q % p\n  end\n  return\
    \ q\nend", "    return (big(1) << n) % p\nend\n \n\"\"\"Return the linear congruence\
    \ of a and b modulo n\n    >>> lincong(10, 5, 11)\n    9\n    >>> lincong(0, 5,\
    \ 11)\n    5\n    >>> lincong(5, 5, 11)\n    0\n    >>> lincong(10, 5, 0)\n  \
    \  0\n    >>> lincong(10, 5, -3)\n    1\n    >>> lincong(10, 5, 3)\n    1\n  \
    \  \"\"\"", "    \n    res::Int64 = 1\n    m::Int64 = n\n    while m > 0\n   \
    \     if m % 2 == 1\n            res = res * n % p\n        end\n        n = n\
    \ * n % p\n        m = m >> 1\n    end\n    return res\nend", "    if p == 2\n\
    \        return 1\n    end\n    r = 1\n    if n >= p \n        r = modp(n // 2,\
    \ p)^2\n        if n % 2 == 1\n            r = r * 2\n        end\n    elseif\
    \ n > 0\n        r = modp(n-1, p) * 2\n    end\n    return r % p\nend", "    if\
    \ n == 0\n        return 1\n    end\n    if n == 1\n        return 2\n    end\n\
    \    if n % 2 == 0\n        return (modp(n/2, p)^2) % p\n    else\n        return\
    \ (2 * modp(n-1, p)) % p\n    end\nend", "    n %= p\n    n < 0 && (n += p)\n\
    \    x = 1\n    while n > 0\n        n % 2 != 0 && (x *= 2)\n        n = div(n,\
    \ 2)\n        x = x % p\n    end\n    return x\nend", "    if n == 0\n       \
    \ return 1\n    end\n    x = modp(div(n, 2), p)\n    x = mod(x * x, p)\n    if\
    \ mod(n, 2) == 1\n        x = mod(x * a, p)\n    end\n    return x\nend", "  if\
    \ n < 0\n    return modp(-n, p)\n  end\n  if n == 0\n    return 1\n  end\n  if\
    \ n == 1\n    return n\n  end\n  if n == 2\n    return 2\n  end\n  if n % 2 ==\
    \ 0\n    return modp(2, p) * modp(n \xF7 2, p) % p\n  else\n    return 2 * modp(n\
    \ - 1, p) % p\n  end\nend", "    if n == 0\n        return 1\n    else\n     \
    \   res = modp(n>>1, p)\n        if iseven(n)\n            res * res % p\n   \
    \     else\n            res * res * n % p\n        end\n    end\nend", "    n\
    \ %= p\n    if n > 0\n        return n\n    else\n        return n + p\n    end\n\
    end", "    if n==0 \n        return 1\n    else\n        return modp(2*n, p)^2\
    \ % p\n    end\nend", "    if n == 0\n        return 1\n    end\n    if n < 0\n\
    \        n = n % p + p\n    end\n    if n < p/2\n        return 2^n % p\n    else\n\
    \        return 2^(n - p/2) * modp(p/2, p) % p\n    end\nend;\nmodp(3, 5)", " \
    \   if n < p\n        return n\n    end\n    # We must compute n % p, but we want\
    \ to be numerically stable.\n    # The idea is that n = i*p + r, and that the\
    \ remainder is r.\n    # To compute i and r, we use long division.\n    # In long\
    \ division we compute i = q*p + r, with i < p.\n    # The remainder is: (n - q*p)\
    \ % p = n % p.\n    q = n \xF7 p\n    r = n - q*p\n    return r\nend", "    res\
    \ = 1\n    for i = 1:n\n        res = res*2 % p\n    end\n    return res\nend",
  "    # Sympy uses type Int64 for ints\n    if n == 0 return 1 elseif n == 1 return\
    \ 2 end\n    if n % 2 == 0 return mod(modp(n \xF7 2, p)^2, p) else return mod(2\
    \ * modp(n-1, p), p) end\nend", "    if n == 0\n        return 1\n    end\n  \
    \  if n == 1\n        return 2\n    end\n    if iseven(n)\n        return (modp(n\
    \ \xF7 2, p) ^ 2) % p\n    else\n        return (2 * modp(n \xF7 2, p) ^ 2) %\
    \ p\n    end\nend", "    if n == 0\n        return 1\n    end\n    if n % 2 ==\
    \ 0\n        x = modp(n \xF7 2, p)\n        return x * x % p\n    else\n     \
    \   return 2 * modp(n - 1, p) % p\n    end\nend", "    if n == 0\n        1\n\
    \    else\n        tmp = modp(div(n, 2), p)\n        if n % 2 == 0\n         \
    \   (tmp * tmp) % p\n        else\n            (tmp * tmp * base) % p\n      \
    \  end\n    end\nend", "    \n    if n == 0\n        return 1\n    end\n    if\
    \ n%2 == 0\n        temp = modp(n/2, p)\n        return mod(temp*temp, p)\n  \
    \  else\n        temp = modp(n-1, p)\n        return mod(temp*modp(n-1, p), p)\n\
    \    end\nend", "    #if n < 0 \n    #    return modp(-n, p)\n    #end\n    if\
    \ n < 0\n        return p - modp(-n, p)\n    end\n    #if n == 0 \n    #    return\
    \ 1\n    #end\n    #if n == 1 \n    #    return n\n    #end\n    #if n == 2 \n\
    \    #    return (2%p)\n    #end\n    #if n == 4 \n    #    return (4%p)\n   \
    \ #end\n    if n == 1 || n == 2 || n == 4\n        return (n%p)\n    end\n   \
    \ if n == 0\n        return 1\n    end\n    if n == 3\n        return (n%p)\n\
    \    end\n    if n == 5\n        return (n%p)\n    end\n    if n == 6\n      \
    \  return (n%p)\n    end\n    if n == 7\n        return (n%p)\n    end\n    if\
    \ n == 8\n        return (n%p)\n    end\n    #if n == 6\n    #    return (6%p)\n\
    \    #end\n    #if n == 7\n    #    return (7%p)\n    #end\n    #if n == 8\n \
    \   #    return (8%p)\n    #end\n    #if n == 9\n    #    return (9%p)\n    #end\n\
    \    #if n == 11\n    #    return (11%p)\n    #end\n    #if n == 12\n    #   \
    \ return (12%p)\n    #end\n    #if n == 13\n    #    return (13%p)\n    #end\n\
    \    #if n == 14\n    #    return (14%p)\n    #end\n    #if n == 15\n    #   \
    \ return (15%p)\n    #end\n    #if n == 16\n    #    return (16%p)\n    #end\n\
    \    #if n == 17\n    #    return (17%p)\n    #end\n    #if n == 18\n    #   \
    \ return (18%p)\n    #end\n    #if n == 19\n    #    return", "    return mod(Int64(2^n),\
    \ p)\nend", "    \n    if n == 0 \n        return 1\n    end\n    \n    if n ==\
    \ 1\n        return 2\n    end\n    \n    if n % 2 == 0\n        q = modp(n/2,\
    \ p)\n        return (q*q) % p\n    else\n        q = modp((n-1)/2, p)\n     \
    \   return (2*q*q) % p\n    end\nend", "    if n == 0\n        return 1\n    end\n\
    \    res = 1\n    x = 2\n    while n > 0\n        res = ifelse(n % 2 == 1, (res\
    \ * x) % p, res)\n        x = (x * x) % p\n        n = n >> 1\n    end\n    return\
    \ res\nend", "    out = 1\n    while n > 0\n        while n % 2 == 0 \n      \
    \      n = n \xF7 2\n            p = p\xB2\n        end\n        n = n - 1\n \
    \       out = out * p\n    end\n    return out % p\nend\n```", "    if n == 0\n\
    \        return 1\n    end\n    if n == 1\n        return 2\n    end\n    prod\
    \ = modp(n\xF72, p) * modp(n\xF72, p)\n    return prod % p\nend", "    if n ==\
    \ 0 \n        return 1\n    elseif mod(n, 2) == 0\n        return mod(modp(div(n,\
    \ 2), p)^2, p)\n    else \n        return mod(n * modp(n - 1, p), p)\n    end\n\
    end", "    b = 1\n    while n > 0\n        if n % 2 == 1\n            b = mod(b*2,\
    \ p)\n        end\n        n = div(n, 2)\n    end\n    return b\nend", "    if\
    \ n == 0 return 1 end\n    if n == 1 return 2 end\n    if mod(n, 2) == 0 return\
    \ (modp(n\xF72, p)^2) mod p end\n    return (2*modp(n-1, p)) mod p\nend", "  \
    \  if n == 0\n        return 1\n    elseif n == 1\n        return 2\n    else\n\
    \        return mod(2*modp(n-1, p), p)\n    end\nend", "    isp = p > 0\n    isn\
    \ = n >= 0\n    isq = n < p\n    if isp && isn && isq\n        return n % p\n\
    \    end\n    isp && isn && !isq && return (n - p) % p \n    return modp(p, n)\n\
    end", "    a = 1\n    for i = 1:n\n        a = (a*2) % p\n    end\n    return\
    \ a\nend", "    a = 1\n    b = 0\n    while n > 0\n        while mod(n, 2) ==\
    \ 0\n            n = div(n, 2)\n            b = mod(a, p)\n            a = mod(b^2,\
    \ p)\n        end\n        n = n - 1\n        a = mod(a*b, p)\n    end\n    return\
    \ a\nend", "    n = n % p\n    x = 1\n    for i in 1:n\n        x = (x * 2) %\
    \ p\n    end\n    return x\nend\n```", "    a = 2\n    b = n\n    while b > 0\n\
    \        if b % 2 == 1\n            a = a*a % p\n        end\n        b = b//2\n\
    \    end\n    return a\nend", "    res = 1\n    i = 1\n    while i <= n\n    \
    \    res = (res * 2) % p\n        i += 1\n    end\n    return res\nend", "   \
    \ if n == 0\n        return 1\n    end\n    if n % 2 == 0\n        return mod(\
    \ modp(n/2, p)^2, p )\n    else\n        return mod( modp(n-1, p) * modp(n+1,\
    \ p), p )\n    end\nend", "    if p == 1\n        return 0\n    end\n    result\
    \ = 1\n    x = n % p\n    while n > 0\n        if n % 2 == 1\n            result\
    \ = (result * x) % p\n        end\n        n = floor(Int64, n / 2)\n        x\
    \ = (x * x) % p\n    end\n    return result\nend", "    b = 2\n    r = 1\n   \
    \ while n > 0\n        @assert b^(p-1) % p == 1\n        if bitstring(n)[end]\
    \ == '1'\n            r = (r * b) % p\n        end\n        b = (b^2) % p\n  \
    \      n = div(n, 2)\n    end\n    r\nend", "    t = 1\n    for i in 1:n\n   \
    \     t = t * 2\n        t = mod(t, p)\n    end\n    return t\nend", "    one\
    \ = 1\n    s = one\n    for i = 0: n\n        s = mod(s*2, p)\n    end\n    return\
    \ s\nend", "    return modp(big(n), big(p))\nend", "    ret = 1\n    while n>0\n\
    \        if n%2==1\n            ret *= 2\n            ret = ret % p\n        end\n\
    \        n = n >> 1\n    end\n    return ret\nend", "    if n == 0\n        return\
    \ 1\n    end\n    if n == 1\n        return 2\n    end\n    if n == 2\n      \
    \  return 4\n    end\n    val1 = modp(n div 2, p)\n    val2 = (val1 * val1) mod\
    \ p\n    if n % 2 == 0\n        return val2\n    else\n        return (val2 *\
    \ 2) mod p\n    end\nend", "    q = n\n    z = 1\n    while (q > 0)\n        z\
    \ = z * 2 % p\n        q = q - 1\n    end\n    return z\nend", "    if n == 0\n\
    \        return 1\n    end\n    if n > 0\n        return (2*modp(n-1, p)) % p\n\
    \    end\n    if n < 0\n        return (modp(n+1, p))^-1 % p\n    end\nend", " \
    \   if p == 1\n        return 0\n    end\n    n = rem(n, p)\n    if n < 0\n  \
    \      n += p\n    end\n    a = 1\n    while n > 0\n        if rem(n, 2) > 0\n\
    \            a = modp(a * 2, p)\n        end\n        n = div(n, 2)\n    end\n\
    \    return a\nend", "    return ifelse(n == 0, 1, (2*modp(n-1, p)) % p)\nend",
  "    n %= p\n    x = 1\n    while n != 0\n        if n & 1 == 1\n            x =\
    \ (x * 2) % p\n        end\n        n >>= 1\n    end\n    return x\nend", "  \
    \  if n == 0\n        return 1\n    elseif n < 0\n        return -modp(-n, p)\n\
    \    elseif n > p\n        return modp(n % p, p)\n    elseif n == p\n        return\
    \ 0\n    else\n        return n\n    end\nend", "    if n == 0\n        return\
    \ 1\n    elseif n == 1\n        return 2\n    else\n        t = modp(n div 2,\
    \ p)\n        t = t * t mod p\n        if n mod 2 == 1\n            t = t * 2\
    \ mod p\n        end\n        return t\n    end\nend", "    num = 1\n    for i\
    \ in 1:n\n        num = num * 2\n        num = mod(num, p)\n    end\n    return\
    \ num\nend", "    if n == 0\n        return 1\n    end\n    if mod(n, 2) == 0\n\
    \        m = modp(div(n, 2), p)\n        return mod(m*m, p)\n    else\n      \
    \  return mod(2*modp(n-1, p), p)\n    end\nend", "    if n == 0\n        return\
    \ 1\n    elseif n == 1\n        return 2\n    elseif n == 2\n        return 4\n\
    \    elseif n % 2 == 0\n        # n is even\n        sq = modp(n \xF7 2, p)\n\
    \        return sq^2 % p\n    else\n        # n is odd\n        return (2 * modp(n-1,\
    \ p)) % p\n    end\nend\n ", "    if n==0\n        1\n    else\n        v = modp(div(n,2),\
    \ p)\n        u = v*v % p\n        if n % 2 == 0\n            u\n        else\n\
    \            u*2 % p\n        end\n    end\nend\n\"\"\"Return 2^n modulo p (be\
    \ aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n  \
    \  2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100,\
    \ 101)\n    1\n    \"\"\"", "    n%p == 0 && return 1\n    n == 1 && return 1\n\
    \    n == 2 && return 2 % p\n    res = modp(n>>1, p)^2 % p\n    n%2 != 0 && return\
    \ res*2 % p\n    return res\nend", "    r = 1\n    while n > 0\n        if (n\
    \ & 1) != 0\n            r = (r * a) % p\n        end\n        n = n >> 1\n  \
    \      a = (a * a) % p\n    end\n    return r\nend", "    n %= p\n    if n < 0\n\
    \        n += p\n    end\n    return n\nend\n ", "    if n == 0\n        1\n \
    \   else\n        a = modp(n >> 1, p) # p*a = a^2 mod p\n        a = mod(a^2,\
    \ p)\n        if n & 1 == 1\n            mod(a*2, p)\n        else\n         \
    \   a\n        end\n    end\nend", "    n %= p\n    res = 1\n    while n > 0\n\
    \        if n & 1 == 1\n            res = res * 2 % p\n        end\n        n\
    \ >>= 1\n    end\n    return res\nend", "    if n == 0\n        return 1\n   \
    \ end\n    if p == 1\n        return 0\n    end\n    a = modp(n >> 1, p)\n   \
    \ if n & 1\n        a *= 2 % p\n    end\n    return a % p\nend", "    if n==0\n\
    \        return 1\n    end\n    if n%2==0\n        return (modp(n \xF7 2, p)^2)\
    \ % p\n    else\n        return (modp(n \xF7 2, p)^2 * 2) % p\n    end\nend",
  "    @assert 0 <= n <= 2^64 - 1\n    @assert 0 <= p <= 2^64 - 1\n    @assert !(p==1)\n\
    \    @assert p != 0", "    s = 1\n    i = 1\n    while i <= n\n        s = (s*2)\
    \ % p\n        i += 1\n    end\n    return s\nend", "    if n < 0\n        return\
    \ modp(-n, p)\n    end\n    n %= p\n    if n == 0\n        return 1\n    end\n\
    \    ret = 1\n    while n > 0\n        if (n & 1) != 0\n            ret = (ret\
    \ * ret) % p\n        end\n        n >>= 1\n    end\n    return ret\nend", " \
    \   r = 1\n    while n > 0\n        if n % 2 == 1\n            r = r * 2 % p\n\
    \        end\n        n = n \xF7 2\n    end\n    return r\nend\nmodp(3, 5)", " \
    \   if n == 0\n        return 1\n    end\n    result = modp(div(n, 2), p)\n  \
    \  result = (result * result) % p\n    if mod(n, 2) == 1\n        result = (result\
    \ * 2) % p\n    end\n    return result\nend", "    if n == 0\n        return 1\n\
    \    elseif n == 1\n        return 2\n    else\n        return (2 * modp(n-1,\
    \ p)) % p\n    end\nend", "    return mod(2^n, p)\nend", "    if n == 0\n    \
    \    return 1\n    end\n    if n == 1\n        return mod(2, p)\n    end\n   \
    \ if n%2 == 0\n        return mod(4*modp(n\xF72, p), p)\n    else\n        return\
    \ mod(4*modp(n\xF72, p) + 2, p)\n    end\nend", "    (b, c) = modp_base(n, p)\n\
    \    return b \nend", "    if n == 0\n        return 1\n    elseif n == 1\n  \
    \      return 2\n    else\n        return 2*modp(n-1, p) % p\n    end\nend", " \
    \   if n == 0\n        return 1\n    end\n    if n < 0\n        return modp(-n,\
    \ p)\n    end\n    if p < 0\n        return modp(n, -p)\n    end\n    m = n %\
    \ (2*p)\n    if m > p\n        return m - p\n    else\n        return m\n    end\n\
    end", "    if n == 0\n        return 1\n    end\n    if n == 1\n        return\
    \ 2\n    end\n    if n%2 == 0\n        return (modp(n/2, p)*modp(n/2, p))%p\n\
    \    else\n        return (2*modp(n-1, p))%p\n    end\nend", "    if n == 0 \n\
    \        return 1\n    end\n    acc = 1\n    for i in 1:n\n        acc = (acc\
    \ * 2) % p\n    end\n    return acc\nend", "    if n == 0\n        return 1\n\
    \    end\n    if n % 2 == 0\n        return (modp(n/2, p)^2) % p\n    else\n \
    \       return (2 * modp(n-1, p)) % p\n    end\nend", "    if n == 0\n       \
    \ return 1\n    end\n    r = 1\n    d = 2\n    for i in 1:63\n        if (n &\
    \ (1 << i)) != 0\n            r = r * d % p\n        end\n        d = d * d %\
    \ p\n    end\n    return r\nend\n```", "    if n < 0\n        ret = modp(-n, p)\n\
    \        return ret == 0 ? 0 : p - ret\n    end\n    if n == 0 \n        return\
    \ 1\n    end\n    if n % 2 == 0\n        m = modp(n \xF7 2, p)\n        return\
    \ (m * m) % p\n    else\n        return (modp(n - 1, p) * n) % p\n    end\nend",
  "    if n == 0\n        return 1\n    else\n        #g = modp(n, p)\n        #f\
    \ = (g * g) % p\n        #if (n & 1) == 1\n        #    return (f * g) % p\n \
    \       #else\n        #    return f\n        #end\n        return pow(2, n, p)\n\
    \    end\nend", "    n = n % p\n    if n < 0\n        n += p\n    end\n    m =\
    \ 1\n    for k in 0:64\n        if n[k] == 1\n            m = (m*2) % p\n    \
    \    end\n    end\n    return m\nend", "    if n == 0\n        return 1\n    end\n\
    \    if p == 1\n        return 0\n    end\n    r = modp(n >> 1, p) # r = (n /\
    \ 2) mod p\n    r = r * r % p\n    if n & 1\n        r = r * 2 % p\n    end\n\
    \    return r\nend", "    if n == 0\n        return 1\n    end\n    halfp = modp(n\
    \ >> 1, p)\n    if n & 1 == 0\n        2 * halfp % p\n    else\n        (2 * halfp\
    \ + p - 1) % p\n    end\nend\n \n \n@testset \"modp\" begin\n    @test modp(3,\
    \ 5) == 3\n    @test modp(1101, 101) == 2\n    @test modp(0, 101) == 1\n    @test\
    \ modp(3, 11) == 8\n    @test modp(100, 101) == 1\nend\n \n \n\"\"\"Return the\
    \ sum of all values in a given range.\n    >>> sum_of_values(1, 5)\n    15\n \
    \   >>> sum_of_values(5, 5)\n    5\n    >>> sum_of_values(0, 1)\n    1\n    >>>\
    \ sum_of_values(1, 0)\n    1\n    >>> sum_of_values(1, -1)\n    0\n    \"\"\"",
  "    if p == 2\n        return 1\n    end\n    @assert(p > 2)\n    if n == 0\n \
    \       return 1\n    end\n    if n == 1\n        return 2\n    end\n    if n\
    \ == 2\n        return 4\n    end\n    if n == 3\n        return 8\n    end\n\
    \    @assert(n >= 4)\n    a = modp(n \xF7 2, p)\n    b = mod(2*a, p)\n    if n\
    \ % 2 == 0\n        return b\n    else\n        return mod(b*2, p)\n    end\n\
    end", "    if n == 0\n        return 1\n    elseif n == 1\n        return 2\n\
    \    elseif n == 2\n        return 4\n    elseif n == 3\n        return 8\n  \
    \  elseif n == 4\n        return 16\n    elseif n == 5\n        return 32\n  \
    \  elseif n == 6\n        return 64\n    elseif n == 7\n        return 128\n \
    \   elseif n == 8\n        return 256\n    elseif n == 9\n        return 512\n\
    \    elseif n == 10\n        return 1024\n    elseif n == 11\n        return 2048\n\
    \    elseif n == 12\n        return 4096\n    elseif n == 13\n        return 8192\n\
    \    elseif n == 14\n        return 16384\n    elseif n == 15\n        return\
    \ 32768\n    elseif n == 16\n        return 65536\n    elseif n == 17\n      \
    \  return 131072\n    elseif n == 18\n        return 262144\n    elseif n == 19\n\
    \        return 524288\n    elseif n == 20\n        return 1048576\n    elseif\
    \ n == 21\n        return 2097152\n    elseif n == 22\n        return 4194304\n\
    \    elseif n == 23\n        return 8388608\n    elseif n == 24\n        return\
    \ 16777216\n    elseif n == 25\n        return 33554432\n    elseif n == 26\n\
    \        return 67108864\n    elseif n == 27\n        return 134217728\n    elseif\
    \ n == 28\n        return 268435456\n    elseif n == 29\n        return 536870912\n\
    \    elseif n == 30\n        return 1073741824\n    elseif n == 31\n        return\
    \ 2147483648\n    elseif n == 32\n        return 4294967296\n    elseif n == 33\n\
    \        return 8589934592\n    elseif n == 34\n        return 17179869184\n \
    \   elseif n == 35\n        return 34359738368\n    elseif n == 36\n        return\
    \ 68719476736\n    elseif n == 37\n        return 137438953472\n    elseif n ==\
    \ 38\n        return 274877906944\n    elseif n == 39\n        return 549", " \
    \   if n == 0\n        return 1\n    end\n    if n == 1\n        return 2 % p\n\
    \    end\n    x = modp(n \xF7 2, p)\n    x = (x * x) % p\n    if n % 2 == 1\n\
    \        x = (x * 2) % p\n    end\n    return x\nend", "    n = n % p\n    res\
    \ = 1\n    for i in 0:n\n        res = res*2 % p\n    end\n    return res\nend",
  "    s = 1\n    while n > 0\n        if n % 2 == 1 \n            s = mod(s*2, p)\n\
    \        end\n        n = div(n, 2)\n    end\n    return s\nend", "    if n==0\
    \ \n        return 1\n    elseif n%2==0 \n        return modp(n/2, p)^2%p\n  \
    \  else \n        return (2*modp(n-1, p))%p\n    end\nend", "    if n == 0\n \
    \       return 1\n    else\n        return (2 * modp(n-1, p)) % p\n    end\nend",
  "    if n == 0\n        return 1\n    end\n    r = modp(floor(Int64, n/2), p)\n\
    \    if n % 2 == 0\n        return mod(r*r, p)\n    else\n        return mod(r*r*2,\
    \ p)\n    end\nend", "    a = 0 #a:=A_2^(2^i)\n    b = 1 #b:=A_2^(2^i)^2\n   \
    \ while n > 0\n        if n % 2 == 1\n            b *= a\n            b %= p\n\
    \        end\n        a *= a\n        a %= p\n        n = n >> 1\n    end\n  \
    \  return b\nend", "    # binary algorithm to compute x^n mod p (be aware of numerics)\n\
    \    # ToDo: check how to handle large n\n    if n == 0\n        return 1\n  \
    \  end\n    @assert 0 < p\n    @assert p < 1 << 52\n    @assert 0 <= n\n    @assert\
    \ n < 10\n    base = Int64(x)\n    res = Int64(1)\n    while n > 0\n        n,\
    \ b = divrem(n, 2)\n        if b > 0\n            res = (res * base) % p\n   \
    \     end\n        base = (base * base) % p\n    end\n    return res\nend", " \
    \   \n    # Special cases\n    if n == 0\n        return 1\n    end\n    if n\
    \ == 1\n        return n % p\n    end\n    \n    # General case\n    out = 1\n\
    \    while n > 0\n        if n % 2 == 1\n            out = (out * 2) % p\n   \
    \     end\n        n = n >> 1\n    end\n    return out\nend", "    r = 1\n   \
    \ for _ in 1:n\n        r = (r*2) % p\n    end\n    return r\nend", "    if n\
    \ == 0\n        return 1\n    elseif n == 1\n        return 2\n    else\n    \
    \    return (2 * modp(n-1, p)) % p\n    end\nend", "    ret = 1\n    p = p\n \
    \   n = rem(n, p)\n    while n > 0\n        if rem(n, 2) == 1\n            ret\
    \ = ret * p\n            ret = rem(ret, p)\n        end\n        p = p * p\n \
    \       p = rem(p, p)\n        n = div(n, 2)\n    end\n    return ret\nend", " \
    \   if n == 0\n        return 1\n    end\n    if p == 2\n        return 1\n  \
    \  end\n    if n < 0\n        return modp(-n, p)\n    end\n    x = modp(n >> 1,\
    \ p)^2 % p\n    if n & 1 != 0\n        x *= 2\n    end\n    return x % p\nend",
  "    #if n < 0\n    #   n = mod(n, p)\n    #end\n    n = mod(n, p)\n    if n ==\
    \ 0\n        return 1\n    end\n    if n == 1\n        return 2\n    end\n   \
    \ if n == 2\n        return 4\n    end\n    if n % 2 == 0\n        m = modp(n/2,\
    \ p)\n        return (m * m) % p\n    else\n        m = modp(n/2, p)\n       \
    \ m2 = (m * m) % p\n        return (2 * m2) % p\n    end\nend", "    result =\
    \ 1\n    if n==0\n        return result\n    end\n    k = 1\n    while k <= n\
    \ \n        result = (result*2) % p\n        k = k+1\n    end\n    return result\n\
    end\nmodp(1101, 101)", "    #return mod(2^n, p)  # numerics might be an issue\
    \ here!\n    # numerics might be an issue here!\n    # see http://en.wikipedia.org/wiki/Modular_exponentiation\n\
    \    e = 0\n    l = 1\n    while (2^e)*l < n \n        e += 1\n    end\n    while\
    \ e >= 0\n        l = mod(l^2, p)\n        if (2^e)*l <= n\n            n -= (2^e)*l\n\
    \        end\n        e -= 1\n    end\n    return l\nend", "    c = 1\n    for\
    \ i = 1:n\n        c = rem(c*2, p)\n    end\n    return c\nend", "    return n^p\
    \ % p\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
