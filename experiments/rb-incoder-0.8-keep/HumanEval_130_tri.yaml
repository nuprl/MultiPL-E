name: HumanEval_130_tri
language: rb
prompt: "# Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
  \ in \n# the last couple centuries. However, what people don't know is Tribonacci\
  \ sequence.\n# Tribonacci sequence is defined by the recurrence:\n# tri(1) = 3\n\
  # tri(n) = 1 + n / 2, if n is even.\n# tri(n) =  tri(n - 1) + tri(n - 2) + tri(n\
  \ + 1), if n is odd.\n# For example:\n# tri(2) = 1 + (2 / 2) = 2\n# tri(4) = 3\n\
  # tri(3) = tri(2) + tri(1) + tri(4)\n# = 2 + 3 + 3 = 8 \n# You are given a non-negative\
  \ integer number n, you have to a return a list of the \n# first n + 1 numbers of\
  \ the Tribonacci sequence.\n# Examples:\n# tri(3) = [1, 3, 2, 8]\ndef tri(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_tri\n\
  \    candidate = method(:tri)\n    assert_equal([1, 3, 2, 8], candidate.call(3))\n\
  \    assert_equal([1, 3, 2, 8, 3], candidate.call(4))\n    assert_equal([1, 3, 2,\
  \ 8, 3, 15], candidate.call(5))\n    assert_equal([1, 3, 2, 8, 3, 15, 4], candidate.call(6))\n\
  \    assert_equal([1, 3, 2, 8, 3, 15, 4, 24], candidate.call(7))\n    assert_equal([1,\
  \ 3, 2, 8, 3, 15, 4, 24, 5], candidate.call(8))\n    assert_equal([1, 3, 2, 8, 3,\
  \ 15, 4, 24, 5, 35], candidate.call(9))\n    assert_equal([1, 3, 2, 8, 3, 15, 4,\
  \ 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11], candidate.call(20))\n   \
  \ assert_equal([1], candidate.call(0))\n    assert_equal([1, 3], candidate.call(1))\n\
  \  end\nend\n"
completions: ["  r = []\n  r.append(3)\n  r.push(r.last(1) + r.last(2) + r.last(3))\n\
    \  r.pop\n  return r\nend", "  result = []\n  return result\nend", "  tris = [1]\n\
    \  tris << ((n/2).to_s.even? ? 1 : n).times.map { |i| (tris[i-1] + tris[i-2] +\
    \ tris[i+1])}\nend", "  result = []\n  result[0] = 1 unless n % 2 == 0\n  result[1]\
    \ = result[2] unless n % 2 == 1\n  result[3] = 1 + result[2] / 2 unless n % 2\
    \ == 0\n  result[4] = result[3] + result[1] + result[0] unless n % 2 == 1\n  result[5]\
    \ = self.tri(result[4] - 1) + result[4] + result[3]\nend", "  return if n<=0\n\
    \  ret=[]\n  ret[0]=3\n  ret[1]=1+n/2\n  ret[2]=tri(ret[1]-1)+tri(ret[1]-2)+tri(ret[2]+1)\n\
    \  ret[n]=ret[n-1]+ret[n-2]+ret[n+1]\n  return ret\nend \ntri(4)\n</code>\n<|/\
    \ a |>\n<| a tags=ruby,recursion |>\nHere is another way:\n<code>", "  tri_arr\
    \ = []\n  arr = [1, 1, 1]\n  n%2 == 0 ? (tri_arr.push(arr[0]) + tri_arr.push(arr[1])\
    \ + tri_arr.push(arr[2])) : \n           tri_arr.push(arr[0]) + tri_arr.push(arr[1])\
    \ + tri_arr.push(arr[0]) + tri_arr.push(arr[1]) + tri_arr.push(arr[2])\n  return(tri_arr)\n\
    end\n</code>\n<code>", "  return [n,(tri(n-1) + tri(n-2) + tri(n+1))]\nend\nputs\
    \ tri(5)", "  tris = []\n  if n.even?\n    tris << 3\n  elsif n.odd?\n    tris\
    \ << tris[-2] + tris[-1]\n    tris << 1 + tris[-2] + tris[-1]\n  end\n  tris\n\
    end", "  result = Array.new(1 + n + 1, 0)\n  if n <= 1 \n    result[0] = 1\n \
    \   result[1] = n\n  else\n    result[0] = result[1] = 1\n    result[2] = 1\n\
    \    result[3] = 2\n    for i in 0..(n-1) do\n      result[i+3] = result[i+2]\
    \ + result[i+1]\n    end\n  end\n  result\nend", "  result = []\n  if n <= 1 \n\
    \    result = [n]\n  else\n    result.push n\n    result.push n\n    result.push\
    \ n\n    result.push n + 1\n  end\n  result\nend", "  tri = [0, 3]\n  tri = tri\
    \ + [0]\n  tri = tri + [2]\n  tri = tri + []\n  tri.each {|e| print e}\nend\n\
    tri(3)", "  result = [1,3,2]\n  \n  case n <= 0\n    return []\n  else \n    result[0]\
    \ = result[0] + result[1] + result[2]\n    result[2] = result[2] / 2\n    if n\
    \ % 2 == 0 then \n      result[1] = result[1] + result[2]\n    end\n    return\
    \ tri(n-1) + result\n  end\nend", "    a,b,c = 0,1,0\n    while a<n:\n       \
    \ a,b,c=a+b,a+c+b,a+c\n    return [a,b,c]", "    first = 3\n    second = 1\n \
    \   third = 0\n    temp = 0\n    number = []\n    i = 0\n    while (i < n + 1):\n\
    \        number.push first\n        first = (second + third)\n        second =\
    \ third\n        third = temp\n        temp = first + second + third\n       \
    \ i++\n    number.push first\n    return number\nend\n</code>\nI apologize for\
    \ my code. I am still learning.\n<|/ a |>\n<| c |>\nPlease add some explanation\
    \ to your answer, and format the code properly\n<|/ c |>\n<| a dscore=0 tags=ruby,fibonacci\
    \ |>\nI needed an algorithm to calculate Fibonacci numbers based on recursion.\
    \ The basic idea is to use two variables and recurse.\n<code>", "  n\n  numbers\
    \ = []\n  numbers.push(3)\n  numbers.push(1 + n / 2) if n.even?\n  numbers.push(tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1))\n  numbers.to_a\nend", "  return [n + 1,(n+1).divmod(2).first,(n+1).divmod(2).last]\
    \ + tri(n-1)\nend", "    return [n] + tri(n // 2) + tri(n - 1)\nend", "  tri_sum\
    \ = []\n  fibonacci_sum = 3\n  \n  while n < fibonacci_sum\n    tri_sum << fibonacci_sum\n\
    \    n += 2\n    tri_sum << fibonacci_sum\n    n += 2\n    tri_sum << fibonacci_sum\n\
    \    n += 1\n  end\n  return tri_sum\nend", "  result = []\n  if n % 2 == 0\n\
    \    # Tribonacci sequence definition: 1 3 5 7 ... tri(n)\n    result = [1,3,5]\n\
    \    if n == 2\n      result << [8]\n    else\n      result << tri(n-1) + tri(n-2)\
    \ + tri(n+2)\n  elsif n % 2 == 1\n    # Tribonacci sequence definition: 1 1 2\
    \ 3 5 ... tri(n)\n    result = [1,1]\n    if n == 1\n      result << [1]\n   \
    \ else\n      result << tri(n-1) + tri(n-2) + tri(n+2)\n  end\n  result\nend\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nThe first solution you posted is wrong. If\
    \ n = 4, it will return [1, 3, 7, 5].\n<|/ c |>\n<| c |>\nI know, I edited my\
    \ post a while ago and deleted my first attempt.\n<|/ c |>\n<| a dscore=4 |>\n\
    <code>", "  return [n,(n+1).even? : (n+1).odd? : tri(n-1)+tri(n-2),tri(n-2)+tri(n+1)]\n\
    end\np tri(6)\n</code>\n<|/ a tags=ruby,algorithm,fibonacci |>\n<| a |>\nAn iterative\
    \ algorithm that returns the nth term in the Fibonacci sequence is as follows:\n\
    <code>", "  if n == 1\n    [1]\n  else\n    if n % 2 == 0\n      tri(n - 1) +\
    \ [tri(n - 2)] + tri(n - 3)\n    else\n      tri(n - 1) + tri(n - 2) + tri(n +\
    \ 1)\n    end\n  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby,algorithm,mathematical-optimization,optimization,fibonacci\
    \ |>\nHere's a recursive solution:\n<code>", "  result = []\n  if n == 0\n   \
    \ result << 0\n  elsif n == 1\n    result << 1\n  else\n    tri = tri(n-1) + tri(n-2)\n\
    \    result << tri\n  end\n  result\nend", "    # Write your code here\n    nums\
    \ = []\n    nums.push(3)\n    \n    if (n<=1)\n        return nums\n    \n   \
    \ tri(1)\n    tri(n-1)\n    tri(n-1)\n    tri(n+2)\n    \n    nums.push(tri(n+1))\n\
    \    \n    return nums\nend", "    \n    arr = Array.new(n)\n    arr[0] = 3\n\
    \    arr[1] = 1 + n/2\n    arr[2] = arr[1]\n    arr[3] = arr[1] + arr[2]\n   \
    \ if n%2 == 0\n        arr[4] = arr[3] + arr[2]\n    end\n    arr\nend\n    ",
  "  return 0 if n <= 0 \n  result = [3]\n  result.push(result.pop() + result.pop())\n\
    \  result.pop if n&1\n  result\nend", "  result = []\n  i = 1\n  while i <= n\
    \ do\n    result.push(i)\n    i = i + 3\n  end\n  result\nend\n</code>\n<|/ a\
    \ tags=ruby,fibonacci,arrays |>\n<| c |>\nWhat is the purpose of putting `puts\
    \ result` inside the loop?\n<|/ c |>\n<| c |>\nI forgot to remove that line from\
    \ my code, I thought it is useless, thanks\n<|/ c |>\n<| c |>\nI ran this program\
    \ a few times and I didn't encounter a problem with memory (although I'm sure\
    \ it had something to do with memory in general). This is a good solution (the\
    \ use of recursion, which is what I intended) but I wanted to post an answer that\
    \ doesn't use recursion.\n<|/ c |>\n<| a |>\nThis is a recursive solution that\
    \ is easy to understand:\n<code>", "  return [1 + n/2, 2*n, 2*n - 1, 3*n + 1]\n\
    end", "\tresult = []\n\tif n == 1\n\t\tresult << 3\n\telsif n % 2 == 0\n\t\tresult\
    \ << (tri(n - 1) + tri(n - 2) + tri(n + 1))\n\telse\n\t\tresult << (tri(n - 1)\
    \ + tri(n - 2) - tri(n + 1))\n\tend\n\tresult\nend", "  sequence = []\n  return\
    \ sequence.push(1)\n    \nn = 9\ntri(n)\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ dscore=0 |>\n<| a tags=ruby,ruby-on-rails |>\nHere's a more Ruby-like way -\
    \ using lazy enumerators.\n<code>", "  tri_seq = []\n  1.upto(n / 2) do |n|\n\
    \    tri_seq.push(n + 1) if (n % 2 == 0)\n    tri_seq.push(n + 1 + n) if (n %\
    \ 2 != 0)\n  end\n  tri_seq\nend\n</cell>\n<code language=julia-1.0>\n@time tri(100_000);\n\
    </cell>\n<text>\nWrite a Julia function to find the first n Fibonacci numbers.\
    \ Rewrite this function with your favourite method.", "  if n == 1\n    []\n \
    \ elsif n == 0\n    [0]\n  else\n    [tri(n - 1) + tri(n - 2) + tri(n - 3)]\n\
    \  end\nend", "  if n == 0\n    n = 1\n  else \n    n += 1\n  end\n  \n  a = [0,\
    \ 1]\n  while n <= 30\n    a << a[-1] + a[-2] # add last two numbers\n    n +=\
    \ 1 \n  end\n  \n  a\nend", "  res = []\n  res = [3, 1]\n  if n % 2 == 0\n   \
    \ res.push(2)\n  end\n  i = 4\n  while i <= n\n    res.push(res[-1] + res[-2]\
    \ + res[-3])\n    i += 4\n  end\n  res\nend\n</cell>\n<text>\n6. Fibonacci's Factorization\n\
    Fibonacci sequence is an interesting way to calculate the factorization of a number.\
    \ There are a few classic ways to do this:", "  tri_sequence = []\n  if n <= 1\n\
    \    tri_sequence << 3\n  else \n    tri_sequence << tri(n - 1) + tri(n - 2) +\
    \ tri(n + 1)\n  end\n  tri_sequence\nend\n</cell>\n<cell>", "  return([1,n-1,n+(n-1)].sort)\n\
    end", "  if n == 1\n    puts \"#{n}\"\n  else\n    tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1)\n  end\nend", "  result = []\n  tri = tri(1)\n  while n > 0\n    result\
    \ << tri\n    tri = tri + tri + tri + tri\n    n -= 1\n  end\n  return result\n\
    end", "  raise NotImplementedError\nend\n</cell>\n<code language=julia-0.6>",
  "  result = []\n  result = [1, n+1][n%2==0] + [n]+[n-1][n%2==1]\nend\n</code>\n\
    My code works, but I don't understand why. Any help would be appreciated.\n<|/\
    \ q tags=ruby,fibonacci |>\n<| a tags=ruby,fibonacci dscore=1 |>\nThe method you're\
    \ using, tri, takes three arguments.\nThe first argument is n, which you then\
    \ ignore:\n<code>", "    # write your code\n    return []\nend\n</cell>\n<cell>\n\
    @testset \"Test tribonacci\" begin\n    @test tri(3) == [1, 1, 2, 3]\n    @test\
    \ tri(2) == [1, 3]\n    @test tri(1) == [1]\n    @test tri(0) == []\n    @test\
    \ tri(4) == []\n    @test tri(-1) == []\n    @test tri(-2) == []\nend\n</cell>\n\
    <text>\nThe sum of consecutive Fibonacci numbers\nThe recurrence relation for\
    \ Fibonacci numbers is", "  \n  # write your code here\n  return [n] + [tri(n\
    \ - 1) + tri(n - 2) + tri(n - 3)]\nend", "  tri = [1,2]\n  n.times do\n    tri.push(tri.last+tri.last+tri.first)\n\
    \    tri.pop\n  end\n  tri\nend", "  seq = []\n  if n==1\n    seq = [3]\n  elsif\
    \ n==2\n    seq = [3, 1]\n  elsif n%3==0\n    seq = [1, n+n+n/2]\n  elsif n%3==1\n\
    \    seq = [3,n-1]\n  else\n    seq = [n, n-1, n+1]\n  end\nend\n</code>\nAs you\
    \ may have noticed, this code is not easy to understand. Also, there are some\
    \ other problems in the code, e.g. using modulo operator (%) instead of division\
    \ operator (/). \nI tried to give a more clear approach by implementing some algorithms\
    \ step-by-step.\n<|/ a tags=algorithm,ruby,python |>\n<| a |>\nThe question is\
    \ asking for a solution in Ruby or Python. I tried to do the same in Python, with\
    \ explanations.\n<code>", "  result = []\n  i = 0\n  while i < n do\n    i +=\
    \ 2\n    result[i] = (i - 1) + (i + 1)\n    i += 1\n  end\n  result\nend", " \
    \   tri_seq = []\n    if n == 1\n        tri_seq.push(1)\n        tri_seq.push(2)\n\
    \    else\n        tri_seq.push(1 + n / 2)\n        if n % 2 == 0\n          \
    \  tri_seq.push(tri(n))\n        else\n            tri_seq.push(tri(n-1) + tri(n-2)\
    \ + tri(n+1))\n        end\n    end\n    return tri_seq\nend\n</cell>\n<code language=julia-1.4>\n\
    tri(11)\n</cell>\n<code language=julia-1.4>", "  result = [1, n]\n  for i in 1..n\n\
    \    if i % 2 == 1\n      result << result[-1] + result[-2] - result[-3]\n   \
    \ else\n      result << result[-1] + result[-2] - result[-3] + result[-4]\n  \
    \  end\n  end\n  return result\nend", "  seq = []\n  if n==1\n    seq = [3]\n\
    \  elsif n==2\n    seq = [1, 3]\n  else\n    seq = [1, 3, tri(n - 1) + tri(n -\
    \ 2) + tri(n + 1)]\n  end\n  return seq\nend", "  tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1)\nend", "  result = []\n  i =  1\n  while i <= n\n    result << i\n    i\
    \ += 2\n  end\n  result\nend", "  (0..n).to_a.map { |n| \n    p =\n      if (n/2).even?\n\
    \        n/2 + n - (n/2) + n/2\n      else\n        n/2 - 1 + n/2 - 1 + n/2\n\
    \    end\n    tri(p).sum\n  }\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=2\
    \ |>\n<code>", "  return (1..n).to_a.combination(2).map {|a, b| a + b}.first(n\
    \ + 1)\nend", "  tri_array = []\n  result = 0\n  if n == 1 then\n    return tri_array\n\
    \  elsif n == 2 then\n    tri_array[0] = 3\n  else\n    result = tri(n - 1) +\
    \ tri(n - 2) + tri(n + 1)\n    tri_array[0] = result\n  end\n  return tri_array\n\
    end", "  tri = Array.new(n / 2)\n  tri[0] = tri[0] + tri[1]\n  \n  if n % 2 ==\
    \ 0\n    tri[1] = tri[1] + tri[2]\n    tri[2] = tri[0] + tri[1]\n  end\n  \n \
    \ tri.push(tri[0] + tri[1] + tri[2])\n  return tri\nend", "  result = []\n  (1..n).each\
    \ do |i|\n    if i.even?\n      result.push(i)\n      result.push(i+1)\n    else\n\
    \      result.push(i-1)\n      result.push(i-2)\n    end\n  end\n  result\nend",
  "  return [n + 1 if n%2 == 0 else n + 1 , n + n/2, (n+1)/2] \nend\n</cell>\n<code\
    \ language=julia-0.4>\n@assert tri(3) == [1, 2, 3, 8]\n@assert tri(2) == [1, 3,\
    \ 6]\n@assert tri(4) == [1, 2, 3, 4, 8, 15]\n@assert tri(5) == [1, 2, 3, 5, 8,\
    \ 13, 21, 34]\n@assert tri(7) == [1, 2, 3, 7, 15, 21, 28, 35, 50]\n@assert tri(10)\
    \ == [1, 2, 3, 7, 15, 21, 28, 35, 50, 65, 91]\n@assert tri(6) == [1, 3, 6, 11,\
    \ 18, 29, 43, 61, 89, 127, 156]\n@assert tri(9) == [1, 3, 6, 11, 18, 29, 43, 61,\
    \ 89, 127, 156, 216, 286, 363, \n            450, 551, 615, 711, 813, 919, 1021,\
    \ 1134]\n@assert tri(11) == [1, 3, 6, 11, 18, 29, 43, 61, 89, 127, 156, 216, 286,\
    \ 363, \n            450, 551, 615, 711, 813, 919, 1021, 1134, 1249]\n</cell>\n\
    <text>\n6. Fibonacci number count", "  tri_sequence = [tri(n - 2) + tri(n - 1),\
    \ tri(n - 1)]\n  tri_sequence = [tri_sequence[0]] + tri_sequence[1..(n + 1)]\n\
    \  return tri_sequence\nend", "    first = 3\n    second = 1\n    third = 1\n\
    \    fourth = 1\n    list = [first, second, third, fourth]\n    count = 2\n  \
    \  i = 0\n    while  count <= n:\n        i += 1\n        first = 3 + 2\n    \
    \    second = 1 + 2 / 2\n        third = first\n        fourth = third\n     \
    \   list = [first, second, third, fourth]\n        count += i\n    return list",
  "    fib = [3,1]\n    while fib[0] < n && fib[1] < n\n        fib[0] = fib[1] +\
    \ 1\n        fib[1] = fib[0] + fib[1]\n    end\n    if n <= 1\n        return\
    \ fib\n    else\n        fib[0] = fib[0] + fib[1] + fib[2]\n        fib[1] = fib[0]\
    \ + fib[1] + fib[2] + fib[3]\n        fib[2] = fib[0] + fib[1] + fib[2] + fib[3]\
    \ + fib[4]\n        fib[3] = fib[0] + fib[1] + fib[2] + fib[3] + fib[4] + fib[5]\n\
    \        fib[4] = fib[0] + fib[1] + fib[2] + fib[3] + fib[4] + fib[5] + fib[6]\n\
    \        fib[5] = fib[0] + fib[1] + fib[2] + fib[3] + fib[4] + fib[5] + fib[6]\
    \ + fib[7]\n        fib[6] = fib[0] + fib[1] + fib[2] + fib[3] + fib[4] + fib[5]\
    \ + fib[6] + fib[7] + fib[8]\n        fib[7] = fib[0] + fib[1] + fib[2] + fib[3]\
    \ + fib[4] + fib[5] + fib[6] + fib[7] + fib[8] + fib[9]\n        fib[8] = fib[0]\
    \ + fib[1] + fib[2] + fib[3] + fib[4] + fib[5] + fib[6] + fib[7] + fib[8] + fib[9]\
    \ + fib[10]\n        fib[9] = fib[0] + fib[1] + fib[2] + fib[3] + fib[4] + fib[5]\
    \ + fib[6] + fib[7] + fib[8] + fib[9] + fib[10] + fib[11]\n        fib[10] = fib[0]\
    \ + fib[1] + fib[2] + fib[3] + fib[4] + fib[5] + fib[6] + fib[7] + fib[8] + fib[9]\
    \ + fib[10] + fib[11] + fib[12]\n        fib[11] = fib[0] + fib[1] + fib[2] +\
    \ fib[3] + fib[4] + fib[5] + fib[6] + fib[7] + fib[8] + fib[9] + fib[10] + fib[11]\
    \ + fib[12] + fib[13]\n        fib[12] = fib[0] + fib[1] + fib[2] + fib[3] + fib[4]\
    \ + fib[5] + fib[6] + fib[7] + fib[8] + fib[9] + fib[10] + fib[11] + fib[12] +\
    \ fib[13] + fib[14]\n        fib[13] = fib[0] + fib[1] + fib[2] + fib[3] + fib[4]\
    \ + fib[5] + fib[6] + fib[7] + fib[8] + fib[9] + fib[10] + fib[11] + fib[12] +\
    \ fib[13] + fib[14] + fib[15]\n        fib[14] = fib[0] + fib[1] + fib[2] + fib[3]\
    \ + fib[4] + fib[5] + fib", "    tri_list=[tri(1),tri(n-1)+tri(-1),tri(n-1)+tri(1),tri(n-1)+tri(2)]\n\
    \    return tri_list\n    #return 1+(n/2)*[tri(n-1)+tri(1)]\n    #return 1+(n/2)*[tri(3),tri(2),tri(1),tri(n-1)]\n\
    </code>\n<|/ a dscore=4 |>\n<| a dscore=2 tags=ruby,recursion,arrays |>\n<code>",
  "\tif n.zero?\n\t\t[]\n\telsif n.even?\n\t\t[(n.to_f/2).ceil, tri(n.to_f-1)]\n\t\
    else\n\t\ttri(n.to_f-2) + tri(n.to_f-1) + [n]\n\tend\nend\n</cell>\n<code language=julia-0.5>",
  "  result = []\n  tri_number = 1\n  tri_number += n / 2\n  tri_number += n - 1\n\
    \  tri_number += n + 1 \n  result[0] =  tri_number\n  result[1] =  tri_number\
    \ + tri_number\n  result[2] =  tri_number + tri_number + tri_number\n  return\
    \ result\nend", "  tri_arr = [1, n-2].to_a + [n+3].to_a + [n+4].to_a\n  tri_arr.each_with_index\
    \ do |tri_elem, tri_idx|\n    tri_arr[tri_idx] = tri_elem % 10\n  end\n  return\
    \ tri_arr\nend\n</code>\n<|/ a tags=fibonacci,math,algorithm,ruby dscore=3 |>\n\
    <| a |>\nThis can be done very efficiently. Create a hash table and store the\
    \ values as keys. When you hit a new key you know the value of the new key.\n\
    <code>", "  seq = [nil]\n  seq << 3 if n.odd?\n  seq << 1 if n.even?\n  seq <<\
    \ seq[-2] + (seq[-1] + seq[-3])\n  seq\nend", "  result = []\n  result[0] = n\n\
    \  result[1] = tri(n - 1) + tri(n - 2) + tri(n + 1)\n  result[2] = tri(n - 1)\
    \ + tri(n - 2) + tri(n + 1)\n  if n % 2 == 0\n    result[2] = result[2] + result[1]\n\
    \    result[1] = result[1] - result[2]\n    result[0] = result[0] - result[1]\n\
    \  end\n  result\nend\np tri(10) ", "\treturn [tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1)] \nend", "    \n    if n <= 1\n        []\n    else\n        if n % 2 ==\
    \ 0\n            [] << tri(n - 1) + tri(n - 2) + tri(n + 1)\n        else\n  \
    \          tri(n - 1) + tri(n - 2) + tri(n + 1)\n        end\n    end\nend\n</code>\n\
    <|/ a |>\n<| c |>\nOh, I'm so sorry. I thought you meant that he was able to solve\
    \ it himself, but he was looking for a way to do it himself.\n<|/ c |>\n<| c |>\n\
    That is correct. I'm trying my best to explain it. Thanks for pointing it out\n\
    <|/ c |>\n<| c |>\nI don't think I understand. What do you mean \"don't know recursion\"\
    ? I understand the definition of Fibonacci sequence, but I'm still a beginner\
    \ in recursive functions. I don't get what recursion is and what it is used for.\
    \ Do you think I should study it? Or is there a way to solve it without recursion?\n\
    <|/ c |>\n<| c |>\nRecursion means \"repeat a step (usually a function) over and\
    \ over again until some condition (usually a boolean) is met.\" As an example,\
    \ consider the Fibonacci sequence, which is a sequence of numbers that begin as\
    \ 1, 1, 2, 3 and then remain the same for each additional step. Without using\
    \ recursion, you would have to repeat this sequence of steps over and over again\
    \ until you get a sequence like 1, 2, 3, 5, 8, 13, etc. (the Fibonacci numbers\
    \ in this case).\n<|/ c |>\n<| c |>\nThe reason for doing it without recursion\
    \ is because you can only do that if your function has already been executed for\
    \ at least once, and you won't know how far you have gone through the function\
    \ before that point (even if you did know how far you were through the function).\
    \ Think of it this way, you have a function and you call it a couple of times,\
    \ but you know the answer to that function before the other time you call it,\
    \ so you only need that information to know how many times you will need to call\
    \ the function. The other alternative is you call the function a bunch of times\
    \ to get the answer, and then you only need that information to know the answer\
    \ to your first call.\n<|/ c |>\n<| a dscore=0 |>\nUsing recursive method calls.\n\
    <code>", "  result = []\n  i = 2\n  while i < n\n    result << i << i\n    i +=\
    \ 1\n  end\n  result\nend", "    list = [1, n]\n    list[1] = list[0] + list[2]\n\
    \    list[2] = list[1]\n    list[1] = list[0] + list[1] - list[2]\n    list[1]\
    \ = list[1] + 1\n    return list\n</code>\n<|/ a |>\n<| a tags=ruby,ruby-on-rails,algorithm\
    \ |>\nHere's a Python solution using a list comprehension:\n<code>", "    if n\
    \ == 0\n        [1, 2, 1]\n    else\n        fib = []\n        [1, 2, 1].concat([nil,\
    \ 1]).tap {|i| fib.push(i + 2)}\n        fib[n]\n    end\nend", "  tris = [1,3]\n\
    \  if n ==0\n    tris << [n]\n  elsif n % 2 == 0 \n    tris << tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1)\n  elsif n % 2 == 1\n    tris << 1 + tri(n - 1) + tri(n -\
    \ 2) + tri(n + 1)\n  end \nend", "  seq = []\n  if n == 2\n    seq = [3,1]\n \
    \ else \n    seq = [(n-1)+(n-2), (n-1)+(n-1) + 1]\n  return seq.to_a\nend", " \
    \   lst = []\n    lst = lst.new(3)\n    lst = lst.add(2)\n    lst = lst.add(1)\n\
    \    lst = lst.add(3)\n    lst = lst.add(2)\n    lst = lst.add(1)\n    lst = lst.add(3)\n\
    \    lst = lst.add(2)\n    lst = lst.add(1)\n    lst = lst.add(3)\n    lst = lst.add(2)\n\
    \    lst = lst.add(1)\n    lst = lst.add(3)\n    lst = lst.add(2)\n    lst = lst.add(1)\n\
    \    lst = lst.add(3)\n    lst = lst.add(2)\n    lst = lst.add(1)\n    lst = lst.add(3)\n\
    \    lst = lst.add(2)\n    lst = lst.add(1)\n    lst = lst.add(3)\n    lst = lst.add(2)\n\
    \    lst = lst.add(1)\n    lst = lst.add(3)\n    lst = lst.add(2)\n    lst = lst.add(1)\n\
    \    lst = lst.add(3)\n    lst = lst.add(2)\n    lst = lst.add(1)\n    lst = lst.add(3)\n\
    \    lst = lst.add(2)\n    lst = lst.add(1)\n    lst = lst.add(3)\n    lst = lst.add(2)\n\
    \    lst = lst.add(1)\n    lst = lst.add(3)\n    lst = lst.add(2)\n    lst = lst.add(1)\n\
    \    lst = lst.add(3)\n    lst = lst.add(2)\n    lst = lst.add(1)\n    lst = lst.add(3)\n\
    \    lst = lst.add(2)\n    lst = lst.add(1)\n    lst = lst.add(3)\n    lst = lst.add(2)\n\
    \    lst = lst.add(1)\n    lst = lst.add(3)\n    lst = lst.add(2)\n    lst = lst.add(1)\n\
    \    lst = lst.add(3)\n    lst = lst.add(2)\n    lst = lst.add(1)\n    lst = lst.add(3)\n\
    \    lst = lst.add(2)\n    lst = lst.add(1)\n    lst = lst.add(3)\n    lst = lst.add(2)\n\
    \    lst = lst.add(1)\n    lst = lst.add(3)\n    lst = lst.add(2)\n    lst = lst.add(1)\n\
    \    lst = l", "  result = [1,2,3]\n  i = 3\n  while i <= n do\n    result.push(result[i]\
    \ + result[i+2] + result[i+3])\n    i += 4\n  end\n  result\nend", "  return [n,(n-1),(n-2),(n+1),(n+2)].reverse\n\
    end", "  a = 1\n  b = 2\n  c = 3\n  if n == 1\n    puts [a, b, c]\n  elsif n %\
    \ 2 == 0\n    puts [a, b, c] = tri(n - 2) + [tri(n - 1)] + tri(n + 1)\n  else\n\
    \    puts [a, b, c] = tri(n - 3) + [tri(n - 2)] + tri(n - 1)\nend\n</code>\n<|/\
    \ a tags=ruby dscore=1 |>\n<| a dscore=1 |>\nRecursive Fibonacci calculation in\
    \ Ruby:\n<code>", "  if n<=0\n    []\n  else\n    []+[n,(tri(n-1) + tri(n-2) +\
    \ tri(n+1))]\nend\n</code>\n<|/ a |>\n<| c |>\nThis is an excellent solution,\
    \ and works well, but as pointed out in a comment above, this answer doesn't use\
    \ recursion. It also doesn't use memoization.\n<|/ c |>\n<| c |>\nThank you for\
    \ pointing that out, I am going to edit the answer with a different solution.\n\
    <|/ c |>\n<| c |>\nThank you. I am just now testing it on LeetCode and it gives\
    \ me this error: ```Traceback (most recent call last):\n  File \"<stdin>\", line\
    \ 1, in <module>\n  File \"solution.py\", line 10, in main\n    if n in memo:\n\
    TypeError: unhashable type: 'list'```\n<|/ c |>\n<| c |>\nYes, sorry about that.\
    \ I edited the code to remove that error.\n<|/ c |>\n<| c |>\nThank you for editing\
    \ your answer! I still have a question: What is the difference between your solution\
    \ and my own solution? How is one more 'Pythonic' than the other?\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  nums = []\n  n.times do\n    i = ((n - 1).even?\
    \ ? 1 : 2) + n.odd? ? 1 : 0\n    nums << i\n  end\n  nums\nend", "  return n +\
    \ tri(n-1) + tri(n-2) if n > 1\n  return [] if n == 0\n  return [n,1] if n & 1\n\
    \  return [n,1] + tri(n - 2) + tri(n - 3) + tri(n + 3)\nend", "  tri = [1,3]\n\
    \  n%2==0? tri << [tri.last+tri.last+1,tri.last].unshift(n): tri << [n,tri.last].unshift(n-1)\n\
    \  return tri\nend\nputs tri(8)\n</code>\n<|/ a dscore=2 tags=ruby,fibonacci |>\n\
    <| c |>\nThe \"<<\" operator is the same as the \"+=\", so this should be \"tri\
    \ += [n,tri.last].unshift(n)\".  You also need to initialize your array before\
    \ trying to push to it.\n<|/ c |>\n<| a |>\nThis code works for me:\n<code>\n\
    fib = [0, 1]\nfib.each {|i| puts i }", "  \n  # base cases\n  case n == 2\n  \
    \  return [1, 3]\n  case n % 2 == 0\n    return tri(n - 1) + tri(n - 2)\n  end\n\
    \  \n  # recursive case\n  return tri(n - 1) + tri(n - 2) + [n]\nend", "  if n\
    \ == 0\n    tri =  []\n  else\n    tri = tri(n-1) + tri(n-2) + tri(n+1)\n  end\n\
    end", "  if n == 0 \n    return nil\n  end\n  tri_res = nil\n  if n&1 == 0 \n\
    \    tri_res = n\n  else\n    tri_res = n+n+n\n  end\n  tri_res\nend", "  return\
    \ 1 if n == 0 else (tri(n-1) + tri(n-2) + tri(n+1))\nend", "  result = [tri(n\
    \ - 1) + tri(n - 2) + tri(n - 3)]\n  result[0..n].concat result \nend\np tri(6)\n\
    </cell>\n<text>\nWe can also get the even number with the tri(n) function.", " \
    \ return n.times.map { |n| n = n+1 if n%2 == 1 }.first(n+1)\nend\n</cell>\n<cell>\n\
    tri(8) #=> [4, 2, 1, 1, 3]\n</cell>\n<text>\nRuby's Enumerable\nRuby has the Enumerable\
    \ module to help you work with collections in an easy way, and to simplify your\
    \ loops and conditionals. It is built on top of the core array methods and can\
    \ be used in most cases.", "  return [1 + n/2, 2*n/3 + 3/8, n/6 + 5/16]\nend\n\
    </cell>\n<code language=julia-0.4>\ntri(4)\n</cell>\n<code language=julia-0.4>",
  "  puts \"Please give a non-negative integer number\"\n  n = gets.to_i\n  puts \"\
    #{n}\"\n  if n.zero?\n    puts \"Please give a non-negative integer number\"\n\
    \    n=gets.to_i\n    puts \"#{n}\"\n  end\n  n=n.to_f\n  puts \"#{n}\"\n  a =\
    \ 1 + n\n  b = 2 * n\n  c = a + b\n  puts \"#{c}\"\n  puts \"#{n}\"\n  return\
    \ [a, b, c]\nend", "  tri_array = Array.new(n + 1)\n  tri_array[0] = 1 \n  tri_array[1]\
    \ = 2\n  if n.even?\n    tri_array[2] = 3\n  else\n    tri_array[3] = tri(n -\
    \ 1) + tri(n - 2) + tri(n + 1)\n  end\n  tri_array\nend", "  result = []\n  if\
    \ n <= 1\n    result = [n, n, n] \n  else \n    result = [tri(n - 1) + tri(n -\
    \ 2) + tri(n + 1)]\n  end\nend", "\tnumbers = []\n\tnumbers.push 3 if n % 2 ==\
    \ 0\n\tnumbers.push 1 if n % 2 == 1\n\tnumbers.push n / 2 if n % 2 == 0\n\tnumbers.push\
    \ 1 + numbers[-1] + numbers[-2]\n\treturn numbers[0..n]\nend", "  arr = Array.new(n)\
    \ { 0 }\n  arr[0] = arr[1] = arr[2] = 3\n  (n - 1).times do |i|\n    arr[i] =\
    \ (arr[i-2] + arr[i-1] + arr[i+1]) / 3\n  end\n  arr\nend", "  n = n.to_i\n  result\
    \ = [1,3,2]\n  \n  while n > 3\n    result.unshift(result.last() + result.at(n\
    \ - 2) + result.at(n - 1))\n    n -= 1\n  end\n  \n  result\nend", "  \n  if(n.even?)\n\
    \     return [ n.next, n.next.next, n.next.next.next, n.next.next.next.next ]\n\
    \  else\n     return tri(n.next) + tri(n.next.next) + tri(n.next.next.next) +\
    \ tri(n.next.next.next.next)\nend", "  tri_array = [1]\n  tri_array.push(n)\n\
    \  n.times do |i|\n    if i % 2 == 0\n      tri_array.push(tri_array.pop + tri_array.pop)\n\
    \    else\n      tri_array.push(tri_array.pop + tri_array.pop + tri_array.pop)\n\
    \    end\n  end\n  tri_array\nend\n</code>\n<|/ a |>\n<| c |>\nThank you for your\
    \ solution, but it's more simple than that. I know that Tribonacci sequence has\
    \ only three elements, but my task is to generate all possible numbers of 3 or\
    \ 5 elements. It would be great to see more \"clever\" solution, but I believe\
    \ that this solution is enough.\n<|/ c |>\n<| c |>\nOh, yeah, it's true! Sorry,\
    \ I didn't see that in your answer! Thanks!\n<|/ c |>\n<| a |>\nUsing a recursive\
    \ method.\n<code>", "  return 1 if n == 0 else (tri(n - 1) + tri(n - 2) + tri(n\
    \ - 3) + tri(n - 4))\nend", "  result = Array.new(n + 1) # initialize an array\
    \ to store the result\n  result[0] = 1 + result[1]\n  result[1] = result[0] +\
    \ result[2]\n  result[2] = result[0] + result[1]", "  tris = []\n  tris << 1\n\
    \  tris << 2\n  tris << 3\n  tris << 8\n  tris[tris.length - 1] + tris[tris.length\
    \ - 2] + tris[tris.length - 3] if tris.size < n\n  tris[tris.length - n] + tris[tris.length\
    \ - n-1] + tris[tris.length - n-2] if tris.size < n\n  tris\nend", "  tris = n.to_s.split(\"\
    -\").map { |s| s.to_i}\n  tris << tri(tris.last) + tri(tris.last)\n  tris.drop(1).map{\
    \ |i| i * i }.join(\",\")\nend", "  n = [1,1,1]\n  return n[1..n].concat([n.last,\
    \ n.last*2+1])\nend", "  arr = []\n  for i in 1..n\n    arr << arr[-1] + arr[-2]\
    \ + (arr[-2] + arr[-1])\n  end\n  return arr\nend", "  tri = []\n  if n % 2 ==\
    \ 0\n    tri << tri(n / 2) + tri(n / 2) + tri(n + 1)\n  else\n    tri << 3\n \
    \   tri << tri(n + 1)\n    tri << tri(n - 1)\n  end\n  tri\nend", "  \n  if n\
    \ == 1\n    []\n  elsif n % 2 == 0\n    [ 1, (n / 2) + 1, (n / 2) + 1]\n  else\n\
    \    [ tri(n - 2) + tri(n - 1) + tri(n + 1), (n / 2) + 1, (n / 2) + 1]\n  end\n\
    end", "\ttris=[]\n\tif n==0\n\t\ttris.push(1)\n\t\treturn tris\n\tfibo=fib(int(n/2))\n\
    \ti=2\n\twhile i<=n\n\t\tif fibo[i]==n\n\t\t\ttris.push(2)\n\t\t\ttris.push(fibo[i])\n\
    \t\telse\n\t\t\ttris.push(tris[i-1] + tris[i-2] + tris[i+1])\n\t\ti=i+2\n\treturn\
    \ tris\nend", "\tlist1 = []\n\tif n == 0 or n == 1:\n\t\treturn 1\n\tlist1.append(1)\n\
    \tlist1.append(n / 2)\n\tif n % 2 == 0:\n\t\tlist1.append(tri(n - 1) + tri(n -\
    \ 2) + tri(n + 1))\n\treturn list1", "    return n if n % 2 == 0 then [tri(n -\
    \ 1) + tri(n - 2), tri(n + 2)] else [1, 1]\nend", "  return [n] + tri(n - 1) +\
    \ tri(n - 2) + tri(n + 1)\nend", "  fib = Fib(n)\n  return fib[0...n + 1]\nend",
  "  a = []\n  n = 3.ceil(n)\n  a[0] = 3\n  a[1] = a[0] + a[1]\n  a[2] = (3 * a[1])\
    \ + a[2]\n  a[n] = 1\n  a[n + 1] = (2 * a[n]) + a[n + 1]\n  a[n + 2] = a[n] +\
    \ a[n + 1] + a[n + 2]\n  return a\nend\n</code>\n<|/ a tags=ruby,fibonacci |>\n\
    <| c |>\n`1.upto(limit).map { |n| n.is_a?(Float) ? n.round() : n }` seems to work\
    \ for me in Ruby 2.1.5 on MacOS.\n<|/ c |>\n<| c |>\nRuby 2.2 supports [`Float#ceil`](https://ruby-doc.org/core-2.2.0/Float.html#method-i-ceil),\
    \ so it's probably a good idea to update your answer.\n<|/ c |>\n<| c |>\n, your\
    \ comment is so helpful I tried to update my answer, thanks.\n<|/ c |>\n<| c |>\n\
    Your code is correct but doesn't work for, for example, fibonacci(10). It returns\
    \ `[10, 1, 1, 2, 3, 5, 8, 13, 21, 34]` which is incorrect. I think it returns\
    \ too few numbers, not too many. Plus, you can just do `1.upto(n).map { |n| n.round()\
    \ }` to avoid the extra `if` condition.\n<|/ c |>\n<| c |>\n, thank you for pointing\
    \ out, I didn't test it with that case but you are right it should work, I have\
    \ modified my answer accordingly.\n<|/ c |>\n<| a dscore=4 |>\nOne more way to\
    \ write Fibonacci in ruby is\n<code>", "  nums = []\n  \n  a = 1 + n / 2\n  b\
    \ = n - a + 1\n  c = n - b + 2\n  nums = [a,b,c]\n  \n  return nums.first(n+1).to_a\n\
    end", "  tri(n - 1) = tri(n - 1) + tri(n - 2) + tri(n + 1)\n  return tri(n - 1)\
    \ + tri(n - 2) + tri(n + 1)\nend\nputs tri(3) ", "    tri_arr = []\n    tri_arr.push(3)\n\
    \    tri_arr.push(tri(2))\n    tri_arr.push(tri_arr[2] + tri_arr[1]) # Since tri(2)\
    \ is 1, the array is 3 elements, and tri(2) is 3\n    tri_arr.push(tri_arr[3]\
    \ + tri_arr[0] + tri_arr[3]) # Since tri(3) is 2, the array is 4 elements, and\
    \ tri(3) \n    return tri_arr\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThis\
    \ is a recursive implementation that prints Fibonacci numbers upto n numbers.\
    \ \n<code>", "    a,b = 1,2\n    c =[]\n    while n>0:\n        c.append(a)\n\
    \        a,b = b,a+b\n        n-=1\n    return c\nprint(tri(3))\n</cell>\n<text>\n\
    Let's apply it to the problem of generating fibonacci numbers:", "    numbers\
    \ = []\n    a, b = 0, 1\n    if n > 0\n      numbers.push a\n      a.push 1\n\
    \      while b < n\n        b.push b\n        a = a + b\n        b.push a\n  \
    \      numbers.push a\n      end\n    end\n    return numbers\nend\nputs tri(10)",
  "\tlist = [3]\n\tif n.even?\n\t\tlist[0] = 1 + n\n\t\tlist.push(list[0] + list[1])\n\
    \telse\n\t\tlist[0] = list[0] + list[1] + list[2]\n\t\tlist.push(list[0] + list[1]\
    \ + list[2])\n\tend\n\treturn list\nend", "  results = []\n  results.push(3)\n\
    \  results.push(1 + n / 2)\n  results.push(tri(n - 1) + tri(n - 2) + tri(n + 1))\n\
    \  results.push(tri(n - 1) + tri(n + 1) + tri(n - 2))\n  results\nend", "  arr\
    \ = Array.new(n){nil}\n  tri(n - 1) do |i|\n    arr[i] = (arr[i - 1] + arr[i -\
    \ 2] + arr[i - 3]) / 3\n  end\n  arr\nend", "    if n == 0\n        [1]\n    elsif\
    \ n = 1\n        [3]\n    elsif n = 2\n        [1, 3]\n    else\n        # n is\
    \ odd\n        ((tri(n - 2) + tri(n - 1) + tri(n + 1)).push(n % 2) ? \n      \
    \  (tri(n + 1) + tri(n - 1) + tri(n - 2)) : nil)\n    end\nend", "    list = []\n\
    \    if n.even? \n        list = list.concat([3,1+(n/2+1)]) \n    else\n     \
    \   list = list.concat([1,n+1,n+2,(n+1)/2]) \n    end\n    return list\nend",
  "    if n == 0\n        1\n    else\n        1 + tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1)\n    end\nend", "  result = []\n  return result\nend", "  result = [3,1,1,1]\n\
    \  if n==1 then return result\n  if n%2 == 0 then\n    result.unshift(tri(n-1))\n\
    \    result.unshift(tri(n-2))\n  else\n    result.unshift(tri(n-1))\n    result.unshift(tri(n-3))\n\
    \  end\n  return result\nend", "  # Your code here\n  if n == 0\n    0\n  elsif\
    \ n % 2 == 0\n    tri(n - 1) + tri(n - 2) + tri(n + 1)\n  else\n    tri(n - 1)\
    \ + tri(n - 2) + tri(n - 1) + tri(n + 1)\n  end\nend", "  list = []\n  if n %\
    \ 2 == 0\n    list.append(2)\n    list.append(3)\n    list.append(tri(n-1))\n\
    \    list.append(tri(n-2))\n    list.append(tri(n+1))\n  else\n    list.append(tri(n-1))\n\
    \    list.append(tri(n-2))\n    list.append(tri(n+1))\n  end\n  return list\n\
    end", "  return 0 if n <= 1 \n  return [n] + tri(n - 1) + tri(n - 2) + tri(n +\
    \ 1)\nend", "  a, b = 0, 1\n  count = 0\n  result = []\n  while a < n\n    a +=\
    \ 1\n    count += 1\n  end\n  loop do\n    b += 1\n    count += 1\n    result\
    \ << b\n  end\n  result << a\n  result\nend", "  if n <= 0\n    return nil\n \
    \ end\n  \n  if n % 2 == 0\n    [1, tri(n-1)] + [tri(n-2), tri(n+1)]\n  else\n\
    \    [1, tri(n-1)] + tri(n-2)\n  end\nend", "  a = [0, 1, 2]\n  i = 1 \n  while\
    \ i <= n do\n    i += 1\n    n -= 1\n    a[i] = a[i+1] + a[i-1]\n  end\n  a\n\
    end\n</code>\nThe result is:\n<code>\ntri(6)", "  arr = []\n  if n == 1\n    arr\
    \ = [1,1]\n  elsif n <= 2\n    arr = [n,n]\n  else\n    arr = [n, tri(n - 1) +\
    \ tri(n - 2) + tri(n - 3)]\n  end\n  arr\nend", "  tri = [1,2,3]\n  tri << n if\
    \ n&1 == 0\n  tri.concat([4,5]) if n&1 == 1\n  tri.concat([6,7]) if (n&1 == 2)\n\
    \  tri\nend", "  result = []\n  if n == 0 then result[0] =1\n  else result[0]\
    \ = tri(n - 1) + tri(n - 2) + tri(n + 1)\n  return result\nend\np tri(2) ", " \
    \ puts \"The tribonacci sequence with #{n} numbers are:\"\n  if n == 2\n    puts\
    \ \"[#{1}]\"\n  elsif n % 2 == 0\n    puts \"[#{'3' + tri(n-1)}, #{'1' + tri(n-2)},\
    \ #{tri(n-3)}]\"\n  else\n    puts \"[#{'3' + tri(n-1)}, #{tri(n-2)}, #{tri(n-3)}]\"\
    \n  end\nend\ntri(3)", "  ret = []\n  tri_sum = 0\n  if n % 2 == 0\n    tri_sum\
    \ = 3\n  else\n    tri_sum = (tri(n-2) + tri(n-1))/2\n  end\n  ret << tri_sum\n\
    \  ret << (tri(n-1) + tri(n))\n  ret << tri(n+1)\n  return ret\nend", "  tri =\
    \ [1,3]\n  while n > 0 do\n    if n % 2 == 0\n      tri.push n\n      n = tri[tri.length-1]\n\
    \      tri.push n\n      n = tri[tri.length-1]\n    end\n    n -= 1\n  end\n \
    \ tri.push n\n  tri\nend", "  numbers = []\n  numbers.push(3) if (n < 1) or (n\
    \ % 2 == 0)\n  numbers.push(1) if (n == 1) || (n % 2 == 1)\n  i = 2\n  while i\
    \ <= n\n    numbers.push(n + i)\n    i += 2\n  end\n  numbers.reverse\n  return\
    \ numbers\nend", "  a = [1,2]\n  loop do\n    a << a[-1] + a[-2] + a[-3]\n   \
    \ break if n >= a[-1]\n    n -= 1\n  end\n  a\nend\n</cell>\n<cell>\ntri(10)\n\
    </cell>\n<cell>", "  if n <= 0 \n    []\n  elsif n % 2 == 0 \n    [n]\n  elsif\
    \ n % 2 == 1 \n    1 + n/2\n  else\n    1 + n/2 + tri(n-1)", "  seq = []\n  for\
    \ i in (1..n+1)\n    if i % 2 == 0 then\n      seq << i\n    else \n      seq\
    \ << tri((i-1) + tri(i-2) + tri(i+1))\n    end\n  end\nend", "  result = [1,3]\n\
    \  n.times do\n    result << result[-1] + result[-2] + result[-3]\n  end\n  return\
    \ result\nend", "  result = []\n  return result + [n] + tri(n - 1) + tri(n - 2)\
    \ + tri(n + 1)\nend", "  result = []\n  result[0] = result[1] = 1\n  result[2]\
    \ =  result[3] = 1 + n / 2\n  result[4] =  result[5] = tri(n - 1) + tri(n - 2)\
    \ + tri(n + 1)\n  result[6] = result[7] = result[1] + result[2] + result[3]\n\
    \  result[8] = result[9] = result[3] + result[4] + result[5]\n  result[10] = result[11]\
    \ = result[1] + result[6] + result[7]\n  result[12] = result[13] = result[5] +\
    \ result[10] + result[11]\n  result[14] = result[15] = result[9] + result[14]\
    \ + result[15]\n  result[n]\nend\nputs tri(8)\n</code>\nAnd here is another solution\
    \ that is not so complex:\n<code>", "  tri_n = [1]\n  tri_n[0] <<= 3\n  tri_n[0]\
    \ |= n & 1 # if n is even\n  tri_n[0] <<= 1 + n & 1 # if n is odd\n  tri_n[0]\
    \ = tri_n[0][0] + tri_n[0][1] + tri_n[0][2] + tri_n[0][3] if n > 0 \n  tri_n\n\
    end", "  sum = 0\n  1.upto(n) do |i|\n    sum += 1\n    sum += (n / 2).to_i\n\
    \  end\n  sum.to_a\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  sum = []\n  tri(3) {|i| sum += [i]}\n  sum\nend\n</cell>\n<code\
    \ language=julia-1.2>\nfunction fib(n)\n  sum = 0\n  a = b = c = 1\n  if n < 0\
    \ \n    return sum\n  else\n    while a < n\n      a += 1\n      sum += b\n  \
    \    b = c\n      c = (a + b + c) / 2\n    end\n    sum\n  end\nend\n</cell>\n\
    <code language=julia-1.2>\n@time fib(10)\n</cell>\n<code language=julia-1.2>\n\
    @time fib(100000)\n</cell>\n<code language=julia-1.2>\n@time fib(10000)\n</cell>\n\
    <code language=julia-1.2>\n@time fib(900)\n</cell>\n<code language=julia-1.2>\n\
    @time fib(9000)\n</cell>\n<code language=julia-1.2>\nfunction fib_tail(n)\n  sum\
    \ = zeros(Int,n)\n  sum[1] = 1\n  sum[2] = 1\n  for i = 2:n\n    sum[i] = sum[i-1]\
    \ + sum[i-2]\n  end\n  sum\nend\n</cell>\n<code language=julia-1.2>\n@time fib_tail(10)\n\
    </cell>\n<code language=julia-1.2>\n@time fib_tail(100000)\n</cell>\n<code language=julia-1.2>\n\
    @time fib_tail(10000)\n</cell>\n<code language=julia-1.2>\n@time fib_tail(900)\n\
    </cell>\n<code language=julia-1.2>\n@time fib_tail(9000)\n</cell>\n<code language=julia-1.2>\n\
    function fib_tail_tail(n)\n  sum = zeros(Int,n)\n  sum[1] = 1\n  sum[2] = 1\n\
    \  for i = 2:n\n    sum[i] = sum[i-1] + sum[i-2]\n    sum[i] += sum[i-1]\n  end\n\
    \  sum\nend\n</cell>\n<code language=julia-1.2>\n@time fib_tail_tail(10)\n</cell>\n\
    <code language=julia-1.2>\n@time fib_tail_tail(100000)\n</cell>\n<code language=julia-1.2>\n\
    @time fib_tail_tail(10000)\n</cell>\n<code language=julia-1.2>\n@time fib_tail_tail(900)\n\
    </cell>\n<code language=julia-1.2>\n@time fib_tail_tail(9000)\n</cell>\n<code\
    \ language=julia-1.2>\nfunction fib_tail_tail_tail(n)\n  sum = zeros(", "  if\
    \ n.even?\n    [1, n/2].concat(tri(n.minus_one(2)).map { |x| x + x })\n  else\n\
    \    tri(n.minus_one(2)).map { |x| x + x }\n  end\nend", "  n%2==0 ?[1,3,2].map{|x|\
    \ x+(n+1)/2}.reverse.to_a : [tri(n-1) + tri(n-2) + tri(n+1)]\nend", "  fib = [1,1]\n\
    \  fib.each_with_index { |e, i| fib[i] = fib[i-1] + fib[i-2] }\n  (fib + [n] *\
    \ (n+1)).to_a\nend", "  arr = []\n  arr << n if n.even?\n  arr << 1 + n / 2 if\
    \ n.odd?\n  arr << tri(n - 1) + tri(n - 2) + tri(n + 1) + 1\n  arr\nend\n</code>\n\
    Here is a benchmarking test based on this solution:\n<code>\nrequire 'benchmark'",
  "  if n == 0\n    []\n  else\n    1 + n + tri(n - 1) + tri(n - 2)\n  end\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=0 |>\nI liked your solution but i thought\
    \ i would do some more thinking and research. \nI found this question on codewars.\
    \ \n<code>", "  if n == 0\n    1\n  elsif n == 1\n    3\n  elsif n % 2 == 0\n\
    \    tri(n - 1) + tri(n - 2) + tri(n + 1)\n  else\n    tri(n - 2) + tri(n - 1)\
    \ + tri(n + 1)\n  end\nend", "  result = []\n  i = 1\n  while i < n\n    result.push(3\
    \ * i)\n    i += 1\n  end\n  result\nend", "  tri = Array.new(n)\n  tri[0] = 3\n\
    \  if n & 1 == 0\n    tri[1] = tri[0] + tri[1]\n  else\n    tri[1] = tri[0] +\
    \ tri[1] + tri[2]\n    tri[2] = tri[0] + tri[1]\n  end\n  tri += tri.first(n -\
    \ 2)\nend", "  return [ n*(n+1)/2, n*(n+2)+1, n*(n+3)+2 ] if n.odd?\n  return\
    \ [n*(n+1)/2, n*(n+2)+1, n*(n+3)+2] + [n*(n-1)/2, n*(n-2)+1, n*(n-3)+2] if n.even?\n\
    end\n</cell>\n<text>\nNext step\nNow, you have seen how to use the Fibonacci sequence\
    \ in ruby to do some simple calculation.\nBut what if you need to use an iterative\
    \ algorithm?\nA possible solution is to use the fibonacci recursion method as\
    \ an iterator (iterators can be written recursively).", "  return [tri(n-1)+tri(n-2),\
    \ tri(n-1)+tri(n-2)]\nend", "  n = n.to_i\n  return [n,(1..n-1).inject{|i,x| (i+x)%2==0?x:(x+2)%2+1}]\n\
    end", "    tri_number = []\n    if n % 2 == 0\n        tri_number.push(n)\n  \
    \      tri_number.push(tri(n / 2) + tri(n / 2) + tri(n / 2))\n        tri_number.push(tri(n\
    \ / 2) + tri(n / 2) + tri(n / 2) + tri(n / 2))\n        tri_number.push(tri(n\
    \ / 2) + tri(n / 2) + tri(n / 2) + tri(n / 2) + tri(n / 2))\n        tri_number.push(tri(n\
    \ / 2) + tri(n / 2) + tri(n / 2) + tri(n / 2) + tri(n / 2) + tri(n / 2) + tri(n\
    \ / 2))\n    else \n        tri_number.push(n)\n        tri_number.push(tri(n\
    \ / 2) + tri(n / 2) + tri(n / 2))\n        tri_number.push(tri(n / 2) + tri(n\
    \ / 2) + tri(n / 2) + tri(n / 2))\n        tri_number.push(tri(n / 2) + tri(n\
    \ / 2) + tri(n / 2) + tri(n / 2))\n        tri_number.push(tri(n / 2) + tri(n\
    \ / 2) + tri(n / 2) + tri(n / 2) + tri(n / 2))\n        tri_number.push(tri(n\
    \ / 2) + tri(n / 2) + tri(n / 2) + tri(n / 2) + tri(n / 2) + tri(n / 2))\n   \
    \ return tri_number\nend\np tri(10)", "  if n <= 1 then\n    n\n  else\n    tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1)\n  end\nend", "\tresult = []\n\tif n % 2 == 0\n\
    \t\tresult.append(3)\n\t\tn = n-1\n\ti = 1\n\twhile i < n\n\t\tresult.push(i +\
    \ 1 + n/2)\n\t\ti += 1\n\tresult.pop\n\treturn result\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nIt might be helpful to also post the code with some explanations.\n\
    <|/ c |>\n<| a tags=fibonacci,math,ruby,recursion |>\nThis question is very old\
    \ and already has an accepted answer, but I felt I should share how I implemented\
    \ the Fibonacci sequence in JavaScript\n<code>\nfunction fibonacci(n){\n  if(n\
    \ === 1){\n    return 1;\n  }\n  if(n === 2){\n    return 2;\n  }", "  tri_array\
    \ = []\n  for i in (0...n).to_a\n    tri_array << i\n    tri_array << tri((i -\
    \ 1) + tri((i - 2)) + tri((i + 1)))\n    tri_array << tri((i - 1) + tri((i - 2))\
    \ + tri((i + 1)))\n    tri_array << i\n  end\n  return tri_array\nend\n</code>\n\
    The last problem is the factorial(n) function. What we have to do is find the\
    \ factorial of n. The factorial(n) function should return factorial(n-1) factorial(n-2)...n\
    \ and factorial(0) should be 1. We could just add them all together but it's more\
    \ efficient to calculate them separately.\n<code>", "  tri_rec = [3]\n  n.times\
    \ { tri_rec.unshift(tri_rec.last + tri_rec.pop + tri_rec.last) }\n  tri_rec\n\
    end", "  array = []\n  tribonacci(n, 0, array)\n  return array\nend", "  tri_1\
    \ = 3\n  tri_2 = tri_1 + tri_1 # tri_2 = tri_1 + tri_1 = 3 + 3 = 6\n  tri_3 =\
    \ tri_2 + tri_2 # tri_3 = tri_2 + tri_2 = 6 + 6 = 12\n  tri_4 = tri_3 + tri_3\
    \ # tri_4 = tri_3 + tri_3 = 12 + 12 = 20\n  return tri_1 + tri_2 + tri_3 + tri_4\n\
    end", "  return [(1 + n / 2).to_f, (n / 2 + 1).to_f] if n > 0\n  return []\nend\n\
    </code>\nI tested the solution using some quick benchmarks with different types\
    \ of inputs, like the following:\n<code>", "    memo = []\n    if n <= 0 \n  \
    \    memo.push(n)\n      return memo\n    else\n      memo.push(n / 2)\n     \
    \ memo.push(n + 1 - (n / 2))\n      return memo\n    end\n  end\nend", "  a =\
    \ b = nil\n  if n\n    a = 3\n    loop {\n      b = a + b\n      if b\n      \
    \  b = 3 + a\n        next b\n      end\n      break b\n    }\n  end\n  a\nend",
  "  a = [1, 1, 1]\n  a.map!{ |i| i*(i+1)/2 if i.odd?  }\n  a.push(n)\n  a\nend",
  "  result = []\n  if n <= 0 then return result\n  result[0] =  3\n  result[1] =\
    \ 1 + (n / 2)\n  result[2] = result[1] + result[0]\n  result[3] = result[2] +\
    \ result[1]\n  result[4] = result[3] + result[2]\n  result[n+1] = result[n] +\
    \ result[n-1]\n  result[n+2] = result[n+1] + result[n]\n  result[n+3] = result[n+2]\
    \ + result[n+1]\n  return result\nend", "  if n.even?\n    n.upto(2).map { |i|\
    \ tri(i + 1) }.inject(:+)\n  else\n    1.upto(n - 2).map { |i| tri(i + 1) + tri(i\
    \ + 2) }.inject(:+).reverse\n  end\nend\n</cell>\n<cell>", "\tresult = 1\n\ti\
    \ =2\n\twhile i <= n do\n\t\ti += 2\n\t\tresult = result + i\n\tend\n\tresult\n\
    end", "  return (1..n + 1).select {|i| i % 2 == 0}.map {|i| 1 + i / 2}\nend",
  "    list = []\n    if n == 0 or n == 1\n        list.push(n)\n    end\n    \n \
    \   if n % 2 == 0\n        list.push(tri(n - 1) + tri(n - 2))\n    end\n    \n\
    \    list.push(tri(n - 1) + tri(n - 2) + tri(n + 1))\n    \n    return list\n\
    end", "  \n  # YOUR CODE HERE\n  \n  return list\nend", "  return [1 + n/2, (n-1)/2,\
    \ n*(n-1)]\nend", "  tria = Array.new(2*n+1) 0\n  tria[1] = 3\n  tria[2] = 1\n\
    \  tria[3] = 1\n  tria[4] = 2\n  tria[5] = 1\n  tria[6] = 2\n  tria[7] = 1 + 3\
    \ + 8\n  tria[8] = 1 + 2 + 8\n  tria[9] = 1 + 2 + 3 + 8\n  return tria\nend",
  "\tif n == 0\n\t\treturn []\n\tif n == 1\n\t\treturn [1]\n\tif n % 2 == 1\n\t\t\
    return tri(n - 1) + tri(n - 2) + tri(n + 1)\n\telse\n\t\treturn tri(n - 2) + tri(n\
    \ - 1) + tri(n + 1)\n\t", "    if n == 0\n        tri_sum = 0\n    elsif n ==\
    \ 1\n        tri_sum = 1\n    elsif n == 2\n        tri_sum = 3\n    elsif n %\
    \ 2 == 0\n        tri_sum = tri(n-1) + tri(n-2)\n    else\n        tri_sum = tri(n-2)\
    \ + tri(n-1)\n    end\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nHere\
    \ is a Ruby version:\n<code>", "  result = []\n  loop do\n    result << (n % 2\
    \ == 0 ? 3 : (n % 2 == 1 ? 1 : 2 + tri(n / 2) + tri(n / 2 - 1)))\n    break if\
    \ result.size < n\n    n /= 2\n  end\n  result\nend\np tri(10)", "  result = []\n\
    \  if n.even?\n    result.push 1 \n    result.push n / 2 \n  else\n    result.push\
    \ 1 \n    result.push n - 1\n    result.push n + 1\n  end\n  result.reduce! do\
    \ |sum, e|\n    sum + e\n  end\n  result\nend\n</code>\nOutput:\n<code>\ntri =>\
    \ [1, 2, 3, 8]\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,fibonacci,ruby-on-rails\
    \ |>\nHere is my solution\n<code>", "  tri = [1, 3]\n  n.times do |i|\n    if\
    \ i % 2\n      tri.last << tri.last + tri.last\n    else\n      tri.last << tri.last\
    \ + tri.last\n    end\n  end\n  return tri\nend\nprint tri(5) # => [1, 1, 2, 3,\
    \ 5, 8]\nprint tri(2) # => [1, 3, 5]\nprint tri(6) # => [1, 2, 3, 5]\nprint tri(8)\
    \ # => [1, 2, 3, 5, 8]\nprint tri(7) # => [1, 3, 2, 5, 4, 5, 8, 7]\nprint tri(2)\
    \ # => [1, 3, 5]\nprint tri(0) # => []\nprint tri(-1) # => []\nprint tri(-2) #\
    \ => []", "  tris = Array.new(n)\n  tris[0] = 3\n  tris[1] = 1\n  tris[2] = (n\
    \ - 1) + tri(n - 2)\n  tris[3] = tris[(n - 2) + tri(n - 1)] + tri(2 * n - 3)\n\
    \  tris.uniq!\n  return tris\nend", "  res = []\n  if n.even? then \n    res <<\
    \ 1 \n    n -= 1\n  else\n    n -= 1\n    tri1 = tri(n-1)\n    tri2 = tri(n-2)\n\
    \    res << tri1 + tri2\n  end\n  res\nend", "    if n == 1\n        [1,3]\n \
    \   if n == 2\n        [1,3,2]\n    if n % 2\n        tri(n-1) + tri(n-2)\n  \
    \  else\n        tri(n-1) + tri(n-2) + tri(n+1)\nend\n</cell>\n<cell>", "    arr\
    \ = []\n    if n<=1\n        arr << 1\n    else\n        if n%2 == 0\n       \
    \     arr << 1 << 1\n        else\n            arr << 1 <<\n            tri(n\
    \ / 2) << \n            tri(n / 2 + 1)\n        end\n    end\n    arr\nend", " \
    \ seq = []\n  i = 2\n  while i < n do\n    seq << i \n    i += 2\n  end\n  seq\
    \ << n\n  return seq\nend", "  return [] if n <= 2\n  return [tri(n-1)+tri(n-2)+tri(n-3)]\n\
    end", "  arr = [0] * (n + 1)\n  arr[0] = 3\n  arr[1] = 1 + n/2\n  arr[(n+1)] =\
    \ arr[n-1] + arr[n-2] + arr[n+2]\n  return arr[0...n]\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert tri(3) == [1, 3, 2, 8] \"Your function should return [1, 3, 2, 8].\"\n\
    </cell>\n<text>\nProblem 4", "  result = []\n  loop do\n    result << tri(n -\
    \ 1) + tri(n - 2) + tri(n - 3)\n    break if n == 1\n    result << tri(n - 1)\
    \ + tri(n - 2)\n    break if n % 2 == 0\n    n -= 1\n  end\n  result\nend", " \
    \ i = 1\n  total = []\n  while i < n\n    total << i\n    i += 1\n    n -= 2 if\
    \ n != 1\n    total << n if n % 2 == 0\n    n += 1 if n % 2 == 1\n  end\n  total\n\
    end\n</cell>\n<code language=julia-1.5>\ntri(15)\n</cell>\n<code language=julia-1.5>",
  "    result = []\n    fib1 = 1\n    fib2 = 1\n    fib3 = 1\n    fib4 = 1\n    fib5\
    \ = 1\n    fib6 = 1\n    fib7 = 1\n    fib8 = 1\n    if n % 2 == 0: # even number\n\
    \        fib1 = fib1 + fib2\n        fib2 = fib3 + fib4\n        fib3 = fib5 +\
    \ fib6\n        fib4 = fib7 + fib8\n        fib5 = fib1\n        fib6 = fib3\n\
    \        fib7 = fib4\n        fib8 = fib5\n        while fib8 <= n:\n        \
    \    result.append(fib8)\n            fib8 = fib8 + fib8\n    elif n % 2 == 1:\
    \ # odd number\n        fib1 = fib1 + fib2\n        fib2 = fib3 + fib4\n     \
    \   fib3 = fib5 + fib6\n        fib4 = fib7 + fib8\n        fib5 = fib1\n    \
    \    fib6 = fib3\n        fib7 = fib4\n        fib8 = fib5\n        while fib8\
    \ <= n:\n            result.append(fib8)\n            fib8 = fib8 + fib8\n   \
    \ else: # Invalid n\n        pass\n    return result\n</cell>\n<cell>", "  return\
    \ [tri(n - 1) + tri(n - 2) + tri(n - 3)]\nend", "  if n < 0\n    return []\n \
    \ a = tri(n - 1) + tri(n - 2)\n  b = tri(n - 2) + tri(n - 3)\n  c = tri(n - 3)\
    \ + tri(n - 4)\n  [a, b, c] = [b, c, a]\n  a += b + c\n  a %= 1000000007\n  return\
    \ a\nend", "    fib = [1,3]\n    while fib[0] <= n\n        fib.unshift(fib[-1]\
    \ + fib[-2])\n    end\n    return fib\nend", "  result = [1,3,2]\n  if n<2\n \
    \   result\n  else\n    result << result[-1] + result[-2] + result[-3] \n    if\
    \ n%2 == 0\n      result\n    else\n      result << result[-1] + result[-2]\n\
    \    end\n  end\nend", "    tri_array = []\n    (1..n).each do |i|\n        tri_array\
    \ << (i-1)\n        tri_array << (i+2)\n    end\n    return tri_array\nend", " \
    \ result = []\n  result[0] = n\n  result[1] = n + 1 + n/2\n  if n % 2 == 0\n \
    \   result[2] = tri(n-1)\n    result[3] = tri(n-2) + tri(n+1)\n  else\n    result[2]\
    \ = tri(n-1) + tri(n-2)\n    result[3] = tri(n-3)\n  end\n  result\nend\nputs\
    \ tri(6)", "\tresult = []\n\tresult << n\n\tif n % 2 == 0\n\t\tresult << tri(n\
    \ - 1) + tri(n - 2)\n\telse\n\t\tresult << tri(n - 1) + tri(n - 2) + tri(n + 1)\n\
    \tend\n\tresult\nend", "  result = [1,3]\n  result[1] = result[1] + result[2]\
    \ if n % 2 == 0\n  result[2] = result[3] + result[1] + result[2] if n % 2 != 0\n\
    \  result[n] = result[n-1] + result[n-2] + result[n] + result[n+1]\n  return result\n\
    end", "    arr = Array.new(n)\n    arr[0] = 3\n    arr.slice!(0, 1); arr.slice!(-1,\
    \ 2); arr.slice!(1, 3)\n    arr\nend", "  if n<=0\n    []\n  else\n    tri(n.floor)\
    \ + tri(n.floor-1) + tri(n.floor-2) + [n]\n  end\nend\n</code>\n<|/ a |>\n<| a\
    \ tags=ruby |>\n<code>\n(1..n).reduce(:+).to_a.reverse\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThis is an awesome solution. Elegant and simple!\n<|/ c |>\n<|\
    \ c |>\nThis should be the accepted answer. `reduce` is the best solution IMHO\
    \ because it avoids unnecessary method calls. Also it returns an array instead\
    \ of an enumerator so `to_a` is needed.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer! \n`reduce` is the best solution IMHO because it avoids unnecessary\
    \ method calls. Also it returns an array instead of an enumerator so `to_a` is\
    \ needed.\n<|/ c |>\n<| c |>\nThis should be the accepted answer! `reduce` is\
    \ the best solution IMHO because it avoids unnecessary method calls. Also it returns\
    \ an array instead of an enumerator so `to_a` is needed.\n<|/ c |>\n<| a |>\n\
    <code>", "\treturn Array.new(n){1..n}.inject(:+).tap {|n| n.odd? ? n.ceil : n.floor\
    \ }.tap {|n| n.even? ? 1 : nil }\nend\n</cell>\n<code language=julia-0.4>", " \
    \ if n == 0\n    [1,3,2]\n  elsif n == 1\n    [3]\n  elsif n == 2\n    [1,3,2]\n\
    \  elsif n % 2 == 0\n    tri(n-1)+tri(n-2)\n  elsif n % 2 == 1\n    tri(n-1)+tri(n-2)+tri(n+2)\n\
    \  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
