name: HumanEval_49_modp
language: rb
prompt: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n# >>>\
  \ modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n# >>> modp(100,\
  \ 101)\n# 1\ndef modp(n, p)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
  \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2,\
  \ candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8,\
  \ candidate.call(3, 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4,\
  \ candidate.call(30, 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
completions: ["  return ((n % p + p) % p + p) % p\nend\n\"\"\"\n    \n    \n  def\
    \ init_state_balanced(self, nstates):\n    \"\"\"\n    Initialize the state vector\
    \ for the balanced problem.\n    \n    Input:\n      nstates (int): number of\
    \ states\n    \n    Output:\n      state_vect (Vector): n-vector (nstates x 1)\n\
    \      start_state (int): starting state\n    \"\"\"\n    #TODO: implement this\n\
    \    self.state_vect = [0.0] * self.nstates\n    \n    \n  def init_state_in_balanced(self,\
    \ nstates):\n    \"\"\"\n    Initialize the state vector for the in-balanced problem.\n\
    \    \n    Input:\n      nstates (int): number of states\n    \n    Output:\n\
    \      state_vect (Vector): n-vector (nstates x 1)\n      start_state (int): starting\
    \ state\n    \"\"\"\n    #TODO: implement this\n    self.state_vect = [0.0] *\
    \ self.nstates\n    \n    \n  def init_state_unbalanced(self, nstates):\n    \"\
    \"\"\n    Initialize the state vector for the unbalanced problem.\n    \n    Input:\n\
    \      nstates (int): number of states\n    \n    Output:\n      state_vect (Vector):\
    \ n-vector (nstates x 1)\n      start_state (int): starting state\n    \"\"\"\n\
    \    #TODO: implement this\n    self.state_vect = [0.0] * self.nstates\n    \n\
    \    \n  def calculate_state_mat(self, state_vect, start_state, nstates, transition_dict):\n\
    \    \"\"\"\n    Calculate the state transition matrix\n    \n    Input:\n   \
    \   state_vect (Vector): n-vector (nstates x 1)\n      start_state (int): starting\
    \ state\n      nstates (int): number of states\n      transition_dict (dict):\
    \ dictionary of transitions\n    \n    Output:\n      transition_mat (Matrix)\n\
    \    \"\"\"\n    \n    ", "    return ((n % (p + 1)) == 0 and 1 or 0)\nend", " \
    \ return ((n % p) + p) % p\nend", "  return ((n+1)%p)\nend", "  pow = ldexp(1,n)\n\
    \  p = ldexp(1,p)\n  x = ldexp(1,n)\n  result = 1\n  while n > 0 do\n    if result\
    \ > p then return 0\n    r = n % p\n    n = r\n    result = r * x + result\n \
    \   x = ldexp(1,x)\n  end\n  return result\nend", "  if p == 0 then\n    return\
    \ 1\n  else\n    if n < 0 or n % p != 0 then\n      return 0\n    else\n     \
    \ return modp(n-1, p)\n    end\n  end\nend", "  while n > p, n -= p, p += 1\n\
    \  n\nend", "  r, s = n, 0\n  while p >= 0 do\n    r, s = (s % p + r) % p, r\n\
    \  end\n  r\nend", "  if p == 0: return 0\n  if n >= p: n %= p\n  return n", '  return
    ((n % p) + p) % p', '  return ((n % p + p) % p + p) % p', "  r = 0\n  while n\
    \ > p\n    r = (r + 1) * (n // p)\n    n %= p\n  end\n  r\nend", "  (p*(n%p))\
    \ % p\nend", "  return 2**(n-1) % (p-1)\nend", "  r = 0\n  while n > 1\n    r\
    \ <<= 1\n    r |= n & 1\n    n >>= 1\n    n &= p\n  end\n  r\nend", "    if n\
    \ < 0 or n >= p\n        return p\n    return p % n", "  if n == 0: return 0\n\
    \  if n == 1: return p\n  if p == 0: return 0\n  if p > n: return 0\n  if p <\
    \ n: return modp(n - p + 1, p) % p\n  s = 1\n  while p & 1 == 0:\n    s += p\n\
    \    p >>= 1\n  if p: return s\n  m = 1\n  while p & 1 == 1:\n    m <<= 1\n  \
    \  p >>= 1\n  s %= m\n  return s", "  return ((n % p) + p) % p\nend", "  r = 1\n\
    \  while n > 0\n    r = r * p % n\n    n = n / 2\n  end\n  r\nend", '  return
    ((n % p) + p) % p', "\treturn ((n % p) + p) % p", "  remainder, result = n, p\
    \ - 1\n  while remainder != 0\n    remainder, remainder = divmod(remainder, p)\n\
    \    result = remainder\n  end\n  result\nend", "  if n < 0 or n >= p\n    puts\
    \ $!\n    puts \"modp error: n (#{n}) not between -p and p (#{p})\"\n    puts\
    \ $!\n    exit(1)\n  end", '  return n^((n&1)+p-n&1) & ((1&n)|p-1)', "  mod =\
    \ 1\n  while n > p\n    mod *= p\n    n -= p\n  mod *= n\n  mod\nend", "  return\
    \ ((n % p) + p) % p\nend", "  result = (n - 1) % p\n  p -= 1\n  while (result\
    \ * p) % p != 0\n  result = (result + p) % p\n  p -= 1\n  while (result * p) %\
    \ p != 0\n  result = (result + p) % p\n  p -= 1\n  result\nend", '  return ((p-1)//n)*n
    + (p % n)', "  return ((n % p) + p) % p\nend", "  m = n % p\n  t = m % p\n  r\
    \ = m % p\n  if r < 0\n    m += p\n    if m > n\n      m -= p\n      t += p\n\
    \  return m\nend", "  result = 1\n  while p > 0\n    if n % p == 0\n      break\n\
    \    p /= 2\n    result += 1\n  result\nend", "\treturn (( n & ( ~ ( (0xffffffffffffffffL)\
    \ >> ( ( n - 1 ) * 64 ) ) ) ) ^ ( ( (0xffffffffffffffffL) >> ( ( n - 1 ) * 64\
    \ ) ) ) & p) ^ ( ( (0xffffffffffffffffL) >> ( ( n - 1 ) * 64 ) ) ) &", "  n =\
    \ n.to_i\n  p = p.to_i", "  return p + (n & -p).bit_length() if p != 0 else n\n\
    end", "  n = n.to_i\n  p = p.to_i\n  if n >= 0\n    return ((n % p) + p) % p\n\
    \  else\n    return ((n % p) + p + 1) % p\n  end\nend", "  return p - (p ** n)\
    \ % p\nend\n@inline function modp(v, d)\n  return v % d\nend\n@inline function\
    \ modp(v, k)\n  return modp(v ^ (v >> k), (1 << k))\nend", "  n = (n.to_i * 2)\
    \ + n\n  n1 = n % p\n  n2 = n - n1\n  if n2 > p\n    n2 %= p\n    n2 += p\n  \
    \  n2 %= p\n  n2 += n1\n  n2 %= p\n  return n2\nend", '  return ((n & (p-1)) ^
    n) % p', "    n %= p\n    while n != 0 and n != p:\n        n >>= 1\n    return\
    \ n", "  (p == 1) ? n : ((n % p) + p) % p\nend", "  return ((p-1) * pow(2, n))\
    \ % p\nend", "  x = n % p\n  if x < 0 then\n    return x + p\n  end\n  return\
    \ x\nend", "  return ((n % p) + p) % p\nend\n</cell>\n<text>\nLet's define our\
    \ own mod function. Modular-arithmetic is pretty cool.", "  return ((n % p) +\
    \ p) % p\nend", "  r = n % p\n  if r > p\n    r %= p\n  end\n  r\nend", '  return
    ((n-1) % p + p) % p', "  nn = n.to_i\n  ps = p.to_s\n  if nn % ps == 0 then\n\
    \    return nn\n  else\n    return ((n % ps) + ps) % ps\n  end\nend\n</code>\n\
    <|/ a tags=lua,math,algorithm |>\n<| a dscore=2 |>\nThis is a trick question about\
    \ a mathematical problem, the problem itself is not interesting for you, however\
    \ the solution is, so I will show you a function that solves this problem.\nIn\
    \ a nutshell you just need to get the prime factorization of the first number\
    \ of the number and then multiply each prime factor of the number with the number\
    \ itself and you will get your answer.\n<code>\nfunction get_factors(n)\nlocal\
    \ factors = {} -- list of factors of n\nfactors[1] = 2\nwhile n > 2 do\n    local\
    \ i = 1\n    local p = factors[i]\n    while p * p <= n and n % p == 0 do\n  \
    \      local q = p / i\n        factors[i] = p\n        factors[q] = i\n     \
    \   i = q + 1\n        p = factors[i]\n    end\n    n = n / i\n    factors[i]\
    \ = n\nend\nreturn factors\nend", '  return ((n % p) + p) % p', "  n = n.abs %\
    \ p\n  if n > 0\n    n, p = p - n, p\n  else\n    n, p = p + (n != 0), p\n  end\n\
    \  n <= p ? n : nil\nend", "  ((n % p) + p) % p\nend\n</code>\nThis algorithm\
    \ is easy to understand, and it's very efficient. The algorithm itself consists\
    \ of three steps. In the first step, you can calculate the factors of n modulo\
    \ p, then apply the reminder algorithm (which I already explained in the very\
    \ beginning).\nThe second step is calculating the inverse of p modulo n.\nFinally,\
    \ the algorithm is rewritten to be able to handle large numbers as well:\n<code>",
  "  ((n % p) + p) % p\nend\n  ", "  n.times { n <= p ? n : n % p }\nend", "  if n\
    \ == 0: return p\n  else return (n % p + p) % p\nend", "  ret = 1\n  while n >\
    \ p do\n    ret = ret * 2\n    n = n / p\n  end\n  ret\nend", "  m = n & -p\n\
    \  m = (m >> p) & p\n  m = (m << p) & p\n  m &= p\n  return m\nend", '  return
    ((n+1)%p)', "\twhile n != 0\n\t\t((n%p) == 0 ? (return n) : (p=(p*10), n%=p)),\n\
    \tend\n\t\n\t# Should not happen.\n\treturn nil\nend", "  return ((p % n) + n)\
    \ % p\nend", "  return ((n // p) * p) % p\nend", "  return ((n%p)+p) % p\nend",
  '  return ((n / p) ** (n % p)) * (p if n < p else 1)', '  return ((n%p) + (n%(p-1)))
    % p', "  result = 1\n  while n > 0 do\n    if n & 1 == 1 then\n      result =\
    \ result * p\n    end\n    n = n / 2\n  end\n  if result % p == 0 then\n    return\
    \ 1\n  end\n  return result\nend", "  n = ((n % p) + p) % p\n  if n == 0 then\
    \ n else n\nend\n</cell>\n<code language=julia-0.5>", "  return ((n % p) + p)\
    \ % p\nend", "  (p == 0) && return 0 # p == 0 is special case\n  return ((n %\
    \ p) + p) % p\nend", "  nn, np = n.to_i, p.to_i\n  return 0 if nn == 0 else p\
    \ - (p // nn) * nn\nend", '  return n and ((n % p) + p) % p', "  return ((n-1)%p\
    \ + p) % p\nend", '  return ((n % p + p) % p) % p', '  return ((n-1)%p + p)%p',
  "\tif n == 0 or p == 0 then\n\t\treturn 0\n\tend\n\tif n < p then\n\t\treturn modp(n\
    \ - p, p)\n\tend\n\treturn n\nend", "  r = p % n\n  r == 0 ? 1 : r\nend", "  r\
    \ =  (n % p).zero? ? p : (rand(p) + 1).ceil\n  while r.odd? && n < p\n    r =\
    \  (r * p + rand(p)).ceil\n  end\n  r\nend\n</code>\n<|/ a |>\n<| a dscore=3 |>\n\
    In Ruby 1.9 you can get the same result with rand.to_s(36):\n<code>", "  rem =\
    \ n\n  while rem>0 and rem%p>0\n    rem = rem%p\n  end\n  return rem.zero? ? n\
    \ : rem\nend", "  r = 0\n  while p > 0\n    r, p = r + n % p, p / 10\n  end\n\
    \  return r\nend", "  if n < 0 or n >= p\n    then return nil\n  else\n    local\
    \ m = (p * p) % p\n    return m == 0 and n or m\n  end\nend", '  return ((n -
    1) % (p + 1)) if (0 < n and n < p) else  n', "  while n > 0\n    n -= p\n  end\n\
    \  n\nend", "\tdiv, mod = n % p, p\n\tif div == 0 and mod != 0: return mod\n\t\
    return modp(div, p)", "\treturn n ** p % p\nend", "  return p if p == 0 mod n\
    \ else modp(n mod (p - 1), p)\nend", '  return ((n % p) + p) % p', "  rem = 0\n\
    \  while n > 0 do\n    rem = rem + n % p\n    n = n / p\n  end\n  return rem\n\
    end", "  r =\n    begin\n      x =\n        begin\n          y =\n           \
    \ begin\n              k1 =\n                begin\n                  r1 =\n \
    \                   begin\n                      k2 =\n                      \
    \  begin\n                          r2 =\n                            begin\n\
    \                              k3 =\n                                begin\n \
    \                                 r3 =\n                                    begin\n\
    \                                      k4 =\n                                \
    \        begin\n                                          r4 =\n             \
    \                               begin\n                                      \
    \        k5 =\n                                                begin\n       \
    \                                           r5 =\n                           \
    \                         begin\n                                            \
    \          k6 =\n                                                        begin\n\
    \                                                          r6 =\n            \
    \                                                begin\n                     \
    \                                         k7 =\n                             \
    \                                   begin\n                                  \
    \                                r7 =\n                                      \
    \                              begin\n                                       \
    \                               k8 =\n                                       \
    \                                 begin\n                                    \
    \                                      r8 =\n                                \
    \                                            begin\n                         \
    \                                                     k9 =\n                 \
    \                                                               begin\n      \
    \                                                                            r9\
    \ =\n                                                                        \
    \            begin\n                                                         \
    \                             k10 =\n                                        \
    \                                                begin\n                     \
    \                                                                     r10 =\n\
    \                                                                            \
    \                begin\n                                                     \
    \                                         k11 =\n                            \
    \                                                                    begin\n \
    \                                                                            \
    \                     r11 =\n                                                \
    \                                                    begin\n                 \
    \                                                                            \
    \         k12 =\n                                                            \
    \                                            begin\n                         \
    \                                                                            \
    \     r12 =\n                                                                \
    \                                            begin\n                         \
    \                                                                            \
    \         k13 =\n                                                            \
    \                                                    begin\n                 \
    \                                                                            \
    \                     r13 =\n                                                \
    \                                                                    begin\n \
    \                                                                            \
    \                                         k14 =\n                            \
    \                                                                            \
    \                begin\n                                                     \
    \                                                                     r14 =\n\
    \                                                                            \
    \                                                begin\n                     \
    \                                                                            \
    \                             k15 =\n                                        \
    \                                                                            \
    \            begin\n                                                         \
    \                                                                         r15\
    \ =\n                                                                        \
    \                                                          begin\n           \
    \                                                                            \
    \                                             k16 =\n                        \
    \                                                                            \
    \                                  begin\n                                   \
    \                                                                            \
    \                         r16 =\n                                            \
    \                                                                            \
    \                begin\n                                                     \
    \                                                                            \
    \         k17 =\n                                                            \
    \                                                                            \
    \    r17 =\n                                                                 \
    \                                                                            \
    \ k18 =\n                                                                    \
    \                                                                            r18\
    \ =\n                                                                        \
    \                                                                          k19\
    \ =\n                                                                        \
    \                                                                            r19\
    \ =\n                                                                        \
    \                                                                            \
    \  k20 =\n                                                                   \
    \                                                                            \
    \         r20 =\n                                                            \
    \                                                                            \
    \                  k21 = begin\n                                             \
    \                                                                            \
    \                                   r21 =\n                                  \
    \                                                                            \
    \                                                k22 =\n                     \
    \                                                                            \
    \                                                               r22 =\n      \
    \                                                                            \
    \                                                                            \
    \    k23 =\n                                                                 \
    \                                                                            \
    \                       r23 =\n                                              \
    \                                                                            \
    \                                            k24 =\n                         \
    \                                                                            \
    \                                                                   r24 =\n  \
    \                                                                            \
    \                                                                            \
    \                k25 =\n                                                     \
    \                                                                            \
    \                               r25 =\n                                      \
    \                                                                            \
    \                                                        k26 =\n             \
    \                                                                            \
    \                                                                       r26 =\n\
    \                                                                            \
    \                                                                            \
    \        r27 =\n                                                             \
    \                                                                            \
    \                       r28 =\n                                              \
    \                                                                            \
    \                                      r29 =\n                               \
    \                                                                            \
    \                                                     r30 =\n                \
    \                                                                            \
    \                                                                    r31 =\n \
    \                                                                            \
    \                                                                            \
    \       r32 =\n                                                              \
    \                                                                            \
    \                      r33 =\n                                               \
    \                                                                            \
    \                                     r34 =\n", "  (p == 0) ? 1 : modp(n >> 1,\
    \ p << 1) + p % n\nend\n</code>\nIt also works with floats and big integers, as\
    \ long as they fit into a 32-bit integer:\n<code>", "  return (n + p) % (p + n)\n\
    end", "  n0 = n.to_i\n  p0 = p.to_i\n  n0mod = n0.modulo(p0).to_i\n  n1mod = (n0mod\
    \ + p0).modulo(p0).to_i\n  n1mod2 = (n0mod + p0).modulo(p0).to_i\n  n2 = (n0mod\
    \ + p0).modulo(p0).to_i\n  n3 = (n0mod + p0).modulo(p0).to_i\n  return n2 if n2\
    \ % p0 == 0 else n3 if n3 % p0 == 0 else n1mod2 if n1mod2 % p0 == 0 else n1mod\n\
    end", "  r\n  if p.zero?\n    r\n  else\n    p % n == 0 ? r : modp(n, p.quoquo)\n\
    \  end\nend", "  x = 1\n  while n > 0\n    x = (x + 1) % p\n    n = n // 2\n \
    \ end\n  x\nend", "  return ((p-1)*n) % p\nend", '    return n % (p - 1)', " \
    \ return ((n-1) & (-p)) | ((n-1) & n)\nend\n</cell>\n<code language=julia-0.4>",
  "  return ((p-1)*n+n)%r\nend", "  return n % (p * 2 - 1)\nend", "  if n<0: return\
    \ 0\n  if n==0: return 1\n  if n==1: return p\n  return n % p", "  # This code\
    \ was written by Georg M\xFCller. It was submitted 2004-01-24:\n  # http://shootout.alioth.debian.org/u32qc.php\n\
    \  x, r = divmod(n, p)\n  if x != 0 or r:\n    if r:\n      x = r\n    return\
    \ x % p\n  return x", "  x =  n\n  rem1 = 1\n  rem2 = 1\n  \n  # Keep going while\
    \ x != 0\n  while rem2 != 0\n    # Get the remainder of x divided by p.\n    rem1\
    \ =  rem1 * p % p\n    # Get the remainder of x divided by (p+1).\n    rem2 =\
    \ rem2 % p + 1\n    x -= 1\n  # Return x mod p.\n  return x % p\nend", '  return
    ((n % p) + p) % p', "  n%=p\n  while (n%p==0) do n+=1\n  return n\nend", "  return\
    \ ((n & -p) * n) >> modbits(n)\nend", '  return ((n % p) + p) % p', '    return
    ((n % p) + p) % p', "  return pow(n, p, p)\nend", "  r, s = 0, 1\n  while n >\
    \ p\n    r, s = s * (n - p), s + 1\n    n /= p\n  return r\nend", "  return 0\
    \ if n == 0 else n % p\nend", "  n, p = n.floor, n + p.floor + 1 while n >= p\
    \ && n % p == 0\n  n\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nVery nice! Do\
    \ you know if there is a way to do the same for BigDecimal instead of integers?\n\
    <|/ c |>\n<| c |>\nyes, just replace the calls to `Integer` by `BigDecimal` everywhere.\n\
    <|/ c |>\n<| c |>\nBut then it would return a BigDecimal instead of an int.\n\
    <|/ c |>\n<| c |>\n: Yes, but your question didn't mention anything about using\
    \ BigDecimal, just integers.\n<|/ c |>\n<| c |>\nYes I know, but my question is\
    \ more on the mathematical side. I would say that the two answers give different\
    \ results for `modp(15, 11)` (for example). `modp(15, 11)` is an odd number when\
    \ compared to `modp(15, 10)` which is even but not `modp(15, 11)`.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "  return ((n % (p+2*3)) * (2*(p % 4) + (p % 7)))\n\
    end", "  r = 0\n  if p == 0 or p == 1 or p == 2\n    return r\n  while p != 0\
    \ and n != 0\n    p = p / 2\n    n /= 2\n    r = r + 1\n  return r % p\nend",
  '  return ((n % p) + p) % p', "  return ((n % (p - 1)) + p) % p\nend", "  n = n.to_i(2)\n\
    \  p = p.to_i(2)\n  while n > 0\n    r, n = n.divmod(p)\n    r = r.to_i(2)\n \
    \   r = r + p if r > p else r\n  end\n  return r\nend", "  nmod = (n % p + p)\
    \ % p\n  if nmod == 0 then\n    return n\n  end\n  return modp(nmod, p)\nend",
  "  m = n % p\n  m == 0 ? n : n / p + m\nend", "  # Make sure n and p are integers.\n\
    \  if n % p == 0 && (n.to_i < 0 || n.to_i >= p.to_i)\n    p # n and p are coprime\n\
    \  else\n    n % p # n is definitely not coprime\n  end\nend", '  return p & (n-1)',
  "  p %= n\n  return 0 if n == 0 else (p + (n % p)) % p\nend\n  ", "  q, r = divmod(n,\
    \ p)\n  if r == 0: return q\n  r1, r2 = divmod((r + 1), p)\n  if r2 == 0: return\
    \ q + r1\n  return q + r1 + 1\nend", '  return p - (p % n)', "  if ((n < 0) or\
    \ (n < p)) or (n >= p)\n    throw ArgumentError(\"modp(#{n}, #{p}): n < 0 or n\
    \ < p or n >= p\")\n  n\nend", "\treturn (n - p % n) % n\nend", '  return (((n%p)+p)%p)
    if p != 0 else 0', '  return n % p', '  return ((n % p) + p) % p', "    if n<0\
    \ or p<0\n        error(\"modp() called with negative arguments\")\n    return\
    \ ((n%p)+p)%p", "  return n & (-p).bin(2).dec()\nend", "  return ((n+p-1)%p)*n\n\
    end", "  return ((n % p) + p) % p\nend", "\tif n == 0\n\t\treturn 1\n\telse if\
    \ n <= p\n\t\treturn 0\n\telse\n\t\tmid = (p + n - 1) >> 1\n\t\tx = modp(n, mid)\n\
    \t\tif x < p\n\t\t\treturn x\n\t\telse\n\t\t\treturn mid\nend", "  r = 1\n  while\
    \ n > 0\n    r = ((n % p) + r) % p\n    n /= p\n  r\nend", "  q, r = divmod(n,\
    \ p)\n  if r != 0: return r\n  a, b = divmod(q, p)\n  if a != 0: return a\n  return\
    \ p", '  return ((n % p) + p) % p', "  x = p\n  r = 1\n  while x >= n do\n   \
    \ x -= n\n    r = r * x\n  end\n  return r\nend", '  return ((n % p) + p) % p',
  '  return ((n % p) + p) % p', "  return ((n-1) * p) % p\nend", "  ((n%p) == 0) ?\
    \ (n%(p == 0 ? 0 : p)) : modp(n%(p == 0 ? 0 : p), p)\nend", "  if n < 0 or p <\
    \ 0\n    raise \"Negative modulo arguments\"\n  result = 1\n  while n > 0\n  \
    \  n -= 1\n    result *= p\n    result %= p\n  result\nend", "  r = n % p\n  return\
    \ r if r == 0 else p + (r * modp(n, p))\nend", '  return n * (n % p + p) % p',
  "  x = ((n % p) + p) % p\n  return x if x >= 0 else x + p", "  n = n.abs # numerically\
    \ safe (mod p)\n  x = n.log2 # bit count of n\n  y = x.quo(p) # y = floor(log2(n))\n\
    \  z = (y - 1).abs # z = 2^y - 1\n  z = (z - y).quo(p) # z = 2^y - 1\n  z = (z\
    \ - 1).quo(p) # z = 2^y - 1\n  x = x.quo(p) # x = (2^(y-1)) - 1\n  return x.quo(p)\
    \ # x", "    if p < 2:\n        return n\n    if p & 1 and n == 0:\n        return\
    \ p\n    if p & 1 and n != 0:\n        return n\n    if n >= p:\n        return\
    \ n\n    if n % p == 0:\n        return modp(n // p, p)\n    else:\n        return\
    \ modp(n % p, p)", "  if n == 0 or p == 0: return 0\n  while p % n == 0: n = n\
    \ / n\n  return n", "  return ((n % p) + p) % p\nend", '  return ((n % p) + p)
    % p', "  return ((n % p) + p) % p\nend", "  r = n % p\n  mod =  (n // p) * p\n\
    \  return r if r < mod else mod\nend", '  return ((n << 1) ^ (n >> 63)) % p',
  '  return ((n & -p) | n) & p', "  if n < 0:\n    return 0\n  if n == 1:\n    return\
    \ 1\n  if n == 2:\n    return p\n  if n % 2 == 0 and p % 2 == 0:\n    return n\n\
    \  if n % 2 == 0 and p % 2 != 0:\n    return p - n\n  return modp(n - 1, p) +\
    \ p - 1", "  result = 1\n  while n > 0 and p > 0\n    quotient, remainder = divmod(n,\
    \ p)\n    n -= quotient\n    result += remainder\n    p -= 1\n  result\nend",
  "  return ((n // p) + 1) * p - n if n > p else n\nend", "\tif n < 0\n\t\traise ValueError,\
    \ \"n cannot be negative\"\n\treturn p**n % p\nend", "  if n < 0 or p < 0\n  \
    \  0\n  elsif n <= p \n    n\n  elsif n == p\n    n\n  else\n    (((n - p) % p)\
    \ + p)\n  end\nend", '  return ((n % p) + p) % p', "  return ((n % p) + p) % p\n\
    end", "  if n < 0 or n >= p\n    return n\n  ret = 1\n  while n > p\n    n -=\
    \ p\n    ret += 1\n  end\n  return ret\nend", '  return ((p-1) * (n)%p)', "  return\
    \ ((n % p) + p) % p\nend", "  return ((n >> p) & Modulus.modulo_mask) ^ Modulus.modulo\n\
    end", "  if p == 0 or p == n:\n    return 1\n  if p == 1 or n == 0: return 0\n\
    \  if n == 1: return 1\n  k = 3\n  while k <= n:\n    if ((k << 1) + 1) <= p:\n\
    \      return k\n    k += 2\n  return k", "  x = n / p\n  r = n % p\n  if r !=\
    \ 0\n    return r + (p - 1)\n  return x", "  remainder, remainders = n % p, []\n\
    \  n.times do |i|\n    remainder, r = remainder % p, i\n    remainders << r if\
    \ r <= 0\n    remainder /= p\n  end\n  remainder\nend", '    return ((n % p) +
    p) % p', "  res = 1\n  while n > p\n    res = (res * n) % p\n    n = (n * n) %\
    \ p\n  res\nend", "  n1 = n - 1\n  n0 = n >> 1\n  n01 = n0 % p\n  n11 = n0 <<\
    \ 1\n  n10 = (n11 >> 1) ^ p\n  n011 = (n10 >> 1) ^ p\n  n101 = n10 % p\n  n110\
    \ = n11 << 1\n  n100 = (n110 >> 1) ^ p\n  n0110 = (n100 >> 1) ^ p\n  n1001 = n100\
    \ % p\n  n0010 = (n1001 >> 1) ^ p\n  n0001 = n1001 << 1\n  n0000 = p << 1\n  n000001\
    \ = (n0010 >> 1) ^ p\n  n0000001 = (n00000 >> 1) ^ p\n  n00000001\nend", "  return\
    \ ((n % p) + p) % p\nend", "  return ((p-1)*n%p)\nend", "  return ((n % (p + 1))\
    \ == 0 and 1 or 0)\nend", "  result = 0\n  if n.zero?\n    return result\n  end ",
  "  (n == 0) && return 1\n  ((p != 1) && (p != 0) && (p != 0)) ? n %= p : n\nend",
  "  return ((n % p) + p) % p\nend", "  n %= p\n  if n == 0 && p != 0\n    p\n  else\n\
    \    n\n  end\nend", "\treturn 0 if (p == 1) else (n & ((1 << p) - 1)) >> p",
  "  n = n % p\n  return n if n < 0 or p == 0 else (n % p)\nend", '  return p if n
    < 0 else ((p % n) + n)', "  n%p ? n : ((n%(p-1))*p + n)\nend", "  return pow(n,\
    \ p, p)\nend", "    mask = n >> 63\n    return ((n ^ mask) ^ mask) % p\nend",
  "  return n%p\nend", '  return ((n >> p) + n) & -p', "  return ((n << p) & 0xff)\n\
    end", "  m = n % p\n  if m == 0 then\n    return 1\n  else\n    return modp(m,\
    \ p)\n  end\nend", "  if ((n & -n) == n) & (n != 0)\n    return n\n  xl = modinv64(n,\
    \ p)\n  r = (xl % p + p) % p\n  return r\nend", '    return ((p-1) * p) % n',
  '  return p if n and p*p < n and n % p == 0 else n', "  return ((n & (p - 1)) ==\
    \ 0)\nend", "  r = n % p\n  if r == 0\n    r = p\n  r\nend", "  n.bit_shift %\
    \ p\nend", "  r = n\n  i = 1\n  while i < p\n    r = ((r % p) + n) % p\n    i\
    \ += 1\n  return r\nend", "\treturn (n % p + p) % p", "\treturn ((p-1)*n) % p\n\
    end", "  if p == 0 or n == 0\n    return 0\n  a = (n << 1) + 1\n  while a >= p\n\
    \    a -= p\n  n = (n << 1) + 1\n  while n < p\n    n <<= 1\n  a %= p\n  n %=\
    \ p\n  a %= p\n  return n", "  return ((p-1)*n) % p\nend", "  # Python allows\
    \ a modulo with zero\n  if  p <= 0 or n <= 0\n    return 0", "  r = p - 1\n  while\
    \ n != 0 and (n & 1) != 0\n    r = ((r - 1) ^ n) & 0xff\n    n >>= 1\n  end\n\
    \  return r\nend", '  return ((n|p) % p) if (n|p) >= 0 else ((n%p) + p)', "  n\
    \ = (n or 0).abs % p\n  if n < 0\n    n = (p + n) % p\n  end\n  n\nend", "  n%p\
    \ < 0 and return n % p\n  n%p == 0 and return n\n  n%p == p and return n\nend\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\n`modp(0, 101)` returns 1 instead of 0\n<|/\
    \ c |>\n<| a tags=math,modular,ruby dscore=3 |>\nFor Python users, here's an optimized\
    \ version of J\xF6rg's solution:\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
