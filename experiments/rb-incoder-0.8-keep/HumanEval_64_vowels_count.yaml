name: HumanEval_64_vowels_count
language: rb
prompt: "# Write a function vowels_count which takes a string representing\n# a word\
  \ as input and returns the number of vowels in the string.\n# Vowels in this case\
  \ are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n# vowel, but only when it is\
  \ at the end of the given word.\n# Example:\n# >>> vowels_count(\"abcde\")\n# 2\n\
  # >>> vowels_count(\"ACEDY\")\n# 3\ndef vowels_count(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_vowels_count\n\
  \    candidate = method(:vowels_count)\n    assert_equal(2, candidate.call(\"abcde\"\
  ))\n    assert_equal(3, candidate.call(\"Alone\"))\n    assert_equal(2, candidate.call(\"\
  key\"))\n    assert_equal(1, candidate.call(\"bye\"))\n    assert_equal(2, candidate.call(\"\
  keY\"))\n    assert_equal(1, candidate.call(\"bYe\"))\n    assert_equal(3, candidate.call(\"\
  ACEDY\"))\n  end\nend\n"
completions: ["  vowels = (\"a\",\"e\",\"i\",\"o\",\"u\",\"y\",\"A\",\"E\",\"I\",\"\
    O\",\"U\",\"Y\")\n  count = 0\n  s.each_char do |c|\n    count += 1 if vowels.include?(c)\n\
    \  end\n  count\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYou don't need `each_char`\
    \ here. Just `s.count(*vowels)`\n<|/ c |>\n<| a dscore=0 |>\nYou can use the count\
    \ method of String:\n<code>", "  return s.scan(/[aeiouy]+/).size\nend", "    vowels\
    \ = %w(a e i o u)\n    s.split('').inject(0) {|acc, x| acc + vowels.include?(x)\
    \ }\nend\n</cell>\n<code language=julia-0.5>\nvowels_count(\"acddee\")\n</cell>\n\
    <code language=julia-0.5>\nvowels_count(\"ACEDY\")\n</cell>\n<text>\nExercise:\
    \ Count how many times a substring occurs within a string\nUse the function substring\
    \ from Julia's String module to find the occurrences of substrings in the given\
    \ string.\nExample:\n    substring(\"aabcde\", \"b\") => 2\n    substring(\"aabcde\"\
    , \"a\") => 0\n    substring(\"aabcde\", \"c\") => 3\nHint: you may want to use\
    \ map, which applies a function to every element of an array.", "    count = 0\n\
    \    vowels = [:a, :e, :i, :o, :u]\n    s.downcase!\n    s.each_byte do |c|\n\
    \        if vowels.include?(c)\n            count += 1\n        end\n    end\n\
    \    return count\nend\n</cell>\n<code language=conda-root-py>", "  s.scan(/[aeiouAEIOU]/)\n\
    \  s.length\nend\n</cell>\n<code language=julia-1.0>", "  # initialize counter\n\
    \  count = 0\n  # iterate through the string, checking each character for vowels\n\
    \  for letter in s\n    if (letter == 'a' || letter == 'e' || letter == 'i' ||\
    \ letter == 'o' || letter == 'u')\n      count += 1\n  # return the count\n  return\
    \ count\nend\n</cell>\n<text>\nProblem 4", "    vowels = ('a', 'e', 'i', 'o',\
    \ 'u')\n    count = 0\n    for i in s\n        count += 1\n        if i not in\
    \ vowels\n            count += 1\n    return count", "  # +++your code here+++\n\
    \  vowels = \"aeiouAEIOU\"\n  count = 0\n  for i in s\n    if i =~ /[aeiou]/\n\
    \      count += 1\n    end\n  end\n  p count\nend\n</cell>\n<cell>", "    # Initialize\
    \ count\n    count=0\n    vowels=\"aeiouAEIOU\"", "  s.each_char do |c|\n    next\
    \ if c != c.upcase\n    vowels = %w(ae ii oo uu)\n    vowels.any? { |vowel| c.downcase\
    \ == vowel }\n  end\nend", "  vowel_count = 0\n  vowels_regex = /[aeiou]/\n  s.upcase\
    \ if vowels_regex.match s.length > 0\n  s.downcase if vowels_regex.match s.length\
    \ > 0\n  s.each_byte { |c| if c == 96 || c == 97 || c == 100 || c == 101 ||\n\
    \                   c == 102 || c == 103 || c == 104 || c == 105 || c == 106 ||\n\
    \                   c == 107 || c == 111 || c == 117 || c == 120 || c == 121 ||\n\
    \                   c == 122 || c == 123\n                   vowel_count = vowel_count\
    \ + 1\n                 end\n               }\n  vowel_count\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nYou guys are fast.  This is what a coworker had written earlier\
    \ today, and it worked!  Not sure why it didn't work earlier...  Anyways, I added\
    \ more to the function and updated the original post.  Thanks for your help.\n\
    <|/ c |>\n<| c |>\nOne thing that may be of use to you is that you can use the\
    \ `String` method [`match`](http://ruby-doc.org/core-2.2.0/String.html#method-i-match)\
    \ to determine if a given string matches a regexp. I see you were doing some sort\
    \ of similar thing with your `vowels_count` function.\n<|/ c |>\n<| c |>\nYeah,\
    \ I started learning about Ruby on Friday last night (it's 2am here now and I'm\
    \ tired of thinking so I went to lunch).  I'm very impressed with how much I can\
    \ do with Ruby, but I'm still struggling with some parts.  Thanks for your help,\
    \ I will keep plugging away.\n<|/ c |>\n<| a dscore=2 |>\nHere's my version:\n\
    <code>", "    vowels = \"aeiouAEIOU\"\n    return s.scan(vowels).size\nend", " \
    \ count = 0\n  s.split('').each do |letter|\n    if letter == \"a\" || letter\
    \ == \"e\" || letter == \"i\" || letter == \"o\" || letter == \"u\" || letter\
    \ == \"y\"\n      count += 1\n    end\n  end\n  count\nend", "    vowel_count\
    \ = 0\n    vowels = \"aeiou\"\n    count = 0\n    s.each_char do |ch|\n      \
    \  count +=1\n        if vowels.include?(ch)\n            vowel_count +=1\n  \
    \      end\n    end\n    vowel_count\nend", "  count = 0\n  s.each_char do |c|\n\
    \    count += 1 if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n\
    \  end\n  count\nend", "  return s.scan(/[aeiou]y$/).count\nend\n</code>\n<|/\
    \ a |>\n<| c |>\n`vowels_count(\"ab\")` returns 0, not 1.\n<|/ c |>\n<| c |>\n\
    - That is exactly why I used `scan` instead of `match`.\n<|/ c |>\n<| c |>\nThe\
    \ question asks for the number of vowels, not the number of y characters in the\
    \ word.\n<|/ c |>\n<| c |>\n- Thanks, I'll make that change.\n<|/ c |>\n<| c |>\n\
    - Thanks for catching that issue. `scan` does indeed seem more appropriate for\
    \ this problem.\n<|/ c |>\n<| a dscore=1 |>\nHere's a slight variation of the\
    \ Ruby way:\n<code>", "    count = 0\n    s.split('').each do |char|\n       \
    \ if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u'\n\
    \            count += 1\n        end\n    end\n    return count\nend", "  # Write\
    \ your function here\n  count = 0\n  s.downcase!\n  s.split('')\n  s.each_index\
    \ do |i|\n    if (s[i] == 'a') or (s[i] == 'e') or (s[i] == 'i') or (s[i] == 'o')\
    \ or (s[i] == 'u')\n      count += 1\n    end\n  end\n  count\nend", "  s = s.downcase.gsub(/[aeiou]/,\
    \ '')\n  s.count('a') + s.count('e') + s.count('i') + s.count('o') + s.count('u')\n\
    end", "  s.upcase!\n  return s.count \"aeiouy\".count\nend", "    count = 0\n\
    \    s.downcase!\n    s.each_char {|c| break if c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u'; count = count + 1 }\n    return count\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis does count 'y' as a vowel too, but that's easily\
    \ fixed with a little extra logic.\n<|/ c |>\n<| c |>\nThanks Dave. This really\
    \ helped me understand and understand what was happening here. I just did it a\
    \ little different than the way you did, by replacing `s.each_char {|c| break\
    \ if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'; count = count +\
    \ 1 }` with `s.each_char {|c| if c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u'; count = count + 1 end; break unless (c == 'y' && s.length > 1)\
    \ }`\n<|/ c |>\n<| c |>\nBTW, `each_char` returns an Enumerator, not a String,\
    \ so you don't need to use `downcase!` on the string. `each_char` will already\
    \ be downcased for you.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "\tvowels = {'a','e','i','o','u'}\n\
    \treturn (vowels.size - (s.count('u') + s.count('o') + s.count('i') + s.count('e')))\n\
    </cell>\n<cell>", "  s.each_char do |ch|\n    if ch == 'a' || ch == 'e' || ch\
    \ == 'i' || ch == 'o' || ch == 'u'\n      return 1\n    end\n  end\n  0\nend",
  "  # Return the number of vowels\n  s.scan(/[aeiouy]+/)\nend", "    s.chars.each\
    \ do |char|\n        vowel_chars = ['a', 'e', 'i', 'o', 'u']\n        vowel_chars.each\
    \ do |vowel|\n            if char == vowel\n                vowel_chars.delete(vowel)\n\
    \            end\n        end\n    end\n    vowel_chars.length\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nYou could improve your answer by adding an explanation\
    \ of what you are doing and how your solution is different.\n<|/ c |>\n<| c |>\n\
    It's not better than mine. Yours does not handle \"y\" as a vowel. mine's does.\n\
    <|/ c |>\n<| a dscore=0 |>\nUse a hash for counting instances of vowels and use\
    \ the .each() method to iterate over each letter in the string.  \n<code>", " \
    \   vowels = \"aeiouAEIOU\"\n    vowels_count = 0\n    for i in 0...s.length\n\
    \        if vowels.include?(s[i]) then\n            vowels_count = vowels_count\
    \ + 1\n        end\n    end\n    return vowels_count\nend", "  s = s.downcase\n\
    \  vowels = %w[a e i o u]\n  return s.scan(vowels).size\nend", "  count = 0\n\
    \  s.each do |letter|\n    if letter == \"a\" || letter == \"e\" || letter ==\
    \ \"i\" || letter == \"o\" || letter == \"u\"\n      count += 1\n    end\n  end\n\
    \  count\nend\n</code></pre>\n<h2 id=\"python-practice\">Practice</h2>\n<p id=\"\
    python\">\n  Python is a popular programming language used for various purposes\n\
    \  including web development, data science, machine learning, cryptographic\n\
    \  computing, software engineering, gaming, mobile devices, and others. In\n \
    \ addition, Python has over 200 million lines of code to run all day. It\n  is\
    \ free and open-source and has several applications.\n</p>", "  count = 0\n  s.each_byte\
    \ do |letter|\n    letter = letter.upcase\n    if letter.eql?(\"A\") || letter.eql?(\"\
    E\") || letter.eql?(\"I\") || letter.eql?(\"O\") || letter.eql?(\"U\")\n     \
    \ count += 1\n    end\n  end\n  return count\nend\nputs vowels_count(\"ACEDY\"\
    )\nputs vowels_count(\"ACEDY\")\nputs vowels_count(\"ACEDY\")\nputs vowels_count(\"\
    ACEDY\")\nputs vowels_count(\"A\")", " \tcount = 0\n \tfor x in s\n\t\tif x ==\
    \ \"a\" or x == \"e\" or x == \"i\" or x == \"o\" or x == \"u\"\n\t\t\tcount +=\
    \ 1\n\treturn count\n\t", "  count = 0\n  s.each_char do |c|\n    count += 1 if\
    \ c == \"a\" || c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\"\n  end\n\
    \  count\nend\n</cell>\n<code language=julia-1.5>", "    vowel_count = 0\n   \
    \ s.split(\"\").each {|w|\n        if w.downcase == 'a' || w.downcase == 'e' ||\
    \ w.downcase == 'i' || w.downcase == 'o' || w.downcase == 'u'\n            vowel_count\
    \ += 1\n        end\n    }\n    vowel_count\nend", "  count = 0\n  vowels = \"\
    aeiouy\"\n  \n  s.each_char do |c|\n    if c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u' then\n      count += 1\n    end\n  end\n  \n  return count\n\
    end", "  s.count(\"a\").to_i + s.count(\"e\").to_i + s.count(\"i\").to_i + s.count(\"\
    o\").to_i + s.count(\"u\").to_i\nend", "  count = 0\n  s.upcase!\n  s.each_char\
    \ do |c|\n    case c\n    when 'a', 'e', 'i', 'o', 'u'\n      count += 1\n   \
    \ end\n  end\n  count\nend\n</code>\nThe last function will probably be the most\
    \ difficult to understand. Let\u2019s break it down by stepping through it. Let\u2019\
    s start with each_char:\n<code>\n\"abcde\".each_char do |c|\n  # This block will\
    \ iterate over the characters in 'abcde'\n  # and assign the value of the block\
    \ to c. So `c` will be `'a'` \n  # through to `'d'`\nend\n</code>\nThis is where\
    \ we start our understanding of what a for loop does. Notice that the return value\
    \ is simply the value that was returned from the block. Now, let\u2019s look at\
    \ each of the cases:\n<code>\n\"abcde\".each_char do |c|\n  # This is an example\
    \ of 'for' loop that assigns c the value \n  # returned by the block on each iteration\
    \ of the loop\n  case c\n  when 'a'\n    # This is an example of 'when' statement\
    \ that will run \n    # the block of code on the following value if the value\
    \ of\n    # the variable `c` is 'a'. \n    count += 1\n  end\nend\n</code>\nNow\
    \ we have an understanding of for loops, and we can easily rewrite our vowels_count\
    \ function to do the same thing, so let\u2019s do that:\n<code>", "  count = 0\n\
    \  s.each_char do |c|\n    count += 1 if c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u'\n  end\n  count\nend", "  count = 0\n  s.each_byte do |c|\n\
    \    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n      count\
    \ += 1\n    end\n  end\n  count\nend\nputs vowels_count(\"abcde\")\nputs vowels_count(\"\
    ACEDY\")", "  count = 0\n  for i in s.downcase\n    if i == 'a' || i == 'e' ||\
    \ i == 'i' || i == 'o' || i == 'u' || i == 'y'\n      count += 1\n    end\n  end\n\
    \  return count\nend", "  s.scan(/[aeiou]y/)\n  s.count('a')\nend\n</cell>\n<cell>",
  "    vowels = \"aeiou\"\n    count = 0\n    for i in s\n        if i !~ vowels\n\
    \            count = count+1\n        end\n    end\n    return count\nend", " \
    \   count = 0\n    for character in s\n        if character == 'a'\n         \
    \   count += 1\n        if character == 'e'\n            count += 1\n        if\
    \ character == 'i'\n            count += 1\n        if character == 'o'\n    \
    \        count += 1\n        if character == 'u'\n            count += 1\n   \
    \         if character == 'y'\n                count += 1\n    return count\n\
    \    ", "  count = 0\n  vowels = ['a','e','i','o','u']\n  s.each_byte do |ch|\n\
    \    if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u'\n      count\
    \ += 1\n    end\n  end\n  return count\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThanks. I tried the method as suggested but for some reason I couldn't get\
    \ it to work (I guess my ruby is rusty). Anyway, I figured out a workaround for\
    \ this; see my answer :)\n<|/ c |>\n<| c |>\nOh yeah... thats cool. By the way,\
    \ how did you know to use `each_byte`? Is it documented somewhere?\n<|/ c |>\n\
    <| c |>\nI used it just to check the character in each byte, but I guess that\
    \ was silly. :)\n<|/ c |>\n<| c |>\nyeah! It was a problem when I was learning\
    \ ruby. But I learned it from here: http://stackoverflow.com/questions/6748699/how-to-get-a-character-in-a-byte-array\n\
    <|/ c |>\n<| c |>\nAnd I found another good source that also gives you the character\
    \ from each byte. http://ruby-doc.org/core-2.1.5/String.html#method-i-byte\n<|/\
    \ c |>\n<| a tags=ruby,string,count |>\nHere's my answer to this, which works\
    \ with multiple vowels\n<code>", "  count = 0\n  vowels = ['a','e','i','o','u']\n\
    \  s.scan(/[aeiou]/)\n  s.each_index do |index|\n    if s[index] =~ /[aeiouy]/\n\
    \      count += 1\n    end\n  end\n  count\nend", "  # Your code here\n  s = s.downcase\n\
    \  count = 0\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  s.each_char{|c|\
    \ vowels.include?(c)}\n  count\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", "  count=0\n\
    \  for i in s\n    count += 1 if i == \"a\" || i == \"e\" || i == \"i\" || i ==\
    \ \"o\" || i == \"u\"\n  end\n  return count\nend", "  # The return value will\
    \ be stored in the \"count\" variable\n  count = 0\n  \n  # The \"a\" array is\
    \ pre-allocated to save a little space\n  # (but don't worry, the size of the\
    \ array will vary from \n  # input string to input string).\n  a = [*0..25]\n\
    \  \n  # Iterate through each character in the string\n  # and increment the corresponding\
    \ value in the \"a\" array.\n  # Note that the \"i\" variable is 0-based, so the\
    \ first character is \n  # at position 0, \"i\" is 1, and so on.\n  (0...s.length).each\
    \ do |i|\n    char = s.at(i)\n    \n    # If the character is a vowel, increment\
    \ the corresponding value in \n    # the array \"a\".\n    if char.upcase == \"\
    A\"\n      count += 1\n    elsif char.upcase == \"E\"\n      count += 1\n    elsif\
    \ char.upcase == \"I\"\n      count += 1\n    elsif char.upcase == \"O\"\n   \
    \   count += 1\n    elsif char.upcase == \"U\"\n      count += 1\n    else\n \
    \     count += 1\n    end\n  end", "  s.chars.grep(/[aeiouAEIOU]/).size\nend",
  "    vowels = %w(aa ee ii oo uu)\n    vowels.each do |vowel|\n        if s[0,vowel.length]\
    \ == vowel\n            return s[0,vowel.length].count(\"a\")\n        end\n \
    \   end\n    0\nend\n</code>\n<|/ a tags=algorithm,ruby,ruby-on-rails |>\n<| a\
    \ |>\nTry this code:\n<code>\nrequire 'set'", "  s.chars.map { |c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u' }.count\nend", "    vowels = %w(a\
    \ e i o u)\n    s.each_char do |c|\n        if vowels.include?(c.downcase) &&\
    \ c[-1] == \"y\"\n            vowels.delete(c)\n        end\n    end\n    vowels.size\n\
    end\n</cell>\n<cell>\nvowels_count(\"abcde\")\n</cell>\n<cell>\nvowels_count(\"\
    ACEDY\")\n</cell>\n<cell>\n%q|vowels_count(\"BETA\")\nvowels_count(\"BETA\")|\n\
    </cell>\n<text>\nStrings as Lists\nStrings in Ruby are immutable. There is no\
    \ way to change the contents of a string without creating a new string object\
    \ that will contain exactly the same characters.", "  count = 0\n  s.chars.each\
    \ do |c|\n    if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n  \
    \    count += 1\n    end\n  end\n  count\nend\n</cell>\n<cell>", "  s.scan(/[aeiouy]/).count\n\
    end", "  s.scan(/[aeiou]/)\n  vowels = s.scan(/[aeiouy]*/)\n  return vowels.count\n\
    end", "    count = 0\n    s.each_char do |c|\n        if c.downcase == \"a\" ||\
    \ c.downcase == \"e\" || c.downcase == \"i\" || c.downcase == \"o\" || c.downcase\
    \ == \"u\"\n            count += 1\n        end\n    end\n    return count\nend",
  "  s.split('').inject(0) do |memo, letter|\n    memo += letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u'\n  end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 tags=ruby,ruby-on-rails |>\nAnother way of doing\
    \ it.\n<code>\nword = \"hello\"", "  vowels = ('a', 'e', 'i', 'o', 'u')\n  count\
    \ = 0\n  for i in s do\n    count += 1\n    break if vowels.member?(i)\n  end\n\
    \  count\nend", "  vowels = %w[a e i o u]\n  vowels.each do |vowel|\n    if s[0,s.length-1]\
    \ == vowel\n      return true\n    end\n  end\n  return false\nend\n</cell>\n\
    <cell>", "  s.scan(/[aeiouy]/)\n  s.count {|x| x == 'y'}\nend\n</code>\nWe can\
    \ now implement the solution you've been given:\n<code>", "  vowel_count = 0\n\
    \  s.split(\"\")\n  s.each do |word|\n    vowel_count += 1 if word[/[aeiouy]+$/]\n\
    \  end\n  vowel_count\nend", "  count = 0\n  s.each do |char|\n    if char ==\
    \ 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u'\n      count\
    \ += 1\n    end\n  end\n  return count\nend", "    vowels = [\"a\", \"e\", \"\
    i\", \"o\", \"u\"]\n    vowel_count = 0\n    for i in s.downcase\n        if vowels.include?\
    \ i\n            vowel_count += 1\n        end\n    end\n    return vowel_count\n\
    end", "  # Return the number of vowels in the string\n  vowels = ''\n  vowel_count\
    \ = 0\n  for letter in s\n    vowels += letter\n    vowel_count += 1 if vowels.include?('a')\
    \ ||\n                   vowels.include?('e') ||\n                   vowels.include?('i')\
    \ ||\n                   vowels.include?('o') ||\n                   vowels.include?('u')\
    \ else\n  end\n  vowels_count\nend\n</cell>\n<cell>", "  s.count(\"aeiou\")\n\
    end\n</cell>\n<cell>", "    s.each_char do |c| \n        if c != 'y' && c != 'Y'\
    \ && c != 'y' && c != 'Y' && c != 'a' && c != 'A' && c != 'e' && c != 'E' && c\
    \ != 'i' && c != 'I' && c != 'o' && c != 'O' && c != 'u' && c != 'U' \n      \
    \  then return false\n        end \n    end\n    return true\nend", "  s = s.upcase\n\
    \  vowels.each do |letter|\n    s[letter] = letter == 'A'\n  end\n  s.count('a')\n\
    end", "  vowels = \"aeiouAEIOU\"\n  count = s.length - s.split.map(&:downcase).map(&:count).inject(:+)\n\
    \  vowels.count{|vowel| count & vowels.index(vowel)}\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI wrote an answer with my approach. I just want to point out that\
    \ your approach is wrong.\n<|/ c |>\n<| c |>\nI agree with you. I don't consider\
    \ it wrong, since I haven't done that type of thing before. I just wanted to give\
    \ the OP a starting point for thinking about how to implement a solution. :)\n\
    <|/ c |>\n<| c |>\nThis would not work in case of `\"aeiouy\"` which should be\
    \ counted as 1 as `y` is at end but `y` is not a vowel.\n<|/ c |>\n<| a dscore=0\
    \ |>\nOne more solution using regular expressions:\n<code>", "  s.upcase!\n  s.gsub!(/[aeiouy]/,\"\
    \")\n  s.gsub!(/[aeiouy]+/,\"y\")\n  s.scan(/[aeiouy]+/).count\nend", "    count\
    \ = 0\n    s.each_char do |c|\n        if c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u'\n            count += 1\n        end\n    end\n    return\
    \ count\nend\n</code>\n<|/ a tags=python,function,ruby |>\n<| c |>\nThanks but\
    \ I can't use each_char method. Can you suggest an alternative method?\n<|/ c\
    \ |>\n<| c |>\nIf you don't want to use `each_char` method then you still have\
    \ access to `each_char` method. Just replace it with some code you wrote which\
    \ does what `each_char` does. It's also very easy to rewrite `each_char` to loop\
    \ through `string` as in my answer with `index` and `end` variables.\n<|/ c |>\n\
    <| a dscore=0 tags=python,function,ruby |>\nI hope this helps you. \n<code>",
  "  s = s.split('')\n  vowel_count = 0\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  for\
    \ char in s\n    if char == vowels[vowel_count]\n      vowel_count += 1\n    elsif\
    \ char == 'y'\n      vowel_count += 1\n    end\n  end\n  return vowel_count\n\
    end", "  s.downcase!\n  s.gsub!(/[^aeiou]/, '')\n  s.gsub!(/[aeiouy]+$/, '')\n\
    \  s.count('aeiou')\nend\n</cell>\n<text>\nTask\nWrite a program that prompts\
    \ the user for two strings. The first string is the phrase to search and the second\
    \ string is the word or words that you would like to search for. If there is no\
    \ search word entered, the program will ask the user to enter a search word. You\
    \ can assume that the word is a valid English word.", "    count = 0\n    vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    letters = s.split(\"\")\n    letters.each\
    \ do |letter|\n        if vowels.include? letter\n            count = count +\
    \ 1\n        end\n    end\n    return count\nend", "    vowels = [\n        \"\
    a\", \n        \"e\", \n        \"i\", \n        \"o\", \n        \"u\", \n  \
    \      \"y\"\n    ]\n    count = 0\n    for i in s\n        if vowels.include?(i)\n\
    \            count += 1\n    end\n    return count\n</code>\n<|/ a tags=ruby,ruby-on-rails-4,ruby-on-rails\
    \ dscore=0 |>\n<| c |>\nThe original code would count the vowels in \"aAaA\" as\
    \ 3.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails-4,ruby-on-rails |>\nI assume you\
    \ are asking for the \"most efficient\" way.\nIt is not clear what the \"most\
    \ efficient\" way would be for you since you have a problem to solve, which is\
    \ an algorithmic problem and we do not know which way it is going to be implemented\
    \ in the future.\nAs an aside, Ruby is a dynamic language, it does not require\
    \ a specific implementation like C.  So, there is some room for efficiency in\
    \ any language.\nHere are two ways to solve the problem.\nOne way to solve the\
    \ problem would be to use a regular expression and match every letter.  This is\
    \ relatively straight forward, but only works for the specific case you specified\
    \ (vowels only).  \nThe second way would be to loop through every letter in the\
    \ string and increment a counter if the letter is vowel.  This is fairly straight\
    \ forward, but also quite inefficient in that you need to iterate through every\
    \ letter.\nThe first way could be implemented as follows:\n<code>", "  return\
    \ s.scan(/[aeiou]/)\nend", "  count = s.length\n  s.each do |char|\n    case char\n\
    \    when 'a'\n      count = count - 1\n    when 'e'\n      count = count - 1\n\
    \    when 'i'\n      count = count - 1\n    when 'o'\n      count = count - 1\n\
    \    when 'u'\n      count = count - 1\n    when 'y'\n      count = count + 1\n\
    \    end\n  end\n  return count\nend\n</pre>\n            </div>\n          </div>\n\
    \        </div>\n      </article>\n    </section>", "  s.scan(/[aeiou]/) do |vowel|\n\
    \    if vowel\n      s.scan(/[aeiouy]/)\n      vowels_count s\n    else\n    \
    \  vowel\n    end\n  end\nend", "  s.split('').each do |c|\n    if c == \"a\"\n\
    \      return 1\n    elsif c == \"e\"\n      return 1\n    elsif c == \"i\"\n\
    \      return 1\n    elsif c == \"o\"\n      return 1\n    elsif c == \"u\"\n\
    \      return 1\n    end\n  end\n  0\nend\n</code>\nYour main method is also really\
    \ simple:\n<code>", "    return s.scan(/[aeiou]/).size\nend", "    vowels = %w[a\
    \ e i o u]\n    vowels.each do |vowel|\n        if vowels.rindex(vowel) == s.length\
    \ - 1\n            s.count(vowel)\n        end\n    end\nend\n</code>\nIf you\
    \ run it now, the following will happen:\n<code>\nruby vowels_count.rb \n1\n2\n\
    3\n</code>\nIf you run the next set of code, it will not work:\n<code>\nruby vowels_count.rb\
    \ \n1\nTraceback (most recent call last):\n    1: from vowels_count.rb:1:in `<main>'\n\
    TypeError: can't convert Symbol into Integer\n</code>\nThis is because you are\
    \ calling a method with one argument, and Ruby only allows one argument to be\
    \ passed to the method.  If you look at the method definition again you will see\
    \ that it takes no arguments.\n<code>", "  return s.scan(/[aeiou]y/).length\n\
    end", "    count = 0\n    s.chars.each { |ch| ch = ch.upcase }\n    s << \"y\"\
    \ unless s[s.length-1].equal? \"y\"\n    s.each_byte { |b| break if b == 'a' ||\
    \ b == 'e' || b == 'i' || b == 'o' || b == 'u' }\n    count += s.count { |x| x\
    \ == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u' }\n    count\nend", " \
    \ s = s.downcase\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  count = 0\n\
    \  s.each_byte do |char|\n    char == \"a\" || char == \"e\" || char == \"i\"\
    \ || char == \"o\" || char == \"u\" ? (count += 1) : nil\n  end\n  count\nend",
  "  s = s.to_s.upcase\n  vowel_count = s.scan(/[aeiouy]/).count\n  s.count('y') ==\
    \ 0 && vowel_count > 0 ? vowel_count : 0\nend", "\tvowel_count = 0\n\ti = 0\n\t\
    while i < s.length\n\t\tif s.slice(i, i+1).downcase == \"a\"\n\t\t\tvowel_count\
    \ += 1\n\t\ti += 1\n\treturn vowel_count\n\t", "    vowels=\"aeiouAEIOU\"\n  \
    \  count=0\n    for word in s.split(//)\n        count += 1 if vowels.include?(word[-1])\
    \ else 0\n    end\n    return count\nend", "  count = 0\n  s.each_byte do |b|\n\
    \    if b >= \"a\" && b <= \"z\"\n      count += 1\n    end\n  end\n  return count\n\
    end\n</cell>\n<cell>", "    # Your code here\n    vowels = [\"a\",\"e\",\"i\"\
    ,\"o\",\"u\",\"y\"]\n    count = 0\n    for char in s:\n        if char in vowels:\n\
    \            count = count + 1\n    return count\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=python |>\nUsing a regular expression and counting the matches:\n<code>",
  "  count = 0\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  s.each_char do |c|\n\
    \    count += 1 if vowels.include?(c)\n  end\n  count\nend", "  count = 0\n  s.each\
    \ do |w|\n    if w.upcase == \"A\" || w.upcase == \"E\" || w.upcase == \"I\" ||\
    \ w.upcase == \"O\" || w.upcase == \"U\" || w.upcase == \"Y\"\n      count +=\
    \ 1\n    end\n  end\n  return count\nend\n</code>\nNow that you have your functions\
    \ working, you should look into writing a function for displaying the results.\
    \ Here's one that works for you (I recommend using tabs and newlines to make it\
    \ easier to read):\n<code>", "  s.scan(/[aeiou]/)\n  s.count('aeiou')\nend", " \
    \   # Your code here\n    # Return number of vowels\n    s.scan(/[aeiouy]+/).count\n\
    end\n</cell>\n<code language=julia-1.0>\nvowels_count(\"abcde\")\n</cell>\n<code\
    \ language=julia-1.0>\nvowels_count(\"ACEDY\")\n</cell>\n<code language=julia-1.0>",
  "  s.split.each_with_index.select {|x,i| x == 'a' || x == 'e' || x == 'i' || x ==\
    \ 'o' || x == 'u'}.size\nend", "  count = 0\n  s.downcase!\n  s.each_char do |c|\n\
    \    c =~ /[aeiou]/\n    count+=1 unless c == ?y\n  end\n  return count\nend",
  "  s.chars.each_with_object(Hash.new(0)) { |c,h| h[c] += 1 }\n  .delete_if { |_,v|\
    \ v <= 1 }\n  .size\nend", "  return s.count(\"aeiouy\")\nend", "  s.downcase!\n\
    \  s.gsub!(/[AEIOUY]$/, '') \n  s.split('').inject(0) {|sum, letter| sum + 1 if\
    \ letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter ==\
    \ 'u'}\nend", "  return s.scan(/[aeiouy]+/).count\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails |>\nYou don't need\
    \ regexp for this task, just use the String's indexOf method.\n<code>", "  # Initialize\
    \ vowels count to 0.\n  count = 0\n  \n  # Split the string into characters.\n\
    \  letters = Array.new\n  s.chars.each do |c|\n    letters << c\n  end", "   \
    \ vowels=\"aeiou\"\n    count=0\n    for i in s\n        if vowels.include?(i)\n\
    \            count+=1\n    end\n    return count\nend\n</code>\nThe second part\
    \ is similar. Below is a function that takes a string, and an optional parameter\
    \ denoting the number of words to print. A default value of 5 is used, meaning\
    \ print 5 words. If no argument is given, the function should return all words\
    \ in alphabetical order. In any case, the function should only print the first\
    \ 5 words in the list. A second parameter can be given to print only the first\
    \ n words in the list. Here's an example:\n<code>", "    vowels = [\"a\", \"e\"\
    , \"i\", \"o\", \"u\"]\n    count = 0\n    for letter in s\n        if letter\
    \ != vowels[-1]\n            count += 1\n    return count\n    ", "  count = 0\n\
    \  s.split('').each do |c|\n    count += 0 if c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u'\n  end\n  return count\nend", "    vowels_count = 0\n\
    \    \n    # Write code here\n    vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n \
    \   for letter in s:\n        if letter in vowels:\n            vowels_count +=\
    \ 1\n    \n    return vowels_count\n</cell>\n<cell>", "  s.split(\"\").each_with_index\
    \ { |c, i| if c == \"a\" || c == \"e\" || c == \"i\" || c == \"o\" || c == \"\
    u\" then\n    count += 1\n  end }\n  count\nend", "  vowel_count = 0\n  s.split(//).each\
    \ do |char|\n    if char == 'a'\n      vowel_count += 1\n    elsif char == 'e'\n\
    \      vowel_count += 1\n    elsif char == 'i'\n      vowel_count += 1\n    elsif\
    \ char == 'o'\n      vowel_count += 1\n    elsif char == 'u'\n      vowel_count\
    \ += 1\n    elsif char == 'y'\n      if vowel_count == 0\n        vowel_count\
    \ += 1\n      end\n    end\n  end\n  vowel_count\nend", "    vowels = ['a', 'e',\
    \ 'i', 'o', 'u']\n    count = 0\n    for i in s\n        if i in vowels\n    \
    \        count += 1\n    end\n    return count\n</code>\n<|/ a dscore=0 tags=ruby,string\
    \ |>\n<| a dscore=0 |>\nWe can use String#count\n<code>\nstr = 'a cat is on the'\n\
    puts str.count('a')", "  count = 0\n  s.chars.each do |c|\n    if c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u' then\n      count += 1\n    end\n\
    \  end\n  count\nend", "  count = 0\n  s.each_byte do |char|\n    if char == 'a'\n\
    \      count += 1\n    elsif char == 'e'\n      count += 1\n    elsif char ==\
    \ 'i'\n      count += 1\n    elsif char == 'o'\n      count += 1\n    elsif char\
    \ == 'u'\n      count += 1\n    elsif char == 'y'\n      count += 1\n    end\n\
    \  end\n  count\nend\n</cell>\n<cell>", "    count = 0\n    # Write your code\
    \ here\n    return count\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "    vowels\
    \ = \"aeiou\"\n    count = 0\n    for char in s\n        if char in vowels\n \
    \           count++\n    return count\n</code>\n<|/ a dscore=0 |>\n<| a |>\nMy\
    \ solution is as follows:", "  s = s.to_s\n  s.scan(/[aeiou]/)\n  s.count(\"y\"\
    )\nend\n</cell>\n<cell>", "  return s.split('').select {|c| (c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u') }.count\nend", "  s.scan(/[aeiou]/)\n\
    \  s.count(\"u\")\nend\n</code></pre>\n<p>Voila! Your vowels_count function is\
    \ now ready to be used.</p>\n<p>In case you were wondering, scan is a function\
    \ that scans a string\nfrom left to right. It also returns the string it scans.\
    \ So in the above\nexample, the function call would return the string \"ac\",\
    \ since scan was\ncalled on \"acde\".</p>\n<p>The second line of the function\
    \ just returns the count of the string\n\"u\", which tells us that \"u\" was found\
    \ in the string. In this case,\nthe function returns the value 3.</p>\n<h2>Exercise</h2>\n\
    <p>Write a function called count_vowels which takes a string as input and\nreturns\
    \ the number of vowels in the string.</p>\n<p>This exercise is really just for\
    \ you to gain practice writing Ruby\nfunctions, as you will learn the more advanced\
    \ ways to code functions\nonce you have finished this one.</p>\n<p>A couple things\
    \ to keep in mind while writing Ruby functions:</p>\n<ul>\n<li>Ruby functions\
    \ can only return a single value. If you want to\nreturn multiple values, you\
    \ have to use either an array or a hash.</li>\n<li>Ruby functions are written\
    \ using def followed by an argument\nlist. You can use any variable names you\
    \ want.</li>\n</ul>\n<h2>Practice problems</h2>\n<ul>\n<li>Write a function that\
    \ takes a string and returns the string without any\nspaces. Example: <code>\"\
    hello world\".withoutSpaces</code> should return\n<code>helloworld</code></li>\n\
    <li>Write a function that takes a string as input and returns the first\nand last\
    \ word. Example: <code>\"hello world\".firstWord</code> should return\n<code>hello</code></li>\n\
    <li>Write a function that takes a string as input and returns the last\nand first\
    \ word. Example: <code>\"hello world\".lastWord</code> should return\n<code>world</code></li>\n\
    </ul>\n<h2>Problem 2</h2>\n<p>Write a function called \"is_palindrome\" which\
    \ takes a single string\nas input and returns true if the string is a palindrome\
    \ (meaning the\nsame forwards and backwards).</p>\n<p>In other words, if you have\
    \ <code>\"madam\"</code>, the function\nwill return true, since <code>\"madam\
    \ am adam\"</code> is a palindrome.</p>\n<p><code>is_palindrome</code> should\
    \ return the string <code>true</code> or <code>false</code>.</p>\n<p>A palindrome\
    \ is a word that reads the same backward as\nforward.</p>\n<h2>Exercise</h2>\n\
    <p>Write a function called \"is_palindrome\" which takes a single string\nas input\
    \ and returns true if the string is a p", "  s = s.downcase\n  s.scan(/[aeiou]/)\n\
    \  s.count('y')\nend\n</cell>\n<cell>", "    vowel_array = [\"a\",\"e\",\"i\"\
    ,\"o\",\"u\"]\n    vowel_array.each { |vowel| s.gsub!(vowel,\"\") }\n    vowel_count\
    \ = s.count(\"a\")\n    vowel_count += s.count(\"e\")\n    vowel_count += s.count(\"\
    i\")\n    vowel_count += s.count(\"o\")\n    vowel_count += s.count(\"u\")\n \
    \   vowel_count += s.count(\"y\")\n    return vowel_count\nend\n</code>\nAnd it\
    \ works!\n<|/ a |>\n<| c |>\nThis does not work properly.  \"A\"+\"B\" = \"AB\"\
    .  Try this with \"A\"+\"Z\" = \"AA\".\n<|/ c |>\n<| c |>\nI changed my code to\
    \ replace all occurrences of the vowels with an empty string and count the number\
    \ of vowels in that.\n<|/ c |>\n<| a dscore=0 |>\nIn a word, I believe the following\
    \ code will be faster than the accepted solutions (in Ruby, at least):\n<code>",
  "  count = 0\n  for i in s\n    if i == ?\n      count += 1\n      end\n    end\n\
    \  end\n  return count\nend", "  s.scan(/[aeiou]/)\n  s.count(\"a\")\nend\n</cell>\n\
    <code language=julia-0.4>", "  s.downcase!\n  s.each_byte do |b|\n    if b ==\
    \ 97 || b == 65 || b == 48 || b == 59 || b == 76 || b == 78\n      count += 1\n\
    \    end\n  end\n  return count\nend\n</code>\nNow the function vowels_count has\
    \ been defined, we can use it in the following program:\n<code>", "  count = 0\n\
    \  s.upcase!\n  s.scan(/[aeiou]/) do |c|\n    count += 1 if c == :a\n    count\
    \ += 1 if c == :e\n    count += 1 if c == :i\n    count += 1 if c == :o\n    count\
    \ += 1 if c == :u\n  end\n  count\nend\n</cell>\n<cell>", "    s.split(\"\").each\
    \ do |word|\n        if word =~ /[aeiouy]+/\n            word.count(\"a\")\n \
    \       end\n    end\nend", "    # Write your code here\n    s.split(//).map {|x|\
    \ x=~/x/ ? x.upcase : x}.count(\"AEIOUY\")\nend", "  # BEGIN Question 4\n  s.gsub!(/[aeiou]y$/,'')\n\
    \  s.count(\"aeiou\")\n  # END Question 4\nend", "    s.each_char {|c| c !~ /[aeiou]/}\n\
    \    s.count('a') + s.count('e') + s.count('i') + s.count('o') + s.count('u')\
    \ + s.count('y')\nend", "  # Convert s to all lowercase letters. \n  s = s.downcase\n\
    \  # Remove all vowels.\n  s.gsub!(/[aeiouy]/, '')\n  return s.count('a')\nend\n\
    </cell>\n<code language=julia-1.0>", "  s = s.downcase\n  s.scan(/[aeiouy]+/)\n\
    \  s.count\nend\n</code>\nThis uses Ruby's String class methods:", "  s = s.upcase\n\
    \  s.scan(/[aeiouy]+/)\n  return s.count(\"y\")\nend", "  s.scan(/[aeiou]/)\n\
    \  s.count('a')\n  s.count('y')\n  s.count('o')\nend", "\tcount = 0\n\tfor i in\
    \ s.split(\"\")\n\t\tif i.upcase == \"A\" || i.upcase == \"E\" || i.upcase ==\
    \ \"I\" || i.upcase == \"O\" || i.upcase == \"U\"\n\t\t\tcount += 1\n\treturn\
    \ count\n\t", "  vowel_count = 0\n  s.each_byte do |c|\n    if c == a.byte\n \
    \     vowel_count += 1\n    elsif c == e.byte\n      vowel_count += 1\n    elsif\
    \ c == i.byte\n      vowel_count += 1\n    elsif c == o.byte\n      vowel_count\
    \ += 1\n    elsif c == u.byte\n      vowel_count += 1\n    end\n  end\n  vowel_count\n\
    end\n</code>\nThe above code should be able to be used in your program - I just\
    \ haven't tested it.\n<|/ a dscore=0 |>\n<| c |>\nYes, you're right I did have\
    \ that incorrectly written. I fixed the error but still get the same issue as\
    \ before. Thank you for the response though.\n<|/ c |>\n<| c |>\n, I've edited\
    \ my answer to correct some errors.\n<|/ c |>\n<| c |>\nThanks for the edit. Now\
    \ I'm getting the error \"undefined method `byte' for nil:NilClass\".\n<|/ c |>\n\
    <| c |>\n, sorry about that. `each_byte` didn't exist until Ruby 1.9. You should\
    \ probably replace it with `each_char`.\n<|/ c |>\n<| c |>\nYes, that fixed it.\
    \ I had just used the wrong method because I was using Ruby 1.8 before and couldn't\
    \ find any documentation on it. Your solution works perfectly.\n<|/ c |>\n<| a\
    \ dscore=0 tags=ruby |>\nSince you said you wanted a \"one liner\", here's one\
    \ that does it all in one line:\n<code>\nputs s.gsub(/[aeiouAEIOU]/,'').split.map(&:length).sum\n\
    </code>\n<|/ a |>\n<| c |>\nI like this solution. Thanks for the help.\n<|/ c\
    \ |>\n<| a tags=ruby |>\nI believe I have your problem resolved. \n<code>\n\"\
    This should be your string\"\n</code>\nAfter you run this, you will get a string\
    \ like this: \n<code>\n\"T\\0\\0\\0\\0 \\0\\0\\0\\0 \\0\\0\\0\\0 \\0\\0\\0\\0\
    \ \\0\\0\\0\\0 \\0\\0\\0\\0 \\0\\0\\0\\0 \\0\\0\\0\\0 \\0\\0\\0\\0 \\0\\0\\0\\\
    0 \\0\\0\\0\\0 \\0\\0\\0\\0 \\0\\0\\0\\0 \\0\\0\\0\\0 \\0\\0\\0\\0 \\0\\0\\0\\\
    0 \\0\\0\\0\\0 \\0\\0\\0\\0 \\0\\0\\0\\0 \\0\\0\\0\\0 \\0\\0\\0\\0 \\0\\0", " \
    \ s = s.downcase\n  s.gsub!(/[aeiou]/, '') # remove vowels\n  s.gsub!(/[ey]/i,\
    \ 'y') # remove 'ey'\n  s.gsub!(/[eiuo]/i, '') # remove 'eiuo'\n  s.gsub!(/[aeiou]/i,\
    \ '') # remove 'ieou'\n  s.count('aeiou')\nend\n</cell>\n<cell>", "  a = s.split('')\n\
    \  vowels_count = 0\n  for i in a\n    if i =='a'\n      vowels_count += 1\n \
    \   elsif i == 'e'\n      vowels_count += 1\n    elsif i == 'i'\n      vowels_count\
    \ += 1\n    elsif i == 'o'\n      vowels_count += 1\n    elsif i == 'u'\n    \
    \  vowels_count += 1\n      end\n  end\n  vowels_count\nend", "  # Initialize\
    \ the count of vowels to zero.\n  count = 0", "  s.split(\"\").map { |x| x = x.downcase\
    \ }.uniq.length\nend", "  count = 0\n  s.split(\"\").each do |letter|\n    count\
    \ += (letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\"\
    \ || letter == \"u\" ? 1 : 0)\n  end\n  count\nend", "  s = s.downcase\n  s.gsub!(/[aeiou]/i,\
    \ '') # Replace any vowel with nothing\n  vowels = s.scan(/[aeiouy]+/) # Count\
    \ any vowels in the string\n  vowels.inject(0) {|s, v| s + 1 if v == 'y' }\nend\n\
    </cell>\n<cell>", "    # Your code here\n    if s.length < 1\n        return 0\n\
    \    vowels = ['a', 'e', 'i', 'o', 'u']\n    vowels.each {|v| return s if v ==\
    \ s[s.length..-1]}.length\nend", "    s.scan(/[aeiouy]+/)\n    s.length\nend",
  "\tcount = 0\n\tfor i in s\n\t\tif i.downcase == 'a' or i.downcase == 'e' or i.downcase\
    \ == 'i' or i.downcase == 'o' or i.downcase == 'u' or i.downcase == 'y'\n\t\t\t\
    count += 1\n\treturn count", "    vowels = ['a','e','i','o','u']\n    count =\
    \ 0\n    \n    for char in s.downcase\n        if vowels.include?(char)\n    \
    \        count += 1\n        end\n    end\n    \n    return count\nend\n</code>\n\
    Now, we can easily call this function to find out how many vowels are in any given\
    \ string\n<code>", "  s = s.downcase\n  vowels = %w(a e i o u).select { |c| c\
    \ =~ /[aeiouy]/ }\n  vowels.inject(0) { |a, e| a + (s.index(e) != s.size - 1 ?\
    \ 1 : 0) }\nend\n</cell>\n<text>\n6.3 String#split\nThe String#split method splits\
    \ a string into an array. Each element of the array contains all the characters\
    \ in the string split on the given delimiter. In the example below, the delimiter\
    \ is /\\s+/, which splits the string at whitespace characters.", "    # Your code\
    \ here\n    s.each_char do |char|\n        if char.eql? 'a' || char.eql? 'e' ||\
    \ char.eql? 'i' || char.eql? 'o' || char.eql? 'u'\n            count += 1\n  \
    \      end\n    end\n    count\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<|\
    \ c |>\nPlease don't encourage people to put their homework assignments on the\
    \ internet. There are plenty of resources out there to learn Ruby from and answering\
    \ homework questions is only going to encourage people to copy and paste code\
    \ without really learning what is going on.\n<|/ c |>\n<| c |>\nThanks ! I didn't\
    \ know that .each_char was the function I was looking for, although I didn't know\
    \ it would be used like that.\n<|/ c |>\n<| a |>\n<code>\n\"hello\".downcase!\n\
    </code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nThis does not provide an answer\
    \ to the question. To critique or request clarification from an author, leave\
    \ a comment below their post. - [From Review](/review/low-quality-posts/11593763)\n\
    <|/ c |>\n<| c |>\nThis doesn't even attempt to answer the question, just provide\
    \ a more generic solution that can be applied to a larger problem domain. The\
    \ answer would still be \"Yes, this would work perfectly.\" However, I do appreciate\
    \ your review.\n<|/ c |>\n<| c |>\nI do appreciate your review and that you're\
    \ trying to help a beginner out. I tried to help you get answers here, but I guess\
    \ you couldn't get much help from other people. Honestly I still think this answer\
    \ is poorly phrased, which could explain why you got downvoted. I'm glad you got\
    \ your answer. :)\n<|/ c |>\n<| a |>\nI thought I'd add that it's better to use\
    \ the method downcase on strings instead of calling downcase! on them.\n<|/ a\
    \ dscore=0 tags=ruby |>\n<| a tags=ruby |>\n<code>", "  count = 0\n  s.each_byte\
    \ do |x|\n    if x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u'\n  \
    \    count += 1\n    end\n  end\n  count\nend", "  s.each_char.inject(0) {|total,\
    \ c| total + (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')}\nend",
  "  s.downcase! # Change all letters to lower-case\n  s.split(\"\").each do |c|\n\
    \    if c == \"a\"\n      a += 1\n    elsif c == \"e\"\n      e += 1\n    elsif\
    \ c == \"i\"\n      i += 1\n    elsif c == \"o\"\n      o += 1\n    elsif c ==\
    \ \"u\"\n      u += 1\n    elsif c == \"y\"\n      y += 1\n    end\n  end\n  return\
    \ a\nend\n</cell>\n<cell>\nassert vowels_count(\"aeiou\") == 1\nassert vowels_count(\"\
    a\") == 0\nassert vowels_count(\"AEIOU\") == 0\nassert vowels_count(\"axyz\")\
    \ == 0\n</cell>\n<cell>", "  s.scan(/[aeiou]/i)\n  s.count('a') + s.count('e')\
    \ + s.count('i') + s.count('o') + s.count('u') + s.count('y')\nend", "  return\
    \ s.gsub(/[aeiou]/).size #gsub replaces each match with a blank space\nend\n</cell>\n\
    <cell>", "\tvowels = %w[a e i o u]\n\ts.split(//).each do |x|\n\t\tvowels.each\
    \ do |v|\n\t\t\treturn 1 if x == v\n\t\tend\n\tend\n\treturn 0\nend", "  vowels\
    \ = ['a', 'e', 'i', 'o', 'u']\n  return s.split(' ').inject(0) { |t,c| t + (c.downcase.delete(*vowels).empty?\
    \ ? 0 : 1) }\nend\n</code>\nAnd voila:\n<code>\nirb(main):010:0> vowels_count(\"\
    A man said to the dog - 'hello'\")\n=> 2\n</code>\n<|/ a tags=ruby,regex |>\n\
    <| c |>\nAwesome explanation and nice solution!\n<|/ c |>\n<| a dscore=2 |>\n\
    I wanted to post another way, that avoids the splitting and count stuff\n<code>",
  "  s.downcase!\n  return s.scan(/[aeiou]/).inject(0) { |count, item| count + (item\
    \ == 'y')}\nend", "  s.count(\"a\").to_i + s.count(\"e\").to_i + s.count(\"i\"\
    ).to_i + s.count(\"o\").to_i + s.count(\"u\").to_i\nend", "  vowels = %w[a e i\
    \ o u]\n  s.gsub(/[aeiouy]+/).count { |vowel| vowels.include?(vowel) }\nend",
  "  s.downcase!\n  s.gsub!(/[^aeiouy]/,\"\")\n  return s.count(\"aeiouy\")\nend",
  "  count = 0\n  s.each do |letter|\n    letter == 'a' || letter == 'e' || letter\
    \ == 'i' || letter == 'o' || letter == 'u' ? count += 1\n  end\n  return count\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is nice but you are doing more\
    \ work than you should. `s.each` does a lot more than you might realize, and `count`\
    \ returns an `Integer`. In fact you shouldn't be using `each` at all.\n<|/ c |>\n\
    <| a tags=ruby |>\nYou could use scan to count the number of occurrences of each\
    \ vowel.\n<code>", "    vowels = \"aeiou\"\n    count = 0\n    i = 0\n    while\
    \ i < s.length\n        if vowels.include? s[i]\n            count += 1\n    \
    \        i += 1\n        end\n    end\n    return count\nend", "    return s.chars.count\
    \ {|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'}\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| a dscore=2 |>\nThis works\
    \ \n<code>", "  count = 0\n  s.downcase!\n  vowels = %w(a e i o u)\n  s.scan(/[aeiou]y/)\
    \ do\n    count += 1 if $~\n  end\n  return count\nend", "\ts.chars.each { |letter|\
    \ return letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter\
    \ == 'u' }\nend", "    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}\n    count\
    \ = 0\n    for char in s\n        if char in vowels\n            count += 1\n\
    \    return count", "    vowels = ('a', 'e', 'i', 'o', 'u', 'y')\n    vowel_count\
    \ = 0\n    for char in s\n        if vowels.include? char\n            vowel_count\
    \ += 1\n        elsif char == 'y'\n            vowel_count += 1\n            vowel_count\
    \ += 1 if s[s.length-1] == 'y'\n        end\n    end\n    vowel_count\nend\n</cell>\n\
    <code language=julia-1.5>", "    vowels = %w{a e i o u}\n    s.each_byte.map {\
    \ |b| vowels.include?(b) ? 1 : 0 }.sum\nend\n</cell>\n<code language=julia-0.5>",
  "    s.split('').map(&:downcase).map {|char| char.match(/[aeiou]/) ? 1 : 0}\nend",
  "  letters = Array.new\n  for i in 0..s.length\n    if s[i]==\"a\"\n      letters.push\
    \ \"a\"\n    elsif s[i]==\"e\"\n      letters.push \"e\"\n    elsif s[i]==\"i\"\
    \n      letters.push \"i\"\n    elsif s[i]==\"o\"\n      letters.push \"o\"\n\
    \    elsif s[i]==\"u\"\n      letters.push \"u\"\n    else\n      letters.push\
    \ \"y\"\n    end\n  end\n  letters.count\nend\n</code>\n<|/ a |>\n<| c |>\n`'y'.include?(s[i])\
    \ ?\n<|/ c |>\n<| c |>\n, thanks for letting me know that! I changed `vowels_count(s)`\
    \ to `vowels_count(s.upcase)` because `vowels_count(s)` would count `y` as a vowel.\n\
    <|/ c |>\n<| c |>\nThat's probably a good idea, but you can do `vowels = %w(ae\
    \ i o u)`.\n<|/ c |>\n<| c |>\n, I'm still fairly new to the Ruby language, so\
    \ I'm not sure if there's an advantage to using your method, but I'm going to\
    \ have to research that. Thanks!\n<|/ c |>\n<| c |>\n, I've researched Ruby enumerable\
    \ methods now a lot and have found that `vowels = %w(ae i o u)` has become a prevalent\
    \ method on String objects in recent versions of Ruby. I think it's more efficient\
    \ and easier to read. Also, I'm fairly new to Ruby myself, and I still want to\
    \ learn how to do things the Ruby-way. :)\n<|/ c |>\n<| a |>\nHere's another one,\
    \ using regular expressions.\n<code>", "  s = s.downcase\n  s.count(\"aeiouy\"\
    )\nend\n</cell>\n<cell>", "  # Your code here\n  vowel_count = 0\n  vowels = \"\
    aeiou\"\n  s.downcase!\n  s = s.tr(\"AEIOUaeiouAEIOU\", \"\").strip.downcase\n\
    \  s.each_byte do |c|\n    if vowels.include?(c)\n      vowel_count += 1\n   \
    \ end\n  end\n  return vowel_count\nend\n</code>\nIn your case, you need to modify\
    \ your code as follows:\n<code>", "    count = 0\n    vowels = %w[a e i o u]\n\
    \    s.split(\"\").each do |i|\n        count += 1 if i.downcase == i.upcase and\
    \ vowels.include?(i)\n    end\n    return count\nend", "  a = s.chars\n  vowels\
    \ = []\n  vowels << a[0] if a.length>0 && a[0]=='a'\n  vowels << a[1] if a.length>1\
    \ && a[1]=='a'\n  vowels << a[2] if a.length>2 && a[2]=='a'\n  vowels << a[3]\
    \ if a.length>3 && a[3]=='a'\n  vowels << a[4] if a.length>4 && a[4]=='a'\n  vowels\
    \ << a[5] if a.length>5 && a[5]=='a'\n  vowels << a[6] if a.length>6 && a[6]=='a'\n\
    \  vowels << a[7] if a.length>7 && a[7]=='a'\n  vowels << a[8] if a.length>8 &&\
    \ a[8]=='a'\n  vowels << a[9] if a.length>9 && a[9]=='a'\n  vowels << a[10] if\
    \ a.length>10 && a[10]=='a'\n  vowels << a[11] if a.length>11 && a[11]=='a'\n\
    \  vowels << a[12] if a.length>12 && a[12]=='a'\n  vowels << a[13] if a.length>13\
    \ && a[13]=='a'\n  vowels << a[14] if a.length>14 && a[14]=='a'\n  vowels << a[15]\
    \ if a.length>15 && a[15]=='a'\n  vowels << a[16] if a.length>16 && a[16]=='a'\n\
    \  vowels << a[17] if a.length>17 && a[17]=='a'\n  vowels << a[18] if a.length>18\
    \ && a[18]=='a'\n  vowels << a[19] if a.length>19 && a[19]=='a'\n  vowels << a[20]\
    \ if a.length>20 && a[20]=='a'\n  vowels << a[21] if a.length>21 && a[21]=='a'\n\
    \  vowels << a[22] if a.length>22 && a[22]=='a'\n  vowels << a[23] if a.length>23\
    \ && a[23]=='a'\n  vowels << a[24] if a.length>24 && a[24]=='a'\n  vowels << a[25]\
    \ if a.length>25 && a[25]=='a'\n  vowels << a[26] if a.length>26 && a[26]=='a'\n\
    \  vowels << a[27] if a.length>27 && a[27]=='a'\n  vowels << a[28] if a.length>28\
    \ && a[", "  vowels = \"aeiou\"\n  count = 0\n  s.downcase!\n  s.split(\"\").each\
    \ do |c|\n    vowels.include?(c) ? count += 1: next\n  end\n  count\nend\n</code>\n\
    Output:\n<code>\n[ruby-2.6.3]$ ruby vowels_count.rb\n2\n3\n</code>\n<|/ a |>\n\
    <| a |>\nA simple solution using String.split. \n<code>", "  vowels = ['a', 'e',\
    \ 'i', 'o', 'u']\n  count = 0\n  s.split(\"\").each do |char|\n    vowels.each\
    \ do |v|\n      if char == v\n        count += 1\n        break if count == 3\n\
    \      end\n    end\n  end\n  count\nend", "\ts.each do |c|\n\t\t%w{aeiou}.include?(c)\
    \ ? true : false\n\tend\nend", "    count = 0\n    vowels = \"aeiouAEIOU\"\n \
    \   for i in s\n        if i in vowels\n            count = count + 1\n    end\n\
    \    count\nend\n</code>\nOutput:\n<code>\nvowels_count(\"abcde\")\n=> 2\nvowels_count(\"\
    ACEDY\")\n=> 3\n</code>\n<|/ a |>\n<| a |>\nJust use count function.\n<code>",
  "    vowel_count = Hash.new(0)\n    vowel_count += 1 if s.include?(\"a\") || s.include?(\"\
    e\") || s.include?(\"i\") || s.include?(\"o\") || s.include?(\"u\") \n    vowel_count\
    \ += 1 if s.include?(\"y\") || s.include?(\"Y\")\n    return vowel_count\nend\n\
    </cell>\n<code language=julia-1.0>", "    words=s.split(\" \")\n    count=0\n\
    \    words.each do |word|\n      if word.count(\"a\") + word.count(\"e\") + word.count(\"\
    i\")+ word.count(\"o\")+ word.count(\"u\") > 0 then\n        count=count+1\n \
    \     end\n    end\n    return count\nend", "  s = s.downcase\n  s.gsub!('aeiou','')\n\
    \  s.count('aeiou')\nend", "  s = s.downcase\n  s.gsub!(\"[aeiouy]\",\"\")\n \
    \ s.count(\"a\")\nend", "    s = s.upcase\n    s.downcase!\n    s.scan(/[aeiouy]$/)\n\
    \    return s.size\nend", "    vowels = %w(a e i o u)\n    s.each { |x| vowels.include?(x)\
    \ }.length\nend\n</cell>\n<text>\nExercise: Write a method count_letters which\
    \ takes a string and returns the number of times each character occurs in the\
    \ string. For example:\n>>> count_letters(\"abracadabra\")\n{\"a\"=>3, \"r\"=>2,\
    \ \"b\"=>2, \"c\"=>1, \"d\"=>2, \"r\"=>1}", "  s.chars.each_with_object(0).sum\
    \ { |c,n| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' && (c == 'y'\
    \ || c == s[s.length]) }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis does\
    \ not count consecutive vowels. For example, `\"ABCD\"` should return 1, not 2.\n\
    <|/ c |>\n<| c |>\nGood catch, I didn't notice that. I'll fix the answer shortly.\
    \ Thanks!\n<|/ c |>\n<| a tags=ruby |>\nA simple solution:\n<code>", "  vowels\
    \ = %w(a e i o u)\n  s.each_char.with_index.inject(0) do |total, (char, index)|\n\
    \    total + 1 if vowels.include?(char) && index % 2 == 0\n  end\nend", " \n \
    \ count = 0\n \n  if s.length == 0\n    return 0\n  \n  for i in 0...s.length-1\n\
    \    if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\
    \ || s[i] == 'y' || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' ||\
    \ s[i] == 'U' || s[i] == 'Y' || s[i] == 'y'\n      count += 1\n  end\n \n  return\
    \ count\nend", "  return s.split(' ').inject(0) {|sum, n| sum+n.count('a') + n.count('e')\
    \ + n.count('i') + n.count('o') + n.count('u') }\nend", "  count = 0\n  s.each_char\
    \ do |char|\n    count += 1 if char == 'a' || char == 'e' || char == 'i' || char\
    \ == 'o' || char == 'u'\n  end\n  return count\nend\n</cell>\n<cell>\nvowels_count(\"\
    acbdE\")\n</cell>\n<cell>", "  s.downcase!\n  s.upcase!\n  vowels = \"aeiou\"\n\
    \  s.gsub!(/[aeiouy]+/, \"\")\n  if s =~ /[^aeiouy]/\n    puts \"Invalid input\"\
    \n  else\n    count = 0\n    s.each_char { |c| count += 1 if vowels.include?(c)\
    \ }\n    puts \"#{count} vowels\"\n  end\nend", "  s.split('').select{|i| i ==\
    \ 'a' || i == 'e' || i == 'i' || i == 'o' || i == 'u'}.size\nend", "  s.downcase!\n\
    \  count = 0\n  s.scan(/[aeiou]/)\n  s.each_index do |i|\n    if s[i] == 'a' or\
    \ s[i] == 'e' or s[i] == 'i' or s[i] == 'o' or s[i] == 'u'\n      count += 1\n\
    \    end\n  end\n  count\nend\n</cell>\n<cell>", "    s.to_s.tr(\" aeiou\", \"\
    \").size\nend", "    count = 0\n    s.each_char do |c|\n        if c == a.to_s\n\
    \            count += 1\n        elsif c == e.to_s\n            count += 1\n \
    \       elsif c == i.to_s\n            count += 1\n        elsif c == o.to_s\n\
    \            count += 1\n        elsif c == u.to_s\n            count += 1\n \
    \       end\n    end\n    return count\nend", "  s.scan(/[aeiou]/i)\nend", " \
    \ s.split(//).reduce(0,:merge).scan(/[aeiou]/).count\nend", "  vowels = ['a',\
    \ 'e', 'i', 'o', 'u', 'y']\n  s.each_char{|c| vowels.include?(c)} ? s.count('a')\
    \ + s.count('e') + s.count('i') + s.count('o') + s.count('u') : nil\nend", " \
    \ count = s.downcase.count(\"aeiou\")\n  if s.endwith?(\"y\")\n    count += 1\n\
    \  end\n  count\nend\n</cell>\n<cell>", "  s = s.downcase\n  s.scan(/[aeiouy]/).count\n\
    end", "  return s.chars.map(&:upcase).count { |c| c == 'A' || c == 'E' || c ==\
    \ 'I' || c == 'O' || c == 'U' }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c\
    \ |>\nWhy not just `s.chars.map(&:upcase).count { |c| c == 'A' || c == 'E' ||\
    \ c == 'I' || c == 'O' || c == 'U' }` ?\n<|/ c |>\n<| c |>\nGood catch. I've updated\
    \ the answer. Thanks.\n<|/ c |>\n<| c |>\nI would suggest using `\"A\".ord < \"\
    E\".ord`, in case your locale uses different letters than English\n<|/ c |>\n\
    <| c |>\n, good point. I didn't think of that. I think I'll change it.\n<|/ c\
    \ |>\n<| a dscore=2 |>\n<code>", "  s.split.count {|x| x == 'a' || x == 'e' ||\
    \ x == 'i' || x == 'o' || x == 'u' }\nend", "  return s.chars.count {|c| c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'}\nend", "\ts.downcase!\n\
    \ts.each_char do |c|\n\t\tif (c=='a' || c=='e' || c=='i' || c=='o' || c=='u')\n\
    \t\t   return true\n\t\tend\n\tend\n\treturn 0\nend", "    # your code here\n\
    \    vowels = [\"a\",\"e\",\"i\",\"o\",\"u\",\"y\"]\n    count = 0\n    count2\
    \ = s.count(\"y\")\n    for c in s:\n        if c in vowels:\n            count\
    \ += 1\n    if count2 > count:\n        return count2\n    return count", "  #\
    \ Remove spaces\n  s = nil\n  s = s.split(//)\n  vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n  vowel_count = 0\n  s.each do |w|\n    vowel_count += 1 if vowels.include?(w.slice[0,\
    \ 2])\n  end\n  vowel_count\nend\n</code>\n<|/ a |>\n<| a tags=ruby dscore=2 |>\n\
    <code>", "  # Write your code here\n  count = 0\n  s.each_char {|c| c =~ /[aeiou]/i\
    \ ? count += 1}\n  return count\nend\n</cell>\n<cell>\nvowels_count(\"aabbccddeeefff\"\
    )\n</cell>\n<cell>\nvowels_count(\"abcd\")\n</cell>\n<cell>", "    return s.count(\"\
    aeiouy\")\n</cell>\n<cell>", "  count = 0\n  s.scan(/[aeiou]/) do |vowel|\n  \
    \  count = count + 1\n  end\n  return count\nend\n</cell>\n<cell>", "  return\
    \ s.count('a') + s.count('e') - s.count('i') + s.count('o') - s.count('u')\nend\n\
    </code>\n<|/ a |>\n<| a dscore=3 |>\nThe most efficient solution to count vowels\
    \ in a string is probably using regex:\n<code>", "  s.chars.each_with_object(0).select\
    \ { |c,n| c == \"a\" || c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\" &&\
    \ n }.length\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
