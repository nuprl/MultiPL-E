name: HumanEval_34_unique
language: rb
prompt: "# Return sorted unique elements in a list\n# >>> unique([5, 3, 5, 2, 3, 3,\
  \ 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\ndef unique(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique\n\
  \    candidate = method(:unique)\n    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5,\
  \ 3, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"
completions: ["  result = []\n  for i in l\n    if ! result.include?(i)\n      result\
    \ << i\n    end\n  end\n  result\nend", "\tl.sort!\n\tl.reverse!\n\tl.uniq!\n\t\
    l.reverse\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq` is very slow for large\
    \ lists. `to_set` can be replaced with `Hash` with `uniq!` `to_set.reverse - Hash.to_set`\n\
    <|/ c |>\n<| c |>\nFor a large list, `uniq!` can be replaced with `sort_by { rand\
    \ }.uniq!`\n<|/ c |>\n<| c |>\nAwesome stuff! I'd never have thought about using\
    \ `uniq!`. Very useful for sorting and filtering a large array before sorting\
    \ and using uniq on the result like this. Thanks!\n<|/ c |>\n<| c |>\nYeah, \"\
    uniq!\" is very slow for large lists. \"to_set\" can be replaced with \"Hash\"\
    \ with \"uniq!\" `to_set.reverse - Hash.to_set`\n<|/ c |>\n<| a tags=ruby,sorting,unique\
    \ dscore=4 |>\nA quick way to keep unique items is:\n<code>\nitems.each { |i|\
    \ items << i unless items.include?(i) }\n</code>\n<|/ a |>\n<| c |>\nThis solution\
    \ is very slow for large arrays.\n<|/ c |>\n<| a |>\n<code>\nlist.uniq.sort!\n\
    </code>\n<|/ a dscore=4 tags=ruby,sorting,unique |>\n<| c |>\nDoesn't work if\
    \ you need to sort the list first. You'll get the same order as before - it's\
    \ not unique.\n<|/ c |>\n<| c |>\n: Not really. It depends on the sorting rules.\
    \ If you sort the list then use uniq, it removes the duplicates.\n<|/ c |>\n<|\
    \ a dscore=3 tags=ruby,sorting,unique |>\n<code>\n[10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10].uniq.sort\n</code>\n<|/ a |>\n<| c |>\nDoesn't work if you\
    \ need to sort the list first. You'll get the same order as before - it's not\
    \ unique.\n<|/ c |>\n<| a tags=ruby,sorting,unique |>\nTo sort the array before\
    \ getting unique values:\n<code>\n[10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10].sort_by.with_index\
    \ {|e,i| e}.uniq.sort\n</code>\n<|/ a dscore=2 |>\n<| c |>\nDoesn't work if you\
    \ need to sort the ", "  l.uniq\nend", "  l.uniq!\nend", "    seen = Set()\n \
    \   return l - seen\nend", "  l.sort!\n  l.reverse!\n  l[1..-1]\nend", "  l.uniq!\n\
    \  l\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nYou can use Array#uniq\
    \ to remove duplicates from a array:\n<code>\na = [1, 2, 3, 3, 5, 6, 6, 7]\na.uniq ",
  "  return l.uniq\nend", "  ret = []\n  l.each do |val|\n    if ret.index(val) ==\
    \ 0\n      ret << val\n    end\n  end\n  ret\nend", "  return l.uniq { |x| l.index(x)\
    \ }\nend", "  seen = {}\n  ret = []\n  l.each do |item|\n    if seen[item]\n \
    \     ret\n    else\n      seen[item] = true\n      ret << item\n    end\n  end\n\
    \  ret\nend", "  l.uniq.sort!\n  l\nend", "\tuniq = Hash.new(:value => l)\n\t\
    Hash.new(:value => l.uniq)\nend", "    seen = Set.new\n    l.uniq(&:itself).map{\
    \ |x| seen.add(x) if seen.include?(x) }\nend\n</code>\nThe main difference from\
    \ uniq is that it does not remove duplicates.\n<|/ a dscore=0 |>\n<| c |>\nWhile\
    \ this link may answer the question, it is better to include the essential parts\
    \ of the answer here and provide the link for reference.  Link-only answers can\
    \ become invalid if the linked page changes.\n<|/ c |>\n<| c |>\nI agree. I'll\
    \ keep this answer up as a possible solution for future reference.\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails |>\nYou can use Enumerable#partition and then flatten\
    \ the two resulting arrays. \n<code>\narray = [10, 20, 30, 30, 30, 40, 50, 60,\
    \ 60, 60]", "  uniq = Set.new\n  l.each do |item|\n    uniq.add(item) if uniq.include?(item)\
    \ == false\n  end\n  uniq\nend", "  l.sort.uniq\nend", "  l = l.uniq unless l.nil?\
    \ or l.is_a?(Set)\n  l\nend", "  r = []\n  seen = {}\n  l.each do |x|\n    if\
    \ seen[x] == true\n      next\n    elsif seen[x]\n      r << x\n    else\n   \
    \   seen[x] = true\n    end\n  end\n  return r\nend", "  l.sort!\n  l.reverse!\n\
    \  l = l.uniq!\n  l.reverse!\n  l\nend\n</code>\n<|/ a tags=sorting,ruby |>\n\
    <| c |>\nThis doesn't take advantage of the fact that order is important.\n<|/\
    \ c |>\n<| a dscore=1 tags=sorting,ruby |>\n<code>", "  l.sort!\n  l.reverse!\n\
    \  l\nend", "  l.uniq!\n  l\nend", "  uniq = Array.new(l.size)\n  uniq.update(l)\n\
    \  uniq.sort!\n  uniq\nend", "  l.uniq.sort\nend\n</code>\n<|/ a |>\n<| a |>\n\
    Ruby has a good built-in library called Set that is good for working with sets\
    \ of unique elements. It also provides methods such as uniq, uniq_if, sort, and\
    \ many more. See the Set documentation\n<|/ a tags=ruby dscore=4 |>\n<| a tags=ruby\
    \ |>\nThe uniq_by method returns an array with unique elements:\n<code>\n[1,2,2,1,2].uniq_by\
    \ { |x| x }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThe order is not guaranteed\
    \ unless you use the `:sort` option, but if you're using `uniq_by` then `uniq`\
    \ would do that for you anyway. See: http://ruby-doc.org/core-2.2.1/Array.html#method-i-uniq_by\n\
    <|/ c |>\n<| a |>\n<code>\n[1,2,3,5].uniq # => [1, 2, 3, 5]\n</code>\nFor a more\
    \ complex situation where you don't care about the order of the duplicates:\n\
    <code>\n[1,2,2,1,2].uniq { |n| [n, n.to_s.reverse].sort.uniq.first }", "  sorted\
    \ = l.sort\n  first = sorted.first\n  last  = sorted.last\n  (first != last) ?\
    \ sorted.uniq : sorted\nend", "  u = {}\n  for i in l do u[i] = true end\n  return\
    \ l.sort.uniq\nend\n</code>\n<|/ a tags=hash,ruby,arrays,algorithm,comparison\
    \ |>\n<| a dscore=0 |>\nThis can be done in O(NlogN) using merge sort. Here is\
    \ a link to merge sort\nhttps://www.geeksforgeeks.org/merge-sort/ \nand here is\
    \ the ruby code \n<code>", "  l.uniq!\n  l\nend", "  l.sort\n  l.uniq!\n  l\n\
    end", "  l.uniq!\n  l\nend", "  l.uniq!\n  l\nend\n</pre>\n          </div>\n\
    \        </div>\n      </div>", "    l.sort!\n    l = l.uniq\n    l\nend", " \
    \ l.uniq!\n  l\nend", "  l.uniq!\nend\n</code>\n<|/ a |>\n<| a tags=ruby-on-rails-3.1,ruby-on-rails,ruby-on-rails-3,ruby,ruby-on-rails-3.2\
    \ dscore=0 |>\nI have been using ruby 1.9.2 and rails 3.2.2 and found the below\
    \ code working for me in rails 3.2.2\n<code>\nModel.order(\"id DESC\").reverse_order(\"\
    id ASC\").to_a\n</code>\n<|/ a |>\n<| a dscore=0 |>\nIt seems that in Rails 4,\
    \ it became a lot easier, and you can do this:\n<code>\nModel.order(:id).reverse_order.to_a\n\
    </code>\n<|/ a tags=ruby-on-rails-3.1,ruby-on-rails,ruby-on-rails-3,ruby,ruby-on-rails-3.2\
    \ |>\n<| a dscore=0 tags=ruby-on-rails-3.1,ruby-on-rails,ruby-on-rails-3,ruby,ruby-on-rails-3.2\
    \ |>\nIt seems that in rails 4, it became a lot easier, and you can do this:\n\
    <code>\nModel.order(:id).reverse_order.to_a\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nI got this working for me in rails 4.2.6:\n<code>\nOrder.all.order(:created_at).reverse_order.pluck(:id)\n\
    </code>\nThis was the only way I could get it to work. No more error messages.\n\
    <|/ a tags=ruby-on-rails-3.1,ruby-on-rails,ruby-on-rails-3,ruby,ruby-on-rails-3.2\
    \ |>\n<| a dscore=0 |>\nI was getting this error\n<code>\nPG::Error: ERROR:  for\
    \ SELECT DISTINCT, ORDER BY expressions must appear in select list\nLINE 1: ...(distinct\
    \ \"orders\".\"order_id\") FROM \"orders\" ORDER BY \"order...\n</code>\nAnd this\
    \ was the query I was running\n<code>\nOrder.all.order(:created_at => :desc).uniq.pluck(:id)\n\
    </code>\nI changed it to this and all works well\n<code>\nOrder.all.order(:created_at\
    \ => :desc).uniq.pluck(:id).sort_by(&:id)\n</code>\n<|/ a tags=ruby-on-rails-3.1,ruby-on-rails,ruby-on-rails-3,ruby,ruby-on-rails-3.2\
    \ |>\n<| a dscore=0 |>\nJust found an alternative using Ruby 1.9.3:\n<code>\n\
    Order.select('DIST", "  l.uniq\nend", "  l.sort.uniq\nend", "  l.uniq!\n  l\n\
    end\nalias uniq unique\n</code>\n<|/ a |>\n<| a |>\n<code>\narr = [1,3,5,2,5,7,8,4,6,9]\n\
    arr.uniq.sort", "    l.uniq!\n    l\nend", "  l.uniq!\n  l\nend", "  seen = {}\n\
    \  result = []\n  l.each do |v|\n    seen[v] = true\n  end\n  l.each do |v|\n\
    \    unless seen[v]\n      result << v\n    end\n  end\n  result\nend", "  l.sort!\n\
    \  uniques = []\n  result = []\n  \n  for el in l\n    if !uniques.include?(el)\n\
    \      uniques << el\n      result << el\n    end\n  end\n  \n  result\nend\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=arrays,ruby dscore=1 |>\nIf you can use\
    \ an external gem, consider this handy gem:\n<code>\nrequire 'set'", "  a = [e[0]\
    \ for e in l]\n  uniq, uniques = Set.new, []\n  a.each_index do |i|\n    if !uniq[i]\
    \ and !uniques.include? a[i]\n      uniq.push(a[i])\n      uniques << a[i]\n \
    \   end\n  end\n  uniq.sort\nend\n</code>\n<|/ a dscore=0 tags=ruby,arrays |>\n\
    <| a tags=ruby,arrays dscore=0 |>\n<code>\narr = [1, 2, 2, 5, 2, 5, 3, 2, 1]\n\
    </code>\n<code>\narr.map { |e| arr.count(e).nonzero? }.compact", "  u = {}\n \
    \ for i in l\n    u[i] = true\n  l\nend", "  l.sort!\n  l.reverse!\n  l.uniq!\n\
    \  l\nend", "    l.sort # in-place, stable sort to keep duplicates last\n    seen\
    \ = []\n    duplicates = false\n    \n    # Go through each element, except for\
    \ the first one\n    for element in l\n        \n        # If the element is not\
    \ in the list, add it and\n        # set duplicates to true.\n        if not in?\
    \ element, seen", "  l.uniq!\n  l\nend", "  l.uniq!\n  l\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nNote that this assumes Ruby 1.9.2+\n<|/ c |>\n<| a tags=arrays,ruby\
    \ |>\n<code>\narray.inject(Hash.new(0)) { |h,i| h[i]+=1; h }\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI like your solution; it's elegant. But in terms of performance:\
    \ it's very bad on large arrays (it will consume memory proportional to the size\
    \ of the array). See my answer for an alternative that runs in linear time without\
    \ consuming more memory than necessary.\n<|/ c |>\n<| c |>\nI disagree with you\
    \ - it runs linear (not quadratic, since each hash element in the hash table is\
    \ visited exactly once by the `inject` method).\n<|/ c |>\n<| c |>\nThis assumes\
    \ Ruby 1.9.2+\n<|/ c |>\n<| c |>\nI tested with Ruby 1.8.7, and it worked fine\
    \ for me, but I did have some problems with 1.9.2\n<|/ c |>\n<| c |>\nNot sure\
    \ how this was accepted, but it does not produce the expected output. In my opinion\
    \ it is not a correct solution.\n<|/ c |>\n<| a tags=arrays,ruby |>\n<code>\n\
    array.inject([[],[],[],[],[]]) { |acc, x| acc[x[0]] << x; acc }\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nThis is a better solution than any of the others provided\
    \ as it doesn't require Ruby 1.9.2. Although I wonder how much time this actually\
    \ takes.\n<|/ c |>\n<| a tags=arrays,ruby |>\nJust for fun, an alternative to\
    \ Ruby's built-in Hash.new method is to use inject:\n<code>", "  l.sort\n  uniq\
    \ = l[0]\n  l.delete_at(1..l.size)\n  l.reverse unless l.empty?\n  uniq\nend",
  "  l = l.sort\n  l.uniq!\n  l\nend", "  l.uniq!\n  l\nend", "  l.uniq!\n  l\nend\n\
    alias uniq unique", "  l.sort # sorts the list for efficient lookup\n  l.uniq!.each\
    \ { |x| yield x } # returns unique elements\nend", "  l.sort.uniq\nend\n</code>\n\
    <|/ a |>\n<| c |>\nFor Ruby 2.0 and newer, you can use the [Enumerable#uniq](https://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-uniq)\
    \ method.\n<|/ c |>\n<| a tags=list,ruby,arrays,unique dscore=5 |>\nI've used\
    \ this one on large lists:\n<code>\nlist.uniq.sort\n</code>\n<|/ a |>\n<| a |>\n\
    Here's how I'd do it (I'm assuming you need the unique values to be in order):\n\
    <code>\nmy_list = [\"a\", \"a\", \"b\", \"c\", \"c\", \"c\", \"d\"]\nmy_list.uniq.sort\n\
    => [\"a\", \"b\", \"c\", \"d\"]\n</code>\n<|/ a dscore=5 tags=list,ruby,arrays,unique\
    \ |>\n<| a |>\n<code>\nrequire 'set'", "  u = {}\n  for i in l\n    u[i] = true\n\
    \  l.sort.each do |i|\n    next if u[i]\n    u[i] = true\n  end\n  l.uniq\nend",
  "  u = {}\n  l2 = []\n  for x in l do\n    if x != nil and not u[x] then\n     \
    \ u[x] = true\n      l2.push(x)\n    end\n  end\n  return l2\nend", "  l.uniq!\n\
    \  l\nend\n</code>\n<|/ a dscore=5 tags=ruby,sorting,arrays,unique |>\n<| c |>\n\
    This method is very slow when compared to built-in `Array#uniq`. See the benchmarks\
    \ below.\n<|/ c |>\n<| c |>\n: What are your benchmarks saying? The fastest method\
    \ depends on many factors. How are you benchmarking it?\n<|/ c |>\n<| c |>\n:\
    \ I wrote my own benchmarks in Ruby 1.9.3 without using Benchmark library. `unique`\
    \ uses `Array#uniq`  and `unique!` uses `Array#uniq!`. I was comparing both methods\
    \ in the question. It looks like `Array#uniq!` performs way better than `Array#uniq`\n\
    <|/ c |>\n<| c |>\n: That's interesting. You're benchmarking `unique` and `unique!`,\
    \ but you don't run your benchmark on each of the two methods; you run it on just\
    \ the `unique` method. How are you running your benchmark? And why are you using\
    \ `Benchmark`?\n<|/ c |>\n<| c |>\n: `benchmark` library is for comparing code\
    \ snippets. To get realistic benchmarks for Ruby code, I use the following code:\
    \ `require 'benchmark'; n = 5; a = Array.new(10000) { n } t = Benchmark.measure\
    \ { a.uniq } puts \"unique in #{t}\" # => unique in 0.010392s`. So `unique` method\
    \ uses `Array#uniq`. `unique!` method uses `Array#uniq!`. Hope this helps.\n<|/\
    \ c |>\n<| a |>\n<code>\n[1,2,2,3].uniq\n</code>\n<|/ a dscore=5 tags=ruby,sorting,arrays,unique\
    \ |>\n<| c |>\nYou forgot the ! in uniq! :)\n<|/ c |>\n<| c |>\nAh, just found\
    \ out in the \"Ruby Programming\" book that this does not work in ruby 1.9.2 due\
    \ to bug fixed in ruby 1.9.3. The book refers to 1.9.2 and 1.9.3 in the \"Gemfile.lock\"\
    \ file.\n<|/ c |>\n<| c |>\nBut it does work in 1.9 (just tested it), thanks\n\
    <|/ c |>\n<| c |>\nNot for arrays with nil, though.\n<|/ c |>\n<| c |>\n`[1,2,2,3].uniq!`\
    \ returns `[1, 2, 3]`, not ", "  l.sort!\n  l.reject { |i| l.index(i) }\nend",
  "  l.sort!\n  l.reject!{|i| i == l.last}\n  l\nend\n</code>\n<|/ a dscore=3 tags=ruby,ruby-on-rails,arrays,duplicates\
    \ |>\n<| c |>\nIt's probably worth noting that this approach also removes duplicates\
    \ from the original array - not just the duplicates that are found in the duplicate-removal\
    \ method.\n<|/ c |>\n<| c |>\nThat is a good point. Just tested and you are right,\
    \ that is also possible. I'll edit the answer to include that.\n<|/ c |>\n<| a\
    \ dscore=3 tags=ruby,ruby-on-rails,arrays,duplicates |>\nI like to use an each_cons\
    \ method from Enumerable. Because it returns a new object it doesn't modify the\
    \ original array like uniq or sort do.\n<code>\n(1..10).each_cons(2).map(&:first).uniq\n\
    => [1, 3, 5, 7, 9]\n</code>\nThis approach will skip any single element in the\
    \ array (except the first element in the array).\n<|/ a |>\n<| a dscore=2 |>\n\
    I find that using #uniq here works best for me in most circumstances.  Here are\
    \ my general rules of thumb:", "  return l.uniq!\nend", "  l.uniq!\nend", "  l.sort!\n\
    \  res = []\n  l.each_with_index do |v,i|\n    if i == 0 || v != l[i-1] then\n\
    \      res << v\n    end\n  end\n  res\nend", "  l.sort\n  l.reverse!\n  l[1..-1]\n\
    end", "  l.sort\n  l.reverse!\n  l.uniq!\n  l\nend", "  l.sort\n  l.reverse\n\
    \  l.reject{|i| l.include?(i)}\nend", "\tl.uniq\nend\nend\nend\nend\nend\nend",
  "  return l.sort().uniq\nend", "  l.uniq\nend", "  seen = Set.new()\n  ret = l\n\
    \  l.each do |item|\n    if seen.include?(item)\n      break\n    else\n     \
    \ seen.add(item)\n      ret << item\n    end\n  end\n  ret\nend", "    seen =\
    \ {}\n    seen_add = seen.add\n    return [x for x in l if x not in seen and not\
    \ seen_add(x)]", "  l2 = []\n  for x in l\n    if l2.include?(x)\n      l2 <<\
    \ x\n    else\n      l2 << x\n    end\n  end\n  l2\nend", "  l.uniq!\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails dscore=1 |>\n<| c |>\nThat is actually a great way\
    \ to implement it, but I don't think it's very efficient as it will require a\
    \ lot of memory and CPU to create an array of all existing elements which is going\
    \ to be the same size as the original array. Using a hash is definitely more efficient.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails |>\nHere is a more compact way that returns\
    \ a hash of unique elements. To make this a little more efficient, the hash can\
    \ only hold unique keys for values that occur more than once in the original array.\n\
    <code>", "  l.uniq!\nend", "  seen = Set.new\n  l.collect do |x|\n    seen[x]\
    \ ? nil : seen[x] = true\n  end\n  seen.keys.sort.reverse\nend", "\tl.uniq!\n\t\
    l\nend", "  seen = Set.new\n  (l || []).uniq(&:itself).map(&:itself).reject{|x|\
    \ seen.add(x)}\nend", "  result = []\n  loop :\n    break if l.empty?\n    result.append(l.shift)\n\
    \    break unless l.any?\n  end\n  result\nend", "  l.uniq!\n  l\nend", "  l.uniq\n\
    end", "    ret = nil\n    l.each do |e|\n        unless ret.nil? || e != ret\n\
    \            ret = e\n        end\n    end\n    ret\nend", "  # @return [Array<int>]\n\
    \  # Enumerable#uniq does not work with Hash types (at least in Ruby 1.9.2)\n\
    \  result = []\n  l.each do |el|\n    result << el if result.index(el) == nil\n\
    \  end\n  result\nend", "  l.sort!\n  l.uniq!\n  l\nend", "  l.uniq!\n  l\nend\n\
    </code>\nThe uniq! method returns self which may be handy in some cases. In this\
    \ case it does nothing.\n<|/ a |>\n<| a dscore=5 |>\nThe simplest solution I've\
    \ seen so far:\n<code>", "    l.uniq!\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,set,collections,hash\
    \ |>\nI wrote a gem which adds support for unique in Ruby Set class.\n<code>\n\
    require 'uniq'", "  l.sort\n  l.reverse!\n  l = [l[0]] + l[1..-1]\n  l.uniq!\n\
    \  l.compact!\n  l.sort!\n  l\nend", "  l.sort!\n  l = [l[0]] + l.uniq.sort if\
    \ l.length < 2\n  l\nend", "  return [a for (a,v) in l.uniq]\nend", "  l.sort!\n\
    \  h = {}\n  result = []\n  l.each do |item|\n    h[item] ||= []\n    h[item]\
    \ << item\n  end\n  h.keys.sort.each do |k|\n    result << k if h[k].length ==\
    \ 1\n  end\n  return result\nend\n</code>\n<|/ a |>\n<| a tags=ruby,hash dscore=0\
    \ |>\nHere's a more concise solution, although's solution is better:\n<code>",
  "  l.uniq!\n  l\nend", "  l.uniq!\n  l\nend", "  seen = {}\n  l.each{|x| seen[x]\
    \ = true }\n  l.each{|x| seen[x] ? seen[x] = false : nil}\n  l.map{|x| x}\nend",
  "  l.uniq!\n  l\nend", "  l.sort if l and l.uniq\n  l\nend", "  seen = {}\n  result\
    \ = []\n  l.each do |i|\n    if seen[i] != nil\n      seen[i]\n    else\n    \
    \  seen[i] = 1\n      result << i\n    end\n  end\n  result\nend", "  l.sort!\n\
    \  l.reverse!\n  l.uniq!\nend", "  # Using Ruby 1.8.7's to_a, and converting to\
    \ a hash via each_with_object\n  h = {}\n  l.each do |item|\n    h.update({ item\
    \ => true }) unless h.has_key?(item)\n  end\n  h.keys\nend", "  seen = {}\n  ulist\
    \ = []\n  for e in l\n    if seen[e.to_s] # if element has already been seen\n\
    \      next\n    else\n      seen[e.to_s] = true\n      ulist << e\n  end\n  ulist\n\
    end", "  l.sort!\n  l.reduce { |v,x| x != v ? v : nil }\nend", "  l.sort!\n  l.reverse!\n\
    \  l\nend", "  l = l.to_a\n  uniques = []\n  \n  l.map!{|i| !uniques.include?(i)\
    \ ? uniques.push(i) : nil}\n  uniques\nend", "  l.sort\n  uniq, idx = [], 1\n\
    \  l.each do |x|\n    if x == uniq[idx] then\n      idx += 1\n    else\n     \
    \ uniq.push(x)\n      idx = 1\n    end\n  end\n  uniq\nend\n</code>\nHere is a\
    \ quick test suite:\n<code>\nrequire 'test/unit'", "  a = l.sort\n  l.sort! {\
    \ |e| e }\n  l\nend", "  l.sort\n  l\nend", "  l.uniq!\n  l\nend", "    l.sort!\n\
    \    l = l.reverse\n    l.uniq!\n    l.reverse!\n    l\nend\n</code>\nI hope this\
    \ helps others.\n<|/ a |>\n<| c |>\nThe `sort!` method will perform a full sort,\
    \ so you could replace it with `l <<= [l.uniq!]`, but that's still less efficient\
    \ than just doing the uniq step at the end.\n<|/ c |>\n<| c |>\nI see your point,\
    \ but this is not a sorting algorithm, it just does something with each item that\
    \ needs to be done in order.\n<|/ c |>\n<| a dscore=5 |>\nAs you were told in\
    \ the comments, uniq is more efficient. Here's my version of the function using\
    \ uniq:\n<code>", "  l.sort!\n  l.reverse!\n  l.uniq!\n  l\nend", "  l.uniq.sort!\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nGood call on `#uniq` - never heard of\
    \ it before. I've never heard of `#sort!` before, and it seems more efficient\
    \ than `#sort` for me. Thanks!\n<|/ c |>\n<| c |>\nYes, this is more efficient.\
    \ See my answer for a detailed explanation.\n<|/ c |>\n<| c |>\nThis should be\
    \ the correct answer, especially if you need to remove duplicates more than once.\n\
    <|/ c |>\n<| c |>\nThis is a good answer, but note that it's inefficient in terms\
    \ of space since it creates a copy of `l`. You could modify it to only sort the\
    \ new copy. `l.uniq(&:object_id).sort!`\n<|/ c |>\n<| c |>\nThe `sort!` method\
    \ can be quite expensive, but it is only a shallow copy of any complex object.\
    \ For instance, it doesn't copy `self.to_a` -- which is what happens when you\
    \ call `l` directly.\n<|/ c |>\n<| a dscore=5 |>\nI know this is a bit late, but\
    \ for future readers who may be looking for this:\n<code>", "  l.uniq { |x| x\
    \ }\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\nI think this is a duplicate of\
    \ \"Remove duplicates from a list in Ruby\", but the answers there don't really\
    \ seem to apply because they don't remove duplicates of nil values.  Here's a\
    \ solution that does:\n<code>", "    seen = {}\n    unique_array = []\n    unique_array.extend(l)\n\
    \    for e in unique_array:\n        if e not in seen:\n            seen[e] =\
    \ 1\n            unique_array.append(e)\n    return unique_array\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\n`uniq` does not seem to exist. Do you mean `unique`?\n\
    <|/ c |>\n<| c |>\nYes, I meant unique, I fixed the answer now\n<|/ c |>\n<| c\
    \ |>\nThe second `uniq` statement could just be `unique_array = unique_array.uniq\
    \ { |e| e }`\n<|/ c |>\n<| c |>\nWhat do you think about this implementation?\
    \ http://stackoverflow.com/a/24241112/184945\n<|/ c |>\n<| c |>\nLooks good, thanks\
    \ for sharing. I'll have to take a closer look.\n<|/ c |>\n<| a tags=arrays,duplicate-removal,ruby\
    \ |>\nYou can use the Set class:\n<code>\n[5, 3, 5, 2, 3, 3, 9, 0, 123].to_set.to_a\n\
    => [0, 2, 3, 5, 9, 123]\n</code>\nAs far as I can tell, this is the best solution\
    \ since it doesn't require looping and doesn't require any sort of custom code\
    \ (such as uniq).\n<|/ a dscore=5 |>\n<| c |>\nThis is the best solution here.\
    \ The others are pretty cool but this also works.\n<|/ c |>\n<| c |>\nThis works\
    \ only in Ruby >= 1.9, but in Ruby < 1.9, use [Array#uniq](http://www.ruby-doc.org/core-1.9.3/Array.html#method-i-uniq)\
    \ instead.\n<|/ c |>\n<| c |>\nThis does not work if the object you are trying\
    \ to convert to a set already has hashes involved, e.g. `[{ a: 1 }, { a: 1 },\
    \ { a: 2 }].to_set.to_a` returns `[{ a: 1 }, { a: 2 }]`. You could always convert\
    \ it to a hash: `[{ a: 1 }, { a: 1 }, { a: 2 }].to_set.to_a.map{|e| Hash[e.to_a]}.flatten`\n\
    <|/ c |>\n<| c |>\nRuby 1.9+ has Array#to_set. Try `[{ a: 1 }, { a: 1 }, { a:\
    \ 2 }].to_set.to_a` [link](http://ruby-doc.org/core-1.9.3/Array.html#method-i-to_set)\n\
    <|/ c |>\n<| c |>\nThis works only for strings. `[{ a: 1 }, { a: 1 }, { a: 2 ",
  "  l.uniq!\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n`uniq` is only available since\
    \ Rails 3.2 (http://api.rubyonrails.org/classes/Enumerable.html#method-i-uniq).\
    \ In Rails 4 there exists the `uniq!` method which has much better performance\
    \ compared to `uniq`.\n<|/ c |>\n<| c |>\nYes, I know. Thanks for your suggestion,\
    \ anyway :)\n<|/ c |>\n<| c |>\nThe current version of Rails includes the uniq!\
    \ method as of 4.0.0.\n<|/ c |>\n<| c |>\nThanks, I didn't know that.\n<|/ c |>\n\
    <| c |>\nIt looks like this solution has a problem in rails 4.2.6.  It says that\
    \ `uniq!` is undefined method.\n<|/ c |>\n<| a tags=ruby,arrays,unique dscore=3\
    \ |>\nYou can use the ruby uniq method.\n<code>\narray.uniq\n</code>\nwill remove\
    \ duplicate values.\n<|/ a |>\n<| c |>\nIt was introduced in ruby 2.1 and has\
    \ worked in ruby 1.9 and 1.8.7 too\n<|/ c |>\n<| c |>\nThanks very much, I was\
    \ wondering why the documentation for .uniq on ruby doesn't mention it.\n<|/ c\
    \ |>\n<| c |>\nIt was in ruby 1.8.6 as well.\n<|/ c |>\n<| c |>\nIt was introduced\
    \ in ruby 1.9.2, and has worked in ruby 1.8.7 and 1.9.1\n<|/ c |>\n<| c |>\nIt\
    \ was introduced in 1.9.3, and has worked in 1.8.7 and 1.9.1\n<|/ c |>\n<| a dscore=2\
    \ |>\nRuby 2.1 has a uniq method\nhttp://ruby-doc.org/core-2.1.0/Array.html#method-i-uniq\n\
    <code>\nruby-1.9.2-p180 :006 > arr = [1, 2, 1, 3, 3, 2, 5, 2, 1, 2, 3, 1, 1, 3]\n\
    \ => [1, 2, 1, 3, 3, 2, 5, 2, 1, 2, 3, 1, 1, 3] \nruby-1.9.2-p180 :007 > arr.uniq\n\
    \ => [1, 2, 3, 1, 1, 5] \n</code>\n<|/ a tags=ruby,arrays,unique |>\n<| a |>\n\
    I have used the code below for a while and have never had any issues. I believe\
    \ it is pretty robust:\n<code>", "  l.uniq!\n  l\nend", "  return l.uniq.sort\n\
    end", "  l.sort!\n  l.uniq!\n  l\nend", "    seen = Set.new\n    l.each do |x|\n\
    \        if seen.add(x)\n            yield(x)\n        end\n    end\nend", " \
    \ r = []\n  r.uniq! if l.is_a?(Enumerable)\n  r.uniq! if l.respond_to?(:uniq!)\n\
    \  r.push(*l)\n  r\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis does not seem\
    \ to work in Ruby 1.8.7. It returns duplicates: uniq! returns an array containing\
    \ all unique elements in the receiver, not just unique elements.\n<|/ c |>\n<|\
    \ a dscore=2 tags=ruby,arrays |>\nHere is a one-liner solution:\n<code>\n>> [5,\
    \ 10, 5, 10, 10, 5].uniq.map(&:to_i)\n=> [5, 10, 10]\n</code>\n<|/ a |>\n<| a\
    \ tags=ruby,arrays dscore=2 |>\nIf you have a more complex object than an array\
    \ you can always use Array#uniq_by to avoid duplicates.\n<code>\n[1,2,2,3].uniq_by(&:abs)\
    \ #=> [1,2,3]\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>", "  u = {}\n  result\
    \ = []\n  i = 0\n  while i < l.length\n    if l[i] not in u\n      u[l[i]] = l[i]\n\
    \      result.push(l[i])\n      i += 1\n    else\n      i += 1\n  end\n  result\n\
    end", "  l.uniq\nend\n</code>\nThe method uniq is available on Array, so you can\
    \ call the method as you call on Array:\n<code>\n[5, 3, 5, 2, 3, 3, 9, 0, 123].uniq\n\
    </code>\n<|/ a tags=ruby,arrays,duplicates |>\n<| c |>\nthis seems very helpful\
    \ and makes perfect sense to me. I will try this out. thanks\n<|/ c |>\n<| c |>\n\
    This won't work with an array of hashes because hashes can't be compared, only\
    \ the keys. I made a post on how to do this https://stackoverflow.com/a/58449613/1349028\n\
    <|/ c |>\n<| c |>\n: I think it would be better to ask a new question and explain\
    \ what you are trying to achieve and show what you have tried so far.\n<|/ c |>\n\
    <| c |>\nhttps://stackoverflow.com/questions/58449613/how-to-find-all-the-duplicate-values-in-a-hash-with-keys-in-order\n\
    <|/ c |>\n<| a dscore=5 |>\nRuby >= 2.3 has the method Array#uniq! which does\
    \ what you want.\n<code>\na = [5, 3, 5, 2, 3, 3, 9, 0, 123]\na.uniq!\na #=> [0,\
    \ 2, 3, 5, 9, 123]\n</code>\nThis method modifies the receiver in-place. See the\
    \ documentation of Array#uniq! for further information.\n<|/ a tags=ruby,arrays,duplicates\
    \ |>\n<| c |>\nThe `!` is unnecessary.\n<|/ c |>\n<| c |>\nThe unnecessary part\
    \ is a misleading warning which can be suppressed with `a.uniq!`\n<|/ c |>\n<|\
    \ c |>\nThat's a nice touch! I didn't know about `uniq!`\n<|/ c |>\n<| a |>\n\
    <code>\na = [\"a\", \"a\", \"b\", \"a\", \"c\", \"c\"]\na.uniq.sort\n</code>\n\
    <|/ a dscore=5 tags=ruby,arrays,duplicates |>\n<| c |>\nBut won't this just sort\
    \ alphabetically? I want to sort by the numerical value.\n<|/ c |>\n<| c |>\n\
    Not alphabetically. It does exactly what a uniq method does: it checks for duplicates\
    \ and removes them. As long as the comparison operator is defined, this will work.\n\
    <|/ c |>\n<| c |>\nIt's not working for me. `[[\"a\", \"a\", \"b\"], [\"a\", \"\
    a\", \"b\"], [\"a\", \"a\"], [\"c\", \"c\", \"b\"], [\"c\", \"c\"]].sort` returns\
    \ `[[\"a\", \"a\", \"b\"], [\"c\", \"c\", \"", "  l.uniq!\nend", "  l.sort\n \
    \ l.reject { |i| l.include?(i) }\nend", "  l.uniq!\n  l\nend", "  u = {}\n  for\
    \ i in l\n    u[i] = true\n  l\nend", "  l.to_a.reduce(:&)\nend", "  l.sort!\n\
    \  n = 0\n  i = nil\n  while i < l.length\n    i += 1\n    if l[i] == l[n]\n \
    \     n += 1\n      while n < l.length && l[n] == l[i]\n        n += 1\n     \
    \ end\n    end\n  end\n  l.dup.delete(l.length) until l[n] == nil\nend\n</code>\n\
    <|/ a tags=ruby,sorting |>\n<| c |>\n`uniq` is very slow if you use large datasets\
    \ (O(n^2)).\n<|/ c |>\n<| a dscore=4 |>\n<code>", "  l.sort\n  l.reject{|e| l.count(e)==1}.sort\n\
    end", "  l.uniq!\n  l\nend", "  u = {}\n  l.each do |n|\n    u[n] = true if u[n]\n\
    \  end\n  u.keys\nend\n</code>\nI agree that this is not a perfect solution, but\
    \ I wanted to post it anyway since it might be useful for somebody :)\n<|/ a tags=arrays,ruby\
    \ |>\n<| a dscore=2 |>\nI needed a quick \"unique\" method to remove duplicate\
    \ entries from a Ruby array. I couldn't find a standard library solution, so I\
    \ ended up writing a custom method using Ruby's hash data structure (aka a Ruby\
    \ Hashes) to remove duplicates.\nThis version only works for arrays, not array-like\
    \ objects (like hashes).\n<code>", "  seen = {}\n  result = []\n  l.each do |element|\n\
    \    if seen[element] == nil\n      seen[element] = 1\n      result << element\n\
    \    end\n  end\n  return result\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\n\
    <code>", "  l.uniq!\nend", "  u = {}\n  for x in l\n    u[x] = u[x] ? u[x] + 1\
    \ : 1\n  l.map! { |x| u[x] }\n  l\nend", "  u = {}\n  ret = []\n  l.each do |item|\n\
    \    u[item] = true\n  end\n  ret = (0...l.size).select { |i| !u.has_key?(i) }\n\
    \  ret\nend", "  l.sort!\n  l.reverse!\n  l[l.find{ |i| l.count(i) > 1}]\nend",
  "  l.sort!\n  unique_elements = []\n  while l.any?\n    unique_elements << l.shift\n\
    \  end\n  unique_elements\nend", "  l.sort.uniq\nend", "  l.sort!\n  l.reverse!\n\
    \  l[1..-1].uniq!\n  l\nend", "  l.sort\n  l.reverse.inject([], :<<)\nend", " \
    \ l.uniq!\nend", "  h = {}\n  l.each do |v|\n    if h[v] == nil\n      h[v] =\
    \ 1\n    else\n      h[v] += 1\n    end\n  end\n  h.keys\nend\n</code>\n<|/ a\
    \ |>\n<| a |>\nYou could use the partition method:\n<code>\narr = [5, 3, 3, 9,\
    \ 0, 123, 5, 3, 5]\narr.partition.select { |x| x.size > 1 }.map(&:first)\n=> [0,\
    \ 3, 123]\n</code>\n<|/ a tags=arrays,ruby,ruby-on-rails,duplicate-removal dscore=3\
    \ |>\n<| c |>\n`arr.partition.select { |x| x.size > 1 }.map(&:first)` => `[5,\
    \ 123]`.\n<|/ c |>\n<| c |>\n- Yes, you are right. I thought it must be more performant\
    \ and wanted to share with others my solutions.\n<|/ c |>\n<| a |>\nI thought\
    \ this would be a cool thing to do in ruby.\n<code>", "  l.uniq.sort\nend\n</code>\n\
    <|/ a |>\n<| c |>\nJust out of curiosity - does this work? `unique([5, 3, 2])`.\n\
    <|/ c |>\n<| c |>\nIt does, and doesn't require a temporary array. `uniq.sort`\
    \ modifies the original array in place, whereas `uniq = l.uniq; uniq.sort` creates\
    \ a new array and returns it. This is useful if you want to preserve the original\
    \ array and modify the contents in-place.\n<|/ c |>\n<| c |>\nYeah, you're right.\
    \ I was thinking of something else. :)\n<|/ c |>\n<| a dscore=2 |>\nYou can use\
    \ an enumerator:\n<code>", "  l.sort.uniq\nend", "    l.sort\n    \n    i = 0\n\
    \    while i < l.size\n        j = i + 1\n        while j < l.size\n         \
    \   if l[i] < l[j]\n                l[i], l[j] = l[j], l[i]\n            end\n\
    \            j += 1\n        end\n        i += 1\n    end\n    \n    l\nend",
  "  l.uniq!\n  l\nend", "  sorted = l.sort\n  last = nil\n  sorted.each do |x|\n\
    \    if last == x\n      next\n    end\n    last = x\n  end\n  sorted\nend\n</code>\n\
    <|/ a tags=sorting,ruby |>\n<| a dscore=0 |>\n<code>", "  l.uniq!\n  l\nend",
  "  seen = Set.new\n  l.each do |element|\n    next if seen.include?(element)\n \
    \   seen << element\n  end\n  seen\nend", "  l.uniq!\n  l\nend", "  return l.uniq.sort\n\
    end\n</pre>", "  l.sort # Sort to avoid any duplicate of elements\n  l.remove!\
    \ l.first if l.size != l.uniq.size # Remove duplicated elements if any\n  l\n\
    end", "  l.sort\n  l\nend", "  u = []\n  u.uniq!\n  u\nend", "    l.sort!\n  \
    \  return l[0...l.size - 1]\nend\n</code>\n<|/ a tags=ruby,arrays,sorting,unique\
    \ dscore=5 |>\n<| c |>\nA better answer than the accepted answer since it works\
    \ with any kind of array.\n<|/ c |>\n<| c |>\nThis answer is better because it\
    \ does not mutate the original array. It just creates a new array and uses the\
    \ `uniq` method of Array.\n<|/ c |>\n<| c |>\nAlso works on frozen arrays, although\
    \ the other answer doesn't.\n<|/ c |>\n<| c |>\nWhat about `[[3,1],[1,2]].uniq`\
    \ for example, returning a `[[1,2]]` instead of `[[3,1],[1,2]]`?\n<|/ c |>\n<|\
    \ c |>\nI believe the above code will work. `[3,1].uniq` will give `[1]`. But\
    \ the answer `[[3,1],[1,2]].uniq` will give `[[3,1],[1,2]]`. \n[3,1].uniq is giving\
    \ you the unique items in first array. So it will give you `1`\n<|/ c |>\n<| a\
    \ |>\n<code>", "    l = l.flatten\n    uniq, idxs = [], 0\n    until l.size <=\
    \ 10000 # or whatever you want, depends on what you're doing\n        curr_idx\
    \ = idxs\n        el = l[curr_idx]\n        if el not in uniq\n            uniq\
    \ << el\n            idxs += 1\n        else\n            uniq[curr_idx] = uniq[curr_idx\
    \ - 1]\n        end if el\n    uniq\nend\n</code>\nFor any array size over 10,000,\
    \ it runs slower than the Ruby version, but for less than 10,000 it runs in less\
    \ than half a second. Granted, this isn't as fast as it could be and you'd need\
    \ some more sophisticated algorithms to improve the performance even further.\n\
    This Ruby version also returns the original array, but if you want a new array,\
    \ you just change the last line to uniq\n<|/ a dscore=2 tags=sorting,ruby,arrays\
    \ |>\n<| a |>\nI like using Set for this type of problem:\n<code>\na = [4,5,5,2,3,5,2,5,3]\n\
    unique = Set.new\na.each { |x| unique << x }\nunique", "  seen = {}\n  result\
    \ = []\n  l.each do |el|\n    seen[el] ? result.push(el) : seen[el] = true\n \
    \ end\n  result\nend", "  l.uniq!\nend", "  l.sort!\n  uniq, idx = [], 0\n  while\
    \ idx < l.size\n    uniq.push(l[idx])\n    idx += 1\n  end\n  uniq\nend", "  l.uniq!\n\
    \  l\nend", "  result = []\n  \n  \n  # Remove duplicates and add them to result\n\
    \  l.each do |x|\n    if !result.include?(x)\n      result << x\n    end\n  end\n\
    \  \n  result\nend", "  seen = Set.new\n  l.each{|item| item != nil ? seen.add!(item)\
    \ : nil}\n  seen.value\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nI like\
    \ this solution, but why use a Set here? Shouldn't it be faster?\n<|/ c |>\n<|\
    \ a tags=arrays,ruby |>\n<code>", "  seen = []\n  l.each{|i| seen << i if !seen.include?(i)}\n\
    \  seen\nend", "  u = {}\n  ret = []\n  u[l.shift] = true\n  l.each { |e| u[e]\
    \ ? ret.push(e) : u[e] = true }\n  ret\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ works but doesn't give the output OP wants. OP wants the unique values.\n<|/\
    \ c |>\n<| c |>\nI took the liberty of modifying it and making it a little faster.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3,arrays |>\nI needed the\
    \ unique values from an array to put in a dropdown, so I came up with:\n<code>\n\
    <%= f.select :country_id, \n  options_for_select((['All'] + COUNTRIES).uniq.map\
    \ {|c| [c.name, c.id]}, params[:country] ? params[:country].id : nil) %>\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3,arrays |>\nYou\
    \ could also do this:\n<code>\ncountries.select { |country| countries.count(country)\
    \ == 1 }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is actually the best solution\
    \ for this problem. Just tried it with an array of hashes and it takes less than\
    \ a second for me to return an array of unique values from that hash. ", "  l.to_a\n\
    \  l.uniq.sort\nend", "  return l.sort().uniq unless l.frozen?\n  l\nend", " \
    \ l.uniq!\n  l\nend", "    seen = {}\n    seen_add = seen.add\n    return [x for\
    \ x in l if x not in seen and not seen_add(x)]\n</code>\n<|/ a tags=python,sorting,dictionary\
    \ dscore=4 |>\n<| a dscore=2 tags=python,sorting,dictionary |>\n<code>", "  sorted\
    \ = l.sort\n  last = sorted.first\n  uniques = []\n  sorted.each do |i|\n    if\
    \ i == last\n      uniques.push i\n    else\n      uniques.push i\n      last\
    \ = i\n    end\n  end\n  uniques\nend", "  l2 = []\n  l2.each do |x|\n    if l2.index(x)\
    \ == l.index(x)\n      next\n    elsif l2.index(x) < l.index(x)\n      l2 << x\n\
    \    end\n  end\n  return l2\nend", "  seen = {}\n  l.inject([]) { |a,e| seen[e]\
    \ ? a << seen[e] : a << e }\nend", "  l.uniq\nend", "  l.sort.uniq\nend", "  \
    \  l = l.sort { |a,b| a <=> b }\n    seen = {}\n    l.each { |e| seen[e] = true\
    \ }\n    l = l.select { |e| seen[e] == false }\n    l\nend", "    seen = set()\n\
    \    seen_add = seen.add\n    return [ x for x in l if x not in seen and not seen_add(x)]",
  "  sorted = l.sort\n  result = []\n  seen = {}\n  i = 0\n  while i < sorted.length\n\
    \    j = i + 1\n    while j < sorted.length\n      if sorted[i] == sorted[j]\n\
    \        j += 1\n      else\n        if seen[sorted[i]]\n          seen[sorted[j]]\
    \ = seen[sorted[i]] + 1\n        else\n          seen[sorted[j]] = 1\n       \
    \   result.push sorted[j]\n        end\n      end\n      i += 1\n    end\n  end\n\
    \  result\nend", "  l.uniq!\nend", "  l.uniq!\n  l\nend", "  l.sort!\n  l = [l[0]]\
    \ + l unless l[0] == l[1]\n  l.uniq!\n  l\nend", "    l.sort!\n    l = l.uniq\n\
    \    l.sort!\nend", "  l.sort!\n  l = l.reject { |e| l.count(e) == 1 }\n  l.uniq!\n\
    \  l\nend\n</code>\n<|/ a tags=ruby,duplicates,arrays,sorting |>\n<| a tags=ruby,duplicates,arrays,sorting\
    \ |>\nFor Ruby 1.9+\n<code>\na = [1, 2, 4, 2, 3, 3, 3, 4, 5]\na.uniq.sort\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis only works if the values are unique. My problem\
    \ was the values were duplicates. I needed to delete them entirely, not just sort.\n\
    <|/ c |>\n<| a |>\nI believe this is what you were looking for:\n<code>\nmyArray\
    \ = [1, 2, 4, 2, 3, 3, 3, 4, 5]\nmyArray.sort!.uniq!\nmyArray\n=> [1, 2, 3, 4,\
    \ 5]\n</code>\n<|/ a dscore=5 tags=ruby,duplicates,arrays,sorting |>\n<| c |>\n\
    Note that this modifies the original array\n<|/ c |>\n<| c |>\nIt doesn't modify\
    \ the original array. `uniq!` modifies the original array as well.\n<|/ c |>\n\
    <| c |>\nThis is not the fastest way. Using `uniq!` will require iterating through\
    \ the array twice. Once for determining the duplicates, once for the new sorting.\
    \ See my answer below for a better approach.\n<|/ c |>\n<| c |>\nI see a very\
    \ similar answer from Mike Miller on the same question as the OP. The only thing\
    \ different is that the OP used `sort!` instead of `sort`. As written, these two\
    \ methods are essentially the same thing, except that `sort!` modifies the original\
    \ array. By contrast, `uniq!` returns an array that does not contain the duplicate\
    \ elements. So, in this case, `uniq!` is the same as `sort!.uniq!`. It is a bit\
    \ more efficient (because `sort!` iterates through the array twice).\n<|/ c |>\n\
    <| c |>\nI don't see how `uniq` can be faster than `sort` + `uniq`, since `uniq`\
    \ has to iterate through the array twice, while `sort` only does it once, therefore\
    \ it runs much slower.\n<|/ c |>\n<| a tags=ruby,duplicates,arrays,sorting dscore=4\
    \ |>\nYou might want to use:\n<code>", "  l.uniq!\n  l\nend", "  l.uniq!\n  l\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`unique` doesn't remove duplicates.\
    \ It only returns them if they're unique. See the description of `uniq` in `Array`\
    \ documentation.\n<|/ c |>\n<| c |>\n: thanks for pointing that out. I updated\
    \ my answer.\n<|/ c |>\n<| c |>\nI see that you edited your answer, but you left\
    \ the original answer intact. Can you change your answer back?\n<|/ c |>\n<| c\
    \ |>\nIt's okay, I changed my answer back to the original version.\n<|/ c |>\n\
    <| a dscore=5 |>\nYou can use uniq to remove duplicate elements.\n<code>\na =\
    \ [\"a\", \"a\", \"a\", \"b\", \"b\"]\na.uniq", "    seen = {}\n    seen_add =\
    \ seen.add\n    return [x for x in l if x not in seen and not seen_add(x)]\nend",
  "  # Make a list of all unique elements in the list\n  ulist = []\n  for x in l\n\
    \    ulist << x\n  end\n  # Sort the list\n  ulist.sort\n  # Return unique elements\n\
    \  ulist\nend", "  l.uniq!\n  l\nend", "  seen = {}\n  result = []\n  l.each do\
    \ |x|\n    seen[x] = true\n    result << x\n  end\n  result.sort!\n  result\n\
    end", "\tl.sort\n\tl.uniq\nend", "  l.uniq!\n  l\nend", "  l.uniq.sort\n  l\n\
    end", "  h = Hash.new\n  l.each do |item|\n    h[item] += 1\n  end\n  h.sort.map\
    \ { |k, v| v }.uniq\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n`[5, 3, 5, 2, 3,\
    \ 3, 9, 0, 123].uniq.sort`\n<|/ c |>\n<| c |>\n: That's a great idea. I didn't\
    \ even know this was possible.\n<|/ c |>\n<| c |>\nThis method is very nice, however,\
    \ it has a caveat.  It will return duplicate elements in a list, as you might\
    \ expect.  For example, try it with `unique([5, 3, 5, 2, 3, 3, 9, 0, 123, 5])`.\
    \  You'll get `[0, 2, 3, 4, 9, 123, 5]` as the output.\n<|/ c |>\n<| c |>\n.roman:\
    \ You are correct. Having duplicate elements in a list is not a problem if those\
    \ elements are unique (which they are). In the example the elements are unique\
    \ so it is fine.\n<|/ c |>\n<| c |>\nWhat about when `Hash` key is a complex object?\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\na = [5, 3, 5, 2, 3, 3, 9, 0, 123]", "  l.uniq!\n\
    end", "  l.uniq!\n  l\nend", "\tl.uniq!\n\tl\nend", "  l.uniq!\n  l\nend", " \
    \ l.uniq!\n  l\nend", "  # Sort unique elements\n  l.sort!\n  # Remove duplicates\n\
    \  l.reject! {|v| l.include?(v)} if l.respond_to? :reject\n  # Return unique elements\n\
    \  l\nend", "    l.sort.uniq!\nend", "  l.sort!\n  l.reverse!\n  l[1..-1].uniq!\n\
    end\n</code>\n<|/ a tags=ruby,arrays,sorting dscore=0 |>\n<| c |>\nYour solution\
    \ returns `false` for `[1, 1, 2, 2, 3]`.\n<|/ c |>\n<| c |>\nThat's a good point!\
    \ I was just testing out a couple of the methods I was thinking of and thought\
    \ they would be pretty similar to each other.\n<|/ c |>\n<| c |>\nOh I see - I\
    \ misunderstood the question\n<|/ c |>\n<| a |>\n<code>", "\tl.sort!\n\tl = l.uniq\n\
    end", "  return l.uniq\nend", "  l = l.dup\n  l.sort!\n  l.remove!\n  l\nend",
  "  l.uniq!\n  l\nend", "  l.uniq { |x| x }\nend\n</code>\nThe return value from\
    \ the method can be further processed if you want a regular array or a hash:\n\
    <code>", "  return unique_bang(l).reverse()\nend", "    l.sort\n    h = l.inject(:<<)\n\
    \    h.uniq!\nend\n</code>\nIn a real program, you might want to rethink whether\
    \ you want unique and sort in the same function, or whether you want the sorting\
    \ be handled by a separate method.\n<|/ a tags=ruby,arrays |>\n<| a dscore=5 |>\n\
    Another way:\n<code>\n[1,2,2,3,1].uniq\n</code>\n<|/ a tags=ruby,arrays |>\n<|\
    \ c |>\nThat's how I do it too.  You don't even need parentheses, though; you\
    \ can chain them on the same line.  `[1,2,2,3,1].uniq.sort`\n<|/ c |>\n<| c |>\n\
    Yeah, but it's worse to read. YMMV.\n<|/ c |>\n<| c |>\nWhat makes you think it's\
    \ worse to read?\n<|/ c |>\n<| c |>\nYou just need to understand how it works.\
    \ It is also a method of `Array` so you should be able to call it with `[1,2,2,3,1].uniq`\
    \ just as you call `sort` on an array.\n<|/ c |>\n<| c |>\nIt just seems more\
    \ explicit to me to have the sort happen right after the uniq instead of having\
    \ to think about it being two different things.\n<|/ c |>\n<| a |>\n<code>\n[1,2,2,3,1].uniq.sort\n\
    </code>\n<|/ a dscore=5 tags=ruby,arrays |>\n<| c |>\n`[1,2,2,3,1].sort_by(&:itself)`\
    \ seems better than `[1,2,2,3,1].uniq`\n<|/ c |>\n<| c |>\n: I like it. The problem\
    \ with `sort_by` here is that it doesn't work (for arrays with different objects),\
    \ but I agree that it'd be nice if it did.\n<|/ c |>\n<| c |>\nThis is better\
    \ than the accepted answer in my opinion. Not sure why it is downvoted.\n<|/ c\
    \ |>\n<| c |>\n: It's not an answer to the question. Someone asking how to sort\
    \ an array should understand that they are asking how to sort arrays, not how\
    \ to sort objects in the array. Not that this is a bad answer, but that it's not\
    \ a direct answer to the question.\n<|/ c |>\n<| c |>\nThis would not work if\
    \ you have `[1,1,2,3,1]` (which would be sorted like `[2,1,3,1]`), as it would\
    \ return `[1,2,3]` instead.\n<|/ c |>\n<| a |>\n<code>\n[1,2,", "  l = l.to_a\n\
    \  l.uniq!\n  l\nend", "  l.uniq!\n  l\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
