name: HumanEval_15_string_sequence
language: rb
prompt: "# Return a string containing space-delimited numbers starting from 0 upto\
  \ n inclusive.\n# >>> string_sequence(0)\n# '0'\n# >>> string_sequence(5)\n# '0\
  \ 1 2 3 4 5'\ndef string_sequence(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_sequence\n\
  \    candidate = method(:string_sequence)\n    assert_equal(\"0\", candidate.call(0))\n\
  \    assert_equal(\"0 1 2 3\", candidate.call(3))\n    assert_equal(\"0 1 2 3 4\
  \ 5 6 7 8 9 10\", candidate.call(10))\n  end\nend\n"
completions: ["  n.to_s(0).scan(/\\d+/).join(\" \")\nend", "  return ('%0.' %(n)).split('\
    \ ').join('')\nend", "  i = 1\n  out = \"\"\n  while (i < n)\n    out << ((i ==\
    \ 1) ? \"#{i}\" : \"#{i} \") + \"#{i+1}\"\n    i += 1\n  out\nend", "  \"#{n}\
    \ #{n*10} #{n*100} #{n*1000} #{n*10000} #{n*100000}\"\nend", "  return '0 1 2\
    \ 3 4 5'[n..-1]\nend", "  \n  s = ''\n  \n  for i in 0...n\n    s += \"#{i}\"\n\
    \  \n  return s\nend", "  \"#{0..n}\"\nend", "  result = ''\n  while n > 0\n \
    \   result << (n -= 1)\n    result << ' '\n  end\n  result\nend", "  s = ''\n\
    \  i = 0\n  while i < n\n    s = s + i\n    i += 1\n  end\n  s\nend", "  n = [n].flatten\n\
    \  n = '0' * (n-n.to_s.length) + ' ' + n\n  n.slice!(0...-1)\n  n\nend", "  s\
    \ = \"\"\n  i =  0\n  while i < n do\n    s = s << i << \" \" \n    i += 1\n \
    \ end\n  return s\nend\n</cell>\n<code language=julia-0.4>\nstring_sequence(5)\n\
    </cell>\n<text>\n4.2 Parametric Functions", "  \"0 1 2 3 4 #{ n-1 }\"\nend", " \
    \ i = n\n  result = ''\n  while i > 0\n    result = i.to_s + ' ' + result\n  \
    \  i -= 1\n  end\n  result\nend", "  i = 0\n  result = ''\n  while i <= n\n  \
    \  result << i\n    i += 1\n  end\n  result\nend", "  result = ''\n  (0...n).each\
    \ do |i|\n    result += i.to_s\n    if i != n\n      result += ' '\n    end\n\
    \  end\n  result\nend\n</cell>\n<cell>\nstring_sequence(4)\n</cell>\n<cell>",
  "  n = [0,n]\n  n.map!{|n| n.to_s.split(\" \").map!{|s| s.to_i}}\n  n.map!{|n| n.map\
    \ {|e| e.to_i}.join(' ')}\n  n[0]\nend", "\tsequence(n)\n\tstring = \"\"\n\ti\
    \ = 0\n\twhile i < n\n\t\tstring += sequence(i)\n\t\ti += 1\n\treturn string\n\
    end", "  result = ''\n  while n > 0\n    result << (n % 10).to_s\n    n /= 10\n\
    \  end\n  result\nend", "  # Generate a string with n spaces, each one a number\
    \ between 0 and n-1.\n  spaces = ' ' * n\n  # Concatenate a string with the spaces,\
    \ with the number 0.\n  numbers = spaces.sub(/0+/, 0).sub(/#{spaces}/, 0).split('\
    \ ').join(' ')\n  # Return the string.\n  numbers\nend", "  n.to_s.rjust(n.to_s.length\
    \ + 1).gsub(/[- ]+/, ' ').split\nend", "  return n.to_s.split(\" \").join(\"'\"\
    +n+\"'\")\nend", "  str = n.to_s\n  str = \"\" + str + \" \" + str if n > 0 ?\
    \ n.to_s.rjust(n - 1, \" \") : \"\"\n  str.chomp!\n  return str\nend", "  i =\
    \ 1\n  result = \"\"\n  while i <= n\n    result = \"#{result} #{i}\".strip\n\
    \    i += 1\n  end\n  return result\nend", "  \"#{0..(n-1)}\"\nend", "  if n ==\
    \ 0\n    '0'\n  else\n    \"#{ 0..#{n-1} }\"\n  end\nend", "  i = 1\n  while i\
    \ <= n\n    i = i.to_s + \" \" + i.to_s\n  end\n  i\nend", "  \"#{0..(n+1)}\"\n\
    end", "  \"#{0.upto(n).map {|i| i.to_s }}\"\nend", "  seq = ''\n  while n > 0\n\
    \    seq << (n % 10).to_s + ' '\n    n /= 10\n  end\n  seq\nend", "  result =\
    \ ''\n  while n > 0\n    result << n\n    n -= 1\n  end\n  result\nend", "  seq\
    \ = ''\n  (0...n).each do |x|\n    seq << x.to_s\n  end\n  seq\nend", "  n = n.to_i\n\
    \  str = n.times.map { |i| i.to_s }.join(\" \")\n  str = str.to_s if str.length\
    \ > 0\n  str\nend", "  string = \"\"\n  (0..n).each {|i| string << (i+1).to_s}\n\
    \  string\nend", "  numbers = 0.upto(n)\n  strings.join numbers.map { |i| i.to_s\
    \ }.split\nend", "  string = ''\n  while n > 0\n    string   = string + ('%0d\
    \ ' % n).slice!(0, 2)\n    n -= 1\n  end\n  string\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby |>\n<| a tags=ruby |>\n<code>", "  return n.to_s.split('').reverse.join('\
    \ ')\nend", "  a = n\n  while a < 10000\n    a += n\n  end\n  a = a.to_s\n  a\
    \ = a.split(\" \").map(&:to_i).join(\" \")\n  a\nend\n</pre>", "  result = ''\n\
    \  for i in 0...n\n    result += i.to_s + ''\n  end\n  result\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nI think `to_s` makes the code less readable, but yes,\
    \ it can be more efficient.\n<|/ c |>\n<| c |>\nHow about using `range` instead\
    \ of `0...n`? [ref](http://stackoverflow.com/questions/155414/ruby-range-vs-for-loop).\n\
    <|/ c |>\n<| c |>\nrange is great when you're doing a lot of calculations but\
    \ otherwise I'd go with the more clear `0...n`.\n<|/ c |>\n<| a dscore=5 tags=ruby\
    \ |>\nThe best way to get a sequence of numbers is to take the number you want,\
    \ and multiply by 10.\n<code>", "  numbers = (0...n).to_a.map { |i| i.to_s }.join('\
    \ ')\n  numbers = numbers.size > 0 ? numbers : ''\n  numbers\nend", "  a = []\n\
    \  i = 0\n  while i < n do\n    a.push to_s(i)\n    i += 1\n  end\n  a.join('\
    \ ')\nend", "  str = nil\n  i = 0\n  while i <= n\n    str = str + ' ' + to_s(i)\n\
    \    i += 1\n  end\n  str\nend", "  number_string.split.each_with_index.map {\
    \ |el, index| el + number_string.split('')[index..index+1].join(\" \") }.join('\
    \ ')\nend", "  i = 1\n  result = \"\"\n  while i <= n\n    result << \"#{i}\\\
    n\"\n    i += 1\n  end\n  result\nend", "    number_strings = []\n    i = 0\n\
    \    while i < n\n        number_strings.push(String.new(i).to_s)\n        i +=\
    \ 1\n    return number_strings.join(' ')\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| a dscore=2 tags=ruby,string |>\nJust for fun, here's another solution,\
    \ using recursion\n<code>", "  ret = ''\n  while n > 0\n    ret += n % 10\n  \
    \  n /= 10\n  ret + ret\nend", "  result = ''\n  for i in 0...n\n    result +=\
    \ i\n    result += ' '\n  end\n  result\nend", "  nums = (0..n).to_a\n  nums.map!\
    \ { |i| i.to_s.rjust(2, \"0\") }\n  nums.join(\" \")\nend", "  n = n.to_i\n  return\
    \ n.times do |i|\n    i = i + '' unless i.is_a? Fixnum\n    i\n  end\nend", " \
    \   s = []\n    for i in(0...n)\n        s << i\n        s << \" \"\n        s\
    \ << i\n        s << \" \"\n        s << i\n        s << \" \"\n        s << i\n\
    \        s << \" \"\n        s << i\n        s << \" \"\n        s << i\n    \
    \    s << \" \"\n        s << i\n        s << \" \"\n    end\n    s.delete_at(s.size\
    \ - 1)\n    return s\nend", "  sequence = ''\n  (0...n).each do |i|\n    sequence\
    \ += i.to_s\n    sequence += ' '\n  end\n  sequence\nend\n</pre>\n          <p>This\
    \ also works on all Enumerable objects.</p>\n<pre class=\"ruby\"><span class=\"\
    ruby-keyword\">class</span> <span class=\"ruby-constant\">Array</span>\n  <span\
    \ class=\"ruby-keyword\">def</span> <span class=\"ruby-identifier\">string_sequence</span>\n\
    \    <span class=\"ruby-ivar\">@string_sequence</span> <span class=\"ruby-operator\"\
    >||=</span> <span class=\"ruby-keyword\">new</span>\n  <span class=\"ruby-keyword\"\
    >end</span>", "  return '0' + ((0 .. n-1).to_a.join(' '))\nend", "  n.to_s.split(\"\
    \ \").map{|n| n.to_i}.join(' ')\nend\n</code>\nNote that I haven't tested these\
    \ with negative numbers. So if you need that, you might want to change your string_sequence\
    \ to accept negative numbers.\n<|/ a tags=string,ruby,arrays |>\n<| a |>\nMy solution:\n\
    <code>", "  a = []\n  (1..n).each{|i| a << (i == 0 ? \"0\" : (i == 1 ? i : i +\
    \ \" \" + (i-1))))\n  a.join(' ')\nend", "  result = '0'\n  for i in (1..n)\n\
    \    result << \" #{result}\"\n  result\nend", "  return '0'*(n - 1) + ' ' + (1..n).map\
    \ { |i| i.to_s }.join(' ')\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThanks,\
    \ that's a lot easier to understand. I am going to try this out soon. One question:\
    \ why does \"return '0'*(n - 1) + ' ' + (1..n).map { |i| i.to_s }.join(' ')\"\
    \ produce that output?\n<|/ c |>\n<| c |>\n- It's a technique for producing an\
    \ ascending string of numbers in Ruby. The first number in the string is `0`,\
    \ which is repeated `n - 1` times. The second number is `1`, which is repeated\
    \ `n - 2` times, and so on...\n<|/ c |>\n<| a dscore=3 tags=ruby,arrays,string\
    \ |>\nHere's another way to do it, but I think the other methods are easier to\
    \ understand and use.\n<code>", "  result = ''\n  for i in 1..n\n    result <<\
    \ ' #{i}'\n  end\n  result\nend", "  (0...n).map { |i| i.to_s }.join(' ')\nend",
  "  result = ''\n  while n > 0\n    result << yield(n % 10)\n    n /= 10\n  result\n\
    end\n</code>\nUsing this string_sequence function we can create an iterative version\
    \ of the Fibonacci sequence:\n<code>", "  string = ''\n  while n > 0\n    string\
    \ += to_s(n % 10)\n    n /= 10\n  end\n  return string\nend", "  s = ''\n  for\
    \ i in (0...n).to_a\n    s = s + \" \" + str(i)\n  end\n  s\nend", "  numbers\
    \ = []\n  for i in 1..n\n    numbers << i\n  numbers\nend\n</code>\nThe return\
    \ statement of the function string_sequence is evaluated immediately after the\
    \ for loop is finished, so numbers is already empty. As you noticed above, the\
    \ return statement returns nil, causing the for loop to terminate immediately.\n\
    <|/ a |>\n<| c |>\n`numbers` will never be empty, because `i` is always less than\
    \ `n`, but the function will return `nil` when `n` is 0.\n<|/ c |>\n<| c |>\n\
    I meant that it would return `nil` when `n` is `0`. I changed my answer accordingly.\n\
    <|/ c |>\n<| a dscore=0 |>\nYou can use recursion. Here is one way to do it:\n\
    <code>", "  str = ''\n  while n > 0\n    str = n.to_s + ' ' + str\n    n -= 1\n\
    \  end\n  str\nend", "  n    = n[1..-1]\n  n    = n.join(' ').split(' ').map {\
    \ |s| s.to_i }.join(' ')\n  n    = n.join(' ').split(' ').map { |s| s.to_s }.join('\
    \ ')\n  n\nend\n</code>\n<|/ a tags=ruby-on-rails-3,ruby-on-rails,ruby,ruby-on-rails-3.2,ruby-on-rails-3.1\
    \ dscore=1 |>\n<| a |>\n<code>\n(1..5).to_s.reverse\n=> \"5 4 3 2 1 0\"\n</code>\n\
    <|/ a dscore=1 tags=ruby-on-rails-3,ruby-on-rails,ruby,ruby-on-rails-3.2,ruby-on-rails-3.1\
    \ |>\n<| a dscore=1 tags=ruby-on-rails-3,ruby-on-rails,ruby,ruby-on-rails-3.2,ruby-on-rails-3.1\
    \ |>\nOne way is to do it in one line\n<code>\n(1..5).to_s.reverse\n</code>\n\
    <|/ a |>\n<| c |>\nThis is not what op asks for\n<|/ c |>\n<| a dscore=1 |>\n\
    I did this using reverse method as follows:\n<code>\n(1..5).to_s.reverse\n</code>\n\
    <|/ a tags=ruby-on-rails-3,ruby-on-rails,ruby,ruby-on-rails-3.2,ruby-on-rails-3.1\
    \ |>\n<| a tags=ruby-on-rails-3,ruby-on-rails,ruby,ruby-on-rails-3.2,ruby-on-rails-3.1\
    \ |>\n<code>\n(1..5).to_s.reverse\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease\
    \ explain your answer to help future readers, and especially your future self\
    \ when you will post code (even if it's working).\n<|/ c |>\n<| c |>\nThis does\
    \ not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/11775871)\n\
    <|/ c |>\n<| c |>\nThis does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post. -\
    \ [From Review](/review/low-quality-posts/11775871)\n<|/ c |>\n<| c |>\nWhile\
    \ this code may answer the question, it would be better to ", "  return ('0 ..\
    \ ' + n).split(' ')\nend", "  sequence = ''\n  i = 0\n  while i < n\n    sequence\
    \ += (i == 0) ? \"'0' : \" << (i + 1)\n    i += 1\n  sequence\nend", "  (0...n).map\
    \ {|i| '%d' % (i+1)}.join(' ')\nend\n</pre>\n          </div>\n        </div>\n\
    \      </section>\n      <section>\n        <h2 id='functions-to-create-a-vector'>Functions\
    \ to create a vector</h2>\n        <div class=\"section-content\">\n         \
    \ <pre>", "  a = ''\n  while n > 0\n    a << n % 10\n    n /= 10\n  end\n  a\n\
    end", "  ('').tap { |s| ('0'..n).each { |i| s << i.to_s } }\nend", "  s = ''\n\
    \  n.times { s << n }\n  s\nend\n</cell>\n<code language=julia-1.5>", "    numbers\
    \ = Array.new(n) { |i| i }\n    numbers.each { |i| numbers.delete(i) }\n    numbers.each\
    \ { |i| numbers.unshift(i) }\n    numbers.join(' ')\nend", "  number_string =\
    \ ''\n  n.to_s.split('').each do |char|\n    number_string += (char.ord - 96).to_s.rjust(2,\
    \ '0') + ' '\n  end\n  number_string[0...-1]\nend", "  numbers = 0...n\n  numbers.to_s.split.join(\"\
    , \")\nend", "  string = \"\"\n  for i in 0..n do\n    string << i\n  end\n  string\n\
    end", "  a = []\n  until a.length >= n do\n    a.push n\n    n += 1\n  end\n \
    \ a.join(' ')\nend\n</pre>", "  i = 0\n  seq = ''\n  while i < n do\n    seq =\
    \ seq + ((i==0)? 0 : (i % 10) + 1) + ' '\n    i += 1\n  end\n  return seq\nend",
  "  result = ''\n  while n > 0\n    result = \" #{result} #{n}\" if n > 0\n    n\
    \ = n - 1\n  end\n  result\nend", "  string = \"\"\n  while n > 0\n    string\
    \ += \" \"\n    n -= 1\n    string += to_s(n)\n  end\n  string\nend", "  result\
    \ = \"\"\n  for i in 0...n\n    result << \" #{i}\"\n  end\n  result\nend", " \
    \   s = '0'*n\n    s.each_char {|c| s << ' ' + c }\n    s.chomp\nend", "  seq\
    \ = ''\n  while n > 0\n    seq << n % 10\n    n /= 10\n  end\n  seq.reverse\n\
    end", "  a = ''\n  loop do\n    a += n.to_s\n    break unless n -= 1\n  end\n\
    \  a\nend", "  a = []\n  for i in 0...n\n    a << i\n    a.join(\" \")\n  end\n\
    \  a\nend", "  result = ''\n  until result.length < n\n    result = result + \"\
    \ \" + i.to_s\n  end\n  result\nend", "  if n < 0 then\n    return ''\n  else\n\
    \    return string_sequence(n-1) + to_string(n) \n  end\nend", "  s = ''\n  (0..n).each\
    \ { |i| s << i }\n  s\nend\n</cell>\n<cell>", "  s = ''\n  n.times do\n    s <<\
    \ n\n  end\n  s\nend", "  res = []\n  for i in (0...n)\n    res << (i > 0 ? \"\
    \ #{i+1}\" : \"\")\n  end\n  res.join('')\nend", "  numbers = 0..(n-1)\n  numbers.to_s.split(\"\
    \ \").map(&:to_i).join(\" \")\nend", "  seq = []\n  while n > 0\n    seq << n\n\
    \    n -= 1\n  end\n  seq.reverse.inject(\"\") {|s| s + \" \"}\nend", "  return\
    \ 0 .. n\nend\n</code>\n<|/ a |>\n<| c |>\nYou might want to include a link to\
    \ the documentation where this is explained.\n<|/ c |>\n<| c |>\n: added a link\
    \ to where it's explained\n<|/ c |>\n<| a |>\nA very simple solution would be\
    \ to use the each_with_index method of the Array class.\n<code>", "  \"#{n} #{numbers(n)}\"\
    \nend\n</pre>", "  result = ''\n  for i in 0..n\n    result << (i % 10).to_s +\
    \ ' '\n  result[0..n-1]\nend", "  seq = ''\n  while n > 0\n    seq += n.to_s[1..-1]\n\
    \    n -= 1\n  seq\nend", "  result = []\n  for i in 0...n\n    result << number_to_string(i)\n\
    \  result.join(' ')\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n<| c |>\nThis\
    \ is amazing! I'm going to give this a try. Just curious, is it possible to extend\
    \ this to a solution with multiple outputs?\n<|/ c |>\n<| c |>\nWhat do you mean\
    \ by multiple outputs? Just do `[string_sequence(i), string_sequence(j)]` instead\
    \ of `string_sequence(i) + string_sequence(j)` inside the `map` method.\n<|/ c\
    \ |>\n<| c |>\nI'm going to be returning both outputs and then combining them\
    \ in the client using javascript\n<|/ c |>\n<| c |>\nI added a more flexible solution\
    \ that can handle arbitrary numbers of output sequences.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  result = ''\n  while n > 0\n    result = result + (n % 10).to_s\
    \ + ' '\n    n = n / 10\n  end\n  result\nend", "  return '0' + ((' ' * (n - 1)).rjust(n).ljust(n))\n\
    end", "  return '%s %d %d %d %d %d %d' % [ n] * 5 # '0 1 2 3 4 5' is the Python\
    \ way of doing the equivalent of '0 1 2 3 4 5'\nend", "  # Create an array of\
    \ strings with numbers starting from 0 up to n inclusive.\n  # Then join all array\
    \ elements into a string with a space in-between.\n  # return [n.to_s].join(\"\
    \ \")\n  return n.to_s\nend", "  return \"#{0..n}\"\nend", "  a = []\n  n.times\
    \ do\n    a << n\n    n += 1\n  end\n  a.join(' ')\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nJust curious, is there a reason why this should be done differently than\
    \ my original code?\n<|/ c |>\n<| c |>\nI think this would be much slower for\
    \ large integers because the array is copied in each iteration.\n<|/ c |>\n<|\
    \ c |>\nMy original code also creates an array in the first place. Your code does\
    \ not. My code also uses `each_char`. I don't see how the copy is expensive. It's\
    \ also not that expensive to call `join` on an `Array`. So how is it expensive\
    \ to call `join` on a `String`?\n<|/ c |>\n<| c |>\n: I think the point of the\
    \ question was to understand what is the difference between these two versions\
    \ and to understand why the original code does not work. Your code does exactly\
    \ the same thing as the original, so I don't see how it could be faster.\n<|/\
    \ c |>\n<| c |>\nThe original code creates a copy of the array in each iteration.\
    \ That is much more expensive than just appending to a string. Your code avoids\
    \ that copy by not creating an array.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>\n\
    (1..n).to_a.reverse.join(' ')\n</code>\n<|/ a dscore=5 |>\n<| c |>\nOr even `(1..n).reverse_each.join('\
    \ ')`\n<|/ c |>\n<| c |>\nThis seems like the simplest solution to me.  Why reinvent\
    \ the wheel when there's a built-in way to do this?\n<|/ c |>\n<| c |>\n+1: This\
    \ is the most efficient and simplest solution that I found.\n<|/ c |>\n<| c |>\n\
    If `n` is very large, `(1..n).to_a.reverse.join(' ')` will result in a memory\
    \ error.  `(1..n).reverse_each.join(' ')` will result in no memory error but is\
    \ not as performant.  I suspect that `(1..n).to_a.reverse.slice(1..-1).join('\
    \ ')` will perform better than `(1..n).reverse_each.join(' ')`.\n<|/ c |>\n<|\
    \ c |>\n`(1..n).to_a.reverse.reverse.join(' ')` results in `nil`. `(1..n).to_a.reverse.slice(1..-1).join('\
    \ ')` results in `\"1 2 3 4 5\"`.\n<|/ c |>", "  return ('%0' + str(n).rjust(n,\
    \ '0')) + ' % ' + (' ' * n)\nend", "  number_sequence = n.to_s\n  number_sequence.gsub!(/0+/,\
    \ '0')\n  number_sequence.gsub!(/1$/, '1')\n  number_sequence.gsub!(/2$/, '2')\n\
    \  number_sequence.gsub!(/3$/, '3')\n  number_sequence.gsub!(/4$/, '4')\n  number_sequence.gsub!(/5$/,\
    \ '5')\n  number_sequence.gsub!(/6$/, '6')\n  number_sequence.gsub!(/7$/, '7')\n\
    \  number_sequence.gsub!(/8$/, '8')\n  number_sequence.gsub!(/9$/, '9')\n  number_sequence.gsub!(/./,\
    \ ' ')\n  number_sequence\nend", "  n.to_s.split(\" \").join(n.to_s.chars.take(n.to_s.chars.length))\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI really like the string_sequence idea -- it's\
    \ much better than using map in ruby.\n<|/ c |>\n<| c |>\nYes that would work\
    \ too, and is really cool.  And I do like your solution -- very neat.\n<|/ c |>\n\
    <| c |>\nI did a test with 100M iterations and this solution seems to be a bit\
    \ faster: 0.091804 seconds.\n<|/ c |>\n<| c |>\nThe accepted answer is far more\
    \ efficient, but this is pretty cool.\n<|/ c |>\n<| c |>\n: I just noticed that\
    \ `string_sequence(0)` and `string_sequence(1)` return `\"0\"` and `\"1\"` respectively\
    \ whereas `string_sequence(2)` returns `\"0 1\"` -- that is, the \"0\" string\
    \ starts with a space while the other strings do not. So the accepted answer only\
    \ works correctly for `n = 1`\n<|/ c |>\n<| a dscore=2 |>\nIf you're using Rails\
    \ you can use the number_to_phone helper (included in ActionView::Helpers::NumberHelper).\n\
    <|/ a tags=ruby,string |>\n<| a dscore=1 |>\nYou don't need a loop:\n<code>",
  "  numbers = Array.new(n - 1) { '0' }\n  (0...n).each do |i|\n    numbers[i] +=\
    \ 1\n  end\n  numbers.join(' ')\nend", "  a = []\n  a.push \"0\"\n  until a[n]\
    \ == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a[n-1]\n  a.push \" \"\n  until\
    \ a[n] == a[n-1]\n  a.push a[n-1]\n  until a[n] == a", "  a = 0\n  while a <=\
    \ n\n    puts a\n    puts \" \"\n    a += 1\n  end\nend", "  return \"\" if n\
    \ == 0 then 0 else \"#{n} #{string_sequence(n-1)}\"\nend", "  result = []\n  while\
    \ n > 0 do\n    result.concat [\"#{ n-- }\"]\n  end\n  result.concat \"0\"\n \
    \ result\nend", "  str = ''\n  while n > 0\n    str = str + ' ' + to_char(n%10)\n\
    \    n /= 10\n  end\n  return str\nend", "  numbers = (0...n).map { |i| i.to_s\
    \ }\n  numbers.join\nend", "  \"#{n}..#{n+n-1}\"\nend", "  str = \"\"\n  for i\
    \ in 0..n-1\n    str = str + \" \" + i.to_s\n  end\n  str\nend", "  ('0' + ((n\
    \ - 1) % 10))*('0 '+ (n % 10)).to_s + string_sequence(n).slice!(0)\nend", "  #\
    \ Initialize the sequence\n  seq = ''", "\tnumbers = Array.new(n)\n\tnumbers.each_index\
    \ do |i|\n\t\tnumbers[i] = i.to_s\n\tend\n\tnumbers.join(' ')\nend", "  string\
    \ = \"\"\n  while n > 0 do\n    string << to_s(n)\n    n -= 1\n  end\n  string\n\
    end", "  # Return an n space delimited sequence of integers.\n  # >>> string_sequence(0)\n\
    \  # '0'\n  # >>> string_sequence(5)\n  # '0 1 2 3 4 5'\n  return \" \".join('%0*d'\
    \ % (n, n) for n in xrange(n))", "  \"'\" + n.to_s.split(\" \").map { |s| s.to_i\
    \ }.sort.inject(:+).to_s.gsub(/(\\d)(?=(?:\\d{3})+(?!\\d))/) { |a,b| a * 10 +b\
    \ }+\"'\"\nend", "  \"#{sequence(n).join(' ')}\"\nend", "  result = \"\"\n  i\
    \ = 1\n  while i <= n\n    result += i\n    i += 1\n  end\n  result\nend", " \
    \ return n.to_s.split(\" \").map(&:to_i).map(&:to_s)\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nNote that this will give different results when called with 0 as\
    \ an argument.\n<|/ c |>\n<| c |>\n: You're right. Updated to fix that.\n<|/ c\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  result = ''\n  for i in 0..n\n\
    \    result = result + \" \" + i\n  end\n  return result\nend", "  return '0'\
    \ + (n-1).to_s + ' ' + (n-1).to_s\nend", "  result = ''\n  for i in 0..n\n   \
    \ result << i\n    result << ' '\n  end\n  result\nend", "  i = 0\n  s = \"\"\n\
    \  while i < n do\n    s += i\n    i += 1\n  end\n  return s\nend", "  return\
    \ \" \".join(\"0123456789\" * n).strip\nend", "  result = \"\"\n  for i in 0...n\n\
    \    result << \" #{i}\"\n  end\n  result\nend", "  n.zero? ? '0' : (n.to_s.chars.join.(\"\
    \ \").downcase.gsub(/[^0-9]/,''))\nend", "  number_to_string = lambda n: n.to_s\n\
    \  string_to_integer = lambda s: s.to_i\n  number_sequence = (0..n).map { |n|\
    \ number_to_string(n) }\n  number_sequence.join\nend", "  sequence = ''\n  i =\
    \ 0\n  while i <= n\n    sequence << i\n    i += 1\n  end\n  sequence\nend", " \
    \ \"#{n} #{string_sequence(n-1).join(' ')}\"\nend", "  a = (0...n).map {|i| \"\
    #{i}\"}.join(' ')\n  a\nend", "  string = ''\n  while n > 0\n    string += n %\
    \ 10\n    n /= 10\n  end\n  return string\nend", "  a = []\n  i = 0\n  while i\
    \ < n\n    a << i\n    i += 1\n  a.join(' ')\nend", "  number_string = \"\"\n\
    \  for i in 1..n\n    number_string += \"#{i} \"\n  end\n  number_string\nend",
  "  string = ''\n  n.times { string << \" #{n}\" }\n  string\nend", "  n1 = (\"%.d\"\
    \ % n).to_i\n  a = ['%d' % n1]\n  a.reject! { |x| x.include?('0') }\n  a.join\n\
    end", "  numbers = []\n  i = 0\n  while i <= n\n    numbers.push(i, i+1)\n   \
    \ i += 1\n  end\n  numbers.join(' ')\nend", "  seq = \"\"\n  for i in 1..n\n \
    \   seq << \" \" << i\n  end\n  seq\nend", "  return nil if n < 1 || n > 10\n\
    \  ret = ''\n  10.upto(n) do |i|\n    ret = i.to_s + ' ' + ret\n  end\n  return\
    \ ret\nend\n</pre>\n<h3><a href=\"http://www.ruby-doc.org/stdlib/libdoc/csv/rdoc/CSV.html\"\
    >CSV</a> </h3>\n<pre class=\"example\">", "  n.to_s.split(\" \").collect(&:to_i)\n\
    end", "  result = ''\n  n.times { result << n }\n  result\nend", "  i = 0\n  str\
    \ = n.to_s\n  str.sub!(/(\\d+)/) { |s| i++ if s.gsub(/\\s+/, '').empty? }.to_s\n\
    \  str\nend", "  return \" \".join('%03d' % n for n in sequence(n).to_a)\nend",
  "  str = ''\n  for i in 0..(n-1)\n    str << i\n    str << ' '\n  end\n  str\nend",
  "\tstring = ''\n\tfor i in 0..n\n\t\tstring += i\n\t\tstring += ' '\n\tend\n\tstring[0..n-1]\n\
    end", "  return n.to_s.rjust(max_length, \"0\")\nend", "  n.times do\n    yield\
    \ '0'\n  end\n  n.times do |i|\n    yield '%d' % (i+1)\n  end\nend", "  result\
    \ = \"\"\n  for i in 0..n-1\n    result += i.to_s\n    result += \" \"\n  result\
    \ += \"#{n}\"\n  result\nend", "  seq = '%s' % n\n  i = 0\n  while i < seq.length\n\
    \    seq = seq[ 0...i ] + ' ' + ( i == 0 ? \"\" : seq.slice( i, i+1 ) )\n    i\
    \ += 1\n  end\n  return seq\nend", "  result = ''\n  for i in 0...n\n    result\
    \ << ' ' + (i+1).to_s\n  end\n  result\nend", "  return \"#{n} #{n+1} #{n+2}\"\
    \nend\n</pre>\n</li>\n</ul>\n<h2>\n<a name=\"Getting%20Started%20with%20Blackberry_5a_deploy_to_simulator\"\
    >5B. Deploy to Simulator</a>\n</h2>", "  result = '' \n  (0...n).each { |i| result\
    \ << i }\n  result\nend", "  a = []\n  n.times do |x|\n    a << x.to_s\n  end\n\
    \  a.join(' ')\nend", "  n = n.to_i\n  return ((n % 10 == 0).to_s + \" \" + \n\
    \          string_sequence(n / 10).to_s + \" \" +\n          ((n % 10 != 0).to_s\
    \ + \" \" + \n           string_sequence(n / 10).to_s).to_s).to_s\nend", "  s\
    \ = ''\n  loop do\n    s = s << ' '\n    break if n <= 0\n    n -= 1\n  end\n\
    \  s.rstrip\nend", "  \"0 1 2 3 4 #(n - 1)\"\n  a = []\n  for i in range(n) a\
    \ << i\n  a.join(' ')\nend", "  return ((1..n).map {|i| '%d' % i}).join(' ')\n\
    end", "  s = '0'\n  while n > 0\n    s = n.to_s + ' ' + s\n    n -= 1\n  end\n\
    \  return s\nend", "  seq = ''\n  n.times do |x|\n    seq << x\n  end\n  seq\n\
    end", "  return \"#{0.upto(n).map{|i| i.to_s}.inspect}\"\nend", "  result = ''\n\
    \  for i in 0..n do\n    result << ' ' << i.to_s\n  end\n  result\nend", "  seq\
    \ = \"\"\n  for i in 1..n\n    seq = seq + \" \" + i\n  end\n  seq\nend", "  n.to_s.split('').join('\
    \ ') + (' ' + string_sequence(n+1))\nend", "  n.to_s.split(\" \").map {|x| x.to_i}.join\n\
    end", "  i = 0\n  result = \"\"\n  while i < n\n    result << (i % 10).to_s +\
    \ \" \"\n    i += 1\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby\
    \ |>\nI wrote a recursive solution which might not be the most efficient but it's\
    \ easy to understand and understandable for me:\n<code>", "  # TODO: Write the\
    \ string sequence.\nend\n</pre>", "  return \"#{n} \" * n\nend\n</pre>", "  return\
    \ n.to_s.each_char.inject(\"\") { |s,c| s+(c==\" \" ? \"0 \" : c.to_s+\" \") }\n\
    end\n</pre>\n<p>And here is how <code>string_sequence</code> is implemented:</p>\n\
    <pre class=\"programlisting\">", "  a = []\n  for i in 0..(n-1).to_a\n    a.push(i.to_s)\n\
    \  end\n  return a.join(\" \")\nend", "\tsequence = ''\n\tfor i in 0..n\n\t\t\
    sequence += i.to_s(10)\n\tend\n\treturn sequence\nend", "  return ('0 .. ' +.to_s\
    \ + (n-1).to_s).rjust(n*2, ' ')\nend", "  s = ''\n  while n > 0 do\n    s = s\
    \ << 1 until n & 1\n    n >>= 1\n  end\n  s\nend\n</code>\n<|/ a |>\n<| a tags=ruby,algorithm,ruby-on-rails\
    \ dscore=3 |>\nI love the String#repeated_permutation answer, but this one may\
    \ be a bit easier to follow:\n<code>", "  (0...n).map { |x| x + ' ' }.join('')\n\
    end", "  s = ''\n  i =0 while i<n do s= s + i.to_s + ' '; i+=1\n  s\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails dscore=0 |>\n<| a dscore=0 |>\nAh! I missed the\
    \ Rails part :) That said, I believe that all you need is a simple loop:\n<code>",
  "  s = ''\n  i = 0\n  while i < n\n    s = s << 1\n    s << i\n    i += 1\n  end\n\
    \  s\nend", "  str = ''\n  i = 0\n  while i < n\n    str << i\n    i += 1\n  end\n\
    \  str\nend", "  # We assume that the input is an integer and that its value falls\
    \ between 0 and n.\n  return '\\n'.join(('%2d' % i) for i in xrange(n))\nend\n\
    </cell>\n<code language=julia-1.5>\nstring_sequence(3)\n</cell>\n<code language=julia-1.5>\n\
    string_sequence(10)\n</cell>\n<code language=julia-1.5>\nstring_sequence(17)\n\
    </cell>\n<text>\nWhat if the function is more interesting?\nLet's say we want\
    \ to convert an array of integers into an array of strings of length n where each\
    \ string contains the numbers with leading zeros.", "  result = ''\n  i = 0\n\
    \  while i < n\n    result << ' '\n    i += 1\n  end\n  return result\nend", " \
    \ return \"#{n} \" + ((1..n).to_a.join(' ')).to_s\nend", "  result = ''\n  for\
    \ i in 0..(n-1).to_s\n    result += i.to_s + ' '\n  end\n  result\nend", "  n\
    \ = (n % 10).zero? ? 10 : (n % 10).to_i + 1 # Normalize n to an integer in 0..10\
    \ range.\n  s.join.to_s.reverse.gsub(\"\\\\\", '').gsub(\",\", '')\nend", "  s\
    \ = '0'\n  (1..n).each do |i|\n    s << ' #{i}'\n  end\n  s\nend", "  str = ''\n\
    \  (0...n).each do |i|\n    str << \" #{i}\"\n  end\n  str\nend\n</code>\nThen\
    \ you can call string_sequence(5) as:\n<code>\n> string_sequence(5)\n => \"0 1\
    \ 2 3 4 5\"\n</code>\nAnd to reverse the order of sequence you just call reverse:\n\
    <code>\n> string_sequence(5).reverse\n => \"5 4 3 2 1 0\"\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nYou don't need to use `+` on `str`. Just `str << \" \"` will do.\n\
    <|/ c |>\n<| a tags=string,ruby |>\nThe accepted answer is not working in Rails\
    \ console. So,\n<code>\n>> \"12345\".reverse\nNoMethodError: undefined method\
    \ `reverse' for \"12345\":String\n    from (irb):1\n    from /home/abhishek/.rvm/gems/ruby-2.4.0/gems/railties-5.0.0.1/lib/rails/commands/console.rb:65:in\
    \ `start'\n    from /home/abhishek/.rvm/gems/ruby-2.4.0/gems/railties-5.0.0.1/lib/rails/commands/console_helper.rb:9:in\
    \ `start'\n    from /home/abhishek/.rvm/gems/ruby-2.4.0/gems/railties-5.0.0.1/lib/rails/commands/commands_tasks.rb:78:in\
    \ `console'\n    from /home/abhishek/.rvm/gems/ruby-2.4.0/gems/railties-5.0.0.1/lib/rails/commands/commands_tasks.rb:49:in\
    \ `run_command!'\n    from /home/abhishek/.rvm/gems/ruby-2.4.0/gems/railties-5.0.0.1/lib/rails/commands.rb:18:in\
    \ `<top (required)>'\n    from /home/abhishek/.rvm/gems/ruby-2.4.0/gems/railties-5.0.0.1/lib/rails/app_rails_loader.rb:53:in\
    \ `require'\n    from /home/abhishek/.rvm/gems/ruby-2.4.0/gems/railties-5.0.0.1/lib/rails/app_rails_loader.rb:53:in\
    \ `block in exec_app_rails'\n    from /home/abhishek/.rvm/gems/ruby-2.4.0/gems/railties-5.0.0.1/lib/rails/app_rails_loader.rb:32:in\
    \ `loop'\n    from /home/abhishek/.rvm/gems/ruby-2.4.0/gems/railties-5.0.0.1/lib/rails/app_rails_loader.rb:32:in\
    \ `exec_app_rails'\n    from /home/abhishek/.rvm/gems/ruby-2.4.0/gems/railties",
  "  return '0' + ((n == 0) ? [] : [n] + string_sequence(n - 1))\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThis answer is very helpful, but I still don't understand why\
    \ you're doing `'0' + ([n] + string_sequence(n - 1))`. I understand `[n] + string_sequence(n\
    \ - 1)` but I don't understand why you're adding that string back to `'0'`.\n\
    <|/ c |>\n<| c |>\n`[n]` is an array with the `n` elements of the `string_sequence(n\
    \ - 1)` array. `[].concat(string_sequence(n - 1)) == [n]`. So, the array `[n]`\
    \ becomes an array of strings with one element: `[n][0]`.\n<|/ c |>\n<| c |>\n\
    `[n]` is an array of one element. `[n]` is an array. `[n][0]` is an array. `[n][0]`\
    \ is an array. `[n][0][0]` is an array.\n<|/ c |>\n<| c |>\nI guess I was confused\
    \ by why you were adding `[n]` to `'0'`. I thought that `[n]` was an array of\
    \ one element. Now it makes sense to me.\n<|/ c |>\n<| c |>\n`[n]` is an array.\
    \ `[n][0]` is an array. `[n][0][0]` is an array. `[n][0][0]` is an array. `[n][0][0][0][0]`\
    \ is an array. `[n][0][0][0][0][0][0]` is an array. `[n][0][0][0][0][0][0][0][0]`\
    \ is an array. `[n][0][0][0][0][0][0][0][0][0][0]` is an array. `[n][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]`\
    \ is an array. `[n][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]",
  "  seq = ''\n  while n > 0\n    seq = seq + rand(10).to_s(10)\n    n = n - 1\n \
    \ end\n  seq\nend", "  res = []\n  i = n\n  while i > 0 do\n    res.push i.to_s\n\
    \    i -= 1\n  end\n  res.reverse # reverse\n  res.join(' ')\nend", "  return\
    \ \"0\" * n\nend", "  (1..n).reduce(:+).to_s\nend", "  str = ''\n  (0..(n-1)).each\
    \ do |i|\n    str << (i==0 ? \"0\" : \" #{i}\")\n  end\n  str\nend", "  return\
    \ n.times.map { |x| x.to_s }.join(' ')\nend", "  return '%d%s' % [n, *string_sequence(n\
    \ + 1)]\nend", "  result = \"\"\n  for i in 0...n\n    result = result + \" \"\
    \ + to_s(i)\n  result\nend", "  s = ''\n  n.times do |n|\n    s << n.to_s\n  \
    \  s << ' '\n  end\n  s[0,s.length-1]\nend", "  s = ''\n  for i in 1..n\n    s\
    \ = s << (i-1).to_s + ' ' + (i).to_s\n  end\n  s\nend", "  string = ''\n  (1..n).each\
    \ do |i|\n    string += i.to_s\n  end\n  return string\nend", "  # Create an array\
    \ to store the numbers in\n  sequence = []\n  # Go from 0 to n\n  (1..n).each\
    \ do |i|\n    # Append the number\n    sequence << i\n  end\n  # Join the array\
    \ into a string\n  sequence.join ' '\nend", "  i=1\n  result=\"\"\n  while i<=n\n\
    \    result=result+\" \"+i\n    i=i+1\n  end\n  result\nend", "  s = ''\n  i =\
    \ 0\n  while i < n\n    s = s << 1 + i\n    i += 1\n  end\n  s\nend", "  # Return\
    \ a string containing space-delimited numbers starting from 0 upto n inclusive.\n\
    \  # >>> string_sequence(0)\n  # '0'\n  # >>> string_sequence(5)\n  # '0 1 2 3\
    \ 4 5'\n  return \"#{n * (n+1)}\"\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
