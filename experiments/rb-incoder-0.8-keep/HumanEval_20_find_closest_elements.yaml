name: HumanEval_20_find_closest_elements
language: rb
prompt: "# From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n# other and return them in order (smaller number,\
  \ larger number).\n# >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
  # (2.0, 2.2)\n# >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# (2.0,\
  \ 2.0)\ndef find_closest_elements(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n\
  \    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0,\
  \ 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2,\
  \ 3.1, 4.1, 5.1]))\n  end\nend\n"
completions: ["  numbers.each do |number|\n    lower = number\n    higher = number\n\
    \    while higher > lower\n      mid = (lower + higher) / 2\n      break if number\
    \ == mid\n      higher = mid\n    end\n    break if number == lower\n    break\
    \ if number == higher\n  end\n  [lower, higher]\nend", "  return numbers.sort.each_cons(2).find\
    \ { |a, b| \n    a.abs <= b.abs and a < b\n  }\nend", "  numbers_to_return = []\n\
    \  smallest_number = numbers.first\n  smallest_index = nil\n  numbers.each_with_index\
    \ do |number, index|\n    smallest_number = number if smallest_number > number\n\
    \    smallest_index = index if smallest_number > numbers[index]\n  end\n  smallest_index.upto(numbers.size-1)\
    \ do |index|\n    numbers_to_return << numbers[index]\n  end\n  numbers_to_return\n\
    end", "  smallest, largest = numbers[0], numbers[0]\n  numbers.each do |num|\n\
    \    next if num == smallest\n    next if num == largest\n    if num < smallest\
    \ || num > largest\n      smallest = num\n      largest = num\n    end\n  end\n\
    \  return [smallest, largest]\nend\n</code>\nIt works by iterating over the array\
    \ and keeping track of two values: smallest and largest. If an element is encountered\
    \ that is larger than both the smallest and largest, the largest becomes smallest,\
    \ and vice versa. If a larger value is encountered that is larger than the smallest\
    \ value, the smallest becomes that value. In the end the smallest and largest\
    \ values are returned in order.\n<|/ a |>\n<| c |>\nThis was very helpful and\
    \ worked perfectly for me.\n<|/ c |>\n<| a dscore=3 |>\n<code>", "  return [\n\
    \    numbers.first - numbers[0..numbers.index{|n| n <= number}].max,\n    numbers[numbers.index{|n|\
    \ n <= number}..-1].max\n  ]\nend", "  minimum = numbers.min\n  maximum = numbers.max\n\
    \  minimum_index = 0\n  maximum_index = 0", "  numbers.each_with_index do |n,\
    \ i|\n    minimum = numbers[i - 1]\n    maximum = numbers[i + 1]\n    minimum_index\
    \ = i - 1\n    maximum_index = i + 1\n    if minimum == maximum\n      return\
    \ minimum, minimum\n    end\n    if minimum > maximum\n      minimum_index, maximum_index\
    \ = maximum_index, minimum_index\n      maximum, minimum = minimum, maximum\n\
    \    end\n    if minimum > n\n      minimum_index = i\n    end\n    if maximum\
    \ < n\n      maximum_index = i\n    end\n    minimum, maximum = minimum_index,\
    \ maximum_index if minimum_index >= maximum_index\n  end\n  return nil, nil\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThanks for the great answer! Do you have an idea\
    \ how to make it with arrays, too? I tried to edit it to work with arrays but\
    \ I failed.\n<|/ c |>\n<| c |>\nI edited my answer to include a solution for an\
    \ array. I'll try to post an explanation.\n<|/ c |>\n<| c |>\nThanks for your\
    \ efforts. I upvoted your answer. :-) But your solution does not work well with\
    \ my arrays. I tried it with `[2.5, 3.0, 1.9, 3.5, 4.5, 2.2]` and it returned\
    \ `[3.0, 2.2]` which is not the correct answer.\n<|/ c |>\n<| c |>\nYou're right,\
    \ I did not test it with arrays. I'll edit the answer to correct this bug.\n<|/\
    \ c |>\n<| c |>\nI've made a couple of edits to my answer. Feel free to roll them\
    \ back if you think they are incorrect. :-)\n<|/ c |>\n<| a |>\nAs far as I understand,\
    \ you want to return the pair of numbers such that they differ by no more than\
    \ the given amount\nSo we have:", "  smallest_difference = numbers[1] - numbers[0]\n\
    \  second_smallest_difference = numbers[-1] - numbers[-2]\n  smallest_difference,\
    \ second_smallest_difference, numbers[0], numbers[-1] = second_smallest_difference,\
    \ smallest_difference, numbers[0], numbers[-1]\n  numbers.sort!\n  \n  result\
    \ = [numbers[0], numbers[-1]]\n  \n  numbers.each_with_index do |number, index|\n\
    \    difference = numbers[index] - number\n    if difference < smallest_difference\n\
    \      result[0] = number\n      smallest_difference = difference\n    elsif difference\
    \ > second_smallest_difference\n      result[-1] = number\n      second_smallest_difference\
    \ = difference\n    end\n  end\n  \n  result\nend", "  numbers_sorted = numbers.sort\n\
    \  smallest_number = numbers_sorted.first\n  largest_number = numbers_sorted.last\n\
    \  smallest_number = smallest_number.to_f\n  largest_number = largest_number.to_f\n\
    \  if smallest_number == largest_number\n    [smallest_number, largest_number]\n\
    \  else\n    [\n      largest_number - smallest_number,\n      smallest_number\
    \ - smallest_number,\n      largest_number,\n      smallest_number\n    ]\n  end\n\
    end", "  numbers.sort!\n  result = nil\n  \n  first = numbers[0]\n  last = numbers[numbers.length-1]\n\
    \  if numbers.count >= 2\n    numbers.each_with_index do |number, index|\n   \
    \   result = number\n      break if index == (numbers.count - 1)\n      result\
    \ = numbers[index+1] if number > numbers[index+1]\n    end\n  end\n  \n  return\
    \ [first, result] if first  < result\n  return [result, last]  if result < last\n\
    \  return [first, last] if first > last\n  \n  nil\nend", "  smallest_difference\
    \ = numbers[0] - numbers[1]\n  smallest_index = 0\n  second_smallest_difference\
    \ = numbers[0] - numbers[1]\n  second_smallest_index = 1\n  \n  smallest_difference_index\
    \ = 0\n  second_smallest_difference_index = 1", "  numbers.each_with_index do\
    \ |number, i|\n    distance = current_number - number\n    if distance <= 0\n\
    \      smallest_number = number\n      largest_number = number\n    elsif distance\
    \ > 0\n      smallest_number = current_number\n      largest_number = number\n\
    \    end\n    current_number = number\n  end\n  [smallest_number, largest_number]\n\
    end", "  smallest, largest = numbers[0], numbers[-1]\n  for i in 1...numbers.count\n\
    \    smallest, largest, element = smallest, numbers[i], numbers[i - 1]\n    if\
    \ element > smallest and element > largest\n      smallest, largest = element,\
    \ smallest\n      smallest, largest = smallest, largest\n    end\n  end\n  [smallest,\
    \ largest]\nend", "  smallest_diff = 10**20\n  smallest_number = nil\n  current_smallest\
    \ = nil\n  biggest_diff = 10**20\n  biggest_number = nil\n  current_biggest =\
    \ nil\n  \n  numbers.each do |number|\n    if current_smallest == nil || number\
    \ < current_smallest\n      current_smallest = number\n    end\n    \n    if current_biggest\
    \ == nil || number > current_biggest\n      current_biggest = number\n    end\n\
    \    \n    diff = (number - current_smallest)\n    if diff < smallest_diff\n \
    \     current_smallest = number\n      smallest_diff = diff\n    end\n    \n \
    \   diff = (number - current_biggest)\n    if diff > biggest_diff\n      current_biggest\
    \ = number\n      biggest_diff = diff\n    end\n  end\n  \n  [current_smallest,\
    \ current_biggest]\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\nSince you seem to\
    \ always want to find the closest to the center of the array I suggest the following\
    \ solution\n<code>", "  numbers.each_with_index do |num, i|\n    closest_num =\
    \ numbers.find_index {|num2| num2 < num}\n    if closest_num != i\n      closest_num\
    \ = i\n    end\n    return num, numbers[closest_num]\n  end\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nI like the ruby approach but it has three bugs: `if closest_num\
    \ != i`, should be `if closest_num == i`, shouldn't `closest_num >= numbers[closest_num]\
    \ or closest_num == numbers[closest_num] and numbers[closest_num] > num` be `numbers[closest_num]\
    \ <= num` or something else?  And `closest_num != numbers[closest_num]` should\
    \ be `closest_num == numbers[closest_num]`\n<|/ c |>\n<| c |>\nSorry.  There were\
    \ two typos.  I tested it and it works.  The main thing I fixed was the two bugs\
    \ mentioned in the comments.\n<|/ c |>\n<| c |>\nI ran this with `numbers = [1.2,2.5,4.4,5.1,7.8,9.9,10.8,11.3,11.4,11.5,11.6,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,11.7,",
  "  numbers.sort { |a,b| a<=>b }\n  numbers[0], numbers[1]\nend", "  if numbers.count\
    \ < 2\n    numbers = numbers.sort { |a,b| a <=> b }\n    numbers = numbers[0...1]\n\
    \    return numbers[0], numbers[0]\n  end", "    numbers.each_with_index do |num,\
    \ index|\n        min_idx = index\n        max_idx = index + 1\n        break\
    \ if numbers.size == index + 1\n        break if max_idx > numbers.size - 1\n\
    \        break if min_idx > numbers.size - 1\n        if numbers[index] > numbers[max_idx]\
    \ || numbers[index] < numbers[min_idx]\n          max_idx = index\n        end\n\
    \        if numbers[index] < numbers[min_idx]\n          min_idx = index\n   \
    \     end\n      end\n      return numbers[min_idx], numbers[max_idx]\n    end\n\
    end", "  return numbers.zip(numbers).reject { |a,b| a < b }.map { |a,b| [a, b]\
    \ }.sort_by { |el| el[0] }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nGood point.\
    \  It seems like he should use something like a binary search (`http://en.wikipedia.org/wiki/Binary_search_algorithm`)\
    \ to find the \"closest\" element to the point that the element would fall into.\n\
    <|/ c |>\n<| c |>\nThat's not really what he wants. He wants a sorted array of\
    \ the two closest numbers so he doesn't have to iterate over every element. There\
    \ are algorithms for doing this faster, but he seems to want to know how to do\
    \ it in O(n), not O(log n).\n<|/ c |>\n<| c |>\n, you're right, I didn't see that\
    \ in the OP's question.  I should have read the question more carefully.\n<|/\
    \ c |>\n<| a dscore=2 tags=ruby |>\n<code>", "  mindiff = []\n  mindiff.push numbers[0]\n\
    \  mindiff.push numbers[1]\n  mindiff.push numbers[1]\n  mindiff.push numbers[0]",
  "  # Sort the list so that smaller elements are first, then larger elements.\n \
    \ numbers.sort!", "  smallest = numbers[0]\n  largest = numbers[0]\n  smallest_index\
    \ = nil\n  largest_index = nil\n  index = 0\n  numbers.each do |number|\n    if\
    \ smallest.nil?\n      smallest = number\n      smallest_index = index\n     \
    \ index = index + 1\n    elsif largest.nil?\n      largest = number\n      largest_index\
    \ = index\n    end\n    if number < smallest\n      smallest = number\n      smallest_index\
    \ = index\n    end\n    if number > largest\n      largest = number\n      largest_index\
    \ = index\n    end\n    index = index + 1\n  end\n  return (smallest, largest)\n\
    end\n</code>\n<|/ a tags=ruby-on-rails,ruby |>\n<| c |>\nFor me, it looks like\
    \ this doesn't give the correct output with numbers: [1,4,5,7] or [100,101,102]\
    \ but rather [1,100,101] or [100,101,102,103]\n<|/ c |>\n<| c |>\nI think OP wants\
    \ to find the two numbers that are closest to each other.\n<|/ c |>\n<| c |>\n\
    The OP says he wants to find the \"closest\" two. Thus my answer. The only other\
    \ thing I could think of was to find the absolute difference between each pair\
    \ of numbers and then find the two with the lowest absolute difference.\n<|/ c\
    \ |>\n<| c |>\nThe OP says he wants to find the closest two. \"the two numbers\
    \ that are closest to each other\" means \"the two numbers that are closest to\
    \ each other and in the order of the original list\"\n<|/ c |>\n<| c |>\n: Yes,\
    \ I saw that. Now I realize my misunderstanding. I've updated my answer.\n<|/\
    \ c |>\n<| a |>\n<code>", "  # Initialize the result\n  min_dist = Float::INFINITY\n\
    \  min_elements = []\n  max_elements = []\n  \n  numbers.each do |element|\n \
    \   distance = calculate_distance(element)\n    if distance < min_dist\n     \
    \ min_dist = distance\n      min_elements = [element]\n    elsif distance > min_dist\n\
    \      max_elements = [element]\n    end\n  end\n  \n  return min_elements, max_elements\n\
    end", "  first_number, second_number = numbers[0..-2]\n  numbers.sort! # Sort\
    \ the elements of the list.\n  return first_number, second_number\nend", "  minimum_difference\
    \ = (numbers[0].to_f + numbers[1].to_f) / 2\n  numbers[0], numbers[1] = numbers[1],\
    \ numbers[0]\n  min_element = numbers.first\n  max_element = numbers.last\n  while\
    \ numbers.any?\n    current = numbers.shift\n    difference = (current - min_element).abs\n\
    \    if difference < minimum_difference\n      minimum_difference = difference\n\
    \      min_element = current\n    else\n      maximum_difference = (max_element\
    \ - current).abs\n      break if maximum_difference < minimum_difference\n   \
    \   numbers[0], numbers[1] = numbers[1], numbers[0]\n    end\n  end\n  return\
    \ [min_element,max_element]\nend", "    numbers.sort!\n    (numbers[0], numbers[1])\n\
    end", "  minimum = numbers.min\n  maximum = numbers.max\n  if minimum > maximum\n\
    \    minimum, maximum = maximum, minimum\n  index = (numbers - minimum).abs.argmin\n\
    \  selected = numbers[index]\n  return selected, numbers[index]\nend\n</code>\n\
    Here are some benchmark tests against the two answers provided by Daniel Schreiner\
    \ above:\n<code>\nrequire 'benchmark'", "  # Sort the numbers in ascending order\n\
    \  numbers.sort!\n  # Initialize two variables\n  smallest = 0.0\n  largest =\
    \ numbers[0]\n  # Find the two closest numbers to eachother in the sorted list\n\
    \  numbers.each_with_index { |number, i|\n    if (i < numbers.length - 1)\n  \
    \    smallest = number\n      largest = numbers[i + 1]\n    end\n  }\n  # Return\
    \ the two numbers\n  return [smallest, largest]\nend", "\tnumbers = numbers.sort",
  "  if numbers.length < 2\n    raise \"Not enough numbers in array\"\n  smallest\
    \ = numbers.shift\n  largest = numbers.shift\n  numbers.each do |number|\n   \
    \ if smallest.abs < number.abs\n      smallest = number\n    elsif largest.abs\
    \ > number.abs\n      largest = number\n    end\n  end\n  [smallest, largest]\n\
    end", "  return numbers.min {|a, b| b<=>a}.zip(numbers.max) {|a, b| (b-a).abs<=>1}.sort\n\
    end", "  numbers.minmax\n  smallest = numbers[0]\n  largest = numbers[-1]\n  smallest_num\
    \ = numbers[1]\n  numbers[1] = largest\n  largest = numbers[-1]\n  numbers[-1]\
    \ = smallest\n  numbers = numbers.sort\n  numbers.minmax\n  [smallest_num, largest]\n\
    end\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| a |>\n<code>", "  # Sort\
    \ the list from the biggest to the smallest\n  numbers.sort!\n  # Use integer\
    \ division so as to not loose any precision\n  quotient = numbers[0] / numbers[1]\n\
    \  \n  if quotient < 0.5\n    return numbers[1], numbers[0]\n  else\n    return\
    \ numbers[0], numbers[1]\n  end\nend", "  numbers.each_with_index do |number,\
    \ index|\n    smallest_distance = number\n    if index == 0\n      smallest_distance\
    \ = numbers[index-1]\n    end\n    smallest_distance = number\n    smallest_distance_index\
    \ = index\n    numbers.each do |number|\n      distance = number - smallest_distance\n\
    \      if distance < smallest_distance\n        smallest_distance = number\n \
    \       smallest_distance_index = index\n      end\n    end\n    yield smallest_distance,\
    \ smallest_distance_index\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,sorting,mathematical-optimization\
    \ |>\nIt appears you want to find the closest pair of numbers. An O(N^2) algorithm\
    \ to solve this problem would be to try all possible pairs and find the smallest\
    \ difference in their absolute values. To find the smallest difference in absolute\
    \ values you need to define a custom comparison method and pass it to the sort\
    \ method:\n<code>", "  return find_closest_elements_between(numbers, 0)\nend",
  "  smallest_diff = numbers[0] - numbers[1]\n  smallest_number = numbers[0]\n  largest_number\
    \ = numbers[1]\n  numbers[0].downto(numbers[1]) do |number|\n    diff = number\
    \ - numbers[1]\n    smallest_diff = (smallest_diff < diff) ? smallest_diff : diff\n\
    \    smallest_number = smallest_number < number ? smallest_number : number\n \
    \   largest_number = largest_number > number ? largest_number : number\n  end\n\
    \  smallest_number\nend", "  # Return one that is closest to all\n  return numbers[numbers.min\
    \ { |x| numbers.max - x == x }]\nend", "  numbers.each_with_index do |number,\
    \ idx|\n    idx = (idx - 1) % numbers.length\n    next numbers[idx] if numbers[idx]\
    \ > number\n    numbers[idx], numbers[(idx + 1) % numbers.length] = number, numbers[idx]\n\
    \  end\n  return numbers[0...numbers.length/2]\nend\n</code>\n<|/ a dscore=2 tags=ruby,arrays\
    \ |>\n<| a |>\nOne more approach:\n<code>\nnumbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]",
  "  numbers.sort!\n  return numbers[0..-2].min, numbers[0..-2].max\nend", "  if numbers.count\
    \ < 2\n    raise ArgumentError, \"There must be at least two numbers to compare\"\
    \n  else\n    numbers.sort!\n    smallest_value = numbers[0]\n    second_smallest_value\
    \ = numbers[1]\n    third_smallest_value = numbers[2]\n    fourth_smallest_value\
    \ = numbers[3]\n    smallest_index = 0\n    second_smallest_index = 1 unless second_smallest_value.nil?\n\
    \    third_smallest_index = 2 unless third_smallest_value.nil?\n    fourth_smallest_index\
    \ = 3 unless fourth_smallest_value.nil?\n    \n    while smallest_index < numbers.count\
    \ - 1\n      smallest_index += 1\n      current_value = numbers[smallest_index]\n\
    \      \n      if current_value == second_smallest_value\n        return numbers[smallest_index],\
    \ numbers[second_smallest_index]\n      elsif current_value == third_smallest_value\n\
    \        return numbers[smallest_index], numbers[third_smallest_index]\n     \
    \ elsif current_value == fourth_smallest_value\n        return numbers[smallest_index],\
    \ numbers[fourth_smallest_index]\n      end\n    end\n    \n    return numbers[smallest_index],\
    \ numbers[smallest_index]\n  end\nend", "  sorted_numbers = numbers.sort\n  \n\
    \  diff = sorted_numbers.last - sorted_numbers.first\n  \n  if diff == 0.0\n \
    \   diff = sorted_numbers[1] - sorted_numbers[0]\n  \n  a = sorted_numbers.first\n\
    \  b = sorted_numbers.last\n  \n  if diff > 0.0\n    \n    while a < b\n     \
    \ if a > sorted_numbers[1]\n        a = sorted_numbers[1]\n      elsif b > sorted_numbers[0]\n\
    \        b = sorted_numbers[0]\n      else\n        sorted_numbers.shift\n   \
    \     sorted_numbers.shift\n        break\n      end\n    end\n    \n    return\
    \ a, b\n    \n  elsif diff < 0.0\n    \n    while a > b\n      if b > sorted_numbers[1]\n\
    \        b = sorted_numbers[1]\n      elsif a < sorted_numbers[0]\n        a =\
    \ sorted_numbers[0]\n      else\n        sorted_numbers.shift\n        sorted_numbers.shift\n\
    \        break\n      end\n    end\n    \n    return a, b\n  end\n  \n  elsif\
    \ sorted_numbers.length < 2\n    return numbers[0], numbers[0]\n  end\nend\n</cell>\n\
    <code language=julia-1.5>\nfind_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
    </cell>\n<code language=julia-1.5>\nfind_closest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0])\n</cell>\n<code language=julia-1.5>\nfind_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.1])\n</cell>\n<code language=julia-1.5>\nfind_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.1])\n</cell>\n<code language=julia-1.5>\nfind_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n</cell>\n<code language=julia-1.5>\nfind_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n</cell>\n<code language=julia-1.5>\nfind_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.1])\n</cell>\n<code language=julia-1.5>\nfind_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.1])\n</cell>\n<code language=julia-1.5>\nfind_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n</cell>\n<code language=julia-1.5>\nfind_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n</cell>\n<code language=julia-1.5>\nfind_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n</cell>\n<code language=julia-1.5>\nfind_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n</cell>\n<code language=julia-1.5>\nfind_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.1])\n</cell>\n", "  # Initialize smallest_number to first\
    \ number\n  smallest_number = numbers[0]\n  second_smallest_number = numbers[1]",
  "  return numbers.sort do |n1, n2|\n    n1 > n2 ? -1 : 1\n  end\nend", "    numbers.each_with_index\
    \ {|x,i| (@sorted_numbers[i]=x) }\n    \n    return nil if numbers.empty?\n  \
    \  \n    min_diff = numbers[1].abs\n    \n    numbers.each_with_index do |x,i|\n\
    \        diff = x.abs\n        next if diff == 0\n        \n        diff = diff\
    \ if diff < min_diff\n        min_diff = diff\n        \n        @sorted_numbers.delete_at(@sorted_numbers.rindex(min_diff))\n\
    \        @sorted_numbers.insert(i, x)\n    end\n    \n    return @sorted_numbers[1..@sorted_numbers.size\
    \ - 1]\nend", "  minimum_distance = numbers[0]\n  minimum_number = numbers[0]\n\
    \  maximum_number = numbers[0]", "  numbers.each do |num|\n    next unless num\n\
    \    closest_index = numbers.index(num) + 1 \n    closest_number = numbers[closest_index]\
    \ unless closest_index.zero?\n    next if closest_index == numbers.size && numbers.size\
    \ > 1\n    return closest_number, num\n  end\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Nicely done. I was going to suggest using `sort_by` but this isn't O(n log n).\
    \ I'd recommend using `min_by` instead (although `min_by` requires Ruby 1.8+ so\
    \ you'll need to `sort` first and `shift` each time).\n<|/ c |>\n<| c |>\nI wanted\
    \ to add this as a comment, but there's too much code for an comment, so I'll\
    \ add it as an answer.\n<|/ c |>\n<| a dscore=1 tags=ruby,arrays,algorithm,sorting\
    \ |>\nAnother solution using Enumerable#sort_by:\n<code>", "    numbers.inject({})\
    \ do |memo, num|\n      memo[num] = [ abs(num), num ]\n      memo\n    end\n \
    \ \n  numbers.sort_by{|k, v| v[0]}.last.last\nend", "  numbers.each_with_index\
    \ do |number, i|\n    i = i + 1\n    best = number\n    j = i\n    while j < numbers.size\
    \ && number > numbers[j]\n      best = numbers[j]\n      j = j + 1\n    end\n\
    \    return [number, best] if numbers[i] != best\n  end\n  nil\nend", "  # Return\
    \ two elements that are closest to each other\n  \n  # Initialize min and max\
    \ as first two elements in numbers, plus one to ensure that they are larger than\
    \ \n  # the third element we compare against\n  min = numbers[1] + 1 \n  max =\
    \ numbers[2] + 1\n  \n  # Loop over all elements in numbers\n  for x in numbers[2..-1]\n\
    \    \n    # Calculate midpoint of range\n    midpoint = (min + max) / 2\n   \
    \ \n    # Check if midpoint is closer to the current element than current min/max\n\
    \    if abs(x - midpoint) < abs(min - max) then\n      min = midpoint\n    else\n\
    \      max = midpoint\n    end\n  end\n  \n  # Return the elements that are closer\
    \ to each other\n  return min, max\nend", "  numbers.each_with_index do |n, i|\n\
    \    smallest = numbers[0]\n    largest = numbers[-1]\n    break if smallest.abs\
    \ < n.abs\n    if largest < n\n      numbers[i], numbers[i - 1] = [n, largest\
    \ - n], n\n      break\n    end\n    numbers[i - 1] = n if smallest > n\n  end\n\
    \  numbers.sort!\n  numbers\nend", "  num1, num2 = numbers.minmax\n  index = nil\n\
    \  i = numbers.index(num1)\n  j = numbers.index(num2)\n  if i >= j\n    index\
    \ = i\n  else\n    index = j\n  end\n  [num1, num2, numbers[index]]\nend", " \
    \ return numbers.sort.map { |x| [x, x] }.min.last\nend", "  # Sort to ensure smallest\
    \ numbers are returned first\n  numbers.sort!\n  # Index of the smallest number\n\
    \  smallest = numbers[0]\n  smallest_index = 0\n  \n  # Starting with the 2nd\
    \ smallest number keep track of the smallest index\n  # until you reach the end\
    \ and then stop\n  numbers.each do |n|\n    smallest = smallest_index\n    smallest_index\
    \ = numbers.index(n)\n    if smallest_index == numbers.size - 1\n      break\n\
    \    end\n  end\n  return [numbers[smallest_index], numbers[smallest_index+1]]\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby,ruby-on-rails |>\nMy implementation:\n\
    <code>", "  numbers.each_with_index do |n, i|\n    break if numbers.count < 2\n\
    \    break if i\n    break if n\n    break if numbers[i] > n\n    break if numbers[i-1]\
    \ < n\n    break if numbers[i-1] < numbers[i]\n    if numbers[i-1] < numbers[i]\n\
    \      numbers[i-1], numbers[i] = numbers[i], numbers[i-1]\n    end\n  end\nend\n\
    </code>\n<|/ a |>\n<| c |>\n`each_cons(2)` can be written more concisely as `each_cons(2).to_a`.\n\
    <|/ c |>\n<| a tags=ruby |>\nJust an FYI, a more rubyish way to do this would\
    \ be using Enumerable#chunk:\n<code>\n[1,2,3,4].chunk(2)", "    min = numbers[0]\n\
    \    max = numbers[0]\n    closest_elements = []\n    closest_elements.append(min)\n\
    \    closest_elements.append(max)\n    numbers.each_with_index do |number, index|\n\
    \        if number < min\n            min = number\n            closest_elements[index]\
    \ = min\n        elsif number > max\n            max = number\n            closest_elements[index]\
    \ = max\n        else\n            closest_elements[index] = number\n        end\n\
    \    end\n    closest_elements\nend", "  numbers.sort\n  smallest_number = numbers[0]\n\
    \  larger_number = numbers[1]\n  while smallest_number < larger_number\n    smallest_number\
    \ += 1\n    larger_number -= 1\n  smallest_number += 1\n  larger_number -= 1\n\
    \  result = [smallest_number, larger_number]\n  return result\nend", "  numbers.sort!\n\
    \  smallest = numbers[0]\n  closest = numbers[0]\n  for i in 1..numbers.count\n\
    \    current = numbers[i]\n    if current == smallest or current == closest.abs\
    \ # if the current number is the same as the smallest or largest number\n    \
    \  continue\n    if current.abs < smallest.abs # if the current number is smaller\
    \ than the smallest number\n      smallest = current\n      closest = i\n    elsif\
    \ current.abs > closest.abs # if the current number is larger than the smallest\
    \ number\n      closest = current\n  end\n  return smallest, closest\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=ruby,ruby-on-rails,algorithm |>\n<code>", "  # If\
    \ there are 2 numbers return that two numbers\n  if numbers.size == 2\n    numbers[0],\
    \ numbers[1] = numbers[1], numbers[0]\n  \n  # If the list has only one number\
    \ return that number\n  elsif numbers.size == 1\n    numbers[0]\n  \n  # else\
    \ return an appropriate message\n  else\n    puts \"Uh oh, I don't have a clue\
    \ what you are trying to do.\" \n  end\nend", "  return [numbers[0..-2].min, [numbers[0..-2].max].max]\n\
    end", "  result = nil\n  numbers.sort.each do |x|\n    result = x if result.nil?\
    \ || result > x\n    result = x if result.nil? || result < x\n  end\n  return\
    \ result\nend", '  numbers.sort!', "  numbers.each_with_index do |num, i|\n  \
    \  closest_pair = [num, numbers[i + 1]] unless i == numbers.length - 1\n    break\
    \ if closest_pair[0] == closest_pair[1]\n  end\n  closest_pair\nend\n</code>\n\
    <|/ a |>\n<| a tags=arrays,ruby,loops,performance |>\n<code>\nnumbers = [3,9,-20,10,-100,8,-8,12,-22,17,-5,4,11,22,-12,1,-24,16]\n\
    p numbers.each_with_index.reject{|x,i| x == numbers[i+1]}.first\n</code>\n<|/\
    \ a dscore=2 |>\n<| a |>\nMy Ruby 1.9.3 implementation for finding the closest\
    \ pair of consecutive elements (without sorting):\n<code>", "  numbers.each_index\
    \ do |i|\n    j = i+1\n    distance = (numbers[j] - numbers[i]).abs\n    if distance\
    \ < minimum\n      minimum = distance\n      returned_number = numbers[i]\n  \
    \    returned_number = numbers[j]\n    end\n  end\n  return [returned_number,\
    \ returned_number]\nend", "    numbers.sort!\n    return numbers[0..-2]\nend",
  "  # Initialize variables\n  smallest, smallest_index, number = nil, 0, nil", " \
    \ sorted_numbers = numbers.sort_by(&:abs)\n  halfway = sorted_numbers.size / 2\n\
    \  return sorted_numbers[halfway], sorted_numbers[halfway + 1]\nend", "  sorted_numbers\
    \ = numbers.sort\n  index = sorted_numbers.rindex {|x| x >= sorted_numbers[-2]}\n\
    \  return numbers[index..-1], numbers[0..index]\nend", "  smallest = numbers[0]\n\
    \  largest = numbers[0]", "  differences = []\n  smallest = numbers[0]\n  largest\
    \ = numbers[0]\n  numbers.each do |number|\n    differences << number-smallest\n\
    \    differences << largest-number\n    smallest = number if difference == 0\n\
    \    largest = number if difference > 0\n  end\n  differences.each { |difference|\
    \ return [smallest, largest] }\nend\n</code>\nIt works by subtracting the smallest\
    \ number from the largest number, then dividing that difference by the difference\
    \ to smallest.  This gives us the closest value and the farthest value in that\
    \ differences list.\n<|/ a dscore=1 tags=ruby,math |>\n<| a tags=ruby,math |>\n\
    You can get the closest value to each other in a loop. In the following example,\
    \ I'll use rand to generate random numbers between 0 and 100, then I'll calculate\
    \ the closest value to each other: \n<code>\n arr = [rand(100), rand(100), rand(100),\
    \ rand(100), rand(100), rand(100)]", "    smallest, largest = numbers[0], numbers[1]\n\
    \    differences = [abs(n - largest) for n in numbers]\n    \n    # Sort the list\n\
    \    differences.sort!\n    # Get the values from the sorted list\n    smallest,\
    \ largest = differences.first, differences.last\n    \n    # Return the sorted\
    \ list\n    [smallest, largest]\nend\n</code>\nThe above code is for Ruby. For\
    \ Python, just change != to <.\n<code>", "  first_number, second_number = numbers[0],\
    \ numbers[1]\n  distance = ((first_number**2) + (second_number**2)**0.5).sqrt\n\
    \  return numbers[distances.index(distance)], numbers[distances.index(distance)+1]\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nIn Ruby I use the following\
    \ method:\n<code>", "  numbers.each_with_index do |n, i|\n    smallest_index =\
    \ i\n    smallest_distance = Float::INFINITY\n    smallest_number = nil\n    numbers.each_with_index\
    \ do |n2, j|\n      distance = n * n2\n      if distance < smallest_distance\n\
    \        smallest_distance = distance\n        smallest_index = j\n        smallest_number\
    \ = n2\n      end\n    end\n    yield smallest_number, numbers[smallest_index]\n\
    \  end\nend", "  numbers.each_with_index do |n, i|\n    index = i\n    (index\
    \ + 1...numbers.size).each do |j|\n      return [n, numbers[j]] if n.abs >= numbers[j].abs\n\
    \    end\n  end\nend", "  numbers.sort!\n  first, second = numbers.first, numbers.last\n\
    \  return [first, second] if first == second || numbers[0] - first > second -\
    \ first\n  [first, second] = numbers if first - second < 0.0\n  [second, first]\
    \ = numbers if first - second < 0.0\n  return [first, second]\nend", "  return\
    \ numbers.sort.map { |n| [n, n + 1] }\nend", "  # The return value of a comparison\
    \ between two numbers is 1 if that number is closer to the first number,\n  #\
    \ and -1 if the number is closer to the second number.\n  return numbers.min <=>\
    \ numbers.max if numbers.length > 1 && (numbers.min <=> numbers.max <=> 0) else\
    \ 0\nend", "  sorted = numbers.sort\n  min = sorted[1]\n  result = sorted\n  numbers.each\
    \ do |number|\n    if number < min\n      min = number\n      result = number\n\
    \    end\n  end\n  result\nend", "  numbers.each do |n|\n    smallest_num = n\n\
    \    largest_num = (n+1)\n    if n < smallest_num\n      smallest_num = n\n  \
    \  end\n    if n > largest_num\n      largest_num = n\n    end\n  end\n  smallest_num\n\
    end", "  numbers = numbers[0..-2]\n  numbers.sort!", "  return numbers.minmax\n\
    end\n</pre>\n</div>\n</div>\n</div>\n</div>\n<div id=\"footer\">\n<div id=\"footer-text\"\
    >\nLast updated 2017-05-15 17:52:00 W. Europe Daylight Time\n</div>\n</div>\n\
    </body>\n</html>\n<|/ file filename=index.html dstars=3 ext=.html |>\n<| c |>\n\
    It was actually just updated in the morning... And thanks for providing the code\
    \ I needed to write my own version. Now I understand it better! :)\n<|/ c |>\n\
    <| c |>\nYes, this is one of the things I hate about programming.\n<|/ c |>\n\
    <| a tags=ruby,arrays dscore=0 |>\n<code>\narr = [1,2,3,4,5,6,7]\narr.min_by{\
    \ |n| [Math.abs(n%2==0), n] }\n</code>\n<|/ a |>\n<| c |>\nA little explanation\
    \ about your answer and how it solves the OP's problem would make the answer even\
    \ better.\n<|/ c |>\n<| a dscore=0 |>\n<code>\narr = array.sort.reverse\narr.each_cons(2)\
    \ do |a,b|\n  puts \"#{a} - #{b}\"\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| a tags=ruby,arrays dscore=0 |>\nHere is another possible way:\n<code>\narr\
    \ = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\narr.select { |x| x.to_i % 2 != 0 }.each_cons(2).to_a\n\
    </code>\n<|/ a |>\n<| a tags=ruby,arrays |>\n<code>\narr.select{|e|e%2==0}\n</code>\n\
    This would select the even numbers in the array.\n<|/ a dscore=0 |>\n<| c |>\n\
    I think you meant `%` and not `/` right? `%` is integer division.\n<|/ c |>\n\
    <| a dscore=0 |>\nFor fun, here's an alternate solution:\n<code>\narr.each_with_index.with_object([])\
    \ do |(e,i),a|\n  if i==0\n    a.unshift(e)\n  elsif i==arr.size\n    a.push(e)\n\
    \  elsif e%2==1\n    a.unshift(e)\n  end\nend", "  # If the length of numbers\
    \ is less than two, return an empty list.\n  return [] if numbers.length < 2 \n\
    \  # Use Math.min to find the first number and Math.max to find the second number\n\
    \  first_number, second_number = numbers[0], numbers[1]\n  # Find the difference\
    \ between the two numbers\n  difference = first_number - second_number\n  # Find\
    \ the absolute value of the difference\n  absolute_difference = abs(difference)\n\
    \  # Find the minimum of the absolute value of the difference\n  minimum_absolute_difference\
    \ = min(absolute_difference)\n  # Find the maximum of the absolute value of the\
    \ difference\n  maximum_absolute_difference = max(absolute_difference)\n  # If\
    \ the difference is smaller than the minimum absolute difference,\n  # return\
    \ the first number\n  if difference < minimum_absolute_difference\n    return\
    \ first_number\n  # If the difference is larger than the maximum absolute difference,\n\
    \  # return the second number\n  else\n    return second_number\nend", "  numbers.sort!\n\
    \  smallest = numbers[0]\n  largest = numbers[1]\n  return [smallest, largest]\
    \ if largest - smallest == 0.0 || largest == smallest then\n    numbers.sort!\n\
    \    smallest = numbers[0]\n    largest = numbers[0]\n    return smallest, largest\n\
    \  else\n    numbers.each_with_index do |n, i|\n      if n - numbers[i] == smallest\n\
    \        largest = numbers[i]\n      elsif numbers[i] - n == largest\n       \
    \ smallest = numbers[i]\n      end\n    end\n    [smallest, largest]\n  end\n\
    end", "  # If the list has two numbers then return them both.\n  # NOTE: if there\
    \ is a tie, return whichever number appears first in the list.\n  return numbers[0,\
    \ 2] if numbers.length >= 2 ", "  numbers.each_with_index do |number, index|\n\
    \    if index > 0\n      closest_distance = number - numbers[index-1]\n    else\n\
    \      closest_distance = number\n    end\n    if closest_distance < number\n\
    \      return numbers[index-1], number\n    end\n  end\nend", "  minimum = numbers[0]\n\
    \  maximum = numbers[0]\n  smallest_difference = nil", "  return [\n    numbers[0..1],\n\
    \    numbers[1..-1]\n  ].sort\nend", "    smallest_number = numbers[0]\n    largest_number\
    \ = numbers[-1]\n    found_smallest_number = nil\n    found_largest_number = nil\n\
    \    smallest_number_index = nil\n    largest_number_index = nil\n    \n    numbers.each\
    \ do |number|\n        if number < smallest_number\n            smallest_number\
    \ = number\n            smallest_number_index = number_index\n        end\n  \
    \      if number > largest_number\n            largest_number = number\n     \
    \       largest_number_index = number_index\n        end\n    end\n    \n    if\
    \ smallest_number == smallest_number_index\n        found_smallest_number = smallest_number\n\
    \        found_largest_number = largest_number\n    else\n        found_smallest_number\
    \ = smallest_number_index\n        found_largest_number = largest_number_index\n\
    \    end\n    \n    if found_smallest_number == found_largest_number\n       \
    \ [found_smallest_number, found_largest_number]\n    else\n        [found_smallest_number,\
    \ found_largest_number].sort\n    end\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3\
    \ |>\nHere is a simple and easy to understand solution:\n<code>", "    numbers.sort!\n\
    \    i = numbers.first\n    return i if numbers.include?(i), numbers.last\nend",
  "  return [\n    numbers[0],\n    numbers[numbers.index(numbers[0]) + 1]\n  ]\n\
    end", "  numbers.each_with_index do |n, i|\n    (closest = (numbers.length - i\
    \ - 1) * (numbers.length - i - 2) / 2 + i).min\n    return numbers[closest], numbers[(closest\
    \ + 1).abs] if numbers.include?(closest)\n  end\n  nil\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis solution also takes O(n) time instead of the O(n2) time of the other\
    \ solutions\n<|/ c |>\n<| a tags=ruby,arrays,math |>\n<code>", "  min_difference\
    \ = numbers.reduce(0){ |min,a| min > a ? min : a }\n  numbers.each { |a| return\
    \ [a, a] if min_difference == a }\n  numbers[0]\nend", "  smallest = numbers[0]\n\
    \  largest = numbers[0]\n  i = 1\n  while i < numbers.length\n    if numbers[i]\
    \ < smallest\n      smallest = numbers[i]\n    elsif numbers[i] > largest\n  \
    \    largest = numbers[i]\n    elsif smallest != largest && numbers[i] > smallest\
    \ && numbers[i] < largest\n      # we found one that is closest, return\n    \
    \  return smallest, largest\n    end\n    i += 1\n  end\n  # none were closest,\
    \ return the smallest\n  return smallest, smallest\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby |>\n<| a |>\nI would do it in a following way:\n<code>", "  numbers.each_with_index\
    \ do |n, i|\n    if numbers[i-1] <= n and numbers[i] > n\n      return [numbers[i-1],\
    \ numbers[i]]\n    end\n  end\nend", "  differences = []\n  smallest = numbers[0]\n\
    \  largest = numbers[0]\n  smallest_difference = numbers.max\n  largest_difference\
    \ = numbers.min", "  numbers_to_compare = numbers.map { |number| number.to_i }\n\
    \  min1 = numbers.min { |number1, number2| numbers_to_compare.include?(number1)\
    \ }\n  max1 = numbers.max { |number1, number2| numbers_to_compare.include?(number1)\
    \ }\n  min2 = numbers.min { |number1, number2| numbers_to_compare.include?(number2)\
    \ }\n  max2 = numbers.max { |number1, number2| numbers_to_compare.include?(number2)\
    \ }\n  [min1, max1, min2, max2]\nend", "  # Find the closest two numbers (with\
    \ smallest difference)\n  a = numbers.min\n  b = numbers.max\n  difference = 0\n\
    \  while difference <= 0\n    difference = ((b - a) ** 2).abs\n    next_a = a\
    \ + difference\n    next_b = b + difference\n    if next_a <= b\n      a = next_a\n\
    \      difference = next_a - b\n    else\n      b = next_b\n      difference =\
    \ next_b - a\n    end\n  end", "  numbers.sort!\n  closest_element = numbers[0]\n\
    \  next_element = numbers[1]\n  \n  while numbers.count >= 2\n    if numbers[2]\
    \ - closest_element < next_element - numbers[2]\n      closest_element = numbers[2]\n\
    \    else\n      next_element = numbers[2]\n    end\n    numbers[2] = numbers[1]\n\
    \    numbers[1] = closest_element\n    closest_element = numbers[0]\n  end\n \
    \ \n  return [numbers[1], numbers[2]]\nend", "  if numbers.nil? or numbers.size\
    \ < 2\n    []\n  else\n    sorted_numbers = numbers.sort\n    smallest_number\
    \ = sorted_numbers.first\n    biggest_number = sorted_numbers.last\n    smallest_index\
    \ = sorted_numbers.index(smallest_number)\n    biggest_index = sorted_numbers.index(biggest_number)\n\
    \    [smallest_number, biggest_number]\n  end\nend", "  numbers = numbers.to_a\
    \ if numbers.respond_to?(:to_a) \n  if numbers.empty?\n    return nil, nil\n \
    \ elsif numbers.size == 1\n    return numbers.first, nil\n  else\n    sorted_numbers\
    \ = numbers.sort_by{|number| number}\n    smallest_difference = sorted_numbers[1]\
    \ - sorted_numbers[0]\n    smallest_difference, smallest_index = smallest_difference,\
    \ 1\n    largest_difference = sorted_numbers[sorted_numbers.length - 1] - sorted_numbers[sorted_numbers.length\
    \ - 2]\n    largest_difference, largest_index = largest_difference, sorted_numbers.length\
    \ - 1\n    sorted_numbers.each do |number|\n      current_difference = number\
    \ - sorted_numbers[smallest_index]\n      if current_difference < smallest_difference\n\
    \        smallest_difference = current_difference\n        smallest_index = smallest_index\
    \ + 1\n      elsif current_difference > largest_difference\n        largest_difference\
    \ = current_difference\n        largest_index = largest_index - 1\n      end\n\
    \    end\n    return sorted_numbers[smallest_index], sorted_numbers[largest_index]\n\
    \  end\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nIf i understand correctly you\
    \ have a set of numbers:\n<code>\n[3.0,5.0,7.0,8.0,10.0,2.0,4.0]\n</code>\nand\
    \ you want to find the closest numbers to each other, with distance less than\
    \ 2.\nYou can do this by:\n<code>", "  minimum = numbers[0]\n  maximum = numbers[1]\n\
    \  min_distance = numbers[0]\n  \n  numbers.each do |number|\n    distance = number\
    \ - minimum\n    if distance < min_distance\n      minimum = number\n      min_distance\
    \ = distance\n    end\n    distance = maximum - number\n    if distance < min_distance\n\
    \      maximum = number\n      min_distance = distance\n    end\n  end\n  [minimum,\
    \ maximum]\nend", "  min1, min2 = numbers[0], 0.0 # numbers[0] holds the smallest\
    \ number\n  max1, max2 = numbers[0], 0.0 # numbers[0] holds the largest number\n\
    \  \n  numbers.each do |num|\n    if num < min1\n      min1, min2 = num, num\n\
    \    elsif num > max1\n      max1, max2 = num, num\n    end\n  end\n  \n  if min1\
    \ < max1\n    min1, max1 = max1, min1\n  end\n  \n  [min1, max1]\nend", "  numbers.each\
    \ do |number|\n    current = number\n    min = numbers[0]\n    max = numbers[0]\n\
    \    numbers.each do |num|\n      current <=> num do |cmp|\n        min = cmp\
    \ == 0 ? min : cmp < 0 ? num : min\n        max = cmp == 0 ? max : cmp < 0 ? num\
    \ : max\n      end\n    end\n    if min != numbers[0]\n      yield min\n    else\n\
    \      yield max\n    end\n  end\nend", "  sorted = numbers.sort\n  minimum =\
    \ sorted[1]\n  minimum_index = 0\n  i = 0", "  sorted_numbers = numbers.sort\n\
    \  return sorted_numbers.first(2), sorted_numbers.last(2)\nend", "  return numbers.sort\
    \ { |a, b| abs b - a }\nend", "  return min_and_max(nth(numbers))\nend", "  distances\
    \ = []\n  for i in 0...numbers.length - 1\n    distances[i] = find_distance_between(numbers[i],\
    \ numbers[i+1])\n  \n  # Select the two numbers with the lowest distance between\
    \ them.\n  minimum = minimum_value(distances)\n  min_ix = distance(distances,\
    \ minimum)\n  \n  if minimum == numbers[min_ix]\n    # If the two are the same\
    \ distance, select the smaller number.\n    minimum = minimum_value(numbers)\n\
    \    min_ix = distance(numbers, minimum)\n  end\n  \n  return numbers[min_ix],\
    \ numbers[min_ix + 1]\nend", "  minimum = numbers.first\n  maximum = numbers.last\n\
    \  sorted_numbers = numbers.sort_by{|x| x}\n  while minimum < maximum\n    if\
    \ sorted_numbers.include?(minimum)\n      minimum = sorted_numbers.first\n   \
    \ else\n      maximum = sorted_numbers.last\n    end\n    sorted_numbers = sorted_numbers.reject{|x|\
    \ x == minimum}\n  end\n  return [minimum, maximum]\nend", "  return nil if numbers.nil?\n\
    \  numbers.each_with_index do |number, index|\n    if index == 0\n      result\
    \ = number\n      return\n    end\n    diff = numbers[index-1] - number\n    if\
    \ diff == 0\n      result = number\n      return\n    end\n    result = numbers[index-1]\
    \ if diff < 0\n  end\n  return nil\nend", "  min_difference = numbers[0]\n  min_number\
    \ = numbers[0]\n  max_number = numbers[0]\n  numbers[1] = numbers[1]\n  numbers[2]\
    \ = numbers[2]\n  if numbers.length < 2\n    return nil\n  else\n    for i in\
    \ 0...numbers.length - 1\n      difference = numbers[i + 1] - numbers[i]\n   \
    \   if difference < min_difference\n        min_difference = difference\n    \
    \    min_number = numbers[i]\n      elsif difference > min_difference\n      \
    \  max_number = numbers[i]\n      end\n    end\n    return min_number, max_number\n\
    \  end\nend", "  # Convert to a hashmap\n  numbers_by_key = numbers.inject({})\
    \ { |h, e| h[e[0]] = e; h }", '  numbers.sort!', "  sorted_numbers = numbers.sort\n\
    \  min_number = numbers.min\n  min_element = [numbers[0], numbers[0]]\n  min_distance\
    \ = numbers[0]", "  numbers.sort.each do |a|\n    index = numbers.index(a)\n \
    \   return numbers[index], numbers[index+1] if index > 0\n    return numbers[index],\
    \ numbers[index-1] if index < numbers.length-1\n  end\nend", "  # Find the two\
    \ numbers closest to each other\n  numbers.map! do |num|\n    numbers_to_compare\
    \ = [num] unless numbers_to_compare.nil?\n    numbers_to_compare << num if numbers_to_compare\
    \ and num > numbers_to_compare[0]\n    numbers_to_compare\n  end\n  numbers.sort!",
  "  numbers.sort!\n  if numbers.length < 2\n    numbers.fill(0.0)\n  end\n  lower\
    \ = numbers[0]\n  upper = numbers[1]\n  if lower == upper\n    return ([lower,\
    \ lower])\n  end\n  midpoint = lower + (upper - lower) / 2\n  closest_elements\
    \ = [find_closest_elements([lower, midpoint, upper]), \n                     \
    \ find_closest_elements([midpoint, lower, upper])]\n  closest_elements[1].map!\
    \ { |x| x[0] }\n  closest_elements\nend\n</code>\nThis solution could be optimised\
    \ further using a binary search to improve the time complexity, but it is not\
    \ that important in this case.\n<|/ a tags=ruby,arrays |>\n<| c |>\nWhat about\
    \ the case where I have an array of an array of two elements?\n<|/ c |>\n<| c\
    \ |>\nThat was my first idea, but you need to be able to handle an array of arrays\
    \ of an arbitrary size which would mean recursion or a loop.\n<|/ c |>\n<| c |>\n\
    : It's still doable with a binary search.\n<|/ c |>\n<| c |>\nHow can you binary\
    \ search an array of arrays of an arbitrary size?\n<|/ c |>\n<| c |>\n: Sure.\
    \ Have you tried doing that? What did you get? Why didn't it work?\n<|/ c |>\n\
    <| a dscore=3 tags=ruby,arrays |>\nHere's a solution that uses recursion, just\
    \ for fun, and in O(n).\n<code>", "  smallest = numbers[0]\n  largest = numbers[1]",
  "  # Get the closest number\n  min_num = numbers.min\n  max_num = numbers.max\n\
    \  return numbers[numbers.index(min_num) + 1] if min_num <= max_num else numbers[numbers.index(max_num)\
    \ - 1]\nend", "  # Add element to each number\n  numbers.each_with_index do |n,\
    \ i|\n    numbers[i] = n + numbers[i]\n  end", "  numbers.each_with_index do |number,\
    \ index|\n    smallest = numbers[index - 1] if index > 0\n    largest = numbers[index\
    \ + 1] if index < numbers.length - 1\n    return smallest, largest if number <\
    \ smallest || number > largest\n  end\nend", "    numbers.sort!\n    return numbers[(0...numbers.size)].maxmax\n\
    end", "  numbers.minmax\nend", "  numbers.each_with_index.min_by(&:abs).last\n\
    end", "  numbers = numbers.sort\n  first = numbers.first\n  last = numbers.last\n\
    \  if first < last\n    return first, last\n  while numbers.length > 2\n    mid\
    \ = (first + last) / 2\n    numbers_between = [i for i in numbers if i > mid and\
    \ i < mid + 1]\n    middle = numbers_between.first\n    if middle == numbers.last\n\
    \      return middle, middle\n    middle = numbers_between.last\n    if middle\
    \ == numbers.first\n      return middle, middle\n    if middle > first and middle\
    \ < last\n      return middle, middle\n    if middle > last\n      first = mid\
    \ + 1\n      continue\n    if middle < first\n      last = mid - 1\n      continue\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| a tags=ruby,arrays,sorting\
    \ |>\nYou can sort with custom comparator:\n<code>\nrequire 'active_support/core_ext/array/extract_options'",
  "    numbers.sort!\n    return numbers[0..-2].minmax\nend", "  numbers.sort!\n \
    \ index = numbers.index {|number| number == numbers.last}\n  result = [numbers[index],\
    \ numbers[index + 1]]\n  return result if numbers.size == index + 1\n  find_closest_elements(numbers[index..-1]\
    \ + [numbers[index], numbers[index + 1]], result)\nend", "    smallest = numbers[0]\n\
    \    largest = numbers[0]\n    smallest_distance = Float::INFINITY\n    largest_index\
    \ = 0\n    numbers.each do |number|\n        distance = number.distance_to(smallest)\n\
    \        smallest_distance = distance if distance < smallest_distance\n      \
    \  distance = number.distance_to(largest)\n        largest_index = distance if\
    \ distance < smallest_distance\n        smallest = number\n        largest = number\n\
    \    end\n    return smallest, numbers[largest_index]\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby,ruby-on-rails-3,algorithm dscore=0 |>\nI think I found a way that\
    \ uses the .sort method, which I believe is O(n log n). The method is below.\n\
    <code>", "  smallest = numbers.min\n  largest = numbers.max\n  i = nil\n  while\
    \ i < numbers.length\n    if numbers[i] - smallest < largest - numbers[i]\n  \
    \    smallest = numbers[i]\n    else\n      largest = numbers[i]\n    end\n  \
    \  i += 1\n  end\n  return smallest, largest\nend", "  smallest_number = numbers[0]\n\
    \  largest_number = numbers[1]\n  numbers.each_with_index do |number, index|\n\
    \    if number < smallest_number\n      smallest_number = number\n    end\n  \
    \  if number > largest_number\n      largest_number = number\n    end\n  end\n\
    \  [smallest_number, largest_number]\nend", "    smallest = numbers[0]\n    biggest\
    \ = numbers[0]\n    \n    numbers.each { |num| biggest = num if num > biggest\
    \ }\n    numbers.each { |num| smallest = num if num < smallest }\n    \n    (smallest,\
    \ biggest)\nend\n</code>\n<|/ a tags=ruby,loops,ruby-on-rails dscore=0 |>\n<|\
    \ a dscore=0 |>\nFor a more elegant solution:\n<code>", "  numbers = numbers.to_a\n\
    \  numbers.shift\n  diff = numbers.max - numbers.min\n  if diff < 0\n    diff\
    \ *= -1\n    numbers = numbers.reverse\n  end\n  result = numbers.inject(:+) ||\
    \ numbers.min\n  result -= diff + numbers.max\n  result = ((result < numbers.min)\
    \ ? numbers.min : result) if numbers.min != 0\n  result = ((result > numbers.max)\
    \ ? numbers.max : result) if numbers.max != 0\n  result\nend", "  return numbers.map\
    \ { |n| [n, n] }.sort.last\nend", "  numbers.map { |number| [number, numbers.min]\
    \ }\n                    .select { |number| number[1]==numbers.min }\n       \
    \             .sort_by { |number| number[0] }\n                    .last(2)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThe \"closest_elements\" function returns only\
    \ one element\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  max_number = numbers.max\n\
    \  min_number = numbers.min", "  # Calculate the differences between the numbers.\
    \ \n  differences = numbers.map { |n| n.abs - numbers[0] }\n  # Sort the differences\
    \ ascending. \n  sorted_differences = differences.sort.reverse\n  # Return the\
    \ first two differences.\n  sorted_differences.first\nend\n</code>\nAnd here's\
    \ how we can use it in our case:\n<code>\nrequire 'find-closest'", "  min = numbers.min\n\
    \  max = numbers.max\n  numbers_copy = numbers.dup\n  (min, max) = (min, max)\
    \ if min == max || numbers_copy.empty?\n  return numbers_copy.min if min < numbers_copy.max\n\
    \  numbers_copy.sort\n  (min, max) = (numbers_copy[numbers_copy.size - 1], numbers_copy[numbers_copy.size\
    \ - 2])\n  (numbers_copy.first - min, numbers_copy.last - max)\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis is not really the answer the OP wants, as they\
    \ asked for a function that returns a tuple of the two closest numbers to a given\
    \ number. This is hardly what `closest_to_number` is for, since this would return\
    \ the two smallest or two largest numbers to given number, which is not the same\
    \ as \"the two closest to it\".\n<|/ c |>\n<| c |>\nIf you're interested in the\
    \ first or the second closest numbers, you can modify the line `numbers_copy.first\
    \ - min` to `numbers_copy.last - min`\n<|/ c |>\n<| c |>\n: good point, I hadn't\
    \ noticed that. The OP may want to modify the returned values so that they always\
    \ contain two numbers instead of just one number.\n<|/ c |>\n<| c |>\nThanks for\
    \ this answer. The question was to find the closest number to given number, not\
    \ the two closest numbers to a given number. This code seems to find the nearest\
    \ number to the given number. Would be great if you can change it so that it returns\
    \ the two closest numbers to a given number or some modification on this.\n<|/\
    \ c |>\n<| a dscore=5 |>\nThe above answers worked for me, but I thought I'd post\
    \ my version so if someone else finds this they know it works.\n<code>", "  differences\
    \ = []\n  smallest, largest, smallest_index, largest_index = numbers[0], numbers[0],\
    \ 1, 0\n  differences << [numbers[0]]\n  numbers.each do |number|\n    differences\
    \ << number if number > largest || number < smallest\n    smallest_index += 1\n\
    \    largest_index  += 1 if number > largest || number < smallest\n    differences\
    \ << number if number < smallest && number > differences[largest_index - 1]\n\
    \    differences << number if number > smallest && number < differences[smallest_index\
    \ - 1]\n    smallest, largest = number, number\n  end\n  differences.sort!\n \
    \ return differences[0], differences[differences.length - 1]\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| c |>\nVery nice, but I wouldn't want to rewrite it just for\
    \ learning purposes. My first thought was to rewrite it using recursion, but my\
    \ inclination was to try to understand how to implement it without recursion.\n\
    <|/ c |>\n<| c |>\nRecursion is no more complicated than iteration, so I'd use\
    \ recursion if possible. My original solution was written to be recursive because\
    \ it was easier to write and understand and I wasn't sure of the use case at hand.\n\
    <|/ c |>\n<| a dscore=2 |>\nI've solved this problem using only basic ruby functions:\
    \ \n<code>", "  numbers.each do |number|\n    next if number == numbers.first",
  "  sorted_numbers = numbers.sort\n  smallest = sorted_numbers.first\n  largest =\
    \ sorted_numbers.last\n  smallest_element = sorted_numbers.find_index { |num|\
    \ num == smallest }\n  largest_element = sorted_numbers.find_index { |num| num\
    \ == largest }\n  return smallest_element == largest_element ? [smallest, largest]\
    \ : [smallest, largest_element]\nend", "  closest_elements = nil\n  numbers.each\
    \ do |num|\n    closest_elements = num if distance_between(num, closest_elements)\
    \ > distance_between(closest_elements, num)\n  end\n  [closest_elements, closest_elements]\n\
    end", "  return numbers.sort_by {|x| x.abs}.first(2).map {|x| x.abs}\nend", " \
    \ numbers.sort\n  result = numbers.minmax\n  if result[1]\n    return [result[0],\
    \ result[1]]\n  else\n    return nil\n  end\nend", "  min = numbers[0]\n  max\
    \ = numbers[0]\n  for x in numbers[1..-1]\n    if x <= max\n      max = x\n  \
    \  else\n      if min > max\n        min, max = x, max\n      else\n        min,\
    \ max = max, x\n    end\n  end\n  min\nend", "  # Sort the numbers in descending\
    \ order\n  numbers.sort!\n  # Remove any elements that are already in the list\n\
    \  numbers.reject { |x| numbers.include?(x) }", "  smallest_diff = Float::INFINITY\n\
    \  smallest_number = nil\n  second_smallest_number = nil\n  numbers.each do |number|\n\
    \    diff = number - smallest_number\n    break if diff < smallest_diff\n    smallest_diff\
    \ = diff\n    smallest_number = number\n  end\n  smallest_diff > Float::INFINITY\
    \ ? return [] : second_smallest_number ? return [smallest_number, second_smallest_number]\
    \ : return [smallest_number]\nend", "  numbers.each_with_index do |n, i|\n   \
    \ found = [n.abs, i]\n    found.each { |f| numbers.delete_at(numbers.index(f))\
    \ if found == f }\n    break if numbers.empty?\n  end\n  return numbers, nil\n\
    end", "  return numbers.sort do |a, b|\n    return b if a < b\n    return a if\
    \ a > b\n  end\nend", "  numbers.sort!\n  smallest_difference = (numbers[1] -\
    \ numbers[0]).abs\n  smaller = numbers[1]\n  bigger = numbers[0]\n  until smallest_difference\
    \ > 0.000001\n    if smaller.to_f < bigger.to_f\n      smallest_difference = (smaller.to_f\
    \ - bigger.to_f).abs\n      smaller = bigger\n      bigger = numbers[numbers.index(bigger)\
    \ + 1]\n    else\n      smallest_difference = (bigger.to_f - smaller.to_f).abs\n\
    \      bigger = numbers[numbers.index(smaller) - 1]\n      smaller = numbers[numbers.index(smaller)\
    \ + 1]\n    end\n  end\n  return [smaller, bigger]\nend", "  min_difference =\
    \ numbers[0]\n  min_difference_index = numbers[0]\n  min_difference_index = 1\n\
    \  for i in 1..numbers.count\n    difference = numbers[i] - numbers[i - 1]\n \
    \   if difference < min_difference\n      min_difference = difference\n      min_difference_index\
    \ = i\n    end\n  end\n  return [numbers[min_difference_index - 1], numbers[min_difference_index]]\n\
    end", "  numbers.each_with_index do |number, index|\n    unless index == 0\n \
    \     closest = numbers[index-1]\n      break if number < closest or number >\
    \ closest\n    end\n  end\n  return [numbers[0], numbers[-1]]\nend", "  numbers.each_with_index\
    \ do |n, i|\n    closest_previous, closest_current = nil, nil\n    numbers.each_with_index\
    \ do |m|\n      if m < n and closest_current == nil\n        closest_current =\
    \ m\n        closest_previous = m\n      elsif m < n and closest_previous != nil\n\
    \        break\n      end\n    end\n    yield closest_previous, closest_current\n\
    \  end\nend", "  numbers.sort_by(&:abs)\n  numbers[1..-1].first(2)\nend", "  numbers_sorted\
    \ = numbers.sort\n  min_value = numbers_sorted.first\n  max_value = numbers_sorted.last",
  "  # Initialize variables\n  smallest, largest = numbers.first, numbers.last\n \
    \ smaller, larger = numbers, []\n  # While there are numbers to process\n  while\
    \ !smaller.nil? && smaller.last < smallest && smaller.first < smallest\n    #\
    \ Append the smallest number to the result set\n    larger << smallest\n    #\
    \ Find the next smallest number\n    smallest = smaller.first\n    # Get the first\
    \ element of the remaining set\n    smaller = smaller.last\n  end\n  # While there\
    \ are numbers to process\n  while !larger.nil? && larger.last > largest && larger.first\
    \ > largest\n    # Append the largest number to the result set\n    larger <<\
    \ largest\n    # Find the next largest number\n    largest = larger.first\n  \
    \  # Get the first element of the remaining set\n    larger = larger.last\n  end\n\
    \  # Return both numbers found, smallest first and largest second\n  [smallest,\
    \ largest]\nend", "  # Sort the array from smallest to largest\n  numbers.sort",
  "  numbers.sort!\n  (first, last) = numbers[0], numbers[-1]\n  (first, last)\nend\n\
    </pre>\n<p>\nSo what is a bit confusing about this?\nThe key thing to remember\
    \ is that we are passing in a <em>list</em> of values <em>not</em> an array.\n\
    The <em>list</em> is <em>not</em> actually an array but rather a <em>list</em>\
    \ that is used to store a series of values, so you can manipulate them however\
    \ you wish.\n</p>\n<p>\nThe code above is pretty straight forward, as long as\
    \ you understand it you can do pretty much anything you like.\n</p>\n<p>\nWhat\
    \ if we had a slightly different method of choosing two elements?\n</p>\n<pre\
    \ class=\"prettyprint lang-js\">", "  sorted_numbers = numbers.sort_by { |number|\
    \ -number } # Sort the array so smallest number is at the front\n  return sorted_numbers.first(2),\
    \ sorted_numbers.last(2)\nend", "  return numbers[numbers.min<numbers.max?numbers.min:numbers.max],\
    \ numbers[numbers.min<numbers.max?numbers.max:numbers.min]\nend", "    min = numbers[0]\n\
    \    max = numbers[1]\n    minimum = numbers[0]\n    maximum = numbers[1]\n  \
    \  numbers.each do |number|\n        minimum = number.nil? ? minimum : number\
    \ if number < minimum\n        maximum = number.nil? ? maximum : number if number\
    \ > maximum\n        min = number if number < min\n        max = number if number\
    \ > max\n    end\n    return min, max\nend", "  # If the list has only one element\
    \ then return that element\n  if numbers.length == 1\n    return numbers", " \
    \ numbers.each_with_index.map { |n, i|\n    [abs(n - numbers[i - 1]), i] }.sort.last\n\
    end", "  return numbers[find_closest_index(numbers)]\nend", "  numbers = [numbers]\
    \ unless numbers.length.positive?\n  numbers.map!(&:round) unless numbers.any?\
    \ { |n| n.is_a? Numeric}\n  numbers = numbers.sort { |a, b| (b - a).abs}\n  return\
    \ numbers.first if numbers.length < 2\n  numbers[0]\nend", "  numbers.sort.with_index\
    \ { |e, i| return i if e == numbers[i-1] }\n  numbers[0]\nend", "  numbers = numbers.clone\n\
    \  numbers.sort do |a, b|\n    a <=> b\n  end", "  numbers.sort!\n  numbers.reverse!\n\
    \  i = 0\n  min = numbers[i]\n  j = 0\n  while j < numbers.length - 1\n    if\
    \ numbers[j] == numbers[j + 1]\n      j += 2\n      i += 1\n    elsif numbers[j]\
    \ < numbers[j + 1]\n      min = numbers[j]\n      i += 1\n    else\n      min\
    \ = numbers[j + 1]\n      j += 1\n    end\n  end\n  if numbers[-1] < min\n   \
    \ min.push(numbers[-1])\n    elsif i == 1\n      return min\n    else\n      return\
    \ (min)\n    end\n  else\n    min.push(numbers[0])\n    elsif i == numbers.length\n\
    \      return min\n    else\n      return (min)\n    end\n  end\nend\n</code>\n\
    <|/ a tags=sorting,arrays,ruby |>\n<| c |>\nThis algorithm is a little bit too\
    \ simple to be useful (at least for this problem). You could probably optimize\
    \ it a bit, for example by sorting the array just once and by swapping elements\
    \ when they are out of order instead of rearranging all elements.\n<|/ c |>\n\
    <| a tags=sorting,arrays,ruby |>\nThe simplest and probably the most readable\
    \ solution to your problem is to implement your own sort method :\n<code>", "\t\
    numbers.sort!", "  sorted_numbers = numbers.sort\n  sorted_numbers.shift\n  sorted_numbers.first\n\
    \  sorted_numbers.last\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,optimization\
    \ dscore=2 |>\n<| c |>\nI like this. It is a little more succinct than mine but\
    \ a little less concise.\n<|/ c |>\n<| a |>\n<code>", "    numbers.each do |n|\n\
    \        return n if (closest_number_from_list(numbers, n) == n)\n    end\nend",
  "  return numbers[numbers.map { |number| abs(number - find_number) }.min_by { |number|\
    \ number }].to_s, find_number\nend", "  # Get a sorted list of all numbers. We\
    \ will use this to find the\n  # closest number in O(n) instead of O(nlogn) for\
    \ every element\n  # comparison.\n  all_numbers = numbers.sort", "  numbers.each_with_index.find\
    \ { |n, i| numbers[i+1] < n }\nend\n</code>\n<|/ a dscore=0 tags=arrays,ruby,sorting,algorithm\
    \ |>\n<| c |>\nI thought the same and went for [O(n)](http://en.wikipedia.org/wiki/Closest_pair_of_points_problem)\
    \ but your solution seems to be more elegant.\n<|/ c |>\n<| c |>\nThis solution\
    \ runs in O(n^2) because of the nested loops.\n<|/ c |>\n<| c |>\n- Oops, yes\
    \ you are right. Nested loops can be reduced to O(n). I have corrected my answer.\n\
    <|/ c |>\n<| a |>\n<code>", "  numbers_sorted = numbers.sort\n  diff = numbers_sorted[1]\
    \ - numbers_sorted[0]\n  if diff == 0.0\n    return numbers_sorted\n  nearest_num\
    \ = numbers_sorted[0]\n  smallest_diff = diff / 2.0\n  for i in 1..numbers_sorted.size\n\
    \    diff = numbers_sorted[i] - nearest_num\n    if diff < smallest_diff\n   \
    \   smallest_diff = diff\n      nearest_num = numbers_sorted[i]\n  end\n  return\
    \ nearest_num, numbers_sorted[numbers_sorted.index(nearest_num)]\nend", "  # If\
    \ there is only one number then return it, no need to look further.\n  return\
    \ numbers[1] if numbers.length > 1 unless numbers.length == 1\n  \n  # Find the\
    \ two closest to each other and return them in order (smaller number, larger number).\n\
    \  numbers = [find_closest_element(n) for n in numbers]\n  return numbers if numbers[0]\
    \ > numbers[1]\n  return numbers[1] if numbers[1] > numbers[0]\n  \n  # Return\
    \ the two closest to each other.\nend", "  numbers.each_with_index.map do |a,\
    \ i|\n    min = numbers[i]\n    max = numbers[i + 1]\n    [min, max] if min !=\
    \ max && (a + max - min).abs < 1.0\n  end.flatten\nend\n</code>\n<|/ a dscore=2\
    \ tags=arrays,ruby |>\n<| c |>\nThanks very much for answering. The only thing\
    \ I find myself confused about is the \"return min\" part. What does it mean to\
    \ return min in the case of the two numbers being the same? Could you possibly\
    \ give an example of the desired result?\n<|/ c |>\n<| c |>\nI added a small example\n\
    <|/ c |>\n<| c |>\nThanks so much, this is really great. Just to clarify, does\
    \ the \"min\" in the first \"if\" statement mean that it returns the smallest\
    \ number that doesn't have a greater number that \"max\" in the second \"if\"\
    \ statement so that in the end we would have two numbers that are the closest\
    \ to each other? Also, does it matter if the numbers are \"floats\" or integers?\
    \ Thanks again!\n<|/ c |>\n<| c |>\nthe min in the if statement is just a variable\
    \ name given to that particular element. It doesn't matter if it's a float or\
    \ integer. Because you are looping through each element in the array and comparing\
    \ it to every element in the array except the one you are currently on. And if\
    \ the elements are equal then you know that it's the closest element and therefore\
    \ it's min value. In the if statements it compares it to other elements in the\
    \ array\n<|/ c |>\n<| c |>\nThanks! Could you possibly explain a little more about\
    \ the numbers in the if's please? What does \"a.min\" and \"a + max - min\" mean\
    \ exactly? Thanks!\n<|/ c |>\n<| a dscore=1 |>\nI think this might work (not tested):\n\
    <code>", "  numbers.each_with_index do |n, i|\n    difference = n - numbers[i-1]\n\
    \    if difference < 0\n      numbers[i-1], numbers[i] = numbers[i], numbers[i-1]\n\
    \      difference = -difference\n    end\n  end\n  numbers.reverse\nend\n</code>\n\
    <|/ a tags=ruby,arrays,algorithm |>\n<| c |>\nI like this but I think `find_closest_elements([1.0,2.0,3.0,4.0,5.0,2.2])`\
    \ should return `[2.0,2.2]` not `[2.2,2.0]`.\n<|/ c |>\n<| c |>\nThanks.  I missed\
    \ that detail.  It still works.  I fixed it now.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\nIf your numbers are sorted, then you don't need the two pointers and you\
    \ can use the following solution:\n<code>", "  min_diff = numbers[0] - numbers[1]\n\
    \  min = numbers[0]\n  min_idx = 0", "  smallest_difference = nil\n  smallest_number\
    \ = nil\n  \n  if numbers.length < 2\n    raise ArgumentError, \"not enough numbers\"\
    \n  \n  else\n    numbers.each do |n|\n      difference = n - smallest_number\n\
    \      \n      # Stop looking if the smallest difference has been found.\n   \
    \   if smallest_difference.nil? || smallest_difference > difference\n        smallest_difference\
    \ = difference\n        smallest_number = n\n      end\n    end\n    \n    return\
    \ smallest_number, smallest_difference\n  end\nend", '  numbers = numbers.sort',
  "  min_diff = numbers[0] - numbers[1]\n  min_elem = numbers[0]\n  \n  returned =\
    \ numbers[1..-1]\n  \n  returned.each { |n| \n    diff = n - numbers[0]\n    \n\
    \    if diff < min_diff\n      min_diff = diff\n      min_elem = n\n    end\n\
    \  }\n  \n  return [min_elem, min_diff]\nend", "  smallest = numbers[0]\n  largest\
    \ = numbers[0]\n  numbers.each do |number|\n    if smallest.nil? or number < smallest\n\
    \      smallest = number\n    end\n    if largest.nil? or number > largest\n \
    \     largest = number\n    end\n  end\n  [smallest, largest]\nend", "  index=0\n\
    \  smallest = numbers[0]\n  largest = numbers[-1]\n  elements.each do |element|\n\
    \    if index>0 and index<numbers.length\n      smallest = numbers[index]\n  \
    \    largest = numbers[index+1]\n    elsif index==0\n      smallest = numbers[index]\n\
    \      largest = numbers[index]\n    else\n      smallest = numbers[index]\n \
    \     largest = numbers[index]\n    end\n    element=(element+smallest)/2.0\n\
    \    if element>largest\n      index=index+1\n      smallest=element\n    else\n\
    \      index=index+1\n      largest=element\n    end\n  end\n  [smallest,largest]\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis works for smaller lists, but larger lists\
    \ often cause an index out of bounds error when indexing into the `numbers` array.\n\
    <|/ c |>\n<| c |>\n- If you're talking about the second version, it seems to have\
    \ run fine for me on a few tests I tried.\n<|/ c |>\n<| c |>\nI see it now that\
    \ you're dividing by 2 after every element - I guess this was a mistake. But still\
    \ - I do not think that your solution runs faster than mine.\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere's a solution which is based on this answer\n<code>", "  minimums =\
    \ numbers.min\n  maximums = numbers.max\n  \n  if minimums == maximums\n    return\
    \ []\n  \n  closest = numbers[maximums]\n  \n  for i in 1..numbers.size-1\n  \
    \  if numbers[i] > closest.abs\n      closest = numbers[i]\n    end\n  end\n \
    \ \n  closest = numbers[minimums]\n  \n  for i in 1..numbers.size-1\n    if numbers[i]\
    \ < closest.abs\n      closest = numbers[i]\n    end\n  end\n  \n  numbers.push\
    \ closest\n  \n  return numbers\nend", "  numbers.each_with_index do |number,\
    \ index|\n    closest_index = index\n    # we consider any number closer to the\
    \ one we are currently checking to be the closest to us\n    # also, we always\
    \ consider our number to be the closest number so far\n    while closest_index\
    \ > 0 and (numbers[closest_index] - numbers[index] > 0)\n      closest_index -=\
    \ 1\n    end\n    closest_index += 1\n    numbers[closest_index] = number\n  end\n\
    \  numbers\nend\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails-3.2,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| a tags=ruby,algorithm,ruby-on-rails-3.2,ruby-on-rails,ruby-on-rails-3\
    \ dscore=1 |>\nHere's my take on it. I think it's fairly simple and should work\
    \ in almost all cases.\n<code>\nnumbers = [10, 15, 15, 9, 15, 15, 15, 16, 15,\
    \ 10, 12, 9, 14, 15, 9, 10, 12, 15, 16, 15, 10, 11, 14, 15, 14, 11, 9, 12, 9,\
    \ 14, 11, 14, 14, 12, 10, 13, 12, 16, 16, 12, 16, 11, 11, 16, 16, 16, 13, 12,\
    \ 9, 13, 11, 14, 16, 12, 13, 16, 13, 10, 14, 11, 11, 14, 15, 16, 10, 10, 13, 14,\
    \ 14, 12, 14, 12, 12, 12, 14, 14, 10, 10, 14, 14, 14, 14, 9, 15, 13, 14, 15, 15,\
    \ 13, 16, 12, 9, 12, 9, 9, 14, 15, 10, 9, 15, 10, 12, 13, 16, 15, 14, 12, 16,\
    \ 9, 10, 13, 13, 12, 16, 15, 16, 11, 11, 15, 15, 16, 14, 14, 10, 11, 15, 15, 16,\
    \ 12, 15, 15, 16, 10, 13, 16, 16, 14, 14, 14, 10, 15, 16, 15, 16, 9, 9, 14, 15,\
    \ 10, 9, 15, 10, 12, 13, 16, 15, 14, 12, 16, 9, 10, 13, 13, 12, 16, 15, 16, 11,\
    \ 11, 15, 15, 16, 14, 14, 10, 11, 15, 15, 16, 12, 15, 15, 16, 10, 13, 16, 16,\
    \ 14, 14, 14, 10, 15, 16, 15, 16, 9, 9, 14, 15, 10, 9, 15, 10, 12, 13, 16, 15,\
    \ 14, 12, 16, 9, 10, 13, 13, 12, 16, 15, 16, 11, 11, 15, 15, 16, 14, 14, 10, 11,\
    \ 15, 15, 16, 12, 15, 15, 16, 10, 13, 16, 16, 14, 14, 14, 10, 15, 16, 15, 16,\
    \ 9, 9, 14, 15, 10, 9, 15, 10, 12, 13, 16, 15, 14, 12, 16, 9, 10, 13, 13, 12,\
    \ 16, 15, 16, 11, 11, 15, 15, 16, 14, 14, 10, 11, 15, 15, 16, 12, 15, 15, 16,\
    \ 10, 13, 16, 16, 14, 14, 14, 10, 15, 16, 15, 16, 9, 9, 14, 15, 10, 9, 15, 10,\
    \ 12, 13, 16, 15, 14, 12, 16, 9, 10, 13, 13, 12, 16, 15, 16, 11, 11, 15, 15, 16,\
    \ 14, 14, 10, 11, 15, 15, 16, 12, 15, 15, 16, 10, ", "  if numbers.length <= 2\n\
    \    numbers\n  else\n    numbers.min_by { |x| [Math.sqrt(Math.pow(numbers[0]\
    \ - x, 2) + Math.pow(numbers[1] - x, 2)), numbers[0], numbers[1]] }\n  end\nend",
  "  # Find the two smallest and two largest numbers and return them in order (smaller\
    \ number, larger number).\n  smallest = numbers[0]\n  largest = numbers[-1]\n\
    \  i = 1\n  while i < numbers.size - 1\n    if numbers[i] > largest\n      largest\
    \ = numbers[i]\n    i += 1\n  i = numbers.size - 1\n  while i >= 0\n    if numbers[i]\
    \ < smallest\n      smallest = numbers[i]\n    i -= 1\n  return smallest, largest\n\
    end", "  numbers_sorted = numbers.sort\n  first = numbers_sorted[0]\n  last =\
    \ numbers_sorted[-1]\n  smallest_difference = find_closest_difference_for_number(first,\
    \ last)\n  closest_numbers = []\n  for i in 1..numbers.size\n    if smallest_difference\
    \ == 0\n      closest_numbers.push(numbers[i])\n      break\n    closest_difference\
    \ = find_closest_difference_for_number(numbers[i], numbers[i-1]) + smallest_difference\n\
    \    closest_numbers.push(numbers[i])\n    smallest_difference = closest_difference\n\
    \  end\n  closest_numbers.sort!\n  return closest_numbers\nend", "\tmin, max =\
    \ numbers[0], numbers[0]\n\tnumbers.each do |number|\n\t\tif min > number\n\t\t\
    \tmin = number\n\t\tend\n\t\tif max < number\n\t\t\tmax = number\n\t\tend\n\t\
    end\n\treturn min, max\nend", "  numbers.sort, numbers = numbers.sort_by, numbers.reverse\
    \ # Ensure numbers is sorted (for use with binary search below)\n  numbers[0],\
    \ numbers[numbers.length - 1] = numbers[numbers.length - 1], numbers[0] # Swap\
    \ smallest and biggest number\n  index, closest = 0, numbers[0]\n  until index\
    \ >= numbers.length\n    return numbers[index], numbers[index + 1]\n    index\
    \ += 1\n  numbers[index], numbers[numbers.length - 1] = numbers[numbers.length\
    \ - 1], numbers[index] # Swap smallest and biggest number\n  index, closest =\
    \ 0, numbers[index]\n  until index >= numbers.length\n    return numbers[index],\
    \ numbers[index + 1]\n    index += 1\n  numbers[index], numbers[numbers.length\
    \ - 1] = numbers[numbers.length - 1], numbers[index] # Swap smallest and biggest\
    \ number\n  index, closest = 0, numbers[0]\n  until index >= numbers.length\n\
    \    return numbers[index], numbers[index + 1]\n    index += 1\n  numbers[index],\
    \ numbers[numbers.length - 1] = numbers[numbers.length - 1], numbers[index] #\
    \ Swap smallest and biggest number\nend\n</code>\n<|/ a tags=ruby,arrays,sorting,binary\
    \ |>\n<| a tags=ruby,arrays,sorting,binary |>\nHere's my take on it.\n<code>",
  "    smallest_number = numbers[0]\n    largest_number = numbers[0]\n    second_smallest_number\
    \ = numbers[0]\n    second_largest_number = numbers[0]\n    \n    elements.each\
    \ do |element|\n        if element < smallest_number || smallest_number == largest_number\n\
    \            if element < smallest_number\n                smallest_number = element\n\
    \            end\n            largest_number = element\n        end\n        if\
    \ element > largest_number || smallest_number == largest_number\n            if\
    \ element > largest_number\n                largest_number = element\n       \
    \     end\n            smallest_number = element\n        end\n        if element\
    \ < second_smallest_number || second_smallest_number == second_largest_number\n\
    \            if element < second_smallest_number\n                second_smallest_number\
    \ = element\n            end\n            second_largest_number = element\n  \
    \      end\n        if element > second_largest_number || second_smallest_number\
    \ == second_largest_number\n            if element > second_largest_number\n \
    \               second_largest_number = element\n            end\n           \
    \ second_smallest_number = element\n        end\n    end\n    \n    smallest_number\n\
    \    largest_number\n    second_smallest_number\n    second_largest_number\nend",
  "  min_value = numbers[0]\n  min_difference = Float::INFINITY", "\t\n\tminimums\
    \ = numbers.min\n\tmaximums = numbers.max\n\t\n\tminimum_index = 0\n\t\n\t# Go\
    \ through all numbers and find the smallest number\n\tfor i in 0..numbers.size\
    \ - 1\n\t\tif numbers[i] < minimums\n\t\t\tminimums = numbers[i]\n\t\t\tminimum_index\
    \ = i\n\t\t\t\n\t\n\t\n\t\n\t# Now find the next minimum value by subtracting\
    \ 1 from it\n\tfor i in 0..numbers.size - 1\n\t\tif numbers[i] - minimums > maximums\
    \ - numbers[i]\n\t\t\tminimums = numbers[i] - 1\n\t\t\tminimum_index = i\n\t\t\
    \t\n\t\n\t\n\t\n\t# Now find the next minimum value by subtracting 1 from it\n\
    \tfor i in 0..numbers.size - 1\n\t\tif numbers[i] - minimums < maximums - numbers[i]\n\
    \t\t\tminimums = numbers[i]\n\t\t\tminimum_index = i\n\t\t\t\n\t\n\t\n\t\n\t\n\
    \t# Now find the next minimum value by adding 1 to it\n\tfor i in 0..numbers.size\
    \ - 1\n\t\tif numbers[i] + minimums > maximums - numbers[i]\n\t\t\tminimums =\
    \ numbers[i] + 1\n\t\t\tminimum_index = i\n\t\t\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    # Now find the next minimum value by adding 1 to it\n\tfor i in 0..numbers.size\
    \ - 1\n\t\tif numbers[i] + minimums < maximums - numbers[i]\n\t\t\tminimums =\
    \ numbers[i]\n\t\t\tminimum_index = i\n\t\t\t\n\t\n\t\n\t\n\t\n\t\n\t# Now find\
    \ the next minimum value by adding 1 to it\n\tfor i in 0..numbers.size - 1\n\t\
    \tif numbers[i] + minimums < maximums - numbers[i]\n\t\t\tminimums = numbers[i]\n\
    \t\t\tminimum_index = i\n\t\t\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    # Return our two smallest elements\n\treturn numbers[minimum_index], numbers[minimum_index\
    \ + 1]", "  min_dist = 2\n  min_elements = nil\n  max_elements = nil\n  numbers.each\
    \ do |num|\n    distance = 0\n    max_dist = nil\n    min_dist = nil\n    numbers.each\
    \ do |n|\n      distance += num * Math.sqrt((n - num) * (n - num))\n      max_dist\
    \ = n if n > max_dist\n      min_dist = n if n < min_dist\n    end\n    if min_dist\
    \ == nil\n      min_dist = max_dist\n    end\n    if distance < min_dist\n   \
    \   min_dist = distance\n      min_elements = num\n    end\n    if max_dist ==\
    \ nil\n      max_dist = distance\n    end\n    if distance > max_dist\n      max_dist\
    \ = distance\n      max_elements = num\n    end\n  end\n  if min_dist == nil\n\
    \    min_dist = max_dist\n  end\n  if min_elements == nil\n    min_elements =\
    \ max_elements\n  end\n  return [min_elements, max_elements]\nend", "  return\
    \ numbers.inject(nil) do |(target, current_number), number|\n    if number ==\
    \ current_number\n      (target, current_number)\n    else\n      # Calculate\
    \ the difference between the current and target number\n      difference = target\
    \ - current_number", "  if numbers.length < 2\n    []\n  else\n    numbers[0,\
    \ numbers.length-1].inject([]){|result,number|\n      result.push(result[-1].nil?\
    \ ? number : result[-1] + number)\n      result\n    }\n  end\nend", "  numbers.sort.each_with_index\
    \ do |number, index|\n    yield(number, numbers[index + 1] if index + 1 < numbers.length)\n\
    \  end\nend\n</code>\nThis works by iterating through the numbers, and picking\
    \ out a number that we're currently considering, and a number that's one past\
    \ the number we started with.  It then yields both of them to the block, which\
    \ returns them in the order we want.\n<|/ a dscore=3 |>\n<| c |>\nThat is much\
    \ better than my solution, although I would probably use a `while numbers.any?`\
    \ instead of `if numbers.any?`\n<|/ c |>\n<| c |>\n: Yes, it is.  I was just being\
    \ slightly fancy, and I like being verbose.  ;)\n<|/ c |>\n<| c |>\nI actually\
    \ think this is a great solution, but it just seems so ugly compared to the other\
    \ solutions I've seen, with so many if statements and ternaries. Seems like there\
    \ should be some kind of array \"select\" method, but I can't seem to find one.\n\
    <|/ c |>\n<| c |>\n: Sure, you could do that.  I tried to avoid that because that's\
    \ a lot of code if you're just doing this once.  It's also a lot more difficult\
    \ to read than a single line.  ;)\n<|/ c |>\n<| c |>\nBut that's what I'm saying,\
    \ your solution seems to be more \"ruby-ish\", but I didn't know that Ruby had\
    \ an \"any\" method that works like Python's \"any\" method. I thought that it\
    \ was a built-in array method.\n<|/ c |>\n<| a tags=ruby |>\nAnother way to do\
    \ it is:\n<code>\n[10, 20, 30, 40, 50].each_cons(2).min", "  numbers.sort.each_with_index\
    \ { |n, i| return [n, numbers[i - 1]] unless i == 0 }\n  raise ArgumentError,\
    \ \"No two numbers exist within tolerance of any other\" unless numbers.size >\
    \ 2\n  raise ArgumentError, \"No two numbers exist within tolerance of each other\"\
    \ unless numbers.size == 2\n  [numbers[0], numbers[1]]\nend", "  numbers.sort!\n\
    \  closest = [numbers[0], numbers[1]]\n  for i in 2..numbers.count\n    dist =\
    \ (numbers[i] - closest[i - 1]) ** 2\n    if dist < closest[i] - closest[i - 1]\n\
    \      closest[i] = dist\n    end\n  end\n  return closest\nend", "  min_difference\
    \ = nil\n  min_element = nil\n  min_value = nil\n  numbers.each do |number|\n\
    \    if min_value == nil\n      min_value = number\n    else\n      new_difference\
    \ = (number - min_value).abs\n      if new_difference < min_difference\n     \
    \   min_difference = new_difference\n        min_element = min_value\n       \
    \ min_value = number\n      end\n    end\n  end\n  [min_element, min_value]\n\
    end", "  numbers.each_with_index do |number,index|\n    closest_index = index\
    \ + 1\n    closest_distance = distance(number, numbers[index])\n    break if closest_distance\
    \ == 0\n    break if closest_distance > numbers[index].abs\n    numbers[closest_index],\
    \ numbers[index] = numbers[index], numbers[closest_index]\n  end\n  return numbers\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
