name: HumanEval_158_find_max
language: rb
prompt: "# Write a function that accepts a list of strings.\n# The list contains different\
  \ words. Return the word with maximum number\n# of unique characters. If multiple\
  \ strings have maximum number of unique\n# characters, return the one which comes\
  \ first in lexicographical order.\n# find_max([\"name\", \"of\", \"string\"]) ==\
  \ \"string\"\n# find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n# find_max([\"\
  aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\ndef find_max(words)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
  \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
  name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
  , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
  , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
  ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
  , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"\
  are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\"\
  , \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
  this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"\
  ]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
  \  end\nend\n"
completions: ["  unique = words.size\n  words.each do |word|\n    chars = word.split(\"\
    \").size\n    if unique > chars\n      unique = chars\n    end\n  end\n  return\
    \ words[words.index(words[words.rindex { |word| word.split(\"\").size == unique\
    \ }])]\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\n def uniquechars(str)\n\
    \    str.split('').uniq.count\n  end\n</code>\n<|/ a tags=ruby-on-rails,ruby,arrays\
    \ dscore=1 |>\n<| c |>\nThis will also not work if the string contains any duplicates.\n\
    <|/ c |>\n<| a tags=ruby-on-rails,ruby,arrays |>\n<code>", "    words_count =\
    \ words.inject(Hash.new(0)) { |sum, w| sum[w] += 1 }\n    return \"\" unless words_count.has_key?(\"\
    \")\n    words_count.values.sort_by(&:last).first\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby |>\nThis is a classic problem to solve with Enumerable:\n\
    <code>", "  # TODO: Write your solution below:\nend", "  unique_characters = Hash.new(0)\n\
    \  unique_characters[:] = ['']*words.size # assign 0 to all characters\n  unique_characters[words[0]]\
    \ += 1\n  words[words.index {|word| word.length <= unique_characters[word].length}].each_with_index\
    \ do |word, i|\n    unique_characters[word] += 1\n    if unique_characters[word]\
    \ == unique_characters[words[i-1]]\n      return word\n    end\n  end\nend", " \
    \   words_with_duplicates = words.uniq.sort\n    unique_characters = words_with_duplicates.map\
    \ do |word|\n        word.chars.uniq.size\n    end\n    return words_with_duplicates.find\
    \ {|word| unique_characters.max == unique_characters.min }\nend\n</code>\nThe\
    \ code above works for your examples. I hope it will work for all your cases.\
    \ Hope it helps.\n<|/ a |>\n<| c |>\nI believe the correct answer is \"string\"\
    .\n<|/ c |>\n<| c |>\nI think the \"string\" is the answer for this case. I think\
    \ the code works as is.\n<|/ c |>\n<| a dscore=0 |>\nI believe the easiest way\
    \ to do this would be to sort the array by word length (strings are longer than\
    \ numbers), then iterate over the array in descending order until you find the\
    \ largest string (i.e. your most \"unique\" word)\n<|/ a tags=arrays,ruby |>\n\
    <| a tags=arrays,ruby dscore=0 |>\nI'd start by sorting the array by the number\
    \ of unique characters, then  keep track of the longest word, and whenever a new\
    \ word is added that has the same number of unique characters as the longest word,\
    \ swap it with the last longest word. That should keep track of the longest word\
    \ with most unique characters. \n<code>\nwords = [\"hello\", \"world\", \"hello\"\
    ]\nuniques = words.uniq.sort\nlongest = uniques.last\nlongest.uniques << uniques.count\n\
    uniques.each do |w|\n  if w.uniques == longest.uniques \n    longest = w\n  else\n\
    \    longest.uniques << w.uniques\n    w.uniques = longest.uniques.count\n  end\n\
    end\nputs longest\n</code>\n<|/ a |>\n<| a |>\n<code>\nwords = [\"aaaaaaa\", \"\
    bb\" ,\"cc\"]\nputs words.max_by { |x| x.chars.uniq.size }.try(:first)\n</code>\n\
    Output:\n<code>\ncc\n</code>\n<|/ a dscore=0 tags=arrays,ruby |>\n<| c |>\nThis\
    \ would only work if all the words have same number of unique characters. I think\
    \ it would be better to keep a variable for the max number of unique characters.\
    \ Also it would be better if we return the word which has max number of unique\
    \ characters instead of returning all words that have max number of unique characters.\
    \ Also it would be better if we return the word which has max number of unique\
    \ characters first.\n<|/ c |>\n<| a |>\nYou can do it this way and get the answer:\n\
    <code>", "  unique_chars = words.uniq.count\n  words.uniq.sort {|a, b| a.length\
    \ <=> b.length }\n  words.uniq.first\nend", "  # TODO: Write your code here.\n\
    \  max = 0\n  max2 = 0\n  maxword = \"\"\n  for i in words\n    if i.length >\
    \ max\n      max = i.length\n      max2 = i.length\n      maxword = i\n  for i\
    \ in words\n    if i.length == max2 and i.length < max\n      maxword = i\n  words.index(maxword)\n\
    end\n</cell>\n<text>\nQ3. Given a string, return the count of its vowels\n(A,\
    \ E, I, O, U).", "  maximum = []\n  words.each do |word|\n    count = word.uniq.count\n\
    \    if count == maximum.count\n      maximum = word\n    else\n      maximum\
    \ = count\n    end\n  end\n  maximum\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby\
    \ |>\n<code>\n\"hello\".split\n => [\"hello\"] \n\"hello\".split.uniq\n => [\"\
    h\", \"e\", \"l\", \"l\", \"o\"] \n</code>\nUse split: it splits the string into\
    \ an array of characters and then unique will remove duplicates.\n<|/ a dscore=1\
    \ |>\n<| c |>\nI think you misunderstood what OP wants. He doesn't want to split\
    \ a string into characters but to count the number of unique characters in that\
    \ string.\n<|/ c |>\n<| c |>\n: Thanks. I wasn't sure about my interpretation.\
    \ Updated my answer.\n<|/ c |>\n<| c |>\n, thanks guys. this is what i was looking\
    \ for :)\n<|/ c |>\n<| a |>\n<code>\n\"hello\".split\n</code>\ngives an array\
    \ of characters.\n<code>\n\"hello\".split.uniq\n</code>\ngives a de-duplicated\
    \ array, so you just want this:\n<code>\n\"hello\".split.size\n</code>\n<|/ a\
    \ tags=ruby dscore=1 |>\n<| a dscore=1 |>\n<code>\n\"hello\".split('').uniq.count\n\
    </code>\n<|/ a tags=ruby |>\n<| a |>\nIf you've got this list of strings:\n<code>\n\
    [\"abc\", \"d\", \"e\", \"g\"]\n</code>\nYou can get the max by doing this:\n\
    <code>\n[\"abc\", \"d\", \"e\", \"g\"].uniq.max", "  words.sort_by { |word| word.length\
    \ }\n  max_length = words.length\n  max_word = words[max_length-1]\n  while max_word.length\
    \ < max_length\n    max_length -= 1\n    if max_length < 1\n      return \"\"\n\
    \    end\n    max_word = words[max_length-1]\n  end\n  max_word\nend\n</cell>\n\
    <code language=conda-env-chemistry-py>\nfind_max([\"aaaaaaa\", \"bb\" ,\"cc\"\
    ])\n</cell>\n<code language=conda-env-chemistry-py>\nfind_max([\"aaaaaaa\", \"\
    bb\" ,\"cc\"]).to_s # Remove .to_s once the code works\n</cell>\n<code language=conda-env-chemistry-py>",
  "  # write your code here\n  max_count = Hash.new(0)\n  words_with_count = words.group_by{|x|\
    \ x}.sort{|a,b| a.length <=> b.length}.values\n  words_with_count.each do |word|\n\
    \    count = word.length\n    word.each_byte do |c|\n      count -= 1\n      if\
    \ count<0\n        break\n      end\n    end\n    if max_count[count]==nil\n \
    \     max_count[count]=word\n    end\n  end\n  return max_count.values.first\n\
    end\n</code>\nI got that answer from here. \nBut this only works if the string\
    \ contain only ASCII, other language or other characters will cause wrong result.\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks man. I am new to Ruby. Could you elaborate\
    \ on what to do in the code? Specifically I don't get what max_count = Hash.new(0).\
    \ Also I don't quite understand how you sort and group the words.\n<|/ c |>\n\
    <| c |>\nI added comments in the code itself. Also I updated my answer for grouping\
    \ words with same count.\n<|/ c |>\n<| c |>\nThis is great! But I got another\
    \ problem. My program is just giving a \"NameError: undefined local variable or\
    \ method `words' for main:Object (NameError)\" error after it prints out the word\
    \ with the maximum count. Could you please tell me what I am doing wrong?\n<|/\
    \ c |>\n<| c |>\nHi, I forgot to add the argument `words`. Please see my updated\
    \ answer.\n<|/ c |>\n<| c |>\nThank you so much! It worked. One more question.\
    \ I tried to use the program with words that contain non-ASCII characters (such\
    \ as Russian letters, Chinese letters, etc) and it didn't work. Is there a way\
    \ to make the program work with any characters?\n<|/ c |>\n<| a dscore=0 |>\n\
    I realize this is an old thread, but I thought this might be helpful to someone.\
    \ I was also looking for an answer to this question, and I found this to be very\
    \ helpful and very simple.\n<code>\nputs \"Enter a string\"\nx = gets.chomp\n\
    x.split.group_by{|i| i}\n</code>\nThis returns an array with each character in\
    \ an array entry, with the count of the number of times each character appears.\
    \ If you wanted to, you could just grab the max of the array, or take the max\
    \ of one of the values, or just print out each value, etc.\n<|/ a tags=string,ruby\
    \ |>\n<| c |>\nThis ", "    words.each_index do |i|\n        char = words[i][0]\n\
    \        count = 1\n        words[i].each do |w|\n            count += 1 if w\
    \ == char\n        end\n        if count == words.count\n            return words[i]\n\
    \        end\n    end\n    return \"\"\nend", "    # Write your code here\n  \
    \  words=words.sort.uniq\n    word=words[words.count,1]\nend\n</code>\n<|/ a tags=ruby,sorting\
    \ dscore=2 |>\n<| c |>\nThis doesn't return the word that comes first in lexicographical\
    \ order, does it?\n<|/ c |>\n<| c |>\nI believe it does\n<|/ c |>\n<| c |>\nIf\
    \ you want the last word in the array you could use words=words.sort!.reverse!\
    \ . Word would then be the last word in the array\n<|/ c |>\n<| c |>\n, This code\
    \ was meant for Ruby 1.9, if you're using 1.8 or older you'll have to make an\
    \ alternate implementation. The one I wrote is for 1.9+\n<|/ c |>\n<| c |>\nI\
    \ used 1.9.2 because i don't have the latest version. Yeah, this doesn't return\
    \ the word that comes first in lexicographical order, though.\n<|/ c |>\n<| a\
    \ dscore=2 |>\n<code>\nwords = ['name','of','string','enam','game','aaaaaaa','bb','cc']\n\
    words.sort_by{|w| w.length}.uniq.last", "  max_count = -1\n  word = nil\n  \n\
    \  # Loop the words in words to find the word with max count\n  words.each do\
    \ |word|\n    count = {}\n    # Loop the words in words\n    words.each do |word_2|\n\
    \      if count != {}\n        word_2.each_char do |c|\n          count[c] = count[c]\
    \ + 1 if count[c] > 0\n        end\n      end\n    end\n    \n    if count.max_by{|k,\
    \ v| v} > max_count\n      max_count = count.max_by{|k, v| v}\n      word = word\n\
    \    end\n  end\n  \n  return word\nend", "  max_unique_count = 0\n  max_unique_word\
    \ = \"\"\n  words.each do |word|\n    unique_count = word.chars.uniq.size\n  \
    \  if unique_count > max_unique_count\n      max_unique_count = unique_count\n\
    \      max_unique_word = word\n    end\n  end\n  if max_unique_word\n    max_unique_word\n\
    \  else\n    words[0]\n  end\nend", "  words.each_with_index do |word, i|\n  \
    \  max_count = 0\n    words.each_with_index do |word2, j|\n      count = word.count(word2)\n\
    \      if count > max_count\n        max_count = count\n        max_word = word2\n\
    \      end\n    end\n    return max_word\n  end\nend", "  words_with_count = []\n\
    \  words.each do |word|\n    char_count = word.chars.uniq.count\n    words_with_count\
    \ << [word, char_count]\n  end\n  words_with_count.sort! { |a,b| b[1] <=> a[1]\
    \ }\n  words_with_count.last[0]\nend\n</code>\nIt sorts the words with the number\
    \ of unique characters and returns the last word of the list with the most characters.\
    \ \nIn Ruby we can use Enumerable#sort which sorts an array in place. You can\
    \ also use the order method to sort the words with most characters:\n<code>\n\
    words.sort { |a,b| b.chars.uniq.count <=> a.chars.uniq.count }\n</code>\n<|/ a\
    \ tags=string,ruby |>\n<| c |>\nA very simple and elegant solution - thanks very\
    \ much :)\n<|/ c |>\n<| a tags=string,ruby |>\nA simple way to approach this would\
    \ be to sort the array of words by length of character and return the last word\
    \ with the highest number of characters. Here's how you could do that:\n<code>",
  "  \nend\n</cell>\n<cell>", "  words.uniq.length.min\nend", "    words.size\n  \
    \  word = words[0]\n    letters = []\n    uniques = []\n    \n    letter = word[0]\n\
    \    letters << letter\n    uniques << letter\n    \n    wordSize = words.size\n\
    \    words[0].length\n    \n    \n    \n    #loop through each word\n    wordSize\
    \ = words.size\n    \n    for i in 1..wordSize-1\n        word = words[i]\n  \
    \      letter = word[0]\n        \n        \n        #loop through each letter\
    \ in current word\n        letterSize = letters.size\n        \n        for j\
    \ in 1..letterSize-1\n            letter = letters[j]\n            \n        \
    \    if letters.include? letter\n                #if the letter already exists\
    \ in the current word, ignore it\n                next\n            else\n   \
    \             #if the letter does not exist in the current word, add it\n    \
    \            letters << letter\n                uniques << letter\n          \
    \      \n            end\n        end\n    end\n    \n    #loop through each unique\
    \ letter\n    uniqueSize = uniques.size\n    \n    for j in 1..uniqueSize-1\n\
    \        letter = uniques[j]\n        \n        if letters.include? letter\n \
    \           #if the letter already exists in the current word, ignore it\n   \
    \         next\n        else\n            #if the letter does not exist in the\
    \ current word, add it\n            letters << letter\n            uniques <<\
    \ letter\n            \n        end\n    end\n    \n    #loop through each unique\
    \ letter\n    uniqueSize = uniques.size\n    \n    for j in 1..uniqueSize-1\n\
    \        letter = uniques[j]\n        \n        if letters.include? letter\n \
    \           #if the letter already exists in the current word, ignore it\n   \
    \         next\n        else\n            #if the letter does not exist in the\
    \ current word, add it\n            letters << letter\n            uniques <<\
    \ letter\n            \n        end\n    end\n    \n    \n    \n    letters.uniq.each\
    \ do |letter|\n        return letter\n    end\n    \n    return \"\"\nend", " \
    \ maxWord = \"\"\n  maxCount = 1\n  words.each { |word| word.chars.uniq.count.to_i\
    \ }.max { |wordCount, word| wordCount > maxCount }.each_char.min_by { |c| c.ord\
    \ }\nend", "    words.uniq.max_by {|word| word.chars.count}\nend", "  unique_chars\
    \ = Hash.new(0)\n  unique_chars.merge! {|key, val| val}\n  unique_chars.reverse_merge!\
    \ {|key, val| val}\n  unique_chars.merge! {|key, val| val}", "  words.sort_by(&:length).last\n\
    end", "  words.each do |word|\n    word.split(\"\").sort.uniq.size < word.split(\"\
    \").size ? word = word.split(\"\").sort.uniq.pop : word\n  end\n  words.first\n\
    end", "  word=words[0]\n  char=0\n  for x in words\n    word=word\n    char=char\n\
    \    break\n  words.shift\n  words.each{|x|word=x}\n  char=char+1\n  words.each{|x|word=x}\n\
    \  words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n \
    \ words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n\
    \  words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n \
    \ words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n\
    \  words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n \
    \ words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n\
    \  words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n \
    \ words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n\
    \  words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n \
    \ words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|word=x}\n\
    \  words.each{|x|word=x}\n  words.each{|x|word=x}\n  words.each{|x|", "  a = words[0]\n\
    \  b = words[1]\n  c = words[2]\n  max = -1\n  i = 1\n  while i < words.length\n\
    \    a = words[i]\n    max = b\n    b = words[i+1]\n    c = words[i+2]\n    i\
    \ = i + 3\n    return c\n  end\nend", "    # Your code here\n    hash = Hash.new(0)\n\
    \    max = Hash.new(0)\n    for w in words\n        if hash[w]\n            if\
    \ hash[w] >= max[w]\n                max = hash\n                max[w] = hash[w]\n\
    \            end\n        else\n            hash[w] = 1\n        end\n    end\n\
    \    return max[words[words.index{|w| hash[w] == max[w]}]] if max\nend\n</cell>\n\
    <code language=julia-1.6>\nfind_max([\"aaaaaaa\", \"bb\" ,\"cc\"])\n</cell>\n\
    <text>\nThe maximum is \"bb\", not \"cc\", but \"cc\" comes before \"bb\" in the\
    \ lexicographical order (first come, first serve).", "  # Use set to remove duplicates\n\
    \  unique = words.map{ |s| s.split('') }.flatten.uniq\n  # Return nil if words\
    \ is nil\n  return unique.nil? ? nil : unique.sort[0]\nend", "  words.sort!\n\
    \  word_hash = {}\n  word = nil\n  words.each do |word|\n    word.split('').each\
    \ do |char|\n      word_hash[char] = word_hash.has_key?(char) ? word_hash[char]\
    \ + 1 : 1\n    end\n    if word_hash.has_key?(\"\")\n      word = word_hash[\"\
    \"]\n    end\n    word_hash = word_hash.delete_if { |k,v| v == word_hash[k] }\n\
    \  end\n  if word_hash.has_key?(\"\")\n    word = word_hash[\"\"]\n  end\n  return\
    \ word\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for your effort. I think this\
    \ solution is O(n) complexity? Because we are looping through all words in the\
    \ sorted order?\n<|/ c |>\n<| c |>\nThanks for the feedback. Yes, it is O(n),\
    \ since we are traversing through each word of the sorted array. This is the most\
    \ efficient algorithm that I can think of. Since you said you were using Ruby\
    \ 1.8.7 or 1.9.2, then you should be able to take advantage of the `each_char`\
    \ method which returns the characters of a string as an array. Since you will\
    \ be doing the same thing for each character (i.e. counting the number of occurrences\
    \ of each character), it shouldn't be too bad, although you could do some optimizations.\
    \ Sorry if this didn't help the O(n) complexity. I hope it helps some.\n<|/ c\
    \ |>\n<| a dscore=2 tags=ruby,string,sorting,algorithm |>\nI believe this is what\
    \ you are looking for:\n<code>", "  new_words = []\n  \n  words.each do |word|\n\
    \    temp_words = []\n    new_word = word\n    word.chars.each do |char|\n   \
    \   temp_words << char if temp_words.include?(char)\n    end\n    new_words.push(temp_words)\n\
    \  end", "  result = \"\"\n  sorted_list = words.sort_by{ |w| w.size }.map{ |w|\
    \ w.reverse }\n  sorted_list.each do |w|\n    if w.size > result.size\n      result\
    \ = w\n    end\n  end\n  result\nend\n</code>\n<|/ a |>\n<| a |>\nThis question\
    \ is similar to longest common substring, and its answer is to iterate over the\
    \ list. It can be easily extended to longest common substring with arbitrary length\n\
    <code>", "  words.sort() #sort array in ascending order\n  word = words[0]\n \
    \ i = 0\n  while i < words.length\n    if word.size == words[i].size\n      word.concat(words[i])\
    \ #add word[i] to word\n      word.uniq!\n      i += 1\n    else\n      if words[i]\
    \ == \"\"\n        word.concat(words[i])\n      end\n    end\n  end\n  word\n\
    end", "    sorted = words.sort(&:count)\n    sorted.first\nend", "  words_and_counts\
    \ = words.each_with_object(Hash.new(0)) {|word, counts| counts[word] += 1 }\n\
    \  max_count = words_and_counts.values.max\n  max_word = \"#{max_count}\".to_sym\
    \ unless max_count.zero?\n  max_word = \"\" unless max_word\n  words_and_counts.keys.min_by\
    \ { |word| words_and_counts[word].to_i }\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ does not handle empty strings in input at all.\n<|/ c |>\n<| a |>\nA very nice\
    \ solution with no additional libraries:\n<code>", "  words.sort!\n  words.length.downto(1).each\
    \ do |length|\n    length.times do |i|\n      i === words.length - 1 ? words.delete\
    \ : break\n    end\n  end\n  words.first || \"\"\nend\n</code>\n<code>", "   \
    \ my_hash = {}\n    my_hash[\"words\"] = []\n    my_hash[\"characters\"] = {}\n\
    \    my_hash[\"number_of_unique_characters\"] = {}\n    my_hash[\"first_letters\"\
    ] = {}\n    my_hash[\"number_of_characters\"] = 0\n    my_hash[\"first_letter\"\
    ] = 0\n    my_hash[\"number_of_unique_characters_after_first_letter\"] = {}\n\
    \    my_hash[\"unique_characters_after_first_letter\"] = {}\n    my_hash[\"number_of_unique_characters_after_first_letter\"\
    ] = {}\n    my_hash[\"number_of_unique_characters_after_first_letter\"] = {}",
  "  sorted_list = words.sort.uniq\n  if sorted_list.size == words.size then\n   \
    \ return sorted_list.first\n  else\n    return \"\"\n  end\nend", "    word_length\
    \ = words.uniq.count{|w| w.length }\n    return \"\" if word_length.zero?\n  \
    \  \n    max_length = words.uniq.max { |a, b| a.length <=> b.length }\n    max_length.slice!(0)\
    \ if max_length.size == 1\n    max_length\nend", "  return nil if words.empty?\n\
    \  max_count = 0\n  max_word = nil\n  words.each do |word|\n    count = word.chars.length\n\
    \    next if count == max_count\n    max_count = count\n    max_word = word\n\
    \  end\n  return max_word\nend", "  unique_count = 0\n  max = \"\"\n  unique_char\
    \ = nil\n  words.each do |word|\n    word.each_char do |char|\n      if unique_char\
    \ == nil\n        unique_char = char\n      elsif char == unique_char\n      \
    \  unique_count += 1\n      else\n        unique_count = 0\n        unique_char\
    \ = char\n      end\n    end\n    if unique_count\n      if unique_count > max\n\
    \        max = word\n      end\n      unique_count = 0\n    end\n  end\n  return\
    \ max\nend", "  words.map! { |word| word.downcase.split(\"\").uniq.size }.max\n\
    end", "  return words[words.index(words.sort{|a,b| a.length <=> b.length}.first)]\
    \ if words.size > 1\n  words.sort{|a,b| a.length <=> b.length}.first\nend", " \
    \ max_unique_characters = Hash.new(0)\n  word_count = 0\n  word_array = []\n \
    \ word_array.push(*words)\n  word_array.uniq.each do |word|\n    word_count +=\
    \ word.count(\"a\")\n    word_count += word.count(\"b\")\n    word_count += word.count(\"\
    c\")\n    word_count += word.count(\"d\")\n    word_count += word.count(\"e\"\
    )\n    word_count += word.count(\"f\")\n    word_count += word.count(\"g\")\n\
    \    word_count += word.count(\"h\")\n    word_count += word.count(\"i\")\n  \
    \  word_count += word.count(\"j\")\n    word_count += word.count(\"k\")\n    word_count\
    \ += word.count(\"l\")\n    word_count += word.count(\"m\")\n    word_count +=\
    \ word.count(\"n\")\n    word_count += word.count(\"o\")\n    word_count += word.count(\"\
    p\")\n    word_count += word.count(\"q\")\n    word_count += word.count(\"r\"\
    )\n    word_count += word.count(\"s\")\n    word_count += word.count(\"t\")\n\
    \    word_count += word.count(\"u\")\n    word_count += word.count(\"v\")\n  \
    \  word_count += word.count(\"w\")\n    word_count += word.count(\"x\")\n    word_count\
    \ += word.count(\"y\")\n    word_count += word.count(\"z\")\n  end\n  word_array.uniq.each\
    \ do |word|\n    word_count += word.count(\"a\")\n    word_count += word.count(\"\
    b\")\n    word_count += word.count(\"c\")\n    word_count += word.count(\"d\"\
    )\n    word_count += word.count(\"e\")\n    word_count += word.count(\"f\")\n\
    \    word_count += word.count(\"g\")\n    word_count += word.count(\"h\")\n  \
    \  word_count += word.count(\"i\")\n    word_count += word.count(\"j\")\n    word_count\
    \ += word.count(\"k\")\n    word_count += word.count(\"l\")\n    word_count +=\
    \ word.count(\"m\")\n    word_count += word.count(\"n\")\n    word_count += word.count(\"\
    o\")\n    word_count += word.count(\"p\")\n    word_count += word.count(\"q\"\
    )\n    word_count += word.count(\"r\")\n    word_count += word.count(\"s\")\n\
    \    word_count += word.count(\"t\")\n    word_count += word.count(\"u\")\n  \
    \  word_count += word.", "  max_count = words.reduce(0) { |i,w| i + (w.count('a')\
    \ + w.count('o') + w.count('i') + w.count('u'))}\n  words.each do |word|\n   \
    \ if word.count > max_count\n      max_count = word.count\n    end\n  end\n  return\
    \ words.first if max_count == words.first.count\n  words.find { |word| word.count\
    \ > max_count }.first\nend", "  word = words[0]\n  char_count = Hash.new(0)\n\
    \  words.each do |word|\n    char_count[word] += 1\n  end\n  char_count.max_by{\
    \ |k, v| v }.first\nend", "  unique = words.group_by { |word| word.count() }.map\
    \ { |k, v| k }.sort.last || \"\"\n  words.detect { |word| word.count() == word.count()\
    \ rescue false }\nend", "  uniq_chars = {}\n  words.each do |word|\n    word.chars.uniq.each\
    \ do |char|\n      uniq_chars[char] ||= []\n      uniq_chars[char] << word\n \
    \   end\n  end\n  max = uniq_chars.values.max_by{|uniq_char| uniq_char.size}\n\
    \  return max.empty? ? \"\" : \"#{max.first}\"\nend", "  result = \"\"\n  words.each\
    \ do |word|\n    word = word.chars.uniq.count\n    words[words.index(word) + 1]\
    \ if word > result\n    result = word\n  end\n  result if result != \"\"\nend",
  "\tword_with_max_chars = \"\"\n\tword_with_max_count = 0\n\twords.each do |word|\n\
    \t\tword.chars.uniq.each do |c|\n\t\t\tword_with_max_count = word_with_max_count\
    \ + 1\n\t\t\tif word_with_max_count > word_with_max_chars.length\n\t\t\t\tword_with_max_chars\
    \ = word\n\t\t\t\tword_with_max_chars.chars.uniq.each do |c|\n\t\t\t\tend\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn word_with_max_chars\nend", "\tword=words[0]\n\t\
    for i in 0..words.length-1\n\t\tj=i+1\n\t\twhile j<words.length\n\t\t\tif words[j]\
    \ == word\n\t\t\t\tword.delete(i)\n\t\t\t\twords[j].delete(i)\n\t\t\t\tbreak\n\
    \t\t\tend\n\t\t\tj+=1\n\t\tend\n\t\tword=words[0]\n\tend\n\tword\nend", "    max\
    \ = words.sort_by { |s| -s.chars.uniq.size }.first\n    words.each { |s| max =\
    \ s.chars.uniq.size > max ? s.chars.uniq.size : max }\n    max == 0 ? \"\" : words.sort_by\
    \ { |s| -s.chars.uniq.size }.find { |s| s.chars.uniq.size == max }.first\nend\n\
    </code>\n<|/ a tags=ruby,string,arrays,character dscore=0 |>\n<| c |>\nThank you\
    \ for answering!  I've been trying to understand how this works, but I keep getting\
    \ a \"NoMethodError: undefined method `chars' for #<Array:0x3ab5ec0>\" error when\
    \ I try to run it.\n<|/ c |>\n<| c |>\nSorry my bad.  You have to convert to strings\
    \ to get this work.  See my updated answer.\n<|/ c |>\n<| a |>\nAnother way to\
    \ look at it:\n<code>", "  words.sort!\n  last_letter = words.pop\n  words.reverse.each_with_index\
    \ do |word, index|\n    if word.length == last_letter.length\n      if word.index(last_letter)\n\
    \        return word\n      else\n        return words[(index+1)]\n      end\n\
    \    end\n  end\nend", "    words = words.sort { |a, b| a.size <=> b.size }\n\
    \    return words[0] if words.size > 1\n    words[0]\nend\n</cell>\n<cell>", " \
    \ unique_count = words.inject(Hash.new(0)) { |h, s| h[s] += 1; h }\n  unique_count.max_by\
    \ { |k, v| v.to_i }[0] rescue \"\"\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    Yeah, I am very new to Ruby. Thank you for teaching me something new today.\n\
    <|/ c |>\n<| c |>\nJust to let you know: this approach isn't working on Ruby 1.9.3,\
    \ it does work on Ruby 2.1.5. But please notice that `inject` method is not available\
    \ until Ruby 1.9. If you need a solution working with Ruby 1.9.3 or 1.9.4, you\
    \ can check out my answer that uses a `Hash` instead.\n<|/ c |>\n<| a tags=ruby,algorithm\
    \ |>\nI believe I've found a more simple and effective solution to this problem.\
    \ I've posted it here in case someone needs it.\n<code>", "  words.uniq.length.max_by\
    \ { |x| x }\nend\n</code>\nI chose to write it in a way that makes sense to me.\
    \  You might find it easier to understand if written like this:\n<code>", "  maximum\
    \ = 0\n  maximum_string = \"\"", "    count = Hash.new(0)\n    words.each do |word|\n\
    \        count[word.downcase] += 1\n    end\n    count.max_by{|k, v| v}\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\n`count[word.downcase] += 1` could simply\
    \ be `count[word] += 1`.\n<|/ c |>\n<| c |>\n: That won't work if word contains\
    \ non ASCII characters.\n<|/ c |>\n<| c |>\n: Thanks, I just changed that.\n<|/\
    \ c |>\n<| c |>\n`find_max([\"aa\", \"b\", \"c\"]) == \"c\"` gives wrong answer\
    \ with `\"a\".downcase == \"a\"`\n<|/ c |>\n<| c |>\nThank you, it's really helpful\
    \ for me!\n<|/ c |>\n<| a dscore=3 |>\nThe other answers are correct in their\
    \ approach, but they're all O(n), which is not good if you have a lot of words\
    \ to sort.\nWhat you're really looking for is a hash which keeps its keys sorted\
    \ by its values. This is exactly what counting sorts do.\n<code>\nrequire 'countingsort'",
  "  words.each_with_index.inject(\"\") do |max, (word, index)| \n    max << word[index]\
    \ unless word[index] == max[max.length-1]\n  end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nWhile this answer isn't wrong, it's too complicated.\n<|/ c |>\n\
    <| c |>\nI agree with you but I just wanted to explain that OP's code was almost\
    \ correct and I was trying to give an alternative without looking too much at\
    \ OP's code - so I used the simplest possible solution. My intention was only\
    \ to point out that OP's code is also correct and I just wanted to point out that\
    \ there is another way without looking too much (I guess there are lots of people\
    \ that don't like `each_with_index` approach and will try to find a way to do\
    \ it with `reduce`...).\n<|/ c |>\n<| c |>\nAgreed, thank you, I'm always looking\
    \ for alternatives\n<|/ c |>\n<| c |>\nI added a simpler version based on your\
    \ suggestion\n<|/ c |>\n<| c |>\nYour code doesn't work if you have a hash with\
    \ more than one unique key. E.g. `{\"a\" => \"b\", \"a\" => \"c\"}`. Also you\
    \ seem to have forgotten that strings sort in the reverse order as compared to\
    \ integers, so `\"cc\"` is sorted before `\"bbbbbb\"`.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  max = \"\"\n  count = 0\n  words.each do |word|\n    chars =\
    \ word.split('').uniq.length\n    count = chars if chars > count\n    max = word\
    \ if chars == count\n  end\n  max\nend\n</code>\n<|/ a tags=ruby,algorithm,string\
    \ dscore=0 |>\n<| c |>\nThat makes sense. Thanks for the explanation!\n<|/ c |>\n\
    <| a |>\nThis is a fun exercise that took me some time to solve. I think the answers\
    \ above are great and should work but I found a really clever way to go about\
    \ it. In my solution, I use recursion to solve the problem but I am sure there\
    \ is a way to do it without recursion if someone can come up with a way that isn't\
    \ recursive. Anyway here is the solution.\n<code>", "  word_hash = Hash.new(0)\n\
    \  words.each do |word|\n    word_hash[word] += 1\n  end\n  sorted_hash = word_hash.sort_by\
    \ {|k, v| -v}\n  if sorted_hash.size > 1\n    sorted_hash[1]\n  else\n    \"\"\
    \n  end\nend", "    unique_set = Set.new\n    unique_word = \"\"\n    word_len\
    \ = 0\n    word_string = \"\"\n    \n    words.each do |word|\n        word_string\
    \ += word.to_s\n        word_len += 1\n        unique_set = unique_set + word.chars\n\
    \    end\n    \n    unique_set.each do |char|\n        word_string = word_string.gsub(char,\
    \ \"\")\n        if word_string.empty?\n            return word_string\n     \
    \   end\n    end\n    return \"\"\nend", "  unique_chars = Hash.new(0)\n  words.each\
    \ do |word|\n    word.each_char do |char|\n      unique_chars[char] += 1\n   \
    \ end\n  end\n  \n  max_char = unique_chars.max_by {|k, v| v}\n  if max_char.nil?\n\
    \    \"\"\n  else\n    max_char[0]\n  end\nend", "  # Your code here\n  max_count\
    \ = words.count\n  word = nil\n  words.each do |word|\n    word_length = word.length\n\
    \    max_count = word.count\n    if (max_count > word_length) \n      word = word\n\
    \    end\n  end\n  return word\nend\nputs find_max([\"name\", \"of\", \"string\"\
    ])\nputs find_max([\"name\", \"enam\", \"game\"])\nputs find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"])\n</cell>\n<text>\nGreat Job!\nThat is it!  Hopefully this little\
    \ notebook has given you an idea of how to complete the challenge.  Feel free\
    \ to play with the code; it is a great way to learn.  And again, don't be afraid\
    \ to ask for help on stack overflow and we will do our best to help.", "  words.each_with_index.inject(\"\
    \") do |result, (a,i,_)|\n    count = result.count a if result.count a > 1\n \
    \   result.concat(a if count == 0)\n    count\n  end\nend\n</cell>\n<cell>\nfind_max([\"\
    name\", \"of\", \"string\"])\n</cell>\n<cell>\nfind_max([\"name\", \"enam\", \"\
    game\"])\n</cell>\n<cell>\nfind_max([\"aaaaaaa\", \"bb\" ,\"cc\"])\n</cell>\n\
    <text>\n13. Find the maximum in a string array.\nThe function takes a list of\
    \ strings as an argument. Your function should return the maximum of the list.",
  "  max_count = 0\n  max_word = nil\n  words.each do |word|\n    count = word.count\
    \ # count the number of occurences of each word\n    if count > max_count\n  \
    \    max_count = count\n      max_word = word\n    end\n  end\n  return max_word\n\
    end", "  sorted_words = []\n  word_frequency = {}\n  # Sort words from longest\
    \ to shortest\n  words[0..-2].each { |word| sorted_words << word }\n  # Count\
    \ how many unique characters each word has\n  words.each { |word| word_frequency[word]\
    \ = word_frequency.fetch(word,0) + 1 }\n  # Find out word with the highest number\
    \ of unique characters\n  sorted_words.each do |word|\n    if word_frequency.has_key?(word)\n\
    \      word_frequency.delete(word)\n      break if word_frequency.size >= words.length\n\
    \    end\n  end\n  word_frequency.delete_if {|word,freq| freq < words.length}\n\
    \  return word_frequency.keys.sort.first\nend\n</code>\n<|/ a dscore=3 tags=ruby,arrays\
    \ |>\n<| c |>\nThis works for the example provided but doesn't scale well when\
    \ the array gets very large. For a array of ~10,000 words, it runs over an hour\
    \ before I finally gave up on it.\n<|/ c |>\n<| a |>\nThis is not the most efficient\
    \ algorithm but still it solves the problem in O(n). \n<code>", "  char_count\
    \ = Hash.new(0)\n  words.sort.each do |word|\n    char_count[word.chars.join]\
    \ ||= 0\n    char_count[word.chars.join] += 1\n  end\n  max_word = char_count.keys.sort.last\n\
    \  return max_word if char_count.has_key?(max_word)\n  words.reverse.sort.each\
    \ do |word|\n    char_count[word.chars.join] ||= 0\n    char_count[word.chars.join]\
    \ += 1\n  end\n  return char_count.keys.sort.last\nend", "  words = [word.split(//)\
    \ for word in words]\n  words_with_count = words.map{|word| [word,words.count(word)]}\n\
    \  words_with_count.max{|a,b| b.last}[0]\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\n`words.map{|word| [word,words.count(word)]}` ***is not*** the most\
    \ efficient way to count unique chars in words.\n<|/ c |>\n<| c |>\nHe didn't\
    \ ask for efficiency, he asked for a solution. And I don't see any other way to\
    \ do it. This is simply a way of counting the unique characters in a string.\n\
    <|/ c |>\n<| a dscore=1 |>\nTry this :\n<code>\na = \"aaaabbbcc\"\na.chars.uniq.sort\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=0 |>\n<code>", "    unique_count\
    \ = Hash.new(0)\n    unique_char = nil\n    words.each do |word|\n        if unique_char\
    \ != nil\n            if unique_char.count == unique_count.count\n           \
    \     unique_char.each do |char|\n                    unique_count[char] += 1\n\
    \                end\n            elsif unique_count[unique_char.last].count ==\
    \ unique_count.count\n                unique_char.each do |char|\n           \
    \         unique_count[char] += 1\n                end\n            end\n    \
    \    end\n        unique_char = unique_char.nil? ? word : nil\n        unique_char\
    \ = word.split(//).uniq.size if unique_char == nil\n        unique_count[unique_char.last]\
    \ += 1\n    end\n    unique_char.each do |char|\n        unique_count[char] =\
    \ unique_count.delete(char) if unique_count.has_key?(char)\n    end\n    unique_char.empty?\
    \ ? nil : unique_char.last\nend\n</code>\n<|/ a tags=algorithm,ruby,string,ruby-on-rails,sorting\
    \ |>\n<| a dscore=2 tags=algorithm,ruby,string,ruby-on-rails,sorting |>\nJust\
    \ for the fun of it I made this solution using Ruby's sort and uniq methods\n\
    <code>", "  words.inject([]) do |m, word|\n    m << word if m.count(word).zero?\
    \ or m[-1] != word\n    m[-1]\n  end\nend", "    unique_chars = Set.new\n    sorted_chars\
    \ = words[0..words.count - 1].sort_by { |w| w.size }.join\n    unique_chars.merge(sorted_chars)\n\
    \    \n    words[0..words.count - 1].sort_by { |w| w.size }.join.downcase if unique_chars.size\
    \ == words.size\nend", "    max_length = 0\n    word = \"\"\n    word_list = []\n\
    \    unique_characters = 0\n    \n    words.each do |word|\n        word_list\
    \ << word\n        unique_characters += word_list.uniq.count\n        max_length\
    \ = unique_characters if unique_characters > max_length\n        word_list = []\n\
    \    end\n    \n    word_list.uniq.each do |word|\n        word_list << word\n\
    \        unique_characters += word_list.uniq.count\n    end\n    max_length =\
    \ unique_characters if unique_characters > max_length\n    word_list.uniq.each\
    \ do |word|\n        word_list << word\n        unique_characters += word_list.uniq.count\n\
    \    end\n    max_length = unique_characters if unique_characters > max_length\n\
    \    \n    max_length > max_length ? words[0] : words[1]\nend", "    words[0]\n\
    \    word = words[0]\n    count = {}\n    max_count = 0\n    i = 0\n    while\
    \ i < words.length\n        word = words[i]\n        count = word.count(\"a\"\
    )\n        if count > max_count then\n            max_count = count\n        \
    \    word = words[i]\n        end\n        count = word.count(\"b\")\n       \
    \ if count > max_count then\n            max_count = count\n            word =\
    \ words[i]\n        end\n        count = word.count(\"c\")\n        if count >\
    \ max_count then\n            max_count = count\n            word = words[i]\n\
    \        end\n        i = i + 1\n    end\n    word\nend\n</code>\n<|/ a |>\n<|\
    \ a dscore=0 |>\nFor each string in the list, we count the number of occurrences\
    \ of a, b, and c in that string, and record this count in a hash.  The hash values\
    \ are the strings that have an occurrence of each of a, b, and c; we then output\
    \ the string with the highest count.\n<code>", "  sorted_words=words.sort_by{|s|\
    \ s.count}\n  if sorted_words.empty?\n    return \"\"\n  end\n  sorted_words.first.dup\n\
    end", "  # sort alphabetically\n  sorted_words=words.sort", "    # Write your\
    \ code here\n\twords.each do |word|\n\t\tsorted_words = word.split('').sort\n\t\
    \twords.delete(word)\n\t\tmax_count = sorted_words.length\n\t\tmax_word = sorted_words[0]\n\
    \t\tsorted_words.each do |word|\n\t\t\tif sorted_words.length == max_count and\
    \ word > max_word\n\t\t\t\tmax_count = sorted_words.length\n\t\t\t\tmax_word =\
    \ word\n\t\t\tend\n\t\tend\n\t\treturn max_word\n\tend\n\treturn \"\"\nend", " \
    \ words.sort(&:count) if words.length > 0\n  words.first(words.length)\nend",
  "  words.each_with_object(Hash.new(0)).max_by {|w| w.size }.last\nend", "  return\
    \ words.max_by { |word| word.chars.uniq.size }\nend\n</code>\nThe other approach,\
    \ which has its own advantages, is to use group_by, which is basically the same\
    \ thing as uniq:\n<code>", "  unique_count = words.uniq.count\n  unique_count\
    \ = unique_count == 0 ? 1 : unique_count\n  max_count = words.uniq.max_by(&:size).size\n\
    \  words.min_by(&:size).first\nend", "  words.each_with_object({}) { |w, memo|\
    \ memo[w] = w.chars.uniq.size }.max.last\nend\n</code>\n<|/ a tags=ruby,string,arrays\
    \ |>\n<| a tags=ruby,string,arrays |>\n<code>\n\"hello\".split('').group_by{|c|\
    \ c.downcase}.max_by{|_,a| a.size}", "  words.sort(&:length).last\nend", "  words\
    \ = words.sort\n  words[0] = words[0].gsub(/[^a-z]/i, '')\n  words[-1] = words[-1].gsub(/[^a-z]/i,\
    \ '')\n  word_counter = Hash.new(0)\n  words.each do |word|\n    word_counter[word]\
    \ += 1\n  end\n  word_counter.max_by {|word, count| count}\nend", "  max_length\
    \ = 0\n  words_with_max_length = \"\"", "  words.uniq.sort\n  words.size\n  words.uniq.length\n\
    end", "  words.each_with_object({}) do |word,h|\n    (h[word] ||= 0) + word.each_char.uniq.size\
    \ \n  end.max.compact.first\nend", "  hash = {}\n  words.each do |word|\n    word.chars.uniq.each\
    \ do |letter|\n      hash[letter] ||= []\n      hash[letter] << word\n    end\n\
    \  end\n  \n  hash.each do |key, value|\n    return value.size if value.size >\
    \ hash[value.first].size\n  end\n  \n  hash.values.compact.first.first || \"\"\
    \nend", "  chars = Array.new\n  words.each do |word|\n    chars.concat(word.split(//).uniq)\n\
    \  end\n  return chars.uniq.sort.last rescue ''\nend", "  unique = words.uniq.size\n\
    \  return unique == 0 ? words[0] : unique.zero? \"\" : \"#{ words.sort.first(:last).first\
    \ }\"\nend\n  ", "  result = \"\"\n  unique_chars = Hash.new(0)\n  words.size.times\
    \ do |i|\n    unique_chars[words[i]] += 1 if unique_chars[words[i]].zero?\n  end\n\
    \  words = words.select {|w| w.size <= unique_chars[w]}\n  words.each do |w|\n\
    \    result = \"\" if w.size == unique_chars[w]\n    result = w if unique_chars[w]\
    \ == words.size\n  end\n  return result if result\n  \"\"\nend", "  uniques =\
    \ Hash.new(0)\n  uniques.default = \"\"\n  words.each do |word|\n    word.chars.uniq.each\
    \ do |letter|\n      uniques[letter] += 1 if !uniques[letter].nil?\n    end\n\
    \  end\n  uniques.max_by do |k, v|\n    v\n  end\nend", "  unique_chars = words.flatten.uniq.size\n\
    \  max_index = -1\n  i = 0\n  while unique_chars > 0\n    unique_chars -= 1\n\
    \    word = words[i]\n    i += 1\n    if word == \"\\n\"\n      break\n    if\
    \ word.length > max_index\n      max_index = word.length\n    words[i] = word\n\
    \  words.each do |word|\n    word.insert(0, \" \")\n  end\n  unique_chars = words.length.uniq.length\n\
    \  words.each do |word|\n    word.insert(0, \" \")\n  end\n  words[max_index]\n\
    end", "    unique_characters = Hash.new(0)\n    words_with_unique_characters =\
    \ Hash.new(0)\n    words_with_max_unique_characters = Hash.new(0)\n    sorted_words\
    \ = words[0...words.size]\n    sorted_words.each do |word|\n        word.each_char\
    \ { |character| unique_characters[character] += 1 }\n        words_with_unique_characters[word]\
    \ = unique_characters.select { |character,count| count == unique_characters[character]\
    \ }\n        words_with_max_unique_characters[word] = words_with_unique_characters[word].max\n\
    \    end\n    words_with_max_unique_characters.values.first.include?(sorted_words.first.first)\
    \ ? sorted_words.first.first : \"\"\nend\n</code>\n<|/ a dscore=0 tags=ruby,ruby-on-rails,string\
    \ |>\n<| c |>\nThis looks like it works.  It isn't obvious to me that `each_char`\
    \ is being used to count the unique characters of a string.  Are there any ruby\
    \ docs I could look at to understand why?  It looks like you're calling `each_char`\
    \ on a string, but I'm not seeing how that's accomplishing the counting...\n<|/\
    \ c |>\n<| c |>\neach_char method just goes through each character in the string\n\
    <|/ c |>\n<| c |>\nI see.  Thanks for the clarification.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  letters = letters.uniq\n  words_to_sort = words.sort { |a, b|\
    \ letters.size <=> letters.count{|c| c == a.chars.join}.size <=> letters.count{|c|\
    \ c == b.chars.join}.size }\n  \n  words_to_sort.uniq.first\nend\n</code>\n<|/\
    \ a tags=ruby dscore=0 |>\n<| c |>\nThanks mate, i tried your solution and it\
    \ worked for me. I will try to understand this solution.\n<|/ c |>\n<| c |>\n\
    I'm glad I could help. Please remember to accept the answer if it worked for you.\
    \ :-)\n<|/ c |>\n<| c |>\nThanks mate! It worked for me as well.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nI propose the following solution:\n<code>", "  words.sort!\n\
    \  words.map!{|word| word.downcase}\n  words.uniq!\n  words.first.size > words.last.size\
    \ ? words.first : words.last\nend\n</code>\nThe above solution does not use sort!,\
    \ map!, uniq! which are time consuming operations. The below solution uses sort!,\
    \ map!, uniq! which are efficient operations and is more readable:\n<code>", " \
    \ words.each { |word|\n    word.chars.uniq.sort.reverse.to_a.reverse.each { |item|\n\
    \      max_count = item.chars.uniq.count \n      if max_count > max_counts\n \
    \       max_counts = max_count\n        max_word = item\n      end\n    }\n  }\n\
    \  max_word\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work when there are\
    \ more than two unique characters. `find_max([\"aaa\", \"bbb\", \"ccc\", \"ddd\"\
    , \"eee\"])` will return `\"bbb\"` instead of `\"aaa\"`. Try it out with three\
    \ characters or more: `find_max([\"aaa\", \"bbb\", \"ccc\", \"aaa\", \"eee\"])`\n\
    <|/ c |>\n<| c |>\nI noticed that and fixed it, now it works fine\n<|/ c |>\n\
    <| c |>\nYou don't need the `to_a` call in the `each` loop. Just do `words.uniq.sort.reverse.each\
    \ { |word|`.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  words.sort_by(&:length).last\n\
    end", "  word=nil\n  word.empty?\n  word.size != 0\n  word.empty? or return \"\
    \"\n  word.max_by{|x| x.size}.first\nend", "    sort = words[0..-1].sort { |a,b|\
    \ a.length <=> b.length }\n    sort.last.empty? ? sort.first : sort.last\nend",
  "    words.each do |word|\n        word.each_char do |char|\n            word.split(char).length\
    \ <= word.length ? word : \"\"\n        end\n    end\nend", "  return words.max_by\
    \ { |word| word.size }\nend", "  word_counts = Hash.new(0)\n  words.each do |word|\n\
    \    word_counts[word] += 1\n  end\n  word_counts.sort_by { |word, count| count\
    \ }.last\nend", "  word_counts = Hash.new(0)\n  words.each {|word| word_counts[word]\
    \ += 1}\n  sorted_word_counts = word_counts.sort_by{|word, count| -count}\n  sorted_word_counts.each\
    \ {|word, count| return word if count == sorted_word_counts.last}\n  return \"\
    \"\nend\n</code>\n<|/ a tags=ruby,string,arrays dscore=0 |>\n<| a tags=ruby,string,arrays\
    \ |>\nYou have to iterate over words and count unique characters. Something like\
    \ this:\n<code>", "  words.sort! # Lexicographical order\n  words.size!\n  i =\
    \ words.index\n  max_count = 0\n  max_word = \"\"\n  while i < words.length\n\
    \    word_length = words[i].length\n    count = words.count { |w| w == words[i]\
    \ } if !words.nil?\n    if count > max_count\n      max_count = count\n      max_word\
    \ = words[i]\n    end\n    i += 1\n  end\n  return max_word\nend", "    words.sort\
    \ {|a,b| a.length <=> b.length }\n    words.uniq.first || \"\"\nend\n</cell>\n\
    <cell>", "  words.group_by{|w| w.count(\"a\")}.max_by{|w, v| v}.first\nend\n</code>\n\
    <|/ a tags=string,ruby |>\n<| a |>\nThis is not the most efficient way of doing\
    \ this, but it's fun to write.\n<code>", "  # most_letters \u2190 {}\n  most_letters\
    \ = {}\n  # most_letters[\"name\"] = most_letters[\"enam\"] = most_letters[\"\
    game\"] = 0\n  # most_letters[\"name\"]\n  words.each do |word|\n    letters =\
    \ word.split(//).count\n    most_letters[word] = letters if letters > most_letters[word]\n\
    \  end\n  most_letters.keys.min\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI see\
    \ that there is already a solution for finding the first element in a given array.\n\
    But for finding the max element (based on the number of characters) in the given\
    \ array this solution works fine.\n<code>", "  words.sort.reverse!\n  i = 0\n\
    \  while i < words.length && words[i].length >= words[i+1].length\n    i += 1\n\
    \  return words[i].length > words[i+1].length ? words[i] : words[i+1]\nend", " \
    \   l = words.map do |word|\n        word.split.uniq.size\n    end.max\n    l\
    \ = words.map do |word|\n        word.split.uniq.size\n    end.max\n    words.select\
    \ { |word| word.split.uniq.size == l }[0]\nend\n</code>\n<|/ a tags=algorithm,ruby\
    \ |>\n<| c |>\nThis assumes the input is a string with no newlines.  A newline\
    \ is added during `split`.\n<|/ c |>\n<| c |>\n: That's why I added the second\
    \ sentence to the top of the answer.  I wrote it that way so I wouldn't have to\
    \ deal with that edge case and would have to think about it when I read the code.\
    \  The edge case is easily handled via `split` anyways.\n<|/ c |>\n<| c |>\nI\
    \ believe it would be a lot more efficient to keep an array of words in `wordcount`\
    \ and return `wordcount.max_by{ |word,count| count }[0]`\n<|/ c |>\n<| c |>\n\
    : `max_by` would be slower than `max_by!` because it would have to iterate over\
    \ all elements anyway.  In a large array, it would be less efficient.  But `max_by!`\
    \ would have about the same performance either way.  I doubt that would ever be\
    \ a concern.\n<|/ c |>\n<| c |>\n: I believe the performance difference will be\
    \ minimal unless `words` is really large.  The `max_by` method iterates through\
    \ the entire `wordcount` array each time.  I guess I should have said that `max_by!`\
    \ would iterate the entire `wordcount` array *only once*.\n<|/ c |>\n<| a tags=algorithm,ruby\
    \ |>\n<code>", "  letters = {}\n  words.each do |w|\n    w.split(//).each do |letter|\n\
    \      letters[letter] ||= 0\n      letters[letter] += 1\n    end\n  end\n  letters.each\
    \ do |letter, count|\n    break if count == letters.values.max\n  end\n  words.each\
    \ do |w|\n    w.split(//).each do |letter|\n      return letter if count == letters[letter]\n\
    \    end\n  end\n  nil\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<|\
    \ a tags=ruby,arrays,algorithm |>\nRuby 2.5.0:\n<code>", "  result = \"\"\n  count\
    \ = 1\n  words.each do |w|\n    if w.size > count\n      result = w\n      count\
    \ = w.size\n    end\n  end\n  result\nend", "  word = words.max {|a, b| a.length\
    \ <=> b.length }\n  while word.size > 0 && !word.sub!('a', '') && !word.sub!('z',\
    \ '')\n    word = words.max {|a, b| a.size <=> b.size }\n  end\n  word\nend",
  "  maxi = 0\n  maxi = words.length\n  words.length.times do\n    words.length.times\
    \ do |i|\n      words[i].length\n      if words[i].length > maxi\n        maxi\
    \ = words[i].length\n      end\n    end\n  end\n  maxi\nend\n</code>\n<|/ a tags=ruby,algorithm\
    \ |>\n<| c |>\n`words.map { |w| w.split('').uniq.size }.max`\n<|/ c |>\n<| c |>\n\
    If `words` is a list of hashes or hashes nested within hashes, you can do `words.map\
    \ { |h| h.values.uniq.size }.max`\n<|/ c |>\n<| c |>\n`Hash#values` is just `each_with_object`\n\
    <|/ c |>\n<| c |>\nIt also doesn't return what you expect `find_max([\"aaaaaaa\"\
    , \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"`\n<|/ c |>\n<| a tags=ruby,algorithm |>\n\
    <code>", "  words.size\n  words.size\n  words.sort\n  words.uniq.size == words.size\
    \ ? \"#{words[0]}\" : \"#{words.last}\"\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ tags=arrays,ruby |>\n<code>\n def max_string(arr)\n  arr.each do |item|\n  \
    \  temp_max = arr.find { |x| x.size > item.size }\n    if temp_max.nil?\n    \
    \  arr << item\n    elsif temp_max.size < item.size\n      arr.delete(temp_max)\n\
    \      arr.push(item)\n    else\n      break\n    end\n  end\n  arr.each do |item|\n\
    \    arr.delete(item)\n  end\n  arr.join('')\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nPlease don't just dump code as an answer and ask for some explanation.\
    \  Explain what the code does and how it solves the problem.\n<|/ c |>\n<| c |>\n\
    Ok, this is what I understood:\n1.) The method 'find' searches for the first element\
    \ of the array, which is equal or larger, and stores it in a local variable 'temp_max'.\n\
    2.) The method 'delete' removes the local variable 'temp_max'.\n3.) The method\
    \ 'push' adds the item to the array, which is smaller or equal to the size of\
    \ the current element.\n4.) The method 'each' iterates over the array, which means\
    \ 'temp_max' will be assigned to one of the array elements, which will be removed\
    \ in the next step 'delete', and so on...\n5.) The method 'join' joins the array\
    \ into one string.\n<|/ c |>\n<| a dscore=1 tags=arrays,ruby |>\nMy solution:\n\
    <code>", "  max = \"\"\n  word_count = Hash.new(0)", "  words.sort_by{|s| s.count('a')}.reverse.first\n\
    end", "  return words[words.index(words[words.length-1])].to_s if words.length\
    \ == 1 || words[0].length == words[words.length-1].length.to_s \n  maxword = \"\
    \"\n  maxcount = 0\n  words.each do |x|\n    i = words.length-1\n    until i >\
    \ 0 do\n      j = 0\n      until j < i do\n        if (words[j].length < words[i].length)\n\
    \          break\n        end\n        j += 1\n      end\n      if (words[j] ==\
    \ words[i])\n        maxcount = words[j].length if words[j].length > maxcount\n\
    \        maxword = words[j] if words[j].length == maxcount \n      end\n     \
    \ i -= 1\n    end\n  end\n  return maxword if maxcount > 0 \nend\n    ", "  max\
    \ = 0\n  unique = Set.new\n  words.each do |word|\n    unique.update(word.split(//))\n\
    \    if unique.length >= max\n      max = unique.length\n    end\n  end\n  unique.length\
    \ == max ? unique.first : \"\"\nend\nputs find_max([\"name\", \"of\", \"string\"\
    ]) # => \"string\"\nputs find_max([\"name\", \"enam\", \"game\"]) # => \"enam\"\
    \nputs find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) # => \"\"", "  unique_set = Set.new\n\
    \  word = nil\n  max_count = 0\n  words.each do |word|\n    unique_set.add(word)\n\
    \    count = unique_set.count\n    max_count = count if count == max_count\n \
    \ end\n  if max_count > 0\n    word = unique_set.min_by{|x| x.count}\n  end\n\
    \  return word\nend", "  words.sort(&:length).reverse\n  unique_chars = []\n \
    \ unique_char_count = 0\n  word = words[0]\n  words.each do |word|\n    word.each_char\
    \ do |char|\n      if !unique_chars.include?(char)\n        unique_chars.push(char)\n\
    \        unique_char_count += 1\n      end\n    end\n  end\n  return word if unique_char_count\
    \ == word.length\n  return \"\"\nend", "  return words[words.index(words.uniq.max)+1]\
    \ \nend", "  words.sort!\n  words.uniq!\n  if words.size > 1\n    words[words.size\
    \ - 1]\n  else\n    \"\"\n  end\nend", "    words.sort_by! { |word| word.size\
    \ }\n    words.reverse!\n    words.detect { |word| word.size < words.max_by {\
    \ |word| word.size } }\nend", "    words.each do |word|\n        word = word.split(//).uniq.sort.join\n\
    \        word_count.push(word) if word_count.include?(word)\n    end\n    word_count.max\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks alot, your solution worked flawlessly.\
    \ \nI wish i could have accepted both answers because i really like your solution\
    \ but i had to accept the other answer because i feel its more \"cleaner\"\n<|/\
    \ c |>\n<| a dscore=0 |>\nIn case you have a fixed size of string array as in\
    \ your question I would simply do the following.\n<code>", "  words.group_by{|w|\
    \ w.length}.max_by{|k, v| v}.last\nend", "  # Write your code here\n  max_count\
    \ = max_val = \"\"\n  word = nil\n  words = []", "  # write your code here\n \
    \ word_count={}\n  word_count_temp={}\n  words=words.sort\n  words.each{|word|\
    \ word_count[word]=1}\n  word_count[words[0]]=0\n  words[0].length.times{|i|\n\
    \    if words[i].length>word_count[words[i]]\n      word_count[words[i]]=words[i].length\n\
    \      word_count_temp[words[i]]=i\n    end\n  }\n  word_count.each do |k, v|\n\
    \    if v>word_count[words[k]]\n      word_count[words[k]]=v\n      word_count_temp[words[k]]=k\n\
    \    end\n  end\n  words.each{|word| word[word_count_temp[word]] }\nend", "  unique_chars\
    \ = {}\n  word.each do |word|\n    word.chars.each do |char|\n      unique_chars[char]\
    \ ||= 0\n      unique_chars[char] += 1\n    end\n  end\n  unique_chars.keys.each\
    \ do |char|\n    unique_chars[char] = unique_chars[char].to_i\n  end\n  return\
    \ unique_chars.sort { |a, b| b.to_i <=> a.to_i }.first\nend", "  return words[words.index(words.uniq.length.max)]\n\
    end", "    words.sort.each { |w| return w if w.length == words.length and w.uniq.length\
    \ == words.length }\nend\n    ", "  word=nil\n  len=nil\n  str=\"\"\n  words.each\
    \ do |word|\n    len=word.length\n    word=word.downcase\n    str=str+word\n \
    \   str.each_char.with_object({}) do |c, h| \n      if h.key?(c)\n        if h[c]\
    \ > 1\n          h[c]=1\n        else\n          h[c]+=1\n        end\n      else\n\
    \        h[c]=1\n      end\n    end.max_by{|k,v| v}\n  end\n  str\nend", "  return\
    \ nil if words.size == 0\n  words.uniq.length.max\nend", "  words.each do |w|\n\
    \    chars = w.split(//).map {|c| c.to_s.size }.uniq.sort\n    max = chars.max\n\
    \    if max != chars.first\n      w = w.gsub(/(.)#{max}$/, '\\1')\n    end\n \
    \ end\n  return nil unless chars.include?(words[0].split(//).map(&:size).uniq.sort.max)\n\
    \  w = words.first\n  w = w.gsub(/(.)#{chars.first}$/, '\\1')\n  return w\nend",
  "    unique_count = Hash.new(0)\n    unique_words = []\n    words.each do |word|\n\
    \        word.downcase.split(//).each do |letter|\n            unique_count +=\
    \ 1[letter] += 1\n        end\n        unique_words << word if unique_count >\
    \ unique_count.max\n    end\n    unique_words.pop unless unique_words.length >\
    \ 1\n    unique_words[0]\nend\n</code>\n<|/ a |>\n<| c |>\nThe question states\
    \ that multiple words can have the same number of unique characters (i.e. two\
    \ words are both `ab`). Your solution doesn't account for this, and also doesn't\
    \ produce words in lexicographical order.\n<|/ c |>\n<| c |>\n, you're right.\
    \ I didn't read the question carefully enough. I'll edit the answer to account\
    \ for that case.\n<|/ c |>\n<| c |>\nI missed the part where you said that \"\
    aaa\" should return \"\" and not \"aaa\" :). But I do think this is a good answer\
    \ to the question (even though I didn't get the question until after I posted\
    \ the answer).\n<|/ c |>\n<| a tags=sorting,ruby dscore=1 |>\nHere's a solution\
    \ using a hash table.  It works, but I'm not sure it scales particularly well.\n\
    <code>", "    word_frequency = {}\n    words_with_unique_characters = []\n   \
    \ \n    # loop over each word in the list of words\n    words.each do |word|\n\
    \        # if the word is already in the hash\n        if word_frequency.has_key?(word)\n\
    \            # increment its count by 1\n            word_frequency[word] += 1\n\
    \        # else add it to the hash with count 1\n        else\n            word_frequency[word]\
    \ = 1\n        end\n    end\n    \n    # loop over the hash\n    word_frequency.each\
    \ do |word, frequency|\n        # if the frequency is greater than 1\n       \
    \ if frequency > 1\n            # add the word to the array with its frequency\
    \ to the list\n            words_with_unique_characters << [word, frequency]\n\
    \        end\n    end\n    \n    # sort the list of words\n    words_with_unique_characters.sort_by\
    \ { |word| word[0] }\n    \n    # return the word with max frequency\n    words_with_unique_characters[0][0]\n\
    end", "  words.each do |word|\n    word.each do |char|\n      counts[char] ||=\
    \ 0\n      counts[char] += 1\n    end\n  end\n  max_count = counts.max\n  if max_count\
    \ == 0\n    return \"\"\n  elsif max_count >= 1\n    return counts.min_by{|k,\
    \ v| k}.first\n  else\n    \"\"\n  end\nend", "  max_count = 0\n  max_word = words[0]\n\
    \  words.each do |word|\n    if word.chars.uniq.size >= max_count\n      max_word\
    \ = word\n    end\n    max_count = word.chars.uniq.size\n  end\n  return max_word\n\
    end", "  return words.group_by{|word| word.chars.uniq.count}.max { |key, value|\
    \ key if value }\nend", "    seen = {}\n    words.each do |word|\n        seen.update(word.chars.map(&:downcase).inject(:+))\n\
    \    end", "    words = words.sort\n    i = 0\n    word = \"\"\n    while i <\
    \ words.length\n       if word.length < words[i].length\n           word = words[i]\n\
    \           i += 1\n       else\n           break\n    end\n    return word\n\
    end", "  words.map! { |word| word.downcase.split(//).uniq.size }\n  words.max\n\
    end", "  count = Hash.new(0)\n  words.each do |word|\n    count[word] += 1\n \
    \ end\n  count.max_by {|k,v| v}\nend\n</cell>\n<text>\nExercise 9\nWrite a function\
    \ that accepts a list of words and returns the word with maximum number of consecutive\
    \ repeats.", "  uniques = Hash.new(0)\n  words.each do |word|\n    word.chars.uniq.each\
    \ do |char|\n      uniques[char] += 1\n    end\n  end\n  return words[uniques.keys.sort].join('')\
    \  if uniques.values.max == uniques.values.min\n  return ''\nend", "  words=words.sort\n\
    \  words[0]=words[0].split(//).map(&:chars).uniq.length\n  words.last.downcase!\n\
    end\nputs find_max([\"aaaaaaa\", \"bb\" ,\"cc\"])", "  word = words[0]\n  word\
    \ = word.split('').uniq.length == 1 ? word : words[0]\n  words[0,words.size -\
    \ 1] = words[words.size - 1, 0]\n  return word\nend", "  words.each do |word|\n\
    \    words.each do |word|\n      words.each do |word|\n        words.each do |word|\n\
    \          if word.length == words.length\n            return word\n         \
    \ else\n            return \"\"\n          end\n        end\n      end\n    end\n\
    \  end\nend", "  words.sort!\n  unique = Set.new\n  result = []\n  word = \"\"\
    \n  words.each do |word|\n    unique.clear\n    word.scan(/./) { |c| unique <<\
    \ c }\n    result << word if unique.size == word.size\n  end\n  result\nend",
  "  word = words.sort_by{|w| w.size}.first\n  word.empty? ? \"\" : word\nend", " \
    \ max_length = 0\n  best_word = \"\"\n  \n  words.each do |word|\n    word_count\
    \ = word.split(\"\").length\n    \n    if word_count > max_length\n      max_length\
    \ = word_count\n      best_word = word\n    end\n  end", "  words.sort()\n  words\
    \ = words.uniq\n  words.uniq!\n  words.max_by {|w| w.length}\nend", "    words.sort!\n\
    \    words.each do |word|\n        unique_characters = unique_characters(word)\n\
    \        if unique_characters.length > unique_characters.max\n            unique_characters.max\
    \ == unique_characters.length ? \n                word : unique_characters.min\n\
    \        end\n    end\nend", "  max_length = 0\n  max_length_word = \"\"", " \
    \ words.sort.reverse.each {|word| word.chars.uniq.length.max || \"\"}\nend\n</cell>\n\
    <cell>", "  words.sort.reverse!\n  words.uniq.length.each_with_object({}) { |word,\
    \ hash| hash[word] = words.count(word).to_i }\n  words.sort.reverse!\n  words.uniq.length.each_with_object({})\
    \ { |word, hash| hash[word] = words.count(word).to_i }.first || \"\"\nend", " \
    \ words.size!=0\n  chars = {}\n  words.each do |word|\n    chars[word.length]\
    \ = word.split(//).uniq.size\n  end\n  words.size>0 && (chars[chars.keys.max]\
    \ == chars[chars.keys.min]) ? words[words.index {|w| w.length == chars.keys.max\
    \ } ] : nil\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nA simple solution\
    \ with hash and sorting:\n<code>", "  words[0] = words[0].gsub(/\\W/,\"\") # remove\
    \ non alphanumeric characters\n  count = words.inject(Hash.new(0)) { |h,word|\
    \ h[word] += 1 ; h }\n  words.sort {|word1, word2| count[word1] <=> count[word2]\
    \ }.first\nend", "  # TODO #1: write a function that accepts a list of strings.\n\
    \  # The list contains different words. Return the word with maximum number\n\
    \  # of unique characters. If multiple strings have maximum number of unique\n\
    \  # characters, return the one which comes first in lexicographical order.\n\
    \  # words = [\"name\",\"of\",\"string\"]\n  # words = [\"name\",\"enam\",\"game\"\
    ]\n  # words = [\"aaaaaaa\",\"bb\",\"cc\"]\n  # words = [\"hello\",\"world\",\"\
    my\",\"friend\"]", "  word = nil\n  word_count = nil\n  word_list = words.sort\
    \ {|x, y| x.length <=> y.length }\n  word_list.each_with_index do |word, idx|\n\
    \    char_count = word.scan(/\\S+/).size\n    if char_count > word_count\n   \
    \   word = word\n      word_count = char_count\n    end\n  end\n  return word\n\
    end", "    unique_chars = Hash.new(0)\n    unique_chars.merge!(words)\n    unique_chars.max_by\
    \ { |k, v| v }\nend", "  # sort\n  words.sort!\n  # sort words\n  words.sort\n\
    \  # remove empty words\n  words.delete_if {|word| word.empty?}\n  # remove duplicated\
    \ words\n  words_to_check = words.dup\n  words_to_check.delete_if {|word| words.count(word)\
    \ == 1}\n  max_word = words_to_check.first\n  # check words one by one\n  while\
    \ words_to_check.any?\n    next_word = words_to_check.shift\n    # compare them\n\
    \    if next_word == max_word\n      max_word = next_word\n    end\n    # check\
    \ if all words has been compared\n    if words_to_check.empty?\n      break\n\
    \    end\n  end\n  # return the max word\n  max_word\nend", "  unique = Hash.new(0)\n\
    \  words.each do |word|\n    unique[word] += 1\n  end", "  sorted_list = words.sort_by\
    \ {|word| word.length}.reverse\n  sorted_list.first\nend", "  words.sort(&:length).first(words.length)\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\n<code>", "  \n  word_count\
    \ = words.inject(Hash.new(0)){|h, s| h[s] += 1; h}.max_by{|k,v| v}\n  if word_count[1]\
    \ >= word_count.last\n    word_count[0]\n  else\n    word_count.last\n  end\n\
    end\nputs find_max([\"name\", \"of\", \"string\"]) #=> \"string\"\nputs find_max([\"\
    name\", \"enam\", \"game\"]) #=> \"enam\"\nputs find_max([\"aaaaaaa\", \"bb\"\
    \ ,\"cc\"]) #=> \"\"\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\n, thanks\
    \ for your feedback. I remember that I was having a lot of difficulties with my\
    \ `inject` solution and I ended up with this solution.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=1 |>\n<code>", "    words.sort.each do |word|\n        unique_chars =\
    \ word.uniq.count\n        unique_chars.max if unique_chars > unique_chars.max\n\
    \    end\nend", "  max_length = 0\n  max_word = nil\n  words.each do |word|\n\
    \    chars = word.split.uniq.size\n    if chars > max_length\n      max_length\
    \ = chars\n      max_word = word\n    end\n  end\n  max_word\nend", "  max_length\
    \ = nil\n  word = nil\n  words.each do |word|\n    uniq = word.chars.uniq.size\n\
    \    if uniq > max_length\n      max_length = uniq\n      word = word\n    end\n\
    \  end\n  return word\nend\n</code>\n<|/ a |>\n<| c |>\nThank you, i tried using\
    \ map but i didn't know i could do that in a better way than what i was trying.\n\
    <|/ c |>\n<| a dscore=0 |>\nI see two ways to do this without using .uniq.size\
    \ or .uniq. I am going to assume you do not want to use those methods.\nFor each\
    \ iteration of the loop, you would like to find the first element which has more\
    \ than unique characters. I would solve this by using a while loop to keep track\
    \ of the current character, and then return when there no more unique characters.\n\
    <code>", "  unique = words.length\n  max_char = unique\n  result = \"\"\n  i =\
    \ 0\n  while i < words.length\n    char = words[i].count(\"a\")\n    if char >\
    \ max_char\n      max_char = char\n      result = words[i]\n    i += 1\n  if result\
    \ == \"\"\n    result = words[i]\n  end\n  return result\nend", "  return words.select\
    \ {|word| word.chars.uniq.size }.sort.first\nend\n</code>\n<|/ a tags=ruby,arrays,string\
    \ |>\n<| a dscore=0 |>\nA more efficient implementation than the solution by is\
    \ to remove duplicate words by using each_with_object. This is also more memory\
    \ efficient as it uses a set rather than an array.\n<code>", "  unique_count =\
    \ Hash.new(0)\n  max_count = 0\n  max_word = \"\"\n  words.each do |word|\n  \
    \  word.each_char do |char|\n      unique_count[char] += 1\n    end\n    if unique_count.values.max_by(&:last).last\n\
    \      max_word = word\n      max_count = unique_count.values.max_by(&:last).last\n\
    \    end\n  end\n  max_word\nend", "  return words.sort.last.uniq.length rescue\
    \ \"\"\nend", "  # Write your code here\n  words_with_count = words.group_by {\
    \ |s| s.length }.map { |k, v| [k, v.length] }.max\n  words_with_count.each { |k,\
    \ v| words[k] = words[k][0, v.count] }\n  return words_with_count.values.join(\"\
    _\") + \"_\" + words_with_count.keys.join(\"_\") if words_with_count.any?\nend",
  "  unique_chars = Hash.new(0)\n  words.each do |word|\n    word.each_char do |char|\n\
    \      unique_chars[char] += 1\n    end\n  end\n  unique_chars.max_by { |k, v|\
    \ v }\nend", "  words.uniq.each do |word|\n    if word.length == words.max\n \
    \     return word\n    end\n  end\n  return \"\"\nend", "  words_with_max = []\n\
    \  unique_chars = Hash.new(0)\n  max_length = 0\n  words.each do |word|\n    unique_chars[word]\
    \ += 1\n    if unique_chars[word] > max_length\n      max_length = unique_chars[word]\n\
    \      words_with_max = word\n    end\n  end\n  words_with_max.empty? ? \"\" :\
    \  words_with_max.min\nend", "  words.sort.map {|x| x.count(\"a\")}.max || \"\"\
    \nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a |>\n<code>\n def func(str)\n\
    \    hash={}\n    str.each_char.map {|x| hash[x] ||= []}\n    str.each_char.map\
    \ {|x| hash[x] << x}\n    str.size.to_s\n end\n</code>\n<|/ a dscore=1 tags=ruby\
    \ |>\n<| a |>\n<code>\n def func(str)\n    str.each_char.group_by(&:itself).max.map(&:first)\n\
    \ end\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a dscore=0 tags=ruby |>\n<code>",
  "  wordlist = words.sort\n  wordlist.uniq.length == 1 ? wordlist.first : wordlist.last\n\
    end\n</code>\n<|/ a tags=string,ruby,arrays,sorting dscore=0 |>\n<| a dscore=0\
    \ |>\nA one-liner using sort and uniq.\n<code>", "  return nil if words.length==0\n\
    \  max_count = 0\n  max_val = words[0]\n  max_word = \"\"\n  words.each do |word|\n\
    \    count = word.count(\"a\")\n    count += word.count(\"e\")\n    count += word.count(\"\
    i\")\n    count += word.count(\"o\")\n    count += word.count(\"u\")\n    count+=1\
    \ \n    count=(count>max_count) ? count : max_count\n    count=(count==max_count)\
    \ ? count : max_count\n    count=(count<max_count) ? count : max_count\n  end\n\
    \  words.each do |word|\n    count = word.count(\"a\")\n    count += word.count(\"\
    e\")\n    count += word.count(\"i\")\n    count += word.count(\"o\")\n    count\
    \ += word.count(\"u\")\n    count+=1 \n    count=(count>max_count) ? count : max_count\n\
    \    count=(count==max_count) ? count : max_count\n    count=(count<max_count)\
    \ ? count : max_count\n  end\n  words.each do |word|\n    count = word.count(\"\
    a\")\n    count += word.count(\"e\")\n    count += word.count(\"i\")\n    count\
    \ += word.count(\"o\")\n    count += word.count(\"u\")\n    count+=1 \n    count=(count>max_count)\
    \ ? count : max_count\n    count=(count==max_count) ? count : max_count\n    count=(count<max_count)\
    \ ? count : max_count\n  end\n  words.each do |word|\n    count = word.count(\"\
    a\")\n    count += word.count(\"e\")\n    count += word.count(\"i\")\n    count\
    \ += word.count(\"o\")\n    count += word.count(\"u\")\n    count+=1 \n    count=(count>max_count)\
    \ ? count : max_count\n    count=(count==max_count) ? count : max_count\n    count=(count<max_count)\
    \ ? count : max_count\n  end\n  words.each do |word|\n    count = word.count(\"\
    a\")\n    count += word.count(\"e\")\n    count += word.count(\"i\")\n    count\
    \ += word.count(\"o\")\n    count += word.count(\"u\")\n    count+=1 \n    count=(count>max_count)\
    \ ? count : max_count\n    count=(count==max_count) ? count : max_count\n    count=(count<max_count)\
    \ ? count : max_count\n  end\n  words.each do |word|\n    count = ", "  result\
    \ = \"\"\n  words.each_with_index do |word, index|\n    chars = word.split(\"\"\
    ).uniq.count\n    if chars > result[chars] && !chars.nil?\n      result = word\n\
    \    end\n  end\n  return result\nend", "    words_with_count = words.group_by\
    \ { |word| word.count }\n    words_with_count.max_by { |word, count| count }.first\n\
    end", "  unique_chars = {}\n  words.each do |word|\n    unique_chars[word] = unique_chars[word].nil?\
    \ ? 0 : unique_chars[word] + 1\n  end\n  words.each do |word|\n    unique_chars[word]\
    \ =  unique_chars[word].nil? ? word.length : unique_chars[word]\n  end\n  sorted_unique_chars\
    \ = unique_chars.sort.reverse\n  words_with_max_unique = sorted_unique_chars.first.last\n\
    \  words_with_max_unique\nend", "  return words.sort.last\nend", "  words.sort!\n\
    \  words[words.index(words[words.length-1]) + 1]\nend", "    unique_chars = Hash.new(0)\n\
    \    words.each do |w|\n        unique_chars[w.chars.uniq.size] += 1\n    end\n\
    \    unique_chars.max_by {|k, v| v }\nend\n</code>\n<|/ a tags=string,ruby dscore=0\
    \ |>\n<| c |>\nThank you for the solution, but could you please tell me why my\
    \ code is not working (I am a beginner)?\n<|/ c |>\n<| c |>\n, your solution doesn't\
    \ work. Try it with `find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\
    `\n<|/ c |>\n<| c |>\n, I have edited my solution. Try this one.\n<|/ c |>\n<|\
    \ c |>\n, Yes you are right, It is returning \"\"aaaaaaa\" as result. Now I have\
    \ fixed it. :)\n<|/ c |>\n<| a dscore=0 tags=string,ruby |>\nAnother way with\
    \ inject:\n<code>", "  # Convert words to array before counting chars\n  sorted_words\
    \ = (words + [\"zz\"]).sort\n  # Set empty string as return value\n  max_string\
    \ = \"\"\n  max_count = 0\n  # Iterate through all the words and count the chars\n\
    \  words.each do |word|\n    count = sorted_words.count(word) #.upcase\n    #\
    \ Set the new value if the current word has the max chars\n    if count > max_count\n\
    \      max_string = word\n      max_count = count\n    end\n  end\n  return max_string\n\
    end", "  words.each_with_object(Hash.new(0)) { |word, hash| hash[word.chars.uniq.size]\
    \ += 1 }.max_by {|_,v| v}[1]\nend", "  words.each do |word|\n    letters_count\
    \ = Hash.new(0)\n    word.split.each do |letter|\n      letters_count[letter]\
    \ += 1\n    end\n    letters_count.each do |letter, count|\n      count > letters_count[letter]\
    \ ? (letters_count[letter] = count) : nil\n    end\n    letters_count.sort.last.nil?\
    \ ? word : letters_count.sort.last\n  end\nend", "  word = words.select{|x| x.chars.uniq.size\
    \ > words.uniq.size}\n  word2 = words.select{|x| x.chars.uniq.size == words.uniq.size}\n\
    \  if word2.empty?\n    return word\n  else\n    return word2.first\n  end\nend",
  "    word_count = {}\n    unique_words = []\n    word_with_max_count = \"\"\n  \
    \  unique_chars = []\n    char_with_max_count = 0\n    word_with_char_with_max_count\
    \ = \"\"", "  word=words[0]\n  words.delete_at(0) if words.empty? #remove the\
    \ first element\n  words.sort_by{|s| s.length}.reverse.first.upcase if words.empty?\
    \ #sort the words according to length\n  words.delete_if {|w| w.length < word.length}\
    \ if words.empty? #remove words of lesser length\n  word=words.reverse.first.upcase\
    \ if words.empty? #reverse the list and get the first word\n  word.gsub!(/[^A-Za-z]/i,\
    \ '')#remove all special characters from the word\n  words.delete_at(0) if words.empty?\
    \ #remove the first (longest) word if there are multiple words having the same\
    \ number of characters\n  words.delete_at(words.length-1) if words.empty? #remove\
    \ the last word if there are multiple words having the same number of characters\n\
    \  word\nend\nputs find_max([\"hello\", \"hi\", \"hallo\", \"hej\", \"hejlo\"\
    , \"halloo\", \"hejhej\", \"hejhejhej\", \"hejhejhejhej\"]) # => hejhejhejhej\n\
    </code>\n<|/ a tags=ruby,sorting,algorithm |>\n<| c |>\nThanks Mittal! I added\
    \ some explanations :)\n<|/ c |>\n<| a dscore=2 tags=ruby,sorting,algorithm |>\n\
    You can use the combination method of Enumerable in Ruby v1.8.7+\n<code>\narray\
    \ = %w{hello hallo hallo hej hejlo}\narray.each_combination(2).max_by(&:length)",
  "  max_count = 0\n  max_word = \"\"\n  max_words = []\n  words.each do |word|\n\
    \    count = 0\n    word = word.downcase\n    word_array.each do |char|\n    \
    \  count += 1 if word.include? char\n    end\n    count > max_count and max_count\
    \ = count\n    max_word = word if count == max_count\n    max_words.push(word)\
    \ if count > max_count\n  end\n  max_words.sort!\n  max_words[0]\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby,arrays |>\n<| c |>\nI think I like your solution a lot,\
    \ but I don't think it is as easy to read as mine.  I do have a follow up question.\
    \  I am going to go ahead and mark this one as the answer, but if you could help\
    \ me out with this follow up question, I would really appreciate it.\n<|/ c |>\n\
    <| c |>\n, I've updated the post with a solution to the follow up question and\
    \ some explanation as well.\n<|/ c |>\n<| c |>\nOh wow, thanks for that follow\
    \ up question, this is really helpful.  I will be going over this and seeing what\
    \ I can come up with.  Thanks again for your help.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\nHere's my solution, based on a comment by Stefan (thank you very much!):\n\
    <code>", "  words = words.sort\n  return words.pop if(words.size==0 || words.all?\
    \ {|word| word.size < words.size}.nil?)\n  word = words.min\n  word.length ==\
    \ 0 ? word = \"\" : word = word.slice!(0...(word.length-1))\n  words.delete(word)\n\
    \  return word\nend", "  words.sort.each do |word|\n    break if word.length ==\
    \ word.length\n    count = 1\n    word.each_char do |char|\n      count += 1 if\
    \ word[count] == char\n    end\n    return word if count == word.length\n  end\n\
    \  return \"\"\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis answer\
    \ is much better than my answer. Using `sort` was unnecessary and didn't produce\
    \ the desired result.\n<|/ c |>\n<| a dscore=1 tags=ruby,arrays |>\n<code>", " \
    \ return words.max_by {|w| w.length}\nend", "  words.sort(&:size).first\nend\n\
    </code>\n<|/ a tags=ruby dscore=0 |>\n<| a tags=ruby dscore=0 |>\nA solution using\
    \ inject:\n<code>", "    max_length = 0\n    word = nil\n    \n    words.each\
    \ do |word|\n      word.split(//).uniq.each do |letter|\n         max_length =\
    \ max_length.to_i if max_length.to_i < letter.length\n      end\n      word =\
    \ word if max_length == word.length\n    end\n    return word if word\nend\nputs\
    \ find_max([\"anne\",\"christina\",\"gerry\",\"john\",\"katy\"])", "  char_count\
    \ = Hash.new(0)\n  words = [word.downcase for word in words]\n  words.uniq.each\
    \ do |word|\n    char_count[word] += 1 if char_count[word] > 0\n  end\n  char_count[\"\
    \"] = words.size\n  char_count.max_by{|k, v| v}[1]\nend", "  sorted_by_uniq_count\
    \ = words.sort_by { |w| w.size }\n  return sorted_by_uniq_count.last if sorted_by_uniq_count.size\
    \ > 1\n  return sorted_by_uniq_count.first\nend", "    \nend", "  word = words[0]\n\
    \  max_count = 0\n  max_word = \"\""]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
