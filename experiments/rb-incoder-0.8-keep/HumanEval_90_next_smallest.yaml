name: HumanEval_90_next_smallest
language: rb
prompt: "# You are given a list of integers.\n# Write a function next_smallest() that\
  \ returns the 2nd smallest element of the list.\n# Return None if there is no such\
  \ element.\n# next_smallest([1, 2, 3, 4, 5]) == 2\n# next_smallest([5, 1, 4, 3,\
  \ 2]) == 2\n# next_smallest([]) == None\n# next_smallest([1, 1]) == None\ndef next_smallest(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_next_smallest\n\
  \    candidate = method(:next_smallest)\n    assert_equal(2, candidate.call([1,\
  \ 2, 3, 4, 5]))\n    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))\n    assert_equal(nil,\
  \ candidate.call([]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(1,\
  \ candidate.call([1, 1, 1, 1, 0]))\n    assert_equal(nil, candidate.call([1, 1]))\n\
  \    assert_equal(-35, candidate.call([-35, 34, 12, -45]))\n  end\nend\n"
completions: ["  smallest,next_smallest = nil,nil\n  lst.each do |x|\n    if smallest\
    \ == nil or x < smallest\n      smallest = x\n    end\n    if x >= smallest\n\
    \      next_smallest = x\n    end\n  end\n  return next_smallest\nend\n</code>\n\
    <|/ a |>\n<| c |>\n+1 for the first answer that shows how to solve the problem\
    \ without using `sort`.\n<|/ c |>\n<| c |>\nThe question was about `next_smallest`,\
    \ but your solution doesn't show it.\n<|/ c |>\n<| c |>\n, my second answer does\
    \ show next_smallest in the comment above\n<|/ c |>\n<| c |>\nOh, yeah, that's\
    \ much better now. I wasn't aware that there was a `next_smallest` function defined\
    \ for `Enumerable`.\n<|/ c |>\n<| a |>\nAs others have mentioned, there are many\
    \ ways to solve this problem.  Here's one way that doesn't use sort:\n<code>",
  "  # Your code here\n  return lst.sort_by {|x| x} .pop(2)\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby,list,sorting |>\n<| c |>\n`sort_by` returns a new array, it doesn't\
    \ modify the original array. `pop` returns nil if the array is empty, and it modifies\
    \ the array it receives.\n<|/ c |>\n<| c |>\nThanks for your comment, I've updated\
    \ the answer, but the answer given by is more elegant, so I leave it untouched.\n\
    <|/ c |>\n<| c |>\nA quick peek at the [documentation](http://www.ruby-doc.org/core-2.1.1/Array.html#method-i-sort_by)\
    \ confirms your suspicion. `sort_by` returns the same array it is called on. `pop`\
    \ modifies the array.\n<|/ c |>\n<| a |>\n<code>", "  smallest = nil\n  next_smallest\
    \ = nil\n  for i in lst\n    smallest = i\n  end\n  lst.reject! {|x| x < smallest}\n\
    \  lst.each {|x| next_smallest = x if x < smallest}\n  next_smallest\nend\n</code>\n\
    <|/ a |>\n<| c |>\nYour solution is O(n^2) complexity. OP's solution is O(n).\n\
    <|/ c |>\n<| c |>\nOh yes, I missed that. Thanks!\n<|/ c |>\n<| c |>\nI think\
    \ this solution has some problems, for example if the list is [6, 12, 2, 5, 7,\
    \ 1, 3, 9, 10] it returns 12, instead of 2. And it also returns nil when there\
    \ is only one element in the list.\n<|/ c |>\n<| c |>\n, thank you for your comment,\
    \ I updated my solution, please check\n<|/ c |>\n<| c |>\n, thank you for your\
    \ comment, I updated my solution, please check\n<|/ c |>\n<| a |>\n<code>", " \
    \ lst.sort!\n  lst.shift\n  lst.first\nend", "  sorted = lst.sort\n  if sorted.length\
    \ == 1\n    return sorted[0]\n  else\n    return sorted[1]\nend\n</code>\n<|/\
    \ a tags=ruby,arrays |>\n<| a |>\nThe solution is as simple as:\n<code>\narr =\
    \ [1,2,3,4,5,6,7,8,9,10]\narr.sort_by {|x| x}[2] # returns 10\n</code>\n<|/ a\
    \ tags=ruby,arrays dscore=2 |>\n<| c |>\nThis solution will give the wrong result\
    \ if `arr` is empty (because `sort_by` returns `nil` when given an empty array).\n\
    <|/ c |>\n<| a tags=ruby,arrays dscore=2 |>\n<code>\narray = [1,2,3,4,5,6,7,8,9,10]\n\
    array.sort_by{|i| i}[2]\n</code>\n<|/ a |>\n<| a tags=ruby,arrays |>\nYou just\
    \ need to reverse the array and select the first element (which will return the\
    \ second smallest element):\n<code>\n[1,2,3,4,5,6,7,8,9,10][1..-1]\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=ruby,arrays dscore=1 |>\nThis also works:\n<code>",
  "  if lst.empty?\n    next\n  else\n    lst.first > lst.last ? lst.last : lst.first\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is a bad answer for large\
    \ lists.\n<|/ c |>\n<| c |>\nIt doesn't work for large lists. This is O(n) and\
    \ the correct answer is O(1).\n<|/ c |>\n<| c |>\nThe OP asked for best answer.\n\
    <|/ c |>\n<| c |>\nNo. As I said, this is O(n) time and O(1) space. That is the\
    \ best answer for this question. The other answers require O(n) space.\n<|/ c\
    \ |>\n<| c |>\nIt is not O(1) space and O(n) time. It requires O(n) space to store\
    \ the result, and that requires O(n) time. O(1) space and O(1) time are two different\
    \ concepts. O(1) space is related to time, O(1) time is related to space.\n<|/\
    \ c |>\n<| a tags=ruby,python,algorithm |>\nHere's a solution in Python:\n<code>",
  "  smallest = nil\n  largest = nil\n  sorted = nil\n  i = 0\n  \n  while i < lst.size\n\
    \    if lst[i] > largest\n      largest = lst[i]\n    end\n    if lst[i] < smallest\n\
    \      smallest = lst[i]\n    end\n    sorted = lst\n    sorted.rotate(-1) i\n\
    \    i += 1\n  end\n  return smallest\nend", "  if lst.empty?\n    next\n  el\
    \ = lst[0]\n  lst.shift 1\n  lst.uniq!\n  lst[0]\n  el\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThis is great, however it doesn't work for empty lists.\n<|/ c\
    \ |>\n<| c |>\n- Yes, you're right. I edited the answer to take care of that case\
    \ as well.\n<|/ c |>\n<| c |>\nIt's okay, I'm just giving you a +1.\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>", "  smallest = lst[0]\n  next smaller = smallest+1\n\
    \  for i in lst\n    next smaller <=> i\n    if next smaller == i\n      return\
    \ next\n  end\n  next\nend\n</code>\n<|/ a tags=ruby,sorting,algorithm |>\n<|\
    \ c |>\nThanks, this was extremely helpful. \nI did notice a problem with this\
    \ though that you didn't address. I wanted to write an algorithm that would return\
    \ the 2nd smallest element of a sorted array (for example, a number in increasing\
    \ order 1, 2, 3, 4, 5 and 7). How would you go about doing this?\n<|/ c |>\n<|\
    \ c |>\nThanks, I appreciate it. This was really helpful and definitely helped\
    \ me understand how to attack the problem at hand.\n<|/ c |>\n<| a tags=ruby,sorting,algorithm\
    \ |>\n<code>", "  smallest = nil\n  smallest_idx = nil\n  lst.each_index do |i|\n\
    \    if smallest.nil? || lst[i] < smallest\n      smallest = lst[i]\n      smallest_idx\
    \ = i\n    end\n  end\n  return smallest\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  result = nil\n  lst.each do |num|\n    if result != nil && result\
    \ > num\n      result = num\n    end\n  end\n  return result\nend", "  lst.sort.reverse\n\
    \  lst.detect { |x| x < lst.first }\nend", "  lst.sort.each_with_index do |x,\
    \ i|\n    return x if i == 0\n    return x if x <= lst[i+1]\n  end\n  return nil\n\
    end", "  \n  # Your code here\n  lst.sort!\n  if lst.empty?\n    return nil\n\
    \  else\n    p lst\n    p lst.size\n    p lst.min\n    return lst[lst.size - 2]\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| a tags=ruby,algorithm |>\n\
    You can use Enumerable#sort, for example:\n<code>\n(1..10).sort { |a, b| (b -\
    \ a) }\n</code>\nreturns\n<code>\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nNice idea, but in Ruby 1.9.2 I get a deprecation warning\
    \ when I try this. `DEPRECATION WARNING: Pass [Enumerable#sort] a block instead\
    \ of a proc. Though blocks will still work, passing a proc is now deprecated because\
    \ it relies on variable binding and will raise an ArgumentError in 1.9. Instead,\
    \ use `sort_by` to pass a block.`\n<|/ c |>\n<| a tags=ruby,algorithm dscore=5\
    \ |>\n<code>\n(1..10).sort_by { |i| i }\n</code>\nThe sort_by method works like\
    \ the sort method but returns a new array instead of modifying the original array:",
  "  lst.sort {|x,y| y < x ? -1 : 1} # sort is stable\n  return lst.first\nend\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nThis was an interesting challenge. I didn't see anyone\
    \ posting their answer so I figured I'd just write my own.\n<code>", "  smallest\
    \ = nil\n  i = nil\n  for i in 0...lst.length\n    if lst[i] < smallest\n    \
    \  smallest = lst[i]\n    end\n  end\n  smallest\nend", "  return lst.find {|x|\
    \ x <=> lst.min}\nend", "  return lst.sort { |a, b| b <=> a }.last\nend", "  \
    \  arr.sort! # Sort in ascending order\n    return arr.shift\nend", "  smallest\
    \ = nil\n  smallest_value = nil\n  lst.each do |x|\n    if smallest_value.nil?\n\
    \      smallest_value = x\n      smallest = x\n    elsif x < smallest_value\n\
    \      smallest_value = x\n      smallest = x\n    end\n  end\n  return smallest\n\
    end\n</code>\n<|/ a tags=ruby,loops |>\n<| a tags=ruby,loops |>\nIf you must use\
    \ loops, you can use the #min method, like this:\n<code>", "  lst.sort\n  lst.shift\
    \ if lst.first == lst.last\n  lst.first\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\n`lst.shift if lst.first == lst.last` is just `lst.shift`. The `if`\
    \ statement is just clutter.\n<|/ c |>\n<| c |>\n`lst.shift if lst.first == lst.last`\
    \ is not \"just clutter\". It makes it easier to understand what that line does.\
    \ I disagree with the sentiment on \"clutter\", but if you disagree then please\
    \ explain the downvote so I can improve my wording.\n<|/ c |>\n<| c |>\nIf `lst.first`\
    \ is `nil` the code would return `nil` and wouldn't work. `lst.shift` would raise\
    \ an exception because `nil` doesn't respond to `shift`. However, `lst.shift if\
    \ lst.first == lst.last` doesn't raise an exception; it simply returns `lst.first`.\
    \ You can test this out by changing `nil` to something that responds to `shift`\
    \ (i.e. `42`).\n<|/ c |>\n<| c |>\nYou are right. I was thinking of something\
    \ like `lst.shift if lst.last == nil` or `lst.shift if lst.first == lst.last`,\
    \ but I was too hasty.\n<|/ c |>\n<| a dscore=5 tags=ruby,arrays |>\nThe easiest\
    \ way to do this with Ruby 1.9 will be:\n<code>", "    smallest_index = lst.index(lst.min)\
    \  # index of smallest element\n    smallest_value = lst[smallest_index]\n   \
    \ lst[smallest_index] = lst.min  # set smallest element to first element\n   \
    \ lst.delete(smallest_value)  # delete smallest element\n    smallest_index +=\
    \ 1\n    smallest_value = lst[smallest_index]\n    lst[smallest_index] = lst.min\
    \  # set smallest element to second element\n    lst.delete(smallest_value)  #\
    \ delete smallest element\n    smallest_index += 1\n    smallest_value = lst[smallest_index]\n\
    \    lst[smallest_index] = lst.min  # set smallest element to third element\n\
    \    lst.delete(smallest_value)  # delete smallest element\n    smallest_index\
    \ += 1\n    smallest_value = lst[smallest_index]\n    lst[smallest_index] = lst.min\
    \  # set smallest element to forth element\n    lst.delete(smallest_value)  #\
    \ delete smallest element\n    smallest_index += 1\n    smallest_value = lst[smallest_index]\n\
    \    lst[smallest_index] = lst.min  # set smallest element to fifth element\n\
    \    lst.delete(smallest_value)  # delete smallest element\n    smallest_index\
    \ += 1\n    smallest_value = lst[smallest_index]\n    lst[smallest_index] = lst.min\
    \  # set smallest element to sixth element\n    lst.delete(smallest_value)  #\
    \ delete smallest element\n    return smallest_value\n</code>\nThis solution will\
    \ work for lists of any size. By indexing the list you can find the minimum element,\
    \ remove it, and add it to the index where it is currently at the list. This will\
    \ always work for any list you throw at it.\n<|/ a |>\n<| c |>\nThis solution\
    \ will break in case of `[1,1,2,3]`, where it won't be able to find the first\
    \ smallest.\n<|/ c |>\n<| c |>\nYes, I edited the solution to allow for any list\
    \ length\n<|/ c |>\n<| c |>\nIt's better to replace `lst.delete(smallest_value)`\
    \ with `lst.remove(smallest_value)`. `remove` returns the removed value and `delete`\
    \ does not. [From the docs](https://docs.python.org/2/tutorial/datastructures.html#more-on-lists):\
    \ \"The remove method deletes the item from the list but returns it. The del statement\
    \ removes the item from the list.\"\n<|/ c |>\n<| c |>\nI agree that `remove`\
    \ would be the better choice. I was just showing how to use `delete` for something\
    \ other than removing an item from a list\n<|/ c |>\n<| a dscore=2 |>\n", "  \
    \  smallest = lst[0]\n    smallest_index = lst.index(smallest)\n    if smallest_index\
    \ > 0 and smallest_index < len(lst)-1:\n        return lst[smallest_index+1]\n\
    \    else:\n        return None\nprint(next_smallest([5, 1, 4, 3, 2]))\nprint(next_smallest([]))\n\
    print(next_smallest([1, 1]))\n</cell>\n<text>\nGiven a list and a value, remove\
    \ all instances of that value inside the list, and return a new list without those\
    \ values.", "  return lst.min if lst.count > 1 else None\nend", "  return lst.sort.last\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere is a ruby implementation\
    \ to find the second smallest.\n<code>", "  if lst.empty?\n    None\n  el = lst.min\n\
    \  lst.delete_at(lst.index(el))\n  el\nend\n</code>\n<|/ a tags=ruby,arrays dscore=1\
    \ |>\n<| a |>\nThis is really late but here is the solution I came up with.\n\
    <code>", "    smallest=nil\n    smallest=lst[1]\n    smallest=lst[0] if smallest==nil\
    \ \n    return smallest\nend", "    i = lst.size - 1\n    return lst[i+1] if i\
    \ > 0 else None\nend", "  lst[0..-1].reverse_each{|x| return x unless lst.include?(x)}\n\
    \  lst[0..-1].first\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis would be\
    \ a great answer if you could explain what `lst[0..-1].reverse_each{|x| return\
    \ x unless lst.include?(x)}` does.\n<|/ c |>\n<| c |>\n`reverse_each` is an iterator\
    \ for an array in reverse. `return x` stops iteration when the first element matches\
    \ the given element (it returns `nil` if no match was found), otherwise it returns\
    \ the element in the array. `include?` returns `true` if the given element is\
    \ in the array (and `nil` otherwise) and `false` otherwise. Combine that with\
    \ the fact that the return value of `include?` is an `if` statement and you get\
    \ the desired behavior.\n<|/ c |>\n<| c |>\nThank you! And thank you for explaining\
    \ `reverse_each`\n<|/ c |>\n<| a |>\nThis would be my way of doing it. I'm sure\
    \ there may be more efficient ways, but this is what I came up with:\n<code>",
  '  smallest, largest = lst.minmax', "  return lst.sort[1] if lst.is_a?(Array) and\
    \ lst.sort.length>1 \n  lst.sort[-2] if lst.is_a?(Array) and lst.sort.length>2\
    \ \n  lst.sort[-1] if lst.is_a?(Array) and lst.sort.length>3 \nend", "  lst.each_with_index\
    \ do |e, i|\n    return e if e.to_i < lst[i+1].to_i \n  end\nend", "    \n   \
    \ smallest = lst[0]\n    smallest_index = -1\n    \n    for idx, val in enumerate(lst):\n\
    \        if val < smallest:\n            smallest = val\n            smallest_idx\
    \ = idx\n            \n    if smallest_index == -1: return None\n    return lst[smallest_index+1]",
  "  smallest_idx = lst.index(lst.min) \n  return lst[smallest_idx + 1] if smallest_idx\
    \ < lst.size - 1 else None\nend", "  if lst.size == 0\n  else\n    min_value =\
    \ lst[0]\n    max_value = lst[0]\n    smallest_index = lst.index min_value\n \
    \   max_index = lst.index max_value\n    return lst[smallest_index + 1] if smallest_index\
    \ != max_index else None\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=ruby,sorting,arrays\
    \ |>\nYou could use the .sort method and just pass the array and it will sort\
    \ it for you. Something like this should work:\n<code>", "  smallest = lst[0]\n\
    \  smallest_index = 0\n  for i in 1..lst.count\n    if smallest[i] > smallest[smallest_index]\n\
    \      smallest = lst[i]\n      smallest_index = i\n    end\n  end\n  smallest\n\
    end\n</code>\n<|/ a |>\n<| c |>\n`next_smallest([1, 2, 3, 4, 5]) == 2` - I don't\
    \ think so, how can you be sure?\n<|/ c |>\n<| c |>\nThe question is what should\
    \ return `next_smallest([2,1,2,3]) == 3`\n<|/ c |>\n<| c |>\nThen the question\
    \ should be \"Find the smallest number in the array and return the next smallest\
    \ number\"\n<|/ c |>\n<| c |>\nNo, the question should be \"Find 2nd smallest\
    \ number in the array and return the next smallest number\"\n<|/ c |>\n<| c |>\n\
    Thanks for the clarification.  Answer updated.\n<|/ c |>\n<| a dscore=1 tags=arrays,ruby\
    \ |>\nOne way to solve this in Ruby is to find the smallest and second smallest\
    \ numbers in an array and return the next smallest:\n<code>", "  min = lst[0]\n\
    \  min_index = lst.index(min)\n  if min_index == 0 # First element, no need to\
    \ search\n    return min\n  min_index -= 1\n  while min_index >= 0 # Iterate through\
    \ list, skipping 1 item\n    return lst[min_index]\n  return nil\nend", "  smallest\
    \ = lst[0]\n  second_smallest = nil\n  lst.each do |x|\n    if x < smallest\n\
    \      second_smallest = smallest\n      smallest = x\n    elsif x == smallest\n\
    \      second_smallest = x\n    end\n  end\n  second_smallest\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails dscore=3 |>\n<| a tags=ruby,ruby-on-rails |>\n<code>",
  "  lst.sort!\n  return lst[1] if lst.length > 1 else None\nend", "    smallest =\
    \ nil\n    nextsmallest = nil\n    smallest.nil?\n    if lst.nil?\n        puts\
    \ \"nil\"\n    end\n    smallest = lst[0]\n    nextsmallest = smallest\n    puts\
    \ smallest\n    puts nextsmallest\n    puts lst.size\n    puts lst.count\n   \
    \ puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_a\n    puts lst.inspect\n    puts lst.size\n    puts lst.count\n\
    \    puts lst.to_", "  lst.sort!\n  if lst.size <= 1\n    return nil\n  else\n\
    \    smallest = lst[1]\n    lst.delete_at(1).min\n  end\nend", "    smallest =\
    \ lst[0]\n    second_smallest = lst[0]\n    \n    for i in lst:\n        if i\
    \ < smallest:\n            second_smallest = smallest\n            smallest =\
    \ i\n        elif i > second_smallest:\n            second_smallest = i\n    \n\
    \    return second_smallest", "  lst = lst.sort\n  lst.shift\n  lst.length ==\
    \ 0 ? nil : lst[1]\nend", "  if lst.size > 1\n    smallest = lst[0]\n    second_smallest\
    \ = lst[1]\n    idx = 3\n    while idx < lst.size\n      smallest = lst[idx]\n\
    \      second_smallest = lst[idx+1]\n      idx += 2\n    return second_smallest\
    \ if second_smallest < smallest else smallest\n  end\nend", "    arr.each_with_index\
    \ do |i,index|\n        if arr[index] < arr[index + 1]\n            return arr[index\
    \ + 1]\n        end\n    end\nend", "  smallest = nil\n  smallest_idx = nil\n\
    \  if lst.size < 1\n    return nil\n  end\n  lst.each_with_index do |x, i|\n \
    \   if x < smallest\n      smallest = x\n      smallest_idx = i\n    end\n  end\n\
    \  if smallest_idx == nil\n    return nil\n  end\n  return smallest\nend", " \
    \ if lst.empty?\n    nil\n  else\n    smallest_element = lst.min\n    if lst.min.next\
    \ == nil\n      nil\n    else\n      next_smallest(smallest_element.next)\n  \
    \  end\n  end\nend", "  return lst.find {|x| x.next == lst.min}\nend", "  lst.sort!\n\
    \  if lst.length < 2\n    puts \"There doesn't exist a 2nd smallest element in\
    \ the list\"\n  elsif lst.last.nil? || lst.last == lst.first\n    puts \"There\
    \ is no 2nd smallest element in the list\"\n  else\n    puts \"#{lst.last} is\
    \ the 2nd smallest element in the list\"\n  end\nend", "    lst = lst.sort {|a,\
    \ b| a <=> b }\n    return lst.shift if lst.size > 0\n    nil\nend\n</code>\n\
    <|/ a dscore=4 tags=ruby |>\n<| c |>\nYou could also use `sort.first(nil, nil)`\n\
    <|/ c |>\n<| c |>\n: That's better, but I think the OP was more concerned with\
    \ the \"next\" rather than \"the first\".\n<|/ c |>\n<| c |>\nYes, but his code\
    \ says \"get the 2nd smallest element of the list\"\n<|/ c |>\n<| c |>\nThe OP\
    \ said the function would be given a list of integers. I assume that is what the\
    \ function should return, though it is not explicitly stated.\n<|/ c |>\n<| c\
    \ |>\n: I interpreted it to be the second smallest element. My code returns `nil`\
    \ if there is no 2nd smallest element in the list, as requested in the OP.\n<|/\
    \ c |>\n<| a tags=ruby |>\nI would do it this way\n<code>", "  if lst.size ==\
    \ 0\n    nil\n  else\n    smallest_el = lst[0]\n    lst.pop(0)\n    smallest_el\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\n<code>", "  smallest = nil\n\
    \  smallest = lst[0] if lst.size == 1\n  lst.each_with_index do |element, i|\n\
    \    if element < smallest\n      smallest = element\n    end\n  end\n  smallest\n\
    end\n</code>\n<|/ a tags=ruby,algorithm,python,python-3.x,ruby-on-rails dscore=2\
    \ |>\n<| a |>\nI realize this thread is very old, but I found an elegant solution\
    \ that I wanted to share. \n<code>", "  lst.sort { |a, b| a.to_i < b.to_i ? -1\
    \ : 1 } \n  lst.size == 1 ? nil : lst[1]\nend", "  arr.sort.each do |x|\n    return\
    \ x if x < arr[arr.length - 1]\n  end\n  return nil\nend", "  sorted_list = lst.sort\n\
    \  if sorted_list.length <= 1\n    return sorted_list[0]\n  return sorted_list[1]\n\
    end", "  lst.reverse.each do |i|\n    if i == lst[1]\n      return i\n    end\n\
    \  end\n  return nil\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm dscore=0\
    \ |>\n<| c |>\nThis would be great, but it doesn't return the correct answer for\
    \ `next_smallest([5, 1, 4, 3, 2])`\n<|/ c |>\n<| c |>\nApologies, I didn't test\
    \ it first. Have now corrected it. I added a more efficient algorithm (based on\
    \ `min` and binary search instead)\n<|/ c |>\n<| a |>\n<code>\na = [1,2,3,4,5]\n\
    a.pop(a.min).pop\n</code>\n<|/ a tags=ruby,arrays,algorithm dscore=0 |>\n<| c\
    \ |>\nThis will fail, if the array contains more than one element with the same\
    \ minimum value. The method will return `nil`.\n<|/ c |>\n<| c |>\nIt does not\
    \ return the 2nd smallest element, that has been asked in the question\n<|/ c\
    \ |>\n<| c |>\nThis returns the *first* smallest element. Also, it returns `nil`\
    \ if there is more than one element with the same minimum value. It's not what\
    \ was asked in the question.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm dscore=0\
    \ |>\n<code>", "    smallest = lst[0]\n    second_smallest = lst[1]\n    third_smallest\
    \ = lst[2]\n    if smallest\n        if second_smallest == lst[1] and third_smallest\
    \ == lst[2]\n            return lst[2]\n        else\n            return second_smallest\n\
    \    else\n        return third_smallest\nend\n</cell>\n<code language=julia-1.3>\n\
    next_smallest([1, 2, 3, 4, 5])\n</cell>\n<code language=julia-1.3>", "  return\
    \ lst.sort.reverse.shift\nend", "  lst.each_with_index do |val, i|\n    return\
    \ val if (i == 0 || val < lst[i - 1]) \n  end\n  nil\nend\nputs next_smallest([5,\
    \ 1, 4, 3, 2]) ", "  lst.sort.reverse\n  lst.detect{|x| x < lst[lst.index(lst.detect{|x|\
    \ x < x})].min}\nend", "  smallest = lst.shift\n  lst.each do |x|\n    return\
    \ x if x < smallest\n    smallest = x\n  end\n  return nil\nend\n</code>\n<|/\
    \ a |>\n<| a tags=ruby dscore=0 |>\nAn example using each_cons (a method of the\
    \ Enumerable class):\n<code>", "  smallest, next_small = lst.sort.minmax\n  next\
    \ smallest\nend\n</cell>\n<cell>", "  return lst.min\nend", "  smallest = nil\n\
    \  if lst.size <= 0\n    smallest = nil\n  elsif lst.size <= 1\n    smallest =\
    \ lst[0]\n  else\n    smallest = lst[0]\n    lst[lst.size - 1].upcase!\n  end\n\
    \  lst[0].downcase!\n  lst.each {|i| smallest = i if i.upcase > smallest.upcase\
    \ }\n  smallest\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a dscore=1 tags=ruby\
    \ |>\n<code>", "  smallest, next_smallest = nil, lst[0]\n  smallest, next_smallest\
    \ = lst, nil\n  lst.each do |e|\n    if e.between?(smallest, next_smallest)\n\
    \      smallest, next_smallest = e, e\n    end\n  end\n  next_smallest\nend",
  "  a = lst[0]\n  b = lst[1]\n  c = lst[2]\n  d = lst[3]\n  e = lst[4]\n  return\
    \  a if (a<b and a<c and a<d and a<e) else b if (b<a and b<c and b<d) else c if\
    \ (c<a and c<b and c<d and c<e) else d if (d<a and d<b and d<c and d<e) else e\
    \ if (e<a and e<b and e<c and e<d) else a\nend", "  if lst.nil? || lst.empty?\n\
    \    lst\n  else\n    if lst.size == 1\n      lst.first\n    else\n      lst.min\n\
    \    end\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer, but\
    \ I think this doesn't solve the problem because this solution just returns what\
    \ the function returns, but the function also modifies the given list. I've updated\
    \ my answer to show what I mean.\n<|/ c |>\n<| c |>\nThe reason this doesn't work\
    \ is because the original list is not modified. The original list is still the\
    \ same, so the function returns the same list, and that's exactly what you need\
    \ to do.\n<|/ c |>\n<| c |>\nMy bad, didn't read the edit properly before commenting.\
    \ Thanks.\n<|/ c |>\n<| c |>\nThis has O(n^2) runtime complexity, is there a way\
    \ to do it with less runtime?\n<|/ c |>\n<| a dscore=2 |>\nI think this solution\
    \ will be helpful for you:\n<code>", "  lst.sort!\n  if lst.empty?\n    puts 'There\
    \ is no 2nd smallest'\n  else\n    lst.shift # remove 2nd smallest element\n \
    \   lst.shift # remove 1st smallest element\n    puts lst.min # return the 2nd\
    \ smallest element\n  end\nend", "  if lst.empty?\n    next\n  el = lst.pop\n\
    \  return el if el < next_smallest(lst) end\nend", "  sorted_list = lst.sort\n\
    \  smallest = sorted_list[0]\n  sorted_list.shift\n  smallest = sorted_list[0]\n\
    \  sorted_list.shift\n  return smallest if sorted_list.size == 0 else None\nend\n\
    </pre>\n</div>", "    smallest_el = nil\n    lst.reject! {|x| x < smallest_el\
    \ }\n    if lst.empty?\n        return nil\n    end\n    smallest_el = lst[0]\n\
    \    smallest_el\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays |>\n\
    <code>", '  return nil unless lst', "  lst.sort\n  lst.shift if lst.size == 1\n\
    \  lst\nend", "  lst.reverse!\n  lst.each do |value|\n    break if value < lst[0]\n\
    \    lst = lst.drop(1)\n  end\n  lst.reverse! if lst.size > 0\n  return lst.first\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,arrays,indexing,algorithm,search\
    \ |>\nHere is one approach using Enumerable#sort_by, which sorts the array in\
    \ place and returns an enumerator.  We then take the first element of the enumerator\
    \ to get the second smallest element:\n<code>", "  if lst.empty?\n    nil\n  else\n\
    \    lst[0] + [lst[1]] + lst[1..-1].min_by(&:lst.include?(lst.last))\n  end\n\
    end\n</code>\nThe second smallest element of a list can be found by adding an\
    \ element and all elements that are smaller than it. The problem with the first\
    \ solution is that it will return nil if all elements smaller than the given element\
    \ are smaller than the given element. In the second solution, the last element\
    \ will always be the smallest.\n<|/ a dscore=2 |>\n<| c |>\nYour code is wrong\
    \ for `next_smallest([1, 2, 3, 4, 5])` it returns 2 but in ruby it returns 5.\n\
    <|/ c |>\n<| c |>\nThanks. I fixed it so it always returns the last element when\
    \ all elements are smaller.\n<|/ c |>\n<| c |>\nThe OP explicitly said in the\
    \ question that the second smallest element is to be returned, not the first one.\n\
    <|/ c |>\n<| c |>\nYes you are right, I've corrected it now.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nHere is an elegant solution that returns a hash with the original elements\
    \ as keys and the next smallest as the value\n<code>", "  lst.sort.first.second\n\
    end", "  lst.each do |val|\n    return val if val < lst[1] and val != nil\n  end\n\
    \  nil\nend\n</code>\nAnd if you want this function to return all elements which\
    \ are lesser than the first one, use the following code\n<code>", "  lst.sort!\
    \ \n  return lst[2] if lst.size > 2 else None\nend\n</cell>\n<code language=julia-1.4>\n\
    next_smallest([5, 1, 4, 3, 2]) == 2\n</cell>\n<code language=julia-1.4>\nfunction\
    \ next_smallest2(lst)\n  lst.sort! \n  if lst.size > 2 \n    return lst[2] \n\
    \  else \n    return None \n  end\nend\n</cell>\n<code language=julia-1.4>\nnext_smallest2([5,\
    \ 1, 4, 3, 2]) == 2\n</cell>\n<code language=julia-1.4>\nfunction next_smallest3(lst)\n\
    \  lst.sort! \n  if lst.size > 2 \n    return lst[2] \n  else \n    return lst.min\n\
    \  end\nend\n</cell>\n<code language=julia-1.4>\nnext_smallest3([5, 1, 4, 3, 2])\
    \ == 2\n</cell>\n<code language=julia-1.4>\nfunction next_smallest4(lst)\n  lst.sort!\
    \ \n  if lst.size > 2 \n    return lst[2] \n  else \n    return lst.max \n  end\n\
    end\n</cell>\n<code language=julia-1.4>\nnext_smallest4([5, 1, 4, 3, 2]) == 2\n\
    </cell>\n<code language=julia-1.4>\nfunction next_smallest(lst)\n  lst.sort! \n\
    \  if lst.size > 2 \n    return lst[2] \n  else \n    return None \n  end\nend\n\
    </cell>\n<code language=julia-1.4>\nnext_smallest([5, 1, 4, 3, 2]) == 2\n</cell>\n\
    <code language=julia-1.4>\nfunction next_smallest1(lst)\n  lst.sort! \n  if lst.size\
    \ > 2 \n    return lst[2] \n  else \n    return lst.min\n  end\nend\n</cell>\n\
    <code language=julia-1.4>\nnext_smallest1([5, 1, 4, 3, 2]) == 2\n</cell>\n<code\
    \ language=julia-1.4>\nfunction next_smallest2(lst)\n  lst.sort! \n  if lst.size\
    \ > 2 \n    return lst[2] \n  else \n    return lst.min\n  end\nend\n</cell>\n\
    <code language=julia-1.4>\nnext_smallest2([5, 1, 4, 3, 2]) == 2\n</cell>\n<code\
    \ language=julia-1.4>\nfunction next_smallest3(lst)\n  lst.sort! \n  if lst.size\
    \ > 2 \n    return lst[2] \n  else \n    return lst.max\n  end\nend\n</cell>\n\
    <code language=julia-1.4>\nnext_smallest3([5, 1, 4, 3, 2]) == 2\n</cell", "  return\
    \ lst.first + lst.find_index{|x|x.next<=>x.first} if lst.size>1\n  return lst.first\
    \ if lst.empty?\nend\n</cell>\n<code language=julia-0.5>", "  return lst.sort{|a,\
    \ b| a <=> b}.delete_if{|x| x != lst[1]} if lst.size >= 2\n  nil\nend\n</code>\n\
    <|/ a dscore=3 tags=ruby,list |>\n<| a |>\nAn efficient solution would be to use\
    \ the Array#index method.\n<code>\na = [2, 4, 5, 6, 10, 11, 15, 19]", "  lst.sort!\
    \ # sorting the list in ascending order\n  return lst[2] if lst.size > 2 else\
    \ None\nend", '  smallest = nil', "    smallest = nil\n    next = []\n    loop\
    \ do\n        next << lst.shift\n        next << smallest\n        smallest =\
    \ nil\n        break unless smallest.nil?\n        loop do\n            smallest\
    \ = next if lst.empty?\n            next << lst.shift\n            next << smallest\n\
    \            break unless smallest.nil?\n        end\n        break unless smallest.nil?\n\
    \    end\n    smallest\nend\n</code>\nIt works fine, but it's an ugly solution\
    \ that I wouldn't recommend for production code.\n<|/ a tags=ruby |>\n<| c |>\n\
    +1 for the solution. but it's also not working for [2,4,1]. it returns 4 instead\
    \ of 1.\n<|/ c |>\n<| c |>\nThis is also not working for [2,4,1,3,5] returning\
    \ 2 instead of 1. Can you please help me with this?\n<|/ c |>\n<| c |>\nI fixed\
    \ the bug; it was a logic error.\n<|/ c |>\n<| c |>\nSorry it took me so long\
    \ to accept this solution. Thanks very much for the solution. I will accept it\
    \ again if I could find a better one. :)\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n\
    <code>", "  return lst.sort.last(2)[1]\nend", "  return lst.find { |e| e.next\
    \ == lst.min }\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=ruby,ruby-on-rails,algorithm\
    \ |>\nAnother approach would be to use the built-in Ruby array sort method:\n\
    <code>", "  smallest = nil\n  smallest_index = nil\n  lst.each do |i|\n    if\
    \ smallest_index.nil?\n      smallest_index = i\n      smallest = i\n    elsif\
    \ i < smallest\n      smallest = i\n      smallest_index = i\n    end\n  end\n\
    \  return smallest_index\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby dscore=0\
    \ |>\nI have an alternative solution to this problem:\n<code>", "  if lst.count\
    \ <= 1\n    lst.pop\n    puts \"No such element\" if lst.empty?\n    return\n\
    \  end\n  lst.sort\n  lst.pop\n  lst.length == 2 ? lst.pop : nil\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a tags=ruby |>\nI suggest you use Enumerable#min_by.\n\
    <code>\n[1, 2, 3, 4, 5].min_by { |v| v }  # => 2\n[1, 2, 3, 4, 5].min_by { |v|\
    \ -v }  # => nil\n</code>\nIt returns either an element of the collection, or\
    \ nil if the collection is empty. Be aware that this method does not sort the\
    \ collection.\n<code>\n[1, 2, 3, 4, 5].min_by { |v| -v }  # => nil\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI like this solution.  However, when I ran the code\
    \ it returned nil instead of 2.  Any idea why that would be?\n<|/ c |>\n<| c |>\n\
    That happens when there is only one element in the collection. I'll update my\
    \ answer.\n<|/ c |>\n<| c |>\nHi Bearts,  I apologize for my ignorance but I still\
    \ am confused on why that would happen.  When I tested it with my original code,\
    \ the code I was trying to use would return the first element of the array if\
    \ there were more than one element in the array.  It seems that is where the nil\
    \ came from since it is returning nil instead of 2.  Am I misunderstanding your\
    \ solution?\n<|/ c |>\n<| c |>\nWhen there is only one element in the array `[1,\
    \ 2, 3, 4, 5]`, `v` is `1`, so `v == v` is the condition to be met. The expression\
    \ `v # => 2` is then evaluated, and returns `2`.\n<|/ c |>\n<| c |>\nAh ok.  So\
    \ it just returns the first value regardless.  Is that what you meant by 'returns\
    \ the 2nd smallest element of the list'?\n<|/ c |>\n<| a dscore=0 tags=ruby |>\n\
    <code>", "  lst.sort\n  lst.shift while lst.first < lst.last\n  lst.first\nend",
  "  # sort is more efficient for sorted data\n  # return lst[1] if lst.sort == true\
    \ else nil\n  lst.sort.select {|x| x < lst[1].to_f}.first\nend", "  smallest =\
    \ lst[0]\n  second_smallest = lst[1]\n  i = 1\n  while i < lst.length\n    if\
    \ lst[i] < smallest\n      second_smallest == smallest\n      smallest = lst[i]\n\
    \    i += 1\n  end\n  return smallest\nend", "    i = 0\n    while i < lst.size\n\
    \        if (i < lst.size && lst[i] < lst[i + 1] && lst[i + 1] < lst[i + 2])\n\
    \            return lst[i + 1]\n        i += 1\n    end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks for the detailed answer! Unfortunately I couldn't solve\
    \ my problem with it. Do you mind looking at my latest edit? :)\n<|/ c |>\n<|\
    \ c |>\nYou want to return the next smallest number if it's not the 2nd smallest\
    \ number and if it's less than the current second smallest number then return\
    \ the current second smallest number as well? If that's the case then you can\
    \ do something like this: `def next_smallest(lst)\n    i = 0\n    while i < lst.size\n\
    \        if (i < lst.size && lst[i] < lst[i + 1])\n            return lst[i +\
    \ 1]\n        end\n        i += 1\n    end\nend` And it should work.\n<|/ c |>\n\
    <| c |>\nThanks again for helping me solve my problem :)\n<|/ c |>\n<| a dscore=0\
    \ |>\nUse sort to solve this problem\n<code>\nnumbers = [10, 9, 8, 7, 5, 6, 4,\
    \ 3, 1]", "  nsmallest, smallest = nil, nil\n  for i in lst\n    if i.nil?\n \
    \     return nil\n    elsif i < smallest.value\n      nsmallest = smallest\n \
    \     smallest = i\n    elsif nsmallest.value < i.value\n      nsmallest = i\n\
    \    end\n  end\n  return smallest\nend", "  smallest = nil\n  \n  lst.each_with_index\
    \ do |x, i|\n    smallest = i if x < smallest\n  end\n  \n  smallest\nend", " \
    \   return lst.sort{|a, b| a <=> b }[1] if lst.length >= 1\nend\n</code>\n<|/\
    \ a tags=ruby,list,minimum dscore=1 |>\n<| c |>\nWhile this code may answer the\
    \ question, providing additional context regarding how and/or why it solves the\
    \ problem would improve the answer's long-term value.\n<|/ c |>\n<| a tags=ruby,list,minimum\
    \ |>\nHere are a couple of ways to get the same result:\n<code>\nmy_list = [5,\
    \ 3, 1, 2, 4, 6, 8, 7]", "  smallest = nil\n  smallest_idx = nil\n  for i in 0..(lst.count-1)\n\
    \    smallest_idx = i\n    if smallest_idx == lst.count-1\n      smallest = lst[lst.count-1]\n\
    \      break\n    elsif lst[i] < lst[smallest_idx]\n      smallest_idx = i\n \
    \   end\n  end\n  return smallest\nend", "    smallest = lst.sort[0]\n    if smallest.nil?\n\
    \        return None\n    smallest = lst.sort[1]\n    smallest\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby,ruby-on-rails,ruby-on-rails-3,rubygems,ruby-on-rails-4\
    \ |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3,rubygems,ruby-on-rails-4 dscore=0\
    \ |>\nI prefer to do this: \n<code>\narray.map { |v| v == array.min ? nil : v\
    \ }.compact\n</code>\n<|/ a |>\n<| c |>\nThat would not return the second smallest\
    \ element. It would return the minimum value if there are no elements equal to\
    \ the minimum value or nil if the minimum value is nil.\n<|/ c |>\n<| c |>\nYour\
    \ solution is good but I am looking for something different from it. I want to\
    \ return the 2nd smallest number if there a duplicate numbers in the array.\n\
    <|/ c |>\n<| c |>\nBut there are two numbers 2 in the array, and I want the 2nd\
    \ smallest element. Your solution would return the first smallest element.\n<|/\
    \ c |>\n<| c |>\nYes, you are right, sorry. But I did not understand your comment\
    \ about the second number. Could you give an example?\n<|/ c |>\n<| c |>\nFor\
    \ example - [1, 2, 3, 4, 5, 6, 7] should return 2, because there is two 2 numbers.\
    \ My method returns 2, which is not the second smallest element of the array.\
    \ I am looking for a solution which would return 2 as the 2nd smallest number\
    \ in the array.\n<|/ c |>\n<| a |>\nThis is a little more elegant than some of\
    \ the other responses posted. It uses the \"break\" keyword which immediately\
    \ ends a loop and returns the first true condition.\n<code>\narray.sort.drop(1).first\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3,rubygems,ruby-on-rails-4\
    \ dscore=0 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3,rubygems,ruby-on-rails-4\
    \ |>\nThis solution is more readable:\n<code>\narray.sort.first\n</code>\nAnd\
    \ it works in case there are more than one elements that are equal to the minimum\
    \ value:\n<code>\n[2,4,1,3].sort.first\n=> 1\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=ruby,ruby-on-rails,ruby-on-rails-3,rubygems,ruby-on-", "  return lst.min\
    \ if lst.min > lst.sort end\nend", "  if lst.size == 0\n    puts \"The list is\
    \ empty\"\n  elsif lst.size == 1\n    puts \"There is no element that is smaller\
    \ than #{lst}\"\n  else\n    puts \"#{lst.shift} is smaller than #{lst.shift}\"\
    \n  end\nend", "    smallest = lst[0]\n    second_smallest = lst[1]\n    smallest_index\
    \ = 2\n    second_smallest_index = 2", "  lst.each_with_index { |el, index| return\
    \ el if index == 0 }\n  nil\nend", "  # get all the elements into an array\n \
    \ elements = lst.to_a\n  # check if the array is empty\n  return if elements.empty?\n\
    \  # find the minimum element and remove it from the array\n  index1 = elements.index{|e|\
    \ e < elements[1]}\n  elements.delete_at(index1)\n  index2 = elements.index{|e|\
    \ e < elements[2]}\n  elements.delete_at(index2)\n  index3 = elements.index{|e|\
    \ e < elements[3]}\n  elements.delete_at(index3)\n  index4 = elements.index{|e|\
    \ e < elements[4]}\n  elements.delete_at(index4)\n  # if the array is empty return\
    \ the nil value\n  return nil if elements.empty?\n  # return the minimum element\
    \ of the array\n  elements[1]\nend", "  return lst.sort.first\nend\n</cell>\n\
    <cell>", "  return nil if lst.empty? or lst.size < 2\n  lst.sort\n  lst.take_while\
    \ { |x| x < lst.first }.last\nend\n</code>\n<|/ a |>\n<| a tags=ruby,ruby-on-rails,sorting\
    \ |>\nThe sort_by method will let you do this:\n<code>\n>> arr = [2,1,3,5,1,4,3,6,9]\n\
    => [2, 1, 1, 3, 5, 3, 4, 6, 9]\n>> arr.sort_by { |e| e }\n=> [1, 3, 4, 5, 2, 6,\
    \ 9, 3, 2]\n</code>\nOr if you need to sort your array in a descending order,\
    \ just pass it a block to reverse the order:\n<code>\n>> arr.sort_by { |e| e }.reverse\n\
    => [9, 3, 6, 4, 5, 3, 2, 1]\n</code>\nTo find the second smallest element in your\
    \ array, you can do this:\n<code>\n>> arr.sort_by { |e| e }.first(2)\n=> [1, 3]\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThe reverse sort is useful, but if the OP\
    \ has more than two numbers to find - then he might want to sort them in order\
    \ and take the second element only. E.g.: `[6,5,4,3,2,1]`\n<|/ c |>\n<| c |>\n\
    `sort_by` only works if the elements *are* in the same order as the original.\
    \ This is not the case in the example above. The `sort_by` solution is much more\
    \ flexible.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  return lst.sort.each_cons(2).find\
    \ do |a, b|\n    a < b\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\"Ruby\
    \ has `next` and a `next!` method, but I don't think they work the way you intended\
    \ here.\" They do work in the way you intended, as long as you know what `next`\
    \ does. You do know what `next!` does, as you already know what `sort` does, so\
    \ what is your problem?\n<|/ c |>\n<| c |>\n: I haven't written code in Ruby for\
    \ more than a year now. I've only written methods and classes in Ruby since 1.8.7\
    \ and I haven't seen `next` used before. I'll definitely have to remember `next`\
    \ from now on and learn to understand it before I start writing in other languages.\
    \ Thanks for pointing out the difference between `next` and `next!`.\n<|/ c |>\n\
    <| c |>\n: You're right. They do work the way I intended and `sort` is indeed\
    \ a method that exists in Ruby since 1.8.7, too. I had some issues with my code\
    \ but now it's fixed and it works. Thanks for pointing that out.\n<|/ c |>\n<|\
    \ c |>\n: Actually, it seems my code works also with Ruby 1.8.7, too.\n<|/ c |>\n\
    <| c |>\n, `sort_by` still exists in 1.8.7, it's just not aliased to `sort`. You\
    \ can call `sort` explicitly, but `sort_by` is much more flexible. For example,\
    \ you can use it to sort a collection based on a block, rather than just by a\
    \ specific key.\n<|/ c |>\n<| a dscore=0 |>\nRuby has both next and next!, but\
    \ I don't think they work the way you intended here.\nThe docs for next say it\
    \ returns the next element of an array, or nil if the array is empty (which you\
    \ have).  What do you expect to happen when you call next on an empty array? \
    \ What would you expect to happen if you call next! with an empty array?  You've\
    \ got to be careful with this method.  You'll want to think carefully about what\
    \ you want to do when you call it on an empty array.\nSimilarly, Ruby has both\
    \ max_by and max_by!, but again, I don't think they work the way you intended\
    \ here.\nThe docs for max_by say it returns the maximal element of an array, or\
    \ nil if there are no elements.  What do you expect to happen when you call max_by\
    \ on an empty array?  What would you expect to happen if you call ", "  smallest\
    \ = nil\n  n = nil\n  lst = lst.sort", "  smallest, smallest_index = find_min_and_index(lst)\n\
    \  return smallest_index ? lst[smallest_index] : smallest\nend", "  smallest =\
    \ nil\n  smallest = lst[1]\n  \n  return smallest if lst.size == 2 ", "  if lst.length\
    \ == 0\n    return nil\n  first_element = lst[0]\n  first_element_index = lst.index(first_element)\n\
    \  second_element_index = first_element_index - 1\n  if second_element_index >\
    \ 0\n    second_element = lst[second_element_index]\n    if second_element > first_element\n\
    \      return second_element\n    end\n  end\n  return nil\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=2 |>\nThe idea is to find the smallest item in the\
    \ list, then to remove it from list, and then to find the 2nd smallest item in\
    \ the list again. We can use the first solution to find the smallest item in the\
    \ list and then remove it. The next step then is to find the second smallest item\
    \ in the list again.\nHere is the solution:\n<code>\n def second_smallest_in_list(lst)\n\
    \   smallest = lst[0]\n   lst.remove(smallest)\n   second_smallest = lst[0]\n\
    \   lst.delete_at(lst.index(second_smallest))\n end\n</code>\n<|/ a tags=ruby,arrays,algorithm\
    \ |>\n<| c |>\nThis one can be made more efficient by moving the second smallest\
    \ to index 1 instead of index -1.  Just add 1 to the index.  Also, I would use\
    \ an array slice instead of `delete_at`.\n<|/ c |>\n<| a |>\n<code>", "    smallest\
    \ = nil\n    smallest_count = 0\n    \n    for x in lst\n        if smallest_count\
    \ == 0\n            smallest = x\n            smallest_count += 1\n          \
    \  \n        if x < smallest\n            smallest_count = 0\n            smallest\
    \ = x\n            \n        end\n    end\n    \n    return smallest\nend", " \
    \ smallest = nil\n  for i in lst do\n    if smallest==nil or i<smallest then\n\
    \      smallest = i\n    end\n  end\n  if smallest==nil then\n    return nil\n\
    \  end\n  j=0\n  for i in lst do\n    if i==smallest then\n      return i\n  \
    \  else\n      j=j+1\n      if j==2 then\n        return nil\n      end\n    end\n\
    \  end\nend\nputs next_smallest([5, 1, 4, 3, 2]) == 2\nputs next_smallest([1,\
    \ 2, 3, 4, 5]) == 2\nputs next_smallest([]) == nil\nputs next_smallest([1, 1])\
    \ == nil\n</cell>\n<cell>", '    smallest = lst[1]', "  return nil if lst.empty?\n\
    \  return lst.min if lst.size == 1\n  lst.drop(1).max\nend", "  lst.sort\n  lst.shift\
    \ if lst.size > 0 \n  lst.first if lst.size > 1\nend", '  smallest = nil', " \
    \ smallest_index = 0\n  smallest = lst[smallest_index]\n  while smallest_index\
    \ < lst.size - 1\n    smallest_index += 1\n    next if lst[smallest_index] < smallest\n\
    \    smallest = lst[smallest_index]\n  end\n  next\nend\nputs next_smallest([5,\
    \ 1, 4, 3, 2])\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,algorithm dscore=0\
    \ |>\nHere is an algorithm which runs in O(n) time complexity. Basically it loops\
    \ through the array and compares the current value with the next value in the\
    \ array. If current value greater than the next value then the current value is\
    \ stored in the temp variable and next is updated to current value. If the current\
    \ value is less than the next value then the next is updated to current value\
    \ and current value is stored in the temp variable. \n<code>", "  return lst.sort.min\n\
    end", "  # Your code here\n  first = nil\n  second = nil\n  count = 0\n  lst.each\
    \ do |el|\n    if(el < first)\n      first = el\n      count = count + 1\n   \
    \ elsif(el < second)\n      second = el\n      count = count + 1\n    end\n  end\n\
    \  if count > 2\n    return nil\n  elsif count == 2\n    return second\n  else\n\
    \    return first\n  end\nend", "  smallest,second=lst[0],lst[1]\n  for i in lst[2..-1]\n\
    \    if smallest>i then\n      smallest=i\n    else\n      second=i\n      break\n\
    \  end\n  return smallest\nend", "  n = lst[0]\n  if n < lst[1]\n    n = lst[1]\n\
    \  end\n  lst[1]\nend", "  smallest = lst[0]\n  index = 1\n  while index < lst.length\n\
    \    if smallest > lst[index]\n      smallest = lst[index]\n      index += 1\n\
    \    index += 1\n  end\n  smallest\nend", "  i = lst.index(lst.sort.min)\n  lst[i+1]\n\
    end", "  lst.shift if lst.size > 1 \n  lst.sort \n  lst.first\nend", "  smallest_idx\
    \ = nil\n  smallest_val = lst[0]", "    arr = lst.length\n    smallest = lst[0]\n\
    \    arr2 = arr-1\n    smallest2 = smallest\n    smallest3 = smallest\n    smallest4\
    \ = smallest\n    smallest5 = smallest\n    smallest6 = smallest\n    smallest7\
    \ = smallest\n    smallest8 = smallest\n    smallest9 = smallest\n    smallest10\
    \ = smallest\n    smallest11 = smallest\n    smallest12 = smallest\n    smallest13\
    \ = smallest\n    smallest14 = smallest\n    smallest15 = smallest\n    smallest16\
    \ = smallest\n    smallest17 = smallest\n    smallest18 = smallest\n    smallest19\
    \ = smallest\n    smallest20 = smallest\n    smallest21 = smallest\n    smallest22\
    \ = smallest\n    smallest23 = smallest\n    smallest24 = smallest\n    smallest25\
    \ = smallest\n    smallest26 = smallest\n    smallest27 = smallest\n    smallest28\
    \ = smallest\n    smallest29 = smallest\n    smallest30 = smallest\n    smallest31\
    \ = smallest\n    smallest32 = smallest\n    smallest33 = smallest\n    smallest34\
    \ = smallest\n    smallest35 = smallest\n    smallest36 = smallest\n    smallest37\
    \ = smallest\n    smallest38 = smallest\n    smallest39 = smallest\n    smallest40\
    \ = smallest\n    smallest41 = smallest\n    smallest42 = smallest\n    smallest43\
    \ = smallest\n    smallest44 = smallest\n    smallest45 = smallest\n    smallest46\
    \ = smallest\n    smallest47 = smallest\n    smallest48 = smallest\n    smallest49\
    \ = smallest\n    smallest50 = smallest\n    smallest51 = smallest\n    smallest52\
    \ = smallest\n    smallest53 = smallest\n    smallest54 = smallest\n    smallest55\
    \ = smallest\n    smallest56 = smallest\n    smallest57 = smallest\n    smallest58\
    \ = smallest\n    smallest59 = smallest\n    smallest60 = smallest\n    smallest61\
    \ = smallest\n    smallest62 = smallest\n    smallest63 = smallest\n    smallest64\
    \ = smallest\n    smalle", "  return lst.sort { |a, b| a <=> b }[1] if lst.size\
    \ > 0\n  nil\nend\n</code>\n<|/ a |>\n<| c |>\nThe question was how to find 2nd\
    \ smallest element in array of `Integer` numbers. Your solution does not work\
    \ in this case\n<|/ c |>\n<| a |>\n<code>", "  return lst[2] if lst.size != nil\
    \ and lst[2] < lst[1] ? lst[2] : nil\nend\n</code>\n<|/ a |>\n<| c |>\nThis is\
    \ my first time working in Ruby; thank you for showing me the syntax. It helped\
    \ me understand the logic behind the solution. It also taught me a little about\
    \ ternary statements and nil values. I appreciate the help!\n<|/ c |>\n<| a |>\n\
    I like Kenneth Reitz's answer. It's elegant and short, but doesn't answer the\
    \ question in the title. It was asked for Ruby, and the question was about what\
    \ happens when there are no elements in an array.\nHere's a one-liner for those\
    \ who are more familiar with Ruby, without using the nil constant:\n<code>", " \
    \ smallest1 = lst[1]\n  smallest2 = lst[2]", "    l = lst.count\n    count = 0\n\
    \    while l > 0 and count < l\n        count += 1\n        lst.shift\n    \n\
    \    return lst.last if count == l else None", "  return lst.sort.min{|a, b| b\
    \ <=> a}\nend", "  lst.sort.take_while { |e| e < lst.last }.last\nend\n</code>\n\
    The solution using take_while would be similar, but more efficient:\n<code>",
  "  sorted = lst.sort\n  if sorted.length <= 1\n    return nil\n  end", "    return\
    \ lst[1] unless lst.nil?\n    return nil if lst.size == 0\n    return lst[1] unless\
    \ lst.size == 1\n    return nil unless lst.size < 2\n    return lst[1] if lst[1]\
    \ > lst[0]\n    next_smallest(lst[2..-1].uniq)\nend", "  return lst.min\nend\n\
    </code>\nThe above code will work on any data structure, and if your list contains\
    \ nil, the method will return nil. \nIn case you are curious why this works:\n\
    <code>\n[1, 2, 3, 4, 5].min #=> 1\n[5, 1, 4, 3, 2].min #=> 1\nnil.min #=> nil\n\
    [1, 1].min #=> nil\n</code>\n<|/ a dscore=5 tags=ruby,null,ruby-on-rails |>\n\
    <| c |>\n`[2,1].min.nil?` returns `nil`. [Array#min](http://www.ruby-doc.org/core-2.1.2/Array.html#method-i-min)\
    \ returns the minimum element of the array. nil doesn't have a minimum element,\
    \ so calling it on it returns nil, which is why `nil.min` returns nil.\n<|/ c\
    \ |>\n<| a tags=ruby,null,ruby-on-rails |>\n<code>", "  smallest_idx = 0\n  smallest_val\
    \ = lst[0]\n  lst.each do |elem|\n    smallest_idx += 1\n    if smallest_val <=\
    \ elem\n      smallest_idx = smallest_idx\n      smallest_val = elem\n    end\n\
    \  end\n  return lst[smallest_idx]\nend", "    smallest_value = lst[0]\n    if\
    \ lst.count == 1\n        smallest_value = lst[0]\n    el = lst.shift\n    smallest_el\
    \ = el\n    while el.nil?\n        el = lst.shift\n    el = lst.shift\n    while\
    \ el.nil?\n        el = lst.shift\n    while smallest_value < el\n        smallest_el\
    \ = el\n        el = lst.shift\n        while el.nil?\n            el = lst.shift\n\
    \        end\n    end\n    smallest_el\nend", "  if lst.empty?\n    nil\n  else\n\
    \    lst.delete_at(1)\n    lst.min if lst.size > 1\n  end\nend", "    if lst.nil?\n\
    \        return None\n    smallest = lst[0]\n    index = lst.index(smallest)\n\
    \    lst.delete_at(index)\n    if lst.empty?\n        return smallest\n    smallest\
    \ = next_smallest(lst)\n    \nend\n</cell>\n<cell>\nnext_smallest([2, 3, 4, 1])\n\
    </cell>\n<cell>\nnext_smallest([5, 1, 4, 3, 2])\n</cell>\n<cell>\nnext_smallest([-1,\
    \ 5, 2, 4, 3])\n</cell>\n<cell>\nnext_smallest([3, 2, 3])\n</cell>\n<cell>\nnext_smallest([3,\
    \ 2, 1])\n</cell>\n<text>\nRe-write a function to return a string representation\
    \ of the largest integer less than or equal to n.", "    smallest = lst[0]\n \
    \   smallest_value = smallest\n    secondsmallest = smallest\n    second_smallest_value\
    \ = secondsmallest\n    for x in lst\n        if x < smallest\n            smallest\
    \ = x\n            smallest_value = x\n        if x < secondsmallest\n       \
    \     secondsmallest = x\n            second_smallest_value = x\n    return smallest_value\
    \ if secondsmallest != smallest_value else None\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nPlease provide some explanation to your answer.\n<|/ c |>\n<| a dscore=0\
    \ tags=python |>\nHere's a solution using a heap that is O(log n).\n<code>\nimport\
    \ heapq", "  sorted_lst = lst.sort\n  if sorted_lst.size == 0\n    return nil\n\
    \  smallest_val = sorted_lst[0]\n  second_smallest_val = smallest_val\n  for i\
    \ in 1..(sorted_lst.size - 1)\n    if sorted_lst[i] < smallest_val\n      smallest_val\
    \ = sorted_lst[i]\n    elsif sorted_lst[i] > smallest_val\n      second_smallest_val\
    \ = smallest_val\n      smallest_val = sorted_lst[i]\n    else\n      break\n\
    \  end\n  if smallest_val == second_smallest_val\n    return nil\n  end\n  smallest_val\n\
    end", "  smallest_idx = nil\n  smallest_val = nil", "  return lst.sort.first(2).last.nil?\
    \ ? nil : lst[lst.length - 1]\nend", "  return lst.min if lst.is_a? Array else\
    \ lst.sort_by {|x| x}.first\nend", "  return nil if lst.empty?\n  smallest = lst[0]\n\
    \  lst.shift\n  smallest = lst.first if smallest.nil?\n  lst.shift\n  return smallest\
    \ if lst.empty? || smallest > smallest\n  next_smallest(lst)\nend\n</code>\nI\
    \ haven't tested it yet, but I think it should work. I'll edit this post with\
    \ any errors that arise.\n<|/ a tags=ruby,sorting,arrays dscore=1 |>\n<| c |>\n\
    Nice solution, but you shouldn't call `next_smallest` recursively, it makes the\
    \ algorithm exponential in time and you get `ArgumentError: wrong number of arguments\
    \ (0 for 1)` when the list is empty. Also, `next_smallest([1, 2, 3, 4, 5])` returns\
    \ `1` instead of `2` because the list is already sorted in ascending order.\n\
    <|/ c |>\n<| c |>\nOh I didn't think about that. I thought they wanted the smallest\
    \ element in the array to be returned. I will edit my solution to reflect that.\
    \ I was just writing the function at the moment, just so I could write out the\
    \ solution. I'll fix my code right now.\n<|/ c |>\n<| c |>\nI have edited my solution\
    \ and tested it on my computer. It is working correctly now. Thanks for the help!\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have two consecutive values that are\
    \ the same. The solution I suggested above works for this case.\n<|/ c |>\n<|\
    \ c |>\nYes you are right I didn't think about that case. I thought that there\
    \ were no repeated values in the list. If that is the case, then it would be easier\
    \ to just find the smallest number in the array and move all the elements to the\
    \ right, and remove the first element. I'll edit my solution and test it again\
    \ to handle that case.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    smallest = lst.sort.first\n\
    \    smallest_in_lst = lst.sort.first\n    smallest_in_lst.next\n    smallest_in_lst.next.next\n\
    end", "  lst.sort { |a, b| b <=> a }\n  lst[0]\nend", "  smallest, second = smallest_element(lst),\
    \ lst[1]\n  if smallest.nil?\n    second\n  else\n    if second.nil?\n      smallest\n\
    \    else\n      smallest < second ? smallest : second\n    end\n  end\nend\n\
    </code>\nNext, write a function next_smallest_all() to take in an array, and return\
    \ the 2nd smallest elements of each of the array.\n<code>", "    minimum, i =lst.min\n\
    \    until minimum == lst[i]\n    minimum, i =lst.min\n    return lst[i]\nend",
  "    smallest = nil\n    smallest_index = 0\n    \n    if lst.empty?\n        return\n\
    \    end", "  \n  lst.each_with_index do |e,i|\n    return e if i == 0 || e <\
    \ lst[i-1]\n  end\n  \n  nil\nend\n</code>\n<|/ a |>\n<| c |>\nThis is not the\
    \ expected output. The question is \"Write a function that returns the 2nd smallest\
    \ element of the given list.\"\n<|/ c |>\n<| c |>\nIt doesn't matter that it's\
    \ not the expected output.  I've been trying to explain what is meant and how\
    \ you arrived at it.  You clearly haven't read the question very carefully, but\
    \ you seem to be reading it as \"return the 2nd smallest element of the list\"\
    \ which is certainly what the code does.\n<|/ c |>\n<| c |>\nNo, OP specifically\
    \ mentioned \"Write a function that returns the 2nd smallest element of the given\
    \ list.\"\n<|/ c |>\n<| c |>\n, The code he posted does that.  But OP specifically\
    \ said \"Write a function that returns the 2nd smallest element of the given list.\"\
    \  Your code does that.  I agree that the question is not clear, but I think the\
    \ OP didn't understand that your code is what he wanted.\n<|/ c |>\n<| c |>\n\
    I disagree that the OP didn't understand this. He states clearly in the comment\
    \ above his code which line does exactly that. If OP understood the question would\
    \ he have provided him with clear answers instead of saying that the question\
    \ is bad?\n<|/ c |>\n<| a dscore=2 tags=ruby |>\n<code>", "    smallest = lst.min\n\
    \    i = lst.index(smallest)\n    lst.delete(i)\n    smallest = lst.min\n    return\
    \ smallest\nend", "  l = lst.clone\n  l.sort\n  l.reverse!\n  return l.shift if\
    \ l.empty? else None\nend", "  if lst.empty?\n    nil\n  else\n    first = lst[0]\n\
    \    last = lst[-1]\n    if first <= last\n      lst.shift\n      lst.shift\n\
    \      lst.shift\n      lst[0]\n    end\n  end\nend", "  if lst.size < 2\n   \
    \ return nil\n  elsif lst.size == 1\n    return lst[0]\n  end\n  \n  smallest\
    \ = nil\n  smallest_count = 0\n  \n  lst.each do |n|\n    if smallest_count >\
    \ 0\n      if n < smallest\n        smallest_count = 0\n        smallest = nil\n\
    \      end\n    elsif n < smallest\n      smallest_count = 1\n      smallest =\
    \ n\n    end\n    \n    smallest_count += 1\n  end\n  \n  return smallest\nend",
  "  lst.sort\n  lst[1..-2].min\nend", "  # Solution below\n  sorted_list = lst.sort\n\
    \  if sorted_list.size == 0 then return nil\n  return sorted_list[sorted_list.size\
    \ - 2]\nend\n</cell>\n<code language=julia-1.0>\nnext_smallest([5, 1, 4, 3, 2])\n\
    </cell>\n<code language=julia-1.0>", "    i = 2\n    while i < lst.length and\
    \ lst[i] < lst[i-1]\n        i = i + 1\n    return i if i < lst.length else None\n\
    end", "  return lst[1] if (lst.length > 1) else nil\nend", "  smallest = nil\n\
    \  smallest_index = nil\n  lst.each_with_index do |item, index|\n    if item.next\
    \ < smallest\n      smallest = item\n      smallest_index = index\n    end\n \
    \ end\n  smallest_index.nil? ? nil : smallest\nend", "  min_key = nil\n  min_value\
    \ = nil\n  min_key = nil\n  min_value = nil\n  min_key = nil\n  min_value = nil\n\
    \  for i in 0..(lst.length - 1)\n    if lst[i] < min_value then\n      min_value\
    \ = lst[i]\n      min_key = i\n    end\n  end\n  if min_value == nil then\n  \
    \  return nil\n  end\n  new_min = lst[min_key]\n  new_max = lst[(min_key + 1)]\n\
    \  if new_min > new_max then\n    new_min = new_max\n  end\n  return new_min\n\
    end", "    minimum = lst[0]\n    i = 0\n    while i < lst.size do\n        if\
    \ lst[i] < minimum then\n            minimum = lst[i]\n        end\n        i\
    \ += 1\n    end\n    if minimum == nil then return nil end\n    minimum2 = minimum\n\
    \    while i < lst.size do\n        if minimum > lst[i] then\n            minimum2\
    \ = lst[i]\n        end\n        i += 1\n    end\n    return minimum2\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis code does not work if the list is empty. It will crash\
    \ at minimum = lst[i] when the list is empty.\n<|/ c |>\n<| c |>\nSorry I was\
    \ busy trying to fix the original code. I've revised my answer to correct the\
    \ bug when list is empty.\n<|/ c |>\n<| c |>\nThis is a more efficient version\
    \ of the original code.\n<|/ c |>\n<| a tags=list,ruby dscore=3 |>\nAnother solution,\
    \ using Enumerable#min\n<code>\n[1, 2, 3, 4].min.next\n=> 2\n</code>\nIf there\
    \ are no items left, min.next will just return nil.\n<code>\n[4, 3, 2, 1].min.next\n\
    => nil\n</code>\n<|/ a |>\n<| a |>\nFor me, the best way to find the next smallest\
    \ or next largest value is to find the difference between the current value and\
    \ the previous value, then sort by the difference and return the next item from\
    \ the sorted list.  In pseudo-code this looks like this:\n<code>", "    min, max\
    \ = lst[0], lst[0]\n    l.each_with_index do |i, i|\n        if i < max\n    \
    \        return i\n        elsif i == max\n            max = i\n        end\n\
    \    end\n    next\nend", "    smallest = lst[0]\n    smallest_index = -1\n  \
    \  smallest_index = 1\n    second_smallest = lst[1]\n    second_smallest_index\
    \ = -1\n    second_smallest_index = 0\n    i = 0\n    while(i < lst.size - 1)\n\
    \        if (lst[i] < smallest)\n            smallest_index = i\n            smallest\
    \ = lst[i]\n        i += 1\n    i += 1\n    while(i < lst.size)\n        if (lst[i]\
    \ < second_smallest and lst[i] > smallest)\n            second_smallest_index\
    \ = i\n            second_smallest = lst[i]\n        i += 1\n    if (second_smallest_index\
    \ == -1)\n        return smallest\n    return second_smallest\n</code>\n<|/ a\
    \ |>\n<| a dscore=0 tags=algorithm,ruby,sorting,arrays |>\nThis code works well\
    \ for the above problem and I guess that there might be some ways that could improve\
    \ the performance. I tried to minimize the lines of code, by using each_with_index\
    \ instead of each. But still it is very slow and still the code is still not very\
    \ elegant.\n<code>", "  smallest = nil\n  smallest_index = 0", "  lst.sort!\n\
    \  index = 1\n  n = lst.index(0, index)\n  while index < n\n    index += 1\n \
    \ end\n  if index == n\n    puts \"There is no next smallest element\"\n    return\
    \ nil\n  end\n  index = index + 1\n  n = lst.index(0, index)\n  while index <\
    \ n\n    if lst.index(index, n) > index\n      n = lst.index(index, n)\n    else\n\
    \      n += 1\n    end\n  end\n  next_smallest = lst[n]\n  return next_smallest\n\
    end", "  result = nil\n  arr.each do |e|\n    if result < e\n      result = e\n\
    \    end\n  end\n  result\nend", "  smallest = lst[0]\n  smallest_count = 0\n\
    \  for i in 0..(lst.size - 2)\n    if smallest_count > lst.size\n      smallest\
    \ = nil\n      break\n    if smallest > lst[i]\n      smallest = lst[i]\n    \
    \  smallest_count += 1\n    smallest\n  end\nend", "    smallest = lst[0]\n  \
    \  second_smallest = lst[1]\n    if lst.size == 1\n        second_smallest\n \
    \   else\n        smallest = lst[1]\n    end\nend", "  smallest = nil\n  lst.each\
    \ do |i|\n    if i.to_i < smallest.to_i\n      smallest = i\n    end\n  end\n\
    \  return smallest unless smallest.nil?\nend", "    minimum = nil\n    minimum\
    \ = lst[0] if lst.is_a? Array\n    minimum = lst.min if lst.is_a? Enumerable\n\
    \    minimum = lst.find { |x| x < minimum }\n    minimum = minimum if minimum.nil?\n\
    \    minimum\nend", "    return lst.sort { |a, b| a.to_i < b.to_i ? -1 : a < b\
    \ ? 1 : a > b ? -1 : a }[2] if lst\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    I like it. I was writing an answer myself but I decided to use the fact that `[]`\
    \ is the last element of any array as my base case. This also makes it easier\
    \ to read and less repetitive.\n<|/ c |>\n<| c |>\nThanks for the comment!  I\
    \ will remember that one from now on!\n<|/ c |>\n<| a |>\n<code>", "    smallest\
    \ = lst[0]\n    second_smallest = nil\n    smallest_index = nil\n    \n    smallest_index\
    \ =\n        smallest_index =\n        smallest_index =\n    \n    smallest_index\
    \ =\n        smallest_index =\n        smallest_index =\n    \n    smallest_index\
    \ =\n        smallest_index =\n        smallest_index =\n    \n    smallest_index\
    \ =\n        smallest_index =\n        smallest_index =\n    \n    if smallest_index\
    \ == nil\n        second_smallest = nil\n    else\n        second_smallest = \n\
    \        second_smallest = \n        second_smallest = \n    \n    return second_smallest\n\
    end", '  smallest, smallest_index = find_smallest(lst)', '  smallest, next_smallest,
    min_idx, max_idx = 0, 1, -1, -1', "    if lst.nil? then\n        return nil\n\
    \    end\n    return lst[1] if lst.size > 2\n    lst[0] = nil\n    return lst[0]\n\
    end", "  smallest = nil\n  smallest_count = 0\n  \n  smallest = lst[0]\n  smallest_count\
    \ = 1\n  \n  lst.each_with_index do |el, i|\n    if el < smallest\n      smallest\
    \ = el\n      smallest_count = i\n    end\n  end\n  \n  if smallest_count != 0\n\
    \    lst[smallest_count]\n  else\n    nil\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a dscore=0 |>\nAnother approach to find the second smallest element in\
    \ an array:\n<code>", "  return lst.min() if (lst.size > 1) && lst.min() < lst.min.next\
    \ else None\nend", "  lst.each do |x|\n    if x.next > x\n      return x\n   \
    \ end\n  end\nend", "  return lst.sort! && lst.pop.first || nil\nend", "  sorted\
    \ = lst.sort\n  sorted[1]\nend", "  lst.sort\n  lst.shift if lst.size > 2\n  lst\n\
    end", "  smallest, large, smallest_index, large_index = 0, 0, 0\n  large_index\
    \ = lst.size - 1\n  while smallest != large_index\n    smallest, large, smallest_index,\
    \ large_index = small(lst)\n  end\n  smallest\nend", "  lst.sort { |a, b| b<=>a\
    \ }\n  lst[1]\nend\n</code>\n<|/ a tags=ruby,sorting |>\n<| c |>\nWhat if `next_smallest`\
    \ is called more than once?\n<|/ c |>\n<| a tags=ruby,sorting |>\n<code>", " \
    \ return lst.sort.first\nend", "    sorted = lst.sort\n    if sorted.first ==\
    \ sorted.last\n        sorted.shift\n        sorted.first\n    sorted.each_with_index\
    \ do |element, index|\n        if index == sorted.first\n            return element\n\
    \        end\n        if element < sorted.second\n            return element\n\
    \        end\n    end\n    return sorted.first\nend", "  if lst.empty?\n    next\n\
    \  end", "    smallest_index = lst.index(lst.min) \n    if smallest_index == 0\
    \ then \n        return nil\n    \n    smallest_index += 1", "    arr = Array.new()\n\
    \    arr.push(*lst)\n    arr.sort!\n    return arr.shift if arr.size > 0\nend",
  '  smallest = nil', "  sorted = lst.sort\n  return sorted[1] if (sorted.length>1)\
    \ else nil\nend", "  min_value = lst[0]\n  index = 1\n  while index < lst.length\n\
    \    min_value = lst[index] if lst[index] < min_value else min_value\n    index\
    \ += 1\n  end\n  return min_value\nend", "  smallest = nil\n  smallest_val = nil\n\
    \  lst.each do |x|\n    if x.nil? || x.is_a? Numeric\n      smallest = x\n   \
    \   smallest_val = x\n      next\n    end\n    if smallest == nil\n      smallest_val\
    \ = x\n      smallest = x\n    else\n      if x.to_i < smallest.to_i\n       \
    \ smallest_val = x\n        smallest = x\n      end\n    end\n  end\n  smallest\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you so much for this. It really helped\
    \ me solve the problem using recursion which I originally tried to avoid.\n<|/\
    \ c |>\n<| c |>\n`next_smallest` is definitely more efficient than `min_or_max`\
    \ but as you can see it's much more obscure.  `min_or_max` is an actual method\
    \ of the Array class, and it does a lot of work to avoid going through all the\
    \ elements of the array when there is only one element left.\n<|/ c |>\n<| c |>\n\
    I definitely see what you're saying here. That's not what I was trying to achieve,\
    \ but I certainly appreciate that you showed how it could be done with the method\
    \ in the question. I'll definitely look into it some more.\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby,recursion |>\nTo find max or min recursively, the easiest way is to\
    \ pass a comparator function as parameter to each call. \nThe comparator function\
    \ is responsible for telling if the current value is the min/max and what to return.\n\
    A simple example (without error checking):\n<code>", "  lst.sort\n  lst[1].nil?\
    \ ? nil : lst[1]\nend", "  smallest = nil\n  smallest_index = nil\n  for i in\
    \ 0..(lst.length-1)\n    if lst[i] < smallest\n      smallest = lst[i]\n     \
    \ smallest_index = i\n    end\n  end\n  if smallest_index\n    return lst[smallest_index+1]\n\
    \  end\n  return smallest\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=ruby,arrays\
    \ |>\nYou can do it this way:\n<code>\narr = [1,2,3,4,5]", "  # Your code here\n\
    \  \nend\n</cell>\n<cell>\n%load solutions/13.py\n</cell>\n<text>\nExercise 3\n\
    Write a function that returns the length of the smallest subarray of a list of\
    \ integers.", "    return lst.sort[1] if lst.sort and lst.sort.size >= 2 else\
    \ nil\nend", "    return lst.sort.last\nend", "  return lst.sort.take_while {\
    \ |x| x < lst.first }.first\nend", "  smallest = nil\n  smallest = lst[0] if lst.size\
    \ > 0\n  lst.each {|x| smallest = x if x < smallest }\n  return smallest\nend",
  "  if lst.size == 0\n    return nil\n  lst[0] = lst[0] + 1\n  \n  if lst[0] < list[0]\n\
    \    lst[0] = list[0] + 1\n  end\n  \n  if lst.size == 1\n    return list[0]\n\
    \  end\nend", "  if lst.empty?\n    nil\n  else\n    sorted = lst.sort\n    sorted.first.succ\n\
    \  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
