name: HumanEval_68_pluck
language: rb
prompt: "# \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
  \ plucked node should be the node with the smallest even value.\n# If multiple nodes\
  \ with the same smallest even value are found return the node that has smallest\
  \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
  \ index ],\n# If there are no even values or the given array is empty, return [].\n\
  # Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output:\
  \ [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\
  \ \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0,\
  \ 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are\
  \ two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
  # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
  \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
  \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
  \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n\
  \    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
  \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
  \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
completions: ["    return nil if arr.length==0\n    arr.each_with_index.inject([])\
    \ { |result, (el, i), j|\n        if el.even? \n            result.push([el, i])\n\
    \        elsif result.reject { |a| a[0]==el }.empty? \n            result.push([el,\
    \ i])\n        end\n        if j == arr.length-1\n            if result.length>1\n\
    \                result.sort! {|x, y| x[0]<=>y[0]}\n                result.pop\n\
    \            end\n        end\n        result\n    }\nend", "  return arr.sort.last\n\
    end", "  even = 1\n  biggest_value = arr.max\n  smallest_value = arr.min\n  smallest_index\
    \ = arr.index(biggest_value)\n  while arr.include? biggest_value\n    biggest_value\
    \ = arr.max\n    smallest_value = arr.min\n    smallest_index = arr.index(biggest_value)\n\
    \  end\n  puts biggest_value\n  puts smallest_value\n  puts smallest_index\n \
    \ return [ biggest_value, smallest_index ]\nend", "  arr = arr.sort\n  index =\
    \ 1\n  minval = arr[1]\n  min = arr[0]\n  while arr[index] < minval\n    arr[index]\
    \ = arr[index] + arr[index + 1]\n    index += 1\n  end\n  index = 0\n  while index\
    \ < arr.length\n    if arr[index] == minval\n      minval += 1\n      if minval\
    \ > arr[index + 1]\n        minval -= 1\n        min_index = index\n      end\n\
    \      index += 1\n      break\n    end\n    index += 1\n  end\n  return [minval,\
    \ min_index]\nend", "  arr.sort_by {|n| n % 2}.first\nend\n</cell>\n<cell>", " \
    \   even = arr.group_by {|x| x % 2 == 0}\n    even = even.sort_by{|k, v| v.count}.reverse\n\
    \    even = even.first\n    return even.last if even\n    return []\nend\n</cell>\n\
    <code language=julia-1.0>", "    even_value = []\n    index = -1", "\tsmallest_value\
    \ = arr.shift\n\tsmallest_index = -1\n\ti = 0\n\twhile i < arr.length\n\t\tif\
    \ arr[i] % 2 == 0\n\t\t\tvalue = arr[i]\n\t\t\tif smallest_value < value\n\t\t\
    \t\tsmallest_value = value\n\t\t\t\tsmallest_index = i\n\t\t\tend\n\t\tend\n\t\
    \ti += 1\n\tend\n\tarr << smallest_value\n\treturn [smallest_value, smallest_index]\n\
    end", "  arr.sort.each_with_index {|e,i|\n    if e%2 == 0\n      return e\n  \
    \  end\n  }\n  return []\nend", "  arr = arr.sort{|a, b| a <=> b} # sort array\
    \ in ascending order\n  arr.each_with_index do |val, i|\n    puts \"#{val} #{i+1}\"\
    \ if i % 2 == 0 # if index is odd, pick up the node\n  end\n  arr.take(arr.size\
    \ / 2).min # find the min in even index\nend", "  even = arr.find_all { |x| x\
    \ % 2 == 0 }\n  even.sort.map { |x| [ x, even.index ] }.first\nend\n</cell>\n\
    <cell>", "  evens = arr.select { |e| e % 2 == 0 }\n  if evens.empty? or evens.uniq.sort\
    \ == evens\n    evens.first\n  else\n    evens.uniq.sort.first\n  end\nend", " \
    \ even_index = []\n  even_min = 0\n  arr.each do |i|\n    if i % 2 == 0\n    \
    \  if even_min == 0\n        even_min = i\n      elsif even_min > i\n        even_min\
    \ = i\n      end\n    end\n  end", "    smallest_value = nil\n    smallest_index\
    \ = nil\n    even_values = nil\n    arr.each_with_index do |node, index|\n   \
    \     if even_values\n            if node.value < smallest_value\n           \
    \     smallest_value = node.value\n                smallest_index = index\n  \
    \          else\n                if node.value == smallest_value && node.index\
    \ == smallest_index\n                    smallest_value = node.value\n       \
    \             smallest_index = index\n                end\n            end\n \
    \       end\n        if node.value % 2 == 0\n            even_values << node.value\n\
    \        end\n    end\n    return smallest_value, smallest_index\nend", "  min\
    \ = nil\n  arr.each do |val|\n    if val % 2 == 0 && val < min || (val % 2 ==\
    \ 0 && val == min)\n      min = val\n    end\n  end\n  if min\n    [min, arr.index(min)]\n\
    \  else\n    []\n  end\nend", "  # Your code here\n  return [] if arr.empty? or\
    \ arr.uniq.size == 1 \n  arr.group_by {|v| v.odd? }.min_by {|_, v| v}.last\nend",
  "  even = arr.each_with_object(Hash.new(0)){|node,hash| hash[node]+=1 }\n  even\
    \ = even.sort.first(2) { |a,b| a[1] <=> b[1] }\n  return even unless even.nil?\
    \ || even.size < 2\n  even.first\nend", "  arr.sort!\n  if arr.empty?\n    []\n\
    \  else\n    puts arr.last\n    puts arr.index\nend\npluck([4, 2, 3])\npluck([1,2,3])\n\
    pluck([])\npluck([5, 0, 3, 0, 4, 2])\npluck([-6, -5, -4, -3, -2, -1]) # returns\
    \ [-6, -4, -3, -2, -1]\npluck([-6, -5, -4, -3, -2, -1, 0]) # returns [-6, -4,\
    \ -3, -2, -1, 0]", "    even = arr.select { |x| x % 2 == 0 }\n    smalest_value\
    \ = even.min\n    smalest_idx = even.index(smalest_value)\n    return if smalest_value\
    \ == 0\n    return smalest_value, smalest_idx\nend\n    ", "    arr.sort!\n  \
    \  if arr.empty? then return [] end\n    arr[0]\n    arr.delete_at(0)\n    arr.each\
    \ do |v|\n        if v.odd? and arr.count > 0\n            arr[0] = v\n      \
    \      arr.delete_at(0)\n        end\n    end\n    if arr.count > 0 then pluck(arr)\
    \ end\nend\nprint pluck([4,2,3])\nprint pluck([1,2,3])\nprint pluck([])\nprint\
    \ pluck([5, 0, 3, 0, 4, 2])", "  arr.sort {|a,b| a <=> b} #sort by value, ascending\n\
    \  evens = []\n  odds = []\n  index = -1\n  arr.each_with_index do |node, index|\n\
    \    if node % 2 == 0\n      evens << [node, index]\n    else\n      odds << [node,\
    \ index]\n    end\n  end\n  evens = evens.sort.take(2) if evens.length>0\n  odds\
    \ = odds.sort.take(2) if odds.length>0\n  return evens if evens.length>0 && evens[0][0]%2==0\n\
    \  return odds if odds.length>0 && odds[0][0]%2!=0\n  return [] if arr.length==0\n\
    end", "  arr.sort!\n  even = arr.index { |i| i.even? }\n  if even.nil?\n    []\n\
    \  elsif even == 1\n    even.last\n  elsif even == 2\n    even.min\n  else\n \
    \   even.min\n    even.min\n  end\nend", "    arr.sort.each {|a| a <=> 0 }\n \
    \   arr.each {|a| if a <=> 0 }\n    arr.each {|a| a.index }\n    arr\nend\n</cell>\n\
    <cell>\nassert pluck([4,2,3]) == [2, 1]\nassert pluck([1,2,3]) == [2, 1]\nassert\
    \ pluck([]) == []\nassert pluck([5, 0]) == [0, 1]\n</cell>\n<text>\n9. Bedtime\n\
    You are given a string S of lowercase letters, punctuation, space or dash characters.\n\
    We are asked to determine the length of the longest substring without spaces,\
    \ dashes or punctuations.\nA substring is a contiguous sequence of characters\
    \ within a string with the same character repeated. It may have different length.",
  " \n  even_values = []\n  min_index = nil\n  smallest_value = nil\n  \n  arr.each\
    \ do |v|\n    if v.to_i % 2 == 0\n      even_values.push(v)\n    else\n      if\
    \ min_index == nil\n        min_index = v\n      elsif smallest_value == nil\n\
    \        smallest_value = v\n      elsif v < smallest_value\n        min_index\
    \ = v\n        smallest_value = v\n      end\n    end\n  end\n  \n  return even_values,\
    \ min_index\nend", "  return arr.sort.first\nend", "  return [] if arr.empty?\n\
    \  evens = arr.select {|x| x % 2 == 0}\n  even = evens.min_by{|x| x}\n  [even,\
    \ evens.index(even)]\nend", "\treturn nil if arr.nil?\n\teven = []\n\todd = 0\n\
    \t\n\tarr.each do |a|\n\t\todd = odd + 1 if a&1 != 0\n\tend\n\t\n\teven << odd\
    \ if odd.zero?\n\t\n\tarr.each do |a|\n\t\tif a&1 == 0\n\t\t\teven.push(a) \n\t\
    \tend\n\tend\n\treturn even.index{|a| a.zero? }\nend", "  even = arr.select {|e|\
    \ e % 2 == 0}\n  if even.size == 0\n    puts []\n    return\n  end\n  even.sort.each_with_index\
    \ { |v, i| puts [v, i] }\nend\n</code>\n<|/ a |>\n<| c |>\nI understand what it\
    \ is saying, but I am not allowed to use the sort function.\n<|/ c |>\n<| c |>\n\
    That was my point :) It can be done, but it will be inefficient. You will have\
    \ to iterate each element twice. Let me see if I can come up with a better solution\
    \ for you\n<|/ c |>\n<| c |>\nI added a possible solution\n<|/ c |>\n<| a tags=ruby\
    \ |>\nHere's a solution using Enumerable#min_by:\n<code>", "  arr.each_with_index\
    \ do |val, i|\n    if val%2 == 0\n      return [val, i]\n    end\n  end\n  return\
    \ []\nend", "  arr.sort\n  arr.find {|e| e % 2 == 0} # first node is smallest\
    \ even number\nend", "  return arr.reduce(:&)\nend", "  arr.sort! #Sort the array\
    \ in ascending order\n  even = arr.select{|x| x % 2 == 0} #Create a new array\
    \ containing all the even values.\n  even.sort! #Sort the even array in ascending\
    \ order\n  even.map!{|x| x+1}  #Increment each value in the even array by one\
    \ to ensure that the index is in order.\n  even.each_index{|x| arr[x] = arr[even[x]-1]\
    \ if even[x]-1 >= 0}\n  even.shift! #Remove the first value from the even array,\
    \ since we always pick the smallest value.\n  even.shift #Remove the first value\
    \ from the even array, since we always pick the smallest value.\n  if even.empty?\
    \ #If there are no even values, return an empty list\n    []\n  elsif even.size\
    \ == 1 #If the even array only has one value, return it.\n    [even.first]\n \
    \ else #If the even array has multiple values, return the smallest value and its\
    \ index\n    even.each{|x| [x, even.index(x)] if x >= 0 && x <= even.length}\n\
    end", "    arr.sort!\n    even = arr.select {|x| x % 2 == 0}\n    odd = arr.select\
    \ {|x| x % 2 == 1}\n    if even.empty?\n        return []\n    if odd.empty?\n\
    \        return even.first\n    smalest_value = even.first\n    smallest_index\
    \ = even.index(smalest_value)\n    smalest_value = odd.first\n    smallest_index\
    \ = odd.index(smalest_value)\n    if smallest_index == 0\n        return even\n\
    \    smallest_value = even[smallest_index]\n    smallest_index = 0\n    even.each\
    \ do |x|\n        if x == smallest_value\n            smallest_index += 1\n  \
    \      else\n            break\n        end\n    end\n    odd.each do |x|\n  \
    \      if x == smallest_value\n            smallest_index += 1\n        else\n\
    \            break\n        end\n    end\n    if smallest_index == 0\n       \
    \ return []\n    end\n    return [smallest_value, smallest_index]\nend\n</cell>\n\
    <cell>\narr = [4, 2, 3]\nresult = pluck(arr)\narr\nresult\n</cell>\n<cell>", " \
    \ arr.each do |item|\n    even = item % 2 == 0\n    if even\n      smallest_index\
    \ = item.index(item)\n      smallest_value = item[smallest_index]\n    elsif smallest_value.nil?\
    \ || smallest_value > item\n      smallest_value = item\n    end\n  end\n  smallest_value\n\
    end", "  arr.sort\n  even = arr.select {|e| e % 2 == 0}\n  even = even.min\n \
    \ arr.delete_at(0)\n  even\nend", "    sorted = arr.reduce(:<=>)\n    sorted.uniq.empty?\
    \ ? [] : [sorted.min.first, sorted.min.find_index { |x| x.even? }].uniq\nend",
  "  min_value = arr.min\n  arr.each do |x|\n    if x.even?\n      return [min_value,\
    \ x]\n    elsif x == min_value\n      return [x, arr.index(x)]\n    end\n  end\n\
    \  raise \"No even value found for pluck\"\nend", "  \n  # Create a hash with\
    \ value as the key for both even and odd values.\n  hash = {}\n  arr.each do |num|\n\
    \    if num % 2 == 0\n      hash[num] = num\n    elsif num % 2 != 0\n      hash[num]\
    \ = num\n    end\n  end", "  min_even_value_index = arr.index(arr.min_by{|x| x.even?}.last.value)\n\
    \  [arr.min_by{|x| x.even?}.last.value, min_even_value_index]\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nHmm, this is a really interesting solution but I'm\
    \ having trouble understanding how it works. I understand how the min by works,\
    \ but don't understand how the min by works with the even? function. I understand\
    \ it returns the minimum value but don't get how the min by works, or the .last\
    \ part and how it all fits together. I also don't understand how it returns the\
    \ even? function part. Could you elaborate on how it all works? I really appreciate\
    \ the response, but if you could please do so, I would really appreciate it.\n\
    <|/ c |>\n<| c |>\nI think I've figured out how it works. I'm just going to have\
    \ to add some comments to my code to make it more clear.\n<|/ c |>\n<| c |>\n\
    I added some comments.\n<|/ c |>\n<| c |>\nThis works, however, it fails if you\
    \ have a duplicate minimum value in a row - for example if you have [1,4,4,3,2,1],\
    \ it returns [4, 3]\n<|/ c |>\n<| a tags=ruby,algorithm,ruby-on-rails |>\nI would've\
    \ posted this as a comment on Ruakh's answer but I don't have enough reputation\
    \ points.\nIf your array is sorted then the following should work:\n<code>", "\t\
    raise \"Not implemented yet\"\nend\n</cell>\n<code language=julia-1.5>\nfunction\
    \ test_pluck()\n\tarr = [4,2,3]\n\tsol = pluck(arr)\n\t@test sol == [2, 1]\n\t\
    arr = [1,2,3]\n\tsol = pluck(arr)\n\t@test sol == [2, 1]\n\tarr = []\n\tsol =\
    \ pluck(arr)\n\t@test sol == []\n\tarr = [5, 0, 3, 0, 4, 2]\n\tsol = pluck(arr)\n\
    \t@test sol == [0, 1]\nend\n</cell>\n<text>\n421. Minimum Path Sum\nGiven a binary\
    \ tree and a sum, find two numbers d, s which minimizes sum \u2211 nodes v \u2208\
    \ subtree of tree such that (v + d) = sum.", "    even = []\n    even = arr.delete_if\
    \ {|x| x.even?}\n    even.sort {|a, b| b.to_i <=> a.to_i}.first\n    return even\n\
    end\n</cell>\n<code language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code language=julia-1.3>\n\
    arr = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code\
    \ language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr\
    \ = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code\
    \ language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr\
    \ = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code\
    \ language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr\
    \ = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code\
    \ language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr\
    \ = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code\
    \ language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr\
    \ = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code\
    \ language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr\
    \ = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code\
    \ language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr\
    \ = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code\
    \ language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr\
    \ = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code\
    \ language=julia-1.3>\narr = [2,3,3]\n</cell>\n<code language=julia-1.3>\narr\
    \ = [2,3,3]\n</cell>\n<code language=", "  if arr.empty?\n    return []\n  index\
    \ = 0\n  arr.each do |val|\n    arr[index] % 2 == 0 ? val : index.next\n  end\n\
    end", "  min = arr[0]\n  min_index = arr[0]\n  arr.delete_at(0)\n  arr.each_index\
    \ { |i| if arr[i].even? && (arr[i].value < min)\n    min = arr[i].value\n    min_index\
    \ = i\n  end}\n  arr\nend", "  arr.sort!\n  even.each do |val|\n    if arr.include?(val)\n\
    \      arr.delete(val)\n      arr.delete(val)\n    end\n  end\n  arr.empty? ?\
    \ [] : [ arr.min, arr.index(arr.min) ]\nend\n</code>\n<|/ a tags=arrays,ruby |>\n\
    <| a tags=arrays,ruby dscore=0 |>\nThis solution is O(n) where n is the number\
    \ of elements in the array.\n<code>", "  max_value, index = 0, 1\n  arr.each do\
    \ |node|\n    if node < max_value && node.even?\n      index = index + 1\n   \
    \   max_value = node\n    end\n  end\n  return [ max_value, index ]\nend", " \
    \   sorted = arr.sort\n    even = sorted.select { |x| x&1 == 0 }\n    even.empty?\
    \ ? nil : even.first\nend", "  min = Array.new\n  arr.each_with_index do |v, i|\n\
    \    if v & 1 == 0\n      min = [v, i]\n    end\n  end\n  min\nend", "    even\
    \ = arr.select { |e| e%2 == 0 }\n    return even.min_by(&:even).first if even.any?\n\
    \    return even.min_by(&:even).last if even.any?\n    return even.min_by(&:even).reverse.first\
    \ if even.any?\n    return even.min_by(&:even).reverse.last if even.any?\n   \
    \ return even.min_by(&:even).reverse.index {|e| e%2 == 0 } if even.any?\n    return\
    \ even.min_by(&:even).reverse.index {|e| e%2 == 0 } if even.any?\n    return even.min_by(&:even).reverse.index\
    \ {|e| e%2 == 0 } if even.any?\n    return even.min_by(&:even).reverse.index {|e|\
    \ e%2 == 0 } if even.any?\n    return even.min_by(&:even).reverse.index {|e| e%2\
    \ == 0 } if even.any?\n    return even.min_by(&:even).reverse.index {|e| e%2 ==\
    \ 0 } if even.any?\n    return even.min_by(&:even).reverse.index {|e| e%2 == 0\
    \ } if even.any?\n    return even.min_by(&:even).reverse.index {|e| e%2 == 0 }\
    \ if even.any?\n    return even.min_by(&:even).reverse.index {|e| e%2 == 0 } if\
    \ even.any?\n    return even.min_by(&:even).reverse.index {|e| e%2 == 0 } if even.any?\n\
    \    return even.min_by(&:even).reverse.index {|e| e%2 == 0 } if even.any?\n \
    \   return even.min_by(&:even).reverse.index {|e| e%2 == 0 } if even.any?\n  \
    \  return even.min_by(&:even).reverse.index {|e| e%2 == 0 } if even.any?\n   \
    \ return even.min_by(&:even).reverse.index {|e| e%2 == 0 } if even.any?\n    return\
    \ even.min_by(&:even).reverse.index {|e| e%2 == 0 } if even.any?\n    return even.min_by(&:even).reverse.index\
    \ {|e| e%2 == 0 } if even.", "    even = arr.select { |x| x % 2 == 0 }.sort {\
    \ |a,b| a.to_i <=> b.to_i }\n    return [ even.first, even.index ] if even.length\
    \ > 0\n    return []\nend", "    arr.uniq.compact.sort.each_with_index { |item,\
    \ index| arr << item if arr.count(item) > 1 }.flatten\nend", "    evens = arr.select\
    \ { |x| x % 2 == 0 }\n    evens.reduce(:min).to_a\nend", "  # Write your code\
    \ here.\n  even = arr.select {|e| e.odd?}.sort\n  even.empty? ? [] : [even.first,\
    \ even.index + 1]\nend", "    even = arr.group_by{|x| x % 2 == 0}\n    return\
    \ even.min_by{|k, v| k}[1].first\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThis\
    \ is my solution\n<code>", "\tarr.sort\n\tindex = arr.index { |x| x.even? }\n\t\
    arr.delete(index)\n\tarr.first\nend", "\treturn [] if arr.empty?\n\tarr.uniq!\n\
    \tarr.sort!", "  arr.sort!\n  arr.each do |value|\n    break if value == 0\n \
    \   break if value == arr.min && value % 2 == 0\n  end\n  arr.index {|x| x < value\
    \ % 2}\nend", "  sorted = arr.sort_by { |x| x.to_i }\n  even = sorted.slice_when\
    \ { |a,b| a.even? && b.even? }\n  even.last\nend", "    arr.sort { |x, y| y <=>\
    \ x }\n    arr.map do |x|\n        if x % 2 == 0\n            x \n        else\n\
    \            arr.index(x)\n        end\n    end\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis is an extremely elegant solution, but it's not very efficient at all\
    \ - sorting the entire array just to find the index of the minimum element, when\
    \ you can find it directly from the array. One can save a lot of time by iterating\
    \ over the array only once and looking it up in a separate variable.\n<|/ c |>\n\
    <| c |>\nYou're right, I didn't think of this case. I edited my answer to include\
    \ a version which does this better.\n<|/ c |>\n<| a tags=arrays,ruby dscore=3\
    \ |>\nHere's a fairly straight-forward way of doing this:\n<code>", "    arr.sort!\
    \ # sort the array by the value\n    pick = []\n    pick.push([arr[0].value, 0])\n\
    \    pick.each do |v|\n        if v[1].even?\n            pick.push([v[0].value,\
    \ v[1].value])\n        end\n    end\n    return pick.uniq.sort\nend", "  \n \
    \ # find all even numbers\n  even = arr.select{|el| el % 2 == 0}\n  \n  # sort\
    \ \n  even.sort!\n  \n  # return the first one\n  if even.empty?\n    return []\n\
    \  end\n  \n  even.shift\n  \n  # return the index\n  [even.first, even.index(0)]\n\
    end", "\tarr.sort!\n\tarr.each_with_index do |val,i|\n\t\tarr[i] = arr.delete_at(arr.index{|x|\
    \ x.even?})\n\tend\n\treturn arr if arr.length == 1\n\tarr.delete_at(0)\n\tarr.sort!\n\
    \tarr.each_with_index do |val,i|\n\t\tarr[i] = arr.delete_at(arr.index{|x| x.even?})\n\
    \tend\n\treturn arr if arr.length == 1\n\treturn nil\nend", "  arr.sort!\n  arr.each\
    \ do |x|\n    arr[arr.index(x)] = x\n  end\n  arr.each_with_index do |node, i|\n\
    \    arr[i] = (arr[i].even? ? arr[i].odd? ? arr[i] : i : node) \n  end\n  arr.delete_if\
    \ { |n| n.even? }\n  arr.delete_if { |n| n.odd? }\n  arr\nend\n</cell>\n<cell>",
  "    # Write your code here\n    arr.sort!\n    evens=0\n    total=0\n    arr.each\
    \ do |node|\n        if node%2==0\n            evens=evens+1\n            total+=node\n\
    \        end\n    end\n    if evens==0\n        arr=[]\n    elsif evens==arr.size\n\
    \        arr=[total,0]\n    else\n        arr.delete_at(arr.index(total))\n  \
    \      arr=[total,evens-1]\n    end\n    return arr\nend", "    arr.sort! # sort\
    \ the array in ascending order according to node.value\n    nodes = []\n    count\
    \ = 0\n    while count < arr.length\n      node = arr[count]\n      if node.value\
    \ == 0 # if the node value is 0 it is the smallest value\n        # so we store\
    \ the node index and its value\n        nodes << [ node.value, node.index ]\n\
    \      else \n        count += 1 # if the node value is not 0 then count +1 \n\
    \    end\n    return nodes[nodes.length-1]\nend", "  even_index = []\n  i = 0\n\
    \  while i < arr.length\n    if arr[i] % 2 == 0\n      even_index << i\n     \
    \ i += 1\n    else\n      i += 1\n    end\n  end\n  even_index\nend\n</cell>\n\
    <cell>", "  evens = arr.select { |x| x.even? }\n  if evens.empty?\n    []\n  else\n\
    \    min_index = evens.min_by { |e| e.value }\n    evens.select { |e| e.value\
    \ == min_index.value }.first\n  end\nend", "  sorted_arr = arr.sort\n  even_index\
    \ = sorted_arr.find { |x| x.even? }\n  even_index ||= sorted_arr.first\n  even_index\n\
    end", "  arr.sort!\n  arr.uniq!\n  even = arr.map { |e| e % 2 == 0 }.compact\n\
    \  if even.empty?\n    return []\n  else\n    even.first\n  end\nend", "\tevens\
    \ = arr.select { |n| n % 2 == 0 }\n\teven = evens.min { |a,b| a.to_s <=> b.to_s\
    \ }\n\tevens.delete(even)\n\tindex = evens.index(even)\n\treturn [even, index]\n\
    end", "\tarr.reject!{ |x| x % 2 == 0 }\n\treturn [arr.min_by(&:even_index).first,\
    \ arr.min_by(&:even_index).last]\nend", "    arr.sort!\n    even_idx = arr.find_index(&:even?)\n\
    \    if even_idx\n        smalest_value = arr[even_idx]\n        index = even_idx\n\
    \    else\n        smalest_value = arr[0]\n        index = 0\n    end\n    arr.slice!(0...index)\n\
    \    arr.delete(even_idx)\n    arr\nend", "    # write your code here\n    arr.each\
    \ do |i|\n        if i % 2 == 0 and i < arr.length/2\n            return [i, arr.index(i)]\
    \ if arr.include?(i)\n        end\n    end\nend\n</cell>\n<cell>", "  arr.sort!\n\
    \  arr.each_with_index { |value, index| value = value if value % 2 == 0 }\n  if\
    \ arr.size == 1\n    [arr[0][0], arr[0]]\n  elsif arr.size == 2\n    [arr[0][0],\
    \ arr[1]]\n  elsif arr.size == 3\n    [arr[0][0], arr[2]]\n  elsif arr.size ==\
    \ 4\n    [arr[0][0], arr[3]]\n  else\n    arr.each_with_index { |value, index|\
    \ value = value if value % 2 == 0 }\n    smallest_even_index = nil\n    smallest_even_value\
    \ = nil\n    arr.each_with_index { |value, index| value = value if value % 2 ==\
    \ 0 }\n    smallest_even_index = arr.index{ |value, index| value = value if value\
    \ % 2 == 0 }\n    smallest_even_value = arr[smallest_even_index]\n    if smallest_even_value\
    \ % 2 == 0\n      [smallest_even_value, smallest_even_index]\n    else\n     \
    \ arr.each_with_index { |value, index| value = value if index % 2 == 0 }\n   \
    \   smallest_even_index = arr.index{ |value, index| value = value if index % 2\
    \ == 0 }\n      smallest_even_value = arr[smallest_even_index]\n      if smallest_even_value\
    \ % 2 == 0\n        [smallest_even_value, smallest_even_index]\n      else\n \
    \       arr.each_with_index { |value, index| value = value if index % 2 != 0 }\n\
    \        smallest_even_index = arr.index{ |value, index| value = value if index\
    \ % 2 != 0 }\n        smallest_even_value = arr[smallest_even_index]\n       \
    \ if smallest_even_value % 2 != 0\n          [smallest_even_value, smallest_even_index]\n\
    \        else\n          []\n        end\n      end\n    end\n  end\nend\n</code>\n\
    <|/ a dscore=0 tags=arrays,algorithm,ruby |>\n<| a dscore=0 tags=arrays,algorithm,ruby\
    \ |>\nI think you can do it in O(n) by iterating over the array and finding the\
    \ indexes of the two even-valued elements. Then find the index of that even-valued\
    \ element and return the difference between their indexes. For example,\n<code>\n\
    arr = [1,2,3]", "  even_values = arr.select {|e| e % 2 == 0}\n  if even_values.empty?\n\
    \    return []\n  else\n    smallest = even_values.min_by{|e| e}\n    index =\
    \ even_values.index(smallest)\n    return [smallest, index]\n  end\nend", "  arr.sort!\n\
    \  arr.map! {|i| i.odd? ? i.next.next : i.even? ? i.next : i}\n  arr.group_by{|i|\
    \ i.even?}.min_by{|i,v| v}[1].last\nend", "  return arr.sort { |x, y| x.even?\
    \ ? y - x : x.even? ? x - y : x - y.even? ? x.abs - y : -x.abs - y }\nend", " \
    \ arr.each_with_index do |val, index|\n    return index if val % 2 == 0\n  end\n\
    \  []\nend", "    node = nil\n    i = 0\n    n = arr.size", "    even_value =\
    \ []\n    i = 0\n    arr.each do |e|\n        if e % 2 == 0\n            even_value.push(e)\n\
    \        else\n            i = i + 1\n        end\n    end\n    even_value.each_with_index\
    \ do |e, i|\n        arr[i] = e\n    end\n    even_value.sort!\n    even_value.each\
    \ do |e|\n        if e % 2 != 0\n            arr.delete_at(arr.index(e))\n   \
    \     end\n    end\n    return arr\nend\n</cell>\n<cell>", "    arr.sort.sort\n\
    \    even_values = arr.select {|x| x%2 == 0 }\n    even_values.uniq.sort\n   \
    \ even_values.min\nend", "  evens = arr.select {|x| x % 2 == 0}\n  if evens.empty?\n\
    \    return []\n  min = evens.min_by{|e| e}\n  index = 0\n  i = 0\n  while i <\
    \ evens.size do\n    e = evens[i]\n    if e == min\n      return [min, index]\n\
    \    index += 1\n    i += 1\n  end\n  return [min, index]\nend", "  evens = arr.select\
    \ {|e| e%2 == 0}\n  arr.select {|e| e%2 == 0 and arr.index(e) < evens.index(e)\
    \ || arr.index(e) == evens.index(e) }\nend\nputs pluck([4,2,3]) # => [2, 1]\n\
    puts pluck([1,2,3]) # => [2, 1]\nputs pluck([]) # => []\nputs pluck([5, 0, 3,\
    \ 0, 4, 2]) # => [0, 1]\n<|/ file |>\n<| a dscore=0 |>\nRuby is an interpreted\
    \ language. Your program is compiled to bytecode (for instance .class files on\
    \ the disk) by your ruby interpreter. Thus, your program is \"interpreted\" only\
    \ once.\nSo, your program is interpreted only once. You can run it many times\
    \ by different interpreters or even multiple interpreters in parallel. Once again,\
    \ you cannot know when the program will stop.\nRuby interpreter can do some optimizations\
    \ regarding your program. For example, when interpreter compiles your program\
    \ it can optimize some parts of it to save CPU (if possible) time. That's because\
    \ Ruby is using interpreter to interpret your program and to execute it. So if\
    \ you have a Ruby program that does not make much use of interpreter, it might\
    \ compile it to some bytecode that is much faster to interpret (though it still\
    \ has some use).\nThe fact that you do not know when the program will stop depends\
    \ on your Ruby interpreter, some Ruby interpreters will run your program for X\
    \ minutes, some other Ruby interpreters will run it for X hours, or some Ruby\
    \ interpreters will run it forever. On the other hand, some Ruby interpreters\
    \ will allow you to run your program for N hours or N days.\nYou can easily see\
    \ that ruby interpreter optimizes your program and saves CPU (if possible) time.\
    \ If you run your program many times with different Ruby interpreters, you will\
    \ see that the CPU (and memory) used by your program will reduce as much as possible\
    \ as many times as you run it by different interpreters.\nThe only way to do that\
    \ is to run your program many times with different Ruby interpreters. And it can\
    \ be very hard to find an interpreter that will run your program many times and\
    \ still be easy to find an interpreter that will run it for N hours.\n<|/ a tags=ruby\
    \ |>\n<| c |>\nI ran a similar program using JRuby interpreter. It ran for 3 minutes\
    \ and returned the correct result for my input. Is this expected behavior?\n<|/\
    \ c |>\n<| c |>\nAs I said, your program is ", "  arr.sort!\n  evens = arr.select\
    \ { |x| x % 2 == 0 }\n  if evens.empty?\n    return []\n  else\n    return evens.sort.first(2).first\n\
    \  end\nend", "  arr.sort do |a,b|\n    a <=> b\n  end\n  return arr[1] if arr[0].even?\n\
    \  arr\nend", "  arr.uniq.map!{|x| x % 2 == 0 ? x : (x.next)}\n  arr.uniq.sort_by{|x|\
    \ x}\n  puts arr.inspect\nend\n</cell>\n<cell>\npluck([1,2,3])\n</cell>\n<cell>\n\
    pluck([4,2,3])\n</cell>\n<cell>\npluck([1,3,2])\n</cell>\n<cell>\npluck([2,2])\n\
    </cell>\n<cell>\npluck([2,1,1])\n</cell>\n<cell>\npluck([2,2,2])\n</cell>\n<cell>\n\
    pluck([2,1,2,3])\n</cell>\n<cell>\npluck([0,0])\n</cell>\n<cell>\npluck([0,1,0])\n\
    </cell>\n<cell>\npluck([1,1,1,1])\n</cell>\n<cell>\npluck([2,2,2,2])\n</cell>\n\
    <cell>\npluck([2,2,3,3,3])\n</cell>\n<cell>\npluck([2,2,3,3,3,3])\n</cell>\n<cell>\n\
    pluck([2,2,3,3,3,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,",
  "  puts arr\n  smallest = nil\n  smallest_index = nil\n  arr.each_with_index do\
    \ |item, index|\n    if item != 0 \n      if smallest == nil\n        smallest\
    \ = item\n        smallest_index = index\n      elsif item < smallest\n      \
    \  smallest = item\n        smallest_index = index\n      end\n    end\n  end\n\
    \  return [ smallest, smallest_index ]\nend\n</code>\n<|/ a tags=ruby,sorting,algorithm\
    \ |>\n<| a |>\n<code>\na = [3, 0, 1, 2]\nb = a.select {|v| v % 2 == 0}\n => [0,\
    \ 2] \nc = b.map {|v| a[v]}\n => [0, 3] \nd = c.sort {|a,b| a <=> b}\n => [0,\
    \ 1, 2] \n</code>\n<|/ a dscore=0 tags=ruby,sorting,algorithm |>\n<| c |>\nYour\
    \ code doesn't work when there are duplicate entries in the array\n<|/ c |>\n\
    <| c |>\nNo, the code works with duplicate entries. If you add an `puts b` to\
    \ your code, you will see that it returns `[0, 3, 2]`\n<|/ c |>\n<| a tags=ruby,sorting,algorithm\
    \ dscore=0 |>\n<code>\narr = [3, 0, 1, 2]\narr.select { |x| x % 2 == 0 }.sort.reverse_each.map\
    \ { |x| arr.index(x) + 1 }", "  even = arr.select {|x| x % 2 == 0}\n  even.min_by\
    \ {|x| x}\nend", "  if arr.empty?\n    []\n  else\n    smalest_value = arr[0]\n\
    \    smallest_index = 0\n    arr.shift\n    arr.each_with_index do |value, index|\n\
    \      if value % 2 == 0\n        smallest_index = index\n      elsif index >\
    \ 0 && value < arr[smallest_index]\n        smallest_index = index\n      end\n\
    \    end\n    [smalest_value, smallest_index]\n  end\nend", "  # sort is O(n log\
    \ n), and we use O(n) to find an even value\n  # first find the smallest even\
    \ value \n  smalest_value = arr[0]\n  smalest_index = 0\n  for i in arr\n    if\
    \ i % 2 == 0\n      smalest_value = i\n      smalest_index = arr.index(i)\n  \
    \    break\n  # now we find the even value\n  even_values = []\n  for i in arr\n\
    \    if i % 2 == 0\n      even_values << i\n  # now we find the smallest index\n\
    \  min_index = even_values.index(min([i for i in even_values if i % 2 == 0]))\n\
    \  \n  # now we pluck one by one to get the smallest value\n  result = smalest_value\n\
    \  while min_index != 0\n    result = [smalest_value, min_index]\n    min_index\
    \ = even_values.index(min([i for i in even_values if i % 2 == 0]))\n  end\n  return\
    \ result\nend", "  a = arr.sort.each_with_index.select{|x,i| x.even?}.first\n\
    \  a && a[1]\nend", "  arr.each_with_index.map{|x| [x, (arr - [x].min).first]}.to_h\n\
    end", "  odd_nodes = []\n  smalest_value = 0\n  smallest_index = -1\n  arr.each\
    \ do |x|\n    if x.is_a?(Integer) && x % 2 != 0\n      if smallest_index == -1\
    \ || x < smalest_value\n        smalest_value = x\n        smallest_index = arr.index(x)\n\
    \      end\n      odd_nodes << x\n    end\n  end\n  return odd_nodes if odd_nodes.length\
    \ == arr.length\n  return [smallest_value, smallest_index] if smallest_index >=\
    \ 0\n  return []\nend\n</cell>\n<code language=conda-root-py>\n%timeit pluck(arr)\n\
    </cell>\n<code language=conda-root-py>", "    # Your code here\n    return arr.sort.reverse\
    \ if arr.length > 0 else []\nend", "    arr.sort\n    i = 0\n    odd = false\n\
    \    num = arr.size\n    while num > 0\n        if arr[i] % 2 == 0\n         \
    \   odd? false : true\n            num -= 1\n        else\n            odd? true\
    \ : false\n            i += 1\n    end\n    i = 0\n    even = false\n    num =\
    \ arr.size\n    while num > 0\n        if arr[i] % 2 == 0\n            even? false\
    \ : true\n            num -= 1\n        else\n            even? true : false\n\
    \            i += 1\n    end\n    i = 0\n    odd = false\n    num = arr.size\n\
    \    while num > 0\n        if arr[i] % 2 != 0\n            odd? false : true\n\
    \            num -= 1\n        else\n            odd? true : false\n         \
    \   i += 1\n    end\n    i = 0\n    even = false\n    num = arr.size\n    while\
    \ num > 0\n        if arr[i] % 2 == 0\n            even? false : true\n      \
    \      num -= 1\n        else\n            even? true : false\n            i +=\
    \ 1\n    end\n    if even\n        return arr[i].downcase\n    else\n        return\
    \ arr[i].downcase\n    end\nend", "  smallest_value = arr[0]\n  smallest_index\
    \ = 0\n  smallest_even_found = false\n  arr.each do |i|\n    if i % 2 == 0 and\
    \ !smallest_even_found\n      smallest_even_found = true\n      smallest_value\
    \ = i\n      smallest_index = i\n    end\n  end\n  smallest_even_found ? [ smallest_even_found,\
    \ smallest_index ] : []\nend", "  # Initialize minVal to a large value to avoid\
    \ overflows.\n  minVal = arr.inject{|a,b| a > b ? a : b }\n  \n  # Set up a map\
    \ to hold the minimum even value and its index.\n  evenIndexes = arr.each_index.group_by{|i|\
    \ arr[i]}.\n    map{|k, v| [k, v.min_by{|i| i[1]}]}\n    \n  # Pick a node (pick\
    \ one that is even and has a minimum index).\n  evenNodes = evenIndexes.keys\n\
    \  evenNodes.delete_if{|node| node.length > minVal}\n  evenNodes.delete_if{|node|\
    \ node[0].even? }\n  \n  # If there are even nodes with same minimum even value,\
    \ pick the smallest node index.\n  if evenNodes.length > 1\n    evenNodes.each{|node|\
    \ evenNodes[node].delete_if{|index| index < minVal}}\n  \n    # If there are even\
    \ nodes with same minimum even value, pick the smallest node index with smallest\
    \ value.\n    evenNodes.each{|node| evenNodes[node].delete_if{|index| index.even?\
    \ || index > minVal}}\n  end\n  \n  # If the array is empty, return an empty list.\n\
    \  evenNodes.empty? ? [] : evenNodes[evenNodes.keys.min]\nend", "  arr.sort {\
    \ |a, b| a <=> b }\n  if arr.length == 0 || arr.all? { |x| x.even? }\n    return\
    \ []\n  else\n    arr.each_with_index { |x, i| puts \"#{x} #{i}\" }\n  end\nend\n\
    </cell>\n<cell>\narr = [4, 2, 3]\npluck(arr)\n</cell>\n<cell>\narr = [1, 2, 3]\n\
    pluck(arr)\n</cell>\n<cell>\narr = []\npluck(arr)\n</cell>\n<cell>\narr = [5,\
    \ 0, 3, 0, 4, 2]\npluck(arr)\n</cell>\n<text>\nGiven an array representing a binary\
    \ tree, return an array containing its levels in breadth first order. If two nodes\
    \ happen to be at the same level, then the order should be according to the value\
    \ of their element in the original tree. Return an empty array if two nodes are\
    \ at the same level.\nExample\nGiven binary tree [1,null,2,null,3,null,4,null,5,null,6]\
    \ \n   1\n      \\\n       2\n      /\n     3\n   4\n      \\\n       5\n    \
    \  \\\n         6\nOutput: [1,3,5,6]", "    arr.sort!\n    arr.each_with_index\
    \ { |value, index| return value if value % 2 == 0 && value != 0 && index == 0\
    \ }\nend", end, "  arr.sort\n  even = arr.select{|n| n % 2 == 0}\n  if even.empty?\n\
    \    []\n  else\n    even.min_index{|n| [n, arr.index(n)]}\n  end\nend", "   \
    \ # Your code here\n    arr.sort!\n    return arr.index { |n| n.even? } if arr.present?\n\
    end", "  # get the index of the first node with the smallest even value\n  index,\
    \ smallest_value = arr.index(arr.min), arr.min\n  # find the smallest even value\
    \ node index\n  while smallest_value%2 == 0 and index < arr.length\n    smallest_value\
    \ = arr[index]+1\n    index += 1\n  \n  # return the smallest even value node,\
    \ and its index\n  return smallest_value, index\nend", "  smallest = 0\n  smallest_index\
    \ = nil\n  index = 1\n  for i in arr\n    smallest = i\n    smallest_index = i\n\
    \    index += 1\n  end\n  [smallest, smallest_index]\nend\n\"\"\"\nGiven an array\
    \ representing a branch of a tree that has non-negative integer nodes\nyour task\
    \ is to pluck one of the nodes and return it.\nThe plucked node should be the\
    \ node with the smallest even value.\nIf multiple nodes with the same smallest\
    \ even value are found return the node that has smallest index.\nThe plucked node\
    \ should be returned in a list, [ smalest_value, its index ],\nIf there are no\
    \ even values or the given array is empty, return [].\nExample 1:\nInput: [4,2,3]\n\
    Output: [2, 1]\nExplanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\nExample 2:\nInput: [1,2,3]\nOutput: [2, 1]\nExplanation: 2 has the smallest\
    \ even value, and 2 has the smallest index. \nExample 3:\nInput: []\nOutput: []\n\
    Example 4:\nInput: [5, 0, 3, 0, 4, 2]\nOutput: [0, 1]\nExplanation: 0 is the smallest\
    \ value, but  there are two zeros,\nso we will choose the first zero, which has\
    \ the smallest index.\nConstraints:\n* 1 <= nodes.length <= 10000\n* 0 <= node.value\n\
    \"\"\"", "  min = nil\n  index = nil\n  arr.each_index do |i|\n    if arr[i].even?\
    \ && arr[i].odd? && arr[i] < min\n      min = arr[i]\n      index = i\n    end\n\
    \  end\n  if min == 0\n    return [min, index]\n  elsif arr.empty?\n    return\
    \ []\n  end\n  arr[0..index-1].each_index do |i|\n    if arr[i].even? && arr[i].odd?\n\
    \      min = min\n      index = i\n    end\n  end\n  [min, index]\nend\n</cell>\n\
    <cell>\narr = [4, 2, 3, 1, 5, 0]\n</cell>\n<cell>\npluck(arr)\n</cell>\n<cell>",
  "    arr.each do |node|\n        smallest_value = node\n        smallest_index =\
    \ -1\n        arr.each_with_index do |val,index|\n            if val == smallest_value\n\
    \                if smallest_index == -1 || val < smallest_value\n           \
    \         smallest_value = val\n                    smallest_index = index\n \
    \               end\n            end\n        end\n        if smallest_index !=\
    \ -1\n            arr.pop(smallest_index)\n        end\n    end\n    arr\nend",
  "  arr.sort!\n  arr.each_with_index do |el, i|\n    next if i % 2 == 0 && el ==\
    \ 0\n    next unless el % 2 == 0\n    arr[i] = el\n  end\n  arr.each_with_index\
    \ do |el, i|\n    if el % 2 == 0\n      arr[i] = el\n    end\n  end\n  arr\nend",
  "\tindex = 1\n\tsmallest_even_value = 1\n\tsmallest_even_index = nil\n\tsmallest_value\
    \ = nil\n\tif arr.empty?\n\t\treturn []\n\tend", end, "    evens = arr.select\
    \ {|x| x % 2 == 0}\n    return evens.min_by { |x| x % 2 }.last if evens.length\
    \ > 0\n    return []\nend", "    evens = arr.select{|n| n % 2 == 0} \n    if evens.size\
    \ == 0\n        return []\n    even = evens.min\n    index = evens.index(even)\n\
    \    [ even, index ]\nend\n</cell>\n<code language=conda-env-Anaconda3-py>\narr\
    \ = [1,5,3,2,5,6,7,3,9]\n</cell>\n<code language=conda-env-Anaconda3-py>\npluck(arr)\n\
    </cell>\n<code language=conda-env-Anaconda3-py>", "  even = arr.select { |x| x.even?\
    \ }.sort\n  return even.first if even.size > 0 \n  return [] if arr.size <= 0\n\
    \  even = arr.select { |x| x.even? }.sort\n  even.find { |x| x.zero? }\nend",
  "  arr.each_with_index { |val, i| arr[i] = val.even? ? val : nil }.compact\nend",
  "    # initialize result array\n    res = []\n    # iterate through nodes of array\n\
    \    arr.each do |node|\n        # check if node value is even\n        if node\
    \ % 2 == 0\n            # add node value to result array\n            res.push(node)\n\
    \        else\n            # remove node value from result array\n           \
    \ arr.delete(node)\n            # check if there are any remaining elements in\
    \ the array\n            if arr.any?\n                # set smallest value to\
    \ last node's value\n                smallest_value = arr.pop\n              \
    \  # iterate through remaining nodes\n                arr.each do |node|\n   \
    \                 # check if node value is even and less than current smallest\
    \ value\n                    if node % 2 == 0 \n                        # if yes\
    \ then add node value to result array\n                        res << node\n \
    \                       break if node < smallest_value\n                    #\
    \ if node value is even and greater than current smallest value \n           \
    \         elsif node % 2 != 0\n                        # set smallest value to\
    \ node's value\n                        smallest_value = node\n              \
    \  end\n            # if no remaining elements in the array then add smallest\
    \ value to result array\n            res[-1] << smallest_value\n        end\n\
    \    end\n    # return result array\n    return res\nend", "  # Write your code\
    \ here.\n  return arr", "  evens = []\n  odds = []\n  arr.each_index do |i|\n\
    \    if arr[i].even?\n      evens << i\n    else \n      odds << i\n    end\n\
    \  end\n  if evens.length > 0 \n    evens.sort!\n    evens.first\n  else\n   \
    \ odds.sort!\n    odds.first\n  end\n  arr.each_index do |i|\n    if arr[i] ==\
    \ evens.first\n      arr[i]\n    elsif arr[i] == odds.first\n      arr[i]\n  \
    \  else\n      nil\n    end\n  end\nend", "    evens = arr.select {|x| x.even?}\n\
    \    evens.each {|x| x.next}\n    evens.min_by {|x| x.even? ? x.next.value : x.value}[1]\n\
    end", "    even_values = arr.select { |x| x%2 == 0 }\n    even_values.sort.each\
    \ do |x|\n        puts x unless x.even?\n    end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=2 |>\n<| c |>\nThat's an interesting approach.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "    smallest_value = nil\n    smallest_index = 0\n    smallest_even_node_index\
    \ = nil\n    arr.each do |value|\n        if smallest_value.nil? or value % 2\
    \ == 0\n            smallest_value = value\n            smallest_index = 1\n \
    \           smallest_even_node_index = 1\n        else\n            if smallest_even_node_index\
    \ == nil\n                smallest_even_node_index = value\n            elsif\
    \ value < smallest_even_node_index\n                smallest_even_node_index =\
    \ value\n            end\n        end\n    end\n    if smallest_even_node_index\
    \ == nil\n        return nil\n    end\n    if smallest_value == nil\n        return\
    \ smallest_even_node_index\n    end\n    [smallest_value, smallest_even_node_index]\n\
    end", "  result=[]\n  arr.each do |el|\n    smallest_value=el\n    smallest_index=0\n\
    \    arr.each do |other_el|\n      if other_el==el\n        next\n      end\n\
    \      if other_el<el\n        smallest_value=other_el\n        smallest_index=other_el\n\
    \      end\n    end\n    if smallest_value%2==0\n      result<<smallest_value\n\
    \    end\n    if smallest_index\n      result<<[smallest_value,smallest_index]\n\
    \    end\n  end\n  return result\nend", "  # code here\n  \n  return []\nend",
  "  arr.sort_by {|x| x.even? }\n  arr.first[1..-1] if arr.size > 0\nend", "    even_values\
    \ = []\n    i = 0\n    while i < arr.length do\n        if arr[i]%2 == 0\n   \
    \         even_values << arr[i]\n        end\n        i+=1\n    end\n    even_values\
    \ = even_values.sort\n    even_values.each do |value|\n        minimum = 0\n \
    \       minimum_index = -1\n        i = 0\n        while i < even_values.length\n\
    \            if even_values[i] == value and i < even_values.length\n         \
    \       minimum = i\n                minimum_index = i\n            end\n    \
    \        i+=1\n        end\n        if minimum_index != -1\n            arr.delete_at\
    \ minimum_index\n        end\n    end\n    return arr\nend", "  # TODO: Write\
    \ your code here\n  return [] if arr.empty?\n  even_value = []\n  even_value_index\
    \ = -1\n  arr.each_with_index do |value, index|\n    if value % 2 == 0\n     \
    \ even_value[index] = value\n      even_value_index = index\n    end\n  end\n\
    \  if even_value_index < 0\n    even_value_index = 0\n  end\n  [even_value[even_value_index],\
    \ even_value_index]\nend", "  return arr.sort{|a, b|\n    a <=> b \n  }.first\n\
    end\n</cell>\n<code language=julia-0.6>", "  arr.sort!\n  arr.delete_if {|i| i.even?\
    \ }\n  arr.delete_if {|i| i == 0 }\n  arr.delete_if {|i| i == arr.first }\n  arr.delete_if\
    \ {|i| i == arr.last }\n  return arr\nend\n</cell>\n<code language=conda-env-Anaconda3-py>",
  "  sorted_arr = arr.sort\n  even_index = sorted_arr.index { |x| x.even? }\n  even_index\
    \ if even_index.even?\n  sorted_arr[even_index.zero? ? 0 : even_index]\nend",
  "  sorted = arr.sort\n  evens = sorted.each_with_index { |v,i| v % 2 == 0 && i ==\
    \ 0 || v }.to_a\n  even = evens.find { |e| e.nonzero? }.zero? ? 0 : 1\n  evens.map\
    \ {|e| [e, e.index+even, e.index+1+evens.index(e)]}\nend", "  arr.sort {|x,y|\
    \ x<=>y } \n  arr.each do |i| \n    break if i%2 == 0\n  end\n  return i\nend",
  "    evens = []\n    i = 0\n    while i < arr.length\n        even = arr[i]\n  \
    \      evens.push(even)\n        if even % 2 == 0 \n            i += 1\n     \
    \   end\n    end\n    evens.sort!\n    return evens.first if evens.length == 1\
    \ && evens[0] == 0\n    evens.each_index do |idx|\n        evens[idx] == evens[idx].succ\
    \ ? evens.delete_at(idx) : nil\n    end\n    return evens.first if evens.length\
    \ == 1 && evens[0] == 0\n    evens.each_index do |idx|\n        evens[idx] ==\
    \ evens[idx].succ ? evens.delete_at(idx) : nil\n    end\n    evens.first\nend\n\
    </cell>\n<cell>\narr = [4, 2, 3]\npluck(arr)\n</cell>\n<text>\nRuby's Array#min\n\
    Ruby's Array#min returns the minimum value in a given array, in O(1) time.", " \
    \ arr.sort!\n  picked_val = arr.pop\n  picked_idx = 0\n  \n  arr.each do |node|\n\
    \    return [] if node < picked_val\n    picked_val = node if node > picked_val\n\
    \    picked_idx += 1\n  end", "    # Your code here\n    if arr == []\n      \
    \  return arr\n    even_value = [arr[0]] \n    for i in range(1,arr.length)\n\
    \        if arr[i] % 2 != 0 and arr[i] not in even_value\n            even_value.insert(0,arr[i])\n\
    \        if even_value.count(even_value[0]) < even_value.count\n            return\
    \ even_value\n        even_value.pop(0)\n    even_value.pop(0)\n    \n    \n \
    \   ", "  return [] if arr.empty?\n  m = arr.min_by {|x| x.even?}\n  [m.value,\
    \ m.index] if m.even?\nend\n</cell>\n<code language=conda-root-py>\n%load solutions/pluck-2.rb\n\
    </cell>\n<text>\nPluck All Even Values", "  if arr.empty?\n    []\n  elsif arr.uniq.count\
    \ == 1\n    [ arr.uniq.first, arr.uniq.index ]\n  else\n    smalest_value = arr[0]\n\
    \    smalest_index = arr.index( smalest_value )\n    arr[ smalest_value ][ 0 ].even?\
    \ and arr.each_with_index {|value,index| next if value == smalest_value and index\
    \ != smalest_index }\n    pluck( arr[ smalest_value - 1 ] ) + [ smalest_value,\
    \ smalest_index ]\n  end\nend\n</code>\nTest\n<code>\narr = [4,2,3]\nputs pluck(arr)\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThe original question stated that it was\
    \ a homework question. Your answer is not helpful for that.\n<|/ c |>\n<| c |>\n\
    My comment was in the middle of a long write-up of my answer. Since I'm only allowed\
    \ to post a comment with 2 links and I have the reputation score of 50 I'll leave\
    \ it here.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "    arr = arr.sort\n    if\
    \ arr.empty? or arr.uniq.count == 1 \n        return []\n    arr.each_with_index\
    \ do |n, i|\n        if n % 2 == 0\n            return [n, i]\n        end\n \
    \   end\n    \nend", "    arr.uniq.sort\n    arr.uniq.sort.map{|x| x % 2 == 0\
    \ ? x : nil}.min.nil? ? [] : [arr.uniq.sort.map{|x| x % 2 == 0 ? x : nil}.min.nil?\
    \ ? [] : arr.uniq.sort.map{|x| x % 2 == 0 ? x : nil}.min, nil].flatten\nend",
  "    \n    even = []\n    evenIndex = -1\n    \n    i = 0\n    while i < arr.length\n\
    \        if arr[i] % 2 == 0\n            even.push arr[i]\n            evenIndex\
    \ = i\n            i += 1\n        else\n            i += 1\n    end", "\tmin_index\
    \ = arr.index(min(arr))\n\tmin = arr[0]\n\tfor i in 1..arr.length\n\t\tmin = arr[i]\n\
    \t\tif min % 2 == 0\n\t\t\tmin_index += 1\n\t\tend\n\t\tbreak unless arr[i] ==\
    \ min\n\tend\n\tplucked_value = arr[min_index]\n\tplucked_value\nend", "\tsmallest_value\
    \ = arr[0]\n\tsmallest_value = arr[0]\n\tsmallest_index = arr[0]\n\tfor i in range(1,arr.length)\n\
    \t\tsmallest_value = arr[i] if arr[i] < smallest_value else smallest_value\n\t\
    \tsmallest_index = smallest_value if arr[i] < smallest_index else smallest_index\n\
    \treturn [smallest_value, smallest_index]\n\tend\nend", "  arr.sort.with_index{\
    \ |e,i| e%2==0 && i<arr.size-1 && ( arr[i+1]==0 || i>0 ? arr[i-1]>arr[i] : arr[i-1]==0\
    \ )? [e,i] : [e,i+1] }\nend\n</cell>\n<cell>", "  result = nil\n  arr.each_with_index\
    \ do |e, i|\n    next if e.even?\n    return result if result && e.to_i == result.to_i\n\
    \    result = i if e.to_i == e.to_i + 1\n  end\n  result\nend", "  minimum = arr.min_by\
    \ {|x| x.even? ? 0 : x.to_i}\n  [minimum.value, minimum.index] if minimum.even?\n\
    end", "  evens = arr.select { |x| x % 2 == 0 }\n  evens.compact.sort.first\nend",
  "\tarr.sort!\n\tarr.each do |i| \n\t\twhile arr !=[i % 2] \n\t\t\tarr.shift\n\t\t\
    end\n\tend\n\tarr\nend", "    # Your code here\n    raise \"Falling through...\"\
    \nend", "\teven = even_indexes(arr)\n\treturn(even.first if even.any? else [])\n\
    \tend\nend", "  even = []\n  odd = []\n  i = 0\n  while i < arr.length\n    if\
    \ arr[i] % 2 != 0\n      odd << arr[i]\n    else\n      even << arr[i]\n    end\n\
    \    i += 1\n  end\n  even.uniq.sort { |x,y| x.to_i <=> y.to_i }\n  even.first\n\
    end", "  arr.sort.tap do |arr| \n    arr.find {|e| e % 2 == 0} \n  end\nend\n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\nSolution using recursion:\n<code>", "  smallest_value\
    \ = nil\n  smallest_index = nil\n  arr.each do |n|\n    if n % 2 == 0\n      if\
    \ smallest_value.nil? or n <= smallest_value\n        smallest_value = n\n   \
    \     smallest_index = n\n      end\n    else\n      return [n] if smallest_value.nil?\
    \ or n <= smallest_value\n    end\n  end\n  smallest_value\nend", "  arr.sort!\n\
    \  arr.find { |x| x % 2 == 0 } || arr.first\nend", "  arr_max = arr.max_by { |e|\
    \ e.to_i }\n  arr_min  = arr.min_by { |e| e.to_i }\n  arr_min_index = 0\n  arr_min_index\
    \ = arr.index(arr_min) if arr.index(arr_min).odd? && arr.index(arr_max).odd?\n\
    \  arr_min = arr_min[arr_min_index]\n  arr_max  = arr_max[arr_min_index]\n  arr_max.even?\
    \ ? [ arr_max, arr_min_index ] : nil\nend", "    arr.uniq!\n    arr.sort!\n  \
    \  if arr.size <= 0\n        return []\n    even, index = arr.first, 0\n    while\
    \ even.even?\n        index += 1\n        even = arr.find {|n| n.even? && n.value\
    \ < even.value}\n    end\n    return [index + 1, even.value - even.index] if even.even?\n\
    \    index += 1\n    return [index] + pluck(arr.drop(index))\nend", "  even_values\
    \ = arr.select { |i| i % 2 == 0 }.sort\n  even_values.first\nend", "  arr.each_with_index.group_by\
    \ { |n,i| n.even? }.min_by { |n,i| i }[1]\nend", "  arr = arr.sort\n  if arr.size\
    \ == 0 \n    return []\n  even = arr.find {|x| x.even?}\n  odd = arr.find {|x|\
    \ !x.even?}\n  if even\n    even.index\n  elsif odd\n    odd.index\n  else\n \
    \   arr.min\n  end\nend\n</cell>\n<cell>", "    arr.sort!\n    return arr.first\
    \ if arr.none? || arr.all?(&:odd?) \n    arr.uniq.sort_by(&:odd?).map(&:odd?).index(false)\
    \ \nend", "    even = []\n    low = arr.find { |n| n % 2 == 0 } || 0\n    even\
    \ = arr.select { |n| n % 2 == 0 }\n    even.each_with_index { |n, i| n.downcase\
    \ if n > low }.min { |n| n.to_i }\nend", "    even = arr.select {|x| x % 2 ==\
    \ 0}.map(&:to_i).uniq\n    even = even.first(even.size).last\n    index = arr.index\
    \ {|x| x == even}\n    arr.delete_at(index)\n    [even, index]\nend", "    return\
    \ [] if arr.empty? # return [] if arr.empty?\n    arr.sort!\n    arr.each_with_index\
    \ { |el, index| return [el, index] }\n    arr.each_with_index { |el, index| return\
    \ [el, index] if el.even? }\n    return nil\nend", "    even_index = arr.index(even_value)\
    \ \n    smallest_value = arr[even_index]\n    return smallest_value, even_index\
    \ if even_index >= 0\nend", "  arr.sort.with_index do |elem, index|\n    (index\
    \ / 2).zero? ? elem : elem[0...index]\n  end\nend", "  arr.sort!\n  arr.each_with_index\
    \ do |node, i|\n    next if node.even?\n    next if node.even? && i == 0\n   \
    \ break if node.even? && i == 1\n    arr[i] = node\n  end\n  return arr\nend",
  " \n    smallest_value = []\n    smallest_index = []\n    smallest_index = 0\n \
    \   smallest_value[0] = 0\n    smallest_index[0] = 0\n    \n    arr.each_index\
    \ do |i|\n        if arr[i] % 2 == 0\n            smallest_value[i] = arr[i]\n\
    \            smallest_index[i] = i\n        end\n    end\n    \n    smallest_value.each_index\
    \ do |i|\n        if smallest_value[i] == smallest_value[0] \n            smallest_index[i]\
    \ = smallest_index[0]\n        else\n            if smallest_value[i] < smallest_value[0]\n\
    \                smallest_value[i] = smallest_value[0]\n                smallest_index[i]\
    \ = smallest_index[0]\n            end\n        end\n    end\n    \n    smallest_value\n\
    end", "    return [] if arr.empty?\n    \n    arr.sort\n    min_val = arr.min\n\
    \    arr.delete_if do |i|\n        if i % 2 == 0 && i % 2 == min_val\n       \
    \     min_val = i\n        else\n            false\n        end\n    end\n   \
    \ [ min_val, arr.index(min_val) ]\nend\nputs pluck([]) # []\nputs pluck([5]) #\
    \ []\nputs pluck([5, 0]) # [0, 1]\nputs pluck([5, 0, 3]) # [0, 1]\nputs pluck([1,\
    \ 0, 4, 2]) # [1, 2]\nputs pluck([7, 11, 9, 11, 12, 13]) # [7, 8]\nputs pluck([2,\
    \ 10, 11, 6, 9, 10]) # [2, 0]\nputs pluck([4, 6, 4, 0, 2, 10]) # [2, 0]\nputs\
    \ pluck([0, 3, 8, 1, 4, 2, 6, 8, 3, 9, 0, 6, 4, 1, 4, 7, 4, 6, 3, 8, 2, 6, 8,\
    \ 3, 9, 0, 6, 4, 1, 4, 7, 4, 6, 3, 8, 2, 6, 8, 3, 9, 0, 6, 4, 1, 4, 7, 4, 6, 3,\
    \ 8, 2, 6, 8, 3, 9, 0, 6, 4, 1, 4, 7, 4, 6, 3, 8, 2, 6, 8, 3, 9, 0, 6, 4, 1, 4,\
    \ 7, 4, 6, 3, 8, 2, 6, 8, 3, 9, 0]) # [2, 1]", "\tarr.sort!\n\tpick = nil\n\t\
    i = 0\n\twhile i < arr.length\n\t\tpick = arr[i]\n\t\ti += 1\n\t\tif pick % 2\
    \ == 0\n\t\t\tbreak\n\tend\n\tarr.delete_at(i)\n\tpick\nend", "    even_values\
    \ = arr.select { |e| e % 2 == 0 }\n    even_values.sort_by! { |e| e }\n    even_values.last\n\
    end", "  min_val, min_i = arr.min{ |a,b| a <=> b }\n  arr.each_index.select {\
    \ |i| arr[i] < min_val && arr[i] % 2 == 0 }.min\nend\n</cell>\n<code language=julia-1.0>\n\
    function find_smallest_index(ns)\n    smallest_index, smallest_val = 0, ns[1]\n\
    \    for index in 2:length(ns)\n        val = ns[index]\n        if val < smallest_val\n\
    \            smallest_val, smallest_index = val, index\n        end\n    end\n\
    \    smallest_index\nend\n</cell>\n<code language=julia-1.0>\nfunction find_smallest_value(ns)\n\
    \    smallest_index, smallest_val = 0, ns[1]\n    for index in 2:length(ns)\n\
    \        val = ns[index]\n        if val < smallest_val\n            smallest_val,\
    \ smallest_index = val, index\n        end\n    end\n    smallest_val\nend\n</cell>\n\
    <code language=julia-1.0>\nfunction find_smallest_even_value(ns)\n    smallest_index,\
    \ smallest_val = 0, ns[1]\n    for index in 2:length(ns)\n        val = ns[index]\n\
    \        if val % 2 == 0 && val < smallest_val\n            smallest_val, smallest_index\
    \ = val, index\n        end\n    end\n    smallest_index\nend\n</cell>\n<code\
    \ language=julia-1.0>\nfunction find_smallest_index(ns)\n    smallest_index, smallest_val\
    \ = 0, ns[1]\n    \n    for index in 2:length(ns)\n        val = ns[index]\n \
    \       if val < smallest_val\n            smallest_val, smallest_index = val,\
    \ index\n        end\n    end\n    smallest_index\nend\n</cell>\n<code language=julia-1.0>\n\
    function find_smallest_value(ns)\n    smallest_index, smallest_val = 0, ns[1]\n\
    \    \n    for index in 2:length(ns)\n        val = ns[index]\n        if val\
    \ < smallest_val\n            smallest_val, smallest_index = val, index\n    \
    \    end\n    end\n    smallest_val\nend\n</cell>\n<code language=julia-1.0>\n\
    function find_smallest_even_value(ns)\n    smallest_index, smallest_val = 0, ns[1]\n\
    \    \n    for index in 2:length(ns)\n        val = ns[index]\n        if val\
    \ % 2 == 0 && val < smallest_val\n            smallest_val, smallest_index = val,\
    \ index\n        end\n    end\n    smallest_index\nend\n</cell>\n<code language=julia-1.0>\n\
    function smallest(nodes)\n    smallest_index, smallest_val = 0, nodes[1]\n   \
    \ for index in 2:length(nodes)\n        val = nodes[index]", "    arr.sort!\n\
    \    return arr.find{|x| x.even?}\nend", "  odd_values = arr.select { |n| n %\
    \ 2 == 1 }\n  even_values = arr.select { |n| n % 2 == 0 }\n  if even_values.empty?\
    \ || odd_values.empty?\n    []\n  else\n    smallest = even_values.sort { |a,\
    \ b| a.to_s <=> b.to_s }\n    [smallest.first, smallest.index(smallest.first)]\n\
    \  end\nend", "  even_values = arr.select{|x| x % 2 == 0}\n  even_values_hash\
    \ = even_values.group_by{|x| x}.map{|x,y| [x,y]}.to_h\n  min_even_value = even_values_hash.min_by{|x,y|\
    \ x}\n  min_even_value_hash = min_even_value.group_by{|x| x}.map{|x,y| [x,y]}.to_h\n\
    \  plucked_value = min_even_value_hash.values.first\n  if plucked_value.nil?\n\
    \    []\n  elsif plucked_value.size < arr.size\n    plucked_value\n  else\n  \
    \  plucked_value.map{|x| arr[x]}\n  end\nend", "  even = arr.select {|v| v % 2\
    \ == 0} #select all the even numbers\n  if even.empty?\n    return []\n  smallest_value_index\
    \ = even.min_by {|v| v} #get the index of the smallest even number in the array\n\
    \  smallest_value = even[smallest_value_index] #get value of the smallest even\
    \ number\n  smallest_value_index = smallest_value_index.to_i\n  if smallest_value_index\
    \ == 0\n    smallest_value_index = nil\n  end\n  return smallest_value, smallest_value_index\n\
    end", "    \n    sorted = arr.sort\n    \n    even = sorted.find { |x| x % 2 ==\
    \ 0 }\n    \n    return even, sorted.index(even)\nend", "    arr.sort!\n    if\
    \ arr.length == 0\n        arr = []\n    arr[0].even?\n    arr[0].even?\n    arr.sort!\
    \ { |a, b| b.even? <=> a.even? } \n    arr.sort! { |a, b| b.even? <=> a.even?\
    \ } \n    arr.first\nend", "  arr.each do |x|\n    if x.even?\n      smallest,\
    \ index = arr.min{|a, b| a.even? <=> b.even?}\n      smallest_value, smallest_index,\
    \ = smallest, index\n    end\n  end\n  return smallest_value, smallest_index\n\
    end", "    arr.each_index{|i|\n        arr[i] = arr[i] % 2 == 0 ? arr[i - 1] :\
    \ arr[i - 1] + 1\n    }\n    arr.sort.each {|i| arr[i] < 0 ? arr.pop : nil }\n\
    \    arr.empty? ? [] : arr\nend", "  arr.each_with_index do |v, i|\n    puts v\n\
    \    break if v % 2 == 0 && v != 0\n  end\nend", "  arr.group_by { |x| x % 2 ==\
    \ 0 }.sort_by { |key, val| val }.last\nend\n</cell>\n<code language=conda-root-py>\n\
    arr = [5, 0, 3, 0, 4, 2]\n</cell>\n<code language=conda-root-py>\npluck(arr)\n\
    </cell>\n<code language=conda-root-py>", "  arr = arr.sort\n  arr.each_with_index.find\
    \ { |val, i| val % 2 == 0 && i > 0 }\nend", "  arr.each_with_index do |n, index|\n\
    \    arr.delete_at(index)\n    puts \"#{n} #{index}\"\n  end \nend\n</code>\n\
    <|/ a |>\n<| c |>\nHi I wanted to try your code, but i got \"syntax error, unexpected\
    \ tLABEL, expecting kEND\" for the line 'puts \"#{n} #{index}\"' do you know why?\n\
    <|/ c |>\n<| a dscore=1 tags=ruby |>\nHere's my solution (it's probably not optimal,\
    \ but I think it's simple, understandable, easy to maintain, easy to read and\
    \ easy to understand):\n<code>\narray = [ 4, 2, 3 ]\narray.each_with_index.min\n\
    </code>\n<|/ a |>\n<| c |>\nThe OP wants both the node and the index in the resulting\
    \ array :P\n<|/ c |>\n<| c |>\n`array.each_with_index.min` returns only two values:\
    \ [2, 1]\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  return [] if arr.empty? else\
    \ arr.uniq.min_by(&:even?)\nend", "  even_index = []\n  arr_index = 0\n  odd_index\
    \ = []\n  arr.each_with_index do |node, index|\n    if index%2 == 0\n      even_index\
    \ << index\n    else\n      odd_index << index\n    end\n  end\n  even_index.sort!\n\
    \  odd_index.sort!\n  if even_index.length == 0 && odd_index.length == 0\n   \
    \ return []\n  end\n  index = even_index.length == 0 ? odd_index.length : even_index.length\n\
    \  even_index = even_index.length == 0 ? [] : even_index.first\n  odd_index =\
    \ odd_index.length == 0 ? [] : odd_index.first\n  if even_index.empty?\n    even_index.push(index)\n\
    \  end\n  if odd_index.empty?\n    odd_index.push(index)\n  end\n  if even_index.length\
    \ == 0\n    even_index.push(index)\n  end\n  if odd_index.length == 0\n    odd_index.push(index)\n\
    \  end\n  if even_index.length == 0 && odd_index.length == 0\n    return []\n\
    \  end\n  if even_index.length == 0 && odd_index.length == 0\n    return [arr_index]\n\
    \  end\n  if even_index.length == 0\n    even_index = even_index.first\n  end\n\
    \  if odd_index.length == 0\n    odd_index = odd_index.first\n  end\n  return\
    \ [arr[even_index], arr[odd_index]]\nend", "  even = arr.select {|n| n % 2 ==\
    \ 0}\n  if even.empty?\n    return []\n  else\n    smalest_value = even.min\n\
    \    return even.find_index { |n| n >= smalest_value }\n  end\nend", "  if arr.size\
    \ == 0 \n    puts []\n  elsif arr.size == 1\n    puts [ arr[0] ]\n  elsif arr.size\
    \ > 1\n    arr = arr.sort\n    puts [ arr[0], arr[arr.length-1] ]\n  end\nend\n\
    <|/ file filename=pick_the_node.py |>\n<| c |>\nA simple solution would be to\
    \ sort and then pick the middle element. This would be O(nlogn), but wouldn't\
    \ you rather find out the smallest value of the array? This would be O(n), and\
    \ it would make you even more efficient.\n<|/ c |>\n<| c |>\nI don't think so,\
    \ I want all even values of array to get selected and sorted and return the smallest\
    \ index.\n<|/ c |>\n<| c |>\nSo you're trying to find the first index of the smallest\
    \ number in the array?\n<|/ c |>\n<| a |>\n<code>", "  arr.sort.reverse!\n  arr.each_with_index{|n,\
    \ i| n.even? and arr.delete_at(i) if i > 0 }\n  arr.sort.reverse!\n  arr.each_index{|i|\
    \ arr[i] > 0 and arr[i + 1] < arr[i] and arr.delete_at(i)}\n  arr\nend\n</cell>\n\
    <cell>\n%run Solution.rb\n</cell>\n<text>\nThe Monty Hall Problem\nWe were asked\
    \ to implement a program to play the Monty Hall Problem.\nMonty Hall has three\
    \ rounds, each with a pre-determined number of players and a ball.\nThe goal of\
    \ the game is to get all three players into the same ball.\nA game consists of\
    \ three rounds, and each round contains three rounds.\nThe first round contains\
    \ exactly five players, and the second round contains exactly one player, the\
    \ third round contains exactly one player, and so on.\nThe players are numbered\
    \ from 0 to n-1, where n is the number of players.\nThe ball consists of wood,\
    \ with numbers 0 to n-1.\nEach player chooses a ball to play next, and that player\
    \ can play no more than one ball.\nSome players play a variation of balls, where\
    \ a player chooses a ball that consists of two of a player's previously chosen\
    \ balls, and the player chooses a third ball of any ball they like.\nThe game\
    \ ends when all players choose a ball of value 0.\nFor example, suppose there\
    \ are five players and one ball.\nFirst round:", "\tmin = arr.first\n\tmin_index\
    \ = arr.index\n\teven = false\n\tfor i in arr\n\t\tif i.even?\n\t\t\teven = true\n\
    \t\t\tmin = i\n\t\t\tmin_index = arr.index(i)\n\t\telsif i.even? != even\n\t\t\
    \tmin = i\n\t\t\tmin_index = arr.index(i)\n\t\tend\n\tend\n\t[min, min_index]\n\
    end", "    arr.each { |x| puts x.even? ? x.to_s + \" at index: \" + x.index :\
    \ x.to_s }\n    arr.sort.each_index { |x| puts x.even? ? x.to_s + \" at index:\
    \ \" + x.index }\n    arr.each_index.sort.each { |x| puts x.even? ? x.to_s + \"\
    \ at index: \" + x.index }\nend", "  # write your code here\n  return arr.sort\
    \ {|a,b|a.even? <=> b.even? }.first\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=arrays,ruby,algorithm\
    \ |>\n<code>\ninput = [4, 2, 3, 0, 5]", "  even_values = arr.select{ |x| x % 2\
    \ == 0 }\n  return even_values.min_by(&:index) if even_values.any?\n  return []\n\
    end", "    arr.sort!\n    even = []\n    less = []\n    greater = []\n    plus\
    \ = []\n    plu = []\n    i = 0\n    while i < arr.length\n        if arr[i] %\
    \ 2 == 0\n            even.push(arr[i])\n        else\n            less.push(arr[i])\n\
    \        end\n        i += 1\n    end\n    i = 0\n    while i < arr.length\n \
    \       if arr[i] > arr[arr.length - 1]\n            greater.push(arr[i])\n  \
    \      else\n            plus.push(arr[i])\n        end\n        i += 1\n    end\n\
    \    i = 0\n    while i < even.length\n        if even[i] < even[even.length -\
    \ 1]\n            plus.push(even[i])\n            i += 1\n        else\n     \
    \       less.push(even[i])\n            i += 1\n        end\n    end\n    i =\
    \ 0\n    while i < less.length\n        if less[i] > less[less.length - 1]\n \
    \           plus.push(less[i])\n            i += 1\n        else\n           \
    \ greater.push(less[i])\n            i += 1\n        end\n    end\n    i = 0\n\
    \    while i < less.length\n        if less[i] > less[less.length - 1]\n     \
    \       plus.push(less[i])\n            i += 1\n        else\n            greater.push(less[i])\n\
    \            i += 1\n        end\n    end\n    i = 0\n    while i < less.length\n\
    \        if less[i] > less[less.length - 1]\n            plus.push(less[i])\n\
    \            i += 1\n        else\n            greater.push(less[i])\n       \
    \     i += 1\n        end\n    end\n    i = 0\n    while i < less.length\n   \
    \     if less[i] > less[less.length - 1]\n            plus.push(less[i])\n   \
    \         i += 1\n        else\n            greater.push(less[i])\n          \
    \  i += 1\n        end\n    end\n    i = 0\n    while i < less.length\n      \
    \  if less[i] > less[less.length - 1]\n            plus.push(less[i])\n      \
    \      i += 1\n        else\n            greater.push(less[i])\n            i\
    \ += 1\n        end\n    end\n    i = 0\n    while i < less.length\n        if\
    \ less[i] > less[less.length - 1]\n            plus.push(less[i])\n          \
    \  i += 1\n        else\n            greater.push(less[i])\n            i += 1\n\
    \        end\n    end\n    i = 0\n    while i < less.length\n        if less[i]\
    \ > less[less.length - 1]\n            plus.push(less[i])\n            i += 1\n\
    \        else\n            greater.push(less[i])\n            i += 1\n       \
    \ end\n    end\n    i = 0\n    while i < less.length\n        if less[i] > less[less.length\
    \ - 1]\n            plus.push(less[i])\n            i += 1\n        else\n   \
    \         greater.push(less[i])\n            i += 1\n        end\n    end\n  \
    \  i = 0\n    while i < less.length\n        if less[i] > less[less.length - 1]\n\
    \            plus.push(less[i])\n", "  arr.each do |e|\n    next if e.to_s ==\
    \ \"0\"\n    idx = e.to_i.next\n    break if idx <= 0\n  end \n  [e, idx] if idx\n\
    end", "  arr.sort.each_with_index do |n,i|\n    if n%2 == 0 then\n      return\
    \ [n, i]\n    end\n  end\n  return []\nend\npluck(arr)\nend", "  arr.sort! \n\
    \  arr.map! {|x| x.even? ? x.to_i : 0}\n  arr << arr.pop.even? ? arr.pop : nil\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere is my solution:\n<code>", "  arr.each_with_index\
    \ do |v, i|\n    v.even? ? arr[i] = nil : arr[i] = arr[i] if v.even?\n  end\n\
    \  arr.uniq.min_by(&:to_i) if arr.uniq.size > 1\n  arr\nend", "    even = []\n\
    \    small = []\n    i = 0\n    while i < arr.length\n        if arr[i].even?\n\
    \            even << arr[i]\n        else\n            small << arr[i]\n     \
    \   end\n        i += 1\n    end\n    even.delete_if { |e| !small.include?(e)\
    \ }\n    even.map { |e| e.value }\nend", "  evens = []\n  arr.each_with_index\
    \ do |n, i|\n    if n % 2 == 0\n      evens << [ n, i ]\n    end\n  end\n  evens\
    \ = evens.sort{|a,b| a[0] <=> b[0]}.first\n  return evens[0] if evens.length ==\
    \ 1\n  evens = evens.sort{|a,b| a[1] <=> b[1]}.first\n  return evens[1] if evens.length\
    \ == 1\n  evens = evens.first\n  return [ evens[0], evens[1] ]\nend", "    even\
    \ = []\n    if arr.size != 0\n        arr.each do |val| \n            if val %\
    \ 2 == 0 && val !=0\n                even.push val\n            end\n        end\n\
    \    end", "\tmin = Array.new\n\tmin.push(-9999999, -1)\n\tmin.each_with_index\
    \ do |value, index|\n\t\tmin[index] = value < min[index][0] && value < min[index][1]\
    \ ? value : (min[index][0] == min[index][1] ? min[index][1] : (min[index][0] <\
    \ min[index][1] ? min[index][0] : min[index][1]))\n\tend\n\tmin.each_with_index\
    \ do |value, index|\n\t\tmin[index] = value < min[index][0] && value < min[index][1]\
    \ ? value : (min[index][0] == min[index][1] ? min[index][1] : (min[index][0] <\
    \ min[index][1] ? min[index][0] : min[index][1]))\n\tend\n\tmin.each_with_index\
    \ do |value, index|\n\t\tmin[index] = value < min[index][0] && value < min[index][1]\
    \ ? value : (min[index][0] == min[index][1] ? min[index][1] : (min[index][0] <\
    \ min[index][1] ? min[index][0] : min[index][1]))\n\tend\n\treturn min\nend\n\
    puts pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\n\
    puts pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\n\
    puts pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\n\
    puts pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\n\
    puts pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\n\
    puts pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\n\
    puts pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\n\
    puts pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\n\
    puts pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\n\
    puts pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\nputs pluck(arr)\n\
    puts pluck(arr)\nputs pluck(arr)\nputs pluck", "  even = arr.select{|v| v.even?}\n\
    \  even.empty? ? [] : even.min_by(&:value).first\nend", "\treturn arr[0] if (arr.length>0&&arr.each_cons(2).all{|a,b|\
    \ a%2==0&&b%2==0}) \n\tarr.each_cons(2).find{|a,b| a%2==0&&b%2==0}&.min&.last&.to_i\n\
    end\n\"\"\"\n\t# TODO your code:\n\traise NotImplementedError()", "  # Your code\
    \ here\n  if arr.length == 0\n    return []\n  min_even = arr.min_by {|x| x.even?}\n\
    \  if min_even.even?\n    min = min_even.value\n    arr.select {|x| x.even? }.each_index\
    \ {|i| min = i if x.value == min }\n    return [min, arr.find {|x| x.even? }.index]\n\
    \  else\n    arr.each {|x| x.even? ? arr.delete_at x.index : nil }\n    pluck(arr)\n\
    \  end\nend", "  min = nil\n  arr.each do |n|\n    next if n == 0\n    next if\
    \ n < 0\n    next if min == nil || n < min\n    min = n\n  end\n  return [min,\
    \ arr.index(min)]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
