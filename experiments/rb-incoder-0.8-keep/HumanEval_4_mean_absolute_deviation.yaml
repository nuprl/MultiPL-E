name: HumanEval_4_mean_absolute_deviation
language: rb
prompt: "# For a given list of input numbers, calculate Mean Absolute Deviation\n\
  # around the mean of this dataset.\n# Mean Absolute Deviation is the average absolute\
  \ difference between each\n# element and a centerpoint (mean in this case):\n# MAD\
  \ = average | x - x_mean |\n# >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n\
  # 1.0\ndef mean_absolute_deviation(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_mean_absolute_deviation\n\
  \    candidate = method(:mean_absolute_deviation)\n    assert_equal(0.5, candidate.call([1.0,\
  \ 2.0]))\n    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))\n    assert_equal(1.2,\
  \ candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n  end\nend\n"
completions: ["  sum_of_squares = numbers.inject(0) {|sum, element| sum + pow(element\
    \ - mean, 2) }\n  numbers.inject(0) {|sum, element| sum + pow((element - mean)\
    \ / stdev, 2) }\nend", "  deviations = numbers.each_with_object(0.0) do |number,\
    \ deviations|\n    deviations += abs number - number\n  end\n  deviations / numbers.count\n\
    end", "  return numbers.inject(:+) / (numbers.size - 1)\nend", "  return Math.log(Math.maximum(maximum(numbers)\
    \ - minimum(numbers), 0))\nend", "  numbers.inject(0) do |sum, num|\n    sum +=\
    \ abs(num - numbers.mean)\n    sum\n  end\nend", "  numbers.inject(0.0) { |sum,\
    \ value| sum + Math.abs(value - mean) }\nend", "  numbers.inject { |sum, item|\
    \ sum + item }\n  numbers.inject { |sum, item| sum + item ** 2 } / numbers.size\n\
    end", "  mean = numbers.inject(0){|sum,x| sum + x }\n  numbers.inject(0){|sum,x|\
    \ sum + Math.abs (x - mean) }\nend", "  deviation = 0\n  numbers.each { |x| deviation\
    \ += abs(x - x.mean) }\n  deviation /= numbers.size\n  deviation\nend", "  numbers.inject(0)\
    \ do |sum, number|\n    sum += abs\n  end\n  numbers.reduce(0) do |sum, number|\n\
    \    sum + pow(number - mean, 2)\n  end\nend", "  numbers.collect{|x| x}.inject(0){|sum,\
    \ e| sum + e ** 2}.inject(:+) / numbers.size\nend", "  n = numbers.length\n  return\
    \ ((numbers.reduce(&:__abs__) / n).abs) * sqrt(n)\nend", "  numbers.each_with_index\
    \ { |n, i| numbers[i] -= n }\n  numbers.inject { |sum, item| sum + item.abs }\n\
    end", "  sorted_numbers.sort!\n  center = sorted_numbers.first\n  diff = 0\n \
    \ for i in sorted_numbers\n    diff += i - center\n    center = i\n  diff /= sorted_numbers.size\n\
    \  diff\nend", "  return numbers.inject(0) {|sum, element| sum + abs(element -\
    \ numbers.mean)}.to_f / numbers.size\nend", "  numbers.inject {|sum, element|\
    \ sum + element if element > 0 }\n  numbers.inject {|sum, element| sum + element\
    \ }\n  numbers.inject {|sum, element| sum + element / numbers.size }\nend", " \
    \ numbers.inject(0) {|sum, number| sum + Math.abs number}\n  numbers.inject(0)\
    \ {|sum, number| sum + Math.abs (number - numbers.mean) }\nend\n</code>\n<|/ a\
    \ tags=ruby,ruby-on-rails,mapreduce dscore=2 |>\n<| a dscore=2 |>\nI was just\
    \ looking for the same thing and found this: https://github.com/tenderlove/ruby-mapreduce\n\
    I ran a quick test and it works.\n<|/ a tags=ruby,ruby-on-rails,mapreduce |>\n\
    <| a tags=ruby,ruby-on-rails,mapreduce |>\nI'm a bit late to the party, but I'm\
    \ posting the solution that I came up with for this problem for my own future\
    \ reference.\nI'm building a simple map reduce application that takes in a bunch\
    \ of JSON objects along with some key/value pairs, and sums up the total of values\
    \ for each key. My code is below. \n<code>\nrequire 'json'", "  numbers.inject(0.0)\
    \ do |sum, number|\n    sum += abs(number)\n    sum\n  end\nend", "  # Sort the\
    \ list so we can calculate the mean.\n  numbers.sort!", "  # Return Mean Absolute\
    \ Deviation of numbers in list (numbers)\n  return numbers.inject(0.0, :+) / numbers.size\n\
    end", "  numbers.inject(0.0) do |sum, value|\n    sum += value.abs\n    sum\n\
    \  end\n  numbers.inject(0.0) do |sum, value|\n    sum += value.abs\n    sum\n\
    \  end\nend", "  numbers.inject do |sum, number|\n    sum += ((number - numbers.mean)\
    \ * number).abs\n    sum\n  end\nend", "\tsum_of_squares = numbers.inject(0) {|sum,\
    \ element| sum + element * element}\n\tmean_of_numbers = numbers.inject(0) {|sum,\
    \ element| sum + element}\n\t(numbers - mean_of_numbers).abs.to_f/sum_of_squares\n\
    end", "    numbers.inject(0) {|sum, number| sum += (number-numbers.mean)**2}\n\
    end", "  numbers.inject(0.0) { |sum, el| sum += el.abs; sum }\n  math.sqrt(numbers.inject(0.0)\
    \ { |sum, el| sum += el.abs2; sum } / numbers.length)\nend\n</code>\nThe first\
    \ method calculates the standard deviation, the second method calculates the mean\
    \ and the third method calculates the average and deviation respectively. As you\
    \ can see these methods can be used to calculate the mean, deviation and average\
    \ of a dataset. Using the above method, you can calculate the standard deviation\
    \ of a dataset as follows:\n<code>\ndataset = [\"4.4\", \"4.3\", \"4.5\", \"4.2\"\
    , \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\"\
    , \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\"\
    , \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\"\
    , \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\"\
    , \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\"\
    , \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\"\
    , \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\"\
    , \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\"\
    , \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\"\
    , \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\"\
    , \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\"\
    , \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\"\
    , \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\"\
    , \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\"\
    , \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\"\
    , \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\"\
    , \"4.2\", \"3.7\", \"4.4\", \"4.3\", \"4.5\", \"4.2\", \"3.7\", \"4.4\", \"4.3\"\
    , \"4.5\", \"", "  numbers.inject(0.0) { |sum, val| sum += val } / numbers.size\n\
    end", "  sum = numbers.inject {|sum, el| sum + el}\n  sum = sum.to_f / numbers.size\n\
    \  sum_of_squares = numbers.inject {|sum, el| (sum.to_f + (el - sum.to_f) ** 2).to_f}\n\
    \  sum_of_squares.to_f / numbers.size\nend", "  numbers.inject(0.0) { |sum, value|\n\
    \    sum += value.abs\n    sum\n  }.sqrt\nend", "  numbers.reduce(:+).inject(0.0)\
    \ do |sum, number|\n    sum += abs(number - numbers.mean)\n    sum\n  end\nend",
  "  return numbers.inject(0.0) { |sum, el| sum + abs ((el - numbers.mean) **2) }\n\
    end", "    mad =  0.0\n    numbers.each{ |n|\n        mad = mad + (n - numbers.mean)\
    \ **2 }\n    mad = mad/numbers.size\n    return mad\nend\n</code>\n<|/ a tags=ruby,calculated-columns,statistics,ruby-on-rails\
    \ |>\n<| a tags=ruby,calculated-columns,statistics,ruby-on-rails |>\nIn Ruby 2.x\
    \ you can use Enumerable#inject:\n<code>", "  numbers.inject(0.0) {|sum, x| sum\
    \ + Math.sqrt(x)}\n  numbers.inject(0.0) {|sum, x| sum + x**2}\n  Math.sqrt(numbers.inject(0.0)\
    \ {|sum, x| sum + x**2}/numbers.size)\nend", "  numbers.inject { |sum, el| sum\
    \ + abs (el - sum) }\n  numbers.inject { |sum, el| sum + el }\n  numbers.inject\
    \ { |sum, el| sum + (el - numbers.mean) / numbers.std }\nend", "  mean_values\
    \ = numbers.map { |number| number.to_f / numbers.size }\n  mean_values.reduce(:+).abs\
    \ / numbers.size\nend", "  numbers.inject(0) {|sum, element| sum + element **\
    \ 2}\n  Math.sqrt(numbers.inject(0) {|sum, element| sum + (element - numbers.mean)\
    \ ** 2})\nend", "  numbers.inject(0) do |sum, value|\n    sum + absolute_difference(value,\
    \ sum / numbers.size)\n  end\nend", "  numbers.inject(0.0) { |sum, number| sum\
    \ += number.abs; sum }\n  mean = numbers.inject { |sum, number| sum + number }\
    \ / numbers.size\n  Math.sqrt(numbers.inject { |sum, number| sum + Math.pow(number\
    \ - mean, 2) } / numbers.size)\nend", "  # Initialize to the mean of the numbers\n\
    \  sum = numbers.inject(:+).to_f / numbers.size\n  diff = numbers.each_with_object([])\
    \ do |n, a|\n    a << [n, n - sum]\n  end\n  diff.inject(:+) / diff.size\nend",
  "    mad =  0.0\n    numbers.each do |number|\n        mad += abs_diff(number, number)\n\
    \    end\n    mad /= numbers.size\n    return mad\nend", "\tsum = 0.0\n\tfor x\
    \ in numbers\n\t\tsum += abs(x - mean(x))\n\treturn sum / numbers.size\nend\n\
    </cell>\n<cell>", "  numbers.reduce(:+).abs.divide(numbers.size)\nend", "  numbers.inject(0){\
    \ |sum, number| sum += pow(number - numbers.sum, 2); sum }\n  numbers.sum / numbers.length.to_f\n\
    end", "  numbers.inject(0.0) do |sum, number|\n    sum + math.abs(number - sum\
    \ / numbers.size)\n  end\nend\n</code>\n<|/ a dscore=4 |>\n<| a |>\nThe best and\
    \ most efficient implementation I found is here: http://www.ruby-doc.org/stdlib-1.9.3/libdoc/benchmark/rdoc/Benchmark.html\n\
    <|/ a tags=ruby dscore=4 |>\n<| a tags=ruby |>\n<code>", "  numbers.inject(0)\
    \ { |sum, element| sum + abs(element - sum) }\n  numbers.inject(0) { |sum, element|\
    \ sum + element }\n  numbers.length / 2\nend", "  numbers.inject(0.0) { |sum,\
    \ element| sum + abs(element - sum) }\n  numbers.inject(0.0) { |sum, element|\
    \ sum + element }\n  numbers.inject(0.0) { |sum, element| sum + element.abs }\n\
    \  numbers.inject(0.0) { |sum, element| sum + element / numbers.size }\nend\n\
    </cell>\n<text>\nExercise:\nWrite a function that returns the sum of the squares\
    \ of the input\nnumbers. The function should take one number as an input and return\n\
    the sum of the squares of that number. Assume that the numbers list\nis always\
    \ sorted in ascending order (from lowest number to highest).", "  # Return the\
    \ mean of the absolute values of the deviations\n  numbers.each_with_index do\
    \ |number, index|\n    deviation = number - numbers.shift\n    deviation = if\
    \ index == 0\n      deviation\n    else\n      numbers.last(2).inject(0) do |sum,\
    \ value|\n        sum + value * deviation\n      end\n    end\n    deviation\n\
    \  end\nend\n</cell>\n<text>\nAgain the mean absolute deviation is 1.", "  numbers.inject(0)\
    \ { |sum, number| sum + Math.abs (number-mean) }\n  numbers.inject(0) { |sum,\
    \ number| sum + Math.pow(number-mean, 2) }\n  numbers.length.times { |i| numbers[i]\
    \ = numbers[i] / numbers.length }\n  Math.sqrt(numbers.inject(0) { |sum, number|\
    \ sum + numbers[i] })\nend", "  numbers.inject(0.0) { |sum, value|\n    sum +\
    \ math.fabs(value - sum / numbers.size)\n  }\nend", "  return sum((x - mean(x))\
    \ for x in numbers) /\n    float(len(numbers))\nend\n</cell>\n<cell>", "  numbers.inject(0.0)\
    \ do |sum, number|\n    sum + ABS(number - mean)\n  end\nend", "    avg = numbers.inject(0.0)\
    \ { |sum, item| sum + item }\n    numbers.map { |item| item - avg  }.abs\nend",
  "  # Compute the mean of the absolute value of the deviations\n  # Use `map` for\
    \ python2\n  m = map(abs, numbers)\n  mn = mean(m)\n  return mean([(x - mn) for\
    \ x in m])\nend", "  numbers.reduce(:+)\n  numbers.reduce(:+) / numbers.size\n\
    end", "  return numbers.inject(0) { |sum, number| sum + abs(number - number.mean)\
    \ }\nend", "  mean = get_mean(numbers)\n  squares = numbers.map { |n| n**2 }\n\
    \  mean = mean + 0.01*numbers.reduce(:+)\n  squares = squares + 0.01*numbers.reduce(:+)\n\
    \  abs = (squares - mean)\n  abs.abs\nend", "  mad_sum = 0.0\n  numbers.each do\
    \ |x|\n    mad_sum += (x - x.mean) ** 2\n  end\n  mad_sum / (numbers.length.to_f\
    \ / 2.0)\nend\n</code>\n<|/ a |>\n<| a tags=ruby-on-rails,ruby,devise,ruby-on-rails-4\
    \ dscore=1 |>\nI think I got your question right, that you want to calculate the\
    \ deviation of a given set of numbers over your whole dataset. This deviation\
    \ should be calculated for each of the numbers you get from the dataset.\nThis\
    \ deviation should be calculated for the whole dataset or for all numbers in the\
    \ dataset. The deviation should be calculated by comparing each of the numbers\
    \ from the dataset with the mean of the dataset.\nFor this, you can use the code\
    \ below (I made a separate method for calculating the deviation):\n<code>", " \
    \ numbers.inject(0.0) { |sum, number| sum + Math.abs ((number - mean) / standard_deviation(number))\
    \ }\nend", "  numbers.inject(0) {|sum, el| sum + abs(el - el.mean) }\nend", " \
    \ numbers.inject(0) { |sum, num| sum + Math.abs num }\n  numbers.inject(0) { |sum,\
    \ num| sum + Math.pow (num - numbers.sum / numbers.count, 2) }\n  numbers.length.floor\
    \ / numbers.sum\nend", "  numbers.inject(0.0) { |sum, number| sum + Math.sqrt(number**2)}\n\
    end", "  # TODO: Write your code here\n  return numbers.inject(0.0) { |sum, element|\
    \ sum += math.abs(element - numbers.mean) }\nend", "    sum = numbers.inject(0.0,\
    \ :+) \n    numbers.reduce(:-) / numbers.reduce(sum)\nend", "  return sum((x -\
    \ mean(x)) for x in numbers) / length(numbers)\nend", "  numbers_mean = mean(numbers)\n\
    \  sum = 0\n  for x in numbers\n    sum += abs(x - numbers_mean)\n  return sum\
    \ / numbers.length\nend\n</code>\n<|/ a tags=statistics,ruby,math |>\n<| a tags=statistics,ruby,math\
    \ |>\nThe ruby gem \"statistics\" includes methods for calculating mean, variance,\
    \ and standard deviation, with code like the following (from here)\n<code>\nrequire\
    \ 'statistics'", "  # Sort the array\n  numbers.sort!\n  # Find mean of the sorted\
    \ numbers\n  mean = numbers.mean\n  # Calculate MAD\n  mad_sum = 0.0\n  mad_count\
    \ = 0.0\n  numbers.each_with_index do |x, i|\n    mad_sum += abs(x - mean)\n \
    \   mad_count += 1\n  end\n  return mad_sum / mad_count if mad_count > 0.0\n \
    \ return nil\nend", "  avg = average(numbers)\n  sum = 0.0\n  count = 0", "  return\
    \ numbers.inject(:+) / (numbers.size - 1.0)\nend", "  result = 0.0\n  sum = numbers.inject(0.0,\
    \ :+)\n  numbers.each do |number|\n    result += number.abs - sum\n    sum = 0.0\n\
    \  end\n  result / numbers.size\nend", "  mean = (numbers.inject(0.0) { |sum,\
    \ e| sum + e }) / numbers.length.to_f\n  (numbers - mean).abs\nend\n</code>\n\
    <|/ a |>\n<| a |>\nHere's an easy way to find the median in Ruby.\n<code>", " \
    \ numbers.inject(0){|sum, el| sum + Math.abs el - sum / numbers.size}\nend", " \
    \ numbers.collect{|x| x}.inject(0.0) do |sum, x|\n    sum += (x-numbers.inject{|sum,\
    \ number| sum + number}.to_f)/numbers.count\n  end\nend", "  n = numbers.inject(:+)\
    \ || 0.0\n  sum = 0.0\n  numbers.each do |x|\n    sum = sum + (x - n) * x\n  end\n\
    \  return sum / n\nend", "  numbers.inject(0) {|sum, el| sum + el**2 }\n  math.sqrt(numbers.inject(0)\
    \ {|sum, el| sum + el**2 } / (numbers.size - 2))\nend", "  numbers.inject { |sum,\
    \ item| sum + Math.sqrt(item * item) }\n  numbers.inject { |sum, item| sum + item\
    \ } / (numbers.length * 1.0)\nend", "  diffs = numbers.map{|x| (x - mean(x))**2\
    \ }\n  average_diffs = diffs.inject(0) {|sum,x| sum + x } / diffs.size\n  Math.sqrt(average_diffs)\n\
    end\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails dscore=1 |>\n<| a dscore=0\
    \ |>\nJust for fun, here is a method that will calculate the mean and median using\
    \ ruby's inject method:\n<code>", "  numbers.inject { |sum, value| sum + value\
    \ * value } / numbers.size\nend", "  numbers.collect{|n| n.abs} .collect{|n| n.to_f}.inject(0.0)\
    \ {|sum, item| sum + item / numbers.count}\nend", "  numbers.inject(0) {|sum,\
    \ number| sum + Math.abs (number-numbers.mean)}.to_f / numbers.size\nend\n</code>\n\
    <|/ a tags=statistics,ruby |>\n<| c |>\nI love this solution! It's elegantly simple.\
    \ I'd like to add a disclaimer: This relies on `Enumerable`'s `inject` method,\
    \ which was introduced in Ruby 1.9. If you're on an earlier version, you could\
    \ use [this version](http://stackoverflow.com/a/12171617/488898) as a drop-in\
    \ replacement for it.\n<|/ c |>\n<| c |>\nAlso, if you use this on a dataset that\
    \ has a lot of outliers such as your sample data above, you may get incorrect\
    \ results. I've posted a [related question](http://stackoverflow.com/q/12171400/488898)\
    \ a while ago.\n<|/ c |>\n<| a |>\nIf you have a bunch of numbers and would like\
    \ to calculate the mean of those, I would use Enumerable#sum and Enumerable#size\n\
    <code>\n> [2.0,3.0,4.0,3.5,6.4,7.0,5.0].reduce(0) {|s,e| s+e }\n=> 6.0\n> [2.0,3.0,4.0,3.5,6.4,7.0,5.0].reduce(0)\
    \ {|s,e| s+e }.to_f/[2.0,3.0,4.0,3.5,6.4,7.0,5.0].size\n=> 6.0\n</code>\n<|/ a\
    \ tags=statistics,ruby dscore=2 |>\n<| a |>\n<code>", "  numbers.inject(0) {|sum,\
    \ val| sum += (val - numbers.reduce(0, :+)) / numbers.size }\nend", "  numbers.inject(0)\
    \ do |sum, (number)|\n    sum + Math.sqrt((number * number).abs)\n  end\nend",
  "  m = 0\n  abs_diff = 0\n  numbers.each_with_index do |n, i|\n    abs_diff += n.abs\
    \ - m\n    m = n.abs\n  end\n  abs_diff / numbers.size\nend", "  numbers.inject(0)\
    \ {|sum,x| sum + Math.abs (x-mean(x))}\n  numbers.length.times do\n    sum = numbers.inject(0)\
    \ {|sum,x| sum + Math.pow (x-mean(x),2)}\n    puts Float(sum / numbers.length.to_f).to_s\
    \ + \"|\"\n  end\nend", "  sum = numbers.inject(0.0) do |sum, value|\n    sum\
    \ += value.abs\n  end\n  numbers.inject(0.0) do |sum, value|\n    sum -= value\
    \ / sum\n  end\nend", "  numbers.inject(0) do |sum, number|\n    sum + Math.sqrt((number\
    \ * number).abs) / numbers.size unless number.zero?\n  end\nend\n</code>\nIf it\
    \ works, you could then use it in your class like so:\n<code>", "  numbers.inject(0)\
    \ do |sum, number|\n    sum + Math.abs (number-numbers.reduce(:+))\n  end\nend",
  "    avg = numbers.inject(:+).to_f / numbers.size\n    numbers.inject(0.0) { |sum,\
    \ el| sum + abs (el - avg) }\nend", "  numbers.inject(0){|sum, x| sum + Math.sqrt(x*x)}\n\
    \  numbers.inject(0){|sum, x| sum + x*x}\n  numbers.inject(0){|sum, x_mean| sum\
    \ + Math.sqrt(x_mean*x_mean)}\n  numbers.inject(0){|sum, x| sum + Math.sqrt(x*x)/x_mean.to_f}\n\
    end", "  sum = numbers.inject(0){|sum, element| sum + element ** 2}\n  mean =\
    \ numbers.inject(0){|sum, element| sum + element}\n  sum / numbers.size\nend",
  "  n = numbers.inject(0) {|sum, element| sum + Math.abs element}\n  numbers.inject(0)\
    \ {|sum, element| sum + Math.sqrt Math.abs element / n}\nend", "  mean = 0.0\n\
    \  deviations = Array.new\n  numbers.each_index { |index|\n    delta = numbers[index]\
    \ - mean\n    deviations << delta\n    mean += delta\n  }\n  mean = mean / numbers.length\n\
    \  deviations.inject(0, :+) / numbers.length\nend", "  mean = 0.0\n  n = 0.0\n\
    \  for x in numbers\n    mean += abs(x - mean)\n    n += 1\n  mean = mean / n\n\
    \  deviation = 0.0\n  for x in numbers\n    deviation += ((x - mean) ** 2)\n \
    \ return deviation / n\nend\n</code>\n<|/ a |>\n<| a tags=average,sorting,algorithm,ruby,ruby-on-rails\
    \ |>\nYou have a list of numbers and you want to find the mean.\n<code>", "  numbers.inject(0.0)\
    \ do |sum, number|\n    sum += abs(number - number.mean)\n    sum\n  end\nend",
  "  avg = numbers.inject(:+).to_f / numbers.size\n  abs = numbers.map { |n| n - avg\
    \ }\n  avg.abs.sqrt\nend", "  numbers.inject(0) { |sum, value| sum + Math.abs\
    \ (value) }\n  numbers.inject(0) { |sum, value| sum + Math.sqrt (value) }\n  numbers.length.to_f\
    \ / numbers.inject(0) { |sum, value| sum + value }\nend", "  numbers = numbers.to_a\n\
    \  absolutes = numbers.map { |number| number.abs }\n  mean = absolutes.mean\n\
    \  deviations = absolutes.map { |x| x - mean }\n  deviations.inject(0) {|sum,\
    \ deviation| sum + deviation}\nend", "  numbers.inject(0.0) {|sum, el| sum + abs\
    \ (el - sum) / numbers.size}\nend", "  mean = numbers.inject(0.0, :+) / numbers.size.to_f\n\
    \  diffs = numbers.map { |n| n - mean }\n  diffs.inject(0.0, :+) / (diffs.size.to_f\
    \ ** 0.5)\nend", "  numbers.inject(0) do |sum, number|\n    sum += abs(number)\n\
    \    sum\n  end\nend\n</cell>\n<code language=conda-root-py>", "  mean = numbers.inject(:+)\
    \ / numbers.size\n  (numbers.inject(:-) / numbers.size).sqrt\nend", "  mean  \
    \ = 0\n  diff   = 0\n  size   = 0\n  sumdiff = 0\n  for i in 0..numbers.size-1\n\
    \    diff = (numbers[i]-mean)\n    sumdiff += diff*diff\n    size  += 1\n    mean\
    \ += diff\n  end\n  mean = mean/size\n  return sumdiff/size\nend", "  sorted_numbers\
    \ = numbers.sort\n  result = 0.0\n  numbers.each_with_index do |n, i|\n    result\
    \ += (n - sorted_numbers[i]) * (n - sorted_numbers[i])\n  end\n  result\nend",
  "  numbers.inject(0.0) { |sum, number| sum + absolute_difference(number) * number}\n\
    end", "  numbers.inject { |sum, el| sum + el**2 }\n  numbers.inject { |sum, el|\
    \ sum + el }\n  numbers.inject { |sum, el| sum + el / 2.0 }\nend", "  numbers.inject(0.0)\
    \ { |sum, value| sum + fabs(value) }\nend\n</code>\n<|/ a dscore=2 tags=ruby-on-rails,ruby,ruby-on-rails-3\
    \ |>\n<| c |>\nThanks, this was helpful and I appreciate you taking time for writing\
    \ this out.  However, I still get an error when I use this code.  I updated my\
    \ question to show what I am trying now.  Any ideas?\n<|/ c |>\n<| c |>\nThe code\
    \ you posted here is not the code that is giving you the error.  You have to change\
    \ your `def` line to read `def mean_absolute_deviation(numbers)` and then you\
    \ should be good.\n<|/ c |>\n<| c |>\nSorry, I did miss-type that.  I updated\
    \ my question to reflect that.  I still get the same error though...  Is there\
    \ something wrong with my code?\n<|/ c |>\n<| c |>\nSorry, my bad.  I didn't realize\
    \ that I needed to put in all the parameters in my function.  I updated the code\
    \ above.  However, now I get an error...\n<|/ c |>\n<| c |>\nYou are still calling\
    \ the `mad_test` method wrong.  It should be `mad_test(numbers)` not `mad_test(numbers,\
    \ numbers, numbers)`.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  numbers.inject(0.0)\
    \ do |sum, number|\n    sum += abs(number)\n  end\n  numbers.inject(0.0) do |sum,\
    \ number|\n    sum + pow((number - numbers.mean), 2)\n  end\nend", "  numbers.inject(0.0)\
    \ do |sum, number|\n    sum += abs(number);\n    sum\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,statistics,median dscore=2 |>\n<| c |>\nI wouldn't say that your\
    \ answer is a bad one.  My only gripe is that it uses \"median\" in a different\
    \ way from other answers that do use median.  So I'm not sure it's a good answer.\n\
    <|/ c |>\n<| c |>\nI think it is an excellent answer!  It's a very simple and\
    \ elegant solution that uses standard Ruby functionality.  I haven't tested it,\
    \ but it should work well for medium sized lists.  I like that this doesn't require\
    \ a huge number packages.\n<|/ c |>\n<| c |>\n: That's very interesting and I\
    \ agree with you.  I've edited my answer to reflect that.  I still think mine\
    \ is a bit too general in that it assumes that the input list is already sorted.\
    \  I'll delete my answer if you think mine is a better answer.\n<|/ c |>\n<| c\
    \ |>\n: Yes I'd be interested to see how others would look at it for medium sized\
    \ lists, but I guess that is more of a case for another question.\n<|/ c |>\n\
    <| c |>\nI don't think this is an answer that works well for medium sized lists.\
    \ For example, if the list is `[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]` then the average\
    \ is `-5.0` whereas the median is `-4`. As I understand it, the median is the\
    \ \"middle\" element of the list. If there are `n` elements in the list, then\
    \ the median is `(n+1)/2`, which is `-1.5`, not `-2`. Perhaps I'm wrong...\n<|/\
    \ c |>\n<| a tags=ruby,statistics,median |>\nHere's another solution using median_inclusive\
    \ from Statistics module:\n<code>", "  return numbers.inject(0) {|sum, el| sum\
    \ + abs(el - numbers.mean)}\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nTo calculate\
    \ the mean of the numbers, use Enumerable#inject:\n<code>\nrequire 'benchmark'",
  "  numbers.inject(0) {|sum, el| sum + abs (el - sum) }\n  numbers.inject(0) {|sum,\
    \ el| sum + abs (el - sum) }\n  numbers.inject (0, :+) / numbers.size\nend", " \
    \ numbers.inject(0) { |sum, e| sum + abs (e - mean(e)) }\nend", "  numbers.inject(0.0)\
    \ do |sum, item|\n    sum += (item - numbers.last).abs\n  end\n  numbers.inject(0.0)\
    \ do |sum, item|\n    sum + Math.sqrt(sum * (item - numbers.last) * (item - numbers.last))\n\
    \  end\nend\n  ", "  mean = (0...numbers.size).inject{|sum, e| sum + e }\n  numbers.inject(0){|sum,\
    \ e| sum + Math.abs (e - mean) }\nend", "  n = numbers.length\n  mean = numbers.inject{|sum,\
    \ val| sum + val} / n\n  sum = 0.0\n  numbers.each do |val|\n    sum = sum + abs(val\
    \ - mean)\n  end\n  sum / n\nend\n</pre>", "  # If no numbers, return None\n \
    \ return numbers.reduce(\n    :+,\n    :-,\n    numbers.inject(0, :+) do |sum,\
    \ num|\n      sum + Math.sqrt(sum * sum - num * num)\n    end\n  )\nend", "  numbers.each_with_object(0.0)\
    \ do |number, mad|\n    mad = mad + absdev(number)\n  end\nend", "  numbers.inject(0.0)\
    \ do |sum, number|\n    sum += math.fabs(number)\n    sum\n  end\nend", "  numbers.reduce(:+).abs\
    \ / numbers.reduce(:+).abs.mean\nend", "  numbers.inject(0, :+).reduce(:-) / numbers.size\n\
    end", "  # Initialize the mean and deviation counters\n  mean = 0.0\n  deviations\
    \ = 0\n  # Iterate over all input numbers\n  numbers.each do |num|\n    mean +=\
    \ num\n  end\n  mean /= numbers.length\n  # Iterate over all numbers in the dataset\n\
    \  numbers.each do |num|\n    deviations += Math.pow(num - mean, 2)\n  end\n \
    \ deviations /= numbers.length\n  # Return the MAD\n  return Math.sqrt(deviations)\n\
    end", "  mean = 0\n  for x in numbers\n    mean += x\n  mean /= numbers.length\n\
    \  deviation = 0\n  for num in numbers\n    deviation += Math.abs ((num - mean))\n\
    \  return deviation / numbers.length\nend", "    avg = mean_list(numbers)\n  \
    \  return sum((x - avg)**2 for x in numbers)/len(numbers)\nend", "  numbers.inject(0.0)\
    \ { |sum, element| sum + abs element }\n  numbers.inject(0.0) { |sum, element|\
    \ sum + element * element }\n  numbers.inject { |sum, element| sum + element }\n\
    \  numbers.inject { |sum, element| sum / element }\nend\n</cell>\n<cell>", " \
    \   sorted = numbers.sort\n    center = sorted.reduce(:+) / sorted.size\n    (sorted.size\
    \ - 1).downto(1) { |i| \n        mean += sorted[i] - center\n        deviation\
    \ += sorted[i] - mean\n    }\n    mean /= sorted.size\n    deviation /= sorted.size\n\
    \    Math.sqrt(deviation)\nend", "  return ma(numbers.map{|x| x.abs},0)\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThis function is useful to calculate\
    \ median with unsorted data:\n<code>", "  mean = 0.0;\n  numbers.each { |n|\n\
    \    mean += n unless n == 0;\n  }\n  mean / numbers.length\nend", "  numbers.inject(0.0)\
    \ { |sum, number| sum += math.fabs(number) }\n  numbers.inject(0.0) { |sum, number|\
    \ sum += math.fabs(number - numbers.mean) }\n  numbers.inject(0.0) { |sum, number|\
    \ sum += math.pow((number - numbers.mean), 2) }\n  numbers.sum / numbers.size\n\
    end\n</code>\nThis implementation is O(n) and runs in O(n) time but because it\
    \ is so straightforward it doesn't require any \"tricks\", it just uses the familiar\
    \ mathematical properties.\n<|/ a dscore=5 |>\n<| c |>\nThis is the only answer\
    \ which answers the question of how to calculate the variance for a list of numbers.\
    \ You even included a link to the relevant wikipedia page. Thank you for that.\
    \ Wish I could give you more upvotes\n<|/ c |>\n<| c |>\nYour `mean_absolute_deviation`\
    \ method doesn't work when passed an array like `[1,2,3]`.  I think it should\
    \ be:", "  numbers.inject(0.0) {|sum, element| sum += element if element}\n  numbers.inject\
    \ {|sum, element| sum + Math.abs element } / numbers.size\nend\n</cell>\n<cell>",
  "  numbers.inject(0) do |sum, number|\n    sum += (number - number.mean)**2\n  end\n\
    \  numbers.inject { |sum, number| sum + number.mean }**(1.0/numbers.size)\nend",
  "  numbers.inject(0) { |sum, num| sum + abs (num) }\n  numbers.inject (0, &:+) /\
    \ (numbers.length)\nend\n</code>\nAnd here is your code:\n<code>", "  sum = 0\n\
    \  mean = 0.0\n  for i in numbers\n    sum += i\n    mean += i\n  mean = mean\
    \ / numbers.length\n  sum = 0.0\n  for i in numbers\n    sum += Math.pow((i -\
    \ mean), 2)\n  return Math.sqrt(sum / numbers.length)\nend\n</code>\nThis code\
    \ works well for small sets of numbers, but it's slow for larger sets. I used\
    \ my own benchmarks to test the performance of this code.\n<code>\nrequire \"\
    benchmark\"", "  numbers.inject(0, :+).to_f / numbers.size.to_f\nend", "  mean\
    \ = numbers.mean\n  sum_of_squares = 0\n  numbers.each do |number|\n    sum_of_squares\
    \ += (number - mean) * (number - mean)\n  end\n  sum_of_squares.sqrt\nend", " \
    \ deviation = 0\n  mean = numbers.reduce(:+)\n  numbers.each {|number| deviation\
    \ += abs(number - mean) }\n  deviation /= numbers.size\n  deviation\nend", " \
    \ mean  = numbers.inject(:+).to_f / numbers.size\n  devs  = numbers.map { |n|\
    \ Float(n.to_f - mean) }\n  devs.reduce(:+) / devs.size\nend", "  ma = numbers.inject(0)\
    \ { |sum, num| sum + abs (num) }\n  numbers.inject (0, 0) { |sum, num| sum + num\
    \ / (ma + 1) }\nend\n</cell>\n<cell>", "  number_array = numbers.to_a\n  mean\
    \ = number_array.mean\n  abs_devs = number_array.map { |n| n.abs - mean }\n  abs_devs.mean\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| a tags=ruby,statistics,statistical-test |>\n\
    <code>\na = [1, 2, 3, 4, 5, 6]", "  numbers.inject(0) do |sum, value|\n    sum\
    \ += (value - numbers.sum) unless value.zero?\n    sum\n  end\nend", "  numbers.inject(0.0)\
    \ { |sum, number| sum + Math.abs(number - mean) }\nend", "  # Mean Absolute Deviation\
    \ is the average absolute difference between each\n  # element and a centerpoint\
    \ (mean in this case):\n  # MAD = average | x - x_mean |\n  \n  # We find the\
    \ mean in this case:\n  mean = numbers.inject(:+) / numbers.size\n  \n  # Then\
    \ we can calculate MAD:\n  numbers.map{|n| mean - (n - mean)}.reduce(:+)\nend",
  "  numbers.inject(0.0) { |sum, value| sum + math.abs(value) }\nend", "  numbers.inject(0)\
    \ {|sum, number| sum + number.abs }\n  numbers.inject(0) {|sum, number| sum +\
    \ number.to_f }\n  numbers.inject(0) {|sum, number| sum + number.to_d }\n  numbers.inject(0)\
    \ {|sum, number| sum + number.to_i }\n  numbers.inject(0) {|sum, number| sum +\
    \ number.abs } / (numbers.size)\nend", "  n = numbers.map {|number| number}.length\n\
    \  md = 0.0\n  numbers.each {|number| md += abs(number - numbers.mean)}\n  md\
    \ / n\nend", "  mean     = numbers.inject(:+) / numbers.size\n  deviations = numbers.map\
    \ { |n| (n - mean) ** 2 }\n  sqrt(deviations.inject(0, :+) / deviations.size)\n\
    end\n</code>\nThis version returns the average MAD across all numbers in the list,\
    \ which you can adjust by changing numbers.size to numbers.count(&:positive?).\n\
    Another approach that might be a bit more readable is to calculate the average\
    \ deviation using Enumerable#inject:\n<code>", "  numbers.inject(0.0) { |sum,\
    \ number| sum += abs(number); sum }\n  numbers.inject { |sum, number| sum + number\
    \ }\n  numbers.inject(0.0) { |sum, number| sum + number**2 }\n  numbers.inject(0.0)\
    \ { |sum, number| sum + number**3 }\n  numbers.inject(0.0) { |sum, number| sum\
    \ + number**4 }\n  numbers.inject(0.0) { |sum, number| sum + number**5 }\n  numbers.inject(0.0)\
    \ { |sum, number| sum + number**6 }\n  numbers.inject(0.0) { |sum, number| sum\
    \ + number**7 }\n  numbers.inject(0.0) { |sum, number| sum + number**8 }\n  numbers.inject(0.0)\
    \ { |sum, number| sum + number**9 }\nend", "  mean      = numbers.inject(:+) /\
    \ numbers.length.to_f\n  diffs     = numbers.map { |x| x - mean }\n  diffs.inject(:-)\
    \ / (diffs.length.to_f / 2).to_f\nend", "  n = numbers.inject { |sum, number|\
    \ sum + abs(number) }\n  (numbers.size - n).fdiv(numbers.size)\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby,arrays,ruby-on-rails |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ dscore=0 |>\nTo give a little bit of credit to everyone who answered this question,\
    \ here is another solution, based on this answer:\n<code>", "  numbers.inject(0)\
    \ {|sum, value| sum + Math.abs value }\n  numbers.inject(0) {|sum, value| sum\
    \ + Math.sqrt value }\n  numbers.inject(0) {|sum, value| sum + (value - numbers.last).abs\
    \ }\n  numbers.inject(0) {|sum, value| sum + value * value }\n  Math.sqrt(numbers[numbers.count\
    \ - 1])\nend", "  mean = 0.0\n  numbers.each do |n|\n    mean += n\n  end\n  mean\
    \ / numbers.length\nend", "  sum = numbers.inject(0){|sum, el| sum + Math.abs\
    \ el - el.mean}\n  numbers.inject(0){|sum, el| sum + Math.abs el}\n  sum / numbers.size\n\
    end", "  return numbers.inject(0.0) { |sum, e| sum + abs(e - numbers.mean) }\n\
    end", "  # get mean\n  mean = numbers.reduce(:+) / numbers.size unless numbers.empty?\n\
    \  # calculate MAD\n  numbers.reduce(:+) - mean\nend", "  return numbers.inject(0)\
    \ { |sum, val| sum + abs(val - numbers.mean) } / (numbers.count * 1.0)\nend",
  "  # TODO: Write your solution here\nend", "  # Sum the absolute value of all numbers\
    \ in the dataset\n  sum = numbers.inject(:+)\n  # Average absolute deviation from\
    \ the mean\n  numbers.inject { |sum, (number)|\n    sum + Math.abs (number - sum\
    \ / numbers.size)\n  }\nend\n</code>\n<|/ a |>\n<| c |>\nThis is nice, but it\
    \ doesn't answer the question, which was how to calculate the [Mean Absolute Deviation](http://en.wikipedia.org/wiki/Mean_deviation#MAD_average)\
    \ around the mean.\n<|/ c |>\n<| a tags=ruby,mapreduce |>\nThis should work:\n\
    <code>", "  numbers.inject([:+, 0, 0].mean) do |sum, el|\n    sum += abs(el -\
    \ sum)\n    sum\n  end\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nGreat answer.\
    \ One note - I think it should be `numbers.inject(:+) + ...` because `+` will\
    \ call `to_f` on the elements, which is different from `inject` which just passes\
    \ the element through.\n<|/ c |>\n<| c |>\nIf numbers is empty or nil then you\
    \ will get an error for `nil.to_f`. You can fix this by changing the inject line\
    \ to `numbers.inject([:+, 0, 0].mean) do |sum, el|` so no error occurs.\n<|/ c\
    \ |>\n<| c |>\nThis seems to be the most accurate solution. I found one more simple\
    \ and nice solution (I posted it too).\n<|/ c |>\n<| c |>\nThis doesn't seem to\
    \ be the best solution, since it uses two passes of the array. [Jason's answer](http://stackoverflow.com/a/14504847/124364)\
    \ seems a bit cleaner and more efficient.\n<|/ c |>\n<| c |>\nThe only problem\
    \ with this is that the mean-absolute-deviation algorithm is O(n^2), so it is\
    \ best to be used with arrays that are very large (e.g. `[1..n]`).\n<|/ c |>\n\
    <| a tags=ruby |>\nHere is one solution that uses reject to remove outliers:\n\
    <code>", "  numbers.inject(0){|sum, element| sum + pow(element - mean, 2)}\nend",
  "  avg = numbers.inject(0.0, :+) / numbers.size\n  sum = 0.0\n  numbers.each do\
    \ |number|\n    sum = sum + Math.pow(number - avg, 2)\n  end\n  Math.sqrt(sum\
    \ / numbers.length)\nend", "  mean = (numbers.inject(:+) / numbers.length).to_f\n\
    \  numbers.map {|n| Math.sqrt((n - mean)**2) }.reduce(:+) / numbers.length\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3,ruby-on-rails-3.2 dscore=3\
    \ |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3,ruby-on-rails-3.2 |>\nI implemented\
    \ a solution based on Sid's ideas:\n<code>", "  mean = 0.0\n  sum = 0.0\n  max_number\
    \ = numbers.max_by { |n| n }\n  numbers.each do |n|\n    sum += max_number - n\n\
    \    mean += max_number - n\n  end\n  mean\nend", "  n = numbers.length\n  if\
    \ n == 0\n    0.0\n  else\n    (numbers.inject(0.0) { |sum, number| sum + Math.pow(number\
    \ - numbers.shift, 2) }) / n\n  end\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    I don't get it, how does this help the OP to calculate the mean and deviation\
    \ for a list of numbers?\n<|/ c |>\n<| c |>\nYou get the `array` out of the `hash`\
    \ with `.values` and the `inject` method will sum all values within this `array`.\n\
    <|/ c |>\n<| c |>\n`[10, 20, 30].inject(0) { |sum, number| sum + number }\n=>\
    \ 30.0`\n<|/ c |>\n<| c |>\nI meant your answer doesn't answer the question that\
    \ was asked.\n<|/ c |>\n<| c |>\nAh, thanks for noticing! But now I realize that\
    \ I haven't answered the question. Still thinking how to answer it.\n<|/ c |>\n\
    <| a tags=ruby dscore=4 |>\nHere's my version using Hash#each_with_object\n<code>\n\
    numbers = [10, 20, 30]\nnumbers.each_with_object(Hash.new(0)) { |n, h| h[n] +=\
    \ n }\np numbers # => [10, 20, 30]\np numbers # => [10, 20, 30]\n</code>\nThe\
    \ Hash.new method initializes h with the default value (here zero) if the key\
    \ does not exist. This means that when the key n is not already in the hash the\
    \ block will be executed, and the block returns the default value. If the hash\
    \ already has a key with value n, then the block is skipped, and the hash retains\
    \ its previous value. Thus the last two lines output the same array. \nThe block\
    \ calculates the sum of the numbers in the array and passes it to the block's\
    \ block argument.\n<|/ a |>\n<| c |>\nThis answer is great, but I think it misses\
    \ the point. The OP asked how to calculate the sum of the numbers and then calculate\
    \ the MAD.\n<|/ c |>\n<| a dscore=3 |>\nThis is an alternative solution using\
    \ each_cons and inject and without using an intermediate Hash:\n<code>\nnumbers\
    \ = [10, 20, 30]\nnumbers.each_cons(2).inject { |a,b| a + b }\n</code>\nThis code\
    \ first calculates the sum of all even and odd pairs of the given array, then\
    \ calculates the average.\n<|/ a tags=ruby |>\n<| c |>\nNice. I'd add `", "  numbers.inject(0)\
    \ {|sum, value| sum + value * value }\n  numbers.inject(0) {|sum, value| sum +\
    \ value }\n  numbers.inject(0) {|sum, value| sum + value * value }\n  numbers.inject(0)\
    \ {|sum, value| sum + value * value }\n  numbers.inject(0) {|sum, value| sum +\
    \ value }\n  numbers.reduce(&:+) / numbers.size\nend\n</cell>\n<text>\nThe following\
    \ cell is based on a script written by Chris Weng. Check it out at .", "  numbers.inject(0){|sum,\
    \ item| sum + abs item }\n  numbers.inject(0){|sum, item| sum + item**2 }\n  numbers.inject(0){|sum,\
    \ item| sum + item**0.5 }\n  numbers.inject(0){|sum, item| sum + item**2.0 }\n\
    \  numbers.inject{|sum, item| sum + item**3 } / numbers.size\nend", "  numbers.inject(0.0)\
    \ do |sum, (number)|\n    sum += (number-numbers.mean)*number\n  end\nend", " \
    \ return numbers.inject(0, :+).reduce(:-) / numbers.size.abs\nend", "  mean  \
    \       = numbers.inject(:+).to_f / numbers.size\n  diffs        = numbers.map{|x|\
    \ x-mean}\n  diffs.inject{|sum, diff| sum + diff }\nend\n</code>\nIt also works\
    \ nicely with arrays:\n<code>\nmean_absolute_deviation([1,2,3,4,5].to_a)", " \
    \ numbers.inject(0) do |sum, element|\n    sum + abs (element - numbers.mean)\n\
    \  end\nend", "    sum = 0.0\n    sumsq = 0.0\n    n = numbers.size\n    for i\
    \ in 0...n\n        sum += numbers[i]\n        sumsq += numbers[i] * numbers[i]\n\
    \    end\n    return sum / n if n > 0 else 0.0\nend", "  return numbers.inject(0.0)\
    \ { |sum, element|\n    sum += abs(element - numbers.mean)\n  }\nend\n</code>\n\
    <|/ a |>\n<| c |>\nGood idea. But be careful with the performance impact of this\
    \ method compared to [the other](http://ruby-doc.org/core-2.1.2/Enumerable.html#method-i-sum_if),\
    \ since `inject` is much faster.\n<|/ c |>\n<| c |>\nYes, but that's not really\
    \ an impact on average, since most people don't have much numbers. But good to\
    \ know, thanks!\n<|/ c |>\n<| c |>\n`reduce` is significantly faster even for\
    \ numbers longer than a few thousand: http://ruby-doc.org/core-2.1.2/Enumerable.html#method-i-reduce\n\
    <|/ c |>\n<| c |>\nAha, thanks. I didn't know `inject` is faster. I'll add this\
    \ to the answer, and +1 this answer. :-)\n<|/ c |>\n<| a |>\nMy suggestion is\
    \ to go with Enumerable#inject, which was introduced in Ruby 1.8.\n<code>", " \
    \ numbers.inject(0.0) { |sum, x| sum + x.abs }\n  numbers.inject { |sum, x| sum\
    \ + x }\n  numbers.inject { |sum, x| sum / 2 }\nend", "  return numbers.inject(0.0)\
    \ do |sum, element|\n    sum += abs(element - numbers.shift)\n    sum\n  end\n\
    end", "  numbers.inject(0){|sum,x| sum + Math.sqrt(x * (x - mean)**2)}\nend",
  "  mean = (numbers.inject(:+) / numbers.length.to_f).to_f\n  mean = numbers.inject(:+)\
    \ / (numbers.length.to_f - (1..0).inject(:+))\n  (numbers.map{|x| mean - x}.reduce(:+)\
    \ / numbers.length.to_f).to_f\nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\nTo get\
    \ the standard deviation of a set of numbers you can use the following algorithm:\n\
    <code>", "  numbers.inject(0) {|sum, number| sum + Math.pow(number - mean, 2)}\n\
    \  math.sqrt(sum / numbers.length)\nend", "  numbers.inject([0.0]) do |sum, number|\n\
    \    sum += abs(number)\n  end\n  numbers.inject do |sum, number|\n    sum + Math.sqrt(sum\
    \ * sum / number)\n  end\nend", "  numbers.inject(0, :+).reduce(:-)/numbers.size\n\
    end", "  avg = numbers.inject(0.0) { |sum, number| sum + number.to_f }\n  numbers.inject(0.0)\
    \ { |sum, number| sum + (number-avg).abs }\nend", "  # Calculate mean of all numbers\n\
    \  mean = numbers.reduce(:+) / numbers.size\n  # Calculate variance\n  variance\
    \ = 0\n  numbers.each do |number|\n    variance += Math.pow(number - mean, 2)\n\
    \  end\n  # Calculate standard deviation\n  deviation = Math.sqrt(variance)\n\
    \  # Calculate MAD\n  mad = deviation.abs / (numbers.size - 1)\n  mad_with_warnings\
    \ = mad if mad > 0.0 && mad < 1.0\n  mad_with_warnings if mad_with_warnings\n\
    end", "  numbers.inject(0) do |sum, number|\n    sum += number.abs\n    sum\n\
    \  end\n  numbers.inject {|sum, number| sum + number.abs} / numbers.size\nend",
  "  numbers.inject{|sum, number| sum + math.fabs(number - sum / numbers.count)}\n\
    end\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails,performance dscore=4 |>\n<|\
    \ c |>\nI like this... `numbers.inject{|sum, number| sum + math.fabs(number -\
    \ sum / numbers.count)}` - very elegant solution. +1 from me.\n<|/ c |>\n<| c\
    \ |>\nThe only thing I'd add, is to avoid calculating the mean on every iteration\
    \ by using the previous sum, something like this: `numbers.inject{|sum, number|\
    \ sum + math.fabs(number - sum / numbers.count) }`, but it's an optimization and\
    \ not really necessary.\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails,performance\
    \ |>\nTo compare the performance of different methods in my own Ruby on Rails\
    \ projects, I added the benchmark gem to my project. Then I did the following:\n\
    <code>\nrequire 'benchmark'", '  numbers = numbers.to_f', "  mean  = numbers.inject(0,\
    \ :+) / numbers.size\n  numbers = numbers.map { |x| x - mean }\n  numbers.reduce(0)\
    \ do |sum, value|\n    sum += value * value\n  end\n  numbers.sqrt\nend", "  mean\
    \     = numbers.inject(0.0) { |sum, element| sum + element }\n  deviation = (numbers\
    \ - mean).abs\n  mad      = deviation.inject(0.0) { |sum, element| sum + element.abs\
    \ }\n  mad_divided_by = numbers.inject(0.0) { |sum, element| sum + element }\n\
    \  return (mad_divided_by - mean) / mad_divided_by\nend", "  return Math.sqrt(mean_absolute_deviation_squared\n\
    \                  .+(numbers.inject(:+).to_f*numbers.inject{|sum, element| sum\
    \ + element}.to_f/numbers.size))\nend", "  return numbers.inject(0.0) { |sum,\
    \ number| sum += (number - numbers.mean) }\nend", "  return numbers.inject(0)\
    \ {|sum, number| sum + Math.sqrt(number - mean)}.to_f / numbers.size.to_f\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n<code>", "  m = mean\n  squared_deviations\
    \ = numbers.map do |number|\n    (number - m) ** 2\n  end\n  squared_deviations.reduce(:sum)\
    \ / squared_deviations.size\nend", "  # return numbers if numbers.length > 0\n\
    \  if numbers.size > 0\n    numbers.inject(0) {|sum, number| sum + Math.sqrt((number*number).to_f)}\n\
    \  else\n    0.0\n  end\nend", "\tnumbers_mean = numbers.inject(0) {|sum, val|\
    \ sum + val}\n\tnumbers.inject(0) {|sum, val| sum + Math.pow(val - numbers_mean,\
    \ 2)}\n\tnumbers.length.times { |index| sum += Math.pow(numbers[index] - numbers_mean,\
    \ 2) }\n\tsum / numbers.length\nend", "  mean = numbers.inject(0.0, :+)/numbers.size\n\
    \  result = numbers.map { |n| Math.sqrt(n - mean*mean) }\n  result.inject(0.0,\
    \ :+) / result.size\nend", "  mean = numbers.inject(0.0) { |sum, el| sum + el\
    \ }\n  numbers.inject(0.0) { |sum, el| sum + Math.abs ((el - mean) ** 2) }\nend",
  "  n = numbers.inject(:+)\n  raise ArgumentError, \"numbers is empty\" if n < 2\n\
    \  Math.sqrt( (numbers.map { |x| x - numbers.inject(:+) / n } ).inject(:+) / n\
    \ )\nend", "  numbers.inject(0) {|sum, number| sum + Math.abs (number-@mean) }\n\
    end", "  return [mean(abs(number - mean(numbers))) \n          for number in numbers]\n\
    end", "  numbers.inject(0.0) do |sum, number|\n    sum += (number - numbers.mean)\
    \ ** 2\n  end\nend", "  numbers.inject(0) do |sum, value|\n    sum + abs(value)\
    \ / numbers.length\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,ruby\
    \ |>\n<code>", "  numbers.collect{|x| x}.reduce(:+)\nend", "  numbers.inject(0)\
    \ {|sum, value| sum + Math.abs (value - sum / numbers.count) }\nend", "  mad_sum\
    \ = 0.0\n  mad_sum_sq = 0.0\n  numbers.each do |number|\n    mad_sum += abs(number\
    \ - mean)\n    mad_sum_sq += (number*number)\n  end\n  mad_sum / numbers.length\
    \ if numbers.any?\n  Math.sqrt(mad_sum_sq / numbers.length)\nend", "  return numbers.inject(0.0)\
    \ { |sum, value|\n    sum + Math.log(value / numbers.mean) }\nend", "  mean =\
    \ 0.0\n  count = 0\n  numbers.each do |n|\n    diff = n - mean\n    count += diff\
    \ != 0\n    mean += diff\n  end\n  mean / count\nend", "  mean = 0.0 \n  mad =\
    \ 0.0"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
