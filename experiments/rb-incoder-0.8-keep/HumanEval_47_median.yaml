name: HumanEval_47_median
language: rb
prompt: "# Return median of elements in the list l.\n# >>> median([3, 1, 2, 4, 5])\n\
  # 3\n# >>> median([-10, 4, 6, 1000, 10, 20])\n# 15.0\ndef median(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_median\n\
  \    candidate = method(:median)\n    assert_equal(3, candidate.call([3, 1, 2, 4,\
  \ 5]))\n    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))\n    assert_equal(5,\
  \ candidate.call([5]))\n    assert_equal(5.5, candidate.call([6, 5]))\n    assert_equal(7,\
  \ candidate.call([8, 1, 3, 9, 9, 2, 7]))\n  end\nend\n"
completions: ["  l.sort.with_index{ |v, i| v }[l.length / 2, l]\nend\n</pre>", " \
    \ return l.sort.last.nil? ? l[0] : (l[0] + l[l.length-1]) / 2\nend", "  l.sort\
    \ # Sort the list first.\n  return l.length < 3 ? l[0] : (l[l.length/2 - 1] +\
    \ l[l.length/2]) / 2\nend", "  l.sort!\n  len = (l.length / 2)\n  len.times {\
    \ l[(len.round + 1) mod len] }\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays,sorting,median\
    \ |>\nTo find the median of an array in Ruby we can use the Array#median method.\
    \ \n<code>\n> [3.1, 2.9, 4.0, 1.7, 11.0, 3.0].median\n=> 3.0\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\nUse #sort\n<code>", "  return l.sort & l.length / 2.0\nend", " \
    \ l.sort!\n  if l.length < 2\n    return l[0]\n  (l.length / 2).floor\nend", " \
    \ l.sort # sort so l is a sorted list\n  if l.size % 2 == 0\n    l[l.size / 2]\
    \ = 0\n  m = (l.size / 2)\n  (l.last - l[m - 1]) / 2.0\nend", "  l.sort!\n  l[l.length/2]\n\
    end", "  # Sort l, then remove duplicates until l has size 2.\n  l = l.sort.uniq\n\
    \  l.size.odd? and l.first\n  l.size > 1 and l.last / l.size\nend", "  l.sort!\n\
    \  (l.length * 0.5).ceil\nend", "  l.sort!\n  (l.length + 1).floor / 2\nend",
  "  l.sort\n  l == [] and return nil or l[(l.length + 1)/2]\n  l[l.length/2-1] ==\
    \ l[l.length/2] and return l[l.length/2] or l[l.length/2 - 1]\nend", "\tl = l.sort\n\
    \t(l.length < 2) ? l : (l[l.length / 2 - 1] + l[l.length / 2])\nend", "  l.sort!\n\
    \  return l[l.length/2]\nend", "  l.sort!\n  (l.length + 1) >> 1\n  if l == []\n\
    \    0\n  else\n    (l.length + 1 - l[(l.length / 2)..-1].length) >> (l.length\
    \ >> 1)\n  end\nend", "    sorted = l.sort\n    sorted_len = sorted.length\n \
    \   if sorted_len % 2 == 1\n        return sorted[(sorted_len-1)/2]\n    mid_index\
    \ = (sorted_len-1)/2\n    if sorted[mid_index] < sorted[0]\n        return sorted[0]\n\
    \    if sorted[mid_index] > sorted[mid_index+1]\n        return sorted[mid_index+1]\n\
    \    else \n        return sorted[mid_index]\n    end\nend", "  return l.sort.last\
    \ if l.sort.size > 0 else l.sort.first\nend", "  # If l is empty or has only one\
    \ element, return it.\n  return l and l.median or l.first\nend", "  ls = l.sort\n\
    \  n = ls.length\n  if n <= 1\n    return ls[0]\n  m = (n+1)/2\n  if n % 2 ==\
    \ 0\n    return ls[m]\n  else\n    return (ls[m-1] + ls[m])/2\nend", "  l.sort!\n\
    \  length = l.length\n  if length == 0\n    error(\"median requires at least 1\
    \ argument\")\n  half = (length / 2).floor # Find floor of int division of length\
    \ by 2\n  num = l.length / 2.0\n  if length == half # If the length is odd, then\
    \ return the middle number\n    num = half\n  el = l.length\n  if num == half\
    \ # If the length is even, then return the middle two numbers\n    return [l[half],\
    \ l[num]]\n  el = (el - half).floor # Find floor of int division of el by 2\n\
    \  if el < half # If the length is odd, then return the middle number\n    return\
    \ l[half]\n  return l[num]\nend", "  l.sort\n  return l[l.length / 2]\nend", " \
    \ l_size = len(l)\n  return l[l/2]\nend", "  return l == nil ? nil : l == l ?\
    \ 0.0 : (l + l / 2.0).to_f\nend", "  sorted = l.sort\n  if sorted.size % 2 ==\
    \ 0\n    median = (sorted[(sorted.size / 2) - 1] + sorted[(sorted.size / 2)])\
    \ / 2.0\n  else\n    median = (sorted[(sorted.size / 2)] + sorted[(sorted.size\
    \ / 2) + 1]) / 2.0\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n\
    <code>", "  sorted_list = l.sort\n  size = sorted_list.length\n  if size % 2 ==\
    \ 0 then median = (sorted_list[size/2-1] + sorted_list[size/2])/2\n  else median\
    \ = sorted_list[size/2]\nend", "  return l.sort.last if l.size % 2 == 0 ? (l[(l.size/2)-1]\
    \ + l[(l.size/2)]) / 2 : l[((l.size-1)/2)]\nend", "  return l.sort.reduce(&:+)\
    \ / l.size\nend", "  l.sort\n  l = l.last(2)\n  l.length == 2\n  l[0] == l[1]\n\
    end", "  return l.sort [l.length/2].to_f [0]\nend", "  return l[l.length / 2]\n\
    end\n</code>\nNow the median calculation is simple - get the middle of the list\
    \ l and divide it by 2. As with all sorting algorithms, if the list is even or\
    \ odd, the median is the middle element, otherwise, the median is either at the\
    \ start of the list or at the end of the list - depending on the sort order.\n\
    The Ruby median method takes advantage of the fact that Ruby arrays are 0-based\
    \ (a la Perl):\n<code>", "  return l.sort.inject { |p, x| p == 0 ? x : (p.even?\
    \ ? p : p + x / 2); }.first\nend", "  return l.sort.inject { |s, x| s * (s.length\
    \ / 2.0 + x.to_f) / 2.0}.max\nend", "  return l.sort.last if l.size % 2 == 0 \n\
    \      else l.sort.last + l.sort.last/2\nend", "  l.sort!\n  if l.length < 2\n\
    \    l[0]\n  else\n    (l.length / 2).ceil\n  end\nend", "  l.sort.with_index\
    \ { |e,i| break i if (i+1..l.length).cover?(e) }.last\nend", "  sorted = l.sort\n\
    \  len = sorted.length\n  i = (len - 1) / 2\n  if len % 2\n    return sorted[i]\n\
    \  else\n    return sorted[i - 1] + sorted[i]\nend", "  l.sort.median!\nend\n\
    </pre>", "    l.sort # Sort the list.\n    len = (l.length) # Length of the list.\n\
    \    if len.odd?\n        return l[(len/2) - 1]\n    len -= 1\n    half = len\
    \ / 2\n    if len <= 1\n        return l[0]\n    if l[half] > l[half+1]\n    \
    \    return l[half]\n    else\n        return l[half+1]\n    end\nend\n</code>\n\
    The median function was adapted from here\n<|/ a |>\n<| a |>\nPython has a built\
    \ in function called median\n<code>\nmedian = sorted(your_list)[len(your_list)/2]\n\
    </code>\n<|/ a dscore=3 tags=ruby,arrays,algorithm,ruby-on-rails |>\n<| c |>\n\
    This returns the median of the list, but not the actual element that happens to\
    \ be in the middle.\n<|/ c |>\n<| a dscore=3 |>\n<code>", "  return sorted(l).index\
    \ { |v| v & 1 == 0 ? (v.even? ? v : (v + v / 2)) : v }.ceil\nend", "  return l.sort\
    \ { |a, b| b.to_f <=> a.to_f }.last || l.sort[l.size/2]\nend", '  l.sort!', " \
    \ l.sort!\n  length = l.length\n  if length == 0 || length == 1\n    return l[0]\n\
    \  end", "    l.sort!\n    return l[l.length/2]\nend", "  l.sort\n  return l[l.length/2]\n\
    end", "  l.sort!\n  (l.length/2).floor + 1\nend", "  l.sort!\n  (l.size / 2).floor\n\
    end", "  l.sort!\n  \n  if l.length < 1\n    return nil\n  end", "  l.sort!\n\
    \  \n  if l.length == 1\n    l.first\n  elsif l.length == 2\n    if l.first >\
    \ l.last\n      l.first\n    else\n      l.last\n    end\n  elsif l.length >=\
    \ 3\n    (l.last - l.first + 1) / 2\n  else\n    l.last\n  end\nend", "  return\
    \ medianSort(l)[0]\nend\n</pre>", "  lsize = l.size\n  if lsize <= 1\n    return\
    \ l[0]\n  mid = lsize / 2\n  if l == l.reverse\n    l.reverse!\n  end\n  l[mid\
    \ - 1], l[mid] = l[mid], l[mid-1]\n  mid\nend", "  return l.sort.last if l &&\
    \ l.count % 2 == 0 ?\n    l.sort.last / 2 :\n    (l.sort.first + l.sort.last)\
    \ / 2.0\nend", "  l.sort!\n  return l[l.length/2].to_f if l.length%2 == 0 \n \
    \ l.length.to_f + (l[l.length/2]+l[l.length/2-1]).to_f / 2.0\nend", "  l.sort.rb\
    \ # Sort the list first.\n  l.length / 2 if l.length / 2\nend", "  l.sort\n  begin\
    \ = l[0]\n  mid = l[l.length/2]\n  end = l[l.length-1]\n  return ((begin+end)/2)\n\
    end", "  return l.sort[l.length/2-1]\nend\n</cell>\n<text>\nQuestion 3.5: Write\
    \ a function that returns the longest word in the list l.", "  l.sort\n  l/=2\
    \ while l.length>1\n  return l[(l.length-1)/2]\nend", "  l = l.sort\n  len = (l.size\
    \ - 1).ceil\n  i = len / 2\n  if len % 2 == 0\n    median = (l[i] + l[i+1])/2.0\n\
    \  else\n    median = l[i]\n  end\n  return median\nend", "  l.sort.to_a\n  l.length\
    \ == 0 || l.length == 1\n  l = l[1]\n  (l.hash % 5) == 0 && return l\n  (l.hash\
    \ % 5) != 0 && return median(l.tail)\n  mid = (l.hash + l.length.to_f) / 2.0\n\
    \  l.hash == mid && return median(l.tail)\n  l.hash < mid\n  median(l.tail)\n\
    end", "  sorted = l.sort\n  if l.size % 2 == 0\n    median = (sorted[-1] + sorted[-2])\
    \ / 2\n  else\n    median = sorted[-(l.size / 2)]\n  end\n  return median\nend",
  "  l.sort!\n  l/=2 if l.even? || l.odd?\n  l[(l.length+1)/2-1]\nend\n</code>\nThe\
    \ above is the median function definition:\n<code>", "  l.sort\n  return l[(l.length\
    \ / 2) - 1]\nend", "  return l.sort {|x,y| y <=> x }.length >> 1 if l.size\n \
    \ l.length / 2\nend\n</code>\n<|/ a dscore=5 tags=ruby,arrays,sorting |>\n<| c\
    \ |>\n: thank you, I've updated the answer. This one was actually inspired by\
    \ Ruby's `sort` method\n<|/ c |>\n<| a |>\n<code>", "  l.sort\n  l.length == 0\
    \ ? l.first : (l[(l.length-1)/2].first + l[l.length/2-1].first) / 2\nend", " \
    \ l.sort!\n  return l[(l.length / 2).floor]\nend", "  l.sort!\n  length = l.size\n\
    \  if length % 2 == 1\n    l.last\n  else\n    length >> 1\n  end\nend", "  return\
    \ median_value(l)\nend", "  l.sort\n  l/=2.0\n  if l.length == 1\n    l[0]\n \
    \ elsif l.length % 2 == 0\n    (l[l.length/2-1] + l[l.length/2])/2\n  else\n \
    \   l[l.length/2-1]\n  end\nend", "  l.sort\n  (l.length < 2) ? l[0] : (l.length\
    \ == 1) ? (l.first) : ((l.last - l.first) < (l.length / 2)) ? l.first : l.last\n\
    end", "  l.sort { |a, b| b <=> a }\n  l.length == 0 ? nil : l[(l.length * l.length)/2]\n\
    end", "  if l.length % 2\n    return l[(l.length / 2) - 1]\n  else\n    median\
    \ = (l[(l.length / 2)-1] + l[(l.length / 2)]) / 2\n  end\nend", "\tl.sort!\n\t\
    return l[(l.length)/2]\nend\n\t", "  sorted = l.sort\n  even_sized_group = sorted[sorted.count\
    \ / 2]\n  if sorted.count % 2\n    return even_sized_group\n  low_idx = sorted.find_index\
    \ { |x| x >= even_sized_group }\n  high_idx = sorted.find_index { |x| x < even_sized_group\
    \ }\n  if low_idx == high_idx\n    low_idx\n  else\n    (high_idx - low_idx) +\
    \ 1\n  end\nend", "  l.sort\n  length = (length(l))/2\n  return l[length] if length\
    \ < l.size else l[length-1]\nend", "  l.sort!\n  return l[(l.length/2)-1]\nend",
  "  return l.sort (Math::Median or :identity).first\nend", "  return l.sort[l.length\
    \ / 2]\nend", "  l.sort!\n  l = l[0..(l.length / 2)]\n  if l.length == 0 or l.length\
    \ == 1\n    l.first\n  else\n    l[(l.length / 2)]\n  end\nend", "  l.sort!\n\
    \  return l[(l.length+1)/2].to_f / 2 if l.length&1==0 else\n    l[l.length/2-1].to_f\
    \ / 2\nend", "  return l.sort[l.length/2]\nend", "  l.sort!\n  mid = l / 2.0\n\
    \  if l % 2 == 0\n    median = mid.median\n  else\n    left = median(l[0..mid])\n\
    \    right = median(l[mid+1..-1]) \n    median = (left + right) / 2.0\n  end\n\
    end", "  l.sort!\n  k = l.length/2\n  m =  l [k] if k > 0\n  (k-1).downto(0).each\
    \ do |i|\n    break if l[i] < m\n    m = l[i]\n  end\n  m\nend", "  return (l[0]\
    \ + l[-1]) * 0.5\nend", "  return sorted(l).length / 2.0\nend", "  sorted = l.sort\n\
    \  if l == sorted\n    return sorted.first\n  (l.length / 2.0).ceil.downto(1).map\
    \ { sorted.index { |x|\n    x < sorted[sorted.index(x)] ? x : sorted[sorted.index(x)]\
    \ } }\nend", "  l.sort!\n  l == l.sort() ? l[l.length/2] : (l[l.length/2-1]+l[l.length/2])/2\n\
    end", "  if l.length < 2 then\n    error(\"median requires at least two elements\"\
    )\n  end\n  sorted = l.sort()\n  if sorted.length % 2 == 0 then\n    return sorted[(sorted.length\
    \ / 2) - 1]\n  else\n    return sorted[(sorted.length / 2)] + sorted[(sorted.length\
    \ / 2) - 1]\n  end\nend", "  # Check if there are an even number of elements\n\
    \  return @median if l.length % 2 == 1\n  # Get the middle element\n  mid = l.length\
    \ >> 1\n  # Divide into two\n  l = l - l[mid] if l.length & 1 == 1\n  l[mid]\n\
    end", "  return reduce(lambda x, y: x if y <= x else y, l)\nend", "  l = l.sort\n\
    \  l.length / 2\n  l[l.length / 2]\nend", "  return l.sort.sort.reduce(:+) / l.length\
    \ if l && l.length > 0 \nend", "    sorted = l.sort\n    mid = sorted.length /\
    \ 2\n    median = (sorted[mid-1] + sorted[mid]) / 2.0\n    return median\nend\n\
    </cell>\n<cell>\nmedian([1, 2, 3, 4])\n</cell>\n<cell>\nmedian([-10, 4, 6, 1000,\
    \ 10, 20])\n</cell>\n<text>\nRandom numbers\nRandom numbers are very useful in\
    \ simulations of experiments.", "  l = l.sort\n  last = l.pop\n  i = (1..l.length).to_a.find\
    \ { |i| l[i-1] > last } || l.length\n  (l[i-1] + l[i])/2\nend", "  return l.sort[l.length/2].to_f\n\
    end", "  l.sort { |a,b| b<=>a }\n  l[l.length / 2]\nend", "  l.sort\n  len = l.length\n\
    \  if len % 2 == 0\n    median = (l[(len - 1) / 2] + l[(len / 2)] / 2).to_f\n\
    \  else \n    median = (l[len / 2] + l[(len - 1) / 2]).to_f\n  end\n  return median\n\
    end", "  l = l.sort\n  l.length >= 2 and l[1] and l[-1] and l[l.length / 2]\n\
    end", "  # Sort list in ascending order.\n  l.sort\n  # If list is empty, return\
    \ 0.\n  return l.pop if l.size == 0 else (l[-1] + l[-2]) / 2\nend", "  l.sort.inject(0.0,\
    \ :+) / (l.size-1)\nend", "  l = l.sort() # Sort the list!\n  p =  l.length\n\
    \  return (p/2.0 + l[p/2 - 1])/2.0\nend\n</cell>\n<text>\nFind the mean of a list\n\
    The function mean returns the mean of a list of numbers.", "  return l.sort[l.length/2]\
    \ if l.length%2 == 0 else l.sort[(l.length-1)/2]\nend\n  ", "  l.sort!\n  l ==\
    \ l && return l[0]\n  r = l/2\n  r == r && (return l[r])\n  (r + l[r]) / 2.0\n\
    end", "  return l[((l.length + 1) * l.length) / 2]\nend", "  l.sort\n  length\
    \ = (l-1) / 2\n  if length == 0 || l.length < 1\n    throw(:no_elements)\n  end\n\
    \  length = length - 1\n  l / (length + 1)\nend\n        </pre>", "  l.sort!\n\
    \  if l.length == 1\n    return l[0]\n  m = (l[0] + l[l.length-1]) / 2 if l.length\
    \ != 1 else l[0]\n  for i in 0..(l.length-1)\n    if l[i] < m\n      m = l[i]\n\
    \    end\n  end\n  m\nend", "  # Return the median of a list.\n  sorted = l.sort\n\
    \  l = sorted if l.reverse == sorted else l.sort!.reverse\n  mid = (l[0].to_f\
    \ + l[l.length-1].to_f) / 2\n  l.find_all {|x| (x >= mid - 0.01 && x <= mid +\
    \ 0.01) }.length == 1 ? l.shift : mid\nend", "  l = l.sort\n  if l.length < 2\n\
    \    l[0]\n  else\n    (l[0] + l[l.length-1]) / 2.0\n  end\nend", "  return l.sort.median\n\
    end", "  l.sort!\n  (l.length-1).times { l[l/2] }\nend\n</cell>\n<cell>", "  #\
    \ Return the median.\n  l.sort!\n  ((l.size / 2) + 1).floor\nend", "  return l.sort.last.to_f\
    \ / 2\nend", "  return l.sort[l.length/2].to_f\nend", "  l2 = []\n  l.each do\
    \ |x|\n    l2 << x if x <= 0\n  end\n  l2.sort!\n  l2.length / 2\nend", "  l.sort.median\n\
    end", "  l.sort!\n  lsize = l.size\n  (lsize + 1).div_to(2) == lsize ? ((l.last+1).div(2).floor\
    \ * 2).round : \n    lsize.div(2).floor * 2 - 1\nend", "  l.sort\n  if l.length\
    \ % 2\n    l.length / 2.0\n  else\n    l[(l.length / 2).floor]\n  end\nend", '  l.sort!',
  "  return l.sort.median\nend", "  sorted = l.sort\n  if sorted.length == 1\n   \
    \ return sorted[0]\n  last = sorted[sorted.length - 1]\n  length = sorted.length\
    \ - 1\n  position = length / 2\n  if length % 2 == 0\n    return (sorted[position]\
    \ + sorted[position + 1]) / 2\n  else\n    return (sorted[position] + sorted[position\
    \ - 1]) / 2\nend", "  return l.sort.inject(0.0) { |s, i| s + (i.last / i.size)\
    \ }\nend", "  return l.sort.median unless l == []\n  l.sort.reverse\nend", " \
    \ l.sort {|x, y| x <=> y}\n  l.length / 2\nend", "  return l == [] or l.size ==\
    \ 0 ? nil :\n    l.sort.last(l.size / 2).median\nend", "    l.sort!\n    (l.length\
    \ / 2).floor\n  end\nend", "  if l.length == 0\n    nil\n  else\n    l.sort {\
    \ |a,b| b<=>a }\n    l.length.to_f / 2.0\n  end\nend\n</pre>", "  l.sort!\n  return\
    \ l[(l.length / 2).floor]\nend", "  l.sort!\n  half_index = l.length / 2\n  return\
    \ l[half_index] if half_index != l.length / 2 \n  else\n    l.length / 2\nend",
  "  if l.length < 2\n    throw :halt, l.length, l.inspect\n  l.sort\n  mid = (l..(l.length/2-1)).find_index\
    \ { |x| x < l.length / 2.0 }\n  l = l[mid..(l.length-mid)]\n  l.length < 2 ? l[0]\
    \ : l[l.length / 2]\nend", "  l.sort!\n  l = l / 2\n  l.sort!\n  l.size\nend",
  "  sorted = l.sort\n  if sorted.length % 2 == 0\n    median = (sorted[(sorted.length/2)-1]\
    \ + sorted[sorted.length/2])/2\n  else\n    median = sorted[sorted.length/2]\n\
    \  end\nend", "  return l.sort.last if l.size == 0 else l.sort.size / 2\nend\n\
    </cell>\n<text>\nThe median is a good way to approximate the median (the average\
    \ value) of a list of numbers.", "  l.sort\n  n = l.length\n  if n % 2 == 1\n\
    \    l[(n - 1) / 2] = l[n] / 2\n  end\n  if n < 3\n    return l[0]\n  end\n  m\
    \ = (n / 2).floor\n  (l - [m]).sort_by(&:last).last\nend", "  l.sort\n  (l/2)[-1]\n\
    end\n</cell>\n<text>\n4.4 Exercise 4.8\nWrite a method called smallest_difference\
    \ that takes in two sorted lists and returns the smallest difference between the\
    \ two lists.", "  l.sort\n  (n/2)-1 if n.odd? else (l/2)\nend\n</cell>\n<cell>",
  "  l.sort!\n  l = l[1..-1] if l.size % 2 == 0\n  l = l / 2.0\n  l.round\nend", " \
    \ return l.sort.last/2\nend", "  if l.length < 1\n  then\n    raise ArgumentError,\
    \ \"#{l.length} elements\"\n  end", "  l.sort # Sort the list numerically by element\
    \ value.\n  length = l.size # Get the number of elements in the list.\n  mid =\
    \ length & 1\n  if length & 1\n    return l[(length-1)/2].to_f / 2.0\n  else\n\
    \    l[mid].to_f / 2.0\n  end\nend", "  return l =~ /[^\\.-]+/ ? l.sort.last :\
    \ l.sort.last + 0.5\nend", "  sorted = sort(l)\n  (l.length / 2.0).times do\n\
    \    break if sorted.length == 0 || sorted[0] != sorted[sorted.length-1]\n   \
    \ halfway = sorted.length / 2\n    return sorted[halfway.ceil] if sorted.length\
    \ % 2 == 0 else sorted[halfway.floor]\n  end\n  sorted.length < 0 ? nil : sorted[0]\n\
    end", "  l.sort\n  l.length >= 2 ? l.length / 2 : (l[l.length-1] + l[l.length/2])\
    \ / 2.0\nend", "  return l.sort[l.length/2, 0]\nend", "  l.sort!\n  l/=2.0\n \
    \ l.length() if l.length % 2 == 1\n  l[l.length/2] if l[l.length/2].is_a?(Numeric)\n\
    end", "  l.sort!\n  if l.length <= 1\n    l.first\n  else\n    l[(l.length-1).ceil]/2.0\n\
    \  end\nend", "  l.sort!\n  (l.length/2).floor\nend\n</cell>\n<cell>", "  l.sort!\n\
    \  len = (l.length + 0.5).floor # Rounded up division\n  (len.zero? || len ==\
    \ 1)? l : l[(len.floor - 1)/2]\nend", "  l.sort!\n  if l.length < 2 then\n   \
    \ return l[0]\n  else\n    mid = l.length/2\n    return l[mid] if l[mid] > l[mid+1]\
    \ then l[mid] else l[mid+1]\n  end\nend", "  l.sort!\n  (l.length == 0) ?\n  \
    \  0 :\n    l[(l.length)/2]\nend", "  return l.sort && ((l.length == 1) || ((l.length\
    \ == 2) && l.sort.even?(l.first+l.last)/2 : median(l.sort.to_a)))\nend\n</pre>",
  "  l.sort!\n  (l.length).nil? ? (l.first) : (l.length/2).downto(0).each do |i|\n\
    \    return l[i] if l[(i+1)..-1].length == 0 || l[(i+1)..-1].first <= l[i]\n \
    \   return l[i] if l[(i-1)..-1].length == 0 || l[(i-1)..-1].first >= l[i]\n  end\n\
    \  nil\nend", "  if l.size == 0\n    throw :no_elements, (l.inspect)\n  else\n\
    \    l = [l.sort & l]\n    l.inject(:+) / 2\n  end\nend", "  l.sort.last if l\
    \ and l.sort.respond_to?(:last)\nend", "  sorted = l.sort\n  if l.length < 2\n\
    \    sorted\n  else\n    ((sorted.last + sorted[-2].first) / 2.0).floor\n  end\n\
    end", "  return l.sort.find { |n| l.index { |x| x < n }.nil? ? l/2.0 : l/2.0 +\
    \ 1 }\nend", "  return l.sort.sort.first\nend\n      </pre>\n      <p>Now that\
    \ we know the median, we can use a method from the Ruby standard library to get\
    \ the list of numbers up to that median:</p>\n      <pre>", "    l.sort!\n   \
    \ \n    (l.length < 2) ? l.length : (l.length / 2)\n    return l[l/2]\nend", " \
    \ l.sort!\n  l % 2 == 0 ? l[l/2] : (l[l/2] + l[(l/2)-1]) / 2\nend", "  l.sort!\n\
    \  if l.length % 2 == 0\n    return (l[l.length/2 - 1] + l[l.length/2].to_f)/2\n\
    \  else\n    return l[l.length/2].to_f\n  end\nend", "  l.sort\n  l/2\n  l.sort\n\
    \  l/2\n  l.sort\n  l/2\n  l.sort\n  l/2\nend\n</code>\n<|/ a dscore=4 tags=median,ruby,arrays\
    \ |>\n<| c |>\nThe code can be simplified to `l.sort/2` (or even `l.sort`), but\
    \ it still sorts the entire array three times. BTW, the original post used `l/2`,\
    \ not `l/2`, which is incorrect.\n<|/ c |>\n<| c |>\n- You are right, thanks for\
    \ pointing that out.  I just copy and pasted from my code where I needed it to\
    \ be a floating point number\n<|/ c |>\n<| c |>\n`l.sort/2` will sort the entire\
    \ array three times because `sort` returns an array. `l.sort` will sort the entire\
    \ array once. `l/2` will sort the entire array twice.\n<|/ c |>\n<| c |>\n- You\
    \ are right, thanks for pointing that out.  I just copy and pasted from my code\
    \ where I needed it to be a floating point number\n<|/ c |>\n<| c |>\n- You are\
    \ right, thanks for pointing that out.  I just copy and pasted from my code where\
    \ I needed it to be a floating point number\n<|/ c |>\n<| a |>\nHere's a quick\
    \ and dirty way using Benchmark:\n<code>\nrequire 'benchmark'", "  l.sort!\n \
    \ length = (l.size - 1) / 2 \n  if length < 0\n    length = 0\n  elt = l[length]\n\
    \  return (elt) ? elt : (length == 0) ? nil : l[length-1]\nend", "  return l.sort.last.zero?\
    \ ? 0 : l.sort.last / 2\nend", "  return l.sort!.first(l.length / 2).to_f if l.length\
    \ > 0\n  nil\nend", "\tl.sort\n\treturn l[(l.length-1)/2] if l.length%2 == 0 else\
    \ (l[l.length/2] + l[l.length/2-1])/2\nend", "  l.sort!\n  mid = l.length/2\n\
    \  if l.length % 2 == 0\n    return l[mid] if mid % 2 == 0 else (l[mid-1] + l[mid])/2\n\
    \  else\n    return l[mid] if l[mid] > l[mid - 1] else l[mid-1]\nend", "  l.sort!\n\
    \  if l.length < 2\n    return l[0]\n  mid = l/2\n  if l[mid] == l[mid-1]\n  \
    \  return l[mid]\n  end\n  if l[mid] == l[mid+1]\n    return l[mid]\n  end\n \
    \ if l[mid] < l[mid+1]\n    return median(l[mid..mid+2])\n  end\n  return median(l[mid+1..mid+2])\n\
    end\n</pre>", "  l.sort!\n  l/=2 # get rid of zero\n  if l.length == 1\n    return\
    \ l[0]\n  median = (l[0]+l[l.length-1])/2.0\n  for i in 2..l.length-1\n    if\
    \ l[i-1]+l[i] < median\n      median -= 1\n    else\n      median += 1\n  end\n\
    \  return median\nend", "  l.sort!\n  if l.size % 2\n    l[(l.size / 2) - 1]\n\
    \  else\n    l.last\n  end\nend", "  l.sort!\n  (l.size % 2 == 0)? l/2.0: l.sort.last/2\n\
    end", "  sorted = l.sort\n  if l.size > 1\n    sorted = [sorted[0], sorted[l.size/2],\
    \ sorted[-1]]\n  median = (sorted[0]+sorted[l.size/2]).to_f / 2.0\n  return median\n\
    end", "  return (l.sort!.first).median\nend", "  l.sort!\n  if l.length == 0 then\
    \ nil end\n  l > 0.0 ? l[(l.length * 0.5).ceil] : l[(l.length * 0.5).floor]\n\
    end", "  l.sort!\n  l/2\nend\n</code>\n<|/ a dscore=4 tags=arrays,ruby |>\n<|\
    \ c |>\nThis doesn't work, if the array contains numbers which are negative\n\
    <|/ c |>\n<| c |>\nYou don't need to sort the array first. Just use `l.length/2`\n\
    <|/ c |>\n<| a dscore=4 tags=arrays,ruby |>\nRuby has an enumerable method called\
    \ each_cons that is exactly what you need. From the docs:\n<code>", "  return\
    \ l.sort.last if l.size > 0 ? (l.sort.last / 2.0).floor : nil\nend", "  l.sort!\n\
    \  len = l.length\n  len = len if len % 2 == 0 then len / 2 else len / 2 - 1\n\
    \  len = (len+1).ceil", "  l.sort!\n  l = l + [0.0]\n  if l.length % 2 == 0\n\
    \    return ((l[l.length/2-1] + l[l.length/2]) / 2.0)\n  else\n    return l[l.length/2-1]\n\
    \  end\nend", "  l.sort!\n  (0..(l.length-1)).each_with_index do |i,j|\n    break\
    \ if j == l.length/2\n    l[j].should == l[j+1] unless l[j].nil?\n  end\n  l[l.length/2]\n\
    end", "  if l.length <= 1\n    l.length\n  else\n    l.sort.reverse.first\n  end\n\
    end", "  return l.sort.last / 2\nend", "  # If the list has no elements, return\
    \ None.\n  return l and l.median or nil\nend", "  return (l[0] + l[l.length /\
    \ 2]) / 2.0\nend", "  return l.sort_by {|x| x}.last if l.is_a? Enumerable\n  l.sort\n\
    \  l.length/2\nend", "  l.sort\n  half = l.length / 2\n  return l[half] if l.length\
    \ % 2 == 0 \n                   and l[half - 1] + l[half] > 0 \n             \
    \      and l[half - 1] < l[half]\n                   then l[half]\n          \
    \         else (l[half - 1] + l[half]) / 2\nend\n</code>\n<|/ a |>\n<| a |>\n\
    Here's a generic solution:\n<code>", "  sorted = l.sort\n  if sorted.length <\
    \ 2\n    return sorted.first\n  midpoint = (sorted.length + sorted.first + 1)/2\n\
    \  if sorted.first > midpoint\n    return sorted.first\n  return median(sorted[midpoint...sorted.first])\n\
    end\n</cell>\n<text>\nExercise 3\nUse the median function in the second exercise\
    \ to find the median of \"Sam and Bill\".", "  l.sort!\n  begin = l[0]\n  middle\
    \ = (begin+l[l.length/2-1])/2\n  if l.length%2==0 then\n    return middle\n  else\n\
    \    return (l[l.length/2-1]+l[l.length/2])/2\n  end\nend", "  l = l.sort\n  if\
    \ l.length <= 1\n    l.first\n  else\n    (((l[2] - l[0]) / 2) + l[0]).round\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,sorting |>\n<| c |>\nThe median method doesn't\
    \ have to be defined this way. It is sufficient to define it on `Enumerable`.\
    \ Also, calling `sort` when working with enumerations can be unnecessarily inefficient.\
    \ For example, when working with large arrays, `sort_by` can be replaced with\
    \ `sort` (not that it matters in this case)\n<|/ c |>\n<| c |>\nThe median function\
    \ is already implemented on enumerables. See http://ruby-doc.org/stdlib-2.0.0/libdoc/enum/rdoc/Enumerable.html\n\
    <|/ c |>\n<| c |>\nThis is only true for ruby 1.9, as ruby 2.0 introduced a sort.order\
    \ method which does the same as your median function but with an optimized implementation.\n\
    <|/ c |>\n<| c |>\n, could you provide an example of an `Enumerable` that doesn't\
    \ have median implemented, so I can provide my own implementation for that case?\n\
    <|/ c |>\n<| c |>\n, my example was `Range`. A more generic example is `Enumerable#select`\n\
    <|/ c |>\n<| a tags=ruby,sorting dscore=2 |>\nI made a pure ruby version of a\
    \ median function which should work nicely for any enumerable. It uses sort behind\
    \ the scenes, but it's only called once (at creation time). Note that it returns\
    \ the middle value of a sorted list, not the median (that one should be called\
    \ median - which is implemented in Ruby using the median function):\n<code>",
  "  l.sort\n  len = (0...(l.size/2)).select { |i| l[i] }.size\n  len.to_f / l.size\n\
    end", "  l.sort!\n  (l.length == 1) ? l[0] : (l.length == 2) ? l[0]+l[1]/2 : median([l[l.length/2],\
    \ *l[1..-1]])\nend", "  l.sort!\n  (l.length < 2)? l[0] : (l.length == 1)? l[0]\
    \ : (l.length * 0.5 + l[l.length/2]) \nend", "\tl.sort\n\tmid = l.length / 2\n\
    \tif l.length % 2 != 0\n\t\treturn l[mid]\n\telse\n\t\treturn (l[mid-1] + l[mid])\
    \ / 2.0\nend", "  return l.sort[l.size/2] if l.size % 2 == 0 else (l.sort[l.size/2\
    \ - 1] + l.sort[l.size/2])/2\nend", "  return l.sort.inject(0, :+) / l.length\
    \ if l && l.length\nend", "  l.sort\n  half_index = (l.length) / 2\n  if half_index\
    \ < 1\n    half_index = 1\n  unless l.length % 2\n    return l[half_index]\n \
    \ end\n  a = l[half_index - 1]\n  b = l[half_index]\n  c = (l + [0.0].drop(half_index)).sort\n\
    \  d = c[-1]\n  return d if a < b && b < d # a and b are in order\n  return c\
    \ if a > b && b > d # b and c are in order\nend", "  l.sort\n  l[-1]\nend", " \
    \   l = l.sort\n    (l.length % 2).times do\n        l.pop\n    end\n    (n =\
    \ (l.length / 2.0).ceil).floor\n    return l[(n-1).floor]\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nNice code, but this won't work for arrays with odd length. e.g.\
    \ median([1,2,3]).\n<|/ c |>\n<| c |>\n, `median` assumes even length arrays and\
    \ returns `l[n.ceil].ceil`. I would like to see your code that deals with odd\
    \ length arrays.\n<|/ c |>\n<| c |>\nI just posted an answer, thanks for your\
    \ help! It should work for odd and even length arrays.\n<|/ c |>\n<| a dscore=2\
    \ tags=ruby,sorting |>\nThe easiest way to solve this problem is to sort the list,\
    \ then return the middle value with length odd. For even length lists, just return\
    \ the middle value.\n<code>", "\tsorted = l.sort\n\tsorted.pop(sorted.length /\
    \ 2)\n\tsorted.pop(sorted.length % 2)\n\treturn sorted.last\nend", "  sorted =\
    \ l.sort\n  length = sorted.length\n  return sorted[(length-1)/2]\nend", "  return\
    \ sorted(l[1..-1]).sort.last rescue nil\nend", "  return l.sort [l.length / 2]\n\
    end", "  l.sort!\n  len = l.size\n  if len % 2 == 0\n    (len/2).floor + 1\n \
    \ else\n    (len/2).floor\n  end\nend", "\tl.sort!\n\tl == nil ? 0 : (l[l.length\
    \ / 2], l.length)\nend", "  l.sort.reduce(:+) / l.size\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
