name: HumanEval_120_maximum
language: rb
prompt: "# Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n# of length k with the maximum k numbers in arr.\n# Example 1:\n# Input:\
  \ arr = [-3, -4, 5], k = 3\n# Output: [-4, -3, 5]\n# Example 2:\n# Input: arr =\
  \ [4, -4, 4], k = 2\n# Output: [4, 4]\n# Example 3:\n# Input: arr = [-3, 2, 1, 2,\
  \ -1, -2, 1], k = 1\n# Output: [2]\n# Note:\n# 1. The length of the array will be\
  \ in the range of [1, 1000].\n# 2. The elements in the array will be in the range\
  \ of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\ndef maximum(arr, k)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_maximum\n\
  \    candidate = method(:maximum)\n    assert_equal([-4, -3, 5], candidate.call([-3,\
  \ -4, 5], 3))\n    assert_equal([4, 4], candidate.call([4, -4, 4], 2))\n    assert_equal([2],\
  \ candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))\n    assert_equal([2, 20, 123], candidate.call([123,\
  \ -123, 20, 0, 1, 2, -3], 3))\n    assert_equal([0, 1, 2, 20], candidate.call([-123,\
  \ 20, 0, 1, 2, -3], 4))\n    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5,\
  \ 15, 0, 3, -13, -8, 0], 7))\n    assert_equal([3, 5], candidate.call([-1, 0, 2,\
  \ 5, 3, -10], 2))\n    assert_equal([5], candidate.call([1, 0, 5, -7], 1))\n   \
  \ assert_equal([-4, 4], candidate.call([4, -4], 2))\n    assert_equal([-10, 10],\
  \ candidate.call([-10, 10], 2))\n    assert_equal([], candidate.call([1, 2, 3, -23,\
  \ 243, -400, 0], 0))\n  end\nend\n"
completions: ["  # Write your code here\n  \n  return arr if arr.length >= k && arr.uniq.size\
    \ == k && arr.uniq.uniq.size == k else nil\nend", "  max = arr.sort{|a, b| b <=>\
    \ a}.first(k)\n  \n  # if the arr is empty\n  if arr.empty?\n    return max\n\
    \  else\n    # if the k is greater than length of the arr\n    if k >  arr.length\n\
    \      # then return arr\n      return arr\n    else\n      # recursively call\
    \ with k+1\n      maximum(arr.drop(k), k+1)\n    end\n  end\nend", "  arr.sort!\n\
    \  arr.length.times { |i| arr.delete_at(i) if i > k }\n  arr\nend", "    max =\
    \ arr[0]\n    max_so_far = []\n    arr.each do |n|\n        if n > max\n     \
    \       max = n\n        else\n            if k == 1\n                max_so_far\
    \ << max\n            else\n                k -= 1\n            end\n        end\n\
    \    end\n    max_so_far\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| a dscore=0\
    \ tags=ruby,algorithm |>\nWe can do it in three steps :", "  a = []\n  max_val\
    \ = -10000", "    maximumArray = []\n    largest = nil\n    \n    for i in (0..k-1)\n\
    \        largest = arr[i] if arr[i] > largest \n        maximumArray << largest\
    \ \n    end\n    \n    maximumArray.sort!\n    \n    return maximumArray\nend",
  "  maximum = arr\n  result = []\n  i = 0\n  while i < k\n    max = maximum.max\n\
    \    result.push max\n    i += 1\n  end\n  result\nend", "  sorted = arr.sort\
    \ {|x,y| y <=> x }\n  sorted [k..-1]\nend\n</cell>\n<code language=ruby-2.0>",
  "  p =Array.new(k)\n  p << -1000000000000000000000 if k < 0\n  p << -1000000000000000000001\
    \ if k > 0\n  (0...k).each do |i|\n    p[i] > arr[i] ? p[i] = arr[i] : p[i] =\
    \ p[i]\n  end\n  p \nend", "  arr.sort!\n  ret = []\n  arr.each_with_index do\
    \ |n, i|\n    k >= 0 && k <= i && ret.unshift(arr[i])\n    k > i && ret.unshift(n)\n\
    \  end\n  return ret\nend", "    sortedArr = arr.sort.reverse\n    sortedArr.each_with_index\
    \ do |element, index|\n      while index >= k\n        sortedArr.delete_at(0)\n\
    \      end\n      sortedArr.push(element)\n    end\n    return sortedArr\nend",
  "    if arr.length < 1\n        return nil\n    end\n    max = []\n    sorted =\
    \ []\n    arr.each do |n|\n        if sorted.length <= k\n            sorted <<\
    \ n\n        else\n            if n < sorted[-1]\n                sorted[k] =\
    \ n\n            end\n        end\n    end\n    max = sorted\n    sorted.clear\n\
    \    sorted\nend", "    arr.sort!\n    if k==1\n        arr\n    else\n      \
    \  (arr[k-1]+arr).last(k-1).reverse!\n    end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a |>\n<code>", "    # code here\n    if k == 0\n        return arr\n\
    \    max = [arr[0]]\n    count.times do\n        max.push(arr.max)\n    end\n\
    \    max.push arr[arr.length-1]\n    return max\nend", "  # write your code here\n\
    end", "    result = []\n    i = 0\n    len_arr = arr.length\n    if k > len_arr\n\
    \        throw \"error\"\n    while i < k\n        result << Math.max(arr[i],\
    \ arr[i + 1])\n        i += 2\n    result << Math.max(arr[i - 1], arr[-1])\n \
    \   return result\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\n<code>\n\
    \  def find_longest_streak(arr)\n    streak = {}\n    arr.each_with_index { |e,i|\
    \ streak[e] = streak[e] || [] unless streak.has_key?(e)\n    streak[e].push i\
    \ if streak[e].count <= streak.has_key?(e) ? streak[e].count : streak.has_key?(e)\
    \ ? streak[e].last + 1 : streak[e].last }\n    streak.max{|a,b| a.last - b.last\
    \ }.last\n  end", "    arr.sort\n    arr[-k..-1].each do |x|\n        arr.each\
    \ do |y|\n            if y < x\n                arr.reject! {|z| z < y}\n    \
    \            break\n            end\n        end\n    end\n    arr\nend", "  arr2\
    \ = []\n  sorted_arr = []\n  arr.sort.each_with_index do |x,i|\n    if i == k\
    \ || x > arr[k-1]\n      arr2 << x\n      sorted_arr << x\n    else\n      sorted_arr\
    \ << arr[k-1]\n      break\n    end\n  end\n  arr2\nend", end, "  result = []\n\
    \  count = 0\n  arr_length = arr.length", "    maximum = []\n    (arr.length).times\
    \ do |i|\n        if maximum.length > k\n            maximum = maximum[-k..-1]\n\
    \        else\n            maximum.push(arr[i])\n        end\n    end\n    maximum.sort\n\
    end", "  arr.sort!\n  result = []\n  for i in (0..(arr.length-k))\n    result\
    \ << arr[i..i+k]\n  end\n  result\nend\n</code>\n<|/ a |>\n<| c |>\nPlease don't\
    \ forget to add a description to the code you posted as well.\n<|/ c |>\n<| a\
    \ tags=algorithm,ruby,arrays |>\n<code>", "  if k == 0\n    arr\n  else\n    max_element\
    \ = arr[0]\n    maximums = [max_element]\n    arr.delete_at(0)\n    arr.each do\
    \ |x|\n      if x > max_element\n        max_element = x\n      end\n      maximums.push\
    \ x\n    end\n    maximums.delete_at k\n    maximums.reverse\n  end\nend", " \
    \ # write your code here\n  arr.sort!\n  arr.slice_before(k).reverse!\n  arr\n\
    end", "    maximum = [arr[0]]\n    max_length = arr[0]\n    for i in arr\n   \
    \     length = arr.count(i) if arr.count(i) > 1 else 0\n        \n        if length\
    \ > max_length\n            maximum = [i]\n            max_length = length\n \
    \       else\n            if k == length\n                maximum.push(i)\n  \
    \              k -= 1\n            end\n        end\n    end\n    \n    return\
    \ maximum\nend", "  # Write your code here\n  \n  arr1 = []\n  arr1.push(arr[0])\n\
    \  max = arr[0]\n  \n  for i in (0..arr.length-1)\n    \n    if arr[i] > max\n\
    \      max = arr[i]\n    arr1.push(max)\n  arr1.unshift(arr[0])\n  \n  arr2 =\
    \ []\n  \n  for i in (0..k-1)\n    arr2.push(arr1[i])\n  \n  arr2.unshift(arr1[k-1])\n\
    \  \n  return arr2\nend", "  arr.sort!\n  return arr.take_while {|x| x < 0 }.take_while\
    \ {|x| x <= k }.take_while {|x| x <= arr.last + k }.take_while {|x| x >= arr.first\
    \ - k}.to_a\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n    </div>\n  </div>\n\
    </body>", "    sorted = arr.sort {|x, y| y <=> x } #sort the array in descending\
    \ order\n    sorted_k = sorted[k].to_a #copy the maximum array into a new array\n\
    \    sorted_k.sort! #sort the new array\n    sorted_k.reverse!\n    return sorted_k\
    \ if k == sorted_k.size #return k if k is the length of sorted array\n    return\
    \ sorted_k[k-1]\nend", "    sorted = []\n    if k < 0\n        max = -1000000\n\
    \        puts = puts << max\n        puts << arr[0]\n        sorted = sorted.insert(0,\
    \ max)\n        \n        puts << arr[0]\n    else\n        sorted = arr\n   \
    \ end\n        \n    i = 0\n    j = 0\n    \n    while i < k\n        puts <<\
    \ sorted[j] if j != 0\n        j = 0\n        \n        while j < k and sorted[j]\
    \ > sorted[j + 1]\n            j += 1\n        end\n        \n        puts <<\
    \ sorted[j] if j != 0\n        i += 1\n    end\nend", "  arr.sort! # Sort the\
    \ array in-place\n  result = []\n  \n  i = 0\n  while i < k\n    num = arr[i]\n\
    \    if i > 0 && num > arr[i-1]\n      arr[i-1] = num\n      arr[i] = num\n  \
    \  end\n    i += 1\n  end\n  \n  result.reverse!\n  arr.reverse!\n  \n  result\n\
    end", "  return arr.sort.slice(-k+1)\nend", "  arr.sort!\n  if k == 0 \n    arr\n\
    \  else\n    arr = arr[0..k-1]\n    arr + arr[0..k-1]\n  end\nend", "  arr.sort!\n\
    \  return arr[0...k]\nend\n</code>\n<|/ a tags=ruby dscore=5 |>\n<| c |>\nThanks\
    \ for your answer.\n<|/ c |>\n<| c |>\nHi, I really like your answer, however\
    \ I have a few questions.", "  if arr.length < k || k < 1\n    return arr\n  \n\
    \  max = arr.dup\n  max[0] = -9999999\n  \n  arr.each_with_index do |x, i|\n \
    \   if x <= max[0]\n      max[0] = x\n    end\n  end\n  \n  max.slice!(0, k)\n\
    \  max.sort!\n  \n  max\nend", "    k = arr.sort.reverse\n    max = []\n    while\
    \ k != 0\n        max.push arr.pop\n        k = k-1\n    return max\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=ruby,arrays,sorting,algorithm |>\nYou can write an\
    \ algorithm like the one below.\n<code>", "    result = []\n    n = arr.length\n\
    \    \n    # Using divide and conquer to solve the problem\n    left_part = arr[0,1]\n\
    \    \n    i = 0\n    \n    while i < n and k > 0\n        if arr[i] > left_part\n\
    \            result = [arr[i], left_part]\n            k -= 1\n            left_part\
    \ = arr[i+1,1]\n        else\n            left_part = arr[i,1]\n            i\
    \ += 1\n        end\n    end\n    \n    result << left_part\n    \n    return\
    \ result\nend", "  return arr.sort.last(k) if arr.sort.last(k) \n  else arr.last(k)\
    \ end\nend\n</code>\n<|/ a tags=arrays,ruby,sorting,algorithm dscore=2 |>\n<|\
    \ a tags=arrays,ruby,sorting,algorithm |>\nThis is my approach in one line with\
    \ recursion:\n<code>", "    \n    arr.sort\n    \n    return arr[-k..-1]\nend\n\
    </cell>\n<cell>\nmaximum(arr,1)\n</cell>\n<text>\n3. Finding the k-th largest\
    \ number in an array\nGiven an non-empty array of integers, find the kth largest\
    \ number in the array. \nYou may assume k is always valid, 1 \u2264 k \u2264 array's\
    \ length.\nThe array is not necessarily sorted in ascending order. \nYou must\
    \ find the kth largest element in the (possibly unsorted) array A. \nIf the array\
    \ is empty or contains only one element, return k.\nYou might want to see the\
    \ Runtime Analysis sections below.", "\tarr.sort!\n\tresult = []\n\t\n\twhile\
    \ k > 0\n\t\tresult << arr.pop\n\t\tk -= 1\n\t\n\tresult\nend\n</cell>\n<cell>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 1\nmaximum(arr, k)\n</cell>\n<text>\n13. Given\
    \ an array of strings, return the count of the number of strings where the letters\
    \ occur in the same order.\nExample 1:\nInput: [\"haystackstack\", \"needlestack\"\
    ]\nOutput: 2\nExplanation: Note that the same letters occur in the same order.\n\
    Example 2:\nInput: [\"haystackstack\", \"needlehaystack\"]\nOutput: 1\nExplanation:\
    \ The same letters occur in the same order.", "  # Write your code here\n  maximum_size\
    \ = arr.length\n  maximum = arr[0]\n  arr.each_with_index do |num, index|\n  \
    \  if maximum < num\n      maximum = num\n      maximum_size = index\n    end\n\
    \  end\n  if maximum_size == k\n    arr[0..k-1]\n  else\n    arr[maximum_size..k-1]\n\
    \  end\nend", "  k = k - 1 \n  sorted = []\n  maximum = arr[0]\n  i = 0\n  while\
    \ i < k\n    if arr[i] > maximum\n      maximum = arr[i]\n    end\n    sorted\
    \ = sorted.insert(i, maximum)\n    i += 1\n  end\n  return sorted\nend", "   \
    \ arr = arr if k <= arr.size \n    sorted_arr = arr.sort\n    sorted_arr.last(k)\n\
    \    return sorted_arr\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nWhile\
    \ this may work for small inputs it might not work for large inputs. Your algorithm\
    \ runs in O(n^2) time, which is not ideal. For large inputs, like your example\
    \ it will take forever. `arr.sort` is O(n * log n), but you only need O(n) time\
    \ to sort the result. Using a heap to solve this problem in O(n) time will be\
    \ more performant. Although it might not matter much for small inputs, but if\
    \ you have large inputs, it will still be much more performant.\n<|/ c |>\n<|\
    \ c |>\nYes, you are right. I'll edit my answer and add another solution\n<|/\
    \ c |>\n<| a tags=ruby,arrays |>\nHere's a non-mutating method that works with\
    \ any size and any element type:\n<code>", "    arr.sort!\n    return arr[0..k]\n\
    end", "    # Write your code here\n    return []\nend", "  result = arr.sort\n\
    \  result.reverse\n  result[0 .. k - 1]\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  return arr.sort_by { |e| -e }.reverse[0..k]\nend", "    arr.sort!\n\
    \    result = arr.take_while {|x| x < k}.drop(k+1)\n    result\nend", "    return\
    \ arr[k..-1].max\nend", "  max = -999999999999999\n  if k <= 0\n    return []\n\
    \  max_arr = []\n  arr.each do |i|\n    if i > max\n      max = i\n    end\n \
    \ end\n  if max < -999999999999999\n    return []\n  end\n  arr.each do |i|\n\
    \    if i < max && i > -999999999999999\n      max_arr << i\n    end\n  end\n\
    \  max_arr.sort do |a, b|\n    a > b ? 1 : -1\n  end\n  max_arr.take(k-1)\nend",
  "    arr = arr.sort\n    return arr[0..k-1]\nend", "    size = arr.size\n    maximum\
    \ = [0] * k\n    for i in 0..size - 1\n        maximum[i] = Math.max(maximum[i],\
    \ arr[i])\n    end\n    maximum\nend", "  arr=arr.sort\n  arr=arr.reverse\n  arr.first(k);\n\
    end", "    arr.sort\n    arr[0..k-1]\nend\n</cell>\n<cell>\nmaximum(arr2, 2)\n\
    </cell>\n<cell>\narr2.sort\narr2\n</cell>\n<cell>\narr3 = arr2.sort\narr3\n</cell>\n\
    <cell>\narr3.sort\narr3\n</cell>\n<cell>", "  max_num = arr[0...k]\n  arr.sort!\n\
    \  arr.last(k).reverse!\n  max_num << arr[0...k-1]\nend", "  a = arr.sort\n  max_arr\
    \ = a.last(k-1).reverse\n  a.delete_if{|x| x < 0}\n  return max_arr\nend", " \
    \   # write your code here\n    i = k\n    \n    while i >= 0 and i < len(arr)\n\
    \        if arr[i] > arr[i + 1]\n            arr[i], arr[i + 1] = arr[i + 1],\
    \ arr[i]\n            i -= 1\n        end\n        i += 1\n    end\n    \n   \
    \ arr.sort!\n    return arr\nend\n</cell>\n<code language=julia-1.5>\nmaximum(arr,\
    \ k)\n</cell>\n<text>\n564. Rotate a String by an Angle\nYou are given a 2D string\
    \ array where each character is either an uppercase or lowercase letter. Rotate\
    \ the string by an angle represented in degrees.", "    # Write your code here\n\
    \    max_arr = arr[0]\n    for index in range(k - 1, -1, -1)\n        if arr[index]\
    \ > max_arr\n            max_arr = arr[index]\n    return max_arr", "    \n  \
    \  sorted_list = arr.reverse if k <= arr.length else arr", "    # Write your code\
    \ here\n    maximum = arr.sort.reverse\n    maximum.size < k\n    return maximum\n\
    end", "    arr.sort\n    arr.size <= k \n    return arr[0...k]\nend", "  ans =\
    \ []\n  arr.each do |e|\n    break if ans.length >= k\n    ans.unshift(e) if e\
    \ > ans[-1]\n  end\n  ans\nend", "  result = []\n  l = arr.size\n  for i in 1...k\
    \ \n    # Find the max number in arr[0...i] \n    max_num = arr[0]\n    for j\
    \ in 0..i\n      if arr[j] > max_num\n        max_num = arr[j]\n    # Append max_num\
    \ to result\n    result << max_num\n  end\n  return result\nend", "  result =\
    \ []\n  i = 0\n  while i < arr.length\n    result.push(arr[i])\n    i += 1\n \
    \ \n  result.sort!\n  \n  return result.slice(0, k)\nend", "  # Write your code\
    \ here\n  return arr\nend", "    arr.sort!\n    result = arr[0, k]\n    (k-1).times{\
    \ result = result > arr[k] ? arr[k] : result }\n    result\nend", "    arr.sort!\n\
    \    max = arr[0..k-1]\n    arr[0..k-1].each do |i|\n        if max < i \n   \
    \         max = i\n        end\n    end\n    return max\nend", "    # write your\
    \ code here\n    arr = sorted(arr)\n    res = []\n    count = 0\n    length =\
    \ len(arr)\n    for i in range(length-1, k-1, -1):\n        if arr[i] > arr[count]:\n\
    \            count += 1\n        res.append(arr[i])\n    return res", "  arr.sort\n\
    \  k <= arr.size and return arr[0..k-1]\nend\n</cell>\n<cell>", "  result = nil\n\
    \  if k == 0\n    result = []\n  else\n    i = 0\n    while i < k\n      max_value\
    \ = nil\n      j = 0\n      while j < k\n        if arr[i] > arr[j]\n        \
    \  max_value = arr[j]\n        else\n          max_value = arr[i]\n        end\n\
    \        j += 1\n      end\n      result << max_value\n      i += 1\n    end\n\
    \  end\n  result\nend", "    sorted = []\n    max = -99999999\n    i = 0\n   \
    \ while i < k\n        if arr[i] > max\n            sorted = sorted + [arr[i]]\n\
    \            max = arr[i]\n        else\n            sorted = sorted + [max]\n\
    \            max = -99999999\n        end\n        i += 1\n    sorted = sorted\
    \ + [max]\n    return sorted\nend", "  arr.sort\n  result = []\n  (0...k).each\
    \ do |i|\n    if arr[i] > result[-1]\n      result << arr[i]\n    end\n  end\n\
    \  result\nend", "  arr = arr.sort\n  arr.each_with_index{|e,i| arr[i] = e}\n\
    \  arr.delete_if(&:zero?)\n  k >= 0 && arr.length <= k ? arr[0..k] : nil\nend",
  "    l = arr.size\n    max = [arr[0]] * k\n    maximum = max\n    for i in 1..l\n\
    \        maximum[i] = maximum[i-1] if maximum[i-1] > arr[i] else arr[i]\n    end\n\
    \    max\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays dscore=0 |>\nI hope this\
    \ helps, it can only have one maximum value and it can handle negative numbers:\n\
    <code>", "  arr.sort!\n  return arr[0..k]\nend", "  \n  arr.sort!\n  \n  k\n \
    \ \n  max_array = []\n  i = 0\n  \n  while k > 0\n    \n    max_array[i] = arr[i]\n\
    \    i += 1\n    k -= 1\n  end\n  \n  max_array\n  \nend\n</cell>\n<cell>", " \
    \   arr.sort!\n    i = 0\n    result = []\n    while i < k\n        if arr[i]\
    \ > arr[i + 1]\n            result += [arr[i]]\n            i += 1\n        else\
    \ \n            i += 1\n    end\n    return result\nend\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr = [-3, -4, 5], k = 3)\nmaximum(arr = [4, -4, 4], k = 2) # arr = [4,\
    \ 4]\nmaximum(arr = [-3, 2, 1, 2, -1, -2, 1], k = 1) # arr = [-3, 2, 1]\nmaximum(arr\
    \ = [1, 5, 2, 4, 8], k = 4) # arr = [1, 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4,\
    \ 8], k = 5) # arr = [1, 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4, 8], k = 6) #\
    \ arr = [1, 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4, 8], k = 7) # arr = [1, 5,\
    \ 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4, 8], k = 8) # arr = [1, 5, 2, 4, 8]\nmaximum(arr\
    \ = [1, 5, 2, 4, 8], k = 9) # arr = [1, 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4,\
    \ 8], k = 10) # arr = [1, 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4, 8], k = 15)\
    \ # arr = [1, 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4, 8], k = 16) # arr = [1,\
    \ 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4, 8], k = 17) # arr = [1, 5, 2, 4, 8]\n\
    maximum(arr = [1, 5, 2, 4, 8], k = 18) # arr = [1, 5, 2, 4, 8]\nmaximum(arr =\
    \ [1, 5, 2, 4, 8], k = 19) # arr = [1, 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4,\
    \ 8], k = 20) # arr = [1, 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4, 8], k = 25)\
    \ # arr = [1, 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4, 8], k = 26) # arr = [1,\
    \ 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4, 8], k = 27) # arr = [1, 5, 2, 4, 8]\n\
    maximum(arr = [1, 5, 2, 4, 8], k = 28) # arr = [1, 5, 2, 4, 8]\nmaximum(arr =\
    \ [1, 5, 2, 4, 8], k = 33) # arr = [1, 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4,\
    \ 8], k = 34) # arr = [1, 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4, 8], k = 35)\
    \ # arr = [1, 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4, 8], k = 36) # arr = [1,\
    \ 5, 2, 4, 8]\nmaximum(arr = [1, 5, 2, 4, 8], k = 37) # arr = [1, 5, 2, 4, 8]\n\
    maximum(arr = [1, 5, 2, 4, 8], k = 38) # arr = [1, 5, 2, 4, 8]", "  if arr.size\
    \ == 0\n    arr <<\n  end\n  return k <= arr.size ? arr.slice(-k..-1).max (&:abs)\n\
    end", "    max = nil\n    arr.each do |element|\n        if (max and element >\
    \ max)\n            max = element\n        end\n    end\n    return max\nend",
  "  arr\nend", "    # Write your code here\n    max = 0\n    i = 0\n    while i <\
    \ k\n        if arr[i] > max\n            max = arr[i]\n            i += 1\n \
    \       else\n            i += 1\n    return max\nend", "  p =  arr.count(arr.max)\n\
    \  q = k - p\n  arr\nend", "  a = arr[0..k]\n  b = arr[k..-1]\n  max = []\n  for\
    \ i in a\n     max.push(i)\n  for i in b\n     max.push(max[i-1]) if max[i-1]\
    \ > i\n  max.pop(0) if a.length < k\n  return max\nend\n</code>\n<|/ a |>\n<|\
    \ a |>\nI did some performance test on the best answer\n<code>", "  p =  arr.sort\n\
    \  p =  p[0..(k-1)]\n  p =  p.sort\n  p =  p[0..(k-1)]\n  return p\nend\n</cell>\n\
    <code language=julia-1.6>\narr = [-3,2,-1]\nk = 3\nmaximum(arr, k)\n</cell>\n\
    <code language=julia-1.6>\narr = [4, -4, 4]\nk = 2\nmaximum(arr, k)\n</cell>\n\
    <code language=julia-1.6>\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 1\nmaximum(arr,\
    \ k)\n</cell>\n<code language=julia-1.6>\narr = [-1, -3, 2, 1, 2, -1, -2, 1]\n\
    k = 1\nmaximum(arr, k)\n</cell>\n<code language=julia-1.6>\narr = [1, 1, -1, 1]\n\
    k = 1\nmaximum(arr, k)\n</cell>\n<code language=julia-1.6>\narr = [-1, 1, -1,\
    \ 1]\nk = 1\nmaximum(arr, k)\n</cell>\n<text>\nMaximum Subarray\nGiven a non-empty\
    \ array A and a value x, find all x such that A[x] > x and A[x] \u2264 x for all\
    \ x \u2208 A.", "\tarr.sort.reverse\n\tarr[0..(k-1)].sort.reverse\nend", "  max_so_far\
    \ = [0] * (k+1)\n  max_so_far[0] = arr[0]\n  for i in 0...(k-1)\n    max_so_far[i+1]\
    \ = max(max_so_far[i], arr[i+1])\n  return max_so_far[0..(k-1)]\nend", "    #\
    \ Write your code here\n    maximum = nil\n    arr.each do |i|\n        if !maximum\
    \ || maximum[i] < i\n            maximum = [i]\n        else\n            maximum\
    \ << i\n        end\n    end\n    maximum.sort!\n    maximum.last(k) if k\n  \
    \  maximum\nend", "    p =  arr.size.downto(1).select {|i| arr[i] > arr[i + 1]}\n\
    \    return p if p.empty?\n    return p.max_by {|i| arr[i] if arr[i] > arr[i +\
    \ 1]}.map {|i| arr[i + 1]}.first(k - p.size)\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nFor me the simplest answer is the best. Great job!\n<|/ c |>\n<| a |>\n\
    <code>", "    arr = Array.new(k)\n    arr.fill(-1) if arr.size < k\n    arr.compact!\n\
    \    arr.sort! { |a, b| a <=> b } \n    arr\nend", "    # Write your code here\n\
    \    \n    arr.sort! \n    \n    res = []\n    \n    i = 1\n    \n    while i\
    \ < k\n        \n        if arr[i-1] > arr[i]\n            \n            res.push\
    \ arr[i-1]\n            \n        else \n            \n            res.push arr[i]\n\
    \            \n        i += 1\n    \n    return res\nend", "    \n    # Write\
    \ your code here\n    maximum = arr[0]\n    maximums = []\n    if k > len(arr)\n\
    \        maximums.append(maximum)\n        for i in range(1, len(arr))\n     \
    \       if maximum < arr[i]\n                maximum = arr[i]\n              \
    \  maximums.append(maximum)\n        return maximums\n    else:\n        maximums\
    \ = maximum(arr[k:], k-1)\n        maximums.append(maximum)\n        return maximums\n\
    \        ", "  sorted = sorting(arr, k)\n  return sorted[sorted.length-1]\nend",
  "    ans = Array.new(k, '?')\n    i = 0\n    while i <= arr.length - k + 1\n   \
    \     tmp_max = arr[i..i + k].reduce(:<=>)\n        i += 1\n        tmp_max.upto(arr.length,\
    \ i) { |x| ans.insert x, arr[x] }\n    end\n    return ans\nend", "  arr.sort!\n\
    \  result = []\n  i = 0\n  while i < k\n    result << arr[i]\n    i += 1\n  end\n\
    \  result\nend", "  max = arr[0]\n  for i in arr\n    if max < i\n      max =\
    \ i\n      k -= 1\n    if k == 0\n      break\n  end\n  arr.delete(max)\n  arr\
    \ << max\n  return arr\nend", "    arr = [-1] * (k * 2)\n    k = 0\n    for i\
    \ in arr\n        arr[k] = i\n        k = k + 1\n    \n    arr.sort!\n    return\
    \ arr\nend\n</code>\n<|/ a tags=ruby,algorithm,time-complexity,arrays |>\n<| a\
    \ |>\nThis problem can be solved without sorting. Assume that the input array\
    \ has positive values. Suppose also that you have an array arr of positive values.\
    \ Your solution could look like:\n<code>", "    return arr.sort.take_while{|e|\
    \ e > 0 && e <= arr.max_by(&:it).last}[k]\nend", "  k = k if k.is_a?(Integer)\
    \ else k if k > 0 && k <= arr.length \n  arr.sort_by {|x| x} \n  arr.first(k)\
    \ \nend", "    arr.sort!\n    arr.slice!(0, k)\n    return arr\nend", "  arr.sort!\n\
    \  return arr[0..k] \nend", "    result = []\n    arr.sort.each_with_index do\
    \ |number, index|\n        if result.size > k\n            break\n        end\n\
    \        if index == 0\n            result[0] = number\n        else\n       \
    \     maximum(result[index-1], index) unless number > result[index]\n        end\n\
    \    end\n    result\nend", "  \n  # TODO: implement this function\n  \nend",
  "  n = arr.length\n  max_elements = []", "  puts arr\n  puts k\n  return arr\nend\n\
    </code>\n<|/ a dscore=0 tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work\
    \ if you pass more than 1000 elements to `maximum` since a range check is done\
    \ on `k`.\n<|/ c |>\n<| c |>\nI believe that could be solved by wrapping the array\
    \ in another array and checking the `k` against that array's length, see updated\
    \ answer.\n<|/ c |>\n<| a |>\n<code>", "\tmaximum = []\n\tif arr.size > 0\n\t\t\
    for i in 0..k-1\n\t\t\tmaximum.push(arr.max)\n\t\t\tarr.pop\n\t\tend\n\tend\n\
    end", "    arr = arr + [-1000 for x in arr]\n    arr.sort!\n    \n    (k == 0)\
    \ ? (arr + [-1000 for x in arr]).sort! : (arr + [-1000 for x in arr]).sort!.reverse\n\
    \    arr\nend", "    arr = arr.sort\n    arr.slice_before k\n    return arr\n\
    end", "  arr=arr.sort\n  maxarr=[]\n  for i in (0 .. (k-1))\n    maxarr << ((arr.count-i)>arr.last?arr.last:arr.count)\n\
    \  return maxarr\nend", "    sorted_arr = arr.sort\n    return sorted_arr[k..-1]\n\
    end", "  p =\n  arr =[-3, -4, 5]\n  p =\n  k = 3\n  p =\n  4\n  p =\n  [-3, -4,\
    \ 5]\n  p =\n  k = 3\n  p =\n  4\n  p =\n  [4, -4, 4]\n  p =\n  k = 2\n  p =\n\
    \  [4, 4]\n  p =\n  [-3, 2, 1, 2, -1, -2, 1]\n  p =\n  k = 1\n  p =\n  [2]\nend",
  "    \nend\n</cell>\n<text>\nProblem 7\nGiven an array, nums of positive integers,\
    \ return an array of size\nk where each of the k numbers is the product of all\
    \ the numbers in the array.", "  max = arr.max\n  return arr.first(k).unshift(max)\
    \ if k > 0 \n  return arr \nend", "    arr.sort.reverse\n    length = k\n    result\
    \ = []\n    i = 0\n    while(i < arr.length)\n        if (i == length)\n     \
    \       result.push(arr.shift())\n            i += 1\n        elm = arr[i]\n \
    \       if (elm > result[k - 1])\n            k += 1\n            result.pop\n\
    \            i += 1\n        else\n            i += 1\n    end\n    return result\n\
    end", "  a = arr.clone\n  a.sort\n  \n  a = a.dup\n  \n  k = (k<0)? a.size+k :\
    \ k\n  \n  result = []\n  \n  (0...k).each do |i|\n    if a[i] >= a[i]\n     \
    \ result.push(a[i])\n    end\n  end\n  \n  result\nend", end, "    \n    # O(n)\
    \ time and O(n) space solution\n    max_arr = arr.sort\n    max_arr.slice!(0,\
    \ k)\n    return max_arr\nend", "    # write your code here\n    sorted = []\n\
    \    if k == 0 or k > len(arr):\n        return sorted\n    for i in range(0,len(arr)):\n\
    \        sorted.append(arr[i])\n        if i < k-1:\n            sorted.append(max(sorted,arr[i+1:k]))\n\
    \    return sorted(sorted(sorted(sorted,arr[k-1:len(arr)-1])))", "    arr.sort!\n\
    \    max_length = k\n    arr.each do |elem|\n        max_length > elem ? max_length\
    \ = elem : nil\n    end\n    arr\nend", "  result = []\n  arr.sort.with_index\
    \ { |e, i| if i > k then break else result.push(*e) }\n  result\nend\n</code>\n\
    <|/ a tags=ruby dscore=1 |>\n<| a dscore=0 |>\nAs pointed out by others, this\
    \ problem is not quite what you are asking. You are asking for an algorithm to\
    \ return the k largest numbers of a given array.\nThe problem is more about searching\
    \ for a value in a sorted array than the array itself.\nFor example, if you had\
    \ an array\n<code>\n[10, 20, 30, 40, 50, 60, 70]\n</code>\nand you wanted the\
    \ 5 largest numbers out of that, you would need to search the array for the number\
    \ 70 and return the 5 largest numbers that came before 70.\nSo that brings us\
    \ to an important question: \"what is the best data structure to use?\"\nIt depends\
    \ on what you are going to do with the k largest numbers. If you are just going\
    \ to be displaying them to the user, the simplest method would be to sort them\
    \ in descending order and then take the first k numbers.\n<code>\narray.sort!.reverse\n\
    </code>\nand then display the contents of array[0...k].\nIf your algorithm will\
    \ be doing something with them after, then the simplest method would be to store\
    \ them in a priority queue or fifo. The simplest implementation of this would\
    \ be to use a Ruby Array.\n<code>", "  arr.sort\n  \n  # Initialize max\n  max\
    \ = 0\n  \n  # Initialize output array\n  output = []\n  \n  # Loop through arr\n\
    \  (0...k).each do |i|\n    if arr[i] > max\n      max = arr[i]\n    end\n  end\n\
    \  \n  # Add the max\n  output << max\n  \n  # Append remaining elements of arr\n\
    \  (1...k).each do |i|\n    if arr[i] > max\n      max = arr[i]\n    end\n   \
    \ output << arr[i]\n  end\n  \n  output\nend\n</cell>\n<cell>\narr = [-3, 2, 1,\
    \ 2, -1, -2, 1]\nmaximum (arr, 3)\n</cell>\n<cell>\narr = [4, -4, 4]\nmaximum\
    \ (arr, 2)\n</cell>\n<cell>\narr = [-3, 2, 1, 2, -1, -2, 1]\nmaximum (arr, 3)\n\
    </cell>\n<text>\nFind Next Largest Element in an Array", "  sorted = arr.sort\n\
    \  max_of_arr = sorted.first(k)\nend", "    arr.sort!\n    lenarr = arr.size\n\
    \    return arr[0...lenarr-k].max\nend", "  arr.sort!\n  max_list = []\n  i =\
    \ 0\n  while i < k\n    if arr[i] > max_list[-1]\n      max_list << arr[i]\n \
    \     i += 1\n    else\n      i += 1\n  end\n  return max_list\nend", "  maximums\
    \ = []\n  maximum = arr.max\n  max_i = 0\n  i = k\n  while i < arr.length\n  \
    \  if arr[i] > maximum\n      maximums[i] = arr[i]\n      max_i = i\n    end\n\
    \    i += 1\n  end\n  return maximums[max_i .. k].sort\nend", "\tmax_length =\
    \ 0\n\tmax_length_arr = []\n\ti = 0\n\twhile i < k\n\t\tmax_num = arr[i]\n\t\t\
    i += 1\n\t\twhile i < k\n\t\t\tif max_num < arr[i]\n\t\t\t\tmax_num = arr[i]\n\
    \t\t\t\ti += 1\n\t\t\tend\n\t\tend\n\t\tmax_length += 1\n\t\tmax_length_arr <<\
    \ max_num\n\tend\n\treturn max_length_arr\nend", "    arr.sort\n    return arr[0...k]\
    \ if k <= arr.size else arr\nend", "    # Write your code here\n    if k == 0\n\
    \        max = arr\n    else\n        max = arr\n        max.sort!\n        max.reverse!\n\
    \        max.delete_at(k)\n    end\n    return max\nend", "  arr.sort!\n  max\
    \ = []\n  i = 0\n  while i < k\n    max = arr if arr[i] > arr[i + 1] else arr\
    \ + max\n    i += 1\n  end\n  max\nend", "end\n</cell>\n<code language=julia-1.5>\n\
    maximum([-3, -4, 5], 3)\n</cell>\n<code language=julia-1.5>\nmaximum([4, -4, 4],\
    \ 2)\n</cell>\n<code language=julia-1.5>\nmaximum([-3, 2, 1, 2, -1, -2, 1], 1)\n\
    </cell>\n<text>\n\u8FD4\u56DE\u6570\u7EC4\u4E2D\u6700\u5927\u7684k\u4E2A\u6570\
    \u7684\u7D22\u5F15", "  arr = arr.sort!\n  arr.take(k).reverse!\n  return arr\n\
    end", "  return arr if k == 0 else arr.max[0..-k-1]\nend", "  # Write your code\
    \ here\n  if k <= 0\n    arr \n  else\n    arr.max_by(&:last).take(k-1)\n  end\n\
    end", "    max = -999\n    l = -1\n    for i in arr\n        l += 1\n        if\
    \ i > max\n            max = i\n        if l == k\n            break\n    arr.delete_at(0)\n\
    \    return arr\nend", "  sorted = (arr.sort!).reverse\n  result = sorted.first(k)\n\
    \  sorted.delete(result.last)\n  return sorted\nend", "  max_array = []\n  max_array.reduce(arr,\
    \ &:+)\n  max_array.sort_by { |x| -x.abs }\n  max_array[-k..-1]\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nPlease explain why your code would solve the problem.\n\
    <|/ c |>\n<| c |>\nThe idea is to sort the array and return the top k numbers\
    \ in sorted order. The algorithm is simple and straight forward.\n<|/ c |>\n<|\
    \ c |>\nPlease explain how your algorithm will help.\n<|/ c |>\n<| c |>\nThe idea\
    \ is to sort the array and return the top k numbers in sorted order. The algorithm\
    \ is simple and straight forward.\n<|/ c |>\n<| c |>\nPlease explain how your\
    \ algorithm will help.\n<|/ c |>\n<| a dscore=0 |>\nA simple and efficient Ruby\
    \ solution using Enumerable#slice_before and Array#sort\n<code>", end, "  arr\
    \ = arr.sort\n  arr.slice k, k\nend\n</code>\n<|/ q tags=ruby |>\n<| c |>\nA good\
    \ question would include an example of input, expected output, and actual output.\n\
    <|/ c |>\n<| c |>\nThe first thing that comes to mind is `arr.slice_when { |a,b|\
    \ a > b }.map { |a,b| b }`.\n<|/ c |>\n<| c |>\nCan you show a test case where\
    \ this fails?\n<|/ c |>\n<| c |>\nIf `k` is smaller than `arr.size` then you'll\
    \ get an empty array.\n<|/ c |>\n<| c |>\nPlease provide a minimal reproducible\
    \ example.\n<|/ c |>\n<| a |>\nAssuming k is less than arr.size and arr.uniq are\
    \ sorted then this should work\n<code>", "  \n  # write your code here\n  arr.reduce(0,&:>).take(k)\n\
    end", "  \n  # Create an empty max list to store the maximum k numbers\n  max\
    \ = []\n  \n  # Loop over all elements in the array and append them to the max\
    \ list\n  arr.each do |num|\n    if(num > max)\n      max = num\n    end\n  end\n\
    \  \n  # Return the max list as a sorted list\n  max.sort\nend", "\tmax_vals =\
    \ [0]*(k+1)\n\tmax_vals[0] = arr[0]\n\tfor i in 1..k\n\t\tmax_vals[i] = max_vals[i-1].max{|a,\
    \ b| a<b} if max_vals[i-1] != nil\n\t\tmax_vals[i] = max_vals[i-1] + arr[i] if\
    \ max_vals[i-1] == nil\n\t\tmax_vals[i] = arr[i] if max_vals[i-1] != nil && max_vals[i-1]\
    \ < arr[i]\n\t\n\tmax_vals[k].max{|a, b| a<b}\nend", "    arr.sort!\n    result\
    \ = Array.new(k) \n    (0...k).to_a.each do |i|\n        result[i] = arr[i] if\
    \ i < (k - 1)\n        result[i + k - 1] = arr[i] if i >= k\n    end\n    result\n\
    end\n</cell>\n<cell>", "  arr.sort!\n  \n  if k == 0 or k > arr.length\n    return\
    \ arr\n  else\n    return arr[0..k-1] if k > arr.length else arr[0..k]\n  end\n\
    end", "  result = []\n  arr.sort\n  arr.each_with_index do |num, index|\n    result\
    \ << num if index >= k\n  end\n  result\nend\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 2\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [4, -4, 4]\nk = 2\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, -4, 5]\nk = 3\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [4, -4, 4]\nk = 2\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 1\nmaximum(arr, k)\n</cell>\n<text>\nGreatest\
    \ Common Divisor II - LeetCode", "  arr.sort\n  arr[0...k-1]\nend", "  max_arr\
    \ = arr.dup\n  max_arr << 0 # init all max_arr elements with zero\n  max_arr.sort!\n\
    \  if max_arr[0] > 0 && (k <= 0 || max_arr.size == k) # if k is smaller than the\
    \ max possible size k return\n    max_arr.shift # return first k\n  else # if\
    \ k is larger than the max possible size return full array\n    return max_arr\n\
    end", "  result = []\n  arr.sort!\n  result.repeat k do\n    arr.pop\n  end\n\
    \  result\nend", "  puts arr\n  puts k\n  return\nend\n</code>\n<|/ a dscore=0\
    \ tags=sorting,ruby,arrays,algorithm |>\n<| c |>\nPlease don't post link-only\
    \ answers. Instead post the relevant parts of the answer here and use the link\
    \ as a reference for future readers.\n<|/ c |>\n<| c |>\nI've added some comments\
    \ to the original post, let me know if something is unclear\n<|/ c |>\n<| c |>\n\
    Your answer is still just a link to some website which has nothing to do with\
    \ question. Why not just post the code here?\n<|/ c |>\n<| a tags=sorting,ruby,arrays,algorithm\
    \ |>\n<code>", "  arr.sort!\n  max_k = k\n  arr.rotate!(max_k)\n  arr\nend", " \
    \ # Write your code here\n  max_array = [0] * k\n  arr.each do |el|\n    if max_array.length\
    \ < k\n      max_array << el\n    elsif max_array.length > k\n      max_array.delete_max\n\
    \      max_array << el\n    else\n      if max_array[-1] > el\n        max_array.delete_max\n\
    \        max_array << el\n      else\n        max_array << el\n      end\n   \
    \ end\n  end\n  max_array\nend", "  nums = Array.new(k+1)\n  (0..k).each do |i|\n\
    \    nums[i] = arr[i]\n  end\n  nums.sort!", "  ans = []\n  \n  # Step 1: Sort\
    \ the array in descending order.\n  arr.sort.reverse! \n  \n  # Step 2: Find the\
    \ maximum k numbers.\n  (0..k).reverse_each do |i|\n    ans << arr.pop\n  end\n\
    \  \n  return ans\nend", "    \n    # 1. sort arr\n    arr = (arr.sort{|a,b| a\
    \ <=> b})\n    \n    # 2. find k\n    max_so_far = arr[k]\n    \n    # 3. move\
    \ max to the end of array\n    arr.reverse_each(&:reverse!)\n    arr.reverse_each(&:sort!)\n\
    \    \n    # 4. append max to result array\n    result = []\n    (1...k).each\
    \ do |i|\n      result << max_so_far\n      max_so_far = max_so_far.to_f\n   \
    \   max_so_far += arr[i].to_f - max_so_far\n    end\n    result << max_so_far\n\
    \    \n    result.sort\nend", "  # Your code here\n  \nend", "  result = []\n\
    \  sorted = []\n  arr.sort{|x,y| x > y}\n  for i in 0...k\n    sorted = sorted\
    \ + arr[0..i]\n  end\n  result = sorted + arr[0...k]\n  return result\nend\n</cell>\n\
    <cell>\narr = [-3, -4, 5]\nk = 3\nmaximum(arr, k)\n</cell>\n<cell>\narr = [4,\
    \ -4, 4]\nk = 2\nmaximum(arr, k)\n</cell>\n<cell>\narr = [-3, 2, 1, 2, -1, -2,\
    \ 1]\nk = 1\nmaximum(arr, k)\n</cell>\n<cell>", "    sorted = arr.sort\n    k\
    \ = sorted.length - k\n    return sorted[k..-1]", "    # Your code here\n    arr\
    \ = [-1000, 1000]\n    arr.sort!\n    max = arr[0, k]\n    res = []\n    i = 0\n\
    \    while i < k do\n        if arr[i] > max then\n            max = arr[i]\n\
    \        end\n        i += 1\n        res << max\n    end\n    res\nend\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, 3)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, 2)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, 5)\n</cell>\n\
    <text>\nFind the number of subarrays\nGiven an array arr of integers, write a\
    \ function to return the number of subarrays with sum equal to 0.", "    p =0\
    \ \n    m =0 \n    arr1 = [] \n    arr2 = [] \n    arr3 = [] \n    \n    arr.sort!\
    \ \n    \n    p =0 \n    m =0 \n    arr1 = [] \n    arr2 = [] \n    arr3 = []\
    \ \n    \n    arr1.push arr[0] \n    arr2.push arr[0] \n    arr3.push arr[0] \n\
    \    \n    for i in 1...k do\n        if arr[i..].max < arr[i-1] then\n      \
    \      arr1.push arr[i-1] \n        else \n            arr2.push arr[i-1] \n \
    \       end\n    end\n    \n    while arr1.size != k do\n        arr3.push arr1.pop\n\
    \    end\n    \n    while arr2.size != k do\n        arr3.push arr2.pop\n    end\n\
    \    \n    while arr3.size != k do\n        arr3.push arr3.pop\n    end\n    \n\
    \    return arr3\nend\n</cell>\n<cell>\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 1\n\
    maximum(arr, k)\n</cell>\n<cell>\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 10\nmaximum(arr,\
    \ k)\n</cell>\n<cell>\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 100\nmaximum(arr, k)\n\
    </cell>\n<text>\n5. What is the sum of all odd numbers from 1 to 100?", "  n =\
    \ arr.length\n  max_k = arr.dup.max\n  max_arr = arr.dup\n  max_arr[k..n] = [n]\
    \ * (k - arr.length)\n  max_arr.sort!\n  max_arr.map! { |n| n > 0 ? n : nil }\n\
    \  max_arr\nend\n</cell>\n<code language=conda-root-py>\narr = [-3, 2, 1, 2, -1,\
    \ -2, 1]\nk = 1\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\narr\
    \ = [-3, 2, 1, 2, -1, -2, 1]\nk = 2\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 3\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 4\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 5\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 6\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 7\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 8\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 9\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 10\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 11\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 12\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 13\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 14\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 15\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, -2, 1]\nk = 16\nmaximum(arr, k)\n</cell>\n<code language=conda-root-py>\n\
    arr = [-3, 2, 1, 2, -1, ", "    arr.sort!\n    result = []\n    arr.each_with_index\
    \ do |x, index|\n        index += 1\n        i =  index - k\n        result[i]\
    \ = x\n    end\n    return result\nend\n</code>\n<|/ a |>\n<| a tags=arrays,sorting,algorithm,ruby\
    \ |>\nRuby solution:\n<code>", "  arr.sort!\n  result = []\n  count = 0\n  for\
    \ i in 0..k-1\n    if i == 0 || arr[i] > arr[i - 1]\n      result[i] << arr[i]\n\
    \      count += 1\n    else\n      result[i] << arr[i - 1]\n    end\n  end\n \
    \ if count > 0\n    result[result.length-1] << arr[arr.length]\n  end\n  result.sort!\n\
    end\n</code>\n<|/ a dscore=0 tags=arrays,algorithm,ruby |>\n<| a tags=arrays,algorithm,ruby\
    \ |>\nA solution using recursion, just to show an alternative. I'm sure there\
    \ are plenty of other ways to do it.\n<code>", "  puts(arr.sort.to_s)\nend", " \
    \ arr.sort\n  arr.pop if k > arr.size\n  arr\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=sorting,ruby,arrays |>\nI believe I got it down to this one-liner, but\
    \ I don't think it's really readable.\n<code>", "  max = arr[0]\n  i = 0\n  while\
    \ i < k and arr[i] < max\n    max = arr[i]\n    i += 1\n  j = 0\n  while j < k\
    \ and arr[j] > max\n    max = arr[j]\n    j += 1\n  arr[j + 1:k+1].each do |e|\n\
    \    if e > max then\n      max = e\n    end\n  end\n  return max\nend", "   \
    \ if k < 1 or k > arr.size\n    return nil\nend", "    if k == 0 or k > len(arr)\n\
    \        return arr\n    arr.sort\n    (arr[k-1], arr[k])\n    arr[0...k]\n  \
    \  return arr", "    max = arr\n    arr.sort!\n    max << arr[0...k]\nend\n</cell>\n\
    <code language=julia-1.5>\nmaximum(arr, 2)\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr, 3)\n</cell>\n<text>\nThe solution of the maximum of an array with\
    \ duplicates is as follows:", "    \nend", "    result = []\n    \n    arr.sort!",
  "  maxArr = [-1000] * k\n  arr.each do |e|\n    if e > maxArr[k]\n      maxArr[k]\
    \ = e\n    end\n  end\n  maxArr\nend", "  arr = arr.sort\n  max = arr.last\n \
    \ i = 0\n  \n  while i < k\n    if arr[i] > max\n      max = arr[i]\n    end\n\
    \    i += 1\n  end\n  max\nend\n</cell>\n<code language=julia-1.0>\nmaximum(arr,\
    \ 2)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, 3)\n</cell>\n<text>\n6.\
    \ Return all elements that appear even number of times in arr", "    i = 0\n \
    \   k = k\n    max = arr[0]\n    while i < k and arr[i] > max:\n        max =\
    \ arr[i]\n        i += 1\n    max = arr[i]\n    return arr[i:]", "    # write\
    \ your code here\n    res = []\n    count = collections.Counter(arr)\n    for\
    \ i, v in count.items():\n        if k == 1 or v > k-1:\n            res.append(arr[i])\n\
    \            k -= 1\n        else:\n            break\n    return res", "  arr.sort!\n\
    \  result = []\n  for i in 0..k-1\n    result << arr[i]\n  end\n  result << arr.max\n\
    \  result\nend", "  new_arr = []\n  arr = arr.sort\n  for i in 0...k\n    new_arr[i]\
    \ = arr[i]\n  new_arr\nend\n</cell>\n<code language=julia-1.0>\nmaximum(arr, 3)\n\
    </cell>\n<code language=julia-1.0>\nmaximum(arr, 2)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, 3)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, 2)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, 3)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, 2)\n</cell>\n<text>\nFind the minimum number in arr", "  # write\
    \ your code here\n  arr.sort!\n  result=[]\n  k=0\n  lenght=arr.size\n  while\
    \ lenght>k\n    result[k]=arr[lenght]\n    lenght-=k\n    k+=1\n  result[k]=arr[lenght]\n\
    \  return result\nend", "    # write your code here\n    h = arr[k-1-i] for i\
    \ in arr[0..k-1] \n    return arr if h > arr[k-1] else arr.reverse\nend\n</cell>\n\
    <cell>\narr = [-3, 2, 1, 2, -1, -2, 1]\nmaximum([1, 2, 3, 4], 2)\n</cell>\n<cell>\n\
    maximum([-9, -10, -9], 2)\n</cell>\n<cell>\nmaximum([1], 2)\n</cell>\n<cell>\n\
    maximum([], 2)\n</cell>\n<text>\n6. Maximum Subarray\nGiven an integer array nums\
    \ and a positive integer k, find the subarray with maximum sum and return its\
    \ sum.", "    arr.sort!\n    ans = []\n    (arr.length >= k) ? arr.each do |x|\n\
    \      ans << x if (ans.length > k) && (ans.length == k)\n    end\n    ans\nend",
  "  result = nil\n  arr.each do |i|\n    result = i if result < i && k <= 0\n   \
    \ k = k - 1\n  end\n  [result] + maximum(arr[k..-1], k - 1) + [arr.max]\nend",
  "    arr = arr.sort\n    arr.length == k ? arr.last : arr[0...k-1].reverse\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>", "    arr.sort\n    arr.take_while\
    \ {|x| x <= arr[k-1]}\nend", "    # Your code here\n    maximum = [-1000,1000,-1000,1000]\n\
    \    for i in (arr[0..k-1]):\n        maximum = maximum.max{|x,y| x>y}\n     \
    \   maximum = maximum.max{|x,y| x>y}\n    maximum.max{|x,y| x>y}\nend\n</code>\n\
    <|/ a tags=ruby,arrays dscore=1 |>\n<| a |>\n<code>", "    l = arr.length\n  \
    \  if k < 0 then\n        k = k + 1\n        arr = arr.sort\n    end\n    largest\
    \ = arr[k]\n    for i in (2..l)\n        if largest.abs > arr[i] then\n      \
    \      largest = arr[i]\n        end\n    end\n    largest\nend", "    arr.sort!\
    \ # O(n log n)\n    arr.take(k) # O(k)\nend\n</cell>\n<code language=julia-0.5>\n\
    maximum(arr, k) # O(n)\nmaximum(arr, 3) # O(n)\nmaximum(arr, 4) # O(n)\n</cell>\n\
    <code language=julia-0.5>", "  if k > 0\n    arr.sort! \n    arr[0...k-1].max\n\
    \  else\n    arr.max\n  end\nend\n</code>\nAnd here is the code for the minimum\
    \ subarray problem:\n<code>", "    sorted_arr = arr.sort\n    maximums = []\n\
    \    for i in 0...k\n        maximums << sorted_arr[i]\n    end\n    maximums\n\
    end", "    # Write your code here\n    arr.sort\n    ret = []\n    while k > 0\n\
    \        arr.pop\n        ret.push arr[-1]\n        k -= 1\n    return ret\nend",
  "  result = []\n  for i in 0..(arr.length-1)\n    if arr[i] > result[k-1]\n    \
    \  result[k] = arr[i]\n      k += 1\n    elsif arr[i] == result[k-1]\n      result[k]\
    \ << arr[i]\n    else\n      result[k] << result[k-1]\n    end\n  end\n  result.sort\
    \ { |i, j| j }.to_a\nend", "  # first sort the array\n  arr.sort", "    \n   \
    \ # \u65B9\u6CD5\u4E00\uFF1A\u6392\u5E8F + \u53BB\u91CD\n    # O(nlogn)\n    #\
    \ O(n)\n    sorted_arr = []\n    arr.sort.reverse_each do |num|\n        sorted_arr\
    \ << num if sorted_arr.length >= k\n    end\n    \n    # \u65B9\u6CD5\u4E8C\uFF1A\
    \u54C8\u5E0C\n    # O(nlogn)\n    # O(n)\n    sorted_arr = arr.sort\n    sorted_arr.delete_if\
    \ {|num| sorted_arr.length >= k}\n    \n    # \u65B9\u6CD5\u4E09\uFF1A\u9012\u5F52\
    \n    # O(nlogn)\n    # O(n)\n    sorted_arr = maximum(sorted_arr, k) if sorted_arr.length\
    \ > k\n    \n    # \u65B9\u6CD5\u56DB\uFF1A\u975E\u9012\u5F52\u7B97\u6CD5\n  \
    \  # O(nlogn)\n    # O(n)\n    \n    sorted_arr = []\n    arr.sort.reverse_each\
    \ do |num|\n        sorted_arr << num if sorted_arr.length >= k\n    end\n   \
    \ \n    sorted_arr\nend", "  \n  # Write your code here.\n  \n  if arr.length\
    \ < k\n    arr\n  else\n    if arr.max < arr[0]\n      arr.sort!\n      arr.shift\n\
    \      maximum(k-1, k)\n    end\n    maximum(k-1, k)\n  end\nend\n</cell>\n<code\
    \ language=julia-1.4>\nmaximum([4,3,-4,5,2,-3],3)\n</cell>\n<code language=julia-1.4>\n\
    maximum([4,3,-4,5,2,-3],2)\n</cell>\n<text>\nPalindrome\nGiven a string, check\
    \ whether it is a palindrome, considering only alphanumeric characters, spaces,\
    \ and the special characters !, $, &, #, ^, and *.", "    # sort arr and take\
    \ the first k element\n    arr.sort\n    result = arr[0, k-1..-1]\n    return\
    \ result\nend", "  max_num = arr[0]\n  min_num = arr[0]\n  for i in arr\n    if\
    \ i > max_num\n      max_num = i\n    if i < min_num\n      min_num = i\n  max_list\
    \ = []\n  for i in arr\n    if i > max_num\n      max_list << i\n    if i < min_num\n\
    \      max_list << i\n  sorted_list = max_list.sort\n  arr.clear\n  arr.concat(sorted_list)\n\
    \  arr.sort\nend", "  \n  return arr[0..k-1].max\nend", "  result = []\n  i =\
    \ 0\n  while i < k\n    max_i = i\n    pos = 0\n    while max_i < arr.length\n\
    \      if arr[max_i] >= arr[pos]\n        max_i += 1\n      else\n        pos\
    \ +=1\n      end\n    end\n    result << arr[pos]\n    i += 1\n  end\n  result\n\
    end", "  arr.sort!\n  return arr[0..k-1] if k <= arr.size \n  arr.sort!\n  arr[0..k-1].max\n\
    end", "  result = arr.dup\n  result.sort!\n  result[k..-1]\nend", "    arr1 =\
    \ arr.sort\n    return arr1[-k..-1]\nend\n</code>\n<|/ a dscore=0 tags=arrays,ruby\
    \ |>\n<| c |>\nI appreciate the effort, but the answer is different from the question\
    \ - you were looking for `k` max items, not `k` max items per group\n<|/ c |>\n\
    <| c |>\nThis answer returns `arr` instead of the desired `k` items. Try `[-3,\
    \ 2, 1, 2, -1, -2, 1].max_by(1)`.\n<|/ c |>\n<| a |>\nHere is a solution that\
    \ returns the desired k items per group, and uses Enumerable#max_by instead of\
    \ Array#sort for efficiency:\n<code>", "  n = arr.length\n  p =  n - k\n  max_arr\
    \ = []\n  i = 0\n  j = 0\n  while (i < n) && (j < (n-k))\n    if (arr[i] > arr[j])\n\
    \      max_arr[j] = max_arr[j] if j < (n-k) else arr[i]\n      j+=1\n    i +=\
    \ 1\n  max_arr[j] = max_arr[j] if j < (n-k) else arr[i]\n  return max_arr\nend",
  "    arr = arr.sort\n    arr.slice!(arr.length-k+1)\n    return arr\nend", "  nums\
    \ = arr[k-1..-1].sort\n  nums[0..k-1]\nend\n\"\"\"\n Problem 5 - Finding a Subarray\
    \ with the Minimum Sum\n \n Given an array of integers and an integer m, find\
    \ all the unique subarrays whose sum is closest to the integer m.\n \n Example\
    \ 1:\n \n Input: nums = [1, 3, 2], m = 4\n Output: [1, 2]\n Explanation: Unique\
    \ subarrays are: [[1], [3], [2, 3]]\n Example 2:\n \n Input: nums = [1, 2, 3,\
    \ 3, 4, 5], m = 10\n Output: [1, 2, 3, 4, 5]\n Explanation: Unique subarrays are:\
    \ [[1, 3], [2, 3], [3, 4], [4, 5], [3, 5]]\n \n\"\"\"\n Problem 6 - Finding a\
    \ String in an array of Strings\n \n Given an array of strings, return a string\
    \ where each word in the array is the concatenation of the strings \n togehter\
    \ with the first letter of the word capitalized. \n \n Example 1:\n \n Input:\
    \ [\"hello\", \"there\", \"my\", \"name\", \"is\", \"Bob\"]\n Output: \"Hello\
    \ There My Name Is Bob\"\n Explanation: The return value should be: \"Hello there\
    \ my name is Bob\"\n \n Example 2:\n \n Input: [\"hello\", \"there\", \"my\",\
    \ \"name\", \"is\", \"Bob\", \"I\", \"am\"]\n Output: \"Hello there my name is\
    \ Bob I am \"\n Explanation: The return value should be: \"Hello there my name\
    \ is Bob I am \"\n \n\"\"\"\n Problem 7 - Finding a Subarray in a Binary Search\
    \ Tree\n \n Given a binary search tree and a number x, find if there exist a subtree\
    \ in the tree whose value equals x.\n \n Example 1:\n \n Input: root = [3,5,1,8,null,10],\
    \ x = 5\n Output: true\n Explanation: There is a subtree with value 5 in the tree\
    \ [3, 5, 1, 8, null, 10]\n \n Example 2:\n \n Input: root = [3,5,1,8,null,10],\
    \ x = 8\n Output: true\n Explanation: There is a subtree with value 8 in the tree\
    \ [3, 5, 1, 8, null, 10]\n \n Example 3:\n \n Input: root = [3,5,1,8,null,10],\
    \ x = 4\n Output: false\n Explanation: There is no subtree with value 4 in the\
    \ tree [3, 5, 1, 8, null, 10]\n \n Example 4:\n \n Input: root = [3,5,1,8,null,10],\
    \ x = 9\n Output: false", "    max = arr[0]\n    i = 0\n    \n    while i < k\
    \ do\n        if max < arr[i] then\n            max = arr[i]\n        end\n  \
    \      i += 1\n    end\n    return max\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
