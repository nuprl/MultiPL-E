name: HumanEval_9_rolling_max
language: rb
prompt: "# From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n# in the sequence.\n# >>> rolling_max([1, 2, 3, 2, 3,\
  \ 4, 2])\n# [1, 2, 3, 3, 3, 4, 4]\ndef rolling_max(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rolling_max\n\
  \    candidate = method(:rolling_max)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([4,\
  \ 4, 4, 4], candidate.call([4, 3, 2, 1]))\n    assert_equal([3, 3, 3, 100, 100],\
  \ candidate.call([3, 2, 3, 100, 3]))\n  end\nend\n"
completions: ["  rolling_max_element = []\n  rolling_max_element = numbers[0]\n  numbers.shift\
    \ if numbers.length > 0 # Remove the first element of the array\n  numbers.each\
    \ do |number|\n    if number > rolling_max_element\n      rolling_max_element\
    \ = number\n    end\n  end\n  rolling_max_element\nend", "  numbers_length = numbers.size\n\
    \  max_value = numbers.first\n  rolling_max_list = []\n  if numbers.size == 1\n\
    \    rolling_max_list = [numbers]\n  else\n    rolling_max_list << []\n    rolling_max_list\
    \ << [numbers[0..numbers_length-1]]\n    rolling_max_list << [numbers[1..numbers_length]]\n\
    \    rolling_max_list << [numbers[2..numbers_length-1]]\n    rolling_max_list\
    \ << [numbers[3..numbers_length]]\n    rolling_max_list << [numbers[4..numbers_length-1]]\n\
    \    rolling_max_list << [numbers[5..numbers_length]]\n    rolling_max_list <<\
    \ [numbers[6..numbers_length-1]]\n    rolling_max_list << [numbers[7..numbers_length]]\n\
    \  end\n  rolling_max_list.each_with_index do |rolling_max, index|\n    if index\
    \ > numbers_length - 2\n      rolling_max << rolling_max[-2]\n      rolling_max\
    \ << rolling_max[-1]\n    end\n  end\n  rolling_max_list\nend", "    \n    # Generate\
    \ empty array\n    arr_max = []", "  roll_max = numbers.first\n  numbers.each\
    \ do |n|\n    roll_max = n if roll_max < n\n  end\n  roll_max\nend", "  numbers\
    \ = numbers.collect {|n| n > 0 ? n : 0}\n  max = numbers.max\n  numbers.each {|n|\
    \ max = [max, n].max }\n  return max\nend", "    numbers.each do |number|\n  \
    \      max_so_far = number if number > max_so_far\n        max_so_far = number\
    \ if number == max_so_far\n    end\n    max_so_far\nend", "  return numbers.max()\
    \ - numbers.drop(numbers.index(numbers.max))\nend", '  rolling_max_max_idx = nil',
  "  numbers.each_cons(2).map { |a, b| a > b ? a : b }\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nFor `numbers = [1,2,3,4,5,6,7]` this returns `[1,1,1,1]`, which\
    \ isn't the right answer.\n<|/ c |>\n<| c |>\nIt returns `[1,2,3,4,5,6,7]` with\
    \ `numbers = [1,2,3,2,3,4,2]`. It should return `[1,2,3,3,3,4,4]` with `numbers\
    \ = [1,2,3,2,3,4,2]`.\n<|/ c |>\n<| c |>\nMy apologies, I misinterpreted your\
    \ answer.  It *is* the right answer, though - thanks!\n<|/ c |>\n<| c |>\nYeah,\
    \ it would be easy to fix the problem by adding one more `each_cons(2)` at the\
    \ end (and thus making it `each_cons(2).map { |a, b| a > b ? a : b }`).\n<|/ c\
    \ |>\n<| a dscore=1 tags=arrays,ruby |>\nHere's another way:\n<code>", "  numbers.shift\
    \ # remove the first element\n  return numbers.reduce(:<<) while numbers.any?\n\
    \  []\nend", "    numbers_copy = numbers.dup\n    numbers_copy.rotate(1)\n   \
    \ numbers_copy.reduce(0, :<)\nend", "  numbers.each_with_object([]) do |number,\
    \ max_list|\n    if number > max_list.last\n      max_list << number\n    end\n\
    \  end\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a tags=ruby |>\n<code>",
  "    numbers.each_cons(2).reduce(:+)\nend\n</code>\n<|/ a |>\n<| c |>\nThis answer\
    \ is a bit too verbose to be useful to most people.  A bit more explanation would\
    \ be more helpful.\n<|/ c |>\n<| c |>\n, I am not going to explain what every\
    \ line is doing. I have added comments to it so that you can read it\n<|/ c |>\n\
    <| c |>\nThis code was also useful to me when I was trying to solve this question:\
    \ http://stackoverflow.com/questions/4701362/ruby-array-sum-over-window-of-4\n\
    <|/ c |>\n<| a tags=arrays,ruby dscore=5 |>\nI find this approach easy to grasp.\n\
    <code>", "  return numbers.inject([]) do |list, number|\n    list << (list.pop\
    \ > number ? list.pop : number)\n    list\n  end\nend", "  max_value = numbers.shift\n\
    \  max_numbers.unshift(max_value)\n  while numbers.any?\n    value = numbers.shift\n\
    \    if value > max_value\n      max_value = value\n    end\n    max_numbers.unshift(value)\n\
    \  end\n  max_numbers\nend", "  numbers.reduce(:<)\nend", "  # Return the given\
    \ list of integers or the empty list if no number is given.\n  return numbers\
    \ if numbers.any? or numbers == [] else []\nend", "\trolling_max_numbers = numbers[0].clone\n\
    \trolling_max_numbers.clear\n\trolling_max_numbers.max_by! { |element| element\
    \ }\n\tnumbers.each do |number|\n\t\trolling_max_numbers.max_by! { |element| element\
    \ }\n\tend\n\trolling_max_numbers\nend", "    max = numbers.first\n    rollings\
    \ = []\n    numbers.each do |number|\n        if number > max\n            max\
    \ = number\n        else\n            rollings << max\n            max = number\n\
    \        end\n    end\n    rollings << max\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nThanks. I was looking for a solution that doesn't require looping through\
    \ all elements. I suppose I should've been clearer about that. Also, I added some\
    \ explanation to my original post.\n<|/ c |>\n<| c |>\nI understand that what\
    \ you are looking for is a method that takes an array and finds its maximum element\
    \ over a certain period of time. I am not sure how to implement this without looping\
    \ through the entire array. I'll post an alternative method that doesn't involve\
    \ loops.\n<|/ c |>\n<| c |>\nI added a non-loop solution that doesn't require\
    \ loops.\n<|/ c |>\n<| c |>\nThanks, I appreciate it. I'm sorry that my original\
    \ post seemed unclear. I guess I thought that if there was a method that took\
    \ an array of integers and found the maximum of that array over a period of time,\
    \ then there would definitely be a solution that doesn't involve looping.\n<|/\
    \ c |>\n<| c |>\nNo problem, it's always good to see different ways to solve a\
    \ problem. I am glad you were able to solve the problem!\n<|/ c |>\n<| a |>\n\
    Another way to solve this problem is using the built-in Array#chunk, which will\
    \ split an array into different chunks. For example, if we want to find the max\
    \ element in a sequence from 6 to 10, we can use something like this:\n<code>\n\
    my_array.chunk(2).map(&:last).max\n</code>\nwhich can return an array as below:\n\
    <code>\n[6, 8]\n</code>\n<|/ a dscore=3 tags=ruby |>\n<| c |>\nThis is pretty\
    \ clever! I was thinking of something similar but didn't know how to implement\
    \ it.\n<|/ c |>\n<| a |>\nIf you need to find the max in a given range of a given\
    \ array, you might want to consider using a Range instead of a Range#includes.\n\
    For example:\n<code>\narray = [1, 2, 3, 2, 3, 4, 2]\nrange = 6.to_i .. 10.to_i\n\
    array.max_by(range)", "  rolling_max_index = 0\n  rolling_max_value = numbers[0]\n\
    \  rolling_max_index = numbers.size - 1\n  numbers.each_with_index do |num, idx|\n\
    \    if (num > rolling_max_value)\n      rolling_max_value = num\n      rolling_max_index\
    \ = idx\n    end\n  end\n  rolling_max = []\n  rolling_max << numbers[rolling_max_index]\n\
    \  while numbers.length > rolling_max_index\n    rolling_max << numbers[rolling_max_index]\n\
    \    rolling_max_index = rolling_max_index + 1\n    rolling_max_value = numbers[rolling_max_index]\n\
    \  end\n  return rolling_max\nend", "  numbers.each do |number|\n    rolling_max\
    \ << number if rolling_max.last >= number\n  end\nend", "  max_so_far = numbers.first\n\
    \  numbers.last.upcase!\n  numbers.each do |number|\n    max_so_far = number if\
    \ number > max_so_far\n  end\n  max_so_far\nend", "  return numbers.reduce(:<<)\n\
    end", "  numbers.reverse_each{|n| n.rotate(-n)}\n  numbers.last\nend", "  numbers.each_index\
    \ do |i|\n    numbers[i].times do\n      if numbers[i].to_i == numbers[i-1].to_i\n\
    \        numbers[i+1] = numbers[i-1]\n      end\n    end\n  end\nend", "  result\
    \ = []\n  numbers.each do |n|\n    result += [n]\n    result << numbers[0..numbers.index(n,\
    \ n).last]\n  end\n  result\nend\n</code>\n<|/ a |>\n<| a dscore=2 tags=ruby |>\n\
    Here's a solution that is fairly simple, straight forward, and fast enough in\
    \ Ruby 1.8.7+ (thanks to Chris Pine):\n<code>", "    max_length = 0\n    numbers.each\
    \ do |x|\n        max_length = x.rolling(max_length).max\n    end\n    max_length.upto(numbers.last)\n\
    end", "    numbers.each_cons(3).with_index do |(numbers, index), index|\n    \
    \    if index > 0\n            numbers.each_cons((index - 1)).with_index do |(numbers,\
    \ index), index|\n                numbers[index] = max(numbers[index], numbers[index\
    \ + 1])\n            end\n        end\n    end\n    numbers\nend", "  numbers.max_by(&:itself).map\n\
    end", "  max_so_far = numbers.shift\n  numbers.each do |number|\n    max_so_far\
    \ = number if number > max_so_far\n  end\n  max_so_far\nend\n</cell>\n<cell>\n\
    rolling_max([1,2,3,2,3,4,2])\n</cell>\n<text>\n5.7: Sort an Array in Descending\
    \ Order\nGiven an array nums, sort the array in descending order. You may assume\
    \ nums is already sorted in non-descending order.", "  max = []\n  numbers.each\
    \ do |num|\n    max = num if num > max.last || max.blank?\n  end\n  max\nend",
  "  numbers.each do |num|\n    num.times {numbers.shift until numbers.empty? or numbers.first}\n\
    \  end\n  numbers\nend", "  numbers.inject([0, nil]) do |max, element|\n    max.last\
    \ < element ? [element, max[1]] : [max, element]\n  end[1]\nend", "  roll_max_number\
    \ = numbers[0]\n  roll_max_indexes = []\n  roll_max_indexes.append(0)", "  rolling_maxs\
    \ = []\n  numbers.length.times do |i|\n    rolling_maxs << numbers.slice(i..-1).max\n\
    \  end\n  rolling_maxs\nend", "  rolling_max = []\n  numbers.each do |x|\n   \
    \ rolling_max << x if x > rolling_max.last\n  end\n  rolling_max.last\nend", " \
    \ rolled_max = numbers.shift\n  numbers.each do |n|\n    rolled_max = n if rolled_max\
    \ < n\n  end\n  rolled_max\nend", "  rolling_max.numbers ||= []\n  if numbers.length\
    \ <= rolling_max.numbers.length\n    rolling_max.numbers << numbers\n  else\n\
    \    rolling_max.numbers.each do |number|\n      rolling_max.numbers << number\n\
    \      rolling_max.numbers.pop if number >= rolling_max.numbers[-1]\n    end\n\
    \  end", "  # Initialize max with last element \n  max_value = numbers.last\n\
    \  \n  # Find largest number in the list of numbers and save it as the current\
    \ max value\n  numbers.each do |n| \n    if n > max_value\n      max_value = n\n\
    \    end\n  end\n  \n  # Return current max value\n  return max_value\nend", " \
    \ sum = 0\n  rollingMax = nil\n  numbers.each { |number| sum += number }\n  rollingMax\
    \ = sum - sum % rollingMax_step_size\n  numbers.each { |number| sum += number\
    \ }\n  rollingMax = sum - sum % rollingMax_step_size\n  rollingMax\nend", "  numbers.each_with_object([])\
    \ do |n,result|\n    result[-1] = n if n <= result[-1]\n    result << n unless\
    \ result.last == n\n  end\nend", "  return [numbers[0..numbers.length-1].max]\n\
    end", "  numbers.reduce(:<<)\nend", "  # Get a sorted version of numbers, because\
    \ a rolling maximum would require going through all of them\n  # and looking at\
    \ only the first element.\n  numbers = numbers.sort\n  numbers = numbers.first(numbers.size)\n\
    \  # The last element is the rolling max so far.\n  last_max = numbers.last\n\
    \  # The last element is the rolling max until this moment.\n  last_max_rolling\
    \ = last_max", "  numbers.reduce(:<<)\nend", "  numbers.sort_by!{ |n| -n }\n \
    \ result = [numbers[0]]\n  numbers.each_index { |i| result << numbers[i] }\n \
    \ result\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,algorithm dscore=1 |>\n\
    <| a |>\nI needed a solution in Ruby for finding the maximum value in a rolling\
    \ window for a specific time period. I couldn't find a solution using just ruby\
    \ methods, but the solution below works in Ruby:\n<code>", "  numbers.map { |n|\
    \ n }.uniq.sort.reverse.last(numbers.count).min\nend", "  numbers.each_with_object([])\
    \ { |n, max| max << n if n > max }.max\nend", "  numbers.inject([[]]) do |rolling_max,\
    \ value|\n    if rolling_max.empty?\n      rolling_max << value\n    else\n  \
    \    rolling_max.last.last < value ? rolling_max << [value] : rolling_max.push\
    \ value\n    end\n    rolling_max\n  end\nend", "  if numbers.nil?\n    return\
    \ []\n  else\n    rolled = numbers.dup\n    rolled.reverse!\n    rolled.each_with_index\
    \ do |v, i|\n      rolled[i] = rolled[i - 1].max\n    end\n    rolled.reverse!\n\
    \    return rolled\n  end\nend", "  numbers.each do |number|\n    if number <\
    \ numbers.last\n      numbers.last(number).each do |num|\n        return num\n\
    \      end\n    end\n  end", "  numbers ||= []\n  max_so_far = numbers.first\n\
    \  numbers.each do |element|\n    if max_so_far > element\n      max_so_far =\
    \ element\n    end\n  end\n  return max_so_far if max_so_far != nil\n  nil\nend",
  "    numbers.reverse!\n    numbers.each do |number|\n        max = number\n    \
    \    numbers.drop(1).each do |number|\n            max = number > max ? number\
    \ : max\n        end\n        numbers.pop if number > max\n        numbers <<\
    \ max\n    end\n    numbers\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ |>\nThis question was asked a while ago but I just thought I would add my answer\
    \ since I could not find one elsewhere. \n<code>", "  rolling_max = numbers.first\n\
    \  numbers.each do |number|\n    if number > rolling_max\n      rolling_max =\
    \ number\n    end\n  end\n  rolling_max\nend\n</pre>\n</li>\n<li>\n<p>\nRuby code:\n\
    </p>\n<pre class=\"ruby\"><span class=\"ruby-keyword\">class</span> <span class=\"\
    ruby-constant\">Integer</span>\n  <span class=\"ruby-keyword\">def</span> <span\
    \ class=\"ruby-identifier\">clamp</span>(<span class=\"ruby-identifier\">max</span>)\n\
    \    <span class=\"ruby-keyword\">if</span> <span class=\"ruby-identifier\">abs</span>(<span\
    \ class=\"ruby-keyword\">self</span>) <span class=\"ruby-operator\">&lt;=</span>\
    \ <span class=\"ruby-identifier\">max</span>\n      <span class=\"ruby-keyword\"\
    >self</span>\n    <span class=\"ruby-keyword\">else</span>\n      <span class=\"\
    ruby-keyword\">self</span> <span class=\"ruby-operator\">-</span> <span class=\"\
    ruby-identifier\">max</span>\n    <span class=\"ruby-keyword\">end</span>\n  <span\
    \ class=\"ruby-keyword\">end</span>\n<span class=\"ruby-keyword\">end</span>\n\
    </pre>\n</li>\n<li>\n<p>\nTest:\n</p>\n<pre class=\"ruby\"><span class=\"ruby-identifier\"\
    >assert</span> <span class=\"ruby-constant\">Integer</span>.<span class=\"ruby-identifier\"\
    >clamp</span>(<span class=\"ruby-number\">2</span>).<span class=\"ruby-identifier\"\
    >equal?</span>(<span class=\"ruby-number\">2</span>)\n<span class=\"ruby-identifier\"\
    >assert</span> <span class=\"ruby-constant\">Integer</span>.<span class=\"ruby-identifier\"\
    >clamp</span>(<span class=\"ruby-number\">-1</span>).<span class=\"ruby-identifier\"\
    >equal?</span>(<span class=\"ruby-number\">1</span>)\n<span class=\"ruby-identifier\"\
    >assert</span> <span class=\"ruby-constant\">Integer</span>.<span class=\"ruby-identifier\"\
    >clamp</span>(<span class=\"ruby-number\">2</span>).<span class=\"ruby-identifier\"\
    >equal?</span>(<span class=\"ruby-number\">2</span>)\n<span class=\"ruby-identifier\"\
    >assert</span> <span class=\"ruby-constant\">Integer</span>.<span class=\"ruby-identifier\"\
    >clamp</span>(<span class=\"ruby-number\">4</span>).<span class=\"ruby-identifier\"\
    >equal?</span>(<span class=\"ruby-number\">4</span>)\n<span class=\"ruby-identifier\"\
    >assert</span> <span class=\"ruby-constant\">Integer</span>.<span class=\"ruby-identifier\"\
    >clamp</span>(<span class=\"ruby-number\">6</span>).<span class=\"ruby-identifier\"\
    >equal?</span>(<span class=\"ruby-number\">6</span>)\n</pre>\n</li>\n<li>\n<p>\n\
    Benchmark:\n</p>\n<pre class=\"ruby\"><span class=\"ruby-keyword\">require</span>\
    \ <span class=\"ruby-string\">'benchmark'</span>\n<span class=\"ruby-keyword\"\
    >module</span> <span class=\"ruby-constant\">Benchmark</span>\n  <span class=\"\
    ruby-keyword\">def</span> <span class=\"ruby-identifier\">run</span>", "  numbers.inject([])\
    \ do |max, number|\n    number.zero? && max[-1] > number || max.push([number])\n\
    \    max[-1]\n  end\nend\n</code>\n<|/ a tags=ruby,list,arrays |>\n<| c |>\nGood\
    \ idea. The solution I gave is quite different, I wanted to post it anyway because\
    \ it can be useful to some people. On the other hand, I really like your, I'm\
    \ going to use this technique somewhere else. :)\n<|/ c |>\n<| c |>\nI appreciate\
    \ you looking into it. I agree it is useful to someone. :)\n<|/ c |>\n<| a dscore=2\
    \ |>\nI'd use a Hash (a dictionary in other languages) to keep track of the rolling\
    \ max, and increment it when a new max is found. Here is a working solution (note\
    \ the use of Integer#ceil):\n<code>", "  numbers.each_with_object([]) do |number,\
    \ list|\n    list << number if list.empty? || list.last >= number\n    list <<\
    \ number if (list.empty? || list.last < number)\n  end\nend\n</code>\nThe benefit\
    \ of this approach is that each time you call the method the list is appended\
    \ to.  So you can do this as many times as you want.  This is called memoization\
    \ and is a great way to make performance improvements.  In Ruby you don't have\
    \ to do this because the language automatically caches the results of methods\
    \ for you if you call them with the same arguments.\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails\
    \ |>\n<| a |>\nRuby Array#max_by returns nil if there are no elements larger than\
    \ the argument given.\n<code>\n[1,2,3,4,5].max_by{|x| x}", "  numbers.each_with_index.map\
    \ { |e, i|\n    rolling_max_index(numbers, i)\n  }\nend", "    numbers.each_with_index.map\
    \ { |x, i| x == numbers.first ? i : i }\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm\
    \ |>\n<| c |>\nThank you for your input. It does work but I'd like to see some\
    \ explanation why it works as well as others answers I got on here.\n<|/ c |>\n\
    <| c |>\nadded explanation\n<|/ c |>\n<| c |>\nThis is by far a much better solution!\
    \ I wish I could give more upvotes.\n<|/ c |>\n<| c |>\nWhat is the `each_with_index`\
    \ method here? I don't get that.\n<|/ c |>\n<| c |>\nIt's the enumerable version\
    \ of each_with_index, see http://ruby-doc.org/core-2.5.1/Enumerable.html\n<|/\
    \ c |>\n<| a |>\nUsing group_by\n<code>\na = [1,5,2,3,6,8,3,5,9,1,2,2,3,7,2,1,1]",
  "  rolling_max.min_max = nil\n  rolling_max.min_maxes = numbers.map do |n|\n   \
    \ [n, n]\n  end\n  numbers.each do |n|\n    rolling_max.min_maxes.each do |m,\
    \ max_rolling_max|\n      n != m && max_rolling_max[1] = m if n > m\n    end\n\
    \  end\n  rolling_max.min_maxes\nend", "  return numbers.reduce(:&)\nend", " \
    \ numbers.map { |n| n.zero? ? n : (rolling_max[n-1] + n) }\nend", "  rolling_max\
    \ = nil\n  last_max = nil\n  numbers.each do |n|\n    rolling_max += n if last_max.nil?\
    \ || rolling_max.nil?\n    last_max = rolling_max if rolling_max.nil? && n.nil?\
    \ || last_max.nil? && n.nil?\n    rolling_max = n if last_max > rolling_max &&\
    \ n.nil?\n  end\n  rolling_max\nend\n</code>\n<|/ a tags=ruby,algorithm dscore=1\
    \ |>\n<| c |>\nI think this is going to be the most efficient solution for what\
    \ I'm trying to do with the way I'm using the method.\n<|/ c |>\n<| c |>\nI tried\
    \ to do this, and it works for the most part, but it's still giving me issues.\
    \ I'm gonna go through the steps and see if I can find anything I did incorrectly.\
    \ EDIT: Nevermind, I found the issue, Thanks!\n<|/ c |>\n<| c |>\nI think I fixed\
    \ the issue I was having. Thanks for your help though!\n<|/ c |>\n<| c |>\nI was\
    \ testing it out more and when I input the numbers 1 through 30, it gives me incorrect\
    \ output. Any idea why this is? It seems to be returning the correct output for\
    \ all the numbers except the ones that get to 30, which is what it returns for\
    \ the first 20 numbers in the array.\n<|/ c |>\n<| c |>\nI noticed that if I take\
    \ out the final 'rolling_max+=n' I get a different output, but still not what\
    \ I want.\n<|/ c |>\n<| a dscore=0 |>\nI ended up getting it working. Thanks to\
    \ Kasper for helping me get this far. Here was what I came up with\n<code>", " \
    \ numbers.each_cons(2).find { |n1, n2| n1 <=> n2 }.max_by(&:last)\nend", "  numbers.each\
    \ do |number|\n    next if number.nil? || number < 0\n    cur_max = [number]\n\
    \    rolling_num(number-1, cur_max, numbers.last) do |max_number|\n      cur_max\
    \ << max_number\n    end\n    cur_max\n  end\nend", "  numbers = numbers.sort_by\
    \ { |number| number.to_i }\n  numbers = [numbers[i] for i in 0...numbers.length]\
    \ if numbers.length <= 1\n  numbers = numbers.reverse", "  rolling_max = numbers.first\n\
    \  rolling_max.each do |number|\n    rolling_max = max(rolling_max, number)\n\
    \  end\n  rolling_max\nend", "  maximum = numbers.first\n  maximum_index = numbers.first\n\
    \  numbers.each_index do |index|\n    if numbers[index] > maximum\n      maximum\
    \ = numbers[index]\n      maximum_index = index\n    end\n  end\n  return maximum,\
    \ maximum_index\nend", "  numbers.each_with_index.map { |e, i| i > 0 ? e : numbers[-i-1]\
    \ }.max_by(&:last)\nend", "\tnumbers.each do |num|\n\t\tnext if num.zero?\n\t\t\
    max_num = num\n\t\tnumbers.each do |num|\n\t\t\tif num > max_num\n\t\t\t\tmax_num\
    \ = num\n\t\t\tend\n\t\tend\n\t\tnumbers.delete(max_num)\n\tend\n\tnumbers\nend",
  "  max_val = 0\n  max_element = numbers[0]\n  min_element = numbers[0]\n  max_element_size\
    \ = numbers.length - 1\n  min_element_size = numbers.length - 1", "  numbers.each_with_index\
    \ do |number, index|\n    yield(number, index) if index == 0\n    yield(number,\
    \ index + 1) if index + 1 >= numbers.length\n  end\nend", "  numbers.each_cons(2).map\
    \ { |a, b| [a, b].max() }\nend", "  numbers.each_cons(2) do |first, second|\n\
    \    first > second ? first : second\n  end\nend\n</cell>\n<code language=julia-1.3>",
  "  numbers = numbers.to_a\n  max_value = numbers.shift\n  numbers.each_with_index\
    \ do |n, i|\n    if i == 0\n      max_value = n\n    elsif n >= max_value\n  \
    \    max_value = n\n    end\n  end\n  max_value\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nI love this solution.  I wouldn't have thought to use each_with_index here.\n\
    <|/ c |>\n<| c |>\nAs a note to the OP though, `rolling_max` will return the last\
    \ element in the array, not the largest one that is less than the array elements.\
    \ A quick fix is to change the last line to `max_value.nil? ? n : max_value` and\
    \ get the same result\n<|/ c |>\n<| c |>\nThanks for pointing out this issue.\
    \ I edited the post accordingly.\n<|/ c |>\n<| a dscore=3 |>\n<code>", "\tmax_number\
    \ = 0\n\tnumbers.each do |number|\n\t\tmax_number = number if number > max_number\n\
    \tend\n\tmax_number\nend", "  numbers.each do |number|\n    (numbers.size..numbers.size+number).each\
    \ do |i|\n      number[i] = number[i - 1] if number[i-1] > number[i]\n    end\n\
    \  end\nend", '  max_numbers = []', "  if numbers.nil?\n    []\n  else\n    rolling_max\
    \ = numbers.shift\n    numbers.each do |num|\n      rolling_max = num if rolling_max\
    \ < num\n    end\n    rolling_max\n  end\nend", "  numbers = numbers.to_a\n  maximum\
    \ = numbers.first.abs", "  numbers.each_with_object([]) { |n, result| result <<\
    \ n if result.size < numbers.size }.max\nend\n</code>\n<|/ a tags=ruby,arrays,max,ruby-on-rails-4\
    \ |>\n<| c |>\nNice solution. I'd probably add `return numbers` at the end of\
    \ `each_with_object` as well, since `max` returns the maximum element of the array\
    \ and that wouldn't make any sense otherwise.\n<|/ c |>\n<| a dscore=4 |>\nAnother\
    \ possible solution with inject:\n<code>\n[1,2,3,2,3,4,2].inject(:>)", "    numbers.each\
    \ { |n| rolling_max(n, true) }\nend", "  rolling_maxes = []\n  last_rolling =\
    \ nil\n  numbers.each do |number|\n    if number > last_rolling\n      last_rolling\
    \ = number\n      rolling_maxes << number\n    end\n  end\n  rolling_maxes\nend",
  "  max = numbers.first\n  numbers.each do |number|\n    max = number if number >\
    \ max\n  end\n  max\nend", "    numbers.reduce(:+)\nend", "  numbers.map {|n|\
    \ [n, n].max}\nend", "  max_number = numbers.first\n  max_list = []\n  for i in\
    \ numbers\n    if i > max_number\n      max_number = i\n      max_list << max_number\n\
    \    end\n  end\n  max_list\nend", "    rolling_maxes = []\n    rolling_maxes.append(numbers.shift)\n\
    \    \n    until numbers.empty?\n        rolling_maxes.append(numbers.shift)\n\
    \    end", "  result = []\n  numbers.each_with_index do |x, i|\n    result.push(x)\
    \ if i <= numbers.size - 4\n    result.push(x) if (i + 1) <= numbers.size - 3\n\
    \  end\n  result\nend", "    numbers.each_cons(2) do |numbers|\n        numbers\
    \ = numbers.max\n        numbers.nil? ? nil : numbers\n    end\nend", "  max =\
    \ 1\n  for i in numbers\n    max = max == i ? i : i\n    max = i == max ? i :\
    \ i\n  max = max == numbers[-1] ? numbers[-1] : max\n  return max\nend", "  numbers.each_with_index.inject([numbers.first])\
    \ do |(max_so_far, index), (number)|\n    max_so_far if number > max_so_far\n\
    \  end\nend", "  result = []\n  numbers.each_index do |i|\n    result << numbers[i].max\
    \ if i >= numbers.size - 1\n  end\n  result\nend", "  rolling_max_max_window =\
    \ window_function(max_window, numbers)\n  rolling_max_min_window = window_function(min_window,\
    \ numbers)\n  rolling_max_sum = numbers.reduce(&:+).reduce(&:-).reduce(&:+)\n\
    \  rolling_max_product = numbers.reduce(&:*).reduce(&:*).reduce(&:+).reduce(&:-).reduce(&:*)\n\
    \  return [rolling_max_sum, rolling_max_product, rolling_max_min_window, rolling_max_max_window]\n\
    end", "  rolling_max_array = []\n  max_number = 0\n  max_element = nil", "  return\
    \ numbers.slice_when do |left, right|\n    right = right.next_upto(left) if right.next_upto(left).nil?\n\
    \    [right].flatten.select(&:> left).first\n  end\nend", "  result = []\n  number.times\
    \ do\n    number = numbers.shift\n    result << number unless number > max_element(result)\
    \ || result.empty?\n    result << number unless number > max_element(result)\n\
    \  end\n  return result\nend", "  rolling_max = numbers[0]\n  rolling_max_indexes\
    \ = []\n  rolling_max_indexes = []\n  for number in numbers\n    if number > rolling_max\n\
    \      rolling_max = number\n      rolling_max_indexes = []\n    rolling_max_indexes\
    \ << number\n  end", "  max = numbers.shift\n  numbers.each do |i|\n    if i >\
    \ max\n      max = i\n    end\n  end\n  max\nend", "  rolling_max_number = numbers.reduce(:max)\n\
    \  rolling_max_index = numbers.index(rolling_max_number)\n  if rolling_max_index\
    \ == 0\n    rolling_max_number\n  elsif rolling_max_index == numbers.size-1\n\
    \    numbers[numbers.size-2]\n  else\n    numbers[rolling_max_index-1]\n  end\n\
    end\n</cell>\n<text>\nGiven the rolling max function, we have a few simple tests\
    \ to make sure the function returns the correct values. It should return the second\
    \ largest number in the list.", "  rolling_max.numbers ||= []\n  rolling_max.numbers\
    \ << numbers\n  rolling_max.numbers << numbers[0...-1] if numbers.size > 0\n \
    \ rolling_max.numbers << numbers[0...-1] if numbers.size > 0", "  numbers.inject(0)\
    \ { |rolling, number| rolling > number ? rolling : number}\nend", "  numbers.each\
    \ { |number| yield number if number > numbers.max }\nend", "  # TODO: Fix it so\
    \ that it works.\n  result = numbers.dup\n  result.unshift nil", "  rolling_max_roll(numbers,\
    \ nil)\nend", "  return numbers[-numbers.length..-1].max\nend", "  max_num = numbers[0]\n\
    \  max_max_num = numbers[0]\n  numbers.each do |number|\n    if number > max_num\n\
    \      max_num = number\n    end\n    if number == max_num\n      max_max_num\
    \ = number\n    end\n  end\n  max_max_num\nend", "  numbers.reduce(:+)\nend",
  "    sums = numbers.reduce(:+) # Sum all numbers in the list\n    rolling_sum =\
    \ 0", "    numbers = numbers.to_a.clone\n    numbers.shift\n    numbers.reverse.inject(0)\
    \ do |max, number|\n        return max if number > max\n        max\n    end\n\
    end", "  numbers.reduce(:<<)\nend", "  numbers.map do |number|\n    number.to_i\n\
    \  end\nend", "  numbers.reduce(:<<)\nend", "    numbers.each do |number|\n  \
    \      max = number\n        numbers.each do |number|\n            if number >\
    \ max\n                max = number\n            end\n        end\n        numbers.delete(max)\n\
    \    end\n    numbers\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=arrays,ruby\
    \ |>\nThis will return a new array containing the largest element of each group:\n\
    <code>\narr = [\n  [ 1, 2 ],\n  [ 2, 3 ],\n  [ 3, 1 ],\n  [ 4, 3 ],\n  [ 1, 7\
    \ ],\n  [ 2, 5 ],\n  [ 6, 7 ],\n]", "  numbers.reduce(:<<)\nend\n</cell>\n<code\
    \ language=julia-0.6>\n@code_warntype rolling_max([1, 2, 3, 2, 3, 4, 2])\n</cell>\n\
    <code language=julia-0.6>", "    rolling_max_value = numbers[0]\n    rolling_max_index\
    \ = numbers[0]\n    if numbers.size == 1\n        return numbers\n    else\n \
    \       numbers.each do |number|\n            if number > rolling_max_value\n\
    \                rolling_max_value = number\n                rolling_max_index\
    \ = number\n            end\n        end\n        return numbers[0, rolling_max_index\
    \ + 1]\n    end\nend", "  rolling_max = numbers.shift\n  numbers.each { |number|\n\
    \    rolling_max = number if number > rolling_max\n  }\n  rolling_max\nend", " \
    \   numbers = numbers.to_a\n    \n    max = numbers.shift\n    \n    numbers.each\
    \ do |n|\n        max = n > max ? n : max\n    end\n    \n    max\nend", "  rolling_max_numbers\
    \ = []\n  rolling_max_indexes = []\n  rolling_max_numbers.clear\n  rolling_max_indexes.clear\n\
    \  rolling_max_numbers.merge!(numbers)\n  rolling_max_indexes.push(0)\n  numbers.each_index\
    \ do |i|\n    rolling_max_numbers.push rolling_max(numbers[(i+1):numbers.length])\n\
    \    rolling_max_indexes.push i\n  end\n  rolling_max_numbers.merge!\nend", " \
    \ numbers.each_with_index.with_object([]) do |(number, i),a|\n    if i > 0 &&\
    \ number > a[i - 1]\n      a << number\n    end\n  end\nend\n</pre>", "  numbers.reduce\
    \ do |a, b|\n    ab = a * b # Calculate the product\n    ab < numbers[-1] ? ab\
    \ : numbers[-1]\n  end\nend", "  rolling = numbers.reduce(:<<)\n  numbers.reverse_each.map\
    \ { |n| rolling += n }\n  numbers\nend", "  window = numbers.shift # first value\
    \ in list\n  window = numbers.pop if numbers.last == window # remove last value\
    \ in list\n  return numbers + [window] * (numbers.size - 1) if numbers.size >\
    \ 0 # repeat until no more rolling\nend", "    numbers.length <= 1\n    numbers.length\
    \ >= numbers.reduce(:+)\n    numbers.reduce(:+)\nend", "  n = numbers.length\n\
    \  max = (numbers[0] || 0).to_f\n  for i in 1..n\n    max = max > numbers[i] ?\
    \ max : numbers[i]\n  end\n  max\nend", "  numbers.each_with_index do |x, i|\n\
    \    if i % 2 == 0\n      numbers[i] = Math.max(numbers[i-1], numbers[i])\n  \
    \  end\n  end\n  return numbers\nend", "  return numbers.reverse.map{|n| n > numbers.last}.inject(:+).reverse\n\
    end", "  rolling_max_nums = []\n  rolling_max_num = numbers.shift\n  rolling_max_nums\
    \ << rolling_max_num\n  rolling_max_nums.each do |number|\n    rolling_max_num\
    \ = number if number > rolling_max_num\n  end\nend", "  numbers.inject([]) do\
    \ |rolling_max, number|\n    rolling_max << number if rolling_max.empty? || number\
    \ > rolling_max[-1]\n    rolling_max\n  end\nend", "    rolling_max_array = []\n\
    \    rolling_max_array_copy = []\n    rolling_max_array_copy2 = []\n    rolling_max_array_copy3\
    \ = []\n    rolling_max_array_copy4 = []\n    rolling_max_array_copy5 = []", " \
    \ return [number].zip(numbers[1..-1]).reduce(:<<).map(&:last)\nend", "  rolling_max_number\
    \ = 0\n  rolling_max_index = 0", "  rolling = {}\n  numbers.each do |num|\n  \
    \  (rolling[num] ||= []) << num\n  end\n  rolling\nend", "  min_value = numbers[0]\n\
    \  rolling_max = []\n  \n  numbers.each do |num|\n    if num < min_value\n   \
    \   rolling_max = rolling_max + [num]\n    else\n      rolling_max = rolling_max\
    \ + [min_value]\n    end\n    min_value = num\n  end\n  \n  rolling_max\nend",
  "  # Find first non-zero number in the list\n  i = 0\n  while i < numbers.length\
    \ and numbers[i] == 0\n    i += 1\n  end", "  numbers.inject([numbers.first])\
    \ do |rolling_max, number|\n    rolling_max if number > rolling_max[-1]\n  end\n\
    end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nYes I did a mistake in my\
    \ post, the array is given as a parameter to the function, and should return the\
    \ rolling max number found till the given moment\n<|/ c |>\n<| c |>\nThat would\
    \ have been helpful to say in your post. Fixed my answer appropriately. My answer\
    \ still works, but I'd be interested to know if there is a better solution.\n\
    <|/ c |>\n<| c |>\nI agree, and I will edit the post to include this information\
    \ as well :)\n<|/ c |>\n<| c |>\nI revised my solution to show you how to do it\
    \ without recursion. I also added a description for what the code does.\n<|/ c\
    \ |>\n<| c |>\nI thought about your solution, and I like the way you break it\
    \ into steps. However you also need to keep track of the last number that you've\
    \ found and compare it to the new number, and I don't think your solution does\
    \ that.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  numbers.each { |x| numbers.shift}\n\
    \  numbers.max\nend", "  rolling_max_value = numbers.shift\n  rolling_max_indices.shift\n\
    \  while numbers.any?\n    rolling_max_value = numbers.pop if numbers.size > rolling_max_size\n\
    \    rolling_max_indices.push(rolling_max_size) if numbers.size == rolling_max_size\n\
    \  end\n  rolling_max_value\nend\n</code>\n<|/ a dscore=0 tags=algorithm,ruby\
    \ |>\n<| a |>\nThis is my solution:\n<code>\nrequire 'set'", "  if numbers.empty?\
    \ then\n    []\n  else\n    rolling_max = numbers.first\n    rolling_max.each_cons(2)\
    \ do |n|\n      rolling_max = n if n > rolling_max\n    end\n  end\nend", "  numbers.each_cons(2)\
    \ do |a, b|\n    break if b.nil?\n    idx = numbers.index { |n| n >= b }.last\n\
    \    return [a, b] if idx == numbers.size - 1\n    idx += 1\n    [a, b] = [b,\
    \ numbers[idx]] if idx > 0 && numbers[idx] == a\n  end\n  nil\nend", "  max_num\
    \ = numbers.reduce(:max)\n  max_index = 0\n  index = 1\n  while max_index != numbers.index([max_num])\n\
    \    max_num = numbers[index-1]\n    max_index = index\n    index += 1\n  end\n\
    \  max_index\nend", "    rolling_maxs = []\n    cur_max_num = 0\n    cur_max =\
    \ numbers[0]", "  rolling_max_number = numbers[0]\n  numbers.each do |num|\n \
    \   rolling_max_number = Math.max(rolling_max_number, num)\n  end\n  rolling_max_number\n\
    end", "  numbers.each_with_index.inject([]) do |max, (max, index)|\n    current\
    \ =  numbers[index]\n    if current >= max\n      max\n    else\n      max\n \
    \   end\n  end\nend", "  numbers.each_with_index do |number, idx|\n    if idx\
    \ > 0\n      number.max == number ? number : number.max\n    else\n      number.max\n\
    \    end\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails-5,ruby-on-rails |>\n\
    <| a |>\nHere is a way using Enumerators:\n<code>\nrequire 'enumerator'", "  sum\
    \ = 0\n  max_number = numbers.shift\n  while numbers.length > 0\n    sum += numbers.shift\n\
    \    return max_number if sum > max_number || numbers.any? { |x| x > max_number\
    \ }\n    max_number = sum\n    sum = 0\n  end\nend", "  return numbers.reduce(:&)\n\
    end", "  return numbers.reduce(:&).reduce(:&)\nend", "  rolling_max_numbers =\
    \ []\n  numbers.each do |number|\n    rolling_max_numbers.push(number)\n    rolling_max_numbers.push(number)\n\
    \  end\n  rolling_max_numbers[1..-1]\nend", "    rolling_max_values = []\n   \
    \ rolling_max_values.clear\n    numbers.each do |number|\n      rolling_max_values\
    \ << number if rolling_max_values.last >= number\n    end\n    return rolling_max_values\n\
    end", "    max = numbers[0]\n    rolling_max_nums = []\n    for i in numbers\n\
    \        rolling_max_nums << i if i > max and i < max << 1\n    end\n    rolling_max_nums.reverse!\n\
    end", "  sorted = []\n  max_number = numbers.max\n  numbers.each do |number|\n\
    \    sorted << number if number >= max_number\n    sorted << max_number if number\
    \ == max_number\n  end\n  sorted\nend", "  numbers.reduce(:<<)\nend", "  rolled\
    \ = numbers.empty?\n  maximum = numbers.first\n  numbers.each_with_index do |num,\
    \ idx|\n    rolled ||= false\n    rolled = rolled or (idx == numbers.size - 1)\n\
    \    maximum = rolled ? (num > maximum) ? num : maximum : num\n  end\n  maximum\n\
    end", "  numbers.reduce(:<<)\nend", "  numbers.reduce(:<<)\n  numbers.reduce(:<<)\n\
    end", "  roll_array = Array.new(numbers.length + 1)\n  roll_array[1] = numbers[0]",
  "  numbers.reduce(:<<) do |max, number|\n    max if max < number\n  end\nend", " \
    \ numbers = numbers.map { |number| number > 0 ? number : -number }\n  rolling_max\
    \ = numbers.reduce(:+)\n  numbers.reverse.map { |number| number > 0 ? number :\
    \ -number }.first while numbers.last <= 0\n  numbers.reverse.map { |number| number\
    \ > 0 ? number : -number }.first(numbers.last).reverse\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\nA simple recursive solution which also\
    \ does not modify the original array (@numbers).\n<code>", "  return numbers.reduce(:<<).take_while\
    \ { |n| n <= number }.max\nend", "  sum = 0\n  rolling_index = 0\n  maximum =\
    \ nil\n  numbers.each do |n|\n    sum = sum + n\n    if sum > maximum\n      rolling_index\
    \ = numbers.index(n)\n      maximum = sum\n    end\n  end\n  maximum\nend", " \
    \ numbers.map { |num| [num, nums.max] }.to_h\nend", "  rolling_max_number = 0\n\
    \  rolling_max_index = 0\n  rolling_max_element = 0\n  \n  numbers.each_with_index\
    \ do |x, i|\n    if rolling_max_number < x\n      rolling_max_number = x\n   \
    \   rolling_max_index = i\n      rolling_max_element = x\n    end\n  end\n  \n\
    \  [rolling_max_number, rolling_max_index, rolling_max_element]\nend", "  return\
    \ rolling_max(numbers.reverse, 1) if numbers.size > 0 else []\nend", "  # Get\
    \ rid of any negative numbers (because rolling max will just take the max number)\n\
    \  numbers = numbers.select { |number| number >= 0 }\n  numbers.reduce(:+).to_f\n\
    end", "  rolling_max_numbers = []\n  rolling_max_number = numbers.shift", "  numbers.each_with_index\
    \ do |num, i|\n    numbers[i] = num if numbers[i-1] >= num\n  end\n  numbers\n\
    end", "  sum = 0\n  rolling_max.times do |times|\n    sum += numbers.shift\n \
    \ end\n  sum\nend", "  numbers.shift\n  numbers.max\nend\n</cell>\n<cell>", " \
    \ # We need to keep track of the last rolling maximum (the one that got rolled\
    \ so far)\n  # so we'll use a variable we'll have to update each time we roll\
    \ a new maximum\n  # We use the second argument for Array's 'set' method and it\
    \ will be the initial value\n  # of the first argument (which is the one we're\
    \ rolling towards currently)\n  # So if the current maximum is smaller than the\
    \ first argument (which we keep\n  # track of the current maximum by), we'll update\
    \ the current maximum with the\n  # second argument which is the first argument\n\
    \  if numbers.last.nil? || numbers.last.first < numbers.first\n    numbers.last\
    \ << numbers.first\n  else\n    numbers.last << numbers.first\n  end\nend", " \
    \ numbers.reverse_each.each.with_index.with_index do |number, index, collection|\n\
    \    collection[index] = number if collection[index] < number\n  end\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| a dscore=4 tags=ruby,max |>\nIn case you are not limited\
    \ to Ruby itself, you can use Array#reduce:\n<code>\narr.reduce { |m, n| m > n\
    \ ? m : n }", "  numbers.each do |number|\n    numbers.delete_at(0)\n    if number\
    \ > numbers.last\n      numbers.last, numbers[numbers.length] = number, number\n\
    \    end\n  end\nend", "  max_value = numbers.max\n  max_index = 0\n  index =\
    \ numbers.size - 1", "  rolling_max_numbers = numbers.dup.sort\n  rolling_max_numbers.shift\
    \ if rolling_max_numbers[0] == rolling_max_numbers.last # Handle corner case when\
    \ numbers is empty.\n  rolling_max_numbers.reduce { |rolling_max, number| rolling_max\
    \ > number ? rolling_max : number }\nend", "  if numbers.nil? || numbers.length\
    \ <= 0\n    []\n  else\n    window = numbers.length - 1\n    maximum = numbers.last\n\
    \    (0..numbers.length).step(1).each do |i|\n      if (numbers[i] - numbers[i-1])\
    \ > maximum\n        maximum = numbers[i] - numbers[i-1]\n      end\n    end\n\
    \    [ numbers ]\n  end\nend", "  # Calculate the first maximum\n  max = numbers[0]\n\
    \  # Store the maximum value\n  max_index = 0\n  # For each element\n  numbers.each_with_index\
    \ do |number, i|\n    # If the element is greater than the maximum\n    if number\
    \ > max\n      # Update the maximum value\n      max = number\n      # Update\
    \ the index\n      max_index = i\n    end\n  end", "  max = numbers.shift\n  numbers.each\
    \ { |n| max = n if n > max }\n  max\nend", "  numbers.each_with_index.map { |n,\
    \ i| n }.\n    each_cons(2).\n    map { |n1, n2| n1.to_s + n2.to_s }.\n    max\
    \ { |n1, n2| n1.to_i + n2.to_i }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=0 tags=ruby,ruby-on-rails |>\nThis might do what you're looking\
    \ for. \n<code>", "  numbers = numbers[0..-2].flatten.sort\n  numbers.each do\
    \ |number|\n    yield number if number > numbers.last\n  end\nend", "  numbers.each_cons(2)\
    \ do |first, second|\n    if first > second\n      first\n    else\n      second\n\
    \    end\n  end\nend", "  # find the first and last index of the number\n  first_index\
    \ = numbers.find_index { |n| n > numbers[0] }\n  last_index = numbers.find_index\
    \ { |n| n > numbers[numbers.size-1] }\n  return numbers.shift(first_index).zip(numbers.drop(last_index)).map\
    \ { |a, b| a > b ? a : b }\nend\n</cell>\n<text>\nLet's see how rolling_max works\
    \ with the example above:", "    numbers = numbers.sort.reverse\n    rolling_max\
    \ = numbers.first\n    maximum = numbers.last\n    numbers.each do |i|\n     \
    \   rolling_max < i ? rolling_max = i : maximum < i ? maximum = i : nil\n    end\n\
    \    rolling_max\nend", "  numbers = numbers.dup\n  rolling_max_numbers = []\n\
    \  rolling_max_numbers_count = numbers.count", "    numbers.max_by { |n| n.to_i\
    \ }\nend", "  numbers.each_with_index do |number, index|\n    numbers[index] ||=\
    \ number\n    numbers[index] <= number ? numbers[index] += numbers[index] : numbers[index]\n\
    \  end\n  numbers.max\nend", "  numbers.map { |x| x.to_i }.sort.each do |rolling_max|\n\
    \    numbers.map { |x| x.to_i }.sort.each_cons(rolling_max + 1) do |biggest|\n\
    \      biggest.each { |number| yield number }\n      break\n    end\n  end\nend",
  "  numbers.each_cons(2).map { |x, y| x if y > x }.compact.first\nend", "  numbers.map\
    \ { |x| x > numbers[numbers.size - 1] ? x : numbers[numbers.size - 1] }\nend",
  "  rolling_max = numbers.first\n  rolling_maxs = []\n  numbers.each do |number|\n\
    \    if number > rolling_max\n      rolling_max = number\n    end\n    rolling_maxs\
    \ << rolling_max\n  end\n  return rolling_maxs\nend", "  numbers.inject([]) {|result,\
    \ element|\n    result.last < element ? result << element : result << result.last\n\
    \  }.reverse\nend\n</cell>\n<cell>", "  rolling_max = numbers.first\n  numbers.each\
    \ do |number|\n    rolling_max = number if number > rolling_max\n  end\n  rolling_max\n\
    end", "  numbers.flatten.select { |n| n <= @max_number }.uniq.sort\nend", "  rolling_max\
    \ = numbers.reduce{|max, value| value > max ? value : max}\n  numbers.reduce(:<)\
    \ #TODO: fix this. this doesn't work.\nend", "  numbers.inject([]) do |rolling_max,\
    \ value|\n    rolling_max << value if rolling_max.max.nil? || rolling_max.max\
    \ > value\n    rolling_max\n  end\nend", "  n = numbers.sample\n  numbers.size.times\
    \ do |i|\n    n -= numbers[i - 1]\n    break if numbers[i]\n  end\n  n\nend\n\
    </code>\nHere is a generic version for any array type\n<code>", "  return numbers.each_cons(2).reduce(:<=).map(&:last)\n\
    end", "    numbers.each_cons(2) do |a,b|\n        if a > b\n            return\
    \ a\n        else\n            return b\n        end\n    end\nend", "  rolling_max_array\
    \ = []\n  rolling_max_value = nil\n  numbers.each do |number|\n    rolling_max_value\
    \ = number if rolling_max_value.nil? || number > rolling_max_value\n    rolling_max_array\
    \ << rolling_max_value\n  end\n  rolling_max_array\nend", "  numbers.each_cons(2)\
    \ do |roll|\n    roll.inject(0) do |rollingmax, element|\n      rollingmax > element\
    \ ? rollingmax : element\n    end\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a |>\nHere is another solution, which uses recursion and works better than other\
    \ solutions. \n<code>", "  n = numbers.size\n  numbers[0..n-1].max\nend", "  numbers.each\
    \ do |number|\n    rolling_max_index = number + 1\n    rolling_max_index = rolling_max_index.upto(numbers.size-1).find\
    \ { |i| numbers[i] > number }\n    numbers[rolling_max_index] = number\n  end\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
