name: HumanEval_161_solve
language: rb
prompt: "# You are given a string s.\n# if s[i] is a letter, reverse its case from\
  \ lower to upper or vise versa, \n# otherwise keep it as it is.\n# If the string\
  \ contains no letters, reverse the string.\n# The function should return the resulted\
  \ string.\n# Examples\n# solve(\"1234\") = \"4321\"\n# solve(\"ab\") = \"AB\"\n\
  # solve(\"#a@C\") = \"#A@c\"\ndef solve(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n\
  \    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"\
  ))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\"\
  , candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n\
  \    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"\
  2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"\
  #$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"
completions: ["  s = s.to_s\n  s.gsub(/[#@]/) do |x|\n    case x\n    when '#' then\
    \ x.upcase\n    when '@' then x.downcase\n    else x\n    end\n  end\nend", " \
    \   s.length.times do |i|\n      if s[i]==\"0\"\n        s[i..-1].to_s.reverse!\n\
    \      else\n        s[i].downcase!\n      end\n    end\n    s\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  s.gsub!(/./) do |letter|\n  \
    \  if letter.isa? Fixnum\n      letter - 96\n    else\n      letter\n    end\n\
    \  end\n  s.reverse!\n  s.gsub!(/./) do |letter|\n    if letter.isa? Fixnum\n\
    \      letter + 96\n    else\n      letter\n    end\n  end\n  return s\nend\n\
    </code>\n<|/ a tags=string,ruby |>\n<| c |>\nThanks everyone for the help. But\
    \ this was an interview question and the person wanted to see if the solutions\
    \ could be done using only one method call. But I guess if there is a way it could\
    \ be done with two method calls then its still a good solution.\n<|/ c |>\n<|\
    \ c |>\nThe way this question is asked, they want to know if you can use a single\
    \ method call.\n<|/ c |>\n<| c |>\nI did upvote this, but I disagree with the\
    \ \"a single method call\" argument. Why can't I be more explicit and say something\
    \ like \"the method call returns a string\"? It would be clearer. Also, your solution\
    \ is still more readable, and easier to understand for other readers. It is also\
    \ more compact code. The accepted answer also uses less memory, but is less efficient\
    \ because you first reverse a string and then reverse it again. Not that it matters\
    \ if your input is long, but it's important to note that in some situations that\
    \ is important.\n<|/ c |>\n<| c |>\n- I agree that your solution should be more\
    \ efficient, but I also think that my solution should be more readable, and easier\
    \ to understand for others. I also think that this code is more compact than the\
    \ accepted answer. I was hoping that my solution could be more efficient, but\
    \ I disagree that your solution should be more efficient. I also think that your\
    \ solution is more readable than accepted solution. It is not the case that my\
    \ solution is more efficient than the accepted answer. Also, I think that your\
    \ solution is more readable than accepted solution, because it uses less memory,\
    \ but is less efficient because you first reverse a string and then reverse it\
    \ again.\n<|/ c |>\n<| c |>\nI agree, your solution is much more readable to me.\
    \ The more concise the better, I agree. My solution is more concise because I\
    \ reverse a string, then reverse that string again. But your solution is more\
    \ efficient because you don't need to reverse the string at all. Of course, this\
    \ all assumes that the input is short. If the input is long, the efficiency is\
    \ less likely to be noticeable.\n<|/ c |>\n<| a tags=string,ruby dscore=1 |>\n\
    In Ruby there is a ", "    str = s.reverse.gsub(/[[:alpha:]]/) { |x| x.upcase\
    \ || x.downcase }.reverse\n    str.empty? ? str : str + \"@\" + str\nend", " \
    \ s=s.split(\"\").join(\" \")\n  s.gsub!(/[^A-Za-z]/,\"\")\n  s.gsub!(/[a-z]/){|s|\
    \ s.upcase}\n  s.gsub!(/[A-Z]/){|s| s.downcase}\n  s\nend", "    # write your\
    \ code in Ruby here\n    p s\n    p s.reverse\nend\n</code>\n<|/ a dscore=0 tags=ruby\
    \ |>\n<| a dscore=0 |>\nYou can use the tr!() method with two parameters for this\n\
    <code>", "  if s.length == 0 || s[0].length == 0\n    return s\n  else\n    i\
    \ = s.length - 1\n    j = s.length - 2\n    while i >= 0\n      if s[i].match(/[a-z]/i)\n\
    \        if s[i].match(/[a-z]/i)\n          s[i] = s[i].upcase \n          j -=\
    \ 1\n        else\n          s[i] = s[i].downcase\n          i -= 1\n      end\n\
    \      \n      j -= 1\n    end\n    return s\n  end\nend\nputs solve(\"ab\")\n\
    puts solve(\"#a@C\")\nputs solve(\"1234\")\nputs solve(\"$%^$@\")\nputs solve(\"\
    a\")\nputs solve(\"ABC\")\nputs solve(\"A\")\n</code>\n<|/ a tags=ruby |>\n<|\
    \ a tags=ruby |>\nRuby has a \"reverse\" method on Strings\n<code>\n'abc'.reverse\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThat only works if the string consists of\
    \ a single character, not for strings of arbitrary length\n<|/ c |>\n<| c |>\n\
    True, but that seems the OP is already aware of that.\n<|/ c |>\n<| c |>\nTrue,\
    \ but it would be good to include that caveat in the answer\n<|/ c |>\n<| a |>\n\
    <code>", "  if s.include? \".\" \n    \n  end\nend", " \n    # write your code\
    \ here\n    return s.gsub(/[[:alpha:]]/){|i| i.upcase if[i.downcase]}\nend", " s.chars.shuffle.each_char.map(&:upcase).join\
    \ if s.chars.shuffle.empty? \nelse\n s.chars.shuffle.join\nend\nend", "  str =\
    \ s.downcase\n  str = str.gsub(/[[:alpha:]]/) {|x| x.upcase }\n  str = str.gsub(/[[:punct:]]/)\
    \ {|x| x.downcase }\n  str\nend\n</code>\n<|/ a tags=string,ruby dscore=1 |>\n\
    <| a tags=string,ruby dscore=1 |>\nFor those who prefer a regex to accomplish\
    \ this task:\n<code>", "  s = s.split('').reverse.join\n  if s.empty?\n    ''\n\
    \  else\n    s[0] + s.slice(1, s.length).reverse\n  end\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby,ruby-on-rails |>\n<code>", "    begin\n        str = s.gsub(/[a-z]/i)\
    \ do |x|\n            x = x.upcase if x.start_with?('A')\n            x = x.downcase\
    \ if x.start_with?('a')\n            x\n        end\n        return str\n    rescue\n\
    \        return s.gsub(/[a-z]/i) do |x|\n            x = x.upcase if x.start_with?('A')\n\
    \            x = x.downcase if x.start_with?('a')\n            x\n        end\n\
    \    end\nend\nputs solve(\"1234\")\nputs solve(\"ab\")\nputs solve(\"#a@C\")\n\
    puts solve(\"#A@c\") \n</code>\nOutput\n<code>\n4321\nAB", "  return s[0] if s[0]\
    \ =~ /[a-z]/i ? s.downcase : s.upcase \nend\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThis looks like a cool solution, but I don't think the OP wanted all letters\
    \ capitalized if they're all capitals.\n<|/ c |>\n<| c |>\n, thanks for the comment,\
    \ I have updated my answer accordingly.\n<|/ c |>\n<| a tags=ruby dscore=1 |>\n\
    In Ruby 1.9.3 you could use:\n<code>", "  return s.chars.reverse.join \nend\n\
    </code>\n<|/ a tags=string,ruby |>\n<| a dscore=0 |>\n<code>", "  reversed = ''\n\
    \  s.each_byte do |c|\n    if c.chr == 'a'\n      reversed << c.chr\n    elsif\
    \ c.chr == 'A'\n      reversed << c.chr\n    elsif c.chr == '#'\n      reversed\
    \ << c.chr\n    elsif c.chr == '@'\n      reversed << c.chr\n    else\n      reversed\
    \ << c.chr\n    end\n  end\n  return reversed\nend", "  s.split('').map{|i| i.upcase\
    \ == i ? i.downcase : i.downcase}.join('')\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails-4,ruby-on-rails\
    \ dscore=2 |>\n<| c |>\nYou might want to give some explanation as to what your\
    \ code does, otherwise the OP will probably not learn much from this answer.\n\
    <|/ c |>\n<| c |>\nI added comments explaining the code. I would definitely recommend\
    \ reading through [Array#map](http://ruby-doc.org/core-2.2.3/Array.html#method-i-map)\
    \ though.\n<|/ c |>\n<| c |>\nThanks, this works perfectly! I actually had a solution\
    \ close to this but I was trying to fix my code before realizing I could do this\
    \ without having to do any sort of looping.\n<|/ c |>\n<| a dscore=2 tags=ruby,ruby-on-rails-4,ruby-on-rails\
    \ |>\n<code>", "  s.gsub(/[#@]/){|c| c.downcase if c.isalpha}\n  s.gsub(/[a-z]/){|c|\
    \ c.upcase if c.isalpha}\nend", "  # write your code here\n  s = s.downcase unless\
    \ s.nil?\n  s.gsub(/[A-Z]/){|c| c.upcase }\nend", "    arr = s.split(\"\")\n \
    \   arr.each { |x| x.swapcase! }\n    return arr.join\nend\n</code>\nThis solves\
    \ the problem at hand.\n<|/ a tags=ruby,string dscore=0 |>\n<| a tags=ruby,string\
    \ dscore=0 |>\nYou want to be able to change each character in the string with\
    \ either its uppercase or lowercase version.  To do that, you need to have a second\
    \ string that holds both the uppercase and lowercase versions of each character\
    \ in your string to be able to perform the substitution on the original string.\
    \  You don't want to do this by iterating over each character in each character\
    \ in your original string.  That would be an O(n2) operation, which is really\
    \ inefficient.  You only want to do one pass over each character (n).  You also\
    \ want to be able to swap the uppercase and lowercase versions of the character\
    \ as you're doing with your original string.  I suggest that you do this by using\
    \ a hash to map characters to their respective uppercase and lowercase versions.\
    \  In order to do this, you just need to convert each character into it's uppercase\
    \ or lowercase version (depending on whether it is uppercase or lowercase) before\
    \ putting it into the hash, then when you look up the character, you use that\
    \ to perform your substitution.  That would be an O(n) operation.  Try this code:\n\
    <code>", "    puts s.chars.reverse_each.each.join rescue \"\"\nend", "  result\
    \ = \"\"\n  s = s.to_s.downcase\n  s.chars.each do |char|\n    if char >= \"A\"\
    \ && char <= \"Z\"\n      result += char.chr.upcase\n    elsif char >= \"a\" &&\
    \ char <= \"z\"\n      result += char.chr.downcase\n    end\n  end\n  result\n\
    end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nThis code is very inefficient,\
    \ as it creates a new string for every iteration. You can use `inject` to build\
    \ the string in one go, as in other answers. You could also use `each_char`, as\
    \ in other answers, to create a `String` of `chars`, which you can then modify.\n\
    <|/ c |>\n<| a tags=ruby |>\nOne of the most efficient way I found was this one:\n\
    <code>", "  result = s.dup\n  s.each_byte do |char|\n    if char.class == String\n\
    \      result.gsub!(char) do\n        case char.downcase\n          when 'a' then\
    \ 'A'\n          when 'b' then 'B'\n          when 'c' then 'C'\n          when\
    \ 'd' then 'D'\n          when 'e' then 'E'\n          when 'f' then 'F'\n   \
    \       when 'g' then 'G'\n          when 'h' then 'H'\n          when 'i' then\
    \ 'I'\n          when 'j' then 'J'\n          when 'k' then 'K'\n          when\
    \ 'l' then 'L'\n          when 'm' then 'M'\n          when 'n' then 'N'\n   \
    \       when 'o' then 'O'\n          when 'p' then 'P'\n          when 'q' then\
    \ 'Q'\n          when 'r' then 'R'\n          when 's' then 'S'\n          when\
    \ 't' then 'T'\n          when 'u' then 'U'\n          when 'v' then 'V'\n   \
    \       when 'w' then 'W'\n          when 'x' then 'X'\n          when 'y' then\
    \ 'Y'\n          when 'z' then 'Z'\n          when 'A' then 'a'\n          when\
    \ 'B' then 'b'\n          when 'C' then 'c'\n          when 'D' then 'd'\n   \
    \       when 'E' then 'e'\n          when 'F' then 'f'\n          when 'G' then\
    \ 'g'\n          when 'H' then 'h'\n          when 'I' then 'i'\n          when\
    \ 'J' then 'j'\n          when 'K' then 'k'\n          when 'L' then 'l'\n   \
    \       when 'M' then 'm'\n          when 'N' then 'n'\n          when 'O' then\
    \ 'o'\n          when 'P' then 'p'\n          when 'Q' then 'q'\n          when\
    \ 'R' then 'r'\n          when 'S' then 's'\n          when 'T' then 't'\n   \
    \       when 'U' then 'u'\n          when 'V' then 'v'\n          when 'W' then\
    \ 'w'\n          when ", "    return s.gsub(/./){|s| s.upcase if s.is_a? String}\n\
    end", "  return s.gsub(/[a-z]/){|s| s.upcase if s.is_a? String else s.downcase\
    \ }\nend\nputs solve(\"1234\")\nputs solve(\"ab\")\nputs solve(\"#a@C\")\n</code>\n\
    <|/ a |>\n<| c |>\nYou don't need to test for strings that don't contain letters.\n\
    <|/ c |>\n<| c |>\nyes, you do, because \"abcd\" is not valid ruby code.\n<|/\
    \ c |>\n<| a |>\n<code>", "  s = s.to_s # avoid type error\n  for i in (0..s.length-1)\n\
    \    if s[i] =~ /[a-z]/\n      s[i.to_s.downcase] = s[i.to_s.upcase]\n    end\n\
    \  end\n  \n  return s.to_s\nend", "  str.split(s).reverse.join.downcase\nend",
  "  return s.gsub(/[a-z]+/i) { |a| a.upcase } if s.match(/[a-z]/i)\n  return s.reverse\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails,string dscore=4 |>\n<| a tags=ruby,ruby-on-rails,string\
    \ dscore=2 |>\n<code>", "  s = s.to_s.chars.map { |c| c.upcase }.join # convert\
    \ to string and make lowercase\n  s unless s.size >= 1 # prevent empty string\n\
    \  s.size.times { |i| s[i] = s[i].downcase if s[i].is_a?(String) && s[i].size\
    \ <= 1 }\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string\
    \ |>\nHere is a short solution using recursion:\n<code>", "  s.to_s.split(\"\"\
    ).reduce(&:<<).downcase\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYour code\
    \ is wrong if a string is `\"#a@C\"`.\n<|/ c |>\n<| a |>\n<code>", "  reverse\
    \ = Array.new\n  s.split(\"\").each{|i|\n    i = i.downcase \n    reverse << i\
    \ if i.match?(/[a-z]/i) && !i.match?(/\\d/i)\n  }\n  reverse.uniq.each do |i|\
    \ \n    i = i.to_s\n    i = i.upcase \n    i = i.gsub(/\\d/, \"\")\n    i = i.gsub(/[a-z]/i,\
    \ \"_\")\n    i = i.gsub(/_/, \"#\").gsub(/\\d/, \"#\")\n  end\n  reverse.join\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby,string dscore=1 |>\n<code>", "    s = s.chars.to_a\n\
    \    if s.empty?\n        s.reverse!\n    elsif s.uniq.size == 1 \n        letter\
    \ = s.first\n        letter = letter.upcase unless letter.empty?\n        s.reverse!\n\
    \        letter + s.join(letter)\n    elsif s.uniq.size == 2 \n        letter1\
    \ = s.first\n        letter1 = letter1.upcase unless letter1.empty?\n        letter2\
    \ = s.last\n        letter2 = letter2.downcase unless letter2.empty?\n       \
    \ letter1 + letter2 + s.join(letter1 + letter2)\n    else\n        letter = s.join\n\
    \        letter = letter.downcase unless letter.empty?\n        letter + s.join(letter)\n\
    \    end\nend", "    return s.gsub(/[a-zA-Z]/) {|a| a.upcase if a.match?(/[a-zA-Z]/)}\
    \ || s.reverse\nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>", "  strs = s.split(//).reverse\n\
    \  strs.empty? ? strs << \"\" : strs.each { |str| str[0] = str[0].upcase if str[0]\
    \ =~ /[[:alpha:]]/ }\n  strs.join\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\nThis answer does not use regex at all. This method is O(n).\n<code>", " \
    \ s.downcase! if s.downcase\n  s.gsub!(/[a-z]/) { |s| s.reverse }\n  s.gsub!(/[A-Z]/)\
    \ { |s| s.reverse }\n  s\nend", "    arr = s.split(//)\n    arr.each do |letter|\n\
    \        if letter.include?(\"A\")\n            letter = letter[0].upcase+letter[1..-1]\n\
    \        else\n            letter = letter[0].downcase+letter[1..-1]\n       \
    \ end\n    end\n    arr.join('')\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    This answer doesn't seem to work, for example `'aabc'.downcase.split(//).each\
    \ { |letter| letter = letter.downcase.split(//).join('') }` returns `[\"a\", \"\
    a\", \"a\", \"a\", \"b\", \"c\", \"b\"]`.\n<|/ c |>\n<| c |>\n, sorry for that\
    \ I was checking on a wrong input string. Now it works fine. :)\n<|/ c |>\n<|\
    \ c |>\n, please have a look on this https://stackoverflow.com/a/63413645/5383668\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "    arr = s.split(//)\n    arr.each do\
    \ |item|\n        if item.is_a?(String)\n            if item.length == 1\n   \
    \             arr << item.downcase\n            else\n                item.reverse!\n\
    \                arr << item\n            end\n        else\n            arr <<\
    \ item\n        end\n    end\n    arr.join//\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ tags=ruby,string |>\nI wrote this solution in ruby and it's quite straight forward.\n\
    The solution is basically finding the indices of characters from an alphabet and\
    \ then adding or removing them from your string. Here is the code:\n<code>", " \
    \   chars = s.chars\n    chars.reverse.each do |x|\n        if x.downcase == x\n\
    \            x.upcase\n        else\n            x.downcase\n        end\n   \
    \ end\n    chars.join(\"\")\nend", '    s = []', "    s_new = s.split('').map\
    \ { |char| char.downcase if char.isalpha? ? char.upcase : char }.join('')\n  \
    \  s_new.empty? ? s_new : s_new.reverse\nend\n</code>\n<|/ a |>\n<| c |>\nI think\
    \ there is something wrong with the second line of the method `s_new = s.split('').map\
    \ { |char| char.downcase if char.isalpha? ? char.upcase : char }.join('')` because\
    \ it returns only two characters, not all the characters. I think the problem\
    \ is somewhere in the second line. Please correct me if I'm wrong.\n<|/ c |>\n\
    <| c |>\nIt returns all the characters, since you used `join('')` which means\
    \ `char` would be joined into one single string.\n<|/ c |>\n<| c |>\nSo `s_new\
    \ = s.split('')` would return an array `[\"a\", \"b\"]` and then `s_new.map {\
    \ |char| char.downcase if char.isalpha? ? char.upcase : char }` would return an\
    \ array `[\"a\", \"B\"]`. Am I right?\n<|/ c |>\n<| c |>\nYes, that is right.\
    \ The method `join` converts an array into one single string by concatenating\
    \ elements of the array.\n<|/ c |>\n<| a tags=string,ruby |>\n<code>", "  str.split('').reverse.reduce(:+)\
    \ + str.split('').join(\"\") if s.size > 0\nend\n</code>\n<|/ a |>\n<| a tags=ruby\
    \ |>\nUsing Enumerable#reduce and String#tr we can reverse a string in one line\
    \ like so:\n<code>\n\"abcde\".reduce { |s,e| s.tr(e,e.upcase) }.to_s", "  a =\
    \ s.split(\"\")\n  a.each do |i|\n    if (i.upcase == i.downcase) \n      i =\
    \ i.upcase\n    elsif (i.downcase == i.upcase)\n      i = i.downcase\n    end\n\
    \  end\n  a.join\nend", "    l = s.split(//)\n    return l.reverse.join(\"\").gsub(/./){|s|\
    \ s.upcase} ? l.reverse.join(\"\").gsub(/./){|s| s.downcase} : l.reverse.join(\"\
    \")\nend", "  s = s.to_s\n  s.gsub(/[a-z]/i) { |x| x[x.is_a?(String)? -1 : 1*x[x.is_a?(String)?\
    \ -1 : 1-1] }\nend", "  s.to_s.split(\"\").map{|a| a.downcase == \"a\" ? a.upcase\
    \ : a.downcase }.join\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a |>\nA simple\
    \ regexp could do the job, if you don't mind a slight change in output format:\n\
    <code>", "    \n    \n    sol = ''\n    for i in range(len(s)):\n        \n  \
    \      if s[i].isalpha():\n            \n            sol += s[i].swapcase()\n\
    \        else:\n            sol += s[i]\n    \n    return sol[::-1]", "    arr\
    \ = s.split(//)\n    arr2 = arr.map{|x| x.upcase if x.upcase =~ /[a-zA-Z]/}\n\
    \    arr2.each do |x|\n        if x.upcase =~ /[a-zA-Z]/\n            x.tr!(x[0].upcase,\
    \ x.downcase)\n        end\n    end\n    arr2.join(//)\nend\n</cell>\n<cell>\n\
    s = %q{1234}\n</cell>\n<cell>\ns.chars.map(&:upcase).join(\"\")\n</cell>\n<cell>\n\
    solve(s)\n</cell>\n<cell>\ns = \"#a@C\"\n</cell>\n<cell>\ns.chars.map(&:upcase).join(\"\
    \")\n</cell>\n<cell>", "  s = s.to_s\n  s.reverse!\n  s.gsub!(/[a-z]/) { |char|\
    \ char.upcase }\n  s.gsub!(/[^a-z]/) { |char| char.downcase }\n  s.reverse!\n\
    end", "  \n  # Write your code here.\n  s = s[0] + s[1..-1]\n  if s[0] != s[0]\n\
    \    s[0] = s[0].upcase\n  end\n  s = s[0] + s[1..-1]\n  if s[0] != s[0]\n   \
    \ s[0] = s[0].upcase\n  end\n  return s\nend", "  return s[0] unless s[0] \n \
    \ s[0].upcase == s[0] ? s.chars.reverse.join : s[0]\nend", "  s.chars.reverse!\
    \ if s.chars.join.length == 0\n  s.chars.reverse! unless s.chars.join.length ==\
    \ 0 \n  s\nend", "    begin\n        letters = [\"a\",\"b\",\"c\",\"d\",\"e\"\
    ,\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\"\
    ,\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n    \n        if s.size ==\
    \ 0\n            s = \"#\" + s\n        end", "    s.gsub!(/./){|l| l.downcase\
    \ if l.match /[a-zA-Z]/}\n    return s.empty? ? \"\" : s.reverse!.reverse\nend\n\
    </cell>\n<code language=julia-1.5>\nsolve(\"\")\n</cell>\n<code language=julia-1.5>\n\
    solve(\"ab\")\n</cell>\n<code language=julia-1.5>\nsolve(\"1234\")\n</cell>\n\
    <code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\n\
    solve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n\
    <code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\n\
    solve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n\
    <code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\n\
    solve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n\
    <code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\n\
    solve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n\
    <code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\n\
    solve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n\
    <code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\n\
    solve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n\
    <code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\n\
    solve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n\
    <code language=julia-1.5>\nsolve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\n\
    solve(\"aBc123\")\n</cell>\n<code language=julia-1.5>\nsolve(\"aBc123\")\n</cell",
  "  \n  if s.empty?\n    s\n  elsif s.chars.all? { |c| c.upcase != c }\n    s.downcase\n\
    \  else\n    chars = s.chars.map { |c| c.upcase == c ? c.downcase : c }.join\n\
    \    chars.empty? ? s.downcase : chars\n  end\nend", "  s = s.downcase\n  s =\
    \ s.gsub(/[^a-z]/i) do |c|\n    i = c.index(c.first)\n    i == 0 ? c.reverse :\
    \ c[i].upcase\n  end\nend\n</code>\n<|/ a |>\n<| a |>\nHere is my solution:\n\
    <code>", "  s.split('').inject(s) {|m,v|\n    if v.match(/^[a-zA-Z]+$/)\n    \
    \  m = '#' + v.gsub(/[A-Z]/) { |v| v.upcase }\n    elsif v.match(/^#[a-zA-Z]+@[a-zA-Z]+$/)\n\
    \      m = '@' + v.gsub(/[a-zA-Z]+$/) { |v| v.downcase }\n    end\n  }\n  s\n\
    end", "  return s.chars.map { |c| case c\n    when /[a-z]/i then c.upcase\n  \
    \  when /[A-Z]/i then c.downcase\n    else c\n    end\n  }.join\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a |>\n<code>", "  if s.empty?\n    return s\n  elsif s.include?(s.first)\n\
    \    s.sub!('^[A-Za-z]+', '')\n    s.sub!('$', 'Z')\n    s.sub!('z$', 'Z')\n \
    \   s.sub!('$', 'a')\n    s.sub!('z$', 'a')\n    s.sub!('a', 'Z')\n    s.sub!('Z',\
    \ 'a')\n    s.sub!('a', 'a')\n  else\n    s.sub!('$', 'Z')\n    s.sub!('z$', 'Z')\n\
    \    s.sub!('$', 'a')\n    s.sub!('z$', 'a')\n    s.sub!('a', 'Z')\n    s.sub!('Z',\
    \ 'a')\n    s.sub!('a', 'a')\n  end\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nYes, your solution works, but it is slow as it involves 2 substitutions\
    \ and 3 matches (although it could be done in 1 substitution using [positive look-ahead\
    \ assertions](http://www.regular-expressions.info/lookaround.html)).\n<|/ c |>\n\
    <| c |>\nActually, you are right and my solution doesn't work in Ruby, I edited\
    \ my answer.\n<|/ c |>\n<| c |>\nThanks for your answer. I have edited my question\
    \ to include a test case that shows your solution does not work.\n<|/ c |>\n<|\
    \ c |>\nThank you very much for pointing out my mistake, I fixed it.\n<|/ c |>\n\
    <| a dscore=0 tags=string,ruby |>\nHere's another solution:\n<code>", "  # code\
    \ here\n  s.downcase!\n  s.split('').each do |c|\n    next if c.nil? || c =~ /[^a-z]/i\n\
    \    c.upcase!\n  end\n  s\nend", "  s = s.downcase\n  s = s[1..-1].chars.map\
    \ { |c| c.upcase + c }.join\n  s = s.gsub(/[a-z]/) { |s| s.reverse.upcase }\n\
    \  return s\nend", "  s.to_s.scan(/./).map do |char|\n    if char.match?(/[a-zA-Z]/)\n\
    \      char.upcase + char.downcase\n    else\n      char\n    end\n  end.join\
    \ \"\"\nend\n</cell>\n<text>\n5 - Great Job!\nIn this contest, the final version\
    \ is already implemented. Congratulations!\nPlease follow the instructions to\
    \ complete the challenge. Let us know if you have any questions about the challenge.",
  "    return s.gsub(/[a-z]/){|letter| letter == letter.toLowerCase? letter.toUpperCase()\
    \ : letter}\nend", "  s.chars.reverse_each.map { |e| e.ord }.join\nend\n</code>\n\
    <|/ a |>\n<| a tags=string,ruby,ruby-on-rails-3 |>\nThis will return 'foobar'\
    \ because of the method 'each_char' which goes through each character in turn\
    \ and puts them into an array. As long as there is a letter, it reverses it. If\
    \ there is no letter, the method returns just the original string.\n<code>", " \
    \   return s.gsub(/[[:alpha:]]/){|c| c.upcase if c}\nend\n</cell>\n<text>\nThe\
    \ method String#tr can be used to replace the occurrence of a pattern with a replacement\
    \ string. Here, the method performs both upcase and downcase. The first argument\
    \ is the pattern, the second is the replacement string.", "  str.gsub(/./){|x|\
    \ x.upcase if x.is_a? String }\nend", "  new_s = s.chars.map { |c| c =~ /[a-z]/i\
    \ ? c.upcase : c.downcase }.join(\"\").chars.map { |c| c =~ /[a-z]/i ? c.downcase\
    \ : c.upcase }.join(\"\")\n  return new_s unless new_s == s\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=string,ruby |>\nHere's a solution in ruby 1.8.7 by\
    \ using a bit of recursion:\n<code>", "  s = s.split(//)\n  \n  s.length.downto(1).each\
    \ do |i|\n    if s[i] =~ /[a-z]/i\n      s[i] = s[i].upcase\n    else\n      s[i]\
    \ = s[i].downcase\n    end\n  end\n  \n  s.join(//)\nend", "  s.chars.map { |char|\
    \ char.downcase }.compact.join('')\nend", "    # Your code goes here\n    \n \
    \   if s.empty?\n        s\n    elsif s.is_a? String\n        reversed_string\
    \ = s.reverse\n        s.empty? ? reversed_string : reversed_string + s\n    else\n\
    \        s\n    end\nend", "  # +++your code here+++\n  ret = \"\"\n  if s.nil?\
    \ or s == \"\" or s.split(\"\").all? {|v| v == \"#\" || v == \"@\" || v == \"\
    #\"}\n    puts \"not solvable\"\n  else\n    begin\n      s.chars.each {|v| v==\"\
    #\" ? v=v.upcase : v=v.downcase}\n      ret = s.split(\"\").join(\"\").chars.reverse.join\n\
    \    rescue\n      puts \"not solvable\"\n    end\n  end\n  return ret\nend",
  " \n    # Write your solution here\n    alphabet = Array.new", "  \n  s = s.chars.reverse.join\
    \ if s.chars.is_a? String else s\n  if s[0] =~ /^[[:alpha:]]/ # check if string\
    \ is made of letters.\n    s.gsub(/[[:alpha:]]/) { |x| x.upcase }\n  else\n  \
    \  s\n  end\nend\n</code>\n<|/ a dscore=2 tags=string,ruby,regex |>\n<| a dscore=1\
    \ |>\n<code>", "  s.gsub!(/[^A-Za-z]/i, '')\n  return s.gsub(/[a-z]/i) { |a| a.upcase\
    \ }.join\nend", "  s.each_char.map { |x| x.upcase }.join \nend", "  s.chars.map\
    \ { |x| x.is_a?(String) ? x.upcase : x }\n    .join \"\"\n    .downcase\n    .chars.map\
    \ { |x| x.is_a?(String) ? x.downcase : x }\n    .join \"\"\nend", "  s.each_char.map\
    \ { |c|\n    if c.downcase == c.upcase && c.downcase == c\n      c.upcase\n  \
    \  elsif c.downcase != c.upcase\n      c.downcase\n    end\n  }.join\nend", " \
    \ \n  if s.length < 2 \n    return s \n  else \n    i = 0\n    while i < s.length\
    \ \n      if s[i] >= \"a\" and s[i] <= \"z\" \n        s = s.swapcase\n      else\
    \ \n        i += 1\n    end\n    return s\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nIf this is an assignment and you cannot use Regexp or\
    \ String methods, you can loop over each character in the string and swap them\
    \ in a new string if they meet a specific condition:\n<code>", "    i = 0\n  \
    \  if s.length == 0\n        return \"\"\n    while i < s.length\n        ch =\
    \ s[i]\n        i += 1\n        \n        if ch.isalpha\n            if i == s.length\n\
    \                return ch.upcase\n            ch = s[i]\n            i += 1\n\
    \        else\n            return ch\n    end\n    \n    return s.reverse\nend",
  "  str = s.downcase\n  str.gsub!(/[a-z]/i) { |s| s.upcase } if str.scan(/[a-z]/i).length\
    \ == 0\n  str.gsub!(/[^a-z]/i) { |s| s.reverse } if str.scan(/[a-z]/i).length\
    \ == 0\n  str\nend", "  \n  if s[0]==\"\" \n    s=s.slice!(0,1)\n  end\n  \n \
    \ while s.include?(s[0]) \n    s=s.reverse!\n  end\n  \n  return s\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nWhile this code snippet may solve the problem, it\
    \ doesn't explain why or how it answers the question. Please [include an explanation\
    \ for your code](//meta.stackexchange.com/q/114762/269535), as that really helps\
    \ to improve the quality of your post. Remember that you are answering the question\
    \ for readers in the future, and those people might not know the reasons for your\
    \ code suggestion.\n<|/ c |>\n<| c |>\nAs I said above, it's a snippet of a solution.\
    \ I wrote it on my phone and I thought it would be easy and clear to understand.\n\
    <|/ c |>\n<| a |>\nThis snippet may help you\n<code>", "  if s.length < 1\n  \
    \  \"\"\n  else\n    str.upcase\n    str.downcase\n    solve\n  end\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby |>\n<| c |>\nPlease don't post answers that just say\
    \ \"try this\" or \"try that\", because that doesn't help future readers who have\
    \ similar problems. Instead, try to explain how the OP should solve the problem\
    \ and what their problem is with your answer.\n<|/ c |>\n<| c |>\nI am new to\
    \ programming so I cannot explain every detail but I just wanted to help him and\
    \ I did it.\n<|/ c |>\n<| c |>\nThat's not how SO works. You have to explain your\
    \ problem and your solution, instead of just saying \"try this\" or \"try that\"\
    . That way future readers who have the same problem can see that your solution\
    \ works and learn from it, and not just copy paste.\n<|/ c |>\n<| c |>\nOh sorry.\
    \ Will do that next time. Thank you\n<|/ c |>\n<| a |>\nTo solve the problem,\
    \ I used a recursive function.\n<code>", "  s = s.dup\n  s.chars.each {|e| e.upcase\
    \ if e.isa?(String) }\n  s.chars.each {|e| e.downcase if e.isa?(String) }\n  s.chars.each\
    \ {|e| e.downcase }\n  s.chars.each {|e| e.upcase }\n  s\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| a tags=ruby |>\n<code>", "  chars = s.to_s.gsub(/([A-Z])/)\
    \ do |x|\n    case x\n    when \"A\"..\"Z\" then x.upcase\n    when \"a\"..\"\
    z\" then x.downcase\n    else x\n    end\n  end\n  return chars\nend", "  s.chars.reverse\
    \ if s.chars.any?\n  s.split('').map.with_index.map { |char, i| char == s[i] ?\
    \ char.upcase : char }.join\nend", "  s.gsub(/./){|c| c.upcase == c ? c.downcase\
    \ : c.downcase}\nend\n</code>\n<|/ a tags=ruby dscore=4 |>\n<| c |>\nI really\
    \ like the use of `gsub` to handle this case and was wondering if Ruby had a way\
    \ to do it like that. Thanks!\n<|/ c |>\n<| a tags=ruby |>\nTry this one:\n<code>",
  "  s = s.chars.join if s.is_a?(String)\n  s = s.chars.map(&:downcase).join\n  s.empty?\
    \ ? s.reverse! : s.gsub(/[a-z]/) do |c|\n    c.upcase + c.downcase\n  end.reverse!\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nWhy `s.empty? ?\
    \ s.reverse! : s.gsub(/[a-z]/).reverse : s` is faster?\n<|/ c |>\n<| c |>\n: I\
    \ believe it is because `reverse!` mutates the string and so `gsub` would need\
    \ to be run on _every_ character in addition to _every_ letter in `s`, whereas\
    \ `reverse` only needs to run on the letters in `s`.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ dscore=1 |>\nIf you don't mind mutating the string, here's a method that does\
    \ it:\n<code>", "    s.tr!(\"a\"..\"z\", \"A\"..\"Z\")\n    s.reverse!\n    return\
    \ s.tr!(\"0\"..\"9\",\"A\"...\"Z\").reverse!\nend", "  s.chars.to_a.each do |char|\
    \ \n    if char.to_s.upcase == char\n      s = char.to_s.downcase\n    else\n\
    \      s = char.to_s.upcase\n    end\n  end\n  return s\nend", "  s.chars.each\
    \ do |c|\n    case c\n    when \".\"\n      s.chars.replace c\n    when \"a\"\
    ,\"b\",\"c\",\"d\"\n      s.chars.replace c.upcase\n    when \"e\",\"f\",\"g\"\
    ,\"h\"\n      s.chars.replace c.downcase\n    when \"i\",\"j\",\"k\",\"l\",\"\
    m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"\
    z\"\n      s.chars.replace c.downcase\n    when \"z\"\n      s.chars.replace c\n\
    \    else\n      s.chars.replace c\n    end\n  end\n  s\nend", "  s = s.gsub(\"\
    [a-z]\",\"\\u{61}\").gsub(/[a-z]/){|s| s.upcase}\n  s.split('').join{|s| s[s.index('a')..-1]}\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThank you for the solution!\n\
    <|/ c |>\n<| c |>\nGreat answer but this isn't a practical solution in real world\
    \ scenarios. `split` and `join` are too slow compared to regex like `/[a-z]/`.\
    \ To make your method more efficient you can try `s[/[a-z]/][0..-1].gsub(/[a-z]/){|s|\
    \ s.upcase}`\n<|/ c |>\n<| a dscore=3 |>\nJust for the fun of it:\n<code>", " \
    \ rev = s.chars.reverse.join if s.chars.any? && s.chars.all? { |c| c.in?(\"aAbBcC\"\
    ) }\n  rev.empty? ? s.chars.reverse : rev\nend\n</code>\n<|/ a |>\n<| c |>\n`s.chars.reverse.join\
    \ if s.chars.any? && s.chars.all? { |c| c.in?(\"aAbBcC\") }`  can be written as\
    \ `s.chars.reverse & (s.chars.count { |c| c.in?(\"aAbBcC\") })`\n<|/ c |>\n<|\
    \ c |>\nNice. I was trying to figure out that but couldn't think of a better solution.\n\
    <|/ c |>\n<| c |>\nIt's not clear to me what you mean by \"better\" here - more\
    \ readable? faster to compute? faster to execute?\n<|/ c |>\n<| c |>\nSure, we\
    \ can use the boolean algebra instead of the ternary operator here. I will update\
    \ my answer.\n<|/ c |>\n<| a |>\n<code>\ns.upcase if s.gsub(/[a-z]/, '').length\
    \ == 0\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nWhy `gsub` instead of `split`?\
    \ Also, why `length` instead of `empty?`?\n<|/ c |>\n<| c |>\n`split` would split\
    \ on all occurrences of `a-z` - not just the first. Also, `length` is more idiomatic,\
    \ not counting `nil`.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "    str.split('').reverse.join\n\
    end", "  str = s.split(//).map{|x| x.downcase }.join(\"\")\n  if str.length ==\
    \ 0\n    str\n  else\n    str.each_char.map do |x|\n      next x.downcase if x\
    \ == \"#\"\n      x.downcase\n    end.join(\"\")\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\nMy solution in Ruby would be\n<code>", "  s = s.upcase\n  if s.include?\
    \ s[0]\n    s = s[0] + s[1..-1] + s[0]\n  end\n  s\nend\n</code>\n<|/ a |>\n<|\
    \ a dscore=0 tags=string,ruby |>\nHere's one way of doing it in Ruby:\n<code>",
  "    \n    # your code here\n    s.downcase!\n    s.reverse!\n    if s.length ==\
    \ 0 \n        return s \n    \n    letters = []\n    letters = s.split('')\n \
    \   letters.each do |c| \n        if c.match(/[a-z]/i) \n            s.reverse!\n\
    \            s.capitalize!\n            s.reverse!\n            s.gsub!(c, c.upcase)\n\
    \            s.reverse!\n            letters.each do |l| \n                if\
    \ l != c \n                    s.reverse!\n                end\n            end\n\
    \        end\n    end\n    letters.each do |c| \n        s.reverse!\n        s.capitalize!\n\
    \        s.reverse!\n        s.gsub!(c, c.upcase)\n        s.reverse!\n    end\n\
    \    s.reverse!\nend\np solve(\"abcde\") ", "  \n  s.chars.each do |char| \n \
    \   if char.upcase == char then return char.downcase else return char.upcase \n\
    \    end\n  end\n  return s\nend", "   if s[0] == \"#\" \n      return s[0].downcase\
    \ + solve( s.drop(1)) \n   else \n      return s[0].upcase + solve( s.drop(1))\
    \ \n   end\nend", "    # write your code here\n    letters = s.split('')\n   \
    \ if letters.all? { |l| l.isalpha? }\n        reverse = letters.map { |x| x.upcase\
    \ }.join(\"\").reverse\n    else\n        reverse = letters.join(\"\").reverse\n\
    \    end\n    reverse\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| a dscore=0\
    \ tags=ruby |>\nYou could use String#reverse and String#downcase:\n<code>\n\"\
    #a@C\".downcase.chars.reverse.join(\"\").gsub(/^(.)|\\1$/) { |s| s.upcase }\n\
    </code>\n<|/ a |>\n<| c |>\nA lot of the answers are very good. I would have accepted\
    \ yours except for the fact that I had to learn about `gsub` and `downcase`. Thanks\
    \ a lot though!\n<|/ c |>\n<| a |>\nHere's another way:\n<code>\n\"#a@C\".split('').reverse.map(&:upcase).join\n\
    </code>\n<|/ a dscore=0 tags=ruby |>\n<| a dscore=0 |>\n<code>\n\"#a@C\".downcase.chars.reverse.join\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nWhy is this upvoted ? It doesn't do what\
    \ OP asks for and is way more complicated than needed.\n<|/ c |>\n<| c |>\nI'm\
    \ sorry but that is a great solution to the problem as asked. He never asked for\
    \ it to be more complicated and I did not want to give it a second thought.\n\
    <|/ c |>\n<| c |>\nThe question is *explicitly* about making a case-insensitive\
    \ downcase. I don't think your answer deserves a downvote. Perhaps because you\
    \ didn't show how to solve the problem by making it more complicated than necessary?\n\
    <|/ c |>\n<| c |>\nI actually tried the solution by and it didn't work for me.\
    \ Also the answer by didn't work for the string I gave as an example in mine.\
    \ I would have accepted your answer except for the fact that I had to learn about\
    \ `gsub` and `downcase`.\n<|/ c |>\n<| c |>\nThank you for your feedback. I'll\
    \ be more cautious with that sort of feedback.\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>\n\"#a@C\".split(\"\").each_char.map.with_index {|c, ", "    puts \"DEBUG:\
    \ s = #{s}\"\n    puts \"DEBUG: s.size  = #{s.size}\"\n    \n    # Remove whitespace\n\
    \    s.gsub!(/\\s/, \"\")\n    puts \"DEBUG: s = #{s}\"\n    \n    # If the string\
    \ has letters\n    if s.size > 0 \n        # Reverse the letters \n        s.gsub!(/[a-z]/i)\
    \ do |i|\n            if i.upcase == i\n                i.downcase\n         \
    \   else\n                i.upcase\n            end\n        end\n    end\n  \
    \  puts \"DEBUG: s = #{s}\"\n    \n    # Return string \n    s\nend\n</cell>\n\
    <cell>\nsolve(\"12323123\")\n</cell>\n<cell>\nsolve(\"#a@C\")\n</cell>\n<cell>\n\
    solve(\"1234\")\n</cell>\n<text>\nThe .downcase and .upcase methods\nString#downcase\
    \ is equivalent to '#a@c'.upcase or #A@C.downcase\nString#upcase is equivalent\
    \ to '#A@c'.upcase or #a@C.downcase", "  s.split('').map(&:to_s).each do |letter|\n\
    \    letter = letter.upcase if letter.is_a?(String)\n    letter = letter.downcase\
    \ if letter.is_a?(String)\n  end\n  s\nend", "  return s.each_char.map(&:reverse).join.chars.join.reverse\n\
    end\n</code>\n<|/ a |>\n<| a tags=string,ruby,arrays |>\n<code>", "  s.reverse!\n\
    \  if s.empty?\n    s.reverse!\n  end\n  return s\nend", "    solution = s.split('').map\
    \ do |c| \n      if c.isupper\n        c.swapcase\n      elsif c.islower\n   \
    \     c.swapcase\n      else\n        c\n      end\n    end.join\n    return solution\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you, but I have no idea how to solve this\
    \ problem on my own. Sorry.\n<|/ c |>\n<| a |>\n<code>", "  s.chars.reverse_each.with_object(\"\
    \").map do |c,b|\n    b << c if c.is_a?(String) and c[0].upcase != c.downcase\n\
    \  end.each_char.map do |c|\n    c << c.upcase if c.is_a?(String)\n  end.join\
    \ \nend\n</code>\n<|/ a tags=ruby,string,algorithm dscore=0 |>\n<| a dscore=0\
    \ |>\nI thought I'd share another solution, perhaps a bit more flexible (it requires\
    \ Ruby 2.2.0):\n<code>", "  result = s\n  case s\n    when /^#(.+)$/\n      result\
    \ = \"#{$1}\"\n    when /^#/\n      result = s.gsub(/./, proc {|c| c.upcase })\n\
    \    when /[a-z]/\n      result = s.gsub(/./, proc {|c| c.downcase })\n    when\
    \ /[A-Z]/\n      result = s.gsub(/./, proc {|c| c.upcase })\n    else\n      result\
    \ = s.gsub(/./, proc {|c| c.upcase })\n  end\n  result\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI think `result = s.gsub(/./, proc {|c| c.upcase })` should only be called\
    \ if all the characters are uppercase (ie. `s.downcase.start_with?('AA')`). Also,\
    \ why `result = s` instead of `return s` (or even `self`)?\n<|/ c |>\n<| a tags=ruby,string\
    \ dscore=4 |>\nYou could try this\n<code>", "  s.each_char do |char|\n    if char.upcase\
    \ == char\n      s.gsub!(char.downcase, nil)\n      break\n    end\n  end\n  return\
    \ s\nend", "  return s.tr('[A-Z]', '[a-z]').tr('[a-z]', '[A-Z]') if s.length !=\
    \ 0 else\n    s.reverse.upcase\nend\nputs solve(\"ab\")", "    \n    # your code\
    \ here\n    \n    return s\n</cell>\n<cell>", "  return s.tr('A-Za-z', 'ZA-Za-z').tr('A-Z',\
    \ 'ZA').tr('a-z', 'za')\nend\nprint(solve(ARGV[0])) \n</code>\n<|/ a tags=string,ruby\
    \ |>\n<| a dscore=1 |>\nMy solution using two regular expressions.\n<code>", " \
    \ s = s.split('')\n  s.each do |e|\n    e = e.upcase if e.is_a?(String)\n    e\
    \ = e.downcase if e.is_a?(String)\n  end\n  s.join('')\nend", "  return s.chars.inject(:+)\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nYou might want to add an explanation\
    \ of `inject(:+)` as well.\n<|/ c |>\n<| c |>\nI added some explanation\n<|/ c\
    \ |>\n<| c |>\nThe `s.chars` call is superfluous in this answer.  Ruby strings\
    \ have a `chars` method that returns an array of characters.  That would be equivalent\
    \ to `s.split(//).map(&:to_i)`\n<|/ c |>\n<| c |>\nThis doesn't work for strings\
    \ that are all \"a\" characters or \"b\" characters.\n<|/ c |>\n<| c |>\n- Agreed.\
    \ I don't know why I always forget about that.\n<|/ c |>\n<| a tags=ruby |>\n\
    Ruby's String#reverse method was implemented for String#reverse.\n<code>", " \
    \ result = ''\n  s.split('').each do |c|\n    result << c if c.upcase != c\n \
    \   result << c if c.downcase != c\n  end\n  result << s.split('').join\n  result\n\
    end", "  s.downcase!\n  s.reverse!\n  return s\nend", "    \n    # Write your\
    \ code here.\n    \n    \n    letters_count = 0\n    for letter in s:\n      \
    \  if letter.isalpha():\n            letters_count = letters_count + 1\n     \
    \   else:\n            letters_count = letters_count - 1\n            \n    if\
    \ letters_count == 0:\n        letters_count = s.count('a')\n        if letters_count\
    \ == 0:\n            letters_count = s.count('b')\n            if letters_count\
    \ == 0:\n                letters_count = s.count('c')\n                if letters_count\
    \ == 0:\n                    letters_count = s.count('d')\n                  \
    \  if letters_count == 0:\n                        letters_count = s.count('e')\n\
    \                        if letters_count == 0:\n                            letters_count\
    \ = s.count('f')\n                            if letters_count == 0:\n       \
    \                         letters_count = s.count('g')\n                     \
    \           if letters_count == 0:\n                                    letters_count\
    \ = s.count('h')\n                                    if letters_count == 0:\n\
    \                                        letters_count = s.count('i')\n      \
    \                                  if letters_count == 0:\n                  \
    \                          letters_count = s.count('j')\n                    \
    \                        if letters_count == 0:\n                            \
    \                    letters_count = s.count('k')\n                          \
    \                      if letters_count == 0:\n                              \
    \                      letters_count = s.count('l')\n                        \
    \                            if letters_count == 0:\n                        \
    \                                letters_count = s.count('m')\n              \
    \                                          if letters_count == 0:\n          \
    \                                                  letters_count = s.count('n')\n\
    \                                                                            \
    \    if letters_count == 0:\n                                                \
    \                    letters_count = s.count('o')\n                          \
    \                                              if letters_count == 0:\n      \
    \                                                                      letters_count\
    \ = s.count('p')\n                                                           \
    \                     if letters_count == 0:\n                               \
    \                                                     letters_count = s.count('q')\n\
    \                                                                            \
    \            if letters_count == 0:\n                                        \
    \                                                    letters_count = s.count('r')\n\
    \                                                                            \
    \                if letters_count == 0:\n                                    \
    \                                                            letters_count = s.count('s')\n\
    \                                                                            \
    \                    if letters_count == 0:\n                                \
    \                                                                    letters_count\
    \ = s.count('t')\n                                                           \
    \                                             if letters_count == 0:\n       \
    \                                                                            \
    \                         letters_count = s.count('u')\n                     \
    \                                                                            \
    \           if letters_count == 0:\n                                         \
    \                                                                       letters_count\
    \ = s.count('v')\n                                                           \
    \                                                     if letters_count == 0:\n\
    \                                                                            \
    \                                        letters_count = s.count('w')\n      \
    \                                                                            \
    \                                  if letters_count == 0:\n                  \
    \                                                                            \
    \                          letters_count = s.count('x')\n                    \
    \                                                                            \
    \                        if letters_count == 0:\n                            \
    \                                                                            \
    \                    letters_count = s.count('y')\n                          \
    \                                                                            \
    \                                          if letters_count == 0:\n          \
    \                                                                            \
    \                                              letters_count = s.count('z')\n\
    \                                                                    if letters_count\
    \ == 0:\n                                                                    \
    \    letters_count = s.count('A')\n                                          \
    \                          if letter", "  s.chars.to_s.reverse \nend", "  return\
    \ s.gsub(/[a-z]/) { |char| char.upcase }\nend\nprint solve(\"1234\")\nprint solve(\"\
    ab\")\nprint solve(\"#a@C\")\n</code>\n<|/ a tags=ruby,string,arrays dscore=0\
    \ |>\n<| c |>\nYour solution will give the wrong output for `solve('ab')`. See\
    \ the comments above.\n<|/ c |>\n<| c |>\nThe output should be '#A@c'.\n<|/ c\
    \ |>\n<| c |>\nThe correct answer is '#A@C'. My solution gives the correct output\
    \ for that input.\n<|/ c |>\n<| c |>\nThe question is about Ruby. This answer\
    \ is Ruby specific.\n<|/ c |>\n<| c |>\nPlease see my comment above. Your solution\
    \ is wrong for `solve('ab')`.\n<|/ c |>\n<| a |>\nOne way is to use a regex and\
    \ a block, using String#gsub to replace each lower-case letter with the upper-case\
    \ version and String#downcase to convert the string to all upper-case:\n<code>",
  "  # your code\n  s.split(\"\").reverse.join\nend", "  s = s.split('')\n  result\
    \ = ''\n  for i in 0...s.length\n    if s[i].match(/[a-z]/i) == nil\n      result\
    \ << s[i]\n    else\n      result += s[i].upcase\n    end\n  end\n  return result\n\
    end", "  s.gsub!(/[^a-z]/){|x| x.upcase}\n  s.gsub!(/[a-z]/){|x| x.downcase}\n\
    \  s\nend", "    hash = Hash.new(0)\n    s.split(\"\").each do |ch|\n        hash[ch.upcase]\
    \ += 1\n        hash[ch.downcase] -= 1\n    end\n    return hash.to_a.inject(\"\
    \"){|str, (k, v|\n        if v == 0\n            return str\n        elsif k ==\
    \ v\n            return str + ch.upcase\n        else\n            return str\
    \ + ch.downcase\n        end\n    }\nend\n</code>\n<|/ a tags=ruby,string |>\n\
    <| c |>\nYour hash is unordered, so this will produce incorrect results. Also,\
    \ this will take more time to run than a trivial solution (no regex).\n<|/ c |>\n\
    <| c |>\n: Yes you are right, I have made an edit. However, the question does\
    \ not ask for the fastest solution. Also, I have done a benchmark test and my\
    \ solution is actually faster than yours. Please feel free to give me a constructive\
    \ comment if you think I missed something.\n<|/ c |>\n<| c |>\n: Your solution\
    \ is faster because it does not use regex. Since regex is slower, the complexity\
    \ of your solution is O(n^2). My solution is O(n).\n<|/ c |>\n<| c |>\n: I am\
    \ not sure what you mean by \"unordered\", a hash has O(1) lookup time. Also,\
    \ I think you misunderstood me, I did not give a solution that uses regex but\
    \ one that uses a method called `split` which converts every character in the\
    \ string to an array. Yes it is O(n), but I think it is faster than my solution.\n\
    <|/ c |>\n<| c |>\n: I guess you meant O(n), not O(n^2) :)\n<|/ c |>\n<| a tags=ruby,string\
    \ dscore=1 |>\nYou can use this code:\n<code>", "    s.length==0? s.reverse:\n\
    \    s.count(\"A\")>0 && s.count(\"a\")>0 && s.count(\"B\")>0 && s.count(\"b\"\
    )>0?s.reverse:\n    s.count(\"A\")>0 && s.count(\"a\")>0?s.reverse:\n    s.count(\"\
    B\")>0 && s.count(\"b\")>0?s.reverse:\n    s.count(\"A\")>0?s.reverse:\n    s.count(\"\
    B\")>0?s.reverse:\n    s.reverse\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a |>\n<code>\n def convert(s)\n    s = s.tr('A-Z', 'a').tr('a-z', 'b').downcase\n\
    \    s.empty? ? s : convert(s.chop) + s.reverse\n  end\n</code>\nThis works for\
    \ any number of lowercase letters and uppercase letters in any order.\n<|/ a dscore=1\
    \ tags=string,ruby,reverse |>\n<| c |>\nI like that solution but I think there's\
    \ a little bug, if the given string is \"A\" it will return \"a\" instead of \"\
    A\", but I think you have a point and I'll work on it.\n<|/ c |>\n<| c |>\nIt\
    \ works for me. Try it out with `\"A\"`. It will return `\"a\"`.\n<|/ c |>\n<|\
    \ c |>\nIt works in my console but not on my codewars submission. I am thinking\
    \ it has to do with the fact that my function only returns s instead of putting\
    \ it in the array and then returning it.\n<|/ c |>\n<| a |>\n<code>", "  return\
    \ s.chars.reverse.join\nend", "  letters = s.chars.select { |char| char.class\
    \ == String }\n  letters.each { |letter| return s.downcase if letter.downcase\
    \ == letter }\n  letters.each { |letter| return s.upcase if letter.upcase == letter\
    \ }\n  return s.upcase if letters.empty?\n  letters.inject(\"\") { |result, letter|\
    \ return result.gsub!(letter, \"#{$letter}#\") }\nend", "    return s if s.empty?\
    \ else  s.gsub(/[a-z]/) {|s| s[/[a-z]/].upcase }.reverse\nend\nputs solve(\"#a@C\"\
    )", "    \n    count = 0\n    for i in s.split(\"\") \n        if i.is_a? String\
    \ then \n            i.upcase \n            count +=1 \n        else \n      \
    \      i \n        end\n    end\n    if count == 0 then \n        s[0..-2].reverse.join\n\
    \    else \n        s[0..-2].reverse.join\n    end\nend", "  s.downcase! if s.is_a?\
    \ String\n  s.gsub!(/[^A-Za-z0-9]/,'')\n  s.reverse! if s.empty?\n  s\nend", " \
    \   chars = s.split('')\n    chars.map!(&:upcase)\n    chars.map!(&:downcase)\n\
    \    chars.join!\n    chars\nend", "  if s.empty? then return s\n  s = s.chars.map{|c|\
    \ c.upcase if c==s[0]}.join(\"\")\n  s = s.chars.map{|c| c.downcase if c==s[0]}.join(\"\
    \")\n  s\nend", "  s = s.chars\n  s.each_index do |i|\n    s[i] = s[i].upcase\
    \ if s[i].isa? String\n  end\n  s.join\nend", "  s = s.downcase\n  \n  s.split('').inject('')\
    \ do |s, char|\n    char == char.upcase ? s.reverse.concat(char) : s\n  end\n\
    end", "  chars = s.split('').map(&:to_s)\n  chars.each do |char|\n    case char\n\
    \    when 'a'..'z'\n      char.upcase!\n    when 'A'..'Z'\n      char.downcase!\n\
    \    end\n  end\n  chars.join\nend\n</code>\n<|/ a tags=ruby,string dscore=1 |>\n\
    <| a dscore=0 |>\nThis is a simple solution using recursion\n<code>", "  s = s.dup\n\
    \  s.delete('^.') \n  s.downcase!\n  s.gsub!(/[A-z]/) {|x| x.ord < 65 ? x.chr.downcase\
    \ : x.chr.upcase }\n  s\nend\n</code>\n<|/ a dscore=3 tags=ruby,string |>\n<|\
    \ a tags=ruby,string |>\nHere is my solution using string substitution:\n<code>",
  "  return s.chars.join.chars.reverse.chars.join\nend\n  ", "  res=\"\"\n  s.split('').each\
    \ do |c|\n    c.upcase! if c==\"A\"\n    c.downcase! if c==\"a\"\n    res<<c\n\
    \  end\n  res\nend", "  s = s.chars.map { |c| c.upcase if c.is_a? String else\
    \ c }\n  return s.first if s.first.empty?\n  s.map { |e| e == s.last ? e : e.capitalize\
    \ }.join(\"\")\nend", "  rev_str = s.gsub(/[a-h]/){|x| x.upcase if x} || s.reverse\n\
    \  rev_str.gsub(/[^a-h]/){|x| x.downcase if !x}\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThe code is working! Thank you so much! Now I have to take care\
    \ of edge cases :) Thanks!\n<|/ c |>\n<| c |>\n`gsub!` *is* evil. `gsub` is an\
    \ alias for `gsub!` which returns `gsub!` itself, so you might as well just use\
    \ `gsub` here.\n<|/ c |>\n<| c |>\n, that's a good point. Since `gsub!` is an\
    \ alias of `gsub`, there's no need for `gsub!` here. The OP didn't ask to mutate\
    \ the string in place so I thought `gsub!` would be clearer. I'll amend my answer\
    \ to make it clearer as well. Thanks.\n<|/ c |>\n<| a dscore=2 tags=ruby |>\n\
    This is in ruby 1.9 :\n<code>", "    s = s.downcase\n    s.gsub!(/[#@]/) { |m|\
    \ m.upcase }\n    s.gsub!(/[^a-z]/) { |m| m.reverse }\n    s.gsub!(/[a-z]/) {\
    \ |m| m.reverse }\n    s.gsub!(/[^A-Z]/) { |m| m.reverse }\n    s.gsub!(/[A-Z]/)\
    \ { |m| m.reverse }\n    s\nend", "  return s.split('').inject(:+).to_s.reverse\n\
    end", "  letters = s.split(//)\n  letters.map { |l| l.downcase }.join(\"\").reverse!\n\
    \  letters.map { |l| l.upcase }.join(\"\").reverse!\n  return letters.join(\"\"\
    )\nend", "  s = s.chars.map{|x| x[0].upcase + x[1].downcase}.join(\"\")\n  s =\
    \ s.gsub(/./){|x| x.gsub(/[a-z]/){|y| \"#{y[0].downcase}#{y[1].upcase}\"}}\n \
    \ return s\nend", "  if s.empty?\n    return s.reverse\n  end\n  s = s.chars.map\
    \ { |e| e.is_a? Char ? e.upcase : e }\n  return s.reverse\nend", "  return \"\
    a\".ord.to_s + s.downcase.ord.to_s if s.chars.all? { |c| c >= 'a' && c <= 'z'\
    \ || c >= 'A' && c <= 'Z' }\n  s.chars.reverse_each.map { |c| c.ord.to_s }.join\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nI thought you were looking for\
    \ `'A'..'Z'.include?(s.downcase)`, but you were looking for `'A'.ord.to_s + s.downcase.ord.to_s`,\
    \ which is quite a different thing. I've updated my answer.\n<|/ c |>\n<| c |>\n\
    I think you meant `'A'..'Z'`, not `'A'.ord.to_s + s.downcase.ord.to_s`.\n<|/ c\
    \ |>\n<| a |>\nThe solution I found is this:\n<code>", "  s.each_char do |c|\n\
    \    if c.is_a? String\n      c.upcase! if c.upcase? && c.downcase?\n      c.downcase!\
    \ if c.downcase? && c.upcase?\n    end\n  end\n  return s\nend", "  str = []\n\
    \  i = 0\n  while i < s.length\n    if s[i] =~ /\\w/ then\n      str[i] = s[i].downcase\n\
    \      i += 1\n    else\n      str[i] = s[i]\n    end\n    i += 1\n  end\n  str.reverse!\n\
    \  str.join('')\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\nHere is my\
    \ take on this, it only converts one letter at a time. It should be quite performant\
    \ (O(n) characters).\n<code>", "  s.chars.each_with_object(\"\") do |c,r|\n  \
    \  r += case c\n      when \"A\"..\"Z\" then c.upcase\n      when \"a\"..\"z\"\
    \ then c.downcase\n      else c\n    end\n  end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI was trying to do this in Ruby using recursion, but your answer\
    \ was a lot cleaner. Thanks!\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    letters\
    \ = s.downcase!\n    \n    letters.each_char do |letter|\n        if letter.is_a?\
    \ String\n            letter.each_char.reduce(\"\") { |tmp, char| \n         \
    \       if char == letter\n                    char.upcase!\n                else\n\
    \                    char.downcase!\n                end\n                tmp\
    \ << char }\n        else\n            if letter == letter\n                letter.upcase!\n\
    \            else\n                letter.downcase!\n            end\n       \
    \ end\n    end", "  s.tr!('a-z','A-Z')\n  s.tr!('A-Z','a-z')\n  s.empty? ? s.tr!('A-Z','a-z')\
    \ : s\nend\n</code>\n<|/ a |>\n<| a tags=string,ruby,replace |>\n<code>", "  s.chars.each\
    \ do |ch| \n    ch = ch.upcase if ch =~ /[a-z]/i\n    ch = ch.downcase if ch =~\
    \ /[A-Z]/i\n  end\n  s.chars.join\nend", "    s.downcase!\n    s.gsub!(/[^a-z]/,\"\
    \")\n    s.empty? ? s.reverse! : \"#{s.gsub(/(?<=\\A)(\\p{Lu})(?=\\z)/){$1.upcase}}\"\
    \nend", "  result = \"\"\n  s = s.downcase\n  s.each_byte {|c| result << c.chr(c.ord\
    \ - 64) if c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z'}\n  result\nend", "  \
    \  s.length.times do |i|\n        if s[i] =~ /[a-z]/i\n            if s[i].upcase\
    \ != s[i].downcase\n                s[i].downcase!\n            else\n       \
    \         s[i].downcase\n            end\n        end\n    end\n    s.length.times\
    \ do |i|\n        if s[i].downcase == s[i].upcase\n            s[i].upcase!\n\
    \        end\n    end\n    s.length.times do |i|\n        if s[i] != \"#\"\n \
    \           s[i].upcase\n        end\n    end\n    s.join\nend\nputs solve(\"\
    1234\")\nputs solve(\"ab\")\nputs solve(\"#a@C\")\n</code>\n<|/ a |>\n<| c |>\n\
    This code fails for \"#a@C\"\n<|/ c |>\n<| c |>\nI think you are right. `#a@C`\
    \ is not a letter but a symbol. I am fixing it.\n<|/ c |>\n<| c |>\nThis is definitely\
    \ the best answer. I don't think I'd write code like this in Ruby at all, but\
    \ that's just me.\n<|/ c |>\n<| c |>\nThis answer fails for the string `#a@C`,\
    \ because it results in `#A@C`, which should be `#a@C`.\n<|/ c |>\n<| c |>\nYou\
    \ are right again. Just fixed it.\n<|/ c |>\n<| a dscore=2 |>\nI came up with\
    \ this solution:\n<code>", "  return s.split('').inject(\"\") { |r, e| r << (r.length\
    \ == 0 ? e : e.upcase) }.reverse\nend\n</code>\n<|/ a |>\n<| c |>\nThis is actually\
    \ a great solution. I was having trouble understanding inject until I read your\
    \ example. I didn't think about reversing after I split the string. Thanks!\n\
    <|/ c |>\n<| a |>\nIn Ruby, you can do this more efficiently using the join method\
    \ of a single string:\n<code>", "  return s.reverse.compact.join\nend", "  s.split('').map\
    \ {|char| char.upcase if char.match(/^[a-zA-Z]/) }.join(\"\").reverse!\nend",
  "  result = \"\"\n  s.chars.each do |char|\n    if char >= \"A\" && char <= \"Z\"\
    \n      result += char.to_i + 32\n    else\n      result += char.to_i\n    end\n\
    \  end\n  return result.to_s\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the\
    \ help! I edited the post to include some test cases. Hopefully this makes things\
    \ a bit easier.\n<|/ c |>\n<| a dscore=0 |>\nI like Martin's solution, though\
    \ I made a change to it so as to keep the function from returning an empty string.\n\
    <code>", "  s = s.split('').join.reverse\n  p s\nend\np solve(\"ab\")\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nWhy `join.reverse`? It sounds like `s.chars.reverse`\
    \ would be more efficient. `join` is an intermediate step, but `reverse` just\
    \ returns a new array, so that's less work for the interpreter. Also, `chars`\
    \ returns an `Array` so there's no need for a `join` call.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  res= \"\"\n  s.each_byte do |x|\n    if x.chr=~/\\A[a-z]/i\n\
    \      res+=x.chr.upcase\n    else\n      res+=x\n    end\n  end\n  return res\n\
    end\nputs solve(\"1234\")\nputs solve(\"ab\")\nputs solve(\"#a@C\")\nputs solve(\"\
    abcd\")\nputs solve(\"a1b2c3\")\nputs solve(\"A1b2C3\")\nputs solve(\"ABC\")\n\
    puts solve(\"a1b2c3\")\nputs solve(\"ab\")\nputs solve(\"a1b2c3\")\nputs solve(\"\
    A1b2C3\")\nputs solve(\"#a@C\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"\
    a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\"\
    )\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\n\
    puts solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs\
    \ solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs\
    \ solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs\
    \ solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs\
    \ solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs\
    \ solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs\
    \ solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs\
    \ solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs\
    \ solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs\
    \ solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs\
    \ solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs\
    \ solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs solve(\"a\")\nputs\
    \ solve(\"a\")\nput", "  s = s.downcase\n  return s.gsub(/[aeiou]\\B/, '\\1')\n\
    end\n</code>\n<|/ a |>\n<| c |>\nFor Ruby 2.7.0 you can replace `s.gsub(/[aeiou]\\\
    B/, '\\1')` with `s.gsub(/[aeiou]\\B/, \"\")`.\n<|/ c |>\n<| c |>\nIn ruby 2.7.0\
    \ you can replace `s.gsub(/[aeiou]\\B/, '\\1')` with `s.gsub(/[aeiou]\\B/, \"\"\
    )`\n<|/ c |>\n<| c |>\nIn ruby 2.7.0 you can replace `s.gsub(/[aeiou]\\B/, '\\\
    1')` with `s.gsub(/[aeiou]\\B/, \"\")`\n<|/ c |>\n<| a tags=regex,ruby dscore=5\
    \ |>\nHere are some more ways (inspired by the answers above) that I use:\n<code>\n\
    \"string\".downcase.tr(\"aeiouAEIOU\", \"AEIOUaeiou\")\n\"string\".gsub(/[aeiouAEIOU]/i,\
    \ \"AEIOU\")\n\"string\".gsub(/[aeiou]/i, \"AEIOU\")\n</code>\n<|/ a |>\n<| c\
    \ |>\nThe first two don't seem to be doing anything for me\n<|/ c |>\n<| c |>\n\
    This works: `\"string\".gsub(/[aeiou]/i, \"\")`\n<|/ c |>\n<| c |>\nThe last one\
    \ doesn't work for me. `\"abcde\".gsub(/[aeiou]/i, \"AEIOU\")` results in `\"\
    AEIOUAeiouAEIOUbcde\"`.\n<|/ c |>\n<| c |>\nThis is also the only solution that\
    \ worked for me in a Rails console, even when I had `/[aeiou]/` instead of `/[aeiouAEIOU]/`.\n\
    <|/ c |>\n<| a |>\n<code>\n\"string\".gsub(/[aeiou]/i, 'AEIOU')\n</code>\nThe\
    \ above will do what you want.\n<|/ a tags=regex,ruby dscore=5 |>\n<| a dscore=5\
    \ |>\nIf you're looking for an alternative without using gsub, you can do:\n<code>\n\
    \"string\".each_char.map { |c| c.upcase if c == 'a' || c == '", "  s = s.to_s.gsub(/[a-zA-Z]/){|c|\
    \ c.upcase + c.downcase}\n  s.reverse if s.empty?\n  s.to_s\nend\n</cell>\n<text>\n\
    Great! Your problem solved is ready. Let's see a few things you learned from our\
    \ test:", "  return s.chars.map{|x| x =~ /[a-zA-Z]/}.none? ? s.reverse : s.downcase\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis code gives me \"ArgumentError:\
    \ wrong number of arguments (given 0, expected 1)\" on \"abc\"\n<|/ c |>\n<| a\
    \ tags=ruby,string |>\n<code>", "    alphabet = s.split(\"\")\n    s = s.dup\n\
    \    i = 0\n    while i < s.length\n       if alphabet[i].match?(/[a-z]/i)\n \
    \          alphabet[i] = alphabet[i].upcase\n       else\n           alphabet[i]\
    \ = alphabet[i].downcase\n       end\n       i += 1\n    end\n    return alphabet.join\n\
    end\n</cell>\n<cell>\nsolve(test).should == \"4321\"\n</cell>\n<text>", "  result\
    \ = s.downcase\n  s.each_char do |i|\n    if i.isalpha?\n      result = i.upcase\
    \ + result\n    elsif i.isnumeric?\n      result = i.to_s + result\n    elsif\
    \ i == \"\"\n      result\n    end\n  end\nend\nputs solve(\"ab\")\n</code>\n\
    <|/ a tags=ruby,string |>\n<| a |>\n<code>", "  s.downcase!\n  s.each_char do\
    \ |c|\n    if c.between?('a'..'z')\n      s.swapcase! if s !~ /#{c}/\n    end\n\
    \  end\n  s.upcase!\n  return s\nend\n</code>\n<|/ a |>\n<| a |>\nUsing regex\n\
    <code>", "  \n  s.downcase!\n  s.gsub!( /[[:alpha:]]/i, \"\" )\n  s.gsub!( /[[:digit:]]/i,\
    \ \"\" )\n  s.gsub!( /[^[:alpha:][:digit:]]/i, \"\" )\n  s.upcase!\n  \n  if s.empty?\n\
    \    s\n  else\n    s.gsub!( /[^[:alpha:][:digit:]]/i, \"\" )\n    s.gsub!( /[[:alpha:][:digit:]]/i,\
    \ \"\" )\n    s.upcase!\n    s.downcase!\n  end\n  \n  s\nend\n</code>\n<|/ a\
    \ |>\n<| a dscore=2 tags=string,ruby,methods |>\nSince Ruby 1.9:\n<code>\ns.tr(%w{a\
    \ b c d e f g h i j k l m n o p q r s t u v w x y z}, %w{A B C D E F G H I J K\
    \ L M N O P Q R S T U V W X Y Z})\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>",
  "  return \"\" if s.empty? || s.chars.all? {|ch| ch.in?(%w[a e i o u])}\n  s.chars.map\
    \ {|ch| ch.downcase == ch ? ch.upcase : ch }.join\nend", "  s.gsub!(/[\\W]/, '')\n\
    \  s.split(//).map { |e| e.capitalize == '' ? e.upcase : e.capitalize }.join\n\
    end", "  # your code here\n  return \"\"\nend\n</cell>\n<code language=julia-0.5>",
  "  if s.nil? then return s end\n  s = \"\" + s\n  for i in 0...s.length\n    s[i]\
    \ = s[i].downcase if s[i].is_a? String\n    s[i] = s[i].upcase if s[i].is_a? String\n\
    \    break if s[i].is_a? String\n  end\n  s = s\n  for i in (0...s.length)\n \
    \   s[i] = s[i].upcase if s[i].is_a? String\n    s[i] = s[i].downcase if s[i].is_a?\
    \ String\n  end\n  s = s.gsub(/[^a-z]/i) { |s| s.upcase }\n  s = s.gsub(/[^A-Z]/)\
    \ { |s| s.downcase }\n  return s\nend", "\ts.split(\"\").map { |char| char.ord\
    \ % 32 }.uniq.each do |char| \n\t\tchar == 0 ? s = s[0...-1] + s[0] : s << char.chr\n\
    \tend\n\ts\nend\nprint solve(ARGV[0]).to_s.inspect\n</code>\n<|/ a |>\n<| c |>\n\
    `s.split(\"\").map { |char| char.ord % 32 }.uniq.each do |char| char == 0 ? s\
    \ = s[0...-1] + s[0] : s << char.chr end` is much better than my answer\n<|/ c\
    \ |>\n<| c |>\nYou don't need the `uniq` part\n<|/ c |>\n<| a tags=string,ruby\
    \ |>\n<code>", "  return \"\"\nend", "  s.split(\"\").map(&:downcase).reduce(:<<).split(\"\
    \").reduce(:<<)\nend", "  str = s.dup\n  str.gsub!(\"[a-z]\") {|s| s.upcase }\n\
    \  str.gsub!(\"[A-Z]\") {|s| s.downcase }\n  return str\nend", "  s = s.downcase\n\
    \  if s.empty?\n    s << s\n  elsif s.include?(s[0]).nil?\n    s << s[0]\n   \
    \ solve(s)\n  else\n    solve(s)\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ c |>\nIt's not about solving the problems, it's about how to handle them with\
    \ code. Your solution works great, although not exactly efficient (requires extra\
    \ memory).\n<|/ c |>\n<| c |>\nWhat do you mean by extra memory? It doesn't require\
    \ extra memory as it is using recursion (which uses memory itself) and is well\
    \ understood. Unless you have a case where it makes your code inefficient, then\
    \ you should definitely go for it :)\n<|/ c |>\n<| c |>\nI thought of one more\
    \ solution which does not use extra memory and which has less lines of code. Take\
    \ a look at my solution.\n<|/ c |>\n<| c |>\nYour solution is still O(n^2), which\
    \ can be O(n) without using a stack (because you're only using one stack frame\
    \ at a time)\n<|/ c |>\n<| a tags=ruby |>\nUse String#gsub!\n<code>", "  s = s.to_s.downcase\n\
    \  s = s.gsub(/[[:alpha:]]/) { $1.upcase } if s.any?\n  s = s.gsub(/[^[:alpha:]]/)\
    \ { $1.downcase } if s.blank?\n  s\nend", "  s = s.chars.reverse.join if s.chars.any?\
    \ \n  s = s.gsub(/[^a-zA-Z]+/,'').reverse\n  s.gsub!(/[^a-zA-Z0-9]+/,'')\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nAha, that is interesting.  I never considered\
    \ the case that a string with no letters would be considered a letter, and that\
    \ makes this a lot simpler than I thought.  However, one thing I am not clear\
    \ on is how this solves my problem.  Are you saying that the \"isLetter?\" function\
    \ should return \"false\" when given an empty string and instead return \"true\"\
    ?  If so, then I would think that would solve my problem, but I don't understand\
    \ how that is the case.  I thought that would mean that the \"s.chars.reverse.join\
    \ if s.chars.any?\" would get evaluated, but wouldn't \"if s.chars.any?\" evaluate\
    \ to \"false\" if the string were empty?  I must be misunderstanding something.\n\
    <|/ c |>\n<| c |>\nNo worries, I understand now.  It seems I was mistaken in thinking\
    \ that if there were no letters in the string, the function would evaluate to\
    \ false.  In fact, my problem was that I was thinking that the empty string would\
    \ be considered a letter by this function.  However, my mistake was thinking that\
    \ an empty string would evaluate to true.  Thanks for your help.  I really appreciate\
    \ it!\n<|/ c |>\n<| a tags=ruby,string |>\n<code>\n\"foo\".gsub(/[[:alpha:]]/)\
    \ { |s| s.upcase }\n</code>\nwill replace every single alpha character with its\
    \ uppercase counterpart.\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "  case\
    \ s\n  when /([a-z]+)$/i\n    s[0].upcase + s.slice(1, s.length)\n  when /([A-Z]+)$/i\n\
    \    s[0].downcase + s.slice(1, s.length)\n  when /^.*/i\n    s.reverse\n  end\n\
    end", "  s.gsub!(/\\p{L}/) { |x| x.upcase } if s.match?(/\\p{L}/)\n  s.gsub!(/./)\
    \ {|x| x.ord } if s.match?(/./)\n  s.gsub!(/(.)\\1/) { |x| x.reverse }\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=ruby,string |>\n<code>", "  s = s.to_s.downcase\n\
    \  if s.length <= 1\n    s\n  else\n    letters = s.chars\n    letters.reverse!\n\
    \    s = letters.join\n  end\nend", "  return s[s.upcase!=\"\"?s.downcase:s.reverse]\n\
    end", "\ts = s.dup.tr('a-zA-Z','A-Z').downcase\n\ts = s.dup.tr('Aa','Zz').downcase\n\
    \ts = s.dup.tr('!@#$%^&*()_+',' ').downcase\n\ts.gsub!(/[[:punct:]]/,'')\n\ts.gsub!(/[[:space:]]/,'\
    \ ')\n\ts\nend", "  new_string = ''\n  s.each_byte do |c|\n    letter = c.chr\n\
    \    new_string << letter == letter[0].upcase ? letter[0].downcase : letter[0].upcase\n\
    \  end\n  new_string += s[0]\n  return new_string\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ dscore=1 |>\n<| a tags=ruby,ruby-on-rails |>\nI like this one:\n<code>\ns =\
    \ 'foo'\np s.tr('A-Z', 'a-z')\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    Using regex is nice, however this can be done without regex:\n<code>\n'foo'.each_char.map\
    \ do |i|\n  (i + 'A'.ord - 'a').chr\nend.join\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\nI hope this one can help you\n<code>\n\
    'foo'.tr('A-Z', 'a-z').to_s.gsub(/./).reverse.tr('a-z', 'A-Z')\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nThanks for your response. This doesn't work if the string\
    \ has only lowercase letters. For example: `s = 'a'; s.tr('A-Z', 'a-z')` gives\
    \ you `'a'`\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\nYou can use String#tr\n\
    <code>\nirb(main):013:0> \"foo\".tr(\"A-Z\", \"a-z\")\n=> \"foo\"\nirb(main):014:0>\
    \ \"Foo\".tr(\"A-Z\", \"a-z\")\n=> \"Foo\"\nirb(main):015:0> \"foo\".tr(\"A-Z\"\
    , \"a-z\").tr(\"a-z\", \"A-Z\")\n=> \"FoO\"\nirb(main):016:0> \"Foo\".tr(\"A-Z\"\
    , \"a-z\").tr(\"a-z\", \"A-Z\").tr(\"A-Z\", \"a-z\")\n=> \"Foo\"\nirb(main):017:0>\
    \ \"FOO\".tr(\"A-Z\", \"a-z\").tr(\"a-z\", \"A-Z\").tr(\"A-Z\", \"a-z\")\n=> \"\
    FOO\"\nirb(main):018:0> \"Foo1\".tr(\"A-Z\", \"a-z\").tr(\"a-z\", \"A-Z\").tr(\"\
    A-Z\", \"a-z\")\n=> \"FoO1\"\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>",
  "    \n    s = s.dup\n    s = s.chars\n    \n    s = s.map { |x| x[0].upcase + x.last\
    \ }.join(\"\")\n    s = s.gsub(/[a-z]/i) { |x| x.upcase }\n    \n    s.reverse\
    \ !=\"\"\n    s\nend", "  s.downcase!\n  s.gsub!(/[#@]/, \"\").reverse!\n  s.gsub!(/@/,\
    \ \"\")\n  s\nend\n</code>\n<|/ a |>\n<| c |>\nThis is what happens when you do\
    \ not test it thoroughly. Sometimes the simplest solution is the best. +1\n<|/\
    \ c |>\n<| a |>\n<code>", "  result = s\n  result.gsub!(/[a-z]/) do |x|\n    x.upcase\
    \ if x.upcase == x\n  end\n  result.gsub!(/[A-Z]/) do |x|\n    x.downcase if x.downcase\
    \ == x\n  end\n  result\nend", "  if s.empty?\n    \"\"\n  else\n    s.chars.map\
    \ do |c|\n      c =~ /[A-Za-z]/ ? (c.upcase + c.downcase) : c\n    end.join\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,string dscore=0 |>\n<| a tags=ruby,string\
    \ |>\nTo give another solution: \n<code>", "  s = s.upcase\n  s.chars.reverse_each\
    \ { |c| s = s.gsub(c.downcase, c.upcase) }\n  s.chars.reverse\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=string,ruby,arrays,sorting |>\n<code>", "    s =\
    \ s.gsub(/[^A-Za-z0-9]/, \"_\") # replace all non-letters with \"_\"\n    s =\
    \ s.gsub(/[_]+/, \"\").downcase # make all letters lowercase\n    s = s.gsub(/__+/,\
    \ \"-\").gsub(/-__+/, \"-\") # replace all \"__\" with \"-\"\n    s = s.gsub(/-\\\
    //, \"/\") # replace \"/-\" with \"/\"\n    s = s.gsub(/\\/-/, \"--\")\n    s\
    \ = s.gsub(/--\\//, \"/\")\n    s = s.gsub(/-$/, \"\") # replace last \"-\" with\
    \ \"\"\n    return s \nend\n</code>\n<|/ a |>\n<| c |>\nThank you for the answer.\
    \ Very helpful.\n<|/ c |>\n<| a dscore=2 tags=ruby,regex |>\nI used the string\
    \ reverse and gsub solution to solve this problem, but to clarify, here is my\
    \ code that is working with ruby 2.1.2:\n<code>", "  s.split('').map {|c| c.match(/[a-z]/i)\
    \ ? c.upcase : c.downcase}.join\nend\n</code>\n<|/ a |>\n<| c |>\nThis answer\
    \ works very well for me, and I love the use of map/join for the split/map process.\n\
    <|/ c |>\n<| a tags=ruby,string,algorithm,ruby-on-rails |>\n<code>\ns.downcase.to_s\
    \ + s.upcase.to_s.reverse\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work\
    \ if you want to reverse a string that already has letters mixed in. E.g. \"aabb\"\
    \ = \"bbaa\".\n<|/ c |>\n<| c |>\n`s.downcase.to_s + s.upcase.to_s.reverse.tr('a-z','A-Z')`\n\
    <|/ c |>\n<| c |>\nTo make the method even more flexible, use `s.downcase.to_s\
    \ + s.upcase.to_s.reverse.tr/[a-z]/, 'A-Z'`.\n<|/ c |>\n<| a |>\n<code>", "  \
    \  chars = s.chars\n    res = []\n    res.concat chars.map { |c| c.to_s }.sort\n\
    \    res.reverse!\n    res.join\nend", "  s.downcase!\n  s.gsub(/[a-z]/i) {|c|\
    \ c.upcase }\n  s.empty? ? s.reverse : s\nend\n</code>\n<|/ a tags=ruby dscore=0\
    \ |>\n<| a tags=ruby |>\n<code>", "    letters = s.split('')\n    letters.each\
    \ do |char|\n        char.upcase! if char == char.downcase\n    end\n    return\
    \ letters.join('')\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=1 |>\nYou can\
    \ use String#tr:\n<code>", "  puts \"#{i} \" + solve1(s) + \"\\n\" if (s.length\
    \ == 0)\n  puts \"#{i} \" + solve2(s) + \"\\n\" if (s.length == 0)\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis is O(n^2). Not that that matters in practice\
    \ because `String#reverse` only does half of it, but `String#downcase` also does\
    \ half of it, and you call both of them on every character of the input string.\n\
    <|/ c |>\n<| c |>\n, thanks for pointing that out, you are right, my solution\
    \ only does O(n), but it was written to show the complexity of solving this problem,\
    \ the complexity of solving any algorithm is O(n), not O(n^2).\n<|/ c |>\n<| c\
    \ |>\nYes, the complexity does matter. `downcase` does more than half of it because\
    \ `downcase` isn't case insensitive. That's probably why you chose to do it that\
    \ way.\n<|/ c |>\n<| a dscore=1 |>\nMy solution:\n<code>", "    s.downcase!\n\
    \    s.scan(/[a-z]/i) { |m| s.insert(s.rindex(m) + 1, m.upcase) }\n    s.rstrip\
    \ if s.match(/\\A[a-z]+\\z/i)\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n\
    This doesn't handle empty strings (i.e., \"\")\n<|/ c |>\n<| c |>\nIt does, but\
    \ OP said that `solve(\"ab\") = \"AB\"`\n<|/ c |>\n<| c |>\nI think you meant\
    \ `s.downcase!` instead of `s.downcase`.\n<|/ c |>\n<| a tags=ruby,string |>\n\
    <code>", "  s = ''.downcase+s.downcase\n  s.split('').each do |a|\n    if a.isalpha?\n\
    \      if a.length == 1\n        s = a.upcase\n      else\n        arr = a.split('')\n\
    \        arr.each_with_index { |s, i| s[i] = s[1..-1] }\n        s = arr.join('')\n\
    \      end\n    end\n  end\n  return s\nend\n</code>\n<|/ a |>\n<| a tags=string,ruby,arrays\
    \ |>\nUse Array#map :\n<code>", "  if s.length==0\n    return s\n  else\n    str=s.split('').reverse().join('')\n\
    \    if str[0]==\"0\" and str[1]==\"0\" and str[2]==\"0\"\n      str=str[3..0]+str[2..3]+str[0..2]+str[3..4]+str[4..0]\n\
    \    else\n      str=str[0]+str[1:]+str[-1]\n    end\n  end\n  return str\nend\n\
    </code>\n<|/ a tags=algorithm,ruby |>\n<| c |>\nThe most idiomatic Ruby solution\
    \ seems to me to be `s.gsub(/./) { |x| x.ord }.tr('0#0A0D', '0#0A').tr('A0D',\
    \ '0#0')`. Ruby has a built-in `tr` method which replaces characters by its ASCII\
    \ code (aka. ordinal). You could then use your solution to reverse the resulting\
    \ string. The result would be `A#0D#0#0A#0D` in the above example.\n<|/ c |>\n\
    <| c |>\n`tr` will replace all characters by the ordinal position of them. In\
    \ the case `'0A0D'` it replaces every `A` by `0`and every `D` by `9`. So `'A#0D#0#0A#0D'`\
    \ becomes `_0#0A#0D_0#0A`. Now we have `'_0#0A#0D_0#0A'`. After that `tr` replaces\
    \ `0#0A` with `'A'` and `0#0D` with `'D'`. Finally `'A#0D#0#0A#0D'` becomes `_A#0D_D#0A#0D`.\
    \ Finally it is `'A#0D#0#0A#0D'`.\n<|/ c |>\n<| c |>\nThe \"idiomatic\" Ruby solution\
    \ has one bug: It returns `\"A#0D#0#0A#0D\"` instead of `\"A#0D#0#0A#0D\"` as\
    \ shown by the OP. The bug is that `tr` replaces multiple occurrences by *first*\
    \ occurrences. `tr('0#0A', '0#0A')` gives you `\"A#0A#0A\"` because `\"A\"` is\
    \ the first occurrence of `\"0#0A\"` and thus `\"0#0A\"` is replaced by ", " \
    \ s.each_char.with_index.map { |e,i| \n    if e.upcase == e\n      s.slice!(i,1)\
    \ \n      e.downcase!\n    elsif e.downcase == e\n      s.slice!(i,1) \n     \
    \ e.upcase!\n    elsif e == e.downcase and i == s.length-1\n      e.upcase!\n\
    \    end\n    e\n  }.join\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=string,ruby,arrays,reverse\
    \ |>\n<code>", "  s.gsub(/[^A-Z]/) do |e|\n    if e.upcase == e\n      e.downcase\n\
    \    else\n      e\n    end\n  end\nend", "\ts.gsub!(/@|$/,\"\")\n\ts.gsub!(/[a-hj-z-]/,'')\n\
    \ts.downcase!\n\ts.reverse!\n\ts\nend", "  return s.split('').map{ |e| e.chars.map(&:downcase).join\
    \ }.join\nend\n</code>\n<|/ a |>\n<| c |>\n`downcase` doesn't do what OP expects.\
    \ Try `'#A@c'.downcase.chars.map(&:downcase).join` which gives `'#a@C'` as output.\n\
    <|/ c |>\n<| c |>\nThat's why I added `join`. Also you see that I didn't use `downcase`,\
    \ since OP wanted '#a@c' as output and '#A@c' was not reversed because of the\
    \ case.\n<|/ c |>\n<| c |>\nAh right, didn't read the question carefully enough,\
    \ sorry.\n<|/ c |>\n<| a |>\nYou can try this\n<code>", "  s.each do |i|\n   \
    \ if i.is_a? String\n      if i.size > 0\n        i.upcase! if i.is_a? String\n\
    \        i.downcase! if i.is_a? String\n      end\n    end\n  end\n  return s.reverse\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby,string |>\n<| a |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
