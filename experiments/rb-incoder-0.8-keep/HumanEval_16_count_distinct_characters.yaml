name: HumanEval_16_count_distinct_characters
language: rb
prompt: "# Given a string, find out how many distinct characters (regardless of case)\
  \ does it consist of\n# >>> count_distinct_characters('xyzXYZ')\n# 3\n# >>> count_distinct_characters('Jerry')\n\
  # 4\ndef count_distinct_characters(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_distinct_characters\n\
  \    candidate = method(:count_distinct_characters)\n    assert_equal(0, candidate.call(\"\
  \"))\n    assert_equal(5, candidate.call(\"abcde\"))\n    assert_equal(5, candidate.call(\"\
  abcdecadeCADE\"))\n    assert_equal(1, candidate.call(\"aaaaAAAAaaaa\"))\n    assert_equal(5,\
  \ candidate.call(\"Jerry jERRY JeRRRY\"))\n  end\nend\n"
completions: ["  count = 0\n  string.upcase!\n  string.downcase!\n  string.each_char\
    \ do |char|\n    if char.upcase != char.downcase\n      count += 1\n    end\n\
    \  end\n  return count\nend", "  return (string.match(/[a-Z]+/gi) || []).length\n\
    end", "    string.each_char.uniq.count\nend\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThis is the best answer, it works perfectly and does not require any extra\
    \ space to store the array that you are creating.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. Thanks!\n<|/ c |>\n<| a dscore=2 |>\nFor Ruby 2.3+\n\
    <code>\n'aaabbbccc'.each_char.with_object(Hash.new(0)) { |c,h| h[c] += 1 }\n \
    \ #=> { 'a'=>1, 'b'=>2, 'c'=>3 }\n</code>\nFor Ruby 2.2\n<code>\n'aaabbbccc'.split('').inject(Hash.new(0))\
    \ { |h,c| h.merge(c=>1)}\n  #=> {\"a\"=>1, \"b\"=>2, \"c\"=>3}\n</code>\nFor Ruby\
    \ 2.0 and before\n<code>\n'aaabbbccc'.split('').inject(Hash.new(0)) { |h,c| h.merge(c=>1)\
    \ { |_,ov,nv| ov + nv }}\n  #=> {\"a\"=>1, \"b\"=>2, \"c\"=>3}\n</code>\n<|/ a\
    \ tags=ruby-on-rails,string,arrays,ruby |>\n<| c |>\nThis works in 2.2, but in\
    \ 2.3 you need to add `with_object(Hash.new(0))` after the `.each_char`.\n<|/\
    \ c |>\n<| c |>\nGood point.  I'll leave my answer in place until a solution for\
    \ Ruby 2.3 can be found.\n<|/ c |>\n<| c |>\nGood point and thanks for updating\
    \ the answer to include your suggestion.\n<|/ c |>\n<| a tags=ruby-on-rails,string,arrays,ruby\
    \ dscore=2 |>\nThe OP requested a solution without creating additional arrays,\
    \ but it looks like the array is not created. Here's a solution using Enumerable#inject.\n\
    <code>", "  return string.split('').uniq.size \nend", "  characters = string.downcase.scan(/[a-z]/i)\n\
    \  characters += string.downcase.scan(/[A-Z]/i)\n  characters += string.downcase.scan(/\\\
    d/i)\n  return characters.size\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere\
    \ is an answer using recursion:\n<code>", "  string.gsub(/\\p{L}/u).length\nend",
  "  string.downcase!\n  string.count('a'..'z') + string.count('A',1,'z') + string.count('a'..'z','A',1)\n\
    end", "  string.downcase!\n  string.gsub(/[\\s'-]/,'').length\nend", "    char_count\
    \ = Hash.new(0)\n    string.each_char do |char|\n      char_count[char] += 1\n\
    \    end\n    char_count.size\nend", "  return string.scan(/./).count\nend", " \
    \   string.count(\"A\") + string.count(\"B\") + string.count(\"C\") + string.count(\"\
    D\") + string.count(\"E\") + string.count(\"F\") + string.count(\"G\") + string.count(\"\
    H\") + string.count(\"I\") + string.count(\"J\") + string.count(\"K\") + string.count(\"\
    L\") + string.count(\"M\") + string.count(\"N\") + string.count(\"O\") + string.count(\"\
    P\") + string.count(\"Q\") + string.count(\"R\") + string.count(\"S\") + string.count(\"\
    T\") + string.count(\"U\") + string.count(\"V\") + string.count(\"W\") + string.count(\"\
    X\") + string.count(\"Y\") + string.count(\"Z\") + 1\nend\n</code>\n<|/ a |>\n\
    <| a |>\nYou can use the following code:\n<code>", "  count = {}\n  string.split('').each\
    \ do |char|\n    if count[char]\n      count[char] += 1\n    else\n      count[char]\
    \ = 1\n    end\n  end\n  \n  count.keys.uniq.count\nend", "  string.to_s.scan(/[a-z]/).count\n\
    end", "  string.downcase!\n  string.each_char.count { |c| c == string.upcase ?\
    \ c.ord : c.ord }.to_s\nend\n</code>\n<|/ a dscore=3 tags=ruby |>\n<| c |>\n`each_char`\
    \ is also available in 1.8.7.  Also, `each_char.to_a` doesn't copy the string\
    \ each time, so this code is actually much faster than the accepted answer (about\
    \ 3x faster)\n<|/ c |>\n<| c |>\nI wonder if there's an advantage to using `each_char`\
    \ instead of `each_codepoint`, since `each_codepoint` would not produce a `nil`\
    \ character (it would be represented as `0`, but `nil.to_s` is `\"\"`).\n<|/ c\
    \ |>\n<| a tags=ruby |>\nJust wanted to post my solution for this issue:\n<code>",
  "  string.each_char.with_object(Hash.new(0)) { |c, counts| counts[c] += 1 }.\n \
    \ map { |c, count| c }.\n  select { |c| c != ' ' }.\n  map { |c| c.to_s.size }.\n\
    \  reduce(:+)\nend\n</code>\nNote that this counts how many characters there are\
    \ in the string, not how many distinct characters it contains.  That could be\
    \ improved, but probably not as important.\n<|/ a tags=string,ruby,count,arrays\
    \ |>\n<| c |>\nThis only counts the number of characters, not the number of unique\
    \ characters.\n<|/ c |>\n<| c |>\nThanks, I didn't know that. Corrected.\n<|/\
    \ c |>\n<| c |>\n`each_char` is an Enumerable extension, so in order to make it\
    \ work in Ruby 1.8.7 you must `require 'backports/1.8.7/enumerable/each_char'`.\
    \  It can be done without backports too, e.g. `string.split(//).length`.\n<|/\
    \ c |>\n<| a tags=string,ruby,count,arrays |>\nHere's a nice way to do it:\n<code>",
  "  string.split(//).inject(0) do |result, char|\n    result + (char.upcase.count\
    \ != char.downcase.count) ? 1 : 0\n  end\nend\n</cell>\n<cell>", "  count = 0\n\
    \  \n  string.downcase!\n  \n  string.each_char do |c|\n    count += 1\n  end\n\
    \  \n  count\nend", "  characters = string.split(//).uniq.count\n  characters_case\
    \ = string.split.map(&:upcase).uniq.count\n  characters_case\nend", "  string.length\n\
    end", "  string.count('a'..'z') + string.count('A'..'Z')\nend", "  string.each_char.group_by{|i|\
    \ i}.count\nend", "  string.length.times do\n    string.chars.uniq.count\n  end\n\
    end", "  string.scan(/./u).size\nend", "  string.gsub!(/([a-z])\\1*/, '\\1')\n\
    \  string.chars.uniq.length\nend", "  chars = string.split(//).uniq.count\n  chars\
    \ << chars.nonzero? ? chars.min : 0\nend", "  string.downcase!\n  string.gsub!(/\\\
    p{Upper}+/, ' ') #remove all uppercase\n  string.gsub!(/\\p{Lower}+/, ' ') #remove\
    \ all lowercase\n  string.gsub!(/\\b[\\p{ASCII}]/, ' ') #remove all non-ascii\
    \ chars\n  string.gsub!(/^[\\p{ASCII}]+/, ' ') #remove all ASCII chars\n  string.gsub!(/\\\
    s+/, ' ') #remove all whitespace\n  string.count(' ') #remove all whitespace and\
    \ count the length of the string\nend\n</code>\nIt also removes all characters\
    \ other than ASCII (a-zA-Z0-9).\n<|/ a dscore=1 |>\n<| c |>\nGood one, could you\
    \ please explain what each part of your regex does and why ?\n<|/ c |>\n<| c |>\n\
    I added some explanations. Let me know if you need more explanations\n<|/ c |>\n\
    <| a dscore=0 |>\nUse a combination of String#gsub and #scan:\n<code>\nstr = \"\
    abc def ghi jkl mno pqrs\"\nstr.gsub(/[[:alpha:]]+/).scan(/./).count", "  characters\
    \ = string.split(\"\")\n  characters.uniq.size\nend\n</cell>\n<text>\nNow that\
    \ we know what a distinct character is, let's find out how many different characters\
    \ are in a string using our count_distinct_characters function.", "  string.split(//).uniq.size\n\
    end", '  # TODO: Check if string is empty and do nothing and return 0', "  string.split('').uniq.size\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string |>\n<code>", " \
    \ string.gsub(/./) { |c| c.upcase }.uniq.size\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| a tags=ruby |>\n<code>", "  string.split(\"\").uniq.size\nend", "  string =\
    \ string.downcase\n  string.count(\"(\").times do string.count(\")\")\n  string.count(\"\
    ,\").times do string.count(\",\")\n  string.count(\".\").times do string.count(\"\
    .\")\n  string.count(\"!\").times do string.count(\"!\")\n  string.count(\"?\"\
    ).times do string.count(\"?\")\n  string.count(\",\").times do string.count(\"\
    ,\")\n  string.count(\"_\").times do string.count(\"_\")\n  string.count(\"&\"\
    ).times do string.count(\"&\")\n  string.count(\"(\").times do string.count(\"\
    )\")\n  string.count(\"\\\"\").times do string.count(\"\\\"\")\n  string.count(\"\
    %\").times do string.count(\"%\")\n  string.count(\"|\").times do string.count(\"\
    |\")\n  string.count(\"=\").times do string.count(\"=\")\n  string.count(\"$\"\
    ).times do string.count(\"$\")\n  string.count(\"'\").times do string.count(\"\
    '\")\n  string.count(\";\").times do string.count(\";\")\n  string.count(\"(\"\
    ).times do string.count(\"(\")\n  string.count(\")\").times do string.count(\"\
    )\")\n  string.count(\",\").times do string.count(\",\")\n  string.count(\"'\"\
    ).times do string.count(\"'\")\n  string.count(\".\").times do string.count(\"\
    .\")\n  string.count(\";\").times do string.count(\";\")\n  string.count(\"=\"\
    ).times do string.count(\"=\")\n  string.count(\"!\").times do string.count(\"\
    !\")\n  string.count(\"!\").times do string.count(\"!\")\n  string.count(\"&\"\
    ).times do string.count(\"&\")\n  string.count(\"!\").times do string.count(\"\
    !\")\n  string.count(\"\\\"\").times do string.count(\"\\\"\")\n  string.count(\"\
    (\").times do string.count(\"(\")\n  string.count(\")\").times do string.count(\"\
    )\")\n  string.count(\",\").times do string.count(\",\")\n  string.count(\";\"\
    ).times do string.count(\";\")\n  string.count(\".\").times do string.count(\"\
    .\")\n  string.count(\"$\").times do string.count(\"$\")\n  string.count(\"=\"\
    ).times do string.count(\"=\")\n  string.count(\"!\").times do string.count(\"\
    !\")\n  string.count(\"!\").times do string.count(\"!\")\n  string.count(\"_\"\
    ).times do string.count(\"_\")\n  string.", "  count = 0\n  string.each_char {\
    \ |c| count += 1 if c.downcase != c.upcase }\n  count\nend", "  chars = string.split('')\n\
    \  chars.uniq.length\nend", "  return string.split(//).uniq.size\nend", "  string.downcase!\n\
    \  string.gsub!('(.)\\\\1+', \"$&\".freeze).length\nend\n</pre>\n          </div>\n\
    \          \n          \n            \n          \n          \n          \n  \
    \          \n            <div class=\"sourcecode\">\n              \n        \
    \      <p class=\"source-link\">\n                Source: \n                <a\
    \ href=\"javascript:toggleSource('method-c-count_distinct_characters_source')\"\
    \ id=\"l_method-c-count_distinct_characters_source\">show</a>\n              \
    \  \n              </p>\n              <div id=\"method-c-count_distinct_characters_source\"\
    \ class=\"dyn-source\">\n                <pre><span class=\"ruby-comment\"># File\
    \ /usr/local/rvm/gems/ruby-2.0.0-p0/gems/activesupport-4.0.0/lib/active_support/core_ext/string/access.rb,\
    \ line 19</span>\n<span class=\"ruby-keyword\">def</span> <span class=\"ruby-keyword\
    \ ruby-title\">count_distinct_characters</span>(<span class=\"ruby-identifier\"\
    >string</span>)\n  <span class=\"ruby-keyword\">if</span> <span class=\"ruby-identifier\"\
    >string</span>.<span class=\"ruby-identifier\">is_a?</span>(<span class=\"ruby-constant\"\
    >Regexp</span>)\n    <span class=\"ruby-identifier\">string</span>.<span class=\"\
    ruby-identifier\">match</span>(<span class=\"ruby-string\">&quot;[^\\\\S\\\\s]+&quot;</span>).<span\
    \ class=\"ruby-identifier\">length</span>\n  <span class=\"ruby-keyword\">else</span>\n\
    \    <span class=\"ruby-identifier\">count_distinct_characters_without_caching</span>(<span\
    \ class=\"ruby-identifier\">string</span>)\n  <span class=\"ruby-keyword\">end</span>\n\
    <span class=\"ruby-keyword\">end</span></pre>\n              </div>\n        \
    \    </div>\n            \n          </div>\n        \n        <div class=\"method\"\
    >\n          <div class=\"title method-title\" id=\"method-i-count_distinct_characters_without_caching\"\
    >\n            \n              <b>count_distinct_characters_without_caching</b>(string)\n\
    \            \n            <a href=\"../../../../../classes/ActiveSupport/Multibyte/Unicode/Character.html#method-i-count_distinct_characters_without_caching\"\
    \ name=\"method-i-count_distinct_characters_without_caching\" class=\"permalink\"\
    >Link</a>\n          </div>\n          \n          \n            <div class=\"\
    description\">\n              <p>Returns <code>0</code> if the character is none\
    \ of the\ncharacters being counted, and <code>1</code> if it is.</p>", "  uniq\
    \ = string.chars.uniq\n  uniq.size, uniq.uniq.size\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nI liked this answer! I liked your idea of reducing the string first,\
    \ then doing the counting in one pass. In my case the string had a length from\
    \ 6 to 30 characters and I needed a count of the distinct characters. I ended\
    \ up with something like this which seems to work pretty well:", "  string.split(//).reduce(0,:+).to_s\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a dscore=2 |>\n<code>", "  string.downcase!\n\
    \  string.scan(/./).size\nend", "    chars.each do |char|\n        counter = counters[char]\n\
    \        counter += 1 if string.include?(char)\n        counters[char] = counter\n\
    \    end\n    return counters.inject(0) {|counter, char| counter + chars[char]}\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you so much! I appreciate it. I was able\
    \ to implement the function with your help.\n<|/ c |>\n<| a dscore=0 |>\nYou can\
    \ do this easily with Aho-Corasick algorithm. Here is the implementation in ruby\
    \ that I am currently working on.\n<code>", "  string.downcase.chars.uniq.length\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a |>\nFor Ruby 2.3+:\n<code>\n'AbcXeY'.each_char.map(&:downcase).uniq.size\n\
    </code>\nFor older versions of Ruby:\n<code>\n'AbcXeY'.split('').map(&:downcase).uniq.size\n\
    </code>\n<|/ a tags=string,ruby dscore=1 |>\n<| a dscore=0 |>\n<code>\n'aaa'.scan(/[a-z]/i).size\n\
    </code>\n<|/ a tags=string,ruby |>\n<| c |>\nThat's a rather inefficient way of\
    \ writing `'aaa'.length`.\n<|/ c |>\n<| c |>\nI don't think so, but that's another\
    \ way to do it.\n<|/ c |>\n<| c |>\n`'aaa'.scan(/[a-z]/i).size` returns `3` -\
    \ `'aaa'.length` returns `4`.\n<|/ c |>\n<| c |>\nYes, that's my point. `scan`\
    \ returns an array of matching strings, and `size` returns `array.size`.\n<|/\
    \ c |>\n<| c |>\nYou asked for a way to find the number of distinct letters in\
    \ an arbitrary string. You're saying you're going to be happy with any solution\
    \ that uses `scan` because you're not happy with any solution using `length`.\n\
    <|/ c |>\n<| a dscore=0 |>\nI came up with a really simple way to do it, though\
    \ I'm sure there is a more elegant way:\n<code>", "  string.downcase!\n  string.squeeze!\n\
    \  string.gsub(/[[:alpha:]]/, '').length\nend", "    string.downcase!\n    chars\
    \ = string.split(//)\n    chars.uniq.size\nend", "  uniq_set = set()\n  string.gsub(/\\\
    W/) { uniq_set.add($&) }\n  uniq_set.length\nend", "  count_characters = Hash.new(0)\n\
    \  string.split(\"\").each do |char|\n    count_characters.update(char)\n  end\n\
    \  count_characters.values.uniq.length\nend", "  string.tr!('ABCDEFGHIJKLMNOPQRSTUVWXYZ',\
    \ '').chars.count\nend", "  count = 0\n  string.downcase!\n  string.each_char.with_index\
    \ do |char, idx|\n    count += 1 if char == string[idx]\n  end\n  count\nend",
  "  string.split(\"\").uniq.count\nend", "  string.upcase! # so that we don't modify\
    \ a string\n  char_count = Hash.new(0)\n  string.each_byte do |char|\n    char_count[char]\
    \ += 1\n  end\n  char_count.count\nend\n</code>\nA few things to notice:", " \
    \ chars = string.upcase.chars.to_a\n  chars.reduce(0) { |acc, char| acc + 1 if\
    \ char == char }\nend", "  count = {}\n  string.gsub!(/./) { count[$&] += 1 }\n\
    \  count[''] = 0\n  count\nend", "  string.downcase!\n  string.count(\"a\")+1\n\
    end", "  string.gsub(/[\\W]+/,'').length\nend", "  string.count('') == 0 ? string.count\
    \ : count_distinct_characters(string.gsub(/[ -]/,''))\nend\n  ", "  return string.split(\"\
    \").uniq.size\nend", "  unique = string.gsub!(/[A-Z]/, '')\n  unique.downcase!\n\
    \  unique.count(\"\\0\")\nend", "  string.chars.uniq.length\nend", "  count_char\
    \ = 0\n  string.split(\"\").each do |char|\n    if !string.include?(char.upcase)\
    \ && !string.include?(char.downcase)\n      count_char += 1\n    end\n  end\n\
    \  count_char\nend", "  characters = string.split(//)\n  characters.uniq!\n  characters.length\n\
    end", "  # initialize result\n  result = 0\n  # loop through every character\n\
    \  string.each_char do |char|\n    # if the character does not equal the current\
    \ character, add it to\n    # the result\n    if result != char\n      result\
    \ += 1\n    end\n  end\n  # return the result\n  result\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis does not seem to work when there are spaces.\n<|/ c |>\n<| c |>\n\
    Ah, I missed that in the spec. I'll take a look at it\n<|/ c |>\n<| c |>\nI updated\
    \ my answer to include a solution that doesn't use additional space characters.\
    \ It was a good question though, and I think this solution would be more efficient\
    \ than creating additional strings.\n<|/ c |>\n<| c |>\nI like the use of `each_char`\
    \ and `+=`.\n<|/ c |>\n<| c |>\nThank you. I appreciate you taking the time to\
    \ provide an alternate solution :)\n<|/ c |>\n<| a |>\nHere's a solution using\
    \ a regular expression:\n<code>", "  result = 0\n  string.each_char.with_index\
    \ do |char, index|\n    result += 1 if char.upcase != char\n  end\n  result\n\
    end", "  string.downcase! # Case is irrelevant\n  string.split('').sort.uniq.count\n\
    end", "  characters = []\n  string.each_char { |c| characters << c }\n  characters.uniq.count\n\
    end", "  string.each_char do |char|\n    char.upcase.count { |c| !c.match(/.\\\
    ?/) ? char.count(c) + 1 : 1  }\n  end\nend\n</code>\nThe result can be seen here:\n\
    <code>\n1.9.3p125 :001 > puts count_distinct_characters('a')\n0\n1.9.3p125 :002\
    \ > puts count_distinct_characters('abc')\n3\n1.9.3p125 :003 > puts count_distinct_characters('xyzXYZ')\n\
    3\n1.9.3p125 :004 > puts count_distinct_characters('Jerry')\n4\n</code>\n<|/ a\
    \ |>\n<| a |>\nTo get the number of distinct characters in a string, you first\
    \ have to get all possible character combinations.\nThen, you need to convert\
    \ them all to lowercase before counting the distinct characters.\nHere's some\
    \ Ruby code to do that:\n<code>", "  chars = string.split(//)\n  chars.uniq.size\n\
    end", "    string.split('').count('x')\nend", "  string.downcase!\n  string.downcase!\n\
    \  string.length.times do |i|\n    if string[i].nil? || string[i] != string[i-1]\n\
    \      string.length = i + 1\n      return string.size\n    end\n  end\n  string.length\n\
    end", "  count = {}\n  string.chars.each{|x| count[x] = count.has_key?(x) ? count[x]+1\
    \ : 1}\n  count.count\nend", "  return string.scan(/[a-z]+/).uniq.size\nend",
  "  string.downcase!\n  string.gsub!(/[^A-Za-z]+/, '')\n  string.length\nend", " \
    \ string.split(\"\").each_with_object(Hash.new(0)) { |c,h| h[c] += 1 }\nend\n\
    </code>\n<|/ a dscore=2 tags=ruby-on-rails,arrays,ruby |>\n<| a dscore=2 tags=ruby-on-rails,arrays,ruby\
    \ |>\nYou can do this\n<code>", "  string.scan(/./).count\nend\n</cell>\n<cell>",
  "  string.count('a') + string.count('z') + string.count('A') + string.count('Z')\n\
    end", "  distinct_char_count = 0\n  string.each_char{ |c|\n    unless chars.include?(c)\n\
    \      chars << c\n      distinct_char_count += 1\n    end\n  }\n  distinct_char_count\n\
    end", "  letters = string.downcase\n  count = letters.count('a')\n  letters.upcase!\n\
    \  count += letters.count('b')\n  letters.upcase!\n  count += letters.count('c')\n\
    \  letters.upcase!\n  count += letters.count('d')\n  letters.upcase!\n  count\
    \ += letters.count('e')\n  letters.upcase!\n  count += letters.count('f')\n  letters.upcase!\n\
    \  count += letters.count('g')\n  letters.upcase!\n  count += letters.count('h')\n\
    \  letters.upcase!\n  count += letters.count('i')\n  letters.upcase!\n  count\
    \ += letters.count('j')\n  letters.upcase!\n  count += letters.count('k')\n  letters.upcase!\n\
    \  count += letters.count('l')\n  letters.upcase!\n  count += letters.count('m')\n\
    \  letters.upcase!\n  count += letters.count('n')\n  letters.upcase!\n  count\
    \ += letters.count('o')\n  letters.upcase!\n  count += letters.count('p')\n  letters.upcase!\n\
    \  count += letters.count('q')\n  letters.upcase!\n  count += letters.count('r')\n\
    \  letters.upcase!\n  count += letters.count('s')\n  letters.upcase!\n  count\
    \ += letters.count('t')\n  letters.upcase!\n  count += letters.count('u')\n  letters.upcase!\n\
    \  count += letters.count('v')\n  letters.upcase!\n  count += letters.count('w')\n\
    \  letters.upcase!\n  count += letters.count('x')\n  letters.upcase!\n  count\
    \ += letters.count('y')\n  letters.upcase!\n  count += letters.count('z')\n  return\
    \ count\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails |>\n<| a\
    \ |>\n<code>", "  characters = {}\n  string.each_char do |char|\n    characters.merge!(char.to_sym\
    \ => 1) unless characters.key?(char.to_sym)\n  end\n  characters.count\nend",
  "  # Iterate over each character in the string\n  distinct_characters = Hash.new(0)\n\
    \  string.each_char do |char|\n    # Increment the count for the character in\
    \ the string \n    distinct_characters[char] += 1\n  end\n  # Return the number\
    \ of distinct characters\n  distinct_characters.length\nend\n</cell>\n<text>\n\
    Step 5: Write a method to check if two strings are anagrams of each other\nImplement\
    \ the method anagram? below to check if two given strings are anagrams of each\
    \ other.\nIf anagram? returns true, then print Anagram.\nIf anagram? returns false,\
    \ then print Not Anagram.\nIf no parameter is given when the method is called,\
    \ then it should return true.\nNote\nThe two strings will only consist of lowercase\
    \ letters.\nThe method should take two strings as parameters.", "  string.gsub(/[^a-z]/i,\
    \ '').length \nend", "  string.upcase.split.length \nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby,string dscore=0 |>\nI came up with this solution using some\
    \ ruby magic to make it more understandable and to ensure the code is reusable.\n\
    <code>", "  string.scan(/./).size\nend", "  return string.split('').inject(0)\
    \ do |count,char| \n    count += 1 if char.upcase != char.downcase \n    count\
    \ \n  end\nend\n</cell>\n<code language=julia-1.5>", "  string.gsub(/[\\x00-\\\
    xFF]/).length\nend", "    string.split('').uniq.count\nend", "  string.each_char\
    \ do |c|\n    return c if string.count(c) == string.size - 1\n    break\n  end\n\
    \  string.size - 1\nend", "  string.chars.to_a.map(&:downcase).uniq.size\nend\n\
    </code>\n<|/ a |>\n<| c |>\nYour code does not count duplicate characters and\
    \ your explanation is not clear. I suggest you remove that from your answer.\n\
    <|/ c |>\n<| c |>\nThanks for the heads up! Updated my answer to account for duplicates.\n\
    <|/ c |>\n<| c |>\nYour second solution is nice but I think the first one is more\
    \ readable.\n<|/ c |>\n<| c |>\nIn Ruby 2.6.3 `string.chars.to_a` returns a `Array`\
    \ not a `Hash`.\n<|/ c |>\n<| c |>\nThis also returns `nil` if `string` is empty.\n\
    <|/ c |>\n<| a tags=ruby,string |>\nHere's a more concise and flexible alternative\
    \ for Ruby versions prior to 2.3\n<code>", "  string.downcase.chars.count\nend",
  "  string.gsub(/./) { |c| c.ord }.uniq.size\nend", "  string.downcase!\n  string.gsub(/[^A-Za-z]/,\
    \ '')\n    .split('')\n    .reduce(:+)\nend", "  string.split(//).reduce(0,:<<)\n\
    end", "  string_to_char = Hash.new(0)\n  string.each_char do |char|\n    string_to_char[char]\
    \ += 1\n  end\n  string_to_char\nend", "    chars = string.split('')\n    count\
    \ = 0\n    count = 1\n    for i in chars\n        if i !=  chars[count]\n    \
    \        count += 1\n            count -= 1\n    return count\n</cell>\n<cell>",
  "  return string.chars.uniq.size\nend\n</code>\nAnd here are the results of running\
    \ the tests:\n<code>", "  string.downcase! # because some strings will have punctuation\
    \ appended at the end\n  count = {}\n  string.each_char do |char|\n    count[char]\
    \ = count.has_key?(char) ? count[char] + 1 : 1\n  end\n  count.keys.uniq.size\n\
    end", "    string.downcase!\n    string.gsub(/[^a-z]+/, ' ').split.uniq.size\n\
    end\n</code>\n<|/ a tags=string,ruby |>\n<| c |>\nThe first method you suggested\
    \ worked like a charm! The second one was giving me a problem though. Somehow\
    \ I realized that in Ruby 1.8 I do not need to use `downcase` method. Instead,\
    \ I can use `gsub(/[^a-z]+/, '')` to get the same result. I did some testing and\
    \ found that both `downcase` and `gsub` does the same job in Ruby 1.8. Thanks!\n\
    <|/ c |>\n<| c |>\nNo problem. It looks like you found a solution to the problem\
    \ you were working on so it's good to hear that you found a working solution\n\
    <|/ c |>\n<| c |>\n, please consider accepting my answer if you found it helpful.\
    \ Thanks!\n<|/ c |>\n<| c |>\nDone! Sorry, I was out for a while so I missed it\n\
    <|/ c |>\n<| a tags=string,ruby |>\nA shorter version of Stefan's solution:\n\
    <code>", "  return string.length.times.with_object(Set.new) { |i,set|\n    set\
    \ << string[i] unless i == 0 || string[i-1] == string[i]\n  }.count\nend", " \
    \ return string.split('').reduce(:+)\nend", "  string.tr!('A-Za-z', '') # remove\
    \ all but upper and lower case letters\n  string.count('A-Za-z') # count them\
    \ all\nend", "  characters = string.split('')\n  characters.delete_if { |c| !c.isdigit\
    \ }\n  characters.count\nend", "  string.split(//).uniq.size\nend", "  string.downcase!\n\
    \  string.gsub(/\\W/,'').length\nend", "  string.chars.uniq.size\nend", "\tstring.downcase!\n\
    \tstring.each_char.inject(0) do |count, char|\n\t\tcount += 1 if char =~ /[A-Za-z]/\n\
    \t\tcount\n\tend\nend", "  string.split(\"\").uniq.size\nend", "  uniq = string.chars.uniq.count\n\
    \  uniq\nend\n</cell>\n<code language=julia-0.4>", "  chars = string.downcase.split('')\n\
    \  chars.map! { |c| c.split('').uniq.size }.inject(:+)\nend\n</code>\n<|/ a tags=ruby,regex\
    \ |>\n<| c |>\nThis is very nice.  My first attempt was almost identical to this.\
    \  I wonder why I didn't think of it that way in the first place.  I like yours\
    \ better since it uses less code and is a lot easier to read.  Also, I will definitely\
    \ use that in other programs.  Thanks!\n<|/ c |>\n<| c |>\nThe main difference\
    \ between yours and mine is that mine is using one regex but yours is splitting\
    \ on every character and counting the number of arrays.  Which is what counts\
    \ the number of distinct characters.  They both work, it's just a matter of which\
    \ one is easier to read.  I did think of it, but I couldn't think of a better\
    \ way to do it, until I started thinking about it more.\n<|/ c |>\n<| c |>\nI\
    \ definitely agree that mine is easier. As I said, I'm a regex whiz, so this is\
    \ all new to me for sure.  So I guess I'm just going with whichever makes it easier\
    \ to read.\n<|/ c |>\n<| c |>\nThe regex `'(?i)[[:alnum:]]+'` would also match\
    \ non-alphanumeric characters only on Ruby 1.8.  Ruby 1.9 does not have the `(?x)`\
    \ modifier, so your version would need to be modified to work with the two versions\
    \ of the language.\n<|/ c |>\n<| c |>\n: In Ruby 1.9 this would be `\\p{L}`, and\
    \ in Ruby 1.8 this would be `\\p{Letter}`.  `[[:alnum:]]` is the same as `\\p{AlphaNumeric}`.\n\
    <|/ c |>\n<| a dscore=2 |>\nThis problem has already been solved: https://github.com/ahoward/fast_unique_array\n\
    <code>\nrequire 'fast_unique_array'\narray = %w[abc def def abc]\nputs FastUniqueArray.new(array).unique_array\n\
    </code>\n<|/ a tags=ruby,regex |>\n<| c |>\nThe FastUniqueArray is nice, but isn't\
    \ fast. Using a regex like `'[[:alnum:]]+'` as posted by-bajica's answer is significantly\
    \ faster.\n<|/ c |>\n<| c |>\nIn ruby 1.9.2 FastUniqueArray is faster than the\
    \ regex solution!  Not as fast as using FastUnique", "  string.downcase!\n  string.gsub(/[^a-zA-Z]/,\
    \ '')\n  string.count('\\000')\nend", "  string = string.downcase\n  string.each_char\
    \ { |char| return string.count(char) if string.include?(char) }\nend\n</code>\n\
    But now I wanna know what happens if I change the last line to\n<code>\n  string.each_char\
    \ { |char| return string.count(char) if string.include?(char) }\n</code>\nIt would\
    \ return the first character only and stop counting characters. So let's rewrite\
    \ it as:\n<code>\n  string.each_char.find { |char| string.include?(char) }\n \
    \ string.count(\"A\")\n</code>\nThis would return \"A\" as the first character\
    \ and stops the count right there. Thus, the method I wrote above works fine and\
    \ we can rewrite it as a one-liner.\n<|/ a dscore=1 tags=ruby |>\n<| a |>\nThe\
    \ correct answer is: \n<code>\nstring.each_char.count { |c| string[c] }\n</code>\n\
    <|/ a dscore=0 tags=ruby |>\n<| c |>\nThat would not do what was needed. It would\
    \ give the number of characters in the string. However he wanted to know the unique\
    \ characters in the string.\n<|/ c |>\n<| a tags=ruby |>\nI used this solution:\n\
    <code>\nstring.each_char.select { |char| string =~ /#{char}/}.size\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nIt would give the number of characters in the string.\
    \ However he wanted to know the unique characters in the string.\n<|/ c |>\n<|\
    \ a tags=ruby |>\nTry this\n<code>\nstring.to_enum(:scan, /\\w/).count\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nWhile this code may answer the question, providing\
    \ additional context regarding why and/or how this code answers the question improves\
    \ its long-term value.\n<|/ c |>\n<| a tags=ruby |>\nAnother way that works for\
    \ most cases:\n<code>\n string.scan(/\\w/).uniq.size\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby |>\n<code>", "    string.downcase!\n    string.gsub(/\\W/,\
    \ '').length\nend", "  string.downcase!\n  string.gsub!(/[^a-z]+/, '')\n  string.count('a')\n\
    end", "  string.split(//).distinct(&:itself).count\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI believe this is incorrect as it will return 0 for an empty string.\
    \ Also I think this doesn't handle Unicode correctly.\n<|/ c |>\n<| c |>\n, you\
    \ are correct, I had tested it on Ruby 1.9.2p290, but the bug was fixed in Ruby\
    \ 2.2.0. Thanks for pointing it out.\n<|/ c |>\n<| c |>\n, can you give a sample\
    \ of how you would like it to handle Unicode?\n<|/ c |>\n<| c |>\nI think this\
    \ one is the best answer so far. It doesn't count any characters in Unicode properly,\
    \ but that's not necessary since the characters are all ASCII.\n<|/ c |>\n<| c\
    \ |>\nI believe the Unicode BMP (Basic Multilingual Plane) characters are part\
    \ of the ASCII character set, but they have their own separate codes.\n<|/ c |>\n\
    <| a dscore=1 |>\nI came up with another solution that also works with arrays\
    \ of strings:\n<code>", "  count = 0\n  string.each_char do |char|\n    if string.index(char)\
    \ == string.length - 1 \n      count += 1\n    else \n      count += 1\n    end\n\
    \  end\n  count\nend\n</code>\nFor a more thorough explanation, see the Ruby docs\
    \ on String#each_char and String#index.\n<|/ a dscore=1 |>\n<| c |>\n`each_char`\
    \ and `index` aren't very Rubyish.\n<|/ c |>\n<| c |>\nI'd be curious to see a\
    \ more Ruby-ish solution as well. `each_char` and `index` are pretty much the\
    \ only two methods I could think of that might be useful. Perhaps there's another\
    \ method I don't know about?\n<|/ c |>\n<| a dscore=0 |>\nHere is an iterative\
    \ solution that uses Array#count:\n<code>", "    string.each_char.with_object(Hash.new(0))\
    \ { |c,h| h[c] += 1 }.values.sum\nend\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails\
    \ |>\n<| c |>\nNice! I like using `each_char` to go through the string rather\
    \ than using `split`. +1.\n<|/ c |>\n<| a |>\nHere's a solution that does not\
    \ require you to count the number of distinct characters in the string but just\
    \ the number of different characters that are contained in the string:\n<code>",
  "  string.downcase!\n  string.chars.group_by.with_index.\n    select{|_, i| i %\
    \ 2 == 0}.values.count.to_i\nend", "  count = 0\n  string.upcase.each_char { |char|\
    \ count += 1 if char == char.downcase }\n  count\nend\n</code>\nThis code can\
    \ be optimized further, but this should be enough to give you a general idea of\
    \ how to do this.\n<|/ a dscore=2 |>\n<| c |>\nThanks for your reply. I'm new\
    \ to Ruby so can you explain what `string.upcase.each_char { |char| count += 1\
    \ if char == char.downcase }` means and how it can be improved? Thanks.\n<|/ c\
    \ |>\n<| c |>\nIt's a very common technique in Ruby to loop through each character\
    \ of a string. The inner loop will increment the variable `count` when `char ==\
    \ char.downcase`, which is true when `char` is converted to all lowercase and\
    \ all uppercase (`char.upcase == char.downcase`).\n<|/ c |>\n<| c |>\nThank you.\
    \ Would you suggest a better way of coding this (that does not use `each_char`)?\
    \ I would be interested to see the improvements you suggest.\n<|/ c |>\n<| c |>\n\
    It's hard to give a \"better\" method without seeing your original code, but that\
    \ code can be improved significantly. I'll add some notes now.\n<|/ c |>\n<| c\
    \ |>\nOk so I've revised my code. I'd appreciate if you would take a look at the\
    \ edit I've made. Would you agree that it is better?\n<|/ c |>\n<| a |>\nHere's\
    \ my take on this, using only a single variable and a simple loop:\n<code>", " \
    \ string.upcase!\n  string.downcase!\n  string.count('a')+1\n  string.count('b')\
    \ + 1\n  string.count('c') + 1\n  string.count('d') + 1\n  string.count('e') +\
    \ 1\n  string.count('f') + 1\n  string.count('g') + 1\n  string.count('h') + 1\n\
    \  string.count('i') + 1\n  string.count('j') + 1\n  string.count('k') + 1\n \
    \ string.count('l') + 1\n  string.count('m') + 1\n  string.count('n') + 1\n  string.count('o')\
    \ + 1\n  string.count('p') + 1\n  string.count('q') + 1\n  string.count('r') +\
    \ 1\n  string.count('s') + 1\n  string.count('t') + 1\n  string.count('u') + 1\n\
    \  string.count('v') + 1\n  string.count('w') + 1\n  string.count('x') + 1\n \
    \ string.count('y') + 1\n  string.count('z') + 1\nend", "  string.downcase!\n\
    \  string.gsub(/[^A-Za-z0-9]+/, '').length\nend\n</code>\n<|/ a |>\n<| a |>\n\
    <code>", "  return string.split(\"\").uniq.size\nend", "  string.split('').count{|c|\
    \ !c.ascii_casefold}\nend", "  string.split('').uniq.size\nend", "  string.downcase!\n\
    \  string.chars.uniq.size\nend", "  string.split(//).uniq.size\nend", "  string.upcase!\n\
    \  string.downcase!\n  string.gsub(/[^a-z]/i,'').length\nend", "  string.downcase!\n\
    \  string.scan(/[^a-z]/).size\nend", "  chars.each_char do |char|\n    string\
    \ = string.gsub(char, '')\n  end\n  return string.size\nend", "  count = 1\n \
    \ string.each_char do |char|\n    count += 1 if char == char.downcase\n  end\n\
    \  return count\nend\n</code>\nAs a side note, your solution is O(n^2) where n\
    \ is the length of the string. Here's a simpler one that's O(n) time:\n<code>",
  "  return string.split('').uniq.count\nend\n</code>\n<|/ a dscore=2 tags=ruby,string,count\
    \ |>\n<| a |>\nAnother way is to use a Hash that has a default value of 0, which\
    \ you can update as you encounter each character in the string.  Then, when you're\
    \ done, just call Hash#values.\n<code>", "  string.downcase!\n  string.split(//).uniq.length\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis is an extremely clever solution.\n<|/ c\
    \ |>\n<| a |>\n<code>\nputs string.downcase.split(//).uniq.count\n</code>\n<|/\
    \ a dscore=4 tags=ruby |>\n<| c |>\nI agree.  This is definitely the simplest\
    \ way to do it.\n<|/ c |>\n<| c |>\nThis is the most concise answer!\n<|/ c |>\n\
    <| a |>\nHere's another one:\n<code>", "  string.each_char.inject 0 do |result,\
    \ char|\n    if char.upcase == char\n      result + 1\n    else # Case insensitive\n\
    \      result\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,string-length |>\n\
    <| a dscore=0 tags=ruby,string-length |>\n<code>", "  string.split('').inject(0)\
    \ do |sum, char| \n    sum += case char\n    when 'a' then 1\n    when 'b' then\
    \ 2\n    when 'c' then 3\n    when 'd' then 4\n    when 'e' then 5\n    when 'f'\
    \ then 6\n    when 'g' then 7\n    when 'h' then 8\n    when 'i' then 9\n    when\
    \ 'j' then 10\n    when 'k' then 11\n    when 'l' then 12\n    when 'm' then 13\n\
    \    when 'n' then 14\n    when 'o' then 15\n    when 'p' then 16\n    when 'q'\
    \ then 17\n    when 'r' then 18\n    when 's' then 19\n    when 't' then 20\n\
    \    when 'u' then 21\n    when 'v' then 22\n    when 'w' then 23\n    when 'x'\
    \ then 24\n    when 'y' then 25\n    when 'z' then 26\n    else 0\n    end\n \
    \ end\nend\n</code>\n<|/ a |>\n<| c |>\nYour code is quite nice and compact. But\
    \ the `each_char` is needlessly complicated; `string.split('').inject(0) { |sum,char|\
    \ sum + (case char... when 'a' then 1... when 'z' then 26... else 0 end)... end`\n\
    <|/ c |>\n<| c |>\n`each_char` is necessary if you want to avoid `0` when there\
    \ are no lowercase letters.\n<|/ c |>\n<| c |>\n: Actually, in Ruby 1.9.1, `each_char`\
    \ does *not* return `nil` when the string is empty, so you could write `string.split('').inject(0)\
    \ { |sum, char| sum + (case char... when 'a' then 1... when 'z' then 26... else\
    \ 0 end)... end` with less overhead. Maybe that's not true in 1.8.7, but it probably\
    \ won't be in 1.9.\n<|/ c |>\n<| c |>\n: Ah yes, you're right, it is 1.9.1 that\
    \ introduced this. 1.8.7 definitely did not return nil.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>\n'Jerry'.split('').inject(:+).tap { |sum| sum += case sum\n    when\
    \ 'a'..'z' then 1\n    when 'A'..'", "  (0...string.length).inject(0) {|sum, count|\
    \ sum + 1 if string.downcase.count(string[count]) == 1 }\nend\n</code>\nThis is\
    \ how I arrived at this:\n<code>\n'xyzXYZ'\n.downcase\n.count('x')\n.times #=>\
    \ 3\n</code>\n<|/ a tags=ruby,string dscore=2 |>\n<| c |>\nHi there, sorry for\
    \ the delay, your answer was very helpful, thank you. Sorry it took so long for\
    \ me to reply but you seem to have done a good job explaining how the code works.\n\
    <|/ c |>\n<| c |>\nIt was a pleasure! I also appreciate that you gave a clear\
    \ description of what you were trying to do. Thanks for that!\n<|/ c |>\n<| a\
    \ dscore=2 tags=ruby,string |>\n<code>\n\"The quick brown fox jumps over the lazy\
    \ dog.\"\n.gsub(/./){|e| e.downcase}\n</code>\n<|/ a |>\n<| c |>\nIt works and\
    \ is pretty concise, but doesn't work in Rails. I assume that the method `gsub`\
    \ does not exist in the String class. I got it to work in Rails by changing it\
    \ to `gsub(/./){|e| e.downcase}`, which works perfectly. I will post my own answer\
    \ below for future reference.\n<|/ c |>\n<| a |>\n<code>", "  string.each_char.uniq.size\n\
    end", "    distinct_characters = Hash.new(0)\n    string.downcase!\n    string.split.each\
    \ do |char|\n        distinct_characters[char] += 1\n    end\n    distinct_characters.values.sum\n\
    end", "  string.downcase.split(//).uniq.size\nend\n</pre>\n</div>\n</div>\n</div>\n\
    </div>\n</div>\n<div id=\"footer\">\n<div id=\"footer-text\">\nLast updated 2015-12-14\
    \ 23:54:39 CET\n</div>\n</div>\n</body>\n</html>\n</code>\n<|/ q dscore=0 |>\n\
    <| a dscore=2 |>\n<code>\nstring.downcase.split(//).uniq.size\n</code>\nThis does\
    \ not do what you expect. It will split all the strings into arrays of characters,\
    \ downcase all the characters and remove any duplicates. Then, it will take that\
    \ array and count the number of unique elements.\nIf you want a count, you can\
    \ use:\n<code>\nstring.downcase.split(//).uniq.size\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a tags=ruby |>\nI see some problems in your code:\n<code>\nstring.downcase.split(//).uniq.size\n\
    </code>\nFirst of all, you don't need to downcase the string because split will\
    \ do it for you:\n<code>\n\"Jerry\".split(//)\n</code>\nThen you split it into\
    \ an array of characters, and then you remove all duplicates in that array:\n\
    <code>\n['J','e','r','y']\n</code>\nNow you count the number of characters in\
    \ that array:\n<code>\n['J','e','r','y'].size", "  string.downcase!\n  string.gsub!(/[\xC0\
    -\u017E]/, '')\n  string.scan(/./).map(&:downcase).uniq.length\nend", "  string.downcase!\n\
    \  string.gsub!('a', '')\n  string.gsub!('b', '')\n  string.gsub!('c', '')\n \
    \ string.gsub!('d', '')\n  string.gsub!('e', '')\n  string.gsub!('f', '')\n  string.gsub!('g',\
    \ '')\n  string.gsub!('h', '')\n  string.gsub!('i', '')\n  string.gsub!('j', '')\n\
    \  string.gsub!('k', '')\n  string.gsub!('l', '')\n  string.gsub!('m', '')\n \
    \ string.gsub!('n', '')\n  string.gsub!('o', '')\n  string.gsub!('p', '')\n  string.gsub!('q',\
    \ '')\n  string.gsub!('r', '')\n  string.gsub!('s', '')\n  string.gsub!('t', '')\n\
    \  string.gsub!('u', '')\n  string.gsub!('v', '')\n  string.gsub!('w', '')\n \
    \ string.gsub!('x', '')\n  string.gsub!('y', '')\n  string.gsub!('z', '')\n  string.count('a'..'z').to_i\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is what I was looking for, thank\
    \ you :)\n<|/ c |>\n<| a dscore=5 |>\nA simple way that doesn't require you to\
    \ import anything, is to use Ruby's built-in String#count method. \n<code>\ns\
    \ = \"asdfdsafasfasdfasdf\"\ns.count(\"asdf\") #=> 3\ns.count(\"asdf\", :start)\
    \ =>  #=> 4\ns.count(\"asdf\", :end) =>    #=> 3\n</code>\nSee String#count in\
    \ the Ruby docs for more.\n<|/ a tags=ruby,string,regex |>\n<| a |>\nIn Ruby,\
    \ you can do something like this to count the number of different characters in\
    \ a string:\n<code>\nstr = \"abcdaad\"\nstr.gsub(/[a-Z]/).uniq.count\n</code>\n\
    <|/ a tags=ruby,string,regex dscore=5 |>\n<| c |>\nI believe this requires `require\
    \ 'set'`\n<|/ c |>\n<| c |>\nThis answer is now out of date (as of 2018). Starting\
    \ with Ruby 2.7, gsub returns an Enumerator, not an Array. Since Enumerators are\
    \ the preferred way to iterate through a collection, gsub should be used now",
  "  string.split('').sort.uniq.length\nend\n</code>\nAs for what exactly you can\
    \ put in these functions, the best option is to write a few test cases and run\
    \ them through both functions and compare the results.\n<|/ a |>\n<| a dscore=4\
    \ tags=ruby,string,string-length,string |>\nThis should be the most concise way.\n\
    <code>", "  # Count how many times each character appears\n  counts = Hash.new(0)\n\
    \  string.each_char.with_index do |char, index|\n    counts[char] += 1\n  end",
  "  string.upcase!\n  string.downcase!\n  string.chars.uniq.length\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]+/, \"\").length\nend", "    string.downcase!\n    string.gsub(/[[:upper:]]/)\
    \ {|char| char.length}\nend\n</code>\n<|/ a tags=ruby,regex |>\n<| a |>\nUsing\
    \ Ruby Regexp:\n<code>\n[ 'jerry', 'Jerry', 'jerry!', 'Jerry!' ].each do |s|\n\
    \  puts s.gsub(/[[:alpha:]]/).uniq.size\nend", "  string.downcase!\n  string.gsub(/[^A-Za-z]/,\
    \ '').length\nend", "  string.each_char.with_index.inject(0) do |count, char|\n\
    \    char.ord <= 90 ? count + 1 : count\n  end\nend", "  count_distinct = 0\n\
    \  string.each_byte {|char| count_distinct += 1 if char.upcase != char.downcase\
    \ }\n  return count_distinct\nend", "  string.downcase!\n  char_count = Hash.new(0)\n\
    \  string.each_char { |c| char_count[c] += 1 }\n  char_count.count.to_a\nend",
  "  string.each_char.inject(0) { |n,c| n + (c.upcase ? 1 : 0) + (c.downcase ? 1 :\
    \ 0)}\nend", "\tstring.downcase!\n\tstring.upcase!", "  string.downcase!\n  string.gsub!(/\\\
    W+/, \"\")\n  string.scan(/./).length\nend\n</code>\nIf you need to do this many\
    \ times, you can also do it in one line with a ternary operator:\n<code>", " \
    \ count = 0\n  string.each_char { |c| count += 1 }\n  count\nend", "  string.gsub(/[^A-Za-z]*/).length\n\
    end", "  result = 0\n  string.each_char { |c| result += (c.downcase == c.upcase)\
    \ ? 1 : 0 }\n  result\nend", "  string = string.downcase\n  string.count('z')\
    \ - string.count('zz')\nend", "  string.downcase!\n  unique = Hash.new(0)\n  string.scan(/./u)\
    \ do |char|\n    unique[char] += 1\n  end\n  unique.max_by { |char,count| count\
    \ }.length\nend\n</code>\n<|/ a |>\n<| c |>\nNice answer, but i prefer to use\
    \ the hash. My answer uses two hashes -- i think the hash version might be faster\
    \ but i'm not sure.\n<|/ c |>\n<| c |>\nActually, i think you can (and should)\
    \ write it in a single line without Hash. Not that i'll mind, but it's more readable.\
    \ :D\n<|/ c |>\n<| c |>\nAgreed. I used your two hashes because i thought it was\
    \ more intuitive to me. :)\n<|/ c |>\n<| c |>\nYour hash method is way better.\
    \ +1\n<|/ c |>\n<| a tags=ruby |>\nI believe you want the count of distinct characters\
    \ in the string.  You can do that like this:\n<code>\n\"hello\".count(\"h\")\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\nYou can use regex and count the number of\
    \ occurrences.\n<code>\n\"hello\".scan(/[h]/).count\n</code>\n<|/ a dscore=1 tags=ruby\
    \ |>\n<| c |>\nThis requires `'h'` to be a literal.  If you want to use a variable,\
    \ you'll have to use `Regexp.escape` on it to make it a literal pattern.\n<|/\
    \ c |>\n<| a tags=ruby |>\nA solution in one line (but less intuitive):\n<code>\n\
    \"hello\".scan(/(h|o)/).count\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    <code>\n[\n  'hello',\n  'foobar',\n  'hello'\n].select { |str| str.match(/[h|o]/).count\
    \ }\n</code>\n<|/ a tags=ruby |>\n<| a dscore=1 |>\nAnother way:\n<code>\n\"hello\"\
    .chars.uniq.length\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 tags=ruby |>\n\
    <code>", "  return string.split('').uniq.size if string.is_a?(String) else\n \
    \ string.size\nend", "  distinct_char_count = 0\n  string.each_byte do |b|\n \
    \   if b.chr != b\n      distinct_char_count += 1\n    end\n  end\n  distinct_char_count\n\
    end", "  return string.each_char.inject(:+).to_s.length\nend", "  string.split(//).reduce(:+)\n\
    end\n</code>\n<|/ a dscore=5 tags=ruby,count,count,string |>\n<| a |>\nThis is\
    \ not the answer to your question, but a slightly different one: \nI did a little\
    \ benchmark on all the answers on this page and found that most of the answers\
    \ use Ruby 2.5.0 - which is only a few weeks old. \nThat means they don't work\
    \ on Windows machines that have Ruby 2.5 installed. \nI found a similar benchmark\
    \ here https://gist.github.com/pangratzel/7265784 - which uses Ruby 2.4.1. \n\
    If you find it useful, I encourage you to upvote this post. \nIn any case, here\
    \ are the benchmark results:\n<code>\nrequire 'benchmark'", "  distinct_count\
    \ = 0\n  string.each_char do |char|\n    distinct_count += 1\n  end \n  distinct_count\n\
    end", "  string.downcase!\n  string.chars.uniq.size\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThanks Boris. But how is your solution for \"The Python Programming Language\"\
    \ not working?\n<|/ c |>\n<| c |>\nOh wait, I'm sorry. I got your solution to\
    \ work! I was using Ruby not Python.\n<|/ c |>\n<| c |>\nNo worries :) I'm glad\
    \ you got it working!\n<|/ c |>\n<| a tags=python,ruby,string |>\nI would use\
    \ the Counter class from the collections module.\n<code>\n>>> from collections\
    \ import Counter\n>>> Counter('python')\nCounter({'p': 2, 'y': 1, 't': 1, 'h':\
    \ 1, 'o': 1})\n</code>\n<|/ a dscore=2 |>\n<| a tags=python,ruby,string |>\nRuby\
    \ has some methods for this (I think).  In Ruby 1.9 the String class has a method\
    \ called each_char which iterates over all the characters in the string.  So this\
    \ would work:\n<code>", "  characters = string.split(//).uniq.sort\n  characters.each\
    \ { |c| yield c if c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' }\n\
    end", "  return string.split('').uniq.size\nend", "  string.scan(/[a-z]/i).inject(0)\
    \ do |c, character|\n    c += 1 if character == \"z\"\n    c += 1 if character\
    \ == \"Z\"\n    c += 1 if character == \"y\"\n    c += 1 if character == \"Y\"\
    \n    c += 1\n  end\nend", "  string.each_char.inject(:+)\nend\n</code>\nThis\
    \ way you will be able to count the number of distinct characters in the string.\n\
    <|/ a tags=ruby,string |>\n<| c |>\nThe OP wants to know the length of the longest\
    \ string with each distinct character.\n<|/ c |>\n<| a |>\n<code>", "  string.each_char.inject(0)\
    \ { |result, char| result + 1 if char.upcase != char.downcase || char.upcase.empty?\
    \ || char.downcase.empty? }\nend", "  return (string.length * string.gsub(/([A-Z])\\\
    1*/, '\\1').length) / string.gsub(/[^A-Z^a-z]$/, '').length\nend", "  characters\
    \ = string.downcase.split('')\n  characters.uniq.length\nend", "  string.downcase!\n\
    \  string.split(//).map {|c| c.downcase! }\n    .uniq.size\nend", "  string.downcase!\n\
    \  count = 0\n  string.each_char do |character|\n    if !character.nil? && !string.include?(character)\n\
    \      count += 1\n    end\n  end\n  count\nend", "  string.each_char do |character|\n\
    \    next if character == string[string.index(character)]\n    count = 0\n   \
    \ string.each_char do |other_character|\n      if character == other_character\n\
    \        count += 1\n      end\n    end\n    count\n  end\nend", "  string.downcase!\n\
    \  count = 1\n  string += \" \"\n  while string.size > 0\n    string = string.slice!(0)\n\
    \    count += 1\n  end\n  count\nend\n</pre>\n</dd>\n<dt id=\"C-R-S-M-I-D\">\n\
    <span id=\"C-R-S-M-I-D-Key\">C-R-S-M-I-D</span>\n    <dl class=\"index\">\n  \
    \    <dt>KEY</dt>\n        <dd>\n          <ul>\n            <li class=\"index-item\
    \ index-item_key\">C-R-S-M-I-D</li>\n            <li class=\"index-item index-item_description\"\
    >Run snippets and switch to new tab</li>\n          </ul>\n        </dd>\n   \
    \   <dt>M</dt>\n      <dd>\n        <ul>\n          <li class=\"index-item index-item_description\"\
    >Toggle comment on/off</li>\n        </ul>\n      </dd>\n      <dt>M</dt>\n  \
    \    <dd>\n        <ul>\n          <li class=\"index-item index-item_description\"\
    >Toggle line comment on/off</li>\n        </ul>\n      </dd>\n      <dt>D</dt>\n\
    \      <dd>\n        <ul>\n          <li class=\"index-item index-item_description\"\
    >Delete selected text</li>\n        </ul>\n      </dd>\n      <dt>R</dt>\n   \
    \   <dd>\n        <ul>\n          <li class=\"index-item index-item_description\"\
    >Reset snippet to its initial state</li>\n        </ul>\n      </dd>\n      <dt>S</dt>\n\
    \      <dd>\n        <ul>\n          <li class=\"index-item index-item_description\"\
    >Save snippet buffer</li>\n        </ul>\n      </dd>\n      <dt>E</dt>\n    \
    \  <dd>\n        <ul>\n          <li class=\"index-item index-item_description\"\
    >Re-run last snippet</li>\n        </ul>\n      </dd>\n      <dt>I</dt>\n    \
    \  <dd>\n        <ul>\n          <li class=\"index-item index-item_description\"\
    >Insert text at cursor location</li>\n        </ul>\n      </dd>\n      <dt>I</dt>\n\
    \      <dd>\n        <ul>\n          <li class=\"index-item index-item_description\"\
    >Insert snippet at cursor location</li>\n        </ul>\n      </dd>\n      <dt>S</dt>\n\
    \      <dd>\n        <ul>\n          <li class=\"index-item index-item_description\"\
    >Save snippet at cursor location</li>\n        </ul>\n      </dd>\n      <dt>E</dt>\n\
    \      <dd>\n        <ul>\n          <li class=\"index-item index-item_description\"\
    >Run last snippet from cursor</li>\n        </ul>\n      </dd>\n      <dt>M</dt>\n\
    \      <dd>\n        <ul>\n          <li class=\"index-item index-item_description\"\
    >Switch between multiple cursors</li>\n        </ul>\n      ", "  return string.split('').uniq.size\n\
    end", "  string.gsub(/./) { |char| char.ord }.uniq.length\nend", "  # Convert\
    \ to upper case so that we don't compare with case-sensitive characters\n  string.upcase!\n\
    \  string = string.downcase", "    characters = string.split(//)\n    characters\
    \ = characters.collect(&:downcase)\n    characters.size\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby,algorithm,string |>\n<| a dscore=0 |>\n<code>\n'XYZXYZ'\n.chars.map\
    \ { |c| c.downcase }\n.uniq\n.size", "  string.scan(/[a-z]/).length\nend", " \
    \ return 0 unless string\n  string.gsub(/([a-z]+)/).uniq.size\nend", "  string.gsub!(/[a-z]+/,\
    \ '') # remove all lower case letters\n  string.downcase!\n  string.squeeze!\n\
    \  string.count(' ') + 1\nend", "  chars = string.split('')\n  chars.uniq.length\n\
    end\n</code>\nAnd if you just need the amount of unique characters, you could\
    \ use the #count method for Strings:\n<code>", "  # Initialize counts\n  counts\
    \ = Hash.new(0)\n  # Iterate through each character\n  string.each_char do |char|\n\
    \    counts[char] +=1\n  end\n  # Iterate through each count\n  counts.each_key\
    \ do |count|\n    # If the count is more than one, return it as it is\n    if\
    \ count > 1\n      return count\n    else\n      # Otherwise, return 0 if the\
    \ character is different from the previous char\n      if counts[count] == 1\n\
    \        return 0\n      end\n    end\n  end\nend", "    distinct_char_count =\
    \ 0\n    \n    # For each letter in string\n    for letter in string\n       \
    \ # Check if the current letter is already in the hash table\n        if @character_count[letter]\n\
    \            # Increase the count by 1\n            @character_count[letter] +=\
    \ 1\n        else\n            # Add the count to the hash table and initialize\
    \ it to 1\n            @character_count[letter] = 1\n        end\n    end\n  \
    \  \n    # Return the count of distinct characters\n    return @character_count.length\n\
    end", "  return string.scan(/[[:lower:]]/).length\nend", "  return string.downcase.split(//).uniq.length\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby-on-rails,ruby,ruby-on-rails-3\
    \ |>\n<code>", "  string.split('').inject(0) {|t,c| t + ((c=c.upcase)? c.length\
    \ : 1) }\nend", "  string.downcase!\n  string.gsub(/[^a-zA-Z]/,'') # remove all\
    \ non-alphanumeric characters\n  string.length\nend", "    characters = string.downcase.split(//)\n\
    \    count = 1\n    characters.each do |char|\n        if char.downcase == char\n\
    \            count = count + 1\n        end\n    end\n    count\nend\n</code>\n\
    Hope this helps!\n<|/ a tags=ruby,string dscore=0 |>\n<| c |>\nThe question asked\
    \ to count the number of distinct characters regardless of case, not number of\
    \ characters in the string. `count_distinct_characters('xyzXYZ')` should return\
    \ 3.\n<|/ c |>\n<| a |>\n<code>\nstring.downcase.split(//)\n</code>\n<|/ a dscore=0\
    \ tags=ruby,string |>\n<| c |>\nWhile this code may answer the question, providing\
    \ additional context regarding how and/or why it solves the problem would improve\
    \ the answer's long-term value.\n<|/ c |>\n<| c |>\nAgreed, but this is the first\
    \ result from Google, so I thought I would share this solution. Hence my remark.\n\
    <|/ c |>\n<| a tags=ruby,string |>\nHow about this?\n<code>\nstring.downcase.split(//).length\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  return string.split(//).uniq.size\n\
    end", "  string.split(//).uniq.count\nend", "  count = 1\n  string.each_char do\
    \ |char|\n    count += 1 if string[char] == char\n  end\n  count\nend", "  string.each_char.with_object(Hash.new(0)){|c,h|\
    \ h[c] += 1 }.values.max\nend", "  string.split('').uniq.size\nend\n</code>\n\
    This is pretty straightforward and simple. It splits the string into an array\
    \ of characters, and it removes duplicate characters. After that it returns the\
    \ size of the array which is the number of distinct characters.\n<|/ a dscore=1\
    \ |>\n<| c |>\nPlease provide additional details in your answer. As it's currently\
    \ written, it's hard to understand your solution.\n<|/ c |>\n<| c |>\nThanks so\
    \ much! Very helpful for me and for everyone else. :)\n<|/ c |>\n<| c |>\nI think\
    \ this might fail on long strings. For example, `count_distinct_characters(\"\
    1234567890\")` returns `1`, but should be `10`.\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>", "  string.gsub(/[^a-zA-Z0-9]+/).length\nend", "  string.count(\"a\".ord)\
    \ - string.count(\"A\".ord)\nend", "  count_distinct_chars_count = 0\n  string.each_char\
    \ do |char|\n    count_distinct_chars_count += 1\n  end\n  count_distinct_chars_count\n\
    end", "  return string.chars.distinct.size\nend", "  return string.split('').uniq.count\n\
    end", "  string.downcase!\n  string.each_char.inject(0) { |result, char| result\
    \ + (char.ord - 96) }\nend", "  string.chars.uniq.size\nend", "  string.split('').uniq.size\n\
    end\n</cell>\n<cell>", "  characters = string.downcase.split('')\n  characters.each\
    \ do |character|\n    character.ord - 1\n  end\nend\n</code>\nBut then there's\
    \ also this:\n<code>", "  string.downcase!\n  string.downcase!\n  string.gsub(/[\\\
    p{Lu}\\p{Ll}]/,'').length\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
