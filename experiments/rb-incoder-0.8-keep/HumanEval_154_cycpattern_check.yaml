name: HumanEval_154_cycpattern_check
language: rb
prompt: "# You are given 2 words. You need to return True if the second word or any\
  \ of its rotations is a substring in the first word\n# cycpattern_check(\"abcd\"\
  ,\"abd\") => False\n# cycpattern_check(\"hello\",\"ell\") => True\n# cycpattern_check(\"\
  whassup\",\"psus\") => False\n# cycpattern_check(\"abab\",\"baa\") => True\n# cycpattern_check(\"\
  efef\",\"eeff\") => False\n# cycpattern_check(\"himenss\",\"simen\") => True\ndef\
  \ cycpattern_check(a, b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_cycpattern_check\n\
  \    candidate = method(:cycpattern_check)\n    assert_equal(false, candidate.call(\"\
  xyzw\", \"xyw\"))\n    assert_equal(true, candidate.call(\"yello\", \"ell\"))\n\
  \    assert_equal(false, candidate.call(\"whattup\", \"ptut\"))\n    assert_equal(true,\
  \ candidate.call(\"efef\", \"fee\"))\n    assert_equal(false, candidate.call(\"\
  abab\", \"aabb\"))\n    assert_equal(true, candidate.call(\"winemtt\", \"tinem\"\
  ))\n  end\nend\n"
completions: ['  return true if a == "a" || a == "b" || a == "c" || a == "d" || a
    == "e" || a == "f" || a == "g" || a == "h" || a == "i" || a == "j" || a == "k"
    || a == "l" || a == "m" || a == "n" || a == "o" || a == "p" || a == "q" || a ==
    "r" || a == "s" || a == "t" || a == "u" || a == "v" || a == "w" || a == "x" ||
    a == "y" || a == "z" || a == "A" || a == "B" || a == "C" || a == "D" || a == "E"
    || a == "F" || a == "G" || a == "H" || a == "I" || a == "J" || a == "K" || a ==
    "L" || a == "M" || a == "N" || a == "O" || a == "P" || a == "Q" || a == "R" ||
    a == "S" || a == "T" || a == "U" || a == "V" || a == "W" || a == "X" || a == "Y"
    || a == "Z"', "  return b.gsub(a,\"\\0\").include?(a.chars.join)\nend", "    if\
    \ a.length == 0 or b.length == 0\n        false\n    else\n        if a.length\
    \ == 1 or b.length == 1\n            return true if a.include? b or b.include?\
    \ a\n        else\n            return true if a.include? b or b.include? a or\
    \ a.include? b or b.include? a or a.include? b or b.include? a\n        end\n\
    \    end\nend", "  a = ''.chars\n  b = ''.chars\n  a_size = a.size\n  b_size =\
    \ b.size\n  return false if a_size != b_size || b_size < 1 || a_size < 1 || a.eq(b)\
    \ end\n  c = 0\n  a_i = 0\n  b_i = 0\n  b_end = b_size - 1\n  while c < b_end\
    \ - 1\n    if a[a_i + c] == b[b_i + c]\n      a_i += 1\n      b_i += 1\n     \
    \ c += 1\n    else if a[a_i + c - 1] == b[b_i + c - 1]\n      a_i -= 1\n     \
    \ b_i -= 1\n      c += 1\n    end\n  end\n  if a_i == a_size or b_i == b_end\n\
    \    return true\n  else false\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\n\
    This is my approach. \nThe idea is to check if the word is a substring of the\
    \ other word, and if so rotate the first word until it contains the other word.\
    \ \n<code>", "    if a != b\n        a.gsub!(/./, \"*\")\n        b.gsub!(/./,\
    \ \"*\")\n        a_arr = a.split\n        b_arr = b.split\n        a_arr.rotate!\
    \ 0\n        b_arr.rotate! 0\n        a_arr.each do |x|\n            if b_arr.include?(x)\n\
    \                return true\n            end\n        end\n    end\n    return\
    \ false\nend\n</code>\n<|/ a tags=string,ruby,algorithm |>\n<| a |>\nThis would\
    \ be my approach.\n<code>", "  a.gsub!(/\\w/) { |s| s.upcase }\n  b.gsub!(/\\\
    w/) { |s| s.upcase }\n  a.split('').sort.each_cons(2) do |s, ss|\n    next if\
    \ s == ss\n    if a.include?(s) || b.include?(s)\n      false\n    else\n    \
    \  if a.include?(ss)\n        true\n      else\n        cycpattern_check(s,ss)\n\
    \      end\n    end\n  end\n  false\nend\n</code>\nNote that I removed the global\
    \ variable and just set it each time.\n<|/ a tags=ruby |>\n<| c |>\nThe `each_cons`\
    \ is a nice touch.\n<|/ c |>\n<| a dscore=3 tags=ruby |>\n<code>", "  a1 = a.split\
    \ # Splits string a into array a1\n  b1 = b.split # Splits string b into array\
    \ b1\n  count = 0\n  i = 0\n  while i < a1.length do\n    count = (count + 1)\
    \ if (a1[i] == a1[i + 1]) #Count the number of rotations needed\n    i = i + 1\n\
    \  end\n  j = 0\n  while j < b1.length do\n    count = (count + 1) if (b1 == b1[j])\
    \ #Count the number of rotations needed\n    j = j + 1\n  end\n  return count\
    \ <= 1\nend\n</cell>\n<text>\n3. Implement a hash table with insert, query and\
    \ delete methods", "  a = a.split('')\n  b = b.split('')\n  a.each_index do |i|\n\
    \    if b.include?(a[i])\n      b.delete(a[i])\n    end\n  end\n  b.include?(a[0])\
    \ ? true : false\nend", "  a.split(\"\").sort.each do |char|\n    return true\
    \ if b.include?(char) ? true : false\n  end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis would be better suited as a comment.\n<|/ c |>\n<| c |>\nOh okay,\
    \ sorry I forgot about that. Thanks again.\n<|/ c |>\n<| c |>\nHe said \"substring\
    \ in the first word\"\n<|/ c |>\n<| a dscore=0 |>\nHere's another way of doing\
    \ it:\n<code>", "  l1 = a\n  l2 = b\n  l1.downcase!\n  l2.downcase!\n  l1 = l1.chars\n\
    \  l2 = l2.chars\n  if l2.empty?\n    return true\n  end\n  return false unless\
    \ l1.include? l2.first\n  i = l1[0]\n  l2.shift\n  l2.each do |c|\n    return\
    \ false if l1.include? c\n  end\n  return true\nend\nend\n</code>\n<|/ q tags=ruby\
    \ |>\n<| c |>\nYou should at least tell us what's wrong with your code. Otherwise\
    \ it's just an invitation to solve the problem for you.\n<|/ c |>\n<| c |>\nIt's\
    \ very likely that I'm just not understanding Ruby well enough, but that's all\
    \ I need at this point. As I said, I'm just trying to learn this language, I'm\
    \ not a professional, and I don't care that I'm stuck on a problem for an hour\
    \ or so. Thanks.\n<|/ c |>\n<| c |>\nDo you need to check all substrings? In that\
    \ case you should be able to use [this answer](http://stackoverflow.com/a/17573460/59087).\n\
    <|/ c |>\n<| c |>\nI'm going to take a stab at the problem and post an answer\
    \ in a minute.\n<|/ c |>\n<| c |>\nYou might want to read \"[How do I ask and\
    \ answer homework questions?](https://meta.stackoverflow.com/q/334822)\".\n<|/\
    \ c |>\n<| a dscore=1 |>\nI believe I solved this question (assuming I understood\
    \ it correctly). First, you didn't describe the rules for cycpattern_check; I\
    \ assumed that every letter in the second string was in the first string. This\
    \ isn't necessarily true, as in \"abcd\" you might be searching for \"abc\".\n\
    <code>", "    a, b = a.split('').reverse.map, b.split('').reverse.map\n    a.map\
    \ { |s| b.include?(s) }.reduce(:&).any?\nend\n</cell>\n<code language=julia-1.1>\n\
    @time cycpattern_check(\"abcd\",\"abd\"); @time cycpattern_check(\"hello\",\"\
    ell\"); @time cycpattern_check(\"whassup\",\"psus\")\n</cell>\n<text>\nExercise\
    \ 2\nWrite a function in Julia that takes a vector of strings and returns a vector\
    \ of booleans that indicates if the word is a palindrome (in the same order),\
    \ or if the word is a substring/rotation of another word", "  s = a[0, b.length]\n\
    \  s.slice!(b) do |c|\n    a[0...a.rindex(c)]\n  end\n  s <= b\nend\n</code>\n\
    <|/ a |>\n<| c |>\nYou shouldn't use `gsub` with a regular expression if you don't\
    \ have to. That's what [`slice!`](http://ruby-doc.org/core/String.html#method-i-slice-21)\
    \ is for. You should probably use a regular expression instead.\n<|/ c |>\n<|\
    \ c |>\nThanks for that! I've edited the answer. Though `gsub` was only used because\
    \ I didn't know any other way of doing it. The regex would obviously be simpler,\
    \ but not as efficient (no backtracking).\n<|/ c |>\n<| a |>\n<code>", "  if a.length\
    \ == 0 or b.length == 0\n    return false\n  end", "  return a.include?(b) ||\
    \ (b =~ /^\\A#{a}\\z/) && a.each_char.any? {|c| b.include?(c) }\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\nWow, that's actually really clever. I've never\
    \ thought of that. Could you provide some explanation on why it's faster? My guess\
    \ is it's because of the `Regexp::last_match` call since it's only looking for\
    \ the first match anyways, but it seems like a clever solution.\n<|/ c |>\n<|\
    \ c |>\nIt would actually be worth noting that this method is very slow; it took\
    \ my computer several minutes to check a 100 character string against a 100 character\
    \ string when compared to my computer running `include?`. My computer is an i7\
    \ 2600k with 4GB of RAM.\n<|/ c |>\n<| c |>\nYou're right. `include?` was a lot\
    \ faster than my version. Also I just realized that this method is actually wrong.\
    \ It doesn't test if the string is a substring of the second string. For example,\
    \ `\"hello\"` and `\"hellox\"` are considered substrings. I made a change that\
    \ fixes that problem.\n<|/ c |>\n<| c |>\n, this is actually surprisingly fast.\
    \ `include?` is even faster on my computer (i7 2600k with 4GB of RAM). My computer\
    \ isn't fast enough at any speed for this to be an issue, but it's nice to see\
    \ that Ruby has this handy method.\n<|/ c |>\n<| c |>\n: Ruby probably had `include?`\
    \ at the time of my answer :) Since I wrote my answer over 3 years ago, I've had\
    \ to write some new answers and update old ones, because I learned something new\
    \ :)\n<|/ c |>\n<| a tags=ruby,string dscore=3 |>\nHere's a version that only\
    \ uses string comparisons:\n<code>", "    a_arr = a.split('')\n    b_arr = b.split('')\n\
    \    i = 0\n    j = 0\n    len_a = a.length\n    len_b = b.length\n    while i\
    \ < len_a && j < len_b\n        if a_arr[i] != b_arr[j]\n            return false\n\
    \        i += 1\n        j += 1\n    if i == len_a && j == len_b\n        return\
    \ true\n    return false\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThis is a\
    \ solution that checks every rotated string for being contained in the original\
    \ string by checking each character with each other character in the string, where\
    \ as it is less optimal that some of the other solutions that use substring functions.\n\
    <code>", "  c = b.chars\n  c.shift # throw away first char\n  c.rotate! # throw\
    \ away the rest\n  a = 0\n  while a < a.length\n    c = a.chars\n    c.shift #\
    \ throw away first char\n    c << b # push b's chars onto c\n    if c == a.chars\n\
    \      return true\n    else\n      c << a # push a's chars onto c\n    end\n\
    \    a += 1\n  end\n  return false\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Thanks a lot for the detailed explanation. The solution is working like a charm!\n\
    <|/ c |>\n<| c |>\nJust curious, what is wrong with my code if I am doing it in\
    \ a very straightforward way?\n<|/ c |>\n<| c |>\n- I tried to explain what was\
    \ wrong with your code in a comment on the question itself.\n<|/ c |>\n<| c |>\n\
    It doesn't need to be \"straightforward\". It can be implemented faster by doing\
    \ it more cleverly using set methods and hashing instead of iterating in Ruby\
    \ but that would be more complicated. There are many ways to do this and in Ruby\
    \ they are all \"straightforward\".\n<|/ c |>\n<| c |>\n- You could speed it up\
    \ if you knew the length of `a` ahead of time because you'd just have to do `while\
    \ b[a.length] == a[0]` instead of iterating over `a`. And then you only have to\
    \ do `b[a.length]` once.\n<|/ c |>\n<| a tags=string,ruby,substring |>\nYou can\
    \ do it with O(|a| * |b|) time:\n<code>", "  a.reverse!\n  a[0..a.length-1].each_char.with_index\
    \ do |c,i|\n    if (b.include?(c)) || (b.include?(a[i]) && cycpattern_check(a[0...i],\
    \ b[0...i])) return true\n  end\n  return false\nend\n</code>\n<|/ a tags=string,pattern-matching,ruby\
    \ |>\n<| c |>\nI see your code, but I don't see how it gives the desired results.\
    \ Can you elaborate?\n<|/ c |>\n<| c |>\nI made some changes, please take a look.\n\
    <|/ c |>\n<| c |>\nAh! Nice, I think this was what I was looking for.\n<|/ c |>\n\
    <| c |>\nI added a more efficient version of the pattern check method.\n<|/ c\
    \ |>\n<| c |>\nThis is great -- but it fails on my edge case: cycpattern_check(\"\
    whassup\",\"psus\") => True; I think it needs better corner cases. I updated the\
    \ question to include my edge case.\n<|/ c |>\n<| a tags=string,pattern-matching,ruby\
    \ |>\nThe accepted answer fails for strings like \"ababc\" with \"abb\" (because\
    \ \"b\" does not occur in \"ababc\"). I think the following version is more robust:\n\
    <code>", "  a.gsub(/\\w/) {|w| w.upcase}.gsub(/[aeiouy]/) {|u| u.downcase}.gsub(/\\\
    d/) {|d| d.to_i}\n  b.gsub(/\\w/) {|w| w.upcase}.gsub(/[aeiouy]/) {|u| u.downcase}.gsub(/\\\
    d/) {|d| d.to_i}\n  b.gsub(/\\w/) {|w| w.upcase}.gsub(/[aeiouy]/) {|u| u.downcase}.gsub(/\\\
    d/) {|d| d.to_i}\n  return a == b \nend\n</code>\n<|/ a dscore=3 tags=string,ruby\
    \ |>\n<| a dscore=3 |>\nA very simple solution can be done using two nested loops\
    \ - one to traverse the characters of word one and the other to traverse the characters\
    \ of word two.\nIf they match then word one is a substring of word two.\n<code>",
  "\tb.split(\"\").each do |el|\n\t\tif a =~ /#{el}/\n\t\t\treturn true\n\t\tend\n\
    \tend\n\treturn false\nend", "  a.gsub!('\\A', '').gsub!('\\z', '').downcase!\n\
    \  b.gsub!('\\A', '').gsub!('\\z', '').downcase!\n  (b.start_with?(a) || b.end_with?(a))\
    \ && b != a || a.include?(b) || b.include?(a)\nend", "  a1 = a.split\n  b1 = b.split\n\
    \  if a.length != b.length\n  false\n  elsif a1.length < b1.length\n  false\n\
    \  elsif a1.first != b1.first\n  false\n  else\n  a1.each_index {|i| b1.each_index\
    \ {|j| return false if a[i].index(b[j]) } }\n  true\n  end\nend", "  a = a.downcase\n\
    \  b = b.downcase\n  return (a.length == b.length) and a.slice(a.length - b.length,\
    \ a.length) == b\nend", "  a.chars.sort.uniq.map{|c| a.chars.count(c)}.max.positive?\n\
    \  b.chars.sort.uniq.map{|c| b.chars.count(c)}.max.positive?\n  a.chars.sort.uniq.map{|c|\
    \ b.chars.count(c)}.min.positive?\n  b.chars.sort.uniq.map{|c| a.chars.count(c)}.min.positive?\n\
    \  a.each_char.all? {|c| b.include?(c)} &&\n  b.each_char.all? {|c| a.include?(c)}\n\
    end\n</cell>\n<code language=julia-0.5>\ncycpattern_check(\"abab\",\"baa\") #\
    \ => True\ncycpattern_check(\"efef\",\"eeff\") # => False\ncycpattern_check(\"\
    himenss\",\"simen\") # => True\n</cell>\n<text>\n3.3 Word Patterns\nNow that you\
    \ have learned what a cylinder pattern is, it's time to implement a word pattern\
    \ search. The idea is quite simple: for each possible pattern of words that you\
    \ have (for example \"aba\" and \"baa\"), you can see if it is a substring of\
    \ the whole word. If it is, print its position. For example for the word \"abcd\"\
    \ the patterns would be:", "  a.split(\"\").each do |word|\n    return false unless\
    \ a.include? word\n    b.split(\"\").each do |word|\n      return false unless\
    \ b.include? word\n    end\n  end\n  return true\nend", "  a = a.upcase\n  b =\
    \ b.upcase\n  a_length = a.length\n  b_length = b.length", "  a1 = a[0]\n  b1\
    \ = b[0]\n  if a1 == b1 or a.size == 1 && a1 == \"#\"\n  else\n    a.each_char\
    \ do |ch|\n      b.each_char do |ch1|\n        if ch == ch1 and ch != a1\n   \
    \       return false\n        end\n      end\n    end\n  end\n  true\nend", " \
    \ a.reverse!\n  b.each_char.with_index do |char, index|\n    a_char = a.chars[index]\n\
    \    b_char = b.chars[index]\n    return true if a_char == b_char || b_char ==\
    \ a_char if b_char.nil? || a_char.nil?\n    if a_char == b_char\n      break\n\
    \    end\n    return true if a_char == b_char if a_char != b_char\n  end\n  false\n\
    end\n</code>\n<|/ a |>\n<| c |>\nAh, I see what you're saying. Thanks!\n<|/ c\
    \ |>\n<| a tags=string,algorithm,ruby dscore=1 |>\nJust for the fun of it: \n\
    <code>", "  a = a.to_s.downcase\n  b = b.to_s.downcase\n  return a.include?(b)\
    \ || a.include?(b[b.length-1])\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c\
    \ |>\nNice, but `include?(b[b-1])` should be `include?(b[b[b-1].to_sym)`. Or `include?(b[b-1].to_s)`,\
    \ which saves you a few characters.\n<|/ c |>\n<| c |>\nThank you for that suggestion!\n\
    <|/ c |>\n<| a |>\nTry something like this:\n<code>", "  a.downcase!\n  b.downcase!\n\
    \  a.gsub!(/(.)\\1*/, '\\1')\n  b.gsub!(/(.)\\1*/, '\\1')\n  a.size==b.size\n\
    \  (0...a.size).all? do |i|\n    (1...a.size).all? do |j|\n      a[j] == b[i]\
    \ && a[j].upcase==b[i].upcase\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThanks for your efforts. I will give them a try and get back to\
    \ you. I actually found a way to do the job. I will post the code as soon as I\
    \ get it working.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    a.each_char.with_index\
    \ do |char, index|\n        if b.include?(char)\n            return true if index\
    \ == 0\n        elsif b.length < index\n            return false\n        end\n\
    \    end\n    return false\nend", "    return a.include?(b) || a.match?(/\\A[A-Z]+\\\
    z/).try(:gsub, /\\b#{b}\\b/).try(:empty?)\nend", "  # Your code here\n  a.split(\"\
    \").include?(b.split(\"\")) ? false : true\nend", "\ta.upcase!\n\tb.downcase!\n\
    \treturn false if a.length != b.length || (a.length == 0 && b.length > 0) || (b.length\
    \ == 0 && a.length > 0) \n\treturn true if a.include?(b) || b.include?(a) || [a,\
    \ b].any? { |c| (a.include?(c) || b.include?(c)) }\n\treturn false\nend", "  return\
    \ false if a.empty? || b.empty? || (a =~ /b/ && b =~ /a/ ? true : false)\n  a_chars\
    \ = []\n  b_chars = []\n  a_chars += a.chars\n  b_chars += b.chars\n  a_chars.uniq\n\
    \  b_chars.uniq\n  a_chars.any? { |char| b_chars.include? char.to_sym }\nend\n\
    </code>\n<|/ a tags=regex,ruby |>\n<| a tags=regex,ruby dscore=0 |>\n<code>\n\
    a = 'abcdefg'\nb = 'cde'\nc = 'defg'", "  c= a[0]+a[1]\n  if b.length>1 then \n\
    \    return false # you can not use \"sub\" with empty string\n  else\n    return\
    \ a.include?(c) or b.include?(c) or a.include?(b) or b.include?(b)\n  end\nend\n\
    </code>\n<|/ a dscore=0 tags=string,ruby |>\n<| c |>\nThanks for the help but\
    \ I am getting an error.     `c= a[0]+a[1]` \n    `NoMethodError: undefined method\
    \ '+' for nil:NilClass`\n<|/ c |>\n<| c |>\nI edited the code as I thought that\
    \ your test data had \"-\" instead of \"+\"\n<|/ c |>\n<| a tags=string,ruby |>\n\
    A solution would be to split the string into its letters and then go through it\
    \ comparing the given string to the current letter.\nExample:\n<code>\na = \"\
    HelloWorld\"\nb = \"hell\"", "  a_array = (a.split(\"\")).to_a\n  b_array = (b.split(\"\
    \")).to_a\n  a_array.length.times do |i|\n    b_array.length.times do |j|\n  \
    \    if a_array[i] == b_array[j]\n        a_array.delete_at(i)\n        b_array.delete_at(j)\n\
    \        break\n      end\n    end\n  end\n  if a_array.length == 0\n    a_array.concat([b])\n\
    \  end\n  if b_array.length == 0\n    b_array.concat([a])\n  end\n  a_array.length\
    \ != b_array.length\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere is\
    \ a solution using only a single array:\n<code>", "  b.length.times do |i|\n \
    \   b.slice!(0, b.length - i).reverse!\n    while a.length <= b.length\n     \
    \ break if a.starts_with?(b)\n      a << b.slice!(0, b.length - b.length)\n  \
    \  end\n    b.slice!(0, b.length)\n  end\n  a.include?(b)\nend", "  a.each_char.map\
    \ do |c|\n    a.split(c).any? { |s| b.split(s).any? } ? false : true\n  end\n\
    end", "  a.length == b.length ? true : false \nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thank you for your help.  I have updated my question and posted my attempt.\n\
    <|/ c |>\n<| c |>\nThis solution only works if both strings have the same number\
    \ of letters. If the number of letters in the second string exceeds the number\
    \ of letters in the first string, the method will say that the second string is\
    \ longer than the first string. I think there is a bug in CycPatt that it would\
    \ also return true for a string with the number of letters in the first string\
    \ exceeding the number of letters in the second string.  ", "  return a.split(\"\
    \").sort.join.(b).split(\"\").sort.join.a.split(\"\").sort.join(\"a\").split(\"\
    \").sort.join(\"a\")==a\nend\n</code>\n<|/ a tags=ruby,regex |>\n<| a |>\n<code>\n\
    word = \"word\"\nsub = \"o\"", "    a.downcase!\n    b.downcase!\n    (a.length\
    \ <= 1 && b.length <= 1) || (a.length >= b.length && a.chars.find {|c| b[a.size\
    \ - b.size + 1].include?(c) }) != nil\nend\n</code>\n<|/ a |>\n<| a tags=string,ruby,regex\
    \ dscore=2 |>\nFor fun, here's a solution using Ruby 1.8's gsub! (for Ruby 1.9.x,\
    \ use gsub) method:\n<code>", "  b.split(\"\").each do |x| \n    a.include?(x)\
    \ ? true : false\n  end\nend", "  return true if (a.gsub!(b,\"\").empty?) and\
    \ (a.include?(b) or b.include?(a))\nend", "    a.upcase!\n    b.upcase!\n    a.length\
    \ == b.length\n    b.each_char { |c|\n        if a.include?(c)\n            a.slice!(c)\n\
    \        end\n    }\n    a.include?(b) || a.include?(b.swapcase)\nend\n</code>\n\
    <|/ a |>\n<| c |>\n`b.slice!(c)` will cause a stack overflow.\n<|/ c |>\n<| c\
    \ |>\nGood catch! I didn't know Ruby had a stack overflow exception...\n<|/ c\
    \ |>\n<| a tags=ruby,string |>\n<code>", "  if a.length == 0 || b.length == 0\n\
    \    return false\n  else\n    pattern = Array()\n    pattern[0] = \"a\"\n   \
    \ pattern[1] = \"b\"\n    pattern[2] = \"c\"\n    pattern[3] = \"d\"\n    pattern[4]\
    \ = \"e\"\n    pattern[5] = \"f\"\n    pattern[6] = \"g\"\n    pattern[7] = \"\
    h\"\n    pattern[8] = \"i\"\n    pattern[9] = \"j\"\n    pattern[10] = \"k\"\n\
    \    pattern[11] = \"l\"\n    pattern[12] = \"m\"\n    pattern[13] = \"n\"\n \
    \   pattern[14] = \"o\"\n    pattern[15] = \"p\"\n    pattern[16] = \"q\"\n  \
    \  pattern[17] = \"r\"\n    pattern[18] = \"s\"\n    pattern[19] = \"t\"\n   \
    \ pattern[20] = \"u\"\n    pattern[21] = \"v\"\n    pattern[22] = \"w\"\n    pattern[23]\
    \ = \"x\"\n    pattern[24] = \"y\"\n    pattern[25] = \"z\"\n    pattern[26] =\
    \ \"aa\"\n    pattern[27] = \"ab\"\n    pattern[28] = \"ac\"\n    pattern[29]\
    \ = \"ad\"\n    pattern[30] = \"ae\"\n    pattern[31] = \"af\"\n    pattern[32]\
    \ = \"ag\"\n    pattern[33] = \"ah\"\n    pattern[34] = \"ai\"\n    pattern[35]\
    \ = \"aj\"\n    pattern[36] = \"ak\"\n    pattern[37] = \"al\"\n    pattern[38]\
    \ = \"am\"\n    pattern[39] = \"an\"\n    pattern[40] = \"ao\"\n    pattern[41]\
    \ = \"ap\"\n    pattern[42] = \"aq\"\n    pattern[43] = \"ar\"\n    pattern[44]\
    \ = \"as\"\n    pattern[45] = \"at\"\n    pattern[46] = \"au\"\n    pattern[47]\
    \ = \"av\"\n    pattern[48] = \"aw\"\n    pattern[49] = \"ax\"\n    pattern[50]\
    \ = \"ay\"\n    pattern[51] = \"az\"\n    pattern[52] = \"ba\"\n    pattern[53]\
    \ = \"bb\"\n    pattern[54] = \"bc\"\n    pattern[55] = \"bd\"\n    pattern[56]\
    \ = \"be\"\n    pattern[57] = \"bf\"\n    pattern[58] = \"bg\"\n    pattern[59]\
    \ = \"bh\"\n    pattern[60] = \"bi\"\n    pattern[61] = \"bj\"\n    pattern[62]\
    \ = \"bk\"\n    pattern[63] = \"bl\"\n    pattern", "  a.length>b.length ? (a.length\
    \ > a.include?(b) ? false : true) : (a.length < b.length ? false : true)\nend",
  "  return true if a.length==0 || b.length==0\n  return true if a==b\n  if a.length>0\n\
    \    return true if a.include? b.downcase\n    return true if a.include? b.upcase\n\
    \    return true if a.include? b.capitalize\n    return true if a.include? b.titlecase\n\
    \  end\n  if b.length>0\n    return true if b.include? a.downcase\n    return\
    \ true if b.include? a.upcase\n    return true if b.include? a.capitalize\n  \
    \  return true if b.include? a.titlecase\n  end\n  return false\nend", "    a.chars.each\
    \ do |x|\n        a.chars.each do |y|\n            if y == x && b.include?(x)\n\
    \                return true\n            end\n        end\n    end\nend\n</cell>\n\
    <text>\nWrite the method cycpattern_check, which is defined above in the cell\
    \ below, that takes in 2 strings a and b and returns true if the second word or\
    \ any of its rotations is a substring in the first word. Return false if the second\
    \ word is not of length 2 or if the second word is of length 1 and contains only\
    \ one of the letters in the first word.", "  first_word = a.chars.to_a\n  second_word\
    \ = b.chars.to_a\n  first_word.push false\n  second_word.push false\n  first_word.rotate(-1).each\
    \ do |first_letter|\n    second_word.rotate(-1).each do |second_letter|\n    \
    \  return true if first_letter == second_word || first_letter === second_word\n\
    \    end\n  end\n  first_word.rotate(1).each do |first_letter|\n    second_word.rotate(1).each\
    \ do |second_letter|\n      return true if first_letter == second_word || first_letter\
    \ === second_word\n    end\n  end\n  return false\nend", "  a, b = a.downcase.strip,\
    \ b.downcase.strip\n  return b[/./.rindex(a)].nil? ? false : (b.sub(a, 0, b.length-1).include?(a[/./.rindex(a)+1])\
    \ ? true : cycpattern_check(a, b[/./.rindex(a)+1])\nend\n</code>\nIt checks if\
    \ each b is the prefix of a, and if it does it returns true\n<|/ a dscore=3 tags=ruby\
    \ |>\n<| a tags=ruby |>\nThe below is a bit faster:\n<code>", "  a = [a[0..a.length-1]]\
    \ << [a[a.length..-1]]\n  b = [b[0..b.length-1]] << [b[b.length..-1]]\n  a.each\
    \ do |x|\n    b.each do |y|\n      if y =~ /#{x}/\n        return true\n     \
    \ end\n    end\n  end\n  return false\nend", "  pattern = a[0..(b-1)]\n  string1\
    \ = b[0..(a-1)]\n  string2 = a[(a+1)..(b-1)]\n  if string2.include?(pattern)\n\
    \    true\n  elsif string1.include?(pattern)\n    true\n  else\n    false\n  end\n\
    end", "  words = a.split(//).reverse\n  i = 0\n  while i < b.length\n    j = a.length\n\
    \    while j > 0\n      if b.slice!(i, 1) in words.slice!(j - 1, j)\n        j\
    \ = j - 1\n      else\n        return true\n      end\n    end\n    i = i + 1\n\
    \  end\n  return false\nend", "  cy = a[0...a.length-2]+a[a.length...-1]\n  ca\
    \ = a[0...a.length-2]+a[a.length..-1]\n  bc = b[0...b.length-2]+b[b.length...-1]\n\
    \  bca = b[0...b.length-2]+b[b.length..-1]\n  cb = b[0...b.length-2]+b[b.length..-1]\n\
    \  return cy==\"#\"+ca+cb && bc==\"#\"+cb+ca ? true : false\nend", "  return a.index(b)\
    \ > -1 ? true : false\nend", "  a.downcase!\n  b.downcase!\n  a.length == b.length\
    \ &&\n  a.each_char.with_object({}) { |x,h| h[x.to_sym] = true }.sort.select {\
    \ |k,v| b.include?(k) }.any? { |k,v| b.include?(k.to_s.reverse) }\nend\n</code>\n\
    The .sort is needed as otherwise it would fail for \"abab\" with both words as\
    \ strings. The result for abab is:\n<code>\n{\"b\"=>true, \"a\"=>true}\n</code>\n\
    Then the .select block filters the hash to just those keys with true values. So\
    \ now we have {\"b\"=>true} as the result. We can now check if any of the values\
    \ return true and we know that the two strings contain any word from the other\
    \ string as either its head or tail.\n<|/ a dscore=2 |>\n<| c |>\nThis should\
    \ be the accepted answer as it covers the question's concerns and also avoids\
    \ unnecessary string comparisons. Also using `.include?` instead of `.each` makes\
    \ the code more compact.\n<|/ c |>\n<| a |>\nSince I am new to Ruby, I wanted\
    \ to see if I could help you out.  I wrote a test program that tests the cycpattern_check\
    \ function.  \n<code>", "  a.downcase!\n  b.downcase!\n  a =~ /#{b}/i\n  b.split(\"\
    \").any? {|e| a =~ /#{e}/i }\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=string,ruby\
    \ |>\nHere's a solution that uses no regexes whatsoever, just basic string manipulation:\n\
    <code>", "  (a.length<2) && (return false)\n  (b.length<2) && (return false)\n\
    \  (a.length>=b.length) && (return false)\n  if a.length == 1\n    return true\n\
    \  end\n  if b.length == 1\n    return false\n  end\n  a.each_char.with_index\
    \ do |x, i|\n    if b.include? x\n      return true\n    end\n    (i < (b.length-1))\
    \ && return false\n  end\n  return false\nend", "    a.split(\"\").each do |w|\n\
    \        return true if b.include? w\n    end\n    false\nend\n</code>\n<|/ a\
    \ tags=ruby,string |>\n<| a dscore=0 |>\n<code>", "  return true if a.include?\
    \ b or b.include? a\nend", "  a = a.split('')\n  b = b.split('')\n  (a.length\
    \ <= b.length ? a : b).each_cons(2) do |a_substr, b_substr|\n    a.include?(b_substr)\
    \ || b.include?(a_substr)\n  end\nend", "  a1 = a[0]\n  a2 = a[-1]\n  b1 = b[0]\n\
    \  b2 = b[-1]\n  (b1.length >= a.length) or (b2.length >= a.length) or (a1.length\
    \ >= b.length) or (a2.length >= b.length)\n  return ((a1 == b1) or (a1 == b2)\
    \ or (a2 == b1) or (a2 == b2))\nend", "  if a.length == 0 or b.length == 0\n \
    \   return false\n  end\n  if b.length < a.length\n    return false\n  end\n \
    \ if a.chars.uniq.size == 0\n    return true\n  end\n  first_char_set = Set.new\n\
    \  b.chars.uniq.each do |bchar|\n    first_char_set.add(bchar)\n  end\n  a.chars.uniq.each\
    \ do |achar|\n    if first_char_set[achar] == nil\n      return false\n    end\n\
    \    first_char_set[achar].each do |first_char|\n      b.chars.uniq.each do |bchar|\n\
    \        if bchar == achar or bchar == first_char\n          return true\n   \
    \     end\n      end\n    end\n  end\n  return false\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThanks for the answer! I'll try to understand and implement it now.\n\
    <|/ c |>\n<| a |>\nI came up with another solution to check pattern in string.\
    \ I used the method I described in my previous answer. \n<code>", "  a.split(\"\
    \").each_index do |i|\n    word = a.split(\"\")[i]\n    b.split(\"\").each_index\
    \ do |j|\n      word_b = b.split(\"\")[j]\n      if word.length >= word_b.length\n\
    \        if word_b[0...word.length] == word\n          return true\n        elsif\
    \ word_b[0...word.length]  == word[0...word_b.length]\n          return true\n\
    \        end\n      end\n    end\n  end\n  return false\nend", "  return a.chars.sort.zip(b.chars).all?\
    \ do |(_,a),(_,b)|\n    a == b or a % 7 == b % 7\n  end\nend", "  a.downcase!\n\
    \  b.downcase!\n  return true if a === b\n  if a.length < b.length\n    return\
    \ false\n  end\n  if a.length > b.length\n    return true\n  end\n  return true\
    \ if a.include?(b) and a.include?(b.chars.drop(1).join)\nend", "  ls = a.chars.to_a\n\
    \  rs = b.chars.to_a\n  ls.zip(rs).each do |x,y|\n    if x.to_s.size != y.to_s.size\n\
    \      return false\n    end\n    if ls.index(x) == rs.index(y)\n      return\
    \ false\n    end\n  end\n  return true\nend\nputs \"#{cycpattern_check('abcd',\
    \ 'abd')}\"\nputs \"#{cycpattern_check('hello', 'ell')}\"\nputs \"#{cycpattern_check('whassup',\
    \ 'psus')}\"\nputs \"#{cycpattern_check('abab', 'baa')}\"\nputs \"#{cycpattern_check('efef',\
    \ 'eeff')}\"\nputs \"#{cycpattern_check('himenss', 'simen')}\"\n</code>\n<|/ a\
    \ tags=ruby dscore=0 |>\n<| c |>\nThis is great! but what if I want to check how\
    \ many rotations it is?\n<|/ c |>\n<| c |>\nIf you count the number of rotations\
    \ it is as simple as iterating through both strings simultaneously and incrementing\
    \ a counter in each pass. You could also do this in a single iteration by comparing\
    \ `i` with `j` each time the comparison is made.\n<|/ c |>\n<| a dscore=0 |>\n\
    Here is my Ruby solution\n<code>", "  \n  # your code\n  \nend\n    ", "    return\
    \ a.include?(b) || b.include?(a) || a.include?(b.rotate!) || b.include?(a.rotate!)\n\
    end", "    \n    # Write your code here\n    a.split(\"\")\n    b.split(\"\")\n\
    \    if a.size == 0 and b.size > 0\n        return false\n    if a.size == 0 or\
    \ b.size == 0\n        return true\n    return a.last(b.size - 1).include? b.last(a.size\
    \ - 1)\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI really liked this problem\
    \ that you have mentioned in the comments. I guess I have found the optimal solution\
    \ for your problem and it is a little bit complicated. Please find my solution\
    \ below. \n<code>", "  a.split(\"\").each_with_index do |word, index|\n    a.split(\"\
    \").each_with_index do |word1, index1|\n      next if index == index1\n      word1\
    \ == word or return false if (word1.length >= word.length) and word1.rotate(index).include?\
    \ word\n    end\n  end\n  true\nend", "  a.each_char {|c|\n    return false unless\
    \ b.include?(c)\n  }\n  true\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\n<code>",
  "  return a.split(//).sort.map(&:join).index(b.split(//).sort.map(&:join).join)\
    \ == -1\nend", "    a.each_char do |char1|\n        b.each_char do |char2|\n \
    \           if char1 == char2\n                true\n            else\n      \
    \          if char1 + \"#\" + char2 == b\n                    true\n         \
    \       end\n            end\n        end\n    end\n    false\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThank you for you help and for teaching me about each_char!\n\
    <|/ c |>\n<| c |>\nIt doesn't work. It works for the first word, but not the second\
    \ one. For example cycpattern_check(\"psus\",\"psus\") => True but cycpattern_check(\"\
    psus\",\"saus\") => False. I don't know why.\n<|/ c |>\n<| c |>\nBecause you aren't\
    \ comparing all chars in second word with all chars in first word. That's why\
    \ it returns `true` in your case since you have `psus#psus`. I've updated my answer\
    \ with the fix\n<|/ c |>\n<| c |>\nThank you so much for the help! I didn't think\
    \ of doing it like that.\n<|/ c |>\n<| c |>\n`each_char` also has a `join` method\
    \ you can use to avoid building strings: `a.each_char.all? { |char1| b.each_char.all?\
    \ { |char2| char1 == char2 } } or a.each_char.include? b.join`\n<|/ c |>\n<| a\
    \ tags=ruby dscore=1 |>\nThe reason your code doesn't work is because you're only\
    \ comparing each character in one string with each character in the other string,\
    \ but not comparing the entire string with each character. For example, let's\
    \ take the first word \"psus\". We'll take that as a base string and compare it\
    \ to \"psus#psus\". Notice that only the second 'p' of \"psus#psus\" matches the\
    \ first 'p' of \"psus\". So \"psus#psus\" matches only a single character in the\
    \ first word.\nThe same thing happens with the second word \"saus\". The base\
    \ string matches \"s#u\", but not \"s#a\". And \"s#a\" matches a single character\
    \ in the second word.\nIn order to fix this, you can take all the characters in\
    \ one string and compare them all to the other string by running each character\
    \ in each string through a loop. The following code does that:\n<code>", "  a.downcase!\n\
    \  b.downcase!\n  return true if a =~ /^(a|b)+$/ and b =~ /^(a|b)+$/ and a.size\
    \ != b.size or a.include?(b) or b.include?(a)\n  return false\nend", "  words\
    \ = a.split(\"\")\n  words_rotated = b.split(\"\")\n  words_rotated.each do |word|\n\
    \    word = word.downcase\n    words.each do |word|\n      return false if word\
    \ == word or word == word.rotation(words) or word == word.rotation(words.reverse)\n\
    \    end\n  end\n  return true\nend", "    return (a.split('').grep(/#{b}/).any?\
    \ || b.split('').grep(/#{a}/).any?)\nend\n</code>\n<|/ a dscore=1 tags=algorithm,ruby\
    \ |>\n<| a tags=algorithm,ruby |>\nI think this would be a more ruby-esque way\
    \ to do it, which is a combination of grep, any?, and slice:\n<code>", "  return\
    \ a.gsub(b, '') =~ /[#{b.upcase}]+/\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=regex,ruby,string\
    \ dscore=0 |>\nAnother possible solution:\n<code>", "  return (b !~ /#{a}|\\(#{a}\\\
    )*|\\[#{a}\\]|\\{#{a}\\}|\\<#{a}\\>|\\~#{a}\\|/) && b !~ /#{a}$/\nend", "  return\
    \ false if a.length == 0 or b.length == 0 or a.length == b.length \n  first =\
    \ a[0...a.length-1]\n  second = b[0...b.length-1]\n  first.length == 0 ?\n   \
    \ true :\n    cycpattern_check(first,second)\nend", "  (a.length >= b.length)\
    \ && return true \n  (a.length < b.length) && return false\n  a.each_char do |char|\
    \ \n    b.each_char do |char_| \n      char_ == char && return true \n      char_\
    \ == char.downcase && return true \n      char_ == char.upcase && return true\
    \ \n      char_ == char.upcase.downcase && return true\n    end\n  end\n  a.length\
    \ >= b.length && return true \n  a.length < b.length && return false \nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis does it for me. Thanks!\n<|/ c |>\n<| a tags=string,ruby\
    \ |>\n<code>", "  a.gsub!(/[^a-z]+/,'')\n  b.gsub!(/[^a-z]+/,'')\n  a.downcase!\n\
    \  b.downcase!\n  i = 0\n  while i <= (a.length-1) and i <= b.length\n    if a[i]\
    \ == b[i]\n      i += 1\n    else\n      break\n    end\n  end\n  return i ==\
    \ (a.length-1)\nend", "  if a.include?(b)\n    return true\n  elsif a.gsub(b,\"\
    \").empty?\n    return true\n  else\n    return false\n  end\nend", "  first \
    \ = a.chars.to_a\n  second = b.chars.to_a\n  first_size = a.size\n  second_size\
    \ = b.size", "    return a.gsub!(/[^a-z]/i, '')\nend", "  a.each_char.with_index\
    \ do |char, idx|\n    if b.include?(char) == false\n      return false\n    end\n\
    \    idx = idx + 1\n  end\n  true\nend", "  first = a.split(\"\")\n  second =\
    \ b.split(\"\")\n  results = []\n  results.push(true)\n  results.push(b in first)\n\
    \  for i in 0..(second.length - 1)\n    index = first.length - 1\n    found =\
    \ false\n    while index > -1 && !found\n      if first[index] == second[i]\n\
    \        results.push(true)\n        found = true\n        break\n      index\
    \ -= 1\n    end\n  end\n  results.each {|b| return b}\nend\n</cell>\n<cell>\n\
    a = \"hello\"\nb = \"ell\"\ncycpattern_check(a,b)\n</cell>\n<cell>\na = \"hello\"\
    \nb = \"ell\"\ncycpattern_check(a,b)\n</cell>\n<cell>\na = \"hello\"\nb = \"ell\"\
    \ncycpattern_check(a,b)\n</cell>\n<cell>\na = \"whassup\"\nb = \"psus\"\ncycpattern_check(a,b)\n\
    </cell>\n<cell>\na = \"whassup\"\nb = \"psus\"\ncycpattern_check(a,b)\n</cell>\n\
    <cell>\na = \"whassup\"\nb = \"psus\"\ncycpattern_check(a,b)\n</cell>\n<cell>\n\
    a = \"abab\"\nb = \"baa\"\ncycpattern_check(a,b)\n</cell>\n<cell>\na = \"efef\"\
    \nb = \"eeff\"\ncycpattern_check(a,b)\n</cell>\n<cell>\na = \"himenss\"\nb = \"\
    simen\"\ncycpattern_check(a,b)\n</cell>\n<cell>\na = \"himenss\"\nb = \"simen\"\
    \ncycpattern_check(a,b)\n</cell>\n<cell>\na = \"himenss\"\nb = \"simen\"\ncycpattern_check(a,b)\n\
    </cell>\n<cell>\na = \"himenss\"\nb = \"simen\"\ncycpattern_check(a,b)\n</cell>\n\
    <cell>\na = \"himenss\"\nb = \"simen\"\ncycpattern_check(a,b)\n</cell>\n<text>\n\
    Conway's Game of Life\nConway's game of life is a simple rule-based game in which\
    \ cells grow and shrink depending on their surroundings. An example of what a\
    \ game of life looks like can be seen below:", "  first = a.split(\"\")\n  second\
    \ = b.split(\"\")", "    word1 = a.split(\"\")\n    word2 = b.split(\"\")\n  \
    \  ans = \"false\"", "  begin = 0\n  b = b.split(\"\").reverse.join\n  a.each_char\
    \ do |char|\n    begin = a.index(b, char) if begin != nil\n    return true if\
    \ begin != nil && begin < a.size\n  end\n  false\nend\n</code>\n<|/ a tags=ruby,regex,string\
    \ |>\n<| c |>\n`a.each_char.with_index.none? { |c,i| b.index(c) }` or `a.each_char.with_index.any?\
    \ { |c,i| b.index(c) }` (as `index` returns `nil` if no match found)\n<|/ c |>\n\
    <| c |>\nI didn't realize `index` returns `nil` if no match found.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\n def cycpattern_check(a, b)\n    return false if a.nil?\
    \ or b.nil?\n    (0..(a.length+b.length)).each do |i|\n      break if i >= (a.length+b.length)\n\
    \      return false unless a.slice!(i..a).include?(b.slice!(0..i.to_s.length))\n\
    \    end\n    return true\n  end\n</code>\n<|/ a tags=ruby,regex,string |>\n<|\
    \ c |>\nIf you just want to check whether one string contains another, you can\
    \ do `b.include?(a)`.\n<|/ c |>\n<| a dscore=0 tags=ruby,regex,string |>\n<code>",
  "  return b.include?(a) || b.split(0).all? { |i| a.include?(i) }\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>", "  a = a.downcase\n  b = b.downcase\n  \n\
    \  a.each_byte do |c|\n    if b.include? c\n      return true\n    end\n  end\n\
    \  \n  a.each_byte do |c|\n    b.each_byte do |r|\n      if c == r\n        return\
    \ true\n      end\n    end\n  end\n  \n  return false\nend", "\ta = a.chars\n\t\
    b = b.chars\n\ta.each_with_index do |c,i|\n\t\tb.each_with_index do |d,j|\n\t\t\
    \tif j != i && a[i].upcase == b[j].upcase\n\t\t\t\treturn true\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn false\nend", "    return b.start_with? a.slice(1, b.length)\
    \ || b.end_with? a.slice(0, b.length)\nend", "  return a.split(\"\").any? { |x|\
    \ b.include? x } || b.split(\"\").any? { |x| a.include? x }\nend\n</code>\n<|/\
    \ a tags=ruby,arrays |>\n<| c |>\n`!a.include?(x)` could be `!b.include?(x)`\n\
    <|/ c |>\n<| c |>\nAlso, `include?` will do a `Regexp` match.\n<|/ c |>\n<| c\
    \ |>\n`include?` will do a `Regexp` match if given a regex argument, not a String.\
    \ Also, `include?` will do a `Regexp` match if the argument contains regex metacharacters.\
    \ Since `!a.include?(x)` already ensures no regex metacharacters are involved,\
    \ `b.include?(x)` does nothing but invoke `include?` on a `Regexp` object (also\
    \ `b.include?(x)` is equivalent to `b.match?(x)`).\n<|/ c |>\n<| c |>\n, yes,\
    \ I see that now, thank you.\n<|/ c |>\n<| a |>\n<code>", "  a = a.downcase\n\
    \  b = b.downcase\n  c = a.gsub(b, \"\")\n  c.length ? a.length >= b.length ?\
    \ c == a : c == b : false\nend", "  a_size = a.size\n  b_size = b.size\n  if a_size\
    \ != b_size\n    return false\n  if b_size > a_size * 2\n    return false\n  \n\
    \  a_hash = a.dup\n  b_hash = b.dup\n  \n  a.slice!(0..(a_size - b_size * 2))\n\
    \  b.slice!(0..(b_size - a_size * 2))\n  \n  for i in (0..a_size - 1)\n    if\
    \ a_hash[i] == b_hash[(i + b_size)]\n      a_hash[i] += 1\n      b_hash[(i + b_size)]\
    \ -= 1\n      break\n    end\n  end\n  \n  b_hash.each_key do |i|\n    return\
    \ false if a_hash[i] != b_hash[i]\n  end\n  \n  return true\nend", "    a_chars\
    \ = a.split(\"\")\n    b_chars = b.split(\"\")\n    return a.count(a[0]) > b.count(b[0])\
    \ and a_chars.sort.product(b_chars.sort).all? do |e| \n    a.count(e) > b.count(e)\n\
    \    end\nend\n</code>\n<|/ a |>\n<| a tags=ruby,string |>\n<code>", "  a.downcase!\n\
    \  b.downcase!\n  a = a.split.to_a\n  b = b.split.to_a\n  return a.include?(b[0])\
    \ or a.include?(b[1]) or b.include?(a[0]) or b.include?(a[1]) or a.include?(b[0])\
    \ or a.include?(b[1]) or b.include?(a[0]) or b.include?(a[1])\nend\n</cell>\n\
    <cell>", "  b.size() > a.size ? false : a.include?(b) ? true : cycpattern_check(b,\
    \ a[0...b.size])\nend", "  return a.downcase.end_with?(b.downcase) || a.downcase.start_with?(b.downcase)\
    \ || b.downcase.end_with?(a.downcase) || b.downcase.start_with?(a.downcase)\n\
    end\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\nI like your answer but I can't\
    \ use your answer. I will need to use regex to solve this problem.\n<|/ c |>\n\
    <| c |>\n: Do you mean that your answer has to use a regular expression? If so,\
    \ I don't understand how that would help the OP.\n<|/ c |>\n<| c |>\nNo, it is\
    \ impossible to solve this problem with regex. You can use regex to solve this\
    \ problem. I don't know how regex is able to solve this problem, but I can't use\
    \ regex to solve this problem.\n<|/ c |>\n<| a tags=ruby,regex |>\n<code>", " \
    \ return a.include? b || b.include? a\nend", "    l = a.length\n    ans = false\n\
    \    b.split('').each do |x|\n        ans = true if l&1 == a.count(x)\n    end\n\
    \    return ans\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThe performance\
    \ of splitting and looping over the same string again and again is going to be\
    \ very slow. Not sure how this code will perform on a longer string\n<|/ c |>\n\
    <| c |>\nI made a small benchmark of your function against other similar functions:\
    \ http://pastebin.com/sQqYKj9r\n<|/ c |>\n<| c |>\nI suppose you mean `ans = ans\
    \ || l&1 == a.count(x)`? That would be an efficient implementation, though.\n\
    <|/ c |>\n<| c |>\n, thanks, this one is faster. http://pastebin.com/4BXkBwBK\
    \ However, it returns true for strings that aren't subsequences of other strings.\n\
    <|/ c |>\n<| c |>\nYeah, that's a fair point. Perhaps I should revise my answer\
    \ to return true for subsequences and to return false for nonsubsequences. I'll\
    \ see if I can come up with something more performant and edit this answer accordingly.\
    \ Thanks!\n<|/ c |>\n<| a dscore=2 |>\nHere is a solution without loops using\
    \ a Ruby regex (as you tagged ruby):\n<code>", "  a.include?(b) || b.include?(a)\n\
    end", "\ta = a.downcase\n\tb = b.downcase\n\ta.scan(/./) { |c| break if c != b\
    \ }\nend", "  x = a.downcase\n  y = b.downcase\n  y.each_char do |c|\n    return\
    \ true if x.include? c\n  end\n  return false\nend\n</code>\n<|/ a |>\n<| c |>\n\
    I love your `each_char`\n<|/ c |>\n<| c |>\nI wrote that on my phone so I couldn't\
    \ remember how it works. I was getting frustrated with it for too long :D\n<|/\
    \ c |>\n<| a tags=ruby,algorithm,string,substring |>\nIn Ruby 1.8.7 you could\
    \ use scan:\n<code>\n'teststring'.scan(/test/)\n</code>\nThis will return an array\
    \ of matches found, in this case ['t','e','s','t','s','i','n'].  If you only want\
    \ the first match you can do:\n<code>\n'teststring'.scan(/test/).first\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nthis solution requires Ruby 1.8.7 which was not available\
    \ when I wrote my answer.  1.8.7 is out now though.  Thanks for the upvote.\n\
    <|/ c |>\n<| c |>\n`'teststring'.scan(/test/).first` would be better; `'teststring'.scan(/test/)[0]`\
    \ would give a MatchData object which can be expensive.\n<|/ c |>\n<| a dscore=4\
    \ |>\n<code>", "  (a.length != b.length) && (a <=> b) > (0 <=> 0)\nend", "  if\
    \ a.include? b || b.include? a\n    return true\n  end\n  a.scan(/(?=\\w*b)(?=\\\
    w*a)/).any? {|x| b.include? x }\nend", "    first = [a[0,1]]\n    last = [a[-1,-1]]\n\
    \    for i in 1..a.size\n        first = [first[1..-1], a[i]]\n        last =\
    \ [last[1..-1], a[i]]\n    end\n    for i in 1..a.size\n        if first[i..-1].include?(b[i])\
    \ or last[i..-1].include?(b[i])\n            return false\n        end\n    end\n\
    \    return true\nend\n</code>\n<|/ a tags=string,ruby,pattern-matching |>\n<|\
    \ a dscore=0 tags=string,ruby,pattern-matching |>\n<code>", "    a.split('').each\
    \ do |x|\n        return true if b.include?(x)\n    end\n    return false\nend\n\
    </code>\n<|/ a |>\n<| a dscore=0 tags=ruby,algorithm,string |>\nThe easiest way\
    \ to solve this is by looking at the string's last character, and then seeing\
    \ if the character in the string matches the string's last character. \nSo if\
    \ you were to do\n<code>", "  return a.include?(b) || b.include?(a)\nend", " \
    \ a[0..a.length-2].each_byte do |byte|\n    b.each_byte do |byte2|\n      return\
    \ false if byte != byte2 && byte != byte2\n    end\n  end\n  return true\nend",
  "  a = a.reverse\n  b = b.reverse\n  (b != nil ? b.each {|w| return false if a.include?\
    \ w }: true)\nend", "    a.each_char do |c|\n        if b.include? c\n       \
    \     return true\n        else\n            return false\n        end\n    end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis looks really good but why not `return true`\
    \ instead of `true && break`?\n<|/ c |>\n<| c |>\nYes, it is exactly the same\
    \ but I wanted to keep it simple.\n<|/ c |>\n<| c |>\nYou can just `return true`\
    \ instead of `return true && break` in this particular case, but why not keep\
    \ the simpler code?\n<|/ c |>\n<| c |>\nI see. Why would you choose a more complicated\
    \ solution over simple one?\n<|/ c |>\n<| c |>\nIn general I'd agree with you.\
    \ However, the first sentence of my answer was about a problem in OP's code, not\
    \ the code's correctness. Also, I'd not choose this solution over any other, because\
    \ I'd always prefer the more simple code.\n<|/ c |>\n<| a tags=ruby,string dscore=1\
    \ |>\nOne way is to compare every character in the second string with every character\
    \ in the first string and count the matches. If the count is equal to the length\
    \ of the first string then they match and you return true. \n<code>", "  b.split('').sort.each\
    \ do |char|\n    a.split('').sort.each do |char2|\n      return false if char2.to_i\
    \ == char.to_i # we already compared this one\n      break if char == char2\n\
    \    end\n    return false # we've already checked this one\n  end\n  true\nend",
  "  \n  case a.length >= 2 and b.length >= 2 \n  when true\n    if a.length < b.length\n\
    \      false\n    elsif a.length == b.length\n      if a.include?(b[0]) || a.include?(b[1])\
    \ || b.include?(a[0]) || b.include?(a[1])\n        true\n      else\n        false\n\
    \      end\n    elsif a.length == b.length + 1\n      if a.include?(b[0]) || a.include?(b[1])\n\
    \        true\n      else\n        false\n      end\n    end\n    when false\n\
    \      false\n  end\nend", "  a.downcase!\n  b.downcase!\n  first = a.split\n\
    \  second = b.split\n  first = first.join(first,first.length-1,0)\n  second =\
    \ second.join(second,second.length-1,0)\n  first = first.chars.to_a\n  second\
    \ = second.chars.to_a\n  return true if first.join(second,first.size,second.size).downcase\
    \ == a.downcase\n  false\nend", "  a.replace 'a'\n  b.replace 'a'\n  a.size >=\
    \ b.size ? a.chars.all? {|c| b.include?(c)} == true : b.chars.all? {|c| a.include?(c)}\
    \ == false\nend", "  l = a.split(\"\")\n  l.rotate(b.split(\"\").size)\n  return\
    \ a.include?(b.gsub(/[#{l*}]+/, \"\")) ? true : false\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThe question was about the [cyclomatic complexity](https://en.m.wikipedia.org/wiki/Cyclomatic_complexity),\
    \ not about performance. Your solution computes more elements than necessary to\
    \ achieve the desired result. Moreover, your solution only works for strings that\
    \ contain multiple characters (so \"abc\" will not pass the test).\n<|/ c |>\n\
    <| c |>\nYes, thanks for your comment. I misread the question and thought the\
    \ length of the second string was constant.\n<|/ c |>\n<| c |>\nThis solution\
    \ is O(N) in the number of characters, not O(N^2) in the number of elements. Since\
    \ we're looking for a substring in a constant number of elements, it's O(N) in\
    \ the number of characters, O(N^2) in the number of elements.\n<|/ c |>\n<| c\
    \ |>\nThank you for your suggestion. \nThe solution you gave can not detect if\
    \ the first string is a substring of the second string with more than 1 character.\
    \ I had updated my code to reflect my comment. I will accept your answer if there\
    \ are no better solutions. I appreciate your answer.\n<|/ c |>\n<| c |>\nThank\
    \ you for the clarification. My solution is indeed O(N) in the number of characters.\n\
    <|/ c |>\n<| a dscore=1 |>\nFor each letter of the second string, you have to\
    \ iterate over the first string character-by-character. For each character, the\
    \ check you have to perform is whether the substring can be found at the current\
    \ position in the first string. Hence the complexity is O(N) in the number of\
    \ characters, since you have to loop through the first string character-by-character.\n\
    The code below implements this idea. It checks if the first string is a substring\
    \ of the second string, and if so returns true if and only if the first string\
    \ starts with the substring from the second string and ends with the substring\
    \ from the first string. This complexity is O(N*M) in the number of characters,\
    \ where N is the length of the first string, and M is the length of the substring\
    \ from the second string.\n<code>", "  (a.length < b.length) ? false : (b.chars.uniq.sort\
    \ == a.chars.uniq.sort) ? a.chars.uniq.sort == b.chars.uniq.sort : a.chars.uniq.sort.include?(b.chars.uniq.sort.first)\n\
    end", "  if a.length < 3 || b.length < 3 || b.length > a.length\n    false\n \
    \ elsif a.size == 0\n    true\n  elsif b.size == 0\n    true\n  elsif b.size <\
    \ a.size || b.size > a.size\n    false\n  else\n    a.each_char.with_index do\
    \ |char, i|\n      if b.include?(char) || cycpattern_check(b, char + b[i..-1]\
    \ + char)\n        true\n      else\n        false\n      end\n    end\n  end\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby |>\n<code>", "    a.downcase!\n    b.downcase!\n\
    \    i = 0\n    while i < a.length && i < b.length\n        pattern = a[i..i+1]\n\
    \        if b.include? pattern\n            return true\n        i += pattern[0].size\n\
    \    end\n    return false\nend", "  a_size = a.size\n  b_size = b.size\n  \n\
    \  if b_size > a_size \n    puts b_size.to_s + \" too big\"\n    exit\n  else\
    \ \n    if b_size < a_size \n      puts b_size.to_s + \" too small\"\n      exit\n\
    \    else\n      a_pattern.each {|x| a_str[x] && a_str[x] !~ b}\n    end\n  end\n\
    \  \n  a_size = 0\n  b_size = 0\n  a_str = Array.new\n  b_str = Array.new\n  \n\
    \  a.split('').each {|x| a_str[x] = x}\n  b.split('').each {|x| b_str[x] = x}\n\
    \  \n  a_str.each {|x| b_str[x] && a_str[x] !~ b_str[x]}\n  return true\nend",
  "  (substr_check(split(a), split(b)))\nend", "  \n  a = a.split(\"\").sort\n  b\
    \ = b.split(\"\").sort\n  \n  a.each_with_index do |a,i|\n    \n    found = b.each_with_index\
    \ do |b,j|\n      \n      if a[i] == a[j] and j > i\n        \n        if j ==\
    \ b.length - 1\n          \n          found = true\n          break\n        \
    \  \n        elsif j + 1 == b.length\n          \n          found = true\n   \
    \       break\n          \n        else\n          \n          if a[j + 1] !=\
    \ b[j]\n            \n            found = true\n            break\n          end\n\
    \        end\n      end\n    end\n    \n    return true if found\n  end\n  \n\
    \  return false\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`split` already returns\
    \ the same array that was passed, so there is no need to use `sort_by`.\n<|/ c\
    \ |>\n<| c |>\nI see, that makes more sense. I removed it. But now I'm getting\
    \ an \"undefined method `split' for nil:NilClass\" error.\n<|/ c |>\n<| c |>\n\
    Looks like the argument is not being passed. Did you change the name of the argument?\n\
    <|/ c |>\n<| c |>\nThanks. I fixed that but it still doesn't work.\n<|/ c |>\n\
    <| c |>\nCan you provide a [mcve] including the argument and expected output?\n\
    <|/ c |>\n<| a dscore=0 |>\nHere is a Ruby solution. As pointed out, you shouldn't\
    \ need to sort the input strings in any way. \n<code>", "  a.gsub!(/./, \"\")\n\
    \  b.gsub!(/./, \"\")\n  a.length == b.length ? true : false \nend\n</code>\n\
    <|/ a tags=ruby,string,algorithm,string-comparison |>\n<| c |>\nThank you. This\
    \ helped. I had missed out to return false when the length of both string is not\
    \ equal.\n<|/ c |>\n<| a |>\n<code>", "  a = \"a\" * (a.length-1) + \"a\".downcase\n\
    \  b.downcase!\n  b.each_char.with_index do |x,i|\n    a.each_char.with_index\
    \ do |y,j|\n      break if j == 0 && (x == a[j+1])\n      break if i+1 == y.length\
    \ && x == y[0]\n      break if i+1 == y.length && x == y[-1]\n      break if i+1\
    \ != y.length && x == y[i+1..-1]\n      break if i+1 != y.length && x == y[i+1..-1]\n\
    \      break if i+1 != y.length && x == y[i+1..-1] && y.include?(x)\n      break\
    \ if i+1 != y.length && x == y[i+1..-1] && y.include?(x) && y.include?(a[i+1])\n\
    \      break if i+1 != y.length && x == y[i+1..-1] && y.include?(x) && y.include?(a[i+1])\
    \ && y.include?(a[j-1])\n      break if i+1 != y.length && x == y[i+1..-1] &&\
    \ y.include?(x) && y.include?(a[i+1]) && y.include?(a[j-1]) && y.include?(a[i-1])\n\
    \    end\n  end\nend", "    a.split(\"\").each_with_index do |word, index|\n \
    \       b.split(\"\").each_with_index do |word2, index2|\n            return true\
    \ if word == word2\n        end\n    end\nend", "  a.chars.sort.each do |ch|\n\
    \    b.chars.sort.each do |ch2|\n      ch = ch.upcase\n      ch2 = ch2.upcase\n\
    \      break if (ch2 == ch and a.length <= b.length) or (ch == ch2 and a.length\
    \ > b.length) or (ch == ch2 and b.length > a.length)\n    end\n  end\n  true\n\
    end", "  a1 = a.chars\n  b1 = b.chars\n  a1.each_with_index do |x,i|\n    b1.each_with_index\
    \ do |y,j|\n      if a[i].eql?(y) and i<j\n        a1.delete_at(i) if i<j\n  \
    \    end\n    end\n  end\n  a1.size == b.size\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis is actually the most efficient solution I've found so far, just\
    \ two problems: 1. It doesn't work for any letter combination with more than 2\
    \ characters 2. It fails the test on the two examples I gave.\n<|/ c |>\n<| c\
    \ |>\nI added a better solution. Let me know if it works!\n<|/ c |>\n<| c |>\n\
    Still not working! Still failing test cases. I'm wondering if it isn't an issue\
    \ with my specific test case. I'm running Ruby 2.1.1 on Mac OS X 10.9.2.\n<|/\
    \ c |>\n<| c |>\nI figured it out! It was an issue with my test case. For some\
    \ reason Ruby 1.8.7 would give me an incorrect result for cycpattern_check(\"\
    ab\",\"ab\"). Turns out Ruby 1.8.7 does not implement the `delete` method on strings.\
    \ I updated the code above to fix this issue and added a test for your updated\
    \ question.\n<|/ c |>\n<| c |>\nThanks! That test case works for me after adding\
    \ the delete. Thanks so much for taking the time to help! I'm surprised Ruby 1.8\
    \ is the only language that doesn't implement delete though.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\nHere is another solution:\n<code>", "  a.downcase!\n  b.downcase!\n  a =\
    \ a.upcase unless a.empty?\n  b = b.upcase unless b.empty?\n  a.size <= b.size\
    \ ? false : a.include?(b) || b.include?(a)\nend\n</code>\n<|/ a tags=ruby,string\
    \ dscore=0 |>\n<| c |>\nThis approach is far from optimal. Consider `cycpattern_check(\"\
    abba\", \"aab\")`, which would return `false`. It would be better to return `false`\
    \ earlier, after having found out that one of the patterns doesn't exist in the\
    \ other one. As it is, you will have to find out whether every single pattern\
    \ is contained in the other, which is a much longer task.\n<|/ c |>\n<| c |>\n\
    The OP asked for optimization. This code should be the solution for any type of\
    \ strings. It is far from optimal for large strings. And there are many many more\
    \ checks to do that cannot be done in one single line - e.g. the complexity of\
    \ the `include?` method. Also, this code will not work for strings that aren't\
    \ a substring of `b` - e.g. `\"abba\"`, `\"ab\"`, `\"a\"`.\n<|/ c |>\n<| c |>\n\
    The question was \"how to improve this code\". My comment was \"this code is far\
    \ from optimal\".\n<|/ c |>\n<| c |>\nAren't you trying to optimize this code?\
    \ Your optimization should be done in the original code itself rather than adding\
    \ extra lines. You can optimize the original code using other methods. Please\
    \ read the question carefully, before making any decisions.\n<|/ c |>\n<| c |>\n\
    Yes, but it is my intention to make the code as easy to understand as possible,\
    \ therefore I added the original code. The original code was also much shorter.\
    \ The original code also has more checks, so I thought the original code would\
    \ be easier to read and easier to understand.\n<|/ c |>\n<| a dscore=0 tags=ruby,string\
    \ |>\nThis is a great opportunity to use Ruby's excellent array methods.\n<code>",
  "  return a.include?(b) ||  a.gsub(b,'').include?(a) || a.gsub(b,'').gsub(a,'').include?(b)\
    \ || a.gsub(b,'').gsub(a,'').gsub(b,'').gsub(a,'').include?(b) || a.gsub(b,'').gsub(a,'').gsub(b,'').gsub(a,'').gsub(b,'').gsub(a,'')\n\
    end", "  return a.include?(b) || b.include?(a) || a.include?(b) && b.include?(a)\n\
    end", "  b = b.split('').reverse\n  a.split('').each { |x| b.each { |y| return\
    \ false if x == y } } \n  return true\nend", '  return false unless a[0...a.length]
    == b', "  a.gsub(/[a-ey-z]+/, \"\").split(\"\").sort.join.split(b).sort.join ==\
    \ a\nend", "  a.split(\"\").each_with_index do |char, index|\n    if (b[index..-1]\
    \ == char) || (b[-index..-1] == char)\n      return true\n    end\n  end\n  false\n\
    end", "  word1 = a.split.join(\"\").downcase\n  word2 = b.split.join(\"\").downcase\n\
    \  result = 0\n  if word1.start_with?(word2)\n    result += 1\n  else\n    result\
    \ += (word1.count(\"a\").to_i + word1.count(\"b\").to_i + word1.count(\"c\").to_i\
    \ + word1.count(\"d\").to_i)\n    word1.upcase.gsub(/[abc](?![abc])/, '').gsub(/[abd](?![abd])/,\
    \ '').gsub(/[edf](?![edf])/, '').gsub(/[efg](?![efg])/, '').gsub(/[fg](?![fg])/,\
    \ '').gsub(/[gh](?![gh])/, '').gsub(/[hij](?![hij])/, '').gsub(/[ijk](?![ijk])/,\
    \ '').gsub(/[klm](?![klm])/, '').gsub(/[mn](?![mn])/, '').gsub(/[opq](?![opq])/,\
    \ '').gsub(/[pqr](?![pqr])/, '').gsub(/[rst](?![rst])/, '').gsub(/[stu](?![stu])/,\
    \ '').gsub(/[trv](?![trv])/, '').gsub(/[uvw](?![uvw])/, '').gsub(/[wxy](?![wxy])/,\
    \ '').gsub(/[z](?![z])/, '').gsub(/(?!a|b|c|d)/, '').count(\"#{word2}\".downcase)\n\
    \    result += (word1.count(\"a\").to_i + word1.count(\"b\").to_i + word1.count(\"\
    c\").to_i + word1.count(\"d\").to_i + word1.count(\"#{word2}\".downcase))\n  end\n\
    \  result -= 1\n  if result >= 0\n    return true\n  else\n    return false\n\
    \  end\nend\n</cell>\n<code language=julia-1.4>", "  a.upcase!\n  b.upcase!\n\
    \  (a.length >= b.length) && (a.length > 0) && return false\n  (0..a.length-1)\
    \ == (b[0..length]) && return true\n  (0..length-1) == (a[0..length]) && return\
    \ true\n  (0..length-1) == (b[0..length]) && a.downcase == b.downcase && return\
    \ true\n  (a[0..length-1] == a[0..length-2]) && (b[0..length-1] == b[0..length-2])\
    \ && return true\n  (a[0..length-1] == b[0..length-2]) && (b[0..length-1] == a[0..length-2])\
    \ && return true\n  (a[0..length-1] == b[0..length-2]) && a[0..length-1] == b[0..length-2]\
    \ && return true\n  (a[0..length-1] == a[0..length-2]) && (b[0..length-1] == a[0..length-2])\
    \ && return true\n  (a[0..length-1] == a[0..length-2]) && (b[0..length-1] == b[0..length-2])\
    \ && a[0..length-1] == b[0..length-2] && return true\n  a.each_char.sort.each\
    \ do |c|\n    break if b[c] == a[0]\n    break if b[c] != a[0] && !(b[c-1] ==\
    \ a[0] && b[c+1] == a[0] && b[c+2] == a[0])\n    break if b[c] == a[0] && b[c-1]\
    \ == a[0] && b[c+1] == a[0] && b[c+2] == a[0]\n  end\n  return false\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=ruby,string dscore=0 |>\nI was trying to solve this\
    \ problem on Hackerrank and got the same error that 'undefined method downcase'\
    \ for nil:NilClass.\nI added the following method which converts the input string\
    \ to lowercase before running the main code:\n<code>", "\tb.length > a.length\
    \ or b.length < 1\n\ta.each_char { |c| b[c] && a.chars.include? b[c] }\nend",
  "    a.split(\"\").each{|x| a.insert(0,x) }\n    b.split(\"\").each{|x| b.insert(0,x)\
    \ }\n    a.length<=b.length ? false : a.each_index.any? {|i| a[i].eql?(b[i])}\n\
    end", "  c = 0\n  while (c+len(b)+1 > a.length) or (c+1 > a.length)\n    c +=\
    \ 1\n  end\n  (c+1).times { a << b[c..].to_s }\n  return a.include?(b) # or a.include?(b[..c])\
    \ # or a.include?(b[..c.to_i])\nend", "  a, b = a.split, b\n  a.length + b.length\
    \ <= 1 ? true : a.each_index do |i|\n    b.each_index do |j|\n      b[j] == a[i..j]\
    \ ? true : false if i == j\n    end\n  end\nend\n</code>\nThis works for the following\
    \ cases:\n<code>\ncycpattern_check(\"abc\", \"abc\")", "  a = a.split('')\n  b\
    \ = b.split('')\n  a.each do |x|\n    b.each do |y|\n      y.downcase!\n     \
    \ y.reverse!\n      break if a == b\n      if x[0...-1] == y\n        return true\n\
    \      end\n    end\n  end\n  return false\nend\n</code>\n<|/ a tags=ruby,arrays,string\
    \ dscore=2 |>\n<| a tags=ruby,arrays,string dscore=2 |>\n<code>", "  return (b\
    \ !~ /^#{a}/ && b !~ /^#{a}[^#{a}]*#{a}$/) rescue false\nend\n</code>\n<|/ a |>\n\
    <| c |>\nWhat about `cycpattern_check(\"abd\",\"baa\")` ?\n<|/ c |>\n<| c |>\n\
    It's not a substring in the first word (at least in my answer). You have `abd`\
    \ and `baa` as two words.\n<|/ c |>\n<| c |>\nThank you so much for your help.\
    \ This is an amazing solution. I am now trying to understand your code. I understand\
    \ it but I don't understand how it works. Would you mind explaining it to me?\n\
    <|/ c |>\n<| c |>\nI see your edit. Thanks! Now I don't understand how `cycpattern_check(\"\
    abd\",\"baa\")` returns true. Could you explain it to me?\n<|/ c |>\n<| c |>\n\
    You're right, I had a typo in there. Fixed now. The `[^#{a}]*` is just matching\
    \ the last char, and `#{a}` is matching the first char. Looking at the regex,\
    \ `[^#{a}]*` means \"match any char other than `#{a}`\". So, since `a` has more\
    \ than one char, the `[^#{a}]*` will match more than a char.\n<|/ c |>\n<| a tags=ruby,string\
    \ dscore=0 |>\n<code>", "  \n  a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 = a.split(//)\n\
    \  b1, b2, b3, b4, b5, b6, b7, b8, b9, b10 = b.split(//)\n  \n  if(b[b.length-1]\
    \ == b[0])\n    return true\n    \n  a11, a12, a13, a14, a15, a16, a17, a18, a19,\
    \ a20 = a10.split(//)\n  b11, b12, b13, b14, b15, b16, b17, b18, b19, b20 = b10.split(//)\n\
    \  \n  return a1[a1.length-1] == a1[a1.length-2]\nend", "  a.gsub!(/[^aeiou]/,\
    \ '') #remove everything other than vowel\n  b.gsub!(/[^aeiou]/, '') #remove everything\
    \ other than vowel\n  \n  b.gsub!(/[aeiou]/, \"#\") #replace every vowel with\
    \ '#'\n  b.gsub!(/#/, \"\") #remove every '#'\n  \n  a = \"#{a}#\"\n  b = \"#{b}#\"\
    \n  \n  if a.include?(b) == true\n    return true\n  elsif b.include?(a) == true\n\
    \    return true\n  else\n    return false\n  end\nend", "  case a\n    when b\n\
    \      true\n    else\n      false\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nThis doesn't work if you pass it something other than a 2-word string.\
    \ It also doesn't work if the word you pass is shorter than the one you're looking\
    \ for.\n<|/ c |>\n<| c |>\nI didn't think about it that way.  I edited the code\
    \ so it should work now.  Thanks!\n<|/ c |>\n<| c |>\nI still think this doesn't\
    \ work. The OP needs to find out if any of its rotations are in the first word.\
    \ Your code will return false if you pass in 'foo' or 'bar' for the second word,\
    \ but if the first word is 'foobar' then it returns true.\n<|/ c |>\n<| c |>\n\
    Now it works. I added another test case.  It's not foolproof but at least it passes\
    \ all the tests.\n<|/ c |>\n<| c |>\nThis still isn't correct. Try passing \"\
    hey\" and \"heyho\".\n<|/ c |>\n<| a tags=ruby |>\nThe question was to write a\
    \ method that will return a true or false based on if a word is a substring of\
    \ a given word, so if you pass it \"Hello\" and \"Hey\" it will return true because\
    \ the word \"Hey\" is in \"Hello\", but false because \"Hello\" is not in \"Hey\"\
    .  \nSo I decided to try and break this problem down a bit so I knew how to write\
    \ it in ruby.  I started with figuring out how to return the true or false of\
    \ the word I was looking for appearing in the word I was looking for.  This was\
    \ done using the includes method.  Then I got lost so I realized that if the word\
    \ I was looking for did not contain the word I was looking for then it would return\
    \ false.  So I wrote the method below.  It uses recursion to go through each character\
    \ in the word you are looking for, then looks if it appears in the current character\
    \ in the word you are looking for.  I added a new case statement to handle strings\
    \ that do not contain the given word.\n<code>", "  a.downcase!\n  b.downcase!\n\
    \  a_size = a.size\n  b_size = b.size\n  a_len = (a.length==a_size) ? a_size :\
    \ a_size + 1\n  b_len = (b.length==b_size) ? b_size : b_size + 1\n  a_map = Array.new(a_size)\n\
    \  b_map = Array.new(b_size)\n  for i in 0..a_len\n    a_map[i] = false\n  end\n\
    \  for i in 0..b_len\n    b_map[i] = false\n  end\n  a_map.each do |x|\n    a_map[x]\
    \ |= b.include?(x)\n  end\n  b_map.each do |x|\n    b_map[x] |= a.include?(x)\n\
    \  end\n  b_map.each_with_index do |v,x|\n    return true if v\n  end\n  return\
    \ false\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,ruby,string,substring,ruby-on-rails\
    \ |>\n<code>", "  \n  a = a\n  b = b\n  a_chars = a.split(\"\")\n  b_chars = b.split(\"\
    \")\n  \n  return b_chars.any?{|c| a_chars.include?(c) }\nend\nputs cycpattern_check(\"\
    abcd\",\"abd\") # => false\nputs cycpattern_check(\"hello\",\"ell\") # => true\n\
    puts cycpattern_check(\"whassup\",\"psus\") # => false\nputs cycpattern_check(\"\
    abab\",\"baa\") # => true\nputs cycpattern_check(\"efef\",\"eeff\") # => false\n\
    puts cycpattern_check(\"himenss\",\"simen\") # => true\n</code>\n<|/ a |>\n<|\
    \ c |>\nIt looks like you're testing whether the string includes all of the letters\
    \ of the second string; this doesn't quite match OP's example output in the question.\n\
    <|/ c |>\n<| a dscore=0 |>\nTry this:\n<code>", "    a.split(\"\").sort.reverse.each\
    \ do |x|\n        if b.include? x\n            return true\n        end\n    end\n\
    \    return false\nend", "  a = a.split(\"\")\n  b = b.split(\"\")\n  a.each_index\
    \ do |i|\n    if b[i] != a[i]\n      return false\n    end\n  end\n  return true\n\
    end", "\ta = a.split('')\n\tb = b.split('')\n\tif a.length != b.length\n\t\treturn\
    \ false\n\tfor i in 1..a.length\n\t\tif a[a.length-i] == b[b.length-i] && cycsubst(a,\
    \ b.length-i) == true\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend\n\
    puts cycpattern_check(\"abcd\",\"abd\") #=> false\nputs cycpattern_check(\"hello\"\
    ,\"ell\") #=> true\nputs cycpattern_check(\"whassup\",\"psus\") #=> false\nputs\
    \ cycpattern_check(\"abab\",\"baa\") #=> true\nputs cycpattern_check(\"efef\"\
    ,\"eeff\") #=> false\nputs cycpattern_check(\"himenss\",\"simen\") #=> true",
  "\tstr1a = a.split(\"\")\n\tstr1b = b.split(\"\")\n\t\n\tstr2a = a.split(\"\").reverse\n\
    \tstr2b = b.split(\"\").reverse", "  a.split('').each do |x|\n    b.split('').each\
    \ do |y|\n      \n      return true if b.include? x || b.include?(x + y) || b.include?(x\
    \ - y) || b.include?(x - y + x)\n    end\n  end\n  \n  return false\nend", " \
    \ a = a.downcase\n  b = b.downcase\n  a.sub!(b, \"\\0\") # Replace the pattern\
    \ with the null\n  c = a.length\n  a.sub!(b, \"\\0\")\n  d = a.length\n  a ==\
    \ b if d == c # Make sure the new string is the same length\nend", "  a = \"#{a}\"\
    .downcase\n  b = \"#{b}\".downcase\n  word = a\n  if b.length == 0\n    return\
    \ true\n  elsif b.length == 1\n    if word =~ /#{b}/\n      return true\n    end\n\
    \    return false\n  elsif a.length == 1\n    if word =~ /#{b}/\n      return\
    \ true\n    end\n    return false\n  end\n  a = \"#{a}#{b}\".split(//).reverse\n\
    \  word = a.last\n  a.pop\n  b.pop\n  a.reverse!\n  b.reverse!\n  until a.length\
    \ == 0\n    a.reverse!\n    b.reverse!\n    if word =~ /#{a.join}$/\n      return\
    \ true\n    end\n    a.reverse!\n    b.reverse!\n  end\n  return false\nend",
  "  # initialize two variables, one for checking the first word and another for checking\
    \ the second word\n  first_w = []\n  second_w = []", "  return true if a.gsub(b,\
    \ '').length == 0\n  a.split(\"\").each_with_index do |x, i|\n    return true\
    \ if a.gsub(b, x) == x\n    i -= 1\n    break true if i >= 0\n  end\n  return\
    \ false\nend", "  return a[0..(a.length - 1)] == b or a[(a.length - 1..0)].chars.all?\
    \ {|c| b.include?(c.downcase)}\nend", "  a.each_char.each do |c|\n    b.each_char.each\
    \ do |d|\n      if c == d\n        true\n      else\n        return false\n  \
    \    end\n    end\n  end\n  return true\nend", "  a.each_char { |c|\n    b = b.split(\"\
    \").reverse\n    b.each_char { |d|\n      return true if c == d\n    }\n  }\n\
    \  return false\nend", "    return true if (a[0..(a.length-1)] == b) || a.include?(b)\
    \ else\n    cycpattern_check(a[1..-1], b)\nend", "  a.each_char do |x|\n    b.each_char\
    \ do |y|\n      return true if x == y\n    end\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a tags=ruby |>\nUsing gsub and a regular expression:\n<code>", "  return\
    \ b.gsub(/[b-z]/i, \"\") == a.gsub(/[b-z]/i, \"\")\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| a |>\n<code>", "  a = a.downcase\n  b = b.downcase\n  return b.split.any?\
    \ {|w| a.include?(w) || a.include?(w.rotate)} if b.include?(a)\n  false\nend\n\
    </code>\n<|/ a |>\n<| c |>\nYour solution will fail when comparing \"himenss\"\
    \ with \"simen\" for example, which will return false, but you cannot compare\
    \ them with a regex for that exact reason you gave.\n<|/ c |>\n<| c |>\nI don't\
    \ see how that can happen with my code.  I only test substrings, not full words,\
    \ as per OP example where \"himenss\" would be true.  However, I guess I'm misunderstanding\
    \ what OP was trying to do with full words.  Maybe the OP should clarify what\
    \ they meant.  I'll edit my answer if OP clarifies things.\n<|/ c |>\n<| c |>\n\
    Your code will pass in that case, but the result of the code is a regexp which\
    \ is different from the expected result. Your regex would return true when comparing\
    \ \"himenss\" with \"simen\". As you can see from my code, I'm matching against\
    \ the exact string \"simen\" and not the substring  \"simen\". Your code returns\
    \ false when comparing \"himenss\" with \"simen\".\n<|/ c |>\n<| c |>\nOh, I see\
    \ what you mean.  I believe my code is more robust now.\n<|/ c |>\n<| c |>\nI'm\
    \ having a lot of trouble understanding your code.  I'm new to ruby, and I'm having\
    \ a hard time seeing how your code is working.  It seems like a lot of the code\
    \ in your example has to do with the variable declarations, etc.  Would you be\
    \ able to walk through this code to understand it better?\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere's a solution I came up with for Ruby 1.9.3:\n<code>", "  a.slice!(b)\n\
    \  return !a.empty?\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,string dscore=1\
    \ |>\nHere is my solution:\n<code>", "    first = true\n    second = nil\n   \
    \ len1 = a.length\n    len2 = b.length", "  (1..a.length).include?(a.index(b))\
    \ ? (\n      b == a[-a.index(b)]\n    ) : (\n      a.split(\"\").any? { |e| e.include?(b)\
    \ }\n    )\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nCan you please explain this\
    \ code please? what happens before the 'do', what happens after the do, and what\
    \ does your regex do exactly?\n<|/ c |>\n<| a |>\n<code>", "  a = a.downcase.gsub(/[^a-z]/,\"\
    \")\n  b = b.downcase.gsub(/[^a-z]/,\"\")\n  a.chars.all?{ |c| b.include?(c) }\n\
    end", "  a.gsub(/[^a-z]/,'').downcase!\n  b.gsub(/[^a-z]/,'').downcase!\n  return\
    \ a.include?(b)\nend\n</code>\n<|/ a tags=ruby,pattern-matching,algorithm,string\
    \ |>\n<| a tags=ruby,pattern-matching,algorithm,string |>\n<code>", "    # Write\
    \ your code here\n    first = a.chars.to_a\n    second = b.chars.to_a\n    first\
    \ = first.rotate(-1).drop(first.size - 1).reverse\n    second = second.rotate(-1).drop(second.size\
    \ - 1).reverse\n    first = first.zip(second).map { |x,y| x.or(y) }\n    \n  \
    \  true = a.chars.to_a.index(b) >= 0\n    true = true or (a.chars.to_a.index(b.chars.to_a[0])\
    \ >= 0) and first.any?{|x| a.chars.to_a.index(x) >= 0 }\n    true = true or (a.chars.to_a.index(b.chars.to_a[-1])\
    \ >= 0) and first.any?{|x| a.chars.to_a.index(x) >= 0 }\n    true\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThe complexity is still `O(n^2)`. The `O(log(n))`\
    \ is `a.chars.to_a.index(b.chars.to_a[0]) >= 0`.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\nHere is another solution:\n<code>", "  return a.include? b or a.include?\
    \ b.downcase\nend", "    a.chars.each_with_index do |char, index|\n        if\
    \ b.include?(char)\n            return false if index == 0\n            return\
    \ true if index == a.length - 1\n            return true if a[index + 1] == b[-1]\n\
    \            return true if a[index + 2] == b[-2]\n        end\n    end\n    true\n\
    end", "  a.gsub(/[^a-zA-Z0-9_]/,'').downcase == b.gsub(/[^a-zA-Z0-9_]/,'').downcase\n\
    end", "    a, b = a.split(\"\"), b.split(\"\")\n    return a.all? && b.any? &&\
    \ b.all? do |x|\n        a.include?(x) && b.include?(x) && b.include?(x) && a.include?(b[b.length-1])\n\
    \    end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like how you put that in\
    \ a single line of code. Also I like the way you break it down into steps. It\
    \ just seems so obvious now that you've done it, but I can't believe I didn't\
    \ think of it.\n<|/ c |>\n<| c |>\nHaving two separate `include?`s inside the\
    \ `all?` clause seems like a bad idea. The first `include?` will have to check\
    \ every element in `a` (`a.length == b.length`) for each element in `b`. Each\
    \ such check will take time proportional to the size of one of the arrays. In\
    \ fact, the first `include?` will have to perform `a.length * b.length` operations.\
    \ `all?` will only have to perform `a.length` checks. I'd recommend using `each_cons(2).any?`\
    \ over `all?` here.\n<|/ c |>\n<| c |>\nAs a small aside, I'd recommend using\
    \ `include?` over `all?` because it's more concise. I find `all?` to be more readable,\
    \ since you won't have to figure out how that method works. I'd recommend using\
    \ `all?` here, because it's less code, and because it might be faster, because\
    \ it's written with concise semantics.\n<|/ c |>\n<| c |>\nThanks for the input.\
    \ I have never seen `each_cons`.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nI think\
    \ I've come up with a very simple and fast solution. I'm sure there are much more\
    \ elegant ways to write this code, but this one works pretty quick for me.\n<code>",
  "  a = a.split('')\n  b = b.split('')\n  count = 0\n  a.each do |e|\n    count +=\
    \ 1 if b.include?(e)\n    count += 1\n  end\n  return count == 0 unless count\
    \ < a.length\n  return false\nend", "  a = a.split(\"\")\n  b = b.split(\"\")\n\
    \  c.length = 0\n  d.length = 0\n  puts a\n  puts b\n  a.reject! { |e| b.include?(e)\
    \ }\n  puts a\n  puts b\n  \n  a.each do |element|\n    puts c\n    puts d\n \
    \   puts \"----------------------\"\n    puts element + element\n    puts element\
    \ + element + element\n    puts element + element + element + element\n    puts\
    \ element + element + element + element + element\n    puts \"----------------------\"\
    \n    puts \"-----\"\n    if c[c.length] == element and d.include?(element)\n\
    \      true\n    else\n      false\n    end\n    puts \"-----\"\n  end\nend",
  "  a.slice!(b)\n  a.each_char.any? do |i|\n    b.each_char.any? do |j|\n      i\
    \ == j ? true : i == b.slice!(i..-1).first ? true : false\n    end\n  end\nend",
  "\ta = a.downcase\n\tb = b.downcase\n\tif a.length < b.length\n\t\tb.reverse &&\
    \ a.chars.to_a.reverse.any? { |x| b.include?(x) }\n\telse\n\t\ta.chars.to_a.any?\
    \ { |x| b.include?(x) }\n\tend\nend", "  a.split(\"\").each_with_index do |e,\
    \ i|\n    b.split(\"\").each_with_index do |f, j|\n      if b[j]==e\n        return\
    \ true\n      elsif i+1<b.length and b.slice!(0,i+1)\n        return true\n  \
    \    end\n    end\n  end\n  return false\nend\n</code>\nThe above code is very\
    \ similar to the one I posted earlier where I compared the word lengths. This\
    \ one instead checks the substring in a single loop.\nThe code above is also very\
    \ similar to the code I posted earlier. But the code above is very efficient and\
    \ does not create a new array of the same size as b.\n<|/ a |>\n<| c |>\nThis\
    \ code is not correct. It returns true if the strings are equal. It should be\
    \ `a.split(\"\").each_with_index.all? { |e,i| b.split(\"\").each_with_index.all?\
    \ { |f,j| e == f } }` (and similarly for the other answers).\n<|/ c |>\n<| c |>\n\
    I didn't realize they had to ignore the letters in the other positions in the\
    \ string. Thanks for noticing. I fixed my answer\n<|/ c |>\n<| c |>\nThis isn't\
    \ working for me - it returns true for `cycpattern_check(\"abcd\",\"abd\") =>\
    \ true`\n<|/ c |>\n<| c |>\nI forgot the `i` in the first parameter. Now it works\n\
    <|/ c |>\n<| a |>\nIn Ruby, a regular expression is the way to go:\n<code>", " \
    \ a.downcase!\n  b.downcase!\n  a[0..a.length-1].split(\"\").each do |w|\n   \
    \ return true if b.include?(w)\n  end\n  return false\nend", "  a.each_char.sort.join.to_s\
    \ == b.each_char.sort.join.to_s\nend", "    l = a.length\n    r = b.length\n \
    \   for i in 0...l-r+1\n        if a.include?(b[i..i+r]) == true\n           \
    \ return true\n        end\n    end\n    return false\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby |>\nThis is what I have so far\n<code>", "  if a.length == 0 or\
    \ b.length == 0\n    return false\n  else\n    a.split(\"\").each { |x|\n    \
    \  b.split(\"\").each { |y|\n        if x == y\n          true\n        else\n\
    \          false\n        end\n      }\n    }\n  end\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby,recursion |>\n<| c |>\nThis code doesn't work: it returns `[]` when\
    \ `a` is empty and `b.length == a.length` when `b` is empty and `b.length != a.length`\
    \ when `b` is not empty and `b` is a substring of every `a`. So `cycpattern_check(\"\
    \", \"\")` returns `[]`, which is not correct.\n<|/ c |>\n<| c |>\nYou are right,\
    \ I missed a part. I have fixed it. You are still able to call it this way if\
    \ you want.\n<|/ c |>\n<| a dscore=0 |>\nHere's another take which I believe is\
    \ simpler.\n<code>", "    \n    return a.include?(b)\nend\n        \n</cell>\n\
    <cell>", "  a = a.downcase\n  b = b.downcase\n  return true if a.index(b) == false\
    \ and b.index(a) == false and a.include?(b)\nend", "    first = a.downcase.gsub(/[^a-z]/,'')\n\
    \    second = b.downcase.gsub(/[^a-z]/,'')\n    first = first.split('')\n    second\
    \ = second.split('')\n    i = 0\n    j = 0\n    ans = 0\n    while i < first.length\
    \ and j < second.length\n        if first[i] == second[j]\n            ans +=\
    \ 1\n        i += 1\n        j += 1\n    return ans == second.length if ans >\
    \ 0 \n    return false # a or b is not a substring\nend", "  a1 = a\n  while a1[-1]\
    \ != \"z\"\n    a1 = a1 + \"z\"\n  end\n  b = b\n  while b[-1] != \"z\"\n    b\
    \ = b + \"z\"\n  end\n  a1 = a1.to_s.downcase\n  b = b.to_s.downcase\n  a1.split('').sort.each\
    \ { |c| return false if b.include?(c)}\n  return true\nend", "  return a.chars.uniq.sort.each_cons(2).any?\
    \ { |x, y| b[0, x.size] == y }\nend\n</cell>\n<cell>", "  return true if a.include?\
    \ b || b.include? a\n  false\nend", "  (a != b) || (a === b)\nend", "  b.gsub!(\"\
    [^\" + a + \"]\", \"\")\n  a.gsub!(\"[^\" + b + \"]\", \"\")\n  if b.length ==\
    \ 0 or a.length == 0\n    return False\n  end\n  c0 = a.slice(0, b.length)\n \
    \ c1 = b.slice(a.slice(0, b.length))\n  if c0 =~ /^#{b}$/\n    if c1 =~ /^#{a}$/\n\
    \      return true\n    end\n  end\n  if c1 =~ /^#{a}$/\n    if c0 =~ /^#{b}$/\n\
    \      return true\n    end\n  end\n  return false\nend", "  a_size = a.size\n\
    \  b_size = b.size\n  return b_size > a_size if b_size > a_size && a_size > b_size\
    \ || (b_size == a_size && a_size == 1) || b.size > a_size else false\nend\n</code>\n\
    <|/ a tags=string,ruby |>\n<| a |>\n<code>", "    ab = a.downcase\n    ba = b.downcase\n\
    \    return ab.include?(ba) || ba % 2 == 0 && ab.include?(ba.to_s[1..-1]) || ab.include?(ba.to_s[0..-2])\n\
    end", "  (a.length >= b.length) && a.downcase.scan(b.downcase).any?\nend", " \
    \ a, b = b.downcase, a.downcase\n  return a.include? b || b.include? a\nend",
  "  a.gsub!(/[^a-z]/i,\"\")\n  b.gsub!(/[^a-z]/i,\"\")\n  \n  if a.size != b.size\n\
    \    return false\n  else\n    l = a.size\n    for i in 0..l-1\n      if a[i]\
    \ != b[i]\n        return false\n      end\n    end\n    \n    return true\n \
    \ end\nend", "  # Write your code here\n  a.downcase!\n  b.downcase!\n  if a.length\
    \ == 0 or b.length == 0\n    return false\n  end\n  i = 0\n  j = 0\n  while i\
    \ < a.length\n    while j < b.length\n      return a.chars.include?(b[j]) or cycpattern_check(b[j],\
    \ a[i+1])\n      j += 1\n    end\n    i += 1\n    j = 0\n  end\nend", "  a.downcase!\n\
    \  b.downcase!\n  b.chars.each do |c|\n    unless a.include? c\n      false\n\
    \    end\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
