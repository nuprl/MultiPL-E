name: HumanEval_91_is_bored
language: rb
prompt: "# You'll be given a string of words, and your task is to count the number\n\
  # of boredoms. A boredom is a sentence that starts with the word \"I\".\n# Sentences\
  \ are delimited by '.', '?' or '!'.\n# For example:\n# >>> is_bored(\"Hello world\"\
  )\n# 0\n# >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\"\
  )\n# 1\ndef is_bored(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_bored\n\
  \    candidate = method(:is_bored)\n    assert_equal(0, candidate.call(\"Hello world\"\
  ))\n    assert_equal(0, candidate.call(\"Is the sky blue?\"))\n    assert_equal(1,\
  \ candidate.call(\"I love It !\"))\n    assert_equal(0, candidate.call(\"bIt\"))\n\
  \    assert_equal(2, candidate.call(\"I feel good today. I will be productive. will\
  \ kill It\"))\n    assert_equal(0, candidate.call(\"You and I are going for a walk\"\
  ))\n  end\nend\n"
completions: ["    bored_chars = [\".\", \"?\", \"!\"]\n    i = 0\n    count = 0\n\
    \    while i < s.length\n        if s[i] !~ bored_chars\n            count +=\
    \ 1\n        i += 1\n    return count\nend\n</cell>\n<code language=julia-0.5>\n\
    is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n</cell>\n\
    <code language=julia-0.5>", "  bored_count = 0\n  s.split(\" \").each do |word|\n\
    \    if (word == \"I\") || (word == \"i\")\n      bored_count += 1\n    end\n\
    \  end\n  return bored_count\nend\n</cell>\n<text>\nTest Your Work", "  count=0\n\
    \  for i in s\n    if i==\"I\" and s[i-1]!=\"!\"\n      count=count+1\n    end\n\
    \  end\n  count\nend\nprint is_bored(\"Hello world\")\nprint is_bored(\"The sky\
    \ is blue. The sun is shining. I love this weather\")\nprint is_bored(\"The sky\
    \ is blue. love this weather\")\nprint is_bored(\"The sky is blue. love.\")\n\
    print is_bored(\"The sky is blue. love this weather\")", "\ts.gsub!(/[\\.\\?\\\
    !]/,'')\n\ts.downcase!\n\ts.split(\" \").each do |word|\n\t\tword.downcase!\n\t\
    \tword.count('I') == 0\n\tend\nend", "    count = 0\n    for word in s.split\n\
    \        if word.first == \"I\"\n            count += 1\n    return count\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\n`s.split.select {|word| word[0] ==\
    \ 'I'}.size` will get you the same thing, though it's much less code. `word[0]`\
    \ is more readable than `word.first`.\n<|/ c |>\n<| a |>\n<code>", "  (0..length(s).downto(0))\
    \ do |i|\n    if s[i] == \".\" || s[i] == \"?\" || s[i] == \"!\"\n      return\
    \ false\n    end\n  end\n  return true\nend", "  s.split('.').each do |part|\n\
    \    if part == \"I\".split(//).first\n      0\n    end\n  end\n  1\nend", " \
    \ if s.include? \"I \"\n    1\n  else\n    0\n  end\nend\n</cell>\n<text>\nLet's\
    \ try it on some of your sentences.", "  s = s + \".\"\n  s.gsub!(/[.?!]/, \"\
    \ \") # collapse spaces\n  s.gsub!(/([^\\s]+\\s?)$/, '\\1') # get rid of trailing\
    \ word\n  s.scan(/I ([^\\s]+)/)\nend", "    count=0\n    array=s.split(\".\")\n\
    \    for i in array\n        if i[0]==\"I\"\n            count+=1\n    return\
    \ count\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is wrong. The OP wants the\
    \ number of sentences that start with \"I\". Your code counts the number of *words*\
    \ that start with \"I\".\n<|/ c |>\n<| c |>\nI agree with, this code doesn't count\
    \ sentences that start with \"I\" as the OP wants. OP needs a function to count\
    \ the number of sentences that start with \"I\"\n<|/ c |>\n<| c |>\nthank you\
    \ for the clarification, I have edited the answer.\n<|/ c |>\n<| c |>\nThe OP\
    \ wants to count the sentences that start with the word \"I\", not the number\
    \ of words that start with the word \"I\". Your code will count the number of\
    \ sentences that start with the word \"I\", not the number of sentences that start\
    \ with the word \"I\". For example, `is_bored(\"Hello. The sky is blue. I am I.\"\
    )` will return 1, when it should be 0.\n<|/ c |>\n<| a tags=ruby |>\nThis is a\
    \ problem that could be solved using the Ruby Range and Enumerable modules. First\
    \ we turn the string into an array of words. Then we iterate through each word\
    \ and look for any word that starts with \"I\". Using Enumerable's select method\
    \ we can get an array of the words that match the criteria. From that we can count\
    \ the array using Ruby's length method.\n<code>", "  s.scan(/\\b(I\\b)/)\nend",
  "  return s.split /([.?!])/\nend", "  s.count(\"i\") >= 3\nend", "  s = string.strip(s)\n\
    \  if s.index(\"I\") < 0 or s.index(\".\")< 0 or s.index(\"!\")< 0\n    return\
    \ 0\n  else\n    return 1\nend", "    bored_words = []\n    count_bored_words\
    \ = 0\n    \n    # YOUR CODE HERE\n    \n    # YOUR CODE HERE\n    \n    # YOUR\
    \ CODE HERE\n    return count_bored_words", "  s.each_char.detect {|c| c == ?I?\
    \ }.nil?\nend\n  </code></pre>", "    bored = 0\n    \n    s.split(\" \").each\
    \ do |word|\n        if(word == \"I\")\n            bored += 1\n        end\n\
    \    end\n    return bored\nend\n</cell>\n<code language=julia-1.0>\nis_bored(\"\
    Hello world\")\n</cell>\n<code language=julia-1.0>\nis_bored(\"The sky is blue.\
    \ The sun is shining. I love this weather\")\n</cell>\n<code language=julia-1.0>\n\
    is_bored(\"Is that all? It sure is not. Is that all? It sure is not\")\n</cell>\n\
    <code language=julia-1.0>\nis_bored(\"The sky is blue. The sun is shining. I love\
    \ this weather. Is it raining now? Is it snowing?\")\n</cell>\n<code language=julia-1.0>\n\
    is_bored(\"Is that all? It sure is not. Is that all? It sure is not\")\n</cell>\n\
    <code language=julia-1.0>\nis_bored(\"Is that all? It sure is not. Is that all?\
    \ It sure is not\")\n</cell>\n<code language=julia-1.0>\nis_bored(\"Is that all?\
    \ It sure is not. Is that all? It sure is not\")\n</cell>\n<code language=julia-1.0>\n\
    is_bored(\"Is that all? It sure is not. Is that all? It sure is not\")\n</cell>\n\
    <code language=julia-1.0>\nis_bored(\"Is that all? It sure is not. Is that all?\
    \ It sure is not\")\n</cell>\n<code language=julia-1.0>\nis_bored(\"Is that all?\
    \ It sure is not. Is that all? It sure is not\")\n</cell>\n<code language=julia-1.0>\n\
    is_bored(\"Is that all? It sure is not. Is that all? It sure is not\")\n</cell>\n\
    <code language=julia-1.0>\nis_bored(\"Is that all? It sure is not. Is that all?\
    \ It sure is not\")\n</cell>\n<code language=julia-1.0>\nis_bored(\"Is that all?\
    \ It sure is not. Is that all? It sure is not\")\n</cell>\n<code language=julia-1.0>\n\
    is_bored(\"Is that all? It sure is not. Is that all? It sure is not\")\n</cell>\n\
    <code language=julia-1.0>\nis_bored(\"Is that all? It sure is not. Is that ",
  "  count = s.scan(/\\A(?:I|i)\\.\\.\\./)\n  return count[1].length >= 1\nend", "\t\
    count = 0\n\twords = s.split(' ')\n\twords.each do |word|\n\t\tif word.downcase\
    \ == \"i\"\n\t\t\tcount += 1\n\t\tend\n\tend\n\treturn count\nend", "    s = s.lower()\n\
    \    bored = 0\n    for i in range(len(s)):\n        if s[i] in 'ie!?' and s[i-1]\
    \ not in 'ie!?':\n            bored += 1\n    return bored\n</cell>\n<cell>",
  "  boredom_count = 0\n  boredom_words = boredom_str.split(//)\n  s.split(//)\n \
    \ for w in boredom_words\n    return w == \"I\" == true\n    boredom_count\nend\n\
    </cell>\n<code language=julia-1.6>", "    # Initialize the number of boredoms\
    \ to 0.\n    boredoms = 0\n    \n    # Initialize a variable `i` to 0.\n    for\
    \ i in range(0, s.length)\n    \n        # Print \"i\" as we count through the\
    \ words in the string.\n        print i\n    \n        # If the word at the current\
    \ value of i is the letter \"I\",\n        # print 0 to the screen.\n        if\
    \ s[i] == 'I'\n            boredoms = 0\n        \n        # If the word at the\
    \ current value of i is not the letter \"I\",\n        # print 1 to the screen.\n\
    \        else\n            boredoms = 1\n    end\n    \n    # Return the number\
    \ of boredoms.\n    return boredoms\nend", "    count = 0\n    s_arr = s.split('.')\n\
    \    for i in s_arr\n      if i.start_with?('I')\n        count += 1\n    end\n\
    \    count\n  end\nend\n</code>\n<|/ a dscore=0 tags=ruby,regex |>\n<| c |>\n\
    Your code fails for `is_bored(\"The sky is blue. The sun is shining. I love this\
    \ weather. Shhhh! I love my job and I hate it!\")`.\n<|/ c |>\n<| c |>\nGood catch.\
    \ Thanks.\n<|/ c |>\n<| c |>\nI've updated my answer to take into account that\
    \ some boredom sentences may have multiple sentences between them.\n<|/ c |>\n\
    <| a dscore=0 |>\nIf it has to be a regex then this seems to be the only way:\n\
    <code>", "  s.gsub!(/^(I)/, 'I')\n  s.gsub!(/\\.|!|?/i, '.')\n  s.count('.')\n\
    end", "  s.gsub!(/(\\.|\\?|\\!)$/, \"\")\n  s.split(\".\").inject(0) {|sum, word|\
    \ sum+1 if word[0]==\"I\"}\nend", "  s.split(\" \").each do |word|\n    word =\
    \ word.strip\n    if word =~ /^I.*$/\n      return 0\n    end\n  end\n  return\
    \ 1\nend\n</code>\nAnd that's pretty much all there is to it!\n<|/ a |>\n<| a\
    \ dscore=0 tags=ruby,ruby-on-rails,algorithm |>\nI recommend you to use Ruby 1.9.3\
    \ features for that task:\n<code>\nstr = \"The sky is blue. The sun is shining.\
    \ I love this weather.\"\nstr_split = str.split(\" \") # => [\"The\", \"sky\"\
    , \"is\", \"blue\", \".\", \"The\", \"sun\", \"is\", \"shining\", \"I\", \"love\"\
    , \"this\", \"weather\"]\nstr_split.each_with_index {|word, i| return i if word\
    \ !~ /^I/ } # => [4, 7]\n</code>\nOr more compact way using Enumerator:\n<code>\n\
    str.split.each_with_index.find {|word, i| !word.match(/^I/) } # => 4\n</code>\n\
    <|/ a |>\n<| c |>\n`each_with_index` returns an enumerator, so `find` would return\
    \ the first index. Also, this isn't Ruby 1.9 compatible.\n<|/ c |>\n<| c |>\n\
    `each_with_index` returns an enumerator, not an array. It returns `[word, i]`\
    \ where `i` is the current index of the array.\n<|/ c |>\n<| c |>\nYes, but `find`\
    \ returns an enumerator, which returns the first element of `Enumerator` (in our\
    \ case `[word,i]`). So there is no need to wrap it in another `Array` constructor.\
    \ Also Ruby 1.9 doesn't support `!~` operator as `!=` does.\n<|/ c |>\n<| c |>\n\
    `each_with_index` returns an enumerator, so `find` would return the first index.\
    \ Also, this isn't Ruby 1.9 compatible.\n<|/ c |>\n<| c |>\nIn Ruby 1.9.3 it returns\
    \ `i` as an integer. Though I agree that it could be cleaned up a bit.\n<|/ c\
    \ |>\n<| a tags=ruby,ruby-on-rails,algorithm dscore=0 |>\nThis is what I came\
    \ up with:\n<code>", "  s.split(\" \").any?{|word| word.start_with?(\"I\")}\n\
    end", "    boredom = false\n    bored = 0\n    word_count = Hash.new(0)\n    sentences\
    \ = s.split('. ')\n    for sentence in sentences\n        bored = bored + 1\n\
    \        words = sentence.split('? ')\n        for word in words\n           \
    \ word_count[word.downcase] += 1\n    end\n    return bored\nend", "  boredom_words\
    \ = [\"I\"]\n  return s.split(/\\./).map{|w| boredom_words.include?(w) ? 1 : 0}.reduce(:+)\n\
    end", "  s = downcase(s)\n  bored = false\n  s.scan(/\\b(i|I)(\\b)?/)\n  bored\
    \ = ($1 == \"i\") && ($2 || $2)\n  s.scan(/\\b(i|I)(\\b)?\\.(\\b)?/)\n  bored\
    \ = ($1 == \"i\") && ($2 || $2) && $3\n  s.scan(/\\b(i|I)(\\b)?\\.(\\b)?\\?(\\\
    b)?/)\n  bored = ($1 == \"i\") && ($2 || $2) && $3\n  s.scan(/\\b(i|I)(\\b)?\\\
    .(\\b)?\\!(\\b)?/)\n  bored = ($1 == \"i\") && ($2 || $2) && $3\n  s.scan(/\\\
    b(i|I)(\\b)?\\.(\\b)?\\.(\\b)?/)\n  bored = ($1 == \"i\") && ($2 || $2) && $3\n\
    \  s.scan(/\\b(i|I)(\\b)?\\.(\\b)?\\.\\?(\\b)?/)\n  bored = ($1 == \"i\") && ($2\
    \ || $2) && $3\n  s.scan(/\\b(i|I)(\\b)?\\.(\\b)?\\.\\!(\\b)?/)\n  bored = ($1\
    \ == \"i\") && ($2 || $2) && $3\n  s.scan(/\\b(i|I)(\\b)?\\.\\?(\\b)?/)\n  bored\
    \ = ($1 == \"i\") && ($2 || $2)\n  s.scan(/\\b(i|I)(\\b)?\\.\\!(\\b)?/)\n  bored\
    \ = ($1 == \"i\") && ($2 || $2)\n  s.scan(/\\b(i|I)(\\b)?\\.\\.(\\b)?/)\n  bored\
    \ = ($1 == \"i\") && ($2 || $2)\n  s.scan(/\\b(i|I)(\\b)?\\.\\.\\?(\\b)?/)\n \
    \ bored = ($1 == \"i\") && ($2 || $2)\n  s.scan(/\\b(i|I)(\\b)?\\.\\.\\!(\\b)?/)\n\
    \  bored = ($1 == \"i\") && ($2 || $2)\n  s.scan(/\\b(i|I)(\\b)?\\.\\.\\.(\\b)?/)\n\
    \  bored = ($1 == \"i\") && ($2 || $2)\n  s.scan(/\\b(i|I)(\\b)?\\.\\.\\.\\?(\\\
    b)?/)\n  ", "    boredoms = s.split(\".?!\")\n    boredoms.each do |b|\n     \
    \   if b.start_with?(\"I\")\n            count(\"bored\")\n        end\n    end\n\
    end", "  count = 0\n  s.scan(/^I[a-z]*/i)\n  count = (s.scan(/^[!.]$/i).length\
    \ >= 1 ? 1 : 0)\n  s.scan(/\\b[a-z][.?!]*\\b/)\n  count = (s.scan(/\\b[!.]$/i).length\
    \ >= 1 ? 1 : 0)\n  count = (s.scan(/\\.|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n\
    \  count = (s.scan(/\\.|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n  count = (s.scan(/\\\
    .|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n  count = (s.scan(/\\.|\\b[a-z]?\\b/).length\
    \ >= 1 ? 1 : 0)\n  count = (s.scan(/\\.|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n\
    \  count = (s.scan(/\\.|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n  count = (s.scan(/\\\
    .|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n  count = (s.scan(/\\.|\\b[a-z]?\\b/).length\
    \ >= 1 ? 1 : 0)\n  count = (s.scan(/\\.|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n\
    \  count = (s.scan(/\\.|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n  count = (s.scan(/\\\
    .|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n  count = (s.scan(/\\.|\\b[a-z]?\\b/).length\
    \ >= 1 ? 1 : 0)\n  count = (s.scan(/\\.|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n\
    \  count = (s.scan(/\\.|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n  count = (s.scan(/\\\
    .|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n  count = (s.scan(/\\.|\\b[a-z]?\\b/).length\
    \ >= 1 ? 1 : 0)\n  count = (s.scan(/\\.|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n\
    \  count = (s.scan(/\\.|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n  count = (s.scan(/\\\
    .|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n  count = (s.scan(/\\.|\\b[a-z]?\\b/).length\
    \ >= 1 ? 1 : 0)\n  count = (s.scan(/\\.|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n\
    \  count = (s.scan(/\\.|\\b[a-z]?\\b/).length >= 1 ? 1 : 0)\n  count", "  s.chars.each\
    \ do |char|\n    next if char == ?!\n    return 0 if char == ?I\n    return 1\
    \ if char == ?.\n    break\n  end\n  0\nend\n</code>\nYou can test it using the\
    \ following code:\n<code>\ns = STDIN.readline.chomp", "  counter = 0\n  boredoms\
    \ = \"\"\n  for word in s.split(\" \")\n    if word == \"I\" or word == \"You\"\
    \n      counter += 1\n    end\n  end\n  return counter\nend\n</cell>\n<text>\n\
    Run the cell below to check your work.", "  s.downcase!\n  bored_words = s.split(\"\
    \ \").select{|w| w =~ /^i/}\n  bored_words.count{|word| word == \"i\"}\nend",
  "    bored = false\n    i = 0\n    while i < s.length\n        if s[i] == '?' or\
    \ s[i] == '!' or s[i] == '.'\n            bored = true\n        end\n        i\
    \ = i + 1\n    end\n    return bored\nend", "    boredoms = s.split\n    boredoms.each\
    \ {|s| return 1 if s.include?(\"I\") }\n    0\nend\n</code>\nNote that in both\
    \ cases, we used return 1 instead of true or false because that's what the problem\
    \ requires:", "  s.split(/\\W+/).find {|x| x.start_with? \"I\" } == 0\nend", " \
    \ s.count('I') == 1 && s.count('.') == 1 && s.count('?') == 1 && s.count('!')\
    \ == 1\nend", "    s = s.downcase\n    bored_count = 0\n    bored_string = \"\"\
    \n    bored_array = s.split(\" \".freeze)\n    bored_array = bored_array.select\
    \ { |word| bored_string += word.downcase }", "  s = 0\n  i = 0\n  while i < s.length\n\
    \    if s[i] != \"I\"\n      break\n    else\n      i += 1\n    end\n  end\n \
    \ return i\nend", "\tboredom = s.split(\".\").count(\"I\") == 0\n\tif boredom\n\
    \t\tputs \"1 point\"\n\telse\n\t\tputs \"0 points\"\n\tend\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (x,i)|\n    case x\n    when '.', '?'\n      sum + 1 if i > 0\n   \
    \ when '!'\n      sum + 1 if i > 0\n    end\n  end\nend", "  count = 0\n  s =\
    \ to_lower(s)\n  s.downcase!\n  s.gsub!(/\\.|\\?|\\!/, '')\n  s.split!\n  s.each\
    \ do |word|\n    if word == \"i\"\n      count += 1\n    end\n  end\n  count\n\
    end", "  s.split('.').count.('I')\nend", "    boredom = false\n    words.each\
    \ { |word| boredom = true if word.upcase == s[0] || word.upcase == s[1] || word.upcase\
    \ == s[2] }\n    boredom\nend", "  i = 0\n  while i < s.length\n    if s[i] ==\
    \ \"I\"\n      i += 1\n      break\n    i += 1\n  return i == s.length\nend",
  "  # Initialize a counter\n  c = 0", "    bored = 0\n    s.each do |word|\n    \
    \  if word == 'I'\n        bored = 1\n        break\n      end\n    end\n    return\
    \ bored\nend", "    boredoms = 0\n    for word in s.split(\" \")\n        boredoms\
    \ += 1 if word[0] == \"I\" else 0\n    puts(boredoms)\nend", "  if s.include?\
    \ \"I\"\n    return 0\n  elsif s.include? \"?\"\n    return 1\n  elsif s.include?\
    \ \"!\"\n    return 1\n  else\n    return 0\n  end\nend", "  s.gsub(/(?<=^|\\\
    s)(I)/, '')\nend", "  return s.downcase.include? \"i\".freeze\nend", "    bored\
    \ = 0\n    s.chars.each { |c| break if c != '?' && c != '!' }.each { |c|\n   \
    \     if c == '.'\n            bored += 1\n        end\n    }\n    return bored\n\
    end", "  s.split.any?(%r{^I\\s})\nend", "  s = s.gsub(/[\\.\\?\\!]/, '')  # remove\
    \ stopwords\n  s = s.strip\n  s = s.downcase\n  s = s.gsub(/\\s+/, ' ')  # remove\
    \ extra spaces\n  s = s.split(' ')\n  s.each do |word|\n    if word == 'I'\n \
    \     return 0\n    end\n  end\n  1\nend", "    words = s.split(\".\")\n    boredoms\
    \ = 0\n    for i in words\n        if i[0] == \"I\"\n            boredoms += 1\n\
    \        end\n    return boredoms\nend", "  return s[0] =~ /^(I.*|.*\\.|!.*)/\n\
    end", "  s.gsub!(/[\\.\\?\\!](\\s*)/){|e| \".\"} # replace .?! by .\n  s.split.select{|word|\
    \ word[0..1]==\"I\"}.size # count the boredoms\nend", "    s = s.downcase\n  \
    \  s = s.gsub(/[\\.\\?\\!]/, ' ') # remove stopwords like \".\" or \"?\"\n   \
    \ s = s.gsub(/\\s+/, ' ') # remove extra spaces\n    s = s.gsub(/\\s+/, ' ') #\
    \ remove extra spaces\n    s = s.gsub(/I /, '') # remove extra spaces\n    s =\
    \ s.gsub(/I /, '')\n    boredoms = s.scan(/I /).size\n    p boredoms\nend", " \
    \ s.split('.').map{|x| x.split('?')}.flatten.select do |x| x[0].strip == 'I'}.count\n\
    end", "  s = s.chomp\n  s.downcase!\n  s.gsub!(/[.?!]\\s+/, \" \")\n  s.gsub!(/\\\
    s*[I]+\\s+/, \"I\")\n  return 0 if s == \"I\" || s.start_with?(\"I\")\n  return\
    \ 1 if s == \"you\" || s.start_with?(\"you\")\n  return 0 if s == \"I\" || s.start_with?(\"\
    you\")\n  return 1\nend", "  s.chars.each_with_index do |c,i|\n    if c == \"\
    I\" && cs[i-1] == \"I\"\n      0 # boredom!\n    end\n  end \nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis is great, but why does it only work when `s` only\
    \ contains letters? I would expect it to  work for sentences as well as just letters,\
    \ e.g. `is_bored(\"Hello world!\")` should return `1`\n<|/ c |>\n<| c |>\nYes,\
    \ this solution will only work for letters. However, there are plenty of solutions\
    \ for word counting if you want them. I just wanted to show that there are a number\
    \ of ways to do this. Since your question was specifically about the boredom count,\
    \ I'll leave it for you to figure out how to modify it to account for word count\
    \ as well. I'll add a bit of code that does that to the answer, but it's not very\
    \ easy to write.\n<|/ c |>\n<| c |>\nThanks for your help, however I am still\
    \ a bit stuck. How would you modify it for the word count?\n<|/ c |>\n<| a tags=ruby,regex\
    \ dscore=0 |>\nHow about using scan instead?\n<code>\ns = 'The sky is blue. The\
    \ sun is shining. I love this weather.'\ns.scan(/I[^.!?]*/).count", "  boredom\
    \ = false\n  s.split(\".\").each do |word|\n    if word == \"I\"\n      boredom\
    \ = true\n    end\n  end\n  boredom\nend", "    boredoms = []\n    words = s.split(\"\
    \ \")\n    for w in words:\n        if w.startswith(\"I\"):\n            boredoms.append(w)\n\
    \    return len(boredoms)\n</code>\nYou might also want to add some test cases,\
    \ to ensure that the output is correct\n<code>", "  s = string.split(s)\n  s.each\
    \ do |word|\n    if word =~ /^I/ \n      return 0\n    end\n  end\n  return 1\n\
    end\n</cell>\n<text>\nNow we are ready to test your function.", "    s = s.downcase\n\
    \    boredoms = s.scan(/\\b(I)/)\n    boredoms.count.to_s\nend", "  count_i =\
    \ 0; count_boredoms = 0; count_others = 0\n  s.split(\".\").each do |sentence|\n\
    \    count_i += 1 if sentence.start_with?(\"I\")\n    count_boredoms += 1 if sentence.start_with?(\"\
    Boredom\")\n    count_others += 1 if sentence.start_with?(\"Other\")\n  end\n\
    \  return count_boredoms == s.count(\".\")\nend", "  boredom = 0\n  s.gsub!(/\\\
    .|\\?|!/) do |x|\n    boredom += 1\n  end\n  return boredom\nend", "  count =\
    \ 0\n  s.each_char.each do |letter|\n    if letter =~ /[I!.]/\n      count +=\
    \ 1\n    end\n  end\n  return count\nend\n</cell>\n<text>\nNow try it out in the\
    \ cell below. Feel free to copy/paste the function definition into the cell below,\
    \ and run it. Make sure it works for cases that you care about!", "    count =\
    \ 0\n    for word in s.split(\" \")\n        if word.start_with?(\"I\")\n    \
    \        count += 1\n    return count\nend", "    s = s.downcase\n    bored_words\
    \ = %w(i me myself)\n    bored_words.each do |word|\n        if s.start_with?(word)\n\
    \            return 1\n        end\n    end\n    return 0\nend\n</cell>\n<cell>",
  "  s.gsub!(/^/,'')\n  s.gsub!(/\\.$/,'') if s.end_with?(\".\")\n  s.gsub!(/\\.$/,'')\
    \ if s.end_with?(\"?\")\n  s.gsub!(/\\.$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\\
    .$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\.$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\\
    .$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\.$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\\
    .$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\.$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\\
    .$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\.$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\\
    .$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\.$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\\
    .$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\.$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\\
    .$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\.$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\\
    .$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\.$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\\
    .$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\.$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\\
    .$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\.$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\\
    .$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\.$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\\
    .$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\.$/,'') if s.end_with?(\"!\")\n  s.gsub!(/\\\
    .$/,'') if s.end_with?(\"", "    bored = false\n    i = 0\n    while i < s.length\n\
    \        if s[i] == \"I\"\n            bored = true\n        end\n        i +=\
    \ 1\n    end\n    return bored\nend", "    # Get the index of the first boredom\
    \ sentence\n    i = 1\n    while i < s.length and s[i] != '.' and s[i] != ','\
    \ and s[i] != ';' and s[i] != '?' and s[i] != '.'\n        i += 1\n    if i >=\
    \ s.length\n        return 0\n    boredoms = 0\n    i = i + 1\n    # Get the index\
    \ of the last boredom sentence\n    i = i\n    while i < s.length and s[i] !=\
    \ '.' and s[i] != ',' and s[i] != ';' and s[i] != '?' and s[i] != '.'\n      \
    \  i += 1\n    i = i - 1\n    # How many boredoms?\n    while i <= s.length\n\
    \        if s[i] == 'I'\n            boredoms += 1\n        i += 1\n    return\
    \ boredoms\nend", "  boredoms = [\"I\", \"myself\", \"my\", \"me\", \"myself?\"\
    , \"myself!\", \"I!\", \"my!\"]\n  boredom_count = 0\n  for boredom in boredoms\
    \ \n    if boredom =~ /^\\s*#{boredom}/ then\n      boredom_count += 1\n    end\n\
    \  end\n  puts boredom_count\nend\n</code>\nAs a hint, you may want to look at\
    \ how to use Ruby methods like include?. Another option is to use a regular expression\
    \ to match the string more exactly. Finally, you could look into using regular\
    \ expressions in Ruby by putting a \"/\" at the start of any regular expression\
    \ you wish to use.\n<|/ a dscore=1 |>\n<| c |>\nThanks for your help and for your\
    \ tips. I will try and implement this.\n<|/ c |>\n<| c |>\nYour first paragraph\
    \ should be \"You'll be given a string of **word**s\", and your second paragraph\
    \ should be \"You'll be given a string of **sentences**\".\n<|/ c |>\n<| c |>\n\
    I added more information to the answer.\n<|/ c |>\n<| c |>\nGreat! This is great\
    \ and much more elegant than my code :) I still need to implement a way to count\
    \ the sentences though, so that's why I opted for my old code. Thanks a lot!\n\
    <|/ c |>\n<| a tags=ruby,regex |>\nYou can try this\n<code>\n def count_boredom(s)\n\
    \   count = s.gsub(/([a-z]+\\.)\\w+/, '').count('I')\n   puts count\n end\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI like this answer, but I think it also matches sentences\
    \ which start with a word. `is_bored(\"I love to code.\")` returns 0, when it\
    \ should return 1.\n<|/ c |>\n<| a tags=ruby,regex |>\nThe other answers suggest\
    \ using gsub to find all matches. However, this would also match sentences like\
    \ \"I like this.\" which might be considered boredom.\nYou could use a regex like\
    \ ([a-z]*\\.)\\w+, which matches any sequence of letters, followed by a single\
    \ dot and followed by one or more word characters. You can then count the number\
    \ of matches.\nFor your example\n<code>\n def count_boredom(s)\n   count = s.scan(/([a-z]*\\\
    .)\\w+/).length\n   puts count\n end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThat ",
  "    count = 0\n    for w in s.split\n        if w.starts_with? \"I\"\n        \
    \    count += 1\n    return count\nend", "  return s.chars.any? {|c| c == 'I'\
    \ || c == '.' || c == '?' || c == '!'}\nend", "  s.each_char.with_index do |c,i|\n\
    \    return 0 if c =~ /^[\\.\\?!]/ and i+1<s.length and s[i+1] =~ /^[\\.\\?!]/\n\
    \  end\n  0\nend\n</cell>\n<code language=conda-root-py>\nis_bored 'Hello world'\n\
    </cell>\n<code language=conda-root-py>\nis_bored 'The sky is blue'\n</cell>\n\
    <code language=conda-root-py>\nis_bored 'The sun is shining'\n</cell>\n<code language=conda-root-py>\n\
    is_bored \"I'm a bored\"\n</cell>\n<code language=conda-root-py>\nis_bored \"\
    I'm a bored.\"\n</cell>\n<code language=conda-root-py>\nis_bored \"I'm a bored\
    \ person.\"\n</cell>\n<text>\nIn the cell above, the '?' is capitalized as it\
    \ matches the 'A' in the string 'am', which is capitalized as it matches the 'A'\
    \ in the string 'bored.'", "  i = 0\n  while i < s.length\n    return false if\
    \ s[i] == \"I\" && boredoms_detected[s[i..-1]]\n    i += 1\n  end\n  \n  true\n\
    end", "    bored = 0\n    words = s.split()\n    for w in words\n        bored\
    \ = bored + (w.eql?(\"I\"))\n    end\n    return bored\nend", "\ts.gsub!(/[.,?!]\\\
    z/, '')\n\tif s[0] == \"I\"\n\t\ts.gsub!(/^I+/, '')\n\telse\n\t\ts.gsub!(/^[^I]+/,\
    \ '')\n\tend\n\treturn s.split.count(\"I\") == 0\nend", "  words = []\n  s.split('.')\
    \ do |w|\n    words << w.chop\n  end\n  s.split('?') do |w|\n    words << w.chop\n\
    \  end\n  s.split('!') do |w|\n    words << w.chop\n  end\n  words.count { |w|\
    \ w.starts_with?(\"I\") }\nend", "  s = String(s).strip_punctuation\n  s.each_char\
    \ do |c|\n    case c\n    when \".\", \"?\", \"!\"\n      return false\n    end\n\
    \  end\n  return true\nend", "  s.chars.grep(/[\\.?!]/)\n  s.chars.count(\"I\"\
    )\nend\n</code>\n<|/ a |>\n<| c |>\n+1 As a side note: this is probably the most\
    \ efficient solution. On a very small string it is probably more efficient to\
    \ just search for the 'I' character rather than counting every character, but\
    \ for a string with a million or so characters, this is clearly the most efficient\
    \ way to do it.\n<|/ c |>\n<| c |>\nIt is not clear how to handle sentences that\
    \ start with a period or question mark. It seems that you treat them as an empty\
    \ string. I would assume that they would not be counted though. The first sentence\
    \ you posted \"Hello world\" returns 0 while the second one \"The sky is blue.\
    \ The sun is shining. I love this weather\" returns 1.\n<|/ c |>\n<| c |>\nAh,\
    \ my mistake, that code had been written as a hurry from memory, and I forgot\
    \ I changed it at the end there. Fixed now.\n<|/ c |>\n<| c |>\nOkay, now that\
    \ you've fixed the code, I am no longer getting a zero. I'm getting the error:\
    \ `undefined method chars for #<Enumerator:0xa27a048>`\n<|/ c |>\n<| c |>\nMy\
    \ bad. I fixed it by adding `to_a` to the end. Sorry for any confusion.\n<|/ c\
    \ |>\n<| a dscore=3 tags=ruby |>\n<code>\ns.scan(/[\\.?!]/).grep(/[I]/).size\n\
    </code>\n<|/ a |>\n<| a |>\nHow about a regexp that says, \"look for I, but only\
    \ if there's an I in a sentence\"?\n<code>\n s.scan(/[\\.?!]/).grep(/[I]/).size\n\
    </code>\n<|/ a dscore=3 tags=ruby |>\n<| c |>\nIt appears that this method is\
    \ faster than the accepted answer. Mine: 1.32 \u03BCs, Ken's (using scan and grep):\
    \ 3.25 \u03BCs, David's (using just count): 2.05 \u03BCs\n<|/ c |>\n<| a |>\n\
    A simple regex can help you here:\n<code>\n>> \"I love this weather\".match(/I\\\
    b.+?\\b/)\n=> #<MatchData \"I\">\n</code>\nSo you can check it against nil instead:\n\
    <code>\n>> \"I love this weather\".match(/I\\", "    s = s.downcase\n    boredom_counts\
    \ = Hash.new(0)\n    boredom_counts[\"I\"] = 0\n    s.split(\" \").each do |word|\n\
    \      boredom_counts[word] += 1 if word =~ /^[I]/ || word =~ /^[!?\\.]/\n   \
    \ end\n    return boredom_counts[\"I\"] > 0\n  end", "  return s.split('.').count\
    \ { |s| s.index(\"I\") == 0 } == 0 ? 0 : 1 \nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=1 |>\n<| c |>\nYou should probably change `str.split('.')` to `str.split('\\\
    .')`. Otherwise, it will split on a literal dot.\n<|/ c |>\n<| c |>\nGood catch.\
    \ Thanks.\n<|/ c |>\n<| c |>\nIf you're interested, I did some benchmarking between\
    \ this and `Regexp.count` (which I believe is more performant). See my answer.\n\
    <|/ c |>\n<| c |>\n`str.split` splits strings based on a regex, and the pattern\
    \ `\\.` matches a literal dot. I believe the two are equivalent (although the\
    \ former is more readable, IMO).\n<|/ c |>\n<| c |>\nYeah, I didn't realize that.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| a tags=ruby,arrays dscore=1 |>\nHere\
    \ are a few alternatives (using Regexp.count as suggested by in the comments):\n\
    <code>", "  count = 0\n  for i in (s.split(\" \"))\n    if i[0].downcase == \"\
    i\"\n      count += 1\n  end\n  count\nend\n</cell>\n<cell>\nis_bored(\"Hello\
    \ world\")\nis_bored(\"The sky is blue. The sun is shining. I love this weather\"\
    )\n</cell>\n<cell>", "    bored_count = 0\n    for word in s.split(\" \")\n  \
    \      if word[0] =~ '^[Ii][a-zA-Z].*$' \n            bored_count += 1\n    end\n\
    \    return bored_count\nend", "  s.gsub!('.','').gsub!('?','').gsub!('!','')\n\
    \  return s[0] == \"I\"\nend", "  i = s.index(\".\")\n  j = s.index(\"?\") if\
    \ s.index(\"?\") < s.index(\".\") else s.index(\"!\")\n  bored = (i == 0 or j\
    \ == 0 or s[i-1] == \"I\" and s[j-1] == \"I\")\n  return bored\nend", '  bored_words
    = %w(i i me me myself myself my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my my my my my my my my my my my my my my my
    my my my my my my my my my my my my ', "  return s.start_with?(\"I\") && sentences(s).count\
    \ > 0\nend\n</cell>\n<text>\nProblem 3\nWrite a function boredom_count() that\
    \ takes in a string of words and returns the number of boredoms present in the\
    \ text.", "  s = s.split(/[.\\?!]/)\n  return s[0..1] == \"I\"\nend", "    # Split\
    \ the string on '.', '?' and '!'.\n    # Don't count periods or question marks\
    \ in counts.\n    counts = s.split(/\\W+/)\n    counts = counts.select {|e| e\
    \ =~ /^([?!])/}\n    counts = counts.count\n    # Return false if there are no\
    \ sentences.\n    return false  if counts == 0\n    # Return true if the last\
    \ word is \"I\".\n    return true  if counts[-1] == \"I\"\n    # Return false\
    \ if the last word is \"I\" or \"the\".\n    return false  if counts[-1] == \"\
    I\" or counts[-1] == \"the\"\n    # Return false if the last two words are \"\
    I\" or \"the\".\n    return false if counts[-2] == \"I\" or counts[-2] == \"the\"\
    \n    # Return false if the first word is \"I\" or \"the\".\n    return false\
    \  if counts[0] == \"I\" or counts[0] == \"the\"\n    # Otherwise, return true.\n\
    \    return true\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the code. I'll give\
    \ it a try and see how it goes.\n<|/ c |>\n<| c |>\n+1 for using RegEx to split\
    \ the string, and to answer the question of how to determine boredom.\n<|/ c |>\n\
    <| a dscore=0 |>\nI guess you mean this:\n<code>", "  s.gsub!(/\\.|\\?|\\!/, \"\
    \")\n  s.split(\" \").any? { |x| x == \"I\" }\nend", "  s.gsub!(/[^.?!]/,\".\"\
    )\n  return s.scan(/\\bI\\b/).size>0\nend", "  s.gsub(/([I]\\w+)/){|s| s.scan(/\\\
    .|\\.|\\?|\\!/).size}\nend", "  s = s.downcase\n  return s.index(\"i\")==0 &&\
    \ s.index(\".\")==s.rindex(\".\")\nend", "  s.scan(/^I[^\\.\\?!]+\\.$/)\n  s.scan(/^I[^\\\
    .\\?!]+\\.\\?$/)\n  s.scan(/^I[^\\.\\?!]+\\.\\!$/)\nend", "\tbored = 0\n\tfor\
    \ i in range(len(s)):\n\t\tif s[i] == 'I' and s[i+1] == 'O':\n\t\t\tbored += 1\n\
    \treturn bored\n</cell>\n<text>\nImplement the is_confused function.", "    return\
    \ s.count(\"I\") == 0\nend", "    count = 0\n    sentences = sentence_split(s)\n\
    \    word_count = 0\n    for sentence in sentences\n        if sentence[word_count]\
    \ == \"I\"\n            count += 1\n            word_count += 1\n    return count\n\
    </cell>\n<cell>", "  i = nil\n  for i in 0...s.length\n    if s[i] =~ /[\\.\\\
    ?!]/\n      break\n    end\n  end\n  return nil if i == s.length\n  return 1 if\
    \ s[i] == \"I\"\n  return 0 #s is not a boredom sentence\nend", "  bored = 0\n\
    \  s = s.downcase\n  s.gsub!(/[^\\.\\?\\!]+/, \"\")\n  s.split(\" \").each do\
    \ |word|\n    if word == \"i\"\n      bored = 1\n      break\n    end\n  end\n\
    \  return bored\nend\n</code>\n<|/ a tags=ruby,string,regex |>\n<| c |>\nYep,\
    \ I'm a big fan of using regex. Just a note, though: It doesn't matter if it's\
    \ more readable. Code is better than human language. In general, human languages\
    \ are much easier to understand than code.\n<|/ c |>\n<| c |>\n\"Human languages\
    \ are much easier to understand than code.\" - I take it you meant programmers,\
    \ not humans, then.\n<|/ c |>\n<| c |>\n: Yes, I do! I meant programmers, not\
    \ people who know a lot about human languages. :)\n<|/ c |>\n<| c |>\n: I see,\
    \ thanks for clarifying, I wasn't familiar with the term.\n<|/ c |>\n<| a tags=ruby,string,regex\
    \ |>\n<code>", "  num_boredoms = count_boredoms(s)\n  return num_boredoms == 3\n\
    end", "  s.scan(/([I!?].*[\\.\\?!])/)\n  s.count(\"I\") \nend\n</cell>\n<code\
    \ language=julia-0.6>", "  return s.scan(/(?:^|\\s)I(\\s.|!|\\s|\\.|\\?|\\!)/)[0].length\n\
    end\n</cell>\n<text>\nis_ghost() checks if a word begins with the word \"ghost\"\
    .\nIt's a ghost if it's not in a dictionary, and it's not in the set \"have\"\
    .\nIt counts multiple ghosts too.", "  s.split(\" \").count {|w| w =~ /^[I].*\\\
    .?[!?]$/} > 0\nend", "  s.split(/\\W+/).each do |word|\n    word.downcase!\n \
    \   return 0 if (word == \"i\")\n    return 1 if (word == \"i\") && (s[0,1] ==\
    \ \"i\")\n    return 1 if (word == \"i\") && (s[0,1] == \"i\") && (s[1,1] == \"\
    i\")\n  end\n  0\nend", "  # Write your code here\n  bored=0\n  bored_idx=0\n\
    \  for i in s:\n    if i=='I' or i=='i':\n      bored+=1\n      bored_idx=bored_idx+1\n\
    \  return bored,bored_idx", "    # Get the number of '.', '?' and '!' in s\n \
    \   (d, n, t) = s.count (\".\"), s.count (\"?\"), s.count (\"!\")\n    return\
    \ d > n or n > t or t > d\nend", "  s = 0\n  a = s.split('.')\n  b = a[0].split('?')\n\
    \  c = b[0].split('!')\n  if a[0].strip == \"I\" and b[0].strip == \"I\" and c[0].strip\
    \ == \"I\"\n  then return 1\n  else return 0\nend", "  s = s[1...s.length]\n \
    \ boredom = true\n  s.each_char do |c|\n    if (c == 'I') && boredom\n      boredom\
    \ = false\n    end\n  end\n  boredom\nend\n</code>\nNow that you have written\
    \ a function that checks whether a bored sentence is one you want to use, write\
    \ a function that takes in a string, a sentence delimiter, and a boolean that\
    \ indicates whether a sentence is bored. Next, write a function that will split\
    \ the string up at the delimiter and give you a count of how many bored sentences\
    \ there are. Here's an example of how you could use these functions:\n<code>",
  "  s.split\n  s.split!", "  s = s.downcase\n  s.gsub!(/[\\.\\?\\!]/,\" \") # Replace\
    \ all punctuation with a space\n  s.gsub!(/I /,\"\") # Remove all instances of\
    \ \"I\"\n  s.gsub!(/\\bI /,\"\") # Remove all instances of \"I \"\n  s.gsub!(/\\\
    bI /,\"\") # Remove all instances of \"I \"\n  s.gsub!(/\\bI /,\"\") # Remove\
    \ all instances of \"I \"\n  s.split(\" \").count(\"I\") # Count instances of\
    \ \"I\"\nend", "    boredom = 0\n    words = s.split('.')\n    words.each { |w|\
    \ w.start_with?(\"I\") && boredom += 1 }\n    return boredom\nend", "    bored\
    \ = 0\n    for sentence in s.split(\".\"):\n        if sentence == \"I\" or sentence\
    \ == \"i\" :\n            bored += 1\n    return bored", "  num_bored = 0\n  parts\
    \ = s.split(\".\")\n  bored_parts = parts[0].split(\"?\")\n  if bored_parts[0].downcase\
    \ == \"i\"\n    num_bored = 1\n  bored_parts = parts[1].split(\"!\")\n  if bored_parts[0].downcase\
    \ == \"i\"\n    num_bored = 1\n  return num_bored\nend", "  return s.split('.').all?{|word|\
    \ word[0] == 'I'} ? 1 : 0\nend", "    count = 0\n    sentences = sentence_count(s)\n\
    \    boredom_words = [\"I\"]\n    boredom_sentences = []\n    boredom_sentence_starts\
    \ = []", "    return s.index(\"I\") != 0\nend", "  s.scan(/\\w+/).count { |word|\
    \ word == \"I\" }\nend", "    count = 0\n    sentences = s.split(\".\")\n    sentences.each\
    \ do |sentence|\n        if sentence.start_with?(\"I\")\n            count +=\
    \ 1\n        end\n    end\n    return count\nend", "  count = 0\n  words = s.split(\"\
    .\")\n  words[1] = words[1].gsub(\"I\", \"\")\n  words.each do |word|\n    if\
    \ word =~ /^I/ then\n      count = count + 1\n    end\n  end\n  return count\n\
    end\n</cell>\n<cell>", "    boredoms = s[:s.index(\".\")+1 ]\n    if boredoms\
    \ == \"I\".downcase\n        return 1\n    else\n        return 0\n    end\nend",
  "    boredom = 0\n    for i in s.split(\" \"):\n        boredom += 1 if i.startwith(\"\
    I\") else 0\n    return boredom\n</code>\nBTW: if you do something like s.split(\"\
    \ \"), you are splitting on the \" \" character, which splits things up by spaces,\
    \ so \"I love\" would be broken up as [\"I\", \"love\"]. \nA quick way to see\
    \ what is going on is to print out s and see what is actually in it. You can do\
    \ this by using something like print(repr(s)) \nI hope this helps!\n<|/ a dscore=2\
    \ tags=python |>\n<| c |>\n`s.split(\" \").count(\"I\")` would be a better way\
    \ to do it - it works even if the string has multiple spaces\n<|/ c |>\n<| c |>\n\
    Thanks for the suggestion! I will use that instead.\n<|/ c |>\n<| c |>\nThis is\
    \ very helpful and very helpful to me\n<|/ c |>\n<| c |>\nThank you everyone for\
    \ your help\n<|/ c |>\n<| a dscore=2 |>\nFor string \"I love the sun\" the loop\
    \ will go through the letters one by one and add 1 to boredom if that letter starts\
    \ with I.  \n<code>", "  s.gsub!(/\\.|\\?|\\!/, '') # get rid of delimiters\n\
    \  s.chars.each do |char|\n    if char.downcase == \"i\"\n      return 0\n   \
    \ end\n  end\n  return 1\nend", "  s.scan(/[\\.\\!\\?\\s]/)\n  s.count(\"I\")\n\
    end", "  s.gsub(/(?<=^|\\s)I\\b/, '').length == 1\nend", "    word_count = 0\n\
    \    bored_words = []\n    for word in s.split():\n        if word.startswith('I'):\n\
    \            word_count += 1\n            bored_words.append(word.lower())\n \
    \       elif word.endswith('?') or word.endswith('!'):\n            bored_words.append(word.lower())\n\
    \        else:\n            bored_words.append(word)\n    bored_words = bored_words[:4]\
    \ # We only care about the first 4 bored words\n    for word in bored_words:\n\
    \        if word in bored_boredom_words:\n            return True\n    return\
    \ False", "  s.scan(/[\\.?!]\\s/) do |word|\n    if word == \"I\"\n      0\n \
    \   elsif s.scan(/\\w+/).first == word\n      1\n    else\n      0\n    end\n\
    \  end\nend", "  s.count(\"I\") == 0\nend\n</cell>\n<code language=julia-1.0>",
  "  s.scan(/I./)\n  s.scan(/!/)\n  s.scan(/\\.\\./)\n  s.scan(/\\?/)\n  return s.scan(/I./).length\n\
    end", "  i = 0\n  boredom = false\n  while i < s.length\n    if s[i] =~ /^I/ &&\
    \ s[i+1] =~ /^./ && s[i+2] =~ /^./\n      boredom = true\n    end\n    i += 1\n\
    \  end\n  return boredom\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,regex\
    \ |>\nI see that the regex posted above doesn't work for me:\n<code>\n>> \"The\
    \ sky is blue. The sun is shining. I love this weather\".match(/I.*?\\./g)\n=>\
    \ #<MatchData \"I\" 1:\".\">\n</code>\nI used this\n<code>\n>> \"The sky is blue.\
    \ The sun is shining. I love this weather\".gsub(/I.*?\\./,'').count('.')\n=>\
    \ 1\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,regex |>\n<code>\n\"Hello world\"\
    .scan(/(?<!I).*?/)\n=> [\"Hello\", \"world\"]\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a tags=ruby,regex dscore=0 |>\n<code>", "  return s.split(\".\").any? { |w|\
    \ w =~ /^I/ }\nend", "  count = 0\n  s.downcase!\n  s.scan(/([I]\\w+|[.!?])/)\n\
    \  s.each do |x|\n    if x.downcase == \"I\"\n      count += 1\n    end\n  end\n\
    \  return count\nend", "\tboredom = false\n\twords = s.split('.')\n\tfor w in\
    \ words\n\t\tif w[0] == 'I'\n\t\t\tboredom = true\n\t\t\tbreak\n\tend\n\treturn\
    \ boredom\nend", "  s.split(//)[0].start_with?(\"I\")\nend", "  s.gsub!('\\.\\\
    .','.')\n  s.gsub!('\\?\\?','?')\n  s.gsub!('\\!\\!','!')\n  s.gsub!('I','I')\n\
    \  s.gsub!('the','the')\n  s.gsub!('is','is')\n  s.gsub!('it','it')\n  return\
    \ s.gsub!('boredom','bored') #count boreds\nend", "  return 1 if s[0] == \"I\"\
    \ else  0\nend", "  bored = s.count(\"I\")\n  bored += 1 if s.count(\".\") > 0\
    \ else 0\n  bored += 1 if s.count(\"!\") > 0 else 0\n  bored += 1 if s.count(\"\
    ?\") > 0 else 0\n  return bored\nend", "  return s.split(\" \").map{|w| w[0..2]==\"\
    I\"}.inject(:+)\nend", "  return s.gsub('[^I].*', '').length >= 3\nend", "  (0..s.count(\"\
    .\")-1).each do |i|\n    return (s[i] == \"I\") ? i+1 : 0\n  end\n  0\nend", " \
    \ a = s.split(\" \") # splits by whitespace\n  if a[0] == \"I\"\n  else\n  a[0]\
    \ == \"I\" \n  boredom_count = 0\n  for a in a\n    if a.include? \"!\"\n    \
    \  boredom_count += 1\n    else a.include?\".\"\n      boredom_count += 1\n  \
    \  end\n  end\n  boredom_count\nend\nis_bored \"Hello world\"", "  s.scan(/^[i.!?]+/)\n\
    end", "  s.scan(/\\b(?<!I).*\\b/)\nend", "  s.gsub!(/[.!?]/,\" \") #substitute\
    \ each dot with a space\n  s.gsub!(/[I]/,\"\") #substitute each I with a space\n\
    \  s.split(\" \").count(\"I\") == 1\nend", "  count = 0\n  s.each_char{|c| break\
    \ count += 1 if c == \"I\"}\n  count\nend", "  s = s.downcase\n  s.match? /^[\\\
    .\\?\\!](I)/\nend", "  s.split.each do |word|\n    if word.start_with?(\"I\")\n\
    \      return 0\n    end\n  end\n  return 1\nend", "  i = s.index(\"I\")\n  j\
    \ = s.index(\".\")\n  k = s.index(\"!\") \n  if j != -1 and k != -1\n    i +=\
    \ j\n    s += k\n  end\n  return s.count(\"I\") > 0\nend", "  s.downcase!\n  s.gsub!(/\\\
    .\\./, \".\")\n  s.gsub!(/\\?\\.\\./, \"?\")\n  s.gsub!(/\\!\\.\\./, \"!\")\n\
    \  s.gsub!(/^I./, \"I\")\n  s.gsub!(/I./, \"I\")\n  s.gsub!(/^I/, \"I\")\n  s.gsub!(/\\\
    .$/, \".\")\n  s.gsub!(/\\.$/, \".\")\n  s.gsub!(/\\.$/, \".\")\n  s.gsub!(/\\\
    .$/, \".\")\n  s.gsub!(/\\.$/, \".\")\n  s.gsub!(/\\?$/, \"?\")\n  s.gsub!(/\\\
    ?$/, \"?\")\n  s.gsub!(/\\?$/, \"?\")\n  s.gsub!(/\\?$/, \"?\")\n  s.gsub!(/\\\
    ?$/, \"?\")\n  s.gsub!(/\\!$/, \"!\")\n  s.gsub!(/\\!$/, \"!\")\n  s.gsub!(/\\\
    !$/, \"!\")\n  s.gsub!(/\\!$/, \"!\")\n  s.gsub!(/\\!$/, \"!\")\n  s.gsub!(/\\\
    !$/, \"!\")\n  s.gsub!(/!$/, \"!\")\n  s.gsub!(/!$/, \"!\")\n  s.gsub!(/!$/, \"\
    !\")\n  s.gsub!(/!$/, \"!\")\n  s.gsub!(/!$/, \"!\")\n  s.gsub!(/^!/, \"!\")\n\
    \  s.gsub!(/^!/, \"!\")\n  s.gsub!(/^!/, \"!\")\n  s.gsub!(/^!/, \"!\")\n  s.gsub!(/!$/,\
    \ \"!\")\n  s.gsub!(/!$/, \"!\")\n  s.gsub!(/!$/, \"!\")\n  s.gsub!(/!$/, \"!\"\
    )\n  s.gsub!(/!$/, \"!\")\n  s.gsub!(/!$/, \"!\")\n  s.gsub!(/!$/, \"!\")\n  s.gsub!(/!$/,\
    \ \"!\")\n  s.gsub!(/!$/, \"!\")\n  s.gsub!(/!$/, \"!\")\n  s.gsub!(/!$/, \"!\"\
    )\n  s.gsub!(/!$/, \"!\")\n  s.gsub!(/!$/, \"!\")\n  s.gsub!(/!$/, \"!\")\n  s.gsub",
  "  return s.scan(/\\b(I\\b)/).length >= 1\nend", "  # Split by delimiters\n  s =\
    \ s.split('.')\n  # Get the first word\n  w = s[0].strip().replace('?','')\n \
    \ if w[0] == \"I\"\n    return 1\n  else\n    return 0\nend", "  s.scan(/\\.\\\
    W?I\\W?|\\W\\.\\W?I\\W?|\\W\\.\\W?|\\WI\\W?/i).length\nend", "  s.split(\" \"\
    ).map { |w| w.start_with?(\"I\") }.count\nend\n</cell>\n<code language=julia-1.6>\n\
    @time is_bored(\"The sky is blue. The sun is shining. I love this weather\");\n\
    </cell>\n<text>\nPart 4: Boredom filter\nThis exercise has you bored until you\
    \ know a good way to treat a boredom.", "  s.gsub!(/(\\.|\\?|!)$/, '')\n  s.split(\"\
    \ \").each { |word|\n    if word.match('I') then\n      return 0\n    elsif word.match('the')\
    \ then\n      return 0\n    elsif word.match('are') then\n      return 0\n   \
    \ end\n  }\n  return 1\nend", "  count = 1\n  s.gsub!(/[\\.\\!?]/, '')\n  s.gsub!(/[\\\
    ?\\!]/, '').each_char {|c| c != 'I' ? count += 1 : nil }\n  count == 1 ? 1 : 0\n\
    end", "  s.split('.').select {|e| e.include?('I')}.count\nend", "  # Return the\
    \ number of sentences that start with the word \"I\"\n  count = 0\n  s = s.downcase\n\
    \  s.gsub!(/[.!?]\\s*$/, '')\n  s.scan(/(?<=^| )\\bI\\b/i) { count += 1}\n  count\n\
    end", "  num_boredom = 0\n  \n  s.gsub!(/\\.{2}/, '')\n  s.gsub!(/\\?{2}/, '')\n\
    \  s.gsub!(/\\!{2}/, '')\n  \n  s.scan(/\\bI\\b/) do |word|\n    num_boredom +=\
    \ 1\n  end\n  \n  num_boredom\nend", "    return s.scan(/\\bI\\b/).size > 0\n\
    end", "  s.chomp!\n  s.scan(/\\b[iI]\\b/i).size > 0\nend", "  return s.count \"\
    I\"\nend\n</cell>\n<code language=julia-0.6>", "  s.split('.').count {|word| word.downcase\
    \ =~ /\\b(I|i|!)\\b/ } > 0\nend", "  return s.gsub!(/\\.|!|I/,\"\").gsub!(/\\\
    .\\.|\\.\\?|\\?\\?/,\"\").length == 1\nend", "    s = s.split\n    boredom = if\
    \ s[0] == \"I\" then 1 else 0\n    return boredom\nend", "  s.downcase!\n  s.gsub!(/(^|\\\
    W)\\W+|(\\W|\\W)+\\W+$/, \"\")\n  s = s.downcase\n  s.gsub!(\"(?<=\\W|^)\\W*[\\\
    ?\\!]\", \".\")\n  s.gsub!(\"(?<=\\W|^)\\.\\.\", \".\")\n  s.gsub!(\"(?<=\\W|^)\\\
    .\", \".\")\n  s.gsub!(\"(?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"(?<=\\W|^)[\\\
    ?\\!]\", \".\")\n  s.gsub!(\"(?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"(?<=\\\
    W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"(?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"\
    (?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"(?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"\
    (?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"(?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"\
    (?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"(?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"\
    (?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"(?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"\
    (?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"(?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"\
    (?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"(?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"\
    (?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"(?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"\
    (?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"(?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!(\"\
    (?<=\\W|^)[\\?\\!]\", \".\")\n  s.gsub!", "  return s.scan(/\\b(?:I|you|he|she|it|the)\\\
    b/).length == 1 ? 0 : 1 end\nend", "    return 0 if(s =~ /[^?.!][I][^?.!]/) else\
    \ 1\nend", "  s.gsub!(/[.?!]/,'')\n  return s.gsub!(/^(I)/,'1').gsub!(/(I|us)$/,'0').size\n\
    end", "  count = 0\n  s.scan(/\\bI\\b/).each do |w|\n    count += 1\n  end\n \
    \ return count\nend\n</pre>", "  s = 0\n  s.split(\" \").each do |word|\n    if\
    \ word[0..1] == \"I\"\n      s = s + 1\n    end\n  end\n  return s\nend\nprint(is_bored(\"\
    Hello world\"))\nprint(is_bored(\"The sky is blue. The sun is shining. I love\
    \ this weather\"))\nprint(is_bored(\"The sun is shining. Hello world\"))\nprint(is_bored(\"\
    The sun is shining. I love this weather.\"))\nprint(is_bored(\"The sun is shining.\
    \ I love this weather.\"))\nprint(is_bored(\"The sun is shining. I love this weather.\
    \ Hello world.\"))\nprint(is_bored(\"The sun is shining. I love this weather.\
    \ Hello world. Hello world.\"))\nprint(is_bored(\"The sun is shining. I love this\
    \ weather. Hello world. Hello world.\"))\nprint(is_bored(\"The sun is shining.\
    \ I love this weather. Hello world. Hello world.\"))\nprint(is_bored(\"The sun\
    \ is shining. I love this weather. Hello world. Hello world.\"))\nprint(is_bored(\"\
    The sun is shining. I love this weather. Hello world. Hello world.\"))\nprint(is_bored(\"\
    The sun is shining. I love this weather. Hello world. Hello world.\"))\nprint(is_bored(\"\
    The sun is shining. I love this weather. Hello world. Hello world.\"))\nprint(is_bored(\"\
    The sun is shining. I love this weather. Hello world. Hello world.\"))\nprint(is_bored(\"\
    The sun is shining. I love this weather. Hello world. Hello world.\"))\nprint(is_bored(\"\
    The sun is shining. I love this weather. Hello world. Hello world.\"))\nprint(is_bored(\"\
    The sun is shining. I love this weather. Hello world. Hello world.\"))\nprint(is_bored(\"\
    The sun is shining. I love this weather. Hello world. Hello world.\"))\nprint(is_bored(\"\
    The sun is shining. I love this weather. Hello world. Hello world.\"))\nprint(is_bored(\"\
    The sun is shining. I love this weather. Hello world. Hello world.\"))\nprint(is_bored(\"\
    The sun is shining. I love this weather. Hello world. Hello world.\"))\nprint(is_bored(\"\
    The sun is shining. I love this weather. Hello world. Hello world.\"))\nprint(is_bored(\"\
    The sun is ", "  return s.index(\"I\") == 0 or s.index(\".\")  or s.index(\"?\"\
    ) or s.index(\"!\")\nend", "  s.gsub!(/[\\.\\?\\!]+/, \" \") \n  s.split(\" \"\
    )\n  s.each do |word|\n    if word == \"I\"\n      return 0\n    end\n  end\n\
    \  return 1\nend\n</cell>\n<cell>", "  if s[0] == \"I\"\n    return 1\n  else\
    \ \n    return 0\nend", "  arr = s.split('.')\n  count = arr[0].count('I')\n \
    \ count += arr[1].count('I') if arr[1].count('I') > 0 then 1 else 0\n  count +=\
    \ arr[2].count('I') if arr[2].count('I') > 0 then 1 else 0\n  count += arr[3].count('I')\
    \ if arr[3].count('I') > 0 then 1 else 0\n  count += arr[4].count('I') if arr[4].count('I')\
    \ > 0 then 1 else 0\n  count += arr[5].count('I') if arr[5].count('I') > 0 then\
    \ 1 else 0\n  count += arr[6].count('I') if arr[6].count('I') > 0 then 1 else\
    \ 0\n  count += arr[7].count('I') if arr[7].count('I') > 0 then 1 else 0\n  count\
    \ += arr[8].count('I') if arr[8].count('I') > 0 then 1 else 0\n  count += arr[9].count('I')\
    \ if arr[9].count('I') > 0 then 1 else 0\n  count += arr[10].count('I') if arr[10].count('I')\
    \ > 0 then 1 else 0\n  count += arr[11].count('I') if arr[11].count('I') > 0 then\
    \ 1 else 0\n  count += arr[12].count('I') if arr[12].count('I') > 0 then 1 else\
    \ 0\n  count += arr[13].count('I') if arr[13].count('I') > 0 then 1 else 0\n \
    \ count += arr[14].count('I') if arr[14].count('I') > 0 then 1 else 0\n  count\
    \ += arr[15].count('I') if arr[15].count('I') > 0 then 1 else 0\n  count += arr[16].count('I')\
    \ if arr[16].count('I') > 0 then 1 else 0\n  count += arr[17].count('I') if arr[17].count('I')\
    \ > 0 then 1 else 0\n  count += arr[18].count('I') if arr[18].count('I') > 0 then\
    \ 1 else 0\n  count += arr[19].count('I') if arr[19].count('I') > 0 then 1 else\
    \ 0\n  count += arr[20].count('I') if arr[20].count('I') > 0 then 1 else 0\n \
    \ count += arr[21].count('I') if arr[21].count('I') > 0 then 1 else 0\n  count\
    \ += arr[22].count('I') if arr[22].count('I') > 0 ", "    s = 0\n    bored = 0\
    \ \n    s = s.split(\" \") # split the string into words\n    i = 0\n    \n  \
    \  while i < len(s)\n        if s[i] == \"I\" or s[i] == \"i\"\n            bored\
    \ = bored + 1\n        i = i + 1\n    end\nend", "    s_array = s.split(\". \"\
    )\n    count = 0\n    boredoms = [\"I\", \"me\", \"my\", \"myself\", \"we\", \"\
    our\", \"ours\", \"ourselves\", \"you\", \"your\", \"yours\", \"yourself\", \"\
    yourselves\", \"he\", \"him\", \"his\", \"himself\", \"she\", \"her\", \"hers\"\
    , \"herself\", \"it\", \"its\", \"itself\", \"they\", \"them\", \"their\", \"\
    theirs\", \"themselves\", \"what\", \"which\", \"who\", \"whom\", \"this\", \"\
    that\", \"these\", \"those\", \"am\", \"is\", \"are\", \"was\", \"were\", \"be\"\
    , \"been\", \"being\", \"have\", \"has\", \"had\", \"having\", \"do\", \"does\"\
    , \"did\", \"doing\", \"a\", \"an\", \"the\", \"and\", \"but\", \"if\", \"or\"\
    , \"because\", \"as\", \"until\", \"while\", \"of\", \"at\", \"by\", \"for\",\
    \ \"with\", \"about\", \"against\", \"between\", \"into\", \"through\", \"during\"\
    , \"before\", \"after\", \"above\", \"below\", \"to\", \"from\", \"up\", \"down\"\
    , \"in\", \"out\", \"on\", \"off\", \"over\", \"under\", \"again\", \"further\"\
    , \"then\", \"once\", \"here\", \"there\", \"when\", \"where\", \"why\", \"how\"\
    , \"all\", \"any\", \"both\", \"each\", \"few\", \"more\", \"most\", \"other\"\
    , \"some\", \"such\", \"no\", \"nor\", \"not\", \"only\", \"own\", \"same\", \"\
    so\", \"than\", \"too\", \"very\", \"s\", \"t\", \"can\", \"will\", \"just\",\
    \ \"don\", \"should\", \"now\"]\n    boredoms_array = []\n    \n    for i in s_array:\n\
    \        if i.startswith(\"I\"):\n            count += 1\n            boredoms_array.append(i)\n\
    \    \n    for i in boredoms_array:\n        if i in s_array:\n            count\
    \ -= 1\n    return count", "    bored_sentences = 0\n    # split into sentence\
    \ array by period, question mark and exclamation mark\n    sentences = s.split(\"\
    .\")\n    # loop through each sentence\n    for sentence in sentences\n      \
    \  if sentence == \"I\"\n            bored_sentences += 1\n    return bored_sentences",
  "  count = 0\n  s.split('.').each do |line|\n    count += 1 if line =~ /^I[a-z]+/i\n\
    \  end\n  count\nend\n</cell>\n<cell>", "    boredoms = Hash.new(0)\n    s.split(\"\
    \ \").each do |word|\n        if word.downcase == \"i\"\n            boredoms[word]\
    \ += 1\n        end\n    end\n    boredoms.keys.length == 1 ? boredoms.values[0]\
    \ : boredoms\nend\n</cell>\n<code language=julia-0.4>\nis_bored(\"The sky is blue.\
    \ The sun is shining. I love this weather\")\n</cell>\n<text>\n6. Question about\
    \ is_satiated", "  s.split(\" \").each do |word|\n    if word =~ /^I/ then return\
    \ 1 end\n  end\n  return 0\nend", "    bored = 0\n    words = s.split(' ')\n \
    \   bored = (s.include? \"i\")\n    return bored\nend", "  return s.scan(/^I\\\
    b\\W+\\w+\\.\\W+\\w+/).count\nend\n</cell>\n<cell>", "    s = s.dup\n    s <<\
    \ \"\" if s.empty?\n    s.slice!(/\\.|\\s|!/).size\n    s.gsub!(/\\b(I\\b)/, '\\\
    1I')\n    s.gsub!(/\\b(I\\b)/, '\\1I')\n    s.gsub!(/\\b(I\\b)/, '\\1I')\n   \
    \ s.gsub!(/\\b(I\\b)/, '\\1I')\n    s.scan(/\\bI\\b/).size\nend", "  s.chars.each_char.with_object(0)\
    \ do |c, count|\n    count += c == 'I' ? 2 : 0\n  end.nonzero?\nend", "  if s.index('I')==0\
    \ or s.index('!')==0 or s.index('.')==0 or s.index('?')==0\n    return 0\n  end\n\
    \  return s.count('.')+s.count('?')+s.count('!')\nend", "    s.gsub!(/[\\.\\?\\\
    !]/, '') \n    s.scan(/\\bI\\b/i).length <= 1\nend", "  s.gsub!(/[.!?]\\s+/,'')\n\
    \  s.gsub!(/I\\b/,'I')\n  s.count(\"I\")\nend", "    count = 0\n    for i in (s.split(\"\
    \ \"))\n        if i[0]==\"I\"\n            count = count + 1\n    return count\n\
    end", "  s.split(\" \").each do |word|\n    next if word !~ /^I/ or word =~ /\\\
    .|!/ or word =~ /\\.|?/\n    return false if word =~ /\\.|!/ or word =~ /\\.|?/\n\
    \  end\n  true\nend", "  count = 0\n  s.gsub(/[.!?]([A-Z])/, \"\\\\1\").gsub(/([A-Z])([.!?])/,\
    \ \"\\\\1\\\\2\").split(\" \").each do |word|\n    word.upcase! if word.downcase\
    \ == \"I\"\n    count += 1 if word == \"I\" or word == \"I'M\"\n  end\n  return\
    \ count\nend\n</cell>\n<cell>\nassert is_bored(\"Hello world\")  == 0\nassert\
    \ is_bored(\"The sky is blue. The sun is shining. I love this weather\") == 1\n\
    assert is_bored(\"The sky is blue. The sun is shining. I love this weather.\"\
    ) == 1\n</cell>\n<text>\nThe next three functions perform a similar operation,\
    \ except that they count the number of capital letters in each word.", "  s.downcase!\n\
    \  s.gsub!('\\.', '\\.\\.')\n  s.gsub!('\\?', '\\.\\?')\n  s.gsub!('\\!', '\\\
    .\\!')\n  s.gsub!('I ', 'I I')\n  s.scan(/(?:I) ([a-zA-Z\\.\\?\\!]+)/).flatten.each\
    \ do |word|\n    if word[0] == word[0].upcase\n      counts[word] += 1\n    end\n\
    \  end\n  counts.each {|k,v| counts[k] = v if v > 0}\n  counts.max\nend", "  words=s.split()\n\
    \  boredoms=words.find_all { |w| w =~/^I/ }\n  boredoms.count\nend", "  s.count(\"\
    I\") == 0\nend", "  s.downcase!\n  s.gsub!(/[.!?]/,\".\")\n  s.gsub!(/[\\s.,]/,\"\
    \")\n  s.gsub!(/([I])/,\" 1 \")\n  s.gsub!(/(\\s)/,\"1 \")\n  s.downcase!\n  s.gsub!(/([I])/,\"\
    \ 2 \")\n  s.gsub!(/(\\s)/,\"2 \")\n  s.gsub!(/(\\w)/,\"1 #{$1.upcase}\")\n  s.gsub!(/(\\\
    s)/,\"2 \")\n  s.downcase!\n  s.gsub!(/([I])/,\" 3 \")\n  s.gsub!(/(\\s)/,\"3\
    \ \")\n  s.gsub!(/(\\w)/,\"2 #{$1.upcase}\")\n  s.gsub!(/(\\s)/,\"3 \")\n  s.downcase!\n\
    \  s.gsub!(/([I])/,\" 4 \")\n  s.gsub!(/(\\s)/,\"4 \")\n  s.gsub!(/(\\w)/,\"3\
    \ #{$1.upcase}\")\n  s.gsub!(/(\\s)/,\"4 \")\n  s.downcase!\n  s.gsub!(/([I])/,\"\
    \ 5 \")\n  s.gsub!(/(\\s)/,\"5 \")\n  s.gsub!(/(\\w)/,\"4 #{$1.upcase}\")\n  s.gsub!(/(\\\
    s)/,\"5 \")\n  s.downcase!\n  s.gsub!(/([I])/,\" 6 \")\n  s.gsub!(/(\\s)/,\"6\
    \ \")\n  s.gsub!(/(\\w)/,\"5 #{$1.upcase}\")\n  s.gsub!(/(\\s)/,\"6 \")\n  s.downcase!\n\
    \  s.gsub!(/([I])/,\" 7 \")\n  s.gsub!(/(\\s)/,\"7 \")\n  s.gsub!(/(\\w)/,\"6\
    \ #{$1.upcase}\")\n  s.gsub!(/(\\s)/,\"7 \")\n  s.downcase!\n  s.gsub!(/([I])/,\"\
    \ 8 \")\n  s.gsub!(/(\\s)/,\"8 \")\n  s.gsub!(/(\\w)/,\"7 #{$1.upcase}\")\n  s.gsub!(/(\\\
    s)/,\"8 \")\n  s.downcase!\n  s.gsub!(", "  return s.count(\"I\") > s.count(\"\
    .\")\nend\n</cell>\n<cell>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
