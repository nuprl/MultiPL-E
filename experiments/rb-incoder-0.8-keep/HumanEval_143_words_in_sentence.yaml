name: HumanEval_143_words_in_sentence
language: rb
prompt: "# You are given a string representing a sentence,\n# the sentence contains\
  \ some words separated by a space,\n# and you have to return a string that contains\
  \ the words from the original sentence,\n# whose lengths are prime numbers,\n# the\
  \ order of the words in the new string should be the same as the original one.\n\
  # Example 1:\n# Input: sentence = \"This is a test\"\n# Output: \"is\"\n# Example\
  \ 2:\n# Input: sentence = \"lets go for swimming\"\n# Output: \"go for\"\n# Constraints:\n\
  # * 1 <= len(sentence) <= 100\n# * sentence contains only letters\ndef words_in_sentence(sentence)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_in_sentence\n\
  \    candidate = method(:words_in_sentence)\n    assert_equal(\"is\", candidate.call(\"\
  This is a test\"))\n    assert_equal(\"go for\", candidate.call(\"lets go for swimming\"\
  ))\n    assert_equal(\"there is no place\", candidate.call(\"there is no place available\
  \ here\"))\n    assert_equal(\"Hi am Hussein\", candidate.call(\"Hi I am Hussein\"\
  ))\n    assert_equal(\"go for it\", candidate.call(\"go for it\"))\n    assert_equal(\"\
  \", candidate.call(\"here\"))\n    assert_equal(\"is\", candidate.call(\"here is\"\
  ))\n  end\nend\n"
completions: ["  sentence = sentence.downcase\n  words = sentence.split(' ')\n  primes\
    \ = []\n  is_prime = true\n  prime = 0\n  i = 0\n  while i < words.length\n  \
    \  prime = true\n    word = words[i]\n    while i < words.length\n      prime\
    \ = false if prime and words[i].length == prime + 1\n      i += 1\n      prime\
    \ = true if prime and words[i].length == prime - 1\n    end\n    primes << prime\n\
    \  end\n  return \"#{words[0]}#{words[primes.find_index(true)]}\"\nend", "  sentence\
    \ = sentence.downcase\n  res = []\n  n = 4\n  primes = []\n  while n <= 100\n\
    \  n = n + 1\n  i = 2\n  while i <= n and n % i != 0\n  i = i + 1\n  if i == n\n\
    \  primes << n\n  end while\n  n = 4\n  while n <= 100\n  n = n + 1\n  i = 1\n\
    \  while i <= n and n % i != 0\n  i = i + 1\n  if i == n\n  primes << n\n  end\
    \ while\n  primes.each do |i|\n  res = res + sentence.split(\" \").select { |s|\
    \ s.size == i }.sort\n  end\n  sentence\nend", "  return sentence.split(' ').map\
    \ { |w| w.length }.reduce(:+).prime?\nend", "  prime_string = sentence_to_prime_string(sentence)\n\
    \  prime_string.each do |word|\n    return word if is_prime(word.length)\n  end\n\
    \  nil\nend", "  n = sentence.length\n  primes = []\n  for i in (1..n).step(2)\
    \ do\n    primes << i\n  end\n  primes.each do |i|\n    if n % i == 0\n      return\
    \ nil\n    end\n  end\n  result = ''\n  for i in (1..n).step(2) do\n    if n %\
    \ i == 0\n      result = result + sentence.slice!(i..n).to_s\n      return result\n\
    \    end\n  end\n  nil\nend", "    # Write your code here\n    array = sentence.split(\"\
    \ \")\n    unique = []\n    length = array.length\n    i = 0\n    while i < length\n\
    \       unique.push(array[i])\n       i += 1\n    end\n    i = 0\n    while i\
    \ < length\n       if unique[i] !=  unique[i+1]\n           unique.push(unique[i+1])\n\
    \           i += 2\n       end\n       i += 1\n    end\n    return unique.join(\"\
    \ \")\nend", "  new_words = ''\n  words = sentence.split(' ')\n  lengths = (0...words.length).select\
    \ {|n| !n.prime?}.map{|n| words.length - n}\n  new_words += words.select {|w|\
    \ lengths.include? words.length - w.length}.join(' ')\n  new_words += words.select\
    \ {|w| lengths.include? w.length}.join(' ')\n  new_words\nend", "    prime_numbers,\
    \ sorted_word = find_primes_and_sorted_word(sentence)\n    prime_words = []\n\
    \    \n    if sorted_word[-1] == sorted_word[-2]\n        sorted_word.pop\n  \
    \  end\n    \n    prime_words.reverse!", "end\nend", "    # your code here\n \
    \   prime_word_list = prime_numbers(sentence.length)\n    sorted_prime_word_list\
    \ = sort_by_length(prime_word_list)\n    prime_word_list.each_with_index do |prime_word_list_index,\
    \ prime_word_list|\n        string_words = sentence.split(' ')\n        string_words[prime_word_list_index]\
    \ = string_words[prime_word_list_index][0,prime_word_list]\n    end\n    sorted_prime_word_list.each_with_index\
    \ do |sorted_prime_word_list_index, sorted_prime_word_list|\n        string_words\
    \ = sentence.split(' ')\n        string_words[sorted_prime_word_list_index] =\
    \ string_words[sorted_prime_word_list_index][0,sorted_prime_word_list]\n    end\n\
    \    puts string_words.join(' ')\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks\
    \ for your answer. I get this error now \"wrong number of arguments (given 0,\
    \ expected 1)\"\n<|/ c |>\n<| c |>\nI edited my answer to add the missing parentheses\
    \ on the `sort_by_length` call. You could also use `each_cons(2)`, which would\
    \ make it a little more concise.\n<|/ c |>\n<| c |>\nThank you for your answers.\
    \ I edited my question to give you more information. Can you please help me with\
    \ that question?\n<|/ c |>\n<| c |>\nI edited my answer to give an alternative\
    \ method of finding the prime numbers and sorting them. Hopefully it helps! If\
    \ it does, don't forget to accept it as the answer.\n<|/ c |>\n<| a tags=ruby,string\
    \ dscore=0 |>\nThis should be more efficient, since you don't have to create all\
    \ the string splits and joins etc. You can just get the prime numbers directly\
    \ and use those to extract the words. This is much more efficient:\n<code>", " \
    \ sentence = sentence.downcase\n  words = sentence.split(' ')\n  words.map!(&:strip)\n\
    \  words.each do |word|\n    if word.match?(/\\A[a-z]+\\z/i)\n      is_prime =\
    \ true\n      for i in range(2, word.chars.length)\n        if word.chars.include?(word.chars.at(i\
    \ - 1)) && word.chars.include?(word.chars.at(word.chars.length - i))\n       \
    \   is_prime = false\n          break\n        end\n      end\n      if is_prime\n\
    \        words << word\n      end\n    end\n  end\n  words.join(' ')\nend", " \
    \ str1, str2, str3 = nil, nil, nil\n  str1, str2, str3 = sentence.split(\" \"\
    ), nil, nil\n  i = 0\n  while i < str1.length do\n    j = str1.length - 1\n  \
    \  while j > 0 and str1[i] + str1[j] == str1[j-1] do\n      str2 = str2.to_s +\
    \ \" \" + str1[i]\n      j -= 1\n    end\n    i += 1\n  end\n  return str2.gsub(\"\
    \ \", \", \")\nend", "  str = sentence\n  str.downcase!\n  str.gsub!(/[^a-z]/i,\
    \ '') # remove non letters\n  str = str.split(\" \").map{|x| x.gsub!(/[^a-z]/i,\
    \ '')} # remove non letters from words and create new array\n  str.select!{|x|\
    \ x.to_i % 2 == 0} # remove all odd numbered words\n  str = str.map{|x| x.gsub!(/[a-z]/i,\
    \ '')} # remove all non letters\n  str.map!{|x| x.split(\"\").sort!}.join.lstrip.rstrip\n\
    end", "  i = 0\n  primes = Array.new(20)\n  primes[0] = 2 # since 2 <= 0\n  primes[1]\
    \ = 3\n  primes[2] = 5\n  primes[3] = 7\n  primes[4] = 11\n  primes[5] = 13\n\
    \  primes[6] = 17\n  primes[7] = 19\n  primes[8] = 23\n  primes[9] = 29\n  primes[10]\
    \ = 31\n  primes[11] = 37\n  primes[12] = 39\n  primes[13] = 43\n  primes[14]\
    \ = 47\n  primes[15] = 53\n  primes[16] = 59\n  primes[17] = 61\n  primes[18]\
    \ = 67\n  primes[19] = 71 \n  i = 0\n  while i < sentence.length\n    prime =\
    \ primes[i]\n    j = i # i is incremented to find the next prime number\n    while\
    \ j < sentence.length\n      if j + prime > sentence.length\n        break\n \
    \     end\n      primes[j + prime] += 1\n      j += 1\n    end\n    i += 1\n \
    \ end\n  result = \"\"\n  i = 0\n  while i < sentence.length\n    if primes[i]\
    \ == sentence[i].length\n      result << sentence[i]\n    end\n    i += 1\n  end\n\
    \  result\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", "    # Your code here\n \
    \   return \"\"\nend", "\t\n\twords_in_sentence = \"\"\n\tsplitted = sentence.split(\"\
    \ \")\n\t\n\tsplitted.each do |word|\n\t\tif word.length == 2\n\t\t\twords_in_sentence\
    \ += word\n\t\tend\n\tend", "  sentence.split(\" \").map(&:to_i)\nend\n</cell>\n\
    <cell>", "  puts \"Your code here\"\n  puts \"Your code here\"\n  puts \"Your\
    \ code here\"\n  puts \"Your code here\"\nend", "  sentence = sentence.split(\"\
    \ \").join(\"\").chars.to_a\n  n = sentence.length\n  return sentence.reverse\
    \ * n / (2*n + 1)\nend\n</cell>\n<code language=julia-0.5>\nwords_in_sentence(\"\
    This is a test\")\n</cell>\n<code language=julia-0.5>\nwords_in_sentence(\"lets\
    \ go for swimming\")\n</cell>\n<code language=julia-0.5>\nwords_in_sentence(\"\
    lets go for swimming now\")\n</cell>\n<code language=julia-0.5>\nwords_in_sentence(\"\
    lets go for swimming now\")\n</cell>\n<code language=julia-0.5>", "  # Your code\
    \ here\nend\n</pre>\n</div></div><br><br><hr><br>************************<div\
    \ id=\"title\">51 Challenges</div>***********************************************<br>************************<div\
    \ id=\"title\">51 Challenges</div>***********************************************<br>************************<div\
    \ id=\"title\">51 Challenges</div>***********************************************\n\
    <div id=\"content\">\n<p>\nThere are two challenges for this tutorial: 51 Challenges\
    \ covers the topics of Ruby on Rails, 52 Challenges covers the topics of Ruby\
    \ on Rails and Object Oriented Programming.\n</p>\n<ul>\n<li>\n<strong>\nRuby\
    \ on Rails: Basics\n</strong>\n<ul>\n<li>\nWe have to develop a small web application\
    \ with Ruby on Rails,\nthe web application will allow users to submit and view\
    \ their feedbacks.\n</li>\n<li>\nThe database for this project is MongoDB\n</li>\n\
    <li>\nA user should submit his feedbacks through web form,\nthe web form will\
    \ save the feedback in MongoDB,\nthe database will store the feedbacks.\n</li>\n\
    <li>\nThe web application should allow users to see all the submitted feedbacks,\n\
    the web page will list all the feedbacks,\nand the user can click to view the\
    \ feedbacks.\n</li>\n<li>\nThe web application should allow users to see only\
    \ some feedbacks,\nthe web page will list all the feedbacks,\nand the user can\
    \ click to view the feedbacks.\n</li>\n<li>\nThe web application should allow\
    \ users to search for a particular feedback,\nthe web page will list all the feedbacks,\n\
    and the user can click to view the feedbacks.\n</li>\n</ul>\n</li>\n<li>\n<strong>\n\
    Ruby on Rails: Object Oriented Programming\n</strong>\n<ul>\n<li>\nWe have to\
    \ develop a small web application with Ruby on Rails,\nthe web application will\
    \ allow users to submit and view their feedbacks.\n</li>\n<li>\nThe database for\
    \ this project is MongoDB\n</li>\n<li>\nA user should submit his feedbacks through\
    \ web form,\nthe web form will save the feedback in MongoDB,\nthe database will\
    \ store the feedbacks.\n</li>\n<li>\nThe web application should allow users to\
    \ see all the submitted feedbacks,\nthe web page will list all the feedbacks,\n\
    and the user can click to view the feedbacks.\n</li>\n<li>\nThe web application\
    \ should allow users to see only some feedbacks,\nthe web page will list all the\
    \ feedbacks,\nand the user can click to view the feedbacks.\n</li>\n<li>\nThe\
    \ web application should allow users to search for a particular feedback,", " \
    \ words = sentence.split ' '\n  words.each do |word|\n    puts word\n  end\nend",
  "  sentence.split.each do |word|\n    word = word.gsub(/[^a-z]/i, '')\n    if !is_prime?(word.length)\n\
    \      return word\n    end\n  end\nend", "  sentence.split(' ').collect do |word|\n\
    \    puts word.length.to_i\n    if word.length % 2 == 0 && word.length.to_i !=\
    \ 1\n      puts word\n    end\n  end\nend", "  result = \"\"\n  i = 0\n  j = 1\n\
    \  while i <= len(sentence)\n    while j <= i\n      if isPrime(j) and j > 1 and\
    \ j <= len(sentence)\n        result << sentence[i]\n        i += 1\n      j +=\
    \ 2\n    end\n    i += 1\n  end\n  result\nend\n</code>\n<|/ a tags=algorithm,ruby,string\
    \ |>\n<| c |>\nThanks a lot for the detailed explanation! I understood my mistake.\
    \ And also for the helpful comments. Thanks a lot\n<|/ c |>\n<| c |>\n, it's fine,\
    \ glad I could help!\n<|/ c |>\n<| c |>\nIt would be better to not use floating\
    \ point arithmetic, but rather just to check the next number in the range is prime.\
    \  That way you don't need floating point arithmetic at all, and your code is\
    \ more efficient.\n<|/ c |>\n<| c |>\n, thanks, that would be a smart way to approach\
    \ this problem, I'll update my answer to include this improvement.\n<|/ c |>\n\
    <| a dscore=0 tags=algorithm,ruby,string |>\n<code>", "  new_sentence = \"\"\n\
    \  new_sentence = \"\"\n  i = 0\n  while i < len(sentence)\n    if i % 2 != 0\n\
    \      new_sentence += sentence[i]\n      i += 1\n    else \n      new_sentence\
    \ += sentence[i]\n    end\n  end\n  new_sentence\nend\n</cell>\n<code language=julia-1.5>\n\
    sentence = \"lets go for swimming\"\nwords_in_sentence(sentence)\n</cell>\n<code\
    \ language=julia-1.5>", "  # splitting string using space\n  words = sentence.split(\"\
    \ \")\n  # initializing new string\n  new_string = \"\"\n  # looping over every\
    \ word in array\n  words.each do |word|\n    # looping over every char in word\n\
    \    word.chars.each do |char|\n      # if current char is a prime number\n  \
    \    if char.prime?\n        # appending it to new string\n        new_string\
    \ += char.to_s\n      end\n    end\n  end\n  # returning string\n  new_string\n\
    end\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| a tags=ruby |>\n<code>", "    #\
    \ Write your code here\n    splits = sentence.split(\" \")\n    count = 0\n  \
    \  new_splits = []\n    length = 0\n    \n    for i in splits:\n        if  i[:len(i)].isalpha():\n\
    \            count+=1\n            length += 1\n        \n    if count==2:\n \
    \       for i in splits:\n            if  i[:len(i)].isalpha():\n            \
    \    new_splits.append(i)\n    else:\n        count = count/2\n        for i in\
    \ splits:\n            if i[:len(i)].isalpha():\n                new_splits.append(i)\n\
    \        \n    new_splits.reverse()\n    new_string = \" \".join(new_splits)\n\
    \    if length%2==0:\n        new_string = new_string[:len(new_string)-1]\n  \
    \      \n    return new_string\n    \n    ", "  str = ''\n  word_count = {}\n\
    \  words = sentence.split\n  words.each do |word|\n    if (not word_count.has_key?(word))\n\
    \      word_count[word] = 1\n    else\n      word_count[word] += 1\n    end\n\
    \  end\n  word_count.each do |key, value|\n    if (not (str.empty?))\n      str\
    \ << \" \"\n    end\n    str << key\n  end\n  return str\nend", "  \n  # TODO:\
    \ Write your code here\nend", "  puts(\"---\")\n  puts(\"---\")\n  puts(sentence)\n\
    \  puts(\"---\")\n  sentence = sentence.split.map(&:downcase)\n  prime_words =\
    \ nil\n  for i in 0..(sentence.length - 1)\n    puts \"i = #{i}\"\n    prime_word\
    \ = false\n    for j in 0..i\n      if sentence[j] =~ /[a-z]/i\n        prime_word\
    \ = true\n        break\n      end\n    end\n    puts \"prime_word = #{prime_word}\"\
    \n    prime_words ||= []\n    if prime_word\n      prime_words << sentence[j]\n\
    \    end\n  end\n  return sentence.join(\" \")\nend\nputs(words_in_sentence(\"\
    lets go for swimming\"))", "  result = ''\n  words = sentence.split(' ')\n  words.each\
    \ do |word|\n    word = word.chomp\n    next if word.chars.map(&:ord).map{|c|\
    \ c.to_i}.inject(:+) == 0 || word.split(//).inject(:+) == 0\n    result = word\
    \ + ' ' + result unless result.empty?\n  end\n  result.gsub(/\\s+/, '')\nend",
  "    primes = []\n    words_in_sentence = []\n    words = sentence.split(' ')\n\
    \    words.each do |word|\n      prime_letter = word_prime_number(word)\n    \
    \  if prime_letter != nil\n        primes.push(prime_letter)\n      end\n    end",
  "  sentence = sentence.split(\" \").sort\n  result = []\n  while sentence.peek\n\
    \    result << sentence.pop\n    result << sentence.pop\n  end\n  sentence\nend\n\
    <|/ c |>\n<| a tags=arrays,ruby |>\nYou can use #chunk:\n<code>\n s = \"this is\
    \ a test of string splitting function\"\n s.split(\" \").chunk(&:itself).map(&:join)\n\
    \ => [\"this\", \"is\", \"a\", \"test\", \"of\", \"string\", \"splitting\", \"\
    function\"]\n</code>\nIn Ruby 2.4.0, #chunk is defined as :\n<code>", "  s = sentence\n\
    \  new_words = []\n  prime_numbers = []\n  while s !~ /^$/ do\n    puts s\n  \
    \  prime_numbers << s.length\n    puts prime_numbers\n    s = s.gsub(/\\s/,'')\n\
    \  end\n  s.downcase!\n  s.gsub!(/\\s/,'')\n  s.split(' ').each do |word|\n  \
    \  puts word\n    new_words << word\n  end\n  s.gsub!(/\\s/,'')\n  new_words.each\
    \ do |word|\n    prime_numbers.each do |prime|\n      if prime.is_a? Integer\n\
    \        break if prime == word.length\n      end\n    end\n  end\n  return s.split('\
    \ ')\nend\nprint words_in_sentence(\"This is a test\")\nprint words_in_sentence(\"\
    lets go for swimming\")\nprint words_in_sentence(\"This is a test\".upcase)\n\
    print words_in_sentence(\"lets go for swimming\".upcase)\nprint words_in_sentence(\"\
    lets go for swimming\".downcase)\nprint words_in_sentence(\"lets go for swimming\"\
    .downcase.upcase)", "  word_counts = Hash.new(0)\n  sentence.split(' ').inject([]){|words|\
    \ words.push(word.downcase)}.each do |word|\n    word_counts[word] += 1\n  end\n\
    \  word_counts.delete_if{|word, count| count == 0}.sort_by{|word,count| count}.map(&:first)\n\
    end", "  # Split sentence into a list.\n  arr = sentence.split(\" \")\n  # Initialize\
    \ a result array.\n  result = \"\"\n  # Go through each element in the array.\n\
    \  arr.each do |word|\n    # Add the current element to the result.\n    result\
    \ << word\n    # Iterate through the rest of the elements.\n    i = 2\n    until\
    \ arr.reduce(:+) == i\n      result << \" \"\n      i += 1\n    end\n  end\n \
    \ # Return the result.\n  return result\nend", "    # Your code here\n    word\
    \ = sentence.split(\" \").map(&:chars).join(\" \")\n    leng = word.length.to_i\n\
    \    leng = Math.sqrt(leng)\n    leng.times do |i|\n        if (word.index(i,\
    \ i + leng).nil?)\n            puts \"#{word[i]}\"\n        end\n    end\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI think this solution is wrong.\
    \ Try `words_in_sentence('this is')`\n<|/ c |>\n<| c |>\n, oh, yes, of course,\
    \ thank you\n<|/ c |>\n<| a dscore=0 |>\nI would just use reduce and take the\
    \ first word from each chunk. \n<code>", end, "  new_list = []\n  word_list =\
    \ sentence.split(\" \")\n  \n  word_list.each do |word|\n    new_list << word\n\
    \    \n    len1 = word.length\n    len2 = 1\n    \n    while len2 <= len1\n  \
    \    if word.include? len2\n        new_list.delete(len)\n      elsif len2 ==\
    \ len1\n        new_list.delete(len2)\n      end\n      \n      len2 += 1\n  \
    \  end\n  end\n  \n  new_list.each do |word|\n    word_list.delete(word)\n  end\n\
    \  \n  word_list.each do |word|\n    word_list.push(word)\n  end\n  \n  word_list.join(\"\
    \ \")\nend", "  # split sentence to an array using spaces as delimiters\n  sentence_array\
    \ = sentence.split(\" \")\n  # start storing result\n  result = []\n  # iterate\
    \ over words in sentence\n  sentence_array.each do |word|\n    # check if current\
    \ word is a prime number\n    prime_number_word?(word)\n    # append current word\
    \ to result\n    result << word\n  end\n  # return result\n  result.join(\" \"\
    )\nend", "    sentence.split.each do |word|\n        word.split(\"\").length.each\
    \ do |length|\n            if length == 1 && (word[0..0] == \"s\" || word[0..0]\
    \ == \"h\" || word[0..0] == \"i\")\n                word[0..0] + word[1..-1]\n\
    \            elsif length == 2 && (word[0..0] == \"l\" || word[0..0] == \"o\"\
    \ || word[0..0] == \"g\")\n                word[0..0] + word[1..-1]\n        \
    \    elsif length == 3 && (word[0..0] == \"t\" || word[0..0] == \"h\")\n     \
    \           word[0..0] + word[1..-1]\n            elsif length == 4 && (word[0..0]\
    \ == \"w\" || word[0..0] == \"e\" || word[0..0] == \"r\" || word[0..0] == \"m\"\
    )\n                word[0..0] + word[1..-1]\n            elsif length == 5 &&\
    \ word[0..0] == \"i\" && word[1..-1] == \"s\"\n                word[0..0] + word[1..-1]\n\
    \            elsif length == 6 && word[0..0] == \"g\" && word[1..-1] == \"s\"\n\
    \                word[0..0] + word[1..-1]\n            elsif length == 7 && word[0..0]\
    \ == \"f\" && word[1..-1] == \"i\"\n                word[0..0] + word[1..-1]\n\
    \            elsif length == 8 && (word[0..0] == \"o\" || word[0..0] == \"r\"\
    \ || word[0..0] == \"m\")\n                word[0..0] + word[1..-1]\n        \
    \    elsif length == 9 && (word[0..0] == \"a\" || word[0..0] == \"s\" || word[0..0]\
    \ == \"e\")\n                word[0..0] + word[1..-1]\n            elsif length\
    \ == 10 && word[0..0] == \"i\" && word[1..-1] == \"r\"\n                word[0..0]\
    \ + word[1..-1]\n            elsif length == 11 && (word[0..0] == \"s\" || word[0..0]\
    \ == \"w\" || word[0..0] == \"e\" || word[0..0] == \"r\" || word[0..0] == \"m\"\
    )\n                word[0..0] + word[1..-1]\n            elsif length == 12 &&\
    \ (word[0..0] == \"g\" || word[0..0] == \"f\" || word[0..0] == \"i\")\n      \
    \          word[0..0] + word[1..-1]\n            elsif length == 13 && (word[0..0]\
    \ == \"f\" || word[0.", "  arr = sentence.split(\" \")\n  out = \"\"\n  arr_rev\
    \ = arr.reverse\n  arr_rev.each do |x|\n    if x.length == 2\n      out << x[0]\n\
    \      out << x[1]\n    end\n  end\n  return out\nend", "    str.split(sentence,\
    \ ' ').map { |word| word.length }.reduce(:&).to_s\nend", "    # Write your code\
    \ here\n    str = sentence.split(\" \")\n    str1 = []\n    \n    for i in str:\n\
    \        if (i.isalpha()):\n            str1.append(i)\n            \n    final\
    \ = []\n    \n    for i in str1:\n        if ((len(i) == 2) or (len(i) == 3)):\n\
    \            final.append(i)\n    \n    return \" \".join(final)", "\tsentence.split(\"\
    \ \").map do |word|\n\t\tword.chars.select.with_index { |x,i| i % 2 == 0 }.first\n\
    \tend.join(' ')\nend", "\twords = []\n\tnew_sentence = \"\"\n\tfor word in sentence.split(\"\
    \ \")\n\t\tletters = word.split(\"\")\n\t\tif letters.each do |letter|\n\t\t\t\
    if letters.length % 2 == 0 \n\t\t\t\tword = letters.last(letters.length / 2).join(\"\
    \")\n\t\t\t\twords.push(word)\n\t\t\t\tnew_sentence += word\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn new_sentence\nend\n<|/ file source=github dstars=0 |>\n<| c |>\n\
    Please add the example input/output and show us where exactly the code is not\
    \ working for you so that we can help you\n<|/ c |>\n<| c |>\nIt's not necessary\
    \ to iterate over an array with `each` just to find the last element in the array.\
    \ Just use `letters.last`.\n<|/ c |>\n<| a |>\nTo achieve this result, I used\
    \ the each_with_index method to iterate through the words and check if the current\
    \ word is an even number. If it is, then I get the last 2 letters of the current\
    \ word and concatenate them to the new array. \n<code>\nsentence = \"lets go for\
    \ swimming\"\nsentence.split.each_with_index do |word,index|\n  if word.length\
    \ % 2 == 0\n    evenWord = word.last(word.length/2)\n    newArray << evenWord\n\
    \  end\nend\nnewArray.join(\" \")", "    sentence = sentence.split(' ')\n    result\
    \ = \"\"\n    result.gsub!('a', '', 1)\n    result.gsub!('b', '', 1)\n    result.gsub!('c',\
    \ '', 1)\n    result.gsub!('d', '', 1)\n    result.gsub!('e', '', 1)\n    result.gsub!('f',\
    \ '', 1)\n    result.gsub!('g', '', 1)\n    result.gsub!('h', '', 1)\n    result.gsub!('i',\
    \ '', 1)\n    result.gsub!('j', '', 1)\n    result.gsub!('k', '', 1)\n    result.gsub!('l',\
    \ '', 1)\n    result.gsub!('m', '', 1)\n    result.gsub!('n', '', 1)\n    result.gsub!('o',\
    \ '', 1)\n    result.gsub!('p', '', 1)\n    result.gsub!('q', '', 1)\n    result.gsub!('r',\
    \ '', 1)\n    result.gsub!('s', '', 1)\n    result.gsub!('t', '', 1)\n    result.gsub!('u',\
    \ '', 1)\n    result.gsub!('v', '', 1)\n    result.gsub!('w', '', 1)\n    result.gsub!('x',\
    \ '', 1)\n    result.gsub!('y', '', 1)\n    result.gsub!('z', '', 1)\n    result.gsub!('\
    \ ', '')\n    result.gsub!(',', '', 1)\n    result.gsub!('.', '', 1)\n    result.gsub!('!',\
    \ '', 1)\n    result.gsub!('?', '')\n    result.gsub!(':', '')\n    result.gsub!(';',\
    \ '')\n    result.gsub!(' ', '')\n    result.gsub!(',', '', 1)\n    result.gsub!('.',\
    \ '', 1)\n    result.gsub!('!', '', 1)\n    result.gsub!('?', '')\n    result.gsub!(':',\
    \ '')\n    result.gsub!(';', '')\n    result.gsub!(' ', '')\n    result.gsub!(',',\
    \ '', 1)\n    result.gsub!('.', '', 1)\n    result.gsub!('!', '', 1)\n    result.gsub!('?',\
    \ '')\n    result.gsub!(':', '')\n    result.gsub!(';', '')\n    result.gsub!('\
    \ ', '')\n    result.gsub!(',', '', 1)\n    result.gsub!('.', '', 1)\n    result.gsub!('!',\
    \ '', 1)\n    result.gsub!('?', '')\n    result.gsub!(':', '')\n    result.gsub!(';',\
    \ '')\n    result.g", "    # Write your code here.\n    letters = sentence.scan(/[a-z]/)\n\
    \    string = \"\"\n    \n    i = 0\n    while i < letters.length\n        \n\
    \        if letters[i] == \"a\"\n            string = string + \"a\"\n       \
    \     i +=1\n        else if letters[i] == \"e\"\n            string = string\
    \ + \"e\"\n            i +=1\n        else if letters[i] == \"i\"\n          \
    \  string = string + \"i\"\n            i +=1\n        else if letters[i] == \"\
    o\"\n            string = string + \"o\"\n            i +=1\n        else if letters[i]\
    \ == \"u\"\n            string = string + \"u\"\n            i +=1\n        else\
    \ if letters[i] == \"A\"\n            string = string + \"A\"\n            i +=1\n\
    \        else if letters[i] == \"E\"\n            string = string + \"E\"\n  \
    \          i +=1\n        else if letters[i] == \"I\"\n            string = string\
    \ + \"I\"\n            i +=1\n        else if letters[i] == \"O\"\n          \
    \  string = string + \"O\"\n            i +=1\n        else if letters[i] == \"\
    U\"\n            string = string + \"U\"\n            i +=1\n        else if letters[i]\
    \ == \"1\"\n            string = string + \"1\"\n            i +=1\n        else\
    \ if letters[i] == \"2\"\n            string = string + \"2\"\n            i +=1\n\
    \        else if letters[i] == \"3\"\n            string = string + \"3\"\n  \
    \          i +=1\n        else if letters[i] == \"4\"\n            string = string\
    \ + \"4\"\n            i +=1\n        else if letters[i] == \"5\"\n          \
    \  string = string + \"5\"\n            i +=1\n        else if letters[i] == \"\
    6\"\n            string = string + \"6\"\n            i +=1\n        else if letters[i]\
    \ == \"7\"\n            string = string + \"7\"\n            i +=1\n        else\
    \ if letters[i] == \"8\"\n            string = string + \"8\"\n            i +=1\n\
    \        else if letters[i] == \"9\"\n            string = string + \"9\"\n  \
    \          i +=1\n        else if letters[i] == \"0\"\n            string = string\
    \ + \"0\"\n            i +=1\n        else if letters[i] == \" \"\n          \
    \  i +=1\n        else if letters[i] == \"\\n\"\n            i +=1\n        else\n\
    \            i += 1\n            \n    string.length\n    \n    \nend", "  sentence\
    \ = sentence.split(\" \").map{ |word| word.tr(\"a-z\", \"\") }\n  sentence.reduce(:\"\
    a\") { |acc, word| acc + \" \" + word } # => \"is\"\nend", "  n = sentence.length\n\
    \  primes = []\n  for i in 2..n do\n    if n % i == 0 then\n      primes << i\n\
    \    end\n  end\n  return(sentence.split(' ').map {|word| primes.include?(word.length)\
    \ ? word : nil }.compact.join(\" \"))\nend", end, "  sentence = sentence.split(\"\
    \ \").map(&:downcase).join(\" \")\n  primes = PrimeCalculator.new(sentence)\n\
    \  primes.primes.map {|s| sentence.split(\" \").map {|w| w if s == w}}.join(\"\
    \ \")\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,algorithm,string |>\n<| a tags=ruby,ruby-on-rails,algorithm,string\
    \ dscore=0 |>\nTry this:\n<code>", "  word = nil\n  sentence = sentence.downcase\n\
    \  words = sentence.split(' ')\n  new_sentence = words[0]\n  new_words = new_sentence.split('\
    \ ')\n  new_words.each do |word|\n    if !word.include?(' ').nil? && !word.empty?\n\
    \      new_length = word.length\n      new_length2 = new_length + 2\n      new_length2\
    \ = new_length2.to_i\n      word = word.split(' ').inject(1) do |sum, word|\n\
    \        sum += word.length\n        sum\n      end\n      word = word.to_i\n\
    \      word = new_length2\n      while word >= 2 do\n        if word % 2 == 1\n\
    \          new_sentence << \" \"\n        end\n        word /= 2\n      end\n\
    \    end\n  end\n  new_sentence\nend", "    # Your code here\n    l = sentence.split(\"\
    \ \").length\n    primes = []\n    i = 1\n    while i <= l\n        if i**2 ==\
    \ l\n            primes.push i\n        end\n        i += 1\n    end\n    primes.sort.each\
    \ do |x| \n        words_in_sentence = sentence.split(\" \").map{|y| y}.grep {\
    \ |z| z.length == x}\n        return words_in_sentence.join(' ')\n    end\n  \
    \  return nil\nend\n</code>\n<|/ a |>\n<| a tags=ruby,string dscore=0 |>\nJust\
    \ to clarify and explain what everyone else has said, Ruby has a great library\
    \ for solving this problem. Namely, the Enumerable module.\n<code>\nsentence =\
    \ \"This is a test\"\nsentence.split.select do |word|\n  word.split.length ==\
    \ 1\nend.join(' ')", "    # Write your code here\n    result = sentence.split(\"\
    \ \").collect{|x| x.downcase.chars.to_a.inject{|s,c| s+c}.to_i}.select{|x| x %\
    \ 2 != 0}.sort.join\nend", end, "  result = \"\"\n  word = \"\"\n  count = 0",
  "  new_sentence = ''\n  length_of_sentence = sentence.length\n  sentence_array =\
    \ sentence.split(' ')\n  length_of_sentence_array = sentence_array.length\n  count\
    \ = 0", "    # initialize result\n    result = \"\"\n    # find all primes\n \
    \   primes = PrimeFactors.primeFactors(sentence.length)\n    # check all primes\
    \ in sentence\n    primes.each do |prime|\n        # check current prime in sentence\n\
    \        count = 0\n        sentence.split(\" \").each do |word|\n           \
    \ if word.length == prime && word =~ /^#{prime}$/\n                count += 1\n\
    \            end\n        end\n        # append current prime to result\n    \
    \    result = result + prime if count == sentence.length\n    end\n    # return\
    \ result\n    result\nend\n</code>\n<|/ a dscore=0 tags=string,ruby |>\n<| a dscore=0\
    \ |>\nThis question is not quite clear but from what I understand, this is a possible\
    \ solution.\n<code>", "  a = sentence.split(\" \").sort\n  a.join('')\nend\n</cell>\n\
    <code language=julia-1.0>\nsentence = \"This is a test\"\n</cell>\n<code language=julia-1.0>\n\
    words_in_sentence(sentence)\n</cell>\n<code language=julia-1.0>\nsentence = \"\
    lets go for swimming\"\n</cell>\n<code language=julia-1.0>\nwords_in_sentence(sentence)\n\
    </cell>\n<code language=julia-1.0>\nsentence = \"lets go for swimming to\"\n</cell>\n\
    <code language=julia-1.0>\nwords_in_sentence(sentence)\n</cell>\n<code language=julia-1.0>\n\
    sentence = \"lets go for swimming to school\"\n</cell>\n<code language=julia-1.0>\n\
    words_in_sentence(sentence)\n</cell>\n<code language=julia-1.0>\nsentence = \"\
    lets go for swimming to school\"\n</cell>\n<code language=julia-1.0>\nwords_in_sentence(sentence)\n\
    </cell>\n<code language=julia-1.0>\nsentence = \"lets go for swimming to school\"\
    \n</cell>\n<code language=julia-1.0>\nwords_in_sentence(sentence)\n</cell>\n<code\
    \ language=julia-1.0>\nsentence = \"lets go for swimming to school to\"\n</cell>\n\
    <code language=julia-1.0>\nwords_in_sentence(sentence)\n</cell>\n<code language=julia-1.0>\n\
    sentence = \"lets go for swimming to school to go to\"\n</cell>\n<code language=julia-1.0>\n\
    words_in_sentence(sentence)\n</cell>\n<code language=julia-1.0>\nsentence = \"\
    lets go for swimming to school to go to school\"\n</cell>\n<code language=julia-1.0>\n\
    words_in_sentence(sentence)\n</cell>\n<code language=julia-1.0>\nsentence = \"\
    lets go for swimming to school to go to school to\"\n</cell>\n<code language=julia-1.0>\n\
    words_in_sentence(sentence)\n</cell>\n<text>\n12. Write a function that splits\
    \ a string into a set of substrings delimited by an arbitrary string. For example,\
    \ given input of \"aabbcc\", and delimiters of \"ab\", the result would be [\"\
    aa\",\"b\",\"cc\"].", "  sentence.split.each do |word|\n    next if word.split(\"\
    \ \").all? { |s| s.include?(letter) }\n    puts word if is_prime?(word.length.to_i)\n\
    \  end\nend", "    # write your code here\n    words = sentence.split(\" \")\n\
    \    result = \"\"\n    candidates = candidates_primes_for(len(words))\n    sorted_candidates\
    \ = sort_by_prime(candidates)\n    i = 0\n    while i < len(sorted_candidates):\n\
    \        if sorted_candidates[i] == 1:\n            result += \" \" + words[i]\n\
    \            i += 1\n        if sorted_candidates[i] == len(words):\n        \
    \    break\n    return result\n</cell>\n<cell>", "  words = sentence.split(\"\
    \ \").to_a\n  words.compact!\n  words_in_sentence_helper(words)\nend", "    words\
    \ = []\n    i = 0\n    while i < sentence.length\n        if sentence[i].is_alpha?\n\
    \            word = sentence[i].to_sym\n            if words_in_sentence.include?\
    \ word\n                next\n            else\n                words_in_sentence\
    \ << word\n            end\n        else\n            next\n        end\n    \
    \    i += 1\n    end\n    words.join\nend", "    # initialize a new array which\
    \ will hold our new words\n    word_list = Array.new(100) # Array.new(100)\n \
    \   # initialize a counter\n    counter = 0\n    # loop over the length of the\
    \ sentence\n    sentence.length.times do |index|\n        # if a space is found,\
    \ add it to the array\n        if sentence.chars[index] == 32\n            word_list[counter]\
    \ = sentence.slice(index, index+1)\n            counter += 1\n        # if the\
    \ character is not a space, increment the counter\n        else\n            counter\
    \ += 1\n        end\n    end\n    # return the new array\n    return word_list\n\
    end", "  str1 = sentence.split\n  str2 = []\n  str3 = []\n  str4 = str1.map do\
    \ |x|\n    x.split(\" \").map do |y|\n      y.to_i\n    end\n  end\n  str4.each\
    \ do |i|\n    if i.all?{|j| j.is_a? Integer} == false\n      str3 << i\n    end\n\
    \  end\n  str3.flatten!\n  str3.uniq\n  str3.each do |i|\n    str2 << i\n  end\n\
    \  str2.map do |i|\n    sentence = sentence.replace(i, \"\")\n  end\n  str2.join(\"\
    \ \")\nend", "    sentence = sentence.downcase.split(\" \").join(\" \")\n    primes\
    \ = \"2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101\
    \ 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197\
    \ 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311\
    \ 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431\
    \ 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557\
    \ 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661\
    \ 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809\
    \ 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937\
    \ 941 947 953 967 971 977 983 991\"\n    return sentence.split(' ').select do\
    \ |word|\n      primes.include?(word.length.to_i)\n    end.join(' ')\n  end\n\
    end\n</code>\nI made it an example using the above script:\n<code>\nputs words_in_sentence('this\
    \ sentence will contain some words')", "  return \"prime\"\nend", "    # Your\
    \ code here\n    str = sentence.split()\n    str.each do |word|\n      str2 =\
    \ []\n      str2.push word\n      str2.each do |word|\n        if word.chars.to_a.uniq.count(word)\
    \ == word.chars.to_a.uniq.count('a') + 1\n          str2.push(word)\n        end\n\
    \      end\n      str2.each do |word|\n        str2.each_with_index do |word,\
    \ index|\n          str2.each do |word|\n            str2.each_with_index do |word,\
    \ index|\n              if index == str.index(word)\n                str2.delete(word)\n\
    \              end\n            end\n          end\n        end\n      end\n \
    \   end\n    str.each_index do |index|\n      if str.include?(index)\n       \
    \ str.remove(index)\n      end\n    end\n    str.each do |word|\n      str2 =\
    \ []\n      str2.push word\n      str2.each do |word|\n        if word.chars.to_a.uniq.count(word)\
    \ == word.chars.to_a.uniq.count('a') + 1\n          str2.push(word)\n        end\n\
    \      end\n      str2.each do |word|\n        str2.each_with_index do |word,\
    \ index|\n          str2.each do |word|\n            str2.each_with_index do |word,\
    \ index|\n              if index == str.index(word)\n                str2.delete(word)\n\
    \              end\n            end\n          end\n        end\n      end\n \
    \   end\n    str.each_index do |index|\n      if str.include?(index)\n       \
    \ str.remove(index)\n      end\n    end\n    str.each do |word|\n      str2 =\
    \ []\n      str2.push word\n      str2.each do |word|\n        if word.chars.to_a.uniq.count(word)\
    \ == word.chars.to_a.uniq.count('a') + 1\n          str2.push(word)\n        end\n\
    \      end\n      str2.each do |word|\n        str2.each_with_index do |word,\
    \ index|\n          str2.each do |word|\n            str2.each_with_index do |word,\
    \ index|\n              if index == str.index(word)\n                str2.delete(word)\n\
    \              end\n            end\n          end\n        end\n      end\n \
    \   end\n    str.each_index do |index|\n      if str.include?(index)\n       \
    \ str.remove(index)\n      end\n    end\n    str.each do |word|\n      str2 =\
    \ []\n      str2.push word\n      str2.each do |word|\n        if word.chars.to_a.uniq.count(word)\
    \ == word.chars.", "  str=sentence.split(' ')\n  new_str=''\n  new_str+=str.first\n\
    \  new_str+=str.drop(1)\n  new_str+=str.drop(2)\n  new_str+=str.drop(3)\n  new_str+=str.drop(4)\n\
    \  new_str+=str.drop(5)\n  new_str+=str.drop(6)\n  new_str+=str.drop(7)\n  new_str+=str.drop(8)\n\
    \  new_str+=str.drop(9)\n  new_str+=str.drop(10)\n  new_str+=str.drop(11)\n  new_str+=str.drop(12)\n\
    \  new_str+=str.drop(13)\n  new_str+=str.drop(14)\n  new_str+=str.drop(15)\n \
    \ new_str+=str.drop(16)\n  new_str+=str.drop(17)\n  new_str+=str.drop(18)\n  new_str+=str.drop(19)\n\
    \  new_str+=str.drop(20)\n  new_str+=str.drop(21)\n  new_str+=str.drop(22)\n \
    \ new_str+=str.drop(23)\n  new_str+=str.drop(24)\n  new_str+=str.drop(25)\n  new_str+=str.drop(26)\n\
    \  new_str+=str.drop(27)\n  new_str+=str.drop(28)\n  new_str+=str.drop(29)\n \
    \ new_str+=str.drop(30)\n  new_str+=str.drop(31)\n  new_str+=str.drop(32)\n  new_str+=str.drop(33)\n\
    \  new_str+=str.drop(34)\n  new_str+=str.drop(35)\n  new_str+=str.drop(36)\n \
    \ new_str+=str.drop(37)\n  new_str+=str.drop(38)\n  new_str+=str.drop(39)\n  new_str+=str.drop(40)\n\
    \  new_str+=str.drop(41)\n  new_str+=str.drop(42)\n  new_str+=str.drop(43)\n \
    \ new_str+=str.drop(44)\n  new_str+=str.drop(45)\n  new_str+=str.drop(46)\n  new_str+=str.drop(47)\n\
    \  new_str+=str.drop(48)\n  new_str+=str.drop(49)\n  new_str+=str.drop(50)\n \
    \ new_str+=str.drop(51)\n  new_str+=str.drop(52)\n  new_str+=str.drop(53)", " \
    \ word_list = sentence.split(\" \")\n  string = \"\"\n  result = \"\"\n  word_list.each\
    \ do |word|\n    if word.chars.count == 1\n      result << word\n    elsif word.length\
    \ == 1\n      result << word\n    end\n  end\n  result\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby,algorithm |>\n<code>", "  words = []\n  words = sentence.split('\
    \ ')\n  p =''\n  new_sentence = ''\n  new_sentence.concat words[0]\n  new_sentence.concat\
    \ ' '\n  for i =1 to words.length-1\n    new_sentence.concat words[i]\n    new_sentence.concat\
    \ ' '\n    if i%2==0\n      p += words[i].length\n    elsif p==words[i].length\n\
    \      p += words[i].length\n    end\n  end\n  return new_sentence\nend", "  sentence\
    \ = sentence.split(//)\n  word_count = {}\n  word_count[\"is\"] = 2\n  word_count[\"\
    let\"] = 2\n  word_count[\"go\"] = 2\n  word_count[\"for\"] = 2\n  word_count[\"\
    swimming\"] = 3\n  word_count[\"s\"] = 1\n  word_count[\"w\"] = 1\n  word_count[\"\
    m\"] = 1\n  word_count[\"y\"] = 1\n  word_count[\"e\"] = 1\n  word_count[\"t\"\
    ] = 1\n  word_count[\"h\"] = 1\n  word_count[\"i\"] = 1\n  word_count[\"n\"] =\
    \ 1\n  word_count[\"g\"] = 1\n  word_count[\"m\"] = 1\n  word_count[\"r\"] = 1\n\
    \  word_count[\"i\"] = 1\n  word_count[\"m\"] = 1", "  \n  sentence_array = sentence.split\n\
    \  \n  result = \"\"\n  \n  new_array = sentence_array.map do |word|\n    word_length\
    \ = word.length\n    \n    word.chars.reduce(:**).to_i if word_length % 2 == 1\n\
    \  end\n  \n  new_array.uniq.sort\n  \n  sentence_array.each do |word|\n    word_length\
    \ = word.length\n    \n    word.chars.reduce(:**).to_i if word_length % 2 == 1\n\
    \  end\n  \n  sentence_array.each do |word|\n    word_length = word.length\n \
    \   \n    word.chars.reduce(:**).to_i if word_length % 2 == 1\n  end\n  \n  new_array.each\
    \ do |word_length|\n    word_length = word_length\n    \n    word.chars.reduce(:**).to_i\
    \ if word_length % 2 == 1\n  end\nend", "  # Your code here\n  \nend", "  # Your\
    \ code here\n  prime_words = []\n  words = sentence.split(\" \")\n  word_numbers\
    \ = []\n  for word in words\n    if word.length == prime_words.length\n      if\
    \ word.to_s == prime_words.to_s\n        prime_words.push(word)\n        word_numbers.push(prime_words.length)\n\
    \      end\n    end\n  end\n  prime_words.uniq = word_numbers\n  prime_words.flatten!\n\
    \  prime_words.sort!\n  prime_words.uniq!\n  prime_words.join(\" \")\nend", " \
    \   arr = sentence.split(\" \")\n    primes = []\n    \n    for num in arr\n \
    \       if prime? num\n            primes << num\n    \n    return primes.join(\"\
    \ \")\nend", "  arr = sentence.split(' ')\n  arr.map { |word| word.length.prime?\
    \ ? word : nil }.join(\" \")\nend", "  res = []\n  n = sentence.length\n  for\
    \ i in 1..n\n    if sentence[i - 1].to_i % i == 0 and sentence[i - 2].to_i % i\
    \ == 0\n      res << sentence[i - 2].to_s\n    end\n  end\n  return res.join(\"\
    \ \")\nend\n</code>\n<|/ a tags=ruby,primes |>\n<| a |>\n<code>", "  str_a = sentence.split\
    \ \" \"\n  str_b = str_a.map {|w| w.chars.map(&:to_i).max }\n  result = str_b.sort.map\
    \ {|w| str_a.find {|w| w.to_i == w}.to_s.size }\n  result.max_by {|w| w}\nend",
  "    primes = []\n    array = sentence.split(\" \") # Split sentence into a list\n\
    \    array.each do |element| # loop through list elements\n        primes = prime\
    \ primes # recalculate primes every loop iteration\n    end\n    primes.join(\"\
    \ \")\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays,primes |>\n<| a |>\nHere's\
    \ my attempt.\n<code>", "    words = sentence.split(\" \")\n    prime_words =\
    \ []\n    prime_words = []\n    prime_words = []\n    prime_words.push words[0]\n\
    \    for i in 1...words.length\n        if words[i].length != words[i - 1].chars.length\n\
    \            prime_words.push words[i]\n            words[i]\n            words[i\
    \ - 1]\n        end\n    end\n    return prime_words.join(\" \")\nend", "    #\
    \ write your code here\n    # return\nend\n</cell>\n<code language=julia-1.0>",
  "  sentence = sentence.split ' '\n  sentence = sentence.join\n  sentence.length.prime?\
    \ sentence.length\nend\n</cell>\n<code language=julia-1.3>\nwords_in_sentence(\"\
    this is a test\")\n</cell>\n<code language=julia-1.3>\nwords_in_sentence(\"lets\
    \ all go for swimming\")\n</cell>\n<text>\n9. Longest Substring Without Repeating\
    \ Characters", "    sentence.split(\" \").select do |x|\n      prime? x.length\n\
    \    end.join(\" \")\nend", "    word_array = sentence.split(\" \")\n    word_array.sort!\n\
    \    return word_array.join(\" \")\nend", "  # Solution using Ruby\n  result =\
    \ sentence.split.map(&:to_s).select { |w| w.prime? }\n  result = result.join\n\
    \  result.length > 0 ? result : \"no prime numbers\"\n  # Solution using Python\
    \ 3\n  words = sentence.split()\n  result = ' '.join([w for w in words if w.prime])\n\
    \  return result if len(result) > 0 else \"no prime numbers\"\nend\n</cell>\n\
    <code language=julia-1.0>\nwords_in_sentence(\"This is a test\")\n</cell>\n<code\
    \ language=julia-1.0>\nwords_in_sentence(\"lets go for swimming\")\n</cell>\n\
    <code language=julia-1.0>\nwords_in_sentence(\"This is a test. Lets see how it\
    \ goes.\")\n</cell>\n<code language=julia-1.0>\nwords_in_sentence(\"This is a\
    \ test. Lets see how it goes.\", limit=3)\n</cell>\n<code language=julia-1.0>\n\
    words_in_sentence(\"Lets see how it goes.\", limit=3)\n</cell>\n<text>\nThe Prime\
    \ Number Test\nThe idea here is that if we find any word that is not prime,\n\
    then we can stop the loop and\nthen we can start with the next word\nby not continuing\
    \ the loop if the word is Prime\nTo speed up the process, we only need to check\
    \ odd numbers. \nIn fact, we also need to find the first odd number\nWe also need\
    \ to find all primes up to sqrt(n)\nWe can do all this by using a sieve of Eratosthenes\
    \ algorithm.", "    arr = sentence.split(\" \")\n    arr1 = []\n    arr2 = []\n\
    \    count = 0\n    arr2.append(arr[0])\n    arr2.extend(arr[1:])\n    i = 0\n\
    \    while(i < len(arr2)):\n        if(isPrime(arr2[i])):\n            arr1.append(arr2[i])\n\
    \            count += 1\n        i += 1\n    s = \" \".join(arr1)\n    return\
    \ s\n</code>\n<|/ a |>\n<| a tags=ruby,primes,python,algorithm,rubygems |>\nMy\
    \ answer is a bit late, but I've spent all day yesterday trying to figure out\
    \ a Ruby solution, and finally got it after a lot of head scratching. Hopefully\
    \ this will be of use to someone else down the road.\n<code>", "  words = []\n\
    \  splits = sentence.split(\" \")\n  splits.each do |x|\n    if x.split(\" \"\
    ).prime_number?\n      words.append(x)\n    end\n  end\n  return words.join(\"\
    \ \")\nend", "  return sentence.split(' ').map {|word| word.length}.uniq\nend",
  "  \n  count = 0\n  str = ''\n  \n  sentence.downcase!\n  words = sentence.split.to_a\n\
    \  \n  for i in 0..words.count-1\n    \n    while str.length != words[i].length\n\
    \      if str.length == 0\n        str = str + words[i]\n      end\n      break\n\
    \    end\n    \n    break if str.length == words[i].length\n    \n    if words[i].is_prime?\n\
    \      count = count + 1\n    end\n  end\n  \n  str\nend\n\"\"\"\n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\
    \  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  ", "  s = sentence.split(\" \"\
    ).map { |w| w.to_i }\n  s.min\n  s.max\n  sentence.join(\" \").split(\" \").map\
    \ { |w| w[s.min..s.max] }.uniq\nend", "    arr = sentence.split\n    arr.map!\
    \ do |x|\n        x.split(//).each_with_object({}) do |y, obj|\n            obj[y]\
    \ ||= 1\n        end\n    end\n    arr.sort_by! do |x|\n        x[1]\n    end\n\
    \    arr.map! do |x|\n        x.first\n    end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=string,ruby,arrays,primes |>\n<code>", "  str=sentence.split(\" \")\n\
    \  str.map!{|x|x.chars.map{|x|x.to_i}}\n  str.join\nend", "  \n  \n  # Split words\
    \ by a space character\n  # and store each word in the array\n  words = sentence.split\n\
    \  \n  # Return an array with lengths that are prime numbers\n  # and order of\
    \ the words should be the same as in sentence\n  return words.select { |w| w.chars.all?\
    \ { |c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' } }\nend", " \
    \ sentence = sentence.split # split sentence by space\n  sorted_words = sentence.reverse\
    \ # reverse sentence\n  sorted_words.select { |word| word.length == 2 } # select\
    \ words with length of 2\nend", "  sentence\nend", "    # Your code here\n   \
    \ words = sentence.split(\" \")\n    prime_words = []\n    prime_words = [i for\
    \ i in words if len(i) == 2]\n    new_words = []\n    new_words = [i for i in\
    \ prime_words if not (any(letter.isalpha() for letter in i))]\n    new_words.insert(0,\"\
    and\")\n    return \" \".join(new_words)", "  n = sentence.split(' ').size\n \
    \ s = sentence.split(' ')\n  s.size.times do |i|\n    if s[i].to_s.chars.map(&:ord).uniq.size\
    \ == 1\n      n = n-1\n    else\n      return s[i].to_s\n    end\n  end\nend\n\
    </code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nThis code only finds one word per\
    \ sentence.  Try `sentence = \"The quick brown fox jumps over the lazy dog\"`.\n\
    <|/ c |>\n<| c |>\nThanks for pointing out that error, I edited my answer and\
    \ added another solution that should work now.\n<|/ c |>\n<| a dscore=0 |>\nHere's\
    \ one way using Enumerable#chunk:\n<code>\nsentence = \"lets go for swimming\"",
  "  s = sentence.split(\" \").map(&:to_i)\n  s.sort.reduce(&:+).to_s\nend", "  count\
    \ = 0\n  res = []\n  sentence.each_char.with_index do |char,i|\n    if char ==\
    \ ' ' then\n      count += 1\n    else\n      res += [char] if count % i == 0\n\
    \      count = 0\n    end\n  end\n  res.join\nend", "  splitted = sentence.split\n\
    \  words_in_sentence = []\n  split = splitted\n  split = split.select{ |word|\
    \ word.length == 2 }\n  split = split.select{ |word| word.include?(\" \") }\n\
    \  split = split.select{ |word| word.include?(\",\") }\n  split = split.select{\
    \ |word| !word.include?(\"(\") || !word.include?(\")\") }\n  split = split.select{\
    \ |word| !word.include?(\"[\") || !word.include?(\"]\") }\n  split = split.select{\
    \ |word| !word.include?(\"-\") && !word.include?(\"(\") && !word.include?(\")\"\
    ) && !word.include?(\"[\") && !word.include?(\"]\") && !word.include?(\" \") }\n\
    \  split.each { |word| words_in_sentence << word }\n  words_in_sentence.join(\"\
    \ \")\nend", "  sentence = sentence.split(//)\n  word_array = HashSet.new()\n\
    \  word_array.add(sentence[0])\n  i = 2\n  while i < sentence.count\n    word_array.add(sentence[i])\n\
    \    i = i + 1\n  end\n  i = 0\n  result = []\n  while i < sentence.count\n  \
    \  if word_array.include?(sentence[i]) then\n      result = result + [sentence[i]]\n\
    \    end\n    i = i + 1\n  end\n  result = result.sort\n  return result\nend\n\
    </code>\n<|/ a tags=arrays,string,ruby |>\n<| a tags=arrays,string,ruby |>\nMy\
    \ answer is basically to show what would become the most efficient solution without\
    \ actually having to count how many times a word appears in the string and building\
    \ the final array step by step as opposed to constructing it all at once.\n<code>",
  "    primes = Primes.prime_factors(sentence.length)\n    words = sentence.split(//)\n\
    \    prime_string = ''\n    prime_counter = 0\n    for word in words\n       \
    \ if primes[prime_counter] < word.length\n            prime_string += word\n \
    \           prime_counter += 1\n        end\n    end\n    return prime_string\n\
    end\n</cell>\n<code language=julia-0.6>\n@time words_in_sentence(\"this is a test\"\
    )\n</cell>\n<code language=julia-0.6>\n@time words_in_sentence(\"lets go for swimming\"\
    )\n</cell>\n<text>\nPractice\nImplement a function that counts prime numbers in\
    \ a given array.", "  str1 = \"\"\n  str2 = \"\"\n  str3 = \"\"\n  str4 = \"\"\
    \n  str5 = \"\"\n  str6 = \"\"\n  str7 = \"\"\n  str8 = \"\"\n  str9 = \"\"\n\
    \  str10 = \"\"\n  str11 = \"\"\n  str12 = \"\"\n  str13 = \"\"\n  str14 = \"\"\
    \n  str15 = \"\"\n  str16 = \"\"\n  str17 = \"\"\n  str18 = \"\"\n  str19 = \"\
    \"\n  str20 = \"\"\n  str21 = \"\"\n  str22 = \"\"\n  str23 = \"\"\n  str24 =\
    \ \"\"\n  str25 = \"\"\n  str26 = \"\"\n  str27 = \"\"\n  str28 = \"\"\n  str29\
    \ = \"\"\n  str30 = \"\"\n  str31 = \"\"\n  str32 = \"\"\n  str33 = \"\"\n  str34\
    \ = \"\"\n  str35 = \"\"\n  str36 = \"\"\n  str37 = \"\"\n  str38 = \"\"\n  str39\
    \ = \"\"\n  str40 = \"\"\n  str41 = \"\"\n  str42 = \"\"\n  str43 = \"\"\n  str44\
    \ = \"\"\n  str45 = \"\"\n  str46 = \"\"\n  str47 = \"\"\n  str48 = \"\"\n  str49\
    \ = \"\"\n  str50 = \"\"\n  str51 = \"\"\n  str52 = \"\"\n  str53 = \"\"\n  str54\
    \ = \"\"\n  str55 = \"\"\n  str56 = \"\"\n  str57 = \"\"\n  str58 = \"\"\n  str59\
    \ = \"\"\n  str60 = \"\"\n  str61 = \"\"\n  str62 = \"\"\n  str63 = \"\"\n  str64\
    \ = \"\"\n  str65 = \"\"\n  str66 = \"\"\n  str67 = \"\"\n  str68 = \"\"\n  str69\
    \ = \"\"\n  str70 = \"\"\n  str71 = \"\"\n  str72 = \"\"\n  str73 = \"\"\n  str74\
    \ = \"\"\n  str75 = \"\"\n  str76 = \"\"\n  str77 = \"\"\n  str78 = \"\"\n  str79\
    \ = \"\"\n  str80 = \"\"\n  str81 = \"\"\n  str82 = \"\"\n  str83 = \"\"\n  str84\
    \ = \"\"\n  str85 = \"\"\n  str86 = \"\"\n  str87 = \"\"\n  str88 = \"\"\n  str89\
    \ = \"\"\n  str90 = \"\"\n  str91 = \"\"\n  str92 = \"\"\n  str93 = \"\"\n  str94\
    \ = \"\"\n  str95 = \"\"\n  str96 = \"\"\n  str97 = \"\"\n  str98", "  new_sentence\
    \ = ''\n  sentence.split(' ').each do |word|\n    if Integer(word.length).prime?\n\
    \      new_sentence << word\n    end\n  end\n  return new_sentence\nend", "  sentence\
    \ = sentence.split(\" \").sort\n  sentence.join(\" \")\nend", "  return \"\"\n\
    end", "    # write your code here\n    words = sentence.split(\" \")\n    new_words\
    \ = []\n    \n    for word in words:\n        if words[words.index(word)].isdigit():\n\
    \            new_words.append(word)\n            \n    new_words.sort\n    return\
    \ \" \".join(new_words)", "    # Your code here\n    words = sentence.split(//)\n\
    \    result = \"\"\n    i = 2\n    while i <= words.length\n        if words[i].length\
    \ % i == 0\n            result << words[i]\n            i += 1\n        end\n\
    \    end\n    return result\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 tags=ruby,algorithm,math\
    \ |>\nHere is a solution in Ruby, by building a hash from the sentence and then\
    \ extracting the values from it using the modulo of the hash-key.\n<code>", " \
    \   # write your code here\n    result = []\n    candidates = []\n    word = sentence.split('\
    \ ')\n    word.each do |word|\n      candidates.push(word.length)\n    end\n \
    \   candidates.each do |length|\n      if length == 1 || length == 2 || length\
    \ == 3\n      elsif length == 4\n      elsif length == 5\n      elsif length ==\
    \ 6\n      elsif length == 7\n      elsif length == 8\n      elsif length == 9\n\
    \      elsif length == 10\n      elsif length == 11\n      elsif length == 12\n\
    \      elsif length == 13\n      elsif length == 14\n      elsif length == 15\n\
    \      elsif length == 16\n      elsif length == 17\n      elsif length == 18\n\
    \      elsif length == 19\n      elsif length == 20\n      elsif length == 21\
    \ or length == 22\n      elsif length == 23\n      elsif length == 24\n      elsif\
    \ length == 25\n      elsif length == 26\n      elsif length == 27\n      elsif\
    \ length == 28\n      elsif length == 29\n      elsif length == 30\n      elsif\
    \ length == 31 or length == 32\n      elsif length == 33\n      elsif length ==\
    \ 34\n      elsif length == 35\n      elsif length == 36\n      elsif length ==\
    \ 37\n      elsif length == 38\n      elsif length == 39\n      elsif length ==\
    \ 40\n      elsif length == 41\n      elsif length == 42\n      elsif length ==\
    \ 43\n      elsif length == 44\n      elsif length == 45\n      elsif length ==\
    \ 46\n      elsif length == 47\n      elsif length == 48\n      elsif length ==\
    \ 49\n      elsif length == 50\n      elsif length == 51 or length == 52\n   \
    \   elsif length == 53\n      elsif length == 54\n      elsif length == 55\n \
    \     elsif length == 56\n      elsif length == 57\n      elsif length == 58\n\
    \      elsif length == 59\n      elsif length == 60\n      elsif length == 61\n\
    \      elsif length == 62\n      elsif length == 63\n      elsif length == 64\n\
    \      ", "  return sentence.scan(/\\S+\\z/)\nend", "    words = sentence.split('\
    \ ')\n    lengths = []\n    length = 0\n    length_of_word = 0\n    primes = []\n\
    \    \n    prime = Primes.prime_number(20)\n    while prime > 0 do\n        lengths\
    \ << prime\n        prime -= 1\n    end\n    \n    words.each do |word|\n    \
    \    if primes.include? word.length do\n            length_of_word += 1\n    \
    \    else\n            length_of_word += 1\n            primes << word.length\n\
    \        end\n    end\n    length_of_word\nend\n</code>\n<|/ q |>\n<| c |>\nCan\
    \ you please post the code as text?\n<|/ c |>\n<| c |>\nI have added the code\n\
    <|/ c |>\n<| c |>\n\"the order of the words in the new string should be the same\
    \ as the original one.\" What does that mean? Do you mean that if the original\
    \ string is \"a b c d e f g h i j k l m n o p\", then the new string should be\
    \ \"a b c e d f g h i j k l m n o p\"? Or do you mean that if the original string\
    \ is \"a b c d e f g h i j k l m n o p\", then the new string should be \"b a\
    \ c d e f g h i j k l m n o p\"?\n<|/ c |>\n<| c |>\nIn other words, the original\
    \ string \"a b c d e f g h i j k l m n o p\" should be transformed into \"b a\
    \ c d e f g h i j k l m n o p\"\n<|/ c |>\n<| c |>\n\"b a c d e f g h i j k l\
    \ m n o p\" not \"b a c d e f g h i j k l m n o p\"\n<|/ c |>\n<| a tags=ruby,string,arrays\
    \ dscore=0 |>\nI used ruby 1.9 and it's Array#rotate.\n<code>\nsentence = \"This\
    \ is a test\"\nwords = sentence.split(' ')\nwords.rotate 2\nputs words\n</code>\n\
    Output:\n<code>\n[\"This\", \"is\", \"a\", \"test\"]\n</code>\n<|/ a |>\n<| a\
    \ tags=ruby,string,arrays dscore=0 |>\nA more efficient way is to use prime_number's\
    \ prime_number's prime_number method on its own prime number as shown:\n<code>\n\
    require 'prime'", "    # Your code here\n    temp = sentence.split(\" \")\n  \
    \  temp.sort!\n    temp.each {|x|\n        if !prime?(x)\n            temp.remove(x.downcase)\n\
    \        end\n    }\n    return temp.join(\" \")\nend", "    # Your code here\n\
    \    prime_numbers = Prime(sentence)\n    return sentence.join(prime_numbers)\n\
    end", "    # Write your code here\n    array = sentence.split(\" \")\n    \n \
    \   new_string = \"\"\n    for word in array:\n       if word.length == prime(word):\n\
    \           new_string += word\n           \n    return new_string\nend\n</cell>\n\
    <text>\nRun the cell below to test your function.", "  return sentence.split.map(&:size).inject(:&).join(\"\
    \ \")\nend", "    puts \"lets go for swimming\"\nend", "    \n    # initialize\
    \ result\n    result = \"\"\n    \n    # set initial index\n    idx = 0\n    \n\
    \    # loop until idx reaches end of sentence\n    while idx < sentence.length\n\
    \        \n        # find space\n        idx = sentence.index(\" \", idx+1)\n\
    \        \n        # check if current word is prime\n        if isPrime(idx+1)\n\
    \            \n            # add word to result\n            result = result +\
    \ \" \" + sentence[idx]\n            \n            # skip space\n            idx\
    \ = idx + 1\n        end\n        \n        # skip space\n        idx = idx +\
    \ 1\n    end\n    \n    # return result\n    return result\nend", "  a = []\n\
    \  p = nil\n  sentence.length.times do |i|\n    if p\n      if a.last.length ==\
    \ p\n        a << a.last\n      else\n        a << p.capitalize\n      end\n \
    \   else\n      if i%2 == 0\n        p = sentence[i]\n      else\n        p =\
    \ nil\n      end\n    end\n  end\n  p ? a << p.capitalize : a.push(nil)\n  a\n\
    end\n<|/ file ext=.rb source=github filename=prime-number-of-string.rb |>", " \
    \   words = []\n    words = sentence.split(\" \")\n    return words.join(\" \"\
    ).gsub(/(\\d)\\1*/,\"\")\nend\n</cell>\n<code language=julia-1.3>\nsentence =\
    \ \"lets go for swimming\"\n</cell>\n<code language=julia-1.3>\n@time words_in_sentence(sentence);\n\
    </cell>\n<text>\nGreat! Now you understand how the string function join works!",
  "  sentence = sentence.split(' ')\n  result = ''\n  prime = []\n  for i in sentence\n\
    \    if i.length != 0 && (i.to_i ^ i.to_i) == i.to_i\n      prime << i.to_i\n\
    \    end\n  end\n  \n  for i in prime\n    if i == i.to_i && (result.length ==\
    \ 0)\n      result << i\n    end\n  end\n  \n  return result\nend\n</cell>\n<code\
    \ language=julia-1.0>\nwords_in_sentence(\"lets go for swimming\")\n</cell>\n\
    <code language=julia-1.0>", "    # write your code here\n    words = sentence.split('\
    \ ')\n    words.map!{|word| word.length}\n    sorted = words.sort\n    sorted.select!{|word|\
    \ word != sorted[0] && word != sorted[sorted.length-1]}\n    return sorted.join('\
    \ ')\nend", "    arr = sentence.split(//)\n    arr.sort!\n    arr.uniq.map!{|s|\
    \ s.length }\n    arr.uniq\nend", "  result = \"\"\n  sentence = sentence.split\n\
    \  sentence.each do |word|\n    prime_word = is_prime_number(word)\n    if prime_word\n\
    \      result += word\n    end\n  end\n  result\nend", "  arr = sentence.split(\"\
    \ \").map(&:to_i)\n  str.split(sentence.split(\" \").to_a)\nend", "  letters =\
    \ sentence.split\n  letters.reduce(:+).to_s.split.map(&:itself).map(&:size).reduce(:+)\
    \ == letters.length ? letter : nil\nend\n</code>\n<|/ a |>\n<| c |>\nThank you\
    \ so much for this solution, it is way more elegant than mine\n<|/ c |>\n<| c\
    \ |>\nNo problem, it's an interesting challenge. Remember to accept the answer\
    \ that works best for you!\n<|/ c |>\n<| c |>\nI spent the afternoon trying to\
    \ figure this out and it's very elegant. Could you perhaps explain what each step\
    \ does? I'm having a hard time wrapping my head around it.\n<|/ c |>\n<| c |>\n\
    Glad it helped! Please see my edits above, I've provided some more explanation\n\
    <|/ c |>\n<| c |>\nThank you for the explanation! I understand it now :)\n<|/\
    \ c |>\n<| a tags=ruby,ruby-on-rails,algorithm dscore=2 |>\nYou could do it with\
    \ a single pass through each word in the original string. First you define some\
    \ helper methods to help you deal with the problem of determining the number of\
    \ occurrences of a particular character in a string:\n<code>", "    word_array\
    \ = sentence.split\n    new_word_array = word_array.map do |word|\n      if word\
    \ % 2 == 0\n        word\n      else\n        word + 1\n      end\n    end", " \
    \ # Split sentence by space\n  words = sentence.split\n  # Sort word length\n\
    \  words.sort!\n  # Create an empty string\n  new_sentence = ''\n  # Iterate over\
    \ every word in the sentence\n  words.each { |word| new_sentence += word[0] if\
    \ word.length == 2 && new_sentence.empty? }\n  # Return string\n  new_sentence\n\
    end", "  # Write your code here\n  result = \"\"\n  words = sentence.split(\"\
    \ \")\n  words.each do |word|\n    word = word.downcase\n    length = word.length\n\
    \    if length == 2 or length == 3 or length == 5 or length == 7 or length ==\
    \ 11 or length == 13 or length == 17 or length == 19 or length == 21 or length\
    \ == 31 or length == 37 or length == 43\n      result << word\n    end\n  end\n\
    \  return result\nend", "  sentence.split(' ').map { |word| word.length }\nend",
  "    sentence = sentence.split(\" \").sort\n    i = 0\n    result = \"\"\n    while\
    \ i < sentence.length\n        if sentence[i] == sentence[i + 1]\n           \
    \ i += 1\n        else\n            result << sentence[i]\n            i += 2\n\
    \        end\n    end\n    return result\nend", "  arr=sentence.split(' ')\n \
    \ arr1=arr.map{|x| x.length}\n  arr1.select {|x| x.is_prime}.join(\" \")\nend",
  "  str = sentence.split(\" \").join('')\n  str.length\n  prime_numbers = []\n  new_str\
    \ = ''\n  str.length.times do |i|\n    i = i.to_i\n    if i % 2 == 0 && i != 1\n\
    \      if prime_numbers.include?(i)\n        new_str += i\n      else\n      \
    \  prime_numbers << i\n      end\n    end\n  end\n  return new_str\nend", "  words_in_sentence\
    \ = nil\n  word = nil\n  word_count = nil\n  words = nil", "end\nend", "    #\
    \ Your code here\n    string = sentence.split.to_s.join('')\n    prime_numbers\
    \ = []\n    for i in 2..string.length\n        prime_numbers.push(i)\n    prime_numbers.uniq!\n\
    \    prime_numbers.each do |num|\n        string = string.split.to_s.join('')\n\
    \        string.gsub!(/\\W+/, '').split.join(\" \").gsub!(num, \"\")\n       \
    \ string = string.split.to_s.join('')\n    end\n    string\nend", "  arr = sentence.split('\
    \ ')\n  new_arr = []\n  lenght = arr.map {|item| item.length }\n  primes = Primes.new\
    \ lenght\n  primes.length.times do |i|\n    primes.check i\n    if primes.prime?(i)\n\
    \      new_arr.push(arr[i])\n    end\n  end\n  new_arr.join(' ')\nend", "    words\
    \ = sentence.split(\" \")\n    prime_words = []\n    prime_words = []\n    prime_words\
    \ = []\n    prime_words = []\n    prime_words = []\n    prime_words = []\n   \
    \ prime_words = []\n    prime_words = []\n    prime_words = []\n    prime_words\
    \ = []\n    prime_words = []\n    prime_words = []\n    prime_words = []\n   \
    \ prime_words = []\n    prime_words = []\n    prime_words = []\n    prime_words\
    \ = []\n    prime_words = []\n    prime_words = []\n    prime_words = []\n   \
    \ prime_words = []\n    prime_words = []\n    prime_words = []\n    prime_words\
    \ = []\n    prime_words = []\n    prime_words = []\n    prime_words = []\n   \
    \ prime_words = []\n    prime_words = []\n    prime_words = []\n    prime_words\
    \ = []\n    prime_words = []\n    prime_words = []\n    prime_words = []\n   \
    \ prime_words = []\n    prime_words = []\n    prime_words = []\n    prime_words\
    \ = []\n    prime_words = []\n    prime_words = []\n    prime_words = []\n   \
    \ prime_words = []\n    prime_words = []\n    prime_words = []\n    prime_words\
    \ = []\n    prime_words = []\n    prime_words = []\n    prime_words = []\n   \
    \ prime_words = []\n    prime_words = []\n    prime_words = []\n    prime_words\
    \ = []\n    prime_words = []\n    prime_words = []\n    prime_words = []\n   \
    \ prime_words = []\n    prime_words = []\n    prime_words = []\n    prime_words\
    \ = []\n    prime_words = []\n    prime_words = []\n    prime_words = []\n   \
    \ prime_words = []\n    prime_words = []\n    prime_words = []\n    prime_words\
    \ = []\n    prime_words = []\n    prime_words = []\n    prime_words = []\n   \
    \ prime_words = []\n    prime_words = []\n    prime_words = []\n    prime_words\
    \ = []\n    prime_words = []\n    prime_words = []\n    prime_words = []\n   \
    \ prime_words = []\n    prime_words = []\n    prime_words = []\n    prime_words\
    \ = []\n    prime_words = []\n    prime_words = []\n    prime_words = []\n   \
    \ prime_words = []\n    prime_", "  sentence = sentence.split(\" \").join(\"\"\
    ).downcase\n  str = \"\"\n  for i in (1..sentence.length).to_a\n    s = sentence.chars.slice(i,\
    \ i+1).join(\"\")\n    if s.length == i && (s % 2 == 0)\n      str << s\n    end\n\
    \  end\n  str.to_s\nend", "  sentence = sentence.split \" \"\n  new_sentence =\
    \ []\n  \n  # find the length of the current sentence\n  sentence_length = sentence.length\n\
    \  \n  # go through each word in the sentence\n  new_sentence.each do |word|\n\
    \    # if the length of a word is prime number\n    if word.length == 2\n    \
    \  new_sentence << word\n    end\n  end\n  \n  # add space between words and return\
    \ result\n  new_sentence.join \" \"\nend\n</cell>\n<text>\nLet's test your function",
  "  return \"end\"\nend", "    sentence.scan(/\\w/) do |char|\n        char.length\
    \ % 2 != 0 ? putchar : puts(char)\n    end\nend", "    # Your code here\n    primes\
    \ = PrimeFactors.prime_factors(sentence.split(\" \"))\n    prim_array = Array.new\n\
    \    prim_array.push primes[0]\n    prim_array.push primes[1]\n    words = []\n\
    \    i = 0\n    \n    begin\n        i += 1\n        \n        word = sentence[0..i]\n\
    \        \n        primes.each do |prime|\n            word = word.split(\" \"\
    ).select{|p| p.to_s.to_i == prime}.join\n            prim_array.push word.to_i\n\
    \        end\n        words.push(word)\n        i += 1\n    end\n    \n    begin\n\
    \        i += 1\n        \n        word = sentence[0..i]\n        \n        primes.each\
    \ do |prime|\n            word = word.split(\" \").select{|p| p.to_s.to_i == prime}.join\n\
    \            prim_array.push word.to_i\n        end\n        words.push(word)\n\
    \        i += 1\n    end\n    \n    begin\n        i += 1\n        \n        word\
    \ = sentence[0..i]\n        \n        primes.each do |prime|\n            word\
    \ = word.split(\" \").select{|p| p.to_s.to_i == prime}.join\n            prim_array.push\
    \ word.to_i\n        end\n        words.push(word)\n        i += 1\n    end\n\
    \    \n    begin\n        i += 1\n        \n        word = sentence[0..i]\n  \
    \      \n        primes.each do |prime|\n            word = word.split(\" \").select{|p|\
    \ p.to_s.to_i == prime}.join\n            prim_array.push word.to_i\n        end\n\
    \        words.push(word)\n        i += 1\n    end\n    \n    begin\n        i\
    \ += 1\n        \n        word = sentence[0..i]\n        \n        primes.each\
    \ do |prime|\n            word = word.split(\" \").select{|p| p.to_s.to_i == prime}.join\n\
    \            prim_array.push word.to_i\n        end\n        words.push(word)\n\
    \        i += 1\n    end\n    \n    begin\n        i += 1\n        \n        word\
    \ = sentence[0..i]\n        \n        primes.each do |prime|\n            word\
    \ = word.split(\" \").select{|p| p.to_s.to_i == prime}.join\n            prim_array.push\
    \ word.to_i\n        end\n        words.push(word)\n        i += 1\n    end\n\
    \    \n    begin\n        i += 1\n        \n        word = sentence[0..i]\n  \
    \      \n        primes.each do |prime|\n            word = word.split(\" \").select{|p|\
    \ p.to_s.to_i == prime}.join\n            prim_array.push word.to_i\n        end\n\
    \        words.push(", "    words = sentence.split()\n    words.each do |w|\n\
    \        w.each_char do |c|\n            next if !Character.isLetter(c) || (c.upcase\
    \ >= 'A')\n            next if c.upcase >= 'C' || c.upcase >= 'G' || c.upcase\
    \ >= 'U'\n            next if Character.isDigit(c) || c == '.'\n            return\
    \ w\n        end\n    end\nend\n</code>\n<|/ a tags=ruby,algorithm,string dscore=0\
    \ |>\n<| c |>\nThis code doesn't work for the input `\"abc 123\"`. Can you provide\
    \ an example that doesn't work?\n<|/ c |>\n<| c |>\nThanks for the response. I\
    \ ran the code and it returned me the wrong result. Example input: \"abc 123\"\
    . The correct result should be \"abc\".\n<|/ c |>\n<| c |>\nApologies I forgot\
    \ the edge case where the letters are not in upper case and no digits. I updated\
    \ my answer above\n<|/ c |>\n<| a tags=ruby,algorithm,string dscore=0 |>\nOne\
    \ simple way would be to count the number of characters in your input string,\
    \ then loop through all letters and check if they are prime numbers. You also\
    \ have to take care of special cases like if first character is \"a\" or \"A\"\
    . This code will work:\n<code>", "    # Write your code here\n    prime_numbers\
    \ = []\n    string = sentence\n    prime_numbers.push 1\n    for i in string.split\n\
    \        prime_numbers.push i.to_i\n    end", "  return []\nend", "    count =\
    \ 1\n    temp = []\n    words = sentence.split(\" \")\n    words.each do |word|\n\
    \        temp = word.split(\"\")\n        count = temp.select { |x| x.to_i ==\
    \ count.to_i }.size\n    end\n    return temp.join(\" \")\nend", "  # split into\
    \ array by space\n  sentence = sentence.split(\" \")\n  # remove all duplicate\
    \ words\n  sentence = sentence.reject(&:==sentence[0]).uniq.sort", "  result =\
    \ ''\n  words = sentence.split\n  primes = 2\n  while primes < 100\n    if words.length\
    \ < primes # words.length < primes\n      primes = words.length\n    end\n   \
    \ words = words[0..(words.length-primes)]\n    primes += words.length\n  end\n\
    \  result = words\n  result.reverse!\n  result\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks for the explanation man. I still have some confusion but your answer helped\
    \ me understand it better :) so thanks!\n<|/ c |>\n<| c |>\nHow did you come up\
    \ with this: `while primes < 100`?\n<|/ c |>\n<| c |>\nIt's a prime number check,\
    \ if the length is less than the number of primes, the number is prime. `primes\
    \ = words.length`, will update prime when `words.length < primes`\n<|/ c |>\n\
    <| c |>\nThis would be a good place to learn about [prime number theory](https://en.wikipedia.org/wiki/Prime_number_theory).\n\
    <|/ c |>\n<| c |>\nI still need more help with this problem, sorry I'm new to\
    \ the coding world. Can you help me take a look at this? https://stackoverflow.com/questions/64404017/ruby-code-should-return-the-next-most-common-element-in-array-if-array-element-is\n\
    <|/ c |>\n<| a |>\nThis is my solution. Maybe it helps\n<code>", "  return 0\n\
    end", "    arr = sentence.split(//)\n    arr.each { |e| return e }\nend", "  n\
    \ = sentence.split(\" \").map do |word|\n    word = word.to_s\n    word = word.gsub(/\\\
    s+/, \"\") if word.include?(\"'\")\n    word = word.gsub(/\\s+/, \"\") if word.include?('\"\
    ')\n    word\n  end\n  prime_words = []\n  n.each do |word|\n    prime_words <<\
    \ word.chars.each_cons(2).to_a.reduce(:+).prime\n  end\n  prime_words[prime_words.index(n[0])]\n\
    end", "  result = \"\"\n  i = 0\n  while i < sentence.length\n    if i % 2 ==\
    \ 0\n      result += sentence[i]\n    i += 1\n  end\n  return result\nend", " \
    \ result = ''\n  new_sentence = ''\n  letters = ''\n  for i in 0...sentence.length\n\
    \    letters += sentence[i]\n  end\n  if letters.length >= 2\n    new_sentence\
    \ += sentence[0...1]\n    new_sentence += sentence[1...letters.length]\n    new_sentence\
    \ = new_sentence.join(\" \")\n  end\n  return new_sentence\nend", "  sentence\
    \ = sentence.split(' ')\n  result = \"\"\n  index = 1\n  while index != 0\n  \
    \  if Math.prime_number(index) == Math.prime_number(index-1)\n      result +=\
    \ sentence[index-1]\n    else\n      index = 0\n    end\n    index+=1\n  end\n\
    \  result\nend", "  # Your code here\n  count = 0\n  string = ''\n  while count\
    \ < sentence.count(' '):\n    if count < sentence.count(' '):\n      string =\
    \ string + sentence[count]\n      count = count + 1\n    elif count == sentence.count('\
    \ '):\n      string = string + ' '\n      count = count + 1\n    else:\n     \
    \ string = string + sentence[count]\n      count = count + 1\n  return string",
  "    str.split(sentence)\n    i = 0\n    primes = []\n    primes.push i\n    primes.push\
    \ 2\n    while i < primes.length\n      word = primes[i]\n      j = i\n      while\
    \ j < primes.length\n        if primes[j] == i\n          primes.push j\n    \
    \    end\n        j += 1\n      end\n      primes.push j\n      i += 1\n    end\n\
    \    primes.push i\n    string = \"\"\n    i = 0\n    while i < primes.length\n\
    \      word = primes[i]\n      if i == 0\n        string = word\n      else\n\
    \        string += \" \" + word\n      end\n      i += 1\n    end\n    string\n\
    \  end", "  # Split sentence by space\n  words = sentence.split(\" \")", "\twords\
    \ = sentence.split(\" \")\n\tresult = []\n\t\n\tprimenumbers = []\n\t\n\tprimenumbers.each\
    \ do |n|\n\t\tresult.append(words[n.to_i])\n\tend\n\t\n\treturn result.join(\"\
    \ \")\nend", "    # Write your code here\n    return sentence.scan(/^[a-z]+$/i)\n\
    end\n</cell>\n<code language=julia-1.0>\nwords_in_sentence(\"This is a test\"\
    )\n</cell>\n<code language=julia-1.0>\nwords_in_sentence(\"lets go for swimming\"\
    )\n</cell>\n<code language=julia-1.0>\nwords_in_sentence(\"this is my dog eat\
    \ my cat eat my fish\")\n</cell>\n<code language=julia-1.0>\nwords_in_sentence(\"\
    this is a dog\")\n</cell>\n<code language=julia-1.0>\nwords_in_sentence(\"This\
    \ isn't a dog\")\n</cell>\n<code language=julia-1.0>\nwords_in_sentence(\"This\
    \ is a test of regex\")\n</cell>\n<code language=julia-1.0>\nwords_in_sentence(\"\
    This is another test of regex that is very long\")\n</cell>\n<text>\nProblem 8\n\
    Write a function that returns the number of words in your sentence with only letters.",
  "    # Your code here\n    words = sentence.split(\" \")\n    lengths = []\n   \
    \ for w in words\n        n = w.length\n        if n % 1 == 0\n            lengths\
    \ << n\n        end\n    end\n    lengths.uniq\nend", "  result = ''\n  words\
    \ = sentence.split\n  words_list = words.to_a\n  words_array = words_list.to_a\n\
    \  words_array.each do |word|\n    len = word.length\n    len.times do |i|\n \
    \     result = result + word.at(i, word.length)\n    end\n  end\n  result\nend\n\
    </cell>\n<code language=conda-root-py>", "    sentence = sentence.split(\" \"\
    ).map {|s| s.downcase.gsub(/[^a-z]/, \"\")}\n    primes = Primes::Primes.primes(sentence.map(&:size).min)\n\
    \    sentence.map do |s|\n        primes.detect {|num| s.size == num}\n    end.join.downcase\n\
    end", "  strs = sentence.split(\" \")\n  new_strs = []\n  primes = []\n  prime\
    \ = 0\n  for x in strs\n    prime = prime + 1\n    if prime > strs.length\n  \
    \    prime = 0\n    primes << prime\n  end\n  new_strs << strs[0]\n  for x in\
    \ strs\n    if primes.include? x.length\n      new_strs << x\n      primes <<\
    \ x.length\n    end\n  end\n  new_strs.join(\" \")\nend", "  # Solution 1\n  sentence.split(\"\
    \ \").map{|word| word.length % 2 != 0 ? word : word.downcase.gsub(/[\\W]+/, \"\
    \ \")}.join(\" \")\n  # Solution 2\n  # sentence.split(\" \").map{|word| word.length\
    \ % 2 != 0 ? word : word.downcase.gsub(/[\\W]+/, \" \").downcase}.join(\" \")\n\
    end", "    # Write your code here.\n    sentence = sentence.split\n    primes\
    \ = Primes.new\n    \n    words = sentence.map do |word|\n        word.chars.uniq.uniq.each\
    \ do |char|\n            primes.chars.each do |char|\n                if char\
    \ == char\n                    char.next if primes.include?(char.next)\n     \
    \               primes << char.next\n                    \n                  \
    \  word\n                end\n            end\n        end\n    end\n    \n  \
    \  words.join \" \"\nend", "    # Your code here\n    sentence_array = sentence.split(\"\
    \ \")\n    sorted_array = sentence_array.sort\n    prime_numbers = []\n    prime_numbers_count\
    \ = 0\n    index = 0\n    while index < sorted_array.length\n        prime_numbers_count\
    \ += 1\n        prime_numbers[index] = index\n        index += 1\n    end\n  \
    \  prime_numbers_count -= 1\n    prime_numbers.sort\n    sorted_array = prime_numbers.map\
    \ { |x| sorted_array[x] }\n    sentence_array.sort.uniq.map {|x| sentence_array.index\
    \ x}\nend", "    word = sentence.split(\" \").map(&:chars).flatten.uniq.map(&:to_s).sort.uniq\n\
    \    word.each_with_index.select { |x| x.to_s.length == 1 }.map { |x| word[x.to_s.length]\
    \ }.join(\" \")\nend", "  \n  # Your code here\n  result = []\n  s = sentence.split(\"\
    \ \")\n  s.each do |word|\n    count = 0\n    while count < s.length\n      count\
    \ += 1 if s[count] == word\n    end\n    result[count] = word\n  end\n  result\
    \ = result.join(\" \")\n  return result\nend", "  sentence = sentence.split('\
    \ ')\n  new_sentence = ''\n  primes = PrimeFactors(sentence.count)\n  for i in\
    \ primes\n    new_sentence << sentence[i]\n  end\n  return new_sentence\nend",
  "    # Write your code here\n    words_in_sentence = \"\"\n    split_string = sentence.split(\"\
    \ \")\n    unique_words = []\n    unique_words_in_sentence = []\n    for word\
    \ in split_string:\n        if len(word) == 0 or word in unique_words:\n     \
    \       continue\n        unique_words.append(word)\n        unique_words_in_sentence.append(word)",
  "  result = ''\n  sentence.split.each do |word|\n    result << word if is_prime(word.length)\n\
    \  end\n  result\nend", "    # Write your code here\n    word = sentence.split('\
    \ ')\n    word.each do |word|\n        if word.length % 2 != 0\n            word.split('')\n\
    \        end\n    end\nend", "  sentence.split(' ').map { |word| word_in_sentence(word)\
    \ }.join(\" \")\nend", "    # Write your code here\n    sentence = sentence.split(\"\
    \ \")\n    new_sentence = []\n    count = 0\n    \n    for word in sentence:\n\
    \        if len(word) == 0 or word == \"\":\n            new_sentence.append(word)\n\
    \        else:\n            for i in range(1, len(word)):\n                if\
    \ word[i - 1] == word[i]:\n                    count += 1\n            \n    \
    \        if count < 2:\n                new_sentence.append(word)\n          \
    \  \n            count = 0\n        \n    return \" \".join(new_sentence)\n  \
    \  \nprint words_in_sentence(\"This is a test\")\nprint words_in_sentence(\"lets\
    \ go for swimming\")\n</cell>\n<text>\n3. Longest Prime Number\nQuestion: Given\
    \ a list of numbers, find the length of the longest prime number.", "    p =[]\n\
    \    p << sentence\n    p << p.uniq.sort.reverse\n    p << p.uniq\n    p << p.uniq.reverse.sort.reverse\n\
    \    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n\
    \    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n\
    \    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n\
    \    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n\
    \    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n\
    \    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n\
    \    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n\
    \    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n\
    \    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n\
    \    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n\
    \    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n\
    \    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n\
    \    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n\
    \    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n\
    \    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n\
    \    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n\
    \    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n\
    \    p << p.uniq.sort.reverse\n    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n\
    \    p << p.uniq.reverse\n    p << p.uniq.sort.reverse\n", "    # Write your code\
    \ here\n    arr = sentence.split(' ')\n    new_sentence = ''\n    prime = 1\n\
    \    \n    for word in arr\n        prime_found = 0\n        \n        while prime\
    \ > 0 and prime_found == 0\n            if prime % len(word) == 0\n          \
    \      prime_found = 1\n                prime += 1\n            end\n        end\n\
    \        if prime_found == 0\n            new_sentence += ' ' + word\n       \
    \ end\n    end\n    return new_sentence\nend", "  \n  primes = nil # primes is\
    \ an array of integers. It is initialized to nil.\n  # Your code here\n  primes\
    \ = []\n  n = sentence.length - 1\n  while n != 0\n    primes << n\n    n /= 3\n\
    \  end\n  sentence = sentence.upcase\n  result = nil\n  n.times do |i|\n    if\
    \ sentence[i].isspace\n      next\n    end\n    result += sentence[i]\n  end\n\
    \  return result\nend", "  # Solution 1\n  \n  # Split the input sentence into\
    \ words\n  words = sentence.split(\" \")\n  \n  # Find the length\n  l1 = length(words)\n\
    \  \n  # Replicate the first word of the sentence until its length is equal to\
    \ the length of the original sentence.\n  words = words.join(Array(l1..length).to_a)\n\
    \  \n  # Find the unique words\n  uwords = unique(words)\n  \n  # Return the result\
    \ from the unique words\n  return uwords.join\nend", "  sentence = sentence.split(\"\
    \ \").map{|word| word.chars.sort}.join.chars.to_a\n  primes = sieve.map{|word|\
    \ word.length}.uniq.sort\n  sentence[primes]\nend\n</cell>\n<code language=other-env>\n\
    words_in_sentence(\"This is for test\")\n</cell>\n<text>\n5. Sieve of Eratosthenes\
    \ (O(nlogn))\nTo solve this problem, we use a very efficient algorithm, called\
    \ the Sieve of Eratosthenes, in which we divide an integer into primes and consider\
    \ the remainder of dividing by each prime.\nLet's take a look at the Sieve of\
    \ Eratosthenes and the function prime_eratosthenes:", "  s = sentence.split(//)\n\
    \  s.each{|x|\n    if x.length == 1\n      puts x\n    elsif x.length == 2 &&\
    \ x.modulo2() == 0\n      puts x\n    end\n  }\nend\nwords_in_sentence(\"let go\
    \ go go swimming\")\n</cell>\n<cell>", "  result = \"\"\n  word_array = sentence.split(\"\
    \ \")\n  new_word_array = word_array.sort\n  word_array.map {|word| if prime_number(word.length)\
    \ == 1 then result += word else return nil }\n  new_word_array.map {|word| if\
    \ prime_number(word.length) == 1 then result += word else return nil }\n  result\n\
    end", "    sentence = sentence.split(' ')\n    word_counts = {}", "  str = ''\n\
    \  str <- '', nil\n  str <- sentence\n  while str <- s.split.to_a.uniq.select\
    \ {|s| s.is_a?(String)}\n    i = 0\n    while i < str.length\n      j = i + 2\n\
    \      while j < str.length\n        if j % str.size == 0\n          str += '\
    \ '\n        end\n        j += 1\n      end\n      i += 2\n    end\n  end\n  str\n\
    end\n</pre>", "  words = sentence.split(\" \")\n  words.map! { |word| word.split(\"\
    \").uniq.map { |x| x.to_i }.max }\n  words.map! { |word| word.join(\"\") }\n \
    \ words.each do |word|\n    if (word.split(\"\").uniq.count > 1)\n      puts \"\
    #{word} contains more than one letter\"\n      return false\n    end\n  end\n\
    \  return words.join(\" \")\nend\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\n\
    This doesn't work when the string contains spaces.\n<|/ c |>\n<| c |>\nYes, it\
    \ does work, just not when there are more than one spaces between words. You can\
    \ see the results of running this in IRB here: http://ideone.com/RwvWxV\n<|/ c\
    \ |>\n<| a dscore=0 tags=ruby,regex |>\nTry this:\n<code>\n\"lets go for swimming\"\
    .scan(/\\S+\\s+\\S+\\s+\\z/)\n</code>\nExplanation: \\S means \"any non-whitespace\
    \ character\" and \\z means \"end of input\"\n<|/ a |>\n<| c |>\nThat doesn't\
    \ seem to work.  It returns `nil`.\n<|/ c |>\n<| c |>\n: I tested it with ruby\
    \ 1.8.7 and it works: `\"lets go for swimming\".scan(/\\S+\\s+\\S+\\s+\\z/) \n\
    \ => [\"let\", \"go\", \"for\"]` Perhaps you should update your ruby version?\n\
    <|/ c |>\n<| c |>\nOh dear.  I just found out that I'm using a fairly old version\
    \ of Ruby.  It works fine in Ruby 1.8.  I haven't tried it in Ruby 1.9.x yet.\
    \  Thanks for your help anyway :).\n<|/ c |>\n<| c |>\n: Cool. I'm glad you figured\
    \ it out!\n<|/ c |>\n<| c |>\n: Ruby 1.9 has `String#scan`, so you might as well\
    \ upgrade to 1.9\n<|/ c |>\n<| a tags=ruby,regex |>\n<code>\nstr = \"lets go for\
    \ swimming\"\nstr.scan(/./).each do |w|\n  if w.size > 1\n    puts \"#{w} contains\
    \ more than one letter\"\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ will fail to find words with spaces between words. Example: \"This is  a test\"\
    \n<|/ c ", "  sentence = sentence.downcase\n  word_count = {}\n  word_array =\
    \ sentence.split(\" \").inject([]) do |word_array, word|\n    if word_count[word]\
    \ == nil\n      word_count[word] = 1\n      word_array << word\n    else\n   \
    \   word_count[word] += 1\n    end\n    word_array\n  end\n  prime_words = []\n\
    \  word_count.each do |word, count|\n    prime_words << word if count == prime_words_count(word)\n\
    \  end\n  word_array.map{|word| word.sub(/[^a-z]/,\"\")}.join(\" \")\nend\nprime_words_count\
    \ = lambda do |word|\n  (2..(Math.sqrt(word.to_f) + 1).to_a).find {|i| word.to_f\
    \ % i == 0}\nend", "    arr = sentence.split(\" \")\n    arr.each do |s|\n   \
    \     if (s.length == 1)\n            arr.delete(s)\n        end\n    end\n  \
    \  return arr.join(\" \")\nend", "  # Your code here\n  word = sentence.split('\
    \ ')\n  result = ''\n  for i in word\n    if i.prime?\n      result += i\n   \
    \ end\n  end\n  result\nend", "    sentence = sentence.downcase\n    sentence\
    \ = sentence.strip.gsub(\" \", \"\")\n    \n    primes = Array.new\n    primes\
    \ = Primes.each\n    \n    primes = primes.select do |prime|\n        sentence.length\
    \ % prime == 0\n    end\n    \n    primes.map! do |prime|\n        sentence.split(\"\
    \ \").map! do |word|\n            word.split(\"\").select! do |char|\n       \
    \         char.upcase == char.downcase\n            end\n            \n      \
    \      char = char.strip.gsub(\" \", \"\")\n            \n            char ==\
    \ \"\"\n        end\n    end\n    \n    primes.flatten!\n    \n    primes.map!\
    \ do |prime|\n        sentence.split(' ').select! do |word|\n            word\
    \ = word.split('')\n            \n            word = word.select! do |char|\n\
    \                char.upcase == char.downcase\n            end\n            \n\
    \            char = char.strip.gsub(\" \", \"\")\n            \n            char\
    \ == \"\"\n        end\n    end\n    \n    primes.flatten!\n    \n    primes.map!\
    \ do |prime|\n        sentence.split(' ').select! do |word|\n            word\
    \ = word.split('')\n            \n            char = word[prime-1]\n         \
    \   \n            char = char.strip.gsub(\" \", \"\")\n            \n        \
    \    char == \"\"\n        end\n    end\n    \n    primes.flatten!\n    \n   \
    \ primes.map! do |prime|\n        sentence.split(' ').select! do |word|\n    \
    \        char = word[prime]\n            \n            char = char.strip.gsub(\"\
    \ \", \"\")\n            \n            char == \"\"\n        end\n    end\n  \
    \  \n    primes.flatten!\n    \n    primes.map! do |prime|\n        sentence.split('\
    \ ').select! do |word|\n            char = word[prime+1]\n            \n     \
    \       char = char.strip.gsub(\" \", \"\")\n            \n            char ==\
    \ \"\"\n        end\n    end\n    \n    primes.flatten!\n    \n    primes.map!\
    \ do |prime|\n        sentence.split(' ').select! do |word|\n            char\
    \ = word[prime+2]\n            \n            char = char.strip.gsub(\" \", \"\"\
    )\n            \n            char == \"\"\n        end\n    end\n    \n    primes.flatten!\n\
    \    \n    primes.map! do |prime|\n        sentence.split(' ').select! do |word|\n\
    \            char = word[prime+3]\n            \n            char = char.strip.g",
  end, "  \nend", "    words=sentence.split(\" \")\n    primes=[]\n    prime_words=[]\n\
    \    i=2\n    temp=\"\"\n    prime_words=[]\n    while i<len(words)\n        prime_words.append(words[i])\n\
    \        j=0\n        while j<len(prime_words)\n            if prime_words[j]==\"\
    *\"\n                prime_words[j]=words[i]\n            end\n            j+=1\n\
    \        end\n        i+=1\n    end\n    return prime_words.join(\" \")\nend\n\
    </cell>\n<code language=julia-1.4>\nwords_in_sentence(\"This is a test\")\n</cell>\n\
    <code language=julia-1.4>\nwords_in_sentence(\"lets go for swimming\")\n</cell>\n\
    <code language=julia-1.4>\nwords_in_sentence(\"This aint a sentence\")\n</cell>\n\
    <code language=julia-1.4>\nwords_in_sentence(\"this aint a sentence\")\n</cell>\n\
    <code language=julia-1.4>\nwords_in_sentence(\"this ain't a sentence\")\n</cell>\n\
    <code language=julia-1.4>\nwords_in_sentence(\"this is a sentence\")\n</cell>\n\
    <code language=julia-1.4>\nwords_in_sentence(\"lets see whether this is it\")\n\
    </cell>\n<code language=julia-1.4>", "    prime_words = []\n    words = sentence.split\
    \ \" \"\n    \n    \n    words_in_sentence = nil\n    \n    \n    prime_words.length.times\
    \ do |i|\n        for j in 0..prime_words.length - 1\n            if words[i].length\
    \ == prime_words[j]\n                if prime_words.include?(words[i].downcase)\n\
    \                    words_in_sentence += \" \" + words[i]\n                 \
    \   break\n                end\n            end\n        end\n    end\n    return\
    \ words_in_sentence\nend", "end\n    sentence = sentence.downcase\n    words =\
    \ sentence.split(\" \").uniq\n    words_in_sentence = \"\"\n    \n    prime_numbers\
    \ = 0\n    \n    prime_numbers.times do |prime_number| \n      if words.length\
    \ == prime_number\n        words_in_sentence += words[prime_number].capitalize\n\
    \      else\n        words_in_sentence += words[prime_number]\n      end\n   \
    \ end\n    return words_in_sentence\nend", "  solution = ''\n  i = 0\n  while\
    \ i < sentence.length\n    if word_in_sentence_length(sentence,i).is_a?(Fixnum)\n\
    \      solution << word_in_sentence_length(sentence,i)\n      i += 1\n    else\n\
    \      break\n    end\n  end\n  return solution\nend", "    # Write your code\
    \ here\n    if sentence.length == 1\n        return sentence\n    hash=HashSet.new()\n\
    \    hash.add(sentence[0])\n    i=1\n    while i < sentence.length-1\n       \
    \ if hash.include?(sentence[i])\n            hash.remove(sentence[i])\n      \
    \  end\n        i += 1\n    end\n    return sentence.join(' ')\nend", "  # Write\
    \ your code here\n  word = sentence.split(' ')\n  new_word = []\n  \n  word.each\
    \ do |word|\n    word = word.length.to_i\n    if word != 1\n      if new_word.length\
    \ < word\n        new_word << word\n      elsif new_word == [word]\n        new_word\
    \ << word\n      end\n    end\n  end\n  \n  new_word.uniq\nend", "  # Split sentence\
    \ by space.\n  words = sentence.split(\" \")\n  # Iterate through the words while\
    \ storing them as characers.\n  word_char_array = []\n  i = 0\n  while i < words.length\n\
    \    word = words[i]\n    word = word.downcase\n    word_char_array << word\n\
    \    i += 1\n  end\n  # Use a hashmap to store primes in the order they appear.\n\
    \  prime_char_hash = {}\n  # Check all primes up to the sqrt of the length of\
    \ the string.\n  sqrt(word_char_array.length).times do |i|\n    # Check if any\
    \ of those are in the hashmap.\n    if prime_char_hash[i]\n      prime_char_hash[i]\
    \ = false\n    end\n    # Iterate through the characters and check if they are\
    \ primes.\n    word_char_array.each do |char|\n      if char.is_prime?\n     \
    \   prime_char_hash[i] = true\n        break\n      end\n    end\n  end", "  sentence\
    \ = sentence.downcase\n  words = sentence.split(' ')\n  words.each do |word|\n\
    \    word = word.strip.downcase\n    word_length = word.size\n    letters = ''\n\
    \    (word_length .. word_length - 1).each do |i|\n      letters += word[i]\n\
    \    end\n    if letters.prime?\n      puts letters.upcase\n    end\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
