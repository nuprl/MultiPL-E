name: HumanEval_37_sort_even
language: rb
prompt: "# This function takes a list l and returns a list l' such that\n# l' is identical\
  \ to l in the odd indicies, while its values at the even indicies are equal\n# to\
  \ the values of the even indicies of l, but sorted.\n# >>> sort_even([1, 2, 3])\n\
  # [1, 2, 3]\n# >>> sort_even([5, 6, 3, 4])\n# [3, 6, 5, 4]\ndef sort_even(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_even\n\
  \    candidate = method(:sort_even)\n    assert_equal([1, 2, 3], candidate.call([1,\
  \ 2, 3]))\n    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5,\
  \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([-12, 8, 3, 4, 5, 2, 12,\
  \ 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n  end\n\
  end\n"
completions: ["  l2 = []\n  even = l.select {|x| x % 2 == 0}\n  odd = l.select {|x|\
    \ x % 2 == 1}\n  even.each {|x| l2 << x}\n  odd.each {|x| l2 << x}\n  l2.sort!\n\
    \  return l2\nend", "  sorted = []\n  even_idx = 1\n  evens = l.select { |x| x\
    \ % 2 == 0 }\n  evens.each { |e| sorted.insert(even_idx, e) }\n  sorted.each {\
    \ |e| sorted.insert(even_idx - 1, e) }\n  return sorted\nend", "    l.each.with_index(2)\
    \ do |(elem, index)|\n        l[index] = elem if index % 2 == 0\n    end\n   \
    \ l\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction sort_even\
    \ (array)\n  return array if array.size % 2 != 0\n  array.each_with_index.each_slice(2).with_index\
    \ do |a, i|\n    a[i] = a[0] if i.even?\n  end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a |>\nI got this for you in one line of ruby\n<code>\n[1,3,5,2,4,6].sort_by{|x|\
    \ x.odd? ? 1 : 0}\n</code>\n<|/ a tags=ruby,arrays dscore=0 |>\n<| c |>\nIf you\
    \ really need an array, just `[1,3,5,2,4,6].sort_by{|x| x.odd? ? 1 : 0}.to_a`\
    \ will do it\n<|/ c |>\n<| c |>\n`[1,3,5,2,4,6].sort_by{|x| x.odd? ? 1 : 0}` would\
    \ sort the array in place, while `[1,3,5,2,4,6].sort_by{|x| x.odd? ? 1 : 0}.to_a`\
    \ creates a new array.\n<|/ c |>\n<| a dscore=0 |>\nI wrote a method to sort an\
    \ array using your criteria and it works.\n<code>", "  even_index = nil\n  odd_index\
    \ = nil\n  even_index = 0\n  odd_index = l.length\n  while (even_index < odd_index)\n\
    \    even_value = l[even_index]\n    odd_value = l[odd_index]\n    if (odd_value\
    \ < even_value)\n      break\n    end\n    odd_index += 1\n    l[even_index] =\
    \ odd_value\n  end\n  return l\nend", "  l.sort!\n  l.each_with_index { |x, i|\
    \ l[i-1] = x if i%2 == 0 }\nend\n</cell>\n<code language=conda-env-PromoterArchitecturePipeline-py>",
  "  l.sort.each_with_index {|x,i| i & 1 == 0 ? l[i] = x : l[i]} if l.kind_of?(Array)\n\
    \  l\nend", "  l.sort!\n  l.each_with_index do |value, index|\n    next if index%2\
    \ == 0\n    l[index] = value\n  end\n  l\nend", "    l.each_with_index do |e,\
    \ i|\n        if i%2\n            l[i.to_i] = e\n        end\n    end\n    l\n\
    end", "  l = l.sort_by { |x| x % 2 }\n  l.each { |x| l[x.to_i] = x }\n  l\nend\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nSorry, but i think that this doesn't sort\
    \ correctly your array. `sort_even([3, 6, 5, 4])` returns `[3, 6, 5, 4]`\n<|/\
    \ c |>\n<| c |>\nYes, you're right, I forgot that it should use the same sort\
    \ on even and odd indicies. It's fixed now. The \"problem\" is that the `sort_by`\
    \ method returns an array (well, an `Enumerator`) in Ruby 1.8.7 (at least), while\
    \ in Ruby 1.9.1 it returns an array-like object (like `Array` in Ruby 1.8.7).\n\
    <|/ c |>\n<| a |>\nHere is a pure Ruby solution using Enumerable#each_with_index\
    \ and Enumerable#map in Ruby 1.9+:\n<code>", "  even = []\n  odd = []", "  l2\
    \ = []\n  even = l.select { |x| x % 2 == 0 }\n  even.each { |x| l2.push x }\n\
    \  odd = l.select { |x| x % 2 == 1 }\n  odd.each { |x| l2.push x }\n  l2.sort\n\
    end", "  l2 = []\n  l2.zip(l).each do |x|\n    x[1] = x[1].sort\n    l2.push(x)\n\
    \  end\n  l2\nend", "    even = []\n    odd = []\n    even.concat l\n    odd.concat\
    \ l\n    even.each do |e|\n        if even.index(e) % 2 == 1\n            even.delete\
    \ e\n        else\n            odd.delete e\n        end\n    end\n    even.concat\
    \ odd\nend", "  even = [l[i] for i in range(len(l)) if i % 2 == 0]\n  even.sort!\n\
    \  even\nend\n</cell>\n<text>\nThis was a little tricky. We created an even list\
    \ and sorted it, but then we lost the original list. Instead, we returned the\
    \ sorted list to our caller. Notice that we didn't reassign l to the return value.\
    \ That is because the function sort_even has already modified l and returns it.\
    \ The function sort_even can only do one thing: return l.", "  sorted = []\n \
    \ sorted = sorted.concat l[0..-1] if l.size % 2 == 0\n  sorted = sorted.concat\
    \ l[2..-1] if l.size % 2 == 1\n  sorted = sorted.concat l[2..] if l.size % 2 ==\
    \ 1\n  sorted = sorted.concat l[1..] if l.size % 2 == 0\n  sorted = sorted.concat\
    \ l[0..2] if l.size % 2 == 0\n  sorted = sorted.concat l[2..] if l.size % 2 ==\
    \ 1\n  sorted = sorted.concat l[0..2] if l.size % 2 == 1\n  sorted = sorted.concat\
    \ l[1..] if l.size % 2 == 0\n  sorted = sorted.concat l[0..1] if l.size % 2 ==\
    \ 0\n  sorted = sorted.concat l[2..] if l.size % 2 == 1\n  sorted = sorted.concat\
    \ l[0..1] if l.size % 2 == 1\n  sorted = sorted.concat l[1..] if l.size % 2 ==\
    \ 0\n  sorted = sorted.concat l[0..] if l.size % 2 == 0\n  sorted = sorted.concat\
    \ l[2..] if l.size % 2 == 1\n  sorted = sorted.concat l[0..] if l.size % 2 ==\
    \ 1\n  sorted = sorted.concat l[1..] if l.size % 2 == 0\n  sorted = sorted.concat\
    \ l[0..] if l.size % 2 == 0\n  sorted = sorted.concat l[2..] if l.size % 2 ==\
    \ 1\n  sorted = sorted.concat l[0..] if l.size % 2 == 1\n  sorted = sorted.concat\
    \ l[1..] if l.size % 2 == 0\n  sorted = sorted.concat l[0..] if l.size % 2 ==\
    \ 0\n  sorted = sorted.concat l[2..] if l.size % 2 == 1\n  sorted = sorted.concat\
    \ l[0..] if l.size % 2 == 1\n  sorted = sorted.concat l[1..] if l.size % 2 ==\
    \ 0\n  sorted = sorted.concat l[0..] if l.size % 2 == 0\n  sorted = sorted.concat\
    \ l[2..] if l.size % 2 == 1\n  sorted = sorted.concat l[0..] if l.size % 2 ==\
    \ 1\n  sorted = sorted.concat l[1..] if l.size % 2 == 0\n  sorted = sorted.concat\
    \ l[0..] if l.size % 2 == 0\n  ", "  l = l.dup\n  l.sort!\n  (0..l.size/2).reverse_each\
    \ do |n|\n    l[n], l[n*2] = l[n*2], l[n]\n  end\n  l\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby,arrays,algorithm dscore=0 |>\n<code>\nrequire 'set'", "  even_values\
    \ = []\n  odd_values = l.clone\n  even_values.unshift(l[0])\n  odd_values.pop\n\
    \  for i in 0..even_values.size\n    odd_values.insert(even_values.size - i -\
    \ 1, even_values[even_values.size - i])\n    even_values.delete(even_values.size\
    \ - i)\n  odd_values.reverse\n  even_values.reverse\n  odd_values.unshift(l[0])\n\
    \  even_values.unshift(l[0])\n  return odd_values\nend", "    even = []\n    odd\
    \ = []\n    even = even.concat(l)\n    odd = odd.concat(l)\n    even = even.sort\n\
    \    odd = odd.sort\n    odd.each_index { |x| even[x] = even[x] }\n    even.each_index\
    \ { |x| odd[x] = even[x] }\n    odd.each_index { |x| even.delete_at(x) }\n   \
    \ even.each_index { |x| odd.delete_at(x) }\n    even.concat(odd)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nIt's interesting that the \"odd\" case is the same as the \"\
    even\" case, since `sort` already uses insertion sort. Also, it's interesting\
    \ that the \"even\" case uses two passes of the array.\n<|/ c |>\n<| c |>\nI was\
    \ actually hoping to find a solution that didn't use an intermediate array at\
    \ all, and didn't use \"each_index\"...but of course it looks like that isn't\
    \ possible.\n<|/ c |>\n<| c |>\n: I added a much simpler solution that doesn't\
    \ use an intermediate array.\n<|/ c |>\n<| c |>\n: I added a much simpler solution\
    \ that uses no intermediate array.\n<|/ c |>\n<| c |>\n: I added a solution that\
    \ doesn't use an intermediate array, but does use \"each_index\".\n<|/ c |>\n\
    <| a dscore=0 |>\nHere's another one that doesn't use an intermediate array. \n\
    <code>", "  l' =()\n  l.each_with_index do |el, ind|\n    el == l[ind] and el\
    \ = l[ind] if ind % 2 == 0\n    l' << el\n  end\n  l'\nend", "  l.each_index {|i|\
    \ l[i] = l[i].odd? l[i] + l[i - 1] : l[i]}\n  l\nend", "    odd = l.select{ |x|\
    \ x % 2 == 0 }\n    even = l.select{ |x| x % 2 == 1 }", "  # sort the even indicies\
    \ of l into their original positions before sorting\n  # and only sort the even\
    \ indicies of the list into their original values\n  l.sort_by!{ |i| i%2 == 0}\n\
    \  l\nend\n</code>\n<|/ a tags=sorting,ruby,arrays |>\n<| a |>\n<code>", "  #\
    \ Make l a copy of l since we don't want to modify l\n  new_l = l.dup", "    even_indexes\
    \ = []\n    odd_indexes = []\n    for i in 0..(l.length/2).to_a\n        even_indexes\
    \ << i\n        odd_indexes << i+1\n    end\n    even_indexes.sort!\n    odd_indexes.sort!\n\
    \    (even_indexes + odd_indexes).sort!\n    even_indexes.each { |i| l[i] = l[even_indexes.index(i)];\
    \ }\n    l\nend", "  l.sort!\n  l.each_with_index do |e, i| l[i.to_s] == l[(i+1).to_s]\
    \ and l[i.to_s] = e end\n  l\nend", "  even_idx = 0.upto(l.size - 2) do |i|\n\
    \    if l[i] % 2 == 0\n      even_idx\n    else\n      even_idx = i\n    end\n\
    \  end\n  even_idx\nend", "  l.size.times do |i|\n    if i.odd?\n      l[i] =\
    \ l[i].sort do |a, b|\n        a <=> b\n      end\n    end\n  end\n  l\nend",
  "  even = []\n  odd = []\n  l.each_with_index do |e, i|\n    if i % 2 == 0\n   \
    \   even << e\n    else\n      odd << e\n    end\n  end\n  even.zip(odd).sort\n\
    end", "  l.each_with_index do |x, i|\n    l[i] = l[i-1] if (i&1)\n  end\n  l\n\
    end", "  evens = l.select.with_index.with_object([])\n  odds = l.select.with_index.with_object([])\n\
    \  evens.each { |e, i| odds[i] += e }\n  evens.map { |e| e.last.last }\nend",
  "  sorted = []\n  even = []\n  sorted = sorted.concat(l)\n  even = even.concat(l)\n\
    \  even.sort!\n  sorted = sorted.concat(even)\n  return sorted\nend", "  l2 =\
    \ []\n  i = 0\n  while i < l.length\n    l2 << l[i] if i % 2 == 0\n    l2 << l[i]\
    \ if i % 2 == 1\n    i += 1\n  end\n  l2\nend", "  # This first loop makes the\
    \ list odd\n  odds = l[0..l.length-1]\n  # This second loop makes the list even\n\
    \  evens = l[2..l.length]\n  # This third loop makes the list even while sorting\
    \ it by the even indicies\n  evens.sort.each_with_index do |e, i|\n    l[i] =\
    \ e\n  end\n  # This fourth loop makes the list odd while sorting it by the odd\
    \ indicies\n  evens.sort.each_with_index do |e, i|\n    l[i+2] = e\n  end\n  #\
    \ This fifth loop makes the list odd\n  l\nend\n</code>\n<|/ a dscore=0 tags=ruby\
    \ |>\n<| c |>\nAren't you supposed to use an indexing technique for the final\
    \ result? `l[0..l.length-1] == l.drop_while { |i| !i.even? }`\n<|/ c |>\n<| c\
    \ |>\n, I'm not a Ruby programmer, but yes, that would be better than my approach.\n\
    <|/ c |>\n<| c |>\nThis doesn't work with odd numbers, though.\n<|/ c |>\n<| c\
    \ |>\nI edited my answer to reflect your comment.  I haven't actually tested my\
    \ code so I'm not sure how well it works.\n<|/ c |>\n<| a tags=ruby |>\n<code>\n\
    \  def evens(array)\n    array.map{|e| e.even? ? e : -e}\n  end", "    even =\
    \ l[0::2]\n    odd = l[1::2]\n    even.zip(odd)\nend", "  l.sort.with_index{ |v,\
    \ i| i % 2 == 0 ? v : v }\nend", "  even_index = 0.even?.length\n  return l.sort_by{\
    \ |i| i.odd? ? (i.zero? ? i : i + even_index) : i }\nend\n</code>\nI wanted to\
    \ post an example of how to use this helper, which was posted by Jakub Nar\u0119\
    bski.\n<code>", "  l.sort!\n  odds = l.find_all { |i| (i%2) }\n  evens = l.find_all\
    \ { |i| (i%2 == 0) }\n  evens.zip(evens).map { |ev,ei| ev += ei }\n  l.concat(odds)\n\
    end", "    even_index = -1\n    odd_index = -1\n    sorted_even = []\n    sorted_odd\
    \ = []", "  even = l.select { |x| x.even? }.sort\n  even.zip(l).flatten!\n  even\n\
    end", "  sorted = []\n  sorted_even = []\n  sorted_odd = []\n  i = 0\n  while\
    \ i < l.size\n    unless l[i]%2 == 0 # or l[i].even?\n      sorted_even = sorted_even.push(l[i])\n\
    \      i += 1\n    else\n      sorted_odd = sorted_odd.push(l[i])\n      i +=\
    \ 1\n    end\n  end\n  sorted = sorted_even.concat(sorted_odd).sort\n  sorted\
    \ = sorted.concat(sorted_even).sort\n  return sorted\nend", "  even = []\n  odd\
    \ = []\n  l.each_with_index do |elem, idx|\n    if idx % 2 == 0\n      even <<\
    \ elem\n    else\n      odd << elem\n    end\n  end\n  even.zip(odd).flatten\n\
    end", "  l.each_index do |i|\n    yield(l[i])\n  end\nend", "  l2 = l.dup\n  l2.sort!\n\
    \  l2.each_with_index {|e, i| l2 if i%2 == 0 }.each {|e| l2 << e}\n  l2\nend",
  "  return l.map { |n| n if n % 2 == 0 }\nend", "  l.each_with_index do |value, index|\n\
    \    (index % 2 == 0) ? (l[index] = value, l[index+1] = value, l[index+2] = value)\
    \ : l[index] = value\n  end\n  l\nend", "  even = []\n  odd = []\n  even.concat(l)\n\
    \  odd.concat(l)\n  even.sort\n  odd.sort\n  even.zip(odd).each { |v| v.sort!\
    \ }\n  even\nend", "  l.each_with_index do |v, i|\n    v.even? ? l.delete_at(i)\
    \ : v\n  end\n  l\nend", "    even = []\n    odd = []\n    for x in l:\n     \
    \   if x % 2 == 1:\n            odd.append(x)\n        else:\n            even.append(x)\n\
    \    return even+odd", "  sorted_even = [l[0], l[1], l[2]]\n  sorted_even.each_with_index\
    \ do |element, index|\n    if index % 2 == 0\n      sorted_even[index] = element\n\
    \    end\n  end\n  sorted_even\nend\n</code>\n<|/ a dscore=0 tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nYour code doesn't work. It returns `[9, 7, 3, 5]` instead of `[7,\
    \ 3, 9, 5]`.\n<|/ c |>\n<| c |>\nIt seems that it works on irb as well, maybe\
    \ something went wrong when pasting it into my terminal.\n<|/ c |>\n<| c |>\n\
    Hmm, interesting. I copied your code and run it on irb. it works but then I copied\
    \ it into my terminal and run it, and I get `[7, 3, 9, 5]`. I'm using ruby 2.2.0p0.\n\
    <|/ c |>\n<| c |>\nRuby is weird.. it's working on my local version but not my\
    \ production server's version. Seems like it's something to do with the version\
    \ differences. I'll have to research that further to see what's going on there.\n\
    <|/ c |>\n<| c |>\nIt seems related to `each_with_index`. I updated the code to\
    \ use `each_with_index(1)` which fixed my problem. Thanks for the help!\n<|/ c\
    \ |>\n<| a tags=ruby,sorting,arrays dscore=0 |>\n<code>\narr = [7, 3, 5, 9, 1]\n\
    p arr.sort_by{|x| x[1..-1]}\n</code>\n<|/ a |>\n<| c |>\nThis does not answer\
    \ the question. He wants to sort the array by first element in descending order.\n\
    <|/ c |>\n<| c |>\nIt does. See the comment under the question. He wants the even\
    \ elements to be in ascending order and the odd ones to be in descending order.\n\
    <|/ c |>\n<| c |>\n`arr.sort` sorts in ascending order. The question was asking\
    \ to sort in descending order. Also, his question says \"sort the array by its\
    \ value at the even indicies\", so the order of the even elements isn't relevant.\n\
    <|/ c |>\n<| a tags=ruby,sorting,arrays |>\nYou can use each_with_index and then\
    \ sort the array based on the index. \n<code>\narr = [7, 3, 5, 9, 1]\narr.each_with_index\
    \ do |val, i|\n    if i % 2 == 0\n        arr[i] = val.reverse\n    end\nend",
  "  even = l[1..-1]\n  odd = l.last(1)\n  even.zip(odd).sort.reverse_each.reverse\n\
    end", "    even = []\n    odd = []\n    even = l.inject(even, :<<)\n    even =\
    \ even.sort.uniq\n    even.each { |i| odd.push((i.odd? ? i : i.even? ? i.odd :\
    \ i.even).value) }\n    odd.zip(even).flatten\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThanks for your answer! I am still very confused with this solution.\
    \ How does the code know that odd is an array and not an integer? Also, what does\
    \ the `<<` do after each `sort`? The odd indicies in the even indicies and vice\
    \ versa?\n<|/ c |>\n<| c |>\nI have edited my answer to make it clearer. The `<<`\
    \ method is an alias for `push` so `odd.push(...)` and `even.push(...)` both accomplish\
    \ the same thing as `odd << ... << even`.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nThe simplest way to do this is:\n<code>\nl = [ 1, 3, 5, 7, 9, 11, 13, 15\
    \ ]", "  even = []\n  odd = []\n  l.each do |x|\n    odd << x\n    x % 2 ? even.push(even.shift)\
    \ : even.push(even.shift)\n  end\n  odd.concat(even)\nend", "  l.each_with_index\
    \ do |v, i|\n    v.even? ? l[i] = v : l[i] = v.odd? ? v + 1 : v - 1\n  end\n \
    \ l\nend", "  even = []\n  odd = []\n  l.each_index do |i|\n    even << l[i] if\
    \ i % 2 == 0\n    odd << l[i] if i % 2 == 1\n  end\n  [even, odd]\nend", "  sorted\
    \ = []\n  for i in 0...l.length-1\n    if l[i] % 2 == 0\n      sorted.push(l[i])\n\
    \      sorted.push(l[i+1]) if i < l.length-1\n    else\n      sorted.push(l[i])\
    \ if i < l.length-1\n      sorted.push(l[i+1]) if i+1 < l.length-1\n    end\n\
    \  end\n  sorted\nend", "  even = []\n  odd = []", "  l.each_with_index { |el,\
    \ index| l[index] = (el % 2 == 0 ? el : el + 2) }\n  l\nend", "    even = []\n\
    \    odd = []\n    \n    for el in l\n        if el <= 0\n            odd.push(el)\n\
    \        else\n            even.push(el)\n    end\n    \n    even.zip(odd).each\
    \ { |a| a.unshift(a[0]) }\n    even.sort()\n    return even\nend\n</cell>\n<cell>",
  "  return l.sort.reverse.map { |i| i % 2 ? i : l[i] }\nend", "  l.sort.each_with_index\
    \ {|item, index| l[index] = item}\n  return l\nend", "  even = even_indexes(l)\n\
    \  odd = odd_indexes(l)\n  even.zip(odd).each do |e| e[1] = e[0].sort_by {|x|\
    \ x % 2}.last.dup; end\n  even\nend", "    even = l.select { |x| x.even? }\n \
    \   even.sort!\n    even\nend", "  l.each_with_index do |x, i|\n    next if i%2\
    \ == 0\n    l[i-1], x = x, l[i-1]\n  end\n  l\nend", "  l.each_with_index do |element,\
    \ i|\n    if i.odd?\n      l[i] = element\n    end\n  end\n  l\nend", "  l.each_index\
    \ { |i| l[i] = l[i].sort { |a, b| b <=> a } }\n  l\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThis is not an answer, this is just a comment - please read [How\
    \ to Answer page](http://stackoverflow.com/questions/how-to-answer), your answer\
    \ should contain at least an explanation for the code\n<|/ c |>\n<| a dscore=2\
    \ |>\nIn Ruby you can do this:\n<code>\n[1, 2, 3, 4, 5].sort\n</code>\nOr:\n<code>\n\
    [1, 2, 3, 4, 5].sort!\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nNote that\
    \ `sort_by` doesn't exist in Ruby 1.8. You'll need to use `sort` instead.\n<|/\
    \ c |>\n<| a tags=ruby,arrays dscore=2 |>\nI find this to be the most efficient\
    \ way to do it:\n<code>", "    even, odd = [], []\n    even.extend l, l[::2]\n\
    \    odd.extend l, l[1::2]\n    even.sort { |a, b| b <=> a }\n    even.map { |x|\
    \ x + 1 } + odd.map { |x| x - 1 }\nend\n</cell>\n<code language=julia-1.5>\nusing\
    \ BenchmarkTools, Plots; pyplot()\nl = sort(rand(1000000))\n@btime sort_even(l)\n\
    </cell>\n<text>\nExercise 3: Using Arrays", "  even_index = []\n  odd_index =\
    \ []\n  even_index.push(l[0])\n  odd_index.push(l[0])", "  even = l.select { |x|\
    \ (x % 2).zero? }\n  even.map! { |x| x.to_i }\n  even.sort!\n  even\nend\n</code>\n\
    <|/ a |>\n<| c |>\nWhile this link may answer the question, it is better to include\
    \ the essential parts of the answer here and provide the link for reference. Link-only\
    \ answers can become invalid if the linked page changes.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=2 |>\nHere's a general solution, inspired by Jordan's answer:\n<code>",
  "  even = l[1..-1].select{ |x| x % 2 == 0 }\n  even.zip( even.map(&:last).sort.reverse\
    \ ).each { |x| l[x.last] = x.first }\n  l\nend", "  even = []\n  odd = []\n  l.each\
    \ do |i|\n    if i % 2 == 0\n      even << i\n    else\n      odd << i\n    end\n\
    \  end\n  even.zip(odd).sort\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n+1 for\
    \ \"list comprehensions look awesome\". You could make them even better with some\
    \ destructuring, `even, odd = [i%2 for i in l].partition`.\n<|/ c |>\n<| c |>\n\
    , thanks.  I didn't know that `partition` existed until now.  But I do know `sort`\
    \ can take a block argument (for sorting by multiple arguments) so it would still\
    \ be cool.\n<|/ c |>\n<| c |>\n, thanks again for sharing your answer. I revised\
    \ it to be more efficient and use only 2 passes through the list. Cheers!\n<|/\
    \ c |>\n<| c |>\n, thanks so much. I tried it out and it's definitely much cleaner.\
    \ One thing I'm still not sure about: why would you use a `while` loop instead\
    \ of a `for` loop?\n<|/ c |>\n<| c |>\n, no particular reason, except for readability.\
    \ `for` loops are more succinct because they don't use an index variable, but\
    \ also because `while` loops make more sense if you need to do something repeatedly.\
    \  If you don't need to do anything repeatedly, a plain `for` loop will do just\
    \ fine.  And if you do need to do something repeatedly, a `while` loop is easier\
    \ to understand.\n<|/ c |>\n<| a tags=ruby,loops |>\nIf your list is sorted, this\
    \ would be pretty straightforward:\n<code>", "  return l.each_with_index.map do\
    \ |(elem, idx), i|\n    if idx % 2 == 0\n      elem\n    else\n      l[idx].tap\
    \ { l[idx] = nil }\n    end\n  end\nend", "  l2 = []\n  n.times do\n    l2 <<\
    \ l.pop\n  end\n  l2.each_with_index do |val, i|\n    l2[i] = val\n  end\n  l2\n\
    end", "  even = l[1..-1].select { |i| i.odd? }\n  even.extend(l[1..-1])\n  even.sort!\n\
    \  even.compact!\n  even\nend", "  l.each_with_index do |e, i|\n    l.delete_at(i)\n\
    \    l.insert(i, e)\n  end\n  l\nend", "  l.each_with_index { |e, i| l[i.to_i\
    \ % 2 == 0 ? i + 1 : i-1] = e}\n  l\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    This doesn't work in the case of a single element list.\n<|/ c |>\n<| c |>\nThat's\
    \ a very good point.  I'll edit the answer to fix that.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>\n[1,2,3,4].sort { |a,b| a<=>b } # => [1,2,3,4,]\n</code>\nIf you're\
    \ not happy with sort's default of using <=>, just do this:\n<code>\n[1,2,3,4].sort\
    \ { |a,b| a.to_i <=> b.to_i }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis works\
    \ only in Ruby 1.8.7 onwards.\n<|/ c |>\n<| a |>\nA slight modification of Eli's\
    \ answer, with more explanation and a better naming.\nThis one uses the standard\
    \ <=> operator and sorts the array in place, using Enumerable#sort_by.\n<code>",
  "  even = l.dup\n  even.each_with_index do |e, i|\n    if i%2 == 0\n      even[i]\
    \ = e + 1\n      even.sort_by! { |x| x }\n      even.delete(e + 1)\n    end\n\
    \  end\n  even\nend\n</cell>\n<cell>", "  l2 = []\n  odd_l = l[1..-1]\n  even_l\
    \ = l[2..-1]\n  \n  l2.concat(odd_l).concat even_l\n  \n  l2.each_with_index do\
    \ |v, i|\n    if i % 2 == 0\n      l2.insert(i, v)\n    end\n  end\n  \n  l2\n\
    end", "  even = []\n  odd = []\n  \n  even.concat l\n  even.each do |item|\n \
    \   odd << item\n  end", "  l.each.with_index do |value, index|\n    next if index\
    \ % 2 == 0\n    l.insert(index, value)\n  end\n  l\nend\n</code>\nAs you can see,\
    \ it's pretty much the same as the one from your code but with an added sort in\
    \ the even indices only, and the use of each_with_index instead of.each.\n<|/\
    \ a dscore=3 |>\n<| c |>\nThat's brilliant, thank you! I was trying to make my\
    \ own version that didn't use a loop, but I couldn't quite figure it out. Thanks\
    \ again.\n<|/ c |>\n<| a dscore=2 tags=ruby,sorting |>\nHere's a way to do it\
    \ without loops and without sorting.\n<code>\nary = [1, 3, 10, 6, 4, 2]", "  l2\
    \ = []\n  even_index = 0\n  odd_index = 1\n  i = 0\n  while i < l.length\n   \
    \ if i % 2 == 0\n      l2 << l[even_index]\n      even_index += 1\n    else\n\
    \      l2 << l[odd_index]\n      odd_index += 1\n    end\n    i += 1\n  end\n\
    \  l2 << l[odd_index]\n  l2 << l[even_index]\n  return l2\nend", "  l.sort!\n\
    \  evens = []\n  odds = []\n  (0...l.length).each do |index|\n    odds << l[index]\
    \ if index % 2 == 1\n    evens << l[index] if (index % 2) == 0\n  end\n  evens\n\
    end\n</code>\nIf you don't know Python, then I would recommend reading about iterators\
    \ and generators, they are really useful for this sort of thing.\n<|/ a tags=ruby,sorting,python\
    \ |>\n<| c |>\nThanks very much. I tried googling iterators and generators, but\
    \ I didn't understand how they worked. Are they the same thing in Ruby?\n<|/ c\
    \ |>\n<| c |>\nA Python iterator is a class that has `__iter__` and `next` methods.\
    \ Ruby also has iterators but they are called Enumerators (which can be confusing\
    \ with Python iterators).  See [this article](http://rubylearning.com/blog/2006/06/iterators-in-ruby).\n\
    <|/ c |>\n<| a tags=ruby,sorting,python |>\nIn ruby we can use \n<code>\n[1,2,3,4].sort.each_with_index\
    \ { |i,j| j%2 == 1 ? [i*2,i] : i }", "  even = l[0..-2]\n  odd = l[1..-1]\n  even.zip(even).map\
    \ { |x, y| [x, y]}.sort.uniq.concat odd\nend", '  l.sort!', "  even = l[1..-1]\n\
    \  odd = l[0..-2]\n  even.zip(odd).sort.map {|x, y| x if x==y else x}.concat(even)\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| a tags=ruby |>\nHere's how I did\
    \ it:\n<code>", "  l.each_index do |i|\n    if i.odd?\n      l[i] = l[i].to_s\n\
    \    end\n  end\n  l.sort\nend", "  evens = l.select { |x| x % 2 == 0 }\n  evens.each\
    \ { |even| even.sort! }\n  evens\nend", "  l.each do |x|\n    if x % 2 == 0\n\
    \      x.to_i\n    else\n      x + 1\n    end\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby,arrays |>\nI assume you want to sort the elements inside\
    \ the array and have them in a new array according to their position in the sorted\
    \ array. For example if the array is [2,4,1,3] the sorted array should be [1,1,2,4,3].\n\
    <code>", "    even = nil\n    odd = nil\n    if l.length == 1 or l.length == 0\n\
    \        return l\n    end\n    even = l.slice(0,l.length/2)\n    odd = l.slice(l.length/2,l.length)\n\
    \    even.each do |x|\n        x = x + 1 until [odd[x], x].max.to_i > [even[x],\
    \ x].min.to_i\n    end\n    even.concat(odd.sort).reverse\nend\n</code>\nEDIT:\n\
    <code>", "  sorted = false\n  even = l.slice!(0..-1)\n  odd = l.slice!(0..-1)\n\
    \  even.zip!(0..-1) { |e| odd << e }\n  even << even.max\n  odd << odd.max\n \
    \ l = even + odd\n  return l unless sorted = true\n  sorted = false\n  l = l +\
    \ [sorted = true]\n  l = sort_odd(l) if !sorted and not l.is_a? Array\n  return\
    \ l\nend", "    even_indexes = []\n    odd_indexes = []", "  l.each_with_index\
    \ do |val, index|\n    l[index] = (index&1) ? val : val.sort\n  end\n  l\nend",
  "    even = []\n    odd = []\n    \n    even.concat(l)\n    even.each_with_index\
    \ do |e, i|\n      odd << e\n      odd << even[i]\n    end\n    \n    even.clear\n\
    \    even.concat(odd)\n    \n    even\nend\n</code>\n<|/ a dscore=1 tags=ruby,sorting,arrays\
    \ |>\n<| a |>\nHere's a slightly more functional approach:\n<code>", "  l.each_with_index\
    \ do |x, i|\n    next if i.odd?\n    l[i-1] = x if l[i-1].nil?\n    l[i-1].each_index\
    \ do |j|\n      break if j == i\n      l[i-1][j-1] = l[i-1][j] if l[i-1][j].nil?\n\
    \      l[i-1][j-1] = l[i-1][j-1] if l[i-1][j-1].nil?\n    end\n  end\n  l\nend",
  "  even = l.cycle(l)\n  odd  = even.cycle(even)\n  even.next!\n  odd.next!\n  even.next!\n\
    \  even.next!\n  even.next!\n  odd.next!\n  even.next!\n  odd.next!\n  even.next!\n\
    \  even.next!\n  even.next!\n  odd.next!\n  even.next!\n  odd.next!\n  even.next!\n\
    \  odd.next!\n  even.next!\n  even.next!\n  even.next!\n  odd.next!\n  even.next!\n\
    \  odd.next!\n  even.next!\n  odd.next!\n  even.next!\n  even.next!\n  odd.next!\n\
    \  even.next!\n  even.next!\n  odd.next!\n  even.next!\n  even.next!\n  odd.next!\n\
    \  even.next!\n  even.next!\n  odd.next!\n  even.next!\n  even.next!\n  even.next!\n\
    \  odd.next!\n  even.next!\n  odd.next!\n  even.next!\n  even.next!\n  even.next!\n\
    \  odd.next!\n  even.next!\n  odd.next!\n  even.next!\n  even.next!\n  odd.next!\n\
    \  even.next!\n  even.next!\n  odd.next!\n  even.next!\n  even.next!\n  even.next!\n\
    \  odd.next!\n  even.next!\n  odd.next!\n  even.next!\n  even.next!\n  even.next!\n\
    \  odd.next!\n  even.next!\n  odd.next!\n  even.next!\n  even.next!\n  odd.next!\n\
    \  even.next!\n  even.next!\n  even.next!\n  odd.next!\n  even.next!\n  odd.next!\n\
    \  even.next!\n  even.next!\n  even.next!\n  odd.next!\n  even.next!\n  odd.next!\n\
    \  even.next!\n  even", "  l = l.sort\n  l[0]\n  for i in 0...l.length / 2\n \
    \   l[i]\n  end\n  l\nend", "  even = l.clone\n  even.insert(even.size - 2, even.first)\n\
    \  even.sort(&:<)\n  even.insert(even.size - 2, even.last)\nend", "  sorted =\
    \ []\n  even = []\n  l.each_index do |i|\n    if i % 2 == 0\n      even << l[i]\n\
    \    else\n      sorted.push(l[i])\n    end\n  end\n  sorted.concat(even)\nend\n\
    </code>\n<|/ a tags=sorting,ruby,ruby-on-rails |>\n<| c |>\nThanks for the help.\
    \  I used your solution and it works perfectly.  However, I wanted to see what\
    \ other people thought.  I'm still trying to wrap my head around this.  I appreciate\
    \ your time and effort.\n<|/ c |>\n<| c |>\nThanks for the solution, it helped\
    \ me a lot! Although, now it only sorts even numbers.\n<|/ c |>\n<| c |>\nYes\
    \ that's correct, just fixed it a while ago!\n<|/ c |>\n<| a |>\nAs noted in the\
    \ comments, this can be done with a single pass through the array. There are some\
    \ possible optimizations we could make here, but that's probably too much for\
    \ now, so let's just take it apart to see what's going on:\n<code>", "  even =\
    \ l[1..-1]\n  odd = l[0..-2]\n  even.zip(odd).sort.reduce(:+)\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nThe first answer gives a solution that's\
    \ O(n*log(n)), which is great, but it's only as fast as O(n^2) because it requires\
    \ sorting the entire list, which isn't ideal in practice. You can also get it\
    \ to perform faster than O(n^2) by using a hash to map your numbers to their corresponding\
    \ position in the list. It will still be O(n^2) worst case, but it's much faster.\n\
    <code>", "  l.each_with_index do |e, i|\n    if i % 2 == 0\n      l[i] = l[i].sort\n\
    \    end\n  end\n  l\nend\n</code>\n<|/ a |>\n<| c |>\nI tested it out in irb\
    \ with the array [1, 2, 3, 4, 5, 6] and this is the result I got:", "  return\
    \ l.sort.each_with_index.map do |e, i|\n    i & 1 ? (i & 2 ? e : l[i]) : e\n \
    \ end\nend", "  return l + l.reverse + l[0:1]\nend", "  return l.sort.with_index\
    \ { |a,i| (i % 2) == 0 ? (a <=> l[i.to_i]) : a }\nend", "  even = l.dup\n  odd\
    \ = l.dup\n  even.each_with_index do |v, i|\n    odd[i] = v if i % 2 == 0\n  end\n\
    \  even.sort\n  even\nend\n</pre>\n            </div>\n          </td>\n     \
    \   </tr>\n        <tr>\n          <td id=\"text-indent-methods\" valign=\"top\"\
    >\n            <div class=\"p\">\n              <p class=\"r\">\n            \
    \    <b>Text.indent</b>\n              </p>\n              <div class=\"indent\"\
    >\n                <div class=\"p\">\n                  <p class=\"r\">\n    \
    \                <b>text</b>\n                  </p>\n                  <p class=\"\
    r\">\n                    <b>:start_line</b>\n                  </p>\n       \
    \           <p class=\"r\">\n                    <b>:start_col</b>\n         \
    \         </p>\n                  <p class=\"r\">\n                    <b>:end_line</b>\n\
    \                  </p>\n                  <p class=\"r\">\n                 \
    \   <b>:end_col</b>\n                  </p>\n                  <p class=\"r\"\
    >\n                    <b>:indent_size</b>\n                  </p>\n         \
    \         <p class=\"r\">\n                    <b>:preserve_newlines?</b>\n  \
    \                </p>\n                  <p class=\"r\">\n                   \
    \ <b>:wrap_width</b>\n                  </p>\n                  <p class=\"r\"\
    >\n                    <b>:escape_html</b>\n                  </p>\n         \
    \         <p class=\"r\">\n                    <b>:html?</b>\n               \
    \   </p>\n                  <p class=\"r\">\n                    <b>:truncate</b>\n\
    \                  </p>\n                  <p class=\"r\">\n                 \
    \   <b>:truncated?</b>\n                  </p>\n                </div>\n     \
    \         </div>\n            </div>\n          </td>\n          <td id=\"text-text-methods\"\
    \ valign=\"top\">\n            <div class=\"p\">\n              <p class=\"r\"\
    >\n                <b>text</b>\n              </p>\n              <div class=\"\
    indent\">\n                <div class=\"p\">\n                  <p class=\"r\"\
    >\n                    <b>:start_line</b>\n                  </p>\n          \
    \        <p class=\"r\">\n                    <b>:start_col</b>\n            \
    \      </p>\n                  <p class=\"r\">\n                    <b>:end_line</b>\n\
    \                  </p>\n                  <p class=\"r\">\n                 \
    \   <b>:end_col</b>\n                  </p>\n                  <p class=\"r\"\
    >\n                    <b>:indent_size</b>\n                  </p>\n         \
    \         <p class=\"r\">\n                    <b>:preserve_newlines?</b>\n  \
    \                </p>\n                  <p class=\"r\">\n                   \
    \ <b>:wrap_width</b>\n                  </p>\n                  <p class=\"r\"\
    >\n                    <b>:escape_html</b>\n                  </p>\n         \
    \         <p class=\"r\">\n                    <b>:html?</b>\n               \
    \   </p>\n                  <p class=\"r\">\n                    <b>:truncate</b>\n\
    \                  </p>\n                  <p class=\"r\">\n                 \
    \   <b>:truncated?</b>\n                  </p>\n                </div>\n     \
    \         </div>\n            </div>\n          </td>\n          <td id=\"text-empty-methods\"\
    \ valign=\"top\">\n            <div class=\"p\">\n              <p class=\"r\"\
    >\n                <b>empty?</b>\n              </p>\n", "  l.each_with_index\
    \ { |e, i| l[i] = e if i % 2 == 0 }\n  l.sort!\n  l\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nUsing a recursive method and sorting:\n<code>", "    even\
    \ = l.each_with_index.map { |x, i| [x, i] }\n    odd = even.map { |x, i| [x, i]\
    \ }.select { |x| x[1] % 2 != 0 }\n    odd.each { |x| even.delete(x) }\n    even.each\
    \ { |x| odd.delete(x) }\n    even.concat(odd)\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\n<code>\n def sort_even(l) = l.sort.reverse\n    i=0=0\n    while\
    \ i<=.length do\n      if ((i%2)==0)\n      puts i\n      else \n      puts i\
    \ + 1 \n      end\n      i=i+1\n    end\n  end\n</code>\n<|/ a tags=ruby |>\n\
    <| a dscore=0 |>\nAnother way:\n<code>\na = [2, 5, 6, 1, 3]\np a.sort_by { |x|\
    \ x % 2 }.map! { |i| [i % 2, *a.values_at(i,3)] }", "  evens = l.each_with_index.with_object([])\
    \ { |(el, el_idx), res| res << el unless el_idx % 2 }\n  evens.sort.each_with_index.with_object([])\
    \ { |(el, el_idx), res| res << el unless el_idx.is_a?(Fixnum) }\nend", "  l.sort!\n\
    \  i = 0\n  l.each_with_index do |e,i|\n    next if i%2 == 0\n    l[i] = e\n \
    \ end\n  l\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| a dscore=0 |>\n\
    The sort_by method should do it:\n<code>", "  even = l.dup.select {|i| i & 1 !=\
    \ 0}.sort\n  even += l.dup.select {|i| i & 1 == 0}.sort # duplicate entries are\
    \ irrelevant\n  return even\nend", "  even = l.dup\n  even.sort { |a, b| a % 2\
    \ != b % 2 ? a <=> b : b <=> a }\n  even\nend", "  even = [l.index(x) for x in\
    \ l if l.index(x) % 2 == 0]\n  odd = [l.index(x) for x in l if l.index(x) % 2\
    \ == 1]\n  even.sort.concat [x for x in even if x not in odd]\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| a tags=ruby |>\n<code>", "  n = l.length\n  even = n.even?\n\
    \  l' =  l.sort_by { |x| x }\n  if even\n    l' = l'.map { |x| x[ 0..n/2 ] }\n\
    \  else\n    l' = l'.map { |x| x[ 0..n-1 ] }\n  end\n  l'\nend", "  l.each do\
    \ |e|\n    next if e % 2\n    l.insert(e, e)\n  end\n  l\nend", "  l.sort! { |x,\
    \ y| x % 2 == 0 ? x : y }\n  l\nend", "  l.sort!\n  even = (1..l.length).step(2).map{|i|\
    \ l[i] }\n  odd = l.size - even.size - l.take(even.size).size\n  l[0...even.size]\
    \ += even\n  l[even.size..l.size] += odd\n  l\nend", "  l.each_with_index do |element,\
    \ index|\n    even = index%2\n    if even != 0\n      l.insert(index, element)\n\
    \    end\n  end\n  l\nend", "  even = l.clone\n  even.sort!\n  (even[(even.size\
    \ - 1) / 2..-1] + even[0...even.size / 2]).each { |i| l[i] = l[i] * 2 }\n  l\n\
    end", "  return l[1..-1].sort { |a,b| a.odd? ? 1 : b.odd? ? -1 : a <=> b }\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThank you. This is great help!\n<|/ c |>\n<| c |>\n\
    No problem, glad to help!\n<|/ c |>\n<| a |>\nIn general, a good strategy here\
    \ is to step through the problem on a piece of paper, or on your desk if you are\
    \ familiar with those techniques.  \nFor example, consider the problem:", "  l.sort.with_index\
    \ { |x, i| x[i].odd? ? i : x.reverse }\nend\n</code>\nNow, if you pass an array\
    \ to the sort_even function, it returns the same array.  If you pass it a Hash,\
    \ it returns a Hash containing the same keys and values, with their values sorted.\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks for taking the time to provide an answer but\
    \ I think this could have been solved using simple ruby functions such as sort.with_index\
    \ (which does exactly what I need already) and no functional programming. Still\
    \ +1 though.\n<|/ c |>\n<| c |>\nYes, I didn't see that `sort_even` needed the\
    \ elements to be sorted, which I now see is what your question asks for.  I've\
    \ updated my answer to show how you can do that.\n<|/ c |>\n<| c |>\nWhat a strange\
    \ choice of language.  You say this works, now you say it's wrong?  Anyway, I've\
    \ updated my answer to show how to do that with only a single pass of the array.\n\
    <|/ c |>\n<| a dscore=1 |>\nAnother option is to convert your array to a hash,\
    \ and then sort the keys, and then convert the hash back to a array.\n<code>",
  "  return l.map { |x| x.odd? ? x : x.even ? x.sort_by { |x| x }[0...0] : x }.sort\n\
    end", "  even = []\n  odd = l\n  even.concat(odd[1..-1].sort)\n  return even\n\
    end", "  even = []\n  odd = []\n  for i in l\n    if i % 2 == 0\n      even.push(i)\n\
    \    else\n      odd << i\n  end\n  return even.concat(odd.sort)\nend", "  l.sort.reject\
    \ {|x| x%2 == 0}.uniq\nend", "  l.each_with_index { |item, i| l[i] = item if i\
    \ % 2 == 0 }\n  l.sort!\n  l\nend", "  evens = l.select { |x| x % 2 == 0 }\n \
    \ evens.sort!\n  return evens\nend", "  l.each_with_index { |x,i| x[i] = x[i.to_s].to_i\
    \ unless i == 0 }\n  l.sort\n  l\nend\n</code>\nThis can be simplified to:\n<code>",
  "  return l.sort.collect {|i| i & 1 ? (i & 2 ? l[i] : l[i >> 1]) : l[i]}\nend",
  "  return l.sort.each_with_index do |x, i|\n    x if i&1\n  end.sort_by{|x| x}\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI added some explanations on how this is working\n\
    <|/ c |>\n<| c |>\nThanks, but I still don't understand how you get this \"|x|\
    \ x\" in the sort_by block. Could you explain it?\n<|/ c |>\n<| c |>\nIt simply\
    \ means \"use the x value from the first element in the array to sort by it\"\n\
    <|/ c |>\n<| a |>\n<code>", "  even_values = l.select { |x| (x % 2).zero? }\n\
    \  even_values.sort!\n  even_values.product(l.map { |x| [x, x] }).flatten!\nend\n\
    </code>\n<|/ a dscore=4 |>\n<| a tags=sorting,arrays,ruby |>\n<code>", "    l.each_with_index\
    \ do |n, i|\n        if i % 2 == 0\n            l[i] = n\n        else\n     \
    \       if n % 2 == 0\n                l[i] = n / 2\n            else\n      \
    \          l[i] = n / 2 + 1\n            end\n        end\n    end\n    l.sort\n\
    end", "  evens = []\n  odd = []\n  for i in l\n    if i % 2 == 0\n      evens\
    \ << i\n    else\n      odd << i\n    end\n  end\n  return evens + odd\nend\n\
    </cell>\n<cell>", "  l.sort.with_index { |_, i| i%2 == 0 }.to_a\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,sorting,algorithm |>\n<| c |>\nWhat about `sort_even([5,2,3,1])`?\
    \ The OP wants 1, 3, 5, 2 to be sorted as 1, 3, 2, 5.\n<|/ c |>\n<| c |>\nMy answer\
    \ takes care of that, see it [here](http://pastie.org/204533). It's a tad inefficient,\
    \ but it's not an algorithmic problem, and it's still not too bad.\n<|/ c |>\n\
    <| c |>\nYes, I forgot about that case, I'll fix it.\n<|/ c |>\n<| c |>\nI believe\
    \ your approach would result in an incorrect sorting if the input array is empty\
    \ though, because it would return `[]` instead of `[1]`.\n<|/ c |>\n<| c |>\n\
    `sort_even` returns `nil` if the input array is empty. `nil.to_a` returns `[[]]`.\
    \ So, the code works as intended.\n<|/ c |>\n<| a dscore=1 |>\nOne approach is\
    \ to find the median of the list, then sort by the median, then find the median\
    \ again and sort by the median, etc.\n<|/ a tags=ruby,ruby-on-rails,sorting,algorithm\
    \ |>\n<| a dscore=1 |>\nYou can do this by breaking the list into two halfs, sorting\
    \ each half, concatenating the two halves, and then sorting each half, concatenating\
    \ the two halves, etc. I know it's not the most efficient solution, just one that\
    \ does what you want and is probably easy to understand.\n<|/ a tags=ruby,ruby-on-rails,sorting,algorithm\
    \ |>\n<| a tags=ruby,ruby-on-rails,sorting,algorithm |>\nThe median of list is\
    \ better than this one, but I thought I would add this because I couldn't find\
    \ any discussion on SO about this problem I thought I would add it for future\
    \ people trying to implement this problem in ruby or in any language.\n<code>\n\
    list = [2,3,5,7,1,9,8,3,5]", "  even = nil\n  odd = nil\n  even = even.dup\n \
    \ odd = odd.dup\n  even.sort!\n  odd.sort!\n  even.zip(odd).each {|e| l[e] = e}\n\
    \  l\nend\n</pre>\n</div>\n</div>\n</div>\n<p>\nThe last step is to define a function\
    \ that takes a list l, and returns the list <code>l</code> sorted by increasing\
    \ even values first, and then decreasing odd values.\n</p>", "  l.each_with_index\
    \ {|v, i| l[i] = v unless i % 2 == 0}\n  l.sort\nend", "  result = []\n  even_indexes\
    \ = l[0..l[-1]] % 2 == 0\n  even_indexes.each do |i|\n    even = even_indexes\
    \ == i\n    odd = !even_indexes == i\n    if even\n      result << l[i]\n    \
    \  result << l[i + 1]\n    else\n      result << l[i]\n    end\n  end\n  return\
    \ result\nend", "  l' =  l.sort_by { |e| e % 2 }.uniq\n  l'.each_with_index {\
    \ |e, i| l' [i] = l' [i] + 1 if i != e.to_i }\n  l''\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis isn't a great solution. It will cause a O(n^2) time complexity to\
    \ solve this.\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  even_values\
    \ = l.select { |x| x % 2 == 0 }\n  even_values.each_with_index do |v, i|\n   \
    \ even_values.slice!(i)\n  end\n  even_values.sort_by { |x| x }\nend\n</code>\n\
    The function sort_even takes a list of integers and sorts them by pairs of even\
    \ values, where the pairs are sorted from largest to smallest (this behavior is\
    \ different from sort_by!, where order is preserved when values are the same).\n\
    In Ruby >= 2.2, we can use the each_cons method on Enumerable (available in Ruby\
    \ >= 2.1.0) to do the same thing as slice_when:\n<code>", "  l2 = []\n  while\
    \ l.count > 1\n    l2.push l.shift\n  end\n  l.each_index { |i| l2.push l[i] }\n\
    \  l2\nend", "  sorted = l.clone\n  sorted.each_index do |i|\n    sorted[i % 2].swap(sorted[i])\n\
    \  end\n  sorted\nend", "  l.sort!\n  l.each_with_index do |element, index|\n\
    \    next if index%2 == 0\n    l.swap(index, index+1)\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails,sorting |>\n<| a |>\nAnother way without sort! \n\
    <code>", "  l.each_with_index { |element, i| l[i] = element if i%2 == 0 }\n  l.sort\n\
    \  l\nend", "  even = l.select { |x| x % 2 == 0 }\n  odd = l.select { |x| x %\
    \ 2 == 1 }\n  even.zip(odd).flatten!\nend\n</code>\n<|/ a dscore=1 tags=ruby,sorting\
    \ |>\n<| c |>\nYes, sorry. I was trying to explain the logic behind it. But I\
    \ see now it makes it more complicated than it needs to be.\n<|/ c |>\n<| c |>\n\
    Yeah, I see now. That's how I originally wrote it, but you were faster.\n<|/ c\
    \ |>\n<| c |>\nI added the other answer I came up with in case it helps anyone\
    \ else who is reading this.\n<|/ c |>\n<| a tags=ruby,sorting |>\nI figured it\
    \ out. This works for any size list. \n<code>", "  even_index = Array.new\n  odd_index\
    \ = Array.new\n  even_index.fill(0).each_with_index { |value, index| value.push(index)\
    \ }\n  odd_index.fill(0).each_with_index { |value, index| value.push(index + 1)\
    \ }\n  even_index.each_with_index do |value, index|\n    odd_index.each_with_index\
    \ do |other, other_index|\n      if even_index[other_index] == index\n       \
    \ odd_index[other_index] = even_index[other_index]\n        break\n      end\n\
    \    end\n  end\n  odd_index.each_with_index do |value, index|\n    even_index[index]\
    \ = value\n  end\n  return even_index\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\nThis is not an answer to the question.\n<|/ c |>\n<| a dscore=0 tags=ruby,arrays\
    \ |>\n<code>\na = a.each_with_index.group_by{|i,j| j % 2}.sort{|a,b| a[0] <=>\
    \ b[0]}.flatten.sort_by{|i,j| i}\n</code>\n<|/ a |>\n<| c |>\n`each_with_index`\
    \ is redundant here. `group_by` takes care of sorting for you\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>", "  even = [l[i] for i in 0...l.length if i%2 == 0]\n \
    \ even.sort\n  even.each_with_index do |e, n| l.insert n, e end\n  l\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nIt's a good answer, but your code is incorrect. `l`\
    \ is a bad variable name for a mutable array, it shadows the built-in `l` array.\n\
    <|/ c |>\n<| a dscore=1 tags=ruby,arrays,sorting |>\nAs you asked to give a code\
    \ without using an additional variable, here's a solution using a combination\
    \ of enumerable and inject methods.\n<code>\n[1, 2, 3, 4].inject([]) do |sorted,\
    \ e|\n  next sorted << e if e.odd?\n  sorted << e\nend", "  even = [l[i] for i\
    \ in range(len(l)) if i%2]\n  odd = [l[i] for i in range(len(l)) if i%2 == 1]\n\
    \  even.sort\n  odd.sort\n  even.push nil\n  odd.push nil\n  even.concat\n  odd.concat\n\
    end\n</code>\n<|/ a tags=algorithm,ruby,sorting dscore=1 |>\n<| c |>\nI see your\
    \ point. In the case of [1, 2, 3] where it is odd then even is [2,3] but this\
    \ is not a good example since it is also odd where it is even.\n<|/ c |>\n<| c\
    \ |>\nI don't see how this helps. For example, `sort_even([1, 2, 3])` returns\
    \ `[1, 2, 3]` whereas `sort_even([3, 1, 2])` returns `[3, 1, 2]`.\n<|/ c |>\n\
    <| c |>\nThe question was \"What is an efficient way to sort a list l into l'\
    \ and l' such that all even indicies in l' are equal?\" And my answer is that\
    \ there is a way to sort a list l such that all even indicies are equal. All you\
    \ need to do is to apply a function that takes the list as argument and returns\
    \ the list you want.\n<|/ c |>\n<| c |>\nI apologize, I didn't see you answer,\
    \ but your answer seems to ignore the fact that the even indicies are already\
    \ equal, and only sorts the odd indicies.\n<|/ c |>\n<| c |>\nNo. My answer does\
    \ sort both even and odd indicies, but only for evens indicies are equal\n<|/\
    \ c |>\n<| a dscore=1 |>\nYou could use this algorithm:\n<code>", "  even = []\n\
    \  odd = []\n  l.each_with_index { |e, i| i % 2 == 0 ? even << e : odd << e }\n\
    \  even.zip(odd).sort.flatten\nend\n</code>\n<|/ a |>\n<| c |>\nThanks, I will\
    \ try this out.\n<|/ c |>\n<| a |>\nThis is what I'd use (it uses Enumerable#chunk),\
    \ which was introduced in Ruby 1.9.2:\n<code>", "  even = []\n  odd = []\n  odd_vals\
    \ = []", "  l.sort { |a, b| a % 2 != b % 2 ? a : b }\nend", '  l.sort!', "  odd_index\
    \ = 0\n  even_index = 1", "  # We create a copy of l and sort it in place\n  l2\
    \ = l.clone\n  l2.sort!\n  # We then replace l's values at even indicies with\
    \ those of l2\n  (l2 & l).map! {|e| l2.index(e) }\n  l2\nend", "  return l.sort_by\
    \ { |x| x % 2 }.to_a\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\nSort with block\
    \ :\n<code>\n[10, 20, 30, 40, 50].sort_by {|x| x % 2}.map(&:to_i)", "  l2 = []\n\
    \  even_idx = []\n  odd_idx = []", "  l.sort! # Make sure the list is in order\n\
    \  l.each_with_index do |n,i|\n    if i % 2 == 0\n      l[i] = l[i+1]\n    end\n\
    \  end\nend", "  l.each_with_index do |value, index|\n    if index % 2 == 0\n\
    \      l[index] = value\n    end\n  end\n  l\nend", "  even = []\n  odd = []",
  "  l.each { |i| l[i.to_i]=l[i.to_i].to_i if i.odd? } if l.length>0\n  l.sort!\n\
    \  l\nend\n</code>\nThe sort_even method is very similar but slightly modified,\
    \ so I won't go over it here. However, here are two examples:\n<code>", "  l.each_with_index\
    \ { |x, i| l[i] = x if i % 2 == 0 }.sort_by(&:last).map(&:first)\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,algorithm |>\n<| a tags=ruby,ruby-on-rails,algorithm\
    \ |>\n<code>", "  l.each_index { |i| l[i] = l[i].clone if i % 2 == 0 }\n  l.sort_by\
    \ { |i| i }\nend", "  sorted = []\n  even = l.select.index(l[0])\n  l.select(*[even+1,\
    \ even+2].each_index{|i| sorted << l[i] })\n  sorted << l[even]\nend", "  even\
    \ = l.partition{|x| x % 2 == 0}\n  odd = l.partition{|x| x % 2 == 1}\n  even.concat(odd.reverse)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThat's great, thanks. I see what you did there.\
    \ I had a couple of issues though. Firstly, `sort_even.sort` isn't necessary.\
    \ Secondly, I didn't want to do anything with the unnecessary elements so I put\
    \ `odd` and `even` in the same array so that I could use `sort` on both and only\
    \ run through `l` once. I ended up using this `sort_even = l.partition{|x| x %\
    \ 2 == 0}.concat l.partition{|x| x % 2 == 1}.reverse`\n<|/ c |>\n<| a dscore=2\
    \ tags=ruby,sorting |>\nOne option is:\n<code>", "  l.each_with_index { |e,i|\
    \ l[i] = e if i%2 == 0 }\nend", "  # create a list of the even indicies of l\n\
    \  even_idx = []\n  i = 0\n  while i < l.length\n    # create a list l of the\
    \ even indicies of l\n    even_idx << i\n    i += 1\n  end\n  # sort l using the\
    \ even_idx list\n  l = l.sort_by { |x| l[even_idx.index(x)] }\n  # return the\
    \ sorted list\n  return l\nend\n</code>\nIn fact, the sort_even function could\
    \ be simplified to this:\n<code>", "  return [e for e in l if e % 2 == 0] + l[-1:]\n\
    end", "  return l.sort_by { |x| x % 2 } \nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nIt's not that hard for a beginner to understand what's going on...\
    \ the point of the exercise is to make it as clear as possible to the OP as well\
    \ as to help him.\n<|/ c |>\n<| c |>\nThis seems like a good solution, except\
    \ for one minor detail - the output should be sorted in descending order, and\
    \ not ascending. I was able to accomplish this by changing `sort_by` to `sort`,\
    \ but I'm not certain if there's a way to do it with `sort_by`.\n<|/ c |>\n<|\
    \ c |>\nSorry about that; my initial reaction was \"Oh, it's trivial, but I forgot\
    \ it when I wrote it!\" :) I've edited my answer to include a method that should\
    \ do what you want. I think it should work... but maybe someone can chime in.\n\
    <|/ c |>\n<| a |>\n<code>", "  even = l.dup\n  even.sort { |a, b| (a % 2) <=>\
    \ (b % 2) ? a <=> b : a <=> b }\n  even\nend", "  even = l.select { |x| (x % 2).even?\
    \ }\n  even.each do |e|\n    even.delete(e)\n    even.insert(even.index(e), e)\n\
    \  end\nend", "  n = l.length\n  l'.fill(n)\n  l'.each_with_index do |v, i|\n\
    \    if i % 2 == 0\n      l'[i] = v\n    end\n  end\n  l'\nend", "  # initialize\
    \ new list to hold values\n  l1 = []\n  # add all even indicies to list l\n  l1\
    \ += l[1..l.length]\n  # add all the odd indicies of l to l1 by removing from\
    \ l\n  l1 += l[1..l.length].reject {|i| l.index(i) % 2 == 1}\n  # return the new\
    \ list\n  l1\nend", "  l.sort!\n  l.each_with_index do |val, i|\n    next if i\
    \ == 0\n    l[i-1] = val if val %2 == 0\n    l[i-1] = l[i-1].to_i\n  end\n  l\n\
    end", "  l = [l[i], l[i + 1] while i < l.length-1 for i=0, 2..l.length-1]\n  l.sort!\n\
    \  l\nend", "  result = []\n  odd = nil\n  even = nil\n  i = 0\n  while i < l.length\n\
    \    if odd && even\n      result.push even\n      result.push odd\n      even\
    \ = nil\n      odd = nil\n      i += 1\n    elsif odd\n      result.push odd\n\
    \      odd = nil\n    elsif even\n      even = l[i]\n    else\n      odd = l[i]\n\
    \      i += 1\n    end\n  end\n  result\nend", "  l.sort.each_with_index { |n,\
    \ i| l.swap(i) if n % 2 == 1 }\n  l\nend", "  l2 = []\n  for i in 0...l.length\n\
    \    if i % 2 == 0\n      l2 << l[i]\n    else\n      l2 << l[i - 1]\n    end\n\
    \  end\n  l\nend", "  even = []\n  odd = []", "  sorted = l\n  odd = 1\n  even\
    \ = 0\n  while odd <= l.length\n    sorted = sorted.concat([sorted[even]])\n \
    \   odd += 1\n  end\n  while even < sorted.length\n    sorted = sorted.concat([sorted[odd]])\n\
    \    even += 1\n  end\n  sorted\nend\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    The \"sort by\" criteria is unclear. Is it simply the even numbers in the array?\
    \ Or is it any even number in the array?\nIf the criteria is simply \"any even\
    \ number in the array\", then just use Array#select.\n<code>\n[1,2,3,4,5,6].select\
    \ {|e| e % 2 == 0}", "  l2 = []\n  l2.extend l\n  l2.sort\n  l2.each_with_index\
    \ { |item, index| l[index] = item if index%2 == 0 }\n  l2.compact\nend\n</code>\n\
    <|/ a dscore=2 tags=arrays,ruby,sorting,ruby-on-rails |>\n<| a tags=arrays,ruby,sorting,ruby-on-rails\
    \ dscore=1 |>\nI agree with Pavan's answer and think you should probably accept\
    \ it.  However, I wanted to present a way to do this in Ruby, since you were asking\
    \ about Rails.\n<code>\nl = [1, 4, 2, 5, 7, 3]", "  even_indexes = (0...l.length/2).to_a\n\
    \  odd_indicies = (0...l.length-1).to_a\n  even_indicies = even_indexes.zip( odd_indicies\
    \ )\n  even_indicies.sort!\n  even_indicies.zip( l ).flatten\nend", "  l.each_with_index\
    \ { |e, i| i.even? ? l[i] = e : l[i].even? ? l[i] = l[i-1] : l[i] = l[i-1] + l[i]\
    \ }\nend", "  # make l an array\n  l2 = []\n  for i in l\n    l2 << i\n  end",
  "  l2 = [x for x in l if x%2 == 0]\n  l2.each do |x|\n    l2.delete_at(x)\n  end\n\
    \  l2.sort!\nend", "  l.sort.with_index { |x, i| i % 2 == 0 && i / 2 == x }\n\
    end\n</code>\n<|/ a tags=algorithm,ruby |>\n<| c |>\nThat's cool! I didn't know\
    \ about `Enumerable#sort!`. But why does `sort_odd` return `l`? Shouldn't it return\
    \ `l' `?\n<|/ c |>\n<| c |>\n- `l` is, by nature, immutable, meaning `sort_odd`\
    \ would have to return a new `List` instance. That would be expensive and unnecessary\
    \ since we could just use `sort_even` to reorder the elements.\n<|/ c |>\n<| c\
    \ |>\nI see. `sort_even` would be more efficient. Thanks!\n<|/ c |>\n<| a dscore=4\
    \ |>\nRuby also has a sort_by method.  Sort by value first, then by key.\n<|/\
    \ a tags=algorithm,ruby |>\n<| c |>\nNice. Also worth mentioning `sort_by!`\n\
    <|/ c |>\n<| c |>\nThis is how I solved it in my first days with ruby, and it's\
    \ the first time I saw this.\n<|/ c |>\n<| c |>\n+1 I didn't know about sort_by,\
    \ that's a good thing to know.\n<|/ c |>\n<| a tags=algorithm,ruby |>\n<code>",
  "  even = []\n  odd = []\n  even.concat(l)\n  odd.concat(l)\n  even.each_with_index\
    \ do |value, index|\n    if index % 2 == 0\n      even[index] = value\n    else\n\
    \      odd.delete(even[index])\n      odd.push(value)\n    end\n  end\n  return\
    \ odd + even\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is a good solution.\
    \ +1. However, it can be shortened to `return l.sort.zip(l.sort).to_h`. Also,\
    \ Ruby >= 2.4 has [`Array#zip`](http://ruby-doc.org/core-2.3.0/Array.html#method-i-zip).\n\
    <|/ c |>\n<| c |>\n: yes but `sort_even` is intended for those who have a Ruby\
    \ version < 2.4 ;-)\n<|/ c |>\n<| c |>\nYes, I know. I was just commenting in\
    \ case that happens to someone in the future who comes across this question and\
    \ finds the other solutions helpful.\n<|/ c |>\n<| a |>\nYou want a transposition,\
    \ which is easily accomplished using Array#transpose.\n<code>\na = [0,1,2,3]\n\
    a.transpose.map(&:first)", "    even = l.each.with_index { |val, index| index\
    \ % 2 }\n    odd = l.each.with_index { |val, index| index % 2 != 0 }\n    even.zip(odd)\n\
    end", "  even_indices = l.select.with_index.select{|e, i| i.odd?}.map{|e, i| i}\n\
    \  even_values = l.select.with_index.select{|e, i| i.even?}.map{|e, i| i}\n  even_values.zip(even_indices).sort.map{|e|\
    \ l[e[0]] = e[1]}.flatten\nend\n</code>\n<|/ a dscore=1 tags=ruby,sorting,ruby-on-rails,arrays\
    \ |>\n<| c |>\nThat is exactly what I needed, I never even knew about `select`\
    \ `with_index` `select` `odd?` and `even?` I love learning new things but I am\
    \ getting a little overwhelmed with them all at the same time. Thanks!\n<|/ c\
    \ |>\n<| a tags=ruby,sorting,ruby-on-rails,arrays |>\nHere's an approach that\
    \ will only require one pass through the array, but will have to build up two\
    \ arrays to do all the work. I tried to use Enumerable#sort_by, but that requires\
    \ a custom comparison function, so I rolled my own.\n<code>", "  return l.sort\
    \ {\n    |a,b| a == b || a % 2 == 0 && b % 2 != 0 ? b : a }\nend", "  evens =\
    \ l.select { |n| n % 2 == 0 }\n  evens.sort!\n  evens.inject { |r, v| r[v] = v;\
    \ r}\nend\n</code>\n<|/ a |>\n<| c |>\n+1 for a nice explanation of your solution\
    \ and for actually solving the problem.\n<|/ c |>\n<| c |>\nThe only thing I did\
    \ not see is that the question asked that the even numbers to be sorted first.\
    \ This solution returns them sorted first\n<|/ c |>\n<| a |>\nHere's my solution:\n\
    <code>", "  l.sort!\n  l.each_with_index do |value, i|\n    l.delete_at(i)\n \
    \   break if i%2 == 0\n  end\n  l\nend", "  l = l.sort\n  (1..l.size/2).each {|i|\
    \ l[i]=l[i*2]}\n  l\nend", "  even = []\n  odd = []\n  for i in l\n    if i %\
    \ 2 == 0\n      even << i\n    else\n      odd << i\n  end\n  even.zip(odd)\n\
    end\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\nThanks a lot for this\
    \ answer. It will be very helpful for me in future too. :) But I have chosen answer\
    \ as correct because I find his answer more understandable and easy to understand.\
    \ :)\n<|/ c |>\n<| a |>\n<code>\nsorted_array = sorted_array.sort!", "    even\
    \ = []\n    odd = []", "  even = nil\n  odd = nil\n  even_index = 0\n  odd_index\
    \ = 1\n  sorted_odd = odd_index\n  sorted_even = even_index\n  while l[even_index]\
    \ != nil\n    even = l[even_index]\n    while l[even_index] == even\n      even_index\
    \ += 1\n      even = l[even_index]\n    end\n    while l[odd_index] == even\n\
    \      odd_index += 1\n      even = l[odd_index]\n    end\n    sorted_odd = sorted_even\n\
    \    sorted_even += 1\n    l[odd_index] = even\n    l[even_index] = even\n  end\n\
    \  return l\nend", "  l2 = []\n  even = l[1..-1]\n  odd = l[2..-1]\n  even.zip(odd).each\
    \ { |a| l2 << a[0] if a[1] % 2 == 0 }\n  l2\nend\n</code>\n<|/ a dscore=1 tags=sorting,ruby\
    \ |>\n<| c |>\nIt seems like you're sorting in place already, so why not just\
    \ use `sort_by`?\n<|/ c |>\n<| c |>\nSorting in place?  I don't really know anything\
    \ about Ruby's sorting functions.  I've been teaching myself Ruby since 2008 and\
    \ I've always used sort_by.\n<|/ c |>\n<| c |>\nAh yeah, I see that now.  I knew\
    \ about sort_by but was unaware of the 'sort' function.  I thought sort was sort\
    \ ascending and sort_by was sort descending.  Thanks!\n<|/ c |>\n<| c |>\nsort_by\
    \ will also work.  Sort only works on the same set of objects.\n<|/ c |>\n<| a\
    \ tags=sorting,ruby dscore=1 |>\nHere's another way using each_cons:\n<code>",
  "  even.sort {|x, y| x == y ? 0 : x < y ? -1 : 1}\n  l\nend", "  return l.reject\
    \ { |x| x % 2 == 1 }.sort { |a, b| a <=> b }\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| a dscore=0 |>\nJust sort the array in reverse, e.g.\n<code>\na = [4,3,2,1]\n\
    a.sort_by!.reverse", "  l.each { |x| l[l.index { |e| e % 2 == 0 }] = x }\n  l\n\
    end", "    l.each do |i|\n        if i > 0\n            l[i] += l[i-1]\n     \
    \       l[i-1] = 0\n        end\n    end\n    l\nend", "  l.each_with_index do\
    \ |v, i|\n    if i%2 == 0\n      l[i.to_s]=v\n    end\n  end\n  l\nend", "  l.sort!\n\
    \  l.each_with_index do |e, i|\n    if (i % 2) == 0\n      l[i] = l[i].to_i if\
    \ (l[i].to_i != 0)\n    end\n  end\n  l\nend\n</pre>", "  new_l = []\n  count\
    \ = 0\n  for i in 0...l.size\n    unless count % 2\n      new_l << l[i]\n    \
    \  count += 1\n    end\n  end\n  return new_l\nend", "  l.sort.each_with_index\
    \ {|e, i| l[i] > l[i + 1] ? i.even? ? l[i], l[i + 1] : l[i + 1], l[i + 1] = l[i\
    \ + 1], l[i] }\n  l\nend\n</code>\n<|/ a tags=ruby,arrays dscore=0 |>\n<| c |>\n\
    Can you explain what `each_with_index` is doing exactly?\n<|/ c |>\n<| c |>\n\
    `each_with_index` iterates through the array `l`, adding each element and its\
    \ index to an array `e`, returning an array `e`. The first time through, it returns\
    \ an array `e` with two elements: the current element and the index of the element.\
    \ The second time through it returns an array `e` with three elements: the previous\
    \ element and its index, and the current element. The third time through it returns\
    \ an array `e` with four elements: the previous element and its index, the previous\
    \ element and its index, and the current element.\n<|/ c |>\n<| c |>\nThis does\
    \ work, but I wanted to avoid using an array to begin with. I'm looking for a\
    \ way to do it without having to create an array and sorting it.\n<|/ c |>\n<|\
    \ c |>\nOh, I see. I'll work on that and get back to you.\n<|/ c |>\n<| c |>\n\
    I added an alternate approach. Let me know if that meets your needs.\n<|/ c |>\n\
    <| a tags=ruby,arrays |>\nI do not know your exact requirement, but this might\
    \ be what you want:\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
