name: HumanEval_51_remove_vowels
language: rb
prompt: "# remove_vowels is a function that takes string and returns string without\
  \ vowels.\n# >>> remove_vowels('')\n# ''\n# >>> remove_vowels('abcdef')\n# 'bcdf'\n\
  # >>> remove_vowels('aaaaa')\n# ''\n# >>> remove_vowels('aaBAA')\n# 'B'\n# >>> remove_vowels('zbcd')\n\
  # 'zbcd'\ndef remove_vowels(text)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_vowels\n\
  \    candidate = method(:remove_vowels)\n    assert_equal(\"\", candidate.call(\"\
  \"))\n    assert_equal(\"bcdf\nghjklm\", candidate.call(\"abcdef\nghijklm\"))\n\
  \    assert_equal(\"fdcb\", candidate.call(\"fedcba\"))\n    assert_equal(\"\",\
  \ candidate.call(\"eeeee\"))\n    assert_equal(\"cB\", candidate.call(\"acBAA\"\
  ))\n    assert_equal(\"cB\", candidate.call(\"EcBOO\"))\n    assert_equal(\"ybcd\"\
  , candidate.call(\"ybcd\"))\n  end\nend\n"
completions: ["  # initialize a variable to hold the string\n  str = ''\n  \n  # iterate\
    \ through the string and store string without vowels \n  for i in text\n    if\
    \ !vowel?(i)\n      str += i\n    end\n  end\n  \n  return str\nend\n</cell>\n\
    <code language=julia-0.5>", "  text.gsub(/[aeiou]/,'')\nend", "\ttext.downcase!\n\
    \ttext.gsub(/[aeiou]/, '')\n\ttext\nend", "  # Write your code here.\n  vowels\
    \ = ['a','e','i','o','u','A','E','I','O','U']\n  text = text.downcase\n  text.scan(/[#{vowels.join}]/)\n\
    \  text\nend", "  text.downcase!\n  text.gsub(/[aeiouyAEIOUY]/, '')\nend", " \
    \ text.downcase!\n  text.gsub!(/[aeiou]/, '')\n  text.gsub!(/[AEIOU]/, '')\n \
    \ text\nend", "  text.downcase!\n  text.gsub!(/[aeiouy]/, '')\nend", "  new_text\
    \ = \"\"\n  text.downcase!\n  text.gsub(/[aeiouAEIOU]/,\"\")\n  text.downcase!\n\
    \  new_text = text\n  new_text\nend", "  return text\nend", "    text.gsub!(/[aeiou]/,\
    \ '')\n    text\nend\n</code>\n<|/ a |>\n<| c |>\n`text.gsub(/[aeiou]/, '')`\n\
    <|/ c |>\n<| a |>\n<code>", "    return text.gsub(/[aeiou]/, '') \nend", "  #\
    \ Split the string into array of characters.\n  split_text = text.split(//)",
  "  text.gsub(/[aeiou]/, '')\nend", "  return text =~ /[aeiouAEIOU]/ ? $&.upcase\
    \ : text\nend\n</code>\nThe result is a regexp that matches any letter, not just\
    \ a vowel, and upcases the matched letter.  Since regexes can span multiple lines,\
    \ we use $& to refer to the matched subexpression.  $& is a special variable that\
    \ always contains the last part of the regex match.\n<|/ a tags=ruby,regex |>\n\
    <| c |>\nWow. That's so cool! I never thought about using `$&`. Thanks :)\n<|/\
    \ c |>\n<| c |>\nThis is awesome. I'm going to have to take a look at your example\
    \ to better understand how to use regex. I'm coming from PHP and was trying to\
    \ do the same thing with regular expressions in Ruby before I learned how to do\
    \ it the right way (I love regex). I appreciate your help!\n<|/ c |>\n<| c |>\n\
    : This isn't a bad answer, and I learned something new today.  I've been using\
    \ Ruby since 1.8.1, and never even thought about using `$&`.  I learned something\
    \ new today!\n<|/ c |>\n<| a tags=ruby,regex |>\nHere's a solution that does not\
    \ use Regexps at all:\n<code>", "  text.gsub(/[aeiou]/, '')\nend", "  # Replace\
    \ all vowels in string with empty string.\n  text.gsub!(/[AEIOUaeiou]/, '')\n\
    end", "  text.gsub(/[aeiou]+/, '')\nend\n</code>\nThe second solution is to use\
    \ an enumerator to loop over your string. This solution would look like this:\n\
    <code>", "    chars = text.downcase.gsub(/[^aeiou]/,'')\n    chars.gsub!(/[aeiouy]/,'')\n\
    \    chars\nend\n</cell>\n<cell>", "  text.gsub(/[aeiouAEIOU]/, '')\nend", " \
    \ text.downcase!\n  text.gsub!(\"[aeiou]\", \"\") \n  return text\nend", "  text.tr!('aeiouAEIOU',\
    \ 'aeiou').tr!('AEIOU', 'aeiou')\n  text\nend\n</cell>\n<cell>", "  text.gsub!(/[aeiouAEIOU]/,\"\
    \")\nend", "  text.downcase!\n  text.gsub!( /[aeiou]/, '' )\n  text\nend", " \
    \   text_with_vowels = ''\n    vowels = %w(a e i o u)\n    text.each_byte do |byte|\n\
    \        if vowels.include?(byte)\n            text_with_vowels += byte\n    \
    \    else\n            text_with_vowels += '.'\n        end\n    end\n    return\
    \ text_with_vowels\nend\n</code>\n<|/ a |>\n<| c |>\nThis does not work for all\
    \ cases. `'aBbcd'` returns `'bcd.'`\n<|/ c |>\n<| c |>\nThe question says \"return\
    \ string without vowels\". There are several ways of making this change, which\
    \ is why I posted my own.\n<|/ c |>\n<| a dscore=1 |>\nThis would be a good time\
    \ to use a regular expression:\n<code>", "  text.gsub!(/[AEIOUYaeiouy]/, '')\n\
    \  return text\nend", "  # Write your logic here.\n  vowels = ['a','e','i','o','u','y']\n\
    \  no_vowels = ''\n  for i in text\n    if !vowels.include?(i)\n      no_vowels\
    \ = no_vowels + i\n    end\n  end\n  return no_vowels\nend", "    text.downcase!\n\
    \    text = text.upcase\n    text.gsub(/[aeiouAEIOU]/,'') # remove vowels from\
    \ string\n    text.upcase!\nend\n</cell>\n<code language=julia-1.5>\n@test remove_vowels(\"\
    \") == \"\"\n@test remove_vowels(\"aaBAA\") == \"B\"\n@test remove_vowels(\"aaaA\"\
    ) == \"A\"\n@test remove_vowels(\"aaBcD\") == \"BCD\"\n@test remove_vowels(\"\
    aaaA\") == \"A\"\n</cell>\n<code language=julia-1.5>\n@test remove_vowels(\"zbcz\"\
    ) == \"bcz\"\n@test remove_vowels(\"zbcz\") == \"bcz\"\n</cell>\n<code language=julia-1.5>\n\
    @test remove_vowels(\"abBcD\") == \"BCd\"\n@test remove_vowels(\"abBcD\") == \"\
    BCd\"\n</cell>\n<text>\nExercise: remove consecutive vowels\nWrite a function\
    \ that removes consecutive vowels from a string.", "  # Write your code here.\n\
    \  vowels = 'aeiou'\n  new_text = text.downcase\n  new_text.gsub!(/[#{vowels}]/,\"\
    \")\n  new_text\nend", "  text.gsub(/[aeiou]/,'')\nend", "  return text.replace\
    \ (/[aeiou]/g, '')\nend\n</cell>\n<code language=julia-1.5>", "    vowels = ['a',\
    \ 'e', 'i', 'o', 'u']\n    for letter in text\n        if letter not in vowels\n\
    \            text =~ /[#{letter}]/\n    end\n    text\nend\n</code>\nYou can then\
    \ use this function like this:\n<code>\ntext = 'The quick brown fox jumps over\
    \ the lazy dog!'", "    text.downcase!\n    text = text.chars.join\n    text.gsub!(/[aeiouyAEIOUY]/,\
    \ '').strip\nend", "  new_str = ''\n  text_length = text.length\n  vowels = ['a',\
    \ 'e', 'i', 'o', 'u']\n  begin = text.length\n  while begin > 0\n    new_str =\
    \ new_str + text[begin]\n    begin = begin - 1\n  end\n  begin = text_length -\
    \ 1\n  while begin > 0\n    if text[begin] !~ /[aeiou]/\n      new_str = new_str\
    \ + text[begin]\n      begin = begin - 1\n    end\n  end\n  return new_str\nend",
  "    text = text.split('')\n    text.reverse()\n    new_text = \"\"\n    vowels\
    \ = \"AEIOU\"\n    for char in text:\n        if char not in vowels:\n       \
    \     new_text = new_text + char\n    return new_text", "  text.gsub!(/[aeiouAEIOU]/,\
    \ '')\nend", "  consonants = %w(a e i o u y)\n  vowels = %w(a e i o u)\n  text.scan(/[#{consonants.join('|')}]/).flatten.map\
    \ { |x| x.tr('AEIOUYaeiouy', '') }\nend", "  text = text.downcase\n  text_without_vowels\
    \ = ''\n  vowels = 'aAiIoOuU'\n  for i in 0...text.count('a')\n    if text.start_with?\
    \ vowels[i]\n      text_without_vowels += text[i..-1]\n    else\n      text_without_vowels\
    \ += text[i..-1]\n    end\n  end\n  text_without_vowels\nend", "  text.scan(/^[aeiou]/).each\
    \ do |char|\n    text.gsub!(char, '').strip\n  end\n  text.strip\nend", "  text\
    \ = text.to_s\n  text.gsub!(/[aeiouAEIOU]/,\"\")\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby,functional-programming |>\nYou can implement the remove_vowels\
    \ method in two ways. \nEither you can pass a block to String#gsub\n<code>", " \
    \ text.gsub(/[aeiou]/, '')\nend\n</cell>\n<code language=julia-1.5>", "  text.gsub!(/[aeiou]/,\
    \ '')\nend", "  text.downcase!\n  text.gsub!(/[aeiouy]/i, '')\n  text\nend", " \
    \ vowels = ['a', 'e', 'i', 'o', 'u', 'y']\n  text = text.downcase\n  text.gsub!(/[#{vowels.join}]/,\
    \ '')\n  text\nend", "  text.downcase!\n  text.gsub!(/[aeiouy]/, '')\n  text.strip!\n\
    end", "    text.gsub(/[aeiou]/, '')\nend", "    text.downcase!\n    text.squeeze!\n\
    \    text.gsub!(/[aeiou]\\z/, '')\n    text.gsub!(/[aeiouy][^aeiouy]\\z/, '')\n\
    \    text.gsub!(/[aeiouy][aeiouy]\\z/, '')\n    text.gsub!(/[aeiouy][bdfg][^aeiouy][^aoui]\\\
    z/, '')\n    text.gsub!(/[aeiouy][^aeiouy]\\z/, '')\n    text.gsub!(/[aeiouy][^aeiouy]\\\
    z/, '')\n    text.gsub!(/[^aeiouy]\\z/, '')\n    text.gsub!(/[^aeiouy]\\z/, '')\n\
    \    text.gsub!(/[^aeiouy][^aoui]\\z/, '')\n    text.gsub!(/[^aeiouy][^aeiouy]\\\
    z/, '')\n    return text\nend", "  text.downcase!\n  text.gsub!(/[aeiou]/, '')\n\
    \  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeioyu]/, '')\n  text.gsub!(/[aeiouy]/,\
    \ '')\n  text.gsub!(/[aeioyu]/, '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/,\
    \ '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/,\
    \ '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/,\
    \ '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/,\
    \ '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/,\
    \ '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/,\
    \ '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/,\
    \ '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/,\
    \ '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/,\
    \ '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/,\
    \ '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/,\
    \ '')\n  text.gsub!(/[aeiouy]/, '')\n  text.gsub!(/[aeiouy]/, '')\n", "  text.downcase!\n\
    \  text.gsub!(/[aeiou]/, '')\nend", "  vowels = 'aeiouAEIOU'\n  result = text.gsub(/[#{vowels}]/,\
    \ '')\n  result.to_s.upcase\nend", "  remove_vowels_re = /[aeiouyAEIOUY]/ # regular\
    \ expression that matches all vowels\n  text.gsub(remove_vowels_re, '')\nend",
  "  text.gsub!(/[aeiou]/, '')\nend", "  text = text.downcase\n  text = text.gsub(/[aeiou]/,\
    \ '')\n  text = text.gsub(/[AEIOU]/, '')\n  text = text.gsub(/[AEIOU]/, '')\n\
    \  text = text.gsub(/[AEIOU]/, '')\n  text = text.gsub(/[AEIOU]/, '')\n  text\
    \ = text.gsub(/[AEIOU]/, '')\n  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/,\
    \ '')\n  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/, '')\n\
    \  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/, '')\n  text\
    \ = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/,\
    \ '')\n  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/, '')\n\
    \  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/, '')\n  text\
    \ = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/,\
    \ '')\n  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/, '')\n\
    \  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/, '')\n  text\
    \ = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/,\
    \ '')\n  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/, '')\n\
    \  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/, '')\n  text\
    \ = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/,\
    \ '')\n  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/, '')\n\
    \  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou]/, '')\n  text\
    \ = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[aeiou", "  text.gsub(/[aeiou]/,\
    \ '')\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby,string,regex dscore=3 |>\n\
    This is another solution\n<code>", "    vowels = 'AEIOUaeiou'\n    count = 0\n\
    \    \n    # remove vowels starting from the 1st letter\n    while count != 0\
    \ and text[count] != ' ': \n        count += 1\n    \n    \n    # remove vowels\
    \ starting from the last letter\n    while count != len(text) and text[count]\
    \ != ' ': \n        count -= 1", "  text.scan(/[aeiou]/).map { |vowel| vowel.ord\
    \ != 65 ? vowel : nil }.compact\nend", "  text = text.downcase\n  text = text.gsub(/[aeiou]/,\
    \ '')\n  return text\nend\n</cell>\n<cell>", "  # Only lowercase letters.\n  text\
    \ = text.downcase\n  # Replace vowels with empty string.\n  text.gsub!(/[aeiou]/,\
    \ '')\n  # Replace any non-alphanumeric characters with single space.\n  text.gsub!(/\\\
    W+/, ' ').strip\nend", "  consonants = 'bcdfghjklmnpqrstvwxyz'\n  vowels = 'aeiou'\n\
    \  text = text.downcase\n  text.gsub!(/[#{consonants}#{vowels}]/, '')\n  text.gsub!(/[#{vowels}]/,\
    \ '')\n  text\nend", "  text.scan(/[aeiou]/).inject(\"\"){|s,v| s.gsub(v, \"\"\
    ) if s}\nend", "    text.upcase!\n    text.downcase!\n    text.gsub(/[aeiou]/,\
    \ '') if text.match(/[aeiou]/)\n    text.downcase!\n    text.strip!\n    text\n\
    end", "  new_text = ''\n  text_list = text.downcase.split(//)\n  text_list.each\
    \ do |letter|\n    vowels = %w(a e i o u)\n    if vowels.include?(letter)\n  \
    \    new_text += letter\n    end\n  end\n  return new_text\nend\n</code>\nThis\
    \ would be the equivalent of the remove_vowels method in Ruby.\n<code>", "  text.scan(/[aeiou]/).join\n\
    end", "    text.downcase!\n    text.gsub(/[aeiou]/,'')\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| a dscore=3 tags=ruby,string |>\n<code>", "  text.downcase!\n  text.scan(/[aeiou]/)\n\
    \  text.gsub!(/[aeiou]/,\"\")\n  text\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    The `gsub!` would be more efficient as `gsub` would return a different object\
    \ rather than mutating the receiver; however, this would still have quadratic\
    \ performance.\n<|/ c |>\n<| a tags=ruby,string,regex |>\nTo improve efficiency\
    \ by about 5%, I used the following.\n<code>", "    # Remove vowels\n    text.scan(/[aeiou]/)\n\
    \    text.tr!(\"aeiou\", \"\")\n    text.tr!(\"zbc\", \"\")\n    return text\n\
    end\n</cell>\n<code language=julia-1.5>", "  text.scan(/[aeiou]/).map { |vowel|\
    \ vowel.downcase }.join(\"\")\nend\n</code>\n<|/ a |>\n<| c |>\nPlease don't copy\
    \ answers from other questions, as they do not add anything to the answers already\
    \ here.\n<|/ c |>\n<| c |>\nYour solution only works with the default Ruby implementation.\
    \ Stick with `scan`, it's much simpler.\n<|/ c |>\n<| c |>\nWhy don't you just\
    \ vote to close as duplicate?\n<|/ c |>\n<| c |>\n- I agree.  But I guess it does\
    \ add value to have it here for the new Ruby programmer who comes along.  Also,\
    \ some people might find it easier to understand and learn from.\n<|/ c |>\n<|\
    \ c |>\nI agree that this is better than `scan`, but it's not a good answer since\
    \ it doesn't explain what the OP was doing wrong.\n<|/ c |>\n<| a dscore=1 |>\n\
    Using regex to find vowels instead of split:\n<code>\n def removeVowels(string)\n\
    \   string.scan(/[aeiou]/).map { |x| x.downcase }.join(\"\")\n end\n</code>\n\
    <|/ a tags=ruby |>\n<| a |>\nI know this is old, but this is what I came up with\
    \ based on my own Ruby skills.\n<code>", "  string.gsub(/\\Aa|e|i|o|u|y\\z/, '',\
    \ text)\nend", "  text.downcase!\n  text.gsub!(/[aeiou]/,\"\")\n  text\nend",
  "    text.downcase!\n    # return string without vowels.\n    return text.tr('aeiou',\
    \ ' ')\nend\n</code>\n<|/ a |>\n<| a dscore=1 tags=ruby,ruby-on-rails |>\nYou\
    \ could do something like this: \n<code>\n'the sun is  shining in the air'[/([^aeiou]+)y/,\
    \ 1]", "  text.downcase!\n  text.gsub(/[aeiouy]/, '') \nend", "    text = text.downcase\n\
    \    \n    text = text.gsub('aeiou','')\n    text = text.gsub('y','')\n    text\
    \ = text.gsub('x','')\n    text = text.gsub('q','')\n    text = text.gsub('w','')\n\
    \    text = text.gsub('s','')\n    text = text.gsub('d','')\n    text = text.gsub('f','')\n\
    \    \n    return text\nend", "    text = text.upcase\n    vowels = %w(a e i o\
    \ u)\n    letters = text.split(//)\n    letters.reject! do |letter|\n        vowels.include?\
    \ letter\n    end\n    letters.join\nend", "  text = text.downcase\n  text.scan(/[aeiouy]+/)\
    \ do |match|\n    text = text.replace match, \"\"\n  end\n  text\nend\n</code>\n\
    Finally, the end result. I've removed the unnecessary function and made one function\
    \ do all. Also, I've used gsub instead of scan because gsub is better and scanning\
    \ regex is slower.\n<code>", "  vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I',\
    \ 'O', 'U']\n  text_without_vowels = text.gsub(/[#{vowels}]+/, '')\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n  text_without_vowels.reverse!\n\
    \  text_without_vowels.reverse!\n  text_without_vowel", "  text_without_vowels\
    \ = ''\n  text_without_vowels.concat text\n  text_without_vowels.scan(/[aeiou]/).delete_if\
    \ do |vowel|\n    vowel != 'a'\n  end \n  text_without_vowels\nend", "    text.downcase!\n\
    \    text.gsub!(/[aeiouy]/,\"\")\n    text.gsub!(/[AEIOUY]/,\"\")\n    text.gsub!(/[AEIOUy]/,\"\
    \")\n    text.gsub!(/[AEIOU]/,\"\")\n    text.gsub!(/[AEIOU]/,\"\")\n    text.gsub!(/[AEIOU]/,\"\
    \")\n    text.gsub!(/[aeiouyAEIOUY]/,\"\")\n    text.gsub!(/[AEIOUYAEIOU]/,\"\"\
    )\n    text.gsub!(/[aeiouAEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU]/,\"\")\n\
    \    text.gsub!(/[aeiouAEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU]/,\"\")\n  \
    \  text.gsub!(/[aeiouAEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU]/,\"\
    \")\n    text.gsub!(/[aeiouAEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU]/,\"\")\n\
    \    text.gsub!(/[aeiouAEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU]/,\"\")\n  \
    \  text.gsub!(/[aeiouAEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU]/,\"\
    \")\n    text.gsub!(/[aeiouAEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU]/,\"\")\n\
    \    text.gsub!(/[aeiouAEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU]/,\"\")\n  \
    \  text.gsub!(/[aeiouAEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU]/,\"\
    \")\n    text.gsub!(/[aeiouAEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU]/,\"\")\n\
    \    text.gsub!(/[aeiouAEIOU]/,\"\")\n    text.gsub!(", "  text = text.downcase\n\
    \  vowels = %w[a e i o u]\n  text.gsub!(vowels, '')\n  return text\nend", "  #\
    \ initialize an array to store vowel count.\n  vowels = Array.new\n  # iterate\
    \ through each character in the string.\n  text.each_char do |c|\n    if c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n      # increment the count\
    \ of vowels by the number of times this character appears.\n      vowels[c] +=\
    \ 1\n    end\n  end\n  # iterate through each vowel count and get the minimum\
    \ value.\n  min_count = vowels.min_by { |count, vowel| count }\n  # initialize\
    \ a new string that we will use to restore the original string.\n  new_text =\
    \ ''\n  # iterate through the original string and increment the character index\
    \ by the number of times this vowel appears.\n  text.each_char do |c|\n    # if\
    \ the character at the current index matches the minimum count, add this character\
    \ to the new string and increment the character index by the number of times the\
    \ minimum count appears.\n    if (vowels[c] == min_count) && (c == 'a')\n    \
    \  new_text += c\n      c += 1\n    else\n      # if the current character is\
    \ not the minimum count, append this character to the new string.\n      new_text\
    \ += c\n    end\n  end\n  return new_text\nend", "  text.gsub!(/[aeiou]/i, '')\n\
    end", "    # Replace 'a' with empty string.\n    text = text.gsub(/a+/, '')\n\
    \    # Replace all vowels.\n    text.gsub!(/[aeiou]/, '')\n    return text\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for your answer. I'm currently working through\
    \ this solution but just wanted to ask a follow up question about using regular\
    \ expressions. Do you know of any good tutorials that show how to read and understand\
    \ regular expressions?\n<|/ c |>\n<| c |>\nYes.  For a good start I'd recommend\
    \ [regular-expressions.info](http://www.regular-expressions.info/tutorial.html),\
    \ but there are also lots of [good books](http://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Dstripbooks&field-keywords=regex)\n\
    <|/ c |>\n<| c |>\nThanks. I'll look into the books you suggested.\n<|/ c |>\n\
    <| c |>\nThe book Regular Expressions by Quantifier  by Jan Goyvaerts is a great\
    \ resource for learning regex in general.\n<|/ c |>\n<| c |>\n+1 for the regex\
    \ tutorial. One thing I learned was that you can add `/` delimiters inside of\
    \ `[]`. So you can say `[aeiou]`. This allows you to nest them (for instance,\
    \ `[aeiou]{3}`). Also, you can use `+` to specify one or more repetition. `+`\
    \ is equivalent to `{1,}`.\n<|/ c |>\n<| a tags=ruby,string,regex,ruby-on-rails\
    \ dscore=3 |>\nI tend to use scan to parse strings instead of regular expressions.\
    \ It lets you find multiple things at once and returns the result as an array.\
    \ For example:\n<code>\nstring = \"aaaaaaa\"\nstring.scan(/a/) # => [\"a\",\"\
    a\",\"a\",\"a\",\"a\"]\n</code>\n<|/ a |>\n<| c |>\nThanks, do you think it would\
    \ be better to use scan in this case over regular expressions?\n<|/ c |>\n<| c\
    \ |>\nIf you really want to use regex then use [**scan**](http://ruby-doc.org/core-2.2.3/String.html#method-i-scan).\n\
    <|/ c |>\n<| c |>\nOkay, thanks. So do you think using the scan method would be\
    \ better than regular expressions in this case?\n<|/ c |>\n<| c |>\nSure. Also,\
    \ it's faster to parse a regex than to scan a string. Plus, it's more flexible.\
    \ For example, if you wanted to return an array of all of the occurence", "  text.gsub(/[aeiou]/,\
    \ '').gsub(/[AEIOU]/, '').downcase\nend\n</cell>\n<cell>\nremove_vowels('Hello')\n\
    </cell>\n<text>\nA better way of performing some task is to use method chaining.\
    \ Method chaining reduces the lines of code but can make it more difficult to\
    \ read, debug and maintain. The idea is to use methods that return self and then\
    \ to chain the results together.", "    vowels = ('aeiouAEIOU')\n    new_text\
    \ = ''\n    \n    # loop through each character in text\n    for letter in text\n\
    \        # if the letter is in our list of vowels \n        if letter in vowels\n\
    \            # add that letter to new_text without vowels\n            new_text\
    \ += letter\n    end\n    return new_text\nend\n</cell>\n<cell>", "  text.gsub(/[aeiou]+/,\
    \ '')\nend\n</code>\nRuby has some useful functions to filter out the vowels automatically.\
    \  In this case, the gsub method is the one you want.  In this case you pass in\
    \ a regular expression that matches one or more (+) vowels (a, e, i, o, u) and\
    \ replace it with an empty string ('').\n<code>", "    text.gsub!(\"a\", \"\"\
    ) #remove all vowels\n    text.gsub!(\"e\", \"\") #remove all vowels\n    text.gsub!(\"\
    i\", \"\") #remove all vowels\n    text.gsub!(\"o\", \"\") #remove all vowels\n\
    \    text.gsub!(\"u\", \"\") #remove all vowels\n    text.gsub!(\"A\", \"\") #remove\
    \ all vowels\n    text.gsub!(\"E\", \"\") #remove all vowels\n    text.gsub!(\"\
    I\", \"\") #remove all vowels\n    text.gsub!(\"O\", \"\") #remove all vowels\n\
    \    text.gsub!(\"U\", \"\") #remove all vowels\n    text.gsub!(\"b\", \"\") #remove\
    \ all vowels\n    text.gsub!(\"c\", \"\") #remove all vowels\n    text.gsub!(\"\
    d\", \"\") #remove all vowels\n    text.gsub!(\"f\", \"\") #remove all vowels\n\
    \    text.gsub!(\"g\", \"\") #remove all vowels\n    text.gsub!(\"h\", \"\") #remove\
    \ all vowels\n    text.gsub!(\"j\", \"\") #remove all vowels\n    text.gsub!(\"\
    k\", \"\") #remove all vowels\n    text.gsub!(\"l\", \"\") #remove all vowels\n\
    \    text.gsub!(\"m\", \"\") #remove all vowels\n    text.gsub!(\"n\", \"\") #remove\
    \ all vowels\n    text.gsub!(\"p\", \"\") #remove all vowels\n    text.gsub!(\"\
    q\", \"\") #remove all vowels\n    text.gsub!(\"r\", \"\") #remove all vowels\n\
    \    text.gsub!(\"s\", \"\") #remove all vowels\n    text.gsub!(\"t\", \"\") #remove\
    \ all vowels\n    text.gsub!(\"v\", \"\") #remove all vowels\n    text.gsub!(\"\
    w\", \"\") #remove all vowels\n    text.gsub!(\"x\", \"\") #remove all vowels\n\
    \    text.gsub!(\"z\", \"\") #remove all vowels\n    text.gsub!(\"H\", \"\") #remove\
    \ all vowels\n    text.gsub!(\"K\", \"\") #remove all vowels\n    text.gsub!(\"\
    L\", \"\") #remove all vowels\n    text.gsub!(\"M\", \"\") #remove all vowels\n\
    \    text.gsub!(\"N\", \"\") #remove all vowels\n    text.gsub!(\"P\", \"\") #remove\
    \ all vowels\n    text.gsub!(\"Q\", \"\"", "    # Create a empty string and append\
    \ every character in text to it.\n    result = ''\n    vowels = ['a','e','i','o','u','A','E','I','O','U']\n\
    \    for i in text\n        if i in vowels\n            # Append the characters\
    \ in the vowels list to the result string.\n            result += i\n    return\
    \ result", "  text.downcase.delete('aeiou')\n  text.delete('aeiou')\nend\n</cell>\n\
    <cell>", "  text.downcase!\n  text.gsub(/[aeiouy]/, '')\nend\n</cell>\n<code language=julia-0.5>",
  "  text.gsub!(/[aeiou]/i, '')\nend", "  text.gsub(/[aeiou]/, '')\nend", "  text.gsub(/[aeiou]/i,\
    \ '')\nend\n</cell>\n<code language=julia-1.5>", "    vowels_regexp = /[aeiouAEIOU]{1}/g\n\
    \    return text.gsub(vowels_regexp,\"\")\nend", "  text.gsub(/[aeiouyAEIOUY]/,\
    \ '')\nend", "  vowels = 'aeiouy'\n  text.gsub(/[#{vowels}]/, '')\nend\n</code>\n\
    <|/ a tags=ruby,regex |>\n<| a tags=ruby,regex |>\nThe regular expression [^aeiouy]\
    \ matches any character other than an a, e, i, o, u, or y.  So [^aeiouy]+, which\
    \ means a string with at least one character other than those vowels, will match\
    \ any string containing one or more vowels.  So the regular expression will match\
    \ \"a\" followed by at least one \"b\".\nThe string \"a\" will match the first\
    \ part of the regular expression ([^aeiouy]), and any subsequent \"b\" will match\
    \ the second part of the regular expression ([^aeiouy]+), and then the \"b\" will\
    \ match the third and so on and so on until the end of the string.\nSo, \"ab\"\
    \ will match the first part of the regular expression ([^aeiouy]), and any subsequent\
    \ \"ab\" will match the second part of the regular expression ([^aeiouy]+), and\
    \ then the \"ab\" will match the third and so on and so on until the end of the\
    \ string.\nAs the others have mentioned, this regular expression is not ideal.\
    \  You might want to consider changing the regular expression, perhaps something\
    \ like\n<code>\n/[aeiouy]+/\n</code>\nto make sure you match only strings with\
    \ one or more vowels.  You could add more vowels to that regular expression too.\n\
    <|/ a dscore=2 |>\n<| c |>\n`[aeiouy]+` is not ideal, because it matches `\"\"\
    `. If `text` is `\"\"`, your regex will return `\"\"` without removing the vowels.\
    \ Ideally, one would match an arbitrary number of vowels in a row, e.g.: `/[aeiouy]+[aeiouy]+/`\n\
    <|/ c |>\n<| c |>\n- I agree.  I wouldn't have used it myself because I was using\
    \ it as an example for how regular expression matching works.  I've updated my\
    \ answer to explain why `[^aeiouy]` doesn't do what I expected.\n<|/ c |>\n<|\
    \ a tags=ruby,regex |>\nIt doesn't work as intended because your pattern matches\
    \ \"ab\" and \"abc\" but not \"abcd\". \nTo solve this problem you have to specify\
    \ a character class which means all characters except for those in the character\
    \ class.\nIn this case you can use the shorthand class \\W which means everything\
    \ except for letters, digits and _ (underscore).\nYou can read more about this\
    \ here:\nhttp://www.regular-expressions.info/shorthand.html\nThis should work\
    \ as intended:\n<code>\n/[^aeiouy\\W]/\n</code>\n<|/ a dscore=2 |>\n<| c ", " \
    \ text.gsub(/[aeiou]/,'') # removing vowels\nend", "  text.gsub(/[aeiouAEIOU]/,\
    \ '')\nend", "  return text.gsub(/[aeiou]/, '').gsub(/[^aeiouAEIOU]/, '').strip\n\
    end", "  text.downcase!\n  text.squeeze!\n  text.gsub(/[aeiouyAEIOUY]/, '')\n\
    end", "  text = text.downcase\n  text = text.gsub(/[aeiou]/, '')\n  text = text.gsub(/[z]/,\
    \ '')\n  text = text.gsub(/[\\s]/, '')\n  return text\nend\n</code>\nThe output\
    \ I get from the program is as follows\n<code>\nirb(main):001:0> \nirb(main):002:0>\
    \ puts remove_vowels('')", "    vowels = %w[a e i o u]\n    return text.gsub(/[#{vowels.join('|')}]/,\
    \ '').squeeze\nend", "  return text.gsub(/[aeiou]/, '')\nend", "    text.gsub!\
    \ \"[aeiouyAEIOUY]\", \"\"\n    text.gsub! \"[aeiouAEIOU]\", \"\"\n    text.gsub!\
    \ \"[AEIOUY]\", \"\"\n    text.gsub! \"[AEIOU]\", \"\"\n    text.gsub! \"[AEY]\"\
    , \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub!\
    \ \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\
    \"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub!\
    \ \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\
    \"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub!\
    \ \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\
    \"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub!\
    \ \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\
    \"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub!\
    \ \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\
    \"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub!\
    \ \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\
    \"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub!\
    \ \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\
    \"\n    text.gsub! \"[AEY]\", \"\"\n    text.gsub! \"[AEY]\", \"\"", "  text.gsub!(/[aeiou]/,\
    \ '')\n  text\nend", "\ttext = text.downcase\n\ttext.scan(/[aeiou]/){|letter|\n\
    \t\ttext.gsub!(letter, '')\n\t}\n\ttext\nend", "  return text.downcase.gsub(/[aeiouyAEIOUY]+/,\
    \ '')\nend", "  text.downcase!\n  text.scan(/[aeiou]/).each do |c|\n    text.gsub!(c,\
    \ '')\n  end\n  text\nend\n</code>\n<|/ a tags=string,regex,ruby dscore=3 |>\n\
    <| c |>\nThat is much cleaner than my solution - I didn't even know `scan` existed.\
    \ Nice answer!\n<|/ c |>\n<| a dscore=3 |>\nHere's another method using tr:\n\
    <code>\n\"a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7\
    \ 8 9\".tr('a-z', 'A-Z')\n</code>\nResult:\n<code>\n=> \"A-Z 0-9 A-Z 0-9 0-9 0-9\
    \ A-Z A-Z 0-9 A-Z 0-9 A-Z 0-9 A-Z 0-9 A-Z 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z A-Z 0-9\
    \ 0-9 A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 A-Z 0-9 A-Z 0-9 0-9 0-9\
    \ A-Z A-Z A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 A-Z 0-9 A-Z 0-9 A-Z\
    \ 0-9 A-Z 0-9 0-9 A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 0-9\
    \ A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9\
    \ A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z\
    \ 0-9 0-9 A-Z 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 0-9\
    \ A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z\
    \ 0-9 A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z 0-9 A-Z 0-9 A-Z 0-9 A-Z 0-9 0-9 A-Z\
    \ 0-9 A-Z", "  text = text.downcase\n  vowels = %w[a e i o u]\n  text.gsub!(vowels,\
    \ ' ')\n  text.gsub!(/[aeiou]{2,}/, '') #remove 2 or more vowels\n  text.gsub!(/[a-z]{2,}/,\
    \ '') #remove 2 or more lowercase letters\n  text.gsub!(/[A-Z]{2,}/, '') #remove\
    \ 2 or more uppercase letters\n  text.strip!\n  text\nend", "  text.gsub(/[aeiou]/,\
    \ '').downcase!\nend", "    text.downcase!\n    return text.gsub(/[aeiou]/,'')\n\
    end", "  vowels = %w[a e i o u]\n  text.downcase.gsub(vowels, \"\").strip.downcase\n\
    end", "  # remove vowels from text\n  vowels = ''\n  text.downcase.scan(/[aeiou]/)\
    \ do |letter|\n    vowels += letter\n  end", "  return text.downcase\nend", " \
    \ text.downcase!\n  text.gsub!(/[aeiou]/, '') if text.index('aeiou') != nil\n\
    \  text.gsub!(/[aeiouy]/i, '') if text.index('aeiou') != nil\n  text.gsub!(/[aeiouy]/i,\
    \ '') if text.index('aeiou') != nil\n  text\nend", "  if text == ''\n    return\
    \ text\n  text = text.downcase\n  text.gsub!('aeiouy','y')\n  text.gsub!('y','a')\n\
    \  text.gsub!('y','a')\n  text.gsub!('y','a')\n  text.gsub!('y','a')\n  text.gsub!('y','a')\n\
    \  return text\nend", "  text.tr!(\"aeiouAEIOU\", \"\")\n  text\nend", "  text.gsub(/[aeiou]/,\
    \ '')\nend", "  return text.gsub(/[aeiou]/, '')\nend", "  text.gsub!(\"[aeiouAEIOU]\"\
    , \"\")\nend", "  # Declare and initialize a variable named vowels_list to an\
    \ empty array named vowels_list.\n  vowels_list = []\n  # Declare and initialize\
    \ a variable named text to an empty string named text.\n  text = ''\n  # Iterate\
    \ over the string text in reverse order and check if the letter is a vowel or\
    \ not. \n  # If it is a vowel, then append it to the vowels_list array.\n  for\
    \ i in text[::-1]\n    if i !~ /[aeiou]/\n      vowels_list.push(i)\n  # Return\
    \ the string vowels_list with only the vowels removed.\n  return vowels_list.join\n\
    end", "  text.gsub!(/[aeiou]/, '')\nend", "  text.scan(/[aeiou]/).map { |e| e\
    \ == :a ? nil : e[0] }.reduce(:+).to_s\nend\n</code>\n<|/ a tags=ruby,regex |>\n\
    <| c |>\nThanks. I accepted your answer (although I went with the first option).\n\
    <|/ c |>\n<| a tags=ruby,regex dscore=2 |>\nHere is another option that should\
    \ work regardless of the length of the string:\n<code>", "  text.downcase!\n \
    \ text.gsub(/[aeiouAEIOU]/,\"\")\n  text.gsub(/[AEIOU]/,\"\")\n  text.gsub(/[AEIOAEOU]/,\"\
    \")\n  text.gsub(/[AEIOAEO]/,\"\")\n  text.gsub(/[AEIOAE]/,\"\")\n  text.gsub(/[AEIOA]/,\"\
    \")\n  text.gsub(/[AEIO]/,\"\")\n  text.gsub(/[AEOU]/,\"\")\n  text.gsub(/[AEO]/,\"\
    \")\n  text.gsub(/[AE]/,\"\")\n  text.gsub(/[A]/,\"\")\n  text.gsub(/[EU]/,\"\"\
    )\n  text.gsub(/[E]/,\"\")\n  text.gsub(/[OU]/,\"\")\n  text.gsub(/[O]/,\"\")\n\
    \  text.gsub(/[OAE]/,\"\")\n  text.gsub(/[OA]/,\"\")\n  text.gsub(/[OE]/,\"\"\
    )\n  text.gsub(/[O]/,\"\")\n  text.gsub(/[EOU]/,\"\")\n  text.gsub(/[E]/,\"\"\
    )\n  text.gsub(/[OAEU]/,\"\")\n  text.gsub(/[OAE]/,\"\")\n  text.gsub(/[OA]/,\"\
    \")\n  text.gsub(/[OAE]/,\"\")\n  text.gsub(/[OA]/,\"\")\n  text.gsub(/[OE]/,\"\
    \")\n  text.gsub(/[OE]/,\"\")\n  text.gsub(/[O]/,\"\")\n  text.gsub(/[OU]/,\"\"\
    )\n  text.gsub(/[OU]/,\"\")\n  text.gsub(/[OU]/,\"\")\n  text.gsub(/[OU]/,\"\"\
    )\n  text.gsub(/[OU]/,\"\")\n  text.gsub(/[OU]/,\"\")\n  text.gsub(/[OU]/,\"\"\
    )\n  text.gsub(/[OU]/,\"\")\n  text.gsub(/[OU]/,\"\")\n  text.gsub(/[OU]/,\"\"\
    )\n  text.gsub(/[OU]/,\"\")\n  text.gsub(/[OU]/,\"\")\n  text.gsub(/[OU", "  text.downcase!\n\
    \  text.scan(/[aeiou]/){ |vowel| text =~ /[#{vowel}]/; text }\n  text\nend", " \
    \ text.scan(/[aeiou]/).map { |s| s.upcase }.join(\"\")\nend", "\tnew_text = text.upcase.split(//)\n\
    \tnew_text = new_text.map do |char|\n\t\tcase char\n\t\twhen \"A\", \"E\", \"\
    I\", \"O\", \"U\"\n\t\t\t\"\"\n\t\telse\n\t\t\tchar\n\t\tend\n\tend\n\tnew_text\
    \ = new_text.join('')\n\treturn new_text\nend", "  text.downcase!\n  text.gsub!(/[aeiouAEIOU]/,\
    \ '')\n  text.gsub!(/[AEIOUaeiou]/, '')\n  text\nend", "  return text.gsub(/[aeiou]/,\
    \ '')\nend", "    text.downcase!\n    text.gsub(/[aeiou]/, '')\nend", "    text.downcase!\n\
    \    text.gsub(/[aeiouyAEIOUY]/,\"\")\nend", "  text.scan(/[aeiou]/).each_cons(2).map(&:join).join('')\n\
    end", "  text_without_vowels = text.downcase\n  text_without_vowels.gsub!(/[aeiou]/,\
    \ '') # remove vowels from string\n  return text_without_vowels\nend", "  vowels\
    \ = %w[a e i o u]\n  text.gsub(/[#{vowels.join}]+/, \"\").strip\nend\n</code>\n\
    I haven't tested this, but it looks like it should do the trick.  I'm still fairly\
    \ new to Ruby, so please let me know if there are any errors, and I'll try to\
    \ address them.\n<|/ a dscore=0 |>\n<| a tags=ruby,string |>\n<code>", "  text.split('').select\
    \ {|c| vowels.include?(c)}.join\nend", "  text.gsub(/[aeiou]+/, '').downcase\n\
    end", "  text.downcase!\n  text.gsub(/[aeiou]/, '')\n  text.chop!\n  text.upcase!\n\
    \  return text\nend", "  text.gsub(/[aeiou]/, '')\nend\n</pre>\n<p>\nIt is not\
    \ always obvious how you might remove a substring from a string. Strings are immutable\
    \ and in Ruby strings are usually enclosed in double quotes (<code>\"</code>).\
    \ If you use single quotes <code>'</code> then you can no longer use double-quotes\
    \ around Ruby strings.\n</p>\n<p>\nYou can use the <code>gsub</code> or <code>gsub!</code>\
    \ method of the string to perform a global substitution on all instances of a\
    \ pattern in a string. <code>gsub</code> will return a modified string while <code>gsub!</code>\
    \ will modify the string in place. In both cases, you can provide a block to the\
    \ method by following the pattern in curly braces (<code>{...}</code>) where <code>gsub</code>\
    \ will return a modified string while <code>gsub!</code> will modify the string\
    \ in place. Here is an example showing both methods:\n</p>\n<pre>", "  # remove\
    \ vowels from text\n  text.gsub(/[aeiou]/,\"\")\nend", "  if text==''\n    \"\"\
    \n  else\n    text.gsub(/[AEIOUYaeiouy]/,\"\") \nend\n</cell>\n<cell>", "    text.tr!{\n\
    \        'a'=>'','e'=>'','i'=>'','o'=>'','u'=>'',\n        'A'=>'','E'=>'','I'=>'','O'=>'','U'=>'',\n\
    \        'z'=>'','c'=>'','d'=>'','g'=>'','m'=>'','n'=>'',\n        'Z'=>'','C'=>'','D'=>'','G'=>'','M'=>'','N'=>'',\n\
    \    }\nend", "  text.gsub!(/[aeiouy]+/, '')\n  text.gsub!(/[aeiouy]y/, '')\n\
    \  text\nend", "  return text.gsub(/[aeiou]/, '')\nend", "  return text.gsub(/[aeiou]/,\
    \ '')\nend", "  new_text = ''\n  text.each_char do |c|\n    case c\n    when 'a'..'z'\n\
    \      new_text += c\n    when 'A'..'Z'\n      new_text += c.downcase\n    end\n\
    \  end\n  new_text\nend", "  text.downcase! \n  text.gsub!(/[aeiouyAEIOUY]+/,'')\n\
    \  text\nend\n</cell>\n<text>\nString#match\nString#match allows you to retrieve\
    \ multiple matches in one shot. String#match returns an Enumerator and can be\
    \ used with Enumerable#map", "  text.downcase!\n  text.gsub(/[aeiou]/,'') \n \
    \ text\nend\n</code>\nRuby regular expressions can match any character or list\
    \ of characters. You can learn more about them here.\n<|/ a dscore=2 tags=string,ruby,regex\
    \ |>\n<| a dscore=2 |>\n<code>", "  text.gsub!(/[aeiou]/,\"\")\n  return text\n\
    end", "  new_text = \"\"\n  vowels = \"aeiouAEIOU\"\n  text.each_char do |char|\n\
    \    if vowels.include? char\n      new_text << char\n    else\n      new_text\
    \ << char.upcase\n    end\n  end\n  return new_text\nend", "  text.gsub(/[aeiou]/,\
    \ '')\nend\n</code>\nYou can find more information in the link below about regular\
    \ expression:\nhttp://www.regular-expressions.info/ruby.html\nAnd more on gsub:\n\
    http://www.ruby-doc.org/core-1.9.3/String.html#method-i-gsub\nI hope this helps.\n\
    <|/ a |>\n<| c |>\nYour regex is wrong. `/[aeiou]/` will match `aeiou` and `AEIOU`.\
    \ What you want is `/[aeiouAEIOU]/`. Also note that `gsub` is case insensitive\
    \ by default. Hence `/[aeiou]/` won't work if you are expecting both `A` and `a`.\n\
    <|/ c |>\n<| c |>\nYes, you're right. I should use 'i' for the regular expression.\n\
    <|/ c |>\n<| c |>\nThis doesn't remove vowels though, it simply removes *any*\
    \ vowel.\n<|/ c |>\n<| c |>\nYeah I didn't see the \"Remove vowels\" bit in the\
    \ question. My bad. I'll edit the answer.\n<|/ c |>\n<| a |>\nHere's a function\
    \ that removes vowels from a string\n<code>", "    text.upcase!\n    text.downcase!\n\
    \    text.chars.reject! { |x| x.in?(VOWELS.join) }\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\n`'aaBAA'.gsub(/[aeiouy]/,'')` gives `\"B\"` but `'aaBAA'.gsub(/[aeiouy]/,'')`\
    \ gives `\"BB\"` \u2014\_I think that is because `/a` is the same as `/[aeiouy]`\n\
    <|/ c |>\n<| c |>\n: you are right, thanks for noticing. I edited my answer.\n\
    <|/ c |>\n<| c |>\nIt might be better to use a regex literal and avoid the use\
    \ of `to_a`: `text.gsub(/[aeiouy]/,\"\")`.\n<|/ c |>\n<| c |>\n: You might want\
    \ to add that as an answer (it works without `to_a`).\n<|/ c |>\n<| c |>\n: It's\
    \ a matter of taste, I think. I'm sure you know that `to_a` is required only when\
    \ you want to convert an array into a `String`.\n<|/ c |>\n<| a dscore=5 tags=ruby,arrays\
    \ |>\nJust to add, here's a very simple way to use map! and gsub!:\n<code>\nword\
    \ = 'apple'", "    text = text.downcase\n    \n    return text.gsub(/[aeiou]/,\
    \ '').downcase\nend", "  text.gsub(/[aeiouyAEIOUY]+/, '')\nend\n</code>\nAnd now\
    \ let's look at how we might use this to remove vowels from the first half of\
    \ a string:\n<code>", "    vowels = 'aeiou'\n    vowels_rep = 'aeiou'\n    \n\
    \    while text !=\"\"\n        replaced = text.gsub(vowels,vowels_rep)\n    \
    \    text =replaced\n    end\n    text\nend\n</cell>\n<cell>\nremove_vowels(\"\
    Mr. John Smith was a great teacher.\")\n</cell>\n<cell>", "    text.downcase!\n\
    \    text.gsub!(/[aeiou]/,\"\")\n    text.gsub!(/[AEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU]/,\"\
    \")\n    text.gsub!(/[\\^aeiou]/,\"\")\n    text.gsub!(/[\\^AEIOU]/,\"\")\n  \
    \  text.gsub!(/[\\^aeiouAEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU\\^]/,\"\")\n\
    \    text.gsub!(/[AEIOU\\^]/,\"\")\n    text.gsub!(/[aeiouAEIOU\\^AEIOU]/,\"\"\
    )\n    text.gsub!(/[\\^aeiouAEIOU\\^]/,\"\")\n    text.gsub!(/[\\^AEIOU\\^]/,\"\
    \")\n    text.gsub!(/[\\^aeiouAEIOU\\^AEIOU]/,\"\")\n    text.gsub!(/[\\^AEIOU\\\
    ^AEIOU]/,\"\")\n    text.gsub!(/[\\^AEIOU\\^]/,\"\")\n    text.gsub!(/[\\^AEIOU\\\
    ^AEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU\\^AEIOU]/,\"\")\n    text.gsub!(/[AEIOU\\\
    ^AEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU\\^]/,\"\")\n    text.gsub!(/[\\^AEIOU\\\
    ^]/,\"\")\n    text.gsub!(/[AEIOU\\^]/,\"\")\n    text.gsub!(/[\\^AEIOU\\^AEIOU]/,\"\
    \")\n    text.gsub!(/[\\^AEIOU\\^AEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU\\\
    ^AEIOU]/,\"\")\n    text.gsub!(/[AEIOU\\^AEIOU]/,\"\")\n    text.gsub!(/[aeiouAEIOU\\\
    ^]/,\"\")\n    text.gsub!(/[\\^AEIOU\\^]/,\"\")\n    text.gsub!(/[AEIOU\\^]/,\"\
    \")\n    text.gsub!(/[\\^AEIOU\\^AEIOU]/,\"\")\n    text.gsub!(", "  text.gsub(/[aeiou]/,\"\
    \").gsub(/[AEIOU]/,\"\")\nend", "  text.downcase!\n  text.gsub!(/[aeiouy]/, '')\n\
    \  return text\nend\n</cell>\n<cell>", "  text.gsub!(/[aeiouAEIOU]/,'') # remove\
    \ all vowels\n  text.gsub!(/[aeiouAEIOUaeiou]/,'') # remove all vowels except\
    \ aeiou\n  text.gsub!(/[aeiouAEIOUaeiouAEIOU]/,'') # remove all vowels except\
    \ aeiouAEIOUaeiou\n  text.gsub!(/[aeiouAEIOUaeiouAEIOUaeiou]/,'') # remove all\
    \ vowels except aeiouAEIOUaeiouAEIOUaeiou\n  text.gsub!(/[aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou]/,'')\
    \ # remove all vowels except aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\n  text.gsub!(/[aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou]/,'')\
    \ # remove all vowels except aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\n \
    \ text.gsub!(/[aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou]/,'')\
    \ # remove all vowels except aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\n\
    \  text.gsub!(/[aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou]/,'')\
    \ # remove all vowels except aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\n\
    \  text.gsub!(/[aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou]/,'')\
    \ # remove all vowels except aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\n\
    \  text.gsub!(/[aeiouAEIOUaeiouAE", "    text.scan(/[aeiou]/) do |vowel|\n   \
    \     text = text.gsub(vowel, '')\n    end\n    return text\nend", "    # your\
    \ code here\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    vowels_index\
    \ = []\n    for char in text:\n        if char in vowels:\n            vowels_index.append(vowels.index(char))\n\
    \        else:\n            pass\n    text = \"\"\n    for index, char in enumerate(text):\n\
    \        if index not in vowels_index:\n            text += char\n    return text\n\
    \    \n</cell>\n<cell>", "    text.downcase!\n    text.tr!('aeiouAEIOU', '')\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you, this worked! Could you explain why\
    \ you chose `text.downcase!` instead of `text.downcase`? Also, it seems like there\
    \ might be an issue with `remove_vowels`, as `remove_vowels('abcabc')` gives `'abc'`\
    \ instead of `'bcc'`. Do you think that's a problem with `remove_vowels`? Thanks\
    \ again.\n<|/ c |>\n<| c |>\nThe `downcase!` method converts the string to lower\
    \ case. That is why we need the second parameter, `'a'`. Also `text.tr!('aeiouAEIOU',\
    \ '')` removes the vowels from the string from the `tr!` method documentation\
    \ is [here](http://ruby-doc.org/core-1.9.3/String.html#method-i-tr).\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>\nrequire 'set'\nstr = \"The quick brown fox jumps over\
    \ the lazy dog\"\nstr1 = str.downcase\nstr1.gsub(/[^aeiou]/,\"\")\n</code>\nor\n\
    <code>\nstr = \"The quick brown fox jumps over the lazy dog\"\nstr1 = str.downcase\n\
    str1.gsub(/[^aeiou]/,'')\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>", "  text.downcase!\n\
    \  text.gsub!(/[aeiouyAEIOUY]/,\"\")\n  text.gsub!(/[aeiouyAEIOUY]{2}/,\"\")\n\
    \  text.gsub!(/[aeiouyAEIOUY]{3}/,\"\")\n  text.gsub!(/[aeiouyAEIOUY]{4}/,\"\"\
    )\n  text.gsub!(/[aeiouyAEIOUY]{5}/,\"\")\n  text.gsub!(/[aeiouyAEIOUY]{6}/,\"\
    \")\n  text.gsub!(/[aeiouyAEIOUY]{7}/,\"\")\n  text.gsub!(/[aeiouyAEIOUY]{8}/,\"\
    \")\n  text.gsub!(/[aeiouyAEIOUY]{9}/,\"\")\n  text.gsub!(/[aeiouyAEIOUY]{10}/,\"\
    \")\n  text.gsub!(/[aeiouyAEIOUY]{11}/,\"\")\n  text.gsub!(/[aeiouyAEIOUY]{12}/,\"\
    \")\n  text.gsub!(/[aeiouyAEIOUY]{13}/,\"\")\n  text.gsub!(/[aeiouyAEIOUY]{14}/,\"\
    \")\n  text.gsub!(/[aeiouyAEIOUY]{15}/,\"\")\n  text.gsub!(/[aeiouyAEIOUY]{16}/,\"\
    \")\n  text.gsub!(/[aeiouyAEIOUY]{17}/,\"\")\n  text.gsub!(/[aeiouyAEIOUY]{18}/,\"\
    \")\n  text.gsub!(/[aeiouyAEIOUY]{19}/,\"\")\n  text.gsub!(/[aeiouyAEIOUY]{20}/,\"\
    \")\n  text.gsub!(/[aeiouyAEIOUY]{21}/,\"\")\n  text.gsub!(/[aeiouyAEIOUY]{22}/,\"\
    \")\n  text.gsub!(/[aeiouyAEIOUY]{23}/,\"\")\n  text.gsub!(/[aeiouyAEIOUY]{24}/,\"\
    \")\n  text.gsub!(/[aeiouyAEIOUY]{25}/,\"\")\n  text.gsub!(/[aeiouyAEIOUY]{26}/,\"\
    \")\n  text.gsub!(/[aeiouyAEIOUY]{27}/,", "  text.replace /[aeiouAEIOU]/,''\n\
    end", "    vowels = %w[a e i o u]\n    text.downcase!\n    text.gsub!('a', '')\n\
    \    text.gsub!('e', '')\n    text.gsub!('i', '')\n    text.gsub!('o', '')\n \
    \   text.gsub!('u', '')\n    text.gsub!(vowels, '')\n    return text\nend", " \
    \ text.downcase!\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,'\
    \ ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n\
    \  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,'\
    \ ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n\
    \  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,'\
    \ ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n\
    \  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,'\
    \ ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n\
    \  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,'\
    \ ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n\
    \  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,'\
    \ ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n  text.gsub!(/[aeiouyAEIOUY]/,' ')\n\
    \  text.gsub!(/[aeiouyAEIOUY", "  text.gsub(/[aeiou]/,\"\")\nend", "  vowels =\
    \ 'aeiou'\n  text.gsub(/#{vowels}/, '')\nend\n</code>\n<|/ a tags=string,ruby,regex,ruby-on-rails\
    \ dscore=2 |>\n<| a tags=string,ruby,regex,ruby-on-rails |>\nIf you're looking\
    \ to remove all vowels from a string here's some code:\n<code>", "  text.downcase!\n\
    \  text.gsub!(/[aeiouAEIOU]/, '')\n  text.gsub!(/[AEIOUaeiou]/, '')\n  text.strip!\n\
    end", "  text.gsub!(\"a\", \"'\")\n  text.gsub!(\"A\", \"'\")\n  text.gsub!(\"\
    E\", \"'\")\n  text.gsub!(\"i\", \"'\")\n  text.gsub!(\"O\", \"'\")\n  text.gsub!(\"\
    u\", \"'\")\n  text.gsub!(\"U\", \"'\")\n  text.gsub!(\"y\", \"'\")\n  text.gsub!(\"\
    Y\", \"'\")\n  text.gsub!(\"a\", \"e\")\n  text.gsub!(\"A\", \"E\")\n  text.gsub!(\"\
    e\", \"E\")\n  text.gsub!(\"i\", \"E\")\n  text.gsub!(\"O\", \"U\")\n  text.gsub!(\"\
    u\", \"U\")\n  text.gsub!(\"y\", \"Y\")\n  text.gsub!(\"Y\", \"Y\")\n  return\
    \ text\nend", "  vowels = {'a','e','i','o','u','A','E','I','O','U'}\n  return\
    \ text.downcase\n    .gsub(/[aeiou]/,'')\n    .gsub(/[AEIOU]/,'')\n    .gsub(/[aeiouAEIOU]/,'')\n\
    end", "    text = text.upcase\n    vowels = %w(a e i o u)\n    text.tr!(*vowels)\n\
    \    \n    text.tr!('aeiou', '')\nend", "  text.downcase!\n  text.gsub(/[aeiouAEIOU]/,\
    \ '')\n  text.downcase!\nend\n</code>\nThe remove_vowels method returns a new\
    \ string without the vowels. I modified your code to demonstrate how it would\
    \ work. First, we define the remove_vowels method, and then test it in the console:\n\
    <code>", "  text.downcase.gsub(/[aeiouy]/, '')\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a |>\nA more readable (IMO) solution with regular expressions:\n<code>",
  "  text.scan(/[aeiou]/)\n  text.gsub!(/[aeiou]/,\"\")\n  text\nend", "  vowels =\
    \ ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n  text.downcase!\n  text.gsub(/[#{vowels.join('|')}]/,\
    \ '')\nend", "    text.gsub!(/[aeiou]/, '')\n    text\nend", "  text.gsub(/[aeiouAEIOU]/,\
    \ '')\nend", "  text.downcase!\n  text.gsub!(/[aeiouy]/,'')\n  text.gsub!(/[\xE6\
    \xF8\xE5]/,'')\n  text.gsub!(/[\u0153\u0152]/,'')\n  text.gsub!(/\u0153/,'o')\n\
    \  text.gsub!(/\u0152/,'O')\n  text.gsub!(/[\u017E\u017C]/,'i')\n  text.gsub!(/\u017E\
    /,'I')\n  text.gsub!(/[\xDF]/,'s')\n  text.gsub!(/[\xDF]/,'S')\n  text.gsub!(/[\xC6\
    ]/,'a')\n  text.gsub!(/[\xD8]/,'O')\n  text.gsub!(/[\xC5]/,'A')\n  text.gsub!(/[\xC4\
    ]/,'e')\n  text.gsub!(/[\xC8]/,'E')\n  text.gsub!(/[\xC7]/,'c')\n  text.gsub!(/[\xC9\
    ]/,'E')\n  text.gsub!(/[\xDF]/,'S')\n  text.gsub!(/[\xDC]/,'U')\n  text.gsub!(/[\xD6\
    ]/,'o')\n  text.gsub!(/[\xD8]/,'O')\n  text.gsub!(/[\xC5]/,'A')\n  text.gsub!(/[\xC4\
    ]/,'e')\n  text.gsub!(/[\xC8]/,'E')\n  text.gsub!(/[\xC7]/,'c')\n  text.gsub!(/[\xC9\
    ]/,'E')\n  text.gsub!(/[\xDF]/,'S')\n  text.gsub!(/[\xDC]/,'U')\n  text.gsub!(/[\xD6\
    ]/,'o')\n  text.gsub!(/[\xD8]/,'O')\n  text.gsub!(/[\xC5]/,'A')\n  text.gsub!(/[\xC4\
    ]/,'e')\n  text.gsub!(/[\xC8]/,'E')\n  text.gsub!(/[\xC7]/,'c')\n  text.gsub!(/[\xC9\
    ]/,'E')\n  text.gsub!(/[\xDF]/,'S')\n  text.gsub!(/[\xDC]/,'U')\n  text.gsub!(",
  "    vowels = \"aeiou\"\n    return text.gsub(/[#{vowels}]/, '')\nend", "  text.gsub(/[aeiouAEIOU]/,\
    \ '') # replace vowels with nothing\n  text.gsub(/[aeiouAEIOU]/, '')\nend", " \
    \ text.gsub(/[aeiou]/, '')\nend", "  text.tr!(\"aeiouAEIOU\", \"_\")\nend\n</code>\n\
    Now we need to remove all special characters (i.e. numbers and punctuation). Here\
    \ I simply replace all characters that aren't letters (uppercase and lowercase)\
    \ with a space.\n<code>", "  text.gsub(/[aeiou]/,'')\n  return text\nend", " \
    \   text.each_char do |char|\n        if ['a', \"e\", 'i', \"o\", \"u\", 'A',\
    \ 'E', 'I', 'O', 'U'].include? char.to_s\n            text = text.replace char.to_s,\
    \ \"\"\n        end\n    end\n    text\nend", "  text.downcase!\n  text.gsub!(/[aeiou]/,\
    \ '')\n  text.strip!\n  return text\nend", "  if text.length == 0\n    return\
    \ text\n  \n  text = text.downcase\n  new_text = \"\"\n  \n  text.each_char do\
    \ |c|\n    unless [ \"a\", \"e\", \"i\", \"o\", \"u\" ].include?(c)\n      new_text\
    \ << c\n    end\n  end\n  \n  return new_text\nend\n</code>\nI did this in Ruby\
    \ 1.8.7. As I see it, there are better ways of doing this in Ruby 1.8.7 (which\
    \ I am using), so you may have to change a few things to get this to work. For\
    \ example, you will probably want to convert a string into a character array instead\
    \ of using a string iterator.\n<|/ a |>\n<| c |>\nYou don't need to change anything,\
    \ just change `text.length` to `new_text.length`.\n<|/ c |>\n<| c |>\nIt worked\
    \ when I tried it in a Ruby console. Perhaps you might try putting `p \"hello\"\
    .downcase` at the top in your code and see what you get.\n<|/ c |>\n<| c |>\n\
    It's not working with the string `'zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd\
    \ zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd\
    \ zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd\
    \ zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd\
    \ zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd\
    \ zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd\
    \ zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbcd zbc", "  text.downcase!\n\
    \  text = text.gsub(/[aeiouAEIOU]+/, '')\n  text.downcase!\n  text\nend\n</cell>\n\
    <text>\nNow let's write the function count_vowels that takes a string and returns\
    \ the number of vowels in it:", "  text.downcase!\n  text.gsub(/[aeiouy]/, '')\n\
    \  text\nend\n</cell>\n<cell>", "  text.gsub(/[aeiou]/, '')\nend", "    no_vowels\
    \ = text.downcase\n    no_vowels.gsub(/[aeiouy]/, '').gsub(/[^aeiouy]/, '')\n\
    end\n</code>\nYou can then use remove_vowels with your text in the view. \n<code>\n\
    <h2><%= remove_vowels(@post.title) %></h2>\n</code>\n<|/ a tags=ruby-on-rails\
    \ |>\n<| c |>\nThanks for your answer. Can you please provide me with a link to\
    \ read more about `remove_vowels` ? I'm pretty new to Rails and I don't fully\
    \ understand how it works.\n<|/ c |>\n<| c |>\n[remove_vowels](http://apidock.com/rails/String/remove_vowels)\
    \ is a method of [String](http://apidock.com/rails/String). You will need to define\
    \ it outside of your class in the controller as shown in my answer.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  text.gsub(/[aeiou]/, '')\nend", "  vowels = %w[a\
    \ e i o u]\n  text.gsub(/[#{vowels.join('|')}]/, '')\nend\n</code>\nThe above\
    \ example shows two ways to use String.gsub to remove vowels from a string. The\
    \ first uses regular expressions via #{} to build the regular expression string.\
    \ The second uses Ruby's Array#join method.\n<code>\nremove_vowels(input)\n</code>\n\
    <|/ a dscore=2 tags=ruby,string |>\n<| c |>\n\"The #gsub method returns a string\"\
    \ is incorrect. The method returns a modified string.\n<|/ c |>\n<| c |>\nThanks\
    \ for letting me know. I updated my answer.\n<|/ c |>\n<| a dscore=2 |>\nAs others\
    \ have pointed out, Ruby has a String#gsub that returns a string. It can also\
    \ take a string and substitute it with a block, which would look like this:\n\
    <code>", "  text.gsub(/[aeiou]/,\"\")\nend", "  return text.gsub(/[aeiou]/,\"\"\
    )\nend", "  new_text = \"\"\n  vowels = \"aeiouAEIOU\"\n  \n  # Loop through the\
    \ text\n  text.each_char do |c|\n    # Check if the current character is a vowel.\n\
    \    if vowels.include?(c)\n      # If the current character is a vowel, add it\
    \ to the new text\n      new_text += c\n    else\n      # If the current character\
    \ is not a vowel, add it to the new text\n      new_text += c\n    end\n  end\n\
    \  \n  return new_text\nend\n</cell>\n<cell>", "  # Your code here\n  return text\n\
    end\n</cell>\n<text>\nSolution\nRun the cell below to test your function.", " \
    \ result = \"\"\n  text.each_char { |c| result << c.upcase if c.upcase != \"A\"\
    \ && c.upcase != \"E\" && c.upcase != \"I\" && c.upcase != \"O\" && c.upcase !=\
    \ \"U\" }\n  return result\nend", "  text.downcase!\n  text.gsub!(/[aeiou]/,\"\
    \") # delete vowels.\n  text.gsub!(/[^aeiou]/,\"\") # delete anything but vowels.\n\
    \  text.strip!\nend", "    text.downcase!\n    text.gsub!(/[aeiouyAEIOUY]/, '')\n\
    end", "  vowels = \"aeiouAEIOU\"\n  return text.gsub(vowels, '')\nend\n</code>\n\
    <|/ q |>\n<| c |>\nWhat is your question? And what do you mean with \"the function\
    \ works not as expected\"?\n<|/ c |>\n<| c |>\nYou don't have to define `remove_vowels`\
    \ inside `while`.\n<|/ c |>\n<| c |>\nWhat is the purpose of `remove_vowels`?\
    \  As it is now, `remove_vowels` gets called as many times as there are items\
    \ in `my_array`. And then only the last item is returned by `remove_vowels`.\n\
    <|/ c |>\n<| c |>\nWhat do you mean with \"the function works not as expected\"\
    \ ?\n<|/ c |>\n<| c |>\nIf you have a lot of time please read through [this post](https://stackoverflow.com/help/how-to-ask)\
    \ and make an edit that clarifies what exactly is not working.\n<|/ c |>\n<| a\
    \ |>\n<code>", "    vowels = \"aeiouAEIOU\"\n    return text.gsub(/[#{vowels}]*/,\
    \ '').gsub(/[^#{vowels}]/, '')\nend", "  return text unless text.length >= 4\n\
    \  text.gsub(/[aeiou]/, '') \nend", "    text = text.downcase\n    text.gsub!(/[aeiouy]/,\
    \ '')\n    return text\nend\n</code>\nAside from that, I think the logic behind\
    \ the code would be clear and easy to understand if written with more clarity\
    \ on the function parameters.\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
