name: HumanEval_66_digitSum
language: rb
prompt: "# Task\n# Write a function that takes a string as input and returns the sum\
  \ of the upper characters only'\n# ASCII codes.\n# Examples:\n# digitSum(\"\") =>\
  \ 0\n# digitSum(\"abAB\") => 131\n# digitSum(\"abcCd\") => 67\n# digitSum(\"helloE\"\
  ) => 69\n# digitSum(\"woArBld\") => 131\n# digitSum(\"aAaaaXa\") => 153\ndef digitSum(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digitSum\n\
  \    candidate = method(:digitSum)\n    assert_equal(0, candidate.call(\"\"))\n\
  \    assert_equal(131, candidate.call(\"abAB\"))\n    assert_equal(67, candidate.call(\"\
  abcCd\"))\n    assert_equal(69, candidate.call(\"helloE\"))\n    assert_equal(131,\
  \ candidate.call(\"woArBld\"))\n    assert_equal(153, candidate.call(\"aAaaaXa\"\
  ))\n    assert_equal(151, candidate.call(\" How are yOu?\"))\n    assert_equal(327,\
  \ candidate.call(\"You arE Very Smart\"))\n  end\nend\n"
completions: ["  sum = 0\n  s.split('').each do |c|\n    sum += c.upcase ? c.to_i\
    \ : nil\n  end\n  sum\nend", "  return s.scan(/[\\d]+/).reduce(:+)\nend", "  s.gsub(/[a-z]/){|s|\
    \ s.ord - 96}\nend", "  sum = 0\n  s.each_byte { |x| sum += x }\n  sum\nend",
  "    sum = 0\n    s.chars.each { |c| sum += (c.ord > 64) ? c.ord - 96 : c.ord }\n\
    \    sum\nend", "  result = s[0]\n  s.each_char{ |c| result += c.ord }\n  result\n\
    end", "  s.upcase.chars.inject(0) { |sum,x| sum + x.to_i }\nend", "  sum = 0\n\
    \  s.split('').each do |letter|\n    sum += letter.codepoint.upcase\n  end\n \
    \ sum\nend", "  sum = 0\n  s.each do |char|\n    sum += char.ord if char.upcase\
    \ == 'A'.ord\n  end\n  sum\nend", "    s = 0\n    i = 0\n    while i < s.length\n\
    \        s += (s.upcase[0...i].size)\n        i += 1\n    end\n    return s\n\
    end", "  sum = 0\n  s.each do |c|\n    sum += (c.to_i).abs\n  end\n  return sum\n\
    end", "    sum = 0\n    s.each_byte { |x| sum += x.ord } \n    return sum\nend",
  "  s.chars.map { |c| c.ord - '0' }.inject { |s, v| s + v }\nend", "  s.each_char.inject(0)\
    \ {|sum, c| sum + c.ord }\nend", "  res = 0\n  s.each_char do |c|\n    if c.upcase\
    \ == \"A\"\n      res += 65\n    elsif c.upcase == \"B\"\n      res += 66\n  \
    \  elsif c.upcase == \"C\"\n      res += 67\n    elsif c.upcase == \"D\"\n   \
    \   res += 68\n    elsif c.upcase == \"E\"\n      res += 69\n    elsif c.upcase\
    \ == \"F\"\n      res += 70\n    elsif c.upcase == \"G\"\n      res += 71\n  \
    \  elsif c.upcase == \"H\"\n      res += 72\n    elsif c.upcase == \"I\"\n   \
    \   res += 73\n    elsif c.upcase == \"J\"\n      res += 74\n    elsif c.upcase\
    \ == \"K\"\n      res += 75\n    elsif c.upcase == \"L\"\n      res += 76\n  \
    \  elsif c.upcase == \"M\"\n      res += 77\n    elsif c.upcase == \"N\"\n   \
    \   res += 78\n    elsif c.upcase == \"O\"\n      res += 79\n    elsif c.upcase\
    \ == \"P\"\n      res += 80\n    elsif c.upcase == \"Q\"\n      res += 81\n  \
    \  elsif c.upcase == \"R\"\n      res += 82\n    elsif c.upcase == \"S\"\n   \
    \   res += 83\n    elsif c.upcase == \"T\"\n      res += 84\n    elsif c.upcase\
    \ == \"U\"\n      res += 85\n    elsif c.upcase == \"V\"\n      res += 86\n  \
    \  elsif c.upcase == \"W\"\n      res += 87\n    elsif c.upcase == \"X\"\n   \
    \   res += 88\n    elsif c.upcase == \"Y\"\n      res += 89\n    elsif c.upcase\
    \ == \"Z\"\n      res += 90\n    else\n      res += c.ord\n    end\n  end\n  res\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`if c.upcase == \"A\" || c.upcase ==\
    \ \"B\"` is probably a better solution here.\n<|/ c |>\n<| c |>\nSure, you are\
    \ right. I was thinking that maybe there is a more general solution for any `N`\
    \ characters, but I didn't want to ", "  s.chars.inject(0) {|sum, char| sum +\
    \ char.ord if char.upcase }\nend\n</code>\nTo do this, I've added the ord method\
    \ on the char, which converts it to an int with the ascii code, then I check to\
    \ see if it's upcase or not.\n<|/ a tags=ruby |>\n<| c |>\nI appreciate your answer\
    \ but my problem states that I need to use regular expressions.\n<|/ c |>\n<|\
    \ c |>\nWell, I guess my answer is good because I've found it useful to know...\
    \ I've never worked with Ruby before so that's good to know! I've added an explanation\
    \ of what I've just done, and I'll keep working on it.\n<|/ c |>\n<| c |>\nI've\
    \ added an edit that shows you how to do it with regular expressions. I hope it's\
    \ more clear.\n<|/ c |>\n<| c |>\nIf my answer solved your problem, can you mark\
    \ it as accepted? It helps other users who have the same problem and come across\
    \ this question. Thanks!\n<|/ c |>\n<| c |>\nI appreciate your efforts but this\
    \ is not a practical solution to the problem. Thanks anyway :)\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>", "  # Your code here\n  \n  return sum\nend", "  s.chars.reduce(0)\
    \ { |sum, c| sum + c.upcase } # :ok\nend\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\"\
    ) \n</cell>\n<text>\nExercise 12: Write a function called digitLength that returns\
    \ the length of the input string in digits.\nThe digitLength function should have\
    \ an input of any type (string, array, integer, float, etc.). It should return\
    \ an integer.", "  result = 0\n  s.each_byte do |ch| \n    result += (ch.ord -\
    \ 48).abs\n  end\n  return result\nend", "    s = 0\n    s.each_char do |char|\n\
    \        s << char.ord\n    end\n    s.to_i\nend", "  s.chars.map { |c| c.ord\
    \ - 'A'.ord }.inject(:+)\nend\nprint digitSum(\"helloE\")\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a |>\nHere is a solution which converts string to array of chars and\
    \ then sums them up\n<code>", "  sum = 0\n  s.each_char do |c|\n    sum += c.ord\
    \ - 32 if c.ord >= 32\n  end\n  sum\nend\n</code>\n<|/ a dscore=2 tags=ruby,string,algorithm\
    \ |>\n<| c |>\n`s.chars.sum.min` is far more efficient than `s.each_char.sum.min`.\
    \ Also this answer doesn't work for strings containing digits and letters, e.g.\
    \ `\"abc123d\"` gives `15` when it should give `12`.\n<|/ c |>\n<| c |>\n, I just\
    \ changed it to a slightly more readable version of the original.\n<|/ c |>\n\
    <| c |>\nI didn't know about `chars.sum.min`. I was reading up on it today and\
    \ came up with a slightly different solution that I'll post now.\n<|/ c |>\n<|\
    \ c |>\nI like this. You get my upvote and I'll choose this one as it is the most\
    \ readable and efficient. Thanks for the solution.\n<|/ c |>\n<| a |>\nAs per\
    \ my comment above, you can simply use String#sum here:\n<code>\n\"abdcd\".sum\
    \ { |c| c.ord - 32 }", "  if s.length == 0\n    return 0\n  end\n  upper = s.upcase\n\
    \  sum = 0\n  (0...upper.length).each do |i|\n    sum += upper[i].to_i\n  end\n\
    \  sum\nend\n</cell>\n<cell>\ndigitSum(\"a\")\n</cell>\n<cell>\ndigitSum(\"ab\"\
    )\n</cell>\n<cell>\ndigitSum(\"abc\")\n</cell>\n<cell>\ndigitSum(\"abcB\")\n</cell>\n\
    <cell>\ndigitSum(\"abcCd\")\n</cell>\n<cell>\ndigitSum(\"abcCdE\")\n</cell>\n\
    <cell>\ndigitSum(\"abcCdEf\")\n</cell>\n<cell>\ndigitSum(\"abcCdEfg\")\n</cell>\n\
    <cell>\ndigitSum(\"abcCdEfgAB\")\n</cell>\n<cell>\ndigitSum(\"abcCdEfgABcd\")\n\
    </cell>\n<cell>\ndigitSum(\"abcCdEfgABcdEF\")\n</cell>\n<cell>\ndigitSum(\"abcCdEfgABcdEFg\"\
    )\n</cell>\n<cell>\ndigitSum(\"abcCdEfgABcdEFgAB\")\n</cell>\n<cell>\ndigitSum(\"\
    abcCdEfgABcdEFgABcd\")\n</cell>\n<cell>\ndigitSum(\"abcCdEfgABcdEFgABcdEF\")\n\
    </cell>\n<cell>\ndigitSum(\"abcCdEfgABcdEFgABcdEFg\")\n</cell>\n<cell>\ndigitSum(\"\
    abcCdEfgABcdEFgABcdEFgAB\")\n</cell>\n<cell>\ndigitSum(\"abcCdEfgABcdEFgABcdEFgABcd\"\
    )\n</cell>\n<cell>\ndigitSum(\"abcCdEfgABcdEFgABcdEFgABcdEF\")\n</cell>\n<cell>\n\
    digitSum(\"abcCdEfgABcdEFgABcdEFgABcdEFg\")\n</cell>\n<cell>\ndigitSum(\"abcCdEfgABcdEFgABcdEFgABcdEFgAB\"\
    )\n</cell>\n<cell>\ndigitSum(\"abcCdEfgABcd", "  return s.gsub(/([[:digit:]]+)/){|s|\
    \ s.upcase.to_i}.inject(:+)\nend", "    sum = 0\n    s.each_byte {|b| sum += b\
    \ if b > 47 and b < 58 }\n    sum\nend\n</cell>\n<code language=julia-0.6>", " \
    \ sum = 0\n  s.each_char.with_index do |c,i|\n    sum = sum + c if i<s.length-1\
    \ && c.upcase >= s[i].upcase\n  end\n  sum\nend", "    s=s.to_s\n    sum=0\n \
    \   length=s.length\n    i=0\n    while i<length\n        if s[i].upcase==s[i].downcase\n\
    \            sum+=s[i].to_i.to_s\n            i+=1\n        else\n           \
    \ i+=1\n    end\n    return sum\nend", "  s.to_s.each_char.inject([0,0]) do |sum,\
    \ digit|\n    sum[1] += digit if digit < '9'\n    sum[0] += digit - '0' if digit\
    \ >= '0'\n    sum\n  end[1]\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThat is\
    \ a pretty cool one-liner :)\n<|/ c |>\n<| a tags=ruby dscore=3 |>\n<code>", " \
    \ s.split(\"\").inject{ |sum,x| sum + x.upcase } \nend", "  return s.chars.reduce(0)\
    \ {|sum,char| sum+char.ord if char > 64}.to_i\nend\n</cell>\n<cell>\ndigitSum('')\
    \ # 0\ndigitSum(\"abAB\") # 131\ndigitSum(\"abcCd\") # 67\ndigitSum(\"helloE\"\
    ) # 69\ndigitSum(\"woArBld\") # 131\ndigitSum(\"aAaaaXa\") # 153\n</cell>\n<text>\n\
    Exercise 12", "  return s.chars.reduce(:+)\nend", "  s.downcase.gsub(/[a-z]/i).inject(0)\
    \ {|t,c| t.to_i * 26 + c.to_i }\nend", "  s = s[0...-1]\n  s.to_s.chars.sum.upcase\n\
    end", "  sum = 0\n  s.chars.each do |char|\n    sum += char.upcase if char >=\
    \ 'a' && char <= 'z'\n  end\n  return sum\nend", "  return s.to_s.scan(/[a-z]/).inject(0){|sum,e|\
    \ sum + e.upcase }\nend", "  # TODO: implement this function\n  return 0", " \
    \   sum = 0\n    chars.each do |c| \n        if c == s.upcase\n            sum\
    \ += c\n        end\n    end\n    return sum\nend", "  total = 0\n  s.chars.each\
    \ do |char|\n    total += char.ord - \"A\".ord\n  end\n  total\nend", "  return\
    \ s.chars.inject(0) {|sum, element| sum + element.upcase }\nend\nputs digitSum(\"\
    hEllo\")\nputs digitSum(\"woArBld\")\nputs digitSum(\"aAaaaXa\")", "  s = s.replace(/[A-Za-z]{1}/g,\"\
    \")\n  sum = 0\n  s.each_byte {|c| sum += c }\n  sum\nend", "  sum = 0\n  for\
    \ c in s\n    if c.upcase == true && c.downcase == false\n      sum += c.codepoint.chr\n\
    \    end\n  end\n  sum\nend", "  s.chars.map { |c| c.to_i.upcase }.inject { |sum,i|\
    \ sum + i }\nend", "  sum = 0\n  s.each_char do |c|\n    sum += c.ord if (65..90).cover?(c.ord)\
    \ || (97..123).cover?(c.ord)\n  end\n  sum\nend", "  return s.inject(0) {|sum,\
    \ letter| sum + letter.ord - 'A'}\nend", "  s.chars.inject(0) do |sum, char|\n\
    \    sum += char if char >= 'A' && char <= 'Z'\n  end\nend", "  return s.split('').inject(:+)\n\
    end", "  s.chars.reduce(:+).to_i\nend", "  sum = 0\n  s.each_byte do |b|\n   \
    \ sum += b if b >= 'A' and b <= 'Z'\n  end\n  return sum.to_i\nend\nprint digitSum(ARGV[0]),\
    \ \"\\n\"", "    sum = 0\n    \n    # Write your solution here\n    \n    return\
    \ sum\n</cell>\n<cell>\ndigitSum(\"helloE\")\n</cell>\n<text>\n4.3 Recursive Function",
  "    sum_ = 0\n    \n    i = 0\n    \n    while  i < s.length\n        \n      \
    \  if  s[i].ord < 122 \n            sum_ = sum_ + s[i].ord \n        \n      \
    \  else \n            sum_ = sum_ + s[i].ord - 87\n        \n        i = i + 1\n\
    \    end\n    \n    return sum_\nend", "    sum = 0\n    i = 0\n    s.each_byte\
    \ {|b|\n        sum += b\n    }\n    return sum\nend", "  result = 0\n  s.each_char\
    \ do |c|\n    if c.ord >= 48 and c.ord <= 57\n      result += c.ord - 48\n   \
    \ end\n  end\n  result\nend", "  s.to_s.split(\"\").inject(0){|sum,c| sum + c.ord\
    \ - 48 }\nend", "    sum=0\n    for i in (s.gsub(/[\\D]/,'').downcase).chars\n\
    \        sum+=i.to_i\n    sum\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis\
    \ doesn't work, at least not in Ruby 1.9.3. It seems like `chars` only takes one\
    \ argument, and you can't specify a range.\n<|/ c |>\n<| c |>\nIt works in 1.8.7.\
    \ Ruby 1.8.7 will throw a syntax error if you try to pass a range.\n<|/ c |>\n\
    <| c |>\nIn 1.8.7, it only takes one argument in Ruby 1.9.  I'm sure it works\
    \ in 1.9.\n<|/ c |>\n<| c |>\n, you are right. I must have read it wrong. I'll\
    \ update it.\n<|/ c |>\n<| c |>\nI believe that in 1.8.7, `chars` takes only one\
    \ argument (no range).  But in 1.9.3, it takes a range.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=2 |>\n<code>", "  res = 0\n  s.downcase.chars.each do |char|\n    next\
    \ if char.upcase != char\n    res += char.ord - char.ord.upcase\n  end\n  return\
    \ res\nend", "  s = 0\n  s.each_byte { |c| s += (c >= 'A' && c <= 'Z') ? c.ord\
    \ - 'A'.ord : c }\nend", "  s = \"\" + s\n  return s.chars.inject(0) { |t,c| t\
    \ + ord c }\nend", "    i = 0\n    sum = 0\n    while i < s.length\n        sum\
    \ = sum + s[i].ord\n        i += 1\n    end\n    return sum\nend", "    s.split(//).inject(0)\
    \ do |sum, char|\n        if char >= 'a' && char <= 'z'\n            sum += char.to_i\n\
    \        end\n        sum\n    end\nend", "  sum = s.downcase.scan(/[A-Z]/).inject(:+)\n\
    end", "  s.split(\"\").inject(0) { |sum, char| sum + char.ord - 'A'.ord }\nend",
  "  return s.to_s.to_i.inject {|sum, digit| sum + digit if digit >= '0' and digit\
    \ <= '9'}\nend\n</code>\nI added .to_s to your original because your strings are\
    \ actually of class String which is an Enumerable object (and it's an Enumerable\
    \ so you can use inject on it), so you have to explicitly convert it to a String\
    \ before you can use inject on it.\n<|/ a tags=ruby |>\n<| c |>\nI'm glad to have\
    \ helped!\n<|/ c |>\n<| a dscore=0 tags=ruby |>\nIn addition to other answers,\
    \ you can also do:\n<code>", "  # split string by '\n  arr = s.split('')\n  #\
    \ convert string to ASCII codes\n  arr = arr.map{|x| x.ord - 97}\n  # return sum\n\
    \  return arr.inject(:+)\nend", "  return s.chars.inject(0) { |sum, el| el >=\
    \ 'A' && el <= 'Z' ? sum + el - 'A' + 10 : sum } + digitSum(s.chars.last)\nend",
  "    sum = 0\n    s.each {|x| sum += x.to_i}\n    sum\nend", "    sum = 0\n    s.each\
    \ do |char|\n        if char >= '0' && char <= '9'\n            sum = sum + char.to_i\n\
    \        end\n    end\n    return sum\nend", "  result = \"\"\n  s.chars.sort.each\
    \ do |char|\n    result += char if char.upcase >= char\n  end\n  result\nend",
  "\ts.chars.each_with_index.inject{|s,e| (s += e[1]) if (e[0] =~ /[A-Z]/)}\nend",
  "  # TODO: Write code here\n  return 0", "  s.chars.reduce(0) { |result, char| char.ord\
    \ - result.ord + 1 }\nend", "  return s.chars.to_a.sum.divmod(10)\nend", "  #\
    \ Your code here\n  \nend", "  result = s.length\n  s.chars.each_with_index do\
    \ |char, index|\n    if char >= 65 && char <= 90\n      result += char - 65\n\
    \    elsif char >= 97 && char <= 122\n      result += char - 97\n    end\n  end\n\
    \  result\nend", "  return s.to_s.chars.inject(0, :+).to_i\nend", "  s.split('').inject(0)\
    \ do |sum, char|\n    if char >= '0' && char <= '9'\n      sum += char.to_i.abs\n\
    \    end\n    sum\n  end\nend", "  result = 0\n  for c in s\n    if ('A' <= c\
    \ && c <= 'Z').zero?\n      result += c.to_i.upcase\n    end\n  end\n  result\n\
    end", "  sum = 0\n  s.each_byte { |c| sum += c.to_i }\n  sum\nend", "  sum = 0\n\
    \  s.chars.each do |ch|\n    if ch.upcase == ch\n      sum += ch.ord\n    end\n\
    \  end\n  sum\nend", "    sum = 0\n    s.length.times { |i| sum += s[i].ord }\n\
    \    sum\nend\n</code>\n<|/ a dscore=0 tags=ruby,arrays |>\n<| c |>\n`s.chars.map(&:ord).sum`\
    \ would be a lot cleaner\n<|/ c |>\n<| c |>\n`s.chars.map(&:ord).inject{|sum,\
    \ a| sum + a}` is even cleaner.\n<|/ c |>\n<| c |>\nHe was specifically asking\
    \ for the sum of only the uppercase characters, not only ASCII characters.\n<|/\
    \ c |>\n<| c |>\nYeah, you're right the question is confusing to me. I was more\
    \ focused on the \"How do I find the sum of only the upper case letters\" and\
    \ I didn't even think about uppercase letters.\n<|/ c |>\n<| c |>\n\"How do I\
    \ find the sum of only the upper case letters\" is not very clear but if he wants\
    \ to just add up ASCII chars then `s.chars.map(&:ord).inject{|sum, a| sum + a}`\
    \ is better than `s.chars.map(&:ord).sum` since `s.chars.map(&:ord).sum` will\
    \ do a `count` for non-letters whereas `s.chars.map(&:ord).inject{|sum, a| sum\
    \ + a}` won't. Just for reference: `s.chars.map(&:ord).sum => 181` and `s.chars.map(&:ord).inject{|sum,\
    \ a| sum + a} => 182`.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  s.each_char.inject(0)\
    \ do |sum, elem|\n    sum + elem.to_i\n  end\nend", "    sum = 0\n    s.each_char\
    \ do |x|\n        sum += x.to_i.upcase if x.to_i.upcase >= 65 && x.to_i.upcase\
    \ <= 70\n    end\n    return sum\nend", "  s.each_byte { |x| return (x + 48) if\
    \ (x > 48 && x < 58) }\nend\nputs digitSum('aaa')", "  s.each_char.inject { |sum,\
    \ char| char.upcase ? sum + char.upcase : sum }.to_s\nend", "  return s.chars.map\
    \ {|c| c.upcase }.inject {|sum, s| sum + s }\nend", "  s.chars.each_cons(2).inject(0)\
    \ { |sum, (s, e)| sum + e.ord - s.ord }\nend", "  sum = 0\n  s.each do |c|\n \
    \   sum += c.ord - 64\n  end\n  sum\nend", "  sum = 0\n  s.each_char do |c|\n\
    \    sum = sum + c.ord + 32\n  end\n  sum\nend\nprint(digitSum(''))\nprint(digitSum('abAB'))\n\
    print(digitSum('abcCd'))\nprint(digitSum('helloE'))\nprint(digitSum('woArBld'))\n\
    print(digitSum('aAaaaXa'))", "    s.chars.reduce(0) {|sum,c| sum + c.ord - 96}\n\
    end\n</cell>\n<code language=julia-1.5>\ndigitSum(\"woArBld\")\n</cell>\n<code\
    \ language=julia-1.5>", " str.scan(/[A-Z]/).reduce(:+)\nend", "  s.scan(/[A-Za-z]+/)\
    \ do |char| \n  char.upcase \n  end.reduce(:+)\nend", "  # Your code here\nend",
  "    return s.upcase.gsub(/[a-z]/).to_s.inject(0) {|sum, letter| sum + letter.ord}\n\
    end", "    sum = 0\n    s.each_char do |i| sum += i if i.upcase == \"A\" end\n\
    \    sum\nend", "  s.chars.inject { |sum, el| sum + el if el >= 'A' && el <= 'Z'\
    \ }\nend", "  chars = s.to_s.chars\n  sum = chars.map {|char| char.upcase }.sum\n\
    \  return sum\nend", "    s = s.to_s \n    s.to_i.inject(0) {|sum, a| sum + a\
    \ }\nend", "    sum = 0\n    s.each_char do |c|\n        if c.upcase > 96\n  \
    \          sum += c.to_i\n        end\n    end\n    return sum\nend", "  s.downcase.scan(/[[:alpha:]]/).reduce(:+)\n\
    end", "  sum = 0\n  s.each do |i|\n    if i.upcase == 'A'\n      sum += 65\n \
    \   elsif i.upcase == 'a'\n      sum += 97\n    elsif i.upcase == 'X'\n      sum\
    \ += 95\n    end\n  end\n  return sum\nend", "  return s.chars.inject(0) { |sum,\
    \ el| sum + el if el >= 'A' && el < 'Z' }\nend", "  s.each_char do |letter|\n\
    \    next if letter == letter[0]\n    next if letter == letter[0]\n    sum +=\
    \ letter\n  end\n  sum\nend\n</code>\n<|/ a |>\n<| c |>\nWhy do you use `next`?\
    \ It seems to me that the `if` statement is sufficient, no?\n<|/ c |>\n<| c |>\n\
    It seems you're right. I updated the answer to reflect that.\n<|/ c |>\n<| a tags=ruby,functional-programming\
    \ |>\nI wrote a more verbose version of the answer by Frederick Cheung, but in\
    \ a very functional style:\n<code>", "    sum = 0\n    \n    if s.empty?\n   \
    \     return sum\n    end\n    \n    for i in 0..s.length-1\n        if s[i].upcase\
    \ == s[i].downcase\n            sum += s[i].code\n        end\n    end\n    \n\
    \    sum\nend\n</cell>\n<code language=julia-1.2>\ndigitSum(\"hello world\")\n\
    </cell>\n<code language=julia-1.2>", "  sum = 0\n  s.chars.each do |c|\n    if\
    \ c.upcase == 'A'\n      sum += 26\n    elsif c.upcase == 'a'\n      sum += 97\n\
    \    elsif c.upcase == 'X'\n      sum += 108\n    elsif c.upcase == 'x'\n    \
    \  sum += 120\n    end\n  end\n  sum\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (element, index)|\n    sum + (element[0] <=> element[1]) * (element[0].ord\
    \ + element[1].ord)\n  end\nend", "  # Solution begins\n  \n  # Step 1: Initialize\
    \ sum with 0\n  sum = 0\n  # Step 2: Iterate through each character in string\n\
    \  s.each_char do |c|\n    # Step 3: If character is an uppercase letter, add\
    \ it to sum\n    if c.upcase == true\n      sum += c.ord\n    end \n  end\n  \n\
    \  # Step 4: Return sum\n  return sum\nend", "  sum = Array.new\n  s.split(\"\"\
    ).each do |char|\n    sum << char.ord.upcase\n  end\n  sum.inject(:+)\nend", " \
    \   s.chars.reduce(:+).upcase\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\nThe way I understand your question, you're trying to find a way to detect\
    \ when a specific character appears in a string, and increment a counter accordingly.\n\
    One way to do that is to use regex. Here's an example of how to use it in your\
    \ code. \n<code>", " result = 0\n s.each_byte do |e|\n  if e >= 48 && e <= 57\n\
    \   result << e\n  end\n end\n result\nend", "  # Your code here\n  return 0\n\
    end", "  sum = 0\n  s.each_byte do |c|\n    sum += c if c >= 48 && c <= 57\n \
    \ end\n  return sum\nend", "  s.downcase!\n  result = 0\n  s.each_char.with_index\
    \ { |c, i| result += c.ord + i if c.upcase }\n  result\nend", "    s.split(\"\"\
    ).inject(0) {|sum, n| sum + n.to_i}\nend", "  s.upcase!\n  s.split.inject{|sum,x|\
    \ sum + x.ord - \"A\".ord }\nend\n</code>\n<|/ a |>\n<| a dscore=1 tags=ruby |>\n\
    You might want to do something like:\n<code>", "    sum = 0\n    s.each_char do\
    \ |char|\n        sum += char.upcase unless char == ?A\n    end\n    return sum\n\
    end", "    \n    sum = 0\n    s.chars.each do |c|\n        if c.upcase == \"A\"\
    \n            sum += 26\n        else\n            sum += c\n        end\n   \
    \ end\n    \n    return sum\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n\
    I did not understand this answer. I was thinking about this problem in the context\
    \ of ASCII. The reason I am getting confused is because there is an extra layer\
    \ of abstraction that the string class provides. Why are you going through each\
    \ character and adding them all up? What if I want to only sum up uppercase ASCII\
    \ characters?\n<|/ c |>\n<| c |>\nI added a link to the ASCII table that explains\
    \ it better than I could. Basically, it says that a capital letter A is 65 and\
    \ a lowercase letter a is 97. So you add 26 to 65 to get 65.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\nYou can use Enumerable#inject:\n<code>\n'hello'.enum_for(:each_char).inject(0)\
    \ {|sum,c| sum + c.upcase }", "  result = 0\n  s.each_char do |c|\n    result\
    \ += (c.ord - '0').abs\n  end\n  return result\nend\n</cell>\n<cell>\ndigitSum(\"\
    aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"\
    aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"\
    aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"\
    aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"\
    aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"\
    aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"\
    aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"\
    aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"\
    aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"\
    aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"\
    aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"\
    aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"\
    aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\")\n</cell>\n<cell>\ndigitSum(\"\
    aAaa", "  return s.chars.map{|c| (c >= 'A' && c <= 'Z') ? c-'A'+10 : c}.inject{|sum,x|\
    \ sum + x}\nend", "  sum = s.chars.map.with_index { |c, i| c.ord }.inject { |sum,\
    \ v| sum + v }\n  sum % 10 # Return one digit\nend", "  s.chars.inject(0) do |sum,\
    \ char|\n    sum + char.ord if char >= '0' && char <= '9'\n  end\nend", "    return\
    \ s.chars.inject(0) { |sum, char| sum + (char ord > 57 ? char.ord - 48 : char.ord\
    \ + 48) }\nend\n</code>\n<|/ a |>\n<| c |>\nI don't think it's necessary to explicitly\
    \ call `to_i`. You can just do `ord - 48`.\n<|/ c |>\n<| c |>\nGood point! Though\
    \ I haven't actually tested this code. I've just copied it straight out of the\
    \ question.\n<|/ c |>\n<| a tags=ruby |>\n<code>\nstring.each_char { |c| c if\
    \ c.ord > 64 }.inject{ |sum, c| sum + c }\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    Nice answer. This also lets you treat Unicode as well.\n<|/ c |>\n<| c |>\nThis\
    \ answer is missing its educational explanation.\n<|/ c |>\n<| a |>\n<code>\n\"\
    abc\".to_enum.each_char.sum{|c| c.ord if c.ord < 128}\n=> 123\n</code>\n<|/ a\
    \ dscore=2 tags=ruby |>\n<| c |>\n\"abc\".to_enum.each_char.sum{|c| c.ord if c.ord\
    \ < 128}\n=> 123\n<|/ c |>\n<| c |>\nThis is the most concise and readable answer,\
    \ IMO.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nstring = \"abc\"\nstring.size.times.reduce(0)\
    \ { |sum, i| sum + string[i][1].to_i if string[i][0] == 'a' }.to_s", "  return\
    \ s.length.to_i\nend\n</cell>\n<text>\n6. Functions\n5.1. Function\nA function\
    \ is a named block of code that can be passed as an argument to another function.\
    \ The other function can then use that function as an argument. Functions are\
    \ very important parts of Ruby, and we will learn about them in later lessons.\
    \ Here is an example of what a function in Ruby looks like:", "  count = 0\n \
    \ s.each do |c|\n    count += if c.upcase == c\n              c.upcase\n     \
    \       else\n              c.downcase\n            end\n  end\n  count\nend",
  "  if s.empty?\n    0\n  else\n    s.chars.map(&:ord).sum\n  end\nend", "    sum\
    \ = 0\n    \n    chars = s.split('')\n    \n    chars.each do |letter|\n     \
    \   if letter.upcase != letter\n            sum += letter.ord\n        end\n \
    \   end\n    return sum\nend", "  s.each_char.inject(:+).to_s\nend", "  s.split(\"\
    \").map(&:to_i).inject(:+).to_s\nend", "  sum = 0\n  s.chars.reverse_each.with_object(sum)\
    \ do |char, sum|\n    sum += if char.upcase == char\n      char.upcase.ord\n \
    \   else \n      char.downcase.ord\n    end\n  end\nend", "  s.upcase =~ /^[[:digit:]]/\
    \ ? s.upcase.to_i : 0\nend", "    sum = 0\n    s.chars.each do |x|\n        if\
    \ x.upcase == x\n            sum += x.ord + 48\n        end\n    end\n    return\
    \ sum\nend", "    return s.to_s.scan(/./).reduce(:+)\nend", "  s.gsub(/[^\\d]/,'').chars.map\
    \ { |c| c.upcase }.inject(:+)\nend", "    # Your code here\n    return 0\nend",
  "    # Your code goes here\n    s.each_byte {|c| sum+=c if c >= 48 && c <= 57}\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI appreciate your answer, but this doesn't solve\
    \ my problem.\n<|/ c |>\n<| c |>\nI see now. I would like to know if the code\
    \ I provided was helpful to you or not.\n<|/ c |>\n<| c |>\nThanks, that's great\
    \ to know! I've already upvoted it.\n<|/ c |>\n<| c |>\nGlad I could help. I see\
    \ that you want to do other things in the future, so keep that in mind when you\
    \ work with strings. I only really edited your question to make it easier to understand.\n\
    <|/ c |>\n<| a tags=ruby,string dscore=2 |>\nYou could use scan and map together\
    \ to get an array of all digits, then sum the array.\n<code>\n\"123321\".scan(/\\\
    d/).map(&:to_i).inject(:+)\n</code>\n<|/ a |>\n<| c |>\nI appreciate your answer,\
    \ but this doesn't solve my problem.\n<|/ c |>\n<| a dscore=1 |>\nIf you just\
    \ want to find the sum of the ASCII codes of the digits, I would suggest the following\
    \ way:\n<code>\n\"1abCdE\".chars.sum { |i| i.to_i }", "  return s.inject {|sum,\
    \ character| sum + character.ord - '0'}\nend\n</cell>\n<cell>\ndigitSum(\"A\"\
    )\n</cell>\n<cell>\ndigitSum(\"abcCd\")\n</cell>\n<cell>\ndigitSum(\"helloE\"\
    )\n</cell>\n<cell>\ndigitSum(\"woArBld\")\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\"\
    )\n</cell>\n<cell>\n'aAaaaXa'.ord #=> 97\n</cell>\n<cell>\n'aAaaaXa'.ord # =>\
    \ 97\n'a'.ord # => 65\n'A'.ord # => 65\n</cell>\n<cell>\n'aA'.ord # => 97\n'A'.ord\
    \ # => 65\n</cell>\n<cell>\n'aA'.ord # => 97\n'A'.ord # => 65\n</cell>\n<cell>\n\
    'aA'.ord # => 97\n'A'.ord # => 65\n</cell>\n<cell>\n'aA'.ord # => 97\n'A'.ord\
    \ # => 65\n</cell>\n<cell>\n'aA'.ord # => 97\n'A'.ord # => 65\n</cell>\n<cell>\n\
    'aA'.ord # => 97\n'A'.ord # => 65\n</cell>\n<cell>\n'aA'.ord # => 97\n'A'.ord\
    \ # => 65\n</cell>\n<cell>\n'aA'.ord # => 97\n'A'.ord # => 65\n</cell>\n<cell>\n\
    'aA'.ord # => 97\n'A'.ord # => 65\n</cell>\n<cell>\n'aA'.ord # => 97\n'A'.ord\
    \ # => 65\n</cell>\n<cell>\n'aA'.ord # => 97\n'A'.ord # => 65\n</cell>\n<cell>\n\
    'aA'.ord # => 97\n'A'.ord # => 65\n</cell>\n<cell>\n'aA'.ord # => 97\n'A'.ord\
    \ # => 65", "  s.downcase!\n  s.chars.inject(0) { |sum, char| sum + char.ord -\
    \ 65 }\nend\n</code>\nThe inject method works like this: the first time the block\
    \ is run, sum is 0. If the first argument is a number, the block is run that many\
    \ times. If it is an array, the block is run once for each element of the array.\n\
    So:\n<code>\ns.chars.inject(0) { |sum, char| sum + char.ord - 65 }\n</code>\n\
    is roughly equivalent to:\n<code>\nsum = s.chars.inject(0) { |sum, char| sum +\
    \ char.ord - 65 }\n</code>\nAnd since char.ord - 65 is just char itself, it's\
    \ equivalent to this:\n<code>\nsum = s.chars.inject(0) { |sum, char| sum + char\
    \ }\n</code>\nFinally, note that inject does not return a value, but a number\
    \ or an array. In other words, it works like this:\n<code>\nsum = s.chars.inject(0)\
    \ { |sum, char| sum + char.ord - 65 }", "  # Convert string to an array of digits\n\
    \  arr = s.chars.map{ |e| e.ord }.sort\n  # Return sum of digits in correct order\n\
    \  arr.inject(0){ |sum,x| sum + x }\nend", "  sum = 0\n  s.each_char do |c|\n\
    \    sum = sum + c.ord + 48 if c.upcase == c\n  end\n  sum\nend", "    s = s.chars.map\
    \ { |c| c.to_i }\n    sum_ = 0\n    s.each { |x| sum_ += x }\n    sum_\nend",
  "  sum = 0\n  s.each_char.map {|c| sum += (c.ord - 'A') * (c.ord - '0')}\n  sum\n\
    end", "  s.chars.inject(0) do |sum, (char)|\n    sum += (char.ord + 48) unless\
    \ char.ord == 8\n  end\nend", "  # Return the sum of all digits in the string\n\
    \  sum = 0\n  s.chars.each {|c| sum += c.to_i}\n  sum\nend", "  result = 0\n \
    \ s.downcase.split(//).each do |v|\n    if v.length > 0\n      result += v.to_i.upcase\
    \ - (v.to_i.upcase - v.to_i.downcase)\n    end\n  end\n  return result\nend\n\
    puts digitSum(ARGV[0]).to_s", "  s.split(\"\").map { |x| x.upcase }.inject{ |sum,\
    \ el| sum + el }\nend", "  s.chars.inject(0) { |sum, e| sum += e if e.is_a? Integer;\
    \ sum }\nend", "  sum = 0\n  s.each_byte do |b|\n    if (b>=65 and b <= 90)\n\
    \      sum+=b-55\n    end\n  end\n  return sum\nend", "  count = 0\n  s.each_char\
    \ do |char|\n    if char > \"9\".ord || char < \"0\".ord # ASCII code for digits\n\
    \      count += 1\n    end\n  end\n  return count\nend", "  s.gsub!( /\\D/, '')\n\
    \  s.to_s.chars.inject(:+)\nend", "  s.each_char.map {|c| c.upcase }.inject(0,\
    \ :+)\nend", "  return s.split(\"\").inject(0) do |sum, i|\n    sum + i.to_i\n\
    \  end\nend\n</code>\n<|/ a dscore=0 tags=functional-programming,ruby |>\n<| a\
    \ dscore=0 |>\nHow about this\n<code>", "  s.chars.map { |c| c.ord }.inject(:+)\n\
    end", "    return s.chars.map(&:to_i).sum\nend", "  # TODO: Write your code here\n\
    \  return 0\nend", "    sum = 0\n    for i in s\n      sum += i.ord / 10\n   \
    \ end\n    sum\nend", "  s.chars.reduce{|sum, char| sum + (char.ord >= 'A' ? char.ord\
    \ - 'A' + 10 : char.ord >= 'a' ? char.ord - 'a' + 26 :  char.ord >= '0' ? char.ord\
    \ - '0' : 0) }\nend", "  sum = 0\n  for c in s.split(\"\").map {|c| c.ord }\n\
    \    sum += (c.to_i) * (c.ord >= 64 and c.ord <= 90 ? -1 : 1)\n  end\n  return\
    \ sum\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI think your `digitSum` should\
    \ return `sum`.\n<|/ c |>\n<| c |>\nGood catch. I will fix it.\n<|/ c |>\n<| a\
    \ tags=ruby,ascii,ruby-on-rails |>\nThis solution is quite simple and does the\
    \ trick:\n<code>", "  sum = 0\n  s.each_char.with_index do |letter, index|\n \
    \   if letter.upcase == \"A\"\n      sum += 32\n    elsif letter.upcase == \"\
    a\"\n      sum += 97\n    elsif letter.upcase == \"X\"\n      sum += 118\n   \
    \ elsif letter.upcase == \"x\"\n      sum += 127\n    end\n  end\n  sum\nend",
  "  digits = s.chars.map { |char| char.ord }.select { |i| i >= 48 && i <= 57 }.sum\n\
    \  digits.to_s\nend", "  sum = 0\n  s.each_char do |c|\n    sum += (c.ord - 'A'\
    \ + 1)\n  end\n  return sum\nend\ndigitSum(\"abc\")\ndigitSum(\"abc\")\ndigitSum(\"\
    AaB\")\ndigitSum(\"AaB\")\ndigitSum(\"aAaaaXa\")\ndigitSum(\"aAaaaXa\")\ndigitSum(\"\
    AaB\")\ndigitSum(\"AaB\")\ndigitSum(\"aAaaaXa\")\ndigitSum(\"aAaaaXa\")", "  s.gsub(/[^\\\
    d]/,'').chars.map(&:ord).reduce(:+)\nend", "    sum = 0\n    s.each_byte {|c|\
    \ sum += c}\n    return sum\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\n\
    \  def digitSum\n    str = \"helloE\"\n    str.split.map {|x| x.to_i.to_s(36).count(\"\
    0\") }.reduce(:+)\n  end\n</code>\n<|/ a tags=ruby,digits,sum dscore=1 |>\n<|\
    \ a |>\nHere's another one:\n<code>", "  sum = 0\n  s.chars.each { |ch| sum +=\
    \ ch.ord - '0'; return sum if sum >= 10 }\nend\n</code>\n<|/ a tags=string,ruby,regex\
    \ |>\n<| c |>\nThis does not produce the correct answer. For example `digitSum(\"\
    aAaaaXa\")` should return 153, but this returns 150.\n<|/ c |>\n<| c |>\nI guess\
    \ it was a typo that should have been `if sum >= 10`. Thanks for pointing it out\
    \ though.\n<|/ c |>\n<| a tags=string,ruby,regex |>\nYou can use this:\n<code>",
  "  sum = 0\n  s.to_s.reverse.each_char.with_index do |char, i|\n    sum += char.ord\
    \ - 96 if char.upcase != char\n  end\n  sum\nend\nputs \"sum of uppercase chars:\
    \ #{digitSum(\"\")}\"\nputs \"sum of uppercase chars: #{digitSum(\"abAB\")}\"\n\
    puts \"sum of uppercase chars: #{digitSum(\"abcCd\")}\"\nputs \"sum of uppercase\
    \ chars: #{digitSum(\"helloE\")}\"\nputs \"sum of uppercase chars: #{digitSum(\"\
    woArBld\")}\"\nputs \"sum of uppercase chars: #{digitSum(\"aAaaaXa\")}\"\n</cell>\n\
    <cell>", "  s.downcase!\n  s.chars.reduce(0) {|sum,c| sum + c.ord + 48 if c >=\
    \ '0' and c <= '9'}\nend", "  sum = 0\n  s.split(\"\").each do |c|\n    sum +=\
    \ c.upcase == c ? c.ord : 0\n  end\n  return sum\nend\n</cell>\n<cell>\ndigitSum(\"\
    \")\n</cell>\n<cell>\ndigitSum(\"abAB\")\n</cell>\n<cell>\ndigitSum(\"abcCd\"\
    )\n</cell>\n<cell>\ndigitSum(\"helloE\")\n</cell>\n<cell>\ndigitSum(\"woArBld\"\
    )\n</cell>\n<cell>\ndigitSum(\"aAaaaXa\")\n</cell>\n<text>\nTask 6\nWrite a function\
    \ that takes a string as input. \nIt should return the longest substring in the\
    \ original string which has the most vowel counts. \nFor example \"abbAAbAb\"\
    \ should return 3 vowel counts, while \"aabb\" would return 2 vowel counts. \n\
    If there is no such substring, it should return 0.\n'vowel counts' are defined\
    \ as follows:\nvowel = 'aeiou'\nconsonant = 'bcdfghjklmnpqrstvwxyz'\nvowel_counts\
    \ = str.chars.group_by(&:upcase).map{|k,v| [k, v.count]}\nvowel_counts.max{|a,\
    \ b| a.last.size <=> b.last.size}[0] => the substring that has most vowel counts\n\
    vowel_counts.max{|a, b| a.last.size <=> b.last.size}[1] => the vowel counts associated\
    \ to that substring", "  result = 0.upto('z'.ord, by: -1).inject(0) { |total,\
    \ (letter, number)| total + (letter.ord - 'a'.ord) * (number.to_i.abs % 26).to_i}\n\
    \  result = result * (s.size - s.length).to_i\nend", "  sum = 0\n  s.each_byte\
    \ {|x| sum += x if x >= 65 && x <= 90}\n  sum\nend", "  s = s.chars.reduce(0)\
    \ {|sum, char| sum + char.upcase - 32}\nend", "  s.scan(/./).inject(0) { |sum,\
    \ chr| sum + chr.ord - \"a\".ord }\nend\n</cell>\n<cell>", "  result = 0\n  s.chars.map\
    \ { |c| result = result + c.upcase }.reduce(:+) \nend", "    sum = 0\n    i =\
    \ 0\n    while i < s.length\n        char = s[i]\n        if char >= '0' and char\
    \ <= '9'\n            sum += char.to_i\n            i += 1\n        end\n    end\n\
    \    return sum\nend", "  s.downcase!\n  s = 0\n  s.each_char {|c| s += c.ord\
    \ if (c.ord >= 48 and c.ord <= 57)}\n  s\nend", "  s = s[0,s.length-1] # removes\
    \ the last character for simplicity\n  s.chars.inject {|sum, letter| sum+letter.ord\
    \ - 96 if letter }.to_s\nend", "  sum = 0\n  s.each_char.with_index do |c, i|\n\
    \    sum += c.ord if c.upcase == c.downcase\n  end\n  sum\nend", "  result = s.to_s.size.times.map\
    \ { |i| s.chars.map{ |c| c.to_i }.sum }\n  result.sum\nend\ndigitSum(\"abAB\"\
    )\ndigitSum(\"abcCd\")\ndigitSum(\"helloE\")\ndigitSum(\"woArBld\")\ndigitSum(\"\
    aAaaaXa\")", "    count = 0\n    s.each_char do |char|\n        char = char.upcase\n\
    \        if char =~ /^[[:alpha:]]/\n            count += char.ord - 96\n     \
    \   end\n    end\n    count\nend", "  s.to_s.each_char.inject(0) { |sum,a| sum\
    \ + a.to_i }\nend", "  s.chars.map { |c| c.ord - 'a'.ord }.inject { |s,i| s +\
    \ i }\nend\n</code>\n<|/ a tags=ruby,arrays,char |>\n<| c |>\nIt's a good answer\
    \ but if you try your method on a string that doesn't contain a letter, the method\
    \ will fail. Maybe add a `try` before `ord =` to catch any unexpected error\n\
    <|/ c |>\n<| c |>\nYou're right, the method should return 0 when there are no\
    \ letters in the input\n<|/ c |>\n<| c |>\nI agree with, your method should be\
    \ called `digitSum` and it should be able to handle `nil` input.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nThe Ruby method String#sum can do this job for you:\n<code>",
  "    sum = s.split.map {|x| x.to_i}.reduce(:+)\n    return sum\nend", "    i = 0\n\
    \    while i < s.length\n        i += 1\n        if s[i] >= 'A' and s[i] <= 'Z'\n\
    \            i += 32\n        end\n    end\n    i\nend", " s.chars.map{|e| e.to_i}.inject(:+)\
    \ # => 131\nend", "  s.chars.map { |c| c.ord }.sum\nend", "  return s.each_char.inject(0)\
    \ { |sum, s| sum + s.upcase }\nend", "  sum = 0\n  s.each_char do |c|\n    sum\
    \ += c.ord - \"A\".ord\n  end\n  sum\nend", "  sum = 0\n  s.each_byte { |c| sum\
    \ += c if c.between?(97..122) }\n  sum\nend", "  # split string by whitespace\
    \ \n  # uppercase letters \n  # convert to array of chars\n  a = s.split('').map(&:upcase)\n\
    \  \n  # sum all chars in uppercase letters \n  a.inject(:+) \nend", "  s.chars.inject(0)\
    \ {|sum, char| sum + char.ord - char.ord.upcase }\nend", "    digits.each { |c|\
    \ s += c.ord }\n    s\nend", "  sum = 0\n  s.each do |i|\n    sum += i.codepoint\
    \ if i.upcase? and i.length > 0\n  end\n  return sum\nend", "  s.split('').inject(0)\
    \ {|sum,char| sum + char.ord}\nend", "  sum = 0\n  s.each_char do |char|\n   \
    \ sum += char.ord\n  end\n  return sum\nend", "  count = 0\n  s.each_char { |c|\n\
    \    if c.upcase > '9' \n      count += 1\n    end\n  }\n  return count\nend",
  "  sum = 0\n  s.each {|x| sum += x.to_i.upcase}\n  return sum\nend", "  sum = 0\n\
    \  s.each_char.with_index do |char, index|\n    if (index + 1) < s.length\n  \
    \    sum = sum + char.ord + s.chars[index + 1].ord if (char >= 'A' && char <=\
    \ 'Z')\n    end\n  end\n  return sum\nend\ndigitSum(\"aAaaaXa\") # => 153\ndigitSum(\"\
    aAaaaXaX\") # => 152\ndigitSum(\"aAaaaXaXbX\") # => 153\ndigitSum(\"AaBbXcX\"\
    ) # => 191\ndigitSum(\"AaBbXcXDdE\") # => 198\ndigitSum(\"aAaaaXaXbXcX\") # =>\
    \ 182", "    sum=0\n    s.chars.each do |c|\n        sum+=c.ord if c.chr?\n  \
    \  end\n    return sum\nend\nputs digitSum(ARGV[0])\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nI think this doesn't match the specs. Look at the examples in the\
    \ question. For example, it returns `11` for `\"a\"` (which should be 0). I think\
    \ `ord 'a'` is 122, not 105, and 122-105 is `11`, which is wrong.\n<|/ c |>\n\
    <| c |>\nSorry, I misunderstood the specs and thought they were all numbers. I've\
    \ added an extra line to the code to deal with the fact that uppercase letters\
    \ have different ASCII values. I still think it's a better answer than mine, though.\n\
    <|/ c |>\n<| c |>\n`c.ord if c.chr?` should be `c.ord if c.chr?` :)\n<|/ c |>\n\
    <| c |>\nThat's not true according to the specs. I'm pretty sure the specs mean\
    \ that `uppercase_digit_sum(\"a\")` should be `0`. Your code returns `11`.\n<|/\
    \ c |>\n<| c |>\nYou are absolutely correct. I edited my answer accordingly.\n\
    <|/ c |>\n<| a dscore=1 tags=ruby |>\nThis is a simple way that doesn't require\
    \ converting the string to an array.\n<code>", "  # Solution\n  sum = 0\n  s.each_char.with_index\
    \ do |char,i|\n    if char.upcase == char\n      sum += i\n    end\n  end\n  return\
    \ sum\n  # End Solution\nend", "    return s.chars.inject(0) { |sum, n| sum +\
    \ (n.ord - '0').to_i }\nend\n</code>\nAs per your question:\n<code>", "  # Your\
    \ code here\n  s.chars.map { |ch| ch.ord - 'a'.ord }.inject(:+)\nend", "    s.length.times\
    \ do |i|\n        s[i] = s[i].upcase.chars.map(&:to_i).inject { |s, e| s + e }\n\
    \    end\n    return s.inject { |s, e| s + e }\nend", "  s.chars.map { |s| s.ord\
    \ }.inject(:+)\nend", "  # TODO: Write your code here\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
