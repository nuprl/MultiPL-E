name: HumanEval_113_odd_count
language: rb
prompt: "# Given a list of strings, where each string consists of only digits, return\
  \ a list.\n# Each element i of the output should be \"the number of odd elements\
  \ in the\n# string i of the input.\" where all the i's should be replaced by the\
  \ number\n# of odd digits in the i'th string of the input.\n# >>> odd_count(['1234567'])\n\
  # [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n# >>> odd_count(['3',\"\
  11111111\"])\n# [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n\
  # \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\ndef odd_count(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_odd_count\n\
  \    candidate = method(:odd_count)\n    assert_equal([\"the number of odd elements\
  \ 4n the str4ng 4 of the 4nput.\"], candidate.call([\"1234567\"]))\n    assert_equal([\"\
  the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd\
  \ elements 8n the str8ng 8 of the 8nput.\"], candidate.call([\"3\", \"11111111\"\
  ]))\n    assert_equal([\"the number of odd elements 2n the str2ng 2 of the 2nput.\"\
  , \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of\
  \ odd elements 2n the str2ng 2 of the 2nput.\"], candidate.call([\"271\", \"137\"\
  , \"314\"]))\n  end\nend\n"
completions: ["  return [ \"the number of odd elements #{lst.select{|e| e.to_i.odd?}.count}\"\
    \ for lst in lst]\nend", "  lst.each_with_index do |str,i|\n    str.gsub!(/\\\
    d/,'n').to_i\n    lst[i] = str.to_s.gsub(/\\d/n,'n').length\n  end\nend\n</code>\n\
    I suspect that the problem is in your loop\n<code>\nwhile !end\n  puts \"Enter\
    \ your next name: #{gets.chomp}. \"\n  name = []\n  while !end\n    puts \"Please\
    \ enter a name: #{gets.chomp}. \"\n    name << gets.chomp.to_i\n  end\n  puts\
    \ \"Your name is #{name}\"\nend\n</code>\nThis just runs a while loop until you\
    \ enter an invalid name, but once you enter a name, you reset the array of names\
    \ to the new name.\nI changed the loop to this:\n<code>\nuntil name.empty?\n \
    \ puts \"Enter your next name: #{gets.chomp}. \"\n  name = []\n  until name.empty?\n\
    \    puts \"Please enter a name: #{gets.chomp}. \"\n    name << gets.chomp.to_i\n\
    \  end\n  puts \"Your name is #{name}\"\nend\n</code>\nAfter doing that, I get\
    \ this result:\n<code>\nEnter your next name: bobby. \nPlease enter a name: bobby.\
    \ \nYour name is [4, 5]", "  lst.map! { |n| n.to_i }\n  odd_nums = []\n  odd_nums.fill(0)\n\
    \  lst.each do |n|\n    odd_nums.map! { |i| i+=1 if n[i].to_i%2 != 0 }\n  end\n\
    \  odd_nums\nend", "  even = lst.select { |s| s.chars.map(&:to_i).all? { |n| n\
    \ % 2 != 0 } }\n  odd = lst.select { |s| s.chars.map(&:to_i).all? { |n| n % 2\
    \ == 0 } }\n  even.zip(odd).map { |e| e[0].length.to_s + \" number of odd elements\"\
    \ +\n                             e[1].to_s.reverse.tr('1',\"8\").length }\nend",
  "  return lst.map {|s| s.gsub(/\\d/){|i| i.to_s.scan(/\\d/).size.odd?}}\nend\n</code>\n\
    <|/ a |>\n<| c |>\nWhat does the scan method do?  Is that a ruby method or is\
    \ it a regex method?  I'm not familiar with regex at all.\n<|/ c |>\n<| c |>\n\
    Scan converts one string to another string. The method scan will find all digits\
    \ in the string, and count the number of odd numbers in it.\n<|/ c |>\n<| a tags=ruby,regex\
    \ |>\nAnother solution:\n<code>", "  odd_sum = []\n  sum = 0\n  for i in lst\n\
    \    sum += i.to_i\n    odd_sum << sum if sum % 2 == 0\n    sum = 0\n  end\n \
    \ odd_sum\nend", "    odd_counter={}\n    odd_counter['0']=0\n    odd_counter['1']=lst[0].count('1')\n\
    \    odd_counter['2']=lst[0].count('2')\n    odd_counter['3']=lst[0].count('3')\n\
    \    odd_counter['4']=lst[0].count('4')\n    odd_counter['5']=lst[0].count('5')\n\
    \    odd_counter['6']=lst[0].count('6')\n    odd_counter['7']=lst[0].count('7')\n\
    \    odd_counter['8']=lst[0].count('8')\n    odd_counter['9']=lst[0].count('9')\n\
    \    odd_counter['10']=lst[0].count('0')\n    odd_counter['11']=lst[1].count('1')\n\
    \    odd_counter['12']=lst[1].count('2')\n    odd_counter['13']=lst[1].count('3')\n\
    \    odd_counter['14']=lst[1].count('4')\n    odd_counter['15']=lst[1].count('5')\n\
    \    odd_counter['16']=lst[1].count('6')\n    odd_counter['17']=lst[1].count('7')\n\
    \    odd_counter['18']=lst[1].count('8')\n    odd_counter['19']=lst[1].count('9')\n\
    \    odd_counter['20']=lst[1].count('0')\n    odd_counter['21']=lst[2].count('1')\n\
    \    odd_counter['22']=lst[2].count('2')\n    odd_counter['23']=lst[2].count('3')\n\
    \    odd_counter['24']=lst[2].count('4')\n    odd_counter['25']=lst[2].count('5')\n\
    \    odd_counter['26']=lst[2].count('6')\n    odd_counter['27']=lst[2].count('7')\n\
    \    odd_counter['28']=lst[2].count('8')\n    odd_counter['29']=lst[2].count('9')\n\
    \    odd_counter['30']=lst[2].count('0')\n    odd_counter['31']=lst[3].count('1')\n\
    \    odd_counter['32']=lst[3].count('2')\n    odd_counter['33']=lst[3].count('3')\n\
    \    odd_counter['34']=lst[3].count('4')\n    odd_counter['35']=lst[3].count('5')\n\
    \    odd_counter['36']=lst[3].count('6')\n    odd_counter['", "    counts = []\n\
    \    odd_count = 0\n    for l in lst\n        odd_count = odd_count + odd?(l):0\n\
    \        counts.push(odd_count)\n    end\n    return counts\nend", "  output =\
    \ []\n  lst.each do |n|\n    n = n.to_s\n    length = n.size\n    odd_number =\
    \ 0\n    (length-2).downto(0) do |index|\n      oddness = (n[index].to_i * 2)\
    \ + 1\n      odd_number = odd_number + oddness\n    end\n    output << ([odd_number].to_s\
    \ + \" odd digit(s) in \" + n.to_s)\n  end\n  return output\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| a tags=ruby dscore=0 |>\nThis is another way to implement\
    \ this problem and I believe it might be faster than the others, as it just iterates\
    \ over the array and counts the odd numbers.\n<code>", "    odd_counts = []\n\
    \    odd_counts_index = 0\n    digit_count = 0\n    for element in lst\n     \
    \   digit_count += 1\n        if digit_count % 2 != 0\n            odd_counts_index\
    \ += 1\n            odd_counts.append(element)\n    odd_counts = odd_counts[0..odd_counts_index-1]\n\
    \    return odd_counts\n</cell>\n<cell>", "  odd_count = [0]*(2**(lst.count('0')\
    \ + lst.count('1') + lst.count('9'))-1)\n  lst.each do |str|\n    str.to_s.split('').each\
    \ do |c|\n      if c.to_i.odd?\n        odd_count[c.to_i] = odd_count[c.to_i]\
    \ + 1\n      end\n    end\n  end\n  return odd_count.collect {|k, v| v.to_s}\n\
    end", "  count = []\n  for i in lst\n    count.push(odd_count([i]))\n  end\n \
    \ count.push(lst.inject(:+))\n  return count.join(\"\\n\")\nend", "  output =\
    \ []\n  lst.each { |element|\n    element = element.to_s.tr('0123456789','').to_i\n\
    \    if element%2 != 0\n      output << \"the number of odd elements #{element}\
    \ of the str#{element} \" \\\n               \"of the input\"\n    end\n  }\n\
    \  output\nend", "  odd_count = 0\n  strings = lst.map {|str| str.to_s.split(//).map\
    \ {|digit| digit.to_i}}.flatten\n  odd_string = strings.select {|str| str.odd?\
    \ }\n  odd_string.each {|str| odd_count += 1}\n  odd_count\nend", "  lst.map {\
    \ |e| e.to_s.split('').select(&:odd?).size }\nend", "  result = []\n  for i in\
    \ lst\n    result.push odd_count(i) \n  result.push \"the number of odd elements\
    \ #{num} of the #{num}nput.\" \n  result\nend", "  counts = Hash.new(0)\n  for\
    \ i in lst\n    counts[i.to_i] += 1\n  return counts\n</code>\nAs for your problem,\
    \ I think this can work out:\n<code>", "  lst.map do |x|\n    x.chars.map {|char|\
    \ char =~ /\\d/ ? char.count(\"1\") : char.count(\"0\") }.sum\n  end\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails dscore=0 |>\n<| c |>\nWhile this code may answer\
    \ the question, it would be better to explain what it does and how it does it.\n\
    <|/ c |>\n<| a |>\nJust for fun, here is a one-line method that will do what you\
    \ want for both positive and negative numbers:\n<code>", "  lst\n  .map!{|x| x.to_i}\n\
    \  .compact\n  .map!{|x| x % 2}\n  .map!{|x| [x, list.count(x)]}\n  .map!{|x,\
    \ y| [y, x]}\n  .map!{|x, y| [x, y]}\n  .sort\n  .map!{|x| x[0]}\nend\n</code>\n\
    And here is how to get the desired output:\n<code>\nodd_count([\"1234567\", \"\
    3\", \"11111111\"])", "  return lst.map{|x| x.count('0')}.inject(:+)\nend", " \
    \ lst.map do |str|\n    str.split(//).map { |n| n % 2 == 0 ? n.to_i : 0 }.length\n\
    \  end.join(\", \") + \".\"\nend", "  str = \"\"\n  odd_elements = []\n  for i\
    \ in lst\n    str = str + i\n    odd_elements.push(str.scan(/\\d*[13579]\\d*/).length)\n\
    \  end\n  return odd_elements\nend", "  if lst.empty?\n    []\n  elsif lst.size\
    \ == 1\n    [ lst.count { |x| x % 2 == 1 } ]\n  else\n    lst[0] = lst.size +\
    \ \"n \" + odd_count(lst.drop(1)).join(\" 1n \")\n  end\nend", "  lst.map do |s|\n\
    \    s.length\n  end\nend\n</code></pre>\n<pre><code class=\"ruby\"># Given a\
    \ list of strings, where each string consists of only digits, return a list.",
  "    odd_sum = 0\n    odd_digits = []\n    input_nums = lst\n    for num in input_nums\n\
    \        odd_digits.push(num.split(//).map(&:to_i).map(&:odd?).count)\n    end",
  "  # Your code goes here\n  lst.each {|el| puts el.scan(/\\d/).inject(0){|sum, el|\
    \ sum + el.count('d')}}\nend", "  lst.map do |str|\n    str.to_s.chars.map(&:odd).map(&:to_i).inject(:+).to_s\n\
    \  end\nend\n</code>\nAnd here's my recursive version\n<code>", "    odd_sum =\
    \ 0\n    for i in lst\n        odd_sum += i.count('o')\n    end\n    odd_count.empty??\
    \ [] : [odd_sum.to_s]\nend", "  lst.each do |s|\n    puts \"the number of odd\
    \ elements #{s.count('1')} \" \\\n      \"the str#{s.length}th #{s.length} of\
    \ the #{s.length}\" \\\n      \"input\"\n  end\nend", "  count = 0\n  list.each\
    \ do |elem|\n    elem.to_s.chars.each do |char|\n      if char.to_i.odd?\n   \
    \     count += 1\n      end\n    end\n  end\n  return count\nend", "  ret = []\n\
    \  l = lst.length\n  (1..l).each do |i|\n    l = lst[i].length\n    ret.push l\
    \ / 2.to_s * \"the number of odd elements \" + l * \"n the str\" + l * \"g \"\
    \ + l\n  end\n  ret\nend", "  lst.inject([]){|a,e| a << [e.size+a[0]] if e.chars.all?{|c|\
    \ c =~ /^\\d$/}}.map(&:join)\nend", "  lst.each_with_index { |el, idx| lst[idx]\
    \ = lst.select { |el2| el2 =~ /\\d/ }.size }\nend\n</code>\nAnd of course you\
    \ can use the built-in method count for the same results, but that doesn't work\
    \ because it counts how many times an item appears in the array instead of how\
    \ many times it occurs in an element.\n<code>", "    odd_count = 0\n    for i\
    \ in lst\n        odd_count += i.to_s.split(//).map(&:to_i).reduce(:+)\n    puts\
    \ \"the number of odd elements is #{odd_count}\"\nend\n</code>\n<|/ a |>\n<| a\
    \ dscore=1 |>\nThis is a very old question, and I see lots of answers with loops\
    \ but I think the most efficient way would be to use a hash to count the occurrences\
    \ of every digit.\n<code>", "  lst.inject([0,]) do |acc, elem|\n    acc[0] +=\
    \ 1\n    if elem.is_a?(String)\n      acc[1] += elem.split(//).count{ |e| e.odd?\
    \ }\n    else\n      acc[1] += elem.to_s.split(//).count{ |e| e.odd? }\n    end\n\
    \    acc\n  end\nend", "  lst.map!{|x| x.chars.map(&:to_i).reduce(&:*)}\n  lst.select!{|x|\
    \ x.to_i.odd?}\nend", "  lst.each{|s| s.split(//).each{|e| odd_count e}}\n  lst.count{|s|\
    \ s.split(//).count{|e| e.odd?}}\nend", "    odd = Array.new\n    count = []\n\
    \    count = 0\n    arr.each do |el|\n      odd.push(el[/\\d/].length)\n    end\n\
    \    odd.each do |el|\n      if arr.index(el) != arr.length-1\n        count.push(count+1+1)\n\
    \      else\n        count.push(count+1)\n      end\n    end\n    return count\n\
    end\n</code>\n<|/ a tags=ruby,count,string |>\n<| a tags=ruby,count,string |>\n\
    I came up with this solution:\n<code>", "  odd = lst.select { |x| x =~ /^\\d{0,9}$/}.count\n\
    \  lst.map { |x| \"the number of odd elements #{odd} the str#{x.count}# of the\
    \ #{x}#\" }\nend", "  lst.map {|s| s.to_i}.inject(:+).to_s\nend", "  return lst.map\
    \ do |str|\n    [(0 ... str.count).map do |i|\n      \"the number of odd elements\"\
    \ + (str.count-i)*\"#{str[0...i]}\" + (str.length-i)*\"#{str[str.length-i..-1]}\"\
    \n    end.join(\",\")]\n  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    I got down-votes but no comment as to why. I suspect this answer will get down-voted\
    \ because it's unreadable, and because it's not an answer (at least not to the\
    \ question asked) but more of a code-golf challenge. I've added some comments\
    \ to improve your answer.\n<|/ c |>\n<| c |>\nI appreciate that, but my answer\
    \ is not an answer. This was more of a code-golf challenge and so I just posted\
    \ my answer.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>\nputs [\n  \"number of\
    \ odd elements in the str#{$_.size} of the str#{$_.size-1}\" for _[0..(arr.size-1)]\n\
    ].flatten.join ','\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\narr.map\
    \ { |s| s.gsub(/(.)(.)/, '\\1 \\2') }\n.map { |s| s.split.map(&:to_i) }\n.map\
    \ { |e| e.count(&:odd?) }\n.map(&:join(','))\n.join ','\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a |>\n<code>", "  return lst.map { |s| s.scan(/\\d/).reduce(:+) }\nend",
  "  odd_odd_count = lst.inject(Hash.new(0)){|h,x| h[x] += 1; h}\n  odd_odd_count.map\
    \ {|key,value| \"the number of odd elements #{value} of the #{key} of the input\"\
    }.join\nend", "  count = 0\n  for i in lst\n    count+=(1 if i.to_s.scan(/\\d/).length%2\
    \ == 1 else 0)\n  end\n  count\nend", "    odd_sum = 0\n    odd_lst = []\n   \
    \ for str in lst\n        odd_sum += odd?(str)\n        odd_lst.push(odd_sum)\n\
    \    odd_lst.map(&:inspect)\nend", "\toutput = []\n\todd_number = 0\n\tdigits\
    \ = lst[0].split(//)\n\tdigits_odd = []\n\tdigits_odd_count = 0\n\tfor x in digits\n\
    \t\tdigits_odd_count += x.to_i(2)\n\tfor x in digits\n\t\todd_number += x.to_i(2)\n\
    \t\tdigits_odd_count += x.to_i(2)\n\t\toutput << \"the number of odd elements\
    \ #{digits_odd_count} the str#{digits_odd_count} #{odd_number} #{odd_number} #{x}\
    \ #{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#{@char}#",
  "  odd_digits = lst.select { |s| s.match(/\\d/) }\n  odd_numbers.map { |str| odd_digits[str.to_i].size\
    \ }.join\nend", "  # Create a variable to hold the number of the odd digits.\n\
    \  odd = 0\n  # Declare a variable to hold the number of odd digits.\n  odd_count\
    \ = 0\n  # Iterate over each string in the input list.\n  for str in lst\n   \
    \ # Convert the string to a list of digits with 'str' as the argument.\n    str_list\
    \ = list(str)\n    # Iterate over each digit in the list.\n    for digit in str_list\n\
    \      # Add 1 to the odd variable if it is an odd digit.\n      if digit.to_i\
    \ % 2 != 0\n        odd += 1\n      # Otherwise, subtract 1 from the odd variable.\n\
    \      else\n        odd -= 1\n      # If odd reaches zero, add 1 to the number\
    \ of odd digits.\n      if odd == 0\n        odd_count += 1\n      # Return the\
    \ number of odd digits for the input list.\n      end\n    end\n  end\n  # Return\
    \ the number of odd digits for all input strings.\n  odd_count\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\nI ran this code, and I got the error `undefined\
    \ method to_i for \"1\":String`\n<|/ c |>\n<| c |>\n: That's because you're passing\
    \ in a string, not a digit.\n<|/ c |>\n<| c |>\nI changed the code to test the\
    \ string for digits first. I also fixed the bug pointed out in Robert's comment.\
    \ Now the code will work with strings or digits, rather than just numbers.\n<|/\
    \ c |>\n<| a tags=ruby,string |>\n<code>", "    odd_counts = []\n    lst.each_index\
    \ do |i|\n        odd_counts << i*(1..10).inject(0) do |c, digit|\n          \
    \  c += 1 if digit.to_i & 1 == 1\n            c\n        end\n    end\n    odd_counts\n\
    end", "  result = []\n  odd_digits = /\\d{2,}/\n  \n  # For each element in lst\n\
    \  lst.each do |item|\n    \n    # Add this item to the result\n    result <<\
    \ \n      \"the number of odd elements \" +\n      item.gsub(/\\d/) { |c| odd_digits.match\
    \ c }.size +\n      \" the \" + \n      item.gsub(/\\d/) { |c| odd_digits.match\
    \ c }.join(\"n\") +\n      \" of the \" +\n      item.gsub(/\\d/) { |c| odd_digits.match\
    \ c }.join(\"n\") +\n      \".\"\n  end\n  \n  # Return the result\n  result\n\
    end", "  count = 0\n  odd_count = 0\n  for i in range(len(lst))\n    odd_count\
    \ = 0 if lst[i].to_s.chomp!='0' else 1\n    count += lst[i].to_s.to_i if lst[i].to_s.to_i%2==0\
    \ else 1\n    count += odd_count if odd_count>0 else 1\n  end\n  odd_count\nend",
  "  return (lst.map {|num| num_odd_digits(num).length}).join(' ')\nend", "  lst.each\
    \ do |str|\n    str.each_char.with_index do |char, i|\n      next if char.odd?\n\
    \      str.slice!(0, i).length.to_s + \" odds.\"\n    end\n  end\nend", "  return\
    \ lst.map {|x| odd_count(x) }.flatten\nend", "  return [ \"the number of odd elements\
    \ #{str.split(\"\",1).inject(0){|n,x|n+=1 if x&1}} \" +\n           \"of the #{str.length}\
    \ of the #{str.split(\"\",1).join(\"\")}\" ] + lst.map do |x|\n    puts \"the\
    \ number of odd elements #{str.split(\"\",1).inject(0){|n,x|n+=1 if x&1}}\" +\n\
    \          \" of the #{str.length} of the #{str.split(\"\",1).join(\"\")}\" if\
    \ x.is_a?(String)\n  end\nend", "    odd_nums = 0\n    odd_num_str = \"\"\n  \
    \  for i in lst\n        odd_nums += odd_count_helper(to_num_str(i),\n       \
    \                             odd_num_str)\n        odd_num_str += to_num_str(i)\n\
    \    return odd_num_str\nend", "    number = 0\n    odd_digits = []", "  str_list\
    \ = lst.map(&:to_s).map(&:to_i)\n  evens = str_list.select {|x| x % 2 == 0}\n\
    \  odds = str_list.select {|x| x % 2 != 0}\n  return evens.product(odds).map {|x,\
    \ y| [x.count, y]}\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nNice. I think you\
    \ meant evens = str_list.select {|x| x % 2 == 0}\n  odds = str_list.select {|x|\
    \ x % 2 != 0}\n<|/ c |>\n<| c |>\nI tried to add some comments to your answer,\
    \ but apparently edits don't count as proper answers :)\n<|/ c |>\n<| a tags=ruby,string,arrays,function\
    \ |>\n<code>\n def odd_count(string)\n string.each_char.group_by(&:to_i).map do\
    \ |k,v|\n   v[0].to_i + v[1].count\n end\n end\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=ruby,string,arrays,function |>\nI suggest this solution:\n<code>", " \
    \ lst.map!(&:to_i)\n  lst.map!(&:odd?)\n  lst.inject(0, :+)\nend", "  odd_count\
    \ = Array.new\n  \n  (0..lst.count-1).each do |i|\n    odd_count.push([\n    \
    \  lst.count(i.to_s[1..-1]),\n      lst.count(i.to_s[0..-2])\n    ])\n  end\n\
    \  \n  odd_count.flatten.compact\nend", "  lst.map! {|s| s.chars.map{|c| c.to_i}.odd?.size}\n\
    \  lst\nend\n</code>\nIt could be that there are better ways to do this. I'd be\
    \ curious to see others' solutions. \nHere it is in Python:\n<code>", "  if lst.empty?\n\
    \    []\n  else\n    odd_counts = []\n    odd_count = 0\n    sum = 0\n    digit\
    \ = lst.first\n    sum = 0\n    while digit?\n      sum += digit.to_i\n      if\
    \ sum % 2 != 0\n        odd_count += 1\n      end\n      odd_counts << odd_count\n\
    \      digit = digit.next\n    end\n    odd_counts << odd_count\n    odd_counts.flatten\n\
    \  end\nend", "  even = lst.select {|x| x.to_s.chars.all? {|c| c =~ /\\d/}}\n\
    \  odd = lst.select {|x| x.to_s.chars.all? {|c| c !~ /\\d/}}\n  even.map {|x|\
    \ x.to_s.chars.size }.zip(odd.map {|x| x.to_s.chars.size }).to_a\nend", "  # Add\
    \ your code here\n  return []\nend", "  lst.map! {|i| i.to_s.each_char.map {|x|\
    \ x.to_i}.to_a}.flatten\n  lst.map! {|x| x.each_cons(2).map(&:length).reduce(:+)}.flatten\n\
    end\n</code>\n<|/ a tags=ruby,string,loops dscore=1 |>\n<| c |>\nI understand\
    \ how to do it without map, but I'm trying to practice loops and reduce, etc.\
    \ Thanks though!\n<|/ c |>\n<| a tags=ruby,string,loops |>\n<code>", "  count\
    \ = 0\n  str_list = lst.map { |x| x.to_s }\n  str_list.each { |x|\n    x.each_char\
    \ { |y| y += 1 if y % 2 == 1 }\n    count += 1\n  }\n  return [\"the number of\
    \ odd elements #{count} the str#{count} #{count.to_s.length}#{\" characters\"\
    \ if count == 1!s} of the #{count}nput.\"]\nend", "  # +++your code here+++\n\
    end\n</cell>\n<cell>", "  strs = lst.map { |s| s.to_s }\n  strs.map { |s| s.split(\"\
    \").reduce(0) { |acc, digit| digit.to_i%2 == 0 ? acc += 1 : acc } }\nend", " \
    \ lst.map! {|s| s.split(\"\").map(&:to_i).reject(&:odd?).size}\nend", "  lst.map\
    \ { |x| x.to_s.chars.map(&:odd? ? 1 : 0).sum }\nend", "  return lst.map {|s| s.count(\"\
    9\") + s.count(\"8\") + s.count(\"7\") + s.count(\"6\") + s.count(\"5\") + s.count(\"\
    4\") + s.count(\"3\") + s.count(\"2\") + s.count(\"1\") + s.count(\"0\") }\nend",
  "  lst.map do |str|\n    str.split(//).map do |char|\n      char.odd? ? 1 : 0\n\
    \    end.reduce(:+)\n  end.join(\",\")\nend", "  lst.map!{|i| i.to_s.split(\"\"\
    ).map(&:odd?).count}\n  lst.map!{|i| i.to_s.split(\"\").map(&:to_i).reduce(:+)\
    \ }\nend\n</cell>\n<text>\nQuestion 10\nWrite a method that takes in a list and\
    \ returns a sorted version of that list.\nUse an ordered dictionary to store your\
    \ input strings. The keys should be the sorted version of your input strings.\
    \ If the value of the key already exists in the ordered dictionary, add the new\
    \ value to the value of the key. Otherwise, add the new value to the end of the\
    \ value of the key. \nThe value of the key should be the length of the string.\n\
    Your method should then return a hash object.", "  lst.map { |n| n.to_s.chars.each_with_index.sum\
    \ { |n, i| i % 2 == 1 } }\nend\n</code>\n<code>", "  lst.map!{ |i| i.to_s.chars.map(&:to_i).sum\
    \ } if lst.is_a?(Array)\n  lst.map { |i| i.to_s.chars.map(&:to_i).sum }.inject([[],[]]){|accu,el|\
    \ accu[1].concat([el if el % 2 == 1]); accu[0].concat([el])}\nend\n</code>\n<|/\
    \ a |>\n<| a |>\nHere's another solution. \n<code>", "  lst.map { |e| e.to_s.scan(/\\\
    d+/).inject(0) { |sum, digit| sum + digit if digit.to_i % 2 == 1 } }\nend\n</code>\n\
    <|/ a tags=ruby,string dscore=1 |>\n<| c |>\nYou could also use `scan(/\\d+/)`.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  lst.each_with_index.reduce(0) do |sum,\
    \ (word, index)|\n    sum + 1 if !word[/(\\d)\\1{3}/].nil?\n  end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nWhy `!word[/(\\d)\\1{3}/].nil?` instead of `!word[/(\\\
    d)\\1{3}/]`?\n<|/ c |>\n<| c |>\nGood point.  I thought it would be faster to\
    \ just check and see if it returned false.  Not sure if it makes a difference\
    \ though.\n<|/ c |>\n<| c |>\nThe difference should be negligible.\n<|/ c |>\n\
    <| c |>\n\"The difference should be negligible.\" No, it's not. Ruby's regexes\
    \ are implemented in the way they are meant to be. `!word[/(\\d)\\1{3}/]` makes\
    \ the code less readable. `!word[/(\\d)\\1{3}/].nil?` is fine and more readable,\
    \ even though `!word[/(\\d)\\1{3}/]` is shorter and more efficient.\n<|/ c |>\n\
    <| a tags=ruby |>\nThis is a variant of the answer from and\n<code>", "  odd_counts\
    \ = []\n  lst.each do |elem|\n    # split the string by single digit strings\n\
    \    str_arr = elem.split\n    str_arr.each do |str|\n      odd_counts << str_arr.count(str)\
    \ % 2 \n    end\n  end\n  return odd_counts\nend\n</code>\nAnd here is the output\
    \ that I get:\n<code>\nirb(main):028:0> odd_count(['1234567'])\n=> [\"the number\
    \ of odd elements 4n the str4ng 4 of the 4nput.\"]\nirb(main):029:0> odd_count(['3',\"\
    11111111\"])\n=> [\"the number of odd elements 1n the str1ng 1 of the 1nput.\"\
    ,\n \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\nirb(main):030:0>\
    \ odd_count([\"abc\", \"defg\"])\n=> [\"the number of odd elements 2n the str2ng\
    \ 2 of the 2nput.\",\n \"the number of odd elements 8n the str8ng 8 of the 8nput.\"\
    ]\nirb(main):031:0> odd_count([\"3\", \"11111111\"])\n=> [\"the number of odd\
    \ elements 1n the str1ng 1 of the 1nput.\",\n \"the number of odd elements 8n\
    \ the str8ng 8 of the 8nput.\"]\nirb(main):032:0> odd_count(['abc', 'defg'])\n\
    => [\"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n \"the number\
    \ of odd elements 8n the str8ng 8 of the 8nput.\"]\nirb(main):033:0> odd_count(['1111111',\
    \ '3333333'])\n=> [\"the number of odd elements 1n the str1ng 1 of the 1nput.\"\
    ,\n \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n</code>\n<|/\
    \ a dscore=3 tags=ruby |>\n<| c |>\nThank you, I had the same idea. I think the\
    \ problem is that OP wants *multiple* elements counted each time, e.g. `['ab',\
    \ 'abc', 'ab']` should return `[4, 2, 8]`.\n<|/ c |>\n<| c |>\nThanks for the\
    \ answer! But how do I output the answer?\n<|/ c |>\n<| c |>\nI'm having trouble\
    \ finding a way to output the answer. I tried using `puts odd_count(list)`, but\
    \ that did not work.\n<|/ c |>\n<|", "  sum = 0\n  odd_count = 0\n  for i in lst\
    \ \n    if i.to_s.length % 2\n      sum += i.to_s.length\n      odd_count += 1\n\
    \    end\n  end\n  result = []\n  sum.to_s.length.times do |i|\n    result <<\
    \ (sum.to_s.chars.each_cons(i).reduce(0) { |s, c| s + c.to_s.length }.to_s)\n\
    \    sum += sum.to_s.length\n  end\n  result << odd_count.to_s\nend", "  result\
    \ = Array.new(lst.size, \"\")\n  lst.each do |i|\n    result.each do |j|\n   \
    \   result[j] = result[j] + 1 if j != i.to_i\n    end\n  end\n  result.each_with_index\
    \ do |i, index|\n    result[index] = result[index].to_s + \" odd the str#{index\
    \ + 1} of #{i + 1}.\" \n  end\n  result\nend", "  if lst.is_a? String\n    lst\
    \ = lst.split(\"\")\n  else\n    lst = lst.to_a\n  end\n  lst.map {|e| e.to_i.odd?\
    \ ? 1 : 0}\nend", "  return lst.inject([]) do |odd_count, digit|\n    if digit.match?(/\\\
    d/)\n      odd_count << digit.length if digit.to_i & 1 == 1\n      odd_count\n\
    \    else\n      []\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays dscore=0\
    \ |>\n<| c |>\nIt would be better to explain what is wrong with OPs code and how\
    \ your answer fixes it. It's not just about \"giving a fish\" but also \"teaching\
    \ fishing\".\n<|/ c |>\n<| c |>\nThank you. Your answer is correct, but as you\
    \ and others have pointed out, this is better suited as a comment. My apologies.\n\
    <|/ c |>\n<| c |>\n, no apologies required. Slowly moving my comment to answer,\
    \ with some explanation.\n<|/ c |>\n<| c |>\n: I see your point. By the way, this\
    \ isn't a fishing game. It's about teaching fishing.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\nYour code will generate an error if your string has more than one digit.\n\
    <code>", "  lst.map! {|x| x.to_i}\n  lst.inject([]) do |acc, i|\n    n = i.to_s.length\n\
    \    acc << acc << (n % 2 == 1 ? \"#{n}n\" : n/2)\n  end\nend", "    lst = lst.to_a\
    \ if lst.kind_of? Array else lst\n    count = 0\n    lst.each do |s|\n       \
    \ count += s.to_i.odd? ? 1 : 0\n    end\n    count = count.to_s\n    count.gsub!(/[^\\\
    d]/,\"\") if count !~ /^\\d+$/\n    count\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis was my first thought too, but I thought it would be tricky\
    \ to get this right.\n<|/ c |>\n<| c |>\nI agree. After I posted this I thought\
    \ about it some more and it seemed more fun to figure this out on my own.\n<|/\
    \ c |>\n<| c |>\nIf you're really interested, I did it in C: http://pastebin.com/UvY0cNkJ\n\
    <|/ c |>\n<| c |>\n- thanks a lot! It was fun to figure out.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  lst.map!{|s| s.split(//).map {|c| c.to_i}.select {|x| x % 2\
    \ == 1}.count}\n  return lst.map {|s| s.to_s.ljust(15, \"0\")}\nend", "  result\
    \ = lst\n  for number in result\n    result.delete_if { |x| x.to_i.odd? }\n  end\n\
    \  return result\nend\n</code>\n<|/ a |>\n<| a tags=ruby,string,arrays |>\nHow\
    \ about just using a regular expression:\n<code>", "  lst.map!{|i| i.to_s.length.odd?\
    \ ? i.to_s.length.to_s + \" odd digits in \" + i : nil }\n  lst.compact!\n  lst\n\
    end", "  lst.each do |n|\n    return [n] unless n.to_s.gsub!(/[^\\d]/,'')\n  \
    \  n.to_s.split('').count(\"o\").to_s\n  end\nend", "  even = lst.select { |i|\
    \ i.to_s.match(/^\\d+$/) }\n  odd_counts = even.map { |i| i.to_s.split(//).map\
    \ { |s| s.count('o') } }\n  odd_counts.flatten.map { |i| i.to_s }\nend", "  #\
    \ Your code here\n  return lst\nend", "  count = [0] * 10\n  for i in lst\n  \
    \  count[i.to_s.length.to_i] +=1\n    count.reduce(&:+)\n  end\n  return count.map\
    \ { |n| [ \"the number of odd elements #{n} the str#{n} of the #{n}\" ] }\nend",
  "  lst.map{|s| s.chars.each_with_index.inject(0){|i, (c, i)| i + (c=='1'?1:0)}}\n\
    end", "  lst.map do |s|\n    count = s.to_s.reverse.scan(/\\d+/).map { |n| n.to_i\
    \ }.inject(:+)\n    [s,\"the number of odd elements #{count} the #{s} of the #{s}.\"\
    ]\n  end\nend", "  lst.each do |str|\n    str.gsub(/\\d/){|s| s.to_i(2)}.inject(:+).to_s.gsub(/(\\\
    d)\\1+/, '\\1')\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby,regex\
    \ |>\nUsing negative lookahead assertions (?!...) in a regex is a common method\
    \ of solving this problem.\nIn ruby:\n<code>\n\"1234567\".gsub(/(?!\\d)\\1+/,\
    \ '').to_s\n</code>\nThis replaces any group of characters that does not contain\
    \ another character (\\d matches a digit) and repeats the group one or more times\
    \ (\\1+), until there are no more repeats left.\n<|/ a dscore=3 |>\n<| a |>\n\
    Here's another way:\n<code>\n\"1234567\".gsub(/(.)\\1*/){|m| m.length}.to_s",
  "  strs = lst.map { |s| s.to_s.split('').inject(:*) }\n  strs.reject { |n| n.to_s.size\
    \ == 1 }\nend", "  lst.each_with_index do |s, i|\n    # print i, \"#{s[:digits]}\
    \ #{s[:digits]}\"\n    if s[:digits] == '0'\n      odd_count = lst[0].each_with_index\
    \ do |word, j|\n        # print \"j #{j} j #{j}\"\n        odd_count = word if\
    \ j % 2 == 1\n        odd_count = word if j % 2 != 1\n      end\n      # print\
    \ \"odd_count #{odd_count} odd_count #{odd_count}\"\n      lst[i] = \"the number\
    \ of odd digits #{odd_count}\"\n    end\n  end\n  lst\nend", "  return [\n   \
    \ \"the number of odd elements \" + count_odd(lst[i]) +\n    \" in the string\
    \ \" + str(i) + \" of the input.\" for\n    i = 0...lst.size - 1\n  ]\nend", " \
    \ odd_count = 0\n  lst.each do |i|\n    odd_count += i.chars.select {|c| c.to_i.odd?}.size\n\
    \  end\n  return [odd_count.to_s]\nend", "  return [ \"the number of odd elements\
    \ #{n} the str#{n} #{n} of the #{n}n.\"\\\n           % n\n         for n in lst.map\
    \ { |s| s.chars.map(&:to_i).count(&:odd?) } ]\nend", "  strs = []\n  nums = []\n\
    \  lst.each do |s|\n    num = s.length\n    num = num.to_i\n    strs << s\n  \
    \  nums << num\n  end\n  strs.each do |s|\n    i = -1\n    num = nums[strs.index(s)].to_i\n\
    \    num.times do\n      i +=1\n      nums[i] += 1\n    end\n    puts strs[strs.index(s)]\
    \ + \"n the str\" + num.to_s + \" of the \" + s.to_s\n  end\nend\n</code>\nAnd\
    \ finally, one more approach using your code.\n<code>", "  odd_count = 0\n  index\
    \ = 0\n  while index < lst.size\n    digit = lst[index]\n    next_index = index\
    \ + 1\n    next_digit = lst[next_index]\n    if next_digit.empty?\n      odd_count\
    \ += digit.to_i\n    elsif next_digit.odd?\n      odd_count += 1\n    end\n  \
    \  index += 1\n  end\n  return[odd_count.to_s]\nend", "  odd_digits = lst.map\
    \ { |digit| digit.to_s.length % 2 }\n  odd_digits.inject([]) do |sum, digit|\n\
    \    if digit\n      sum + odd_digits[digit-1]\n    else\n      sum\n    end\n\
    \  end\nend", "  lst.map!{|s| s.split(\"\").map{|c| c==\"1\" && c!=\"9\" ? 1 :\
    \ 0}.reduce(:+)}\n  lst.map!{|s| s.split(\"\").map{|c| c==\"9\" && c!=\"1\" ?\
    \ 1 : 0}.reduce(:+)}\n  lst.map!{|s| s.split(\"\").map{|c| c==\"1\" || c==\"9\"\
    \ ? 1 : 0}.reduce(:+)}\nend", "  lst.map!{|e| e[/\\d+/].to_i if e.is_a?(String)}\
    \ if lst.is_a?(Array) \n  lst.map!{|e| e.to_i if e.is_a?(String)}\n  lst.map!{|e|\
    \ (e%2 == 0? e.length : nil)}.compact\n  lst.map { |e| e*1 }.join\nend\n</code>\n\
    <|/ a |>\n<| c |>\nNice use of `map!`\n<|/ c |>\n<| c |>\nI wonder if this is\
    \ a good use of `map!`. `map!` modifies the original array as it's called on it.\
    \ Wouldn't this make it mutate your input array as well?\n<|/ c |>\n<| c |>\n\
    That's what I thought, but didn't test it before I posted it. But I think it will.\
    \ So it is! :)\n<|/ c |>\n<| c |>\n: I see your point now. That's why I said I\
    \ didn't test it before posting it, but I'm pretty sure it mutates the original\
    \ array as well (I tested it by changing my input). So it does mutate input as\
    \ well as returning a new array.\n<|/ c |>\n<| a tags=string,ruby,arrays,count\
    \ |>\n<code>", "    odd_digits = []\n    for n in lst\n        if n.to_i.odd?\n\
    \            odd_digits << n.to_i\n        else\n            odd_digits << n\n\
    \        end\n    end\n    odd_digits\nend", "    odd_lst = lst.map { |str| str.each_char.map\
    \ { |c| c.to_i.odd? ? 1 : 0 } }\n    odd_lst.flatten.compact.map { |num| sprintf(\"\
    the number of odd elements %n the %n of the %nput.\", num * -1, num) }\nend",
  "  result = []\n  odd = (0 .. lst.length).find_all {|i| (lst[i] =~ /\\d/)}\n  (0..lst.length-1).each\
    \ {|i| result << odd.size}\n  result\nend", "  lst.each do |s|\n    s.chars.each\
    \ do |char|\n      char.to_i(2)\n    end\n  end\nend", "  lst.map do |s|\n   \
    \ s.split('').map do |i|\n      if i.to_i.odd?\n        i.to_i.to_s.length\n \
    \     else\n        \"#{i.to_i}n\"\n      end\n    end.join(' ')\n  end\nend",
  "  odd_count = []\n  odd_count.push \"the number of odd elements #{lst[0].count(\"\
    1\")} of the #{lst[0].count(\"1\")} of the #{lst[0].count(\"1\")}\"\n  odd_count.push\
    \ \"the number of odd elements #{lst[0].count(\"8\")} of the #{lst[0].count(\"\
    8\")} of the #{lst[0].count(\"8\")}\"\n  odd_count\nend", "  counts = []\n  odd_digits\
    \ = 0\n  lst.each do |num|\n    count = []\n    digits = num.to_s.reverse.split(//).map{|s|\
    \ s.to_i}\n    digits.each do |digit|\n      odd_digits += 1 if digit % 2 == 1\n\
    \      count << digit if digit % 2 == 0\n    end\n    counts << count.join(' ').to_s\
    \ if count.any?\n  end\n  counts\nend", "  output = []\n  for i in lst\n    if\
    \ i.to_s.size == 1\n      output[0] << \"the number of odd elements #{\"%i\" %\
    \ i.to_s.size }n the str#{\"%i\" % i.to_s.size}ng #{\"%i\" % i.to_s.size }# of\
    \ the #{\"%i\" % i.to_s.size}nput.\\n\"\n      output[1] << \"the number of odd\
    \ elements #{\"%i\" % i.to_s.size }n the str#{\"%i\" % i.to_s.size}ng #{\"%i\"\
    \ % i.to_s.size }# of the #{\"%i\" % i.to_s.size}nput.\\n\"\n    else\n      odd_digit\
    \ = i.to_s.size - 1\n      output[0] << \"the number of odd elements #{\"%i\"\
    \ % i.to_s.size }n the str#{\"%i\" % i.to_s.size}ng #{\"%i\" % i.to_s.size }#\
    \ of the #{\"%i\" % i.to_s.size}nput.\\n\"\n      output[1] << \"the number of\
    \ odd elements #{\"%i\" % odd_digit }n the str#{\"%i\" % odd_digit}ng #{\"%i\"\
    \ % odd_digit }# of the #{\"%i\" % i.to_s.size}nput.\\n\"\n    end\n  end\nend",
  "  odd_strings = []\n  lst.each do |string|\n    odd_string = []\n    string.split('').each\
    \ do |digit|\n      if digit.to_i.odd?\n        odd_string << digit.to_i\n   \
    \   end\n    end\n    odd_strings << odd_string.join(' ') unless odd_string.blank?\n\
    \  end\n  return odd_strings\nend", "  lst.map! { |i| i.chars.to_a.join.count(i.chars.to_a)\
    \ }\n  lst.map! { |i| i.chars.to_a.join.count(i.chars.to_a) }\n  lst.map! { |i|\
    \ i.chars.to_a.join.count(i.chars.to_a) }\n  lst.map! { |i| i.chars.to_a.join.count(i.chars.to_a)\
    \ }\n  lst.map! { |i| i.chars.to_a.join.count(i.chars.to_a) }\n  lst.map! { |i|\
    \ i.chars.to_a.join.count(i.chars.to_a) }\n  lst.map! { |i| i.chars.to_a.join.count(i.chars.to_a)\
    \ }\n  lst.map! { |i| i.chars.to_a.join.count(i.chars.to_a) }\n  lst.map! { |i|\
    \ i.chars.to_a.join.count(i.chars.to_a) }\n  lst.map! { |i| i.chars.to_a.join.count(i.chars.to_a)\
    \ }\n  lst.map! { |i| i.chars.to_a.join.count(i.chars.to_a) }\n  lst.map! { |i|\
    \ i.chars.to_a.join.count(i.chars.to_a) }\n  lst.map! { |i| i.chars.to_a.join.count(i.chars.to_a)\
    \ }\n  lst.map! { |i| i.chars.to_a.join.count(i.chars.to_a) }\n  lst.map! { |i|\
    \ i.chars.to_a.join.count(i.chars.to_a) }\n  lst.map! { |i| i.chars.to_a.join.count(i.chars.to_a)\
    \ }\n  lst.map! { |i| i.chars.to_a.join.count(i.chars.to_a) }\n  lst.map! { |i|\
    \ i.chars.to_a.join.count(i.chars.to_a) }\n  lst.map! { |i| i.chars.to_a.join.count(i.chars.to_a)\
    \ }\n  lst.map! { |i| i.chars.to_a.join.count(i.chars.to_a) }\n  lst.map! { |i|\
    \ i.chars.", "  count_str = lambda s: s.split('').map { |s| s.to_i }.select {\
    \ |e| e % 2 == 1 }.count\n  lst.reverse.map { |s| count_str(s) }.unshift(:all)\n\
    end", "  lst.each do |s|\n    count = (s.length**2 - s.length).to_i\n    s.split(\"\
    \").inject(0) do |m, x|\n      m+=1 if x.to_i%2==1\n      m+=count if x.to_i%2==0\n\
    \    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a |>\n<code>", " \
    \ return [ \"the number of odd elements #{lst.count(digit)}n the str#{lst.count(digit)}\
    \ #{digit}#{lst.count(digit)} of the #{lst.count(digit)}nput.\" for digit in lst\
    \ ]\nend", "  lst.map!(&:to_i)\n  lst.map!(&:to_s)\n  lst.map do |x|\n    if x.odd?\n\
    \      puts \"the number of odd elements #{x.length} the str#{x.length} of #{x}\"\
    \n    else\n      x\n    end\n  end\nend", "  str.split(/,/).map { |str| str.split(//)\
    \ }.inject( [] ) do |res,str|\n    res << ( str.map { |s| s.to_i }.count { |i|\
    \ i & 1 } ).to_s\n  end\nend", "  \nend", "  counts = Hash.new(0)\n  lst = lst.map{|s|\
    \ s.to_i}\n  lst.each {|i| counts.merge!({i => counts[i]+1})}\n  counts.reject!{|k,\
    \ v| v % 2}.map{|k, v| [k, v]}.to_a\nend", "  lst.map! do |x|\n    x.to_s.scan(/\\\
    d+/).count\n  end\n  lst.map! do |x|\n    if x.is_a?(String)\n      x.to_s.scan(/\\\
    d+/).map(&:to_i).count\n    else\n      x\n    end\n  end\n  lst.map do |x|\n\
    \    if x.is_a?(String)\n      x.to_s.scan(/\\d+/).map(&:odd?).count\n    else\n\
    \      x\n    end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n\
    Here is another take using Enumerable#each_char and Enumerable#inject.\n<code>",
  "  count_odd_in_list(lst, 0)\nend", "  counts = Hash.new(0)\n  counts[:odd_digits]\
    \ = Hash.new(0)\n  for i in lst\n    counts[:odd_digits][odd_digits(i)] += 1\n\
    \  end\n  counts[:odd_digits].values.collect{|v| v.join(' ')}\nend", "  lst.map!\
    \ {|x| x.count(\"0\")}\n  lst.map! {|x| x.count(\"1\")}\n  lst.map! {|x| x.count(\"\
    2\")}\n  lst.map! {|x| x.count(\"3\")}\n  lst.map! {|x| x.count(\"4\")}\n  lst.map!\
    \ {|x| x.count(\"5\")}\n  lst.map! {|x| x.count(\"6\")}\n  lst.map! {|x| x.count(\"\
    7\")}\n  lst.map! {|x| x.count(\"8\")}\n  lst.map! {|x| x.count(\"9\")}\n  lst\n\
    end", "  odd_count_list=[]\n  for i in lst \n    count=0\n    for j in i\n   \
    \   if j.to_s.length.odd?\n        count+=1\n      end\n    end\n    odd_count_list.push(count)\n\
    \  end\n  odd_count_list\nend\n</code>\nThe above code will return a list of odd\
    \ digits in a given string. You can then run your odd_count method to return a\
    \ list of odd digits in a given string. \n<code>\nodd_count([1,2,3,4,5,6])", " \
    \ output = []\n  lst.each do |str|\n    output <<\n      \"the number of odd elements\
    \ #{str.chars.map { |x| x == '1'? 1 : 0 }.sum} \"\n    \"the str#{str.count} #{str.chars.map\
    \ { |x| x == '1'? 1 : 0 }.sum}n the str#{str.count}\"\n      \"#{str.chars.map\
    \ { |x| x == '1'? 1 : 0 }.sum}th str#{str.count}\"\n    \" of the #{str.count}\"\
    \n  end\n  output\nend\n</code>\nTo explain the above, the map function will iterate\
    \ over the string. for each character, if it equals 1, then it will add 1 to a\
    \ counter, otherwise 0, and sum this counter for each of the string's characters.\
    \ We then need to use #{...}.sum to get the sum of this counter. \nFinally, we\
    \ add this number to the output with a line such as \"the number of odd elements\
    \ #{...}\".\n<|/ a tags=ruby |>\n<| a |>\nHere's another one using regular expressions\
    \ and Enumerable#inject:\n<code>", "  ret = []\n  lst.each_with_index do |s, i|\n\
    \    ret.push \"the number of odd elements in #{s[i]} of the #{s[i]} of the #{s[i]}.\"\
    \n  end\n  ret\nend", "  str.gsub!(/\\d+/) do num|\n    odd_count(num.scan(/\\\
    d/)).map {|s| num.size + s}\n  end\n  lst\nend\n</code>\n<|/ a |>\n<| a tags=regex,ruby,string\
    \ |>\nHere's a fairly simple solution that doesn't involve using regular expressions\
    \ (although I think that's an advantage, since you're using them a lot in this\
    \ situation).\n<code>", "  count = []\n  \n  for i in lst\n    count.push(i.to_s.length.odd?\
    \ ? \"#{i.to_s.length}\" : \"#{i.to_s.length.even? ? '8' : '1'}\")\n    \n  end\n\
    \  \n  count.join(',')\nend", "  lst.each_with_index.map { |s,i| [s,lst.count(s.to_s.chars.group_by(&:odd?).map(&:last))]\
    \ }.flatten.uniq\nend\n</code>\n<|/ a dscore=2 tags=string,ruby,arrays |>\n<|\
    \ a tags=string,ruby,arrays dscore=1 |>\nOne method would be to convert the string\
    \ to a character array, group the elements using each, and collect the count:\n\
    <code>\nstrg = '1234567'\nstrg.chars.group_by(&:odd?).count\n</code>\nThis returns:\n\
    <code>\n{\"0\"=>1, \"1\"=>2, \"2\"=>1, \"3\"=>2, \"4\"=>1, \"5\"=>2, \"6\"=>1,\
    \ \"7\"=>2}\n</code>\nThis can then be joined to the original string:\n<code>\n\
    [strg, 'odd?'].map {|s| [s, strg.chars.group_by(&:odd?).count[s]] }.flatten\n\
    </code>\nThis returns the desired output:\n<code>\n[\"the number of odd elements\
    \ 4n the str4ng 4 of the 4nput.\", \"the number of odd elements 1n the str1ng\
    \ 1 of the 1nput.\",\n\"the number of odd elements 8n the str8ng 8 of the 8nput.\"\
    ]\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\nstr = \"1234567\"\nodd_count =\
    \ str.chars.group_by(&:odd?).count \n</code>\nreturns \n<code>\n{\"0\"=>1, \"\
    1\"=>2, \"2\"=>1, \"3\"=>2, \"4\"=>1, \"5\"=>2, \"6\"=>1, \"7\"=>2}\n</code>\n\
    <|/ a tags=string,ruby,arrays |>\n<| a dscore=0 tags=string,ruby,arrays |>\n<code>\n\
    str = \"1234567\"\n</code>\nFirst count the number of odd numbers:\n<code>\nodds\
    \ = str.count{ |i| i.odd? }\n  #=> 4 \n</code>\nThen join with the number of characters:\n\
    <code>\nodds.times { |i| str = str.chomp + \", #{odds} odd digits\" }\n  #=> \"\
    4 odd digits, 1 odd digits, 8 odd digits\" \n</code>\nThe steps are as follows.\n\
    <code>\nodds = str.count{ |i| i.odd? }\n  #=> 4 \nodds = str.count{ |i| i.odd?\
    \ }\n  #=> 4 \n</code>\n<code>\nodds.times { |i| str = str.chomp + \", #{odds}\
    \ odd digits\" }\n  #=> \"4 odd ", "  # Write your code here\n  odd_count_list\
    \ = [0 for x in range(len(lst))]\n  for k in range(len(lst)):\n    num = lst[k]\n\
    \    odd_count_list = []\n    count_num = 0\n    for index in range(0,len(num)-1,2):\n\
    \      if int(num[index+1:len(num)]) % 2 != 0:\n        count_num += 1\n     \
    \ odd_count_list.append(count_num)\n  return odd_count_list\n</cell>\n<cell>",
  "  lst.each_with_index do |x, i|\n    # if the i'th element in lst[i] is a string,\
    \ convert it to an integer.\n    lst[i] = x.to_i\n  end\n  lst.map { |x| odd_digits_count(x)\
    \ }\nend", "  count = 0\n  lst.each do |e|\n    count += e.chars.select { |c|\
    \ c !~ /\\d/ }.size % 2\n  end\n  puts count == 0 ? \"the number of odd digits\
    \ in the input is 0\" :\n    \"the number of odd digits in the input is #{count}\"\
    \nend", "  lst.inject([[]]) do |res, (i, str)|\n    odd = str.count('1')\n   \
    \ if odd > res[i].length\n      res[i] << odd\n    end\n    res\n  end\nend",
  "  lst.map { |x| x.to_s.length }.inject(:+)\nend", "  lst.map{|x| x.to_s.length.to_i}\n\
    end", "    even = []\n    odd = []\n    i = 0\n    while i < lst.size\n      \
    \  even.push(lst[i].to_s.length % 2)\n        i += 1\n    end\n    while i < lst.size\n\
    \        num = lst[i].to_s.length\n        odd.push(num - even.inject(0) {|sum,\
    \ num| sum + (num % 2)})\n        i += 1\n    end\n    even.zip(odd).map {|e|\
    \ e[0] + ' odd ' + e[1]}\nend", "  return lst.inject([]) do |acc, x|\n    acc\
    \ << x if x.digits.odd?\n    acc << x.to_s.size if x.to_s.size > 0\n    acc\n\
    \  end\nend", "\todd_count = []\n\tfor i in lst\n\t\todd_count << i\n\t\todd_count\
    \ = odd_count.map {|i| i.to_s.split(\"\").reject {|j| j == \"1\"}}.map {|i| i.length}.compact\n\
    \tend\n\todd_count.join\nend", "    counts = Hash.new(0)\n    counts[:odd] = Array.new(lst.length)\
    \ { 0 }", "  sum = 0\n  sum1 = 0\n  sum2 = 0\n  sum3 = 0\n  sum4 = 0\n  sum5 =\
    \ 0\n  sum6 = 0\n  sum7 = 0\n  sum8 = 0\n  sum9 = 0\n  sum10 = 0\n  for i in lst\n\
    \    sum1 = sum1 + i.count('1')\n    sum2 = sum2 + i.count('2')\n    sum3 = sum3\
    \ + i.count('3')\n    sum4 = sum4 + i.count('4')\n    sum5 = sum5 + i.count('5')\n\
    \    sum6 = sum6 + i.count('6')\n    sum7 = sum7 + i.count('7')\n    sum8 = sum8\
    \ + i.count('8')\n    sum9 = sum9 + i.count('9')\n    sum10 = sum10 + i.count('0')\n\
    \  end\n  odd_list = []\n  odd_list << \"The number of odd elements in the str\"\
    \ << sum << \" of the str\" << sum1 << \" is\" << sum1 - sum << \" times.\"\n\
    \  odd_list << \"The number of odd elements in the str\" << sum << \" of the str\"\
    \ << sum2 << \" is\" << sum2 - sum << \" times.\"\n  odd_list << \"The number\
    \ of odd elements in the str\" << sum << \" of the str\" << sum3 << \" is\" <<\
    \ sum3 - sum << \" times.\"\n  odd_list << \"The number of odd elements in the\
    \ str\" << sum << \" of the str\" << sum4 << \" is\" << sum4 - sum << \" times.\"\
    \n  odd_list << \"The number of odd elements in the str\" << sum << \" of the\
    \ str\" << sum5 << \" is\" << sum5 - sum << \" times.\"\n  odd_list << \"The number\
    \ of odd elements in the str\" << sum << \" of the str\" << sum6 << \" is\" <<\
    \ sum6 - sum << \" times.\"\n  odd_list << \"The number of odd elements in the\
    \ str\" << sum << \" of the str\" << sum7 << \" is\" << sum7 - sum << \" times.\"\
    \n  odd_list << \"The number of odd elements in the str\" << sum << \" of the\
    \ str\" << sum8 << \" is\" << sum8 - sum << \" times.\"\n  odd_list << \"The number\
    \ of odd elements in the str\" << sum << \" of the str\" << sum9 << \" is\" <<\
    \ sum9 - sum << \" times.\"\n  odd_list << \"The number of odd elements in the\
    \ str\" << sum << \" of the str\" << sum10 << \" is\" << sum10 - sum << \" times.\"\
    \nend", "  return lst.map {|e| e.to_s.length - e.to_s.scan(/\\d/).count if e.is_a?(String)}.compact\n\
    end", "  lst.map { |i| i.chars.map{|c| c.to_i}.inject(:&) }.reduce(:+)\nend",
  "  lst.flatten.select {|x| x.to_s.split(\"\").odd?}\nend", "  lst.map {|i| i.to_s.length}\n\
    \        .select {|x| x % 2 != 0}.map{|x| \"the number of odd elements #{x} of\
    \ the str#{x} #{lst[x].length} of the #{lst[x]}\".to_s}.join(\", \")\nend\n</code>\n\
    Now that we have our helper, we can use it as such:\n<code>\nodd_count(['1234567'])",
  "    odd_lst = []\n    odd_count = 0\n    odd_num = []", "  lst.inject([]) {|count,\
    \ x|\n    return count+x if x.to_i.odd?\n  }\nend", "  odd = 0.zero\n  for x in\
    \ lst\n    odd += x.to_s.scan(/\\d/).count{|a| a.odd? }.to_i\n  end\n  odd.to_s\n\
    end", "  count = []\n  odd_count = 0\n  for i in lst\n    count.push(i.count(1))\n\
    \    odd_count += i.count(1)\n  end\n  count.unshift(odd_count)\n  return count\n\
    end", "  odd_counts = []\n  odd_counts_seen = {}\n  odd_counts.each do |odd_counts|\n\
    \    lst.each do |i|\n      if i = odd_counts[i]\n        odd_counts_seen[i] =\
    \ 1\n      else\n        if odd_counts_seen[i]\n          odd_counts_seen[i] +=\
    \ 1\n        else\n          odd_counts_seen[i] = 1\n        end\n      end\n\
    \    end\n  end\n  odd_counts\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays |>\n\
    <| a dscore=1 tags=ruby,arrays |>\nI like the other solutions, but for fun, here's\
    \ a solution I came up with:\n<code>", "  ret = []\n  str.split(\"\",0).each do\
    \ |x|\n    unless lst.map{|y| y.to_i}.include? x.to_i\n      ret << x.to_s + \"\
    \ n the str\" + x.to_s + \" \" +  lst.map{|y| y.to_i}.count.to_s + \"n of the\
    \ \" + lst.map{|y| y.to_i}.count + \" input.\"\n    end\n  end\n  ret\nend\n</cell>\n\
    <code language=julia-1.4>", "  return lst.map { |s| s.count('0') }.inject(:+)\n\
    end", "  result = lst.map { |s| s.split(//).uniq.size }.\n    select { |s| s.odd?\
    \ }.\n    map { |s| s.to_s.size.to_s }.\n    map { |s| [s.to_s,s] }.\n    sort_by\
    \ { |s| s[1].length }.reverse.to_a\n  result.unshift \"The number of odd elements\
    \ in the input\"\n  result\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n`odd_count`\
    \ only returns the number of odd elements in the input list, but does not output\
    \ the strings.  It also does not output the strings in any particular order.\n\
    <|/ c |>\n<| c |>\n, thanks for pointing that out. I've fixed the code so it outputs\
    \ the strings in an order that's easy to read.\n<|/ c |>\n<| c |>\nThank you for\
    \ fixing the code!\n<|/ c |>\n<| c |>\nThank you for fixing the code! Your code\
    \ is simple and concise.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails-3 |>\nThe OP\
    \ wanted a method that outputs the odd/even number for each string.\n<code>",
  "  lst.map {|x| x.to_s.length}.inject(:+).map do |num|\n    num = num.to_s.reverse\n\
    \    count = num.count {|x| x.to_i % 2 != 0}\n    \"the number of odd elements\
    \ #{num.count} the str#{num.count} #{count} of the #{num.count}nput.\"\n  end\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI find this solution to be extremely\
    \ hard to read and understand.\n<|/ c |>\n<| c |>\n: Yes, and I agree. I've added\
    \ a step by step explanation.\n<|/ c |>\n<| c |>\nThank you for such a complete\
    \ explanation. While I do appreciate your answer very much, I cannot mark it as\
    \ \"The Answer\". I would like to mark it as \"Correct Answer\", but Stack Overflow\
    \ doesn't allow that. I think I should change my mind about this and change my\
    \ mind about my coding abilities to get this to work. Your help is much appreciated.\
    \ Thanks again!\n<|/ c |>\n<| a dscore=2 |>\n<code>\n'789 234 123 456 789 234\
    \ 123 456'.scan(/\\d+/).map { |i| i.to_s.length }", "    odd = 0.step.each do\
    \ |s|\n        odd += 1 if s.to_s.chars.map(&:ord).reject(&:odd?).size > 0\n \
    \   end\n    odd_count.map(&:prepend(odd.to_s))\nend\n</code>\nFor each string\
    \ in the list, map each character in the string to its ASCII\nvalue. If that character\
    \ is odd, add 1 to the result (if it is not odd,\nadd 0).\nUse inject to sum the\
    \ values up. In the block, the current result is the last result\nand the next\
    \ string is the current string. The initial result will be 0.\nprepend will add\
    \ the value to the beginning of the result list.\n<|/ a tags=ruby,string-length\
    \ dscore=1 |>\n<| c |>\nNice! I like that last one, too. Mine is slightly more\
    \ elegant, I suppose.\n<|/ c |>\n<| a tags=ruby,string-length dscore=0 |>\nI agree\
    \ with Tin Man. I wrote the code in a very simple and straightforward manner.\
    \ Since you asked in a comment:\n<code>", "  lst.inject([]) do |sum, item|\n \
    \   sum << item.to_i.odd? ? item.to_i.odd? ? 1 : 1 : 0\n  end\nend", "  lst.each_with_index\
    \ { |str, i| \n    lst[i] = \"the number of odd elements \" + str.count(digits[i\
    \ % digits.length]) + \" in the #{i}nth string of the input.\"\n  }\nend", " \
    \ n = 0\n  for i in lst\n    n += i.to_s.length % 2 == 1\n  end\n  n.to_s\nend",
  "  lst.map! do |num|\n    num = num.to_s\n    count = []\n    i = 0\n    while i\
    \ < num.length\n      while i+1 < num.length && (num[i]+num[i+1]).to_s.length\
    \ <= 1\n        i+=1\n      end\n      i+=1\n      count.push(num.length-i)\n\
    \    end\n    num.chars.zip((0..num.length-1)).to_a.zip(count).map(&:join).map\
    \ do |str, count|\n      \"the number of odd element#{count} of the str#{count}\
    \ of the str#{str}.\"\n    end\n  end\n  lst.flatten\nend", "  odd_lst.clear\n\
    \  for i in lst\n    odd_lst << i.scan(/\\d/).length\n  end\n  odd_lst.map!{|n|\
    \ n % 2 == 0 ? \"the number of odd elements #{n} of the str#{n} of the str.\"\
    \ : \"the number of odd elements #{n} of the str#{n} of the str.\" }\n  odd_lst\n\
    end", "  digits = lst.map{|d| d.to_s}.map(&:to_i).reject(&:zero?)\n  digits.map!{|d|\
    \ d.odd? ? 1 : 0}\n  digits.map!{|d| d.nonzero? ? 1 : 0}\n  digits.map!{|d| d.to_s}.map!{|s|\
    \ s.chars.sort.reduce(:+).to_s}\n  digits.map!{|d| d.to_s}.map!{|s| s.chars.sort.reduce(:+).to_s}\n\
    \  digits.map!{|d| d.to_s}.map!{|s| s.chars.sort.reduce(:+).to_s}\n  digits.map!{|d|\
    \ d.to_s}.map!{|s| s.chars.sort.reduce(:+).to_s}\n  digits.map!{|d| d.to_s}.map!{|s|\
    \ s.chars.sort.reduce(:+).to_s}\n  digits.map!{|d| d.to_s}.map!{|s| s.chars.sort.reduce(:+).to_s}\n\
    \  digits.map!{|d| d.to_s}.map!{|s| s.chars.sort.reduce(:+).to_s}\n  digits.map!{|d|\
    \ d.to_s}.map!{|s| s.chars.sort.reduce(:+).to_s}\n  digits.map!{|d| d.to_s}.map!{|s|\
    \ s.chars.sort.reduce(:+).to_s}\n  digits.map!{|d| d.to_s}.map!{|s| s.chars.sort.reduce(:+).to_s}\n\
    \  digits.map!{|d| d.to_s}.map!{|s| s.chars.sort.reduce(:+).to_s}\n  digits.map!{|d|\
    \ d.to_s}.map!{|s| s.chars.sort.reduce(:+).to_s}\n  digits.map!{|d| d.to_s}.map!{|s|\
    \ s.chars.sort.reduce(:+).to_s}\n  digits.map!{|d| d.to_s}.map!{|s| s.chars.sort.reduce(:+).to_s}\n\
    \  digits.map!{|d| d.to_s}.map!{|s| s.chars.sort.reduce(:+).to_s}\n  digits.map!{",
  "  lst.each_with_index do |e, i|\n    e.split(\"\").uniq.each do |char|\n      lst[i]\
    \ << \"the number of odd elements #{char.count(\"#\")}n the str#{char.count(\"\
    0\")}ng #{char.count(\"1\")}of the #{char.count(\"1\")}nput.\"\n    end\n  end\n\
    end", "  res=[]\n  for i in lst\n    odd=true\n    for j in i\n      odd=odd&&(j==\"\
    0\")\n    unless odd\n      res.push(i)\n  return res.join(\"\\n\")\nend\n  ",
  "  sum = []\n  (0...lst.size).each do |i|\n    sum = sum + lst.map { |e| 1 if e.to_s.to_i(2)\
    \ & 1 }\n  end\n  return sum\nend", "  lst.map { |e| e.chars.map(&:to_i).reduce(:+).to_s\
    \ }.uniq\nend\n</cell>\n<cell>", "    count = []\n    for s in lst\n        count.push\
    \ ( s.length.to_s.split(//).map{ |e| e.length }.inject(:+) )\n    end\n    count.each_with_index{\
    \ |n,i| count[i] = \"the number of odd elements #{n}n the str#{n}#{i+1} of the\
    \ #{i+1}#{i}#{i}#{i}#{i}#{i}.\" }\nend\n</code>\nAnd the results:\n<code>\nirb(main):012:0>\
    \ odd_count ['1234567']\n=> [\"the number of odd elements 4n the str4ng 4 of the\
    \ 4nput.\"]\nirb(main):013:0> odd_count ['3',\"11111111\"]\n=> [\"the number of\
    \ odd elements 1n the str1ng 1 of the 1nput.\",\n    \"the number of odd elements\
    \ 8n the str8ng 8 of the 8nput.\"]\nirb(main):014:0> odd_count ['3',\"11111111\"\
    ,\"22222222\"]\n=> [\"the number of odd elements 1n the str1ng 1 of the 1nput.\"\
    ,\n    \"the number of odd elements 8n the str8ng 8 of the 8nput.\",\n    \"the\
    \ number of odd elements 4n the str4ng 4 of the 4nput.\"]\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI love that you are posting the code. I was about to post my own.\n\
    <|/ c |>\n<| c |>\nAwesome answer! This is really helpful and I learned something\
    \ new. Thank you so much!\n<|/ c |>\n<| a dscore=1 tags=ruby,string |>\n<code>",
  "  odd_counts = []\n  lst.each_with_index do |element, index|\n    odds = element.chars.map\
    \ {|char| char.to_i}\n    if element.is_a?(String)\n      odds.each do |num|\n\
    \        odd_counts << [index, odds.count(num)]\n      end\n    elsif element.is_a?(Integer)\
    \ && element.even?\n      odd_counts << [index, 1]\n    end\n  end\n  odd_counts.flatten.map\
    \ {|odd_count| odd_count.to_s + \" in the #{odd_count.first}nd string of the #{odd_count.last}nd\
    \ input.\"}\nend", "  return [odd_count(l, 1) for l in lst]\nend\n</code>\n<|/\
    \ a tags=ruby,recursion |>\n<| c |>\nYour solution seems too complicated. Why\
    \ do you require recursion?\n<|/ c |>\n<| c |>\n: I wanted to show that you can\
    \ solve this problem with a simple loop. Recursion is necessary when you're trying\
    \ to solve the same kind of problem recursively.\n<|/ c |>\n<| c |>\n: Also, the\
    \ problem asks for the number of odd digits. This is different than counting the\
    \ number of times an element in the string is an odd digit.\n<|/ c |>\n<| c |>\n\
    : Oh, I see. I missed that part. My bad. I thought this was asking how to count\
    \ the amount of times an odd digit occurred, but I was assuming that the problem\
    \ was just counting the number of odd digits in the string.\n<|/ c |>\n<| a |>\n\
    <code>\nodd_count = lambda { |string| \n  string.each_char.inject(0) do |sum,ch|\
    \ \n    ((sum % 2).nonzero? || sum + 1.nonzero? || sum - 1.nonzero?) ? sum + 1\
    \ : sum\n  end\n}", "  lst.inject([]){ |sum, elt|\n    sum << elt.length if elt.odd?\n\
    \    sum\n  }\nend", "  even.count(lst.collect{|s| s.chars.each_cons(2).map(&:join).map(&:to_i)}).join(\"\
    ,\")\nend", "    sum = 0\n    odd_digit = 0\n    for i in lst\n        sum +=\
    \ i.to_i\n        odd_digit += i.to_i % 10\n    \n    odd_ls = []\n    sum % 2\
    \ == 1 ? odd_ls.push(\"the number of odd elements #{sum} of the #{lst.length}\
    \ #{lst}\") : odd_ls.push(\"the number of odd elements #{sum}n the #{lst}#{odd_digit}\"\
    ) \nend", "  lst.map!(&:to_i)\n  lst.map!(&:to_s)\n  lst.map!{|s| s.length}\n\
    \  lst.map!{|s| s.chars.each.count(&:odd?).to_s}\nend", "  output = []\n  string\
    \ = ''\n  for i in lst\n    string += i\n  end\n  count = string.length\n  count\
    \ = 0\n  i = 0\n  while i < string.length\n    count = 0\n    i += 1 # i will\
    \ move up\n    while i < string.length and (string[i].to_i % 2 != 0)\n      count\
    \ += 1\n      i += 1\n    end\n    output << \"the number of odd elements #{i}\
    \ the str#{i}ng #{count} of the #{i}nput.\\n\"\n  end\n  output\nend", "  lst.map!\
    \ {|i| i.to_i}\n  odd_digits = lst.each_with_index.with_object(Hash.new(0)){|(i,j),h|\
    \ h[j]+=1 if i.odd?}\n  odd_digits = odd_digits.map{|k,v| \"#{k} #{v}\"}.join(\"\
    , \")\n  return [odd_digits]\nend", "  # Your code here!\n  return lst.map(&:to_i).map\
    \ { |i| i.to_s.chars.map { |c| c.to_i.odd? }.sum }\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nIt's not necessarily about beauty, but about efficiency. Your solution\
    \ does about as much work as mine does, but it is also more complex and less efficient.\n\
    <|/ c |>\n<| a tags=ruby dscore=2 |>\nThis is actually the way I do it. I think\
    \ it's a very clever method. One minor thing I'd like to add is to use enumerable\
    \ instead of map, but I don't know whether that is an advantage or not for this\
    \ particular example.\n<code>", "  lst.map {|s| s.chars.map(&:to_i).map {|n| n\
    \ % 2 == 1 ? n : 0}.sum}\nend", "  return lst.map {|s|\n    s.length.odd? ? s.length\
    \ : s.length.odd? ? s.length - 1 : s.length + 1\n  }.inject(:+)\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nYou could do that in one line like this:\n<code>",
  "    odd_count = 0\n    string = lst.map { |x| x.to_i }\n    string.each_with_index\
    \ { |s,i| odd_count += s.odd? ? 1 : 0 }\n    string.map { |s| s.odd? ? \"the number\
    \ of odd elements #{odd_count} the str#{odd_count} #{s} of the #{s}.\" : '' }\n\
    end", "  lst.map { |str| str.to_s.chars.map(&:to_i).reduce(:+).odd? }\nend", " \
    \ count = []\n  lst.each do |i|\n    count[i] = i.split(\"\").inject(0) do |sum,v|\n\
    \      sum += v.to_i**0.5\n      sum\n    end\n  end\n  count.map!{|i| i.to_s}\n\
    \  count\nend", "  output = []\n  lst.each do |num|\n    count = 1\n    num.each\
    \ do |digit|\n      count += 1 if digit.to_i%2 != 0\n    end\n    output << [count,\
    \ num]\n  end\n  output\nend", "  num = []\n  res = []\n  for i in lst\n    num.push(i.to_s.length)\n\
    \  end\n  res = num.map!{ |i| i.odd? ? i : 0 }\n  res.each do |i|\n    if i.is_a?\
    \ String\n      res.map do |x|\n        if x.include?(i)\n          res.delete(x)\n\
    \        end\n      end\n    end\n  end\n  res\nend", "  odds_count = 0\n  for\
    \ i in lst.flatten(1)\n    if i.to_s.length % 2 == 1\n      odds_count += 1\n\
    \    end\n  end\n  lst.map!{|x| x.to_s.length}\n  odd_count_output = odds_count.times.map\
    \ do |i|\n    \"the number of odd elements #{i} of the str#{i} of the input.\"\
    \n  end\n  odd_count_output.flatten(1)\nend\n</code>\n<|/ a dscore=1 tags=ruby\
    \ |>\n<| c |>\nI appreciate the effort, but I don't believe that it is what the\
    \ OP is looking for. From the question, it is clear that the OP is asking \"count\
    \ the number of odd characters in the string\". As such '1234567' should return\
    \ '3' but instead returns '2'.\n<|/ c |>\n<| a tags=ruby |>\nYou can use the enumerator\
    \ feature of String:\n<code>", "  result = [0] * lst.size\n  odd_count = 0\n \
    \ for i in lst\n    odd_count += i.size % 2 != 0\n    result[odd_count] += 1 if\
    \ odd_count < result.size else 0\n  end\n  return result\nend", "  return lst.map\
    \ { |s| s.count(&:odd?) }.compact\nend", "  odd_num = 0\n  odd_num_list = []",
  "  odd_list = []\n  odd_count = 0\n  list_length = lst.count(\"\\n\")\n  for i in\
    \ 0...list_length do\n    temp = 0\n    for j in 0...i.to_s do\n      if lst[j].to_i.odd?\n\
    \        temp = temp + 1\n      end\n    end\n    if temp > odd_count\n      odd_count\
    \ = temp\n      odd_list << temp\n    end\n  end\n  odd_list << odd_count\n  return\
    \ odd_list\nend", "  new_lst = []\n  i = 0\n  while i < lst.size\n    new_lst\
    \ << [lst[i]].join([\"the number of odd elements \" << (lst[i].to_s.length - lst[i].to_s.chars.count\
    \ % 2).to_s << \" of the str#ng #{lst[i].to_s.length} of the #{lst[i]}.\"].split(\"\
    \ \"))\n    i += 1\n  end\n  return new_lst\nend", "  lst.map!{|e| e.to_s.length\
    \ * e.to_s.scan(/\\d/).length}\n  lst.map!{|e| e % 2 != 0 ? \"#{e}n\" : e}\nend",
  "  counts = Hash.new(0)\n  lst.each do |str|\n    str.each_char {|c| counts[c] +=\
    \ 1}\n  end\n  counts.each {|k,v| counts[k] = v.odd? ? v.length : 0}\n  counts.keys.sort.map\
    \ {|k| \"the number of odd elements #{k} the str#{k} #{counts[k]} of the #{k}put.\"\
    }\nend", "  result = lst[0].to_s.length\n  lst.each do |e|\n    result += (e.to_s.length\
    \ % 2)\n  end\n  result\nend", "  result=[]\n  arr.each do |str|\n    result.push(\"\
    the number of odd elements in the\" + str.gsub(/\\d/,\"\") + \" of the \" + str\
    \ + \"input.\")\n  end\n  return result\nend\n</code>\n<|/ q |>\n<| c |>\nYou're\
    \ missing a `return` statement in your `each` loop.\n<|/ c |>\n<| c |>\nThanks,\
    \ I added the return statement in each loop, but i still get the error:", "  counts\
    \ = []\n  for el in lst\n    el = el.to_s\n    el = el.to_i\n    odd_digits =\
    \ el.modulo(2)\n    counts << [el.to_i + odd_digits]\n  counts.collect!(&:to_s)\n\
    end", "  return lst.map{|x| count_odd_digits(x)}.flatten.map {|x| x.to_s}\nend\n\
    </code>\nNow we use the above functions to rewrite our solution:\n<code>", " \
    \ counts = []\n  strs = []\n  for i in lst\n    strs << i.to_s\n    counts <<\
    \ i.count(\"9\")\n  end\n  strs.uniq.map{|s| strs.count(s)}\nend", "  return lst.map\
    \ { |s| s.count(/[1-8]/) }\nend", "  return lst.map{|s| s.scan(/\\d+/).reject(&:empty?).size}.sort\n\
    end", "  lst = lst.map { |s| s.chars.map(&:to_i).reduce(:+) }\n  lst.map(&:odd?)\n\
    end", "  # Your code here\n  count.to_a = []\n  lst.each do |i|\n    count = []\n\
    \    i.split.each do |j|\n      count << j.count('0') unless j.count('0')\n  \
    \  end\n    count.to_a.push(count)\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
