name: HumanEval_100_make_a_pile
language: rb
prompt: "# Given a positive integer n, you have to make a pile of n levels of stones.\n\
  # The first level has n stones.\n# The number of stones in the next level is:\n\
  # - the next odd number if n is odd.\n# - the next even number if n is even.\n#\
  \ Return the number of stones in each level in a list, where element at index\n\
  # i represents the number of stones in the level (i+1).\n# Examples:\n# >>> make_a_pile(3)\n\
  # [3, 5, 7]\ndef make_a_pile(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_a_pile\n\
  \    candidate = method(:make_a_pile)\n    assert_equal([3, 5, 7], candidate.call(3))\n\
  \    assert_equal([4, 6, 8, 10], candidate.call(4))\n    assert_equal([5, 7, 9,\
  \ 11, 13], candidate.call(5))\n    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))\n\
  \    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))\n  end\nend\n"
completions: ["  result = []\n  make_pile(n, 1)\n  result\nend", "  result = []\n\
    \  pile_size = n\n  pile_size -= 1 if n % 2 == 0 else 0\n  for i in 0...pile_size\n\
    \    result[i] = n\n    if pile_size % 2 == 1\n      n = n % 2 + n / 2\n    end\n\
    \  end\n  return result\nend\n</cell>\n<code language=julia-1.5>", "    pile =\
    \ Array.new(n.to_i, '') #\_+1 -> [nil] ?\_\n    pile[0] = n\n    if n % 2 == 1\
    \ \n        pile[1] += 1\n        pile[2] += 1\n    else\n        pile[1] += 1\n\
    \        pile[2] += 1\n    end\n    pile\nend", "  n = n % 2\n  return [n, 2*(n-1),\
    \ 3*(n-1)]\nend", "  result = []\n  for i in (0..n-1)\n    result << i+1 if (i+1)%2\
    \ != 0 else  (i+2)%3\n  result\nend", "  if n == 0 then return []\n  if n == 1\
    \ then return [n]\n  return make_a_pile(n / 2) + [n % 2 + 1]\nend", "  a=[]\n\
    \  (1..n).each{|i|a[i]=(i%2).odd?i+1:i+2}\n  a\nend", "  res = []\n  if n % 2\
    \ == 0 then stones = n else stones = (n + 1)\n  while stones > 0\n    res << stones\n\
    \    stones = stones - 2 if stones & 1 == 0 else stones - 1\n  end\n  res\nend\n\
    </cell>\n<cell>", "  return [] if n <= 0 \n  \n  # Return an array of n size.\
    \ First element will have the value 'n' and next will be the value of the \n \
    \ # next level. \n  arr = []\n  arr.push(n)\n  \n  i = 3\n  \n  while i > 0\n\
    \  \n    # Push the current number of stones to the array\n    arr.push(i % 2\
    \ == 0 ? n : n % 2)\n    \n    # Find the next level\n    i = i / 2\n  end\n \
    \ \n  arr\nend", "  arr = []\n  while n > 0\n    arr << n\n    n -= n % 2 == 0\
    \ ? 2 : 3\n  end\n  arr.reverse\nend\n</code>\n<|/ a tags=ruby,algorithm,math,language-agnostic,combinatorics\
    \ dscore=1 |>\n<| a dscore=1 |>\nThe first thing that comes to mind is that there\
    \ is a straightforward recursive solution.\nIf you have a binary number with a\
    \ leading zero, convert it to its decimal equivalent. Starting with the smallest\
    \ ones, subtract out the number you just converted. Keep doing this until you\
    \ run out of numbers. So for n=3, you would start with the smallest ones, convert\
    \ them from 3 to 3-1=3, then 3-2=1 and so on. The number of these would be 2^k,\
    \ and you can calculate the sum as 2^k + 2^(k-1) + 2^(k-2) + ... + 2^0.\nSo the\
    \ sum of all 2^k possible numbers is the sum of all 2^k binary numbers.\n<|/ a\
    \ tags=ruby,algorithm,math,language-agnostic,combinatorics |>\n<| a tags=ruby,algorithm,math,language-agnostic,combinatorics\
    \ |>\nSince your function returns the number of ways of placing the stones in\
    \ a pile of n stones, I assume the number of stones in each pile is equal to the\
    \ number of ways to put them on one side of a pile.\nThe next thing that comes\
    \ to mind is that you are trying to find the number of ways to put n stones in\
    \ a pile of n+1 stones.\nA recursive algorithm could solve this problem in time\
    \ O(n!) by iteratively placing the stones in all the possible ways and keeping\
    \ track of the number of ways of placing each stone on the other side. This would\
    \ produce a recursive algorithm of time O(2^n). Since you are doing this in ruby\
    \ I assume you are familiar with recursion.\n<|/ a dscore=1 |>\n<| c |>\nWhat\
    \ is \"n!\" in your recurrence?\n<|/ c |>\n<| c |>\nSorry that was supposed to\
    \ be a typo.\n<|/ c |>\n<| c |>\n\"n!\" means \"n factorial\". http://en.wikipedia.org/wiki/Factorial\n\
    <|/ c |>\n<| c |>\nThe last sentence in your answer is incorrect.\n<|/ c |>\n\
    <| a dscore=1 |>\nI made a recursive function which finds number of possible combination\
    \ by putting n stones in a pile of n+1 stones.\n<code>", "  arr = Array.new(n)\n\
    \  arr[0]=n\n  arr.each_index do |i|\n    arr[i+1] = i%2==0 ? arr[i]+2 : arr[i]+1\n\
    \  end\n  arr\nend\n</pre>\n<p>Test:</p>\n<pre class=\"prettyprint lang-Ruby\"\
    >", "  if n % 2 == 1\n    make_a_pile(n / 2)\n  else\n    make_a_pile(3 * n +\
    \ 1)\n  end\nend", "  res = []\n  for x in 1..n\n    if n%2 != 0\n      next if\
    \ x==n\n      res = [n] + res\n    else\n      res = [n-x] + res\n      next\n\
    \  end\n  res\nend", "  pile = [1]\n  n.times { pile.push(pile.last * 2 + (n %\
    \ 2 == 0 ? 0 : 1)) }\n  pile\nend", "  arr = []\n  for i in 0...n\n    arr[i]\
    \ = i % 2 ? n : 2 * n\n    n = (n - arr[i]) / 2\n    arr[i] = arr[i] + arr[i]\
    \ - 1\n  end\n  return arr\nend", "    levels = []\n    odd = (n&1)==1\n    even\
    \ = (n&2)==0\n    while n>1:\n        levels.append(n%2) if odd else levels.append(n//2)\n\
    \        n = n//2\n    levels.append(n)\n    return levels", "    levels = []\n\
    \    level = [n]\n    while n != 1\n        if n & 1\n            levels << level[1]\
    \ * 2\n            levels << level[1] * 2\n        else\n            levels <<\
    \ level[1] * 2\n            levels << level[1] * 2\n        end\n        n /=\
    \ 2\n    end\n    levels << level[1]\n    return levels\nend", "    pile = Array.new(2*n+1,\
    \ 0)\n    pile[0].upto(pile[n]) do |i|\n        pile[i+n+1] = (n+1)**2 if i.even?\n\
    \        pile[i+2*n+1] = (n+1)**2 if i.odd?\n    end\n    pile\nend", "    return\
    \ make_pile(n)\nend", "  pile = [n] * n\n  pile.each_with_index { |e, i| pile[i]\
    \ = e % 2 ? e + 1 : e }\n  pile\nend", "  arr = Array.new(n) do\n    if n & 1\
    \ == 0\n      n\n    else\n      n + 1\n    end\n  end\n  arr.map {|i| i * n +\
    \ 1 }\nend", "  list = []\n  for i in 0..n-1\n    list << n % 2 == 0 ? n : n*3+1\n\
    \    n /= 2\n  list\nend", "  arr = (n..n+n-1).to_a\n  arr = arr.map { |i| i %\
    \ 2 ? n : n*2 }\n  arr.reverse\nend", "  if n <= 0\n    return []\n  end\n  stones\
    \ = n % 2 == 0 ? n : n + 1 # n is odd\n  pile = [stones]\n  stones = stones.to_i\n\
    \  while stones > 0\n    if stones.even?\n      stones -= 2\n      pile.push(n/2)\n\
    \    else\n      stones -= 1\n    end\n  end\n  pile.reverse!\n  return pile\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,functional-programming |>\n<code>",
  "  arr = Array.new(n)\n  1.upto(n){|i| arr[i] = i+1 if i%2 == 1 || i%2 == 0}\n \
    \ return arr\nend", "  arr = []\n  while n > 0\n    if n % 2 == 0\n      n /=\
    \ 2\n      arr << n\n    else\n      n /= 2\n      n += 1\n      arr << n\n  \
    \  end\n  end\n  arr\nend", "  levels = []\n  n.times { levels << n if n.odd?\
    \ || n.even? }\n  levels.map { |n| n.odd? ? n : n * 2 }\nend", "    arr = Array.new(n)\n\
    \    arr[0] = 1\n    arr[1] = n\n    arr[2] = n\n    if n % 2\n        arr[2]\
    \ = ((arr[2] - 1) / 2).ceil\n    end\n    \n    # arr will be\n    # [1,n,n],[1,n+1,n+1],[1,n+2,n+2]\n\
    \    # arr[1..n] represent the number of stones in each level\n    \n    # iterate\
    \ till the length of arr\n    arr.each_index do |i|\n        arr[i + 1] = arr[i]\
    \ + arr[i * 2] + arr[i * 2]\n    end\n    \n    # return it\n    return arr\n\
    end", "  levels = []\n  for i in 0..n-1\n    if n%i == 0\n      levels << n%i\n\
    \      n /= i\n    end\n  end\n  levels << n\n  return levels\nend", "  count\
    \ = [1]\n  for i in 1..n\n    count[i] = count[i-1] + (n%i==0 ? (i+1) : 0)\n \
    \ end\n  count[n]\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| a tags=ruby,algorithm\
    \ |>\nJust for fun, I thought of an extreme fast solution.\n<code>", "  list =\
    \ Array.new(n)\n  i = 0\n  while (i<n)\n    list.push(i+1)\n    i += 1\n  if n%2==1\n\
    \    list.push(list.pop(2)*2+2)\n  else\n    list.push(list.pop(1)*2+2)\n  return\
    \ list\nend", "  arr = Array.new(n / 2 + 1) do |i|\n    if i.odd?\n      i + 1\n\
    \    else\n      i + 2\n    end\n  end\n  arr\nend", "  levels = [n]\n  for i\
    \ in 1..n\n    levels << levels[i % 2].even? ? i + 1 : i\n  end\n  levels\nend",
  "    stones = []\n    odd = n/2\n    even = (n-1)/2\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.push odd\n    stones.push even\n    stones.push odd\n    stones.push\
    \ even\n    stones.", "    return Array.new(n - 1, 0, 0) { |i| i == 0 ? n : n\
    \ % 2 == 0 ? n / 2 * 2 + 1 : n / 2 * 2 + 2 }\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nI cannot get this to work for me, I get \"wrong number of arguments (given\
    \ 0, expected 1) (ArgumentError)\" on the .new line and can't figure out what\
    \ it means. I do have 2 arrays, a level and a pile. Can you please explain what\
    \ that means?\n<|/ c |>\n<| c |>\nSorry, the line was supposed to be:", "  return\
    \ [] if n.zero? or n % 2 == 0\n  result = [n]\n  while result != []\n    n = result.pop\n\
    \    odd, even = n.odd?, n.even?\n    next_odd, next_even = odd, even\n    if\
    \ odd\n      result.push(n.next)\n      n -= n.next\n    else if even\n      result.push(n.next\
    \ * 2)\n      n -= n.next * 2\n    else # n.even?\n      result.push(n.next)\n\
    \      n -= n.next\n  end\n  result\nend", "  stones = []\n  if n % 2 == 1\n \
    \   stones << n\n  elsif n == 0\n    stones\n  else\n    stones << n % 2 == 0\
    \ ? n : n - 1\n    stones << make_a_pile(n - 1)\n  end\nend", "  list = []\n \
    \ while n > 0\n    list.append(n % 2 == 0 ? n : n * 2)\n    n /= 2\n  end\n  list\n\
    end", "  # check if n is odd.\n  return [n] if n % 2 == 1 else {\n    # check\
    \ if the n is even.\n    n: n % 2 == 0 ? n / 2 : 3 * n + 1\n  }.map {|n| make_a_pile(n)\
    \ }\nend", "  pile = []\n  \n  while n > 0 do\n    if n % 2 == 0 then\n      pile\
    \ = pile + [n - 1]\n      n = n / 2\n    else\n      pile = pile + [n / 2]\n \
    \     n = n / 2\n    end\n  end\n  return pile\nend", "  levels = Array.new(0,0)\
    \ # levels is a 2D array\n  pile = Array.new(n) \n  for i in 0...n\n    levels[i]\
    \ = pile.pop\n  end\n  return levels\nend", "  ns = n.odd? ? n.to_s+1 : n.to_s+2\n\
    \  ns = []\n  n.times { |i| ns << i }\n  ns << n\n  ns << n\n  ns << n\n  ns\n\
    end", "  nums = (0...n).to_a\n  pile = []\n  odd_counter = 0\n  even_counter =\
    \ 0\n  for i in 0...n\n    if nums[i] > n\n      pile.push(even_counter)\n   \
    \   even_counter = 0\n    elsif nums[i] < n\n      pile.push(odd_counter)\n  \
    \    odd_counter = 0\n    else\n      pile.push(nums[i])\n      odd_counter +=\
    \ 1\n      even_counter += 1\n    end\n  end\n  pile.push(even_counter)\n  pile.push(odd_counter)\n\
    \  return pile\nend", "  \n  # Your code here\n  arr = []\n  arr = Array.new(n)\n\
    \  arr[0] = n\n  arr = arr.select { |x| x % 2 == 0 }\n  arr = arr.select { |x|\
    \ x % 2 != 0 }\n  arr.each_index { |i| arr[i+1] = arr[i/2] + arr[i/2+1] }\n  return\
    \ arr\nend", "    levels = [0 for _ in range(n+1)]\n    for i in range(1, n+1):\n\
    \        if n % i == 0:\n            levels[i] += n/i\n    return levels", " \
    \   arr = [n+1] # the first level has n stones.\n    arr += [n] if n.odd? # add\
    \ the next odd number\n    arr += [n] if n.even? # add the next even number\n\
    \    arr\nend", "  n1 = n\n  n2 = n1.odd? ? n1.next * 2 : n1.next\n  n3 = n2.even?\
    \ ? n2.next * 2 : n2.next\n  n4 = n3.odd? ? n3.next * 2 : n3.next\n  n5 = n4.even?\
    \ ? n4.next * 2 : n4.next\n  n6 = n5.odd? ? n5.next * 2 : n5.next\n  n7 = n6.even?\
    \ ? n6.next * 2 : n6.next\n  n8 = n7.odd? ? n7.next * 2 : n7.next\n  n9 =n8.even?\
    \ ? n8.next * 2 : n8.next\n  n10=n9.odd? ? n9.next * 2 : n9.next\n  n11=n10.even?\
    \ ? n10.next * 2 : n10.next\n  n12=n11.odd? ? n11.next * 2 : n11.next\n  n13=n12.even?\
    \ ? n12.next * 2 : n12.next\n  n14=n13.odd? ? n13.next * 2 : n13.next\n  n15=n14.even?\
    \ ? n14.next * 2 : n14.next\n  n16=n15.odd? ? n15.next * 2 : n15.next\n  n17=n16.even?\
    \ ? n16.next * 2 : n16.next\n  n18=n17.odd? ? n17.next * 2 : n17.next\n  n19=n18.even?\
    \ ? n18.next * 2 : n18.next\n  n20=n19.odd? ? n19.next * 2 : n19.next\n  n21=n20.even?\
    \ ? n20.next * 2 : n20.next\n  n22=n21.odd? ? n21.next * 2 : n21.next\n  n23=n22.even?\
    \ ? n22.next * 2 : n22.next\n  n24=n23.odd? ? n23.next * 2 : n23.next\n  n25=n24.even?\
    \ ? n24.next * 2 : n24.next\n  n26=n25.odd? ? n25.next * 2 : n25.next\n  n27=n26.even?\
    \ ? n26.next * 2 : n26.next\n  n28=n27.odd? ? n27.next * 2 : n27.next\n  n29=n28.even?\
    \ ? n28.next * 2 : n28.next\n  n30=n29.odd? ? n", "  n = n.to_i\n  return [n %\
    \ 2 == 0 ? n : n * 3 + 1]\nend", "  a = [n]\n  a.unshift(n % 2 == 0 ? n.odd? n\
    \ : n.even? n : n.odd? n.even? n : n.even? n.odd? n.even? n)\n  for i in (0..a.length\
    \ - 2)\n    a[i + 1] = a[i + 1].odd? a[i + 1] : a[i + 1].even? a[i + 1] : a[i\
    \ + 1].odd? a[i + 1].even? a[i + 1] : a[i + 1].even? a[i + 1].odd? a[i + 1].even?\
    \ a[i + 1] : a[i + 1].even? a[i + 1].odd? a[i + 1].even? a[i + 1] : nil\n  end\n\
    \  a\nend", "  result = []\n  1.upto(n) do |level|\n    next if level == 1\n \
    \   next   = (level % 2 == 0) ? n : level - n.to_i\n    next  += 1.upto(next).reduce(0){|sum,\
    \ i| sum + i }\n    result << next\n  end\n  result\nend", "  # TODO: Your code\
    \ here!\nend\n</cell>\n<text>\nSolution", "    levels = [0 for _ in 0..(n-1)]\n\
    \    levels[0] = n\n    levels.each_index do |i|\n        if i.odd?\n        \
    \    levels[i+1] = levels[i].next\n        else\n            levels[i+1] = levels[i].next/2\n\
    \        end\n    end\n    levels\nend\n</code>\n<|/ a dscore=0 tags=ruby,arrays,algorithm\
    \ |>\n<| c |>\nI think you got your assignment wrong. The OP said *\u201CThe first\
    \ level has n stones.\u201D* \u2013 not how many stones are in the first level\u2026\
    \n<|/ c |>\n<| c |>\n, I agree that he made a mistake in his wording but he did\
    \ provide the example that he provided in the question. I think the question is\
    \ clear enough as it is, although I agree that he should provide an example that\
    \ makes clear the OP did his homework.\n<|/ c |>\n<| c |>\nThe OP's question doesn't\
    \ have much to do with homework. He was having trouble with the definition of\
    \ a pile of stones.\n<|/ c |>\n<| c |>\nAgreed, I missed that, but I feel that\
    \ this answer should be marked as correct.\n<|/ c |>\n<| a dscore=0 |>\nI agree\
    \ with Tadman that your code looks fine and very similar to mine (though I added\
    \ some comments to make it easier to follow). \nHowever, your initial thought\
    \ of creating a hash would make sense to me. I assume this is an exercise in learning\
    \ how to manipulate arrays, but if not, I would not use a hash at all. Your initial\
    \ code was pretty easy to understand:", "  num_pile = []\n  count = 0\n  if n\
    \ % 2 == 0\n    count += n / 2\n    num_pile.push(count)\n  end\n  if n % 2 !=\
    \ 0\n    count += (n - 1) / 2\n    num_pile.push(count)\n  end\n  return num_pile\n\
    end", "  return n.times.map { |i| i % 2 ? i : i + 1 }\nend\n</code>\nIf you don't\
    \ feel like writing it by hand, you can get it here with a ruby one-liner:\n<code>\n\
    require 'open-uri'\nrequire 'time'", "  return make_levels(n)[n]\nend", "  levels\
    \ = []\n  i = 0\n  while n > 0\n    n -= ((n & 1) != 0) ? 2 : 3\n    levels[i]\
    \ = n\n    i += 1\n  end\n  levels\nend", "  pile = Array.new(n - 1)\n  pile[1]\
    \ = n\n  (1..n).each do |i|\n    pile[i] = pile[i+1] if i.odd?\n    pile[i] =\
    \ pile[i] - 1 if i.even?\n  end\n  pile\nend", "\tpile = []\n\tif n.odd?\n\t\t\
    for i in (1..n).odd?\n\t\t\tpile.push(i+1)\n\telse\n\t\tfor i in (1..n).even?\n\
    \t\t\tpile.push(i+1)\n\tend\n\treturn pile\nend", "  levels = []\n  loop do\n\
    \    if n % 2 == 1\n      levels << n\n      n += 1\n      n -= 1\n    else\n\
    \      levels << (n * 2)\n      n += 1\n      n -= 1\n    end\n  end\n  levels\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a |>\nUsing recursion \n<code>", "    levels\
    \ = []\n    pile = [n]*n\n    pile.each_index do |i|\n        next if i+1%2 ==\
    \ 0\n        level = [pile[i]]\n        pile[i].times do |j|\n            level.push((j+i)%2\
    \ ? pile[j] : pile[j-1])\n        end\n        levels.push(level)\n    end\n \
    \   levels.flatten\nend\n</code>\n<|/ a tags=ruby,piles |>\n<| a |>\n<code>",
  "  levels = []\n  stones = 1\n  i = 0\n  while i < n\n    case n % 2\n    when 1\n\
    \      stones += n\n    when 0\n      stones += n + 1\n    else\n      stones\
    \ += n + 1\n    end\n    levels << stones\n    i += 1\n  end\n  levels\nend",
  "  arr = []\n  i = 0\n  while i < n\n    arr.push(n-i%2)\n    i = i+1\n  end\n \
    \ arr.push(n)\n  return arr\nend", "  return [n*(n+1)/2, n*(n+2)/2]\nend\n</cell>\n\
    <code language=julia-1.5>", "  pile = []\n  level = 1", "  r = []\n  if n%2 !=\
    \ 0\n    r.push(n.even? n: n.odd? n-2 : n-3)\n  else\n    r.push(n)\n  end\n \
    \ until r.empty?\n  r\nend\n</cell>\n<code language=julia-0.4>\nfunction make_a_pile2(n)\n\
    \  r = []\n  if n%2 != 0\n    r.push(n.even? n: n.odd? n-2 : n-3)\n  else\n  \
    \  r.push(n)\n  end\n  while !r.empty?\n    r.push(r.first)\n    r.pop\n  end\n\
    \  r\nend\n</cell>\n<code language=julia-0.4>\nmake_a_pile2(3)\n</cell>\n<code\
    \ language=julia-0.4>\nmake_a_pile2(11)\n</cell>\n<code language=julia-0.4>\n\
    make_a_pile2(-1)\n</cell>\n<code language=julia-0.4>", "    pile = Array.new(2*n-1,\
    \ 0)\n    pile[0] = n\n    pile[1] = n\n    pile[2] = n", "  n = n || 0\n  if\
    \ n == 0\n    return [n]\n  if n==1 then\n    return [1]\n  if n % 2\n    # n\
    \ is odd\n    odd_n = Math.next_odd_number(n)\n    evens = n - odd_n\n    pile\
    \ = [odd_n] + make_a_pile(evens)\n  else\n    # n is even\n    evens = n - Math.next_odd_number(n)\n\
    \    pile = make_a_pile(evens) + [Math.next_even_number(n)]\n  end\n  return pile\n\
    end", "  arr = (1..n).to_a\n  arr.delete_if { |i| i % 2 == 1 }\n  arr.delete_if\
    \ { |i| i % 2 == 0 }\n  arr.map { |i| i + 1  }\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nYour solution is more simple to understand and I appreciate it\
    \ but I would like to know why my solution doesn't work...\n<|/ c |>\n<| c |>\n\
    I agree, your solution is much simpler and it works but it still doesn't explain\
    \ why my solution doesn't work... Anyways, thanks anyways...\n<|/ c |>\n<| c |>\n\
    I have no explanation about why the solution fails yet. Will try to see if I can\
    \ find anything else. In the meantime I'll keep thinking and I will update the\
    \ answer if I find anything.\n<|/ c |>\n<| c |>\nYeah, that's a pity :) Hope someone\
    \ can figure it out. Thanks anyways.\n<|/ c |>\n<| c |>\nI added a little explanation\
    \ but I can't find a proper explanation yet :/\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\nAnother way to do it:\n<code>", "  pile = [n]\n  for i in (1..n-1)\n   \
    \ pile[i] = pile[i-1] + pile[i-2]\n    pile[i] = if i % 2 == 0\n      pile[i]\n\
    \      else\n      pile[i/2] - pile[i]\n  end\n  pile\nend", "  levels = []\n\
    \  for i in 1..n\n    levels.push(n % 2) << i\n    n = n/2\n  end\n  levels\n\
    end", "  raise \"not yet implemented\" # remove this line and implement the body\
    \ of the method\nend\n</code>\nI hope this helps.\n<|/ a tags=arrays,ruby,ruby-on-rails\
    \ dscore=0 |>\n<| c |>\nThanks for the help but i think i missed something.  I'm\
    \ supposed to use two variables to hold the number of stones in the first pile.\
    \  Then the second pile should take up the remaining space.  Then the third. \
    \ Then the fourth.  I'm supposed to put each pile into an array and return that\
    \ array.\n<|/ c |>\n<| c |>\nOh ok.  Yes, that makes sense.\n<|/ c |>\n<| c |>\n\
    How are you supposed to use those variables?  You can certainly use variables\
    \ inside methods, but you need to make sure that the variables are local to the\
    \ method; otherwise, they will be created in the scope of the method.  Also, make\
    \ sure to return the array, not print it, from the method.\n<|/ c |>\n<| c |>\n\
    I added a description of the two variables and how I should use them in the method.\
    \  I appreciate your help.\n<|/ c |>\n<| c |>\nI just updated my code with the\
    \ additional requirements.  I appreciate your help.\n<|/ c |>\n<| a dscore=0 |>\n\
    You can do this with a single method if you know the number of levels up to the\
    \ nth level:\n<code>", "  if n == 0\n    []\n  elsif n % 2 == 1\n    [n - 1, n\
    \ - 3]\n  else\n    [n - 3, n - 5, n - 7]\n  end\nend", "  return n.even? ? [n].pack('n')\
    \ : [(n.odd? ? [n.next_odd].pack('n') : [n.next_even].pack('n'))].pack('n')\n\
    end\n</pre>\n            </div>\n          </div>\n        </div>\n      </div>\n\
    \    </div>\n  </div>\n</div>", "  # Your code here\n  arr = []\n  arr << n\n\
    \  arr = arr.reverse\n  arr[0]\n  arr.each_index{|i|\n    if (i % 2 == 0) then\n\
    \      arr[i] = arr[i] + arr[i+1]\n      arr[i] = arr[i]/2\n    else\n      arr[i]\
    \ = arr[i]/2\n    end\n  }\n  arr\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>", "    pile = []\n    count = n\n    level = 1", "  # Your code here\n\
    end", "  result = []\n  n%2==0 ? (result<< n ) : (result<< n >> 1)\n  (0..result.length-1).each\
    \ do |index|\n    result << (index+1).floor\n  end\n  result\nend", "  res = []\n\
    \  for i in 0..(n/2).round do \n    res.push n.even? ? n : (n.odd? ? 2*(n-2) +\
    \ 1 : 2*(n-1))\n  end\n  res\nend", "  list = []\n  n1 = n\n  n2 = n\n  while\
    \ n1 != 0 and n2 != 0\n    n1 = n1 - 1\n    n2 = n2 - 1\n    if n1 % 2\n     \
    \ list.push(n1)\n      n1 = n1 + 1\n    end\n    if n2 % 2\n      list.push(n2)\n\
    \      n2 = n2 + 1\n    end\n  end\n  list\nend", "  if n == 0\n    0\n  else\n\
    \    n - 2\n    make_a_pile(n - 2) + [n % 2 == 0]\n  end\nend", "  if n == 1\n\
    \    [1]\n  else if n == 2\n    [3]\n  else\n    make_a_pile((n-1).even?? n+1\
    \ : n-2)\n       + [n-1, n]\n  end\nend\n</pre>", "  puts(n)\n  pile = Array.new(n)\
    \ { 0 }\n  puts(pile)\n  level = 1\n  pile.first = 1\n  while pile.last < n\n\
    \    n = n + 1\n    pile.last += n <= 0 ? 1 : n\n    pile.push level\n    level\
    \ = level % 2 == 0 ? level + 1 : level - 1\n    puts(pile)\n  end\n  puts(pile)\n\
    \  return pile\nend", "  return [0, 1, 2].map {|i| i+1 if i % 2 == 0 else i+2}\
    \   # +2 because odd or even\nend", "    pile = Array.new(n)\n    pile.each do\
    \ |i|\n        pile[i] = i+1\n    end\n    pile.each_with_index do |i, index|\n\
    \        pile[index] = i+1 if i%2 == 1\n        pile[index] = i+1 if i%2 == 0\n\
    \    end\n    pile\nend", "  if n % 2 != 0\n    1.upto(Math.sqrt(n), &:odd?)\n\
    \  else\n    1.upto(Math.sqrt(n), &:even?)\n  end\nend\n</code>\n<|/ a |>\n<|\
    \ a tags=ruby |>\n<code>", "    count = []\n    count.push(n)\n    i =(n%2) ?\
    \ (n+1) : (n-1)\n    count.push(i)\n    count.push(n - i)\n    count.push(n -\
    \ 2*i)\n    count.push(n - 3*i)\n    count.push(n - 4*i)\n    count.push(n - 5*i)\n\
    \    count.push(n - 6*i)\n    count.push(n - 7*i)\n    count.push(n - 8*i)\n \
    \   count.push(n - 9*i)\n    count.push(n - 10*i)\n    count.push(n - 11*i)\n\
    \    count.push(n - 12*i)\n    count.push(n - 13*i)\n    count.push(n - 14*i)\n\
    \    count.push(n - 15*i)\n    count.push(n - 16*i)\n    count.push(n - 17*i)\n\
    \    count.push(n - 18*i)\n    count.push(n - 19*i)\n    count.push(n - 20*i)\n\
    \    count.push(n - 21*i)\n    count.push(n - 22*i)\n    count.push(n - 23*i)\n\
    \    count.push(n - 24*i)\n    count.push(n - 25*i)\n    count.push(n - 26*i)\n\
    \    count.push(n - 27*i)\n    count.push(n - 28*i)\n    count.push(n - 29*i)\n\
    \    count.push(n - 30*i)\n    count.push(n - 31*i)\n    count.push(n - 32*i)\n\
    \    count.push(n - 33*i)\n    count.push(n - 34*i)\n    count.push(n - 35*i)\n\
    \    count.push(n - 36*i)\n    count.push(n - 37*i)\n    count.push(n - 38*i)\n\
    \    count.push(n - 39*i)\n    count.push(n - 40*i)\n    count.push(n - 41*i)\n\
    \    count.push(n - 42*i)\n    count.push(n - 43*i)\n    count.push(n - 44*i)\n\
    \    count.push(n - 45*i)\n    count.push(n - 46*i)\n    count.push(n - 47*i)\n\
    \    count.push(n - 48*i)\n    count.push(n - 49*i)\n    count.push(n - 50*i)\n\
    \    count.push(n - 51*i)\n    count.push(n - 52*i)\n    count.push(n - 53*i)\n\
    \    count.push(n - 54*i)\n    count.push(n - 55*i)\n    count.push(n - 56*i)\n\
    \    count.push(n - 57*i)\n    count.push(n - 58*i)\n    count.push(n - 59*i)\n\
    \    count.push(n - 60*i)\n    count.push(n - 61*i)\n    count.push(n - 62", " \
    \ (0..n)\n    .map { |n| n == 0 ? 1 : n & 1 == 0 ? n + 2 : n + 4 }\n    .inject\
    \ { |sum, num| sum + num }\nend\n</code>\n<|/ a tags=math,ruby,algorithm |>\n\
    <| c |>\nI thought of doing it with an array, but that's an approach I wouldn't\
    \ be too happy with. Sure it's more readable, I'm not a big fan of array operations.\n\
    <|/ c |>\n<| a dscore=2 tags=math,ruby,algorithm |>\nYou can do this with Array#each_cons.\n\
    <code>", "  return n.times.map {|i| i+1 if i.odd? else i+2}\nend", "  i = 0\n\
    \  pile = [n]\n  while pile[-1] > 0\n    i += 1\n    next if n % 2 == 0\n    pile.push(pile.pop\
    \ * 2)\n    n -= 1\n  return pile\nend\n</cell>\n<code language=julia-1.1>", " \
    \ nums = []\n  n = 1\n  while n <= n\n    nums.push n % 2 == 0 ? n : n * 3 + 1\n\
    \    n += 1\n  end\n  nums\nend\n</code>\n<|/ a |>\n<| a dscore=1 tags=arrays,ruby,functional-programming\
    \ |>\n<code>", "  n = n - 1\n  a = []\n  while n > 0\n    a.push(n) \n    if n\
    \ % 2 == 0\n      a.push(n % 2)\n    end\n    n = n / 2\n  end\n  return a\nend",
  "  result = [n]\n  if n % 2 == 1\n    result.push(n % 2 * 2)\n  else\n    result.push(n\
    \ % 2 * 2)\n    result.push(n % 2 * 2)\n  return result\nend", "  count = n\n\
    \  pile = []\n  while count != 1\n    count /= 2\n    pile.push(count)\n  end\n\
    \  pile\nend", "  if n == 0 then 0\n  else if n % 2 == 0 then make_a_pile(n/2)\
    \ + [(n/2).next].next # odd\n  else make_a_pile(n/2) + [(n/2).next].next # even\n\
    end\n</cell>\n<code language=julia-1.5>", "  levels = [nil] * n\n  levels.inject((n.even?\
    \ ? 0 : -1) + n.odd? ? 1 : 0) do |level, n|\n    level.succ!\n    level\n  end\n\
    \  levels\nend", "    stones = [n]\n    pile = []\n    i = 0\n    while stones.count\
    \ != n\n        if stones.count % 2 == 1\n            pile.push stones.shift\n\
    \        else\n            pile.push stones.shift + (2*stones.count - 1)\n   \
    \     i += 1\n    end\n    return pile\nend", "    arr = [n]\n    return arr if\
    \ n%2 == 0 else arr + make_a_pile(2 * n -1)\nend\n</code>\n<|/ a dscore=0 tags=arrays,ruby,recursion\
    \ |>\n<| a dscore=0 |>\nThe below code will work for any positive number as long\
    \ as your are adding up\n<code>", "    arr = []\n    if n % 2 == 1:\n        arr\
    \ << n\n        return arr\n    arr << n << n << n << n << n << n << n << n <<\
    \ n << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n\
    \ << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n <<\
    \ n << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n\
    \ << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n <<\
    \ n << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n\
    \ << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n <<\
    \ n << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n\
    \ << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n <<\
    \ n << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n\
    \ << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n <<\
    \ n << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n\
    \ << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n <<\
    \ n << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n\
    \ << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n <<\
    \ n << n << n << n << n << n << n << n << n << n << n << n << n << n << n << n\
    \ << n << n << n << n << n << ", "    counts = Array.new(n+1, 0)\n    counts[0]\
    \ = 1\n    counts[n] = 1\n    counts[2] += 1\n    counts[n/2] += 1\n    counts[3*(n/2)]\
    \ += 1\n    counts[3*n/2] += 1\n    counts[3*(n+1)] += 1\n    counts[3*(n+2)]\
    \ += 1\n    counts[4*(n+1)] += 1\n    counts[4*(n+2)] += 1\n    counts[4*(n+3)]\
    \ += 1\n    counts[5*n] += 1\n    counts[6*n] += 1\n    counts[7*n] += 1\n   \
    \ return counts\nend", "  stones = []\n  if n % 2 == 1\n    stones << n\n  else\n\
    \    stones << n / 2\n    stones << n / 2 + n / 2\n  end\n  stones.map { |stone|\
    \ stone == 1 ? stone : stone * 2 }\nend", "    arr = []\n    if n > 0\n      \
    \  arr.push(n)\n        if n > 0\n            arr.push(n % 2)\n            if\
    \ n % 2 == 0\n                arr.push(n / 2)\n            end\n        end\n\
    \    end\n    return arr\nend\n</code>\nNow for the solution. The trick is to\
    \ realise that we want to find all subsets of our input array where the number\
    \ of stone levels is evenly divisible by 2. This can be done by counting the number\
    \ of stone levels that are divisible by 2 and dividing those by 2. If we get an\
    \ integer that is exactly divisible by 2, the answer is 2. Otherwise, if we get\
    \ an integer that does not divide evenly by 2, we add 1 to that number:\n<code>",
  "  levels = [n]\n  while n > 0\n    n -= n % 2 == 0 ? n : n + 1 \n    levels <<\
    \ n\n  end\n  levels.reverse\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    Just to add my two cents. I like some of the solutions already posted here, but\
    \ none of them seem to have addressed the OP's question: How would you do this\
    \ with nested loops?\nHere's an example solution:\n<code>", "  if n % 2 == 1\n\
    \    return [n - 1, (n / 2) + 1]\n  else\n    return [n - 1, (n / 2)]\nend", " \
    \ return [].tap do |pile|\n    if n < 2\n      return [pile]\n    end\n    pile\
    \ = [n].tap { |i| pile[i-1] = pile[i-1] % 2 }\n    pile.each_index do |i|\n  \
    \    pile[i] = pile[i] % 2 ? pile[i] - 1 : 1\n    end\n  end\nend", "  return\
    \ make_a_pile_aux(n,0).to_a\nend", "    # Write your code here.\n    num = n\n\
    \    pile = Array.new(num, n)\n    pile[0].upto(num-1, 2) do |i|\n        pile[i+1]\
    \ = pile[i+1].to_i + 1\n        pile[i+1].upto(num-1, 2) do |j|\n            pile[i+j-1]\
    \ = pile[i+j-1].to_i + 1\n        end\n    end\n    pile\nend", "  pile = []\n\
    \  while n != 0\n    pile.push(n)\n    n, n = n / 2, n % 2\n  end\n  pile\nend",
  "  levels = []\n  levels.push(n)\n  if n == 1\n    levels.push n % 2 == 0 ? 1 :\
    \ 2\n  else\n    levels.push n % 2 == 0 ? 1 : 2\n    levels.push 3 * n / 2\n \
    \   levels.push 3 * n / 2 + 1\n  levels\nend\n</cell>\n<cell>", "    pile = []\n\
    \    i = 0\n    while i < n\n        if n % 2 == 1\n            pile.push(n+1)\n\
    \            i += 2\n        else\n            pile.push(n-1)\n            i +=\
    \ 1\n    end\n    return pile\nend", "    stones = Array.new(n + 1, '1')\n   \
    \ stones.inject(0) { |memo, i| memo + i if i % 2 == 1 }\n    stones.map { |i|\
    \ stones[i+1].size if stones[i+1].size < stones[i].size }\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThe second `stones.inject(0)` should be `stones.inject(0)`?\n<|/\
    \ c |>\n<| c |>\nYes, thanks. Fixed.\n<|/ c |>\n<| a tags=ruby |>\nA solution\
    \ in Ruby:\n<code>", "  pile = []\n  for i in 0..(n-1)\n    stone = i % 2 ? i+1\
    \ : i\n    pile.push(stone)\n  end\n  return pile\nend", "  if n == 0 then\n \
    \   [1]\n  else\n    odd, even, stones = n, n+1, 0\n    if odd > even then\n \
    \     odd - even + 1\n    else\n      even - odd + 1\n    end\n    stones = [stones]\
    \ + make_a_pile(even)\n    stones = stones + make_a_pile(odd)\n  end\nend", " \
    \ pile = []\n  for i in 1..n\n    if i.odd? then\n      pile.push i.next\n   \
    \ else\n      pile.push i.next.next\n    end\n  end\n  pile\nend", "    pile =\
    \ [0, ]\n    count = 0\n    while n > 0\n        count += 1 if n % 2 == 1 else\
    \ 0\n        pile.push n\n        n -= 1 if n % 2 == 0 else 0\n    end\n    pile.reverse\n\
    \    pile\nend\n</cell>\n<code language=julia-1.0>", "  result = [n]\n  while\
    \ n > 0\n    n -= 1\n    if n & 1\n      result.push(n / 2)\n    else\n      result.push(n\
    \ * 3)\n  end\n  result\nend", "  n = [n] * n\n  n.map!{|i| i % 2 == 0 ? i + 1\
    \ : i}\n  return n.sort\nend", "  pile = [n]\n  while n > 1\n    pile = pile.push(n\
    \ % 2 == 0 ? n : n*2)\n    n = n / 2\n  end\n  pile\nend", "  arr = []\n  arr\
    \ << n\n  n.times { arr << n if n.odd? }\n  n.times { arr << n if n.even? }\n\
    \  arr\nend", "  pile = []\n  while n > 0\n    pile.push(n * 2 + 1)\n    n = n\
    \ / 2\n  end\n  return pile\nend", "  if n<0 then\n    return nil\n  else\n  \
    \  return [nil, 2*n+1, 3*n+2, 4*n+3, 5*n+4, 6*n+5, 7*n+6]\n  end\nend\n</cell>\n\
    <text>\nExercise (Backwards)\nThe pile of 1 stone has 1 empty space, the pile\
    \ of 2 has 1 empty space, 2 empty spaces and the pile of 3 has 1 empty space.\n\
    What is the minimum number of levels required to make 100 stones?", "  a = []\n\
    \  while n>1\n    if n % 2 == 1\n      a.push(n/2)\n      n = n-2\n    else\n\
    \      a.push(n%2)\n      n = n-1\n  end\n  a\nend", "  result = []\n  for i in\
    \ 0...n\n    if n % 2 == 1\n      result << i + 1\n    else\n      result << n\
    \ / 2\n    end\n  end\n  result\nend", "    stones = 0\n    pile = [stones]\n\
    \    while n > 0\n        if n % 2 == 0\n            stones += 2\n           \
    \ pile.push(stones)\n        else\n            stones += 3\n            pile.push(stones)\n\
    \            n -= 1\n        end\n    end\n    pile\nend", "  levels = []\n  stones\
    \ = n\n  levels << stones\n  while stones % 2 == 0\n    stones /= 2\n    levels\
    \ << stones\n  levels << stones\n  levels.uniq!\n  levels\nend\n</pre>\n<p>\n\
    <details><summary>Solution</summary>\n<pre>", "  \n  pile = [n]\n  for i in 1...n\n\
    \  \n    if i % 2 == 1\n      pile.push(n % 2)\n      n /= 2\n    elsif i % 2\
    \ != 1\n      pile.push(n * 2)\n      n /= 2\n    end\n  end\n  \n  return pile\n\
    end", "  levels = []\n  while n > 0\n    levels << n if n.odd? else n\n    n +=\
    \ (n % 2 == 0) ? 1 : 2\n  end\n  levels << n if n.odd? && n != 0\n  return levels\n\
    end", "    # your code here\n    p = [0 for _ in range(n+1)]\n    p[1] = 1\n \
    \   p[2] = 1", "  return [].tap do |res|\n    res << n if n % 2 == 1\n    res\
    \ << n if n % 2 == 0\n    res\n  end\nend", "  stones = Array.new(1..n, 0)\n \
    \ while stones[0] < n\n    stones.shift\n    stones.unshift ((n+2).odd? ? stones.shift\
    \ : stones.shift)\n  end\n  stones.compact!\n  stones\nend\n</code>\nI tried to\
    \ keep my solution as simple as possible, with the main focus on the main loop.\
    \ \nMy initial idea was to have a counter that would count the iterations. However,\
    \ I ended up with O(n^2) complexity. \nThen, I noticed that if we had some knowledge\
    \ about the problem, we can refactor our code into O(n) complexity by only considering\
    \ the odd numbers. \nI came up with this:\n<code>", "    levels = []\n    if n\
    \ % 2 == 0\n        levels = [n]\n    else\n        levels = [n, 2 * n - 1]\n\
    \    n = 1\n    while n < levels[-1]\n        levels.append(2 * levels[-1] - levels[-2])\n\
    \        n += 1\n    return levels\nend\n</cell>\n<code language=julia-1.0>\n\
    make_a_pile(5)\n</cell>\n<code language=julia-1.0>", "  a = Array.new(n)\n  n.times\
    \ do |i|\n    a[i] = i % 2 ? i.succ : i.next\n  end\n  a\nend", "  levels = []\n\
    \  loop do\n    levels << rand(1..n)\n    n = (n+1) % 2\n  end\n  levels\nend",
  "  arr = Array.new(n) { Array.new(0) }\n  arr[0][0] = 1\n  for i in 1..n\n    arr[i-1][i\
    \ % 2 == 0] += 1\n  end\n  arr\nend", "  list = Array.new\n  if n == 2 || n ==\
    \ 3 then return [n]\n  list = Array.new\n  for i in 1..n do\n    next if i % 2\
    \ == 1\n    next if i % 3 == 0\n    list[i] = n\n  end\n  list\nend", "  a = Array.new(2*n)\n\
    \  \n  # first level\n  a[1] = 1\n  \n  # second level\n  if n % 2 == 0\n    a[2]\
    \ = 1\n  else\n    a[2] = 0\n  end\n  \n  # third level\n  a[4] = 1\n  \n  # fourth\
    \ level\n  if n % 4 == 0\n    a[6] = 1\n  else\n    a[6] = 0\n  end\n  \n  a\n\
    end", "  # Your code here\n  result = []\n  i = 0\n  while i < n do\n    if n.odd?\n\
    \      result[i] = (n.odd? ? n.odd+1 : n.even?) ? n.odd+1 : n.even?\n    else\n\
    \      result[i] = (n.even? ? n.even+1 : n.odd?) ? n.even+1 : n.odd?\n    end\n\
    \    i += 1\n  end\n  result\nend", "  total = [0, nil, nil]\n  n.times { total\
    \ = [total[0] + 1, total[2] + 1 if n.odd? && total[2] <= n || n.even? && total[1]\
    \ < n ? total[1] : nil, total[0] + n <= n ? total[0] + n : nil] }\n  total\nend\n\
    </code>\n<|/ a |>\n<| c |>\nNice solution. Although it is not the most performant\
    \ way, it's pretty cool. One thing to note is that this solution will perform\
    \ `n` function calls. Which is why I upvoted it, but I'm afraid it will perform\
    \ better than the others.\n<|/ c |>\n<| a tags=ruby,algorithm |>\n<code>", " \
    \ if n == 0\n    []\n  elsif n % 2 == 1\n    [n+1, n/2]\n  elsif n % 2 != 1\n\
    \    [n/2]\n  end\nend\n</code>\n<|/ a tags=ruby,algorithm,data-structures dscore=4\
    \ |>\n<| a dscore=4 tags=ruby,algorithm,data-structures |>\nMy answer is a bit\
    \ different.\n<code>", "  num_stones = Array.new(n+1)\n  num_stones[0] = n\n \
    \ num_stones[1] = 0\n  num_stones[n] = 1\n  pile = num_stones.slice!(0..n).sort_by(&:first).reverse\n\
    \  pile.each_with_index do |level,i|\n    level[i] += 1\n  end\n  return pile\n\
    end", "  pile = [n]\n  if n%2 == 0\n    pile.push(2*n + ((n+1)/2))\n  end\n  return\
    \ pile\nend", "  # TODO: implement me\nend", "  pile = [n]\n  pile.each {|x| x\
    \ = 2*x + 1 ; pile.push(x)}\n  pile\nend", "  pile = []\n  (n - (n&1)) + 1.times\
    \ { pile.push(n - (n&1)) }\n  pile.push(n+1)\nend", "  n = n % 2 + 1\n  stones\
    \ = [n]\n  while n > 1\n    n -= 2 if n % 2 == 0\n    stones << n\n  end\n  stones\n\
    end", "  if n == 0 then\n    return [0]\n  end\n  s = make_a_pile(n-1)\n  if n\
    \ % 2 == 1 then\n    s[2] = s[2] = s[1]\n    s[1] = 0\n  end\n  return s\nend",
  "    levels = []\n    level = [n]\n    i =  0\n    while level.length < n\n    \
    \    i += 1\n        if i==1\n            level.push (2*i+1)\n        end\n  \
    \      if i%2 == 1\n            level.push (2*i+1)\n        else\n           \
    \ level.push (2*i)\n        end\n    end\n    levels.push (level.last)\n    return\
    \ levels\nend", "  a = Array.new(n) do |i|\n    i = i + 1 if i&1\n    i = i +\
    \ 1 if i&2\n    i\n  end\n  a\nend", "    num = n || 0\n    odd = num % 2 || 0\n\
    \    num = (num - odd) / 2 || 0\n    num = (num - even) / 2 || 0\n    return [num]\n\
    end", "  if n > 0\n    make_a_pile(n % 2)\n    pile.push(n) if n % 2 == 0\n  \
    \  pile = pile.concat(make_a_pile(n % 2))\n  end\n  pile\nend\nputs make_a_pile(3)",
  "  even = 0\n  odd = 0\n  result = []\n  if n % 2 == 0\n    even = make_a_pile(n/2)\n\
    \  end\n  if n % 2 != 0\n    odd = make_a_pile(n/2)\n  end\n  result.push(odd\
    \ + even)\n  result.push(odd + even)\n  if n % 2 != 0\n    result.push(odd + even)\n\
    \  end\n  return result\nend", "  a = []\n  i = 0\n  while i < n\n    a.push i\
    \ % 2 ? i : i + 2\n    i += 1\n  end\n  a\nend\n</pre>\n</div>\n</div>\n</div>\n\
    </div>\n</div>\n<hr>\n<ul>\n<li><a href=\"http://gigamonkeys.com/book/\"><img\
    \ src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/GigamonkeysLogoBrightContrast.svg/200px-GigamonkeysLogoBrightContrast.svg.png\"\
    \ height=40 border=0></a></li>\n</ul>\n</body>\n</html>", "  result = []\n  for\
    \ i in 1..n\n    if n % 2 == 1\n      result << i\n      result << i + 1\n   \
    \ else\n      result << i << 1\n    end\n  end\n  result\nend\n</pre>\n      \
    \      </div>\n          </div>\n          <div class=\"col-md-4\">\n        \
    \    <div class=\"panel panel-default\">\n              <div class=\"panel-body\"\
    >\n                <h3>A Stone Pile</h3>\n                <p>\n              \
    \    Given a positive integer n, you have to make a pile\n                  of\
    \ n levels of stones. Each level has n stones.\n                  The first level\
    \ has n stones.\n                  The number of stones in the next level is:\n\
    \                  - the next odd number if n is odd.\n                  - the\
    \ next even number if n is even.\n                  Return the number of stones\
    \ in each level in a list, where element at index\n                  i represents\
    \ the number of stones in the level (i+1).\n                  Examples:\n    \
    \              >>> make_a_pile(3)\n                  [3, 5, 7]\n             \
    \   </p>\n                <pre><code class=\"ruby\"><span class=\"ruby-keyword\"\
    >class</span> <span class=\"ruby-constant\">Pile</span>\n  <span class=\"ruby-keyword\"\
    >def</span> <span class=\"ruby-identifier\">make_a_pile</span>(n)\n    <span class=\"\
    ruby-identifier\">result</span> = []\n    <span class=\"ruby-keyword\">for</span>\
    \ <span class=\"ruby-identifier\">i</span> <span class=\"ruby-operator\">in</span>\
    \ <span class=\"ruby-keyword\">1..n</span>\n      <span class=\"ruby-keyword\"\
    >if</span> <span class=\"ruby-identifier\">n</span> <span class=\"ruby-operator\"\
    >%</span> <span class=\"ruby-value\">2</span> <span class=\"ruby-operator\">==</span>\
    \ <span class=\"ruby-value\">0</span> <span class=\"ruby-operator\">||</span>\
    \ <span class=\"ruby-identifier\">i</span> <span class=\"ruby-operator\">==</span>\
    \ <span class=\"ruby-value\">1</span>\n        <span class=\"ruby-identifier\"\
    >result</span> <span class=\"ruby-operator\">&lt;&lt;</span> <span class=\"ruby-identifier\"\
    >i</span> <span class=\"ruby-operator\">&lt;&lt;</span> <span class=\"ruby-value\"\
    >1</span>\n      <span class=\"ruby-keyword\">else</span>\n        <span class=\"\
    ruby-identifier\">result</span> <span class=\"ruby-operator\">&lt;&lt;</span>\
    \ <span class=\"ruby-identifier\">i</span> <span class=\"ruby-operator\">&lt;&lt;</span>\
    \ <span class=\"ruby-identifier\">i</span> <span class=\"ruby-operator\">&lt;&lt;</span>\
    \ <span class=\"ruby-value\">1</span>\n      <span class=\"ruby-keyword\">end</span>\n\
    \    <span class=\"ruby-keyword\">end</span>\n    <span class=\"ruby-identifier\"\
    >result</span>\n  <span class=\"ruby-keyword\">end</span>\n<span class=\"ruby-keyword\"\
    >end</span>", "    arr = Array.new\n    if n%2 == 0 then\n        arr[1] = n\n\
    \        arr[2] = n+1\n        arr[3] = n+2\n    else\n        arr[1] = n\n  \
    \      arr[2] = n-1\n        arr[3] = n-2\n    end\n    return arr\nend", "  ret\
    \ = []\n  n.times do |i|\n    if i.odd?\n      ret << i.next\n    else\n     \
    \ ret << i.next/2\n    end\n  end\n  ret\nend", "  return [n % 2 == 0 ? n : (n+1),\
    \ (n + ((n/2).floor)).floor.ceil]\nend\np make_a_pile(4)", "    stones = Array.new(2*n-1,\
    \ 0)\n    stones.each_index do |i|\n        stones[i+1] = (n+i).odd? ? i : (2*i-1).even?\
    \ ? i : i+1\n    end\n    stones\nend\n</code>\n<|/ a |>\n<| a tags=ruby,loops,arrays\
    \ |>\nThis isn't a Ruby question -- it's just an algorithmic question.  It's simple\
    \ enough to understand that you can solve it just with a for loop and a counter.\
    \  Here's a simple way to solve it:\n<code>", "  # Your code here\n  return make_pile(n)\n\
    end\n</cell>\n<code language=julia-1.5>", "  if n == 0\n    [ ]\n  else\n    p\
    \ =  make_a_pile(n-1)\n    if n&1\n      p << n-1\n    else\n      p << n\n  \
    \  end\n    p\n  end\nend", "  pile = []\n  pile.push(n) while n > 1\n  pile.each\
    \ do |i|\n    pile.push(i * 2 if i.odd?)\n    pile.push(i * 3 if i.even?)\n  end\n\
    \  pile\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\nHaha, I actually\
    \ posted this question after coming up with a similar solution. I'm very grateful\
    \ for your solution, thank you!\n<|/ c |>\n<| a tags=ruby,algorithm |>\nThe answer\
    \ is given by Clark Hall. \nLet me first explain how it works before answering\
    \ your question.\nThe first step was to build a pile of n rows with n stones,\
    \ where each row is a pile of stones.\nThis was easy. You just created a pile\
    \ of n rows and placed n stones in each row.\nThe next step is to make each row\
    \ two rows - one with an odd number of stones and one with an even number of stones.\n\
    This can be done by creating two pile of n stones, one with n stones and one with\
    \ n/2 stones.\nThen, we add these two pile of n stones together, and we get two\
    \ pile of n/4 stones.\nThe same process will give us n pile of n/8 stones.\nFinally,\
    \ the process will repeat n times, thus making a pile of n rows.\nHere is the\
    \ code:\n<code>", "    level = []\n    while n > 0\n        if n % 2\n       \
    \     level += [n/2]\n            n /= 2\n        else\n            level += [n/2+1]\n\
    \            n /= 2\n        end\n    end\n    level\nend\n</cell>\n<code language=julia-1.5>",
  "    pile = [n]\n    for x in range(1, n+1)\n        if x % 2 == 0\n           \
    \ pile.push (x * 2)\n        else \n            pile.push (x * 3)\n          \
    \  pile.push (x * 4)\n    return pile\nend", "  return [n % 2 == 0 ? 1 : 0, n\
    \ % 2 == 0 ? 0 : 1][n]\nend", "  pile = [n]\n  if n == 0 then return pile\n  while\
    \ n > 0\n    if n % 2 == 0\n      pile.push(n / 2)\n    else\n      pile.push((n\
    \ / 2)+1)\n    n = n / 2\n  return pile\nend", "  levels = []\n  for i in 0...n\n\
    \    level = make_a_level(i)\n    levels.push level\n  end\n  return levels\n\
    end", "  result = [n]\n  for i in 1..n\n    result.push(i*2 + i%2 == 0 ? i*2 :\
    \ (i*2 + i%2)-1)\n  end\n  result\nend\nputs make_a_pile(10)", "  result = [n]\n\
    \  for i in 1..n\n    if i % 2 == 1\n      result << (i + 1)\n    else\n     \
    \ result << (i + 2)\n  end\n  result\nend\n</cell>\n<cell>\n@test make_a_pile(3)\
    \ == [3, 5, 7]\n@test make_a_pile(10) == [10, 14, 21, 35, 52, 70, 90, 135, 170,\
    \ 213]\n@test make_a_pile(11) == [11, 15, 21, 35, 52, 65, 91, 125, 150, 175, 221,\
    \ 265]\n@test make_a_pile(12) == [12, 11, 16, 23, 36, 51, 72, 92, 126, 152, 187,\
    \ 231, 266, 310, 365]\n@test make_a_pile(13) == [13, 12, 14, 22, 37, 53, 73, 93,\
    \ 127, 153, 191, 236, 271, 313, 376, 410]\n</cell>\n<text>\nLet's write a few\
    \ helpers to deal with piles.", "  result = []\n  i = 0\n  while i < n\n    i\
    \ += 2\n    result << i if i.odd? else i\n  end\n  result\nend", "    # Your code\
    \ here\n    pile = [n]\n    for i in range(1, n):\n        if n % 2 == 0:\n  \
    \          pile.append(pile[i-1] + 1)\n        else:\n            pile.append(pile[i-1]\
    \ + 2)\n    return pile\n</code>\n<|/ a tags=python |>\n<| c |>\nThis does not\
    \ work in all cases. Please look at this example: `make_a_pile(17)` --> `[17,\
    \ 25, 37, 51, 67, 83, 99, 117, 135, 161, 189, 207, 233, 251]`. This is different\
    \ than `[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29]`.\n<|/ c |>\n\
    <| c |>\n, thank you for pointing this out! I edited the answer accordingly.\n\
    <|/ c |>\n<| c |>\nWhat if n=0 ?\n<|/ c |>\n<| c |>\n, thanks for pointing that\
    \ out! I edited the answer accordingly.\n<|/ c |>\n<| a tags=python |>\nA solution\
    \ without using any extra functions and without using any extra variables:\n<code>",
  "  stone_count = 1\n  return [stone_count] * n\nend", "  return [n % 2] + [n % 2\
    \ ? (n / 2) + 1 : n / 2]\nend\n</cell>\n<code language=julia-1.5>", "\ta = []\n\
    \tfor i in 1..n\n\t\ta << n % 2 == 0 ? i : 3*i\n\t\tn /= 2\n\treturn a\nend",
  "  return make_levels(n, n % 2 == 0) << 1\nend", "  return (0..n - 1).to_a.select\
    \ {|i| (i%2).zero? }.map {|i| (i + (n+1)**0.5).floor}\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI tried to understand the code but there are two things I don't\
    \ understand. First, I think that n+1 should be replaced by (n+1)**0.5. I tried\
    \ it, and the code seems to work. I also tried the other version that includes\
    \ n**0.5 but the code returns wrong answer for n=3.\n<|/ c |>\n<| c |>\nI guess\
    \ that is the \"floor\" part, where I thought I needed to round down but somehow\
    \ I got it wrong. I'm a beginner and I guess that the code above was really just\
    \ a proof of concept. I'll try to understand the code more carefully later.\n\
    <|/ c |>\n<| c |>\n`(n+1)**0.5` should be `(n+1)**0.55`\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby |>\n<code>", "  num_list = [n]\n  while n != 1\n    next_odd_n = (n\
    \ + 1).odd?\n    next_even_n = (n + 1).even?\n    num_list << next_odd_n << next_even_n\n\
    \    n -= 1\n  end\n  num_list\nend", "    levels = []\n    pile = []\n    i =\
    \ 0\n    while n > 0\n        if n%2 == 0\n            levels[i] = n\n       \
    \     pile[i] = 1\n            i += 1\n            n = 1\n            i += 1\n\
    \            n -= 1\n        else \n            pile[i] = levels[i-1] + pile[i-1]\n\
    \            i += 1\n            n = 1\n            i += 1\n            n -= 1\n\
    \    levels.reverse()\n    pile.reverse()\n    return levels\nprint(make_a_pile(3))",
  "  n.times {|i| puts i + 1 if n.odd? }\n  n.times {|i| puts i + 2 if n.even? }\n\
    end", "  return Array.new(2*n+1) do |i|\n    i % 2 == 0 ? n : (n+1).next\n  end\n\
    end", "  pile = Array.new(Integer(n))\n  pile.push(Integer(n)) # push the initial\
    \ amount of stones\n  for i in 0...Integer(n).even?\n    pile.push(Integer(pile[i]\
    \ + Integer(i).odd? ? 2 : 1))\n  end\n  pile\nend", "  pile = []\n  pile.push(n)\
    \ if n.odd? then pile.push(n.odd?)\n  pile.push(n) if n.even? then pile.push(n.even?)\n\
    \  pile.each_index do |i|\n    pile[i] = pile[i+1] if pile[i] != nil && pile[i]\
    \ > 0\n  end\n  pile\nend\n</code>\nThis is an efficient way to perform the task\
    \ in O(n) time.\n<|/ a tags=ruby |>\n<| c |>\nThis code doesn't do what you expect\
    \ it to. For example, `make_a_pile(5)` will generate `[5, 3, 1]`. The correct\
    \ answer is `[5, 7, 1]`\n<|/ c |>\n<| c |>\nYou are correct! I didn't notice this\
    \ error until after I posted it. I corrected the code as you suggested and have\
    \ tested the code now.\n<|/ c |>\n<| a tags=ruby |>\nYou don't even need to do\
    \ all that messiness with pushing to an array\n<code>", "  result = []\n  for\
    \ i in (0..n).step(2) { result << i }\n  result\nend", "    pile = []\n    while\
    \ n > 0\n        if n % 2 == 1\n            pile.push(n-1)\n            n = (n+2)\
    \ / 2\n        else\n            pile.push(n % 2)\n            n = n / 2\n   \
    \ end\n    pile\nend", "    pile = [n]\n    pile[0] = pile[1] = n\n    if n %\
    \ 2 == 1\n        pile[2] = pile[-1] = 2*(n-1)\n        pile[0] -= 2\n    elsif\
    \ n % 2 == 0\n        pile[2] += n-1\n        pile[1] -= 2*(n-1)\n        pile[0]\
    \ -= 2*(n-1)\n    return pile\nend\n</cell>\n<code language=julia-1.5>", "   \
    \ pile = []\n    number = 1\n    i = 2\n    while i <= n\n        if i % 2 ==\
    \ 0\n            pile[i] = number\n            number = number + 1\n        else\
    \ # if i is odd\n            pile[i] = number - number\n            number = number\
    \ + 1\n        i = i + 1\n    return pile", "  r = []\n  for i in (1..n).to_a\n\
    \    if n % 2 == 0\n      r.push(i + 1)\n    else\n      r.push(i + 2)\n  end\n\
    \  r\nend", "  # Add your code here\n  count = [1,3,5]\n  while n > 1\n    if\
    \ n % 2 == 0\n      count << count[1]\n      n = n/2\n      count[1] = count[1]+1\n\
    \    else \n      count << count[2]\n      n = n/2\n      count[2] = count[2]+1\n\
    \  end\n  return count\nend", "  arr = []\n  for i in 1..n\n    if n%2 == 1\n\
    \      arr[i] = n//2 + 1\n    else\n      arr[i] = n//2\n  end\n  return arr\n\
    end", "    count = []\n    count[i] = 1\n    if n % 2 == 0\n        count[i/2]\
    \ = n / 2\n    else \n        count[i/2+1] = n / 2\n    i += 1\n    return count\n\
    end", "  level = []\n  if n % 2 == 1\n    n = n + 1\n    level = [n]\n  end\n\
    \  i = 0\n  while i < n\n    i = i + 1\n    next_odd_or_small = n % 2 == 1 ? n\
    \ + 2 : n\n    next_even = next_odd_or_small % 2 == 0 ? next_odd_or_small - 1\
    \ : next_odd_or_small\n    level << next_even\n  end\n  level\nend", "  nums =\
    \ Array.new(n)\n  nums.fill(n*2)\n  nums.each.with_index do |value, i|\n    if\
    \ i % 2 == 0\n      nums[i] = value + 1\n    else\n      nums[i] = value - 1\n\
    \    end\n  end\n  return nums\nend", "  pile = []\n  pile.push n if n.odd?\n\
    \  pile.push n.even? ? n : n.odd? ? n.ceil : n.floor\n  n.times do\n    pile.push\
    \ pile.pop + 1 unless pile.pop.odd?\n  end\n  pile\nend", "  num = []\n  for i\
    \ in (1..n).to_a\n    if n % 2 == 1\n      num << num.last + 2\n    else \n  \
    \    num << num.last + 1\n  end\n  num\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ is very clever. I didn't think of using .last like that.\n<|/ c |>\n<| c |>\n\
    This code works perfectly. One thing I wanted to clarify is why does this work?\
    \ I don't quite understand the logic behind why this is necessary for the code\
    \ to work. I'm fairly new to Ruby so I do appreciate any help that you can provide.\n\
    <|/ c |>\n<| c |>\nIt works by using the fact that in Ruby, arrays are objects.\
    \ When you call `<<` on something, you are effectively doing `@array.push(something)`.\n\
    <|/ c |>\n<| c |>\nI see, that makes sense. I tried something similar but I had\
    \ just pushed a variable and I was getting the same result. The method pushes\
    \ something to the end of the array. Thanks again.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  arr = [n]\n  if n > 0\n    make_a_pile(n - 1) unless n % 2 ==\
    \ 0\n    arr << n\n    make_a_pile(n + 1) unless n % 2 == 0\n    arr << n\n  end\n\
    \  arr\nend\n</code>\nNow I put this in a method in the class, which is also passed\
    \ the number of stones required as an argument.\n<code>", "  (0...n).map {|i|\
    \ (i+1).odd? ? i.odd*2 : i.even*2}.sum\nend", "  stones = []\n  n_odd = n % 2\
    \ # check if n is odd\n  n /= 2 # make n even\n  n_even = n % 2 # check if n is\
    \ even\n  n /= 2 # make n even\n  n_odd = n % 2 # check if n is odd\n  n /= 2\
    \ # make n even\n  n_even = n % 2 # check if n is even\n  n /= 2 # make n even\n\
    \  n_odd = n % 2 # check if n is odd\n  n /= 2 # make n even\n  n_even = n % 2\
    \ # check if n is even\n  n /= 2 # make n even\n  n_odd = n % 2 # check if n is\
    \ odd\n  n /= 2 # make n even\n  n_even = n % 2 # check if n is even\n  n /= 2\
    \ # make n even\n  n_odd = n % 2 # check if n is odd\n  n /= 2 # make n even\n\
    \  n_even = n % 2 # check if n is even\n  n /= 2 # make n even\n  n_odd = n %\
    \ 2 # check if n is odd\n  n /= 2 # make n even\n  n_even = n % 2 # check if n\
    \ is even\n  n /= 2 # make n even\n  n_odd = n % 2 # check if n is odd\n  n /=\
    \ 2 # make n even\n  n_even = n % 2 # check if n is even\n  n /= 2 # make n even\n\
    \  n_odd = n % 2 # check if n is odd\n  n /= 2 # make n even\n  n_even = n % 2\
    \ # check if n is even\n  n /= 2 # make n even\n  n_odd = n % 2 # check if n is\
    \ odd\n  n /= 2 # make n even\n  n_even = n % 2 # check if n is even\n  n /= 2\
    \ # make n even\n  n_odd = n % 2 # check if n is odd\n  n /= 2 # make n even\n\
    \  n_even = n % 2 # check if n is even\n  n /= 2 # make n even\n  n_odd = n %\
    \ 2 # check if n is odd\n  n /= 2 # make n even\n  n_even = n % 2 # check if n\
    \ is even\n  n /= 2 # make n even\n  n_odd = n % 2 # check if n is odd\n  n /=\
    \ 2 # make n even\n  n_even = n % 2 # check if n is even\n  n /= 2 # make n even\n\
    \  n_odd = ", "  levels = []\n  while n > 0\n    if n.odd? and levels.length ==\
    \ 0\n      levels.push n\n      n -= 2\n    elsif n.even? and levels.length ==\
    \ 0\n      levels.push n\n      n -= 2\n    elsif levels.length == 0\n      levels.push\
    \ n\n      n -= 1\n    end\n  end\n  levels\nend", "  r = []\n  r.push(n-1)\n\
    \  while r.last % 2 == 0\n    r.push(r.last+2)\n  end\n  r\nend", "  pile = Array.new(3)\
    \ { n }\n  while pile[0] == 0\n    pile.shift 2\n  end\n  pile.shift 1\n  i =\
    \ 1\n  while pile[0] > 0\n    if n % 2 == 0\n      pile[i] = pile[0] + (n - 1)\n\
    \      pile.shift 2\n    else\n      pile[i] = pile[0] + (n - 1)\n      pile.shift\
    \ 1\n    end\n    i += 1\n  end\n  pile.map { |n| n - 1 }\nend", "  # TODO: fix\
    \ this to pass tests\n  return [n + (n % 2 == 1 and n or n * 2)]\nend\n</cell>\n\
    <code language=julia-1.0>", "  return [n % 2 == 0 ? (n + 1) : (n + 2) for n in\
    \ 1..n]\nend", "  ret = []\n  i = 0\n  while n < 0\n    n += i + 1\n    i += 1\n\
    \  end\n  while i < n\n    ret = ret + [i]\n    i += 1\n  end\n  ret\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=3 |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
