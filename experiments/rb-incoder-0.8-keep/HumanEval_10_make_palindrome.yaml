name: HumanEval_10_make_palindrome
language: rb
prompt: "# Find the shortest palindrome that begins with a supplied string.\n# Algorithm\
  \ idea is simple:\n# - Find the longest postfix of supplied string that is a palindrome.\n\
  # - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n# >>> make_palindrome('')\n# ''\n# >>> make_palindrome('cat')\n\
  # 'catac'\n# >>> make_palindrome('cata')\n# 'catac'\ndef make_palindrome(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_palindrome\n\
  \    candidate = method(:make_palindrome)\n    assert_equal(\"\", candidate.call(\"\
  \"))\n    assert_equal(\"x\", candidate.call(\"x\"))\n    assert_equal(\"xyzyx\"\
  , candidate.call(\"xyz\"))\n    assert_equal(\"xyx\", candidate.call(\"xyx\"))\n\
  \    assert_equal(\"jerryrrej\", candidate.call(\"jerry\"))\n  end\nend\n"
completions: ["  longest, first = max_prefix(string.split(//))\n  puts reverse first.gsub(longest,\
    \ longest.reverse).reverse\nend", "  string.length >= 2 ? prefix_palindrome(string)\
    \ : suffix_palindrome(string)\nend", "  longest_postfix = find_longest_postfix_substr(string)\n\
    \  if longest_postfix == ''\n    string\n  else\n    string + string_reverse(longest_postfix)\n\
    \  end\nend", "  max_length = 0\n  postfix = nil", "  string.chars.reverse\n \
    \ max_len = string.chars.reverse.find { |c| string[c] == string[string.length\
    \ - c.length] }\n  prefix = string.slice(0,-max_len)\n  prefix_reversed = (prefix\
    \ + '').chars.reverse\n  postfix = string.slice(max_len+string.length)\n  postfix_reversed\
    \ = (postfix + '').chars.reverse\n  beginning_of_palindrome = (prefix_reversed+\
    \ postfix_reversed).join\n  beginning_of_palindrome\nend", "  max_length = 0\n\
    \  longest = ''", "  string = string.to_s.downcase\n  palindrome = \"\"\n  while\
    \ string.length != 0\n    prefix = string.take_prefix_of(string.last.to_s.reverse)\n\
    \    palindrome = prefix + palindrome\n    string = string.drop_while(prefix.length\
    \ != 0)\n  end\n  palindrome\nend", "  lc_string = string.downcase\n  lc_string.gsub!(/[^a-z]+/,\
    \ '')\n  prefix_string = lc_string.sub(/^[a-z]/, '')\n  prefix_string.gsub!(/[a-z]+/,\
    \ '')\n  prefix_string.gsub!(/[aeiouy]+/, '')\n  prefix_string.gsub!(/[0-9]*/,\
    \ '')\n  prefix_string.gsub!(/[a-z]/, '')\n  prefix_string.gsub!(/[A-Z]/, '')\n\
    \  prefix_string.gsub!(/[AEIOUY]/, '')\n  prefix_string.gsub!(/[^a-z]+/, '')\n\
    \  prefix_string = prefix_string.sub(/^[a-z]/, '')\n  prefix_string.gsub!(/[a-z]+/,\
    \ '')\n  prefix_string.gsub!(/[aeiouy]+/, '')\n  prefix_string.gsub!(/[0-9]*/,\
    \ '')\n  prefix_string.gsub!(/[a-z]/, '')\n  prefix_string.gsub!(/[A-Z]/, '')\n\
    \  prefix_string.gsub!(/[AEIOUY]/, '')\n  prefix_string.gsub!(/[^a-z]+/, '')\n\
    \  prefix_string = prefix_string.sub(/^[a-z]/, '')\n  prefix_string.gsub!(/[a-z]+/,\
    \ '')\n  prefix_string.gsub!(/[aeiouy]+/, '')\n  prefix_string.gsub!(/[0-9]*/,\
    \ '')\n  prefix_string.gsub!(/[a-z]/, '')\n  prefix_string.gsub!(/[A-Z]/, '')\n\
    \  prefix_string.gsub!(/[AEIOUY]/, '')\n  prefix_string.gsub!(/[^a-z]+/, '')\n\
    \  prefix_string = prefix_string.sub(/^[a-z]/, '')\n  prefix_string.gsub!(/[a-z]+/,\
    \ '')\n  prefix_string.gsub!(/[aeiouy]+/, '')\n  prefix_string.gsub!(/[0-9]*/,\
    \ '')\n  prefix_string.gsub!(/[a-z]/, '')\n  prefix_string.gsub!(/[A-Z]/, '')\n\
    \  prefix_string.gsub!(/[AEIOUY]/, '')\n  prefix_string.gsub!(/[^a-z]+/, '')\n\
    \  prefix_string = prefix_string.sub(/^[a-z]/, '')\n  prefix_string.gsub!(/[a-z]+/,\
    \ '')\n  prefix_string.gsub!(/[aeiouy]+/, '')\n  prefix_string.gsub!(/[0-9]*/,\
    \ '')\n  prefix_string.gsub!(/[a-z]/, '')\n  prefix_string.gsub!(/[A-Z]/, '')\n\
    \  prefix_string.gsub!(/[AEIOUY]/, '')\n  prefix_string.gsub!(/", "  max_postfix\
    \ = find_longest_postfix_that_is_palindrome(string)\n  new_string = string.sub(max_postfix,\
    \ -max_postfix).reverse\n  new_string << max_postfix\n  return new_string\nend",
  "  max_length = 0\n  prefix_length = 0\n  string_length = string.length\n  reversed_string\
    \ = string.dup\n  while true\n    max_length = max_length ? max_length : string_length\n\
    \    if max_length < string_length - prefix_length\n      return nil if max_length\
    \ == 0\n      break\n    end\n    prefix_length = 0\n    while true\n      prefix_length\
    \ = prefix_length ? prefix_length : string_length - max_length\n      if prefix_length\
    \ <= 0\n        prefix_length = string_length - max_length\n      end\n      break\
    \ if prefix_length < max_length\n      prefix_length += 1\n    end\n    prefix_length\
    \ = max_length - prefix_length\n    reversed_string = reversed_string[0,prefix_length..-1]\
    \ + reversed_string[prefix_length..-1]\n  end\nend\n</code>\n<|/ a tags=ruby,string\
    \ dscore=1 |>\n<| a tags=ruby,string |>\n<code>", "  suffixes = string.scan(/[a-z]/)\n\
    \  suffixes.each {|suffix|\n    if suffix.is_a?(String)\n      palindrome = suffix.reverse\n\
    \      string.insert(string.size - suffix.size, palindrome)\n    end\n  }\n  return\
    \ string\nend", "  palindrome_length = 0\n  string.split(//).reverse.each do |letter|\n\
    \    # Add letter to palindrome and increment length\n    palindrome_length =\
    \ palindrome_length + letter.length\n  end\n  \n  start_index = 0\n  \n  while\
    \ string[start_index]\n    # Add letter to the palindrome and increment start\
    \ index\n    palindrome_length = palindrome_length + string[start_index].length\n\
    \    start_index = start_index + string[start_index].length\n  end\n  \n  \n \
    \ # Create a string of length 1 more than the longest postfix of string that is\
    \ a palindrome\n  palindrome = string[0...palindrome_length]\n  \n  # Add reverse\
    \ of string prefix before the palindromic suffix\n  palindrome = palindrome +\
    \ string.slice(start_index..-1)\n  \n  \n  return palindrome\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThank you very much for sharing your code. I implemented it in\
    \ my ruby code and it works perfectly fine. Although I cannot get the second case\
    \ to work. I get 'aa' instead of 'abac'.\n<|/ c |>\n<| c |>\nAh yes. I must have\
    \ misread the question. I thought you wanted to reverse the entire string instead\
    \ of just the prefix. I'll edit my answer.\n<|/ c |>\n<| c |>\nThanks for your\
    \ edit. It works now.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  string.split(\"\
    \").each_with_object(\"\") do |char, i|\n    i += 1 if char == char.downcase\n\
    \    (char == char.downcase && i > 0) && (i -= 1) if i == string.rindex(char)\n\
    \    string.insert(i, char)\n  end\nend", "  string.reverse\n  prefix = string.slice!(0...(string.length\
    \ - 1).reverse.length)\n  string << prefix[1..-1].reverse\nend", "  beginning_palindrome\
    \ = find_palindrome(string)\n  beginning_palindrome_with_middle = find_palindrome(string[beginning_palindrome.length..-1])\n\
    \  beginning_palindrome_with_middle_as_string = beginning_palindrome_with_middle.to_s\n\
    \  beginning_palindrome_with_middle_as_string + beginning_palindrome + string[beginning_palindrome.length..-1]\n\
    end", "  reverse_string = ''\n  last_char = nil\n  string = string.downcase\n\
    \  string.each_char do |char|\n    if char == last_char\n      reverse_string\
    \ << char\n      last_char = nil\n    else\n      last_char = char\n    end\n\
    \  end\n  reverse_string << string.slice!(0...-1)\n  string.length.times.reduce(reverse_string)\
    \ do |suffix, n|\n    suffix << reverse_string.slice!(0...n)\n  end\nend\n</code>\n\
    <|/ a dscore=4 tags=ruby |>\n<| a dscore=3 |>\n<code>", "  max_length = (string.length\
    \ * 2) - string.length\n  string_to_reverse = string.reverse\n  string_to_reverse.slice!(max_length)\n\
    \  string_to_reverse << string\n  string_to_reverse.reverse!\n  return string_to_reverse\n\
    end", "  longest = find_longest_palindrome(string)\n  suffix  = string[longest.begin..-1]\n\
    \  prefix  = string[0..longest.begin-1]\n  reverse_suffix  = reverse(suffix)\n\
    \  reverse_prefix  = reverse(prefix)\n  string.insert(longest.end+1, reverse_suffix)\
    \ \n  string.insert(longest.end+1, reverse_prefix) \n  string\nend\n</code>\n\
    Now we can use this to get the best palindrome in the entire string of strings:\n\
    <code>", "  length          = string.length\n  palindrome      = ''\n  reverse_string\
    \  = ''", "  string = string.to_s\n  longest = string.length\n  prefix = ''\n\
    \  for i in 0...longest\n    suffix =string[(i+1):].gsub(/\\w+/) { |s| s.reverse\
    \ }\n    if suffix.to_s.eql?(string)\n      prefix << suffix\n      break\n  \
    \  end\n  end\n  if prefix == ''\n    return string.gsub(/\\w+/) { |s| s.reverse\
    \ }\n  else\n    prefix << string.gsub(/\\w+/) { |s| s.reverse }\n  end\nend",
  "  string.reverse!\n  if string.empty?\n    string\n  else\n    find_suffix_palindrome(string,\
    \ 0)\n  end\nend", "  return string + reverse(string)\nend\n</code>\nI then decided\
    \ to use the string method reverse to do the string reverse in ruby, but the reverse\
    \ method returns an Array, so I converted it into a String using join. \nI then\
    \ created a variable that takes the length of the string passed into the function\
    \ and uses the join method to reverse the string. \nThe method then returns the\
    \ variable with the reversed string appended.\n<code>\npalindrome = make_palindrome(\"\
    hello\")\n</code>\nThe variable palindrome now contains the reverse of hello and\
    \ can be checked as follows:\n<code>\npalindrome.length #=> 6\npalindrome\n  #=>\
    \ #<String:0x007fa0d34f15f0=\"hellodcba\">\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nThis doesn't answer the question. The OP was asking how to implement `reverse`,\
    \ not how it works.\n<|/ c |>\n<| c |>\nYes I realise that but I thought it would\
    \ be helpful for the OP to learn how it works rather than how to implement it.\
    \ I've edited my answer to make it clearer.\n<|/ c |>\n<| c |>\nThe question was\
    \ how to use `reverse`, not how to write `reverse`. Your answer is still wrong.\n\
    <|/ c |>\n<| c |>\nI thought it would be helpful for OP to learn how `reverse`\
    \ works. My answer is now updated to show how to use `reverse`.\n<|/ c |>\n<|\
    \ a tags=ruby dscore=2 |>\nIn ruby 1.8, there is a reverse method that works on\
    \ the string. \n<code>\n\"hello\".reverse\n</code>\n<|/ a |>\n<| c |>\nThis is\
    \ only valid for ruby versions >= 1.8.7\n<|/ c |>\n<| a tags=ruby dscore=2 |>\n\
    As an alternative to reverse, you may use the substr method with negative start\
    \ index for negative indices and positive ones for positive ones.\n<code>", " \
    \ longest = \"\"\n  longest = string.gsub(/(?<=\\w)(?=\\w)/) { $& + reverse $&}\n\
    \  longest += \"#\" + reverse(string.split(\"\").reverse.join)\n  return longest\n\
    end\n</pre>", "  return string.length == 0 ? string : string + make_palindrome(string.reverse)\n\
    end\n</cell>\n<code language=julia-1.5>", "  max_length = 0\n  postfix = []\n\
    \  i = 0\n  while i < string.length\n    postfix << string[i]\n    i += 1\n  \
    \  if string[i] != string[string.length -1 -i]\n      max_length += 1\n    end\n\
    \  end\n  if max_length == 0\n    return string\n  end\n  postfix.reverse!\n \
    \ return string + postfix.join\nend", "  return string + \"#\" + string.chars.reverse.last\n\
    end", "  longest = find_longest_palindrome(string)\n  return longest + string.reverse(longest.size)\n\
    end", "  string.reverse.insert(0, string.slice(0,string.length).reverse)\n  string\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for empty strings: http://rubular.com/r/YZ5t8yqsRu\n\
    <|/ c |>\n<| c |>\nI see what you mean. Let me rework it.\n<|/ c |>\n<| c |>\n\
    This is not working with empty strings :( the output will be \"a\" and it is wrong,\
    \ since it is not an empty string.\n<|/ c |>\n<| c |>\nThis doesn't work with\
    \ empty strings: http://rubular.com/r/zFZPkC1vJk\n<|/ c |>\n<| c |>\n: That is\
    \ because your program returns an empty string. The function should return an\
    \ empty string when the input is empty.\n<|/ c |>\n<| a tags=ruby,string,palindrome\
    \ |>\nThis is my first time answering here, so I apologize if I make a mistake.\n\
    I realized that my solution was not the most efficient, so I wrote this in Python,\
    \ using string slicing and some itertools. I don't know Ruby, so I converted it\
    \ back to Ruby.\n<code>", "  beginning_palindromic_rev = string\n  longest_postfix_idx\
    \ = -1\n  longest_postfix_len = 0\n  i = 0\n  while i < string.length\n    j =\
    \ i\n    i += 1\n    while i < string.length and string[i] == string[j]\n    \
    \  i += 1\n    if i == j\n      beginning_palindromic_rev += string[j]\n     \
    \ longest_postfix_idx = j\n      longest_postfix_len = i - j + 1\n      break\n\
    \    end\n  end\n  if longest_postfix_len > 1\n    postfix_str = string[-longest_postfix_len..-1]\n\
    \    beginning_palindromic_rev << reverseString(postfix_str)\n  end\n  return\
    \ beginning_palindromic_rev\nend", "  longest = ''\n  longest.length = 0\n  longest.prepend(0)\n\
    \  longest_postfixes = make_postfix_list(string, longest.length)\n  longest_postfix_to_append\
    \ = ''\n  longest_postfix_to_prepend = ''\n  longest_postfix_to_append.reverse\n\
    \  longest_postfix_to_prepend.reverse\n  \n  longest_postfix_to_append.each do\
    \ |postfix_to_append|\n    longest_postfix_to_prepend = postfix_to_append\n  \
    \  longest_postfix_to_prepend.reverse\n    longest_postfix_to_append.each do |postfix_to_prepend|\n\
    \      if postfix_to_prepend.include?(longest_postfix_to_append)\n        if longest_postfix_to_prepend.length\
    \ > longest.length\n          longest = postfix_to_prepend\n          longest.length\
    \ = longest_postfix_to_prepend.length\n        end\n        break\n      end\n\
    \    end\n  end\n  \n  longest\nend", "  return string unless string.length >=\
    \ 2\n  string[0..string.length / 2] + string[string.length / 2, string.length].reverse\n\
    end", "  if string.length < 1\n    string\n  elsif string.length == 1\n    ''\n\
    \  else\n    suffix = 'c'\n    string.each_char.with_index do |char, index|\n\
    \      suffix += char if char == string[index+1]\n    end\n    string.rindex(suffix).reverse!\
    \ + suffix\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=2 tags=ruby |>\n\
    Here's my solution:\n<code>", "  postfix, postfix_palindrome = make_postfix_palindrome(string,\
    \ true)\n  prefix = string.split(postfix_palindrome).reverse.join(postfix_palindrome)\n\
    \  return prefix + postfix_palindrome\nend", "  if string.empty?\n    string\n\
    \  else\n    begin = make_postfix_string(string)\n    end = reversed_string(begin)\n\
    \    begin + end\n  end\nend\n</cell>\n<cell>\nmake_palindrome(\"cat\")\n</cell>\n\
    <cell>\nmake_palindrome(\"cab\")\n</cell>\n<cell>", "  longest = 0\n  i = string.length\
    \ - 1\n  while i > 0 and string[i] != string[longest]\n    longest += 1\n    i\
    \ -= 1\n  end\n  longest\n  mid = longest / 2 + 1\n  if longest % 2 == 0\n   \
    \ string.insert(mid, string[mid-1] + string[mid])\n  else\n    string.insert(mid,\
    \ string[mid-1] + string[mid-1])\n  end\nend\n</cell>\n<cell>", "  \n  # First\
    \ find the longest postfix of supplied string that is a palindrome\n  postfix\
    \ = string.split(//)\n  while postfix.size == 1\n    postfix = string.split(//).reverse\n\
    \  end\n  \n  # Add the reverse of the string prefix before palindromic postfix\
    \ to the end of the string.\n  new_string = string[0, string.length - postfix.size]\
    \ + postfix.reverse.join\n  \n  return new_string\nend\n</code>\nThis isn't the\
    \ most elegant solution, but I was able to get it working using this.\n<|/ a dscore=0\
    \ |>\n<| a tags=algorithm,ruby,string |>\nHere's a recursive solution that'll\
    \ handle a bunch of edge cases like multiple letters ending in a vowel, multiple\
    \ letters that start with a vowel and a consonant. Also handles cases like \"\
    AaBbC\" since this is not a palindrome. It also handles cases like \"AA\" or \"\
    ABC\" since this is not a palindrome. It'll work for all cases except when input\
    \ is a single character.\n<code>\nrequire 'set'", "  start_index = string.rindex(\"\
    a\") || 0\n  end_index = string.rindex(\"z\") || string.length - 1\n  longest_postfix\
    \ = []\n  longest_postfix.concat string[start_index..end_index].scan(/./).reverse\n\
    \  longest_postfix.concat string[start_index..end_index].scan(/./)\n  return longest_postfix.join\n\
    end\n</code>\n<|/ a tags=algorithm,ruby,python |>\n<| c |>\nYou probably want\
    \ `string.rindex(\"a\")||0`. Also `string.rindex(\"z\")||string.length-1` would\
    \ be more efficient.\n<|/ c |>\n<| a dscore=2 |>\nHere's a Python3 version:\n\
    <code>", "  result = string\n  string.gsub!(/[a-z]+/)\n  string.gsub!(/[A-Z]+/)\n\
    \  string.gsub!(/[^A-Za-z]+/)\n  string.gsub!(/[^a-z]+/) do |match|\n    result\
    \ = result + match.reverse\n  end\n  string.gsub!(/[A-Za-z]+/)\n  string.gsub!(/[a-z]+/)\n\
    \  return result\nend", "  result = string.dup\n  string.gsub!(/([a-z])(?=[a-z]*$)/){$1.reverse}\n\
    \  string.gsub!(/([a-z])(?=[a-z]*)/){$1.reverse}\n  string.gsub!(/(?<=[a-z])(?=[a-z]*)/){$1.reverse}\n\
    \  string.gsub!(/([a-z])(?=[a-z]*)/){$1.reverse}\n  string.gsub!(/(?<=[a-z])([a-z]*)/){$1.reverse}\n\
    \  string.gsub!(/([a-z])([a-z]*)/){$1.reverse}\n  string.gsub!(/(?<=[a-z])([a-z]*)/){$1.reverse}\n\
    \  string.gsub!(/(?<=[a-z])([a-z]*)/){$1.reverse}\n  string.gsub!(/([a-z])([a-z]*)/){$1.reverse}\n\
    \  string.gsub!(/(?<=[a-z])([a-z]*)/){$1.reverse}\n  string.gsub!(/([a-z])([a-z]*)/){$1.reverse}\n\
    \  string.gsub!(/(?<=[a-z])([a-z]*)/){$1.reverse}\n  string.gsub!(/([a-z])([a-z]*)/){$1.reverse}\n\
    \  string.gsub!(/(?<=[a-z])([a-z]*)/){$1.reverse}\n  string.gsub!(/(?<=[a-z])([a-z]*)/){$1.reverse}\n\
    \  string.gsub!(/([a-z])([a-z]*)/){$1.reverse}\n  string.gsub!(/(?<=[a-z])([a-z]*)/){$1.reverse}\n\
    \  string.gsub!(/([a-z])([a-z]*)/){$1.reverse}\n  string.gsub!(/(?<=[a-z])([a-z]*)/){$1.reverse}\n\
    \  string.gsub!(/([a-z])([a-z]*)/){$1.reverse}\n  string.gsub!(/(?<=[a-z])([a-z]*)/){$1.reverse}\n\
    \  string.gsub!(/([a-z])([a-z]*)/){$1.reverse}\n  string.gsub!(/(?<=[a-z])([a-z]*)/){$1.reverse}\n\
    \  string.gsub!(/([a-z])([a-z]*)/){$1.reverse}\n  string.gsub!(/(?<=[a-z])([a-z]*)/){$1.reverse}\n\
    \  string.gsub!(/([a-z])([a-z]*)/){$1.reverse}\n  string.gsub!(/(?<", "  return\
    \ string[0..(string.length - 1).step(-1..-1)] + string[-1..(string.length - 1).step(-1..-1)].reverse\n\
    end", "  prefix_length = 0\n  palindrome = \"\"\n  string.split(\"\").each_with_index\
    \ do |char, index|\n    if char == string[-index]\n      prefix_length += 1\n\
    \    else\n      break\n    end\n  end\n  palindrome << string[-prefix_length]\n\
    \  string.split(\"\").each_with_index do |char, index|\n    if char != string[-index]\n\
    \      break\n    end\n  end\n  palindrome << string[-index][::-1]\n  return palindrome\n\
    end\n</code>\n<|/ a tags=string,palindrome,ruby,algorithm |>\n<| c |>\nIt would\
    \ be better to say that the longest postfix that is a palindrome is found by reversing\
    \ the string prefix that comes before the palindromic suffix.\n<|/ c |>\n<| c\
    \ |>\nYes, you are right. I reworded the comment to reflect this.\n<|/ c |>\n\
    <| a dscore=0 |>\nHere is another solution that I came up with using Ruby regular\
    \ expressions. I hope it helps:\n<code>", "  if string.empty?\n    string\n  elsif\
    \ string.length == 1\n    string + string.reverse\n  else\n    palindrome = find_longest_palindromic_substring(string)\n\
    \    string + reverse_string(palindrome)\n  end\nend", "  return string + string.reverse\
    \ + string.slice(0,-string.index.reverse(string))\nend\n</cell>\n<code language=julia-1.3>",
  "  # Start with the shortest possible palindrome\n  start = string.length\n  # Find\
    \ the longest postfix of string that is a palindrome\n  start = find_longest_postfix(string,\
    \ start)\n  # Append the reverse of the postfix to the end of the string\n  string\
    \ = string + string[start..-end].reverse\n  return string\nend\n</code>\n<|/ a\
    \ tags=ruby,algorithm,string |>\n<| a tags=ruby,algorithm,string dscore=0 |>\n\
    This solution only finds the longest palindrome from the start of each string.\
    \ \n<code>", "  len_string = string.length\n  postfix_string = string + 'x'\n\
    \  reverse_string = ''\n  reverse_suffix = ''\n  for i in (1 .. len_string)\n\
    \    if string.slice(i).reverse != string.slice(i).downcase\n      reverse_string\
    \ += string.slice(i).reverse\n      reverse_suffix += string.slice(i).downcase\n\
    \    else\n      reverse_string += string.slice(i)\n      reverse_suffix += string.slice(i).downcase\n\
    \    end\n  end\n  return postfix_string.reverse.concat(string.slice(len_string).reverse).concat(reverse_suffix).reverse\n\
    end", "  max_length = 0\n  max_length_postfix = 0\n  postfix_chars = string.split(//)\n\
    \  postfix_chars.reverse\n  postfix_chars.each do |char|\n    if char == char.to_s.reverse\n\
    \      max_length +=1\n      max_length_postfix +=1\n    end\n  end\n  max_length\
    \ <= max_length_postfix ? string : string + char.chr + char.chr + char.chr + make_palindrome(string.slice(-max_length_postfix,\
    \ string.length))\nend", "  string.split(//).each_with_index.\n      map { |char,\
    \ index| [char, string[index..-1]] }.\n      inject(:+).\n      reverse.\n   \
    \   each_char.\n      join\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis solution\
    \ makes use of an intermediate string. That is because a string is quite expensive\
    \ to reverse.\n<|/ c |>\n<| c |>\nThe string reverse is done only once at the\
    \ end in the `make_palindrome` function. The string is then rebuilt from that\
    \ reverse string and that is very cheap. In the `findLongestPalindrome` function\
    \ the string is read many times.\n<|/ c |>\n<| c |>\nYou are correct. I was misreading.\
    \ My apologies.\n<|/ c |>\n<| a tags=algorithm,ruby dscore=0 |>\nAs others said,\
    \ it's an O(n^2) algorithm. Here's my implementation in Ruby with recursion:\n\
    <code>", "  if string.empty?\n    string\n  else\n    string.slice(0..string.size\
    \ - 2).reverse.concat(string.slice(1..string.size))\n  end\nend", "  reversed_string\
    \ = string\n  string.gsub(/\\w/) { |i| reversed_string += i.reverse }\n  reversed_string\n\
    end", "  length    = string.length\n  min_length = 0\n  \n  index = 0\n  while\
    \ index < length\n    # Skip the prefix that matches the longest palindromic suffix.\n\
    \    if length >= min_length && string[index] == string[length - min_length]\n\
    \      index = index + 1\n    else\n      min_length = length\n      index   \
    \ = 0\n    end\n  end\n  \n  index = 0\n  while index >= 0\n    # Append the reverse\
    \ of the prefix that comes before this suffix.\n    string[index + 1] = string[length\
    \ - 1 - index]\n    index = index - 1\n  end\n  \n  return string\nend\n</cell>\n\
    <code language=julia-1.6>", "  max_length = max_palindrome_length(string)\n  start\
    \ = string.rindex(string[max_length])\n  end = start+max_length\n  suffix = ''\n\
    \  for i in string[start:end].downcase\n    suffix = i\n  end\n  result = string[0,\
    \ start] + string[end, string.length]+suffix\n  return result\nend", "  reverse\
    \ = string.reverse\n  reverse_length = string.length\n  max_length = 0\n  longest_postfix\
    \ = ''\n  i = 0", "  str = \"\"\n  char_count = 0\n  for i in string.downcase\n\
    \    if char_count%2 == 0\n      str += i\n      char_count += 1\n    else if\
    \ char_count%2 == 1\n      str += i.downcase\n      char_count += 1\n    else\n\
    \      nil\n  end\n  if str == str.reverse\n    str\n  else\n    false\n  end\n\
    end\n</code>\nSo you can now find your palindrome by saying make_palindrome string\n\
    <|/ a tags=string,palindrome,ruby |>\n<| a |>\n<code>", "  return string + string.reverse.slice(0,string.rindex(string.reverse.reverse))\n\
    end", "  max_len = 0\n  palindrome = ''\n  min_len = string.length", '  string.length
    < 2 ? string : string << string.reverse', "  l=string.size\n  max_postfix_i=(l-1)/2+1\n\
    \  max_postfix_j=max_postfix_i\n  result=''\n  for i in [max_postfix_i,max_postfix_j]\n\
    \    if i>0 and i<=l-1\n      a=string[i]\n      b=string[l-i-1]\n      result+=a*reversal(b)+a\n\
    \    end\n  end\n  result\nend", "  # O(n/2) because for each char we need to\
    \ iterate through the string n times.\n  max_length = 0\n  palindrome = ''\n \
    \ i = 0\n  while i < string.length\n    max_length = max_length if max_length\
    \ > string.length - i else string.length - i\n    i += max_length\n    string_to_compare\
    \ = string[max_length..-1]\n    unless string_to_compare == string.chars.reverse[max_length..-1]\n\
    \      next\n    end\n    palindrome << string_to_compare if string_to_compare\
    \ == string.reverse[max_length..-1]\n  end\n  palindrome\nend", "  string = string.dup\n\
    \  return \"\" if string.empty? || string.length <= 1\n  begin = string[0..-2]\n\
    \  reverse = reverse(string.slice(1, string.length).reverse)\n  reverse << begin\n\
    \  return string[0..-2] if reverse == begin || reverse == reverse\nend", "  return\
    \ string.gsub(/^(.)(.+?)(.)(.+?)\\1/) {\n    \"#{$1}#{$2}#{$4}#{$3}\".gsub(/.$/,\
    \ \"#{$1}#{$2}#{$3}\")\n  }\nend", '  return string if string.length <= 3 or string.length
    >= 5 ', "  \n  # No palindromic substrings found.\n  return string unless string.length\
    \ <= 2\n  \n  # No palindromic substrings with length 2.\n  return string if string.length\
    \ == 2\n  \n  # Find the longest postfix of supplied string that is a palindrome.\n\
    \  longest = find_longest_palindrome_postfix(string.dup)\n  \n  # No palindromic\
    \ substrings found with that length.\n  return string if longest <= 2\n  \n  #\
    \ Palindromic substring found with that length.\n  postfix = string[0, longest].dup\n\
    \  \n  # Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n  string.insert(0, reverse string[longest..-1],\
    \ longest)\n  \n  # Return the postfix string.\n  return postfix\nend", "  return\
    \ find_longest_palindrome(string) + find_longest_palindrome(string.reverse)\n\
    end", "  beginning_of_the_longest_palindrome = nil\n  longest_postfix_to_prepend\
    \ = nil\n  string.downcase.split(\"\").each do |char|\n    longest = string.length\n\
    \    longest_postfix_to_prepend = nil\n    string.split(char).each do |suffix|\n\
    \      longest.times { longest_postfix_to_prepend += suffix }\n      longest.times\
    \ { longest_postfix_to_prepend += char }\n      longest_postfix_to_prepend.downcase!\n\
    \      break if longest_postfix_to_prepend.eql?(string.downcase)\n    end\n  \
    \  beginning_of_the_longest_palindrome ||= longest_postfix_to_prepend\n  end\n\
    \  beginning_of_the_longest_palindrome\nend", "    max_length = string.size\n\
    \    if max_length <= 1\n        string\n    else\n        postfix = string.dup\n\
    \        max_length -= 1\n        max_length.times { postfix.rjust 1 }\n     \
    \   length = postfix.size\n        reverse_postfix = postfix.reverse\n       \
    \ postfix.insert(length, reverse_postfix)\n        postfix.slice!(0, length +\
    \ max_length)\n        postfix.reverse!\n        postfix.slice!(0, max_length)\n\
    \        postfix.prepend(string)\n        postfix.to_s\n    end\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby,string |>\n<| a tags=ruby,string |>\nIn Python:\n<code>",
  "  original = string\n  string = string.dup\n  # Find the longest postfix that is\
    \ a palindrome\n  longest = find_longest_palindrome_postfix(string)\n  longest.downcase!\n\
    \  longest.split(//)\n  # Reverse the longest postfix to get the palindromic prefix\
    \ that ends before the longest postfix\n  while string.index(longest) > string.rindex(longest)\n\
    \    string = string.rjust(string.rindex(longest))\n  end\n  string = string.rjust(string.index(longest))\n\
    \  # Append the reverse of the longest postfix to the string that comes before\
    \ it\n  string << reverse(string[0..string.index(longest)])\n  string\nend", " \
    \ string.reverse!\n  string.slice(0,(string.length/2).round)\n  string.slice((string.length/2).round)\n\
    end", "  length = get_length(string)\n  postfix = string.slice(0..(length / 2))\
    \ # The postfix of supplied string.\n  postfix_reversed = postfix.reverse  # Reverse\
    \ the string postfix.\n  start_index = postfix_reversed.length + 2\n  end_index\
    \ = start_index + length\n  return string + postfix_reversed.slice(start_index,\
    \ end_index)\nend", "  longest, longest_index = longest_palindrome_indexes(string)\n\
    \  return string.gsub(longest, longest_index, longest + longest_palindrome_substring_from_index(string,\
    \ longest))\nend", "  return [string] + string.reverse.chars.take(string.size\
    \ - string.index(reverse(string)))\nend", "  string = string.gsub(/[^a-zA-Z0-9_]/,\
    \ '') # remove special characters\n  postfix_length = len(string) - 1 # get postfix\
    \ length\n  reverse_postfix = string.reverse[postfix_length] # reverse postfix\n\
    \  result = string[0..postfix_length + 1] + reverse_postfix # build the palindrome\
    \ string\n  return result.downcase if result.downcase != string # check if result\
    \ is a palindrome\nend\n</code>\n<|/ a tags=ruby,string dscore=3 |>\n<| c |>\n\
    That's really smart, but `make_palindrome(\"ab\") #=> \"b\"`. Is that intentional?\
    \ I'd have thought that `make_palindrome(\"abba\")` would return `\"abb\"`.\n\
    <|/ c |>\n<| c |>\nYou're right, I missed that condition. Edited the answer.\n\
    <|/ c |>\n<| a |>\nIn addition to the other answers, I'd like to point out that\
    \ the algorithm doesn't use recursion and doesn't use regular expressions, although\
    \ this is very easy to change, since the regular expressions make it hard to read,\
    \ especially if you need to make it work with multi-character delimiters.\n<code>",
  "  palindrome = ''\n  postfix = string.split(//).reverse\n  unless postfix.join.eql?(string)\n\
    \    postfix.join!(string)\n  end\n  postfix.join!(string)\n  postfix.reverse!\n\
    \  postfix.join!(string)\n  if postfix.eql?(string)\n    palindrome = string\n\
    \  else\n    palindrome = string[0,string.index(postfix.join,string)]\n  end\n\
    \  return palindrome\nend", "    length = string.length\n    palindrome = ''\n\
    \    (start_idx, end_idx) = get_prefix_and_suffix_indexes(string, length)\n  \
    \  (start_idx_prime, end_idx_prime) = get_prefix_and_suffix_indexes(palindrome,\
    \ length)\n    while start_idx < end_idx\n        curr_string = string[start_idx...end_idx]\n\
    \        curr_string_reversed = string[start_idx_prime...end_idx_prime]\n    \
    \    if curr_string == curr_string_reversed\n            palindrome << curr_string\n\
    \            start_idx += 1\n            start_idx_prime += 1\n            length\
    \ -= 2\n            while (start_idx < end_idx) && length <= 0\n             \
    \   curr_string = string[start_idx...end_idx]\n                curr_string_reversed\
    \ = string[start_idx_prime...end_idx_prime]\n                length += curr_string.length\n\
    \                palindrome << curr_string\n                palindrome << curr_string_reversed\n\
    \                start_idx += 1\n                start_idx_prime += 1\n      \
    \  end\n    end\n    palindrome\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n\
    <| a dscore=0 |>\nAn alternative solution to the problem:\n<code>\nstr = \"ab\"\
    \nstr.reverse #=> \"ba\"", "  palindrome = string.dup\n  palindrome.chars.reverse_each{\
    \ |c| palindrome << c if c.chr == c && c.upcase == c.downcase }\n  return palindrome\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| c |>\nNice solution, but it takes too much\
    \ time. How can we improve it? :)\n<|/ c |>\n<| c |>\nI tested it, and it does\
    \ in fact finish in about 2.5 seconds. Do you have some test case that it's taking\
    \ too long?\n<|/ c |>\n<| c |>\nYes, I used this algorithm: ```def palindrome(str)\n\
    \   string = (str + 'a').dup\n   string.chars.reverse_each { |c| string << c if\
    \ c.chr == c && c.upcase == c.downcase }\n   return string\n end``` on \"aba\"\
    \ and it took 1.5 seconds\n<|/ c |>\n<| c |>\nHmm, interesting. Did you put that\
    \ in a loop to run it 10 times or did you just run it once on the string \"aba\"\
    ?\n<|/ c |>\n<| c |>\nI ran it 100 times. But it seems that you just need to run\
    \ the algorithm once on the string \"aba\" and then compare it to the results\
    \ from your algorithm. Your solution just takes 1.5 seconds to run on \"aba\"\
    \ :)\n<|/ c |>\n<| a |>\nI've implemented a method which is based on Dijkstra's\
    \ Algorithm to find all Palindromes in a given String.\n<code>", "  string.chars.reverse.join\
    \ string[1..-1] == string\nend", "  string = string.downcase\n  len  = string.length\n\
    \  str  = string[0...len]\n  rev  = string.reverse\n  i    = 0\n  while len >\
    \ 0\n    if str != rev\n      break\n    i += 1\n    rev = string[i..-1].reverse\n\
    \    len -= 1\n  end\n  str += i\n  str\nend\n</code>\nTesting:\n<code>", "  return\
    \ string.gsub(/(?<=[a-zA-Z])(?=[a-zA-Z])/,'').reverse\nend", "  longest = 0\n\
    \  longestString = \"\"\n  longestPostfix = \"\"\n  prefixLength = 0\n  postFix\
    \ = \"\"\n  count = 0\n  i = 1\n  while i < string.length\n    postFix = string.slice(i..i\
    \ + 1)\n    if postFix != postFix.reverse\n      postFix = postFix.reverse\n \
    \     postFix = postFix.reverse\n    end\n    longest = postFix.length\n    if\
    \ longest > longestString\n      longestString = postFix\n    end\n    longestPostfix\
    \ = longestPostfix.upto(longest).find_all { |i| i == longestString.reverse }.first\n\
    \    i += 1\n    count += 1\n  end\n  longestPostfix = longestPostfix.reverse\n\
    \  longestPostfix = longestPostfix.upto(longest).find_all { |i| i == longestString\
    \ }.first\n  longestPostfix = longestPostfix.reverse\n  longestPostfix = longestPostfix.upto(longest).find_all\
    \ { |i| i == postFix.reverse }.first\n  longestPostfix = longestPostfix.reverse\n\
    \  longestPostfix = longestPostfix.upto(longest).find_all { |i| i == postFix.reverse\
    \ }.first\n  longestPostfix = longestPostfix.reverse\n  longestPostfix = longestPostfix.upto(longest).find_all\
    \ { |i| i == postFix.reverse }.first\n  longestPostfix = longestPostfix.reverse\n\
    \  longestPostfix = longestPostfix.upto(longest).find_all { |i| i == postFix.reverse\
    \ }.first\n  longestPostfix = longestPostfix.reverse\n  return longestPostfix\n\
    end", "    \n    suffix       = (string).reverse\n    prefix = string[0 .. -1]\n\
    \    \n    return prefix + suffix\nend\n</cell>\n<cell>", "  reverse_string =\
    \ string.reverse\n  result = ''\n  reverse_string.length.times do |i|\n    next_char\
    \ = string[-i-1]\n    reverse_string += next_char\n    result += next_char\n \
    \ end\n  result.reverse!\n  result\nend", "  return string + reverse(string[string.size..-1])\n\
    end", "  longest = length(string)\n  middle = longest / 2\n  suffix = (string.slice(middle..-1).reverse).concat(string.slice(0...middle))\n\
    \  prefix = (string.slice(0, middle).reverse).concat(string.slice(middle..-1))\n\
    \  prefix = prefix.reverse\n  return prefix.concat(suffix)\nend", "  longest =\
    \ get_longest_postfix_of(string)\n  reversed_prefix = string[0,longest]\n  reversed_suffix\
    \ = '' unless reversed_prefix.is_a?(String)\n  reversed_prefix += reversed_suffix\n\
    \  reversed_prefix_reversed = reversed_prefix.reverse\n  result = reversed_prefix_reversed\
    \ + string + reversed_suffix\n  return result if longest.is_a?(Integer)\nend",
  "  start_index, end_index = 0, string.length - 1\n  while start_index <= end_index\n\
    \    if string[start_index] == string[end_index]\n      start_index += 1\n   \
    \   end_index -= 1\n    else \n      break\n  end\n  return string + string[start_index...end_index].reverse\n\
    end", "  string = (string || '').downcase\n  longest = string.split(//).max {\
    \ |a,b| a.size <=> b.size }.size\n  \n  string[0,longest].reverse.concat(string[longest..-1]).reverse\n\
    end", "  string.reverse if string.length <= 3 \n  max_length = (string.length\
    \ / 2) + 1\n  suffix = (string.length % 2)\n  result = (1..max_length).map { |index|\
    \ \n    string[index].to_s + string[(max_length - index - 1)..-1]\n  }.map { |s|\
    \ s + \"c\" }.join(\"\")\n  suffix == 0 ? result : \"c\" + result + suffix \n\
    end", "    l = string.size\n    max_length = l / 2\n    palindrome = \"\"\n  \
    \  (index, length) = find_longest_postfix_index(string, max_length)\n    \n  \
    \  while length < max_length\n        string.slice!(0, index)\n        reversed_string\
    \ = string.reverse\n        (index, length) = find_longest_postfix_index(reversed_string,\
    \ max_length)\n        palindrome << reversed_string[0...index]\n    end\n   \
    \ palindrome\nend\n</code>\n<|/ a |>\n<| a dscore=2 tags=ruby |>\nThe solution\
    \ in the question \"How to determine whether a string is a palindrome?\" doesn't\
    \ work if there is no palindrome in the string.\n<code>", "  max_length = 0\n\
    \  max_length_palindrome = 0\n  max_length_suffix = 0\n  max_length_suffix_palindrome\
    \ = 0\n  string.downcase!\n  string.split(//).each do |c|\n    if c.is_a?(String)\n\
    \      c.downcase!\n    end\n    if c.length == max_length\n      if c.reverse.eql?(c)\n\
    \        max_length_palindrome = max_length\n        max_length_suffix_palindrome\
    \ = max_length\n      else\n        if c.reverse.eql?(c.slice!(0, max_length -\
    \ max_length_palindrome + 1))\n          max_length_palindrome = max_length\n\
    \        end\n      end\n    end\n  end\n  max_length_palindrome == max_length_suffix_palindrome\
    \ ? (max_length + max_length_palindrome + 1) : max_length_suffix_palindrome\n\
    end", "  string.gsub(/[aeiouy]/, ' ').split.reverse.join\nend", "  reverse = string.dup.reverse\n\
    \  index = string.size", "  if string == \"\"\n    return \"\"\n  index = string.length\n\
    \  while index > 1\n    reverse = reverse(string[0...index-1])\n    if string.start_with?(reverse)\n\
    \      string = string + \"#{reverse}\"\n      break\n    end\n    index -= 1\n\
    \  end\n  string\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThe palindrome code\
    \ above fails for strings such as `'abba'` because the `String#length` method\
    \ returns `3` for the `'abba'` string, which is `'abc'` in the middle of the `'abba'`\
    \ string and `'abb'` at the end. This doesn't match the palindrome requirement,\
    \ which requires `'abba'` to return `'abb'`, as it's prefixed by `'abba'`.\n<|/\
    \ c |>\n<| c |>\nYou are correct, which is why I wrote my comment \"Algorithm\
    \ idea is simple:\n- Find the longest postfix of supplied string that is a palindrome.\"\
    \ This requirement was not met by the algorithm, and I wasn't suggesting that\
    \ the algorithm was wrong. I'm suggesting that it was a requirement the OP didn't\
    \ mention. My algorithm works because of the requirements of the question. Also,\
    \ I mentioned that my algorithm does not actually work and that's why I wrote\
    \ my comment \"The palindrome code above fails for strings such as 'abba' because\
    \ the String#length method returns 3 for the 'abba' string, which is 'abc' in\
    \ the middle of the 'abba' string and 'abb' at the end.\" I wrote a comment, not\
    \ a solution. Thank you for pointing out my mistake.\n<|/ c |>\n<| c |>\nFair\
    \ enough. My comments were (a) not intended to be a solution but an explanation\
    \ as to why OP's code did not work (b) not intended to be a solution and an explanation\
    \ as to how OP's code should work, and (c) not intended to be a solution. Feel\
    \ free to edit to correct my mistake.\n<|/ c |>\n<| a dscore=0 |>\nIn case you\
    \ need to create a function that can do the same without using reverse, here is\
    \ the code that worked for me:\n<code>", "  longest = ''\n  longest = find_longest_postfix_palindrome(string)\n\
    \  middle = find_middle_of_longest_postfix_palindrome(string, longest)\n  middle_reverse\
    \ = reversed_string(middle, longest)\n  middle_reverse_with_palindrome = middle\
    \ + middle_reverse\n  return middle_reverse_with_palindrome\nend\n</code>\n<|/\
    \ a tags=algorithm,ruby,language-agnostic |>\n<| a |>\nHere's a solution in ruby,\
    \ that works well for me. It uses a simple algorithm that builds the palindrome\
    \ backwards, using two pointers. I'm using a hash for efficiency, but you could\
    \ also use two arrays. I did this because I find the idea of using two pointers,\
    \ makes a lot of sense.\n<code>", "  string.gsub!('\\n', '') # Replace newline\
    \ chars with spaces for ease of comparison.\n  palindrome = string\n  suffix_length\
    \ = string - palindrome\n  if suffix_length > 0\n    palindrome << string.reverse(suffix_length)\n\
    \  end\n  return(palindrome)\nend", "  string = string.to_s.dup\n  string.gsub!(/[^a-z]/i,\
    \ '')\n  return string + (string[0,1] == string[-1,0] ? string.slice(1) : '')\
    \ # Reverse the first and the last char of string.\nend", "  l=string.size\n \
    \ return (string[l..l-1]+string[0,l-1]+string[l..-1]).reverse.tr(\" \",\"\")\n\
    end", "  longest = find_longest(string)\n  suffix = ''\n  prefix = string[0,longest.min]\n\
    \  reversed = reverse_string(prefix, longest.max)\n  puts(string + reverse + suffix)\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,algorithm |>\nThis is probably\
    \ not as efficient as some of the other solutions provided, but here's an implementation\
    \ in Ruby. This uses a modified version of the Longest Palindromic Substring algorithm\n\
    <code>", "  max_length = length(string)\n  max_length = max_length * max_length\n\
    \  max_length = (max_length / 2).floor", "  suffix = (string.length * 'a') + string\n\
    \  prefix_len = string.length - suffix.length\n  postfix_palindrome = string.reverse.sub(regexp_palindrome,\
    \ string)\n  postfix_palindrome = postfix_palindrome + suffix.sub(regexp_palindrome,\
    \ suffix)\n  return prefix_len + postfix_palindrome\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThanks for taking the time to answer the question. Can you please\
    \ elaborate a little bit more about how you arrived at the complexity of the algorithm?\
    \ What is a common pitfall when analyzing algorithm complexity?\n<|/ c |>\n<|\
    \ c |>\nI guess the complexity of the algorithm depends on how \"hard\" it is\
    \ to understand the algorithm. My guess is that the complexity of both solutions\
    \ are `O(n)`. You can think of it like finding a palindrome without actually checking\
    \ if it is palindrome - that's why I used the reverse function in one algorithm\
    \ - it can be `O(1)` compared to checking the suffix is palindrome in the other\
    \ algorithm.\n<|/ c |>\n<| c |>\nI believe the first algorithm is `O(n)`, but\
    \ maybe I am misinterpreting it. I believe it takes the longest possible suffix\
    \ that is a palindrome and appends it to its original suffix, which is `O(n)`\
    \ as well. Is that correct?\n<|/ c |>\n<| c |>\nAm I right in saying that the\
    \ second algorithm is `O(n)` because it only takes out a prefix palindrome rather\
    \ than a suffix palindrome?\n<|/ c |>\n<| c |>\nI believe that the first algorithm\
    \ is `O(n)`, but the second algorithm is `O(M*N)` where `M` is length of `string`\
    \ and `N` is length of `string`. Since both algorithms take out a suffix palindrome,\
    \ the total complexity is `O(M*N)`.\n<|/ c |>\n<| a tags=algorithm,ruby,string\
    \ |>\nUsing a combination of scan and reverse, we can easily solve this problem\
    \ in O(n) time complexity:\n<code>", "  palindrome = ''\n  if string.empty?\n\
    \    palindrome\n  else\n    max_length = string.size\n    max_length_suffix_start\
    \ = max_length\n    suffix_start = 0\n    suffix_end = max_length - 1\n    while\
    \ suffix_end >= suffix_start\n      # TODO: consider case when suffix is longer\
    \ than palindrome to reduce runtime\n      suffix_suffixes = string.slice(suffix_end,\
    \ max_length)\n      suffix_suffixes.reverse!\n      suffix_suffix =  suffix_suffixes.reverse\n\
    \      palindrome << string[suffix_start, suffix_end]\n      suffix_end -= 1\n\
    \    end\n    palindrome << string[suffix_start, max_length_suffix_start]\n  end\n\
    end", "  string.downcase!\n  return string.split.reverse .join('') + string.reverse\n\
    end", "  reverse_string = string\n  string.downcase!\n  while string.length !=\
    \ 0\n    if string.upcase == string\n      break\n    end\n    reverse_string\
    \ = string.reverse!\n    string.downcase!\n  end\n  string.upcase!\n  reverse_string\
    \ += string.downcase\n  return reverse_string\nend", "  i = 1\n  while i <= string.length\n\
    \    s = string.slice(i..string.length)\n    s = s.reverse\n    string.concat\
    \ s\n    i += 1\n  end\n  string\nend", "  string.gsub!(/[^A-Za-z]/, \"\")\n \
    \ length = string.size - 1\n  max_length = (length - 1) / 2\n  max_index = length\
    \ - max_length\n  max_char = string[max_index]\n  min_length = max_length + 1\n\
    \  min_index = length - min_length\n  min_char = string[min_index]\n  string[0,\
    \ max_length] = max_char\n  string[max_length, length] = min_char\n  result =\
    \ []\n  index = 0\n  while index != length\n    if index == min_index\n      result\
    \ = [string[0, min_length]] + string[min_length, length]\n      break\n    end\n\
    \    index += 1\n  end\n  result\nend", "  longest_postfix_with_prefix_length\
    \ = {\n    '' => {\n      'length' => 0,\n      'suffix' => nil\n    },\n    'cat'\
    \ => {\n      'length' => 3,\n      'suffix' => 'at'\n    },\n    'cata' => {\n\
    \      'length' => 3,\n      'suffix' => 'at'\n    },\n    'catat' => {\n    \
    \  'length' => 3,\n      'suffix' => 'at'\n    },\n    'catact' => {\n      'length'\
    \ => 3,\n      'suffix' => 'at'\n    },\n    'catatat' => {\n      'length' =>\
    \ 3,\n      'suffix' => 'at'\n    },\n    'catatatat' => {\n      'length' =>\
    \ 3,\n      'suffix' => 'at'\n    },\n    'catactatat' => {\n      'length' =>\
    \ 3,\n      'suffix' => 'at'\n    },\n    'catatatatat' => {\n      'length' =>\
    \ 3,\n      'suffix' => 'at'\n    },\n    'catactatatat' => {\n      'length'\
    \ => 3,\n      'suffix' => 'at'\n    },\n    'catactatatatat' => {\n      'length'\
    \ => 3,\n      'suffix' => 'at'\n    },\n    'catactatatatatat' => {\n      'length'\
    \ => 3,\n      'suffix' => 'at'\n    },\n    'catactatatatatatat' => {\n     \
    \ 'length' => 3,\n      'suffix' => 'at'\n    },\n    'catactatatatatatat' =>\
    \ {\n      'length' => 3,\n      'suffix' => 'at'\n    },\n    'catactatatatatatatat'\
    \ => {\n      'length' => 3,\n      'suffix' => 'at'\n    }\n  }", "  result =\
    \ ''\n  string.each_byte { |c| result << c }\n  string.each_byte { |c| result\
    \ << (c == string[-1] ? c : c.reverse) }\n  result\nend", "  prefix_length = 0\n\
    \  suffix_length = string.size - 1\n  while suffix_length > prefix_length\n  \
    \  # Find the longest postfix of supplied string that is a palindrome.\n    postfix_length\
    \ = suffix_length + 1\n    while postfix_length < string.size and string[postfix_length]\
    \ != string[prefix_length]\n      postfix_length += 1\n    prefix_length += 1\n\
    \    suffix_length -= 1\n    postfix_string = string[prefix_length..postfix_length]\n\
    \    postfix_reversed_string = (string[prefix_length..-1] + postfix_string).reverse\n\
    \    string << postfix_reversed_string\n  end\n  string\nend", '  palindrome =
    nil', "  return string + make_palindrome(string.split(\"\").reverse.join).split(\"\
    \").reverse.join\nend", "  string = string.gsub(/([a-z])/,'\\1'.ord.downcase)\n\
    \  min_length = string.length\n  max_length = string.length\n  while min_length\
    \ > 1\n    max_length += 1\n    min_length = max_length - 1\n  end\n  max_length\
    \ -= 1\n  max_index = 0\n  i = max_length\n  while i >= 0\n    if i == max_length\n\
    \      max_index += 1\n      i -= 1\n      max_length -= 1\n    end\n    reversed_string\
    \ = string[max_index..-1].downcase\n    break if string == reversed_string\n \
    \   i -= 1\n  end\n  result = ''\n  string.each_char do |c|\n    if c.ord.downcase\
    \ == reversed_string.ord.downcase\n      result << c\n    else\n      result <<\
    \ c.ord.downcase\n    end\n  end\n  result\nend", "  result = string\n  postfix\
    \ = string.split('')\n  postfix.reverse\n  until postfix.join.index( result )\
    \ == 0 do\n    result = \"#{result}#{postfix.join.reverse}\"\n  end\n  result\n\
    end", "  if string.empty?\n    string\n  else\n    palindrome = string.reverse\n\
    \    prefix_length = string.rindex(string.reverse)\n    palindrome << string[0,\
    \ prefix_length]\n  end\nend\n</code>\nNow the only thing left is to find the\
    \ longest palindrome that begins with a supplied string.\n<code>", "  reverse_string\
    \ = string.reverse\n  max_len = 0\n  longest_palindromic_rev = \"\"\n  start_pos\
    \ = 1\n  end_pos = string.length - 1\n  while start_pos <= end_pos\n    prefix\
    \ = string[start_pos..end_pos]\n    palindromic_rev = string.reverse\n    next_len\
    \ = end_pos - start_pos + 1\n    if next_len > max_len\n      max_len = next_len\n\
    \      longest_palindromic_rev = palindromic_rev\n      start_pos = start_pos\
    \ + 1\n    end\n    if palindromic_rev == prefix\n      start_pos = start_pos\
    \ + 1\n      end_pos = end_pos - 1\n    end\n  end\n  longest_palindromic_rev\
    \ << string[start_pos+1..end_pos]\n  longest_palindromic_rev << reverse_string\n\
    \  return longest_palindromic_rev\nend", "  string.downcase!\n  if string.length\
    \ <= 2\n    string\n  else\n    prefix = string[0...string.length].reverse\n \
    \   suffix = string[0...string.length].reverse\n    suffix.gsub!(/[atgac]/, '')\
    \ # remove any unwanted characters from the suffix\n    string[0...string.length]\
    \ << suffix << prefix # append the suffix before the prefix\n    make_palindrome(string)\
    \ # find other palindromes in the remainder of the string\n  end\nend", "  return\
    \ string if string.empty? or string.is_space? or string.chars.count > 1\n  result\
    \ = string\n  prefix = string[0, string.chars.count - 1].reverse\n  prefix_length\
    \ = (prefix + 'a').chars.count - 1\n  prefix_chars = (prefix + 'a').chars\n  prefix_start\
    \ = prefix_chars.first\n  prefix_end = prefix_chars.last", "  reversed = string.reverse\n\
    \  postfix = string.reverse.split(string)\n  longest = postfix[postfix.length\
    \ - 1]\n  postfix.pop\n  postfix.reverse!\n  postfix.unshift(longest)\n  postfix.join('')\n\
    end\n</code>\n<|/ a tags=ruby,algorithm dscore=2 |>\n<| c |>\nI like this, though\
    \ it fails on \"bbaa\" as a valid solution.  The solution suggested here is a\
    \ bit more elegant.\n<|/ c |>\n<| c |>\nSure, thanks for sharing your solution;\
    \ I'm sure it will be useful for people who stumble across this thread.\n<|/ c\
    \ |>\n<| a tags=ruby,algorithm |>\nI came up with this in Ruby:\n<code>", "  lst_suffix_to_prepend\
    \ = []\n  lst_suffix_to_append = []\n  lst_suffix_to_append.push(0)\n  lst_suffix_to_prepend.push(0)\n\
    \  lst_suffix_to_prepend.push(string.length)\n  lst_suffix_to_append.push(string.length)\n\
    \  while lst_suffix_to_prepend.length > 0 && lst_suffix_to_append.length > 0\n\
    \    suffix_to_prepend = lst_suffix_to_prepend.pop\n    suffix_to_append = lst_suffix_to_append.pop\n\
    \    if string.slice!(suffix_to_prepend)\n      suffix =  string.slice!(0 .. -1\
    \ * (suffix_to_prepend - suffix_to_append))\n      string.slice!(0, suffix_to_prepend\
    \ - 1)\n      string.reverse_update!(suffix) if suffix.size == 0\n    end\n  \
    \  if string.slice!(suffix_to_append)\n      suffix =  string.slice!(0 .. -1 *\
    \ (suffix_to_append - suffix_to_prepend))\n      string.reverse_update!(suffix)\
    \ if suffix.size == 0\n    end\n  end\n  return string.join\nend", "  str = string.dup\n\
    \  prefix = str[0..str.index(str.reverse)]\n  suffix = str[str.index(str.reverse)+1..-1]\n\
    \  new_str = prefix + suffix.reverse\n  new_str == str ? string : new_str\nend",
  "  reversed_suffix = ''\n  reversed_string = ''\n  \n  while string != ''\n    \n\
    \    if string.length == 1\n      reversed_string = '#{string}'\n      break\n\
    \    end\n    \n    suffix_to_remove = string[string.length]\n    reversed_suffix\
    \ = reversed_suffix.gsub(suffix_to_remove, '')\n    reversed_string = reversed_string\
    \ + reversed_suffix\n    string = string[0..length-1]\n  end\n  \n  return reversed_string\n\
    end\n    ", "  reverse_string = string.split('').reverse.join('')\n  longest_postfix_string\
    \ = string.split(reverse_string).first\n  longest_postfix_string.gsub!(reverse_string,\
    \ longest_postfix_string.split(longest_postfix_string.reverse).first)\n  string\
    \ << longest_postfix_string\n  string\nend", "  reverse = string.reverse\n  start_index\
    \ = -1\n  end_index = -1\n  reverse_index = 0\n  while reverse_index < string.length\n\
    \    char = string[reverse_index]\n    if char == reverse[reverse_index]\n   \
    \   start_index = reverse_index + 1\n      end_index = reverse_index + 1 + 1\n\
    \      break\n    reverse_index += 1\n  end\n  if start_index == -1 || end_index\
    \ == -1\n    raise Exception.new('No palindrome found.')\n  start_index -= 1\n\
    \  end_index -= 1\n  output_string = string.dup\n  output_string[start_index...end_index]\
    \ = string[start_index...end_index].reverse\n  output_string\nend", "  max_count\
    \ = 0\n  max_string = ''\n  string.reverse\n  string.each_char do |char|\n   \
    \ count = (string.index(char) .. string.index(char)).count\n    if count == max_count\
    \ and count > 0\n      max_count = count\n      max_string = string\n    end\n\
    \  end\n  max_string\nend\n</code>\nTests\n<code>\nputs make_palindrome('abc')",
  "  longest = max_postfix(string)\n  new_string = string\n  new_string.slice!(0,\
    \ longest.size)\n  new_string << reverse << longest if longest.length <= string.length\n\
    \  new_string\nend\n</code>\n<|/ a dscore=4 |>\n<| a tags=ruby,string |>\nSince\
    \ this question has a Ruby tag, you can solve this problem in Ruby with a single\
    \ method call:\n<code>", "  return string + reverse(string).reverse.sub(/([a-z])/)\
    \ {|s| s[0,1].upcase + s[1..-1]}\nend", "  # Find the longest palindrome that\
    \ begins with supplied string.\n  # Algorithm idea is simple:\n  # - Find the\
    \ longest postfix of supplied string that is a palindrome.\n  # - Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n  if string.length == 0\n    string\n  else\n    prefix_len = 0\n \
    \   postfix_len = 0\n    string.each_char do |char|\n      if char == char.reverse\
    \ && string.rindex(char, prefix_len) > -1\n        postfix_len = prefix_len\n\
    \      end\n      prefix_len += 1\n    end\n    string[0, postfix_len + prefix_len]\n\
    \  end\nend", "  string = string.dup\n  reversed_string = ''\n  index = 0\n  while\
    \ index < string.length\n    reversed_string << string[index].chr\n    index +=\
    \ 1\n  end\n  index = -1\n  while index >= 0\n    if string[index] == reversed_string[index]\n\
    \      string = string.gsub(string, string[0..index-1] + string[index+1 .. string.length].chars)\n\
    \      reversed_string = reversed_string.gsub(string, string[0..index-1] + string[index+1\
    \ .. string.length].chars)\n    else\n      break\n    end\n    index -= 1\n \
    \ end\n  return string\nend", "  return string + 'c' + reverse(string)\nend",
  "  string = string.reverse\n  longest = string.scan(/\\p{Upper}/ ).max_by { |s|\
    \ s.length }\n  postfix = string.chars.to_a.reverse\n  prefix = postfix.take_while\
    \ { |s| s == longest }\n  prefix + string\nend", "  max_length = 0\n  index =\
    \ string.size # start searching from end (for longest postfix of suffix)\n  while\
    \ index >= 0\n    if string[index] == string[max_length]\n      max_length +=\
    \ 1\n    else # index is smaller than the max_length\n      break\n    index =\
    \ index - 1\n  end\n  if max_length == 0\n    return ''\n  else\n    begin_index\
    \ = max_length # start searching from end (for prefix before palindromic suffix)\n\
    \    while begin_index >= 0\n      if string[begin_index] != string[begin_index\
    \ - max_length]\n        break\n      else\n        begin_index -= 1\n      end\n\
    \    end\n    return string[0...begin_index] + 'a' + string[begin_index...end]\
    \ # return prefix + suffix + 'a'\n  end\nend", "  string = string.dup\n  string.reverse!\n\
    \  string = string.gsub(/a{2,}/, 'aa')\n  string = string.gsub(/a[a-z]+/, 'a')\n\
    \  string = string.gsub(/a[a-z]+/, 'a')\n  string = string.gsub(/a[a-z]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  string = string.gsub(/a[^a]+/, 'a')\n  string = string.gsub(/a[^a]+/, 'a')\n\
    \  ", "  palindrome = ''\n  start = string.size\n  string.downcase!\n  while start\
    \ > 0\n    string.slice!(start)\n    suffix = string[1..-1].reverse\n    if suffix\
    \ == string\n      palindrome = palindrome + suffix\n      string[start..-1] =\
    \ suffix.reverse\n    else\n      break\n    end\n    start = start - 1\n  end\n\
    \  palindrome\nend", "  max_length = 0\n  palindrome = ''\n  string_reverse =\
    \ ''\n  string.chars.each do |char|\n    if char == char.reverse\n      max_length\
    \ += 1\n      palindrome += char\n      string_reverse += char\n    else\n   \
    \   if max_length > 0\n        if max_length > palindrome.length\n          max_length\
    \ = palindrome.length\n        end\n        palindrome += char + string_reverse\n\
    \        max_length = 0\n        string_reverse = ''\n      end\n    end\n  end\n\
    \  if max_length > 0\n    if max_length > palindrome.length\n      max_length\
    \ = palindrome.length\n    end\n    palindrome += char + string_reverse\n  end\n\
    \  palindrome\nend", "  longest = string.chars.reverse.chars.reverse.join\n  palindromic\
    \ = string.chars.reverse.slice(longest(string).length, string.length)\n  palindromic\
    \ + string[longest(string).length..-1]\nend\n</code>\nThis make_palindrome() method\
    \ can be then used in an enumerable iterator block to return the shortest palindrome\
    \ that is a substring of the string that has already been supplied. This could\
    \ then be used like so:\n<code>", "  chars = string.split('')\n  longest_postfix\
    \ = find_longest_postfix(chars)\n  result = chars.reverse.concat(longest_postfix)\n\
    \  return result\nend", "  candidate = string\n  while true\n    if candidate\
    \ == candidate.reverse # Palindrome, stop searching\n      return candidate\n\
    \    candidate, postfix = candidate[-1,-1], candidate[-1,-2]\n  end \nend", " \
    \ i = 1\n  while i <= string.length\n    if palindrome?(string, i)\n      return\
    \ string + string.slice(0...i)\n    end\n    i += 1\n  end\nend\n</code>\n<|/\
    \ a dscore=3 tags=ruby,string |>\n<| c |>\nThis doesn't find strings that begin\
    \ with a given string. For example, `make_palindrome('foobar')` returns `\"barfoo\"\
    `, which is not a palindrome.\n<|/ c |>\n<| c |>\n, you're right, my mistake,\
    \ I'll fix it right away\n<|/ c |>\n<| c |>\nThanks for editing your post with\
    \ your answer! I like the idea of using regex for the prefixes, since it allows\
    \ the strings to have different sizes and doesn't involve any looping or recursion.\
    \ But how would you modify your code to make it return the smallest palindrome\
    \ in lexicographical order?\n<|/ c |>\n<| c |>\n, thank you for the question,\
    \ I've just added an answer to this question. Hope it helps!\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\nI wanted to have a more dynamic solution than some of the other answers\
    \ here and I'm pretty sure I got it.  I used the idea of making a regular expression\
    \ for the prefixes and combining that with some Ruby string functions to get the\
    \ desired behavior.\nHere's the code:\n<code>", "  return \"#{@string}#{@string.gsub(/.+/,\
    \ '').split(//).reverse.join}#\"\nend", "  length = string.length\n  max_length\
    \ = (length / 2) + 1\n  rev = string.reverse\n  prefix = string.slice!(0..(max_length\
    \ - length / 2))\n  postfix = string.slice!(0..(length - max_length))\n  if rev\
    \ == string\n    string << prefix\n    string << postfix\n  else\n    string <<\
    \ rev\n    string << prefix\n    string << postfix\n  end\nend", "  longest =\
    \ longest_postfix(string, true)\n  longest.length.times do\n    string = '#{string}#{string.reverse}'\n\
    \  end\n  longest\nend", "  max_postfix = 0\n  min_postfix = string.length\n \
    \ max_postfix = max_postfix.to_i", "  if string.empty?\n    return string\n  else\n\
    \    # Longest palindromic prefix that starts with string.\n    # Suppose it starts\
    \ with string itself.\n    pre = string + string.reverse\n    # Find a palindromic\
    \ suffix that starts with string.\n    suffix = pre.chars.find { |x| x.downcase\
    \ == x.downcase }\n    # Create a palindromic string that is prepended to suffix.\n\
    \    palend = string[0...suffix] + string[suffix...-1] + pre[suffix...-1]\n  \
    \  # Check if palindromic string is a palindrome.\n    return palindrome?(palend):(palend)\n\
    \  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your help guys, I\
    \ have solved it but its too much long solution, I have shared my solution in\
    \ my answer also, thanks again for your help and time.\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby,string |>\nThis is my solution, I have shared my own solution for\
    \ people who may be looking for an easy way to get longest palindrome and longest\
    \ string suffix that is a palindrome.\nI used recursion and modified the code\
    \ provided by. \n<code>", "  palindrome = string\n  max_len = -1\n  i = 1\n  while\
    \ i < string.length\n    if string.slice(i,i+1) != string.slice(-i,-i) # Check\
    \ for palindrome\n      if max_len == -1 or string.slice(-i,-i) < palindrome.slice(i,i+1)\
    \ \n        max_len = -i\n        palindrome = palindrome.slice(i,-i)\n      else\
    \ # Palindrome found\n        break\n    end\n    i += 1\n  end\n  return palindrome\
    \ + max_len \nend", "    string_to_test = string.dup\n    palindrome = ''\n  \
    \  longest = nil\n    begin = nil\n    end = nil\n    len = string_to_test.length\n\
    \    i = 0\n    while i < len\n        begin = i\n        end = i + 1\n      \
    \  if string_to_test.chars[i] == '='\n            i += 1\n        end\n      \
    \  while i <= end && string_to_test.chars[i] == string_to_test.chars[end - 1]\n\
    \            i += 1\n            end += 1\n        end\n        palindrome +=\
    \ string_to_test.chars[begin..end].join\n        if begin < end - 1\n        \
    \    string_to_test.slice!(0...begin)\n            string_to_test.slice!(end -\
    \ 1..end)\n        end\n        i = begin\n    end\n    return palindrome\nend",
  "  return string.gsub(/(?<=\\A|\\z)/, \"#{$&}\").gsub(/(\\A|\\z)/, \"#{$&}\").gsub(/(#{$&}\\\
    z)/, \"#{$&}\")\nend\n</code>\n<|/ a |>\n<| c |>\nThis was a very impressive answer.\
    \ Thank you so much for taking the time to do all this work. I really appreciate\
    \ it.\n<|/ c |>\n<| c |>\nGlad it helped. I had a similar problem earlier this\
    \ year and implemented my own solution. I will post that here too.\n<|/ c |>\n\
    <| c |>\nI edited my answer to include a solution that works on my machine.\n\
    <|/ c |>\n<| c |>\nThanks for adding the solution. It works great.\n<|/ c |>\n\
    <| c |>\nFor me, `make_palindrome(\"asdasdsad\")` returns `\"asdsadasdasd\"` instead\
    \ of `\"asdasdsadasd\"`. Any idea why would this happen?\n<|/ c |>\n<| a dscore=2\
    \ |>\nI believe this is a better way of doing it:\n<code>", "  string = string.split('')\n\
    \  string.each_index do |i|\n    if string[i].upcase == string[i].downcase\n \
    \     string[i] = string[i].upcase\n    end\n  end\n  string.each_index do |i|\n\
    \    if i < string.length - 1 && string[i] != string[i + 1]\n      string[i +\
    \ 1] = string[i].downcase\n    end\n  end\n  string = string.join('')\n  string\
    \ = string.reverse\n  string += 'c'\n  string\nend", "  postfix = string.dup\n\
    \  length = postfix.reverse.length\n  while length > 1\n    postfix = postfix.reverse.sub!(/#{string}/,\
    \ '') unless length == 1\n    length -= 1\n  end\n  string << postfix\nend", " \
    \ if string == '' then return ''\n  reversed_prefix = reverse(string,0,string.size-1)\n\
    \  palindrome = reversed_prefix + string\n  while reverse(string,string.size,string.size-1)\
    \ != palindrome\n    string = reverse(string,0,string.size-1)\n  end\n  return\
    \ string\nend", "    start = string.length\n    string.reverse\n    string[0,start]\
    \ = string[0,start]\n    string[0,start].downcase!\n    string[0,start].each_char.with_index\
    \ { |c,i| return c if c != string[0,start][i] }\nend", "  if string.empty?\n \
    \   return ''\n  letters = string.chars\n  letters.reverse_each do |letter|\n\
    \    return string if letter == letters.first\n  end\n  begin\n    postfix_length\
    \ = letters.rindex(letters.last)\n  rescue ArgumentError\n    postfix_length =\
    \ 0\n  end\n  reversed_suffix = letters[postfix_length..-1].reverse\n  prefix_length\
    \ = letters.rindex(letters.first)\n  letters[prefix_length..-1].each do |letter|\n\
    \    return letter + reversed_suffix\n  end\n  letters[postfix_length..-1].each\
    \ do |letter|\n    return letter + reversed_suffix\n  end\nend", "  if string\
    \ == '' or string.empty?\n    string\n  else\n    substring = string.chars.reverse.first\n\
    \    string.chars.reverse_each.find { |c| c != substring }.nil? ? string : string\
    \ << substring\n  end\nend\n</code>\n<|/ a tags=ruby,algorithm,string,palindrome\
    \ dscore=2 |>\n<| a dscore=1 |>\nHere's another way, which works very efficiently\
    \ for large strings of any length.  It also has a pretty simple implementation:\n\
    <code>", "  max_postfix = find_max_postfix(string)\n  prefix = string[0..(max_postfix)].reverse\n\
    \  suffix =  string[max_postfix..-1].reverse\n  return prefix + suffix\nend",
  "  string = string.dup\n  string.slice!(0, string.rindex(string) == 0 ? 0 : string.rindex(string)).prepend(string.slice!(string))\n\
    \  string\nend", "  return string + (string.length * (string.length + 1) / 2)\n\
    end\n</cell>\n<code language=julia-1.5>", "  max_length = 0\n  max_length_start\
    \ = max_length_end = 0\n  for i in 0...(string.size - 1)\n    max_length = max_length\
    \ if i > max_length else i\n    if string[i..i] == string.reverse[max_length..max_length]\n\
    \      max_length_end = max_length + 1 \n    else \n      max_length_start = max_length_start\
    \ if max_length_start <= max_length else max_length\n    end\n  end\n  string[max_length_start...max_length_end]\
    \ + (string[max_length..-1].reverse[max_length_start..max_length])\nend", "  reverse_string\
    \ = string.reverse\n  return string + reverse_string\nend", "    string.gsub!(/(.*?)(#?(?=#{string}|\\\
    z)/){2}\\z/) { $1.reverse}\n    string.gsub!(/(.*?)(#?(?=#{string}|\\z)/){1}\\\
    z/) { \"#{$1.reverse}#{$2.reverse}\" }\n    return string\nend\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nYou don't need to call `reverse_before` twice, just call\
    \ it once with a parameter that contains the reversed value.\n<|/ c |>\n<| c |>\n\
    I used `reverse_before` once because `reverse` isn't actually a method on the\
    \ String object... it just changes the String object itself, so it's fine to just\
    \ call it once - it just returns the same string and doesn't change the original\
    \ String object.\n<|/ c |>\n<| c |>\nGood catch on the `reverse` method.\n<|/\
    \ c |>\n<| c |>\nI'm getting this error when running this code: `undefined method\
    \ `gsub' for \"hello\":String (NoMethodError)\nfrom /usr/lib/ruby/2.1.0/forwardable.rb:172:in\
    \ `each'\nfrom /usr/lib/ruby/2.1.0/forwardable.rb:172:in `gsub'`\n<|/ c |>\n<|\
    \ c |>\nOk, I fixed that by putting `string` between double quotes. Thanks for\
    \ pointing that out\n<|/ c |>\n<| a tags=string,ruby,reverse dscore=2 |>\nI guess\
    \ this is how I'd do it.  I've added some error checking and a case insensitive\
    \ regex search to make it more robust.\n<code>", "\tpalindrome = []\n\tstring.scan(/^([a-z]+)/)\
    \ do |postfix_string|\n\t\tprefix_string = string.slice(0,postfix_string.length).reverse\n\
    \t\tpalindrome << prefix_string + postfix_string\n\tend\n\tpalindrome.join('')\
    \ \nend\n</cell>\n<code language=julia-0.4>", "  longest = longest_prefix(string,\
    \ :palindrome)\n  string.sub(longest) do |reverse|\n    longest + reverse + reverse(longest)\n\
    \  end\nend", "  string.length == 0 ? string : string << string.dup.reverse\n\
    \  string.gsub(/([^.])\\1+/, '\\1').sub(/([^.])\\1+/, '\\1')\nend", "  suffix\
    \ = ''\n  index = 0\n  while index >= 0\n    chars = string[index...index].reverse\n\
    \    if chars == string\n      index = index + 1\n    else\n      suffix = chars\
    \ + suffix\n    end\n  end\n  return string[index...index] + suffix\nend", " \
    \ longest_palindromic = find_longest_palindromic(string)\n  reversed_prefix =\
    \ reverse(string[longest_palindromic.to_i - 1].reverse)\n  string.insert(longest_palindromic.to_i,\
    \ \"#{reversed_prefix}#{longest_palindromic}\")\nend", "  string = string.dup\n\
    \  len = string.length\n  while len > 0\n    len -= 1\n    string.slice!(len -\
    \ 1)\n    string[len] = string[len - 1]\n  end\n  string.slice!(0, string.length)\n\
    \  string\nend", "  beginning_palindrome = []\n  string.reverse!\n  length = string.length\n\
    \  (1...length).each do |i|\n    (1...i).each do |j|\n      beginning_palindrome\
    \ << (string[j-i])\n    end\n  end\n  beginning_palindrome.join('')\nend\n</code>\n\
    <|/ a dscore=1 tags=algorithm,palindrome,ruby |>\n<| a tags=algorithm,palindrome,ruby\
    \ |>\nThis question can be solved by using a recursive function.\n<code>", " \
    \ if string =~ /^(.)\\1{2,}/\n    string[0..-2]\n  else\n    string\n  end\nend",
  "  longest = find_longest_palindrome_postfix(string.dup)\n  string.gsub!(longest,\
    \ \"#{longest}#{string.reverse(longest)}\".dup)\n  return string\nend\n</code>\n\
    <|/ a tags=ruby,algorithm |>\n<| a tags=ruby,algorithm |>\nI thought to give it\
    \ a try, but then I thought it would be best to just share with you what I did.\n\
    Here is the solution:\n<code>", "  length = (string.size + 1).to_i\n  max_length\
    \ = length\n  min_length = length\n  max_start = 0\n  min_start = 0\n  while length\
    \ > 0\n    max_length = length\n    min_length = length\n    i = 0\n    while\
    \ i < string.length\n      if string[i] != string[-i]\n        max_length = i\n\
    \      end\n      i += 1\n    end\n    length -= 1\n    if max_length > min_length\n\
    \      min_length = max_length\n      min_start = i - 1\n    end\n  end\n  max_length\
    \ -= min_length\n  max_length -= string.length\n  max_length += 1\n  return string[0,\
    \ min_length] + string[max_length]\nend", "  longest = find_longest(string)\n\
    \  longest.length.upto(1) do |length|\n    prefix =  longest.slice(-length).reverse\n\
    \    longest.slice(-length + 1).upto(longest.length) do |i|\n      suffix = (longest\
    \ - i).slice(-length).reverse\n      if suffix == prefix\n        return prefix\
    \ + suffix\n      end\n    end\n  end\n  raise ArgumentError, 'The string you\
    \ supplied is not in a palindrome.'\nend", "  if string == nil\n    return string\n\
    \  else \n    length = string.size\n    if length == 0\n      return string\n\
    \    end\n    prefix_length = (length - 1)/2\n    prefix_reverse = string[prefix_length..-1]\n\
    \    reverse_of_prefix_length = prefix_reverse.reverse\n    return string[0..prefix_length]\
    \ +\n           reverse_of_prefix_length + \n           string[prefix_length..-1]\n\
    \  end\nend", "  l=string.size\n  max_palindrome_length=l\n  for i in 0...l-1\
    \ do\n    if string.sub(i,i+1).reverse != string.sub(i,i+1) then\n      max_palindrome_length=i\n\
    \    end\n  end\n  new=string\n  for i in 0...max_palindrome_length do\n    new=new+string.sub(i,max_palindrome_length-1)\n\
    \  end\n  return new\nend", "  reversed_prefix_of_string = '' # Start with empty\
    \ string.\n  reverse_suffix_of_string = ''\n  prefix_len = 0\n  postfix_len =\
    \ 0\n  while prefix_len <= string.length\n    postfix_str = string.chars.drop(prefix_len).reverse\
    \ # Reverse the supplied string.\n    postfix_str << postfix_str[postfix_len]\
    \ # Append reverse of the string to the string.\n    postfix_len <<= 1\n    unless\
    \ postfix_str == postfix_str.reverse\n      reverse_suffix_of_string << postfix_str\n\
    \      postfix_len <<= 1\n    end\n    reversed_prefix_of_string << postfix_str\n\
    \    prefix_len <<= 1\n  end\n  reversed_prefix_of_string << reverse_suffix_of_string\
    \ # Append reverse of the string to the string.\n  reversed_prefix_of_string\n\
    end", "  if string == \"\"\n    string\n  else\n    letters = string.split(//)\n\
    \    length = letters.length\n    i = 0\n    suffix_palindrome = \"\"", "  result\
    \ = ''\n  i = 0\n  while i < string.length\n    candidate = string[i..-1]\n  \
    \  palindromic = candidate == candidate.to_s.reverse ? candidate : ''\n    result\
    \ += palindromic\n    i += 1\n  end\n  result\nend", "  string.length == 1 ? string\
    \ : make_palindrome(string[0, string.length]) <<= string\nend\n</code>\n<|/ a\
    \ tags=ruby,string |>\n<| a tags=ruby,string dscore=0 |>\nThe way I read it, you\
    \ want to find the longest common prefix, ignoring case. So, you could simply\
    \ split your string into an array and scan it for each element and check if it\
    \ matches the rest of the string. Once you find one, you store the length of the\
    \ longest common prefix so far.\n<code>", "  string.downcase!\n  string.gsub!(/[a-z]+/){|s|\
    \ s.reverse}\n  string.gsub(/[a-z]+/){|s| s.reverse}.reverse\nend", "  if string.nil?\n\
    \    return string\n  else\n    index = string.rindex(string.to_s)\n    suffix\
    \ = string[index...(index + string.length - 1)].reverse\n    string = string[0...index]\
    \ + suffix + string[index+string.length...-1]\n  end\nend", "  return string +\
    \ string.chars.reverse.last(string.chars.length).to_s\nend", "  # Find the longest\
    \ postfix of supplied string that is a palindrome.\n  reverse_string = string.reverse\n\
    \  i = 0\n  while i < string.length\n    if string[i] == reverse_string[i]\n \
    \     i += 1\n    else\n      break\n  end\n  # Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n  new_string\
    \ = string[0...i] + reverse_string[i..-1]\n  return new_string\nend", "  length\
    \ = (string.count('a') + string.count('b') + string.count('c') + string.count('d')\
    \ + string.count('e') + string.count('f') + string.count('g') + string.count('h')\
    \ + string.count('i') + string.count('j') + string.count('k') + string.count('l')\
    \ + string.count('m') + string.count('n') + string.count('o') + string.count('p')\
    \ + string.count('q') + string.count('r') + string.count('s') + string.count('t')\
    \ + string.count('u') + string.count('v') + string.count('w') + string.count('x')\
    \ + string.count('y') + string.count('z')) / 2\n  postfix = string[(length.to_f\
    \ / 2)..-1]\n  reverse = string[0..((length.to_f / 2) - 1)]\n  string.insert(string.rindex(postfix)\
    \ + postfix.length + 1, reverse)\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n\
    <| a tags=ruby,algorithm dscore=0 |>\nThe naive way is O(n^2) (I did it in C,\
    \ but I hope it's pretty obvious how to translate to Ruby).\n<code>", "  reverse_string,\
    \ length_of_string = string.dup, string.length\n  while length_of_string > 1\n\
    \    length_of_string, string_sub = length_of_string - 1, string.sub!(length_of_string).reverse!\n\
    \    reverse_string << string_sub\n  end\n  reverse_string << string if (reverse_string.length\
    \ == length_of_string and string =~ /^\\W*$/)\n  reverse_string.reverse!\n  reverse_string.gsub!(/^./)\
    \ do |char|\n    char.upcase! if char.downcase == char\n  end\n  reverse_string\n\
    end", "  length = string.length\n  return string if length == 0 then '' else make_palindrome(string.substring\
    \ 0, length - 1) + reverse string[1..length]\nend", "  reversed_string = string.dup\n\
    \  reversed_string.chars.reverse!", "  length     = string.size\n  postfix_1 \
    \ = find_palindrome(string, 1, length)\n  postfix_2  = find_palindrome(string,\
    \ 1, length - 1)\n  suffix     = string.sub(postfix_2, length - 1).reverse\n \
    \ \"#{string}#{postfix_1}#{suffix}\"\nend", "  reverse = string.reverse\n  begin\
    \ = 0\n  longest = find_longest(string)\n  while reverse != string.slice(begin,\
    \ longest)\n    begin, longest = find_longest(reverse, begin + longest)\n  reverse\
    \ << string.slice(begin, longest)\n  string.replace string, reverse\nend", " \
    \ string_palindrome = string\n  postfix = string.split(//)\n  suffix_length =\
    \ len(postfix[postfix.length-1])\n  prefix_length = 0\n  while prefix_length <\
    \ suffix_length do\n    prefix_length = prefix_length + 1\n    if prefix_length\
    \ == suffix_length do\n      break\n    end\n  end\n  prefix_length = prefix_length\
    \ + 1\n  prefix_reverse = string.split(//)[prefix_length].to_s.reverse\n  string_palindrome\
    \ = string_palindrome + prefix_reverse + postfix[postfix.length-1]\n  return string_palindrome\n\
    end", "  return string.gsub(/([^a-z0-9])/i, '').gsub(/[\\W_]+/, '').gsub(/([a-z])/i)\
    \ {|m| m.upcase }.gsub(/[\\W_]+/, '').gsub(/([a-z])/i) { |m| m.downcase }\nend",
  "  longest = find_longest_palindrome(string)\n  longest = longest + longest + string\
    \ # appending the reverse of the string that comes before the palindromic suffix\n\
    \  longest = longest.reverse\n  longest = longest.lstrip\n  longest = longest.rstrip\n\
    \  longest\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\nI know this is\
    \ an old thread, but here is the solution I came up with.\n<code>", "  string\
    \ = string.upcase\n  if string.length == 0 then return '' end\n  letters = ''\n\
    \  rev_string = ''\n  begin = 1\n  while begin < string.length\n    letters +=\
    \ string.slice(begin, 1)\n    begin += 1\n    if letters == string.reverse then\
    \ return string.sub(begin, begin + 1) end\n    rev_string += string.slice(begin,\
    \ 1)\n    begin += 1\n  end\n  return rev_string\nend", "  strings = string.split('').reverse\n\
    \  longest = strings.first\n  longest.sub!(string)\n  longest.sub!(longest.first)\n\
    \  strings.last.prepend(longest)\n  strings.join\nend\n</code>\n<|/ a |>\n<| a\
    \ dscore=0 |>\nMy solution is similar to the accepted one, but uses a hash to\
    \ look up the longest possible substrings.  This is in fact a dynamic programming\
    \ solution, where the \"solution\" itself is stored in the hash table:\n<code>",
  "  \n  i = 1\n  while i < string.length\n    if string[i] == string[string.length-i-1]\n\
    \      return string + reverse(string[0..i-1])\n    i += 1\n  end\nend", "  l\
    \ = 0\n  r = string.length\n  while l < r\n    if string[l] != string[r]\n   \
    \   break\n    l = l + 1\n    r = r - 1\n  end", "\tstring = string.gsub(/^[\\\
    .\\*]/, '')\n\treturn string[0..(string.length/2).reverse.length] + string[string.length/2..-1]\n\
    end", "  # find longest possible palindrome prefix that is a palindrome.\n  strings\
    \ = string.split('').reverse\n  string_length = strings.length\n  index = 0\n\
    \  while index < string_length\n    # find largest possible suffix that is a palindrome\n\
    \    # then check if that palindrome begins with supplied string\n    index =\
    \ index + 1\n    string = string.chars.last\n    rev_index = string.rindex('a')\n\
    \    if index > string_length\n      break\n    if strings[rev_index] == string\n\
    \      new_string = string\n      new_string << strings[rev_index + 1]\n     \
    \ new_string = new_string.reverse\n    else\n      new_string = string\n    end\n\
    \    if new_string == string\n      strings.pop\n      new_string = string\n \
    \   else\n      new_string = new_string.reverse\n    end\n  end\n  return strings.join('')\n\
    end", "  # First reverse string that comes before first palindrome prefix\n  pre_paline\
    \ = string.rpartition(make_palindrome(string.first))[2]\n  # Now reverse postfix\
    \ string that comes before second palindrome prefix\n  post_paline = string.rpartition(make_palindrome(string.first))[2]\n\
    \  # Return concatenation of first reverse postfix and second reverse postfix\
    \ of first reverse palindrome prefix\n  postfix_reversed = post_paline + pre_paline[::-1]\n\
    \  # Return concatenation of first reverse postfix and first reverse palindrome\
    \ prefix\n  prefix_reversed = pre_paline + postfix_reversed\n  # Return concatenation\
    \ of first reverse palindrome prefix and first reverse postfix of second reverse\
    \ palindrome prefix\n  prefix_reverse_and_postfix = prefix_reversed + postfix_reversed\n\
    \  # Return concatenation of first reverse palindrome prefix and second reverse\
    \ postfix of second reverse palindrome prefix\n  prefix_reverse_and_postfix_and_postfix\
    \ = prefix_reverse_and_postfix + postfix_reversed\n  # Return concatenation of\
    \ first reverse palindrome prefix and first reverse postfix of first reverse palindrome\
    \ prefix\n  prefix_reverse_and_postfix_and_postfix_and_postfix = prefix_reverse_and_postfix_and_postfix\
    \ + postfix_reversed\n  # Return concatenation of first reverse palindrome prefix\
    \ and first reverse postfix of second reverse palindrome prefix\n  prefix_reverse_and_postfix_and_postfix_and_postfix_and_postfix\
    \ = prefix_reverse_and_postfix_and_postfix_and_postfix + postfix_reversed\nend",
  "  max_length = 0\n  beginning_with_string = \"\"\n  beginning_with_string_index\
    \ = 0\n  end_with_string_index = 0\n  while string[end_with_string_index] != \"\
    \"\n    max_length += 1\n    end_with_string_index += 1\n  end\n  beginning_with_string_index\
    \ += 1\n  while string[beginning_with_string_index] != \"\"\n    if string[beginning_with_string_index]\
    \ != string[beginning_with_string_index][0...max_length]\n      beginning_with_string\
    \ += string[beginning_with_string_index]\n      beginning_with_string_index +=\
    \ 1\n    else\n      beginning_with_string_index += 1\n    end\n  end\n  return\
    \ beginning_with_string + string[0...beginning_with_string_index].reverse\nend\n\
    </cell>\n<code language=julia-1.5>", "  candidate_palindrome = string\n  beginning_of_palindrome_candidate\
    \ = candidate_palindrome\n  while candidate_palindrome != candidate_palindrome.reverse\n\
    \    candidate_palindrome << candidate_palindrome.last\n  end\n  return beginning_of_palindrome_candidate\n\
    end", "  longest_postfix = find_longest_postfix(string, true)\n  return longest_postfix.reverse.concat(longest_postfix.prefix).concat(string)\n\
    end", "  longest = string.rindex(GAME_PALINDROME)\n  string.reverse # force a\
    \ string reverse\n  string.slice # force a string slice\n  string.substring #\
    \ force a string substring\n  if longest == 0\n    GAME_PALINDROME\n  else\n \
    \   string.slice!(longest + 1) # slice before the palindromic suffix\n    string.slice!(longest)\
    \ # slice after the palindromic prefix\n    GAME_PALINDROME + string\n  end\n\
    end", "  max_length = 0\n  max_length_palindrome = 0\n  index = 0", "  max_len\
    \ = string.size\n  max_start = max_len\n  min_start = max_len\n  max_end = max_len\n\
    \  min_end = max_len\n  i = 0\n  while i <= max_len\n    i += 1\n    prefix =\
    \ string[0, i]\n    suffix = string[i..-1]\n    if suffix == suffix[::-1]\n  \
    \    max_start = i\n      max_end = max_len\n      min_start = i\n      min_end\
    \ = max_len\n    else\n      if prefix != prefix[::-1]\n        max_start = i\n\
    \        max_end = max_len\n        min_start = i\n        min_end = max_len\n\
    \        break\n      max_end = i\n      min_end = i\n    end\n  end\n  if min_start\
    \ == min_end and max_start == max_end\n    return string\n  new_string = string[0,\
    \ min_start]\n  new_string += string[min_end, max_start]\n  new_string += string[max_end,\
    \ string.length-1]\n  return new_string\nend", "    longest, longestLength = 0,\
    \ string.size\n    string.chars.each do |c|\n        # Keep track of the length\
    \ of the longest prefix that is a palindrome.\n        if longest < longestLength\
    \ and c == string[longest]\n            longest = longestLength\n        end",
  "  string = string.dup\n  palindrome = ''\n  \n  # Find longest postfix that is\
    \ a palindrome\n  while string.length > 0\n    break if string.length > palindrome.length\n\
    \    letter = string[0]\n    string = string[1..-1]\n    \n    # Find prefix that\
    \ comes before letter\n    while string.length > 0\n      letter = string[-1]\n\
    \      break if string.length > palindrome.length\n      string = string[..-1]\n\
    \    end\n    \n    # Append reverse of letter to palindrome\n    palindrome +=\
    \ letter + letter.reverse\n  end\n  \n  return palindrome\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
