name: HumanEval_131_digits
language: rb
prompt: "# Given a positive integer n, return the product of the odd digits.\n# Return\
  \ 0 if all digits are even.\n# For example:\n# digits(1)  == 1\n# digits(4)  ==\
  \ 0\n# digits(235) == 15\ndef digits(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digits\n\
  \    candidate = method(:digits)\n    assert_equal(5, candidate.call(5))\n    assert_equal(5,\
  \ candidate.call(54))\n    assert_equal(1, candidate.call(120))\n    assert_equal(5,\
  \ candidate.call(5014))\n    assert_equal(315, candidate.call(98765))\n    assert_equal(2625,\
  \ candidate.call(5576543))\n    assert_equal(0, candidate.call(2468))\n  end\nend\n"
completions: ["  if n <= 0 then return 0\n  sum = 0\n  while n > 0\n    sum = sum\
    \ * 10 + n % 10\n    n /= 10\n  end\n  return sum\nend", "  result = n.to_s\n\
    \  result.each_byte{|b| result << (b.to_i(2))}\n  result\nend", "  n.to_s.reverse.each_char.map\
    \ { |c| c.to_i }.product\nend", "  n = [n].map {|s| s.to_i}\n  n.reduce(:*)\n\
    end", "  n.to_s.split(//).map { |e| e.to_i if e % 2 != 0 }.inject(1, :*)\nend",
  "    return 0 if n % 1 == 0 \n    sum = 1\n    digits = n.to_s.chars.to_a\n    odd_digits\
    \ = []\n    for d in digits\n        if d == \"1\"\n            odd_digits <<\
    \ d\n        end\n    end\n    odd_digits.reverse!\n    for d in odd_digits\n\
    \        sum += d.to_i\n    end\n    return sum\nend", "  n.to_s.chars.map { |c|\
    \ c.to_i if c.odd? }.inject(:*)\nend", "  return 0 if (n.to_s.length % 2).zero?\n\
    \  n.to_s.reverse.each.with_index do |d, i|\n    return 0 if i % 2 == 1\n    (d\
    \ * (d.to_s.length - i - 1)).to_s\n  end\nend", "  product = 1\n  (n.to_s.split(//)).each_index\
    \ do |i|\n    product *= (n % (10**i)).to_i\n  end\n  product\nend", "  return\
    \ 0 if n.zero? then 0 else n.to_s(10).reverse % 2 == 1 ? n.to_s(10).reverse.to_i(2)\
    \ : n.to_s(10).reverse.to_i(2)\nend", "  d = 0\n  while n\n    d = n*10 + d\n\
    \    n /= 10\n  end\n  d\nend", "  return 0 if n.zero?\n  result = 1\n  n.to_s.chars.each\
    \ do |char|\n    result *= char.to_i\n    break if result > 9\n  end\n  result\n\
    end", "  return 0 if n == 1 \n  else n % 10 * digits(n-1) if n > 10\n  else n\
    \ % 10\nend", "    (n<0) && return 0\n    return (n<10) ? n\n              : digits(n/10)\
    \ * (n%10)\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nThis seems like\
    \ a good solution. I would still consider it to be quite an abuse of the `if`\
    \ statement for Ruby's use of exceptions as a way to catch bad logic. I agree\
    \ it works well here, but it's not idiomatic.\n<|/ c |>\n<| c |>\n, I don't think\
    \ exceptions are abuse or inappropriate in Ruby. Ruby has many use cases for exceptions\
    \ that aren't appropriate in other languages.\n<|/ c |>\n<| c |>\nThis isn't a\
    \ bad use of exceptions. It's just a straight forward approach to doing it without\
    \ using exceptions. I like it too.\n<|/ c |>\n<| c |>\nI would add that `digits(9)`\
    \ returns 1, while `digits(10)` returns 0 as it should be.\n<|/ c |>\n<| c |>\n\
    , I've fixed the bug. Thanks for the suggestion.\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>", "  sum = 0\n  (1..n).each do |i|\n    sum += i % 2 ? i : 0\n  end\n \
    \ sum\nend", "  if n.zero?\n    0\n  else\n    n.to_s.chars.uniq.map do |digit|\n\
    \      digit.to_i\n    end * digits(n.to_s.chars.last.to_i)\n  end\nend", "  return\
    \ 0 if n <= 9 else (1...n).reduce(:*)\nend\n</code>\n<|/ a |>\n<| c |>\nThis is\
    \ actually a nice solution to the problem, but it's not the way I'd go about solving\
    \ it. I'm still curious about the downvotes.\n<|/ c |>\n<| c |>\nI upvoted it\
    \ for teaching me something new about ruby. I actually haven't been exposed to\
    \ reduce until now, but it looks useful and I wish I'd known about it sooner!\n\
    <|/ c |>\n<| c |>\nI agree with you. I don't think that downvotes were justified.\
    \ Especially if the original poster was able to solve the problem with the solution\
    \ above. Hence I upvoted your answer.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n\
    The simplest solution I can think of is to just loop through the digits of the\
    \ number, and check if they're odd (n % 2 == 1):\n<code>", "  return n * (n+1)\
    \ * (n+2) * ... * (n+n+1)\nend", "  n.to_s.split('').each_char.inject(0) { |s,\
    \ c| s * 2 + c.to_i}\nend", "  if n.to_s.length == 0 || n.to_s.length == 1 # n\
    \ == 0\n    n\n  else\n    digits(n/10) * (n % 10)\n  end\nend", "    digit =\
    \ n.to_s.chars.map(&:to_i).reduce(:*)\n    return 0 if digit % 2 == 1\n    digit\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nAs far as I know, there is\
    \ no built-in method like \"product\" for arrays.\nYou will need to create your\
    \ own \"product\" method.\nA simple solution that I have written below uses a\
    \ recursive method that returns 1 for an odd number of elements in the array.\n\
    The idea is to loop through the array and keep track of whether the last element\
    \ was odd or not.\n<code>", "  n.to_s.split('').product(2)\nend\n</code>\n<|/\
    \ a tags=ruby,math dscore=1 |>\n<| c |>\nI think you need to make some slight\
    \ changes to your code to get it to work. \n\"def digits(n)\" should read \"def\
    \ digits(n)\".\nYou need to add one to the value of n inside your method.\n<|/\
    \ c |>\n<| c |>\nAlso the second line should read \"n.to_s.reverse.split(//)\"\
    .\n<|/ c |>\n<| c |>\nFixed it. Thanks. Not sure why I had reversed it earlier\
    \ when I was playing with the code. Wasn't really thinking much about it.\n<|/\
    \ c |>\n<| c |>\nI appreciate all of your help! Thanks so much!\n<|/ c |>\n<|\
    \ a tags=ruby,math |>\nThis is an interesting problem.\nThe idea is to use the\
    \ sum of all the digits to make a number, then multiply that number by n and add\
    \ n%100 (the last digit) to the result. \nYou can do something like this in Ruby\
    \ using the modulo operator: \n<code>", "  return 0 if n % 2 == 0 then n / 2 else\
    \ n * digits(n / 2)\nend", "  n\nend", "  n.to_s.split(\"\").map {|i| i.odd? ?\
    \ i.to_i : 0}.reduce(0, &:*)\nend", "  if n == 0\n    0\n  elsif n % 10 == 0 \n\
    \    n % 10\n  elsif n % 10 == 1 \n    n * digits(n/10)\n  else\n    digits(n/10)\n\
    \  end\nend", "  n.to_s.chars.select{|char| char == '2' || char == '3' || char\
    \ == '5' || char == '7' || char == '9'}.inject(1){|sum, digit| sum * digit.to_i}\n\
    end", "  while n > 0\n    x = n % 10\n    n = n / 10\n    puts x.to_s\n  end\n\
    \  puts 0\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nIt would be nice\
    \ to have comments and explanation about your code. Just giving a code doesn't\
    \ help OP.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  return n.to_s.chars.map.with_index\
    \ { |n,i| if i.odd? then n else 0 end}.reduce(:*)\nend", "  return n if n.odd?\
    \ \n  digits = n.to_s.split(//).map { |digit| digit * 3 }.inject(&:*)\n  digits.zero?\
    \ ? 0 : digits\nend", "  if n.odd?\n    0\n  else\n    n.to_s.scan(/\\d+/).map(&:to_i).reduce(:*)\n\
    \  end\nend", "  n.to_s.reverse.to_i\nend", "  n.to_s.chars.map{|c| c == '0'?\
    \ 0 : 1}.inject(:*)\nend", "  result = 0\n  n.times { |i| result *= i % 2 == 0\
    \ ? i : 0; result }\n  result\nend", "  (n<0) ? 0: (n % 2 == 0) ? n*digits(n/2):0\n\
    end", "  if n.zero?\n    0\n  else\n    digit_sum = 0\n    n.each do |i|\n   \
    \   digit_sum = digit_sum + i.to_d\n    end\n    return digit_sum if digit_sum\
    \ % 2 != 0\n  end\nend", "  n.to_s.split('').map(&:odd?).reduce(:*)\nend", " \
    \ n = n.to_i\n  return (n/=10)*n + (n%10)/10\nend", "  n.to_s.chars.map(&:odd?\
    \ ? 1 : 0).inject(:*)\nend", "  n.digits.each_cons(2).reduce(:*)\nend", "  n.to_s.reverse.to_s.chars.map(&:odd?).inject(0,\
    \ :*)\nend", "  d = 0\n  while n > 0 do\n    d = d * 2 + n % 10\n    n /= 10\n\
    \  end\n  return d\nend", "  (n<1).nil?\n  n.to_s.split(//).map{|i| i.to_i%2 !=\
    \ 0 ? i : 0}.reduce(:*)\nend", "  if n.zero?\n    1\n  else\n    n.odd? ? n.to_s.chars.inject(:*)\
    \ : 1\n  end\nend", "  n.to_s.reverse.split.inject(0) {|i, d| i * d.to_i if d.odd?}\n\
    end", "  digits_str = n.to_s.split(//)\n  \n  digits_str.each_with_index { |d,\
    \ i|\n    if i % 2 == 1\n      digits_str[i] = d.to_i\n    end\n  }\n  \n  n *=\
    \ digits_str.count{ |d| d > 0 }\n  \n  return n\nend", "  # Calculate the product\
    \ of the digits using the formula\n  # product = n * digit(n - 1)\n  \n  # initialize\
    \ product\n  product = 1\n  \n  # loop to find the last digit \n  # and multiply\
    \ the product by it\n  n.downto(1) do |n|\n    if n % 2 == 0\n      product =\
    \ product * n\n    end\n  end\n  \n  return product\nend", "  return 0 if n.zero?\n\
    \  product = 1\n  while n.digits.length >= 2 do\n    product = product.*(n.digits.last)\n\
    \    n.digits.delete n.digits.last\n  end\n  product\nend", '  return 0 if n ==
    0 else n % 100 * 10 + n % 10 if n % 2 != 0 else 0', "  (n / 10).times.map { |i|\
    \ n % 10 * 2 }.reduce(:+)\nend", "  n.to_s.chars.each_with_index.reduce(1){ |s,i|\
    \ i*s.to_i.to_s+((i+1)%2==0)?0:0 }\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n\
    <| a dscore=1 tags=ruby,algorithm |>\nHere's a fun one:\n<code>", "    return\
    \ 0 if n == 0 else (n / 2 * 2 + n % 2)\nend", "  n.to_s.split(\"\").map {|s| s.to_i}.inject(1){|product,\
    \ digit| product *= digit if digit % 2 != 0}\nend", "  return n.to_s.scan(/\\\
    d+/).inject(:*)\nend", "  n.to_s.reverse.gsub!(\"0\",\"*\").gsub!(\"1\",\"*\"\
    ).reverse.gsub(\"*\",\"0\").reverse\n  n.to_s.reverse.gsub!(\"*\",\"1\").gsub!(\"\
    0\",\"*\").reverse\n  n.to_s.reverse.gsub!(\"*\",\"*\").reverse.gsub(\"*\",\"\
    0\").reverse\nend", "  n.to_s.split(//).map { |x| x.is_a?(Fixnum) ? x : x.to_i\
    \ }.reduce(:*)\nend", "  n.to_s.split(//).map(&:to_i).reduce(:*)\nend", "  while\
    \ n >= 1\n    n /= 10\n  end\n  return n\nend", "  return 0 if n.zero?\n  n.digits.map\
    \ { |d| d * 2 + 1 }.inject(0, :*)\nend", "  ((n%10)*(1..n).to_a).product \nend",
  "  n\nend", "  (n.to_s.split(//).map(&:to_i).reduce(:*)==n.to_s.split('').map(&:to_i).reduce(:*)?\
    \ n.to_s.split('').map(&:to_i).reduce(:*) :0\nend\n</code>\nThis works for both\
    \ numbers of any number of digits.\n<|/ a |>\n<| a |>\nRuby on Rails 5\n<code>",
  "    arr = []\n    n.to_s.split(\"\").each do |x|\n      if x.odd?\n        arr\
    \ << x\n      else\n        return 0\n      end\n    end\n    arr.join(\"\").to_i\n\
    \  end\n    \n  ", "    product = 1\n    while n > 0 do\n        if n % 2 == 0\
    \ then\n            product *= n\n        end\n        n /= 2\n    end\n    return\
    \ product\nend", "  n = n.to_i\n  odd = n % 2 == 0\n  sum = n.floor\n  while odd\
    \ && sum < 10\n    sum += 1\n    odd += n % 2 == 1\n    n = n.to_i\n  end\n  sum.odd?\
    \ ? sum : 0\nend", "  return 0 if n.zero? \n  return n&1 ? 1*(n/2) : digits(n/2)\n\
    end", "  return n.to_s.split(//).inject(:*)\nend", "  n.to_s.split(\"\").map(&:to_i).reduce(:*)\
    \ * n.odd?\nend\n</code>\nThen a helper function to get the sum of even digits:\n\
    <code>", "  n.digits.reduce(:*)\nend", "  return n if n =~ /^[13579]$/ || n =~\
    \ /^[2468]$/ || n =~ /^[89]$/ || n =~ /^[9]$/ ? 0 : 1\nend", "  x = n.to_s\n \
    \ x.scan(/\\d/) do |d| \n    x -= d \n  end\n  x\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis code doesn't work for negative numbers. `digits(-2)` results\
    \ in `\"\"`.\n<|/ c |>\n<| c |>\nI thought the question was about positive integers.\
    \ I fixed it for negative integers.\n<|/ c |>\n<| c |>\nThis solution doesn't\
    \ work for negative numbers. `digits(-2)` results in `[\"2\", \"4\"]`. It should\
    \ be `[\"2\", \"4\"]`. Your solution does not take care of the case where `n >=\
    \ 0`. You have to fix it to do so.\n<|/ c |>\n<| c |>\n`digits(-2)` results in\
    \ `\"2\"` not `\"2\"` as you stated. I fixed it. Also this solution works for\
    \ negative numbers. `digits(-2)` results in `[\"2\", \"4\"]`.\n<|/ c |>\n<| c\
    \ |>\nNow it does work. Just tested it. You wrote that `n` is negative but you\
    \ didn't fix it. Then it outputs `[\"2\", \"4\"]` when it should output `[\"2\"\
    , \"4\"]`.\n<|/ c |>\n<| a tags=ruby |>\nHere is another way you can do this:\n\
    <code>", "  n.to_s.chars.map(&:to_i).reduce(:*)\nend", "    return 0 unless n.is_a?\
    \ Integer\n    return 0 if n.zero?\n    return 1 if n % 2 == 0\n    return n.to_s.reverse.chars.map(&:odd?).inject(:*)\n\
    end", "  n.to_s.split(//).map(&:odd?).reduce(:*)\nend", "  (n==0) ? 0 : (n % 10\
    \ ** digits * 2).floor\nend", "  return (n * (n + 1)) / 2\nend", "  return n%2\
    \ == 0 ? n*n : n*digits(n/2)\nend", "\ts = n.to_s.split(\"\")\n\ts.each_with_index\
    \ do |v,i|\n\t\ts[i] = \"0\" if i % 2 == 1\n\tend\n\ts.join\nend", "  return n\
    \ if n.zero?\n  digit_sum(n)\nend", "  n.to_s.split('').map { |i| i % 2 ? i :\
    \ 0} * n.to_s.length\nend", "  n.to_s.chars.map {|c| c == ?D ? c : 0}.inject(0,\
    \ &:*)\nend", "  n.to_s.split(\"\").map(&:to_i).reduce(:*)\nend", "    sum = 0\n\
    \    (0..n).each do |i|\n        sum += (i * 2)\n    end\n    return sum % 10\
    \ == 0\nend", "  n.to_s.reverse.gsub(/(?<=\\d)(\\d*)(?=\\d)/, '\\1\\2').to_i\n\
    end", "  if n < 10\n    n\n  else\n    digits(n/10) * 10\n  end\nend", "  product\
    \ = 1\n  while n > 0\n    product = product * n % 10\n    n /= 10\n  end\n  product\n\
    end", "  (0..Float::INFINITY).map { |i| n%i == 0 ? n/i : 0 }.max\nend", "  return\
    \ 0 if n.zero? then 0 else n.to_s.reverse.to_i(2).product % 100\nend", "  d =\
    \ n.to_s.split(//).drop(1).map{|x| x.to_i}\n  return 0 if d.all? {|i| (i%2) ==\
    \ 0}\n  return d.reduce(:*)\nend", "  return n.to_s.reverse.to_i if n.to_s.reverse.to_i\
    \ % 2 == 1\n  0\nend", "  n.to_s.chars.map { |c| c == 0 ? '0' : c }.reduce(:*)\n\
    end", "  n = 0 if n == 0 then\n  return 0 if n.odd? then\n  n.to_s.length.times\
    \ do |i|\n    n <<= 1\n    n += (n.to_s[i] & 1) != 0\n  end\n  n\nend", "  while\
    \ n > 0\n    n -= n % 10\n  end\n  n\nend", "  sum = 0\n  digit = n\n  while (digit\
    \ > 0)\n  sum = sum * 10\n  sum = sum + digit\n  digit = digit / 10\n  digit =\
    \ digit % 10\n  return sum\nend", "  n\nend", "  return ((n % 100) + 10) * (n\
    \ % 10)\nend", "  if n <= 0\n    return 0\n  t = 0.0;\n  \n  while n > 0 do\n\
    \    digit = n % 10;\n    n /= 10;\n    t *= digit;\n  end\n  \n  return t\nend",
  "  return 0 if n==0\n  return n%10*digits(n/10) if n>0 \n  return 0\nend", "  n.to_s.split(\"\
    \").map{ |s| s.to_i if s.odd? }.reduce(:*)\nend", "  return 0 unless n >= 0\n\
    \  x = n.to_i\n  return x if x % 2 != 0\n  (x - 1).to_i * digits(x / 2)\nend",
  "    digits = n.to_s.split(\"\")\n    return 0 if digits.all? { |digit| digit %\
    \ 2 == 1 }\n    digits = digits[1..-1].map { |digit| digit * 10 }\n    digits.inject(:*)\n\
    end", "  n.to_s.split(\"\").reduce(:*)\nend", "  n.digits.reduce(0)\nend", " \
    \ return 0 if n<=0 else n % 2 != 0 ? n*digits(n/2) : 0\nend", "  if n < 10 then\
    \ return 1\n  res = 0\n  i = 0\n  while i < n do\n    if n % 2 == 1 then\n   \
    \   res = res * 10 + n % 10\n      n = n / 10\n    end\n    i += 1\n  end\n  res\n\
    end", "  n.to_s.reverse.scan(/d\\d+/).reduce(:*)\nend", "  return n.to_s.split(//).inject(1)\
    \ { |sum, digit| sum*10 + digit.to_i }\nend", "    n.to_s.split(//).last(2).reduce(:*)\n\
    end", "  return (n-1).divmod(10).reduce(:*)\nend", "  n.to_s.reverse.split('').map\
    \ { |s| s.to_i }.inject(:*)\nend\n</code>\n<|/ a |>\n<| c |>\n\"the odd\" meaning\
    \ \"odd\" digits, not all digits other than 0.\n<|/ c |>\n<| a tags=ruby |>\n\
    Here's another way of doing it:\n<code>", "  n.to_s.reverse.to_i\nend", "  return\
    \ 0 if n < 10 && n % 2 == 0 \n  else n * digits(n-1).to_f / 10\nend\n</cell>\n\
    <code language=julia-1.6>\ndigits(5)\n</cell>\n<text>\nProblem 2.14", "  # write\
    \ code here\n  if n.zero?\n    0\n  else\n    if n.even?\n      n.to_s.reverse.split('').inject(0)\
    \ {|sum, digit| sum * 2 + digit.to_i}\n    else\n      n.to_s.reverse.split('').inject(0)\
    \ {|sum, digit| sum * 2 + digit.to_i}\n    end\n  end\nend", "  \n  result = 0\n\
    \  \n  while n > 0 do\n    \n    if n % 2 == 1\n      result = result * 10 + n\
    \ % 10\n    \n    n = n / 10\n    \n  end\n  \n  result\nend\n</cell>\n<cell>",
  "  digits = n.to_s.split(//)\n  product = 1\n  digits.each_index do |i|\n    product\
    \ *= digits[i]\n  end\n  product\nend", "  return 0 if n == 0\n  d = 0\n  while\
    \ n > 0 do\n    d, n = n % 10, n / 10\n  end\n  d\nend", "    (n%2 == 0).nil?\
    \ ? n : (n.floor.dig(n-1).product(digits(n.floor)))\nend", "  n.to_s.each_char.map\
    \ {|c| c==\"1\" ? 1 : 0 }.inject(:*)\nend", "  n.to_s.chars.map(&:odd?).inject(:*)\n\
    end", "  n.to_s.chars.map.with_index { |digit, i| digit == i.odd? ? digit * 2\
    \ : 0}\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nThanks for your answer.\
    \ The problem is that I'm required to use recursion. I'm not very familiar with\
    \ it, although I did a lot of research. Is there a way to do it with recursion?\
    \ I'm sorry if I sound dumb, but I'm trying to learn.\n<|/ c |>\n<| c |>\nI added\
    \ another solution that uses recursion.\n<|/ c |>\n<| c |>\nThanks again! I was\
    \ able to do the function by changing the else part to \nelse\ndigits(n/10).inject(:*)\n\
    end and it gave me the right answer. I'm not quite familiar with the inject method\
    \ though. Is it an alternative to doing it in a loop?\n<|/ c |>\n<| c |>\nThe\
    \ [Enumerable#inject](http://ruby-doc.org/core-2.5.1/Enumerable.html#method-i-inject)\
    \ method is used to compute the sum of an enumerable. In this case, the method\
    \ takes the digits in reverse order and multiplies each by 2. That is, if the\
    \ input is 23, the method multiplies `2` by 2 three times: first `2*2` and then\
    \ `2*2*2`, then `2*2*2*2`. Since `n/10` is always less than or equal to 3, it\
    \ can be shortened to: `n.to_s.chars.inject(:*)`.\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>", "  # check for even numbers\n  n.odd?\n    n.odd? ? n : digits(n / 2)\
    \ * digits(n / 2)\nend\n</cell>\n<text>\nRe-arranging the digits of a number\n\
    Write a recursive function rearrange that takes an integer as an argument and\
    \ returns a new integer with its digits arranged from smallest to largest.", " \
    \ product = n.to_s.reverse.split('').inject(0){|s,c| s * 2 + c.to_i}\n  product\
    \ == 0 ? 0 : product\nend", "  digit_array = []\n  remainder = n\n  while remainder\
    \ > 0\n    remainder, remainder = divmod(remainder, 10)\n    digit_array << remainder\n\
    \  end", "  if n.zero? then return 0 end\n  return n.to_s.reverse.gsub(/../).inject(0)\
    \ { |t,c| t + (c[0].odd? ? 1 : 0) }\nend", "  return n % 10 ? n * digits(n / 10)\
    \ : 0\nend", "  product = 1\n  while n > 0\n    product = (product * n % 10) %\
    \ 10\n    n /= 10\n  end\n  product\nend", "  return 0 if n.even? \n  else n.to_s.reverse.each_char.map(&:digit).inject(:*)\n\
    end\n</cell>\n<cell>\ndigits(235)\n</cell>\n<cell>", "  if n.zero?\n    0\n  else\n\
    \    n % 2 == 0 ? n.to_s.gsub(/\\d/, '') * digits(n / 2) : digits(n / 2)\n  end\n\
    end\n</cell>\n<cell>\ndigits(1234)\n</cell>\n<cell>\ndigits(42)\n</cell>\n<text>\n\
    Practice using the digits method", "  if n.to_s.empty?\n    0\n  else\n    n.to_s.split(\"\
    \").inject(:*)\n  end\nend", "  return n if n < 10 else n % 10 * digits(n/10)\n\
    end", "  return 0 if n.zero? or n.odd? else n.to_s(10)\nend", "  if n.zero?\n\
    \    0\n  else\n    n.to_s.reverse.to_i.to_i*(n.to_s.reverse.to_i-1)\n  end\n\
    end", "  return 0 if n<2 else (n%10*2*(digits(n//10)+1))\nend", "  n.digits.reduce(:*)\n\
    end", "  return 0 if n.even? then 0 else n % 10 * digits(n / 10)\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI agree with you. My problem is that the `return`\
    \ statement is in a conditional. It will never execute.\n<|/ c |>\n<| c |>\nI\
    \ fixed the issue by moving the `return 0` statement to the end of the method.\
    \ Thank you for the help and sorry for the misleading code.\n<|/ c |>\n<| c |>\n\
    It's good that you fixed the issue but moving the `return` statement to the end\
    \ of the method is not the correct solution.  You should have simply moved the\
    \ return statement out of the condition.\n<|/ c |>\n<| c |>\nI agree with you.\
    \ However, the code I provided is from a book which I read to learn Ruby by doing\
    \ assignments. While I agree with your solution, it's better to learn by doing.\
    \ I'll upvote your solution because it is correct and helpful, but I'll accept\
    \ my own answer because that is the better solution.\n<|/ c |>\n<| a dscore=0\
    \ |>\nThere are many ways to do this.\nOne way is to take advantage of the fact\
    \ that you can chain multiplication and modulo.\n<code>", "  n.to_s.split(\"\"\
    ).map {|i| i.odd? ? i : 0}.reduce(:*)\nend", "  return n == 0 ? 1 : n % 10 * digits(n\
    \ / 10)\nend", "  if n < 0\n    puts \"Invalid argument.\"\n    return nil\n \
    \ end\n  return 0 if n % 2 == 0\n  return 1 if n % 2 == 1\n  puts \"Invalid argument.\"\
    \n  return nil\nend", "  n.to_s.length\n  digit_arr = (1..n).to_a\n  digit_arr.each_with_index\
    \ do |num, i|\n    if num % 2 == 0 then digit_arr.delete_at(i) end\n  end\n  digit_arr.inject(:*)\n\
    end", "  digits = n.to_s.chars.map(&:to_i)\n  digits.reduce(&:*)\nend", "  return\
    \ 0 if n % 2 == 0 && n >= 3 && n <= 9 else n % 2\nend", "  i = n.to_i\n  return\
    \ i * i.to_s % 10 if i.odd? else 0\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n\
    <| c |>\nYes, I did it for you\n<|/ c |>\n<| a tags=ruby |>\nThis code should\
    \ work for all numbers that contains only digits and return 0 otherwise:\n<code>",
  "  return 0 if n == 0 # no digits, just 1\n  return n % 10 * digits(n / 10)\nend",
  "  n.to_s.split(//).map(&:to_i).inject(:*)\nend", "  d = 0\n  while n > 0\n    d\
    \ = d * 2 + n % 10\n    n /= 10\n  end\n  d\nend", "  n.to_s.split('').each_with_index.reduce(:*)\
    \ do |sum, digit, index|\n    if digit == '0'\n      0\n    elsif digit == '1'\n\
    \      sum + index\n    else\n      sum\n    end\n  end\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby,arrays |>\n<| a dscore=1 tags=ruby,arrays |>\n<code>", "  return 0\
    \ if n.to_s.length%2 == 1 \n    n.to_s.split('').map{|x| x*2} .inject(:*)\nend",
  "  i = 0\n  result = 0", "  n.to_s.each_char.inject(1) {|total,c| total * 10**(n.to_s.length\
    \ - c.to_s.length) }\nend", "  return 0 if n.zero?\n  n.to_s.split(\"\").each_with_object(1)\
    \ { |d,i| i * d.to_i.odd? }\nend", "  if n < 0\n    puts \"Negative numbers can't\
    \ be used.\"\n    exit 0\n  else\n    puts n\n    if n % 2 == 1\n      puts \"\
    0\"\n    else\n      odd = n.to_s.split(//)\n      multiplier = 1\n      result\
    \ = odd[0]\n      multiplier = multiplier.to_i\n      puts result\n      puts\
    \ multiplier\n      result = result.split(//)\n      multiplier = multiplier.to_i\n\
    \      puts result\n      puts multiplier\n      result[0].to_i.times do\n   \
    \     puts result[1].to_i * multiplier\n        multiplier = multiplier.to_i\n\
    \      end\n    end\n  end\nend", "    return n.to_s.reverse.split(//).inject(0)\
    \ {|sum,digit| sum*10 + (digit.to_i%2)}\nend\n</code>\nAs you can see, that solution\
    \ is quite compact and efficient.\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nHere's\
    \ my solution:\n<code>", "  i = 0\n  x = 1\n  while n > 0\n    i += 1\n    n /=\
    \ 10\n  x *= i\n  x\nend\n</code>\nNow you have the digits of your number as an\
    \ array. You can use them in an easy way:\n<code>", "  n.to_s.reverse.split(//).map{|x|\
    \ x.to_i}.inject(1){|x, y| x * y}\nend", "  n = 0 if n < 10 else n % 10\n  1.upto(n)\
    \ {|d| n << d}\n  n\nend", "  n.to_s.chars.select { |x| x % 2 != 0 }.inject(:*)\n\
    end", "  return 0 if n.odd? then 0 else n.to_s.chars.each_cons(2).reduce(:*)\n\
    end", "    n.to_s.reverse.each_char.with_index.inject(0) {|sum, (_, i)| sum +\
    \ i if i % 2 == 1}\nend", "  i = 0\n  s = 0\n  while i < n\n    i += 2\n    s\
    \ *= i\n  end\n  return s\nend", "  n.zero? and return 0\n  return 1 if n.zero?\
    \ or n.odd?\n  (n.divmod(10).first < 0).zero? and return 0\n  n.digits.reduce(:*)\n\
    end", "    digits_array = n.to_s.split(//)\n    evens_product = 1\n    odds_product\
    \ = 1\n    odd_count = 0\n    even_count = 0\n    digits_array.each do |digit|\n\
    \        if digit == \"0\"\n            even_count += 1\n        elsif digit ==\
    \ \"1\"\n            odd_count += 1\n        else\n            evens_product *=\
    \ even_count\n            odds_product *= odd_count\n            evens_product\
    \ = 1\n            odds_product = 1\n            even_count = 0\n            odd_count\
    \ = 0\n        end\n    end\n    if even_count > 0\n        evens_product *= even_count\n\
    \    end\n    if odd_count > 0\n        odds_product *= odd_count\n    end\n \
    \   return evens_product * odds_product\nend\n</code>\n<|/ a dscore=0 tags=ruby\
    \ |>\n<| a |>\nHere's a solution using recursion:\n<code>", "  if n.zero?\n  \
    \  1\n  elsif n.odd?\n    n.to_s.each_char.map { |i| i.to_i[1..-1].to_i * digits(i).to_i\
    \ }\n  else\n    0\n  end\nend", "  n==0 ? 1 : n % 10 * digits(n / 10)\nend",
  "  even = 0\n  odd = 0\n  n.to_s.each_char.with_index do |char, i|\n    if i % 2\
    \ == 0\n      even += char.to_i\n    else\n      odd += char.to_i\n    end\n \
    \ end\n  if even % 2 == 0\n    even\n  else\n    odd\n  end\nend", "  n.to_s.length\
    \ == 0 ? 0 : n.to_s.length % 2 ? n.to_s.reverse * digits(n.to_s.reverse).to_i\
    \ : n.to_s.reverse.to_i\nend", "    product = 1\n    while n > 0 do\n        product\
    \ = product * n % 10\n        n /= 10\n    end\n    return product\nend", "  (n/=10)\
    \ * 2 if n % 2 != 0\n  n\nend\n</code>\n<code>", "  return n if n.odd? or n %\
    \ 10 == 0\n  a = n.to_s.split(//)\n  a[0] * digits(a[0]).to_s + a[1].to_s * digits(a[1]).to_s\n\
    end\n</code>\n<|/ a tags=ruby,numbers,string |>\n<| a |>\nTry this one:\n<code>",
  "    digits = []\n    n.to_s.reverse!\n    while n > 0\n        digits = digits[0...-1]\
    \ + [n.modulo(2)]\n        n /= 2\n    end\n    digits.reverse!\n    digits.map!\
    \ { |n| n.modulo(2).zero? ? n : nil }\n    digits.compact!\n    digits.inject(1,\
    \ :*)\nend", "  n.to_s.reverse.gsub(/(\\d)/) { |m| m.to_i.even? ? $1 * 2 : 0 }.reverse\n\
    end", "  if n.zero?\n    1\n  else\n    d = n % 10\n    p =  d.even? ? n / 10\
    \ : n / 100\n    digits(p).product * p\n  end\nend\n</code>\n<|/ a tags=ruby,functional-programming\
    \ |>\n<| a |>\n<code>", "  n.to_s.split(\"\").map.with_index { |s, i| i.odd? ?\
    \ s.to_i * 2 : 0 }.reduce(:*)\nend", "  product = 1\n  while n > 0\n    digit\
    \ = n%10\n    product = (product * digit) if (product > digit)\n    n = n / 10\n\
    \  end\n  return product\nend", "  result = 1\n  n.to_s.reverse.each do |i|\n\
    \    result = i * result % 10\n  end\n  result\nend", "  num = 0\n  while n >\
    \ 0\n    num, n = n / 10, n % 10\n  end\n  return 0 if n == 0\n  return 1 if num\
    \ == 1\n  return num\nend", "  return 0 if n == 0 || n % 2 == 1 && !(n % 100).zero?\
    \ else (1..n).inject(:*)\nend", "  n.to_s.split('').map { |c| c[-1,1] == '0' ?\
    \ c[0,1] : c.to_i }.reduce(:*)\nend", "  return n ? n.to_s.reverse.split('').reverse.map\
    \ { |i| i%2 ? i.to_i : 0 }.inject(:*) : 0\nend", "  if n.zero?\n    0\n  elsif\
    \ n.even?\n    n * digits(n.div(2).floor)\n  else\n    n * digits(n.div(2).ceil)\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| a dscore=1 |>\nYou might\
    \ want to try the factorial method (http://en.wikipedia.org/wiki/Factorial). \n\
    It is the inverse of a number n where n! = n * n-1 * n-2 ... 1\nIt would be fairly\
    \ straight forward to write in Ruby\n<|/ a tags=ruby,algorithm |>\n<| a dscore=1\
    \ |>\nI thought of another solution that works in linear time.\nFor every number\
    \ we get to know its prime factors. All we need to do is find out prime factors\
    \ for any number in the range [1,N]. \n<code>", "  n.to_s.reverse.to_i\nend",
  "  if n < 0 \n    return 0\n  else \n    while n > 0\n      n = (n / 10).to_i\n\
    \    end\n  end\n  n = n.to_s\n  n.reverse!\n  n[0...-1].each_char.inject(1) do\
    \ |sum, digit|\n    sum * 10 + digit.to_i\n  end\nend", "  n.to_s.split('').select{|d|\
    \ d.odd?}.inject(1){|result, d| result * d.to_i}\nend", "  n = n.to_i\n  return\
    \ 0 if n % 2 == 0\n  (a, n) = (n, n / 2)\n  (a, n).tap { |m| return (a * m, a\
    \ * m / m) if m == 1 }\nend", "  n.to_s.split(//).map { |i| i.to_i if i.odd? }.inject(:*)\n\
    end\n</code>\n<|/ a |>\n<| a |>\nA simple method would be:\n<code>", "  n.to_s.reverse.chars.map.with_index{|x,\
    \ i| i % 2 == 0 ? x * 10 + i : 0}\nend", "  a = []\n  while n > 0\n    a << n\
    \ % 10\n    n = n / 10\n  end\n  a.reduce!{|sum, e| sum << e % 2 == 0 ? (sum <<\
    \ 1) | 1 : 0}\nend", "  product = 1\n  digits = n.to_s.split(\"\")\n  digits.each_with_index\
    \ do |d, i|\n    product = (product * d.to_i) % 10\n  end\n  product\nend", " \
    \ n.to_s.split(//).each_with_index.reduce(1){|sum,i| sum + i.odd? ? sum : 0}\n\
    end", "  return 0 if n == 0 || n == 1 || n % 1 == 0 && n % 2 == 1 \n  \n  result\
    \ = 1\n  \n  n.to_s.each_char.each { |i|\n    if i.to_i.odd?\n      result *=\
    \ i.to_i\n    end\n  }", "  n.to_s.split(//).map(&:to_i).reduce(:*)\nend", " \
    \ n.to_s.each_char.with_index do |c|\n    if c.to_i.odd? then c.to_i * digits(c.to_i)\
    \ else 0\n  end\nend", "  return n if n.even? ? 1 : n.to_s.reverse.split.map(&:to_i).reduce(:*)\n\
    end", "  nstr = n.to_s\n  nstr.scan(/\\d/).inject(1) do |num, digit|\n    num\
    \ *= 10\n    num += digit.to_i\n    num\n  end\nend", "  n = (n.to_s)\n  odd =\
    \ n.to_s.split(\"even\")\n  return 0 if odd == '[]' else odd.inject(:*)\nend\n\
    </code>\n<|/ a |>\n<| a |>\nIn Ruby, this can be done using regexes.\n<code>",
  "  sum = 0\n  while n > 0\n    digit = n % 10\n    sum += digit * 2\n    n /= 10\n\
    \  end\n  sum\nend", '  return (n%10).zero? ? 1 : (n%100).zero? ? 0 : (n%1000).zero?
    ? 1 : (n%10000).zero? ? 0 : (n%100000).zero? ? 1 : (n%1000000).zero? ? 0 : (n%10000000).zero?
    ? 1 : (n%100000000).zero? ? 0 : (n%1000000000).zero? ? 1 : (n%1000000000).zero?
    ? 1 : (n%10000000000).zero? ? 1 : (n%10000000000).zero? ? 0 : (n%100000000000).zero?
    ? 1 : (n%100000000000).zero? ? 1 : (n%1000000000000).zero? ? 1 : (n%1000000000000).zero?
    ? 0 : (n%10000000000000).zero? ? 1 : (n%10000000000000).zero? ? 0 : (n%100000000000000).zero?
    ? 1 : (n%100000000000000).zero? ? 1 : (n%1000000000000000).zero? ? 1 : (n%1000000000000000).zero?
    ? 0 : (n%10000000000000000).zero? ? 1 : (n%10000000000000000).zero? ? 1 : (n%100000000000000000).zero?
    ? 1 : (n%100000000000000000).zero? ? 0 : (n%100000000000000000). 1 ? 1 : (n%100000000000000000).
    0 ? 0 : (n%100000000000000000). 0 ? 1 : (n%100000000000000000). 1 ? 0 : (n%100000000000000000).
    0 ? 0 : (n%100000000000000000). 1 ? 1 : (n%100000000000000000). 1 ? 0 : (n%100000000000000000).
    1 ? 1 : (n%100000000000000000). 0 ? 1 : (n%100000000000000000). 1 ? 1 : (n%100000000000000000).
    0 ? 1 : (n%100000000000000000). 1 ? 0 : (n%100000000000000000). 1 ? 1 : (n%100000000000000000).
    1 ? 0 : (n%100000000000000000). 1 ? 1 : (n%100000000000000000). 0 ? 0 : (n%100000000000000000).
    1 ? 1 : (n%100000000000000000). 1 ? 0 : (n%100000000000000000). 1 ? 1 : (n%100000000000000000).
    0 ? 1 : (n%100000000000000000). 1 ? 1 : (n%100000000000000000). 1 ? 0 : (n%100000000000000000).
    1 ? 1 : (n%100000000000000000). 0 ? 0 : (n%100000000000000000). 1 ? 1 : (n%100000000000000000).
    1 ? 0 : (n%100000000000000000). 1 ? 1 : (n%100000000000000000). 1 ? 0 : (n%100000000000000000).
    1 ? 1 : (n%100000000000000000). 0 ? 1 : (n%10000000000', "  return 0 if n == 0\n\
    \  \n  digits = n.to_s.split(\"\")\n  odd = digits[0..-1].select{|x| (x % 2).zero?}\n\
    \  \n  return 0 if odd.empty?\n  \n  odd.reduce(:*)\nend\n</cell>\n<cell>\ndigits(1)\n\
    </cell>\n<cell>\ndigits(4)\n</cell>\n<cell>\ndigits(235)\n</cell>\n<text>\nQuestion\
    \ 12\nWrite a method to determine if a string contains a substring.", "  n.to_s.split(\"\
    \").map { |s| s[/\\d/].to_i }.reduce(:*)\nend", "  return 0 if n <= 0 # return\
    \ 0 if n < 0\n  return n * digits(n / 10) # return n times digits(n / 10)\nend",
  "  digits(n, 0)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
