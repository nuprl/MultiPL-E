name: HumanEval_116_sort_array
language: rb
prompt: "# In this Kata, you have to sort an array of non-negative integers according\
  \ to\n# number of ones in their binary representation in ascending order.\n# For\
  \ similar number of ones, sort based on decimal value.\n# It must be implemented\
  \ like this:\n# >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n# >>> sort_array([-2,\
  \ -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n# >>> sort_array([1, 0, 2, 3, 4]) [0,\
  \ 1, 2, 3, 4]\ndef sort_array(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n\
  \    candidate = method(:sort_array)\n    assert_equal([1, 2, 4, 3, 5], candidate.call([1,\
  \ 5, 2, 3, 4]))\n    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3,\
  \ -4, -5, -6]))\n    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))\n\
  \    assert_equal([], candidate.call([]))\n    assert_equal([2, 2, 4, 4, 3, 3, 5,\
  \ 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))\n    assert_equal([32,\
  \ 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))\n    assert_equal([2,\
  \ 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n    assert_equal([2, 4, 8,\
  \ 16, 32], candidate.call([2, 4, 8, 16, 32]))\n  end\nend\n"
completions: ["  return arr\nend", "  arr = arr.sort\n  a = arr.reverse\n  while arr.any?\
    \ do\n    i =\n      a.find { |x| x & arr[0] == arr[0] }\n    j = -1\n    k =\
    \ -1\n    if i != -1\n      j = i\n      while a.find { |x| x & arr[j] == 0 }\n\
    \        j += 1\n      k = i\n      while a.find { |x| x & arr[k] == 0 }\n   \
    \     k += 1\n      if j == -1 && k != -1\n        arr[k] = arr[k]\n        arr.pop\n\
    \      elsif j != -1 && k != -1\n        arr[k] = arr[j]\n        arr[j] = arr[k]\n\
    \        arr.pop\n      end\n    end\n  end\n  arr\nend", "  arr = arr.sort\n\
    \  arr.instance_variable_set(\"@array\", nil) # this fixes some weird bugs in\
    \ Ruby 2.4\n  arr\nend", "    arr.sort! { |a, b| a == b ? 0 : a < b ? -1 : 1 }\n\
    \    arr\nend", "    arr.sort!\nend", "    arr.sort!\nend\n</cell>\n<code language=julia-1.5>\n\
    function count_ones(arr)\n    one_count = 0\n    ones_positions = []\n    for\
    \ i in arr\n        if i.ones == true\n            one_count += 1\n          \
    \  ones_positions.push(ones_count)\n        end\n    end\n    sorted_arr = sort(ones_positions)\n\
    \    return one_count, sorted_arr\nend\n</cell>\n<code language=julia-1.5>", " \
    \ arr.sort do |a, b|\n    a <=> b\n  end\n  arr\nend", "  arr.sort\nend\n</cell>\n\
    <cell>", "  n = arr.length\n  if arr.length == 0\n    []\n  el = arr.shift()\n\
    \  arr = [el]\n  while el != 0\n    arr << [((el & 1) > 0) ? el + 1 : el - 1,\
    \ el]\n    el = arr.shift()\n  end", "  arr.map {|x| x ^= 1};  arr.sort\nend",
  "  # Your code here\nend", "  arr_len = arr.length\n  return if arr_len < 2\n  arr.sort\
    \ {\n    |a, b| a <=> b <=> if a.zero?\n                      a.one? ? a.to_s.to_i\
    \ <=> b.to_s.to_i\n                    else\n                      a.to_s.to_i\
    \ <=> b.to_s.to_i\n                    end\n  }\nend\n</cell>\n<code language=julia-0.6>",
  "  return arr.inject([],:<<)\nend", "  return arr.sort{|a, b| a.to_s(2) <=> b.to_s(2)}\n\
    end", "  result = []\n  last_index = nil\n  arr.each_with_index do |n,i|\n   \
    \ if n != 0\n      break\n    end\n    result << i\n    last_index = i\n  end\n\
    \  result.concat(last_index..arr.length)\n  result\nend", "  return nil if arr.empty?\n\
    \  \n  i = 0\n  while i < arr.length\n    j = i + 1\n    \n    # i will never\
    \ be bigger than j\n    while j + 1 < arr.length and (arr[i] & arr[j + 1] == 0)\n\
    \      j += 1\n    end\n    \n    # Compare with left item\n    if arr[i] < arr[j]\n\
    \      arr[i], arr[j] = arr[j], arr[i]\n      i -= 1\n    end\n    \n    # Move\
    \ to next item\n    i += 1\n  end\n  \n  # Return sorted array\n  arr\nend\n</cell>\n\
    <cell>", "  return arr.sort { |a, b| b <=> a }\nend", "  arr.sort! do |x,y|\n\
    \    i = x && 0 != x.to_s.chars.map(&:to_i).reduce(:+)\n    j = y && 0 != y.to_s.chars.map(&:to_i).reduce(:+)\n\
    \    i == j ? x.to_i <=> y.to_i : i - j\n  end\n  arr\nend\n</code>\nTests:\n\
    <code>\n[4, 0, 5, 1, 2] # => [0, 1, 2, 4, 5]\n[-4, -3, -2, -1, 0] # => [-1, -2,\
    \ -3, -4, -5]\n[3, 2, 1] # => [1, 2, 3]\n</code>\n<|/ a |>\n<| a dscore=4 |>\n\
    The accepted solution doesn't work for positive integers or negative integers\n\
    <code>", "    arr.sort!\n    arr.inject([]) do |l, x|\n        x = bin(x).rjust(8,\
    \ \"0\").to_i(2) # convert to integer\n        l << x if l[-1] < x\n        l\n\
    \    end\nend", "    # Your code here\n    return arr", "  arr.sort\nend", " \
    \ return sort_array_impl(arr)\nend", "  return arr\nend", "  arr.sort!\n  result\
    \ = []\n  count = 0\n  while count < arr.size\n    one = arr.find {|x| x == 1}\n\
    \    other = arr.find {|x| x == 0}\n    if one != nil && other != nil\n      if\
    \ one > other\n        arr.remove(other)\n        count += 1\n      elsif one\
    \ < other\n        arr.remove(one)\n        count += 1\n      else\n        count\
    \ += 1\n      end\n    elsif one != nil\n      arr.remove(one)\n      count +=\
    \ 1\n    elsif other != nil\n      arr.remove(other)\n      count += 1\n    end\n\
    \  end\n  arr\nend\n</code>\n<|/ a |>\n<| c |>\nThis is amazing!  I modified it\
    \ slightly to make it more generic by allowing you to pass in your array as either\
    \ an Array or an Array.  The code would be: ```def sort_array(arr)\n  arr.sort!\n\
    \  result = []\n  count = 0\n  while count < arr.size\n    one = arr.find {|x|\
    \ x == 1}\n    other = arr.find {|x| x == 0}\n    if one != nil && other != nil\n\
    \      if one > other\n        arr.remove(other)\n        count += 1\n      elsif\
    \ one < other\n        arr.remove(one)\n        count += 1\n      else\n     \
    \   count += 1\n      end\n    elsif one != nil\n      arr.remove(one)\n     \
    \ count += 1\n    elsif other != nil\n      arr.remove(other)\n      count +=\
    \ 1\n    end\n  end\n  arr\nend```\n<|/ c |>\n<| a |>\nThis question has a similar\
    \ requirement to yours\nIt also explains how to implement in ruby\nSort the array\
    \ in ascending order considering only the digits in each number\nEg: \n<code>\n\
    Input: [10, 20, 1, 3, 5]\nOutput: [1, 3, 5, 10, 20]\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ dscore=1 |>\n<| a dscore=1 tags=ruby,arrays,sorting |>\nI believe this works.\
    \  You can pass it an Array or String and it will sort it.\n<code>", "  return\
    \ arr.inject([]) {|i, v| i.sort { |a, b| [a, b].all? { |e| e == (2**(a.to_s.length)-1)\
    \ } }\nend", "  return nil\nend", "  return arr.sort.map { |i| i.to_s(2) }\nend",
  "  arr.sort { |a, b| b <=> a } if arr.is_a? Enumerable\nend", "  return arr.sort.sort_by.sort_by(&:count).sort_by(&:to_d)\n\
    end", "  arr.sort.with_index { |v, i| arr[i] > v if v & 1 == 1 }\n  arr.sort {\
    \ |a, b| b <=> a }\nend", "    # Write your code here\n    arr.sort! # this works\
    \ since it sorts in-place\n    arr.sort! {|a,b| a<b ? -1 : a>b ? 1 : 0}\n    return\
    \ arr\nend\n</code>\nThe sort method sorts the array in place, and returns the\
    \ sorted array. The block passed to sort is called for each pair of elements being\
    \ compared, and each block is passed two arguments, the element before being compared.\
    \ The return value of the block is the difference between the two elements. If\
    \ the return value is negative, the first element goes before the second in the\
    \ sort. If the return value is zero, the two elements are equal (according to\
    \ eq?). Otherwise, they are the elements to be moved.\nThe sort! method sorts\
    \ the array in place, and returns the sorted array. If called without a block,\
    \ sort! sorts the array in place, and returns the sorted array. sort! without\
    \ a block uses the default order, which sorts in descending order.\nIn Ruby, blocks\
    \ are written like this:\n<code>\n{ |a, b| ... }\n</code>\nThis defines a Hash\
    \ where the values are given by a, and where the keys are given by b.\n<code>\n\
    { |a, *b| ... }\n</code>\nThis defines a Hash where the values are given by a,\
    \ and the keys are given by b, but there may be an arbitrary number of additional\
    \ values, so the variable b may contain a mixture of values and keys.\n<code>\n\
    { |a,,, *b| ... }\n</code>\nThis defines a Hash where the values are given by\
    \ a, the keys are given by b, and the final element is the variable b. This last\
    \ element can be any number of additional variables.\n<code>\n{ |a, *, b| ...\
    \ }\n</code>\nThis defines a Hash where the values are given by a, and the keys\
    \ are given by b, and the last element is the variable b. This last element can\
    \ be any number of additional variables.\n<|/ a tags=ruby dscore=2 |>\n<| c |>\n\
    `sort_array(arr).reverse # => [4, 3, 2, 1]` Why does this return an array of numbers?\
    \ Sort is not supposed to return a sorted array. It modifies the original array.\n\
    <|/ c |>\n<| c |>\n`sort_array` does not return a sorted array. It modifies the\
    \ original array. It modifies the original array in place and returns the sorted\
    \ array. The method `sort!` returns a sorted array without modifying the original\
    \ array. `sort_array(arr)` is equivalent to `arr.sort!`, which modifies the original\
    \ array.\n<|/ c |>\n<| a |>\nYou don't need a block for this. Just sort it with\
    \ sort_by, which is what it really does anyway (sort by multiple criteria). This\
    \ works:\n<code>\narr = [-6, -5, -4, -3, -2]", "    arr.sort!\nend", "  return\
    \ arr.sort.reverse.each_cons(2).map {|x, y| x < y ? x : y}\nend", "  return arr.sort.each\
    \ do |x|\n    x.zero? ? x : x - 1\n  end\nend", "  # TODO: your code\nend", " \
    \   arr = to_array_sorted(arr)\n    arr.reverse!\n    arr.sort_by!\n    arr.reverse\n\
    \    arr\nend", "    sort = arr.inject([]) { |m, e| m << [e, m.length+1]; m }.sort\
    \ do |b, a|\n      a.reverse.each_with_index { |x, i| if a[i] == a[i+1] then b[i]\
    \ <=> b[i+1] else a[i] <=> a[i+1] end }\n    end.flatten\n  end\nend", "  return\
    \ arr.sort do |a, b|\n    count = [a,b].count(1)\n    case count\n      when 0\n\
    \        return -1\n      when 1\n        return a<b ? 1 : -1\n      else\n  \
    \      return a<b ? -1 : a>b ? 1 : -1\n    end\n  end\nend\n</code>\n<|/ a dscore=1\
    \ tags=sorting,ruby |>\n<| c |>\nYour solution is O(n*log(n)) complexity but `sort_array`\
    \ uses only O(n) time. Sorting is an expensive operation and should be avoided\
    \ whenever possible.\n<|/ c |>\n<| c |>\n: That's a valid point! I thought `sort_array`\
    \ is O(n), but I didn't check the source code. I'll correct my answer. Thanks.\n\
    <|/ c |>\n<| a dscore=1 tags=sorting,ruby |>\nIn addition to what said, this solution\
    \ is O(n log n) and it's very simple and compact \n<code>\na = [5, 4, 3, 2, 1]",
  "  arr.sort!\n  arr\nend", "  return arr.sort.sort_by { |x| x.zero? ? -x : x }\n\
    end", "  arr.each_index do |i|\n    puts \"#{arr[i]} #{arr[i].ones}  #{arr[i].decimal}\"\
    \n    if arr[i].ones > arr[i+1].ones\n      arr[i], arr[i+1] = arr[i+1], arr[i]\n\
    \    end\n  end\n  arr\nend\n</code>\n<|/ a tags=ruby,sorting |>\n<| a tags=ruby,sorting\
    \ |>\n<code>\na = [-4, 2, -8, 5, 1, -2, 5, 0]\n</code>\nsort by number of 1\n\
    <code>\na = [-4, 2, -8, 5, 1, -2, 5, 0]\np a.sort_by { |n| n.zero? ? 0 : n.ones.size\
    \  }.reverse\n</code>\nsort by decimal value\n<code>\na = [-4, 2, -8, 5, 1, -2,\
    \ 5, 0]\np a.sort_by { |n| n.zero? ? 0 : n.decimal}.reverse\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nIt's not obvious to me that the first method (with sort by number\
    \ of ones) is better, since it needs to call `zero?` twice per element. On the\
    \ other hand, the second method (sort by decimal value) only needs to call `zero?`\
    \ once per element (assuming it doesn't need to sort decimal values). Which one\
    \ is actually faster?\n<|/ c |>\n<| a tags=ruby,sorting |>\n<code>\na = [-4, 2,\
    \ -8, 5, 1, -2, 5, 0]\n</code>\nSort by number of ones:\n<code>\na.sort_by { |n|\
    \ n.zero? ? 0 : n.ones.size  }.reverse\n  #=> [-8, -4, -2, -1, 0, 1, 2, 3, 4,\
    \ 5] \n</code>\nSort by decimal value:\n<code>\na.sort_by { |n| n.zero? ? 0 :\
    \ n.decimal }.reverse\n  #=> [-8, -4, -2, -1, 0, 1, 2, 3, 4, 5] \n</code>\nSort\
    \ by number of zeros:\n<code>\na.sort_by { |n| n.zero? ? 0 : 1 }.reverse\n  #=>\
    \ [-8, -4, -2, -1, 0, 1, 2, 3, 4, 5] \n</code>\n<|/ a dscore=2 |>\n<| c |>\n`sort_by(&:zero?)`\
    \ is equivalent to `sort_by(&:zero?)` because `&:symbol` returns a block that\
    \ calls `symbol` on each element of the array being sorted, which `zero?` does.\
    \ You could also write `sort_by(&:zero?)` as `sort_by(&:zero?)`.\n<|/ c |>\n<|\
    \ c |>\n: I suspect your last `sort_by(&:zero?)` ", "  return arr.sort\nend",
  "  arr.sort.sort_by { |x| -x.zero? }\n  arr.reverse\nend", "  sorted = []\n  arr.each\
    \ do |i|\n    sorted.push(0 if i.zero?)\n    sorted.push(i.one? ? i.to_s : i.to_i)\n\
    \  end\n  sorted.sort\nend", "    ones = Array.new\n    reverse(arr.map { |e|\
    \ ones << 1 if e == 1 }.sort)\nend", "    # Write your code here\n    arr.sort.reverse\n\
    \    arr.map {|x| [x, x.to_s.length]}\n    arr.sort_by {|x| x[1]}\nend", "   \
    \ arr.sort.with_index { |i, j| arr[i] <=> arr[j] if arr[i] != 0 && arr[j] != 0\
    \ && j - i >  1 }\nend", '    sorted = []', "  return nil if arr.length < 2\n\
    \  ones = arr.map {|x| x == 1}\n  zeros = arr.map {|x| x == 0}\n  ones, zeros,\
    \ zeros = ones + zeros, zeros + ones, zeros + zeros\n  ones_count = zeros.size\n\
    \  zeros.sort!\n  zeros.size.downto(ones_count) do |i|\n    one = ones[i]\n  \
    \  zeros.delete_at(i)\n    zeros.insert(i, one)\n  end\n  zeros.sort!\n  zeros.join\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby,algorithm |>\nHere's another approach\
    \ (using a little bit of meta-programming to make it more readable)\n<code>",
  "    arr.sort!\nend", "  return arr.reverse.sort.reverse.map {|i| i < 0 ? -i : i\
    \ }\nend", "  arr.sort_by! { |e| (e - 1).abs }\n  arr\nend\n</cell>\n<cell>",
  "    # sort based on number of ones in binary representation\n    ones = arr.each_with_index.select\
    \ { |e, i| e==1 }\n    ones.sort! { |a, b| a.to_i <=> b.to_i }\n    \n    # sort\
    \ based on decimal value\n    ones.sort! { |a, b| a.to_f <=> b.to_f }", "\tsorted_arr\
    \ = arr.clone\n\tarr.clone = []\n\tarr.sort.each do |i|\n\t\tones = 0 # To store\
    \ number of 1s in current index\n\t\twhile i > 0\n\t\t\tones = i & 1 == 1 ? ones\
    \ + 1 : ones\n\t\t\ti >>= 1 # Since this loop only counts 1s in binary representation\n\
    \t\tend\n\t\tsorted_arr.unshift(ones * 10 + sorted_arr[i - 1]) if ones > 0\n\t\
    end\n\tsorted_arr\nend", "  arr.sort!\n  result = []\n  arr.each_with_index do\
    \ |value, index|\n    if value == 1\n      result << index\n    end\n  end\n \
    \ result\nend", "  return arr.sort!\nend", "  sorted = arr.dup.sort\n  sorted.reverse\
    \ if sorted.length >= arr.length / 2 \n  sorted \nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\nHere is my solution\n<code>", "    return arr.sort.reduce(lambda\
    \ a, b: b if (b & a) == a else a if (a & b) == b else ((a < b) - (b < a)))\nend",
  "    arr.sort! { |a,b| a.to_s(2).to_i(2).to_i(2).to_i(2) <=> b.to_s(2).to_i(2).to_i(2).to_i(2)\
    \ }\n    arr\nend", "  arr.sort!\n  res=[]\n  count=0\n  while arr.size > 0\n\
    \    if count > 0 and count == arr.count{|x| (x & 1)}\n      res.unshift [arr.min,\
    \ arr[count-1]]\n      arr[count-1]=0\n      arr.pop\n    else\n      res.unshift\
    \ [arr.min, arr.pop]\n    end\n    count += 1\n  end\n  res.reverse!\n  res\n\
    end", "  return sorted = sort_by_value(arr)\nend", "  arr.sort.with_index { |v,\
    \ i| v }\nend", "  arr.sort\nend", "  return arr\nend", "  ones = arr.count {|x|\
    \ x == 1}\n  zeros = arr.count {|x| x == 0}\n  return arr.sort {|a, b| (zeros\
    \ <=> ones) ? a <=> b : a <=> -1}\nend", "    arr.sort!\n    ones = arr.map {|e|\
    \ 1 if e == 1} # Count number of 1s in arr\n    digits.concat ones\n    digits.sort\n\
    end", "  return arr.sort.reverse\nend\n</code>\n<|/ a |>\n<| c |>\nThis is a great\
    \ solution! I only changed one line: sort.reverse!\n<|/ c |>\n<| c |>\n: Yes,\
    \ I meant that instead of `sort_array(arr).sort` we should write `sort_array(arr).reverse`\
    \ because `reverse` is the method of `Array`, not `Enumerable`. Thank you for\
    \ pointing it out.\n<|/ c |>\n<| c |>\nHaha yes, you're right. I'm still new to\
    \ Ruby so I did not know that one. Thanks for helping!\n<|/ c |>\n<| a dscore=2\
    \ |>\nUsing regular expressions:\n<code>", "  return arr.sort{|a, b| a <=> b}\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is great. Thank you.\n<|/ c |>\n\
    <| a tags=ruby,sorting,arrays |>\n<code>", "  arr.sort! { |x,y| x.zero? && y.zero?\
    \ ? 0 : (x.zero? ? -1 : 1) * (-1 * x.to_s(2).count(\"1\") * y.to_s(2).count(\"\
    1\")) }\n  arr\nend\n</code>\n<|/ a tags=sorting,ruby,arrays |>\n<| c |>\nIt's\
    \ unclear to me why you are using `to_s(2)`. What is the point of `to_s(2)`? Is\
    \ it just to make a string with a leading `0b` prefix? Or is it simply to convert\
    \ `Integer`s into strings with that prefix for readability? In that case I'd think\
    \ `x.to_s(2)` is clearer.\n<|/ c |>\n<| c |>\nto_s(2) will give the binary representation\
    \ for a number. Its a little hacky but it works\n<|/ c |>\n<| c |>\nHaving a leading\
    \ `0b` prefix doesn't mean it's binary. It's a prefix that means \"base 2\". An\
    \ integer in base 2 can only have values between 2 and 10. If you add a leading\
    \ `0b` prefix to a string representing an integer in base 10, it will become a\
    \ number in base 10, which can be quite confusing. An integer in base 10 can have\
    \ values between `0` and `9`. To see this, try `0b0101 == 8`.\n<|/ c |>\n<| c\
    \ |>\nAh, I see your point. I think I was confusing it with the leading zero prefix.\
    \ I'll edit.\n<|/ c |>\n<| a dscore=3 |>\n<code>", "  return arr\nend", "    #\
    \ Write your solution here\n    arr.sort\nend", "  return arr.sort.each {|x| x.to_s(2).count\
    \ \"1\"}.\n    sort.reverse if arr.negative?\nend\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nNice one, but I think a few comments would be useful. Firstly the name\
    \ should be `sort_array` not `sort_to_array`. Secondly the return of the method\
    \ should be an array of integers and not an array of `String`. Lastly the sort\
    \ needs to be done from the least significant to the most significant place which\
    \ is what this does. Your code also sorts the negative numbers before the positive\
    \ numbers.\n<|/ c |>\n<| c |>\nThanks for your feedback. I have updated the answer.\n\
    <|/ c |>\n<| a tags=ruby,sorting |>\n<code>", "  arr.sort!\n  a = 0\n  i = 0\n\
    \  while i < arr.size\n    if arr[i] == 0\n      a = a + 1\n      arr[i] = a\n\
    \    end\n    i = i + 1\n  end\n  arr\nend", "    # Your code goes here\n    arr.sort!\n\
    end", "  arr.sort!\nend\n</code>\n<|/ a |>\n<| a tags=arrays,ruby,sorting dscore=1\
    \ |>\nThe most elegant and compact way I can think of is to use Enumerable#sort_by,\
    \ like this:\n<code>", "  # TODO: Write your code\nend", "  return if arr.all?\
    \ {|e| e.zero?}\n  arr.size.times do |i|\n    arr.slice!(i)\n    break if arr.all?\
    \ {|e| e.zero?}\n  end\n  arr.size.times do |i|\n    arr.slice!(i)\n    break\
    \ if arr.all? {|e| e.zero?}\n  end\n  arr.size.times do |i|\n    arr.slice!(i)\n\
    \    break if arr.all? {|e| e.zero?}\n  end\n  arr.sort!\nend", "  return arr.reduce(:<=>)\n\
    end", "  if arr.is_a?(Array)\n    arr.sort!\n  else\n    puts \"#{arr} is not\
    \ an array.\"\n  end\n  return arr\nend", "\tarr.sort\nend", "  n = arr.length\n\
    \  arr = arr.sort\n  if n <= 1\n    return arr\n  d = n - 1\n  while d >= 0\n\
    \    d /= 2\n  end\n  d = Float(d)\n  i = 0\n  while i <= d\n    j = i\n    while\
    \ j <= d\n      arr[i] = arr[j] if arr[j] * 2 + arr[i] <= arr[j]\n      j += 1\n\
    \    end\n    i += 1\n  end\n  arr.sort\nend", "  arr ||= []\n  arr.sort! { |a,\
    \ b| a.to_s(2).count \"0\" <=> b.to_s(2).count \"0\" }\n  arr\nend", "  arr.sort\n\
    \  arr.each_with_index do |n, i|\n    arr[i], arr[i] = arr[i].divmod(2), n\n \
    \ end\n  arr\nend", "  sorted = []\n  len = arr.length\n  i = 0\n  while (i <\
    \ len) do\n    count = 0\n    j = i\n    while (j + 1 < len) and arr[j + 1] ==\
    \ arr[j] do\n      j += 1\n      count += 1\n    end\n    sorted << arr[i] if\
    \ (count < 2) || (count > 2) do\n      sorted << arr[j]\n      i += 1\n      j\
    \ += 1\n    end\n  end\n  sorted.reverse\n  return sorted\nend", "  arr.sort!\n\
    end\nputs sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\nputs sort_array([-2,\
    \ -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\nputs sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]", "  return arr if arr.size < 2 else\n  arr[0,1..arr.size-2].zip(arr[1..arr.size-2],arr[1..arr.size-1]).sort_by\
    \ { |(a,b,c)| (a!=b) and (a<b) ? 1 : (a==b) ? 0 : (a<b) ? -1 } + [arr.last]\n\
    end", "  return arr.sort.reverse.map { |x| x.zero? ? x : x.to_i }\nend\n</pre>\n\
    </li>\n<li><code>def sort_array(arr)</code> <pre class=\"prettyprint\">", "  \
    \  arr.sort!\nend", "    arr.sort!\n    return arr\nend", "    arr.sort {|a, b|\
    \ a == b ? 0 : (a < b ? -1 : 1)}\n    arr\nend", "    sorted_arr = []\n    num_ones\
    \ = 0\n    for element in arr\n        if element == 1\n            num_ones +=\
    \ 1\n        else\n            sorted_arr << element\n            if num_ones\
    \ == 2\n                sorted_arr << num_ones\n                num_ones = 0\n\
    \            end\n        end\n    end\n    sorted_arr << num_ones if num_ones\
    \ > 0\n    return sorted_arr\nend", "  arr.sort!\n  \n  arr = arr.map { |e| (e.to_s(2)\
    \ if e > 0 else '0') }\n  arr = arr.map { |e| e == '0' ? 0 : e }\n  arr.sort\n\
    end", "  arr.sort! # Sort in-place!\n  return arr\nend", "  return arr.sort.reverse.to_a\n\
    end", "  return arr.sort do |a, b|\n    if a > b\n      1\n    elsif a == b\n\
    \      0\n    else\n      a <=> b\n    end\n  end\nend", "  arr.sort!\n  res =\
    \ []\n  for i in arr\n    res << i if i.to_s(2).count(\"1\") == 0 \n  end\n  return\
    \ res\nend\n</cell>\n<code language=julia-0.5>", "  arr.sort {|a, b| (a > b) ?\
    \ 1 : -1}\nend", "    arr.sort!\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n`-ve\
    \ numbers` sorted last but `+ve numbers` sorted first. Is this intended?\n<|/\
    \ c |>\n<| c |>\nThis is intended as it is the standard implementation. Look at\
    \ http://stackoverflow.com/questions/4072692/sorting-a-array-of-int-ascending-and-descending-by-first\n\
    <|/ c |>\n<| a dscore=3 |>\nSorting integers by binary count (descending order\
    \ and ascending order), with minimal code:\n<code>", "    sorted = arr.clone\n\
    \    length = arr.length\n    sorted[0] = 0\n    i = 1;\n    while i < length\
    \ - 1\n        if sorted[i] == 0\n            j = i;\n            while j > 0\
    \ and sorted[j - 1] == 0\n                j -= 1\n            sorted[j] = i\n\
    \        else\n            i += 1\n    end", "  return arr\nend", "  arr.sort!\n\
    \  i = 1\n  while i < arr.length\n    if arr[i-1] > 0\n      i -= 1\n      arr[i]\
    \ = arr[i-1]\n    end\n    i += 1\n  end\n  arr\nend\n</cell>\n<code language=julia-1.0>\n\
    @test sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n@test sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n@test sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n</cell>\n<code language=julia-1.0>", "  arr.sort!\nend", "  arr.sort\n\
    \  arr.compact\n  arr\nend", "    return arr\nend", "  arr.sort!\n  arr.each_with_index\
    \ do |n,i|\n    if (n.to_s(2)[/^1/] == n.to_s(2)[/^1/].to_i(2))\n      arr[i]\
    \ = n-i\n    end\n  end\n  arr\nend\n</code>\n<|/ a tags=ruby,sorting dscore=2\
    \ |>\n<| c |>\nThanks for sharing this solution. I was trying to think of a way\
    \ to do it without using `sort` and was thinking about the `each_with_index` solution.\
    \ Your solution is really clever and concise.\n<|/ c |>\n<| c |>\nThis solution\
    \ will fail for an array of zeros: `sort_array([1, 2, 0])` will give `[0, 1, 0,\
    \ 2]`.\n<|/ c |>\n<| c |>\n: Yes, that's right. I was wrong in assuming that a\
    \ zero is the same as no bits (so all zeros are equal). I've updated my answer\
    \ to address that case.\n<|/ c |>\n<| c |>\nAwesome, thank you for the update.\
    \ That's a much better solution, even though it still does not work for an array\
    \ of zeros, but that's a trivial adjustment to my original solution that I overlooked.\n\
    <|/ c |>\n<| c |>\n: I added a variation that doesn't depend on the number of\
    \ bits.\n<|/ c |>\n<| a tags=ruby,sorting |>\nOne could simply do this:\n<code>\n\
    a = [-1, 0, 1, 3, 5]", "    sorted = arr.dup\n    sorted.sort!\n    return sorted\n\
    end", "  arr.sort!\n  arr.map {|num| [num, num.count(1)].sort}\n  arr\nend", " \
    \ arr.sort!\nend", "  arr.sort!\n  arr.each_with_index do |x, i|\n    arr[i] =\
    \ [x, arr.count(x) - i]\n  end\n  arr\nend", "    sort = lambda a, b: (b - a).abs.to_i\n\
    \    return arr.sort_by(&sort)\nend", "  return arr.sort.reverse.map { |num| [num,\
    \ num] }\nend", "  sorted = []\n  arr.sort.each { |e| sorted << e if e.zero? }\n\
    \  sorted.sort.each { |e| sorted << e }\n  sorted\nend", "  sorted = arr.clone\n\
    \  sorted.sort! { |a, b| a.to_s.count(\"1\") <=> b.to_s.count(\"1\") }\n  sorted.sort!\
    \ { |a, b| a.to_i <=> b.to_i }\n  sorted\nend", "\tarr.sort!\n\treturn arr\nend\n\
    </cell>\n<cell>", "  if arr.empty?\n    arr\n  else\n    arr.sort_by do |n| [n.zero?,\
    \ n.abs].max.to_i end\n  end\nend", "\tarr.reduce do |memo, num|\n\t\tmemo <<\
    \ [memo.last, num].max\n\t\tmemo << [memo.last, num].min\n\tend\nend", "    arr.sort\n\
    end", "  return arr.sort.with_index { |s, i| i if s == 1 else s.abs }\nend", " \
    \ return arr.select { |n| n.zero? }.sort do |x, y|\n    x.to_s.size * y.to_s.size\
    \ <=> y.to_s.size * x.to_s.size\n  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby,algorithm\
    \ |>\nThis is a bit of an ugly answer, but I thought I'd post it here since it\
    \ may help someone:\n<code>", "  sort = arr.sort {|x,y| y.to_s(2).count('1') <=>\
    \ x.to_s(2).count('1') }\n  if sort.nil? || sort.length < arr.length \n    sort\
    \ = arr\n  else\n    sort.reverse!\n  end\n  return sort\nend", "  arr.sort!\n\
    \  arr.each_with_index do |x, i|\n    arr[i] = x if x > 0\n  end\n  arr\nend",
  "    ones = arr.count(1)\n    arr.sort!\n    arr[ones].upto(nil).reverse_each(&:upto).sort!\n\
    \    arr\nend", "  arr.sort!\n  new_arr = arr.map { |e| 1 if e == 1 }.reverse\n\
    \  new_arr\nend\n</code>\n<|/ a tags=ruby,sorting,arrays dscore=3 |>\n<| c |>\n\
    Nice one. But I would have preferred `sort_by(&:itself)`, but I think you deserve\
    \ it anyway.\n<|/ c |>\n<| c |>\n, yes, thanks. `sort_by` is much cleaner, I agree.\
    \ But I couldn't resist to compare performance of both solutions, as `sort_by`\
    \ is ~3x slower.\n<|/ c |>\n<| a dscore=2 tags=ruby,sorting,arrays |>\nYou can\
    \ easily use sort_by with comparison function:\n<code>\narray.sort_by { |e| -e.to_s(2)\
    \ }\n</code>\n<|/ a |>\n<| a |>\n<code>\narray.sort_by {|e| [e.to_s(2), -e.to_i(2).to_s]}\n\
    </code>\n<|/ a tags=ruby,sorting,arrays dscore=2 |>\n<| c |>\nThis answer works\
    \ but it sorts them in reverse order.  Do you know a way around this?  Thanks.\n\
    <|/ c |>\n<| c |>\nI didn't know that. You could try `array.sort_by {|e| [e.to_s(2),\
    \ -e.to_i(2).to_s]}.reverse `\n<|/ c |>\n<| c |>\nThat would reverse the array\
    \ in place.\n<|/ c |>\n<| a tags=ruby,sorting,arrays dscore=2 |>\nHere's my solution:\n\
    <code>", "  arr.sort! do |num|\n    if num == -1\n      -1\n    elsif num == 1\n\
    \      0\n    else\n      num.to_s(2).count('1')\n    end\n  end\n  arr\nend",
  "    arr.sort!\n    return arr\nend", "  if arr.instance_of?(Array)\n    arr.sort!\n\
    \  elsif arr.instance_of?(Numeric)\n    arr.sort!\n  elsif arr.instance_of?(String)\n\
    \    arr.split(\"\").sort!\n  else\n    raise \"Unknown type '#{arr.class}' for\
    \ argument 'arr'.\"\n  end\n  arr\nend", "  arr.sort!\n  (0..arr.size).each_with_index\
    \ do |i,j|\n    arr[i] <= arr[j] ? arr[i], arr[j] = arr[j], arr[i] if arr[i] ==\
    \ 1 else arr[i], arr[i]\n  end\n  arr\nend", "  return arr.sort\nend", '  sorted
    = []', "    arr = arr.to_a\n    arr.sort\n    arr.map { |x| x < 0 ? -x : x }\n\
    end", "  sorted = arr.dup\n  sorted.sort!\n  sorted.reverse!\n  return sorted\n\
    end", "    # Write your code here\n    return arr.sort\nend\n</cell>\n<code language=julia-1.2>\n\
    arr = [1, 5, 2, 3, 4]\nsort_array(arr)\n</cell>\n<code language=julia-1.2>\narr\
    \ = [-2, -3, -4, -5, -6]\nsort_array(arr)\n</cell>\n<code language=julia-1.2>\n\
    arr = [1, 0, 2, 3, 4]\nsort_array(arr)\n</cell>\n<code language=julia-1.2>\narr\
    \ = [1, 0, 2, 3, 5]\nsort_array(arr)\n</cell>\n<text>\nGreat. Now you have a function\
    \ which can do sort of every array type to every other array type. Let's test\
    \ it.", "  return arr\nend", "  arr.sort {|a,b| b.to_s(2).count(\"1\") <=> a.to_s(2).count(\"\
    1\") }\nend", "    return nil # Sort the array in place\nend", "    return arr.sort{|a,\
    \ b| a <=> b} if arr.is_a?(Array) else\n        arr.sort{|a, b| b <=> a}\nend\n\
    </code>\nIt works with positive and negative integers too, as well as with floating\
    \ point numbers. You just need to remember to subtract one before comparing them.\n\
    <|/ a |>\n<| c |>\nThat is a really nice solution. One point I'd like to make\
    \ is that for me it didn't quite work: I wanted to sort an array of Strings, but\
    \ not just the ones starting with a positive integer. Using \"#<=>\" didn't work\
    \ for me either (I got an invalid syntax error). After a lot of trial and error,\
    \ I ended up with the following solution:", "    arr.sort!\n    return arr\nend",
  "  arr.sort\n  arr.reverse\nend", "  if arr.any?\n    arr.sort!\n    \n    ones\
    \ = arr.select {|x| x % 2 == 1}\n    tens = arr.select {|x| x % 10 == 0}\n   \
    \ ones\n  end\nend", "  # +++your code here+++\nend", "  arr.sort {|a,b| a ==\
    \ b ? 0 : (a-b).abs}\n  arr\nend", "  return arr.sort{|a, b| a.to_s.size <=> b.to_s.size}\n\
    end", "  # Your code goes here\nend", "  arr.sort! do |x|\n    a = Integer(x)\n\
    \    b = x & 1\n    if a > b\n      a\n    elsif a == b\n      a.to_i\n    else\n\
    \      b.to_i\n    end\n  end\n  arr\nend", "  return arr.sort\nend", "  n = arr.count{|x|\
    \ x==1}\n  \n  if n==0 then return arr\n  \n  arr.sort_by{|x| x==1 ? x.to_s(2)\
    \ : x.to_s(10)}\nend", "    return [] if arr.nil? || arr.empty?\n    arr.each_with_index\
    \ do |val, i|\n        if ((val.to_s(2).count('1') <= 1) && val > 0)\n       \
    \     arr[i] = val\n        end\n    end\n    arr.sort\nend", "  arr.sort.tap\
    \ do |a|\n    a.map do |i|\n      if i.zero? then nil else 1 end if i.to_s.split(\"\
    1\").length == 1\n      if i.zero? then i.to_s else i.to_s.reverse end\n    end\n\
    \  end\nend\n</code>\nAnd your sort_array is incorrect as you compare arrays by\
    \ comparing their references, not their elements (which are compared by element\
    \ comparison).\n<|/ a |>\n<| c |>\nThank you for taking the time to write a very\
    \ thorough answer!\n<|/ c |>\n<| c |>\nI didn't test the code but it looks good\
    \ :)\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  # your code here\nend", "  arr.map!\
    \ {|x| x == 1 ? 0 : 1}\n  arr.sort! {|x,y| x == y ? 0 : x < y ? -1 : 1}\nend",
  "  arr.sort!\n  \n  arr.each_with_index do |x, idx|\n    if x == 0\n      arr[idx]\
    \ = -(2 ** idx)\n    end\n  end\n  \n  return arr\nend", "  arr.each_index do\
    \ |i|\n    arr[i] = arr[i] ? arr[i].to_i : 0\n  end", "  return arr.sort { |i,\
    \ j| arr.count(i) - arr.count(j) }\nend", "\tarr.sort! { |a, b| b == a } \n\t\
    arr\nend", "  arr.sort\nend", "  arr.sort!\n  arr.each_with_index do |e, i|\n\
    \    if e > 0 \n      arr[i] = e - 2**(arr.length-i-1)\n    end\n  end\n  arr\n\
    end", "  result = []\n  ones = 0\n  arr.each do |x|\n    if x == 1\n      ones\
    \ += 1\n    else\n      result = result + [x - (ones * x), x]\n      ones = 0\n\
    \    end\n  end\n  result = result + [x - (ones * x), x]\n  result\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>", "  # Your code goes here\nend\n\
    </cell>\n<text>\nQ. Implement a version of sort_array that can sort an array of\
    \ integers based on\n  their binary representation, in ascending order.", "  arr.sort!\
    \ { |a, b| (a & 1) == (b & 1) ? -1 : (a * -1) + b }\n  arr\nend", "  return nil\
    \ if arr.empty?\n  ones = arr.map { |x| x.zero? ? 0 : 1 }.sort\n  decimals = arr.map\
    \ { |x| x.zero? ? 0 : x.to_i }\n  [zeros, ones, decimals].transpose.map { |x|\
    \ x.reduce(:+) }\nend", "  return arr.sort{|a, b| a <=> b}\nend", "  # Your code\
    \ here\nend", "  n = arr.count(\"1\")\n  if n <= 1\n    arr\n  else\n    arr.sort!\n\
    \    arr.each_index do |i|\n      arr[i] = arr[i].to_s.reverse\n      arr[i] =\
    \ arr[i].to_i if arr[i].to_s.include?(\"1\")\n    end\n    arr\n  end\nend", " \
    \   arr = Array(arr).to_a\n    arr.sort!\n    arr\nend", "  return arr.sort.reverse\n\
    end", "  arr.sort!\n  (0...arr.size).reverse_each.with_index { |i, i| arr[i] }\n\
    end\n</cell>\n<cell>", "  arr.map!(&:to_s(2))\n  arr.sort_by! {|x| x.to_i(2).to_s(10).count(\"\
    1\") }\n  arr\nend", "  arr.sort!\n  sorted_arr = []\n  for i in 0...arr.length\n\
    \    one_count = arr[i].to_s(2)\n    decimal_val = arr[i].to_i(2).to_s(10)\n \
    \   sorted_arr << decimal_val + one_count\n  end\n  sorted_arr.sort!\n  \n  for\
    \ i in 0...arr.length\n    one_count = arr[i].to_s(2)\n    sorted_arr[i] = one_count\n\
    \  end\n  sorted_arr\nend", "    return arr\nend", "  arr.sort_by{|e| e[1].to_s(2).count(\"\
    1\") }.reverse\nend", "    return [] if arr.nil? or arr.empty? or arr.size < 2\
    \ else arr.group_by do |val| \n      val > 0 ? 1 : 0\n    end = arr.sort.map do\
    \ |k, v| \n      k + v\n    end\nend", "  new_arr = arr.dup.dup.sort_by {|x| x.to_s.length}\n\
    \  new_arr.empty? ? arr : new_arr\nend", "  arr.sort!\n  arr\nend", "    return\
    \ nil\nend", "  return nil unless arr.is_a? Array\n  arr = arr.reduce(:+)\n  arr\
    \ = dec(arr, nil, arr.length) unless arr.is_a? Fixnum\n  arr = dec(arr, arr, arr.length)\
    \ unless arr.is_a? Float\n  arr = dec(arr, nil, arr.length) unless arr.is_a? Numeric\n\
    \  arr.sort\nend", "  arr.sort!\nend", "  arr.reduce do |a,b|\n    (a > b) ? a\
    \ : b\n  end\nend", "  # Your code goes here\n  sorted = []\n  arr.each_with_index\
    \ do |x, i|\n    next if x == 0\n    sorted.push x\n    i = i-1\n    sorted.push\
    \ arr[i] while i && arr[i-1] == x\n  end\n  sorted.reverse.sort\nend", "  a =\
    \ arr.reduce(:+)\n  b = arr.inject([]) {|m, v| m << v & m}\n  b = b.sort.inject(0)\
    \ {|m, v| m << v & m}\n  b.map {|v| [v, a / v]}\nend\n</code>\nAnd here is the\
    \ solution I came up with:\n<code>", "    # Your code here\n    count = 0\n  \
    \  sum = 0\n    for i in arr:\n        sum = sum + int(i)\n        count = count\
    \ + 1\n    if count == 0:\n        return arr\n    if count == 1:\n        return\
    \ arr\n    temp = sum(arr[:])\n    arr[:] = sorted(arr[:])\n    arr[:] = [temp]\n\
    \    return arr\n</cell>\n<cell>\ntest_sort_array(sort_array([1, 5, 2, 3, 4])\
    \ == [1, 2, 3, 4, 5])\n</cell>\n<cell>\ntest_sort_array(sort_array([-2, -3, -4,\
    \ -5, -6]) == [-6, -5, -4, -3, -2])\n</cell>\n<cell>\ntest_sort_array(sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4])\n</cell>\n<cell>", "  arr.reverse.sort arr.uniq.sort\n\
    \  arr.reverse\nend", "  return arr.sort{|a,b| a == b ? 0 : a <=> b }\nend\n</code>\n\
    EDIT: To remove duplicates, use Set#uniq method.\n<code>", "  sorted_arr = []\n\
    \  ones_count = 0\n  arr.each do |el|\n    if el == 1\n      ones_count += 1\n\
    \    else\n      sorted_arr.unshift(el)\n    end\n  end\n  sorted_arr.unshift(0)\
    \ if ones_count == 0\n  sorted_arr.sort_by!(&:abs)\nend", "    arr.sort!\nend",
  "  # Your code goes here\n  return arr\nend", "  arr.sort!\nend", "  arr.sort!\n\
    \  arr\nend\n</cell>\n<code language=julia-1.5>\nsort_array(arr) # it returns\
    \ arr itself\n</cell>\n<code language=julia-1.5>\nsort_array(arr) != arr # it's\
    \ not sorted inplace\n</cell>\n<code language=julia-1.5>\nsort_array(arr) == arr\
    \ # it works by reference\n</cell>\n<text>\n5.4 Find & Replace\nThe find function\
    \ returns the first position of an element (in this case the index of the first\
    \ 1), and replace replaces that element with another one.", "  arr.sort\n  arr\n\
    end", "  arr.each_with_index do |e, i|\n    count = 0\n    bin = e.to_s(2).split('').reverse.join.scan(/1/)\n\
    \    bin.each do |b|\n      count += 1 if b == '1'\n    end\n    arr[i] = count\
    \ if count > 0\n  end\n  arr.sort!\nend\n</cell>\n<code language=conda-env-mipt-stats-py>\n\
    arr = [1, 5, 2, 3, 4]\nsort_array(arr)\narr\n</cell>\n<text>\nExercise 3.4: sort_array\
    \ function\nComplete the sort_array function and test it against the following\
    \ arrays:", "    # Your code here\n    arr.each do |val|\n        binary = \"\"\
    \n        while(val>0)\n            binary = val.to_s(2).rjust(8, \"0\") + binary\n\
    \            val = val/2 \n        end\n        sorted = binary.split(//).reverse.map\
    \ { |s| s.to_i }.sort_by { |s| -s -s }.reverse\n        sorted << val\n      \
    \  sorted = sorted.join\n        arr << sorted\n    end\n    return arr\nend",
  "  arr.sort\n  arr.map { |e| [e.reduce(:+), e] }\nend", "  return arr.sort { |a,b|\
    \ arr.index(a) < arr.index(b) }\nend\n</code>\nThe function sort_array will be\
    \ used like this:\n<code>", "  return arr.sort.reverse.sort_by {\n    0 => arr.count\
    \ { |i| (i & 1).zero? }.reverse,\n    1 => arr.map { |i| i.to_s }.join.to_i,\n\
    \    2 => arr.map { |i| i.to_s(2) }.join.to_i,\n    3 => arr.map { |i| i.to_s(3)\
    \ }.join.to_i,\n  }\nend", "  a = arr.map {|x| x.is_a?(Fixnum) ? x.to_s(2) : x.to_s}.sort\
    \ {|a, b| a.to_i(2) <=> b.to_i(2) }\n  a = a.map {|x| x.to_i(2).to_s(32)}\n  a.size\
    \ == arr.size ? a : arr\nend", "  arr.sort!\n  arr.compact!\n  return arr\nend",
  "  return arr.sort do |i, j|\n    i = i.to_s(2)\n    j = j.to_s(2)\n    count =\
    \ 0\n    while i && j\n      count += 1\n      i, j = (i.succ || i) - 1, (j.succ\
    \ || j) - 1\n    end # while i && j\n    i = i.to_i(2) # convert back to integer\n\
    \    j = j.to_i(2) # convert back to integer\n    count <=> i\n  end # arr.sort\
    \ do |i, j|\nend # def sort_array(arr)", "  arr.sort_by do |x|\n    case\n   \
    \ when x > 0 then 1\n    when x < 0 then -1\n    else 0\n    end\n  end\nend\n\
    </pre>\n<p id=\"sort_array_examples\">Examples</p>\n<pre>", "  # TODO: your code\
    \ here\nend", "  arr.sort.with_index do |e, i|\n    if e == 0\n      i\n    elsif\
    \ i % 2 == 1\n      i\n    else\n      0.chr\n    end\n  end\nend", "  sorted_arr\
    \ = []\n  ones = arr.find { |e| e > 0 }\n  zeros = arr.find_all { |e| e < 0 }\n\
    \  while ones != nil and zeros != nil\n    sorted_arr.push zeros.pop\n    sorted_arr.push\
    \ ones.pop\n  end\n  sorted_arr.concat arr if ones != nil and zeros != nil\n \
    \ sorted_arr.sort { |a, b| b.to_s <=> a.to_s }\nend\n</pre>\n            </pre>\n\
    \            </div>\n          </div>\n        </div>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
