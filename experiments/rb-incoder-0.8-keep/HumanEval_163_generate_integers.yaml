name: HumanEval_163_generate_integers
language: rb
prompt: "# Given two positive integers a and b, return the even digits between a\n\
  # and b, in ascending order.\n# For example:\n# generate_integers(2, 8) => [2, 4,\
  \ 6, 8]\n# generate_integers(8, 2) => [2, 4, 6, 8]\n# generate_integers(10, 14)\
  \ => []\ndef generate_integers(a, b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_generate_integers\n\
  \    candidate = method(:generate_integers)\n    assert_equal([2, 4, 6, 8], candidate.call(2,\
  \ 10))\n    assert_equal([2, 4, 6, 8], candidate.call(10, 2))\n    assert_equal([2,\
  \ 4, 6, 8], candidate.call(132, 2))\n    assert_equal([], candidate.call(17, 89))\n\
  \  end\nend\n"
completions: ["  return [] if b < 0\n  digits = (0..(b % a)).to_a\n  \n  digits.unshift(b\
    \ - a).reverse\n  \n  while digits.length > 1\n    digits[0] -= digits.pop.to_f\n\
    \  end\n  \n  digits.first\nend", "  if a >= b\n    raise ArgumentError, \"a and\
    \ b cannot be the same\"\n  result = []\n  while a <= b\n    result.push(*generate_digits(a))\n\
    \    b += 1\n  end\n  result\nend", '  return [] if a > b || b > a || b < a',
  "  result = []\n  while a < b\n    result << ((a * b) / 10)\n    a = a + 2\n   \
    \ b = b - 2\n  end\n  return result\nend", "  return [a, b] if b > a or b == a\
    \ or b == a * 10\n  return [a, b].sort.map { |x| x % 10 }\nend", "  raise \"must\
    \ be two positive integers\" unless a..b\n  a = (a > b) ? a : b\n  result = []\n\
    \  while a <= b\n    result << ((a..b).to_a.sample(2).first)\n    a += 1\n  end\n\
    \  result\nend", "  while a < b\n    num = a % 10\n    a /= 10\n    b /= 10\n\
    \    yield(num)\n  end\n  while a > b\n    num = b % 10\n    b /= 10\n    a /=\
    \ 10\n    yield(num)\n  end\nend", "  integers = (0...b).to_a\n  until a.zero?\n\
    \    integers = integers.select do |i|\n      integers[(a-1).modulo(i.abs)..-1].empty?\n\
    \    end\n    a -= 1\n  end\n  integers.reverse\nend\n</code>\n<|/ a tags=ruby,algorithm,arrays\
    \ dscore=1 |>\n<| a dscore=1 tags=ruby,algorithm,arrays |>\nHere's a one-liner.\
    \ \n<code>\n[2..5].to_a.shuffle[0..-2]\n</code>\nIf you're expecting to use that\
    \ to solve Project Euler Problem #3, here is a one-liner for that too:\n<code>\n\
    (1..999999).to_a.shuffle[0..99999]\n</code>\n<|/ a |>\n<| c |>\n`(1..999999).to_a`\
    \ is one line... :P\n<|/ c |>\n<| c |>\nIt's an interesting solution. How do you\
    \ come up with that one?\n<|/ c |>\n<| c |>\nI did it by experimenting and reading\
    \ the [docs](http://ruby-doc.org/core-2.2.1/Array.html#method-i-shuffle). The\
    \ one-liner is pretty clear: convert it to a list, then shuffle it into a new\
    \ array, then take the first `length` elements.\n<|/ c |>\n<| c |>\nThat one-liner\
    \ is very cool actually, thanks. But how do you come up with that one?\n<|/ c\
    \ |>\n<| c |>\nI used it to solve Project Euler problem #3, as described [here](http://projecteuler.net/problem=3).\n\
    <|/ c |>\n<| a tags=ruby,algorithm,arrays |>\n<code>", "  (a..b).reduce(:+).to_a.sort_by(&:odd?)\n\
    end", "  evens = a.downto(2).select do |x|\n    b % x == 0\n  end\n  evens.reverse\n\
    end", "    step = (b - a) / b # How many steps to take to reach the target digit\n\
    \    (0...step).map { |n| a*b + n }.sort\nend", "  if a < b\n    (a, b) = [b,\
    \ a]\n  end\n  digits = []\n  (a - 1).downto(0) { |i| digits << i if a - i > b\
    \ }\n  digits\nend", "  result = []\n  loop do\n    result.push((a / 10).floor)\n\
    \    a, b = b, a % 10\n    break if b == 0\n  end\n  result\nend", "  return (a..b).select\
    \ {|i| (i + 1).zero? ? (i.even? ? i : nil) : nil}\nend", "  range = (b-a).to_a\n\
    \  even = []\n  for i in range\n    if i % 2 == 0\n      even << a\n      a +=\
    \ 1\n    end\n  end\n  even\nend", "  even = Array.new(b - a + 1)\n  i = 1\n \
    \ while i <= b\n    even[i] = i % a\n    i += 1\n  end\n  even\nend", "    return\
    \ (b - a).times.map { b | (a..b).map { |i| i%10 } }.sort.reverse\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nI thought about this and I liked it a lot, but then\
    \ I realized it wasn\u2019t working. Can you please post the output you received?\n\
    <|/ c |>\n<| c |>\nHmm.. I\u2019ve tried this and it just seems to return the\
    \ input numbers. `[6, 1, 8, 4, 2, 7, 3, 9, 5]`\n<|/ c |>\n<| c |>\nI don\u2019\
    t know what I\u2019m doing wrong. I\u2019ve tried a few variations and it just\
    \ seems to be returning the numbers I input to the script.\n<|/ c |>\n<| c |>\n\
    It looks like you have an extra `end` on your second last line.\n<|/ c |>\n<|\
    \ c |>\nThanks for the help. I ended up doing something very similar to this just\
    \ before I saw your answer. I did something like `[a,b,c,d]=[a,b,c,d].sort.reverse`\
    \ and that seems to have worked. Thanks again!\n<|/ c |>\n<| a dscore=0 tags=ruby\
    \ |>\n<code>", "  return [] if b - a < 2\n  even = []\n  odd = []\n  (a .. b).each\
    \ do |n|\n    n.odd? ? odd << n : even << n\n  end\n  [even, odd]\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays dscore=2 |>\n<| c |>\nThis works, however it uses\
    \ recursion which is usually frowned upon.\n<|/ c |>\n<| c |>\nI disagree. Recursion\
    \ is a perfectly valid way to solve this problem.\n<|/ c |>\n<| c |>\nRecursion\
    \ is perfectly valid but not preferred. There is an implicit loop there in ruby.\
    \ :)\n<|/ c |>\n<| c |>\nI wouldn't call it \"perfectly\" valid, but it's definitely\
    \ more efficient than iterating over an array (and less code to write), though\
    \ it's a bit of a contrived example :)\n<|/ c |>\n<| c |>\nRecursion is \"perfectly\"\
    \ valid in most cases, but \"perfectly\" valid is not the same as efficient. Remember\
    \ how you were taught to \"write less, do more\" in school? That was a good example,\
    \ but it's not a good example of the value of recursion.\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>\n[1,2,3,4,5,6,7,8,9].sort.select {|n| n %2 == 1}\n=> [1, 3, 5, 7,\
    \ 9]\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is not an efficient solution.\n\
    <|/ c |>\n<| c |>\nIt is a trivial solution to a simple problem. I would recommend\
    \ this answer over others because of it's simplicity.\n<|/ c |>\n<| c |>\nI agree\
    \ that this is a trivial solution to a simple problem. However, it does introduce\
    \ unnecessary overhead, such as a method call when the array is so small.\n<|/\
    \ c |>\n<| c |>\n`sort` has to go through all the elements at least once in order\
    \ to return a sorted array. `select` will go through each element only once in\
    \ any case.\n<|/ c |>\n<| c |>\nThe method call is expensive, but also more memory-intensive\
    \ than a trivial loop. Even when only going through 100 elements, it's less efficient\
    \ than a trivial loop. If this is in some performance critical part of your program,\
    \ you should refactor to something more efficient. If this code is just a one-off\
    \ or throwaway program, the overhead is negligible.\n<|/ ", "    return a.times.map{\
    \ |i| a * (rand(b+1) - rand(1))}\nend", "  return a > b ? [] : (b - a).downto(1).map\
    \ { |i| (a + i).to_i }\nend", "  a = 0\n  b = 0\n  array = []\n  while a <= b\n\
    \    number = generate_integer(a, b)\n    array.push(number)\n    a += 1\n   \
    \ b += 1\n  end\n  array\nend", "  a <=> b\nend", "  result = []\n  while b >\
    \ 0\n    if b%2 == 0\n      a += 2\n    else\n      a -= 1\n    end\n    b /=\
    \ 2\n    result << a\n  end\n  result\nend", "  return [] if a >= b\n  result\
    \ = []\n  (a..b).each do |i|\n    result << i if (i & 1) == 0\n  end\n  result\n\
    end", "  return [a + (i * (b - a)).to_s.rjust(b.to_s.length, '0').to_i \n    \
    \      for i in 1..(b - a)]\nend", "  return [] if a > b\n  (a + 1).downto(b)\
    \ do |i|\n    (i / 10).even? ? i : nil\n  end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=ruby |>\nHere is another recursive method:\n<code>", "  return b ? [...generate_integers(b,\
    \ a), [a]] : [a]\nend", '  integers = []', "    i = 0\n    while i <= b\n    \
    \    i += (a + 1).to_i\n    end\n    i = 0\n    while i <= a\n        i += (a\
    \ + 1).to_i\n    end\n    i = 0\n    while i <= b\n        i += (a + 1).to_i\n\
    \    end\n    i = 0\n    while i <= b\n        i += (a + 1).to_i\n    end\n  \
    \  i = 0\n    while i <= a\n        i += (a + 1).to_i\n    end\nend", "  (a +\
    \ b + 1) * (a / b).to_i\nend", "  int_range = (1..(b - a))\n  int_range.map do\
    \ |i|\n    i / (10**((b - a).to_f / 2))\n  end\nend", "  (1..b).select { |n| n\
    \ % a == 0 }\nend\n</code>\nTo find the missing digits between 2 numbers a, b\
    \ (inclusive), we must generate the list of numbers between a and b, then use\
    \ the missing_digits method described above.\n<code>", "  (1..b).collect {|i|\
    \ (a..b).collect {|j| i*j}.reject {|e| e < 0}}.flatten.compact\nend", "    lower\
    \ = a < b\n    result = []\n    until a > b do\n        num = rand(lower...b)\
    \ + 1\n        until num == 0 do\n            result.push num\n            num\
    \ = rand(lower...b) + 1\n        end\n        a = b\n        b = num\n    end\n\
    \    until lower do\n        result.push a\n        a = rand(lower...b) + 1\n\
    \    end\n    result\nend", "  evens = Array.new(a-1)\n  (1..b-1).each do |n|\n\
    \    evens.unshift(n) if evens.grep(&:odd?).size < n\n  end\n  evens.reject!(&:odd?)\n\
    \  evens.sort!\nend", "  if a > b\n    return []\n  else\n    list = []\n    (1..a).each\
    \ { |n| list << n }\n    list.push(b)\n    list.sort! { |x, y| y <=> x }\n   \
    \ list\n  end\nend", "    arr = []\n    (a - 1).downto(0) do |x|\n        (b -\
    \ 1).downto(0) do |y|\n            arr << x + (y - 1) * 10\n        end\n    end\n\
    \    arr\nend\n</cell>\n<code language=julia-1.2>\ngenerate_integers(2, 8)\n</cell>\n\
    <code language=julia-1.2>\ngenerate_integers(8, 2)\n</cell>\n<code language=julia-1.2>\n\
    generate_integers(10, 14)\n</cell>\n<code language=julia-1.2>\ngenerate_integers(0,\
    \ 100)\n</cell>\n<code language=julia-1.2>\ngenerate_integers(100, 0)\n</cell>\n\
    <text>\nNext, we want to convert a string into a vector. For example, suppose\
    \ we have the string \"hello\", then we want to generate the vector", "  int_list\
    \ = []\n  int_list << a\n  while int_list.last.to_i <> b\n    int_list << int_list.last.to_i\n\
    \  end\n  int_list.last.to_i\nend", "  evens = []\n  for i in 1..b\n    evens\
    \ << a % 10\n    a /= 10\n  end\n  evens\nend", "  a *= -1\n  return a - ((a +\
    \ b) / 2)\nend", "  a.downto(b) do |i|\n    return [i, i] if (i % 2) != 0\n  end\n\
    end\n</code>\nIn your code:\n<code>", "  (1..b).map { |i| a % i == 0 ? i : nil\
    \ }.compact\nend\n</code>\nUsing this new function:\n<code>", "  integers = []\n\
    \  (1..b).each do |i|\n    integers += (1..i).select {|j| j % a != 0}\n  end\n\
    \  integers\nend", '  result = []', "  result = []\n  while a <= b\n    result\
    \ << a\n    a += 2\n  end\n  result\nend", "    arr = []\n    if a < b\n     \
    \   a, b = b, a\n    end\n    while a < b\n        arr << a\n        a += 1\n\
    \    end\n    arr\nend", "    range = b-a+1\n    (0...range).to_a.sort_by(&:to_i).map{|i|\
    \ i + a}.compact\nend", "  arr = []\n  while a <= b\n    arr << a while a % 10\
    \ == 0\n    a += 1\n  end\n  arr\nend", "  r = a\n  puts [r]\n  while r < b\n\
    \    r = r + 2\n    puts [r]\n  end\n  puts [r]\n  puts \"Done.\"\nend", "   \
    \ even = []\n    while a < b\n        even << (a % 10)\n        a = (a * 10) +\
    \ 1 - (a % 10)\n    end\n    even\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ solve the problem because even and odd are in different lists. You just want\
    \ to sort a list of even numbers in ascending order.\n<|/ c |>\n<| c |>\nYou are\
    \ right, I had missed that.\n<|/ c |>\n<| c |>\nHow would I be able to get the\
    \ odd numbers between a and b?\n<|/ c |>\n<| c |>\nYou want to get odd numbers\
    \ between a and b, but in ascending order, so I guess you want to sort them in\
    \ ascending order?\n<|/ c |>\n<| c |>\nYes correct, I want the odd numbers sorted\
    \ in ascending order\n<|/ c |>\n<| a dscore=2 tags=ruby |>\nHere's one possible\
    \ solution:\n<code>", "  return [] if a > b || a <= 0\n  result = []\n  i = 0\n\
    \  while i < a || i < b\n    i += 1\n    result << i if i % 2 != 0\n  end\n  result\n\
    end", "    sum = []\n    count = 0\n    while count <= b-a+1\n        sum += [(2\
    \ * a+count)..(b-a+1)].sort.map{|i| (i+1)%10 }\n        count += 1\n    sum\n\
    end", "  # Write your code here.\n  if a <= 0 || b <= 0\n  else\n    digits =\
    \ []\n    i = 0\n    while i <  a\n      digits[i] = i % (b - a + 1) + a\n   \
    \   i += 1\n    return digits\n  end\nend", "  result = []\n  (1..b).each do |n|\n\
    \    (1..a).each do |m|\n      if (m*m > n*n)\n        result << n\n        break\n\
    \      end\n    end\n  end\n  result\nend", "  digits = 0..a\n  i = b\n  while\
    \ i < a\n    digits = digits[0..i] + digits[1..a]\n    i += 1\n  end\n  digits.sort\n\
    end", "  # TODO: Implement me\nend", "  a = '0' * (a - b)\n  nums = (0..b)\n \
    \ a.split(//).each_with_index do |char, idx|\n    char = char.to_i\n    until\
    \ nums.any? {|n| n % char == 0 } do\n      next if nums.size == 0\n      next\
    \ if nums.first == 0\n      nums.shift\n    end\n    nums << char\n  end\n  nums.map\
    \ { |n| n.to_s(36) }\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| a dscore=1\
    \ |>\nI propose this ruby solution\n<code>", "  digits = []\n  while a <= b\n\
    \    digit = a % 10\n    a /= 10\n    b /= 10\n    digits.append(digit)\n  end\n\
    \  digits = digits.reverse\n  digits.each{|d| puts d}\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI like this idea, however, it just seems to return a bunch of zeroes\
    \ in my case.\n<|/ c |>\n<| c |>\nThat is interesting, it works fine for me, I\
    \ think there was something wrong with my test cases? I used generate_integers(10,\
    \ 13) to test it.\n<|/ c |>\n<| c |>\nInteresting... I'll play around with it\
    \ some more and let you know if I can get it to work for me.\n<|/ c |>\n<| c |>\n\
    Hmmm... I seem to have hit a snag when running this through RSpec. RSpec is returning\
    \ `expected: 3, got: 1` and I can't figure out why...\n<|/ c |>\n<| c |>\nI figured\
    \ out my problem, it was my fault, I was returning the wrong thing in the `get_digit`\
    \ function! Thanks for helping me find it!\n<|/ c |>\n<| a |>\nI know this is\
    \ old, but here is a simple answer that doesn't require a recursive call:\n<code>",
  "  return (a..b).select { |x| x % 2 == 0 }\nend", "  a = (a % 100).to_i\n  b = (b\
    \ % 100).to_i\n  \n  int_a = a.to_i\n  int_b = b.to_i\n  \n  int_a = (int_a..int_b).to_a\n\
    \  int_a.each do |int|\n    int_b += 1\n    if (int % 2 == 0)\n      int_b +=\
    \ 1\n    end\n    break if int_b <= int_a\n  end\n  int_a\nend", "    puts b -\
    \ a\n    while a <= b\n        a += 2\n        puts a\n    end\nend\ngenerate_integers(2,\
    \ 8)\n</cell>\n<text>\nExercise 3\nWrite a function called even_integers that\
    \ takes two arguments: an integer a and a integer b. Your function should return\
    \ a list of integers between a and b each containing an even digit (1 through\
    \ 9). For example, given a = 2 and b = 8, your function should return [2, 4, 6,\
    \ 8, 1, 3, 5, 7, 9].", "  (a + b) - b + 2 * a\nend", '  result = []', "    a.upto(b.downto(a)\
    \ + 1) do |i|\n        if i % 2 == 0\n            puts i\n        end\n    end\n\
    end", "  a = a - 1 if a.odd? and a.positive? and a.nonzero? and a.odd?\n  b =\
    \ b - 1 if b.odd? and b.positive? and b.nonzero? and b.odd?\n  res = []\n  while\
    \ a <= b\n    a += 2 if a.odd? and a.positive? and a.nonzero? and a.odd?\n   \
    \ res << a.odd? ? a.to_s + a.even? ? \"0\" : a.to_s + a.even? ? \"2\" : a.to_s\n\
    \    a += 2 if a.odd? and a.positive? and a.nonzero? and a.odd?\n  end\n  res\n\
    end", "    range(a,b).map { |i| i - (a..b).to_a.index(i % b) }\nend", "  return\
    \ [] if a > b\n  n = []\n  while a <= b\n    n << a\n    a += 2\n  end\n  n\n\
    end", "  result = []\n  a.upto(b.to_i) do |i|\n    result << i unless i.odd?\n\
    \  end\n  result\nend", "  result = []\n  while a < b\n    result.push b - a -\
    \ 1\n    a += 2\n  end\n  result\nend", "  int_range = a.upto(b) # Get all integers\
    \ between a and b\n  int_range.each do |i| # Iterate over the range\n    int_range.count(i)\
    \ #if i is a duplicate, count it once to account for duplicates.\n  end\nend",
  "  r = []\n  while a <= b\n    a += 1\n    if a <= b\n      r << a\n    end\n  end\n\
    \  r\nend", "  while a < b\n    p =\n    if a >= b\n      b\n    else\n      a\n\
    \    end\n    p += 2\n    while p < b\n      p += 2\n    end\n    p -= 1\n   \
    \ b += 1\n  end\nend", '  return [] if a > b', "  # write your code here\n  return\
    \ []\nend", "  result = []\n  (1..b).each do |n|\n    result += a * (n - 1).downto(a)\n\
    \  end\n  result\nend", "    even = generate_numbers(a, b)\n    odd = generate_numbers(b,\
    \ a)\n    even.concat(odd)\n    even.uniq!\n    even.sort!\n    return even\n\
    end", "  (1..b).each {|x| return x if a*x <= b}.first(a - 1)\nend", "  # Return\
    \ an empty array if the numbers are too large (> 999)\n  return [] if b > 999",
  "  result = []\n  (1..b).each do\n    (a + a).times do\n      result << a\n    \
    \  a += 1\n    end\n  end\n  result\nend\n</code>\n<|/ a |>\n<| a tags=ruby,algorithm\
    \ dscore=2 |>\nHere is a recursive solution using Ruby 2.0 and its Array#repeated_permutation:\n\
    <code>", "  if a < b\n    a, b = [b, a]\n  end\n  a.downto(b).select {|n| n %\
    \ 2 == 0}\nend", "  a = [a]\n  b = [b]\n  a.pop if a.empty?\n  b.pop if b.empty?\n\
    \  res = []\n  a.pop.times do\n    res << a.pop.next\n  end\n  b.times do\n  \
    \  res << b.pop.next\n  end\n  res\nend", "  result = []\n  (1..b).each do |i|\n\
    \    result += [a*i % (10**b)]\n  end\n  result\nend", "    lower = a\n    upper\
    \ = b\n    digits = []\n    while lower < upper\n        digits.push(lower)\n\
    \        lower = lower + 2\n    end\n    digits.reverse!\n    digits\nend", " \
    \ a = [a, b].min # guarantee that b >= a\n  generate_integers(a, b + 1) if b <=\
    \ a # recursive case\n  a = a.floor\n  a = a.next if a.odd?\n  a.upto(a + 1, b\
    \ - a + 1) do |i|\n    yield i\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nCan you explain why you're using recursion?\n<|/ c |>\n<| c |>\n: It's a\
    \ [simple problem](https://en.wikipedia.org/wiki/Simple_inclusion_test) I wanted\
    \ to solve with recursion.\n<|/ c |>\n<| a dscore=0 |>\nThe other solutions posted\
    \ here using 'range' are fine, but that would not work with arrays of different\
    \ sizes. I wanted to make a solution using recursion and 'each'.\n<code>", " \
    \ # TODO: Write your code here\nend", "  result = []\n  while a <= b\n    result\
    \ << ((a % 10).floor).next\n    a += 1\n  end\n  result\nend", '  arr = []', " \
    \ evens = Array.new(a - b)\n  evens += a - (b - 2)\n  evens.fill(b - 2) until\
    \ evens.uniq.size == 0\n  evens.sort\nend", "  (1..b).select {|i| i % a == 0}\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c\
    \ |>\nYou can't just use `b - a` because that doesn't count the final digit. You\
    \ have to check each number from 1 to b and then add them to a `hash`. Then, when\
    \ you're done, `hash.values` will return an array of the unique odd digits.\n\
    <|/ c |>\n<| c |>\nThat's a good point. My answer could be easily modified to\
    \ account for that though.\n<|/ c |>\n<| c |>\n`(0..(b-a)).step(2).map { |i| b\
    \ + i - (b - i).abs%b}.reverse.uniq.compact` should do the trick. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nNice, just remember that `hash.values.uniq` will\
    \ only return unique values. I suppose that makes sense since `uniq` only checks\
    \ for equality, and `hash.values.uniq` won't return `[2,3,4]` for example since\
    \ 2 != 3.\n<|/ c |>\n<| c |>\nThanks for the answer. I am not familiar with hash\
    \ tables, but I believe this algorithm is correct. But I would really appreciate\
    \ if you could give me some explanation on the code you posted.\n<|/ c |>\n<|\
    \ a |>\nYou will need an Array and a Hash to store each odd number from 1 to n.\
    \ \n<code>", "  result = []\n  (b - a).to_i(0).times {\n    a + (rand(a + (b -\
    \ a)).abs * rand(b - a)).to_i << result.push(rand(a + (b - a)).abs).to_s\n  }\n\
    \  result\nend", "\tres = []\n\tdigits = b - a\n\tremainder = 0\n\twhile digits\
    \ != 0\n\t\tdigits = digits - 1\n\t\tremainder = remainder + a\n\tend\n\tfor i\
    \ in 0...remainder\n\t\tres.push(i)\n\tend\n\treturn res.reverse\nend", "  a_bit_array\
    \ = [a * b].pack('L').to_i(2).divmod(2**32)\n  result = []\n  while a_bit_array[0]\
    \ > 0\n    result << a_bit_array[0] & 0xffffffff\n    a_bit_array[0] = (a_bit_array[0]\
    \ - a_bit_array[1]).divmod(2**32)\n  end\n  result\nend", "  # Write your code\
    \ here\n  return [] if a > b\n  [a...b].sort.reverse.each_slice(2).map { |_, idx|\
    \ idx }\nend", "  i = 1\n  result = []\n  while i <= a or i <= b\n    result +=\
    \ [i]\n    i += 1\n  end\n  result\nend", "  result = []\n  (a - 1).downto(0)\
    \ do |d|\n    (b.to_f / d).to_s.chars.map { |c| c.to_i }.each do |i|\n      result\
    \ << i % d\n    end\n    break if result.length >= b\n  end\n  result\nend", " \
    \ l = []\n  while a < b\n    a, b = b, a+b\n    l.push(b % 10)\n  end\n  l\nend",
  "    return [] if a > b\n    (0...b).select { |i| a % i == 0 }.sort\nend", "  return\
    \ [] if a < b\n  [b] + generate_integers(a - 1, b) if a > b\nend\ngenerate_integers(2,\
    \ 8) #=> [2, 4, 6, 8]\ngenerate_integers(8, 2) #=> [2, 4, 6, 8]\ngenerate_integers(10,\
    \ 14) #=> []\ngenerate_integers(10, 10) #=> []\ngenerate_integers(0, 0) #=> []",
  "  return b.to_a if a.zero? || b.zero?\n  (a + b).to_a.sort_by(&:to_i).map { |x|\
    \ x.to_i }\nend", '  return [] if a >= b', "  return [] if a < 0 || b < 0\n  return\
    \ [a, b] if b > a || b < a\n  \n  res = []\n  while a != b\n    a -= 1\n    b\
    \ = a % b\n    break if a == 0\n  end\n  \n  res += b\n  a += 1\n  \n  while a\
    \ != b\n    b += 1\n    a %= b\n  end\n  \n  res += a\n  \n  return res\nend",
  "  (0..(b - a)).each do |i|\n    puts \"[#{i}, #{i + a - 1}, #{i + a + 1}]\"\n \
    \ end\nend", "  result = []\n  (b - a).times do\n    result << (a + (rand(10)\
    \ * (b - a + 1)))\n  end\n  result\nend", "    step = (b - a) / 2 + a\n    result\
    \ = []\n    (1..step).each do |i|\n        next if i == a\n        result << i\n\
    \    end\n    return result\nend", "    i = 0\n    while i <= b\n        if i\
    \ % a == 0\n            puts i\n        end\n        i += 1\n    end\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>", "  range = a..b\n  evens = range.select {|n|\
    \ n % 2 == 0}\n  evens.sort.reverse\nend\n</code>\n<|/ a tags=ruby,arrays,string\
    \ |>\n<| c |>\nThat is quite clever, and clever and clever and clever. I think\
    \ I would have approached this problem by creating 2 arrays of digits, `odd_digits`\
    \ of `a` and even digits of `b`, and then finding the difference between the arrays.\n\
    <|/ c |>\n<| c |>\n, I think that approach is better. I'd prefer using two arrays\
    \ over an array to hold two numbers, but I think you could also use an array.\n\
    <|/ c |>\n<| c |>\nThis could certainly be optimized to remove the use of Array#select\
    \ and Array#sort by only returning the odd ones from #sort, but I think doing\
    \ so would make it less legible.\n<|/ c |>\n<| c |>\n, yes, I think that would\
    \ make it a little nicer. I'll try to edit my answer to use your approach.\n<|/\
    \ c |>\n<| c |>\nI have edited my answer, and I think it is probably a little\
    \ nicer than my last approach. My approach is much more efficient than my second\
    \ one.\n<|/ c |>\n<| a dscore=2 |>\nThe most efficient way I can think of is to\
    \ use recursion:\n<code>", "  evens = 0..(b-1)\n  evens.map {|i| a..(a+1).to_a\
    \ & evens.to_a[i.to_s]}.flatten\nend\n</code>\n<|/ a tags=ruby,arrays dscore=0\
    \ |>\n<| a tags=ruby,arrays |>\n<code>", "  result = []\n  (1..b).each{|i| result\
    \ << i}\n  (1..a).each{|i| result << i unless result - i.inject{|sum, n| sum +\
    \ n}}\n  result\nend", "  raise ArgumentError, 'first argument must be greater\
    \ than or equal to second argument' if a.nil? || b.nil? || a < b\n  (a .. (b -\
    \ a + 1)).select {|x| x.to_i == x / 10 ? x.to_i.even? : x.to_i.odd? }\nend", " \
    \ result = []\n  while a < b\n    a += (10 ** (8 - a))\n    result.push(a)\n \
    \ end\n  result\nend", "  (a .. b).each_with_object([]) do |i, a|\n    a << i\
    \ if (i.to_s.chars.map(&:ord).reduce(:+) % 2).zero?\n  end\nend", "  x = a\n \
    \ y = b", "  return Array.new(b-a + 1, 0) << a | a >> (b-a + 1)\nend", "  n =\
    \ 1\n  result = []\n  while n <= b do\n    result << n\n    n += a\n  end\n  result\n\
    end", "  x = []\n  while a <= b\n    a += 2\n    x.push(a)\n  end\n  x\nend",
  "  result = []\n  while a <= b\n    a += 2\n    result << a\n  end\n  result\nend",
  "  result = []\n  while a <= b\n    a += 2\n    result << a\n  end\n  result\nend",
  "  digits = []\n  loop do\n    digit = (a + b) / 2\n    if a > b || digit.to_i ==\
    \ 0\n      break\n    end\n    digit = digit.to_i\n    a -= digit\n    b /= 10\n\
    \    digits << digit\n  end\n  digits.reverse\nend", '  return [] if a >= b',
  "  if a == b\n    []\n  else\n    a = (a - 1) * 10\n    b = b * 10\n    puts a\n\
    \    puts b\n    if b >= a\n      generate_integers(b, a)\n    elsif a < b\n \
    \     generate_integers(a, b)\n    else\n      puts \"Done!\"\n    end\n  end\n\
    end", "  puts \"#{a} #{b}\"\n  return nil unless b > a\n  (1..b).each do |i|\n\
    \    (i / a).times do |j|\n      p i\n      p j\n      p a / j\n      p j + ((j\
    \ / a) * a)\n      puts \"\\n\"\n    end\n  end\n  puts \"\\n\"\nend", "  (a >\
    \ b) ? [a] : [].tap do |integers|\n    (a > 0) ? integers = integers + generate_integers(a\
    \ - 1, b)\n               : integers += generate_integers(b - 1, a)\n  end\nend",
  "  result = []\n  (1..b).each{|i| result << i % a if i % a == 0}\n  result\nend",
  "  return [] if a > b\n  a.upto(a + b - 1) do |i|\n    if i % a == 0 && i % b ==\
    \ 0\n      yield i\n    end\n  end\nend", "  range(a..b).select {|x| x % 2 ==\
    \ 0}\nend\n</code>\nYou just need to call it in your method and return the result:\n\
    <code>", "    digits = []\n    digit = a % 10\n    a /= 10\n    digits.append(digit)\n\
    \    digits.reverse", "  return [a, b, a, b, b, b, a, a] if a > b else [a, b,\
    \ b, a, a, b, b, a, a] if b > a || b <= 0\n  result = []\n  while a <= b\n   \
    \ result.push(a)\n    a += 1\n  end\n  result\nend", "  r = []\n  if a < b\n \
    \   puts \"#{a} is smaller than #{b}\"\n  else\n    puts \"#{a} is larger than\
    \ #{b}\"\n  end\n  for a ... b\n    next if b <= 0\n    puts \"#{a}...\"\n   \
    \ r.unshift(a)\n  end\n  r\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  even = []\n  if a == b\n    even.push a\n  else\n    even.push\
    \ a - b\n    while a < b\n      even.push a\n      a += 1\n    end\n    even.push\
    \ b\n  end\n  return even\nend", "  return [] if b < a || a < 0\n  result = []\n\
    \  x = a\n  while x <= b\n    result << x\n    x += 2\n  end\n  result\nend",
  "  r = []\n  (a .. b).each do |i|\n    r.push( i )\n  end\n  return r\nend", " \
    \ result = []\n  while a < b\n    result << (a % 10).to_i\n    a += 1\n  end\n\
    \  result\nend", "  return a.downto(1).map do |x|\n    x % 10\n  end.take_while\
    \ do |x|\n    x.odd?\n  end.take_while do |x|\n    x <= b\n  end\nend", "    return\
    \ [] if a < b\n    (carry, digits) = generate_integers(b, a) rescue [b, a]\n \
    \   digits.each_with_index.map { |d, i| ((carry % 10) + d) % 10 }\nend", "  if\
    \ b > 0\n    return []\n  else\n    return a.times.map { |i| i / 10 }.reverse\
    \ until a == 1\n  end\nend", "  (1..b).select{|x| x % a != 0}\nend", "  return\
    \ [] if a >= b\n  range = a..b # Range is inclusive\n  range.uniq.select { |x|\
    \ x % 2 == 0 } # Return unique even numbers\nend", "  a = a.to_i\n  b = b.to_i\n\
    \  if a > b\n    a, b = b, a\n  end\n  (1..b).to_a.reverse.select { |i| i % a\
    \ == 0 }\nend\n</code>\n<|/ a dscore=0 tags=ruby-on-rails,ruby |>\n<| c |>\nPlease\
    \ add an explanation as to why this solution works.\n<|/ c |>\n<| c |>\nJust did\n\
    <|/ c |>\n<| c |>\n\"*Given two positive integers a and b, return the even digits\
    \ between a and b, in ascending order.*\" - `[a,b].sort[2..-1].map{|x|x.to_s[0,x.to_s.length/2]}`\n\
    <|/ c |>\n<| a |>\nHere's a fun solution, by splitting the input string into letters\
    \ and numbers and then building a string containing only the numbers:\n<code>",
  "  evens = []\n  while a <= b\n    evens.push b%10\n    b = b /10 # integer division\
    \ makes this an int\n  end\n  evens.push b\n  evens\nend", "  result = []\n  (a..b).each\
    \ do |num|\n    while num % 10 == 0\n      result << num\n      num = num / 10\n\
    \    end\n  end\n  result\nend", "  while a < b\n    a += 1\n    b += 1\n  end\n\
    \  a\nend", "  (a .. b).select { |n| n % 2 == 0 }\nend", "  even_integers = []\n\
    \  while a < b\n    even_integers.push(a+rand(9))\n    a += rand(9)\n  end\n \
    \ even_integers\nend", "  res = []\n  while a <= b\n    res << a\n    a, b = b,\
    \ a + b\n  end\n  res\nend", "  return [] if b > a\n  result = []\n  for i in\
    \ 0 .. b\n    if i % a == 0\n      result << i\n    end\n  end\n  return result\n\
    end", "    i = b\n    (1..b).each do |e|\n        if (e >= a) then\n         \
    \   yield e\n            i += 1\n        end\n    end\nend", "\tnumbers = Array.new",
  "  range = (1..b)\n  while a > 0 do\n    range.drop(1).each do |n|\n      a = a\
    \ - n\n      if a < 0\n        return range.take(b).reverse\n      end\n    end\n\
    \  end\nend", "  l = 0\n  u = b", "\ta < b ? [] : [(b % b / 2).floor * b + a -\
    \ 1] + (generate_integers(a, (b / 2).floor * 2) + generate_integers((b / 2).floor\
    \ * 2, b))\nend", "  a = (a / 10).floor\n  b = (b / 10).floor", "  return [] if\
    \ a > b\n  s = a + b\n  result = []\n  while a <= b\n    result << a\n    a +=\
    \ 2\n  end\n  result.reverse\nend\n</code>\nThe solution then becomes:\n<code>",
  "  a1 = a - 1\n  b1 = b - 1\n  \n  i = a1 \n  while i > b1\n    i = i - 1\n    i\
    \ += 1\n  end\n  \n  nums = []\n  while i < b1\n    nums << i\n    i += 1\n  end\n\
    \  \n  nums\nend", "  result = []\n  (a - 1).downto(0) do |x|\n    result += [x\
    \ - b].to_s * (a % x)\n  end\n  result << a - b\n  result\nend", "  even = a %\
    \ 10\n  odd =  b % 10\n  res = []\n  while even > 0 || odd > 0\n    if even >\
    \ 0 && (even + odd) % 2 == 0\n      even = even - even\n      res.push(even)\n\
    \    else\n      odd = odd - odd\n      res.push(odd)\n    end\n  end\n  res\n\
    end", "  result = []\n  loop do\n    if a >= b\n      break\n    end\n    a +=\
    \ 1\n    result << a\n  end\n  result\nend", "  (a > b) ? a : b\nend", '  result
    = []', "    integers.shuffle.take((b - a).ceil).to_a\nend", "  result = []\n \
    \ (1..b).each do |i|\n    result << (a...i).take_while do |x|\n      x % 2 ==\
    \ 0\n    end.sort\n  end\n  result\nend", "    a, b = a.to_i, b.to_i\n    result\
    \ = []\n    i =  a\n    until i <= b\n        result << i\n        i += 1\n  \
    \  end\n    result.sort\n    result\nend\n</code>\n<|/ a |>\n<| c |>\nWhile this\
    \ code may answer the question, providing additional context regarding why and/or\
    \ how this code answers the question improves its long-term value.\n<|/ c |>\n\
    <| c |>\nThis only gets you the even numbers between two input numbers. The question\
    \ is how to get all even numbers between two given numbers.\n<|/ c |>\n<| a |>\n\
    The general pattern here is known as \"binary search\".\nIn other words, find\
    \ what number is closest to some input value and then check if that number is\
    \ in range.\nThe algorithm is as follows:\n<code>\nFind the middle element of\
    \ the list, call it m.\nLoop through all odd numbers starting at m and checking\
    \ if it is in range.\nIf it is, add m to result.\nIf it is not, check if it is\
    \ closer to m by checking if m+1 is closer to m.\nIf it is closer, swap m and\
    \ m+1, and repeat this until you reach an even number.\n</code>\nA good overview\
    \ of the complexity is given in the Wikipedia article.\n<|/ a tags=ruby,algorithm\
    \ dscore=5 |>\n<| c |>\nThank you very much for providing an easy solution in\
    \ ruby, but your explanation is a bit over my head. Could you provide an example\
    \ of how to implement this in ruby?\n<|/ c |>\n<| a tags=ruby,algorithm dscore=3\
    \ |>\n<code>", "  return [] if a > b\n  evens = generate_integers(a + 1, b - 1)\n\
    \  evens.unshift(a % 10) if a % 10 != 0\n  evens.unshift(a / 10 % 10) if a / 10\
    \ % 10 != 0\n  evens.unshift(a / 100) if a / 100 != 0\n  evens.unshift(a / 1000\
    \ % 10) if a / 1000 % 10 != 0\n  evens.unshift(a / 10000 if a / 10000 != 0 else\
    \ '')\n  evens.unshift(a / 100000 if a / 100000 != 0 else '')\n  evens.unshift(a\
    \ / 1000000 if a / 1000000 != 0 else '')\n  evens.unshift(a / 10000000 if a /\
    \ 10000000 != 0 else '')\n  evens.unshift(a / 100000000 if a / 100000000 != 0\
    \ else '')\n  evens.unshift(a / 1000000000 if a / 1000000000 != 0 else '')\n \
    \ evens.unshift(a / 10000000000 if a / 10000000000 != 0 else '')\n  evens.unshift(a\
    \ / 100000000000 if a / 100000000000 != 0 else '')\n  evens.unshift(a / 1000000000000\
    \ if a / 1000000000000 != 0 else '')\n  evens.unshift(a / 100000000000000 if a\
    \ / 100000000000000 != 0 else '')\n  evens.unshift(a / 10000000000000000 if a\
    \ / 10000000000000000 != 0 else '')\n  evens.unshift(a / 100000000000000000 if\
    \ a / 100000000000000000 != 0 else '')\n  evens.unshift(a / 1000000000000000000\
    \ if a / 1000000000000000000 != 0 else '')\n  evens.unshift(a / 10000000000000000000\
    \ if a / 10000000000000000000 != 0 else '')\n  evens.unshift(a / 100000000000000000000\
    \ if a / 100000000000000000000 != 0 else '')\n  evens.unshift(a / 10000000000000000000000\
    \ if a / 10000000000000000000000 != 0 else '')\n  evens.unshift(a / 1000000000000000000000000\
    \ if a / 1000000000000000000000000 != 0 else '')\n  evens.unshift(a / 10000000000000000000000000\
    \ if a\n      / 10000000000000000000000000\n      != 0 else '')\n  evens.unshift(a\
    \ / 100000000000000000000000000 if a\n      / 100000000000000000000000000\n  \
    \    != 0 else '')\n  evens.unshift(a / 1000000000000000000000000000 if a\n  \
    \    / 1000000000000000000000000000\n      != 0 else '')\n  evens.unshift(a /\
    \ 10000000000000000000000000000 if a\n      / 10000000000000000000000000000\n\
    \      != 0 else '')\n  evens.unshift(a / 1000000000000000000000000000000 if a",
  "  return [] if b > a\n  digits = []\n  while a > 0\n    a -= 1\n    digits.push(a%10)\n\
    \    a /= 10\n  digits.reverse!\n  digits.each_index do |index|\n    digits[index],\
    \ digits[index+2] = digits[index+2], digits[index]\n  end\n  digits.reverse!\n\
    \  digits[0..(b-a)+1]\nend", "  return [] if a >= b\n  a_to_b = b-a+1\n  even\
    \ = []\n  for i in 0..a_to_b-1\n    even.push(a+i)\n  end\n  even.sort\nend",
  "  while a < b\n    a, b = b, a + b\n    a % 2 == 0 ? (a.times { b % 2 == 0 ? b\
    \ % a : a }.to_a).sort : []\n  end\nend", "  return [] if a >= b\n  digits = generate_integers(a\
    \ + 1, b)\n  digits.insert(0, a) if a < 10\n  digits\nend", "  result = []\n \
    \ while a < b\n    result += [a]\n    a += 1\n  end\n  result.sort\nend", "  numbers\
    \ = []\n  while a < b\n    numbers << a % 10\n    a += 1\n  end\n  numbers.sort!\n\
    \  numbers\nend", "  (a + b).times { yield b.to_s.rjust(2, '0').to_i }\nend",
  "  i = 1\n  loop do\n    if i <= a || i > b\n      break\n    end\n    i += 1\n\
    \  end\n  i\nend", "  result = []\n  (1..b).each do |number|\n    result += ([number]\
    \ * number)[a..b]\n  end\n  result\nend", '    integers = []', "  generate_integers\
    \ = a > b ? [] : []\n  return b >= a ? generate_integers : generate_integers +\
    \ a.to_s.chars.sort.\n    collect { |n| [n, n % a] }\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis is an interesting way to do this in Ruby, but I don't think\
    \ it will work for larger numbers.  For example, if `a = 32768` and `b = 10`,\
    \ then `generate_evens(a, b)` is going to return `[]`, but I don't think that's\
    \ what the OP wants.\n<|/ c |>\n<| c |>\nI misread the original question, you\
    \ are right. This method works in general but will give an empty array if both\
    \ `a` and `b` are > 10. Will edit my answer with this caveat.\n<|/ c |>\n<| c\
    \ |>\nThanks for your answer but what if I want the solution to be in Ruby language?\n\
    <|/ c |>\n<| a tags=ruby dscore=0 |>\nI assume you mean by \"the digits between\
    \ a and b\" the set of all numbers between a and b (inclusive) that are even.\
    \  \nIf so, you can do this:\n<code>", "  r = []\n  while a < b\n    a += 1\n\
    \    r << a\n  end\n  r\nend", "  result = []\n  while a < b\n    a, b = b, a+b\n\
    \    result << b % 10\n  end\n  result\nend\n</code>\nI didn't add error handling\
    \ (and you should of course). Just use whatever code you have for integers to\
    \ generate the even digits between a and b.\n<code>\nintegers(8, 2)", "  result\
    \ = []\n  while a < b\n    (a += 2).times do \n      result.push(a) \n    end\n\
    \  end\n  return result\nend", "  (a + b).step(2) { |i| yield i }\nend", "  return\
    \ [] if a >= b\n  first = a\n  second = b\n  while first < second\n    first +=\
    \ first + first + 1\n    second -= second - second + second + 1\n  end\n  result\
    \ = []\n  while first < second\n    result << first\n    first += first + first\
    \ + 1\n    second -= second - second + second + 1\n  end\n  result\nend", "  return\
    \ [] if a < b\n  r = Array.new(a - b)\n  r += b.to_s * (b - a)\n  r.each_with_index\
    \ { |x, i| r[i] = x.modulo(b) }\n  r.sort.reverse\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nthanks! I wasn't aware of the modulus operator (%). I had thought that\
    \ modulo is only used for division.\n<|/ c |>\n<| c |>\nOh, yeah, I forgot about\
    \ that, sorry. Modulus is a weird operator though, it looks like it's meant to\
    \ be used for the remainder of division rather than a modulus, hence the weird\
    \ name. I think it's called a remainder operator because that's what it does.\
    \ I guess I never realized this before now.\n<|/ c |>\n<| c |>\nThe modulus operator\
    \ is used in conjunction with `%` which is also used in a number of other arithmetic\
    \ operators in Ruby. `%` is the modulus operator, and `%` is the remainder operator\
    \ (`/` the division operator). `%` is also used in an example in the [Math documentation](http://ruby-doc.org/stdlib-1.9.3/libdoc/math/rdoc/Math.html),\
    \ which is also the standard example in every Ruby tutorial.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nThis doesn't strictly answer your question, but if you're just trying to\
    \ find out all the numbers within a certain range (as opposed to generating them),\
    \ it's trivial with Array#to_a:\n<code>\n>> [11, 18, 23, 36, 43, 48, 54, 57, 61,\
    \ 65, 68, 73, 78, 83, 88, 93, 99].to_a\n=> [11, 18, 23, 36, 43, 48, 54, 57, 61,\
    \ 65, 68, 73, 78, 83, 88, 93, 99]\n</code>\n<|/ a dscore=3 |>\n<| c |>\nIt's not\
    \ so trivial for me to understand why this works.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nThe most elegant way is to use Ruby's own Enumerable#each_cons method:\n\
    <code>\n(1..10).each_cons(2) do |a,b|\n  p a\n  p b\nend", "  if a > b\n    [a,\
    \ b] = [b, a]\n  i = 0\n  result = []\n  while i < b\n    next_digit = rand(10)..rand(10).to_i\n\
    \    result << next_digit\n    i += 1\n  result\nend", "  result = []\n  while\
    \ a < b\n    digit = a%10\n    digit = digit * 10 + a%10\n    digit = digit *\
    \ 10 + a%10\n    a += 1\n    b += 1\n    result << digit\n  end\n  return result\n\
    end", "  (0..b).find_all {|i| i >= a}.sort.each_cons(2).to_a\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\n`[1,2,3,4,5,6,7,8,9,0]` => `[0,1,2,3,4,5,6,7,8,9]`\n\
    <|/ c |>\n<| c |>\nThis doesn't produce the required results.\n<|/ c |>\n<| c\
    \ |>\nIt was actually an afterthought and I completely forgot to adjust my code\
    \ to return all even numbers instead of even and odd numbers. My mistake.\n<|/\
    \ c |>\n<| a tags=ruby,arrays,ruby-on-rails-3 |>\n<code>", "  result = []\n  while\
    \ a <= b\n    result << a\n    a = generate_integers(b, a).inject(:+)\n  end\n\
    \  result\nend", "  even_integers = []\n  while a <= b\n    digit = a%10\n   \
    \ if digit.zero?\n      even_integers << digit\n      a += 10\n    else\n    \
    \  a += 1\n      break\n    end\n  end\n  even_integers\nend", "  puts \"[generate_integers(#{a},\
    \ #{b}) => #{gen_ints_between_ints(a, b)}]\"\nend", "  return [] if b < a \n \
    \ (a - 1).downto(b).to_a.map{|i| (i * 10) + i}.take_while {|i| i < a}.sort.take(a+1)\n\
    end", "  digits = []\n  while a <= b\n    a += 1\n    digits << a % 10\n  end\n\
    \  digits.reverse\nend\n</code>\nThen we can get the even digits of integers between\
    \ 2 & 10 like this:\n<code>\ngenerate_integers(2, 10)\n</code>\nThe odd digits\
    \ are left as an exercise for you.\nUpdate\nThe above solution can be easily extended\
    \ to include non-inclusive ranges.  Here's a version that includes a range & a\
    \ method to generate a list of integers from a specific range:\n<code>", "  numbers\
    \ = []\n  while a < b\n    numbers[a..b] = (a..b).to_a\n    a += 1\n    b += 1\n\
    \  end\n  numbers.flatten\nend", "  return a < b ? [] : (b - a).downto(1).flat_map\
    \ do |i|\n    [] if a.to_i ==  i\n    [] if b.to_i == i\n    i.to_s.rjust(2, \"\
    0\").to_i\n  end\nend", "  result = []\n  while a < b\n    result << (b - a).abs\n\
    \    next if a.zero?\n    next if result > b\n    a = b\n  end\n  result\nend",
  "    step = (b-a)/2\n    even = []\n    (1..b).each do |i|\n      even.push(i*step)\n\
    \    end\n    (0...a).each do |i|\n      even.push(i+step*2)\n    end\n    even.sort\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis code works only when `a` and `b`\
    \ are the same, otherwise `step` will be different for each step.\n<|/ c |>\n\
    <| c |>\nThis code works only when `a` and `b` are the same, otherwise `step`\
    \ will be different for each step.\n<|/ c |>\n<| c |>\n: Sorry, yes, I was just\
    \ answering the question, not criticizing your answer, since you obviously don't\
    \ need this anymore. Thanks for the comment.\n<|/ c |>\n<| c |>\nIt's not my answer,\
    \ but thanks for the suggestion.\n<|/ c |>\n<| a |>\nThe solutions above did not\
    \ work for me in ruby 2.0.0-p247. Here is another solution that works:\n<code>",
  "  if b < a\n    []\n  else\n    a = a.to_i\n    b = b.to_i\n    a = []\n    (a\
    \ + b).to_a.sort\n  end\nend", "\tint_arr = []\n\tint_arr += a % b\n\tint_arr\
    \ += a / (2 * b)\n\tint_arr.each do |i| int_arr.unshift(i)\n\tend\n\tint_arr\n\
    end", "  if a >= b\n    []\n  else\n    integers(a .. b).select { |i| i % 2 ==\
    \ 0 }\n  end\nend", "  a.downto(Math.min(a, b)) do |num|\n    if num % 2 == 0\n\
    \      yield num\n    end\n  end\nend", "  range = 0\n  while a < b\n    range\
    \ = (range * 10) + (a - b)\n    a = (a + 1)\n    b = b + 1\n  end\n  range.to_a[range\
    \ % 10].to_s\nend", "  if a > b\n    a, b = b, a\n  end\n  result = []\n  while\
    \ a <= b\n    a += 1\n    result << a\n  end\n  result\nend", '    digits = []',
  "  result = []\n  (0..b).each do |i|\n    if i % 2 == 0\n      result << i\n   \
    \ end\n  end\n  result\nend", "  return [] unless b > 0\n  result = []\n  while\
    \ a < b\n    a += 1\n    result += [a]\n  end\n  result\nend\n</code>\n<|/ a tags=algorithm,ruby\
    \ |>\n<| c |>\nThis is an awesome solution. Thank you! I wasn't expecting such\
    \ an elegant solution but this is very elegant and efficient.\n<|/ c |>\n<| c\
    \ |>\nThis is a nice solution to the problem as presented. However, it fails for\
    \ negative numbers. I wonder if there is a way to generalize the solution to handle\
    \ negative numbers?\n<|/ c |>\n<| c |>\nThanks for catching that. I fixed my answer\
    \ accordingly\n<|/ c |>\n<| a dscore=2 |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
