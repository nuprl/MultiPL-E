name: HumanEval_2_truncate_number
language: rb
prompt: "# Given a positive floating point number, it can be decomposed into\n# and\
  \ integer part (largest integer smaller than given number) and decimals\n# (leftover\
  \ part always smaller than 1).\n# Return the decimal part of the number.\n# >>>\
  \ truncate_number(3.5)\n# 0.5\ndef truncate_number(number)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_truncate_number\n\
  \    candidate = method(:truncate_number)\n    assert_equal(0.5, candidate.call(3.5))\n\
  \    assert_equal(0.25, candidate.call(1.25))\n    assert_equal(0.0, candidate.call(123.0))\n\
  \  end\nend\n"
completions: ["  number.to_s.split('.')[1].to_i\nend", "  number = number.floor\n\
    \  number, decimals = number.divmod(1)\n  return number unless decimals > 0\n\
    \  decimals\nend", "  parts = (number % 1).floor\n  decimal = (number - parts).abs",
  "  # remove integer\n  number = number_to_rounded(number)", "  int_part, decimal_part\
    \ = number_to_decompose(number)\n  int_part = (int_part / 10).floor\n  decimal_part\
    \ = 10 - decimal_part.floor\n  decimal_part * 10 if decimal_part > 0 # truncate\
    \ decimals\n  int_part.to_s + '.' + decimal_part.to_s\nend", "  parts = number.to_s.split('.')\n\
    \  parts[0].gsub!(/(\\d+\\.?\\d*)\\z/, '\\1')\n  if parts[0] < 1\n    parts[0].sub!(/\\\
    .?0*$/, '')\n  else\n    parts[0].sub!(/\\.?(\\d)$/, '\\1')\n  end\n  return parts[0]\
    \ + '.' + parts[1]\nend", "  dec = number[/^[0-9]+\\.?[0-9]*$/]\n  return dec\
    \ if dec && dec.length > 1 ? dec[/\\.?(\\d+)/].to_f : 0.0\nend", "  return number\
    \ % 1 == 0 ? (number / 1) : number\nend", "  numbers = Float(number)\n  return\
    \ numbers.floor.as_decimal(precision: numbers.decimals)\nend", "  # Round to nearest\
    \ integer and truncate.\n  integer = math.trunc(number)\n  # If there is a decimal\
    \ part, the number must be truncated\n  # to integer.\n  if number - integer <\
    \ 1.0\n    integer\n  else\n    integer\n  end\nend", "  number.to_s.split('.')[1].to_i\n\
    end", "  truncate_number_part = 0.0;\n  decimals = 0.0;\n  num_part = number.to_i;\n\
    \  while num_part > 0\n    decimals += 1\n    truncate_number_part += num_part\
    \ / 10.0;\n    num_part = num_part % 10.0;\n  end", "  return floor(number, -1)\n\
    end", "\treturn (number - number.floor)/number.abs\nend", "    factors = [1, 10]\n\
    \    rounded_number = number\n    decimal_part = 0", "  num = number.to_f\n  while\
    \ num > 0\n    num = num / 10.0\n  end\n  num\nend", "  truncate_number = number.floor\n\
    \  if truncate_number < 0.5\n    truncate_number\n  else\n    (number - truncate_number)\
    \ * Math::log(10)\n  end\nend", "  truncate_to = truncate_decimals(number)\n \
    \ truncate_from = truncate_decimals(truncate_to)\n  number = \"%.#{truncate_from}f\"\
    \ % truncate_to\n  number = number.sub(/\\.?0+$/, '') if number =~ /^\\.?0+$/\
    \ && truncate_from == 0\n  number.to_f\nend", "  if number < 1\n    0\n  else\n\
    \    truncate(number, -decimal_places(number))\n  end\nend", "  # Truncate the\
    \ decimal part to the minimum number of\n  # non-decimal digits (i.e. round down)\
    \ that is smaller than the\n  # given number\n  number = math.trunc(number)\n\
    \  return math.floor(number) if number > 0 else math.ceil(number)\nend\nend\n\
    </code>\n<|/ q |>\n<| c |>\nWhat is your question?\n<|/ c |>\n<| c |>\nHow do\
    \ I round up to the nearest whole number in Ruby?\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "  return [number%1, number].max\nend", "  if number < 1.0 and number\
    \ != 0 then\n    number = number - 1\n    number, decimals = math.modf(number)\n\
    \    number = math.trunc(number)\n  end\n  return number\nend\n</code></pre>",
  "  return (0.0 if number < 0.0 else\n          (1.0 / number) if\n          (number\
    \ >= 0.0 and number < 1.0) else\n          number)\nend", "  number = number.to_f\n\
    \  if number > 1.0 and number < 1.00000000000001 and number != 0.0\n    digits\
    \ = number.floor.to_s.split('.')\n    decimal = digits[1..-1].join\n    number\
    \ = number.to_f - number * decimal.to_f\n  end\n  return number\nend", "  parts\
    \ = (number - math.trunc(number)) * 100.0\n  parts -= parts % 1\n  parts\nend",
  "  part1 = (Math.ceil(number) - number) / 2\n  part2 = number - part1\n  return\
    \ part2\nend", "  return number.truncate(1).to_f\nend", "  return number.floor.to_f\
    \ if number.is_a? Integer\n  number.to_s.rindex('.').to_i\nend", "  number, decimals\
    \ = number.to_s.split(\".\", 1)\n  decimals = (decimals || 1).to_i\n  truncate_decimals\
    \ = (decimals - 1).abs\n  truncate_number = number.to_s.truncate(truncate_decimals)\n\
    end", "  number = number.to_f\n  return number.truncate if number.respond_to?(:truncate)\n\
    \  decimal_part = number.digits % Decimal::DIGIT_COUNT\n  quotient = number /\
    \ 10.**decimal_part\n  remainder = number % 10.**decimal_part\n  return quotient\
    \ * 10 **decimal_part if remainder.zero?\n  quotient, decimal = remainder.divmod(10.**decimal_part)\n\
    \  decimal_part == 0 ? decimal.zero? : decimal\nend", "  factor = 10.0 ** ceil(log10(number))\n\
    \  truncate_factor = factor * 10.0 - 1.0\n  return round(number / truncate_factor,\
    \ truncate_factor)\nend", "  pow10 = 10\n  abs_number = abs(number)\n  decimals\
    \ = abs_number - truncate(abs_number)", "  return ((number*100).floor).round/100.0\n\
    end", "  fraction, integer = Float(number).div(1).to_a\n  decimals = fraction.truncate\n\
    \  return integer + decimals\nend", "  return [round(number, 0), number - round(number,\
    \ 0)]\nend", "  number, integer_part, decimal_part = number.to_s.split('.')\n\
    \  decimal_part = decimal_part.sub(/0+$/, '')\n  return decimal_part\nend", " \
    \ truncated = number.floor\n  decimal = number.abs - truncated\n  if number.abs\
    \ == truncated\n    decimal == 0\n  else\n    decimal < 1 and return number\n\
    \  end\n  truncated + decimal\nend\n</pre>\n<p>\n  Note that in some languages,\
    \ integers may not be exact, e.g. Python uses\n  the C language integer type,\
    \ not Java's long.\n</p>\n<h4 id=\"finding-a-number-from-a-string-in-python\"\
    >Finding a number from a string in Python</h4>\n<p>\n  You can use string methods\
    \ to find numbers in a string. For example,\n  the '5' in '55.55.55.55' can be\
    \ found by\n</p>\n<pre class=\"code ruby\">\n<span class=\"ruby-comment\"># finds\
    \ 5 from the start of the string</span>\n<span class=\"ruby-identifier\">'55.55.55.55'.index(<span\
    \ class=\"ruby-string\">'5'</span>)", "  truncate_part = (number % 1) / 1\n  truncated\
    \ = truncate_part.floor\n  return truncated\nend", "  return [number.floor, number.frac].max\n\
    end\n</cell>\n<code language=julia-1.5>\ntruncate_number(3.5)\n</cell>\n<code\
    \ language=julia-1.5>", "  fraction, integer = Float(number).divmod(1)\n  decimal\
    \ =  fraction.truncate\n  \n  return decimal unless fraction.zero? && fraction.negative?\n\
    \  \n  truncated =  (integer + decimal).to_s\n  \n  integer = ''\n  while integer\
    \ <= number && integer != '.' && integer != ''\n    integer << 0\n    integer\
    \ += integer.to_s\n  end\n  \n  return integer + decimal.to_s\nend", "  parts\
    \ = number.to_s.split(\".\")\n  parts[0] = parts[0].gsub(/(\\d)\\1+$/, \"\\\\\
    1\")\n  parts[0] = parts[0].gsub(/0+$/, \"\")\n  return parts[0].to_f\nend", " \
    \ decimal_part = number.decimal\n  result = number / Math.pow(10, decimal_part)\n\
    \  result = truncate(result)\n  return result\nend", "  return number.truncate\
    \ ? number.truncate : BigDecimal.new('0.' + number.to_s)\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThat's a very cool solution!  I had to change it a little bit to\
    \ make it work.  I posted it as an answer.\n<|/ c |>\n<| a tags=ruby-on-rails,ruby\
    \ |>\n<code>", "  x = Math.log10(number)\n  y = Math.log(x, 10)\n  z = Math.round((y\
    \ - x + 1) * Math.pow(10, -Math.log10(number)))\n  trunc = number / (Math.pow(10,\
    \ z))\nend", "  precision = number.kind_of? Float\n  negative = number < 0", " \
    \ return [float(number) - int(float(number)), float(number) % 1].join.to_f\nend",
  "  if number.is_a?(BigDecimal)\n    BigDecimal.new('0').send(:new, (number.to_s.ljust(number.to_s.size,\
    \ \"0\")), :precision=>number.scale, :scale=>0)\n  else\n    BigDecimal.new('0').send(:new,\
    \ (number.to_s.ljust(number.to_s.size, \"0\")), :precision=>number.scale)\n  end\n\
    end", "    integer, decimal = math.modf(number)\n    decimal = decimal.round(decimal)\n\
    \    if decimal.is_zero?\n        integer = 0\n    elsif decimal.is_odd?\n   \
    \     integer = integer * -1\n    elsif integer.to_i < 0\n        integer = integer\
    \ * -1\n    end\n    return integer\nend", "  parts = number.floor.divmod(1)\n\
    \  decimals = parts[1].div(10).floor\n  parts[1].modulo(10).floor.divmod(1).first\n\
    end", "  return number.truncate if Rails.env.test? || Rails.env.development? else\n\
    \    number.round\nend", "  truncate_float_to_decimal(number)\nend", "  return\
    \ ((number % 1) == 0 and number) or number - math.floor( number )\nend", "  power\
    \ = (BigDecimal.new(number.to_s).to_f.to_i ** BigDecimal.new('0.5').to_i).floor\n\
    \  power = BigDecimal.new(number.to_s).to_f.to_i / BigDecimal.new(power.to_s).to_f\n\
    \  power = power.floor\n  power = power.to_i\n  power = power - 1\n  power = BigDecimal.new(\"\
    1\").to_f.to_i * power\n  return BigDecimal.new(number.to_s).to_f.to_i * power\
    \ / BigDecimal.new(number.to_s).to_f\nend", "  return number > 0 ? number.floor\
    \ : number\nend", "  return BigDecimal(number).truncate()\nend", "    decimal_part\
    \ = number % 1\n    integer =  number - decimal_part\n    return decimal_part\
    \ + (integer(number) != float(number).to_f)\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby\
    \ |>\n<| c |>\nI haven't found this post before today. I had to dig a bit to find\
    \ it and it solved my problem perfectly. Thanks!\n<|/ c |>\n<| a |>\nYou can use\
    \ Ruby's BigDecimal class to do this. It has numerous methods that make this easy:\n\
    <code>\nrequire 'bigdecimal'", "  number = number.to_f\n  decimals = Math.log10(number).floor\n\
    \  int_part = number - decimals.log10\n  trunc_part = Math.pow(10.0, decimals)\n\
    \  trunc_part_f = trunc_part.to_f\n  trunc_part_i = trunc_part_f.to_i\n  return\
    \ int_part + trunc_part_i\nend", "  return BigDecimal(number.to_s).truncate\n\
    end", "  return number - truncate_decimal(number)\nend", "  if number >= 0\n \
    \   number = number.floor\n  else\n    number = number.ceil\n  end\n  number =\
    \ number.to_i\n  if number % 1 == 0\n    return number\n  end\n  return number\
    \ - 1\nend", "  number = number.floor\n  while number.positive? && number > 1\n\
    \    number -= 1\n  end\n  number\nend", "  power = math.floor(math.log(number))\n\
    \  fraction = number / math.pow(10.0, power)\n  integerPart = integer - fraction\n\
    \  decimalPart = fraction\n  return decimalPart\nend", "  if number.is_a?(BigDecimal)\n\
    \    parts = number.to_s.split('.')\n    trunc_part = parts[0].to_i\n    number\
    \ = parts[1]\n  else\n    trunc_part = number.round(-BigDecimal.new('0.5'))\n\
    \    number = number.floor\n  end\n  \n  return number, trunc_part\nend", "  return\
    \ ((number - number.floor) / 0.01) / 1.0\nend", "  return number.to_s.split(\"\
    .\")[0].to_i\nend", "  return number.trunc if number.trunc.to_f < 1.0\n  number_int\
    \ = number.ceil\n  number_dec = number.floor\n  number_dec.to_f / number_int.to_f\n\
    end", "  return number - number.floor * number.to_f\nend", "  return floor(number\
    \ * 100) / 100\nend", "  return number.truncate if Rails.env.test? || (Rails.env.development?\
    \ && !Rails.env.cucumber?) \n  \n  parts = number.to_s.split('.')\n  parts[0].to_i\n\
    end", "  number, decimals = number.divmod(1)\n  decimals\nend", "    number =\
    \ number_to_dec(number)\n    if number < 1\n        number = 0\n    end\n    return\
    \ number\nend", "  number = number.to_i\n  return ((number * 100) + 100).floor/100.0\n\
    end", "  part1, part2 = number.to_s.split('.')\n  part1.slice!(part1.length-1,\
    \ part1.length).to_f\nend\n</pre>", "  return number - truncate_number_part(number)\
    \ if number > truncate_number_part(number) else number\nend", "  if number ==\
    \ 0\n    0\n  else\n    truncate_number(number/10) * 10\n  end\nend", "  if number.to_i.to_s\
    \ == number.to_s\n    number.to_s\n  else\n    number.to_f\n  end\nend", "  truncate_decimal\
    \ = number % 1\n  truncate_integer = number - truncate_decimal\n  return truncate_integer\n\
    end", "  decimals = 0.1 if number%1 == 0 else (0.0 if number < 1.0 else 1.0) -\
    \ number.floor\n  integer_part = number.ceil * 10 - number\n  truncate_part =\
    \ (integer_part.to_f / 10.0) * 10 - integer_part.to_i\n  decimal_part = truncate_part\
    \ * 10 / 10\n  return decimal_part\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,truncate\
    \ |>\nYou can use this:\n<code>", "  floored = Math.floor\n  decimal, integer\
    \ = floored(number), floored(number - 1.)\n  if decimal >= 1.\n    integer\n \
    \ else\n    integer + 1.\n  end\nend", "  number = round(number)\n  decimal_part\
    \ = number % 1\n  number = number - decimal_part\n  return number\nend", "  return\
    \ number.to_f if number.finite? and number.to_f.zero? and number.to_f.negative?\
    \ # number#round\n  # return number if number.finite? and number.to_f.zero? #\
    \ number#round\n  raise \"Not a number (#{number})\" if number.nil? or number.finite?\n\
    \  return 0.0\nend", "  return truncate(number, 1)\nend", "  return [truncate(number[0]),\
    \ number[1]]\nend", "\tnum = number.to_f\n\tif num >= 1\n\t\ttruncate_digit =\
    \ num % 1\n\t\tif truncate_digit == 0\n\t\t\treturn num\n\t\telse\n\t\t\treturn\
    \ truncate_digit * Math.pow(10, Float::INFINITY)\n\telse\n\t\treturn 0\n\tend\n\
    end", "  if number.is_a?(Float)\n    digits = BigDecimal(number.to_s)\n    return\
    \ BigDecimal.new(digits.digits.first(digit_digit_limit),\n                   \
    \     digit_digit_limit, digits)\n  elsif number.is_a?(BigDecimal)\n    digits\
    \  = number.digits\n    digits = digits[0,digit_digit_limit(digits)]\n    return\
    \ BigDecimal.new(digits, digit_digit_limit(digits), nil)\n  end\nend", "  return\
    \ number.trunc\nend", "  truncate_number = Math.trunc(number)\n  digits = truncate_number\
    \ - number\n  \n  if digits == 0\n    truncate_number\n  else\n    truncate_number\
    \ - Math.ceil(Math.log10(truncate_number))\n  end\nend", "\treturn (number - trunc(number))\n\
    end", "  num_stringified = \"#{i}\"\n  num_stringified = num_stringified.reverse.chars.to_a\n\
    \  if num_stringified.length == 1\n    digit = 0\n  else\n    digit = num_stringified.length\n\
    \  end", "  truncate_decimal(number,0)\nend", "  parts = number.to_s.split(\"\
    .\")\n  integer = parts[0].to_i\n  decimals = parts[1].to_i\n  if integer < number\n\
    \    integer\n  elsif decimals < 1\n    number\n  else\n    truncate(number *\
    \ 10, decimals)\n  end\nend", "    num = number.to_f\n    decimals = (num % 1).floor\n\
    \    return num - decimals\nend", "  return BigDecimal(number.to_s).divide(BigDecimal(10).pow(-BigDecimal(number.to_s).count('.'))).to_d\n\
    end", "  while number % 1\n    number /= 10\n  truncate_fraction(number)\nend",
  "  return truncate(number, 1) == 0? truncate_number(number*100) : number\nend",
  "  return number.round(0) / 1.0\nend", "\ttrunc_part, num = number.divmod(1)\n\t\
    return trunc_part\nend", "  return number.truncate if number\n  parts = number.to_s.split('.')\n\
    \  parts[-1] = parts[-1].sub('1').floor\n  parts[-2] = parts[-2].sub(parts[-2].to_f).floor\n\
    \  parts.join('.')\nend", "  return number.floor/number.to_f\nend", "  decimal\
    \ = number.to_f.floor\n  integer  = number.to_f.ceil - decimal\n  if integer <\
    \ 1\n    decimal  = 0\n    integer = 1\n  end\n  return number - decimal\nend\n\
    </pre>", "  truncated = (number % 1).floor\n  decimal = number - truncated\n \
    \ truncated = truncated.floor\n  if truncated == 0\n    truncated = 1\n  end\n\
    \  return truncated.to_f + decimal\nend", "  parts = (number % 1).floor, number\
    \ - parts[0]\n  parts[1] + 1 unless parts.all?\n  parts[0]\nend", "  truncate_decimal\
    \ = BigDecimal(number).truncate(BIGDECIMAL_PRECISION)\n  truncate_decimal = BigDecimal(truncate_decimal).divide(BIGDECIMAL_MULTIPLIER,\
    \ BigDecimal.ROUND_HALF_UP)\n  truncate_decimal = BigDecimal(truncate_decimal).divide(BIGDECIMAL_MULTIPLIER,\
    \ BigDecimal.ROUND_HALF_UP)\n  return truncate_decimal.to_f\nend\n</code>\n<|/\
    \ a tags=ruby-on-rails,ruby,ruby-on-rails-4 |>\n<| a |>\nHere is an optimized\
    \ version that works with BigDecimal and Float:\n<code>", "  number, decimals\
    \ = number.divmod(1)\n  return number\nend", "  return number.to_f / 10\nend",
  "  num = number.floor\n  return num if num < 1.0 else num - 1\nend\n</code>\n<|/\
    \ a dscore=0 tags=math,ruby |>\n<| a dscore=0 |>\nHere's another solution which\
    \ uses the floor method of BigNum.\n<code>", "  number.is_a?(Numeric) ? number.floor\
    \ : number\nend", "  if number < 1\n    1\n  else\n    number\n  end\nend", " \
    \ return number / 10\nend", "  number - BigDecimal(number).round(precision)\n\
    end", "  number, decimals = math.modf(number)\n  integers = (number - decimals)\
    \ * math.pow(10, decimals)\n  integer += decimals\n  return integer / math.pow(10,\
    \ decimals)\nend", "  \n  # Return number\n  return number\nend", "  return Math.trunc(number)\
    \ if number % 1 == 0 else Math.trunc(number * 10) / 10\nend", "  parts = [number]\n\
    \  parts << BigDecimal(\"0.#{parts[-1].to_s.rjust(9, '0')}\")\n  parts[-1] = parts[-1].succ\n\
    \  parts[-2] = parts[-1].abs\n  parts.delete_at -1\n  parts.join.to_i\nend", " \
    \ decomp = big_decomp(number)\n  decimal = decomp[-1,-1]\n  if decimal < 1\n \
    \   return number\n  end\n  quotient = decomp[-1,-2] * 10**(decomp[-2,-1]-1)\n\
    \  return number - quotient\nend", "  if number == 0.0 \n    1.0\n  else\n   \
    \ truncate_part(number)\n  end\nend", "  number_parts = number.to_s.split('.')\n\
    \  decimal_part = (number_parts.length > 1) ? number_parts[-1] : 0\n  integer_part\
    \ = (number_parts.length > 0) ? number_parts[0] : number\n  \n  if !number_parts[0].to_f.zero?\n\
    \    decimal_part = 1\n    number_parts[0] = number_parts[0].to_f\n  else \n \
    \   number_parts[0] = 0\n  end\n  \n  return number_parts[0] + (number_parts[1].to_f\
    \ * 10) + decimal_part\nend\n</cell>\n<text>\nNow we have, for instance, truncate_number(3.55)\
    \ to return 3 instead of 3.5.", "  if number < 1\n    0\n  else\n    truncate_number(number\
    \ - math.trunc(number))\n  end\nend", "  if number >= 1\n    decimal = number\
    \ % 1\n    number = number - decimal\n    number = number / 1\n  else\n    number\
    \ = 0\n  end\n  return number\nend", "  parts = number.to_s.split('.')\n  truncate_part\
    \ = parts[parts.length-1].to_i\n  if truncate_part.zero?\n    truncate_part\n\
    \  else\n    parts[0] + truncate_part + '.0'\n  end\nend", "  return [number %\
    \ 1, number - number % 1].max\nend", "  # Make it non-negative\n  number = -number\
    \ if number < 0 else number", "  power = number.to_i\n  fraction = number - power\n\
    \  integer = 0", "  return round(number, 10) if number % 1 == 0 else number\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThe solution works for integer and float\
    \ numbers but not strings. Any idea how to do that for strings?\n<|/ c |>\n<|\
    \ c |>\n`string.trunc` should work for strings as well, but you'll need to convert\
    \ the result to a float for it to work.  If you can't use `string`, you might\
    \ try `number.to_s` and then call `truncate_number`.\n<|/ c |>\n<| c |>\n`truncate_number(2.4.round)`\
    \ returns `2` but expected return value `2.4`\n<|/ c |>\n<| c |>\nYou might be\
    \ able to use [`round`](https://www.rubydoc.info/stdlib/core/1.9.2/Numeric#round-instance-method)\
    \ instead of `truncate_number`, but that's a little more complicated.\n<|/ c |>\n\
    <| c |>\n`truncate_number(2.4)` returns 2 but expected return value 2.4\n<|/ c\
    \ |>\n<| a dscore=5 tags=ruby,rounding,floating-point |>\n<code>\n2.4.round",
  "  return truncate(number, 1)\nend", "  return number - truncate_number(number *\
    \ 10)\nend", "    \n    number_integer = number\n    \n    number_fraction = number_integer.to_f",
  "    precision = number.to_s.size\n    integer = truncate_to_int(number)\n    fraction\
    \ = number - truncate_to_int(number)\n    fraction = fraction / 10**precision\n\
    \    fraction.round(2)\n    \n    truncated = integer + fraction.to_s\n    \n\
    \    unless truncated == number\n        truncated.send(:initialize, truncate_to_int(truncated))\n\
    \    end\n    \n    truncated\nend\n</code>\nThe code above will truncate a float\
    \ down to an integer, but only down to 14 digits. If you need a higher precision,\
    \ take a look at https://stackoverflow.com/a/13648500/36696\n<|/ a |>\n<| c |>\n\
    This answer is excellent.  However, I cannot get it working in rails 4.2.4\n<|/\
    \ c |>\n<| c |>\nThis code worked for me with rails 4.2.4. Make sure you're using\
    \ Ruby 2.x or later, because it's using Ruby 2.x and doesn't work with Ruby 1.x.\n\
    <|/ c |>\n<| c |>\nThis is an awesome answer! Thanks a lot. Just a note to anyone\
    \ trying to use this with Rails 5: It looks like `truncate_to_int` has been moved\
    \ to ActiveSupport, so you will need to add `ActiveSupport::CoreExtensions::Numeric::NumberMethods`\
    \ as an argument to your method call.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ dscore=4 |>\nBased on answer by I did this :\n<code>", "  int_part, decimal_part\
    \ = Float(number).to_s.split('.')\n  int_part.gsub!(/^0+/, '')\n  decimal_part.gsub!(/^0+/,\
    \ '')\n  decimal_part.gsub!(/0+$/, '')\n  truncate_decimal(decimal_part)\nend",
  "\tdecimal_part, integer_part = number_to_decompose(number)\n\treturn decimal_part\n\
    end", "  if number % 1 == 0\n    trunc_number = number\n  else\n    trunc_number\
    \ = number - 1\n    decimal_part_number = (number % 1)\n  end\nend", "  floored\
    \ = number.floor\n  decimal = number - floored\n  if floored.zero?\n    decimal.nan?\
    \ ? nan : floored.nan? ? floored : decimal\n  else\n    floored.nan? ? floored\
    \ : floored.floor.nan? ? floored.floor : floored.floor\n  end\nend", "\treturn\
    \ (number % 1)\nend", "  return number.to_f % 1 == 0 ?\n    number.to_f - number.to_f\
    \ % 1 :\n    number.to_f\nend", "  number = to_number(number)\n  return BigDecimal(number).truncate\
    \ if number.is_a? BigDecimal\n  return number.truncate if number.is_a? Fixnum\n\
    \  return number\nend", "  number_parts = number.to_s.split('.')\n  decimal_part\
    \ = number_parts.pop.to_i\n  \n  if number_parts.length == 1\n    truncate_part\
    \ = number_parts[0].to_i\n  else\n    truncate_part = decimal_part\n  end\n  \n\
    \  truncate_part == 0 ? 0 : (truncate_part + decimal_part).trunc\nend\n</code>\n\
    I took the liberty to fix your code. It's a little more verbose but it works :-)\n\
    <code>", "  floored = math.floor(number)\n  decimal = number - floored\n  floored,\
    \ decimal = floored.floor, decimal.floor\n  decimal, floored = decimal.round,\
    \ floored.round\n  return floored * Math.pow(10, decimal)\nend", "  return number.floor\n\
    end\n</code>\n<|/ a tags=ruby-on-rails,ruby |>\n<| c |>\nThis code does not work\
    \ when number is \"3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317596042568796713395158859835598220906978969552186511308100516216328217985044669058273468869397067982103421134387035840091715364367892590360011330530548820466521384146951941511609433057270365759591953092186117381932611793105118548074462379962749567351885752724891227938183011949129833673362440656643086021394946395224737190702179860943702770539217176293175960\"\
    \n<|/ c |>\n<| c |>\nit does for me. Are you sure that it's what you want? `2.to_s.to_i`\
    \ will fail with your input string. Also, it doesn't work with decimal numbers\
    \ like `3.14159265358979323846264338327950288419716939937510", "  number   = Float(number)\n\
    \  int_part = number/Integer(number)\n  dec_part = number.remainder(int_part)\n\
    \  if number.negative?\n    dec_part *= -1\n  end\n  dec_part\nend", "  decimal\
    \ = number - truncate(number)\n  integer =  truncate (number)\n  return integer\
    \ + decimal\nend", "  decimals = BigDecimal.new(number).scale # decimal part position\n\
    \  i = BigDecimal.new(number).to_i # integer part\n  \n  if i < 0\n    i = -i\
    \ + 1 # negative integer part\n  else\n    i = i + 1 # positive integer part\n\
    \  end\n  \n  if i < 0\n    # integer part and decimal part are equal\n    BigDecimal.new(number).truncate\n\
    \  else\n    # integer part is larger than decimal part\n    BigDecimal.new(number).truncate(decimals)\n\
    \  end\nend", "  return ((number % 1) * 10).floor\nend", "\treturn number - (number\
    \ * math.trunc(number))\nend", "  return number - truncate(number)\nend", "  number\
    \ = number.to_i\n  factor = BigDecimal.new(10).pow((number.to_s.size - 1)).to_i\n\
    \  decimal = number.to_f % factor\n  return number.to_f / factor + decimal\nend",
  "  floored = number.floor\n  decimal_part = number - floored\n  integer_part = floored\
    \ + [\n    truncate_number(decimal_part[/\\.\\./]),\n    truncate_number(decimal_part[1..-1]),\n\
    \  ]\n  integer_part || fail('number too small for decimal part')\n  decimal_part.to_i\n\
    end", "\treturn (number % 1) / 2\nend", "  return number - truncate_decimal(number)\n\
    end", "  digits = number.to_s.split(\".\")[0].to_i\n  decimals = number.to_s.split(\"\
    .\")[1]\n  return number == (digits|0) ? number : (number * decimals / digits)\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThank you, this is very helpful.\n\
    <|/ c |>\n<| c |>\nWhy you not use `BigDecimal` instead of `Fixnum` ?\n<|/ c |>\n\
    <| c |>\nThis doesn't seem to work when given \"0.56\" (or whatever the decimal\
    \ portion is called).\n<|/ c |>\n<| c |>\nYes, it works only for decimal fractions\
    \ with one decimal place. In the OP's question, \"0.56\" was given as an example,\
    \ so I assumed it was a decimal fraction.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ for all inputs. See my answer below for why.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  return number % 1\nend", "  decimal_part = number - BigDecimal(number).floor\n\
    \  truncate_decimal = decimal_part.to_f < 1.0\n  BigDecimal(number).truncate(decimal_part)\
    \ if truncate_decimal\nend", "  if number.is_a?(Numeric)\n    decimal_part = BigDecimal.new(number).scale\
    \ - BigDecimal.new(number).digits.length\n    BigDecimal.new(number).truncate\n\
    \  else\n    decimal_part = 0\n    BigDecimal.new(number).truncate(0)\n  end\n\
    end", "  number = Float(number).round(1e-2)\n  \n  num_parts = number.div(10).floor\n\
    \  decimal_parts = number.fmod((10 ** num_parts))", "  return number.floor/number.to_f\n\
    end", "  number.floor.to_f / (1 / BigDecimal.new(10).to_d)\nend", "  return round(number,\
    \ DIGITS)\nend", "  number_parts = number.to_s.split('.')\n  if number_parts.length\
    \ == 1\n    number\n  else\n    number_parts[0]\n  end\nend", "  return number.trunc\n\
    end", "  return floor(number), modulo(number, 1)\nend", "  int_part = floor(number)\n\
    \  decimals = number - int_part\n  int_part = 0 if int_part < 0 else int_part\n\
    \  return int_part + (decimals * POW10)\nend", "\treturn (number % 1) * pow(10,\
    \ floor(log10(number))-2)\nend", "  return ((number % 1) * 100).floor\nend", " \
    \ return number.truncate if BigDecimal.new(number).truncate.zero? else number\n\
    end\n</code>\n<|/ a tags=bigdecimal,ruby dscore=2 |>\n<| c |>\nThe question explicitly\
    \ specifies Ruby versions 2.6.3+ so `BigDecimal.new(number)` won't work.\n<|/\
    \ c |>\n<| c |>\nThanks, I've updated the answer.\n<|/ c |>\n<| a tags=bigdecimal,ruby\
    \ |>\nI thought about a similar problem and just came up with the following.\n\
    <code>", "  if number.is_a?(Integer)\n    number\n  elsif number.is_a?(Float)\n\
    \    number = number.trunc\n    number.is_a?(Float) ? number : number\n  else\n\
    \    number\n  end\nend", "  number = number.to_i\n  if number == 0\n    number\n\
    \  else\n    truncated = (number / 10.0)\n    number % 10\n  end\nend", "  number.to_s.split(\"\
    .\").map{|i| i.to_i}.max\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c\
    \ |>\nThis is really nice. Thank you. I had no idea about `to_f`. I learned something\
    \ today!\n<|/ c |>\n<| c |>\nThis is so cool, thank you!  I never thought to look\
    \ at it like that.  I never would have thought to look at a number as a string.\
    \ One thing though, I think it should be `to_f`, not `to_d`.\n<|/ c |>\n<| c |>\n\
    Thank you, you're right! I'm gonna update the answer right away.\n<|/ c |>\n<|\
    \ c |>\nIt was very helpful to me! I only used the truncate_number for decimal\
    \ values because I wanted the decimal value only to be two places.\n<|/ c |>\n\
    <| a dscore=4 |>\nIf you want to ensure the accuracy of float arithmetics, you\
    \ should use BigDecimal.\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis looks\
    \ interesting. I'm going to check this out. Thanks!\n<|/ c |>\n<| a dscore=4 |>\n\
    To ensure accuracy, use BigDecimal.  In Ruby 2.3, the standard library has a BigDecimal\
    \ class that is essentially an arbitrary-precision floating point.  In Ruby 2.4,\
    \ this class will be in the standard library, and will work identically to Float.\n\
    <code>\nrequire 'bigdecimal'\nBigDecimal.new(3.5)", "  rounded_number = Math.ceil(number)\n\
    \  decimals = number - rounded_number\n  decimals = decimals * 100\n  decimals\
    \ = Math.ceil(decimals)\n  return rounded_number, decimals\nend", "  number =\
    \ BigDecimal.new(number)\n  number.downto(1)\n  number.to_f\nend", "  if number\
    \ < 0\n    number = 0 - number\n    number = -0.00001 - number\n    number = -number\
    \ / 10\n    number = -number % 1\n  else\n    number = number / 10\n  end", " \
    \ decimals = number_to_rounded(number, -1)\n  decimals.zero? ? 0 : (decimals -\
    \ trunc(decimals))\nend", "  return \"%.1f\" % number\nend", "  number, decimals\
    \ = number.to_s.split('.')\n  decimals.delete('0')\n  decimals.inject(0) do |last_digit,\
    \ digit|\n    (last_digit * 10) + digit.to_i\n  end\nend", "  return number.round/(10**floor(log10(number)))\n\
    end\n</code>\nSo now, the following should work:\n<code>", "  if number.is_a?(Float)\n\
    \    decimals = truncate_decimals(number)\n    (integer, decimals) = number_to_rounded(decimals,\
    \ number)\n  else\n    decimals = truncate_decimals(BigDecimal(number).round)\n\
    \    integer = number\n  end", "  number = Float(number)\n  return number.floor\
    \ if number.round(-Float::INFINITY) == number else number.ceil\nend", "  decimal\
    \ = number.to_s.rindex(DECIMAL_DELIMITER, 2)\n  integer  = number.to_s.rindex(ZERO_DECIMAL_POSITION)\n\
    \  decimal = decimal + (1 if decimal > integer else 0)\n  return number.to_s.sub(DECIMAL_DELIMITER,\
    \ decimal.to_i)\nend", "  # Round it to reduce error\n  number = Math.round_number(number)\n\
    \  # Decompose into an integer and decimal part\n  integer_part, decimal_part\
    \ = Math.truncate_number(number)\n  # Return the decimal part\n  return decimal_part\n\
    end", "  return number.truncate(1).truncate(0)\nend", "  return math.floor(number)\
    \ if number < 0.0 else math.ceil(number)\nend", "  if number < 1\n    number\n\
    \  else\n    truncate(number, digits(number))\n  end\nend", "  pow10 = number.to_i\n\
    \  pow10 = 10 if pow10 < 10 else pow10\n  pow10 /= 10\n  pow10 -= 1 if pow10 >\
    \ 9 else 0\n  pow10 = 10**pow10\n  return number.to_f / pow10\nend", "  return\
    \ number-truncate(number)\nend", "  number.to_f % 1\nend", "  if number.is_a?\
    \ Fixnum\n    number, decimal_part = number.divmod(1)\n  else\n    decimal_part\
    \ = number\n    number = 0.0\n  end\n  return [number, decimal_part]\nend", " \
    \ # If the given number is zero or less then return zero.\n  return number <=\
    \ 0 ? 0 : 1", "  parts = [int(number)]\n  number *= 10", "  return ((number -\
    \ trunc(number)) * 100).floor.to_s + '%'\nend", '  number, integer_part, decimals
    = split_number(number)', "  return ((number % 1) * (1.0 / Math::Float(10 ** floor(log10(number))))).floor\n\
    end", "  return Math.trunc(number)\nend", "  return [truncate_decimal(number[0]),\
    \ number[1]]\nend", "  return number * (1 - 1.0 / 10 ** math.floor(math.log10(number)))\n\
    end", "  return truncate(number, 1)\nend\nRubyVM::InstructionSequence.send(:define_method,\
    \ :truncate_number, 0) do |number|\n  return truncate_number(number)\nend", " \
    \ return round(number, - number.floor)\nend", "  return Float(number).trunc\n\
    end", "  return round(number * 100)/100\nend", "  return Math.floor(number) if\
    \ number % 1 == 0 then number else number - 1\nend\n</pre>\n<p>\n  These functions\
    \ can handle both positive and negative numbers, and they\n  return the largest\
    \ and leftover parts separately. As long as you do not\n  care about the sign\
    \ you can safely pass any number to them.\n</p>\n<p>\n  You can also use them\
    \ together as in\n</p>\n<pre class=\"code\">", "  # Round down.\n  i = number.to_i\n\
    \  \n  while i >= 1\n    i /= 10\n  end\n  \n  # Round down.\n  i = number.to_i\n\
    \  \n  while i >= 1\n    i /= 10\n  end\n  \n  # Round down.\n  i = number.to_i\n\
    \  \n  # Round down.\n  i = number.to_i\n  \n  while i >= 1\n    i /= 10\n  end\n\
    \  \n  # Round up.\n  i = number.to_i\n  \n  while i >= 1\n    i *= 10\n  end\n\
    \  \n  return i\nend", "  parts = [0.0]\n  multiplier = 1.0\n  while number !=\
    \ 0\n    parts << number\n    number  = number / 10\n    multiplier = multiplier\
    \ * 10.0\n  end\n  parts << number\n  parts.inject(0.0) { |sum, part| sum + part\
    \  }\nend", "\tcase number\n\t\twhen 0\n\t\t\t0\n\t\twhen 1\n\t\t\t1\n\t\twhen\
    \ 2\n\t\t\t2\n\t\twhen 3\n\t\t\t3\n\t\twhen 4\n\t\t\t4\n\t\twhen 5\n\t\t\t5\n\t\
    \twhen 6\n\t\t\t6\n\t\twhen 7\n\t\t\t7\n\t\twhen 8\n\t\t\t8\n\t\twhen 9\n\t\t\t\
    9\n\t\twhen 10\n\t\t\t10\n\t\twhen 11\n\t\t\t11\n\t\twhen 12\n\t\t\t12\n\t\twhen\
    \ 13\n\t\t\t13\n\t\twhen 14\n\t\t\t14\n\t\twhen 15\n\t\t\t15\n\t\twhen 16\n\t\t\
    \t16\n\t\twhen 17\n\t\t\t17\n\t\twhen 18\n\t\t\t18\n\t\twhen 19\n\t\t\t19\n\t\t\
    when 20\n\t\t\t20\n\t\twhen 21\n\t\t\t21\n\t\twhen 22\n\t\t\t22\n\t\twhen 23\n\
    \t\t\t23\n\t\twhen 24\n\t\t\t24\n\t\twhen 25\n\t\t\t25\n\t\twhen 26\n\t\t\t26\n\
    \t\twhen 27\n\t\t\t27\n\t\twhen 28\n\t\t\t28\n\t\twhen 29\n\t\t\t29\n\t\twhen\
    \ 30\n\t\t\t30\n\t\twhen 31\n\t\t\t31\n\t\twhen 32\n\t\t\t32\n\t\twhen 33\n\t\t\
    \t33\n\t\twhen 34\n\t\t\t34\n\t\twhen 35\n\t\t\t35\n\t\twhen 36\n\t\t\t36\n\t\t\
    when 37\n\t\t\t37\n\t\twhen 38\n\t\t\t38\n\t\twhen 39\n\t\t\t39\n\t\twhen 40\n\
    \t\t\t40\n\t\twhen 41\n\t\t\t41\n\t\twhen 42\n\t\t\t42\n\t\twhen 43\n\t\t\t43\n\
    \t\twhen 44\n\t\t\t44\n\t\twhen 45\n\t\t\t45\n\t\twhen 46\n\t\t\t46\n\t\twhen\
    \ 47\n\t\t\t47\n\t\twhen 48\n\t\t\t48\n\t\twhen 49\n\t\t\t49\n\t\twhen 50\n\t\t\
    \t50\n\t\twhen 51\n\t\t\t51\n\t\twhen 52\n\t\t\t52\n\t\twhen 53\n\t\t\t53\n\t\t\
    when 54\n\t\t\t54\n\t\twhen 55\n\t\t\t55\n\t\twhen 56\n\t\t\t56\n\t\twhen 57\n\
    \t\t\t57\n\t\twhen 58\n\t\t\t58\n\t\twhen 59\n\t\t\t59\n\t\twhen 60\n\t\t\t60\n\
    \t\twhen 61\n\t\t\t61\n\t\twhen 62\n\t\t\t62\n\t\twhen 63\n\t\t\t63\n\t\twhen\
    \ 64\n\t\t\t64\n\t\twhen 65\n\t\t\t65\n\t\twhen 66\n\t\t\t66\n\t\twhen 67\n\t\t\
    \t67\n\t\twhen 68\n\t\t\t68\n\t\twhen 69\n\t\t\t69\n\t\twhen 70\n\t\t\t70\n\t\t\
    when 71\n\t\t\t71\n\t\twhen 72\n"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
