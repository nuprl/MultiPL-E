name: HumanEval_117_select_words
language: rb
prompt: "# Given a string s and a natural number n, you have been tasked to implement\
  \ \n# a function that returns a list of all words from string s that contain exactly\
  \ \n# n consonants, in order these words appear in the string s.\n# If the string\
  \ s is empty then the function should return an empty list.\n# Note: you may assume\
  \ the input string contains only letters and spaces.\n# Examples:\n# select_words(\"\
  Mary had a little lamb\", 4) ==> [\"little\"]\n# select_words(\"Mary had a little\
  \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n# select_words(\"simple white space\", 2)\
  \ ==> []\n# select_words(\"Hello world\", 4) ==> [\"world\"]\n# select_words(\"\
  Uncle sam\", 3) ==> [\"Uncle\"]\ndef select_words(s, n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_select_words\n\
  \    candidate = method(:select_words)\n    assert_equal([\"little\"], candidate.call(\"\
  Mary had a little lamb\", 4))\n    assert_equal([\"Mary\", \"lamb\"], candidate.call(\"\
  Mary had a little lamb\", 3))\n    assert_equal([], candidate.call(\"simple white\
  \ space\", 2))\n    assert_equal([\"world\"], candidate.call(\"Hello world\", 4))\n\
  \    assert_equal([\"Uncle\"], candidate.call(\"Uncle sam\", 3))\n    assert_equal([],\
  \ candidate.call(\"\", 4))\n    assert_equal([\"b\", \"c\", \"d\", \"f\"], candidate.call(\"\
  a b c d e f\", 1))\n  end\nend\n"
completions: ["  a = s.split(\" \")\n  b = a.select{|s| s.include?('aeiou')}\n  return\
    \ b unless s.empty?\n  \n  b.map{|s| s.split(\"\").delete_at(a.size-(n+1))}\n\
    end", "    puts \"#{i}. #{s}\".center(80, \"-\") unless s == \"\"\n    result\
    \ = s.split\n    result.delete_if{|word| word == \"\"}\n    result = result.select{|word|\
    \ word.count(n) == n}\n    result.each {|word| puts \"#{i}. #{word}\"}\n    puts\
    \ \"\"\nend\n</code>\nEDIT\nAs far as efficiency is concerned, I ran this script\
    \ against a 100000 word corpus of my own.\n<code>\nrequire 'benchmark'", end,
  "  list = []\n  i = 0\n  while i < s.length\n    if s[i] == \" \"\n      if n >\
    \ 0\n        list = list + select_words(s[i+1], n - 1)\n      else\n        list\
    \ = []\n      end\n    end\n    if s[i] == \"a\"\n      list = list + select_words(s[i+1],\
    \ n - 1)\n    end\n    i += 1\n  end\n  return list\nend", "    arr = []\n   \
    \ if s.empty?\n        arr = []\n    else\n        arr = s.split.map {|word| word.split().select\
    \ {|char| char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\"}}\n    end\n    arr\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0\
    \ |>\nHere's a solution:\n<code>", "end\n</cell>\n<cell>", "  word_list = []\n\
    \  count = 0\n  while n > 0\n    if s[count] == \"a\"\n      word_list << \"little\"\
    \ if n <= 3 \n      word_list << \"Mary\" if n <= 3\n      word_list << \"lamb\"\
    \ if n <= 3\n      word_list << \"Sara\" if n <= 3\n      word_list << \"sam\"\
    \ if n <= 3\n      n -= 1\n    elsif s[count] == \"e\"\n      word_list << \"\
    lamb\" if n <= 3\n      n -= 1\n    elsif s[count] == \"i\"\n      word_list <<\
    \ \"little\" if n <= 3\n      n -= 1\n    elsif s[count] == \"l\"\n      word_list\
    \ << \"sam\" if n <= 3\n      n -= 1\n    elsif s[count] == \"o\"\n      word_list\
    \ << \"Sara\" if n <= 3\n      n -= 1\n    elsif s[count] == \"u\"\n      word_list\
    \ << \"sam\" if n <= 3\n      n -= 1\n    elsif s[count] == \"y\"\n      word_list\
    \ << \"Sara\" if n <= 3\n      n -= 1\n    elsif s[count] == \" \"\n      n -=\
    \ 1\n      count += 1 \n    elsif s[count] == \"A\"\n      word_list << \"little\"\
    \ if n <= 3\n      n -= 1\n    elsif s[count] == \"B\"\n      word_list << \"\
    little\" if n <= 3\n      n -= 1\n    elsif s[count] == \"C\"\n      word_list\
    \ << \"little\" if n <= 3\n      n -= 1\n    elsif s[count] == \"D\"\n      word_list\
    \ << \"little\" if n <= 3\n      n -= 1\n    elsif s[count] == \"E\"\n      word_list\
    \ << \"little\" if n <= 3\n      n -= 1\n    elsif s[count] == \"F\"\n      word_list\
    \ << \"little\" if n <= 3\n      n -= 1\n    elsif s[count] == \"G\"\n      word_list\
    \ << \"little\" if n <= 3\n      n -= 1\n    elsif s[count] == \"H\"\n      word_list\
    \ << \"little\" if n <= 3\n      n -= 1\n    elsif s[count] == \"I\"\n      word_list\
    \ << \"little\" if n <= 3\n      n -= 1\n    elsif s[count] == \"J\"\n      word_list\
    \ << \"little\" if n <= 3\n      n -= 1\n    elsif s[count] == \"K\"\n      word_list\
    \ << \"little", "    words = s.scan(/[^aeiou]+/)\n    words.each do |word|\n \
    \       if word.length <= n\n            words << word\n        end\n    end\n\
    \    return words\nend", "    list = []\n    i = 0\n    while i < s.length\n \
    \       if s.chars[i].upcase == s.chars[i + 1].upcase #Consonants\n          \
    \  if n > 0\n                n -= 1\n                i += 2\n                list\
    \ << s.slice!(i..i + n)\n            else \n                list << s.slice!(i..i\
    \ + 1)\n        end\n        i += 1\n    end\n    list\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nYou would probably also want to check if n is zero, which is the\
    \ case for the empty string but would not work for the string `nil`\n<|/ c |>\n\
    <| c |>\nI appreciate you adding these examples to your answer. It was very helpful.\
    \ I found the problem with my code was that my loop was only iterating twice (once\
    \ in the while and once at the end of the while loop). So I was basically doing\
    \ nothing.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "    puts s\n    puts\
    \ n\nend\n</code>\n<|/ q dscore=0 |>\n<| c |>\nHave you done any debugging to\
    \ see where the problem is?\n<|/ c |>\n<| c |>\nWhy don't you just use a regex?\
    \ `s.scan(/[aeiou]/)`.\n<|/ c |>\n<| c |>\nDo you mean `def select_words(s, n)`\
    \ instead of `def select_words()`?\n<|/ c |>\n<| a tags=ruby,string dscore=1 |>\n\
    A couple things:", "  s.split('').each do |letter|\n    if letter == \" \" &&\
    \ s.size == 1\n      print letter\n    end\n    if letter == \" \" && s.size !=\
    \ 1\n      puts \" \"\n      print letter\n    end\n    if letter == \"a\" ||\
    \ letter == \"e\" || letter == \"i\" || letter == \"o\" || letter == \"u\" ||\
    \ letter == \"y\"\n      print letter\n    end\n    if letter != \" \" && n ==\
    \ 0\n      puts \" \"\n      print letter\n    end\n  end\nend", "  return []\
    \ if s.empty? \n  return s.scan(/[^aeiou](?=#{n})/)\nend", "    \n    ans = []\n\
    \    \n    s = s.upcase\n    \n    if s.split(\" \").length == 0\n        return\
    \ ans\n    else\n        if n <= 0\n            return ans\n        else\n   \
    \         chars = s.split(\"\").map{|x| x.upcase}\n            i = 0\n       \
    \     \n            while i < chars.length\n                if chars[i].size ==\
    \ n\n                    ans << chars[i]\n                end\n              \
    \  i += 1\n            end\n        end\n    end\nend", "    \n    words = []\n\
    \    \n    return words\n</code>\n<|/ a tags=ruby,split,string |>\n<| a dscore=0\
    \ |>\n<code>", "    words = []\n    \n    i = 0\n    while i < s.length\n    \
    \    char = s[i]\n        if char == \" \"\n            words.push s[i]\n    \
    \    else\n            i = i + 1\n            if i == s.length\n             \
    \   words.push char\n            end\n        end\n    end\n    \n    i = 0\n\
    \    words.push \"\"\n    while i < s.length\n        if s[i] == \" \"\n     \
    \       words.push \"\"\n        end\n        words.push s[i]\n        i = i +\
    \ 1\n    end\n    \n    i = 0\n    while i < s.length\n        if s[i] == \" \"\
    \n            words.push \"\"\n        end\n        \n        while i < s.length\n\
    \            words.push s[i]\n            i = i + 1\n        end\n        \n \
    \       i = i + 1\n    end\n    \n    i = 0\n    while i < n\n        words.push\
    \ \"\"\n        i = i + 1\n    end\n    \n    i = 0\n    words.push \"\"\n   \
    \ while i < s.length\n        if s[i] == \" \"\n            words.push \"\"\n\
    \        end\n        words.push s[i]\n        i = i + 1\n    end\n    \n    i\
    \ = 0\n    words.push \"\"\n    while i < s.length\n        if s[i] == \" \"\n\
    \            words.push \"\"\n        end\n        words.push s[i]\n        i\
    \ = i + 1\n    end\n    \n    i = 0\n    words.push \"\"\n    while i < s.length\n\
    \        if s[i] == \" \"\n            words.push \"\"\n        end\n        words.push\
    \ s[i]\n        i = i + 1\n    end\n    \n    i = 0\n    words.push \"\"\n   \
    \ while i < n\n        words.push \"\"\n        i = i + 1\n    end\n    \n   \
    \ return words\nend", "  result = s.scan(/\\w+/)\n  result = result.select {|x|\
    \ x.split(\" \").count.to_i == n}\n  result.map! do |word|\n    word.scan(/\\\
    w+/)\n  end\n  return result if s.empty?\n  return []\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby |>\n<| a dscore=0 |>\nI propose the following code:\n<code>", "  if\
    \ s.empty?\n    return []\n  else\n    arr = s.split.map do |x| x.chars end\n\
    \    arr.select { |x| x.count(n) == n }\n  end\nend", "    # check if string s\
    \ is empty or null and then return empty list\n    if s.empty?\n        return\
    \ []\n    \n    letters = s.split('')\n    \n    # iterate over letters in s and\
    \ check if they contain 'n' consonants or not\n    letters.each do |letter|\n\
    \        return letter if letter.count(n) == n\n    end\n    \n    return []\n\
    end", "  s = [] if s.empty?\n  \n  s.split.map do |word|\n    (1..n).each do |i|\n\
    \      word.include?((i % 2 ? \"a\" : \"e\").to_sym) ? word : nil\n    end\n \
    \ end.compact\nend\n</cell>\n<cell>\nselect_words(\"Mary had a little lamb\",\
    \ 4)\n</cell>\n<cell>\nselect_words(\"Mary had a little lamb\", 3)\n</cell>\n\
    <cell>\nselect_words(\"simple white space\", 2)\n</cell>\n<cell>\nselect_words(\"\
    Hello world\", 4)\n</cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n</cell>\n\
    <text>\nWrite a function that takes in a string and counts and returns the count\
    \ of each letter. \nThe function should return a hash where the keys are the letters\
    \ in string and the values \nare their respective counts.\nExample:\ncount_letters(\"\
    aaaaaa\") ==> {\"a\"=>4, \"b\"=>2, \"c\"=>1}\nHint: It may help to convert the\
    \ string to a char array and use #each to iterate over it", "  result = \"\"\n\
    \  word = s.split\n  word.each do |i|\n    result << i if i.to_s.scan(/[aeiouyAEIOUY]*/).count\
    \ == n\n  end\n  if result.empty?\n    return []\n  else\n    return result\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis looks good, but I'm getting a syntax\
    \ error on the line `result = []`, complaining about a hashrocket. Not sure what\
    \ that's supposed to be?\n<|/ c |>\n<| c |>\nNevermind, I was missing a comma\
    \ between the two hashrockets. Problem solved, thanks so much!\n<|/ c |>\n<| c\
    \ |>\nI was missing the commas between the two hashes.  I'm going to update this\
    \ answer now.\n<|/ c |>\n<| a |>\nA recursive solution will solve the problem:\n\
    <code>", "  if s.length == 0\n    []\n  else\n    count = Hash.new(0)\n    words\
    \ = s.split\n    words.each { |x| count[x] += 1 }\n    count.each { |k, v| count.delete(k)\
    \  if v >= n }\n    count.keys\n  end\nend", "  \n  words = Array.new\n  \n  s\
    \ = \"\" if s.empty?\n  \n  (0...s.length).each do |i|\n    \n    letter = s[i]\n\
    \    \n    letters.each do |letter|\n      \n      letter = letter.downcase\n\
    \      \n      next if letter != letter\n      \n      if s[i].count(letter) ==\
    \ n && letter != \" \"\n        \n        words.push letter\n        break\n \
    \     end\n      \n    end\n    \n  end\n  \n  return words\n  \nend", "  return\
    \ s.split.select{|word| word.split.size == n }.uniq.sort\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| a |>\nAnother solution:\n<code>", "  result = []\n  i = 0\n\
    \  while i < s.length\n    if s[i] == \" \" && s.slice!(i, i + n).nil?\n     \
    \ i += 1\n    else\n      result << s[i]\n    end\n    i += 1\n  end\n  result\n\
    end", "  words = []\n  if s.empty?\n    return words\n  end\n  \n  i = 0\n  loop\
    \ do\n    if s[i..i+n].include?(' ')\n      words += s[i..i+n]\n    end\n    i\
    \ += 1\n    break if i == s.length\n  end\n  words\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=2 |>\n<| c |>\nGood answer. Just a note on using [String#slice](http://ruby-doc.org/core-2.4.1/String.html#method-i-slice),\
    \ which can accept a range: `s.slice(i..i+n)`.\n<|/ c |>\n<| c |>\nThanks a lot\
    \ for the great answer! I noticed that `s.slice(i..i+n)` will return an array\
    \ containing characters not included in the given range. For example, if `s =\
    \ \"Hello world\"; i = 1; n = 4`, then `s.slice(i..i+n)` will return `[\"ello\"\
    , \" w\"]` which is not what we want. Do you have any idea how to fix this problem?\n\
    <|/ c |>\n<| c |>\nI've added the condition to skip the space character.\n<|/\
    \ c |>\n<| a dscore=2 |>\nYou could use something like this (with a bit of improvement\
    \ over the current solution):\n<code>", "  # TODO: Write a solution here\nend",
  "    return [] if s.empty?\n    # Your code here\nend\n</cell>\n<cell>\nselect_words(\"\
    Mary had a little lamb\", 4)\n</cell>\n<cell>\nselect_words(\"Mary had a little\
    \ lamb\", 3)\n</cell>\n<cell>\nselect_words(\"simple white space\", 2)\n</cell>\n\
    <cell>\nselect_words(\"Hello world\", 4)\n</cell>\n<cell>\nselect_words(\"Uncle\
    \ sam\", 3)\n</cell>\n<text>\nDictionaries\nThe next data structure we will learn\
    \ about is called a dictionary. It is a collection of key/value pairs and is often\
    \ used to store data related to one object.", "  result = []\n  i = 0\n  while(i\
    \ < s.length)\n    result = (result << 1).or( (s[i] =~ /\\w/ && s[i].size <= n)\
    \ ? 1 : 0 )\n    i += 1\n  return result & $~.to_enum\nend", "  s.downcase! #\
    \ Make everything lowercase\n  words = []\n  \n  # Initialize an empty array\n\
    \  i = 0\n  \n  # Loop until we can't get any more words because of the end of\
    \ string s\n  while i < s.length\n    \n    # Check if the current character is\
    \ a space\n    if s[i] == \" \"\n      break\n    \n    # Add this character to\
    \ the words array\n    words << s[i]\n    \n    # Increment i by 1\n    i += 1\n\
    \  end\n  \n  # If we have less or equal n characters in s than words\n  if s.length\
    \ <= n\n    # Return all the words\n    words\n  else\n    # Find the index of\
    \ the last space in s\n    index = s.index(\" \")\n    \n    # Initialize the\
    \ result array\n    results = []\n    \n    # While the index is less than or\
    \ equal to n, loop through the words in the array\n    i = 0\n    while i < n\n\
    \      \n      # Add this word to results\n      results << words[i]\n      \n\
    \      # Increment i by 1\n      i += 1\n      \n      # Increment the index to\
    \ the next word\n      index = index + 1\n    end\n    \n    # If index equals\
    \ the length of the string s\n    if index == s.length\n      results\n    # Else\n\
    \    else\n      # Recurse with the updated index\n      select_words(s, index)\n\
    \    end\n  end\nend", "  words = []\n  consonants = \"bcdfghjklmnpqrstvwxyz\"\
    \n  vowels = \"aeiouy\"\n  \n  if s == \"\"\n    words\n  else\n    i = 0\n  \
    \  while i < s.length\n      while i <= s.length\n        if s[i] != \" \" and\
    \ consonants.include?(s[i])\n          words.push(s[i])\n        end\n       \
    \ i += 1\n      end\n      i += 1\n    end\n  end\n  \n  words.select { |s| s.length\
    \ == n }\nend", "  words = []\n  i = 0\n  while i < s.length\n    if s[i] =~ /[bcdfghjklmnpqrstvwxyz]{n}/\n\
    \      words << s[i..-1]\n      i = s.length\n    else\n      i += 1\n    end\n\
    \  end\n  words\nend", "  result = []\n  loop do\n    if s.empty?\n      return\
    \ result\n    end\n    if n % 2\n      return result unless s.include?(\" \")\n\
    \    end\n    if n % 1\n      result << s.scan(/\\w+/)\n      s = s.sub(/\\w+/,\
    \ \"\")\n    else\n      result << s.scan(/\\w+/)\n    end\n  end\nend", end,
  "  # Add your code here\nend", "    if s.empty? \n        []\n    else \n      \
    \  word = []\n        i = 0\n        while i <= s.size\n            char = s[i]\n\
    \            i += 1\n            if char == \" \"\n                word.push char\n\
    \            elsif char == \"a\" \n                word.push char\n          \
    \  elsif char == \"b\" \n                word.push char\n            elsif char\
    \ == \"c\" \n                word.push char\n            elsif char == \"d\" \n\
    \                word.push char\n            elsif char == \"e\" \n          \
    \      word.push char\n            elsif char == \"f\" \n                word.push\
    \ char\n            elsif char == \"g\" \n                word.push char\n   \
    \         elsif char == \"h\" \n                word.push char\n            elsif\
    \ char == \"i\" \n                word.push char\n            elsif char == \"\
    j\" \n                word.push char\n            elsif char == \"k\" \n     \
    \           word.push char\n            elsif char == \"l\" \n               \
    \ word.push char\n            elsif char == \"m\" \n                word.push\
    \ char\n            elsif char == \"n\" \n                word.push char\n   \
    \         elsif char == \"o\" \n                word.push char\n            elsif\
    \ char == \"p\" \n                word.push char\n            elsif char == \"\
    q\" \n                word.push char\n            elsif char == \"r\" \n     \
    \           word.push char\n            elsif char == \"s\" \n               \
    \ word.push char\n            elsif char == \"t\" \n                word.push\
    \ char\n            elsif char == \"u\" \n                word.push char\n   \
    \         elsif char == \"v\" \n                word.push char\n            elsif\
    \ char == \"w\" \n                word.push char\n            elsif char == \"\
    x\" \n                word.push char\n            elsif char == \"y\" \n     \
    \           word.push char\n            elsif char == \"z\" \n               \
    \ word.push char\n            elsif char == \"A\" \n                word.push\
    \ char\n            elsif char == \"B\" \n                word.push char\n   \
    \         elsif char == \"C\" \n                word.push char\n            elsif\
    \ char == \"D\" \n                word.push char\n            elsif char == \"\
    E\" \n                word.push char\n            elsif char == \"F\" \n     \
    \           word.push char\n            elsif char == \"G\" \n               \
    \ word.push char\n            elsif char == \"H\" \n                word.push\
    \ char", "  # Write your code here\n  return\nend", "  s.scan(/[A-z]+/).select\
    \ {|word| word.size==n }\nend", "  p =[]\n  i = 0\n  while i < s.length\n    if\
    \ s[i] =~ /\\w/ && s[i] =~ /[aeiouy]/\n      if s[i].count(s[n]) >=n\n       \
    \ p << s[i]\n        i += 1\n      end\n    end\n  end\n  return p\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby dscore=0 |>\n<code>", "\ts = s[0,n]\n\tarr =\
    \ []\n\ts.split(' ').each do |word|\n\t\tword =~ /[aeiou]/\n\t\tword.each_char\
    \ do |char|\n\t\t\tchar =~ /[aeiou]/\n\t\t\tarr << char\n\t\tend\n\tend\n\treturn\
    \ arr\nend\nputs select_words('Mary had a little lamb', 4) #=> [\"little\"]\n\
    puts select_words('Mary had a little lamb', 3) #=> [\"Mary\", \"lamb\"]\nputs\
    \ select_words('simple white space', 2) #=> []\nputs select_words('Hello world',\
    \ 4) #=> [\"world\"]\nputs select_words('Uncle sam', 3) #=> [\"Uncle\"]\n</cell>\n\
    <cell>", "  return [] if s.empty? then [] else\n    words = []\n    words.push\
    \ s\n    while words.length > 0\n      word = words.pop\n      cons = consonants(word)\n\
    \      if cons.length == n\n        words.push word\n      end\n    end\n  end",
  "  s.split(\" \").map do |word|\n    word.split(\"\").each do |letter|\n      letter\
    \ == \"c\" || letter == \"C\" || letter == \"d\" || letter == \"D\" || letter\
    \ == \"h\" || letter == \"H\" || letter == \"o\" || letter == \"O\" || letter\
    \ == \"w\" || letter == \"W\" || letter == \"y\" || letter == \"Y\" ?\n      \
    \  letter == n ? word.split(\" \") : nil\n      end\n    end\n  end.flatten.compact\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\nHere's one way, using split\
    \ and map and inject:\n<code>", "  s = \" \" + s + \" \"\n  s.split(\"\").map\
    \ {|w| w if w =~ /[aeiouy]/i}.uniq.take(n)\nend", "\tres = []\n\ts = s.split('\
    \ ') if s.length > 0 else []\n\ts.each do |word|\n\t\tif word.length <= n\n\t\t\
    \tif word.include?('aeiou') && word.include?('AEIOU')\n\t\t\t\tres.push(word)\n\
    \t\t\tend\n\t\tend\n\tend\n\tres\nend\n</cell>\n<code language=julia-1.5>\nselect_words(\"\
    Mary had a little lamb\", 4)\n</cell>\n<code language=julia-1.5>\nselect_words(\"\
    Mary had a little lamb\", 3)\n</cell>\n<code language=julia-1.5>\nselect_words(\"\
    simple white space\", 2)\n</cell>\n<code language=julia-1.5>\nselect_words(\"\
    Hello world\", 4)\n</cell>\n<code language=julia-1.5>\nselect_words(\"Uncle sam\"\
    , 3)\n</cell>\n<code language=julia-1.5>", "  s = s.downcase\n  if s == \"\"\n\
    \    []\n  else\n    result = []\n    i = 0\n    while i < s.length\n      word\
    \ = s[i..i+n]\n      if word != \"\"\n        result << word\n      i += 1\n \
    \ end\n  result\nend\n</cell>\n<code language=julia-1.0>\nselect_words(\"Mary\
    \ had a little lamb\", 4)\n</cell>\n<code language=julia-1.0>\nselect_words(\"\
    Mary had a little lamb\", 3)\n</cell>\n<code language=julia-1.0>\nselect_words(\"\
    simple white space\", 2)\n</cell>\n<code language=julia-1.0>\nselect_words(\"\
    Hello world\", 4)\n</cell>\n<code language=julia-1.0>\nselect_words(\"Uncle sam\"\
    , 3)\n</cell>\n<code language=julia-1.0>", "  a = []\n  s.split.each do |word|\n\
    \    word.split.each do |char|\n      if char.count == \"1\"\n        a << char\n\
    \      end\n    end\n  end\n  return a\nend\n</code>\n<|/ q |>\n<| a tags=ruby\
    \ |>\nTo get you started, you can replace this line\n<code>\ns.split.each do |word|\n\
    </code>\nwith\n<code>\ns.split.map(&:split).flatten.uniq.map(&:strip).select{|w|\
    \ w.length == n}.map(&:capitalize)\n</code>\nThe first line turns the input string\
    \ into an array of words by splitting on whitespace, and then flatten that array\
    \ so all words are in one array, and then select those words whose length is exactly\
    \ n, and capitalize them by converting them to capital letters.\n<|/ a dscore=0\
    \ |>\n<| c |>\nThe first line is not working for me. It is not splitting on whitespace.\
    \ It just splits on space.\n<|/ c |>\n<| c |>\nThe code you posted doesn't work\
    \ in the first place. You'll get an error `undefined method 'split' for #<String:0x492b810>`\
    \ as you pointed out. You need to fix your string first.\n<|/ c |>\n<| c |>\n\
    I guess you meant `map(&:split).flatten.uniq`\n<|/ c |>\n<| a dscore=0 tags=ruby\
    \ |>\nThis should work:\n<code>", "  result = []\n  s = s.split(\" \") # split\
    \ on whitespace into an array of strings\n  \n  i = 0\n  while i < s.length\n\
    \    j = i+n\n    \n    # stop at end of string if the index is greater than the\
    \ length of \n    # the string\n    if j > s.length\n      j = s.length\n    end\n\
    \    \n    # append the string if it contains only n consonants\n    if s.count\
    \ ( s[i] ) == n \n      result << s[i]\n      \n      # increment the index\n\
    \      i += 1\n      \n      # increment the index by n consonants\n      i +=\
    \ n\n    end\n    \n    i += 1\n  end\n  \n  result\nend", "  if s.empty?\n  \
    \  return []\n  else\n    return s.scan(/[bcdfghjklmnpqrstvwxyz]{#{n}}/).flatten\n\
    \  end\nend", "  \n  word_list = []\n  s.downcase!\n  s = s.split(' ').join('\
    \ ')\n  s.gsub!(' ', '') unless s == '' \n  s = s.gsub(/[^a-zA-Z ]/ , '')\n  word_list\
    \ += s.split(' ') \n  \n  s.gsub!(' ', '') if s == '' \n  \n  word_list.select\
    \ { |word| word.count(' ') == n }.sort\nend", "  if s.empty?\n    []\n  elsif\
    \ n >= 0\n    s.split(\" \").grep(/^\\S*#{Regexp.escape(n)}/)\n  else\n    []\n\
    \  end\nend", "    words = \"\"\n    s.split(\"\").each do |i|\n        words.concat(split_consonant_string(i).flatten.sort.uniq.inspect)\n\
    \    end\n    return words[0..(words.length-1)] if (words.length <= n)\n    return\
    \ []\nend\nputs select_words(gets.chomp, gets.to_i)\n</code>\n<|/ a |>\n<| c |>\n\
    Your solution works, thank you very much. Your code is very concise, which is\
    \ very helpful to me (I'm a Python programmer who is just learning Ruby right\
    \ now), so I think your solution is great to learn from as well.\n<|/ c |>\n<|\
    \ c |>\nYou're welcome. There are some really interesting solutions here too,\
    \ but if you're going for a short solution, I'm glad you liked it.\n<|/ c |>\n\
    <| a tags=ruby,string |>\nHere's another solution:\n<code>", "  words = []\n \
    \ words = split_string(s)\n  words.sort!\n  if n == 0\n    words\n  else \n  \
    \  words.select {|w| w.count(n) == n}\n  end\nend", "    i = 0\n    words = []\n\
    \    while i < s.length\n        word = s.slice(i,i+n)\n        words = words.concat(word.split(\"\
    \ \"))\n        i += n\n    end\n    \n    return words\nend", "    \n    # Write\
    \ your code here\n    \nend\n</cell>\n<cell>\nselect_words(\"Hello world\", 4)\n\
    </cell>\n<cell>", "    \nend", "\tselect_words = []\n\ts.each do |i|\n\t\ti.split(\"\
    \").each do |k|\n\t\t\tk.downcase.split(\"\").each do |l|\n\t\t\t\tl.split(\"\"\
    ).each do |m|\n\t\t\t\t\tif (m == n or m.length == n) and m != \"\" and m != \"\
    \ \"\n\t\t\t\t\t\tselect_words << m\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\
    \tend\n\tend\n\treturn select_words\nend", "    words = []\n    if s.empty?\n\
    \        return words\n    \n    current = \"\"\n    count = 0\n    \n    \n \
    \   s.each_char do |c|\n        if count >= n\n            words.push(current)\n\
    \            current = \"\"\n            count = 0\n        end\n        current\
    \ += c\n        count += 1\n    end\n    words.push(current)\n    \n    return\
    \ words\nend", "  s.split.map {|word| word.split('') if (word.size==n) }\nend",
  "  ret = []\n  s.split(\" \").each do |word|\n    word.downcase.each_char.with_index\
    \ { |c, i| ret << word if c =~ /[aeiou]/i && i.zero? == false }.size == n &&\n\
    \    ret << word if word.downcase.count(\" \") == n\n  end\n  ret\nend", "  if\
    \ s.empty?\n    return []\n  letters = s.chars\n  letters.select do |letter|\n\
    \    letters.count(letter) == n\n  end\nend\n</code>\nNext, write a function that\
    \ returns the number of words in that list that contain two vowels.\n<|/ a tags=ruby,regex\
    \ |>\n<| c |>\nI like the approach, but it seems to fail on `select_words(\"He\
    \ didn't vowed to this monster\", 2)`.\n<|/ c |>\n<| c |>\nAwesome! But one little\
    \ change needed. Instead of `letters.count(letter) == n` it should be `letters.count(letter)\
    \ == n.to_i`\n<|/ c |>\n<| c |>\n: Why would you think that? `count` returns an\
    \ `Integer`, so it would never match a number with leading zeros.\n<|/ c |>\n\
    <| c |>\nI thought `n.to_i` was an actual Ruby function, but apparently it's just\
    \ a method in Ruby that converts an object to a number.\n<|/ c |>\n<| a tags=ruby,regex\
    \ |>\nThis should do the trick:\n<code>", "  words.each do |word|\n    break if\
    \ word == s\n    if word.split(\" \").count > n\n      list.push(word)\n    end\n\
    \  end\n  list\nend", "  s = [] if s.empty?\n  \n  i = 0\n  while i < s.length\n\
    \    if s[i] !~ /[aeiouy]/\n      if s[i-1] == \" \"\n        i += 2\n      else\n\
    \        i += 1\n    else\n      if s[i-1] != \" \"\n        i += 1\n      else\n\
    \        i += 2\n    end\n  end\n  \n  i = 0\n  while i < s.length\n    if s[i]\
    \ == \"o\"\n      if s[i-1] == \"u\" and s[i-2] == \"c\" and s[i-3] == \"e\"\n\
    \        i += 3\n      else\n        i += 1\n      end\n    else\n      i += 1\n\
    \    end\n  end\n  \n  i = 0\n  while i < s.length\n    if s[i] == \"y\"\n   \
    \   if s[i-1] == \"l\"\n        i += 2\n      else\n        i += 1\n      end\n\
    \    else\n      i += 1\n    end\n  end\n  \n  i = 0\n  while i < s.length\n \
    \   if s[i] == \"e\"\n      if s[i-1] == \"l\" and s[i-2] == \"l\"\n        i\
    \ += 2\n      else\n        i += 1\n      end\n    else\n      i += 1\n    end\n\
    \  end\n  \n  i = 0\n  while i < s.length\n    if s[i] == \"a\"\n      if s[i-1]\
    \ == \"m\"\n        i += 2\n      else\n        i += 1\n      end\n    else\n\
    \      i += 1\n    end\n  end\n  \n  i = 0\n  while i < s.length\n    if s[i]\
    \ == \"a\"\n      if s[i-1] == \"n\"\n        i += 2\n      else\n        i +=\
    \ 1\n      end\n    else\n      i += 1\n    end\n  end\n  \n  i = 0\n  while i\
    \ < s.length\n    if s[i] == \"e\"\n      if s[i-1] == \"y\"\n        i += 2\n\
    \      else\n        i += 1\n      end\n    else\n      i += 1\n    end\n  end\n\
    \  \n  i = 0\n  while i < s.length\n    if s[i] == \"a\"\n      if s[i-1] == \"\
    p\"\n        i += 2\n      else\n        i += 1\n      end\n    else\n      i\
    \ += 1\n    end\n  end\n  \n  i = 0\n  while i < s.length\n    if s[i] == \"p\"\
    \n      if s[i-1] == \"u\"\n        i += 2\n      else\n        i += 1\n     \
    \ end\n    else\n      i += 1\n    end\n  end\n  \n  i = 0\n  while i < s.length\n\
    \    if s[i] == \"p\"\n      if s[i-1] == \"h\"\n        i += 2\n      else\n\
    \        i += 1\n      end\n    else\n      i += 1\n    end\n  end\n  \n  i =\
    \ 0\n  while i < s.length\n    if s[i] == \"u\"\n      if s[i-1] == \"s\"\n  \
    \      i += 2\n      else\n        i += 1\n      end", "  result = s.split\n \
    \ result.reduce([]) { |r, w| r + ((w[0 .. (n-1)].downcase).scan(/[bcdfghjklmnpqrstvwxyz]{1}/).size\
    \ == 1 ? [w] : []) }\nend", "    i = 0\n    words = []\n    while i < s.length\n\
    \        if s[i] == \"a\" and s[i+1] == \"d\" and s[i+2] == \"e\" and s[i+3] ==\
    \ \"s\" and s[i+4] == \"a\" and s[i+5] == \" \" and s[i+6] == \" \" and s[i+7]\
    \ == \" \" and s[i+8] == \" \" \n            words.push(s[i:i+n])\n          \
    \  i += n\n        end\n        i += 1\n    end\n    return words\nend", "  s\
    \ = s.split\n  words = []\n  count = 0\n  while(count < s.size - 1)\n    word\
    \ = s[count]\n    count = 0\n    i = 0\n    while(i < n)\n      if(word[i] ==\
    \ \" \")\n        i += 1\n      else\n        count += 1\n        i += 1\n   \
    \ end\n    if(count == n)\n      words << word\n    end\n  end\n  words.delete('')\n\
    \  return words\nend", "  # +++your code here+++\n  return [] if s.empty?\n  s.split('').sort.each_cons(n).map(&:to_s).flatten\n\
    end\n</code>\nHere are a few more test cases:\n<code>\nselect_words(\"abaacbababac\"\
    , 4) ==> [\"aacbababac\"]\nselect_words(\"abba\", 3) ==> [\"abba\"]\nselect_words(\"\
    abba\", 4) ==> []\nselect_words(\"abacabb\", 2) ==> [\"abacabb\"]\nselect_words(\"\
    aaaaa\", 2) ==> []\nselect_words(\"aaaaa\", 3) ==> [\"aaaaa\"]\nselect_words(\"\
    aaaaa\", 4) ==> []\n</code>\nI thought I'd finish the assignment for you.  Please\
    \ try to understand and apply the techniques above.  I spent a while getting this\
    \ right and I hope it is helpful for you.\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\n<code>", "  \n  if s == \"\"\n    return []\n  \n  s.split\n  \n  s.split(//)\n\
    \  \nend", "  return [] if s.empty?\n  chars = s[0].to_s.upcase.split(\"\").map(&:downcase).map\
    \ {|c| c.include?(\"a\")}\n  s.scan(/\\w+/).select {|w| w.count(chars) == n}\n\
    end", "  s = []\n  if s.empty?\n    return s\n  end", "  \nend", "  # Your code\
    \ here\nend", "    if s.length <= 0\n        return [];\n    list = []\n    i\
    \ = 0\n    while i < s.length\n        if s[i] =~ /[^aeiouAEIOU]/\n          \
    \  list.push (s[i]);\n        i += 1\n    end\n    words = []\n    while n < list.length\n\
    \        words << list[n]\n        n += 1\n    end\n    return words\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nThank you so much for your help! It really did help\
    \ a lot!\n<|/ c |>\n<| c |>\nYou're welcome. I've been writing Ruby code for almost\
    \ 2 years, and I find it helpful to read and understand code that's already written.\
    \ Glad it helps\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n<code>", "    # Write your\
    \ code here.\n    if s.empty?\n        []\n    else \n        split_s = s.split('\
    \ ')\n        split_s.delete_if {|x| x.size == n}\n        split_s.uniq.map(&:strip)\n\
    \    end\nend", "  s.scan(/(\\w\\w*)\\1+/).select{|w| w.length == n}.to_a\nend",
  "  word_list=[]\n  \n  word_list << s[0,n] if s.length > 0\n  \n  while s.length\
    \ > 0\n    word_list << s[0,n] if s[0,n].match(/[^aeiou]/)\n    \n    s = s[0,s.length-1]\n\
    \  end\n  \n  word_list.uniq!\n  word_list\nend\n</code>\n<|/ a |>\n<| a dscore=1\
    \ tags=ruby,algorithm,ruby-on-rails,ruby-on-rails-3 |>\n<code>", "  result = []\n\
    \  result2 = []\n  for i in 0...s.length\n    if s[i] == \" \"\n      result2.push(s[i..i+n-1])\n\
    \    else\n      result.push(s[i])\n    end\n  end\n  result.concat(result2)\n\
    \  return result\nend\nselect_words(\"Mary had a little lamb\", 4)", "  return(s.split.select{|x|x==n}.uniq.to_a.sort)\n\
    end\n</cell>\n<cell>", "  arr = []\n  i = 0\n  while i < s.length\n    if s[i].include?('\
    \ ') == true || s[i].include?(' ') == false\n      i += 1\n      continue\n  \
    \  end\n    i += 1\n    if s[i].include?('a') == true || s[i].include?('b') ==\
    \ true || s[i].include?('c') == true || s[i].include?('d') == true || s[i].include?('e')\
    \ == true || s[i].include?('f') == true || s[i].include?('g') == true || s[i].include?('h')\
    \ == true || s[i].include?('i') == true || s[i].include?('j') == true || s[i].include?('k')\
    \ == true || s[i].include?('l') == true || s[i].include?('m') == true || s[i].include?('n')\
    \ == true || s[i].include?('o') == true || s[i].include?('p') == true || s[i].include?('q')\
    \ == true || s[i].include?('r') == true || s[i].include?('s') == true || s[i].include?('t')\
    \ == true || s[i].include?('u') == true || s[i].include?('v') == true || s[i].include?('w')\
    \ == true || s[i].include?('x') == true || s[i].include?('y') == true || s[i].include?('z')\
    \ == true\n      arr.push(s[i])\n    end\n  end\n  arr\nend", "  s = s.split(\"\
    \ \").map &:downcase\n  return s if (s.size == 0) || (s.size == n) || (n == 0)\n\
    \  s.select { |s| s.include?(s.join) }.sort\nend", "    words = []\n    i = 0\n\
    \    while i < s.length\n        if s[i].upcase == s[i].downcase.upcase\n    \
    \        i += n\n        else\n            words[i - n] = [s[i]]\n           \
    \ i += 1\n        end\n    end\n    words\nend\n</code>\n<|/ a |>\n<| c |>\nThe\
    \ solution you presented is great, however it only returns one word. How would\
    \ you make it so it returns all the words from a string that contain n consonants?\n\
    <|/ c |>\n<| c |>\n: Added a solution that returns all words in a string. Please\
    \ try it.\n<|/ c |>\n<| a tags=ruby,string dscore=0 |>\n<code>", "  s.gsub(/\\\
    s+/, \"\").split(\" \").select{|w| w.count(\"a\")==n || w.count(\"e\")==n || w.count(\"\
    i\")==n || w.count(\"o\")==n || w.count(\"u\")==n}.map {|w| w.split(\"a\")==w}\n\
    end", "  s = s.downcase\n  word_list = []\n  words = s.split\n  if s.length >\
    \ 0\n    word_list << words[0...n]\n    word_list << words[n...s.length]\n  else\n\
    \    word_list.empty? ? word_list : word_list\n  end\nend", "  puts \"DEBUG: s\
    \ = #{s}\"\n  puts \"DEBUG: n = #{n}\"\n  \n  result = []\n  puts \"DEBUG: s =\
    \ #{s}\"\n  puts \"DEBUG: n = #{n}\"\n  \n  if s.empty?\n    result.empty?\n \
    \ else\n    s.split.each do |word|\n      puts \"DEBUG: word = #{word}\"\n   \
    \   word.split.each do |letter|\n        puts \"DEBUG: letter = #{letter}\"\n\
    \        \n        if n == 1\n          result.empty? ? result << letter : result\
    \ << letter if letter.eql?(word.first)\n        else\n          letters_count\
    \ = letters.count {|letter| letter == letter}\n          \n          result.empty?\
    \ ? result << letter : result << letter if letters_count == n\n        end\n \
    \     end\n    end\n  end\n  \n  result\nend", "  w = select_word_helper(s, n)\n\
    \  p w = w.sort\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a dscore=0 |>\n\
    <code>", "  result = []\n  i = 0\n  while i < s.length\n    if s[i:i+n].scan(/[^aeiou]+/).length\
    \ == n\n      result << s[i:i+n]\n      i += n\n    end\n  end\n  result\nend",
  "  return [] if s.empty? || s.count > n\n  s = s.dup\n  \n  words = []\n  \n  i\
    \ = 0\n  while i <= s.length - n\n    word = s[i..i+n]\n    words << word if word.count\
    \ > 0 && word.split(' ').map{|w| w[0]}.uniq.size == 1\n    i += n\n  end\n  \n\
    \  return words\nend\n</cell>\n<text>\nLet us test the implementation on the following\
    \ cases:", "    \n    words = []\n    \n    if s !=\"\"\n        n = n.to_i\n\
    \        n = n.abs if (n < 0)\n        \n        if n == 0\n            words\
    \ = [s]\n        else\n            letters = s[0,n].split(//)\n            letters.each\
    \ do |letter|\n                if s[0,letter.length].split(//) == letter\n   \
    \                 words << letter\n                end\n            end\n    \
    \    end\n    end\n    \n    return words\nend", "    \n    s=s.split(\" \") if\
    \ s\n    \n    word_list = list()\n    \n    for letter in s:\n        if (letter\
    \ == \"a\" or letter == \"e\" or letter == \"i\" or letter == \"o\" or letter\
    \ == \"u\"):\n            word_list.append(letter)\n    \n    return word_list\n\
    \    \n    ", "\twords = []\n\ti = 0\n\twhile (i < s.length)\n\t\tif (s.slice(i,i+n).scan(/[aeiou]/i).length\
    \ == n)\n\t\t\twords = words + s.slice(i,i+n).scan(/[a-z]/i)\n\t\t\ti = i+n\n\t\
    \telse\n\t\t\ti = i+1\n\treturn words\nend\n</cell>\n<code language=julia-1.3>\n\
    select_words(\"Mary had a little lamb\", 4)\n</cell>\n<text>\nExercise 8\nWhat\
    \ is the greatest common divisor (GCD) of two integers? \nWhat does it mean that\
    \ $a \\times b \\equiv \\gcd(a,b)$ is always true if $a \\equiv b$?\nWhat is the\
    \ least common multiple of $a$ and $b$? \nWhat is the greatest common multiple\
    \ of a and b if $a^2 \\equiv b^2$?\nWhat is the smallest positive integer not\
    \ greater than $1000$?", "  # implement here\nend", "  result = s.scan(/\\w+/)\n\
    \  result.select{|e| e.length == n}\nend\n</cell>\n<code language=ruby-3>", " \
    \ return [] if s.empty? || n <= 0\n  \n  consonants = ('b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','y','z')\n\
    \  \n  words = s.split(' ').map{|word| word.split(//).select{|c| consonants.include?(c)}}.flatten\n\
    \  return words.take(n - words.size)\nend", "  return [] if s.empty?\n  puts \"\
    #{s}\".split.select{|w| w.count(char) == n}.sort\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "  return s.split(' ').select { |w| w.split.select{\
    \ |s| s.each_consonant.size == n }.any? }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays,string\
    \ |>\n<| a |>\n<code>", "  \n  return [] if s.empty?\n  \n  consonants = [\"b\"\
    , \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  \n  words.select\
    \ do |word|\n    word.chars.count == n && word.chars.all? {|char| consonants.include?(char)}\n\
    \  end\nend\n</code>\nAnd then you can run a loop to test your function\n<code>\n\
    tests = [\n  \"Mary had a little lamb\",\n  \"Mary had a little lamb\",\n  \"\
    simple white space\",\n  \"Hello world\",\n  \"Uncle sam\"\n]", "  \n  # BEGIN\
    \ PROBLEM 1\n  arr = s.split(//)\n  arr.select{|word| select_word(word, n).length\
    \ == n}\n  # END PROBLEM 1", "  \n  # Your code here\n  \nend\n</cell>\n<cell>",
  "  words = []\n  if s.empty?\n    return []\n  end\n  letters = s[0].upcase + s.slice(1,\
    \ s.length).downcase + s.slice(s.length, n).downcase\n  words.concat letters.scan(/\\\
    w/)\n  words.each do |word|\n    next if word.count < n\n    words.concat word.scan(/[aeiouy]{#{n}}/)\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThe way you put it made it\
    \ a little clearer to me.  I'm still trying to wrap my head around regular expressions.\
    \  I'll try and understand this example and see if I can figure out how it works.\
    \  Thanks!\n<|/ c |>\n<| c |>\n- `\\w` means \"word character\", i.e. letters,\
    \ digits, and underscores. `[aeiouy]{#{n}}` means \"match any of those letters\
    \ at least #{n} times\". `scan` returns a list of matching strings. `words.concat\
    \ word.scan(/[aeiouy]{#{n}}/)` means \"concatenate all the words that match *or*\
    \ that match #{n} times the letters matched.\n<|/ c |>\n<| c |>\n- `[aeiouy]{#{n}}`\
    \ isn't a regular expression (but a Ruby expression). `/[aeiouy]{#{n}}/` is a\
    \ regular expression and is equivalent to the more explicit `/[aeiouy]+/`. `word.scan(/[aeiouy]+/)`\
    \ would also work, but I'd recommend against it - it's more readable to use the\
    \ more readable expression.\n<|/ c |>\n<| a |>\nI would use a regular expression\
    \ to do this. Something like this might work:\n<code>", "  strs = str.split(\"\
    \ \").map {|s| s.strip}\n  if strs.size == 0\n    []\n  else\n    strs.select\
    \ {|s| s.size == n}.map {|s| s.capitalize}\n  end\nend", "  words = []\n  \n \
    \ if s.empty?\n    words\n  else\n    if s.include?(' ')\n      words.push s\n\
    \      words\n    end\n    \n    i = s.length - 1\n    \n    while i >= 0\n  \
    \    words.push s[0..(i-1)]\n      i -= 1\n    end\n    \n    words.reverse.each\
    \ do |word|\n      if word.length == n\n        words << word\n      end\n   \
    \ end\n    \n    words\n  end\nend\n</cell>\n<cell>", "  s.split(\" \").map {\
    \ |w| w.split(\" \").select { |w| w.count() == n }.join(\"  \") }\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nGreat solution, but you forgot the empty string case.\
    \  For future reference, what if I gave you a problem and asked you to give me\
    \ the solution?  Can you write code so you didn't need other people's hard work\
    \ to figure out how to solve the problem?\n<|/ c |>\n<| c |>\nIt works perfectly.\
    \ Thanks a lot for your help.\n<|/ c |>\n<| c |>\nWon't work if the number of\
    \ words is equal to n. This will return all words of length n.\n<|/ c |>\n<| a\
    \ |>\nHere is a solution that works for the case when your string has spaces,\
    \ but doesn't work when your string doesn't have spaces.\n<code>", "    \n   \
    \ # YOUR CODE HERE\n    \n    return []\n    \nend\n</cell>\n<text>\nRun the code\
    \ cell below to test your solution.", "  result = []\n  s.split(' ').each do |word|\n\
    \    word.scan(/[a-z]+/).each do |letter|\n      next if letter.size < n\n   \
    \   result << word\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=algorithm,ruby\
    \ |>\n<| c |>\nI actually like your solution because you use the size of the words\
    \ to control which words get returned. But I like your explanation about why it\
    \ works. Thanks.\n<|/ c |>\n<| c |>\nI like the explanation of why it works. My\
    \ only question is why do you need a 'next' statement after each letter? It seems\
    \ to work without it.\n<|/ c |>\n<| a tags=algorithm,ruby dscore=1 |>\nHere's\
    \ a simpler way of doing this:\n<code>", "  result = []\n  if s.length > 0\n \
    \   letters = Array.new(n)\n    letters.each { |i| letters[i] = s.gsub(/\\W/,\
    \ '') }\n    letters.each do |letter|\n      result += s[letter.each_cons(n).min_by(&:length).last(n\
    \ - 1)].split\n    end\n  end\n  result\nend", "  s = s.downcase\n  s.gsub!(/\\\
    s+/, \" \")\n  s.gsub!(/[\\p{Zs}\\s]/, \"\")\n  s.split\n  s.select{ |w| w.split(\"\
    \ \").size == n }\nend", "  word = s.split(\" \")\n  return word.join(\",\").split(\"\
    ,\")\nend", "\tlist = s.split\n\tlist.select\nend", "  result = []\n  s.split(\"\
    \ \").each do |w|\n    w.split(\"\").each do |c|\n      next if c == \"n\" \n\
    \      result << c if n == 1\n      n -= 1\n    end\n  end\n  result\nend\n</cell>\n\
    <cell>", "  \n  # TODO: \n  # your code goes here\n  \nend\n</cell>\n<cell>",
  "  l = []\n  if s.empty?\n    return []\n  \n  s = s.scan(/[A-za-z]+/)\n  \n  s.each\
    \ do |item|\n    if item.split(\" \").length == n\n      l << item\n    end\n\
    \  end", "  words = s.split\n  result = []\n  until s.length == 0\n    result.push(words[0...n])\n\
    \    s.pop\n  result\nend", "  \n  words = []\n  \n  if s.empty?\n    return words\n\
    \  \n  if n > 0\n    for i in 0...s.length\n      if s[i] != \"x\"\n        if\
    \ n > 0\n          if s[i:i+n] == \".\"\n            i += n\n          else \n\
    \            words.push(s[i:i+n])\n        end\n      else\n        if n > 0\n\
    \          if s[i:i+n] == \".\"\n            i += n\n          else \n       \
    \     words.push(s[i:i+1])\n        end\n      end\n    end\n  else \n    for\
    \ i in 0...s.length\n      if s[i] != \"x\"\n        if n > 0\n          if s[i:i+n]\
    \ == \".\"\n            i += n\n          else \n            words.push(s[i:i+1])\n\
    \        end\n      else\n        if n > 0\n          if s[i:i+n] == \".\"\n \
    \           i += n\n          else \n            words.push(s[i:i+1])\n      \
    \  end\n      end\n    end\n  end\n  \n  return words\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\nHere is my Ruby solution:\n<code>", "  s = s.split\n  result\
    \ = []\n  if s.length == 0\n    return []\n  s.each_index do |i|\n    if s[i].match(/[aeiou]/i)\
    \ == nil\n      result << s[i]\n      if result.size == n\n        return result\n\
    \      end\n    end\n  end\nend", "  arr = []\n  if s.empty?\n    arr\n  else\n\
    \    while n > 0\n      word = s.split(\" \").map { |w| w.capitalize }\n     \
    \ word.each do |w|\n        w.each_char do |c|\n          if c.to_s.size != n\n\
    \            next\n          end\n          arr << w if c.to_s.size == n\n   \
    \     end\n      end\n      n -= 1\n    end\n    arr\n  end\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThank you so much, great explanation. Sorry for the trouble,\
    \ I'm new to programming and just had the task to do an exercise for school. This\
    \ was a great help :)\n<|/ c |>\n<| a tags=ruby |>\nAnother way\n<code>", "\t\
    s = ''\n\tresult = []\n\ti = 0\n\twhile i < s.length\n\t\tif s.count('a') + s.count('e')\
    \ + s.count('i') + s.count('o') + s.count('u') == n\n\t\t\tresult << s\n\t\tend\n\
    \t\ti += 1\n\tend\n\tresult\nend", "    list = []\n    string = \"\"\n    i =\
    \ 1\n    while i < s.length\n        if s.include? \" \"\n            i = 0\n\
    \            string += \" \"\n            i += 1\n        else\n            i\
    \ += 1\n            if i <= n\n                if s.include? s[i]\n          \
    \          list << string\n                    string = \"\"\n               \
    \ end\n            end\n        end\n    end\n    return list\nend\n</code>\n\
    <|/ a tags=ruby,arrays dscore=1 |>\n<| a tags=ruby,arrays |>\n<code>", "  result\
    \ = []\n  s.each do |word|\n    word.split.each do |letter|\n      if letter.length\
    \ == n\n        result << word\n        break\n      end\n    end\n  end\n  result\n\
    end", "  \n  # TODO: Write your code here\n  \nend", "  return [] if s.empty?\n\
    \  words = []\n  left_side = s.split.each_cons(2).map {|left, right| left + right}\n\
    \  words += left_side if (left_side.length == n)\n  words + left_side.drop(n).each_cons(n).map\
    \ {|left, right| left + right}\nend", "    \n    return []\nend", "    letters\
    \ = s.split(\"\")\n    select_words = []\n    count=1\n    for letter in letters\n\
    \        if letter=~\"consonant\"\n            count+=1\n        if count==n\n\
    \            select_word=letter\n            select_words.append(select_word)\n\
    \            count=1\n            letters=s.split(\"\")\n            letter=letters.shift\n\
    \        end\n    end\n    \n    return select_words\nend", "    # Your code here\n\
    \    return []\nend", "  return [] if s.empty?\n  result = s.scan(/([a-z]+?)(\\\
    s[a-z]+?)?/).flatten.uniq.select {|word| word.size <= n }\n  result.empty? ? []\
    \ : result\nend", "  return [] if s.empty? || n <= 0\n  \n  a = s.split(' ').map\
    \ { |w| w.split('') }\n  a.each_cons(n).map(&:join)\nend", "  \n  # Your code\
    \ here!\n  \n  return words\nend", "  return [] if s.empty?\n  words = []\n  i\
    \ = 0\n  while i < s.length\n    words = words +  \n      (s.chars.select { |c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' }).to_a\n    i += 1\n\
    \  end\n  words.select { |w| w.size == n }\nend\n</cell>\n<cell>\nselect_words\
    \ \"Mary had a little lamb\", 4\n</cell>\n<cell>\nselect_words \"Mary had a little\
    \ lamb\", 3\n</cell>\n<cell>\nselect_words \"simple white space\", 2\n</cell>\n\
    <cell>\nselect_words \"Hello world\", 4\n</cell>\n<cell>\nselect_words \"Uncle\
    \ sam\", 3\n</cell>\n<cell>\nselect_words \"Hello world\", 4\n</cell>\n<cell>\n\
    select_words \"Uncle sam\", 3\n</cell>\n<text>\nImplement an is_palindrome function\n\
    Given a string, return True if it is known to be a palindrome, otherwise, return\
    \ False.\nIf the string is a palindrome, you may assume that a string that contains\
    \ only spaces and letters is a palindrome.", "  puts n\n  return []\nend", " \
    \   # write your code here\n    ret = []\n    word = \"\"\n    for c in s.downcase\n\
    \        if (c == \" \" ) || (c == \"\\n\" ) || (c == \"\\t\") || (c == \"\\r\"\
    ) || (c == \"'\")\n            ret = []\n            word = \"\"\n        else\n\
    \            if c == \".\"\n                ret.push(word)\n                word\
    \ = \"\"\n            else\n                word += c\n            end\n     \
    \   end\n    end\n    return ret\nend\n</cell>\n<cell>", "  s = s.downcase\n \
    \ arr = []\n  i = 0\n  while i < s.length\n    if s[i] == \"a\"\n      arr <<\
    \ s[i]\n      i += 1\n      while i < s.length && s[i] == \"a\"\n        i +=\
    \ 1\n    end\n    if s[i] == \"e\"\n      arr << s[i]\n      i += 1\n      while\
    \ i < s.length && s[i] == \"e\"\n        i += 1\n    end\n    if s[i] == \"o\"\
    \n      arr << s[i]\n      i += 1\n      while i < s.length && s[i] == \"o\"\n\
    \        i += 1\n    end\n    if s[i] == \"u\"\n      arr << s[i]\n      i +=\
    \ 1\n      while i < s.length && s[i] == \"u\"\n        i += 1\n    end\n    i\
    \ += 1\n  end\n  arr.uniq\nend", "  if s.length==0 then return []\n  w=split_string(s)\n\
    \  w=[w for i in w for j in i if j!=' ' and j!='\\n']\n  re=[]\n  for i in w\n\
    \    for j in i\n      if j==' ' and j!='\\n' and n==1 and re.length==0 then return\
    \ re\n      else if j==' ' and j!='\\n' and n>1 and re.length==0 then return re\n\
    \      else if j!='\\n' and j!='' and n==1 and re.length==0 then return re\n \
    \     else if j!='\\n' and j!='' and n>1 and re.length==0 then return re\n   \
    \   else if j==' ' and j!='\\n' and n>1 and re.length==0 then return re\n    \
    \  else if j!='\\n' and j!='' and n==1 and re.length>0 then return re\n      else\
    \ if j!='\\n' and j!='' and n>1 and re.length>0 then return re\n      else if\
    \ j==' ' and j!='\\n' and n>1 and re.length>0 then return re\n      else if j!='\\\
    n' and j!='' and n==1 and re.length==1 then return re\n      else if j!='\\n'\
    \ and j!='' and n>1 and re.length==1 then return re\n      else if j==' ' and\
    \ j!='\\n' and n>1 and re.length==1 then return re\n      else if j!='\\n' and\
    \ j!='' and n==1 and re.length>1 then return re\n      else if j!='\\n' and j!=''\
    \ and n>1 and re.length>1 then return re\n      else if j==' ' and j!='\\n' and\
    \ n>1 and re.length>1 then return re\n      else if j!='\\n' and j!='' and n==1\
    \ and re.length==2 then return re\n      else if j!='\\n' and j!='' and n>1 and\
    \ re.length==2 then return re\n      else if j==' ' and j!='\\n' and n>1 and re.length==2\
    \ then return re\n      else if j!='\\n' and j!='' and n==1 and re.length>2 then\
    \ return re\n      else if j!='\\n' and j!='' and n>1 and re.length>2 then return\
    \ re\n      else if j==' ' and j!='\\n' and n>1 and re.length>2 then return re\n\
    \      else if j!='\\n", "  # your code here\n  list=[]\n  l=s.split(\" \")\n\
    \  for word in l\n    if s.length.eql?(n)\n      if /[aeiouy]/i.match(word)  \n\
    \        list.push(word)\n    end\n  end\n  return list\nend", "    \n    # Write\
    \ your logic here\n    return s.scan(/[a-zA-Z]*/).select{|l| l.scan(/[aeiouy]/).size\
    \ <= n}\nend", "  s = s.replace(/[\",.?;]|\\s/, \"\")\n  return s.split(\" \"\
    ).select { |w| w.length == n }.map(&:capitalize).map(&:capitalize)\nend", "  s.split(\"\
    \ \").map do |word|\n    if word.scan(/[aeiou]/i).length == n\n      word\n  \
    \  end\n  end\nend", "  result=[]\n  while s.empty?==false\n    result<<s.slice!(0,n)\n\
    \    s.slice!(0,n)\n  end\n  return result\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| a dscore=0 |>\nMy Solution uses String#chars\n<code>", "    \n    return []\n\
    end", "  if s.length == 0\n    []\n  else\n    select_words_helper(s, n).to_a\n\
    \  end\nend", "    \n    word = s[0..n]\n    chars = s.split\n    array = chars.to_a\n\
    \    \n    array.select {|element| element.include?(word) }\nend\n</cell>\n<cell>\n\
    select_words(\"Hello world\", 4)\n</cell>\n<cell>\nselect_words(\"Uncle sam\"\
    , 3)\n</cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"\
    Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n</cell>\n<cell>\n\
    select_words(\"Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n\
    </cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"\
    Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n</cell>\n<cell>\n\
    select_words(\"Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n\
    </cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"\
    Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n</cell>\n<cell>\n\
    select_words(\"Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n\
    </cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"\
    Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n</cell>\n<cell>\n\
    select_words(\"Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n\
    </cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"\
    Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n</cell>\n<cell>\n\
    select_words(\"Uncle sam\", 3)\n</cell>\n<cell>\nselect_words(\"Uncle sam\", 3)\n\
    </cell>\n<cell>\nselect_words(\"Uncle sam", "  l = []\n  i = s.length-1\n  while\
    \ i >= 0 do\n    if s[i] =~ /[^aeiou]+/\n      break\n    else\n      if s[i]\
    \ =~ /[^aeiou]+/\n        l.push s[i]\n      end\n      i -= 1\n    end\n  end\n\
    \  return l if l.size < n\n  l = []\n  i = 0\n  while i < s.length do\n    if\
    \ s[i] =~ /[^aeiou]+/\n      l.push s[i]\n      i += 1\n    else\n      i += 1\n\
    \    end\n  end\n  return l if l.size >= n\n  l = []\n  i = 0\n  while i < s.length\
    \ do\n    if s[i] =~ /[^aeiou]+/\n      l.push s[i]\n      i += 1\n    else\n\
    \      if s[i] =~ /[^aeiou]+/\n        l.push s[i]\n        i += 1\n      end\n\
    \      i += 1\n    end\n  end\n  return l if l.size >= n\nend", "    # your code\
    \ here\n    return [] if s.empty?\n    \n    words = []\n    \n    words.concat(s.split)\
    \ if s.length <= n\n    \n    i = n\n    \n    loop do\n        words.concat words.split[i..-1]\
    \ if i < n\n        i -= 1\n        break if i < 0\n    end\n    \n    words\n\
    end", "    s = [] if s.empty?\n    selected_words = []\n    # Loop through each\
    \ word in s.split\n    s.split.each do |word|\n        # Check to see if this\
    \ word contains exactly n consonants\n        if word.scan(/[b-df-hj-np-tv-z]/).length\
    \ == n\n            selected_words << word\n        end\n    end\n    selected_words\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThank you so much!\n<|/ c |>\n\
    <| c |>\nHey Steve - I ran your code and it worked, but I noticed a problem. When\
    \ I ran it on \"Mary had a little lamb\" it returned [\"little\", \"lamb\"]. But\
    \ when I ran it on \"Hello world\" it returned [\"Hello\", \"world\"]. Why did\
    \ that happen?\n<|/ c |>\n<| c |>\nAh, I see what you meant. I was running the\
    \ wrong test case. I'll take a look at it more closely.\n<|/ c |>\n<| c |>\nHey\
    \ Steve, if you have any questions, feel free to shoot me an email at  or by Twitter.\n\
    <|/ c |>\n<| c |>\nHi Steve, I just realized that when I ran your code on the\
    \ first string \"Mary had a little lamb\", it returned [\"little\"] instead of\
    \ [\"Mary\", \"lamb\"]. How would you modify your code to fix this problem?\n\
    <|/ c |>\n<| a tags=ruby,string dscore=2 |>\n<code>\n\"Mary had a little lamb\"\
    .split.each_cons(3).map(&:join)", "    # Write your code here.\nend\n</cell>\n\
    <cell>", "  return [] if s.empty?\n  \n  cs = s.chars\n  cs.length == 0 ? [] :\
    \ cs.select {|c| c.consonants? }.take_while {|c| c == n }.to_a\nend", "  result\
    \ = []\n  \n  return result\nend", "    \n    list = s.split(\" \")\n    \n  \
    \  for el in list\n        return el\n    \n    list.empty?\n    return []\n \
    \   \nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=ruby |>\n<code>", "  s.gsub(/(\\\
    w+?)(\\W+|$)/){|i| i[n].to_i.nonzero? ? i.first : nil }.scan(/\\w+/)\nend", " \
    \ s.split(\" \").select(&:include?('a')..include?('A')).select { |word| word.size\
    \ == n }.uniq\nend", "  s.split.each_with_object([]).with_index do |word, ns|\n\
    \    word.split.each { |w| ns << w if w.include?('aeiou'.chars.map(&:downcase).join)\
    \ }\n    break if ns == n\n  end\nend\n</code>\nThe above code uses a method called\
    \ include? which returns true if a value is in an array or string and returns\
    \ false if it is not.\n<code>", "    # Your code here\n    result = []\n    rest_of_word\
    \ = s.split(' ')\n    number_of_words = rest_of_word.size\n    if number_of_words\
    \ < n\n        result.push rest_of_word\n    else\n        count = 0\n       \
    \ index = 0\n        while index < number_of_words\n            consonant = rest_of_word[index]\n\
    \            word = rest_of_word[index + 1]\n            index = index + 2\n \
    \           if index >= number_of_words - 1\n                break\n         \
    \   if consonant == word\n                count += 1\n            if count ==\
    \ n\n                result.push word\n            count = 0\n        end\n  \
    \  end\nend", "  if s.nil? || n < 1 || n > 10 then return [] end\n  words = s.split(\"\
    \ \").map(&:downcase)\n  words.select { |x| x.chars.size == n }.sort.uniq.join(\"\
    \ \")\nend\n</cell>\n<cell>", "  result = []\n  s = s.split(\" \").map(&:strip)\n\
    \  s.each { |word| result << word if word.count(n) == n }\n  result\nend", " \
    \ s.split(\" \").select {|word| word.split(\"\").count {|c| c == n.chr}} if s\n\
    \  []\nend", "    str.split(\" \").select { |word| word.count(n) == n }\nend\n\
    </code>\n<|/ a |>\n<| c |>\n`String#split` accepts a regex as an argument.  `split`\
    \ doesn't take a regex as an argument.  Also the `split` method returns an array\
    \ of strings so there's no need to use `join`.  You also forgot to include a final\
    \ `end`.\n<|/ c |>\n<| c |>\nThanks Jared - I fixed those issues when I was trying\
    \ to copy and paste it from the test file. I wasn't quite sure how to handle it\
    \ otherwise. I'll edit the post with my changes.\n<|/ c |>\n<| a |>\n<code>",
  "    \n    words= []\n    \n    # Write your code here\n    if s.empty?\n      \
    \  return words\n    \n    if n==0\n        words.push '' \n        return words\n\
    \    \n    \n    if n == 1\n        words.push (s.split(' ').sample)\n       \
    \ return words\n    \n    words.push (s.split(' ').sample) \n    \n    while words.length\
    \ > 0\n       letter = s.split[words[words.length-1].downcase].sample\n      \
    \ words.last << letter\n       if words.last == words[words.length-1]\n      \
    \     words.pop\n       elsif letter == words[words.length-1]\n           words.pop\n\
    \       else\n           words.pop\n    end\n    \n    return words", "  raise\
    \ \"not implemented\"\nend", "  if s.empty?\n    []\n  else\n    words.select\
    \ do |word|\n      if word.length == n\n        true\n      else\n        false\n\
    \      end\n    end\n  end\nend\n</code>\nAnd for the most general case:\n<code>",
  "    count = 0\n    words = []\n    s.each do |char|\n        if char == \"a\" ||\
    \ char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" || char ==\
    \ \"y\"\n            count += 1\n        end\n        if count == n\n        \
    \    words.push(char)\n        end\n    end\n    return words\nend", "  s.downcase!\n\
    \  return [] if s.empty?\n  s.split.map do |word|\n    word = word.split(//).map(&:downcase)\n\
    \    word.map do |char|\n      char.downcase.count(\"aeiou\") < n && char.downcase.count(\"\
    aeiou\") == char.count(\"aeiou\")\n    end.all?\n  end.any?\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails |>\n<| c |>\nIt took me a minute to understand your\
    \ code. But after understanding it, it's really helpful to me.\n<|/ c |>\n<| c\
    \ |>\nThis answer was extremely helpful for me to understand the code from another\
    \ source.  Thank you for the explanation!\n<|/ c |>\n<| a |>\nI made my own attempt\
    \ at this:\n<code>", "  s.split(\" \").map do |word|\n    word[/\\w{#{n}}/].split.map(&:capitalize).join(\"\
    \ \")\n  end.flatten\nend", "  arr = []\n  if s.empty?\n    arr = []\n  else \n\
    \    temp = s.split(\"\")\n    temp.each do |word|\n      if word.size <= n\n\
    \        arr.push(word)\n      end\n    end\n  end\n  return arr\nend", "  if\
    \ s == \"\"\n    []\n  else\n    words = []\n    word = s[0]\n    for w in s.split('\
    \ ').select{|w| w == word} + [word]\n      if n == word.count('a') + 1\n     \
    \   words.push(word)\n      end\n    end\n    words\n  end\nend", "    return\
    \ \nend", "end\n</pre>\n<h2>Thoughts</h2>\n<p>\nWe have just gone over most of\
    \ the problems asked in the assignment but we can give some thoughts.\nThe most\
    \ important point to consider is that what makes a word is dependent on the previous\
    \ words.\nWe cannot just take a string and count the letters in that string. If\
    \ we want to implement this algorithm correctly we will need a stack to keep track\
    \ of the previous words that we see.\nThe key point to remember is that we can\
    \ build up a string from each word we encounter and we will need a way to keep\
    \ track of what letters have already been seen.\nWe can keep track of what letters\
    \ have already been seen by using a set which holds unique items.\nIf we encounter\
    \ a letter and it is in the set we can ignore it.\nIf we encounter a letter and\
    \ it is not in the set we will need to add it to the set and push the new word.\n\
    If we encounter a space in the input string we will need to return our list of\
    \ words.\nWe can accomplish the above by using a stack and a set together to keep\
    \ track of the previous words.\nWe will also need a way to keep track of the current\
    \ word; a variable called curr_word that is initialized to an empty string at\
    \ the start of the function.\nFinally, we need to implement our recursive base\
    \ case by adding empty strings to the list of previous words.\n</p>\n<h2>Code\
    \ Solutions</h2>\n<pre>", "  s.split\n  s.count(\".\")\n  if s.count == \".\"\n\
    \    select = []\n  elsif s.count == \".\"\n    select = s.split\n  elsif s.count\
    \ == \"!\"\n    select = s.split.delete_if{ |word| word == \"!\" }.map { |word|\
    \ word[-1] }\n  elsif s.count == \"?\"\n    select = s.split.delete_if{ |word|\
    \ word == \"?\" }.map { |word| word[-2] }\n  elsif s.count == \"!\"\n    select\
    \ = s.split.delete_if{ |word| word == \"!\" }.map { |word| word[-1] }\n  elsif\
    \ s.count == \"?\"\n    select = s.split.delete_if{ |word| word == \"?\" }.map\
    \ { |word| word[-2] }\n  elsif s.count == \"!\"\n    select = s.split.delete_if{\
    \ |word| word == \"!\" }.map { |word| word[-1] }\n  elsif s.count == \"?\"\n \
    \   select = s.split.delete_if{ |word| word == \"?\" }.map { |word| word[-2] }\n\
    \  elsif s.count == \"!\"\n    select = s.split.delete_if{ |word| word == \"!\"\
    \ }.map { |word| word[-1] }\n  elsif s.count == \"?\"\n    select = s.split.delete_if{\
    \ |word| word == \"?\" }.map { |word| word[-2] }\n  elsif s.count == \"!\"\n \
    \   select = s.split.delete_if{ |word| word == \"!\" }.map { |word| word[-1] }\n\
    \  elsif s.count == \"?\"\n    select = s.split.delete_if{ |word| word == \"?\"\
    \ }.map { |word| word[-2] }\n  elsif s.count == \"!\"\n    select = s.split.delete_if{\
    \ |word| word == \"!\" }.map { |word| word[-1] }\n  elsif s.count == \"?\"\n \
    \   select = s.split.delete_if{ |word| word == \"?\" }.map { |word| word[-2] }\n\
    \  elsif s.count == \"!\"\n    select = s.split.delete_if{ |word| word == \"!\"\
    \ }.map { |word| word[-1] }\n  elsif s.count == \"?\"\n    select = s.split.delete_if{\
    \ |word| word == \"?\" }.map { |word", "    i = 0\n    words = []\n    while i\
    \ < s.length\n        if s.slice!(i..i+n).scan(/[bcdfghjklmnpqrstvwxyz]{2,}/).size\
    \ == n\n            words.push!(s[i..i+n])\n        end\n        i += 1\n    end\n\
    \    words\nend", "    words = s.split(' ')\n    select_words = []\n    i = 0\n\
    \    while i < len(words)\n        word = words[i]\n        if ((word.split('\
    \ ').length - 1) >= n)\n            select_words.append(word)\n        i += 1\n\
    \    return select_words\n    ", "  if s.length==0\n    []\n  else\n    result=[]\n\
    \    i=0;\n    while i<s.length\n      if s[i:i+n].join==s[0..n]\n        result.push\
    \ s[i:i+n]\n        i+=n\n      else\n        i+=1\n    end\n    result\n  end\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 tags=ruby |>\n<code>", "  result\
    \ = []\n  if s.length > 0\n    letters = s[0]\n    count = 1\n    while count\
    \ < n\n      letters += s[count + 1]\n      count += 2\n      s = s[count..s.length\
    \ - 1]\n      \n      if s.include?(letters)\n        result << letters\n    \
    \  end\n    end\n  else\n    result = []\n  end\n  \n  result\nend", "  word =\
    \ s.split(\" \").select{|word| word.length==n}\n  word.to_a.join(\" \")\nend\n\
    </code>\n<|/ a |>\n<| c |>\n`select_words(\"simple white space\", 2) ==> []` does\
    \ not work right.  See my answer.\n<|/ c |>\n<| c |>\nI noticed that `select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]` does not work.  So I made an adjustment.\n<|/\
    \ c |>\n<| c |>\n`select_words(\"simple white space\", 2) ==> []` does not work\
    \ right. see my answer as well.\n<|/ c |>\n<| c |>\n, Yes, thanks, I missed that\
    \ one as I was trying to fix my code.  I added a fix for the non-consonant case.\n\
    <|/ c |>\n<| c |>\n, your solution does not work for the problem stated in the\
    \ comments above.  It returns `[\"a\", \"white\", \"space\"]`.\n<|/ c |>\n<| a\
    \ |>\nThis code will count all words in a text with the correct length and containing\
    \ only letters.\n<code>", "  words = []\n  letters = s.split(//)\n  letters.each\
    \ do |letter|\n    letter = letter.downcase\n    letters = letter.split(//)\n\
    \    letters.each do |l|\n      if l=~ /[aeiouy]/\n        words << letter\n \
    \     end\n    end\n  end\n  words.sort!\n  return words\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis one does not appear to work if the string is \"Mary had a\
    \ little lamb\". It will return [\"Mary\", \"lamb\"], but it should return [\"\
    lamb\"] since \"lamb\" contains 4 consonants. I have updated the question to show\
    \ you the desired output.\n<|/ c |>\n<| c |>\nWhat is `//`?\n<|/ c |>\n<| c |>\n\
    It is a [regular expression](http://www.ruby-doc.org/core-2.1.1/Regexp.html) indicating\
    \ \"any character zero, one or more times\".\n<|/ c |>\n<| c |>\nI see, it would\
    \ be better to write it as `split`. Thanks for the explanation.\n<|/ c |>\n<|\
    \ c |>\nNote that this solution also sorts the list, which might not be desired.\
    \ For example in the input `\"Mary had a little lamb\"`, if you sort the list,\
    \ `\"lamb\"` would come before `\"little\"`.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nIf you want pure Ruby solution that doesn't use regular expression:\n<code>",
  "  # Your code here\n  arr = s.split(\"\")\n  arr.delete_if { |x| x.match(\"[^aeiouy]+\"\
    ) }\n  if arr.size == 0\n    []\n  else\n    arr.select { |x| x.match(\"^[aeiouy]+\"\
    ).to_a == [n] }.each { |x| puts x }\n  end\nend", "  \n  return [] if s.empty?\n\
    \  \n  return s.split(' ').select {|x| x.count(n).even?}.map{|s| s.split.select{|x|\
    \ x.count(n).even?}}\nend", "  s.split(\" \").map{|w| w if w.scan(/[b-df-hj-np-tv-z]/)\
    \ == n}.compact\nend", "  # +++your code here+++\n  result = []\n  loop do\n \
    \   break if s.empty?\n    result << s[:n].downcase.split\n    s = s[n..-1]\n\
    \  end\n  result\nend", "  result = []\n  if s.length == 0 then return result\n\
    \  i = 0\n  while i < s.length\n    char = s[i]\n    if n > 0\n      result.append(char)\n\
    \      i += n\n    else\n      i = i + 1\n      while i < s.length\n        if\
    \ s[i] != char\n          break\n        i = i + 1\n      end\n      result.append(char)\n\
    \    end\n  end\n  result\nend", "    # check if n exists\n    if n <= 0\n   \
    \     return false\n    \n    # make a list of all consonants in a string\n  \
    \  letters = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"e\"]\n    consonants\
    \ = [letter + \"o\" for letter in letters]\n    \n    # make a list of all words\
    \ in the string\n    words = s.split\n    \n    # initialize an empty list\n \
    \   return_words = []\n    \n    # loop through each word in the string\n    for\
    \ word in words\n        \n        # loop through each consonant in the word and\
    \ add to list\n        for consonant in consonants\n            return_words +=\
    \ word[consonant.index(n)..]\n    end\n    \n    # return the list\n    return\
    \ return_words\nend", "    \n    # Write your code here\n    return []\nend\n\
    </cell>\n<text>\n2.4 Palindrome checker with Array\nExercise 2b: Given a string\
    \ s, you are asked to write a function that checks if it is a palindrome or not.",
  "\tresult = []\n\tif s == \"\"\n\t\tresult\n\telse\n\t\tresult = s.split\n\tend\n\
    \tresult = result.select { |word| word.count { |letter| letter == \"a\" || letter\
    \ == \"e\" || letter == \"i\" || letter == \"o\" || letter == \"u\" } }\n\tif\
    \ n < result.length\n\t\tresult\n\telse\n\t\tresult\n\tend\nend\nputs select_words(\"\
    Mary had a little lamb\", 4).inspect\nputs select_words(\"Mary had a little lamb\"\
    , 3).inspect\nputs select_words(\"simple white space\", 2).inspect\nputs select_words(\"\
    Hello world\", 4).inspect\nputs select_words(\"Uncle sam\", 3).inspect", "  return\
    \ [] if s.empty?\n  \n  return s.split #=> ['Mary', 'had', 'a', 'little', 'lamb']\n\
    end", "    list = \"\"\n    count = 0\n    \n    # Check for non-empty string\n\
    \    if s.empty?\n        return list\n    \n    # Initialize a list of vowels\n\
    \    vowels = %w[a e i o u]\n    \n    # Loop through each letter in the string\n\
    \    s.each do |letter|\n        # If current letter is in list vowels then skip\
    \ it\n        if vowels.include?(letter)\n            next\n        end\n    \n\
    \        # Initialize a boolean variable for number of consonants\n        consonants_found\
    \ = false\n    \n        # Loop through each consonant\n        consonant_counter\
    \ = 1\n        while consonants_found == false && consonant_counter <= n do\n\
    \            # If the current letter is the last letter in the consonant loop\
    \ through next consonant\n            if consonant_counter == n\n            \
    \    consonant_counter += 1 \n                consonants_found = true if consonant_counter\
    \ == n\n            elsif letter == consonant_counter\n                consonants_found\
    \ = true if consonant_counter != n\n                list << letter\n         \
    \       consonant_counter += 1 \n            else\n                consonant_counter\
    \ += 1\n            end\n        end\n    end\n    return list\nend", "  a = s.split(\"\
    \ \")\n  b = a[0]\n  c = b.split(\"\")\n  d = \"\"\n  e = []\n  a.each do |i|\n\
    \    i.to_s.split(\" \").each do |j|\n      if j == \"#{i}\"\n        d = d +\
    \ \"#{j} \"\n      end\n    end\n  end\n  d.split(\" \").each do |f|\n    e.push(f)\n\
    \  end\n  a.each do |i|\n    i.to_s.split(\" \").each do |j|\n      if j == e.last\n\
    \        a = i\n      end\n    end\n  end\n  a\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nPlease don't post only code as answer, but also provide an explanation\
    \ what your code does and how it solves the problem of the question. Answers with\
    \ an explanation are usually more helpful and of better quality, and are more\
    \ likely to attract upvotes.\n<|/ c |>\n<| c |>\nThis code does not work if the\
    \ phrase contains more than one space.\n<|/ c |>\n<| c |>\n, you are right. I\
    \ made a fix to it. The code has been updated\n<|/ c |>\n<| a tags=ruby |>\nHere\
    \ is a way to do it using regular expressions:\n<code>", "  if s.nil? or n < 1\n\
    \    return []\n  else\n    letters = s.split(\" \").join(\"\").chars.to_a\n \
    \   words.select { |w| letters.count { |l| w.include?(l) }.to_i == n }\n  end\n\
    end", "  result = []\n  if s.empty? then return result\n  \n  # split the input\
    \ s into an array of words\n  s = s.split\n  \n  # remove empty strings\n  s.delete_if\
    \ { |e| !e.empty? }\n  \n  # loop over the array\n  s.each do |word|\n    # create\
    \ a sub-array of letters from this word\n    letters = word.split('')\n    \n\
    \    # remove letters that are not in the list\n    letters.delete_if { |e| e\
    \ !~ /[aeiouy]+/ }\n    \n    # see if any are in the list\n    letters.any? {|e|\
    \ e =~ /[aeiouy]+/ }\n    \n    # if the length of the array matches the desired\
    \ number, then push it to result\n    if letters.length == n then result << word\
    \ end\n  end\n  \n  # return the result\n  result\nend", "  # Split s into an\
    \ array of words\n  s = s.split\n  # Return an empty array if s is empty\n  return\
    \ [] if s.empty?\n  # Create an array of 26 empty strings\n  arr = Array.new(26)\n\
    \  # Populate the empty strings with the empty string \"\"\n  arr.each { |s| s\
    \ << \"\" }\n  # Go through each character of the string s\n  s.each do |c|\n\
    \    # Find where in arr the character is stored\n    i = (c - 'a').abs\n    #\
    \ Remove that element and place a copy in its place\n    arr[i] << arr[i].last\n\
    \    # Remove the last character from all arrays\n    arr.slice!(0...i-1)\n  end\n\
    \  # Remove all empty strings from the array\n  arr.compact!\n  # Return an Array\
    \ containing all elements that have the given number of consonants\n  arr.select\
    \ { |a| a.length == n }\nend", " \n  result = []\n  i = 0\n  while i < s.length\n\
    \    if s[i] ==  \" \" or s[i] == \"\\n\"\n      i += 1\n      continue\n    if\
    \ s.chars.all? { |char| char == s[i]}\n      result.push s[i]\n      i += 1\n\
    \      continue\n    end\n    if i == s.length - 1\n      result.push s[i]\n \
    \     i += 1\n      continue\n    end\n    if s[i..i+n].chars.all? { |char| char\
    \ == s[i]}\n      result.push s[i..i+n]\n      i += n\n      continue\n    end\n\
    \    i += 1\n  end\n  \n  if result.length == 0\n    return []\n  end\n  result\n\
    end", "    if s.empty?\n        []\n    elsif n == 0\n        []\n    elsif s.include?(\"\
    \ \")\n        []\n    else\n        words = []\n        pos = 1\n        while\
    \ pos < s.length\n            if (s[pos-1] == \" \" && pos > 1) || s[pos] == \"\
    \ \"\n                words.push s[0..pos-1]\n                pos = pos + 1\n\
    \            elsif s.include?(\" \")\n                words.push s[0..pos]\n \
    \               pos = pos + 1\n            else\n                words.push s[0..pos]\n\
    \                pos = pos + 1\n            end\n        end\n        return words\n\
    \    end\nend", "  \nend", "  result = []\n  loop do\n    if s.empty?\n      break\n\
    \    end\n    result << s[0] if n > 0\n    n -= 1\n    s = s.slice(1, s.length)\n\
    \  end\n  result\nend", "  s.scan(/[^aeiou]/).select { |v| v.size == n }.to_a\n\
    end", "    words = []\n    i = j = 0\n    while i < s.length\n        if s[i].upcase\
    \ == s[j].upcase\n            if s[i].downcase == s[j].downcase\n            \
    \    if s[i].size == n\n                    words << s[i].downcase\n         \
    \           i += 1\n                    j += 1\n                else\n       \
    \             j += 1\n            else\n                i += 1\n        else\n\
    \            i += 1\n    end\n    return words\nend", "    words = s.split if\
    \ s.respond_to?(:split) \n      s.chars.each_with_object([]) { |c,a| a.push(c)\
    \ if n.zero? || c.to_s.length == n} \n    end \nend\n</code>\n<|/ a |>\n<| a tags=ruby\
    \ |>\n<code>", "    \n    # Your code goes here\n    list = s.split(\" \")\n \
    \   \n    list.each do |word|\n        if word.count(word) == n\n            puts\
    \ word\n        end\n    end\nend", "  s = \"\" if s.nil? || s.empty? \n  a =\
    \ s.split(\" \").select{|x| x[0].match(\"[aeiouy]\") }.sort{|x, y| y.length <=>\
    \ x.length}\n  a.select {|x| x.length == n }.sort.join(\" \")\nend", "    if s.length\
    \ == 0\n        return []\n    \n    lista = []\n    lista << s.chars.to_a\n \
    \   \n    while lista.size > n\n        lista.remove(lista[0])\n    end\n    \n\
    \    return lista\nend", "  # Your code here\n  s.split(/[^aeiou]*/).reject {\
    \ |w| w.length < n }.map { |w| w.split('').reject { |c| c.blank? }.join }\nend",
  "  s.split(//)\nend\n</code>\nThe above code doesn't work, but I believe it gives\
    \ the idea of what should be done. I would appreciate if someone can help me to\
    \ finish this up.\n<|/ q tags=ruby,string dscore=0 |>\n<| c |>\nWhat is the question?\n\
    <|/ c |>\n<| c |>\nThe question was to implement a function that returns a list\
    \ of all words from string s that contain exactly n consonants, in order these\
    \ words appear in the string s.\n<|/ c |>\n<| c |>\nPlease read \"[mcve]\". Since\
    \ you haven't even shown us your attempt, how are we to know what that attempt\
    \ is? You need to show us what you've tried so far, how that failed to work, and\
    \ how you were expecting it to work. Otherwise we're just making guesses as to\
    \ what you may have done wrong. Also, why is this tagged \"ruby\" and \"java\"\
    ? How are they related?\n<|/ c |>\n<| c |>\nSorry for that. I just edited my question,\
    \ hope it better reflects my intention.\n<|/ c |>\n<| c |>\nWhen you say *\"a\
    \ natural number n\"*, do you mean \"a number in the set {1, 2, 3, ..., n}\"?\n\
    <|/ c |>\n<| a tags=ruby,string dscore=2 |>\nHere's one way to accomplish what\
    \ you want. I decided to use regular expressions to match the word and digits.\
    \ Because the regular expression is rather large, I split the regex into separate\
    \ lines with //.\n<code>", "  # Your code here\nend", "  result=[]\n  for i in\
    \ 0..s.length-1\n    if s[i]=~\"^\\w{#{n}}$\"\n      result << s[i]\n    end\n\
    \  end\n  result\nend", "    \n    # Write your code here\n    \nend", "    #\
    \ Your code here\n    return []\nend", "  return  s.split.select { |i| i.count(\"\
    a\") >= n }.sort\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
