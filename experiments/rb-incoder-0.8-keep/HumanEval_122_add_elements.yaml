name: HumanEval_122_add_elements
language: rb
prompt: "# Given a non-empty array of integers arr and an integer k, return\n# the\
  \ sum of the elements with at most two digits from the first k elements of arr.\n\
  # Example:\n# Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n# Output: 24 # sum\
  \ of 21 + 3\n# Constraints:\n# 1. 1 <= len(arr) <= 100\n# 2. 1 <= k <= len(arr)\n\
  def add_elements(arr, k)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add_elements\n\
  \    candidate = method(:add_elements)\n    assert_equal(-4, candidate.call([1,\
  \ -2, -3, 41, 57, 76, 87, 88, 99], 3))\n    assert_equal(0, candidate.call([111,\
  \ 121, 3, 4000, 5, 6], 2))\n    assert_equal(125, candidate.call([11, 21, 3, 90,\
  \ 5, 6, 7, 8, 9], 4))\n    assert_equal(24, candidate.call([111, 21, 3, 4000, 5,\
  \ 6, 7, 8, 9], 4))\n    assert_equal(1, candidate.call([1], 1))\n  end\nend\n"
completions: ["    arr.each_with_index do |x, i|\n        return if i == k\n     \
    \   arr.delete_at(i) if arr[i] > 9\n    end\n    arr.last\nend\n</code>\n<|/ a\
    \ tags=algorithm,ruby dscore=1 |>\n<| a |>\nThis solution is in Ruby and uses\
    \ no additional storage.  It is based on the idea that if the last two digits\
    \ are equal we must add the last digit to it.\n<code>", "  sum = 0\n  for i in\
    \ 0...k\n    sum += arr[i]\n  end\n  return sum\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=sum,ruby,algorithm |>\nI used the recursive solution.\n<code>",
  "  arr.each do |x| # loop on each element\n    x.to_s # convert to a string to make\
    \ it more convenient to work with\n    x.to_i # convert to an integer to compare\
    \ values\n  end\nend", "  count = 0\n  for i in 1..k\n    if arr[i] > 10\n   \
    \   count += arr[i] - 10\n    else\n      count += arr[i]\n  end\n  return count\n\
    end", "    # your code\n    arr.each do |a|\n        if a.to_i >= k\n        \
    \    sum+=a\n        end\n    end\n    return sum\nend", "  ans = 0\n  for i in\
    \ 0...k\n    ans += arr[i]\n  el = arr.length\n  while el > 0\n    if el % 2 ==\
    \ 0\n      ans += arr[el]\n    el -= 1\n    ans *= 10\n  end\n  ans\nend\n</code>\n\
    <|/ a tags=arrays,ruby |>\n<| c |>\nThis doesn't answer OP's question of \"can\
    \ you do it without looping\".\n<|/ c |>\n<| c |>\nI agree, but i would have added\
    \ more explanation since he explicitly asked for it without looping.\n<|/ c |>\n\
    <| c |>\nOP's question explicitly says \"can you do it without looping\". `while\
    \ arr` would work equally well, just more efficiently and simpler.\n<|/ c |>\n\
    <| a dscore=1 |>\nI really like this question, especially since I only used Ruby\
    \ so far:\n<code>", "  result = 0\n  result.update(arr[0..(k-1)])\n  result.update(arr[1..k])\n\
    \  result.update(arr[2..(k-1)])\n  result.update(arr[3..k])\n  return result\n\
    end", "  arr.first(k).inject(:+)\nend\n</cell>\n<cell>\nadd_elements([111,21,3,4000,5,6,7,8,9],\
    \ 4)\n</cell>\n<cell>", "  k = k if k > arr.size \n  sum = 0 \n  (0...arr.size).to_a.reverse.take(k).each\
    \ do |i|\n    sum += arr[i]\n  end\n  sum\nend", "  sum = 0\n  for i in (0..k).to_a\n\
    \    sum += arr[i]\n    \n  return sum\nend", "    first,rest = arr[0,k-1], arr[k,-1]\n\
    \    sum = first\n    for num in rest\n        sum += num if num < 10 else sum\
    \ + num - 9\n    return sum\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n\
    <| a |>\nMy version takes O(n) time and O(1) space using hash. O(n) space is achieved\
    \ by converting arr into binary number string and hash each digit. O(n) time is\
    \ achieved by converting arr into binary number and add each binary digit to result.\n\
    <code>", "  return arr.reduce(:+) if k > arr.size else arr[k..].inject(:+).to_i\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays dscore=0 |>\n<code>\n\
    arr = [111,21,3,4000,5,6,7,8,9]\nk = 4\nresult = []\narr.each_with_index do |e,\
    \ i| \n  result << ((i < (arr.size-k))? arr[i]: arr[i+1]) \nend\nresult.count{\
    \ |i| i.to_s.size < k }.to_i\n</code>\n<|/ a |>\n<| c |>\nThis solution fails\
    \ when the size of the array is less than `k`.\n<|/ c |>\n<| c |>\n, you're right,\
    \ just fixed that. Thanks!\n<|/ c |>\n<| a dscore=0 |>\n<code>\narr = [111,21,3,4000,5,6,7,8,9]\n\
    n = 4\narr.each_cons(n).reduce(0) { |acc, x| acc + x }", "  result = 0\n  arr.each\
    \ do |x|\n    result += (x / 10) + (x / 100) + (x / 1000) + (x / 10000)\n  end\n\
    \  result\nend\n</cell>\n<cell>\narr = [111,21,3,4000,5,6,7,8,9]\nadd_elements(arr,\
    \ 4)\n</cell>\n<cell>", "    arr.each do |element|\n        if element > 9 ^ 2\n\
    \            puts element if element % 10 + element % 10 <= k\n        end\n \
    \   end\nend\n</code>\n<|/ a tags=ruby,arrays dscore=1 |>\n<| c |>\nWhat is `9\
    \ ^ 2` supposed to mean?\n<|/ c |>\n<| c |>\n`9 ^ 2` means `9 to the power of\
    \ 2`. So for instance `9 ^ 2 = 32768`\n<|/ c |>\n<| c |>\nThe `^` operator is\
    \ bitwise XOR.\n<|/ c |>\n<| c |>\nThis doesn't work for numbers > 1000\n<|/ c\
    \ |>\n<| c |>\nMy bad, I had a typo in there. Updated now.\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby,arrays |>\n<code>", "    sum = 0\n    i = 0\n    while i < k\n   \
    \     sum += arr[i]\n        if sum > 999\n            sum -= 999\n        i +=\
    \ 1\n    return sum\nend\n</cell>\n<code language=julia-0.6>\nfunction add_elements(arr,k)\n\
    \    sum = 0\n    sum = 0\n    i = 0\n    while i < k\n        sum += arr[i]\n\
    \        if sum > 999\n            sum -= 999\n        i += 1\n    return sum\n\
    end\n</cell>\n<code language=julia-0.6>\nadd_elements([111,21,3,4000,5,6,7,8,9],4)\n\
    </cell>\n<code language=julia-0.6>\n@time add_elements([111,21,3,4000,5,6,7,8,9],4);\n\
    </cell>\n<code language=julia-0.6>\n@time add_elements(randn(10000), 10);\n</cell>\n\
    <code language=julia-0.6>\n@time add_elements(randn(10000), 10);\n</cell>\n<code\
    \ language=julia-0.6>\n@time add_elements(randn(10000), 10);\n</cell>\n<code language=julia-0.6>\n\
    @time add_elements(randn(10000), 10);\n</cell>\n<code language=julia-0.6>\n@time\
    \ add_elements(randn(10000), 10);\n</cell>\n<code language=julia-0.6>\n@time add_elements(randn(10000),\
    \ 10);\n</cell>\n<code language=julia-0.6>\n@time add_elements(randn(10000), 10);\n\
    </cell>\n<code language=julia-0.6>\n@time add_elements(randn(10000), 10);\n</cell>\n\
    <code language=julia-0.6>\n@time add_elements(randn(10000), 10);\n</cell>\n<code\
    \ language=julia-0.6>\n@time add_elements(randn(10000), 10);\n</cell>\n<code language=julia-0.6>\n\
    @time add_elements(randn(10000), 10);\n</cell>\n<code language=julia-0.6>\n@time\
    \ add_elements(randn(10000), 10);\n</cell>\n<code language=julia-0.6>\n@time add_elements(randn(10000),\
    \ 10);\n</cell>\n<code language=julia-0.6>\n@time add_elements(randn(10000), 10);\n\
    </cell>\n<code language=julia-0.6>\n@time add_elements(randn(10000), 10);\n</cell>\n\
    <code language=julia-0.6>\n@time add_elements(randn(10000), 10);\n</cell>\n<code\
    \ language=julia-0.6>\n@time add_elements(randn(10000), 10);\n</cell>\n<code language=julia-0.6>",
  "  sum = 0 \n  for i in 0...k\n    if arr[i] > 9999\n      sum += arr[i] - 10000\n\
    \    else\n      sum += arr[i]\n  end\n  return sum\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby,arrays,ruby-on-rails |>\n<| a dscore=0 |>\n<code>", "  arr.each do\
    \ |el|\n    sum = 0\n    if k > 0\n      while k >= 2\n        sum += el\n   \
    \     k -= 2\n      end\n      sum += el\n      k -= 2\n    end\n    sum\n  end\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| a dscore=0 |>\n<code>\narr.map {|el|\
    \ el > 9 ? el % 9 : el }.inject(:+).div(9) # => 24\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nThis works very well for non-negative integers. However, it will not\
    \ work for negative integers.\n<|/ c |>\n<| c |>\n, negative integers will be\
    \ processed correctly too: `-9 => -9` and `-10 => -10` since `(-9) % 9 == -9`,\
    \ `(-10) % 9 == -10`.\n<|/ c |>\n<| a tags=ruby |>\n<code>\narr.map(&:to_s).join.scan(/\\\
    d{2}/).reduce(:+)\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nYou can use this:\n\
    <code>\narr.map { |x| x > 9 ? x.modulo(9) : x }.inject(&:+).div(9)\n</code>\n\
    <|/ a tags=ruby |>\n<| a dscore=0 tags=ruby |>\nIn a way similar to another answer,\
    \ but the idea is to use Array#sum:\n<code>\narr.sum(&:to_i).div(9)\n</code>\n\
    <|/ a |>\n<| c |>\nWhat is the difference between `sum` and `inject`?\n<|/ c |>\n\
    <| c |>\n`inject` will add the values while `sum` will add the values per each\
    \ item. In the case of `inject` the total will be the result of the last operation\
    \ and will start with the first item. For instance if you have an array `[1,2,3]`\
    \ and `inject` you get `1` but the `sum` will be `1 + 2 + 3` which is `6`.\n<|/\
    \ c |>\n<| c |>\n`sum` returns a single number. `inject` returns an array of numbers.\
    \ So in other words `sum` will return the sum of all the items in the array while\
    \ `inject` will return the result of adding the first number to the result of\
    \ the next item, etc.\n<|/ c |>\n<| c |>\nThe difference is that `sum` will sum\
    \ all the items in the array and `inject` will add all the items to the result\
    \ of the previous item.\n<|/ c |>\n<|", "  arr[0, k]\nend\n</code>\n<|/ a tags=ruby,arrays,string,sum,algorithm\
    \ dscore=0 |>\n<| a tags=ruby,arrays,string,sum,algorithm |>\n<code>\narr = [111,21,3,4000,5,6,7,8,9]",
  "  # write your code here\n  arr.each_with_index do |x,i|\n    arr[i] = x + arr[i-1]\
    \ if i >= k\n  end\n  return arr[0]\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    <code>", "  arr.sort.with_index do |elem, i|\n    arr[i-k-1] <= elem if elem <\
    \ 10\n    arr[i-k-1] > elem if elem > 10\n  end\n  arr[k-1]\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nYeah, I was thinking about the same solution but your\
    \ solution is more elegant and more efficient. Upvoted :) I was thinking about\
    \ using `with_index` but somehow missed your `arr[i-k-1] <= elem` condition. I'll\
    \ edit my answer accordingly.\n<|/ c |>\n<| c |>\nI didn't know that `sort` was\
    \ an Array#method. Thanks for your explanation.\n<|/ c |>\n<| a tags=arrays,ruby\
    \ dscore=0 |>\nHere's a solution using inject to compute the sum of the elements\
    \ with at most two digits from the first k elements of the array. The result is\
    \ the sum of all elements with at most two digits from the first k elements of\
    \ the array, and the last element can be computed using Array#last and Array#length.\
    \ \n<code>", "    sum = 0\n    for i in (0..k-1)\n        sum += arr[i]\n    \
    \    sum += arr[i+1]\n    return sum\nend", "  sum = arr[0] * 0\n  i = 0\n  while\
    \ i < k\n    sum += arr[i]\n    i += 1\n  end\n  return sum.to_i\nend", "  arr.sort.with_index\
    \ do |x,i| \n    if i > k \n      break \n    else \n      sum += x \n    end\
    \ \n  end \nend\n</cell>\n<cell>\narr = [111,21,3,4000,5,6,7,8,9]\nk = 3\n</cell>\n\
    <cell>", end, "  # Your code here\nend", "  result = 0\n  arr.each do |i|\n  \
    \  if i.to_s.length <= k\n      result += i\n    else\n      result -= arr[k-i.to_s.length]\n\
    \      arr[k-i.to_s.length] = i\n      break\n    end\n  end\n  result\nend\n\
    </code>\nAnd my solution looks like this\n<code>", "  sum = 0\n  arr.each do |x|\n\
    \    sum += x if x.to_s.size < k\n  end\n  sum\nend", "  return arr.combination(k).reduce(:+)\n\
    end\n</cell>\n<cell>\n@test add_elements([[3,5], [3,7,2,5], [7,3,5,3], [1,7,2,3,5,6],\
    \ 3], 2) == 18\n</cell>\n<text>\nProblem 2\nGiven a binary tree and a sum, determine\
    \ if the tree has a root-to-leaf path such that adding up all the values along\
    \ the path equals the given sum. \nFor example, given the following binary tree\
    \ and sum = 22: \n      5\n     / \\\n    4   8\n   /   / \\\n  11  13  4\nThe\
    \ root-to-leaf path [5,8,11,13] has a root-to-leaf path Sum 22 = 65 = 25. \nWrite\
    \ a function:", "  arr.slice!(0...k)\n  arr.uniq!\n  arr.sort!\n  sum = 0\n  arr.each_with_index\
    \ do |value, index|\n    if value.length <= 2\n      sum += value\n    end\n \
    \ end\n  return sum\nend", "  sum = 0 \n  for i in (0..k-1)\n    sum += arr[i]\n\
    \  end\n  sum\nend", "  # write your code here\n  sum = 0 \n  for i in 1..k\n\
    \    sum += arr[i-1]\n  end\n  return sum\nend", "  return arr.reduce(0) {|sum,\
    \ e| sum + e + arr[k - e - 1]}\nend\n</cell>\n<code language=ruby-1.9.3-p44>",
  "  arr.each_with_index do |x,i|\n    arr.slice!(i..i+k)\n  end\n  arr.sort!\n  arr.inject(0)\
    \ { |sum,i| sum + arr[i] }\nend", "  # write your code here\n  return 0\nend",
  "  arr.sort.each_with_index do |el, index|\n    sum = sum + el if index >= k\n \
    \ end\n  sum\nend\n</cell>\n<text>\nAdd Two Numbers", "  arr.each_with_index do\
    \ |x, i|\n    j = i+k-1\n    if j <= arr.length && arr[j].to_s.size<=2\n     \
    \ sum = (arr[j].to_s.size + arr[j-1].to_s.size + arr[i].to_s.size).to_i\n    \
    \  arr[j] = sum\n    end\n  end\n  arr\nend\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nThe below solution works only with positive integers only, and also will\
    \ run faster:\n<code>", "    max = 999999999999999\n    ans = [0] * (k+1)\n  \
    \  for i in 1...k\n        ans[i] = max\n    end", "  arr.sort\n  sum = 0\n  for\
    \ i in (arr[k..-1] - arr[0..k])\n    sum += i\n  return sum\nend\n</code>\n<|/\
    \ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nHere's a way without using\
    \ any sorting. Not that it's efficient but easy to understand and to refactor\
    \ (if needed):\n<code>", "  sum = 0\n  arr.each_with_index do |i, index|\n   \
    \ next if index < k\n    sum += i\n  end\n  sum\nend", "  result = 0\n  arr.each_with_index\
    \ do |el, i|\n    if i < k - 1\n      result += el\n    end\n  end\n  result\n\
    end", "  ret = 0\n  arr.size.times do |i|\n    if i > (k - 1)\n      ret += arr[i-k+1]\n\
    \    end\n  end\n  ret\nend", "  arr = arr.sort\n  result = 0\n  result.concat(arr[0..k-1])\n\
    \  return arr.reduce(:+)\nend\n</code>\nI hope this helps\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\nA simple solution which makes use of #sum and #reduce\n<code>",
  "    # Write your code here\n    sum = 0\n    sum2 = 0\n    num = 0\n    for e in\
    \ arr\n        sum += e\n        num += 1\n    \n    arr.each_with_index { |element,\
    \ index|\n        if index > k\n            sum2 += element\n        end\n   \
    \ }\n    \n    if sum + sum2 > sum2\n        sum += sum2\n    end\n    \n    sum\n\
    end", "  result = 0\n  arr.each do |i|\n    if i.to_s.size == 2\n      result\
    \ += i\n    end\n  end\n  return result\nend", "  arr.sort.with_index { |e,i|\
    \ e = (e*9+i/9).to_i }\n  (0...k).inject(0) { |sum,i| sum + arr[i] }\nend", " \
    \   sum = arr[0]\n    index = 1\n    while index <= k\n        sum += arr[index]\n\
    \        index += 1\n    end", "  sum = 0\n  while k > 0\n    sum = sum + arr.pop(0)\n\
    \    k = k - 1\n  sum\nend", "  sum = 0\n  arr = arr.sort\n  arr.each_with_index\
    \ do |element, index|\n    if index <= k\n      sum += element\n    else\n   \
    \   sum -= element\n    end\n  end\n  sum\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| a tags=ruby dscore=0 |>\nI understand that you are looking for a single lined\
    \ solution for this kind of problem. Here is one way:\n<code>\narr = %w{111 21\
    \ 3 4000 5 6 7 8 9}\nk = 4\narr.chunk {|e| e}.take(k).inject {|t,f| t+f.reduce(0)\
    \ {|r,s| r+s}} # => 24\n</code>\nOr using a ternary operator:\n<code>\narr.chunk\
    \ {|e| e}.take(k).inject {|t,f| t+f.reduce(0) {|r,s| r+s if s<10}}\n</code>\n\
    <|/ a |>\n<| a |>\n<code>\narr = %w{111 21 3 4000 5 6 7 8 9}\nk= 4\narr.chunk{|x|\
    \ x.to_i}.reduce(0) {|s, x| s+x if x.to_i < k}\n</code>\n<|/ a tags=ruby dscore=0\
    \ |>\n<| c |>\nThis does not provide an answer to the question. To critique or\
    \ request clarification from an author, leave a comment below their post. - [From\
    \ Review](/review/low-quality-posts/16370073)\n<|/ c |>\n<| c |>\nThanks. I removed\
    \ the comment because I felt I deserved the downvote.  I do hope you understand.\n\
    <|/ c |>\n<| a |>\n<code>\narr = %w[111 21 3 4000 5 6 7 8 9]\nk= 4\narr.chunk\
    \ { |n| n.to_i }.select { |n, i| i < k }.sum { |n, i| n }", "  # Your code here\n\
    \  return arr[0] + arr[1] + arr[2] + arr[3] + arr[4]\nend", "  sum = 0\n  arr.sort_by!(&:to_i)\n\
    \  for i in 0..k\n    sum = sum + arr[i].to_i\n  end\n  sum\nend\n</code>\n<|/\
    \ a tags=ruby,arrays dscore=1 |>\n<| c |>\nThis is not the optimal solution, just\
    \ my take on it. It would be better to `sum.sort_by!(&:to_i)` before `sum.slice_when\
    \ { |a,b| a.to_i < b.to_i }`.\n<|/ c |>\n<| c |>\nI believe you're correct, although\
    \ I'd prefer `sum.sort_by!(&:to_i)` before `sum.slice_when`, since that gives\
    \ me control over the initial ordering.\n<|/ c |>\n<| c |>\nThanks. I edited my\
    \ answer, it may seem that way now, but I was referring to your first sentence\
    \ `The main problem is the sorting of the array which takes O(nlogn)`.\n<|/ c\
    \ |>\n<| a dscore=1 |>\nHere's another way:\n<code>", "  sum = 0\n  for i in (0..arr.length-1).step(k)\n\
    \    sum += arr[i]\n  end\n  return sum\nend\n</code>\nI tested the code with\
    \ sample inputs, but I didn't find a test case where it failed on edge case such\
    \ as when the k exceeds the array's length. The edge case is when k is 0. I don't\
    \ know the exact algorithm that determines if it's valid to reach k from the last\
    \ position. \nHope this helps.\n<|/ a tags=arrays,algorithm,ruby |>\n<| c |>\n\
    I think the problem was that if you had the array [111,21,3,4000,5,6,7,8,9] and\
    \ k=4, you would need to sum 1+1+1+1+1=6 and not 6.\n<|/ c |>\n<| c |>\n: Right.\
    \ I didn't notice that. I've updated my answer. Thanks for pointing out.\n<|/\
    \ c |>\n<| a tags=arrays,algorithm,ruby |>\nHere's a solution written in Ruby:\n\
    <code>", "  arr.map!{ |num| num.to_s(2) }\n  sum = 0\n  arr.each do |num|\n  \
    \  break if num.to_s.length < k\n    sum += num.to_i(10)\n  end\n  return sum\n\
    end", "  arr.each_with_index do |e, i|\n    return e if i==k\n    return e if\
    \ e<10 && e.to_s.size < 2\n  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\n\
    I think you only need to check the first k elements, then you need to sum up any\
    \ element that is smaller than 10 but have at least two digits.\n<code>\narr =\
    \ [111,21,3,4000,5,6,7,8,9]\nk = 3", "    sum = 0\n    arr.each_with_index do\
    \ |i, index|\n        if index >= k\n            break\n        end\n        sum\
    \ += i\n    end\n    return sum\nend\nadd_elements([111,21,3,4000,5,6,7,8,9],\
    \ 4)", "  sum = 0\n  arr.each do |x|\n    sum += x if x.to_s.length > k\n  end\n\
    \  sum\nend\n</code>\nAnd then\n<code>\narr = [111,21,3,4000,5,6,7,8,9] \nk =\
    \ 3\n</code>\ngives\n<code>\n k = 3", "  result = 0\n  arr.each do |x|\n    result\
    \ += x if x.to_s.length > k\n  end\n  result\nend", "  sum = 0\n  arr.each do\
    \ |num|\n    sum += num if num.to_s.split(\"\").length.between?(2, k)\n  end\n\
    \  sum\nend\n</cell>\n<cell>\nsolution = add_elements([111,21,3,4000,5,6,7,8,9],\
    \ 4)\nsolution\n</cell>\n<cell>\nsolution = add_elements(arr = [111,21,3,4000,5,6,7,8,9],\
    \ k = 4)\nsolution\n</cell>\n<text>\n4.5 Merge K Sorted Arrays\nYou are given\
    \ k sorted arrays of size n each. Merge k sorted arrays into a single sorted array.\
    \ The result array should be sorted in non-decreasing order. If k is greater than\
    \ n, then print 0 as the final result.", "  arr.sort!\n  return arr[k..-1].inject(0){|sum,e|\
    \ sum + e * 10 }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is not an answer\
    \ to the question. An answer should contain an explanation of your code and why\
    \ it does what it does.\n<|/ c |>\n<| c |>\nWhile this code snippet may solve\
    \ the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>\narray=[111,21,3,4000,5,6,7,8,9]",
  "  return arr.inject(0) { |sum, n| sum + n if n.to_s.length <= k }\nend", "  sum\
    \ = 0\n  for i in (1...k).to_a\n    sum += arr[i] if arr[i] % 10 > 1 \n  end\n\
    \  sum\nend", "  sum = 0\n  for i in range(k)\n    sum += arr[i]\n  sum -= arr[0]\n\
    \  sum -= arr[k-1]\n  sum -= arr[-1]\n  return sum\nend", "  arr.each do |x|\n\
    \    return x + arr[0] if x > 9\n  end\n  return 0\nend", "  sum = arr[0]\n  arr.shift\n\
    \  until arr.length == 0\n  sum -= arr[0]\n  arr.shift\n  until arr.length ==\
    \ 0\n  sum -= arr[0]\n  return sum + k*arr[0]\nend\n</code>\n<|/ a |>\n<| c |>\n\
    I like this one, but how would I extend it if I want to add up the elements with\
    \ no more than 2 digits? I edited my original post to show what I mean.\n<|/ c\
    \ |>\n<| c |>\nHow would you know if there are no elements with no more than two\
    \ digits?\n<|/ c |>\n<| c |>\nI added an update to the bottom of my original post\
    \ to show what I mean.\n<|/ c |>\n<| c |>\nHow would you know if there are elements\
    \ with no more than two digits?\n<|/ c |>\n<| c |>\nI mean how would you know\
    \ if an element in the array is less than 10 without iterating over every single\
    \ element and adding them up.\n<|/ c |>\n<| a |>\n<code>", "  ans = 0\n  arr.each\
    \ do |x|\n    if x >= 100 || x <= 100\n      ans += k\n      k -= 1 if k > 0\n\
    \    else\n      ans += (x - 10 if x > 10)\n    end\n  end\n  ans\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a dscore=2 |>\nA slightly more elegant way of doing it\
    \ :\n<code>", "  arr.sort.reverse\n  result = 0\n  for i in (0..k-1)\n    if arr[i]\
    \ % 10 > arr[i+1] % 10\n      result += (arr[i] + arr[i+1]) / 2\n    else\n  \
    \    result += arr[i]\n    end\n  end\n  result\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "    # sum = 0\n    # for i in arr[k..]\n   \
    \ sum = arr[k]\n    i = k\n    while i >= 1\n        sum += arr[i]\n        i\
    \ -= 1\n    return sum\nend\n</cell>\n<text>\n\uC0C1\uC218", "  arr.length >=\
    \ k and k > 0 and k * 2 <= arr.length\n  arr.map { |e| e > 10 ? (e % 10 + e) :\
    \ [e] }\n        .chunk {|e| e.length == k }\n        .map {|e,v| e + v.inject(:+)\
    \ }\n        .inject { |a,b| a + b }\nend\n</code>\n<|/ a tags=arrays,ruby dscore=0\
    \ |>\n<| c |>\nThis looks much cleaner than what I have currently. Could you explain\
    \ the purpose of the array mapping at the bottom of the function?\n<|/ c |>\n\
    <| c |>\nI added some explanation.\n<|/ c |>\n<| c |>\nThanks. Would you mind\
    \ explaining why this would be a better solution than what I have currently? I'm\
    \ really curious.\n<|/ c |>\n<| c |>\nThe code is cleaner, easier to understand,\
    \ and will likely perform better.  I also think the `chunk` method is more readable\
    \ than mine.  And `inject` is an underutilized method.  In addition I think `chunk`\
    \ is more readable than `slice_when` IMO.\n<|/ c |>\n<| c |>\nI like that chunk_when\
    \ is more readable than slice_when. Thanks.\n<|/ c |>\n<| a dscore=0 tags=arrays,ruby\
    \ |>\nThe first two elements of the array must be less than 10. After that we\
    \ can have an array of two elements where the first element is the sum of all\
    \ the other elements.\n<code>", "  arr[k] + (arr[k-1].to_s.chars.reduce(:+) if\
    \ arr[k-1].to_s.chars.size > 1 )\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI\
    \ like this one, but it doesn't work when k is bigger than the size of arr. E.g.\
    \ if k = 100, and arr = [111,21,3,4000,5,6,7,8,9], then the output is still 100.\
    \ Should be 24.\n<|/ c |>\n<| c |>\nI misunderstood the question. I thought the\
    \ constraint was `1 <= k <= len(arr)`. I'll update the solution.\n<|/ c |>\n<|\
    \ a |>\nHere's another one:\n<code>", "  if arr.nil?\n    return 0\n  elsif arr.length\
    \ < k\n    return 0\n  elsif k == arr.length\n    return arr[0]\n  elsif arr.length\
    \ >= k\n    temp = 0\n    arr.each_with_index do |n, i|\n      if i <= k - 2\n\
    \        temp += n\n      end\n    end\n    return temp\n  end\nend", "  sum =\
    \ 0\n  index = 0\n  while index < k\n    sum = sum + arr[index] unless arr[index]\
    \ < 10\n    index += 1\n  end\n  sum\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This was my initial thought to solve the problem, but it does not meet the requirements\
    \ of time complexity.  It is an O(n) algorithm, not O(1) like my solution.\n<|/\
    \ c |>\n<| c |>\nI think this one is O(n log n), but that would be only a benefit\
    \ if you had a much larger number and the biggest sum was the largest.\n<|/ c\
    \ |>\n<| c |>\nYou are correct, my solution did not meet time complexity requirements.\
    \ I changed my solution to use a variable number of digits and it does meet time\
    \ complexity requirements.\n<|/ c |>\n<| c |>\nThis doesn't meet time complexity\
    \ requirements.  See my explanation of my solution to understand.\n<|/ c |>\n\
    <| a |>\nThis solution does not meet time complexity requirements. My solution\
    \ is O(n) but it does not meet time complexity requirements.\n<code>", "  result\
    \ = 0\n  arr.each do |i|\n    if i.to_s.length <= k\n      result += i\n    end\n\
    \  end\n  result\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n<| a tags=algorithm,ruby\
    \ |>\n<code>", "  i = 0\n  total = 0\n  while i < k\n  begin\n    total += arr[i]\n\
    \    i += 1\n  end\n  i = 0\n  while i < k\n  begin\n    total -= arr[i]\n   \
    \ i += 1\n  end\n  return total\nend\n</code>\nHope this helps!!\n<|/ a |>\n<|\
    \ a |>\nThis problem can be solved without loops. We are only allowed to use loops\
    \ within functions.\n<code>", "  sum = 0\n  arr.each do |num|\n    sum += num\
    \ if num > 9\n  end\n  return sum if k == 0 || k > arr.size\n  add_elements(arr[k..-1],\
    \ k)\nend\n</code>\n<|/ a tags=arrays,ruby,algorithm |>\n<| c |>\nThanks for you\
    \ solution, but I needed a Ruby solution (I edited the question)\n<|/ c |>\n<|\
    \ c |>\nIt is not obvious to me why your solution passes all the test cases and\
    \ my solution does not. Your solution does not seem to use any Ruby features.\
    \ Moreover, your solution is more concise than mine, so you should accept it as\
    \ the answer. If not, I will delete this answer.\n<|/ c |>\n<| c |>\nThanks for\
    \ the answer but I need to find an algorithm solution and not a Ruby one (I edited\
    \ the question)\n<|/ c |>\n<| a tags=arrays,ruby,algorithm |>\nYou could do it\
    \ as follows:\n<code>", "  result = 0\n  arr.each { |item| result += item if item.to_s.length\
    \ <= k }\n  result\nend", "    sum = 0\n    arr.sort_by{|x| x.to_i}\n    for i\
    \ in 0...k\n        sum += arr[i].to_i\n    end\n    sum\nend", "  sum = 0\n \
    \ i = 0\n  while i < k\n    sum += arr[i]\n    i += 1\n  end\n  return sum\nend",
  "  # TODO: Your code here\n  if arr.nil? || arr.length == 0\n    return\n  end\n\
    \  if k < 0 || k >= arr.length\n    return\n  end\n  arr[k-1] = arr[k-1].to_s.to_i\n\
    \  return arr.reduce(0) { |sum, el| sum + el if el.length <= 2 }\nend", "    \n\
    end\n</code>\n<|/ a |>\n<| c |>\nThe question stated that the sum of first k elements.\
    \ So it must be k <= len(arr).\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  sum =\
    \ 0\n  for i in 1...k\n    sum += arr[i]\n  end\n  return sum\nend", "    \n \
    \   sum = 0\n    \n    for i in arr[k..-1]\n        sum += i\n    end\n    \n\
    \    sum\nend\n</cell>\n<text>\nIntersection", "  res = 0\n  for i in 1..k\n \
    \   sum = arr[i..i+2].reduce(:+)\n    res += sum\n  end\n  res\nend\n</cell>\n\
    <cell>", "  arr.each do |x|\n    sum = 0\n    (1..k).each do |y|\n      sum +=\
    \ x % 10\n      x = x // 10\n    end\n    return sum\n  end\nend", "  sum = 0\n\
    \  \n  if k <= 0 or k > arr.length\n    return 0\n  \n  arr.each_with_index do\
    \ |element, index|\n    sum = sum + element * (10 ** index)\n  end", "  # Your\
    \ code here\n  if k == 0 or k > arr.length then 0\n  else k == arr.length ? arr[k]\
    \ : arr[k] - arr[k-1]\nend", "  sum = arr[0]\n  arr.shift\n  arr[0..k-1].each\
    \ do |x|\n    sum+=x\n  end\n  return sum\nend", "  # write your code here\n \
    \ sum = 0\n  elements = arr.dup\n  (elements[0...k]).each do |x|\n    sum += x\n\
    \  end\n  sum\nend", "  arr.slice!(k, k+2)\n  arr.inject(0, :+) || -1\nend", " \
    \ i = 0\n  result = 0\n  while i < k do\n    result += arr[i]\n    i += 1\n  end\n\
    \  return result\nend", "  # write your code here\n  result = 0\n  i = 0\n  while\
    \ i < k do\n    result = result + arr[i]\n    i += 1\n  end\n  result\nend", " \
    \ sum = 0\n  arr.each do |n|\n    sum += n if n.to_s.size < k\n    sum -= n if\
    \ n.to_s.size == k\n    sum -= n if n.to_s.size > k\n  end\n  sum\nend\n</code>\n\
    <|/ a |>\n<| c |>\nYou rewrote his code to make the problem clearer, but you didn't\
    \ solve the problem. How do you know that this doesn't work?\n<|/ c |>\n<| a tags=algorithm,ruby\
    \ dscore=0 |>\nHere's a solution in Java, maybe it will give you some ideas\n\
    <code>\npublic static int twoDigSum (int[] arr, int k) {\n    int sum = 0;\n \
    \   for(int i = 0; i < arr.length; i++){\n        sum += arr[i] - Math.pow(10,\
    \ k - arr[i].toString().length());\n    }\n    return sum;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nI don't think this works. What is Math.pow(10, k - arr[i].toString().length())\
    \ ?\n<|/ c |>\n<| c |>\nMath.pow(10, k - arr[i].toString().length()) gives us\
    \ the power of ten that is equivalent to multiplying it by 10 to the power of\
    \ the difference of k and length of arr[i] (k - length of arr[i]) e.g. if arr[i]\
    \ has length 4 then the expression gives us 10 times 10 (100) which is 20. If\
    \ arr[i] has length 5 then it gives us 10 times 10 (1000) which is 400\n<|/ c\
    \ |>\n<| a |>\nI think this will be one of the solution\n<code>\nfunction twoDigitSum\
    \ (arr,k)\n sum = 0\n arr.each do |n| \n   sum+= n/Math.pow(10,k-1) if n/Math.pow(10,k-1)\
    \ > 0\n   sum-= n/Math.pow(10,k-1) if n/Math.pow(10,k-1) < 0 \n end\n return sum\n\
    end\n</code>\n<|/ a dscore=0 tags=algorithm,ruby |>\n<| a dscore=0 tags=algorithm,ruby\
    \ |>\nOne more in Ruby:\n<code>\narr = [\"111\", \"21\", \"3\", \"4000\", \"5\"\
    , \"6\", \"7\", \"8\", \"9\"]\nk = 3\narr.size.times.each {|i| arr[i] = arr[i].to_i\
    \ if arr[i].to_s.size <= k }\narr.size.times.each {|i| arr[i] = -arr[i] if arr[i].to_s.size\
    \ > k }\narr.sum\n</code>\n<|/ a |>\n<| a tags=algorithm,ruby |>\nHere's another\
    \ one in Ruby:\n<code>", "    count = 0\n    result = 0\n    for i in arr[k..-1]\n\
    \        result += i\n        count += 1\n        if count == 2\n            break\n\
    \    end \n    return result\nend", "  sum = 0\n  arr.each do |x|\n    sum +=\
    \ x if sum + x > (sum - x if sum >= x else sum + x)\n  end\n  return sum\nend",
  "    sum = 0\n    for el in arr[0..k]\n        sum += el if el.length <= 2 else\
    \ el.length\n    return sum\nend", "  total = 0\n  arr.each do |i|\n    if i <\
    \ 10\n      total += i\n      i += 1\n    else\n      current =  i - k + 1\n \
    \     while current <= i do\n        total += current\n        current += 1\n\
    \      end\n    end\n  end\n  return total\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This is not correct for an array with more than 1 element\n<|/ c |>\n<| c |>\n\
    It fails for an array of length 0 or 1.\n<|/ c |>\n<| c |>\nNo, it works. I've\
    \ just tested it.\n<|/ c |>\n<| c |>\nI apologize. I've just tested your solution.\
    \ It fails for an array with less than 1 element. I tested the array you provided\
    \ and it failed with a length of 1.\n<|/ c |>\n<| c |>\nYes, you are right. I've\
    \ fixed my answer. Thank you!\n<|/ c |>\n<| a dscore=0 |>\nHere is a more generic\
    \ solution:\n<code>", "  new_arr = []\n  index = 0\n  sum = 0\n  while index <\
    \ k\n    sum += arr[index]\n    new_arr << sum\n    sum %= 10\n    index += 1\n\
    \  end\n  if new_arr.length < k\n    sum -= arr[k..new_arr.length].inject(0){|s,\
    \ v| s + v}\n  end\n  sum\nend", "    sum = 0\n    arr.each_with_index do |value,\
    \ index|\n        if index <= k\n            sum += value\n        end\n    end\n\
    \    sum\nend\n</code>\n<code>", "    sum = 0\n    arr.each_with_index do |n,i|\n\
    \        sum += (n % 10) + (arr[i+1..-1].sum % 10) + arr[i+1..-1].sum\n    end\n\
    \    return sum\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nHere is another solution\
    \ from https://community.topcoder.com/stat?c=problem_statement&pm=23502&rd=9888\n\
    <code>\nimport java.util.*;\npublic class Kata\n{\n    static String toChars(String\
    \ s, int k) {\n        StringBuilder sb = new StringBuilder(s.length());\n   \
    \     for (int i = 0; i < s.length(); i++) {\n            if (i >= k) {\n    \
    \            sb.append(s.charAt(i));\n            }\n        }\n        return\
    \ sb.toString();\n    }", "  arr.each_with_index {|el, i|\n    if i <= k\n   \
    \   el\n    else\n      el - 2**(i+1) - 2**(i-1)\n    }\n  end\nend\n</code>\n\
    <|/ a |>\n<| a tags=arrays,ruby |>\n<code>\narr = [111,21,3,4000,5,6,7,8,9]\n\
    arr.each_with_index do |el, index|\n  el - 2**(index+1) - 2**index\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI guess you meant `el - 2**(index+1) - 2**index` instead\
    \ of `el - 2**(index+1)`, since you subtracted a power of 2 from `el` earlier.\n\
    <|/ c |>\n<| a tags=arrays,ruby dscore=2 |>\n<code>\n(1..100).to_a.each_with_object({})\
    \ do |num, memo|\n  memo[num.to_s.rjust(2,\"0\").to_i] = num.to_s.rjust(2,\"0\"\
    )\nend.values.inject(:+)\n</code>\n<|/ a |>\n<| a dscore=2 tags=arrays,ruby |>\n\
    Here's another way:\n<code>\n(1..100).inject(0) { |t,n| t + (2**(n.to_s.rjust(2,\"\
    0\").to_i)) - 2**(n.to_s.rjust(2,\"0\").to_i - 1)}\n</code>\n<|/ a |>\n<| c |>\n\
    Nice, but `n.to_s.rjust(2,\"0\")` is just `n.to_s.rjust(2,\"0\")` (no need for\
    \ `to_i` as `rjust` already returns an Integer).\n<|/ c |>\n<| a tags=arrays,ruby\
    \ |>\n<code>\narr = [111,21,3,4000,5,6,7,8,9]\narr.each_with_object([]) do |n,\
    \ acc| \n  n =~ /^0*[0-9]/ ? acc.push(n.to_i) : \n    (acc << n.to_i).last.inject(:+)\
    \ - 2**(acc.size + 1).to_i\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    <code>\narr = [111,21,3,4000,5,6,7,8,9]", "  sum = 0\n  for i in 0...k\n    sum\
    \ = sum + arr[i]\n    arr = arr[i + 1: len(arr)]\n  end\n  return sum\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby |>\n<| a |>\n<code>", "    sum = 0\n    return sum\n\
    end", "  sum = 0\n  n = arr.length\n  for i in 1..k\n    if arr[i] % 10 + arr[i-1]\
    \ % 10 <= 2 # if i-1 is in range\n      sum += arr[i]\n    end\n  end\n  return\
    \ sum\nend\n</code>\n<|/ a |>\n<| a tags=ruby,algorithm,ruby-on-rails |>\nHere's\
    \ a solution in ruby:\n<code>", "  sum = 0\n  arr.each do |num|\n    if num.to_s.length\
    \ <= k && num.to_s.split('').uniq.size == k\n      sum += num.to_i\n    end\n\
    \  end\n  return sum\nend", "    arr.size.times do |i|\n        if i < (arr.size\
    \ - k) && arr.at(i).to_i < 10\n            sum = 0\n            j = i\n      \
    \      while (j <= (arr.size - k)) && (arr.at(j).to_i >= 10)\n               \
    \ sum +=arr.at(j).to_i\n                j += 1\n            end\n            arr.at(i)\
    \ = sum\n        end\n    end\n    arr\nend", "  arr.each_with_index do |el, i|\n\
    \    if i == k - 1 then\n      arr[i] = (el / 100).floor * 100 + el % 100\n  \
    \  else\n      arr[i] = el\n    end\n  end\n  arr.sum\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby |>\n<code>", "  arr.slice!(0..k)\n  arr.sort!\n  sum = arr[0..k].inject\
    \ { |sum, n| sum + n }\nend", "  result = 0\n  result2 = k\n  for i in 0..k\n\
    \    result += (arr[i])\n    break if arr[i] == 0\n  end\n  for i in 0..k\n  \
    \  result2 += (arr[i+1])\n    break if arr[i+1] == 0\n  end\n  result += (arr[k])\n\
    \  result2 += (arr[k+1])\n  result += (arr[k+2])\n  result2 += (arr[k+3])\n  return\
    \ result+result2\nend", "  return arr.sum - 2 * arr.slice_up(k).sum\nend", " \
    \ arr.each do |i|\n    if k == 0 #\n      sum\n      return\n    end\n    if i.to_s.length\
    \ >= 2 #\n      sum += i #\n      add_elements(arr[k..-1], k - 1) #\n    end\n\
    \  end\nend", "    sum = 0\n    (k-1).times { sum += arr.shift() }\n    sum.times\
    \ { sum += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times { sum\
    \ += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift\
    \ }\n    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift }\n\
    \    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times\
    \ { sum += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times { sum\
    \ += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift\
    \ }\n    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift }\n\
    \    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times\
    \ { sum += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times { sum\
    \ += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift\
    \ }\n    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift }\n\
    \    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times\
    \ { sum += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times { sum\
    \ += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift\
    \ }\n    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift }\n\
    \    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times\
    \ { sum += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times { sum\
    \ += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift\
    \ }\n    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift }\n\
    \    sum.times { sum += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times\
    \ { sum += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times { sum\
    \ += arr.shift }\n    sum.times { sum += arr.shift }\n    sum.times { sum += arr.",
  "  sum = 0\n  first_k = arr[0..k-1]\n  for i in first_k\n    sum += i\n  end\n \
    \ sum\nend", "  (0..(arr.length-1)).to_a.reverse.inject(0) { |total, index| total\
    \ + arr[index] if arr.size >= index + 1 && arr[index].length <= k }\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "    sum = 0\n    i = k\n    while\
    \ i < arr.length\n        sum += arr[i]\n        i += 1\n    end\n    return sum\n\
    end", "    arr.each do |x|\n        sum = 0\n        while(x % 10 == 0)\n    \
    \        sum += x\n            x /= 10\n        end\n        if(sum <= k)\n  \
    \          return sum\n        end\n    end\nend", "  n = arr.length\n  max_len\
    \ = k\n  sum = 0\n  for i in 0...k\n    sum += arr[i]\n  end\n  sum -= (max_len\
    \ - 1) * arr.first(k).last(max_len + 1 - k)\n  sum\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 tags=ruby |>\n<code>", "    # Your code here\n    return 0\n\
    end", "    total = total = 0\n    for num in arr\n        if total + num < 10\n\
    \            total += num\n        else\n            total += 10\n           \
    \ total += num\n            total = 10 - total\n            total += num\n   \
    \         total = 10 - total\n            total += num\n            break\n  \
    \  end\n    total\nend\nadd_elements([111,21,3,4000,5,6,7,8,9], 4)\n</code>\n\
    <|/ a |>\n<| c |>\nIt would be much simpler to use `if total + num < 10` than\
    \ to reset `total` every time you get to the else clause.  It would be simpler\
    \ to use `total = total + num` than `total += num` and it would be simpler to\
    \ use `return total` than `return nil`.\n<|/ c |>\n<| c |>\nyeah, I just realized\
    \ that and fixed the code.\n<|/ c |>\n<| c |>\nI wouldn't consider this a good\
    \ approach as it assumes a sorted array. Even if there are not duplicates, this\
    \ doesn't take advantage of it being sorted. Since it's a challenge, I guess I\
    \ shouldn't bother trying to get it right and let others find it for themselves.\
    \ :P\n<|/ c |>\n<| a tags=ruby,algorithm,arrays,math dscore=0 |>\nI know this\
    \ is an old question and you have already accepted an answer, but here is a solution\
    \ that is more Ruby-like. \nThe method below takes in an array of strings and\
    \ an integer k and returns the sum of the two digits from the first k elements.\
    \ \n<code>", "    sum_ = 0\n    sum_2 = sum_\n    i = 0\n    while i < k\n   \
    \     i += 1\n        sum_ += arr[i]\n        sum_2 += arr[i]\n    end\n    sum_\
    \ = sum_ - sum_2 * 10\n    sum_ /= 10\n    return sum_\nend\n</cell>\n<code language=julia-1.5>\n\
    add_elements(arr, k)\n</cell>\n<text>\nProblem 4", "  sum = 0\n  i = 0\n  while\
    \ i < k\n    sum = sum + arr[i]\n    i += 1\n  end\n  return sum\nend", "  if\
    \ k >= len(arr) then return 0\n  if k == 0 then return arr[0]\n  sum = 0\n  i\
    \ = k\n  while i < len(arr) and sum < 90000000000 do\n    sum = sum + arr[i]\n\
    \    i += 1\n  end\n  return sum\nend", "  sum = 0\n  arr.each do |el|\n    if\
    \ k <= 2\n      sum += el\n      k += 1\n    else\n      k = k - 1\n      sum\
    \ += el\n    end\n  end\n  return sum\nend", "  # Your code here\n  sum = 0\n\
    \  i = 0\n  while i < k\n    sum += arr[i]\n    i += 1\n  end\n  return sum\n\
    end", "  sum = 0\n  size = k\n  first_k_index = k - 1\n  last_k_index = (arr[-1]).to_s.size",
  "  a = arr[0...k].sum\n  b = arr[k+1..-1].sum\n  return a+b\nend", "  arr.each_with_index\
    \ do |e, i|\n    if i >= k\n      break\n    end\n    sum += e\n  end\n  sum\n\
    end", "  arr.each do |e|\n    break e if e.to_s.length <= k\n  end\n  return e\
    \ + arr[k + (k-1)]\nend\n</cell>\n<text>\nGiven an array A of positive integers,\
    \ return a new array with the largest elements from\nthe original array appended\
    \ in increasing order.", end, "  sum = 0\n  arr.each_with_index do |v,i|\n   \
    \ if i.to_i < k\n      sum += v\n      next if sum >= 10\n    end\n    if i.to_i\
    \ >= k\n      break\n    end\n  end\n  sum\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=1 |>\n<| a dscore=0 |>\n<code>", "  arr.slice_from(k)\nend\n</cell>\n\
    <cell>\nadd_elements([1,2,3], 2)\n</cell>\n<text>\n5 - Set and List", "  # initalize\
    \ sum to 0\n  sum = 0", "  # Your code here\n  sum = 0\n  max_val = arr[0]\n \
    \ for i in 1..k\n    sum += arr[i]\n  end\n  return sum\nend", "    arr = arr.sort\n\
    \    return arr[k] + arr[k + 1] if k + 1 < arr.length else arr[0] + arr[1]\nend",
  "  return nil\nend", "  arr.sort\n  i = 0\n  s = 0\n  while i < k\n    s += arr[i]\n\
    \    i += 1\n  end\n  s\nend", "  sum = 0\n  arr.each do |i|\n    sum -= i if\
    \ i.to_s.size <= k \n    sum += i if i.to_s.size == k\n  end\n  sum\nend\n</code>\n\
    The solution is in Ruby 3.0.2\n<|/ a tags=algorithm dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\npublic static int findMaxSumSubsets(int[] arr, int k) {\n    int\
    \ sum = 0, max = 0, sumWithTwoDigits = 0;\n    for (int i : arr) {\n        sum\
    \ += i;\n        if (sum > max) {\n            max = sum;\n            sumWithTwoDigits\
    \ = sum;\n        } else if (sum + 10 > max) {\n            sumWithTwoDigits +=\
    \ sum;\n            max = sum + 10;\n        }\n    }\n    k = max / 10 + ((max\
    \ % 10 == 0) ? 0 : 1);\n    for (int i = 0; i < k; i++) {\n        if (sumWithTwoDigits\
    \ - i * 10 >= k * i) {\n            return sumWithTwoDigits - i * 10;\n      \
    \  }\n    }\n    return k * k * sum;\n}\n</code>\n<|/ a tags=algorithm |>\n<|\
    \ c |>\nThis fails if k == 1 and arr has only one element.\n<|/ c |>\n<| c |>\n\
    This is basically a brute force solution. I wonder how long it would take to find\
    \ an optimal solution.\n<|/ c |>\n<| c |>\nOh yes, you're right. Thanks for pointing\
    \ out. I'll edit my answer.\n<|/ c |>\n<| a dscore=0 |>\nWe can solve it by using\
    \ dynamic programming\n<code>\nfunction findMaxSumSubsets(arr, k) {\n    var sum\
    \ = 0;\n    var sumWithTwoDigits = 0;", "    # Write your code here.\n    sum\
    \ = 0\n    start = k\n    end = arr.length\n    while start <= end\n        sum\
    \ = sum + arr[start]\n        start += 1\n    end\n    sum <= sum + arr[end]\n\
    \    return sum", "  total = 0\n  for i in 0..(arr.size - k).to_a\n    total +=\
    \ arr[i..(i + k - 1).to_a].sum\n  end\n  total\nend", "  result = arr[0]\n  for\
    \ i in 1..k-1\n    result += arr[i]\n  end\n  result\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis code doesn't work properly. Look at the example I added in\
    \ the question.\n<|/ c |>\n<| c |>\nWhat if k is higher than the length of arr?\n\
    <|/ c |>\n<| c |>\nThat case would break the algorithm. Look at the example in\
    \ the question.\n<|/ c |>\n<| c |>\nYes, I edited the code with some extra constraints\
    \ so it will work for all cases. :)\n<|/ c |>\n<| c |>\nThis still doesn't work\
    \ for every test case. I updated my question with a test case and output example.\n\
    <|/ c |>\n<| a |>\nI wrote it in a very short time by only using a single variable\
    \ and no loops.\n<code>", "  sum = 0\n  arr.each do |i|\n    while k > 0\n   \
    \   sum += i\n      k -= 1\n    end\n  end\n  sum\nend", "    sum = 0\n    (1..k).each\
    \ do |i|\n        sum += arr[i]\n    end\n    return sum\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nCould you please explain why this code is more \"pythonic\"\
    \ than the other answers?\n<|/ c |>\n<| c |>\nI find them very easy to read, especially\
    \ for someone who hasn't done much Ruby. But I would have thought the accepted\
    \ answer should be the one that says \"rubyists won't be surprised by that\",\
    \ since a lot of rubyists don't do Ruby :)\n<|/ c |>\n<| c |>\nThis doesn't work.\
    \ It doesn't work for input `arr = [111, 21, 3, 4000, 5, 6, 7, 8, 9]` and `k =\
    \ 4`\n<|/ c |>\n<| c |>\nThe accepted answer is incorrect. I've tested it with\
    \ all valid inputs.\n<|/ c |>\n<| c |>\nIf your array is large and you need the\
    \ most optimal solution, my solution would be to sort it (O(n log n) time). Then\
    \ for each index `i`, you can just do `arr[k-i-1]` and add that to the sum.\n\
    <|/ c |>\n<| a tags=ruby,python,algorithm |>\nA Ruby implementation of this problem\
    \ which also works with an input array that has more than 10 entries:\n<code>",
  "  arr.map do |el|\n    el = el.to_i # convert el to int\n    el <= 99 and el +\
    \ el.odd? # el with two digits\n  end\n  arr[k].to_i + arr[k].odd?\nend\n</code>\n\
    <|/ a |>\n<| c |>\nNice. Even if I hadn't used the map method, that would be very\
    \ helpful. Thanks!\n<|/ c |>\n<| c |>\nYou don't need the `map` method - you just\
    \ need the filter.  You can also shorten that to `arr.max() - arr.min() + 1`.\n\
    <|/ c |>\n<| a dscore=2 |>\nTo get the sum, use Ruby's inject method:\n<code>\n\
    arr = [111,21,3,4000,5,6,7,8,9] # => [111, 21, 3, 4000, 5, 6, 7, 8, 9]\narr.inject(0)\
    \ { |sum, e| sum + e if e % 10 == 0 } # => 24\n</code>\nIf you're unfamiliar with\
    \ inject and lambda, check out this article on Ruby lambdas. Inject is a method\
    \ in the Enumerable module that iterates over every element in a collection and\
    \ applies the passed block once to the element and every following element. In\
    \ the block, we are simply summing the elements that are divisible by 10, then\
    \ adding the original element to the sum (if it's not divisible by 10).\n<|/ a\
    \ tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\n<code>\narr = [111,21,3,4000,5,6,7,8,9]\n\
    arr.select {|x| x % 10 == 0}.reduce(:+)\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ tags=ruby,arrays |>\n<code>", "  # sum = 0\n  # for i in 0..k-1\n  #   sum +=\
    \ arr[i]\n  #   if sum > 1000\n  #      return sum\n  # return sum", "    sum\
    \ = 0\n    if k <= 0 or k > len(arr)\n        raise ArgumentError.new(\"Invalid\
    \ k\")\n    \n    arr = arr[k..-1] ", "  sum_so_far = arr[0]\n  sum_of_first_k\
    \ = arr[0...k]\n  last_digit = 1\n  arr.each do |x|\n    if x.to_s.length <= last_digit\n\
    \      sum_of_first_k << last_digit\n      last_digit = 0\n    elsif x.to_s.length\
    \ >= last_digit + 1\n      sum_of_first_k << x.to_s[last_digit]\n      last_digit\
    \ = x.to_s.length - 1\n    else\n      sum_of_first_k << x.to_s[last_digit - 1]\n\
    \      last_digit = x.to_s.length - 2\n    end\n    sum_of_first_k = sum_of_first_k.sum\n\
    \    sum_so_far += sum_of_first_k\n  end\n  return sum_so_far\nend", "  arr.map\
    \ {|x| x.to_s.split(//).first(k)}\n  .flatten.inject {|t,x| t+x} \nend", "  sum\
    \ = 0\n  arr.each do |x|\n    sum += x if x > 0 and (x % 10) <= k\n  end\n  return\
    \ sum\nend", "  # write your code here\n  return arr\nend", "  result = 0.0;\n\
    \  arr.each do |x|\n    sum = x;\n    sum.to_s.each_char {|c| sum += c}\n    result\
    \ += sum - k;\n    break if result > 9\n  end\n  return result\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby,dynamic-programming,algorithm |>\nI came up\
    \ with a way that does not use any loops and does not use any addition or multiplication.\
    \ I use the fact that for addition xy + z == x + y + z, which makes it easy to\
    \ identify the parts of the number in which the sum is less than or equal to 10\
    \ (i.e. the part that does not have the first two digits of the number). Then\
    \ I can just sum the digits as normal and sum the first two digits from those\
    \ parts that need it.\n<code>", "  n = arr.size\n  sum = arr[0]\n  for i in (1..n-1)\n\
    \    sum = (sum * 10) + arr[i]\n  end\n  sum.to_i(2)\nend\n</pre>", "    sum_of_elements\
    \ = 0\n    arr.each_index do |i|\n        if sum_of_elements == 0 || (sum_of_elements\
    \ + (arr[i] - i) % 10) <= sum_of_elements\n            sum_of_elements += (arr[i]\
    \ - i) % 10\n        end\n    end\n    sum_of_elements < 10 ? 10 : sum_of_elements\n\
    end", "  sum = 0\n  for i in 1..k\n    sum = sum + arr[i]\n  end\n  return sum\n\
    end", "    sum = 0\n    if k == 1 and arr[0] != nil\n        sum += arr[0]\n \
    \   elsif arr[0] < 1000\n        sum += arr[0]\n        arr.shift\n    else\n\
    \        arr.shift\n        sum += arr[0]\n        arr.shift\n    end\n    while\
    \ arr.size > 0\n        sum += arr.pop\n    end\n    return sum\nend\n</code>\n\
    <|/ a |>\n<| c |>\nWhy do you assume that the first element is a number? What\
    \ if it's not an integer, but a string, like \"A\"?\n<|/ c |>\n<| a |>\nJust to\
    \ complement the other answers here with more explanation.\nHere's a Ruby solution\
    \ to your problem:\n<code>", "  arr.each_with_index { |e, i| arr[i] = e if i >\
    \ k }\n  arr.sum\nend", "  arr.reduce(:+)\nend", "  sum = 0\n  i = 0\n  while\
    \ (i < k) and (arr[i] < 10)\n    i += 1\n  arr.slice!(i)\n  i += 2\n  while i\
    \ < k\n    sum += arr[i]\n    i += 1\n    break if sum < sum + arr[i]\n  end\n\
    \  return sum\nend", "  sum = 0\n  i = 0\n  while i < k\n    sum = sum + arr[i]\n\
    \    i = i + 1\n    break if sum > 1000\n    sum = sum + arr[i]\n    i = i + 1\n\
    \  end\n  return sum\nend", "    arr.each do |i|\n      arr.each_index do |j|\n\
    \        if j+1 < k && arr[j] == arr[j+1]\n          arr[j] = arr[j]+arr[j+1]\n\
    \          arr.delete_at(j+1)\n          break\n        end\n      end\n    end\n\
    \    arr.max\nend", "    arr.size.times do |i|\n        if arr[i] > 99\n     \
    \       return arr[i]\n        end\n    end\n    return arr[0]\nend", "    sum\
    \ = 0\n    arr.each do |i|\n        sum += i if i.to_s.length <= 2\n    end\n\
    \    sum\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nYour method is very\
    \ inefficient and needlessly complex. Besides, it's not Ruby-like (no `map` for\
    \ example) and it doesn't solve the problem of only having access to `k`. Please\
    \ see my answer, where I give an example where it can be done in O(n).\n<|/ c\
    \ |>\n<| c |>\nYour solution doesn't return the correct result. For example, if\
    \ the input is `arr = [111,21,3,4000,5,6,7,8,9]` and k is set to `10`, you get\
    \ `22` as the result. Moreover, `map` should be avoided in Ruby, and should be\
    \ replaced by `each`.\n<|/ c |>\n<| c |>\nAlso, if you don't want to copy the\
    \ array: `arr.each_index.with_object(0..k).map { |i,o| arr[i] + o }.reduce(:+)`\n\
    <|/ c |>\n<| a tags=ruby |>\nHere is an O(n) solution which does not require any\
    \ extra memory:\n<code>", "    total = 0\n    for i in 0...k\n        total +=\
    \ arr[i]\n    end\n    total\nend", "  arr.sort.reverse\n  (0..k).each do |i|\n\
    \    arr[i] if arr[i] <= arr[i+1]\n  end\n  return arr[0..k].inject(:+)\nend\n\
    </code>\n<|/ a |>\n<| c |>\nVery elegant solution. I would just add `break if\
    \ k == arr.length-1` to the bottom of the method. This way you don't need to reverse\
    \ the array first. Also, I'd suggest replacing `arr[i] if arr[i] <= arr[i+1]`\
    \ with `arr[i-1] if arr[i-1] <= arr[i]`, since the first and last elements are\
    \ already sorted.\n<|/ c |>\n<| c |>\nThe break will prevent the code from returning\
    \ the first k elements only, but won't prevent the code from returning any element\
    \ in the range 0 to k - 1. To make it fully correct you'd need to add `if k <\
    \ arr.length-1` to the break. Anyway I suggest to replace it by `arr[i-1] if arr[i-1]\
    \ <= arr[i]` to avoid the extra reversing of arrays.\n<|/ c |>\n<| c |>\nYou're\
    \ right. I misread the requirements.\n<|/ c |>\n<| a dscore=2 tags=arrays,ruby\
    \ |>\n<code>\narr = [111,21,3,4000,5,6,7,8,9] #=> [111, 21, 3, 4000, 5, 6, 7,\
    \ 8, 9]\narr.sort.each_cons(3).select { |e| e.size <= 2 }.inject(:+)\n  #=> 24\n\
    </code>\nThe steps:\n<code>\ne = arr.sort\n  #=> [3, 4000, 5, 6, 4000, 4000, 7,\
    \ 8, 9] \nc = e.each_cons(3)\n  #=> #<Enumerator: #<Enumerator: [3, 4000, 5, 6,\
    \ 4000, 4000, 7, 8, 9]:each_cons(3)>:each_cons> \na = c.select { |e| e.size <=\
    \ 2 }\n  #=> #<Enumerator: #<Enumerator: #<Enumerator: [3, 4000, 5, 6, 4000, 4000,\
    \ 7, 8, 9]:each_cons(3)>:each_cons>:select> \na.inject(:+)\n  #=> 24\n</code>\n\
    <|/ a |>\n<| c |>\nThe OP asks for the sum of the elements with at most two digits\
    \ from the first k elements of arr. Your code returns sum of the first k elements.\n\
    <|/ c |>\n<| c |>\n, thanks. I misread the requirements.\n<|/ c |>\n<| a dscore=1\
    \ |>\nI find this solution the most Ruby-like:\n<code>", "  # write your code\
    \ here\n  sum = 0\n  for i in 0..(k-1)\n    if arr[i] >= 10 && arr[i] <= 99\n\
    \      sum += arr[i]\n    end\n  end\n  sum\nend", "  arr.reduce do |sum, number|\n\
    \    sum + number if number < 1000\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 |>\nUsing each_cons can make this easy.\n<code>", "  arr.sort\n \
    \ return arr[k..k+k].sum\nend", "    sum_arr = 0\n    for i in 0...k\n       \
    \ sum_arr += arr[i]\n    end\n    return sum_arr\nend", "  arr.sort\n  sum = 0\n\
    \  for i in 0..k\n    sum += arr[i] if i < k && arr[i] % 10 != 0 else arr[i]\n\
    \  end\n  sum\nend", "  return arr.max_by { |x| x.divmod(10).last }.sum\nend\n\
    </cell>\n<text>\nThe Problem\nThis algorithm is O(N*M).", "  count = 0\n  arr.each\
    \ do |n|\n    count += n\n    if count == 2\n      return count\n    end\n   \
    \ count = 0\n  end\n  0\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nHi Andrew,\
    \ your solution does not work for large inputs. I tested your solution for input\
    \ = [102, 103, 104, 105], k = 3, your solution returns 2 instead of 3, which means\
    \ it only checks the 1st 2 elements and sums them. The 3rd and 4th elements are\
    \ ignored and only 1 element is summed.\n<|/ c |>\n<| c |>\nHi Haoge, thanks for\
    \ the feedback. I realize my solution may not be the best for very large inputs,\
    \ but I wanted to post the solution that I came up with. It was an interesting\
    \ question and it made me think about this problem in different ways. I updated\
    \ my solution above to account for large inputs.\n<|/ c |>\n<| a dscore=0 |>\n\
    Here's another solution (same as the second one posted by Haoge):\n<code>", " \
    \   # Write your code here.\n    sum = 0\n    for i in 0..(k-1)\n        sum =\
    \ sum + arr[i]\n    end\n    return sum\nend\n</cell>\n<text>\n\_Solution Using\
    \ Sort\nWe can implement the above solution using a Ruby sort using a custom compare\
    \ function. Here is a solution that does this by storing the first k elements\
    \ of the array in a temporary array, then passing that array to the Ruby sort\
    \ method, and then returning the sum of the temporary array.", "  sum = 0\n  for\
    \ i in (0..k-1)\n    sum += arr[i]\n  return sum\nend", "  arr = arr + [0] * (100\
    \ - k)\n  sum = 0\n  \n  for i in 0..k-1\n    sum = sum + arr[i]\n  end\n  \n\
    \  return sum\nend", "  arr.each_with_index do |el, index|\n    sum ||= 0\n  \
    \  sum += (el % 10) + 10*((k-1)-index)\n  end\n  return sum\nend", "  sum = 0\n\
    \  arr.each do |i|\n    if i.to_s.length > 2\n      sum = sum + i.to_s[0...k]\n\
    \    end\n  end\n  sum.to_s\nend", "  result = nil\n  for i in 0..k-1\n    if\
    \ i == 0 or arr[i-1] > arr[i] \n      result = arr[i - 1] + arr[i]\n    end\n\
    \  end\n  result\nend", "  first = []\n  last = []\n  for i in 0...k-1\n    if\
    \ arr[i] > 100\n      last = arr[i]\n    else\n      first = arr[i]\n    end\n\
    \  end\n  \n  return first + last\nend", "    sum = 0\n    arr_set = arr.to_set\n\
    \    arr_set.pop(k - 1).each do |i|\n        sum += i\n    end\n    sum\nend",
  "  total = 0\n  index = 0\n  while index < k\n    if arr[index] >= 100\n      arr[index]\
    \ += 1\n    end \n    index+=1\n  end\n  index=0\n  while index < k\n    if arr[index]\
    \ >= 10\n      total += arr[index]\n    end \n    index+=1\n  end\n  total\nend",
  "  result = 0\n  arr.each_index do |i|\n    result += arr[i..k].sum.to_s\n    break\
    \ if result.to_s.length < 2\n  end\n  result\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\nI know this question has already an accepted answer, but I just wanted\
    \ to add some time complexity analysis points to the other answers, to see if\
    \ we can go further. \nThe accepted answer is clearly the most performant one:\
    \ it runs in O(n) time, and it is easy to understand and implement. \nHowever,\
    \ if we analyze the complexity of the inner loop, we see that it is indeed O(n).\
    \ Since this loop is run k times, it is equivalent to the following formula:\n\
    <code>\nO(1*3*..n*k) = O(n^k)\n</code>\nSo we can conclude that there exists a\
    \ constant k for the loop that is always equal to 1, and we can also conclude\
    \ that there is also a constant n (the length of the array).\nThis means that\
    \ we can conclude that the above loop has a complexity of O(n^k), which can be\
    \ simplified to: O(n^n). \nThis means that if we were to iterate over the array\
    \ for each element in the array, the complexity of the above algorithm would be\
    \ O(n^n), but if we were to iterate only once, the complexity would become O(n).\n\
    <|/ a tags=ruby dscore=2 |>\n<| a |>\n<code>\na = ['111', '21', '3', '4000', '5',\
    \ '6', '7', '8', '9']\na.select { |e| e.to_s.split('').size == 1 }.join('').to_i",
  "  arr.sort\n  sum = 0\n  while k > 0\n    sum = sum + arr[k-1] % 10 + arr[k-1]\
    \ / 10\n    k -= 1\n  return sum\nend", "  arr.sort\n  sum = arr[0] + arr[k-1]\n\
    \  for i in (1..k-1)\n    sum += arr[i]\n  end\n  sum\nend\n</code>\nThis has\
    \ complexity of O(n).\n<|/ a tags=algorithm,ruby,arrays |>\n<| a |>\nA simple\
    \ solution using Ruby would be the following:\n<code>\nrequire 'set'", "    arr.each_with_index\
    \ do |element, index|\n      sum = 0\n      sum << index if (index <= k) && (index\
    \ + k < arr.length)\n      sum += element if index + k <= arr.length\n    end\n\
    \    sum\n  end", "    arr.sort {|a,b| b <=> a }\n    sum = 0\n    i = 0\n   \
    \ while i < k and i < arr.size\n        sum += arr[i]\n        i += 1\n    end\n\
    \    return sum\nend", "  arr.slice!(k..-1) if arr.size < k # remove extra elements\n\
    \  arr.sort_by(&:it) rescue nil rescue Array.new(k,0) - arr # sort and subtract\
    \ arrays\n  arr + arr[-1] - arr.first(k) # remove duplicate elements\nend", " \
    \ arr[k..-1].inject(:+) # inject method takes an object and a block and returns\
    \ a new object based on the injection\nend", "  sum = arr[0]\n  for i in 1..k\n\
    \    sum = sum + arr[i]\n  end\n  return sum\nend", "  arr.sort\n  answer = 0\n\
    \  for i in 1..k\n    answer += arr[i..-1].first\n  end\n  answer\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis works.  However it also requires me to sort the\
    \ array and also use k in the sum.\n<|/ c |>\n<| c |>\n`sort arr` is O(nlogn)\
    \ where n is the size of the array. `k` would still be constant in the overall\
    \ complexity. Plus you could add some optimizations to `first` that you could\
    \ do in `add_elements`\n<|/ c |>\n<| c |>\nYour code is wrong. `add_elements([111,21,3,4000,5,6,7,8,9],\
    \ 4)` outputs 105.\n<|/ c |>\n<| c |>\nThe input was already sorted.\n<|/ c |>\n\
    <| c |>\nYou're right. Wasn't paying enough attention to what the constraints\
    \ were. I updated my answer. Thanks!\n<|/ c |>\n<| a dscore=2 |>\nHere's my version\n\
    <code>", "    sum = 0\n    arr = arr.sort\n    arr.each do |i|\n        if i.to_s.length\
    \ > 1\n            sum = sum + i\n        elsif i.to_s.length == 1\n         \
    \   sum = sum + i\n        elsif i > arr.length\n            break\n        end\n\
    \    end\n    return sum\nend", "    # Your code here\n    sum = 0\n    arr.each_with_index\
    \ do |x, index|\n        if index <= k\n            sum += x\n        else\n \
    \           sum += x - arr[index-1]\n        end\n    end\n    return sum\nend\n\
    </code>\n<|/ a tags=ruby,arrays,algorithm,sorting |>\n<| c |>\nThis solution is\
    \ incorrect. Try `arr = [111,21,3,4000,5,6,7,8,9], k = 4`. It should return 42\
    \ but your solution returns 24. Your solution is summing up `3` twice\n<|/ c |>\n\
    <| c |>\n, you are correct. I've updated the answer with a correction.\n<|/ c\
    \ |>\n<| c |>\nYour code still returns 24 as you still are summing up `3` twice.\
    \ `k` can be larger than the length of the array. Check `k = 11` in your example\n\
    <|/ c |>\n<| c |>\n, I don't think your comment is correct at all. I've added\
    \ a test case, and verified the results.\n<|/ c |>\n<| c |>\nI didnt say your\
    \ code was wrong. Your comment was incorrect since your current code returns `42`\
    \ for `[111,21,3,4000,5,6,7,8,9], k = 11`, your current solution returns `24`\
    \ for `[111,21,3,4000,5,6,7,8,9], k = 4`. Your current code actually returns `42`\
    \ for `[111,21,3,4000,5,6,7,8,9], k = 8`\n<|/ c |>\n<| a |>\nYou can do the following\
    \ using Enumerable#slice_when:\n<code>", "    # Your code here\n    return 0\n\
    end", "  return arr.sum { |x| x.divmod(10).last }.divmod(10).last\nend", "  count\
    \ = 0\n  arr.each do |el|\n    el = el if el >= 10**k\n    el = el.to_i\n    el\
    \ = el if el < 10**k\n    el = el - 10**k\n    count = el if count == 0\n    count\
    \ = el + count\n  end\n  count\nend", "    sum = 0\n    arr.each_with_index do\
    \ |value, i|\n        sum+=value if i<k\n    end\n    return sum\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  new_arr = arr.dup\n  sum_of_twos\
    \ = 0\n  while new_arr.size > 0 do\n    if new_arr.size >= k\n      sum_of_twos\
    \ += new_arr.first - k\n      new_arr.drop(k)\n    else\n      sum_of_twos +=\
    \ new_arr.first\n      new_arr.first = 0\n    end\n  end\n  sum_of_twos\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if array has duplicate\
    \ element.\n<|/ c |>\n<| a tags=ruby,arrays |>\nA ruby solution based on each_with_index\
    \ and enumerator:\n<code>", "  sum = 0\n  arr.each_with_index do |element, index|\n\
    \    if index >= k\n      sum += element\n    end\n  end\n  sum\nend", "  sum\
    \ = 0\n  i = k\n  while i <= arr.length\n    sum += arr[i]\n    i += 1\n  return\
    \ sum\nend", "  sum = 0\n  if k > 0\n    arr = arr[0...k]\n  until k == 0 do\n\
    \    sum = (arr[0] if arr.length > 0 else\n           arr.shift if arr.length\
    \ == 0 else\n           arr.shift) + sum\n  end\n  sum\nend", "  result = 0\n\
    \  for i in (1..k-1)\n    result += arr[i]\n  end\n  result += arr[k]\nend", " \
    \ sum = arr[0]\n  arr.shift\n  while arr.size > 0\n    sum += arr.pop\n  end\n\
    \  return sum\nend", "  arr.slice!(k..k+2)\n  arr.reduce(:+)\nend\n</code>\n<|/\
    \ a tags=ruby,arrays |>\n<| a tags=ruby,arrays dscore=0 |>\n<code>\narr = [111,21,3,4000,5,6,7,8,9]\n\
    arr.sort_by{ |num| num.to_s.split(\"-\").last }\n</code>\n<|/ a |>\n<| c |>\n\
    While this code snippet may solve the question, [including an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| a |>\n<code>\na = [111,21,3,4000,5,6,7,8,9]\n\
    p a.sort{|x,y| x.to_s.split('-')[-1] <=> y.to_s.split('-')[-1]}[0]\n</code>\n\
    <|/ a dscore=0 tags=ruby,arrays |>\n<| c |>\n`to_s.split('-')` should be `to_s.split('-').to_a`.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>\na = [111,21,3,4000,5,6,7,8,9]", " \
    \ arr.sort_by! { |e| -e.length }\n  counter = 0\n  result = 0\n  arr.each_with_index\
    \ { |e, i| result += e if counter < i && i % k == 0 }\n  result\nend", "  sum\
    \ = 0\n  i = 0\n  while (i < k) and arr[i] >= 10\n    sum += arr[i]\n    i +=\
    \ 1\n  \n  j = 0\n  while (j < k) and arr[j] >= 10\n    sum += arr[j]\n    j +=\
    \ 1\n  \n  return sum\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
