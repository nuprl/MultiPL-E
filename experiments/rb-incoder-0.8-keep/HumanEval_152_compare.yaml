name: HumanEval_152_compare
language: rb
prompt: "# I think we all remember that feeling when the result of some long-awaited\n\
  # event is finally known. The feelings and thoughts you have at that moment are\n\
  # definitely worth noting down and comparing.\n# Your task is to determine if a\
  \ person correctly guessed the results of a number of matches.\n# You are given\
  \ two arrays of scores and guesses of equal length, where each index shows a match.\
  \ \n# Return an array of the same length denoting how far off each guess was. If\
  \ they have guessed correctly,\n# the value is 0, and if not, the value is the absolute\
  \ difference between the guess and the score.\n# example:\n# compare([1,2,3,4,5,1],[1,2,3,4,2,-2])\
  \ -> [0,0,0,0,3,3]\n# compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\ndef\
  \ compare(game, guess)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_compare\n\
  \    candidate = method(:compare)\n    assert_equal([0, 0, 0, 0, 3, 3], candidate.call([1,\
  \ 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]))\n    assert_equal([0, 0, 0, 0, 0, 0], candidate.call([0,\
  \ 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]))\n    assert_equal([2, 4, 6], candidate.call([1,\
  \ 2, 3], [-1, -2, -3]))\n    assert_equal([2, 0, 0, 1], candidate.call([1, 2, 3,\
  \ 5], [-1, 2, 3, 4]))\n  end\nend\n"
completions: ["  # TODO\nend", "    # BEGIN PROBLEM 1 (4 points) *requires local variable*\n\
    \    winner = false\n    wins = 0\n    losses = 0\n    match = 0\n    misses =\
    \ 0\n    guesses = []\n    win = 0\n    winningScores = [0,0,0,0,0,0]", "    diff\
    \ = game[0] - guess[0]\n    diff_sum = 0\n    for i in 0...game.size\n       \
    \ if game[i] == guess[i]\n            diff_sum += 1\n        elsif game[i] !=\
    \ guess[i]\n            diff_sum += abs(game[i] - guess[i])\n        end\n   \
    \ end\n    \n    diff_arr = [diff] * game.size\n    for i in 0...game.size\n \
    \       if game[i] == guess[i]\n            diff_arr[i] = 0\n        else\n  \
    \          diff_arr[i] = abs(game[i] - guess[i])\n        end\n    end\n    \n\
    \    return diff_arr\nend\n</cell>\n<code language=julia-1.3>", "  # TODO your\
    \ code here\n  return guess\nend\n</cell>\n<cell>", "    answer = []\n    size\
    \ = guess.length\n    score = 0\n    i = 0\n    \n    while i < size do\n    \
    \    guessed = guess[i]\n        guesses = game[i]\n        \n        if guessed\
    \ == 0 then\n            guessed = guessed\n        else\n            guessed\
    \ = guessed - game[i]\n        end\n        \n        for j in 0..guesses.length\
    \ do\n            answer = answer + [guessed]\n        end\n        \n       \
    \ i = i + 1\n    end\n    \n    return answer\nend", "    scores = []\n    totalGuesses\
    \ = game.length\n    score = 0\n    gameLength = game.length\n    \n    guess\
    \ = guess.sort!\n    \n    gameLength = game.length\n    guess = guess.sort!\n\
    \    \n    guess = guess.map {|x| x.to_i}\n    guess = guess.sort!\n    \n   \
    \ guess.each do |index|\n        \n        if game[index] == guess[index]\n  \
    \          score = 0\n        elsif game[index] > guess[index] && game[index]\
    \ > score\n            score = game[index] - guess[index]\n        elsif game[index]\
    \ < guess[index] && game[index] < score\n            score = guess[index] - game[index]\n\
    \        end\n        scores << score\n    end\n    return scores\nend", "  game\
    \ = game.sort.sort\n  guess = guess.sort.sort\n  diffs = []\n  game.length\n \
    \ guess.length\n  game.each_with_index do |gamei, gamei|\n    diff = game.to_i\
    \ - guess.to_i\n    diffs.push(diff)\n  end\n  game\nend", "  result = []\n  diff\
    \ = 0\n  \n  game.each_with_index do |item, index|\n    if item != guess[index]\n\
    \      diff = abs(item - guess[index])\n      result[index] = diff\n    end\n\
    \  end\n  result\nend\n</cell>\n<code language=julia-0.4>\nfunction compare_with_diff(game,\
    \ guess)\n  diff = 0\n  \n  game.each_with_index do |item, index|\n    if item\
    \ != guess[index]\n      diff = abs(item - guess[index])\n    end\n  end\n  diff\n\
    end\n</cell>\n<code language=julia-0.4>\ngame = [1,2,3,4,5,1]\nguess = [1,2,3,4,2,-2]",
  " \n    arr = []\n    guess = []\n    \n    game.each do |i|\n        arr.push(i)\
    \ \n    end\n    guess.each do |i|\n        guess.push(i) \n    end\n    \n  \
    \  arr.each do |i|\n        guessed.each do |j|\n            if i == j then \n\
    \                arr.push(0)\n                guess.push(0)\n            end\n\
    \        end\n    end\n    \n    arr.each do |i|\n        if guess[i] == 0\n \
    \           guess[i] = game[i]\n        end\n    end\n    \n    arr.each do |i|\n\
    \        if guess[i] != game[i]\n            arr[i] = abs(guess[i]-game[i])\n\
    \        end\n    end\n    \n    return arr\nend", "  game = game.to_a\n  guess\
    \ = guess.to_a\n  \n  game_size = game.length\n  guess_size = guess.length\n \
    \ \n  result = []\n  \n  (0...guess_size).each do |i|\n    guess = guess[i]\n\
    \    \n    diff =\n      game[guess[i] - 1]\n      \n    result[i] = diff\n  \
    \  \n  end\n  \n  result\nend", '  game = game.sort!', "    # Your code here\n\
    \    guess = guess.map {|score| score.abs}\n    game = game.map {|score| score.abs}\n\
    \    correct = game.reduce(0) {|sum, score| sum if guess == score}\n    wrong\
    \ = game.count() - correct\n    differences = game.map {|score| guess == score\
    \ ? 0 : guess - score}\n    [correct, wrong, differences.min, differences.max]\n\
    end\n</cell>\n<code language=julia-1.3>", "\tgame = game.sort\n\tguess = guess.sort\n\
    \tgame.each_with_index { |num, i| guess[i] = num - guess[i] }\n\tguess.each_with_index\
    \ { |num, i| game[i] = num - game[i] }\n\tgame.each_with_index { |num, i| game[i]\
    \ < guess[i] and game[i] += 10 }\n\tguess.each_with_index { |num, i| guess[i]\
    \ < game[i] and guess[i] += 10 }\n\tguess.map { |num| abs(num - guess[game.index\
    \ {|x| x == num}] || 0 ) }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThank you\
    \ so much!\n<|/ c |>\n<| c |>\nI'm glad that helped! I guess your question was\
    \ about a comparison of two arrays, so I thought this would be a great place to\
    \ share with you :)\n<|/ c |>\n<| c |>\nNice answer but it's not what he wants.\
    \ He wants to know the distance between each array element and the first element\
    \ of guess array. For example, compare([1,5,4,3,2,3],[-1,-5,-4,-3,-2,-1]) should\
    \ return [1,1,5,5,3,3].\n<|/ c |>\n<| c |>\nI see what you mean, let me fix this\
    \ up.\n<|/ c |>\n<| c |>\nI fixed it up. Is this the correct solution?\n<|/ c\
    \ |>\n<| a dscore=0 |>\n<code>", "    # game: an array of scores\n    # guess:\
    \ an array of guesses\n    # returns: an array of answers, an array of guesses,\
    \ and the correct result\n    # Your code here\n    \n    if game.size != guess.size\n\
    \        puts \"Incorrect sizes\"\n        exit(0)\n    \n    answer = []\n  \
    \  guess = []\n    correct_count = 0\n    \n    i = 0\n    while i < game.length\n\
    \        if game[i] < guess[i]\n            answer.push(game[i] - guess[i])\n\
    \            correct_count += 1\n            i += 1\n        else\n          \
    \  guess.push(game[i] - guess[i])\n            i += 1\n    \n    return answer,\
    \ guess, correct_count\nend", "  guess = guess.sort!\n  game = game.sort!\n  guess\
    \ = guess.each_with_index.map { |val,index|\n    if index == 0\n      val\n  \
    \  elsif val != game[index]\n      val - game[index]\n    end\n  }\n  guess =\
    \ guess.each_with_index.map { |val,index|\n    if val != game[index]\n      val\
    \ - game[index]\n    end\n  }\nend", "  game2 = []\n  game2.push(guess[0])\n \
    \ game2.push(guess[1])\n  game2.push(guess[2])\n  game2.push(guess[3])\n  game2.push(guess[4])",
  "    # TODO\n    return -1\nend", "  game = game.map{|i| i>=0}\n  guess = guess.map{|i|\
    \ i>=0}\n  guesses = game-guess\n  scores = guess-game\n  scores.map!{|i| (abs(i))\
    \ if (i<0) }\n  scores << 0 if (scores.length==guesses.length)\n  guesses.zip(scores).map{|a,b|\
    \ a+b}\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  return [game[i]\
    \ - guess[i] for i in range(len(game))]\nend", "    game_size = game.size\n  \
    \  guess_size = guess.size\n    differences = []\n    if game.size == guess_size\n\
    \        if guess == game.sort\n            differences = 0\n        else\n  \
    \          differences = game.sort.length - guess.sort.length\n    end\n    return\
    \ differences\nend", "  # TODO: your code here\n  count = 0\n  while count < len(game)\n\
    \    puts game.include?(guess[count])\n    count += 1\n  end\nend", "\tresult\
    \ = game\n\tcorrected = guess[0..game.length-1].sort\n\tguessed.each do |i|\n\t\
    \tresult[i][0] += abs(guess[i] - corrected[i])\n\tend\n\tresult.sort\nend", " \
    \ game_res = [game[0]]\n  guess_res = [guess[0]]\n  game_g = 0\n  guess_g = 0\n\
    \  game_gb = game_res.count game\n  guess_gb = guess_res.count guess\n  game_gb\
    \ = if game_gb > guess_gb then game_gb else guess_gb\n  for i in 1..game_gb\n\
    \    if game[i] == guess[i]\n      game_res << 0\n      guess_res << 0\n     \
    \ next\n    else\n      game_res << game[i] - guess_g\n      guess_res << guess[i]\
    \ - game_g\n    end\n  end\n  return game_res.join\nend", "    leng = game.length\n\
    \    temp = [0 for i in range(leng)]\n    temp_sum = 0\n    for i in 0...leng\n\
    \        if game[i] != guess[i]\n            temp[i] = abs(game[i] - guess[i])\n\
    \            temp_sum += temp[i]\n        end\n    end\n    return temp\nend",
  "  scores = []\n  guesses = []\n  guesses_i = 0\n  scores_i = 0\n  scores.insert(0,0)\n\
    \  guesses.insert(0,0)\n  scores.insert(0,0)\n  guesses.insert(0,0)\n  while guesses_i\
    \ < guess.length\n    if scores[guesses_i] >= score\n      guesses_i += 1\n  \
    \  else\n      guesses.insert(0,guesses_i+1)\n      scores.insert(0,scores[guesses_i])\n\
    \      guesses_i += 1\n      break\n    end\n  end\n  while scores_i < guess.length\n\
    \    if guesses[guesses.length-scores_i] >= guesses[guesses.length-scores_i+1]\n\
    \      guesses.insert(guesses.length-scores_i,guesses[guesses.length-scores_i+1])\n\
    \      scores.insert(scores.last,scores[scores.last])\n      guesses.insert(guesses.length-scores_i+1,0)\n\
    \      guesses_i += 1\n      scores_i += 1\n      break\n    end\n  end\n  guesses\
    \ = guesses[0...guesses.length-1]\n  scores = scores[1...scores.length-1]\n  guesses.each_index\
    \ do |i|\n    if guesses[i] == 0\n      guesses[i] = guesses[i+1]\n      scores.insert(0,scores[0])\n\
    \    end\n  end\n  return guesses\nend", "  correct=0\n  score=0\n  for i in 0..guess.length\n\
    \    if game[i] == guess[i]\n      correct+=1\n      score=0\n    else\n     \
    \ score=game[i] - guess[i]\n    end\n  end\n  return score\nend", "  game = game.dup\n\
    \  guess = guess.dup\n  game.zip!(0)\n  guess.zip!(0)\n  \n  offset = 0\n  guesses\
    \ = []\n  games  = []\n  game.zip!(0)\n  guess.zip!(0)\n  \n  games << 0 while\
    \ game[0] == 0\n  guesses << 0 while guess[0] == 0\n  \n  \n  guesses.unshift(guess[0])\
    \ while guesses[0] == 0\n  \n  games.unshift(game[0]) while game[0] == 0\n  \n\
    \  guesses.shift while guesses[0] == 0\n  games.shift while game[0] == 0\n  \n\
    \  guesses.shift while guesses[0] == 0\n  games.shift while game[0] == 0\n  \n\
    \  games.shift while game[0] == 0\n  guesses << 0 while guess[0] == 0\n  \n  \n\
    \  offset = -1\n  \n  guesses << guesses[0]\n  games << games[0]\n  \n  guesses.shift\
    \ while guesses[0] == 0\n  games.shift while game[0] == 0\n  \n  guesses.shift\
    \ while guesses[0] == 0\n  games.shift while game[0] == 0\n  \n  games.shift while\
    \ game[0] == 0\n  guesses << guesses[0]\n  \n  guesses.shift while guesses[0]\
    \ == 0\n  games.shift while game[0] == 0\n  \n  guesses.shift while guesses[0]\
    \ == 0\n  games.shift while game[0] == 0\n  \n  \n  offset = -1\n  \n  guesses\
    \ << guesses[0]\n  games << games[0]\n  \n  guesses.shift while guesses[0] ==\
    \ 0\n  games.shift while game[0] == 0\n  \n  guesses.shift while guesses[0] ==\
    \ 0\n  games.shift while game[0] == 0\n  \n  games.shift while game[0] == 0\n\
    \  guesses << guesses[0]\n  \n  guesses.shift while guesses[0] == 0\n  games.shift\
    \ while game[0] == 0\n  \n  guesses.shift while guesses[0] == 0\n  games.shift\
    \ while game[0] == 0\n  \n  \n  offset = -1\n  \n  guesses << guesses[0]\n  games\
    \ << games[0]\n  \n  guesses.shift while guesses[0] == 0\n  games.shift while\
    \ game[0] == 0\n  \n  guesses.shift while guesses[0] == 0\n  games.shift while\
    \ game[0] == 0\n  \n  game", "  diffs = Array.new()\n  game.zip(guess).each do\
    \ |score,guess|\n    diffs.push( (guess - score).abs ) \n  end\n  diffs\nend",
  "  # TODO: Write a Ruby version of the compare method\n  score = 0\n  guess = guess.sort\n\
    \  game.sort!\n  game = game.sort\n  i1 = game.index {|x| x == guess[0]}\n  i2\
    \ = game.index {|x| x == guess[1]}\n  i3 = game.index {|x| x == guess[2]}\n  i4\
    \ = game.index {|x| x == guess[3]}\n  i5 = game.index {|x| x == guess[4]}\n  guess[i1..i5]\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI didn't ask for the ruby version, I only asked\
    \ for the algorithm and how to use it to find the answer.\n<|/ c |>\n<| c |>\n\
    No it isn't, you asked for how the algorithm would work and gave the Ruby implementation.\n\
    <|/ c |>\n<| c |>\nI did ask for the algorithm and I gave you the implementation\
    \ in the comments of my original post. I didn't ask you to write the Ruby version.\
    \ Did you even read my post at all?\n<|/ c |>\n<| c |>\nYes, I did read it. However\
    \ you asked for ruby version and I gave you a ruby version, which is in ruby\n\
    <|/ c |>\n<| c |>\nSo what do you want me to do? Write the ruby version? I have\
    \ no idea how to do that.\n<|/ c |>\n<| a tags=ruby,algorithm,sorting,arrays dscore=0\
    \ |>\n<code>", "  game=game.dup.sort!\n  guess=guess.dup.sort!\n  ret=[0,0]\n\
    \  game.each_with_index {|n,i| ret[0]+=n-guess[i] }\n  guess.each_with_index {|n,i|\
    \ ret[1]+=n-game[i] }\n  ret\nend", "  scores = []\n  guesses = []\n  guesses.push\
    \ game\n  scores.push game[0]\n  guesses.push guess[0]\n  scores.push guess[0]\n\
    \  guesses.push guess[1]\n  scores.push guess[1]\n  guesses.push guess[2]\n  scores.push\
    \ guess[2]\n  guesses.push guess[3]\n  scores.push guess[3]\n  guesses.push guess[4]\n\
    \  scores.push guess[4]\n  guesses.push guess[5]\n  scores.push guess[5]\n  guesses.push\
    \ guess[6]\n  scores.push guess[6]\n  guesses.push guess[7]\n  scores.push guess[7]\n\
    \  guesses.push guess[8]\n  scores.push guess[8]\n  guesses.push guess[9]\n  scores.push\
    \ guess[9]\n  guesses.push guess[10]\n  scores.push guess[10]\n  guesses.push\
    \ guess[11]\n  scores.push guess[11]\n  guesses.push guess[12]\n  scores.push\
    \ guess[12]\n  guesses.push guess[13]\n  scores.push guess[13]\n  guesses.push\
    \ guess[14]\n  scores.push guess[14]\n  guesses.push guess[15]\n  scores.push\
    \ guess[15]\n  guesses.push guess[16]\n  scores.push guess[16]\n  guesses.push\
    \ guess[17]\n  scores.push guess[17]\n  guesses.push guess[18]\n  scores.push\
    \ guess[18]\n  guesses.push guess[19]\n  scores.push guess[19]\n  guesses.push\
    \ guess[20]\n  scores.push guess[20]\n  guesses.push guess[21]\n  scores.push\
    \ guess[21]\n  guesses.push guess[22]\n  scores.push guess[22]\n  guesses.push\
    \ guess[23]\n  scores.push guess[23]\n  guesses.push guess[24]\n  scores.push\
    \ guess[24]\n  guesses.push guess[25]\n  scores.push guess[25]\n  guesses.push\
    \ guess[26]\n  scores.push guess[26]\n  guesses.push guess[27]\n  scores.push\
    \ guess[27]\n  guesses.push guess[28]\n  scores.push guess[28", "    i = 0\n \
    \   correct_guesses = 0\n    wrong_guesses = 0\n    differences = []\n    guesses\
    \ = guess[0...-1]\n    scores = game[0...-1]\n    scores.each_index do |index|\n\
    \        difference = (guesses[index] - scores[index])\n        \n        if difference\
    \ == 0\n            differences[index] = 0\n        else\n            differences[index]\
    \ = difference\n        end\n    end\n    differences.each_index do |index|\n\
    \        if differences[index] == 0\n            correct_guesses += 1\n      \
    \  else\n            wrong_guesses += 1\n        end\n    end\n    return [correct_guesses,\
    \ wrong_guesses]\nend", "    guesses.each { |g| g.each { |s| guesses << [g - s]\
    \ } }\n    games.each { |g| games << [g - guess] }\n    guesses.flatten\nend",
  "    \n    # Your code goes here\n    score = 0\n    game = game.sort!\n    guess\
    \ = guess.sort!\n    guess = game.to_a\n    score = game.to_a\n    \n    puts\
    \ score\n    puts guess\n    \n    \n    \n    \n    return score\nend", "   \
    \ return game-gues\nend", "    arr=game.dup\n    arr.sort!\n    arr.reverse!\n\
    \    guess=guess.dup\n    guess=guess.sort!\n    guess=guess.reverse!\n    arr=arr.collect{|x|\
    \ x-guess}\n    arr\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nThis\
    \ is probably the best answer to this particular question, but I still don't understand\
    \ why he said \"I thought of counting the number of wins, loses, and ties\" instead\
    \ of just saying \"you know the game is tie or lose, just count the number of\
    \ wins, loses, and ties\".\n<|/ c |>\n<| c |>\nThe game is TicTacToe, with the\
    \ board of the game being represented by an array. I'm supposed to count the wins,\
    \ loses, and ties by seeing what happens if a certain person guesses the game\
    \ correctly and what happens otherwise. Given the code above, would it be possible\
    \ to tell me which line in the code corresponds to which line?\n<|/ c |>\n<| c\
    \ |>\nthe line that does the counting is the `arr=arr.collect{|x| x-guess}` line.\
    \ If there are any more questions, let me know.\n<|/ c |>\n<| c |>\nThanks for\
    \ all the help. I really appreciate it. I edited the original question with my\
    \ current solution, but I'm not sure I'm doing it right. I need to find out why\
    \ my code doesn't output the right values. The question I posted above is really\
    \ what I need help with.\n<|/ c |>\n<| c |>\nI updated the answer. It should work,\
    \ but I haven't tested it so let me know if there are any problems. I might have\
    \ some typos or stuff that I didn't notice right away, so let me know if there\
    \ are any problems.\n<|/ c |>\n<| a dscore=0 tags=ruby |>\n<code>", "  game =\
    \ game.flatten\n  guess = guess.flatten\n  result = 0.dup\n  guessed_index = 0.dup\n\
    \  guessed_value = 0.dup\n  correct_index = 0.dup\n  correct_value = 0.dup\n \
    \ game_index = 0.dup\n  game_value = 0.dup\n  guessed_index = 0\n  correct_index\
    \ = 0\n  guessed_value = 0\n  game_index = 0\n  game_value = 0\n  for i in 0...game.size\n\
    \    result += (game[i] - guess[i])\n    guessed_index += i\n    guessed_value\
    \ += game[i] - guess[i]\n    game_index += 1\n    game_value = game[i] - guess[i]\n\
    \  end\n  for i in 0...guess.size\n    if game[guessed_index] == guess[i]\n  \
    \    guessed_value += 1\n      correct_index += 1\n      correct_value += game_index\n\
    \    end\n  end\n  for i in 0...game.size\n    if game[correct_index] == guess[i]\n\
    \      correct_value += 1\n      guessed_value += 1\n    end\n  end\n  correct_value\
    \ = correct_value.abs()\n  guessed_value = guessed_value.abs()\n  result = []\n\
    \  while correct_value > 0\n    result << [correct_index,correct_value]\n    correct_index\
    \ -= 1\n    correct_value -= 1\n  end\n  while guessed_value > 0\n    result <<\
    \ [guessed_index,guessed_value]\n    guessed_index -= 1\n    guessed_value -=\
    \ 1\n  end\n  result\nend", "  \nend", "  game.zip!(0..guess.length-1){ |i,j|\n\
    \    if game[i] != guess[j]\n      game.delete_at(i+1)\n      return i\n    end\n\
    \  }\n  game.length\nend\n</cell>\n<code language=julia-0.5>\n@time guess = Int[\
    \ rand(10) for i in 1:10000 ]\n@time game = Int[ rand(10) for i in 1:10000 ]\n\
    @time guesses = rand( 10000, 10 )\n@time result = compare( game, guess )\n@time\
    \ result = compare( game, guesses )\n@time result = compare( game, guesses.T )\n\
    @time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )\n@time result = compare( game, guesses\
    \ )\n@time result = compare( game, guesses )", "  # TODO 5-3: Compute the sum\
    \ of differences between guess and score, and return an array of length guess\n\
    \  # Hint: Use sum and a list comprehension\n  diffs = [abs(x - y) for x,y in\
    \ zip(game, guess)]\n  return diffs\nend", "  game = game.dup\n  guess = guess.dup\n\
    \  result = []\n  \n  game.length.times do |i|\n    guess.length.times do |j|\n\
    \      result[j] = result[j] || 0\n      result[j] += game[i] if guess[j] == game[i]\n\
    \    end\n  end\n  result.map {|i| i[i.length] }\nend", "    # Your code here\n\
    \    score = [x for x in game if x in guess]\n    guess = [x for x in guess if\
    \ x in game]\n    diff = [abs(x - y) for x,y in zip(score,guess)]\n    score =\
    \ [x for x in score]\n    guess = [x for x in guess]\n    diff = [x for x in diff]\n\
    \    return diff\n</cell>\n<cell>", "  if game.size == guess.size \n    difference\
    \ = [0 for _ in range(game.size)]\n    for index in range(game.size)\n      difference[index]\
    \ = game[index] - guess[index]\n    return difference\n  end\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThank you! I appreciate you taking the time to respond. That\
    \ worked perfectly.\n<|/ c |>\n<| c |>\nGlad to help. If this answered your question,\
    \ please [mark as answer](https://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work)\
    \ so that others know this is the solution.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ dscore=0 |>\nHere is a slightly modified version of your code that works more\
    \ efficiently since it uses Ruby's built-in enumerable methods.\n<code>", "  return\n\
    end\n</cell>\n<code language=julia-0.6>", "    game = [int(x) for x in game]\n\
    \    guess = [int(x) for x in guess]\n    count = 0\n    for game in game:\n \
    \       if game > guess:\n            count -= 1\n        elif game < guess:\n\
    \            count += 1\n        else:\n            count += 0\n    return count\n\
    </cell>\n<code language=conda-env-py36-py>", "\tguess=guess.to_a\n\tresult = []\n\
    \tgame=game.to_a\n\tgame.each do |e|\n\t\tguess.each do |r|\n\t\t\tif e == r\n\
    \t\t\t\tresult << 0\n\t\t\telse\n\t\t\t\tresult << (e-r)\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn result\nend", "  game, guess = game.clone, guess.clone\n  return\
    \ game.map { |e| [e, guess.index(e, game.first)] }.compact.map { |e| e.last.to_f\
    \ - e.first }.sort_by(&:last).reverse\nend\n</code>\nLet's test your function:\n\
    <code>\ncompare([1,2,3,4,5,1], [1,2,3,4,2,-2]) # => [0, 0, 0, 0, 3, 3]\ncompare([0,5,0,0,0,4],\
    \ [4,1,1,0,0,-2]) # => [4, 4, 1, 0, 0, 6]\n</code>\nNow comes the interesting\
    \ part:\n<code>\nguess = compare([1,2,3,4,5,1], [1,2,3,4,2,-2]).first\ngame =\
    \ compare([0,5,0,0,0,4], [4,1,1,0,0,-2]).first", "  game = game.to_a\n  guess\
    \ = guess.to_a\n  length = game.size\n  result = []\n  guessed_correctly = false",
  "    matches = 0\n    score = 0\n    if game.size == guess.size and game.size ==\
    \ guess.size\n        game = game.reverse!\n        guess = guess.reverse!\n \
    \       while matches < game.size do\n            if game[matches] == guess[matches]\n\
    \                score += 0\n                matches += 1\n            else\n\
    \                score += abs(game[matches] - guess[matches])\n              \
    \  matches += 1\n        end\n        return score\n    end\nend", "  score =\
    \ 0\n  index = 0\n  correct_guesses = []\n  \n  while index < guess.length\n \
    \   if game[index] == guess[index]\n      score += 0\n      correct_guesses.push(game[index])\n\
    \      index+=1\n    else if game[index] > guess[index]\n      score += 0\n  \
    \    index+=1\n      \n      while index < guess.length\n        if game[index]\
    \ < guess[index] \n          score += -1\n          correct_guesses.push(game[index])\n\
    \          index+=1\n        end\n      index+=1\n    end\n  end", "  # Write\
    \ your solution here\n  game.map!{|e| e != guess.last ? e.abs - guess.last : e}\n\
    \  game.each {|i| game[i] = guess.include? game[i] ? game[i].abs - game[i].last\
    \ : game[i] }\n  game\nend\n</cell>\n<code language=conda-env-CourseraMLAndrewNgmyNoteEnv-py>",
  "end\n</cell>\n<code language=julia-1.5>", "    diff = []\n    game_size = len(game)\n\
    \    guess_size = len(guess)\n    if game_size == guess_size then \n        if\
    \ game_size\n        then \n            diff = [game[i] - guess[i] for i in range(0,game_size)]\n\
    \        end\n    else \n        diff = game_size - guess_size\n    end\n    return\
    \ diff\nend", "    guesses = []\n    scores = []", "  game.length.times do |i|\n\
    \    guess.length.times do |j|\n      next if j == i\n      guess[j] == game[i]\
    \ ? game[i] : 0\n    end\n  end\n  game.map { |n| n.abs }\nend", "    i = game.length\n\
    \    j = len(guess)\n    diff = Array.new\n    while i > 0\n        diff = Array.new(game[i])\
    \ + diff\n        i -= 1\n    i = j\n    while j > 0\n        diff = Array.new(guess[j])\
    \ - diff\n        j -= 1\n    diff\nend\n</cell>\n<code language=julia-1.5>",
  "  (0...guess.length).map { |index|\n    (game[index] == guess[index]) ? 0 : guess[index]\
    \ - game[index]\n  }\nend", "  game_size = game.size\n  guess_size = guess.size\n\
    \  correct_guesses = []\n  for i in 0...game_size\n    correct_guesses.push(0)\n\
    \  end\n  \n  for i in 0...guess_size\n    if game[i] != guess[i]\n      correct_guesses[game[i]-1]\
    \ += 1\n    end\n  end\n  \n  for i in 0...game_size\n    if game[i] != 0\n  \
    \    correct_guesses[i] += abs(guess[i] - game[i])\n    end\n  end\n  \n  return\
    \ correct_guesses\nend", "    # Write your code here\n    correct = 0\n    wrong\
    \ = 0\n    for i in (0..(game.length-1))\n        correct = game[i]\n        guess\
    \ = guess[i]\n        if guess == correct\n        then correct += 1\n       \
    \ elsif guess != correct\n        then wrong += 1\n        else wrong += 1\n \
    \   answers = [correct - wrong]\n    return answers", "  game.each {|score,guess|\
    \ score==guess ? nil :\n    guess_diff=guess - score if score>guess else score\
    \ - guess\n    guess_diff < 0 ? guess_diff+abs(guess_diff) : guess_diff\n  }\n\
    end", "    game2 = game.dup\n    guess2 = guess.dup\n    count = 0\n    for i\
    \ in 0..game.size\n        if game[i] != guess2[i]\n            count = count\
    \ + 1\n        end\n    end\n    return [count, guess2 - game]\nend", "  scores\
    \ = []\n  guesses = []\n  \n  for i in 0..game.size-1\n    scores += [i]\n   \
    \ guesses += [i]\n  end", "    game=game.to_a.sort\n    guess=guess.to_a.sort\n\
    \    return -guess.map { |i| game.count { |j| i == j } }\nend\n</cell>\n<code\
    \ language=julia-0.5>\n@test compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) == [0,0,0,0,3,3]\n\
    @test compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) == [4,4,1,0,0,6]\n@test compare([0,0,0,0,3,3],[0,0,0,0,0,-3])\
    \ == [0,0,0,0,3,3]\n@test compare([0,0,0,0,0,-3],[0,0,0,0,3,3]) == [0,0,0,0,3,3]\n\
    </cell>\n<text>\n4.8 Test your code\nRun your function on several test cases to\
    \ test that your code is working to solve the problem you set out to solve.",
  "    \n    game_score = sum(game)\n    guess_score = sum(guess)\n    correct_guesses\
    \ = 0\n    correct_score = 0\n    \n    for idx, num in enumerate(game):\n   \
    \     if num == guess_score:\n            correct_guesses += 1\n        elif num\
    \ > guess_score:\n            correct_score += abs(num-guess_score)\n        else:\n\
    \            correct_score += abs(guess_score - num)\n            \n    \n   \
    \ return [correct_guesses, correct_score]\n    \n        \n</cell>\n<cell>", " \
    \   game_size = len(game)\n    guess_size = len(guess)\n    matches = 0\n    \n\
    \    if guess_size != game_size:\n        return game_size", "    size = guess.size\n\
    \    true = Array.new\n    false = Array.new\n    correct = 0\n    score = 0\n\
    \    guesses = 0\n    scores.each_with_index do |score, index|\n        guess\
    \ = game[index]\n        if guess == score\n            guess == score\n     \
    \   else\n            guesses += 1\n            if guess == score\n          \
    \      correct += 1\n            else\n                guess = guess - score\n\
    \            end\n        end\n        if guess == score\n            true[index]\
    \ = 1\n            true[index + 1] = 1\n        else\n            false[index]\
    \ = abs(guess - score)\n            false[index + 1] = abs(guess - score)\n  \
    \      end\n    end\n    if guesses == size\n        true[size] = 1\n        true[size\
    \ + 1] = 1\n    else\n        false[size] = abs(guesses - size)\n        false[size\
    \ + 1] = abs(guesses - size)\n    end\n    false\nend", "    diff = [0] * game.size\n\
    \    i = 0\n    while i < game.size and guess[i] == game[i]\n        diff[i] =\
    \ 0\n        i += 1\n    while i < game.size\n        diff[i] = abs(guess[i] -\
    \ game[i])\n        i += 1\n    diff.each_with_index do |d, i|\n        if d ==\
    \ 0\n            guess[i] = 0\n            i += 1\n        end\n    end\n    guess\n\
    end", "  game = game.dup\n  guess = guess.dup\n  \n  # Your code here", "    correct_count\
    \ = 0\n    guesses = 0\n    while guesses < len(guess)\n        if game[guesses]\
    \ == guess[guesses]\n            correct_count += 1\n        guesses += 1\n  \
    \  if guesses == len(guess)\n        return [correct_count]\n    else\n      \
    \  return [-abs(correct_count - guesses)]\nend", "    return Array.new(guess.length){|i|\
    \ game.include?(guess[i]) ? 0 : guess[i] - game[i]}\nend\n</cell>\n<code language=julia-1.6>",
  "  game.reduce(guess)\n  guess = game.transpose()\n  guess = guess.reduce(guess)\n\
    \  \n  result = []\n  \n  game.reduce(game)\n  game.transpose().reduce(guess)\n\
    \  \n  game.reduce(game)\n  game.transpose().reduce(game)\n  \n  game.reduce(guess)\n\
    \  game.transpose().reduce(guess)\n  guess = guess.reduce(guess)\n  \n  game.reduce(game)\n\
    \  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n\
    \  \n  game.reduce(guess)\n  game.transpose().reduce(guess)\n  guess.reduce(guess)\n\
    \  guess.reduce(guess)\n  guess.reduce(guess)\n  guess.reduce(guess)\n  \n  game.reduce(game)\n\
    \  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n\
    \  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n  \n  game.reduce(guess)\n\
    \  game.transpose().reduce(guess)\n  guess.reduce(guess)\n  guess.reduce(guess)\n\
    \  guess.reduce(guess)\n  guess.reduce(guess)\n  guess.reduce(guess)\n  \n  game.reduce(game)\n\
    \  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n\
    \  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n\
    \  game.transpose().reduce(game)\n  \n  game.reduce(guess)\n  game.transpose().reduce(guess)\n\
    \  guess.reduce(guess)\n  guess.reduce(guess)\n  guess.reduce(guess)\n  guess.reduce(guess)\n\
    \  guess.reduce(guess)\n  guess.reduce(guess)\n  guess.reduce(guess)\n  \n  game.reduce(game)\n\
    \  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n\
    \  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n\
    \  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n  game.transpose().reduce(game)\n\
    \  \n  game.reduce(guess)\n  game.transpose().reduce(guess)\n  guess.reduce(guess)\n\
    \  guess.reduce(guess)\n  ", "    \n    scores = []\n    \n    # Create a variable\
    \ for \"guesses\" where we have our guesses, each of size 4\n    guesses = []\n\
    \    \n    # Create a variable for \"games\" where we store our actual games,\
    \ each of size 5\n    games = []\n    \n    # Loop through each of the 5 games\
    \ in our array\n    for game in game\n        \n        # Create a variable for\
    \ \"guesses\" where we have our guesses, each of size 4\n        guesses = guesses\
    \ + guess\n        \n        # Create a variable for \"games\" where we store\
    \ our actual games, each of size 5\n        games = games + game\n    \n    #\
    \ Now we loop through each of the 4 guesses\n    for guess in guesses\n      \
    \  \n        # Create a variable for \"scores\" where we store our scores for\
    \ each guess, each of size 5\n        scores = []\n        \n        # For each\
    \ of the 5 games in our array\n        for game in games\n            \n     \
    \       # Create a variable for \"scores\" where we store our scores for each\
    \ guess, each of size 4\n            scores = []\n            \n            #\
    \ If the games are the same, our score is 0, and if not, our score is the difference\n\
    \            if game == guess\n                scores.append(0)\n            else\n\
    \                scores.append(abs(guess - game))\n        \n        # If the\
    \ scores are all the same, we have correctly guessed the results\n        if scores.count(scores[0])\
    \ == len(scores)\n            return scores\n        \n        # If there are\
    \ at least 2 scores, the person has made incorrect guesses\n        elif scores.count(scores[0])\
    \ >= 2\n            # Return the scores list\n            return scores\n    \
    \        \n        # If there are no scores at all, we can't correctly guess the\
    \ results\n        else:\n            # Return the scores list\n            return\
    \ scores\n            ", "  guess = guess.dup.sort\n  game.sort.each_with_index{|e,i|\
    \ e==0 ? (game[i]=0) : game[i] += (e<guess ? -1 : 1)}\n  game\nend", "    \n \
    \   # your code here\n    return game-guess\n    ", "  game = [x.to_i for x in\
    \ game]\n  guess = [x.to_i for x in guess]\n  diffs = []\n  \n  # iterate over\
    \ each index in guess\n  for i in 0...guess.size\n    guess = guess[i].to_i\n\
    \    \n    if guess == 0 \n      diffs.push(0) \n    else\n      # iterate over\
    \ each index in game\n      for i in 0...game.size\n        game = game[i].to_i\n\
    \        \n        # if the game and guess are equal\n        if game == guess\n\
    \          diffs.push(0) \n        # else we check if the game is greater than\
    \ the guess\n        else\n          if game > guess\n            diffs.push(-game)\
    \ \n          else\n            diffs.push(game)\n        end\n      end\n   \
    \ end\n  end\n  \n  # return an array of differences for each index in guess\n\
    \  return diffs\nend", "    # Your code here\n    scores = [g for g in guess]\n\
    \    correct = 0\n    for g in game\n        if g == guess\n            correct\
    \ += 1\n            scores -= 1\n        end\n    end\n    diff = scores.abs\n\
    \    game = [g for g in game]\n    # Your code here\n    return game\nend", " \
    \   # your code here\n    return game\nend\n</cell>\n<code language=julia-0.6>\n\
    game1 = [(4,5),(3,5),(1,1),(4,5),(0,5),(5,5)]\nguess = [1,2,3,4,5,1]\n</cell>\n\
    <code language=julia-0.6>\n@assert compare(game1,guess) == [0,0,0,0,3,3]\n@assert\
    \ compare(game1,guess2) == [0,0,0,0,3,3]\n@assert compare([1,2,3,4,5,1],[1,2,3,4,2,-2])\
    \ == [0,0,0,0,3,3]\n@assert compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) == [4,4,1,0,0,6]\n\
    </cell>\n<text>\nSolution", "  correct = 0\n  guessed_correctly = 0\n  difference\
    \ = 0\n  for i in 0 ... game.length - 1\n    difference += abs(guess[i] - game[i])\n\
    \  end\n  for i in 0 ... guess.length - 1\n    guessed_correctly += guess[i] ==\
    \ game[i]\n    correct += guessed_correctly\n  end\n  p difference\nend", "  #\
    \ your code here\n  score.empty?\n  guessed.empty?\n  miss.empty?\n  \n  score.push(game.length)\n\
    \  guessed.push(guess.length)\n  miss.push(game.length-guess.length)\n  \n  for\
    \ i in 0...game.length\n    if game[i] == guess[i]\n      score.push(0)\n    \
    \  guessed.push(0)\n      miss.push(0)\n    elsif game[i] != guess[i]\n      score.push(game[i]\
    \ - guess[i])\n      guessed.push(guess[i])\n      miss.push(game[i] - guess[i])\n\
    \    end\n  end\n  miss.each { |i| return i }\n  score.each { |i| return i }\n\
    \  score.size\nend\n</code>\nSome of the bugs I noticed in your code:\n<code>\n\
    score.empty?\nguessed.empty?\nmiss.empty?\n</code>\nYou are not comparing anything\
    \ in those cases, you are trying to access an array element on that variable that\
    \ does not exist. The first two lines do not do anything useful in your current\
    \ code, and the third line will throw an error.\n<code>\nscore.push(game.length)\n\
    guessed.push(guess.length)\nmiss.push(game.length-guess.length)\n</code>\nThis\
    \ line is also not doing anything useful, you are just pushing some value to the\
    \ array.\n<code>\nfor i in 0...game.length\n    if game[i] == guess[i]\n     \
    \ score.push(0)\n      guessed.push(0)\n      miss.push(0)\n    elsif game[i]\
    \ != guess[i]\n      score.push(game[i] - guess[i])\n      guessed.push(guess[i])\n\
    \      miss.push(game[i] - guess[i])\n    end\n  end\n  miss.each { |i| return\
    \ i }\n  score.each { |i| return i }\n  score.size\nend\n</code>\nThere are a\
    \ couple of problems here. First and foremost, you are not using the index variable\
    \ i in your loop. Even if you were, you are not comparing anything. The array\
    \ is sorted and you are just looping through it. Instead, you should use:\n<code>",
  "  a = game.size\n  b = guess.size\n  if a != b\n    throw :not_equal\n  res = Array.new(a)\n\
    \  b.times do |i|\n    if guess[i] < game[i]\n      res[i] = 0\n    else\n   \
    \   res[i] = (game[i] - guess[i])\n    end\n  end\n  res\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    diff = Array.new(guess.length)\n    guesses = Array.new(guess.length)",
  "    # Write your code here.\n    return game-guess\nend\n</cell>\n<code language=julia-1.4>",
  "  scores = []\n  while game.size != guess.size\n    game = game.to_a\n    guess\
    \ = guess.to_a\n  end\n  game_size = game.size\n  guesses_size = guess.size\n\
    \  max_difference = 0\n  for index in 0..guesses_size-1\n    difference = abs(guess[index]\
    \ - game[index])\n    if game[index] == guess[index] and game[index] > 0\n   \
    \   difference = 0\n    else\n      if game[index] > guess[index]\n        difference\
    \ = difference - 1\n      else\n        difference = difference + 1\n      end\n\
    \    end\n    scores.push difference\n    max_difference = max_difference > difference\
    \ ? max_difference : difference\n  end\n  scores.push max_difference\n  return\
    \ scores\nend", "    # write your solution here\n    score = game[0]\n    guess\
    \ = game[1]\n    diff = []\n    i = 0\n    temp1 = []\n    temp2 = []\n    while\
    \ i < len(guess):\n        if guess[i] in score:\n            temp = score\n \
    \           temp.append(guess[i])\n            temp1 = temp\n            temp2\
    \ = temp\n            \n        else:\n            temp = score\n            temp.append(guess[i])\n\
    \            temp2 = temp\n        i = i+1", "  guesses = 0\n  scores.each do\
    \ |score|\n    guesses << 0 if guesses.include?(score)\n    guesses << guess[games.index(score)]\
    \ unless guesses.include?(score)\n  end\n  guesses\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=0 |>\n<| c |>\nThe `games.index` call is redundant since the `guesses`\
    \ array is sorted already.\n<|/ c |>\n<| c |>\nYou're right, I've made edit. Thanks.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  result = []\n  n = guess.length\n\
    \  \n  for i in 0...n\n    result += [0]*n\n  end\n  \n  for i in 0...n\n    for\
    \ j in 0...n\n      if game[i]==guess[j] and i!=j\n        result[i] += game[j]\
    \ - guess[j]\n      end\n    end\n  end\n  \n  result.max\nend\n</cell>\n<code\
    \ language=julia-1.5>", "  \nend", "    # Your code here\n    \n    correct =\
    \ 0\n    game = game[-1*len(guess):]\n    for i in game:\n        if i == guess[game.index(i)]:\n\
    \            correct += 1\n    game = game[-1*len(guess):]\n    return [0]*len(guess)\
    \ + [abs(i-guess[game.index(i)]) for i in game]\n</cell>\n<cell>", "  game, guess\
    \ = game, guess.sort\n  puts \"#{game} #{guess}\"\n  puts \"#{game.count('0')}\
    \ #{guess.count('0')}\"\n  game, guess = game[1..-1], guess[1..-1]\n  puts \"\
    #{game} #{guess}\"\n  puts \"#{game.count('0')} #{guess.count('0')}\"\n  game,\
    \ guess = game[1..-1], guess[1..-1]\n  puts \"#{game} #{guess}\"\n  puts \"#{game.count('0')}\
    \ #{guess.count('0')}\"\n  result = [0,0,0,0,0,0]\n  loop do\n    puts \"#{game}\
    \ #{guess}\"\n    puts \"#{game.count('0')} #{guess.count('0')}\"\n    game.each_with_index\
    \ do |e,i|\n      result[i] += guess.count(e) - game.count(e)\n    end\n    break\
    \ if result.all? { |x| x == 0 }\n    puts \"#{game} #{guess}\"\n    puts \"#{game.count('0')}\
    \ #{guess.count('0')}\"\n  end\n  result\nend", "  game = game.sort\n  guess =\
    \ guess.sort\n  game_size = [game.length]\n  guess_size = [guess.length]\n  result\
    \ = []\n  # compare all possible guesses\n  for i in 0..(guess.length-1)\n   \
    \ # add value to result if there is a match\n    if game[i] > guess[i]\n     \
    \ game_size[i+1] += (game[i] - game[i])\n      guess_size[i+1] += 1\n      result.push\
    \ game[i]\n    else\n      game_size[i+1] += 1\n      result.push game[i]\n  \
    \    result.push guess[i]\n  end\n  result.push game_size.max\n  result.push guess_size.max\n\
    \  return result\nend\n</cell>\n<code language=julia-1.5>", "    game = game.sort{|a,b|\
    \ a <=> b}\n    guess = guess.sort{|a,b| a <=> b}\n    i = 0\n    j = guess.length\n\
    \    diff = []\n    while i < game.length and j < guess.length\n        if game[i]\
    \ < guess[j]\n            i += 1\n        else\n            j -= 1\n         \
    \   diff << game[i] - guess[j]\n            game[i], game[j] = game[j], game[i]\n\
    \        end\n    end\n    diff += game.size - i\n    diff += guess.length - j\n\
    \    game.length += guess.length\n    guess.length = 0\n    return diff\nend",
  "  \n  # TODO: fill in code here.\n  guess_max = game.max(guess)\n  score = [guess_max]\
    \ - [score[i] for i in game]\n  i = 0\n  while i < game.size\n    if score[i]\
    \ != 0\n      score [i] += score[i - 1]\n      score[i - 1] = score[i]\n     \
    \ i += 1\n    i += 1\n  end\n  return  score\nend\n</cell>\n<cell>", "  \nend",
  "    correct = 0\n    \n    for g in guess \n        correct += game - g\n     \
    \   \n    return correct\n    \nprint(compare([1,2,3,4,5,1],[1,2,3,4,2,-2]))\n\
    print(compare([0,5,0,0,0,4],[4,1,1,0,0,-2]))\n</cell>\n<text>\nQuestion", "  \
    \  return nil\nend", "    # Your code here\n    score = 0\n    if game.size !=\
    \ guess.size\n        game = game.dup\n        guess = guess.dup\n        game.clear\n\
    \        guess.clear\n    end\n    game = game.collect{|i| i==0?0:1}\n    guess\
    \ = guess.collect{|i| i==0?0:1}\n    guess = guess.sort.to_a\n    guess = guess.size\n\
    \    game = game.sort.to_a\n    game.zip(0..guess).collect {|a,b| (a-b).abs}\n\
    end\n</code>\n<|/ a |>\n<| a |>\nHere's a Ruby implementation:\n<code>", "   \
    \ differences = []\n    i = 0\n    while i < guess.length\n        if game[i]\
    \ != guess[i]\n            differences[i] = abs(game[i] - guess[i])\n        end\n\
    \        i += 1\n    end\n    return differences\nend\n</cell>\n<code language=julia-0.6>",
  "  game = [int(x) for x in game]\n  guess = [int(x) for x in guess]\n  guesses =\
    \ []\n  gameScore = 0\n  \n  for i, v in enumerate(guess):\n    gameScore += game[i]\n\
    \    guesses.append(gameScore)\n    \n  correct = []\n  \n  for i, v in enumerate(guesses):\n\
    \    if guess == guesses[:i]:\n      correct.append(0)\n    else:\n      correct.append(abs(v-gameScore))",
  "    scores = []\n    for a in game\n        if guess[a]==game[a]\n            score=0\n\
    \        else\n            score = abs(guess[a]-game[a])\n        end\n      \
    \  scores.push(score)\n    end\n    return scores\nend\n</cell>\n<code language=julia-1.4>\n\
    @time compare([1,2,3,4,5,1],[1,2,3,4,2,-2])\n</cell>\n<text>\nNow we will make\
    \ our own version of compare which works over collections and uses reduce to apply\
    \ a function to each element in the collection.\nIt is important that we use reduce\
    \ to solve the problem rather than a for loop (as we are doing in this exercise)\
    \ as it reduces the complexity of the problem (we are no longer iterating over\
    \ the entire collection but rather reducing the set of items that we must examine).\
    \ The reduce function takes a collection of items and a function (or block) that\
    \ accepts an item and returns another item. In this case we need a function that\
    \ takes a single argument and reduces over an array. Here we define such a function:",
  "  game = game.dup\n  guess = guess.dup\n  game.each_with_index do |score, index|\n\
    \    guess[index] =\n      guess[index] == -1 ? score : guess[index] + score\n\
    \  end\n  guess = guess.reject(&:zero?)\n  guess = guess.inject(0) { |sum, score|\
    \ sum + score }\n  guess = -guess\n  game.reject { |score| score == 0 }\nend",
  "    result = []\n    guesses = [-1] * game.size\n    if game.size != guess.size\n\
    \        throw :wrong_size\n    \n    for index in 0..game.size\n        if game[index]\
    \ == 0\n            result[index] << 0\n        else\n            guesses[index]\
    \ = abs(guess[index] - game[index])\n        end\n    end\n    \n    for index\
    \ in 0..game.size\n        if guesses[index] != -1\n            result[index]\
    \ << guesses[index]\n        end\n    end\n    return result\nend", "  game.length\
    \ == guess.length\n  score = [0,0,0,0,0]\n  guess.length == game.size\n  for i\
    \ in 0..game.size-1\n    score[i] = game[i] - guess[i]\n    if guess[i] == game[i]\
    \ then return score.fill 0\n    else return score\nend", "  scores = []\n  i =\
    \ 0\n  while i < guess.length\n    score = 0\n    if guess[i] == game[i]\n   \
    \   score += 0\n    else\n      score += guess[i] * -1\n    end\n    scores.push(score)\n\
    \    i += 1\n  end\n  scores.sort!\n  return scores\nend", "    # initialize a\
    \ counter for misses, a counter for matches, and a counter for\n    # all guesses,\
    \ guesses, and scores\n    matches = 0\n    misses = 0\n    total = 0\n    \n\
    \    # go through all the guesses\n    for index in range(0, len(guess)):\n  \
    \      # add the difference between guess and the score to the total\n       \
    \ total += guess[index] - game[index]\n        \n        # check to see if the\
    \ guess was correct\n        if game[index] == guess[index]:\n            # increment\
    \ the matches counter\n            matches += 1\n        else:\n            #\
    \ increment the misses counter\n            misses += 1\n    \n    # create an\
    \ array of how many guesses were correct for the number of matches\n    answer\
    \ = 0\n    for index in range(0, len(guess)):\n        # subtract the amount of\
    \ guesses that were incorrect by the amount of guesses that were correct\n   \
    \     answer = answer - guess[index] - matches[index]\n    \n    # if the sum\
    \ of all the differences is positive, the person is correct\n    if total > 0:\n\
    \        # output an array of zeros denoting how far off each guess was\n    \
    \    answer = [0]\n    else:\n        # if the total is negative, the person did\
    \ not guess the correct amount\n        # of times\n        answer = [abs(total)]\n\
    \    \n    # return the array of correct values\n    return answer\n</cell>\n\
    <cell>", "    # your code here\n    \n    game_len = game.length\n    guess_len\
    \ = guess.length\n    correct_guess = []\n    wrong_guess = []\n    \n    \n \
    \   for index,i in enumerate(game):\n        \n        if guess==game:\n     \
    \       correct_guess.append(index)\n            correct_guess.append(index)\n\
    \            correct_guess.append(index)\n            correct_guess.append(index)\n\
    \        elif guess!=game:\n            wrong_guess.append(index)\n          \
    \  wrong_guess.append(index)\n            wrong_guess.append(index)\n        \
    \    wrong_guess.append(index)\n            \n    \n    correct_guess_sum = 0\n\
    \    for i in correct_guess:\n        correct_guess_sum += i\n    correct_guess_sum=correct_guess_sum*(game_len-guess_len)\n\
    \    \n    wrong_guess_sum = 0\n    for i in wrong_guess:\n        wrong_guess_sum\
    \ += i\n    wrong_guess_sum=wrong_guess_sum*(guess_len-game_len)\n    \n    \n\
    \    \n    correct_guess_sum = correct_guess_sum-(game_len-guess_len)\n    wrong_guess_sum\
    \ = wrong_guess_sum-(guess_len-game_len)\n    \n    \n    guess_difference = []\n\
    \    for i in correct_guess:\n        guess_difference.append(i)\n    for i in\
    \ wrong_guess:\n        guess_difference.append(i)\n    \n    \n    diff = [i\
    \ for i in guess_difference if i!=0]\n    diff = [i for i in diff if i>0]\n  \
    \  \n    diff_count = 0\n    for i in diff:\n        diff_count += i\n    \n \
    \   \n    result = [i for i in guess_difference if i!=0]\n    result = [i for\
    \ i in result if i>0]\n    \n    \n    \n    \n    diff_count = 0\n    for i in\
    \ result:\n        diff_count += i\n    \n    diff_count = diff_count * -1\n \
    \   \n    \n    \n    \n    \n    diff_count = diff_count - (guess_len-game_len)\n\
    \    \n    \n    \n    \n    diff_count = diff_count * -1\n    \n    \n    \n\
    \    diff_count = diff_count - (guess_len-game_len)\n    \n    \n    \n    diff_count\
    \ = diff_count - (guess_len-game_len)\n    \n    \n    \n    diff_count = diff_count\
    \ - (guess_len-game_len)\n    \n    \n    \n    diff_count = diff_count - (guess_len-game_len)\n\
    \    \n    \n    \n    diff_count = diff_count - (guess_len-game_len)\n    \n\
    \    \n    \n    diff_count = diff_count - (guess_len-game_len)\n    \n    \n\
    \    \n    diff_count = diff_count - (guess_len-game_len)\n    \n    \n    \n",
  "  # TODO: fill this in with your code\nend", "  num_correct = 0\n  num_wrong =\
    \ 0\n  game.each_with_index do |score, i| \n    puts \"game: #{game}, guess: #{guess[i]},\
    \ score: #{score}\"\n    if guess[i] == score\n      puts \"game correct\"\n \
    \     num_correct = num_correct + 1\n    else\n      puts \"game wrong\"\n   \
    \   num_wrong = num_wrong + 1\n    end\n  end\n  return [num_correct, num_wrong]\n\
    end\n</code>\nA few points to keep in mind: ", "  score = 0\n  guesses = []\n\
    \  scores.each do |score|\n    guesses.each do |guesse|\n      if game[score]\
    \ == guess\n        score += 0\n      else\n        score += game.abs * (guess\
    \ - game[score])\n      end\n    end\n  end\n  guesses\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThanks for your answer. \nI tried to run your code on https://repl.it/languages/ruby\
    \ but it return this error:\n`ArgumentError: comparison of Fixnum with nil failed`\n\
    <|/ c |>\n<| c |>\nAre you sure that you are using it correctly? Because it works\
    \ fine on my computer.\n<|/ c |>\n<| c |>\nOh my bad, I made a typo. \nIt works\
    \ perfectly now. Thanks again for your help!\n<|/ c |>\n<| c |>\nAwesome! Thank\
    \ you :)\n<|/ c |>\n<| a |>\nThe way you have defined scores is causing the error\
    \ you are seeing. Since you are trying to compare the score with the guess, I\
    \ suggest you change scores to an array of score values like below:\n<code>\n\
    scores = [1,2,3,4,5,1]\nguesses = [1,2,3,4,2,-2]\n</code>\nThen you can use a\
    \ for each loop to iterate over each score and guess:\n<code>\nscores.each do\
    \ |score|\n  guesses.each do |guess|\n    if score == guess\n      score += 0\n\
    \    else\n      score += abs(guess - score)\n    end\n  end\nend", "    diff\
    \ = 0\n    game = [] if game == nil end\n    guess = [] if guess == nil end\n\
    \    return game if game.size == guess.size \n    game.each_with_index do |score,\
    \ index|\n        if game[index] == guess[index]\n            diff += score\n\
    \        else\n            diff += abs(game[index] - guess[index])\n        end\n\
    \    end\n    return diff\nend\n</code>\nThe main difference here is that we are\
    \ not using enumerators anymore here. We are just iterating through the lists\
    \ directly instead of using enumerators. \nThe idea here is that we iterate through\
    \ the first list to get the score for each index in the second list. When you\
    \ iterate through the first list again to get the next index, the result should\
    \ be the same. \nThe idea is simple. Take the first index from the first list.\
    \ If the item at that index is equal to the item at that index from the second\
    \ list, then add that score to the current score and continue. If they're not\
    \ equal, then add the difference between the two scores.\n<|/ a dscore=0 |>\n\
    <| c |>\nThanks, I figured it was a nested loop to get the values I wanted, but\
    \ just wasn't sure how to get the difference correctly. Also, I did read this\
    \ article but don't think it will apply to my current situation. http://rubylearning.com/blog/2009/04/ruby_enumerable.html\n\
    <|/ c |>\n<| c |>\nI added a little more explanation to the answer. Let me know\
    \ if it helps.\n<|/ c |>\n<| a tags=ruby |>\nHere's a fun way to do it.\n<code>",
  "    gamesize = size(game)\n    guesssize = size(guess)\n    diff = [0] * guesssize\n\
    \    gamemax = 0\n    for i in range(guesssize):\n        if game[i] == guess[i]:\n\
    \            diff[i] = 0\n        else:\n            gamemax = game[i] if game[i]\
    \ > gamemax else gamemax\n            diff[i] = abs(game[i] - guess[i])\n    diff\
    \ = diff[gamesize - 1:gamesize]\n    if gamesize > guesssize:\n        diff =\
    \ diff[:guesssize]\n    return diff\n</code>\n<|/ a tags=algorithm,python |>\n\
    <| c |>\nThank you! I changed it to your code. The problem is that it works only\
    \ if all the numbers are correct. If there is only one match, it doesn't work\
    \ at all.\n<|/ c |>\n<| c |>\nI used your solution in my code and made my own\
    \ one (which is far from perfect).\n<|/ c |>\n<| a tags=algorithm,python |>\n\
    I changed my code according to Jason S. suggestion.\n<code>", "  (0...game.size).map\
    \ { |i| guess[i] ? game[i] - guess[i] : (game[i] - guess[i].abs) }\nend", "  \
    \  game, guess = map(Array[Int], game, guess)\n    game.zipWithIndex.filter{case\
    \ (score, index) => (game(index) == guess(index))}.map(identity).map{case (score,\
    \ index) => abs((guess(index) - score))}\nend", "  # Your code here\n  result\
    \ = [0,0,0]\n  for i in range(guess.length)\n    if game[i] == guess[i]\n    \
    \  result[0] += 1\n    else\n      result[1] = abs(game[i] - guess[i])\n     \
    \ result[2] = abs(game[i] - guess[i])\n  return result\nend", "    guess = guess[0...-1]\n\
    \    score = game[0...-1]\n    return score - guess\nend", "    \n    # set some\
    \ initial values to make things easier\n    total = 0\n    correct = 0\n    \n\
    \    # loop over each guess and compare it to each item in the game\n    # if\
    \ the guess is equal to the item then increment the correct counter\n    # otherwise\
    \ add the absolute difference between the guess and the item\n    # to the total\
    \ counter\n    # then return the total\n    for guess in guess\n        total\
    \ = 0\n        correct = 0\n        \n        for game in game\n            total\
    \ += game.index(guess)\n            correct += game.index(guess)\n        end\n\
    \        \n        if total == game.length\n            return correct\n     \
    \   end\n    end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThank you so much\
    \ for the solution and the explanation! It really helped me a lot. I\u2019m still\
    \ having trouble grasping the concept of nested loops. I\u2019m going to go ahead\
    \ and study a little more, but if you have any good books or online resources\
    \ to get me started I would greatly appreciate it! Thanks again!\n<|/ c |>\n<|\
    \ c |>\n- I've added a bit of explanation to the answer.\n<|/ c |>\n<| c |>\n\
    Wow! Thanks so much for the explanation! I understand it now that I\u2019m using\
    \ nested loops correctly. Thanks again!\n<|/ c |>\n<| a tags=ruby |>\nHere is\
    \ another possible solution using Ruby's Enumerable#each_cons method.\n<code>",
  "    count = 0\n    i = 0\n    j = 0\n    results = []\n    \n    while i < guess.length\
    \ and j < game.length\n        if game[j] == guess[i]\n            j += 1\n  \
    \          i += 1\n        else \n            if j > 0\n                count\
    \ = j - i + 1\n                results.push(count)\n            i = 0\n      \
    \      j += 1\n            \n    count += j - i + 1\n    results.push(count)\n\
    \    \n    return results\n    \n    \n</cell>\n<cell>", "  score = 0\n  guesses\
    \ = 0\n  i = game.length\n  j = guess.length\n  game.length = j\n  guess.length\
    \ = i\n  for i in 0...i\n    game[i] = guess[i] or guess[i]\n  end\n  for i in\
    \ 0...j\n    guesses = guesses or guess[i]\n  end\n  for i in 0...i\n    score\
    \ = score + abs(game[i] - guess[i]) unless (guess[i] == 0 && guesses)\n  end\n\
    \  for i in 0...i\n    game[i] = 0\n  end\n  return [score, score, score, score,\
    \ score, score, score, score, score, score, score, score, score, score, score]\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThank you very much for this code. I'm\
    \ looking forward to testing it out.\n<|/ c |>\n<| c |>\nI tested it out and it\
    \ works, but now I have to figure out how to get it to print out the \"right\"\
    \ answer. I've been working on this for a while, and I'm coming up with nothing.\n\
    <|/ c |>\n<| c |>\nIf your question is solved please accept an answer and ask\
    \ a new question if you have problems.\n<|/ c |>\n<| c |>\nI was able to figure\
    \ it out, but now when I try to run it it says \"syntax error, unexpected '=',\
    \ expecting keyword_end\". Do you know why this is happening?\n<|/ c |>\n<| c\
    \ |>\nThere was a missing `end` statement near the end of the code snippet. I've\
    \ edited my post to include it here.\n<|/ c |>\n<| a tags=ruby |>\nThe solution\
    \ proposed by is awesome. I've done the following. This one is not the most elegant,\
    \ but it gets the job done. It also returns an array with the score for each guess.\n\
    <code>", "    \n    # Your code here\n    game = game\n    guess = guess", " \
    \ return [game[i] - guess[i] for i in range(0,guess.length)] if guess.length ==\
    \ game.length else game.map { |g| guess.length - g.length }.max\nend", "    game.each\
    \ { |value| guesses << value+guess }\n    guesses.each_with_index do |value, index|\n\
    \        difference = game[index] - value\n        correct ? 0 : (difference)\n\
    \    end\nend", "  return [0 if g == 0 else abs(g - s) for g, s in zip(game, guess)]\n\
    \  ", "  n = game.count\n  g = guess.count\n  diffs = [0 for _i in 0...n]\n  for\
    \ i in 0...n\n    diffs[i] = game[i] - guess[i]\n  end\n  for j in 0...g\n   \
    \ diffs[j] = abs(diffs[j])\n  end\n  return diffs\nend", "  return [game[i] -\
    \ guess[i] for i in range(0,7) if game[i] != 0]\nend", "  correct = 0\n  for i\
    \ in 0...guess.length\n    if game[i] == guess[i]\n      correct+=1\n    end\n\
    \  end\n  diffs = []\n  for i in 0...guess.length\n    diffs[i] = abs (guess[i]\
    \ - game[i]) \n  end\n  return diffs\nend\n</cell>\n<code language=julia-1.5>",
  "  game.length == guess.length\n  guesses = Array.new\n  game.length.times do |i|\n\
    \    if guess[i]==game[i]\n      guesses.push(0)\n    else\n      guesses.push(game[i]\
    \ - guess[i])\n    end\n  end\n  guesses\nend", "  guesses = Array.new(guess.size,\
    \ 0)\n  scores.each_with_index do |s, i|\n    guesses[i] = if s == guess[i] then\
    \ 0 else (abs(s - guess[i]))\n  end\n  guesses\nend\n</cell>\n<cell>", "  guess\
    \ = guess.map{|v| v < 0 ? -v : v}\n  diff = []\n  game.each_with_index do |score,\
    \ idx|\n    if score == guess[idx]\n      diff << 0\n    elsif score < guess[idx]\n\
    \      diff << score - guess[idx]\n    elsif score > guess[idx]\n      diff <<\
    \ guess[idx] - score\n    end\n  end\n  diff\nend", "    return game.length -\
    \ guess.map{|item| item > 0 ? item : -item }\nend\n</code>\n<|/ a tags=ruby,arrays,math\
    \ |>\n<| c |>\nThanks very much. I appreciate your help with this! It makes so\
    \ much more sense.\n<|/ c |>\n<| a |>\nHere's another way to solve it\n<code>",
  "  guess = guess.sort\n  game = game.sort\n  diff = []\n  max_score = -game[0]\n\
    \  max_guess = -guess[0]\n  max_guess = guess.find{|x|x == max_guess}\n  max_score\
    \ = -game[0]\n  max_score = game.find{|x|x == max_score}\n  game.each_with_index\
    \ do |score, index|\n    index = index if score == max_score || score == max_guess\n\
    \    diff = diff + [max_score - score] unless index == game.length-1\n  end\n\
    \  diff = diff.reverse\nend\n</cell>\n<code language=conda-env-adventofcode-py>\n\
    %w{\n  compare\n  guess\n  game\n}.each do |method_name|\n  assert_equal(['compare',\
    \ 'guess', 'game'], method_name.split('_').map(&:capitalize))\nend\n</cell>\n\
    <text>\nPart 4\nThe match function below takes in two arrays of scores and guesses,\
    \ compares them, and returns a list of differences between the two arrays.\nExample:\n\
    guesses = [1,2,3,4,5,1]\nscores = [1,2,3,4,5,1]\nThe result of the match function\
    \ should be [5,0,-3,-5,-3,0]", "  game = game.flatten.uniq\n  guess = guess.flatten.uniq",
  "    game = game.sort.to_a\n    guess = guess.sort.to_a\n    guesses = 0\n    games\
    \ = 0\n    guesses = []\n    games = []\n    while game != [] and guess != []\n\
    \        games << game.last\n        games << guess.length\n        guesses <<\
    \ guess.last\n        guesses << guess.length\n        game.pop\n        guess.pop\n\
    \    end\n    \n    return games\nend", "    game_size = len(game)\n    guess_size\
    \ = len(guess)\n    wrong_guess = []\n    right_guess = []", "    # Write your\
    \ code here\n    if game.count == 0\n        return guess\n    guess = 0\n   \
    \ \n    score.count  = 0\n    score2.count = 0\n    \n    diff = [guess[a] - game[a]\
    \ for a in range(len(guess))]\n    score2 = [guess[a] - game[a] for a in range(len(guess))]\n\
    \    \n    if diff == [0 for x in range(len(guess))]:\n        return 0\n    else:\n\
    \        return [min(diff), max(diff)]", "    \n    return []\n</cell>\n<cell>\n\
    compare([1,2,3,4,5,1],[1,2,3,4,2,-2])\n</cell>\n<cell>\ncompare([0,5,0,0,0,4],[4,1,1,0,0,-2])\n\
    </cell>\n<cell>\ncompare([0,5,0,0,0,4],[4,1,1,0,0,0])\n</cell>\n<cell>", "  \n\
    \  # your code here\n  \n  game = game.flatten\n  guess = guess.flatten\n  delta\
    \ = []\n  game.each do |game_value|\n    guess.each do |guess_value|\n      delta\
    \ = delta + (game_value - guess_value)\n    end\n  end\n  return delta\nend",
  "\tgameSize = length(game)\n\tguesses = length(guess)\n\tcorrect = Array.new\n\t\
    for i in 0...gameSize\n\t\tcorrect[i] = 0\n\tfor i in 0...guesses\n\t\tcorrect[i]\
    \ = game[i] - guess[i]\n\tcorrect = correct.map(&:abs)\n\treturn correct\nend",
  "  # your code\nend", "    # This is our initial state and all variables that we\
    \ will later update during the loop.\n    i = 0\n    gameResult = game[i]\n  \
    \  gameGuess = guess[i]\n    result = 0\n    gameGuessedCorrectly = False", " \
    \ game = [game] + [0] * (len(guess) - 1)\n  guess = [guess] + [0] * (len(game)\
    \ - 1)\n  result = [0, 0, 0]\n  for i in 0 ... len(game) - 1:\n    for j in 0\
    \ ... len(guess) - 1:\n      if not (game[i] == guess[j] and game[i] or guess[j]):\n\
    \        result[0] += 1 if game[i] else 0\n        result[1] += 1 if guess[j]\
    \ else 0\n        result[2] += abs(game[i] - guess[j])\n        break\n  return\
    \ result\nend", "  winning = 0\n  for i in 0...(game.length)\n    if game[i] ==\
    \ guess[i]\n      winning += 1\n    end\n  end\n  return winning\nend", "  # Your\
    \ code here\n  result = Array.new\n  result_index = 0\n  game_index = 0\n  guesses_index\
    \ = 0\n  guess_index = 0\n  while guess_index < guess.length\n    if guess[guess_index]\
    \ == game[game_index] \n      result << 0\n      game_index += 1\n    elsif guess[guess_index]\
    \ > game[game_index]\n      result << guess[guess_index] - game[game_index]\n\
    \      game_index += 1\n      result_index += 1\n    elsif guess[guess_index]\
    \ < game[game_index]\n      result << guess[guess_index] - game[game_index]\n\
    \      guesses_index += 1\n      guess_index += 1\n      game_index += 1\n   \
    \ end\n  end\n  return [result,guesses_index] if guesses_index == 0 \n  return\
    \ [result,guesses_index] + compare(game, guess[guesses_index..-1])\nend", "  game_size\
    \  = game.size\n  guess_size = guess.size\n  \n  game     = (game == guess_size)\
    \ ? 0 : abs(game-guess_size)\n  game     = (game.nonzero?) ? game.max: game\n\
    \  guess    = (guess == guess_size) ? 0 : abs(guess-guess_size)\n  guess    =\
    \ (guess.nonzero?) ? guess.max: guess\n  \n  result    = Array.new (guess_size).fill(0)\n\
    \  \n  game.each_with_index do |v,i|\n    guess[i].each_with_index do |g,j|\n\
    \      result[j] += (v==g) ? 0 : abs(v-g)\n    end\n  end\n  \n  result\nend",
  "  guesses_count = 0\n  winner = game[0]\n  difference = 0\n  for i in 0...guess.length\n\
    \    if guess[i] == winner\n      guesses_count += 1\n      difference += 0\n\
    \    else\n      difference += abs(guess[i] - game[i])\n    end\n  end\n  difference\
    \ = [difference, guesses_count]\n  return difference\nend\n</cell>\n<code language=julia-0.6>",
  "    # Your code here\n    \n    # your code here\n    differences = []\n    \n\
    \    for i in range(len(game)):\n        if game[i] == guess[i]:\n           \
    \ differences.append(0)\n        elif game[i] > guess[i]:\n            differences.append(abs(game[i]\
    \ - guess[i]))\n        else:\n            differences.append(abs(guess[i] - game[i]))\n\
    \    \n    return differences", "    # write your code here\n    return guess",
  "    game = game.sort.reverse!\n    guess = guess.sort.reverse!\n    guessed.each_with_index\
    \ do |val, index|\n        if val == guess[index]\n            guessed.replace(val)\n\
    \        else\n            guessed += (val - guess[index])\n        end\n    end\n\
    \    guessed\nend\n</cell>\n<cell>", "  guess_min = game.min\n  guess_max = game.max\n\
    \  guess_total = game.sum\n  scores = [guess_total]\n  guesses = Array.new(guess.length)\n\
    \  guesses.fill(guess_total)\n  for i in 0...game.length-1\n    if game[i] ==\
    \ guess_total\n      guesses[i] = 0\n      continue\n    guesses[i] = abs(guess[i]\
    \ - game[i]) \n  end\n  guesses.each do |i|\n    if guess[i] == guess_min\n  \
    \    scores[i] = 0\n    elsif guess[i] < guess_min\n      scores[i] = guess[i]\
    \ - guess_min\n    elsif guess[i] > guess_max\n      scores[i] = guess_max - guess[i]\n\
    \    else\n      scores[i] = guess[i] - guess_total\n    end\n  end\n  scores.sort\n\
    end", "    score = 0\n    i = game.length()\n    j = guess.length()\n    while\
    \ i != 0 and j != 0\n        score += game[i]-guess[j]\n        if game[i] > guess[j]\n\
    \            i -= 1\n        else\n            j += 1\n    return score\n</code>\n\
    The first line is a bit of rubbish code but it's all I have to solve the problem\
    \ with. I'm sure you can figure out the rest.\n<|/ a dscore=2 |>\n<| a |>\n<code>",
  "    game = game.to_a\n    guess = guess.to_a\n    diff = Array.new(guess.size)\n\
    \    \n    game.each_with_index do |val, idx|\n      if guess[idx] == val\n  \
    \      diff[idx] = 0\n      else\n        diff[idx] = val - guess[idx]\n     \
    \ end\n    end\n    \n    diff.select { |x| x < 0 }.map { |x| -x }\nend", "  game\
    \ = game.to_a\n  guess = guess.to_a\n  correct = 0\n  wrong = 0\n  game.length.times\
    \ do |i|\n    correct += game[i] >= guess[i] ? 1 : 0\n    wrong += 1\n  end\n\
    \  return[correct, wrong]\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe problem\
    \ is that the score array is also not sorted. Thus, it would be better to use\
    \ the index of the score in the array.\n<|/ c |>\n<| c |>\nI meant that `game\
    \ = game.to_a` and `guess = guess.to_a` need to be used after the `sort`.\n<|/\
    \ c |>\n<| a tags=ruby,arrays |>\n<code>", "  game.zip(guess).map { |(s,g)| s\
    \ == g ? 0 : abs (s - g) }\nend\n</code>\nThe above code also uses map to return\
    \ an array of the differences between the two arrays, instead of comparing them\
    \ with ==. Since we are using zip to merge the two arrays into a single array,\
    \ we can use map to map each element of it to a function that compares the score\
    \ with the guess:\n<code>", "  game = game.map { |i| i.to_i }\n  guess = guess.map\
    \ { |i| i.to_i }\n  guesses = guess - game\n  diff = game.zip(guesses).map { |x,y|\
    \ x != y ? abs(x-y) : 0 }\n  return diff\nend", "  game = [game] if game.length\
    \ == guess.length then game\n  guess = [guess] if guess.length == game.length\
    \ then guess\n  scores = [game,guess].transpose\n  diffs = []\n  games.each_with_index\
    \ do |g,i|\n    guess = guesses[i]\n    score = scores[i]\n    diffs << score\
    \ - guess unless guess < score\n  end\n  diffs\nend", "\t\n\tgame_size = len(game)\n\
    \tguess_size = len(guess)", "    arr = game.length\n    arr_guess = guess.length\n\
    \    score = 0\n    arr_diff = []\n    i = 0\n    j = 0\n    \n    while i < arr\
    \ and j < arr_guess\n        if game[i] == guess[j]\n            score += 0 #\
    \ if the value is the same, score is 0\n        else \n            score += abs(game[i]\
    \ - guess[j]) # if the value is not the same, score is abs(game[i] - guess[j])\n\
    \        i += 1\n        j += 1\n        \n    # return an array\n    while i\
    \ < arr\n        score += 0\n        i += 1\n    return score\n</cell>\n<cell>\n\
    arr = [1,2,3,4,5,1]\narr_guess = [1,2,3,4,2,-2]\ncompare(arr, arr_guess) # returns\
    \ [0,0,0,0,3,3]\n</cell>\n<cell>\narr = [0,5,0,0,0,4]\narr_guess = [4,1,1,0,0,-2]\n\
    compare(arr, arr_guess) # returns [4,4,1,0,0,6]\n</cell>\n<text>\nQuestion 3\n\
    Write a function that takes in a list A of words and returns True or False depending\
    \ on whether a word can be found in the dictionary by going through all the words\
    \ in the dictionary.", "    # TODO - your implementation here\n    result = 0\n\
    \    \n    return result ", "  game = game.dup\n  guess = guess.dup\n  result\
    \ = []\n  \n  game.each_index do |i|\n    game.delete_at(i) unless game[i] >=\
    \ 0\n    guess.delete_at(i) unless guess[i] >= 0\n  end\n  \n  game.each_index\
    \ do |i|\n    result << game[i] - guess[i] unless game[i] == guess[i]\n  end\n\
    \  \n  result\nend", "    diff = []\n    guesses_count = guess.length\n    guesses_count\
    \ = 0 if guesses_count == 0 else guesses_count - 1\n    games_count = game.length\n\
    \    games_count = 0 if games_count == 0 else games_count - 1\n    for i in 0...guesses_count\n\
    \        for j in 0...games_count\n            diff[i] = diff[i] + (game[j] ==\
    \ guess[i]) ? 0 : abs(game[j] - guess[i])\n        end\n    end\n    return diff\n\
    end\n</cell>\n<code language=julia-1.5>", "    score = 0\n    guessed = [false\
    \ for i in 0..(guess.length-1)]\n    guessed_correct = [false for i in 0..(guess.length-1)]\n\
    \    for i in 0..(game.length-1)\n        if game[i] == guess[i]\n           \
    \ guessed_correct[i] = true\n            score += 0\n        else if game[i] >\
    \ guess[i]\n            guessed_correct[i] = true\n            score += 1\n  \
    \      else\n            guessed_correct[i] = false\n            score += abs(game[i]\
    \ - guess[i])\n    return guessed_correct, score\n</cell>\n<cell>", '  result
    = Array.new', "  result = []\n  game.each_with_index do |value, index|\n    if\
    \ guess[index] == value\n      result << 0\n    else\n      result << guess[index]\
    \ - value\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=arrays,ruby |>\n\
    <| c |>\n`guess[index]` can be `nil` so you should add an extra check in that\
    \ case.\n<|/ c |>\n<| c |>\nOh yes I forgot to add that. Thank you.\n<|/ c |>\n\
    <| a dscore=2 |>\nI thought I would present a solution which compares every entry\
    \ of the two arrays, rather than doing a single comparision.\n<code>", "  game_size\
    \ = game.length\n  guess_size = guess.length\n  guessed_correctly_array = []\n\
    \  result = []\n  for i in 0...game_size\n    if game[i] == guess_size then\n\
    \      guessed_correctly_array[i] = 0\n      break\n    end\n    guessed_correctly_array[i]\
    \ = guess_size - game[i]\n  end\n  for i in 0...guess_size\n    if guess[i] ==\
    \ game_size then\n      guessed_correctly_array[i] = 0\n      break\n    end\n\
    \    guessed_correctly_array[i] = guess[i] - game[i]\n  end\n  for i in 0...game_size\n\
    \    result << guessed_correctly_array[i]\n  end\n  return result\nend\n</cell>\n\
    <code language=julia-1.5>", "  result = []\n  for i in 0..(guess.length-1)\n \
    \   result[i] = 0\n    \n  for i in 0..(game.length-1)\n    result[i] += guess[i]\
    \ == game[i] ? 0 : (guess[i] - game[i])\n    \n  result.max\nend", "    game =\
    \ game.to_a\n    guess = guess.to_a", "  return game\nend", "  correct = 0\n \
    \ wrong = 0\n  score = 0\n  \n  for i in 0...game.count\n    if game[i] != guess[i]\n\
    \      correct += 1\n    else \n      wrong += (guess[i] - game[i])\n    end\n\
    \  end\n  \n  score = (-wrong) if (correct > wrong) else\n    (correct - wrong)\
    \ if (correct < wrong) else\n    wrong\n  \n  return [-score...score]\nend", " \
    \   game.each_with_index do |score, index|\n        guess[index] = score if guess[index]\
    \ == 0\n    end\n    guess = guess.map(&:abs)\n    score = game.map(&:abs)\n \
    \   guess = guess.zip(score).transpose\n    guess = guess.map do |x, index|\n\
    \        if guess[index] == 0\n            0\n        elsif guess[index] == score[index]\n\
    \            0\n        else\n            x - score[index]\n        end\n    end\n\
    end", "    game = game.sort\n    guess = guess.sort\n    i = 0\n    j = 0\n  \
    \  diff = []\n    diff_i = 0\n    diff_j = 0\n    \n    while i < game.length\
    \ and j < guess.length\n        if game[i] == guess[j]\n            i += 1\n \
    \           j += 1\n        else\n            i = game.length\n            j =\
    \ guess.length\n            diff_i += abs(game[i] - guess[j])\n            diff_j\
    \ += abs(guess[j] - game[i])\n        end\n    end\n    \n    diff_i.to_a.concat(diff_j.to_a)\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nthank you for your answer, I've made\
    \ some tests and I believe your code returns the same value as mine, it's just\
    \ slower and the test result are different. Thank you for your answer anyway I\
    \ appreciate it. Your code returns an array of the same length as my array where\
    \ each value is a difference between 2 elements of the array. My array is an array\
    \ of integers and I need an another array with the same length as my array where\
    \ each value is the difference between 2 numbers of the array (so it's a difference\
    \ between 2 array elements)\n<|/ c |>\n<| c |>\nSorry for the misunderstanding,\
    \ I misread the question. I was thinking of the differences between the elements\
    \ in both arrays and this was how I interpreted the question initially. I will\
    \ update the answer with what I believe is the correct interpretation.\n<|/ c\
    \ |>\n<| c |>\nI updated my answer with what I think should be the correct solution\n\
    <|/ c |>\n<| c |>\nI did some tests and it works fine but it's a bit slow and\
    \ I don't know why. I have an array of 131 elements and I put a break point in\
    \ my function and it breaks when I test the first element of the array. I guess\
    \ there is something that makes it slow but I don't know why, I put a break point\
    \ at `while i < game.length and j < guess.length` and it breaks when I test the\
    \ 1st element of the array. It's a total of only 10 tests so the program will\
    \ break on this first test, it takes about 1 second to execute the function, but\
    \ I still think it's too slow and don't know why\n<|/ c |>\n<| c |>\nI think your\
    \ function is definitely slower than mine but I don't understand why. Maybe the\
    \ test is not good enough and I have to find a way to make it faster.\n<|/ c |>\n\
    <| a tags=ruby |>\nThe test is slow because I tested it on small arrays and it\
    \ didn't stop before the end of array, so the function doesn't get enough time\
    \ to reach the end of the test and the test is never finished. Now I tested it\
    \ on larger arrays and it ", "  return game-guess\nend", "  # your code goes here\n\
    \  return\nend", "  diff = 0\n  \n  # your code here\n  \n  return diff\nend",
  "    # your implementation here\n    score = game.to_a\n    answer = guess.to_a\n\
    \    answers = Array.new(guess.length)\n    # loop through all guesses\n    guess.each\
    \ do |guess|\n        # loop through all scores\n        score.each do |score|\n\
    \            # check if guess is on current score\n            if guess == score\n\
    \                # if guess is on current score\n                # return 0\n\
    \                answers[guess.length] = 0\n                break\n          \
    \  else\n                # if guess is not on current score\n                #\
    \ return difference between guess and score\n                answers[guess.length]\
    \ = if guess > score\n                                        guess - score\n\
    \                                    else\n                                  \
    \      score - guess\n                                    end\n            end\n\
    \        end\n    end\n    # return an array of guesses off by how far\n    answers\n\
    end\n</cell>\n<code language=julia-1.3>", "  game, guess = game, guess.flatten.sort.uniq\n\
    \  game.each_with_index do |c, i|\n    guess = guess.select { |a| a == i }\n \
    \   guess = 0 if guess.empty?\n    guess = guess.min { |x,y| (x <=> y) || x ==\
    \ y }\n    guess = guess.abs if guess != 0\n    guess[i] = guess\n  end\n  game\n\
    end\n</code>\n<|/ a tags=ruby,arrays,sorting,algorithm |>\n<| a tags=ruby,arrays,sorting,algorithm\
    \ |>\nI decided to put my answer here because I feel like this is a very interesting\
    \ question for those that want a solution in Ruby.\n<code>", "    i = 0\n    score\
    \ = 0\n    guesses = 0\n    answer = []\n    answer2 = []\n    correct = 0\n \
    \   while i < len(game) and i < len(guess)\n        if game[i] == guess[i]\n \
    \           score += 1\n            i += 1\n            guesses +=1\n        \
    \    answer = [score - guesses, guesses, score]\n            correct = 1\n   \
    \     elif game[i] != guess[i]\n            i += 1\n            guesses +=1\n\
    \            answer = [score - guesses, guesses, score]\n            correct =\
    \ 0\n    answer2 = answer\n    return answer2", '    return game-guess', "  if\
    \ game.length != guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    game.length, guess.length\n    game.length, guess.length\n\
    \    game.length, guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    game.length, guess.length\n    game.length, guess.length\n\
    \    game.length, guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    game.length, guess.length\n    game.length, guess.length\n\
    \    game.length, guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    game.length, guess.length\n    game.length, guess.length\n\
    \    game.length, guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    game.length, guess.length\n    game.length, guess.length\n\
    \    game.length, guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    game.length, guess.length\n    game.length, guess.length\n\
    \    game.length, guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    game.length, guess.length\n    game.length, guess.length\n\
    \    game.length, guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    game.length, guess.length\n    game.length, guess.length\n\
    \    game.length, guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    game.length, guess.length\n    game.length, guess.length\n\
    \    game.length, guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    game.length, guess.length\n    game.length, guess.length\n\
    \    game.length, guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    game.length, guess.length\n    game.length, guess.length\n\
    \    game.length, guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    game.length, guess.length\n    game.length, guess.length\n\
    \    game.length, guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    game.length, guess.length\n    game.length, guess.length\n\
    \    game.length, guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    game.length, guess.length\n    game.length, guess.length\n\
    \    game.length, guess.length\n    game.length, guess.length\n    game.length,\
    \ guess.length\n    ", "  result = [0 for i in range(len(guess))]\n  count = 0\n\
    \  for index, value in enumerate(guess)\n    count = count + 1 if game[index]\
    \ == value else 0\n    if count == len(game)\n      result[index] = 0\n    else\n\
    \      result[index] = abs(value - game[index])\n  end\n  return result\nend\n\
    </cell>\n<code language=julia-1.0>", "  return game-gues\nend", "  diff = nil\n\
    \  for i in 0..(guess.length-1)\n    diff[i] = abs(guess[i] - game[i])\n  end\n\
    end", "    answers = []\n    differences = []\n    size = game.size\n    guesses\
    \ = guess[0..(size-1)]\n    scores = game[0..(size-1)]\n    i = 0\n    size =\
    \ game.size\n    guesses.each do |g|\n        if guess[i] == scores[i]\n     \
    \       i += 1\n            differences.push(guess[i] - scores[i])\n        elsif\
    \ scores[i] > guess[i]\n            i += 1\n            differences.push(guess[i]\
    \ - scores[i])\n        else\n            differences.push(0)\n        end\n \
    \   end\n    differences.each do |difference|\n        if difference > 0\n   \
    \         answers << 0\n        elsif difference < 0\n            answers << difference\n\
    \        else\n            answers << 0\n        end\n    end\n    return answers\n\
    end\n</code>\n<|/ a |>\n<| c |>\nHow would you write this in Ruby using the new\
    \ syntax?\n<|/ c |>\n<| c |>\nYou would use `Array#chunk`, not `Array#each_slice`.\n\
    <|/ c |>\n<| c |>\nI'm also not sure why you use `guesses.each_slice(game_size)`\
    \ rather than `guess[0..(size-1)]`?\n<|/ c |>\n<| c |>\nBecause `guess[0..(size-1)]`\
    \ will be `[]` when `size == 0`.\n<|/ c |>\n<| c |>\nOh. I didn't think of that.\
    \ Thank you.\n<|/ c |>\n<| a |>\n<code>", "    game.reverse!\n    guess.reverse!\n\
    \    i = 0\n    correct = 0\n    wrong = 0\n    while i < game.length\n      \
    \  if game[i] == guess[i]\n            correct += 1\n        else\n          \
    \  wrong += 1\n            i = game.length - 1\n        end\n        i -= 1\n\
    \    end\n    \n    return [correct, wrong]\nend", "  guess, game = game.transpose,\
    \ guess.transpose\n  guess, game = guess.uniq, game.uniq\n  differences = 0..(guess.length).map\
    \ { |index|\n    (game.indexof(guess[index]) or game.length)\n  }\n  differences.map\
    \ { |index|\n    guess[index] || 0\n  }\nend\n</pre>", "  wins = 0\n  for i in\
    \ range(len(game))\n    if game[i] == guess[i]\n      wins += 1\n  end\n  diff\
    \ = [0, 0, 0]\n  for i in range(len(game))\n    diff[i] = abs(guess[i] - game[i])\n\
    \  end\n  return diff\nend", "  # initialize result with 0\n  result = [0] * len(guess)",
  "    \n    # Add your code here\n    answer = []\n    guess = guess.sort!\n    game\
    \ = game.sort!\n    score.each do |score|\n        guessed.each do |guessed|\n\
    \            if score == guessed then\n                answer.push(0)\n      \
    \      elsif score > guessed then\n                answer.push(abs(score - guessed))\n\
    \            else\n                answer.push(abs(guessed - score))\n       \
    \     end\n        end\n    end\n    return answer\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThe OP asked for a comparison between scores so if he wants to find how\
    \ much difference is between a score and an answer, then he should calculate the\
    \ `diff` variable instead of the `answer`. `diff` should contain the score difference\
    \ between each guess and answer instead of the whole array.\n<|/ c |>\n<| c |>\n\
    Thank you for your answer! I haven't been able to implement it yet but I think\
    \ it's because I haven't completely understood recursion and that's why it isn't\
    \ working as intended.\n<|/ c |>\n<| a |>\n<code>\nfunction compare(game,guess){\n\
    \    diff = [];\n    game.forEach(function(element,index){\n        diff.push(abs(element\
    \ - guess[index]));\n    });\n    return diff;\n}\n</code>\n<|/ a tags=ruby dscore=0\
    \ |>\n<| a |>\nHere's a slightly different approach that doesn't use any extra\
    \ arrays.  It uses an explicit loop over the indices of the game and guesses arrays.\
    \  This isn't really a recursive solution, but it does use more explicit variable\
    \ names.\n<code>", "  guesses.zip(game).inject([]) {|sum, (x, y) | (sum << 1).tap\
    \ { sum << x - y } }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like\
    \ this solution because it does a lot of things in one go, thanks!\n<|/ c |>\n\
    <| c |>\nWhoa, cool solution! I didn't know about inject!\n<|/ c |>\n<| c |>\n\
    No problem, glad I could help. Also, glad to see you like it! :)\n<|/ c |>\n<|\
    \ c |>\n: You might want to edit your first example to demonstrate that `[0,0,0,0,3,3]`\
    \ is the correct answer.\n<|/ c |>\n<| c |>\nGood catch. Fixed it.\n<|/ c |>\n\
    <| a |>\n<code>", "  puts \"GAME: #{game.inspect}\"\n  puts \"GUESS: #{guess.inspect}\"\
    \n  guess = guess.to_f\n  game = game.to_f\n  \n  diff = []\n  \n  i = 1\n  \n\
    \  # Calculate the difference between the guess and the score\n  diff.push guess\
    \ - game[i]\n  \n  i += 1\n  \n  loop do\n    \n    # Calculate the difference\
    \ between the guess and the score\n    diff = guess - game[i]\n    \n    # If\
    \ we get a number greater than or equal to 0, then guess is correct\n    if diff\
    \ >= 0\n      # We have guessed correctly - break\n      break\n    elsif diff\
    \ < 0\n      # We have guessed wrong - subtract the difference from the current\
    \ guess\n      guess = guess - diff\n    else\n      # We have guessed wrong -\
    \ subtract the difference from the current guess\n      guess = guess + diff\n\
    \    end\n    \n    i += 1\n  end\n  \n  puts \"DIFF: #{diff}\"\n  puts \"GUESS:\
    \ #{guess}\"\n  puts \"GAME: #{game}\"\n  \n  return diff\nend", "    # Your code\
    \ here\n    score = game.size\n    guess = guess.dup\n    diffs = Array.new(game.size)\n\
    \    i = 0\n    while i < score\n        if guess[i] == game[i]\n            diffs[i]\
    \ = 0\n        else\n            diffs[i] = Math.abs (guess[i]-game[i])\n    \
    \    end\n        i += 1\n    end\n    diffs\nend", "    differences = 0..guess.length\n\
    \    game.length.times do |i|\n        differences[i] = (game[i]-guess[i])\n \
    \   end\n    differences.each_with_index do |difference, index|\n        if difference\
    \ < 0\n            differences[index] = 0\n        else\n            differences[index]\
    \ = difference\n        end\n    end\nend", "    matches = 0\n    while matches\
    \ <= len(guess)\n        if game[matches] == guess[matches]\n            matches\
    \ +=1\n        end\n    end\n    correct = 0\n    for i in 0..(matches)\n    \
    \    if game[i] == guess[i]\n            correct +=1\n        end\n    end\n \
    \   if correct == matches\n        return [0,0,0,0,0]\n    end\n    sum = 0\n\
    \    for i in 0..(matches)\n        sum +=abs(game[i] - guess[i])\n    end\n \
    \   return sum\nend\n</cell>\n<code language=julia-0.5>", "  game.length == guess.length\n\
    \  game.zip(guess).map { |a,b| abs(a-b) }\nend", "  #\n  # fill in the blanks\n\
    \  #\nend", "  game.reverse!\n  guess.reverse!\n  result = []\n  game_size = game.size\n\
    \  guess_size = guess.size\n  \n  result.clear\n  guesses_corrected = []\n  guesses_total\
    \ = 0\n  \n  i = 0\n  j = 0\n  \n  while (i < game_size) && (j < guess_size)\n\
    \    if game[i] == guess[j] # Same as game[i] == guess[j], but faster\n      guesses_corrected\
    \ << i\n      guesses_total += 1\n      i += 1\n      j += 1\n    else \n    \
    \  # If there is a mismatch on the current index, we found a winning combo\n \
    \     guesses_corrected << (guess_size - j) + i\n      guesses_total += 1\n  \
    \    i -= 1\n      break\n    end\n  end\n  \n  result = (game.size - guesses_corrected).times.collect\
    \ {|i| guesses_corrected[i]}\n  \n  result\nend", "  result = [0,0,0,0]\n  correct\
    \ = 1\n  for i in 0..guess.length-1\n    score = -guess[i]\n    guess[i] = game[i]\n\
    \    game[i] = score\n    diff =\n    if game[i] == score\n      correct += 1\n\
    \    end\n    guess[i] = 0\n    game[i] = 0\n    result[i] = diff if game[i] ==\
    \ score else (diff > 0 ? 1 : -1)\n  end\n  result\nend", end, "  score.clear #\
    \ Clear the score array\n  game.each_with_index do |score, index|\n    unless\
    \ guess[index] == score # If the two do not match\n      score - guess # Add the\
    \ difference\n    end\n    score[index] = 0 # If they match correctly, set the\
    \ value to 0\n  end\n  score\nend\n</code>\n<|/ a |>\n<| a tags=arrays,ruby,ruby-on-rails\
    \ |>\nA solution using Array#permutation:\n<code>", "  # Your code goes here\n\
    \  game = game.sort!.collect{|x| x}\n  guess = guess.sort!.collect{|x| x}\n  guessed_count\
    \ = 0\n  correct_count = 0\n  differences = []\n  game.each_with_index do |val,\
    \ index|\n    if guess[index] == val\n      guessed_count += 1\n    else \n  \
    \    differences << val - guess[index]\n    end\n    if guess[index] == val\n\
    \      correct_count += 1\n    end\n  end\n  return [guessed_count, correct_count,\
    \ differences]\nend", "  i = 0\n  score = 0\n  game.length\n  guess.length\n \
    \ while i < game.length and score == 0\n    if game[i] > guess[i]\n      score\
    \ += abs(game[i] - guess[i])\n      i += 1\n    else \n      score += abs(guess[i]\
    \ - game[i])\n      i += 1\n  end\n  score\nend\n</cell>\n<code language=julia-1.0>",
  "    game, guess = game.reverse, guess[::-1]\n    scores = [ (guess[i] - game[i])\
    \ for i in range(len(guess)) ]\n    \n    return [ 0 if scores[i] == 0 else abs(scores[i])\
    \ for i in range(len(scores)) ]\n</cell>\n<cell>", "  # TODO: implement this function\n\
    \  \n  # My solution:\n  game_size = game.size\n  guess_size = guess.size\n  answer\
    \ = []\n  index = 0\n  \n  while index < game_size\n    if game[index] == guess[index]\n\
    \      index += 1\n      answer.push(game[index])\n    else\n      answer.push(game[index]\
    \ - guess[index])\n      index += guess_size\n    end\n  end\n  answer\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
