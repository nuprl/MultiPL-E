name: HumanEval_33_sort_third
language: rb
prompt: "# This function takes a list l and returns a list l' such that\n# l' is identical\
  \ to l in the indicies that are not divisible by three, while its values at the\
  \ indicies that are divisible by three are equal\n# to the values of the corresponding\
  \ indicies of l, but sorted.\n# >>> sort_third([1, 2, 3])\n# [1, 2, 3]\n# >>> sort_third([5,\
  \ 6, 3, 4, 8, 9, 2])\n# [2, 6, 3, 4, 8, 9, 5]\ndef sort_third(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_third\n\
  \    candidate = method(:sort_third)\n    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5,\
  \ 6, 3, 4, 8, 9, 2]))\n    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5,\
  \ 8, 3, 4, 6, 9, 2]))\n    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5,\
  \ 6, 9, 4, 8, 3, 2]))\n    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5,\
  \ 6, 3, 4, 8, 9, 2, 1]))\n  end\nend\n"
completions: ["    l.each_with_index {|x, i| l.delete_at(i) if i % 3 != 0}\n    l.sort!\n\
    \    l\nend\n</code>\n<|/ a |>\n<| c |>\nThis was really helpful. I would give\
    \ you more points, but my reputation is too low.\n<|/ c |>\n<| c |>\nI wouldnt\
    \ have thought it would be necessary to delete the indices from the array first,\
    \ but I'm glad you made that suggestion.  Thanks for posting.\n<|/ c |>\n<| c\
    \ |>\nThis assumes the array is sorted.\n<|/ c |>\n<| c |>\nNo, this doesn't,\
    \ but it does not require it to be sorted.\n<|/ c |>\n<| a |>\nHere is a bit cleaner\
    \ version.\n<code>", "  l.each_with_index { |e, i| l[i] = e if i % 3 == 0 && i\
    \ != l[i] }.sort\nend", "\tnew_l = l\n\tcount = 0\n\twhile count < l.count\n\t\
    \tnew_l.sort!\n\t\tcount += 1\n\tnew_l\nend", "\tindex = 0\n\tlistLength = l.length\n\
    \twhile index < listLength\n\t\tthird = index * 3\n\t\twhile third + 3 < listLength\n\
    \t\t\tif l[third] == l[third + 3]\n\t\t\t\tl[third], l[third + 3] = l[third +\
    \ 3], l[third]\n\t\t\t\tthird = third + 3\n\t\t\telse\n\t\t\t\tthird = third +\
    \ 3\n\t\tindex = index + 1\n\tend\nend", "  l.sort\n  return l.reduce(:+)\nend",
  "  l.sort\n  l.each_with_index { |e, i| l[i] = e if i % 3 == 0 }\n  return l\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis solution is very good but the problem was I did\
    \ not understand how to do the sorting. Thanks.\n<|/ c |>\n<| c |>\nThis is exactly\
    \ how I would have done it. It's a clever solution that I wasn't even aware of\
    \ until I saw it. I was looking for an answer without using `sort`.\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails,sorting |>\n<code>", "  l2 = []\n  l3 = []\n  l.each_with_index\
    \ do |e, i|\n    if i % 3 != 0\n      l3 << e\n    else\n      l2 << e\n    end\n\
    \  end\n  l2 + l3\nend", "  l.sort!\n  l = l.each_with_index.map {|e, i| [e, i]\
    \ if i % 3 == 0 }.sort\n  l.inject {|a, e| a.push e[0] } << l[0][0]\nend\n</code>\n\
    <|/ a |>\n<| a |>\n<code>", "  i = 0\n  while i < l.size\n    i += 1\n    if l[i]\
    \ % 3 == 0\n      l.delete_at(i)\n    else\n      l[i] += l[i-1]\n      l[i-1]\n\
    \      l[i] = l[i-1] + l[i]/3\n    end\n  end\n  l\nend", "  l.sort_by!\n  l.each_with_index\
    \ do |x, i|\n    if (i % 3 == 0)\n      l[i] = l[i-1]\n    end\n  end\nend", " \
    \ l.each_with_index do |e,i|\n    if (i%3 == 0)\n      l[i] = l[i/3]\n    end\n\
    \  end\n  return l.sort\nend\n</code>\n<|/ a tags=ruby,arrays,sorting dscore=1\
    \ |>\n<| a |>\nHere's another solution that is simple and doesn't require you\
    \ to write any additional methods. It is based on the idea that you can use the\
    \ modulo operator % to divide the elements of a list by 3 to make a new list that\
    \ is divided by 3 but the elements are still sorted. \n<code>", "\tl.sort\n\t\
    l.each_with_index do |elem, i|\n\t\tj = (i + 1) % 3\n\t\tl[i] = l[j] if elem %\
    \ 3 == 0\n\t\tl[j] = elem if elem % 3 != 0\n\tend\n\treturn l\nend", "  \n  #\
    \ create a list with indicies that are divisible by three set to 1\n  ld_3 = l.select\
    \ {|x| x % 3 == 0 }\n  \n  # get a list of indicies that are divisible by three\
    \ but are also not divisible by five or six\n  ld_3_p = ld_3.select {|x| x % 3\
    \ != 0 && !x % 5 == 0 && x % 6 == 0 }\n  \n  # get a list of indicies that are\
    \ divisible by three\n  ld_3_p1 = ld_3.select {|x| x % 3 == 0 }\n  \n  # create\
    \ a list with all indicies that are divisible by three but are also not divisible\
    \ by five or six set to 1\n  ld_3_p_1 = ld_3_p1.select {|x| x % 3 != 0 && !x %\
    \ 5 == 0 && x % 6 == 0 }\n  \n  # create an array of all values that will be the\
    \ values of the new list\n  new_vals = ld_3_p1.map {|x| l[x] }\n  \n  # get the\
    \ indicies that do not appear in ld_3_p1\n  ld_3_p1_indicies = [ld_3_p1.index(x)\
    \ + 1 for x in ld_3_p1]\n  \n  # take the indicies from new_vals that do not appear\
    \ in ld_3_p_1 and add them to ld_3_p_1\n  ld_3_p_1 += ld_3_p1_indicies.map {|x|\
    \ new_vals[x-1]}\n  \n  # create a new list by replacing the values in ld_3_p1\
    \ with the corresponding values from new_vals\n  ld_3_p1 = new_vals.map {|x| ld_3_p1[x-1]}\n\
    \  \n  # create a new list by replacing the values in ld_3_p1 with the corresponding\
    \ values from new_vals\n  ld_3_p1 = new_vals.map {|x| ld_3_p1[x-1]}\n  \n  # get\
    \ the indicies that do not appear in ld_3_p\n  ld_3_p_indicies = [ld_3_p.index(x)\
    \ + 1 for x in ld_3_p]\n  \n  # take the indicies from new_vals that do not appear\
    \ in ld_3_p_1 and add them to ld_3_p\n  ld_3 += ld_3_p_indicies.map {|x| new_vals[x-1]}\n\
    \  \n  # return a new list with the indicies in ld_", "  l.each_with_index do\
    \ |e, i|\n    l[i] = l[i] * 2 if i % 3 == 0\n  end\n  l.sort\nend", "  return\
    \ l + [l[0]] + l[2..-1].reject { |i| l[i] % 3 == 0 }\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby,arrays |>\nUsing Enumerable#sort_by:\n<code>", "  l.each_with_index\
    \ do |n,i|\n    next if i%3 == 0\n    l.delete n\n  end\n  l\nend", "  l.each\
    \ do |i|\n    l.delete(i)\n  end\n  l.reduce(:+)\nend\n</code>\n<|/ a tags=sorting,ruby\
    \ |>\n<| a |>\nA different approach to this:\n<code>", "  l.sort.with_index do\
    \ |value, index|\n    # find first value that isn't divisible by three\n    until\
    \ index % 3 == 0 do\n      index -= 1\n    end\n    # find second value that is\
    \ divisible by three\n    until index % 3 == 1 do\n      index -= 1\n    end\n\
    \    # move the larger value to the middle\n    until index == 0 do\n      index\
    \ -= 1\n    end\n    # move the smaller value to the beginning of the list\n \
    \   until index == 1 do\n      index -= 1\n    end\n    value unless index ==\
    \ 0\n  end\n  l\nend\n</code>\nAnd then, use it to get your desired output:\n\
    <code>", "    l.sort {|a, b| b % 3 ? b : a - b }\nend", "    l.sort{|a, b| a %\
    \ 3 == b % 3 ? a.to_i + b.to_i : a > b ? 1 : -1}\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=1 |>\n<| a tags=ruby |>\nThis should do the trick:\n<code>", "  sorted_list\
    \ = [ l[i] ]\n  while i < l.length\n    next_value = l[i]\n    if l[i] % 3 ==\
    \ 0\n      sorted_list << next_value\n      i -= 1\n    else\n      i = i + 1\n\
    \    end\n  end\n  sorted_list\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ dscore=0 |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10]", "  l2 = []\n  i = 0\n  while\
    \ i < l.length\n    if l[i] % 3 == 0\n      l2.push((l[i] / 3, l[i]))\n    else\n\
    \      l2.push(l[i])\n    end\n    i += 1\n  end\n  l2.sort\n  l2.each_with_index\
    \ do |v, index|\n    l[index] = v[1]\n  end\n  l2\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks, this seems like it would work, but I ran into a problem.\
    \ I've added the results of my function to the end of the original post. Could\
    \ you take a look?\n<|/ c |>\n<| c |>\nThat should do the trick.  You just have\
    \ to sort before you apply the function.  I'll update the answer accordingly.\n\
    <|/ c |>\n<| c |>\nUpdated the answer accordingly.\n<|/ c |>\n<| c |>\nThis was\
    \ very helpful, thank you so much! I ran into a slight issue. I've added the results\
    \ of my function to the end of the original post. Could you take a look?\n<|/\
    \ c |>\n<| c |>\nSo it looks like the algorithm works fine, except for the fact\
    \ that the third value of the resulting array is incorrect. Could you help me\
    \ figure out how to fix that?\n<|/ c |>\n<| a dscore=0 |>\nI would use Array#transpose\
    \ (doc here), which returns a new array containing the transposed elements of\
    \ the original array:\n<code>", "    l.sort!\n    i = 0\n    while(i < l.length)\n\
    \        if l[i] % 3 == 0\n            if i < l.length - 1\n                if\
    \ l[i + 1] % 3 == 0\n                    l[i], l[i + 1] = l[i + 1], l[i]\n   \
    \                 i += 1\n                end\n            end\n        end\n\
    \        i += 1\n    end\n    l\nend", "  l' =  Array.new\n  l.each_with_index\
    \ do |e, i|\n    i.zero? ? l' << e : l' << (e) if i % 3 == 0\n  end\n  l' << l[-1].sort\
    \ # add the final list\nend", "    l3 = []\n    i = 0\n    divisible_by_three\
    \ = true\n    l = l.clone\n    while i < l.length\n        if divisible_by_three\n\
    \            l3.push(l[i])\n            i += 1\n        elsif i == l.length\n\
    \            l3.push(l[i])\n            i += 1\n            divisible_by_three\
    \ = false\n        else\n            el = l[i]\n            while i < l.length\n\
    \                if l % 3 != 0\n                    l3.push(el)\n            \
    \        i += 1\n                    el = l[i]\n                else\n       \
    \             el = l[i]\n                    i += 1\n                    break\n\
    \            divisible_by_three = true\n        end\n    end\n    return l3\n\
    end", "  return l.each_with_index.sort do |a, b|\n    if a.even? && b.even?\n\
    \      a.even? ? b.even? ? b.last : a.last : a.even? ? b.even? ? a.last : b.even?\
    \ ? a.last : b.last\n    else\n      a.odd? ? b.odd? ? b.last : a.last : a.odd?\
    \ ? b.odd? ? a.last : b.odd? ? a.last : b.last\n    end\n  end\nend", "  l.sort\
    \ do |a,b|\n    if a%3 == 0\n      a\n    elsif b%3 == 0\n      b\n    else\n\
    \      a <=> b\n    end\n  end\nend", "    l.sort!\n    l2 = 0\n    l3 = 0\n \
    \   loop do\n        if l[l2] % 3 == 0 and l[l3] % 3 != 0\n            l3 = 0\n\
    \            l2 += 1\n        else\n            l3 += 1\n        end\n       \
    \ break if l2 == l.size - 1\n    end\n    l2 = l2.reverse\n    l3 = l3.reverse\n\
    \    l3 = l3[0..-1]\n    l2 = l2[0..-1]\n    l += l2 + l3\n    l.reverse\nend",
  "  l1 = l.dup\n  l1.sort_by(&:last).map { |l| l1 << l }\nend", "  l.each_with_index\
    \ do |value, index|\n    next if index == 0\n    if index % 3 == 0\n      l[index]\
    \ = l[index - 3]\n      l[index - 3] = value\n    else\n      l[index] = l[index\
    \ - 1]\n      l[index - 1] = value\n    end\n  end\nend", "  l = l.dup\n  l.sort!",
  "  return l.map { |i|\n    i / 3 if i % 3 != 0 && ! l[i / 3].nil?\n  }.sort_by {\
    \ |i|\n    i / 3\n  }.map { |i|\n    l[i / 3]\n  }\nend", "  new_list = []\n \
    \ new_list.extend(l)\n  new_list.each_with_index {|e,i| i.even? ? new_list.delete_at(i)\
    \ << new_list.delete_at(i) : new_list.delete_at(i)}\n  new_list.sort\n  new_list\n\
    end", "  sorted = []\n  index = 0\n  while index < l.length\n    if index != (l.length\
    \ / 3) * 3\n      sorted.push(l[index])\n    index += 1\n  end\n  return sorted\n\
    end\n</cell>\n<cell>", "  l.each_with_index do |value, index|\n    if index %\
    \ 3 == 0\n      l[index].uniq!\n      l[index].sort!\n    end\n  end\n  l\nend",
  "  sorted = l\n  for i in 0..(l.length-1)\n    next if l[i] % 3 == 0\n    next if\
    \ l[i] % 3 == 1\n    next if l[i] % 3 == 2\n    sorted[i - 1] = l[i]\n  end\n\
    \  return sorted\nend", "  third = l.last(3) # get all but the last 3 elements\
    \ of a list\n  third.each_with_index { |val, index| l[index] = val }\n  third\n\
    end", "  l2 = l.clone\n  l2.sort!\n  l2.each_with_index do |val, index|\n    if\
    \ index % 3 == 0\n      l2.delete_at(index)\n    end\n  end\n  return l2\nend",
  "  l.map! {|x| x % 3 == 0 ? x : (x % 2 ? x : (x % 1 ? x : x))}\n  l.sort!\n  l\n\
    end", "  return l.sort.map { |i| i / 3 }.uniq.reduce(&:+)\nend\n</code>\n<|/ a\
    \ tags=ruby dscore=1 |>\n<| a |>\nI like's answer, but I think I'd probably do\
    \ something like this:\n<code>", "  l3 = []\n  l.each do |e|\n    puts \"e = #{e}\"\
    \n    l.each do |e|\n      puts \"e = #{e}\"\n      l3.each do |e|\n        puts\
    \ \"e = #{e}\"\n        next if e == e\n        puts \"e = #{e}\"\n        l.each\
    \ do |e|\n          puts \"e = #{e}\"\n          if e == e\n            l3 <<\
    \ e\n            l.each do |e|\n              puts \"e = #{e}\"\n            end\n\
    \          end\n        end\n      end\n    end\n  end\n  return l3\nend", " \
    \ l.sort.with_index { |n, i| return i if i.odd? }\nend", "  l = l.dup\n  l.reverse_each{|i|\
    \ i%3 == 0 && l.pop}\n  l\nend", "  l.each_with_index { |v, i| l[i] = v unless\
    \ i % 3 == 0 }\n  l.sort_by { |v| v }\n  l\nend", "  index = 0\n  l2 = []\n  while\
    \ index < l.length do\n    next if index == (l.length / 3)\n    l2.push l[index]\n\
    \    index = index + 1\n  end\n  l2.each do\n    next if l2.include? l[index -\
    \ 3]\n    l[index] = l[index - 3]\n    l[index - 3] = l[index - 2]\n    l[index\
    \ - 2] = l[index - 1]\n    l[index - 1] = l[index]\n    index = index - 2\n  end\n\
    \  l2\nend", "  l.sort\n  l[l.length / 3..-1].each_with_index do |e, i|\n    if\
    \ i % 3 == 0\n      l[i] = l[i - 1]\n    end\n  end\n  return l\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\n<code>", "  l.sort\n  l[(l.length / 3).floor].upto((l.length\
    \ / 3).floor + 1).each { |x| l[x] = l[l.length - 1] }\n  l\nend", "  l.reduce(&:+).sort_by{\
    \ |e| e % 3 }\nend\n</code>\nAnd an example usage:\n<code>\nl = %w{hello world\
    \ today is goodbye bye bye a b c d e f g h i j k l m n o p}", "  l.each_with_index\
    \ do |val, i|\n    if val % 3 == 0 && i > 0 and (i + 1) < l.size\n      l[i +\
    \ 1] = l[i]\n    end\n  end\n  l\nend", "  l.each_with_index do |val, i|\n   \
    \ l.insert(i, val)\n  end\nend", "  l1 = []\n  l2 = []\n  l.each_with_index do\
    \ |value, index|\n    l1 << value\n    if index % 3 != 0\n      l2 << value\n\
    \    end\n  end\n  l1.zip(l2).sort\nend", "  l3 = l.dup\n  l3.sort { |a,b| b %\
    \ 3 == 0 ? a : b }\n  l3\nend", "  sorted = []\n  last_seen = 0\n  last_seen_val\
    \ = l[0]\n  sorted_nums = []\n  num_seen = 0\n  last_seen_num = 0\n  for i in\
    \ l\n    num = i\n    if num_seen % 3 == 0\n      num_seen = num_seen + 1\n  \
    \    last_seen_num = last_seen_num + 1\n      num = last_seen_num\n    end\n \
    \   if i > last_seen_num\n      last_seen = last_seen_num\n      last_seen_val\
    \ = i\n    end\n    if num_seen % 3 == 0\n      sorted_nums.push(last_seen_val)\n\
    \    end\n    sorted_nums.push(num)\n    last_seen_num = num\n  end\n  sorted_nums.push(last_seen_val)\n\
    \  return sorted_nums\nend\n</code>\nThis code will run much faster if you can\
    \ find a way to avoid creating those extra arrays (which you really can't do,\
    \ since you don't know beforehand how many of them you will need in advance).\n\
    <|/ a |>\n<| a dscore=1 |>\nThe problem is because you do not know the size of\
    \ the array you are sorting.\nYou will need to use a variable to keep track of\
    \ which number you first found and which number you last found and swap them when\
    \ they are different.\n<code>\narr = [5,2,7,4,1,3,8]", "    l.sort.with_index\
    \ { |a, b| b % 3 == 0 ? b : b }\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby\
    \ |>\nI like this solution:\n<code>", "  l.each_with_index do |e, i|\n    if i\
    \ % 3 == 0\n      l[i] = l[i]\n    end\n  end\n  l.sort\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=0 |>\n<| c |>\nHi Jon,Thanks for the help,i tried the above code,but\
    \ it gives an error.\n<|/ c |>\n<| c |>\nYes it gives an error ,can you please\
    \ help me to fix that?\n<|/ c |>\n<| c |>\nThe error says undefined method `each'\
    \ for [5, 6, 3, 4, 8, 9, 2]:Array\n<|/ c |>\n<| c |>\nHi Jon,Thanks for the help,I\
    \ modified the code as you suggested but still the error exists.can you please\
    \ help me to fix that too?\n<|/ c |>\n<| c |>\nI edited the original post with\
    \ the code I used which does not give an error, and gives [2, 3, 5, 6, 4, 8, 9]\
    \ for the input [5, 6, 3, 4, 8, 9, 2] as expected.\n<|/ c |>\n<| a |>\nA very\
    \ simple and fast algorithm would be to sort only those elements whose index %\
    \ 3 equals 0.\n<code>", "    l.sort!\n    l.each_with_index do |n, i|\n      \
    \  if i % 3 == 0\n            l.insert(i, n)\n        end\n    end\n    l\nend",
  "  l.each_with_index do |e, i|\n    l.delete_at(i)\n    break if i%3 == 0\n    l.insert(i,\
    \ e)\n  end\n  return l\nend\n</cell>\n<cell>", "  l.sort\n  index = 0\n  while\
    \ index < l.length\n    count = l.length - index\n    if count % 3 == 0\n    \
    \  l[index], l[index + 1], l[index + 2] = l[index + 1], l[index], l[index + 2]\n\
    \      index += 2\n      count += 1\n    else\n      index += 1\n    end\n  end\n\
    \  return l\nend", "  for i in 0..(l.size / 3) - 1\n    l[i], l[i + 1], l[i +\
    \ 2] = l[i + 2], l[i + 1], l[i]\n  end\n  l\nend", "    l, counts = l.partition{|x|\
    \ x % 3 == 0}\n    l.sort!\n    l.zip(counts)\nend", "  lp = l.length\n  l.each_with_index\
    \ do |value, index|\n    index = index % lp\n    if index == 0 then value = value\
    \ % 3 else value = value % 3 && value + (3 - (value % 3)) end\n    l[index] =\
    \ value\n  end\n  l\nend", "  l.sort\n  l[0].zero? ? l : l[(l[0].to_i / 3).floor]\n\
    end", "  result = []\n  l.each_with_index do |value, index|\n    if index % 3\
    \ == 0\n      result.push(l[index])\n    else\n      result.push(value)\n    end\n\
    \  end\n  result.sort_by { |e| e }\nend\n</code>\n<|/ a |>\n<| c |>\nThe OP wants\
    \ the list to be sorted by groups of 3... Not every 3rd element.\n<|/ c |>\n<|\
    \ c |>\nThe OP said in a comment that they needed the list sorted by groups of\
    \ 3. My answer does exactly that. I'll make an edit just in case it was not clear\
    \ enough.\n<|/ c |>\n<| a dscore=2 tags=ruby,arrays,sorting |>\n<code>", "  l1\
    \ = l.sort\n  l2 = []\n  l2.extend(l1[0::2])\n  l2.extend(l1[2::2])\n  return\
    \ l2\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nAs you mentioned there are only\
    \ 10 elements in the list you can do this:\n<code>", "  n = l.length\n  l', idxs\
    \ = [], []\n  for i in 0..n-1\n    if (l[i] % 3 == 0)\n      idxs << i\n    else\n\
    \      l' << l[i]\n    end\n  end\n  l' << l[n-1]\n  idxs.sort!", "  l.sort_by\
    \ do |i|\n    if i % 3 == 0\n      i\n    else\n      i += 3\n      i\n    end\n\
    \  end\nend\n</code>\nThe sort_third function first sorts the list by the indexes,\
    \ then it adjusts the indices that are not divisible by three by the number of\
    \ items divisible by three before sorting.\n<code>", "  ls = l.reverse\n  ls.each_index\
    \ do |i|\n    next if i % 3 != 0\n    index = ls.index(i)\n    ls[i] = l[index]\n\
    \    ls[index] = i\n  end\n  return ls.reverse\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=2 |>\n<| c |>\nWow... this is really cool but unfortunately the question\
    \ was about a Ruby solution.\n<|/ c |>\n<| a |>\nTry this:\n<code>", "  return\
    \ l.sort_by {|x| x.index % 3}.to_a\nend", "  l.each_with_index do |v, i|\n   \
    \ next if i % 3 == 0\n    v.swap(i, i + 1)\n  end\n  l.sort\nend", "  l.sort!\n\
    \  l[l.index(l.last / 3)], l[l.index(l.last / 3) * 2], l[l.index(l.last / 3) *\
    \ 2] = l[l.index(l.last / 3) * 2], l[l.index(l.last / 3)], l[l.index(l.last /\
    \ 3) * 2]\n  l\nend", "  sorted = []\n  third = 1\n  while l != []\n    sorted\
    \ = sorted + l\n    third = third*3\n    if third == 1 \n      third = 1\n   \
    \   l = l[1..-1]\n    else\n      l = []\n    end\n  end\n  return sorted\nend",
  "  n3 = l.size\n  l2 = []\n  for i in 0...n3\n    unless i % 3 == 0\n      l2.push(l[i])\n\
    \    else \n      l2.push(l[i])\n    end\n  end\n  l2.sort\n  return l2\nend",
  "    l.sort {|a, b| (a % 3 == 0) ? (b == 0) : (b == 1)}\nend", "    l.sort!\n  \
    \  \n    index = 0\n    l = l.dup\n    l = l[1..-1]", "  a = l.clone\n  a.sort!\n\
    \  \n  for i in 0...(l.size-1)\n    if l[i] % 3 == 0\n      a.delete_at(l)\n \
    \     break\n    end\n  end\n  \n  a\nend", "    l.map! {|x| x % 3 == 0 ? x :\
    \ (x % 3 ? x : x + 1)}\n    l.sort\nend", "  l2 = []\n  l2.push(l[0])\n  l2.push(l[1])\n\
    \  l2.push(l[2])\n  for i in 0..(l[0].length-1) - 2\n    l2.push(l[2].dup.tap{\
    \ |e| e[i] }.sort)\n  end\n  return l2\nend", "  l.each_with_index do |e, i|\n\
    \    next if i == 0\n    next unless e % 3 == 0\n    l.delete_at i\n    l.insert\
    \ i, e\n  end\n  l\nend", "\tsorted = []\n\twhile l != []\n\t\tbegin = l.index{\
    \ |x| x % 3 != 0}\n\t\tmiddle = l.index{ |x| x % 3 == 0}\n\t\tend = l.index{ |x|\
    \ x % 3 == 1}", "  l.each_with_index do |value, index|\n    next\n    if index%3\
    \ == 0 then value = value else value = value.downcase end\n    if value.nil? then\
    \ next\n    else l[value] = l[index] if value.to_i <=> l[index].to_i <=> l[index].to_i\
    \ <=> value.to_i\n      end\n    end\n  end\n  l\nend", "  l3 = l\n  l3.sort\n\
    \  l3\nend", "    l.each_with_index do |val, ind|\n        if ind % 3 == 0\n \
    \           l.delete_at(ind)\n            l.insert(ind, val)\n        end\n  \
    \  end\n    return l\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI wrote a solution\
    \ for this problem using recursion. It may not be the most efficient but it does\
    \ the job.\n<code>", "  l = l.dup\n  l.each_index { |i| l[i] % 3 ? l[i] = l[i].to_i\
    \ + 1 : l[i] = l[i].to_i }\n  l.sort\n  l\nend", "  l.each_with_index do |v, i|\n\
    \    if i % 3 != 0\n      l[i] = v\n    end\n  end\n  l\nend", "  l.map { |e|\
    \ [e, l.index e] }.sort_by { |e| e[1] }.map { |e| e[0] }\nend", "    l.sort{|a,\
    \ b| (a%3 <=> b%3)}\nend\n</code>\n<|/ a |>\n<| c |>\nI believe this answer does\
    \ nothing useful. You could remove the call to `sort_third` from your second example\
    \ and get the same result.\n<|/ c |>\n<| c |>\nHmm, what do you mean by \"I believe\
    \ this answer does nothing useful\"? It sort the list by the third element of\
    \ every element, effectively sorting the list by its indices. And this seems exactly\
    \ what OP wants ...\n<|/ c |>\n<| c |>\nThis is not the right solution, because\
    \ it's an in-place sort, and doesn't return a sorted list.\n<|/ c |>\n<| a dscore=3\
    \ |>\n<code>\n[1,2,3].sort.each_with_index { |val,index| val % 3 == 0 && [val]\
    \ << index if index%3 != 0 }", "  l_size = l.length\n  new_size = (l_size + 3)/3\n\
    \  \n  # Create an array with as many elements as 'new_size' and the indicies\
    \ equal to the values in 'l'\n  l3 = [nil]*new_size\n  (0..new_size-1).each{|i|\
    \ l3[i] = l[i]}\n  \n  # Iterate over the list of indicies that are divisible\
    \ by three and\n  # swap them with the indicies that are divisible by three\n\
    \  (l3.each_index{|i| l3[i] = l3[3*i-1]}..l_size-1).each{|i| l3[i] = l[i].swap}\n\
    \  \n  # Return the list with its indicies sorted.\n  l3\nend", "  l2 = []\n \
    \ l.sort.each do |i|\n    if i.even?\n      l2.push(i)\n    elsif i % 3 == 0\n\
    \      l2.push(l[l.index(i)])\n    end\n  end\n  l2.uniq\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThat's a nice trick; it would be worth pointing out that the sort\
    \ step is O(n log n), but your `sort_third` doesn't do any sorting. It just finds\
    \ the index of a given number and puts it in the correct spot.\n<|/ c |>\n<| c\
    \ |>\nThanks, I added the sorting to the second version now that I've fixed the\
    \ second one (it had a bug).\n<|/ c |>\n<| c |>\nVery nice, thanks. I knew there\
    \ had to be a clever way to do this; your answer is very helpful.\n<|/ c |>\n\
    <| a dscore=0 tags=ruby |>\n<code>", "  return l.map {|i| [i, l[i] % 3 == 0 ?\
    \ l[i] : l[i] - 1]}.sort_by {|i| i[1]}\nend", "  l.each_with_index do |val, i|\n\
    \    if i % 3 != 0\n      l[i] <=> val\n    else\n      l[i] <=> l[i-1]\n    end\n\
    \  end\nend\n</cell>\n<cell>", "  l2 = []\n  for i in l\n    ind = 0\n    while\
    \ ind < l.length && l[ind] % 3 != 0\n      ind += 1\n    l2 << l[ind..-1]\n  end\n\
    \  l2.sort!\n  l\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", "  return l.sort.zip(l).map\
    \ {|i, j| j % 3 == 0 ? i : j.odd? i: j}\nend", "  l.sort!\n  l[1..-1].each_with_index\
    \ { |a, i| l[i] = l[i..-1].inject(0) do |sum, v| sum += v if (i % 3 == 0) then\
    \ v else sum + v end; sum + v}\nend", "  third = l.each_cons(3)\n  third.sort\
    \ { |a, b| (a.last <=> b.last) }\n  third.flatten\nend", "  l1 = l\n  l2 = []\n\
    \  l3.each_with_index do |value, index|\n    next if index%3 != 0\n    l2 << value\n\
    \  end\n  l3\nend", "    l.sort\n    l.each_with_index do |number, index|\n  \
    \      divisible_by_three = (index / 3).zero?\n        l[index] =\n          \
    \  divisible_by_three\n                ? l[index + 1]\n                : l[index\
    \ - 1 + 3]\n    end\nend\n</code>\nAs I said, I wrote this in a hurry and did\
    \ not test it carefully; but you get the idea behind how it should be done and\
    \ you can reuse it if you want.  And like I said, I wrote this in a hurry, but\
    \ I hope you get the general idea.\n<|/ a tags=ruby,ruby-on-rails |>\n<| a |>\n\
    I like's solution (which is definitely the one I would use), but I wanted to see\
    \ a solution where I don't have to sort the array. Here's my take on it:\n<code>",
  "    l.each_with_index do |e, i|\n        l[i], l[i+1] = l[i+1], l[i] if i%3 ==\
    \ 0\n    end\n    l\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\n\
    It would be better to define `sort_third` as `def sort_third(l).with_index.sort_by(&:first).map(&:last)`.\n\
    <|/ c |>\n<| c |>\n`sort_by` and `sort_by!` don't have a `reverse` option. `sort_by!`\
    \ does have `reverse: true`. Maybe it would be better to replace `sort_by` with\
    \ `sort_by!`.\n<|/ c |>\n<| c |>\n: I don't think they have the `reverse` option,\
    \ though. Maybe I'm confused.\n<|/ c |>\n<| c |>\n: I believe you are confused.\
    \ The last line of the [documentation](http://ruby-doc.org/core-2.4.1/Enumerable.html#method-i-sort_by-21)\
    \ says: `The default order is ascending, from lowest to highest`.\n<|/ c |>\n\
    <| c |>\n: I'm pretty sure `sort_by!` does have `reverse: true`. `sort_by!` calls\
    \ [`Enumerable#reverse_each`](http://ruby-doc.org/core-2.4.1/Enumerable.html#method-i-reverse_each)\
    \ and passes its argument `l.reverse` into `sort_by!`.\n<|/ c |>\n<| a |>\nHere's\
    \ another solution:\n<code>", "  l.sort {|x, y| x % 3 == 0 ? y : (x % 3 > 0 ?\
    \ x : y)}\nend", "  l.each_with_index do |e, i|\n    if i % 3 == 0\n      l[i]\
    \ = e\n    end\n  end\n  l\nend", "  l.sort_by do |i|\n    i / 3\n  end + ([l.last]\
    \ * l.size % 3 )\nend", "  l.sort.with_index do |value, index|\n    index % 3\
    \ == 0 && value <= l[index / 3]\n  end\nend\n</code>\nThe return statement could\
    \ be written more tersely as:\n<code>", "  l.each_with_index do |(v, i), (v1,\
    \ i1)|\n    if i1 % 3 == 0\n      l[i1] = v\n    end\n  end\n  l\nend\n</code>\n\
    <|/ a tags=arrays,sorting,ruby |>\n<| c |>\nThis is very cool. One thing that\
    \ bothers me is how you wrote `(v, i), (v1, i1)`.  I'm not familiar with that\
    \ syntax.  What do the parens do there exactly?\n<|/ c |>\n<| c |>\nThe parentheses\
    \ separate the two values to be assigned and passed to the block by `each_with_index`.\
    \  I suggest you read [Blocks and Procs in Ruby](http://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-each_with_index).\n\
    <|/ c |>\n<| a dscore=0 tags=arrays,sorting,ruby |>\nThis would work well:\n<code>",
  "  l' =  []\n  l.each_with_index do |e, i|\n    if i%3 == 0 then\n      l.insert\
    \ i, e\n    else\n      l.insert i, e\n      l'.insert i, e\n    end\n  end\n\
    \  return l'\nend", "  l.sort.each_with_index do |e, i|\n    break if i % 3 ==\
    \ 0\n    next unless e\n    l[i] = e if e > l[i-1]\n  end\n  return l\nend\n</pre>",
  "  l.sort{|x, y| x % 3 == 0 && y % 3 == 0 || x % 3 == 0 && y % 3 == 0 && x <=> y}\n\
    end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nThanks. I knew it could be\
    \ done in a one-liner but I didn't know how to do it.\n<|/ c |>\n<| c |>\nIt's\
    \ not a one-liner, it's more complicated, but it could be done with some kind\
    \ of trickery involving hashes.\n<|/ c |>\n<| c |>\nI didn't know hashes could\
    \ be used like that. Thanks.\n<|/ c |>\n<| c |>\nI think you meant to write `sort_third([5,\
    \ 6, 3, 4, 8, 9, 2])` rather than `sort_third([9, 6, 3, 4, 8, 9, 2])`.\n<|/ c\
    \ |>\n<| c |>\nOops, sorry. Fixed. It was a typo when I pasted it.\n<|/ c |>\n\
    <| a |>\nHow about something like this?\n<code>\nsort_third([1, 2, 3])", "  lp\
    \ = l.copy()\n  lp.sort!", "  l3 = l.dup\n  (0..l.length-1).each do |i|\n    (i..l.length-1).each\
    \ do |j|\n      if  l[j] % 3 != 0\n        l3[i] = l[j]\n        l3.delete_at(j+1)\n\
    \        break\n      end\n    end\n  end\n  l3\nend", "  l.sort!\n  return l\n\
    end\n</code>\nYou were almost there. Now you just need to do what you did in the\
    \ first function sort_second. Here are some hints:", "  l.each_with_index do |n,\
    \ i|\n    break if i % 3 == 0 # If the index is divisible by 3, do nothing, otherwise\
    \ add the value at that index to the list l and delete that value\n    l[i] +=\
    \ l[n]\n    l.remove(n)\n  end\n  l\nend\n</code>\n<|/ a |>\n<| c |>\nThank you\
    \ for the code sample and an explanation of the algorithm you wrote. While my\
    \ code works in Python, I do have some questions regarding the first line of code.\
    \ Why do you use two variables for the index and n? Also, what is the purpose\
    \ of l[i] += l[n]?\n<|/ c |>\n<| c |>\n`i` was being used for the `each_with_index`\
    \ iterator. `i` was also being used to keep the value of `n` so that it wouldn't\
    \ be altered by the line `l[n] = l[i]`\n<|/ c |>\n<| a dscore=0 |>\n<code>", " \
    \   l.sort!\n    l[0] = (l[0].abs % 3 == 0) ? (l[1] < l[2] ? l[1] : l[2]) : l[1]\n\
    \    l[1] = (l[1].abs % 3 == 0) ? (l[2] < l[0] ? l[2] : l[0]) : l[2]\n    l[2]\
    \ = (l[2].abs % 3 == 0) ? (l[0] < l[1] ? l[0] : l[1]) : l[0]\n    l.sort!\nend",
  "  index = 0\n  lsize = l.length\n  l.each_index do |i|\n    if (i % 3 == 0)\n \
    \     l.delete_at(i - 3)\n      l.delete_at(i)\n    end\n  end\n  l\nend\n</pre>",
  "  l = (l + [nil]).sort\n  i = 0\n  while i < l.length\n    if i % 3 != 0\n    \
    \  l[i] = l[i + 1]\n    end\n    i += 1\n  end\n  l\nend", "  sorted = []\n  i\
    \ = 0\n  while i < l.length\n    if i % 3 == 0\n      sorted = sorted + l[i].sort.reverse\n\
    \    else\n      sorted = sorted + l[i]\n    end\n    i += 1\n  end\n  sorted\n\
    end", "    l.sort{|a, b| (a % 3 == b % 3) ? a : b }\nend\n</code>\n<|/ a tags=ruby,sorting\
    \ |>\n<| c |>\nThanks for posting this - it helped me to realize that I needed\
    \ to do this on an array/hash of hashes.\n<|/ c |>\n<| a tags=ruby,sorting dscore=2\
    \ |>\n<code>", "  l.sort! { |a, b| a % 3 == 0 ? b : a }\n  l\nend", "  l.each_with_index\
    \ do |e, i|\n    if i % 3 == 0\n      l[i] = l[i]\n    end\n  end\n  l.sort!\n\
    \  l\nend\n</code>\n<|/ a |>\n<| c |>\nthanks for your answer, but i want a general\
    \ way for all lists with same length and divisible by 3\n<|/ c |>\n<| c |>\nThen\
    \ please update your question to reflect that and give some examples of desired\
    \ output for various inputs.\n<|/ c |>\n<| c |>\nWhat about `[2, 6, 3, 4, 8, 9,\
    \ 5]` ?\n<|/ c |>\n<| c |>\nGood catch, I had not thought about it.\n<|/ c |>\n\
    <| a dscore=1 |>\nIn one line:\n<code>", "  l.sort.with_index do |e, i|\n    if\
    \ i % 3 == 0\n      l[i] = l[i]\n    end\n  end\n  l\nend", "  result = []\n \
    \ for i in l\n    result.push i\n    while result.last % 3 == 0\n      result.pop\
    \ pop\n    end\n  end\n  result\nend\n</cell>\n<cell>", "  l.each_with_index do\
    \ |e, i|\n    l.delete_at(i)\n  end\n  l += l[0..(l.size / 3)]\n  l.sort\nend\n\
    </code>\nIf you want something a bit quicker you can always use Ruby's built-in\
    \ sorting algorithms.\n<|/ a dscore=0 tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| a |>\nYou can try this\n<code>", "  l1 = l.clone\n  for i in (0...l.length)\n\
    \    l1[i/3] = [l1[i/3], i] if i%3 == 0\n    l1[i] = l1[i]\n  end\n  l1.sort\n\
    end", "  l = l.clone\n  l.sort!\n  l.each_with_index { |e, i|\n    next unless\
    \ i % 3 == 0\n    l.delete_at(i) if i % 3 == 1\n  }\n  l\nend", "  l2 = []\n \
    \ l2.push(l[0])\n  l.shift\n  while l.length > 0\n    v = l.shift\n    if v %\
    \ 3 == 0\n      l2.push(v)\n    elsif v % 3 == 1\n      l.unshift(v)\n      l2.push(v)\n\
    \    else\n      l.unshift(v)\n    end\n  end\n  l2\nend", "  l3 = l.dup\n  l3.sort!\
    \ {|a, b| b % 3 <=> a % 3}\n  l3\nend", "    third = l.index { |i| i%3 == 0 }\n\
    \    (l.dup).sort! { |a, b| l[a] <=> l[b] }\n    l.slice! third\nend\n</code>\n\
    <|/ a tags=ruby dscore=2 |>\n<| c |>\nWow, this looks quite elegant. Could you\
    \ explain what `l.dup` means? I only know that `dup` \"Creates a shallow copy\
    \ of obj\" but what does it mean \"shallow copy\" here?\n<|/ c |>\n<| c |>\n:\
    \ That means `l` is being passed as a reference that means `l` is *not* a new\
    \ object but rather a reference to an existing object. When you change `l` you\
    \ change `l` as you did before `sort_third`. If you do `l=[1,2,3]` then `l.dup`\
    \ creates a *new* object but `l` remains unchanged. But if you do `l=l.dup` then\
    \ `l.dup` creates a new object and `l` becomes that object.\n<|/ c |>\n<| c |>\n\
    Thank you very much for this detailed explanation! I've read the doc of [Object#dup](http://ruby-doc.org/core-2.1.3/Object.html#method-i-dup)\
    \ but still have no idea what \"shallow copy\" means. Now I understand, it just\
    \ means \"reference\" :D\n<|/ c |>\n<| a |>\nHere's a more straightforward way\
    \ that doesn't use hashes or sorting.\n<code>", "  l[l.index(l[0]) % 3] = [l[0],\
    \ l[1], l[2]]\n  l[l.index(l[1]) % 3] = [l[1], l[2], l[0]]\n  l[l.index(l[2])\
    \ % 3] = [l[2], l[0], l[1]]\nend\n</code>\nAnd here are the results of some tests.\n\
    <code>\n[sort_third([]), sort_third([1]), sort_third([1, 2, 3]), sort_third([5,\
    \ 6, 3, 4, 8, 9, 2]), sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4,\
    \ 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]),\
    \ sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3,\
    \ 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4,\
    \ 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]),\
    \ sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3,\
    \ 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4,\
    \ 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]),\
    \ sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3,\
    \ 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4,\
    \ 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]),\
    \ sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3,\
    \ 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4,\
    \ 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]),\
    \ sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3,\
    \ 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4,\
    \ 8, 10, 8, 7, 3, 10, 6, 5, 2]), sort_third([4, 8, 10, 8, 7, 3, 10, 6, 5, 2]), ",
  "\tl3 = []\n\tl3.push l[0]\n\tl.shift\n\tl.shift\n\tl.shift\n\tl3.push l[0]\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl3.push l[0]\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\
    \tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\tl.shift\n\t\
    l.", "  l.sort.with_index { |(v, i), (j, k)|\n    i /= 3\n    k /= 3\n    if k\
    \ % 3 == 0\n      l[j..k] = l[i..k]\n    end\n    l[j..k] = v\n  }\n  l\nend",
  "  l.sort_by {|x| x % 3 }\nend", "\tsorted_l = []\n\tfor i in 1...l.size\n\t\tsorted_l\
    \ << l[i]\n\t\tbreak if l[i-1] % 3 == 0\n\tsorted_l << l[-1]\n\treturn sorted_l\n\
    end\n</code>\nNow the sorting function is much shorter:\n<code>", "  l.sort\n\
    \  l.reject! { |i| i.odd? }\n  return l\nend\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThis is nice, but it would be nicer to have it sort from largest to smallest\
    \ value.  For example, instead of `[2, 6, 3, 4, 8, 9, 5]` it should be `[5, 6,\
    \ 3, 4, 8, 9, 2]`, where the 2nd value is `5`, because `5` appears multiple times\
    \ after the 2nd value `2`.\n<|/ c |>\n<| c |>\nOh, I see.  That's a different\
    \ problem - one that would require a different approach.  I was only looking at\
    \ sorting based on a condition on the item, but I didn't want to complicate the\
    \ code too much - that's why I didn't add it into the answer, but I'll add it.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere is a solution based on your idea. It's not very\
    \ fancy, but I hope you get the idea.\n<code>\narr = [1, 2, 3, 4, 5, 1, 2, 3,\
    \ 4, 5]", "  l1 = l.to_a\n  l2 = l1.sort do |i| \n    return l[i/3] if l[i/3].zero?\n\
    \    l[i/3].zero? ? -1 : 1\n  end\n  l1 + l2\nend\n</code>\n<|/ a dscore=1 tags=arrays,sorting,ruby,ruby-on-rails\
    \ |>\n<| c |>\nAh, I missed the third element at first glance. I thought it was\
    \ an example of the problem being posed. Thanks for the clarification.\n<|/ c\
    \ |>\n<| c |>\nI've updated my answer to include a solution that uses `sort_by`.\n\
    <|/ c |>\n<| a tags=arrays,sorting,ruby,ruby-on-rails |>\nYou could sort the list\
    \ and then slice the list into three parts using a range.\nFor example:\n<code>\n\
    >> a = %w{a b c d e f g}\n=> [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\
    ]\n>> a.sort_by{|c| c}\n=> [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\n\
    >> a[0..3]+a[4..6]+a[7..a.length]\n=> [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\"]\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this works, it forces the\
    \ entire list of items to be sorted and then sliced into three parts. Which might\
    \ not always be what you want.\n<|/ c |>\n<| c |>\nI agree, but I assumed that\
    \ OP already had all the items in the list sorted from least to greatest and hence\
    \ the question didn't make any sense.\n<|/ c |>\n<| a tags=arrays,sorting,ruby,ruby-on-rails\
    \ |>\nTry this:\n<code>", "    l.each_with_index do |v, i|\n        l[i] = l[i]\
    \ if i && !(i%3).nil?\n    end\n    l.sort\nend", "  l2 = l.clone\n  l2.sort\n\
    \  l2.each_with_index { |e,i| l2.delete_at(i) if i % 3 == 0 }\n  l2.sort\nend",
  "    \n    # Sort the list by its indicies, but only if the value at the indicies\
    \ are not divisible by three.\n    l' =  l[l.sort { |a, b| a.reverse <=> b.reverse\
    \ }].sort", "  l = l.clone\n  l.sort!\n  l.each_with_index do |value, index|\n\
    \    next if index % 3 == 0\n    l[index] = value\n  end\n  l\nend", "    l.sort!\
    \ do |i|\n        if i % 3 == 0\n            i\n        elsif i == 0\n       \
    \     i\n        else\n            if i == 2\n                i\n            else\n\
    \                if l[i - 1] < l[i] and l[i - 2] < l[i]\n                    i\n\
    \                else\n                    i\n                end\n          \
    \  end\n        end\n    end\n    l\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\n<code>", "  l.each do |i|\n    if i.is_a?(Integer)\n      if i.modulo(3)\
    \ == 0 && !i.zero?\n        l[i..-1].map! { |e| e << i }\n      end\n    end\n\
    \  end\n  l\nend\n</code>\nThe above code takes advantage of the fact that lists\
    \ are enumerable and that an assignment to an existing element in an array will\
    \ change its index, while a mutating method (map!) is non-destructive (it changes\
    \ the list itself). Note that it is assumed that all numbers are positive.\n<|/\
    \ a |>\n<| c |>\nThis is an excellent solution and it makes me understand the\
    \ power of Ruby iterators.  However, it does not work for `[1, 2, 3, 5, 7, 9,\
    \ 3]`.  Can you see why not?\n<|/ c |>\n<| c |>\nI've added a small fix that takes\
    \ into account that all numbers need to be positive. Sorry that my previous version\
    \ did not work for negative numbers, I was a bit too eager to finish the question\
    \ while waiting for an interview question.\n<|/ c |>\n<| c |>\nI ran this through\
    \ the debugger in Ruby 2.7.0, and it doesn't work.  It doesn't change anything\
    \ at all to the `list` parameter, and it isn't throwing any exceptions.  This\
    \ isn't a destructive change, it's really not doing anything.\n<|/ c |>\n<| c\
    \ |>\nI am running it on Ruby 2.7.0, and it is definitely changing the array passed\
    \ to it. It also prints out the array before and after the sorting operation.\
    \ Also, it is not throwing any exceptions (it returns `nil` on purpose).\n<|/\
    \ c |>\n<| c |>\nAh, yes, it does work.  Your version works with the test case,\
    \ but apparently the test case has negative numbers.  I wonder why.  I guess that's\
    \ why I said it worked with your version.  Either way, I'm going to mark your\
    \ solution as correct.\n<|/ c |>\n<| a dscore=0 |>\nThis should be pretty simple.\
    \  You basically want to rearrange the items in the array so that the items whose\
    \ numbers divide 3 are in three groups of 3, and those whose numbers don't divide\
    \ three are in one group.  I assume that numbers are positive integers and that\
    \ there will be at least one item in each group.  Then you just need to keep track\
    \ of which groups the current item belongs in.\n<code>", "    l.sort\n    l.each_with_index\
    \ do |value, index|\n        if index % 3 == 0 and value % 3 != 0\n          \
    \  l.delete_at(index)\n        else\n            l[index] = value\n        end\n\
    \    end\n    return l\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays\
    \ |>\nYou can try something like this, though it's not very efficient:\n<code>",
  "  l1, l2, l3 = [l[x] for x in\n                  [0, 1, 2, 3, 4, 5, 6, 7]]\n  sorted\
    \ = []\n  while l1 != l2 or l3 != l2:\n    if l3 > l2:\n      sorted.append(l3)\n\
    \      l3 = l3 + 1\n    elif l2 > l3:\n      sorted.append(l2)\n      l2 = l2\
    \ + 1\n    else:\n      sorted.append(l1)\n      l1 = l1 + 1\n  sorted.append(l3)\n\
    \  sorted.append(l2)\n  return sorted", "  l.sort!\n  result = []\n  count = 0\n\
    \  i = 0\n  while i < l.length\n    if l.length % 3 == 0\n      count += 1\n \
    \   else\n      count = 0\n    end\n    if count == 3\n      result << l[i]\n\
    \      result << l[i + 1]\n      result << l[i + 2]\n      i += 2\n      count\
    \ = 0\n    else\n      i += 1\n    end\n  end\n  result << l[i]\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis is wrong for `sort_third([1,2,5,3,4])` returning\
    \ `[4,3,1,2,5]`. You might want to use `i < l.length`.\n<|/ c |>\n<| a |>\nA solution\
    \ in Ruby:\n<code>", "  l.each_with_index do |el, i|\n    break if el % 3 == 0\n\
    \    l[i] = l[i] - el if el % 3 == 1\n    l[i] = l[i] + el if el % 3 == 2\n  end\n\
    end\n</code>\n<|/ a |>\n<| a |>\nThis seems like a good use case for a map.\n\
    <code>", "  l1, l2, l3 = l[0], l[1], l[2]\n  l1.sort_by{|i| i%3}.zip(l2.sort_by{|i|\
    \ i%3}.zip(l3.sort_by{|i| i%3})).flatten\nend", "  # Your code here\n  l.sort!\n\
    \  i = 0\n  while i < l.length\n    if l[i] % 3 == 0 && l[i] != l[i-1]\n     \
    \ l[i],l[i-1] = l[i-1],l[i]\n    end\n    i += 1\n  end\n  l\nend\n</cell>\n<cell>",
  "  l.each_index { |i| l[i] = l[i].to_i if l[i] % 3 == 0 }\n  l.sort\nend", "  l.each_with_index\
    \ do |val, index|\n    l[index] = val if index%3 == 0\n  end\n  l.sort_by { |value|\
    \ value.to_i }\nend", "  lsize = l.size\n  lsize.times do |i|\n    (i + lsize)\
    \ % 3 ? l[(i + lsize) // 3] = l[i] : l[i] = l[(i + lsize) // 3]\n  end\n  l\n\
    end\n</code>\n<|/ a dscore=0 tags=sorting,arrays,ruby |>\n<| a |>\n<code>", " \
    \ l.each_with_index do |n, i|\n    (i%3 == 0 || l[i-1] != n) ? l << n : l[i-1]\
    \ == n ? l << n : l[i-1]\n  end\n  l\nend", "    even_index = []\n    odd_index\
    \ = []\n    \n    for i in (0..l.count-1)\n        \n        if l[i] % 3 == 0\n\
    \            even_index << l[i]\n        else \n            odd_index << l[i]\n\
    \            \n    even_index.sort\n    odd_index.sort\n    \n    l[0..even_index.count-1]\
    \ = even_index\n    l[even_index.count..-1] = odd_index\nend", "  # return l if\
    \ l == [] else [l.pop(0), sort_third(l), l.pop(0)]\n  return l if l == [] else\
    \ [l.pop(0), sort_third(l), l.pop(0)] if l.index(l.pop(0)) % 3 == 0 else [l.pop(0),\
    \ sort_third(l), l.pop(0)] if l.index(l.pop(0)) % 3 == 1 else [l.pop(0), sort_third(l),\
    \ l.pop(0)]\nend", "  return [l.sort {|a, b| (a % 3) != (b % 3) ? a <=> b : 0}[0...-1]]\n\
    end", "    l3 = []\n    count = 0\n    for i in l\n        count += 1\n      \
    \  if count % 3 != 0\n            l3 << i\n        else\n            l3 << l[count\
    \ - 1]\n        end\n    end\n    l3\nend", "  l.sort {|x, y| x < y ? -1 : x >\
    \ y ? 1 : 0}\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\nI came up with\
    \ a solution using a single sort and multiple enumerators. I used this as a quick\
    \ way to see if I could do this in Ruby.\n<code>", "    l.each_with_index do |element,\
    \ i|\n        if i != 0 && i % 3 == 0\n            l[i] <= l[i-1] ? l[i-1] = element\
    \ : l[i] = element\n        end\n    end\n    l\nend", "  l = l.to_a\n  l2 = []\n\
    \  \n  l.each_with_index do |el, i|\n    if i % 3 == 0 && i != 0\n      el = l[i-1]\n\
    \    end\n    l2 << el\n  end\n  \n  l2.sort!\n  \n  l2.each_with_index do |el,\
    \ i|\n    if i % 3 == 0\n      l2.delete_at(i)\n    end\n  end\n  \n  l\nend",
  "  l.each_with_index { |x, i| l[i] = x if i % 3 == 0 }\n  l.sort!\n  l\nend", " \
    \ l = l.dup.sort { |a,b| b != a && a%3 != 0} # sort the list without changing\
    \ the indices\n  l.each_with_index { |a,b| l[b] = b if b != a && a%3 == 0} # reorder\
    \ the list by replacing the indices with their corresponding values\n  l\nend\n\
    </code>\n<|/ a tags=ruby,sorting,arrays dscore=2 |>\n<| c |>\nThanks for the help\
    \ but it says method is not defined for Fixnum\n<|/ c |>\n<| c |>\nOh, my mistake.\
    \ Fixed it.\n<|/ c |>\n<| c |>\nIt works, thanks! One thing I'm still trying to\
    \ figure out is if there is a way to change the numbers without changing the indices\n\
    <|/ c |>\n<| c |>\nYou're welcome. I added a description of how to do this to\
    \ my answer.\n<|/ c |>\n<| a |>\nAs already stated sort_by is one approach but\
    \ you can achieve this in O(n) by keeping a hash that maps each number to the\
    \ list of indexes.\nFor example:\n<code>", "\tfor i in 0..(l.length-1)\n\t\tl[i]\
    \ = l[i] + l[i-1] if i%3 != 0\n\tl.sort!\n\tl\nend", "  third = l.map { |x| x\
    \ % 3 }.uniq\n  l.map { |x| x if x != third.shift }\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nYour answer is almost the same as the other one but this one is\
    \ more concise and works well with my tests.\n<|/ c |>\n<| c |>\n- yes, I know.\
    \  I was about to edit my answer.  Yours was a good catch and I didn't realize\
    \ that my answer would have missed that one.  I should also point out that my\
    \ answer works with your examples, but it would be better to not refactor my solution\
    \ and just fix the problem with my solution. :-)\n<|/ c |>\n<| c |>\nI thought\
    \ about that, but thought it would be better to leave it alone and edit it than\
    \ to edit it wrong.  My answer is already pretty long (especially if you're not\
    \ familiar with Ruby syntax or anything like that), and I'm not sure how this\
    \ would be refactored for that reason.  I'll edit my answer once you fix your\
    \ answer.  :-)\n<|/ c |>\n<| a |>\nThis problem is more difficult than it seems\
    \ at first, but after some thought, I've come up with a solution.\nI first wrote\
    \ a script to print the indices that need to be changed:\n<code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n\
    a.each_with_index { |val,i|\n    if val%3 != 0 && i%3 == 0\n        puts i\n \
    \   end\n}\n</code>\nWhen I ran it, I got\n<code>\n1\n3\n7\n11\n13\n15\n17\n</code>\n\
    (The script doesn't care about values that aren't divisible by 3 or those that\
    \ aren't multiples of 3).\nAfter that, I wrote a script to print the indices that\
    \ need to be changed:\n<code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n\
    a.each_with_index { |val,i|\n    if val%3 != 0 && i%3 == 0\n        puts i\n \
    \   end\n}\na.each_with_index { |val,i|\n    if val%3 != 0 && i%3 == 0\n     \
    \   puts i\n    end\n}\n</code>\nWhen I ran the script, I got \n<code>\n1\n3\n\
    7\n11\n13\n15\n17\n</code>\nThis made me realize that we can use Ruby's Enumerable#",
  "  return l.sort_by {|e| e % 3 }.uniq.compact\nend\n</code>\n<|/ a tags=sorting,ruby\
    \ |>\n<| c |>\nThe sorting algorithm isn't stable, and shouldn't be used this\
    \ way (except for the OP's specific purposes).\n<|/ c |>\n<| c |>\n: What is your\
    \ objection? The OP's purpose is to sort a list by three arbitrary properties\
    \ (in this case, the first, the second and the third). How is this not stable\
    \ (except for those properties being unstable, which doesn't matter)? Also, I\
    \ wouldn't have thought that an implementation would not have a stable sorting,\
    \ but I haven't looked at the code.\n<|/ c |>\n<| c |>\nIt looks like the sorting\
    \ algorithm is stable, but `sort_by` is not (and for that matter, `sort` is not\
    \ stable). However, your solution is more \"rubyish\".\n<|/ c |>\n<| c |>\nHmm,\
    \ okay. I guess I'm still not understanding what that means. I thought that `sort_by`\
    \ was \"stable\" because it guaranteed that duplicates in the result would be\
    \ in the same order as the original. By \"stable\" I meant that they would not\
    \ change order when compared to their original order. Is this not correct? I guess\
    \ my confusion stems from trying to use the term \"stable\" without understanding\
    \ what it means.\n<|/ c |>\n<| c |>\n: Yes, it's true. My point is that it's unnecessary\
    \ for you to use this solution and should only be considered as a fallback (to\
    \ show a more Rubyish solution).\n<|/ c |>\n<| a dscore=2 tags=sorting,ruby |>\n\
    You could use Enumerable#sort_by:\n<code>\nsorted_list = list.sort_by {|x| [x%3,\
    \ x,x%3, x%3]}\n</code>\n<|/ a |>\n<| c |>\nNice solution. Just keep in mind that\
    \ `sort_by` returns an array of arrays, not an array of hashes. So, if you do\
    \ `sorted_list.inspect` it will print `[[1, 6, 3], [1, 8, 3], [2, 6, 3], [3, 8,\
    \ 3], [5, 6, 3], [6, 8, 3], [7, 6, 3], [8, 8, 3]]`\n<|/ c |>\n<| c |>\nI agree\
    \ that it's unconventional to do it this way, but it is possible to do so. `list.sort_by\
    \ {|x| [x%3, x,x%3, x%3]}.map(&:last)`\n<|/ c |>\n<| a tags=sorting,ruby ", " \
    \ l.each_with_index do |val, i|\n    if i % 3 == 0 && i != 0\n      l[i-1] = val\n\
    \    end\n  end\n  l\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is very inefficient.\
    \ Also, you should probably put a `-1` in the return statement instead of `0`.\n\
    <|/ c |>\n<| c |>\nHow inefficient? As I said in the answer, \"sort by dividing\
    \ by three\", which does exactly that. Why would you return `0` for the index\
    \ 0?\n<|/ c |>\n<| c |>\nOh, I see what you mean. Yes, you do want to return the\
    \ *last* element of the array. This means you need to sort by the modulus `3`\
    \ in the key function.\n<|/ c |>\n<| c |>\nAhh, I see, you're right. I'll update\
    \ it accordingly, thanks.\n<|/ c |>\n<| c |>\nOkay, I've updated my answer to\
    \ include the correct sort function.\n<|/ c |>\n<| a |>\nAnother approach is to\
    \ sort the array as you iterate over it, using each_cons to divide up the array\
    \ into threes. The remainder of the array can then be sorted using sort_by\n<code>\n\
    array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]", "  l.sort.with_index { |a, b|\
    \ b if b%3 == 0 }\nend\n</code>\n<|/ a |>\n<| c |>\nThe question was specifically\
    \ about Ruby. I assume you meant [tag:ruby-on-rails-4] and [tag:ruby-on-rails].\n\
    <|/ c |>\n<| c |>\nThanks. Fixed the tags and added a note about Ruby's `Enumerable`\
    \ module. I also added an explanation about how it works.\n<|/ c |>\n<| c |>\n\
    Ah, that makes a lot of sense. Thanks for adding the explanation! I've never seen\
    \ the `with_index` method before.\n<|/ c |>\n<| c |>\nThis is really cool! I thought\
    \ I was going to get some code golf for this, but this works wonderfully!\n<|/\
    \ c |>\n<| c |>\nI ended up getting this code golfing by doing the following with\
    \ Ruby: ```puts [1,2,3,4,5,6,7,8,9,10].sort.chunk(&:odd?)```. I got it working\
    \ with [the answer](https://stackoverflow.com/a/47395714/9547676) which uses `chunk`,\
    \ but yours is cleaner. Thanks so much!\n<|/ c |>\n<| a |>\nA different take on\
    \ it:\n<code>", "  l.sort\n  l.each_with_index do |val, i|\n    if i%3 == 0\n\
    \      l[i] = l[i+1]\n    end\n  end\n  l\nend", "  l.sort.with_index do |value,\
    \ index|\n    index % 3 == 0 ? value : value\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\n<code>", "  l.sort\n  l.each_with_index do |n, i|\n    i -= 1 if\
    \ i % 3 == 1\n    l[i] = n\n  end\n  l\nend\n</code>\nThis takes your array, creates\
    \ a sorted copy of it by calling sort, and then iterates over each element and\
    \ checks if it is divisible by three. If it is, it adds the element to the correct\
    \ position of that same array. Otherwise, nothing happens.\nAt the end of this\
    \ block of code, the original list is returned.\n<|/ a dscore=0 |>\n<| c |>\n\
    I don't think that `each_with_index` would be an appropriate solution, since it\
    \ requires you to perform the iteration twice. Also, `each_with_index` is only\
    \ necessary if you need the indexes of the original elements (which I doubt if\
    \ you do).\n<|/ c |>\n<| c |>\n, I agree with you. I just tried to keep it simple.\
    \ Since the OP asked about how to sort an array, this would be the simplest solution.\
    \ However, I agree that this is unlikely to be the best solution as I stated earlier.\n\
    <|/ c |>\n<| c |>\n, I see what you mean. `each_with_index` doesn't require iterating\
    \ the entire array twice. In the first block, `l` is an array, and `l.sort` performs\
    \ iteration on the entire array. So `each_with_index` is simply needed to get\
    \ the indexes, and `sort` will perform an iteration on the entire array again\
    \ to get the sorted array.\n<|/ c |>\n<| a dscore=0 |>\nThis works for me:\n<code>\n\
    require 'enumerator'", "  thirds = []\n  while l != []\n    thirds.push l.pop\n\
    \  end\n  sorted = []\n  i = 0\n  while i < thirds.length\n    j = thirds.length\
    \ - 1\n    while j >= i && thirds[j] == thirds[j - 1]\n      j -= 1\n    end\n\
    \    sorted << thirds[i]\n    thirds.delete_at(i)\n    i = j\n  end\n  return\
    \ sorted\nend", "  l.each_with_index do |number, index|\n    if index%3 == 0\n\
    \      l.swap(index, index+1)\n    end\n  end\nend", "  a = []\n  b = []\n  c\
    \ = []\n  for i in l\n    if i % 3 == 0\n      a << i\n    elsif i % 3 == 1\n\
    \      b << i\n    elsif i % 3 == 2\n      c << i\n    end\n  end\n  return a<<b<<c\n\
    end", "    l.each_with_index do |num, index|\n        if index%3 == 0\n      \
    \      l.delete_at(index)\n        end\n    end\n    l.sort!\n    l.each_with_index\
    \ do |num, index|\n        if index%3 == 0\n            l[index] = num\n     \
    \   end\n    end\n    return l\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<|\
    \ a dscore=0 |>\n<code>", "  l.each_with_index { |x, i| l[i] = x if i % 3 == 0\
    \ }\n  l.sort\nend\n</code>\n<|/ a |>\n<| c |>\nYour code is wrong. Check it out:\n\
    `[5, 6, 3, 4, 8, 9, 2].each_with_index.map { |x, i| [x, i] if i % 3 == 0 }.to_h\n\
    => [5, 6, 3, 4, 8, 9, 2]`\n<|/ c |>\n<| c |>\nYeah you're right. I didn't think\
    \ of it when typing my answer. I just updated it. Thanks.\n<|/ c |>\n<| c |>\n\
    I actually like this one better. It is more robust, because when there is no element\
    \ in the list with index divisible by three, `[x, i]` will evaluate to `nil`.\n\
    <|/ c |>\n<| a dscore=2 tags=ruby |>\n<code>\na = [1, 2, 3, 6, 7, 8, 9]\nb = a.dup\n\
    b.delete_if { |e| e % 3 == 0 }\nb.sort\n</code>\n<|/ a |>\n<| a |>\nYou can use\
    \ map to create an index. After that, you can sort it and map it to its original\
    \ indices:\n<code>\na = [1, 2, 3, 6, 7, 8, 9]\na.map.with_index { |n, i| [i, n]\
    \ }.sort\n=> [[1, 1], [2, 2], [3, 3], [7, 6], [8, 7], [9, 9]]\n</code>\n<|/ a\
    \ tags=ruby dscore=1 |>\n<| a dscore=1 |>\n<code>\na = [1, 2, 3, 6, 7, 8, 9]",
  "    l = sorted(l)\n    l.each_with_index do |e, i|\n        if i % 3 != 0\n   \
    \         l.delete_at(i)\n        end\n    end\n    l\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI'm afraid this doesn't work well for lists of large numbers. Try `sort_third([10,\
    \ 100, 1000, 10000, 100000, 10000000])`. The result would be `[100000, 10000000,\
    \ 10000, 1000, 100, 10]`.\n<|/ c |>\n<| c |>\nAh, of course! I should change it\
    \ to use `each_with_index` instead. Fixed it now\n<|/ c |>\n<| c |>\nThis is great.\
    \ Thank you!\n<|/ c |>\n<| a dscore=1 |>\nHere's an alternative using Enumerable#partition,\
    \ sorting and flattening:\n<code>\n[1, 2, 3].partition { |e| e % 3 == 0 }.sort_by\
    \ { |e| e % 3 }.flatten", "  l.each_with_index do |n,i|\n    index =\n    if n\
    \ % 3 == 0\n      i\n    else\n      (i+1)%3\n    end\n    temp = l[i]\n    l[i]\
    \ = l[index]\n    l[index] = temp\n  end\n  l\nend", "  sorted = []\n  i = 0\n\
    \  while i < l.length\n    divisible_by_three = i % 3 != 0\n    sorted_by_value\
    \ = {}\n    sorted_by_value[l[i]] = l[i]\n    if divisible_by_three\n      sorted_by_value[l[i>>2]]\
    \ = l[i>>2]\n    end\n    sorted << sorted_by_value\n    i += 1\n  end\n  sorted\n\
    end", "  l = l.to_a\n  l3 = []\n  i = 0\n  while i < l.length\n    if i % 3 ==\
    \ 0\n      l3 << l[i]\n    end\n    i += 1\n  end\n  return l3.sort\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails dscore=0 |>\n<code>",
  "  lt = []\n  for i in 0...l.length\n    v = l[i]\n    if v & 3 == 0 && v & 1 !=\
    \ 0\n      lt << v\n      lt << l[i]\n      lt << l[i+1]\n      lt << l[i+2]\n\
    \    end\n  end\n  return lt\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI suppose\
    \ it could also be done like this.\n<code>", "  return l.sort_by { |e| (e.to_f\
    \ % 3) != 0 }.sort\nend", "    l.sort\n    l.each_with_index { |x, i| l[i] = x\
    \ if i % 3 == 0 }\nend", "  l.sort!\n  new_l = l.clone\n  new_l.each_with_index\
    \ do |value, i|\n    if i % 3 == 0\n      new_l[i] = new_l[i] + new_l[i + 1]\n\
    \      new_l[i + 1] = new_l[i]\n    end\n  end\n  new_l\nend", "  l.sort_by {\
    \ |i| i % (l.length / 3) }\nend", "  return l.each_with_index.map do |n, i|\n\
    \    if i % 3 > 0\n      n\n    else\n      i + n if n != 0\n    end\n  end\n\
    end", "  new = []\n  l.each_with_index do |value, index|\n    until index != 0\
    \ && index % 3 == 0\n      new.push(value)\n      index += 1\n    end\n  end\n\
    \  new\nend\n</code>\n<|/ a dscore=2 tags=ruby,sorting,arrays |>\n<| a |>\nTry\
    \ this out. I used the Ruby 2.1 version, so it might not work with older Ruby\
    \ versions. Also, I assumed that you want to sort each number individually and\
    \ not the whole array. So, if there's more than one number per array, these numbers\
    \ need to be sorted. \n<code>", "  l.each_with_index do |x, i|\n    if i % 3 ==\
    \ 0\n      l[i] = x\n    end\n  end\n  l.sort!\nend\n</code>\n<|/ a dscore=1 tags=sorting,ruby\
    \ |>\n<| a |>\nIf you're not very into sorting algorithms, the following method\
    \ sorts the input array by splitting each of the elements into three and sorting\
    \ the third element in descending order.\n<code>", "  return l.partition {|e|\
    \ (e % 3 == 0)}.sort {|a, b| (b % 3 == 0).nonzero? ? b : a}\nend", "  return l[0\
    \ .. (l.length / 3)].sort { |a, b| l == a || l == b ? 0 : (l < a ? -1 : 1) } +\
    \ l[0 .. l.length / 3]\nend", "  l1, l2 = l.sort, l.sort\n  l1.zip(l2).map do\
    \ |a|\n    (a[1] & 3 == a[0] ? a[0] : a[1])\n  end\nend", "    l.sort!\n    l.each_with_index\
    \ { |e, i|\n        if i % 3 == 0\n            l[(i + 1) / 3] = e\n        end\n\
    \    }\n    return l\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\nI really\
    \ like this approach! However, I do have a question about the part where you swap\
    \ the values at index 'i' with 'i+1' and 'i/2' -- I understand that the values\
    \ at those indices get changed, but I am confused about how exactly the function\
    \ knows to change the values at those indicies?\n<|/ c |>\n<| c |>\nThe method\
    \ sort_third does a sort of the array and swaps the values at indices 0 and 1,\
    \ the other values get swapped as well. Have a look at the example in the answer\n\
    <|/ c |>\n<| c |>\nThe values at those indicies get swapped, but how? You said\
    \ `l[(i + 1) / 3] = e` which I assume is swapping the values at those indicies\
    \ with those at other indices (and thus changing the indices to match up) but\
    \ I don't understand how that line knows to do that.\n<|/ c |>\n<| c |>\nThe function\
    \ calls .sort! on the original array. Ruby keeps track of the indices of the array\
    \ that have been changed since it last returned. This way the code knows that\
    \ if you use l[0] after this function, it will return the value in position 0\
    \ even though it has been changed. When you do `l[(i + 1) / 3] = e`, it replaces\
    \ the value at index `i` in the original list with that at index `i+1` while also\
    \ changing all the other indices as well.\n<|/ c |>\n<| c |>\nThis was a great\
    \ explanation and your example works great! Thank you so much!\n<|/ c |>\n<| a\
    \ tags=ruby |>\n<code>", "  result = l.copy()\n  result.sort_by! do |x|\n    divisible_by_three\
    \ = result - x\n    indicies_that_are_divisible_by_three = result.find_index(divisible_by_three)\n\
    \    indicies_that_are_divisible_by_three.each do |i|\n      result[i] = x\n \
    \   end\n  end\n  result\nend\n</cell>\n<cell>", "  l'.each do |i|\n    l[i] =\
    \ l[i] % 3\n    if l[i] != 0\n      l'.delete(i)\n      break\n    end\n  end\n\
    \  l'\nend\n</code>\n<|/ a tags=ruby,algorithm dscore=0 |>\n<| c |>\nThe method\
    \ `sort_third` modifies the list in place and returns it. If you don't assign\
    \ it back to a variable, nothing happens. I think you want to have it return the\
    \ sorted list.\n<|/ c |>\n<| c |>\n: I guess you mean `l'.sort` instead of `l'.each`\
    \ since `sort` returns a new array. I assume he already knows how to sort a list.\n\
    <|/ c |>\n<| c |>\nI guess the OP does not know *how* to sort a list. That's why\
    \ he wants something that \"sorts list while preserving its values\". That's why\
    \ I suggested `sort_third`.\n<|/ c |>\n<| c |>\nAh yes, you're right. Sorry for\
    \ the misunderstanding. I assumed the OP knew the solution to sorting a list.\
    \ Thanks for pointing that out. I edited my answer to make it a little clearer.\n\
    <|/ c |>\n<| a |>\nIf it's okay to create a new list for each pass, this would\
    \ be a way to do it:\n<code>", "  l.each_with_index do |val, i|\n    next if i\
    \ % 3 == 0\n    l.delete_at(i)\n  end\n  l.sort!\n  l\nend", "  l.sort!\n  \n\
    \  l.each_with_index do |val, index|\n    if index % 3 == 0\n      l[index] =\
    \ val\n    end\n  end\n  \n  l\nend\n</cell>\n<cell>\nsort_third([5, 6, 3, 4,\
    \ 8, 9, 2])\n</cell>\n<text>\nThe sort_third function has one line and one variable\
    \ declaration, which makes it easy to see how it works. We loop through the list\
    \ l, which we pass to the function, which will modify the list, and save the list\
    \ into the variable l'.", "  l.sort {|a,b| a % 3 == b % 3 ? a - b : a % 3 ? 1\
    \ : b - a }\nend", "    len_l = 0\n    for num in l\n        len_l += 1\n    end\n\
    \    thirds = (len_l / 3) - 1\n    l.sort\n    while thirds >= 0\n        l.delete_at((thirds\
    \ - 1) % len_l)\n        thirds = thirds - 1\n    end\n    return l\nend", " \
    \ l.each_with_index {|n, i| l[i] = l[i].sort if l[i].modulo(3).zero?}\n  l\nend\n\
    </code>\n<|/ a dscore=0 tags=sorting,ruby |>\n<| a tags=sorting,ruby dscore=0\
    \ |>\nIf it helps, here's a slightly shorter way to do it:\n<code>", "  l = l.clone\n\
    \  l[0] = l[1] = l[2] = nil\n  l.sort!\n  l\nend", "  l.sort!\n  l.each_with_index\
    \ do |e, i|\n    next if i % 3 == 0\n    l[i] = e\n  end\n  l\nend", "  result\
    \ = []\n  result.concat(l.take(l.length / 3))\n  result.concat(l.drop(l.length\
    \ / 3))\n  return result\nend", "  l.each do |i|\n    if i.even?\n      l[i] =\
    \ l[i].max\n    elsif i.odd?\n      l[i] = l[i].min\n    end\n  end\n  l\nend",
  "  len1 = l.length\n  len2 = l.length\n  third = len1 / 3\n  len3 = len1 - third\n\
    \  l3 = (len3.times.map { |x| l.slice!(0,third+x) }) + len3.times.map { |x| l.slice!(0,\
    \ third) }\n  len4 = l.length - len3\n  l4 = len4.times.map { |x| l.slice!(0,\
    \ len3) }\n  l4.repeated_permutation(len4).map(&:flatten)\nend", "  l3 = l.dup.each_with_index.map\
    \ { |v, i| [ i / 3, v ] }.to_h\n  l3.delete_if { |_,v| v % 3 == 0 }\n  l3.sort.map\
    \ { |_,v| v % 3 == 0 ? v : v % 3 }.concat(l3.sort.map { |_,v| v % 3 })\nend",
  "  l.sort!\n  l[0::3] = l[0::3].sort\n  l[1::3] = l[1::3].sort\n  l[2::3] = l[2::3].sort\n\
    \  l\nend", "  l = [l[0], l[1], l[2]]\n  l.each_with_index do |value, index|\n\
    \    index % 3 == 0 && l[index] == value && l[index + 1] < value && l[index +\
    \ 2] < value\n    index % 3 != 0 && l[index] == value && l[index - 1] < value\
    \ && l[index - 2] < value\n    l[index] = value\n  end\n  l\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
