name: HumanEval_70_strange_sort_list
language: rb
prompt: "# Given list of integers, return list in strange order.\n# Strange sorting,\
  \ is when you start with the minimum value,\n# then maximum of the remaining integers,\
  \ then minimum and so on.\n# Examples:\n# strange_sort_list([1, 2, 3, 4]) == [1,\
  \ 4, 2, 3]\n# strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n# strange_sort_list([])\
  \ == []\ndef strange_sort_list(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strange_sort_list\n\
  \    candidate = method(:strange_sort_list)\n    assert_equal([1, 4, 2, 3], candidate.call([1,\
  \ 2, 3, 4]))\n    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))\n\
  \    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))\n    assert_equal([1,\
  \ 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))\n    assert_equal([5, 5, 5,\
  \ 5], candidate.call([5, 5, 5, 5]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7,\
  \ 8]))\n    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2,\
  \ 5, 5, -5, -5]))\n    assert_equal([111111], candidate.call([111111]))\n  end\n\
  end\n"
completions: ["  sorted = []\n  list.sort { |a,b| b <=> a }\n  lst.each { |item| sorted.push(item)\
    \ }\n  return sorted\nend", "  lst.sort!\n  result = ''\n  lst.each do |x|\n \
    \   result << x.to_s\n  end\n  result\nend", "  min_val = lst.min_by{ |x| x }\n\
    \  max_val = lst.max_by{ |x| x }\n  min_val.zip(*max_val).flatten\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\n<code>", "  lst.sort!\n  lst.map { |num| num.abs }\n\
    end", "\tsorted = []\n\tfor i in lst\n\t\tsorted.insert(0, lst.pop(lst.index(min([lst])))\n\
    \treturn sorted\nend", "  # Write your code here\n  return lst.sort\nend", " \
    \   lst = lst.sort\n    lst.reverse!\n    lst\nend", "  res = []\n  i = 0\n  \n\
    \  while i < lst.size do\n    res << lst[i] \n    i += 1\n  end\n  \n  i = 1\n\
    \  \n  while i < lst.size do\n    tmp = res[-1]\n    \n    tmp = lst[i] if i >\
    \ 0 and (lst[i-1] == tmp or lst[i-1].between?(tmp, tmp+1))\n    \n    res << tmp\n\
    \    i += 1\n  end\n  \n  res\nend\n</code>\n<|/ a tags=arrays,ruby,sorting |>\n\
    <| c |>\nThis is clever but I don't think it works with edge cases such as [5,5,5,5,5].\n\
    <|/ c |>\n<| c |>\nHad an edge case. Fixed.\n<|/ c |>\n<| c |>\nThis is brilliant!\
    \ I implemented the sorting algorithm in Python, and it is way faster that `Array#sort`.\
    \ My solution: `def strange_sort(a): return sorted(a) + sorted(reversed(a)).cycle.rotate(-1).to_a`\n\
    <|/ c |>\n<| a tags=arrays,ruby,sorting |>\nThe trick is to use a hash table to\
    \ store the current order and compare each item with the current order.\n<code>",
  "  lst.sort\n  lst.map(&:to_s).sort\nend\n</code>\n<|/ a |>\n<| c |>\n`sort_by!`\
    \ will mutate `self`, which is undesirable.\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  return lst.sort\nend", "    sorted_list = []\n    if !lst.empty?\n      sorted_list\
    \ = lst\n      sorted_list.sort!\n    end\n    sorted_list\n  end\n</code>\n<|/\
    \ a tags=ruby,sorting,arrays |>\n<| c |>\nI think you are wrong. I got this result\
    \ with `strange_sort_list [1,2,4,5]\n=> [1, 4, 5, 2]`\n<|/ c |>\n<| c |>\nsorry,\
    \ I thought you were looking for a descending sort (from largest to smallest)\n\
    <|/ c |>\n<| c |>\nI got this from your answer, `strange_sort_list [4,3,2,1]\n\
    => [4, 3, 2, 1]`\n<|/ c |>\n<| c |>\nyes, I got that as well.  I didn't notice\
    \ the descending aspect in the question and just sorted it ascending.  I modified\
    \ my answer to include a descending sort\n<|/ c |>\n<| c |>\nIt would be great\
    \ to get a benchmark of these two solutions, I believe there may be a difference\n\
    <|/ c |>\n<| a |>\nTry this\n<code>", "  lst.sort! # Now use Ruby sorting\n  lst.map\
    \ { |x| x.to_s } # Stringify and join on commas\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\n`@strange_sort_list = str.chars.map { |x| x.to_s }.join(',')` is\
    \ a bit too much of an overhead when you're just using it once. `strange_sort_list(str.chars.map\
    \ { |x| x.to_s })` would even be better.\n<|/ c |>\n<| c |>\nAgreed. I'll just\
    \ keep the comment in my code for clarity and understanding. I was just trying\
    \ to illustrate `map` and `join` which I have found to be a pretty useful method\
    \ on Array objects. I see your point, I guess it just seemed like the most direct\
    \ route to demonstrate `map`.\n<|/ c |>\n<| a dscore=0 |>\nA simple (but not the\
    \ best) solution is to use regular expressions, here is an example:\n<code>",
  "  # write code here\n  return lst\nend", "  return lst.sort_by { |x| [-x, x] }\n\
    end\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>", "  return lst.sort.reverse\n\
    end", "  sorted = []\n  min_index = 0\n  max_index = 0\n  while lst != []\n  \
    \  sorted = sorted + lst.sort\n    lst.clear\n    puts \"#{min_index}-#{max_index}\
    \ #{lst}\"\n    min_index = min_value_index\n    max_index = max_value_index\n\
    \  end\n  sorted\nend", "  return lst.sort.reverse.join(' ')\nend", "    min =\
    \ lst.min\n    max = lst.max\n    return lst.sort{|a,b| min <=> b <=> max}.to_a\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a |>\nI know this is an old thread, but I\
    \ just came up with a solution that doesn't use sort and also sorts in descending\
    \ order:\n<code>", "  if lst.nil?\n    lst\n  else\n    lst.sort\n    strange_sort_list(lst.take_while\
    \ { |x| x < lst.max })\n    strange_sort_list(lst.take_while { |x| x < lst.min\
    \ })\n  end\nend", "  lst.sort.reverse!\n  return lst\nend", "    smallest = lst[0]\n\
    \    largest = lst[0]\n    smallest_index = -1\n    largest_index = -1\n    smallest_value\
    \ = smallest\n    largest_value = largest", "  return lst.sort { |a, b| a.to_s\
    \ <=> b.to_s }\nend", "  # sort list\n  lst.sort", "  return lst.sort.reverse\n\
    end", "  lst.sort!\n  return lst\nend", "  result = lst\n  result.reverse!\n \
    \ result.pop\n  result.pop\n  result.pop\n  result.pop\n  result.pop\n  result.reverse!\n\
    \  result\nend\n</code>\n<|/ a |>\n<| c |>\nThis isn't really the sort the OP\
    \ is asking for.  Your code just returns a copy of the original list, not the\
    \ list itself.\n<|/ c |>\n<| c |>\nOP wants the list sorted in strange order,\
    \ I think he's looking for a more compact way of doing that. Your solution is\
    \ O(n^2).\n<|/ c |>\n<| c |>\nYes, I was looking for a more compact/efficient\
    \ solution, thanks.\n<|/ c |>\n<| c |>\nI like this solution, for its simplicity.\n\
    <|/ c |>\n<| c |>\nNice solution! I like it so much I created [an answer](https://stackoverflow.com/a/53874415/1142603)\
    \ with an explanation that makes me want to upvote it.\n<|/ c |>\n<| a |>\nHere's\
    \ a one-liner using each_cons and map that does the trick:\n<code>", "  lst.sort!\n\
    end", "\tlst.each do |x|\n\t\tmin = x\n\t\tmax = x\n\t\tarr.each do |y|\n\t\t\t\
    if min > y\n\t\t\t\tmin = y\n\t\t\tend\n\t\t\tif max < y\n\t\t\t\tmax = y\n\t\t\
    \tend\n\t\tend\n\t\tif min == max\n\t\t\tlst.sort! { |a, b| a <=> b }\n\t\telse\n\
    \t\t\tlst.sort! { |a, b| a <=> b }\n\t\t\tlst.sort! { |a, b| b <=> a }\n\t\tend\n\
    \tend\n\tlst\nend", "  new_list = []\n  new_list.insert(0, lst.sort.min)\n  new_list.insert(0,\
    \ lst.sort.max)\n  new_list.insert(0, lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n\
    \  new_list.insert(0, lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n  new_list.insert(0,\
    \ lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n  new_list.insert(0, lst.sort.min)\n\
    \  new_list.insert(0, lst.sort.max)\n  new_list.insert(0, lst.sort.min)\n  new_list.insert(0,\
    \ lst.sort.max)\n  new_list.insert(0, lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n\
    \  new_list.insert(0, lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n  new_list.insert(0,\
    \ lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n  new_list.insert(0, lst.sort.min)\n\
    \  new_list.insert(0, lst.sort.max)\n  new_list.insert(0, lst.sort.min)\n  new_list.insert(0,\
    \ lst.sort.max)\n  new_list.insert(0, lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n\
    \  new_list.insert(0, lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n  new_list.insert(0,\
    \ lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n  new_list.insert(0, lst.sort.min)\n\
    \  new_list.insert(0, lst.sort.max)\n  new_list.insert(0, lst.sort.min)\n  new_list.insert(0,\
    \ lst.sort.max)\n  new_list.insert(0, lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n\
    \  new_list.insert(0, lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n  new_list.insert(0,\
    \ lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n  new_list.insert(0, lst.sort.min)\n\
    \  new_list.insert(0, lst.sort.max)\n  new_list.insert(0, lst.sort.min)\n  new_list.insert(0,\
    \ lst.sort.max)\n  new_list.insert(0, lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n\
    \  new_list.insert(0, lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n  new_list.insert(0,\
    \ lst.sort.min)\n  new_list.insert(0, lst.sort.max)\n  new_list.insert(0, lst.sort.min)\n\
    \  new_list.insert(0, lst.sort.max)\n  new_list.insert(0, lst.sort.", "  lst.sort\n\
    end", "  sorted = []\n  minimum, maximum = lst.min, lst.max\n  sorted = lst\n\
    \  sorted.sort! {|a, b| a <=> b }\n  sorted.reverse!\n  sorted.each_index { |i|\
    \ sorted.insert(i, minimum) }\n  sorted.each_index { |i| sorted.insert(i, maximum)\
    \ }\n  sorted.each_index { |i| sorted.insert(i, minimum) }\n  sorted.map { |i|\
    \ lst[i] }\nend", "  result = []\n  while lst.length != 0\n    smallest = lst.shift\n\
    \    largest = lst.shift\n    result.push(largest)\n    result.push(smallest)\n\
    \  end\n  result\nend", "  return lst.sort.reverse.map(&:first)\nend\n</code>\n\
    And now you can call it like so:\n<code>\nstrange_sort_list([3, 5, 1, 2])\n</code>\n\
    And it will output [3, 5, 1, 2] in the console. Try it online at repl.it: https://repl.it/@robertoleal/strange-sort-list\n\
    <|/ a tags=sorting,ruby |>\n<| c |>\n`[3, 5, 1, 2].sort` outputs `[3, 1, 5, 2]`.\
    \ `[3, 5, 1, 2].sort!` outputs `[1, 2, 3, 5]`. `[3, 5, 1, 2].sort_by(&:abs)` outputs\
    \ `[3, 1, 5, 2]`.\n<|/ c |>\n<| c |>\n`[3, 5, 1, 2].sort!` outputs `[1, 2, 3,\
    \ 5]`\n<|/ c |>\n<| c |>\n`[3, 5, 1, 2].sort!` outputs `[1, 2, 3, 5]`\n<|/ c |>\n\
    <| c |>\n`[3, 5, 1, 2].sort!` outputs `[1, 2, 3, 5]`\n<|/ c |>\n<| a tags=sorting,ruby\
    \ |>\nIn general, you can use sort_by and sort_by:\n<code>\na = [5,1,3,2]\na.sort_by\
    \ { |x| x }  # => [1, 3, 2, 3, 5]\na.sort_by(&:abs)  # => [1, 3, 2, 3, 5]\n</code>\n\
    sort_by and sort_by accept a block that will be applied to each element in turn.\
    \ The block can return any value that would sort the array in the same way as\
    \ the original array, so you can use this to sort by any criteria you want.\n\
    You can also pass a block to sort_by which uses Array#<=>:\n<code>\na = [5,1,3,2]\n\
    a.sort_by { |x| x <=> 7 }", "  lst.sort!\n  lst.each_with_index do |item, idx|\n\
    \    idx == lst.size - 1 && item.next\n    lst.delete_at(idx)\n  end\n  lst\n\
    end", "  lst = lst.sort {|a, b| a.to_i <=> b.to_i}\n  lst.to_a\nend", "  return\
    \ lst.sort_by {|x| -x.abs} if lst\nend", "  if lst.is_empty?\n    lst\n  else\n\
    \    first = lst[0]\n    last = lst[-1]\n    mid = first\n    lst = lst.drop(1)\n\
    \    lst = lst.unshift(first)\n    lst = lst.unshift(last)\n    lst = lst.sort_by\
    \ {|x| x}\n    lst = lst.unshift(mid)\n    lst\n  end\nend", "  lst.sort!\n  i\
    \ = 0\n  while i < lst.size\n    if lst[i] > lst[i + 1]\n      lst[i], lst[i +\
    \ 1] = lst[i + 1], lst[i]\n    else\n      i += 1\n    end\n  end\n  lst\nend",
  "    lst = lst.sort\n    return lst.to_s\nend\n</code>\n<|/ a tags=ruby |>\n<| a\
    \ tags=ruby |>\n<code>", "  result = []\n  min_value = lst[0]\n  max_value = lst[0]\n\
    \  lst.each {|x| min_value = x < min_value ? x : min_value}\n  lst.each {|x| max_value\
    \ = x > max_value ? x : max_value}\n  lst.each {|x| result.push(x)}\n  result.push(1)\n\
    \  result.push(max_value)\n  result.push(min_value)\n  result\nend", "  sorted\
    \ = []\n  sorted = sorted.concat(lst[1..-1]).concat(lst[0..-2]).concat(lst[-1])\
    \ if lst.count > 1\n  sorted = sorted.concat(lst[0..-2]) if lst.count > 1\n  sorted\
    \ = sorted.concat(lst[-1]) if lst.count > 1\n  sorted = sorted.concat(lst[1..-1])\
    \ if lst.count > 1\n  sorted = sorted.concat(lst[1..-1]) if lst.count > 1\n  sorted\
    \ = sorted.concat(lst[0..-2]) if lst.count > 1\n  return sorted\nend", "  lst.sort\n\
    end\n</code>\nFor a more concise solution, use sort_by, which will sort in place,\
    \ using <=>:\n<code>", "  new_list = []\n  min = lst[0]\n  max = lst[0]\n  max_index\
    \ = lst.index(0)\n  new_list = [max]\n  for i in lst\n    if i != max\n      if\
    \ i < min\n        min_index = lst.index(min)\n        new_list << min\n     \
    \   new_list << lst[min_index]\n        max = min\n        min = lst[min_index]\n\
    \      elsif i > max\n        max_index = lst.index(max)\n        new_list <<\
    \ max\n        new_list << lst[max_index]\n        min = i\n        max = i\n\
    \      else\n        max = i\n      end\n    end\n  end\n  new_list << min\n \
    \ new_list << max\n  new_list\nend\n</code>\n<|/ a |>\n<| a |>\nI came up with\
    \ this solution using recursion. Recursion keeps calling itself until it's no\
    \ longer necessary. The last thing you want is a recursive solution that is too\
    \ complicated and it's hard to understand.\n<code>", "  sorted = []\n  while lst.any?\n\
    \    sorted = [lst.pop, lst.min, sorted.last, lst.max] + sorted\n  end\n  sorted\n\
    end", "    sorted = []\n    minimum = lst[0]\n    maximum = lst[0]\n    \n   \
    \ for i in lst\n        if i == minimum\n            minimum += 1\n          \
    \  \n            if minimum > maximum\n                sorted = sorted + [minimum]\n\
    \                minimum = minimum + 1\n            else\n                sorted\
    \ = sorted + [minimum, maximum]\n                minimum = minimum + 1\n     \
    \           maximum = maximum - 1\n        else\n            maximum -= 1\n  \
    \          \n            if minimum > maximum\n                sorted = sorted\
    \ + [minimum]\n                minimum = minimum + 1\n            else\n     \
    \           sorted = sorted + [minimum, maximum]\n                minimum = minimum\
    \ + 1\n                maximum = maximum - 1\n    \n    return sorted\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\n`strange_sort_list([1, 2, 4, 3]) == [1, 3, 2, 4]`\n\
    <|/ c |>\n<| c |>\nThank you, this is not the most optimal solution, but I like\
    \ it because it actually sorts the list. My solution is much more elegant than\
    \ this one.\n<|/ c |>\n<| c |>\nYeah, it's almost like a merge sort, but it's\
    \ in strange order.\n<|/ c |>\n<| c |>\nIt's in strange order because it's an\
    \ insertion sort algorithm, not an algorithm to sort anything more complex than\
    \ a list of numbers.\n<|/ c |>\n<| a tags=sorting,ruby |>\nJust another way to\
    \ do it,\n<code>\n[3, 4, 1, 2].sort_by { |x| x.rand }.reverse.map(&:first)", " \
    \   return lst.sort.reverse\nend", "  min_index = lst.index(lst.min) \n  max_index\
    \ = lst.index(lst.max)\n  return [lst[min_index], lst[max_index], lst[min_index+1],\
    \ lst[max_index-1]]\nend", "  if lst.empty?\n    []\n  else\n    lst.sort! do\
    \ |a, b|\n      a<b? -1 : (a == b? 0 : a < b? 1 : -1)\n    end\n  end\n  lst\n\
    end", "  result = [lst[0]]\n  for i in lst[1..-1]\n    index = result.index(i)\n\
    \    result.insert(index + 1, i)\n  result\nend\n</code>\n<|/ a dscore=2 tags=ruby,arrays\
    \ |>\n<| a tags=ruby,arrays |>\nHere's my take on it. This should work for all\
    \ cases. It's not very \"rubyish\" though.\n<code>", "  return lst.sort_by{|x|\
    \ lst.count(x)}.uniq\nend", "  return lst.sort.map { |x| x.to_s }.reverse\nend\n\
    </code>\nThis implementation is more memory efficient and faster than the other\
    \ one. Just check out benchmark below. :)\n<|/ a |>\n<| c |>\nThe accepted answer\
    \ works on 1.9.3. Mine works on 1.8.7.\n<|/ c |>\n<| c |>\nMy answer works on\
    \ Ruby 1.8.7, but the other answer (`str.sort.reverse`) works on Ruby 1.9.3. Which\
    \ version did you test on?\n<|/ c |>\n<| c |>\nMy code works on 1.8.7 as well\
    \ as the other answer. Try copy-pasting my code to a file and run it. My code\
    \ also works on 1.9.3.\n<|/ c |>\n<| c |>\nOh I see. I misread the comments.\n\
    <|/ c |>\n<| c |>\nWhy not use `sort_by`? `sort_by { |x| x.to_s }.reverse` works\
    \ in 1.8.7 and 1.9.3.\n<|/ c |>\n<| a tags=ruby |>\nI know this is an old post,\
    \ but I think this is cleaner (and faster):\n<code>", "  return lst.sort.reverse\n\
    end", "  if lst.length == 0 then []\n  else if lst.length == 1 then lst\n  else\
    \ \n    left = lst[0]\n    right = lst[1]\n    rest = lst.drop(2)\n    rest =\
    \ strange_sort_list(rest)\n    if rest.length == 0 then [left] + rest\n    else\
    \ if rest.length == 1 then [left, rest]\n    else \n      left = strange_sort_list(rest)[0]\n\
    \      right = strange_sort_list(rest)[1]\n      [left, right] + rest.drop(2)\n\
    \  end\nend", "  if lst.nil? or lst.length == 0\n    return []\n  else\n    max\
    \ = lst[0]\n    min = max\n    rest1 = strange_sort_list(lst[1..-1])\n    rest2\
    \ = strange_sort_list(lst[2..-1])\n    rest3 = strange_sort_list(lst[3..-1])\n\
    \    \n    rest1.concat rest2\n    rest1.concat rest3\n    rest1.concat [min]\n\
    \    \n    return rest1\n  end\nend", "  lst.sort.each { |n| lst.push(n) }\n \
    \ lst\nend\n</code>\n<|/ a tags=arrays,ruby,sorting,algorithm |>\n<| c |>\n`arr`\
    \ is modified by the method `push`, so it won't be an Array but an Enumerator\
    \ (which can be converted to an Array via `to_a`). Also, the method `push` modifies\
    \ the receiver in-place and doesn't return anything.\n<|/ c |>\n<| c |>\nYes you\
    \ are right I did not read the code properly. Fixed and thanks.\n<|/ c |>\n<|\
    \ c |>\nNotice that calling `push` on an Enumerator modifies the collection in-place.\
    \ Calling `to_a` on the Enumerator converts the Enumerator to an Array in-place.\
    \ Both calls are needed because an Enumerator is not an Array. Also, calling `to_a`\
    \ is useless, because `push` returns a new Enumerator instance.\n<|/ c |>\n<|\
    \ c |>\nAlso notice that `sort` is an Enumerable method, whereas `sort_by` an\
    \ Enumerator method. In fact, `sort` will convert an Enumerable to an Array in-place\
    \ (by converting each element to an Array and sorting it), whereas `sort_by` creates\
    \ a new Enumerator.\n<|/ c |>\n<| a |>\nIf arr is already sorted, then this is\
    \ very efficient.\nOtherwise, you are just sorting the elements one by one, which\
    \ is slow. Sorting the entire array once is faster.\n<code>", "  lst = lst.sort\
    \ { |a, b| a.to_s <=> b.to_s }\n  lst.each { |i| i.to_i }\nend\n</code>\n<|/ a\
    \ tags=ruby,string |>\n<| a tags=ruby,string |>\nYou could use a combination of\
    \ String#split and Enumerable#sort_by!:\n<code>", "  lst.sort_by do |element|\n\
    \    element < element ? element : element\n  end\nend", "  return lst.sort\n\
    end", "  sorted = []\n  for i in 1...lst.size\n    sorted.push lst[i - 1]\n  \
    \  sorted.push lst[i]\n    sorted.push lst[i..-2]\n    sorted.push lst[-2..-1]\n\
    \  end\n  sorted\nend", "  return lst.sort.reverse if lst.size > 0 && !lst.all?\
    \ { |x| x > lst.first }\n  lst\nend", "  lst.sort { |a, b| a.to_s <=> b.to_s }\n\
    \  return lst\nend", "  if lst.is_a? String or lst.is_a? Fixnum\n    lst\n  else\n\
    \    lst.sort\n  end\nend", "  lst.sort!\n  result = \"\"\n  (0...lst.size).each\
    \ do |index|\n    result << lst[index]\n  end\n  result\nend", "  lst.sort\n \
    \ i = 0\n  tmp = 1\n  while i < lst.size - 1\n    tmp += 1\n    i += 1\n  end\n\
    \  while i < lst.size\n    lst[i] += 1\n    tmp += 1\n    i += 1\n  end\n  lst.sort\n\
    \  return lst\nend", "  lst.sort!\n  for i in (1..lst.count)\n    lst[i..lst.count-i].sort!\n\
    \  end\n  lst\nend\n</code>\n<|/ a dscore=1 tags=sorting,ruby |>\n<| c |>\nI find\
    \ it strange that `(1..lst.count).sort_by { |i| lst.index(i) }` doesn't work the\
    \ same way as `lst.sort! { |a, b| lst.index(a) <=> lst.index(b) }`. Also, `(1..lst.count).sort_by\
    \ { |i| lst.index(i) }` is very inefficient compared to `lst.sort! { |a, b| lst.index(a)\
    \ <=> lst.index(b) }`.\n<|/ c |>\n<| c |>\nYeah `(1..lst.count).sort_by { |i|\
    \ lst.index(i) }` doesn't work the same way as `lst.sort! { |a, b| lst.index(a)\
    \ <=> lst.index(b) }`. \nMy first solution was based on what was in the question\
    \ where `lst.sort! { |a, b| lst.index(a) <=> lst.index(b) }` wasn't working. \n\
    Then I changed it to be more efficient by finding the first instance of each,\
    \ and then sorting the rest of `lst` based on the indexes of these firsts.\n<|/\
    \ c |>\n<| c |>\nYour first solution will work for your example, but if your example\
    \ were `strange_sort_list([4, 5, 3, 1, 2])` your first solution would return `[4,\
    \ 3, 1, 5, 2]`.\n<|/ c |>\n<| a tags=sorting,ruby dscore=0 |>\nYou can first sort\
    \ all by their index, then sort all again by the first occurrence:\n<code>", " \
    \ min = lst[0]\n  max = lst[0]\n  for i in 1..lst.size\n    if lst[i] > max\n\
    \      max = lst[i]\n    elsif lst[i] < min\n      min = lst[i]\n    end\n  end\n\
    \  lst.sort! {|x,y| x > y ? 1 : x > y ? -1 : 0} # Sorts largest to smallest\n\
    \  lst.push (min) lst.push (max) # Sorts smallest to largest\n  lst\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThanks so much for helping me out on this. However,\
    \ I still don't understand how to use this function to sort the list. I keep getting\
    \ an error.", "  return lst.sort {|i, j| i <=> j }.to_a\nend", "    sorted = []\n\
    \    sorted.concat(lst)\n    sorted.sort\n    return sorted\nend", "  if lst.empty?\n\
    \    lst\n  else\n    first = lst.first\n    last = lst.last", "  lst = lst.sort.reverse\n\
    \  lst.each_with_index { |e, i| lst.insert(i, e) }\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nIf you're going to use `sort!` on a sorted array, you're really\
    \ not gaining much from doing a `reverse` first.  I'd recommend `sort_by` or `sort_by!`\
    \ over `sort` here.\n<|/ c |>\n<| c |>\nThanks I updated to use sort_by! as suggested\
    \ :)\n<|/ c |>\n<| a tags=sorting,ruby |>\nHere are some answers already given:\n\
    <code>\na = [3,7,8,4,2,1,6,10]\np a.sort { |a, b| a.to_i <=> b.to_i }", "  lst.sort\n\
    \  lst.reverse\nend\n</code>\n<|/ a tags=sorting,ruby,arrays |>\n<| a dscore=0\
    \ |>\n<code>\na = [5,5,5,5]\nb = [5,5,5,5]\nc = a.sort + b.sort\np [a,b,c]\n</code>\n\
    <|/ a tags=sorting,ruby,arrays |>\n<| c |>\nThis will produce [5, 5, 5, 5, 5]\
    \ as opposed to [5, 5, 5, 5, 5]\n<|/ c |>\n<| c |>\nI tested it with ruby 1.8.7\
    \ and 1.9.1. And it works fine.\n<|/ c |>\n<| c |>\nI know, I said the same thing\
    \ in the comment to your answer.  I used ruby 1.9.2.  I guess you're using 1.8.7\
    \ :)\n<|/ c |>\n<| c |>\nYou're right, it works fine with 1.8.7, too. But it's\
    \ not clear which version of Ruby you are using. My comment was just for future\
    \ readers.\n<|/ c |>\n<| c |>\nI am still using 1.8.7 now :P I have the habit\
    \ of using different versions to see how it works, I guess it wasn't clear enough\
    \ :)\n<|/ c |>\n<| a tags=sorting,ruby,arrays |>\n<code>", "  lst.sort_by!(&:to_s)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nVery nice answer.  I'd add that `#sort_by!` modifies\
    \ the array and therefore modifies the original collection (if that's what `sort`\
    \ returns), which is probably not what was intended.  So, `lst.sort_by! { |x|\
    \ x.to_s }` would work.  Or you could simply do `lst.sort.reverse`.  If you do\
    \ need a new `Array`, you can do `lst.sort { |a, b| b.to_s <=> a.to_s }.to_a`.\
    \  As for why `sort_by!` doesn't modify the collection, it's because `sort_by!`\
    \ takes a block as an argument and blocks capture the variables in the context\
    \ where they are defined.\n<|/ c |>\n<| c |>\nFor those who are wondering why\
    \ `sort_by!` doesn't modify the original collection, you need to remember that\
    \ `sort_by!` is an in-place method.  It modifies the original collection and returns\
    \ `nil`.  `sort!` on the other hand returns a new collection sorted by the original\
    \ collection.  The difference is that `sort!` modifies the original collection\
    \ and returns a new sorted collection.  See [this answer](http://stackoverflow.com/questions/16289642/difference-between-sort-and-sort-by/16289649#16289649)\
    \ for more details.  Also, `sort_by!` modifies the original collection if you\
    \ pass it a block.\n<|/ c |>\n<| a dscore=5 tags=ruby |>\nI like Ruby's sort method\
    \ better. :)\n<code>\nlst.sort\n</code>\nIf you want to sort by multiple criteria,\
    \ you can do something like the following:\n<code>\nlst.sort do |a,b|\n  case\
    \ a <=> b\n  when 0\n    0\n  when 1\n    a <=> b\n  else\n    1\n  end\nend\n\
    </code>\n<|/ a |>\n<| c |>\nRuby's sort is faster than the other answer. Check\
    \ my answer for benchmark comparisons\n<|/ c |>\n<| c |>\nYou don't need the `case`\
    \ statement there; `sort_by` supports comparators such as `{ |a| a.to_i <=> b.to_i\
    \ }`\n<|/ c |>\n<| c |>\nAgreed. My answer was written before Ruby 1.9 allowed\
    \ block comparators.\n<|/ c |>\n<| a dscore=5 tags=ruby |>\n<code>\narray.sort.reverse\n\
    </code>\nThe reverse method returns a new ", "  if lst.empty?\n    lst\n  elsif\
    \ lst.size == 1\n    lst\n  else\n    min = lst.min\n    max = lst.max\n    sorted_list\
    \ = lst.sort.reverse\n    strange_sort_list(sorted_list)\n    sorted_list << min\n\
    \    strange_sort_list(sorted_list)\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3,ruby-on-rails-3.2\
    \ |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3,ruby-on-rails-3.2 |>\nThe answers\
    \ by Jos\xE9 Valim and Szymon Mosca\u0144ski are great. I would like to add that\
    \ you could also do something like the following.\n<code>\nnumbers = [1, 2, 3,\
    \ 4, 5, 6]", "  lst.each_with_index { |element, index|\n    temp_index = index\n\
    \    temp_element = element\n    loop do\n      break unless element.nil?\n  \
    \    element = lst[temp_index]\n      temp_index -= 1\n    end\n    lst[temp_index]\
    \ = temp_element\n    lst[temp_index + 1] = element\n  }\n  return lst\nend",
  "  result = []\n  length = lst.size\n  minimum = lst.min\n  maximum = lst.max\n\
    \  while length > 0\n    minimum = minimum if minimum < lst[length-1] then lst[length-1]\
    \ else minimum\n    maximum = maximum if maximum > lst[length-1] then lst[length-1]\
    \ else maximum\n    length = length - 1\n    result.push( minimum )\n    result.push(\
    \ maximum )\n    minimum = minimum unless minimum == maximum\n  end\n  result\n\
    end\n</code>\n<|/ a tags=sorting,algorithm,ruby |>\n<| a dscore=1 |>\nThis is\
    \ a modified version of the algorithm from WolframAlpha for ruby:\n<code>", " \
    \ return lst.sort do |a,b|\n    a>b? 1:a<b? -1\n  end\nend\n</code>\nRuby code\
    \ from my blog: Ruby code from my blog\n<|/ a dscore=3 |>\n<| a tags=algorithm,sorting,ruby\
    \ |>\nThis is O(n log n) algorithm. Time complexity is O(n log n).\n<code>", " \
    \   copy = lst.dup\n    sort = []\n    sort.push copy[0]\n    sort.push copy[1..-1].max",
  "  sorted = []\n  sorted.concat(lst[0..<(lst.length)])\n  sorted.concat(lst[(lst.length..)-1])\n\
    \  sorted.concat(lst[1..<(lst.length)])\n  return sorted\nend", "  sorted = []\n\
    \  sorted = lst.sort.reverse.first {|i| !sorted.include?(i)} + sorted\n  return\
    \ sorted\nend", "  lst = lst.sort\n  n = 0\n  while n < lst.count\n    n += 1\n\
    \  end\n  result = \"\"\n  while n > 0\n    result << lst[n - 1]\n    n -= 1\n\
    \  end\n  result\nend", "  new_list = []\n  sorted = []\n  i = 0\n  while i <\
    \ lst.size\n    sorted = sorted.push(lst[i])\n    i += 1\n  end\n  while i < lst.size\n\
    \    sorted = sorted.push(lst[i])\n    i += 1\n  end\n  sorted = sorted.reverse\n\
    \  i = 0\n  while i < lst.size\n    new_list.push(sorted[i])\n    i += 1\n  end\n\
    \  return new_list\nend", "  return lst.sort{|a, b| a.to_i > b.to_i ? 1 : a.to_i\
    \ < b.to_i ? -1 : 0}.to_a\nend\n</code>\n<|/ a |>\n<| c |>\n`sort` uses the default\
    \ `Comparable` implementation.\n<|/ c |>\n<| a tags=sorting,ruby |>\nIf you know\
    \ the range of possible integers, you can do this:\n<code>", "  # Create a temp\
    \ array to store the original integers\n  temp = lst.dup", "  i = 0\n  while i\
    \ < lst.length\n    if i > lst.length - 1 || lst[i] > lst[i+1]\n      lst.swap(i,\
    \ i + 1)\n      i += 1\n    else \n      i += 1\n  end\n  lst\nend", "  lst.sort\
    \ do |a, b|\n    a <=> b\n  end\nend", "  return lst.sort.map { |num| num.zero?\
    \ ? num : num.abs; num }\nend", "  lst.sort!\n  lst.inject([]) { |sum, el| sum\
    \ << el }\nend", "  sorted = []\n  length = lst.size\n  i = 0\n  while i < length\n\
    \    min = lst[i]\n    max = lst[i + 1]\n    sorted = sorted + [min]\n    if min\
    \ < max\n      sorted = sorted + [max]\n      i += 1\n    else\n      sorted =\
    \ sorted + [max]\n      sorted = sorted + [min]\n      i -= 1\n    end\n  end\n\
    \  sorted\nend", "  if lst.empty?\n    lst\n  else\n    lst.sort { |a, b| a <=>\
    \ b }\n    strange_sort_list(lst.reverse)\n  end\nend\n</code>\n<|/ a |>\n<| a\
    \ tags=arrays,ruby |>\nHere is an approach that returns the input unchanged if\
    \ it is not sorted or returns the original input if it is not sorted:\n<code>",
  "  lst.sort!\n  lst.reverse!\n  lst\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    I haven't checked your answer but I'm thinking it would have to be `lst.sort_by(&:itself)`\
    \ for the code to work correctly.\n<|/ c |>\n<| c |>\nI think `sort_by` does what\
    \ you want here.\n<|/ c |>\n<| c |>\n`lst.sort_by(&:itself)` will work in the\
    \ most simple cases but not for sorting objects. `strange_sort_list([4, 3, 2,\
    \ \"cat\"]) #=> [4, 3, 2, \"cat\"]` but if you use `strange_sort_list([4, 3, 2,\
    \ \"cat\"].sort_by(&:itself)) #=> [4, 3, 2, ['cat']]`\n<|/ c |>\n<| c |>\nThis\
    \ is what I needed `lst.sort_by! { |x| x.to_s }`\n<|/ c |>\n<| a dscore=2 tags=ruby\
    \ |>\nI like sort_by because it doesn't mutate the array in place, but in general,\
    \ I prefer merge! to sort_by!, because it doesn't mutate the array in place, but\
    \ returns the new array. This makes it easier for me to deal with my arrays without\
    \ worrying about mutating them in place. Here is a general implementation of merge!:\n\
    <code>", "    sorted = []\n    reverse_sorted = []\n    reversed_sorted = []\n\
    \    \n    # Start with the lowest integer, put it at the beginning of \n    #\
    \ the sorted, reversed sorted and reversed sorted lists.\n    sorted.unshift(lst[0])\n\
    \    reversed_sorted.unshift(lst[0])\n    reverse_sorted.unshift(lst[0])\n   \
    \ \n    # Sort rest of list, put it at the end of the sorted list\n    # and reversed\
    \ sorted list.\n    sorted.push(lst[1])\n    reversed_sorted.push(lst[1])\n  \
    \  reverse_sorted.push(lst[1])\n    \n    # Sort rest of list, put it at the end\
    \ of the sorted list\n    # and reversed sorted list.\n    sorted.push(lst[2])\n\
    \    reversed_sorted.push(lst[2])\n    reverse_sorted.push(lst[2])\n    \n   \
    \ # Sort rest of list, put it at the end of the sorted list\n    # and reversed\
    \ sorted list.\n    sorted.push(lst[3])\n    reversed_sorted.push(lst[3])\n  \
    \  reverse_sorted.push(lst[3])\n    \n    # Sort rest of list, put it at the end\
    \ of the sorted list\n    # and reversed sorted list.\n    sorted.push(lst[4])\n\
    \    reversed_sorted.push(lst[4])\n    reverse_sorted.push(lst[4])\n    \n   \
    \ # Sort rest of list, put it at the end of the sorted list\n    # and reversed\
    \ sorted list.\n    sorted.push(lst[5])\n    reversed_sorted.push(lst[5])\n  \
    \  reverse_sorted.push(lst[5])\n    \n    # Sort rest of list, put it at the end\
    \ of the sorted list\n    # and reversed sorted list.\n    sorted.push(lst[6])\n\
    \    reversed_sorted.push(lst[6])\n    reverse_sorted.push(lst[6])\n    \n   \
    \ # Sort rest of list, put it at the end of the sorted list\n    # and reversed\
    \ sorted list.\n    sorted.push(lst[7])\n    reversed_sorted.push(lst[7])\n  \
    \  reverse_sorted.push(lst[7])\n    \n    # Sort rest of list, put it at the end\
    \ of the sorted list\n    # and reversed sorted list.\n    sorted.push(lst[8])\n\
    \    reversed_sorted.push(lst[8])\n    reverse_sorted.push(lst[8])\n    \n   \
    \ # Sort rest of list, put it at the end of the sorted list\n    # and reversed\
    \ sorted list.\n    sorted.push(lst[9])\n    reversed_sorted.push(lst[9])\n  \
    \  reverse_sorted.push(lst[9])\n    \n    # Sort rest of list, put it at the end\
    \ of the sorted list\n    # and reversed sorted list.\n    sorted.push(", "  \
    \  # Your code here\n    minimum = minimum(lst)\n    maximum = maximum(lst)\n\
    \    lst = sorted(lst)\n    return lst\nend", "  # Base case\n  if lst.nil?\n\
    \    nil\n  # One item\n  elsif lst.size == 1\n    lst\n  # Multiple items\n \
    \ else\n    max = max_of_list(lst)\n    remaining = lst.size - 1\n    min = min_of_list(lst)\n\
    \    numbers = generate_numbers_from_min_and_max(max, min, remaining)\n    numbers\
    \ = numbers.flatten(1)\n  end\nend", "  lst.sort\n  lst.reverse\n  lst\nend\n\
    </cell>\n<code language=julia-1.6>\nstrange_sort_list(my_list)\n</cell>\n<code\
    \ language=julia-1.6>", '  lst.sort', "  lst.sort!\n  strange_sorted = lst.reverse.sort!.reverse\n\
    \  return strange_sorted\nend\n</code>\n<|/ a |>\n<| c |>\nThe question is about\
    \ `strange_sort_list` method not `sort_list`\n<|/ c |>\n<| c |>\nYou are right,\
    \ I misread the method name. My apologies\n<|/ c |>\n<| a tags=ruby,sorting,ruby-on-rails-4\
    \ |>\n<code>", "  lst.sort\n  sorted = []\n  while lst.length > 0\n    sorted\
    \ = sorted + lst[0..lst.length-1]\n    lst = lst[lst.length..-1]\n  end\n  sorted\n\
    end", "  return lst.sort.reverse\nend\n</code>\n<|/ a dscore=2 tags=ruby,algorithm,sorting,arrays\
    \ |>\n<| c |>\nI like that you added the explanation about why sorting in reverse\
    \ order is important.\n<|/ c |>\n<| c |>\nI liked this answer too, but I prefer\
    \ to return the original array in case you don't want to modify the original array\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "    return lst.sort.reverse.to_a\nend",
  "    sort = lst.sort.reverse.map{|x| x.to_i}\n    sort.map{|x| lst.delete(x)}.reverse.map{|x|\
    \ lst.insert(lst.index, x)}\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,sorting\
    \ |>\nOne liner:\n<code>\narr = [4, 5, 3, 2, 1]\narr.map {|i| i==arr.min? arr.max:\
    \ i }", "  return lst.sort.with_index { |value, i| i }\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nHi Matz I like your answer, could you explain the 'sort' method\
    \ and why we use it? Thanks.\n<|/ c |>\n<| a |>\nIf you wish to sort a list without\
    \ using sort, try something like this:\n<code>", "  lst.each_with_index do |item,\
    \ i|\n    i = i % 2\n    (i || 1) > 0 && lst.swap(item, lst.at(i))\n  end\n  return\
    \ lst\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you! This was helpful.\n\
    <|/ c |>\n<| a tags=ruby |>\nI wrote a solution that uses inject to sort the given\
    \ array in-place and then returns the sorted array.\n<code>", "  sorted = []\n\
    \  while lst.any?\n    sorted = sorted + lst.sort.reverse\n    lst = lst.sort.reverse\n\
    \  end\n  sorted\nend", '  lst.sort!', "  if lst.empty?\n    return []\n  min\
    \ = lst.min\n  max = lst.max\n  list1 = strange_sort_list(lst.drop(min))\n  list2\
    \ = strange_sort_list(lst.take(max..lst.length))\n  list3 = list1 + list2\n  return\
    \ list3.concat([min])\nend", "  return lst.sort do |x,y| \n    case\n    when\
    \ x < y then -1\n    when x > y then 1\n    else 0\n    end\n  end\nend\n</code>\n\
    A few notes:\nIt's considered bad practice to use class names like Array because\
    \ it's confusing.\nIn Ruby, comparing any two objects is done using <, >, == or\
    \ eql? methods.  See this page for more info.\n<|/ a tags=ruby,sorting,arrays,algorithm\
    \ |>\n<| c |>\nWhoops, I read your original post too quickly and didn't notice\
    \ that you had the array in reverse order.  I'll edit to fix it.  But thanks for\
    \ the heads up!\n<|/ c |>\n<| c |>\nThanks for your answer. Just wanted to add\
    \ that you should not use `case` statement to implement custom sort method on\
    \ Array or Hash. It would be much more simple and readable if you just use `return\
    \ [...].sort` instead of using case statement. Also, `[...].sort` doesn't work\
    \ in ruby 1.9+, so you would have to use `[...].sort_by(...)` instead.\n<|/ c\
    \ |>\n<| a |>\n<code>", "\tsorted_list = []\n\tlst.each do |i|\n\t\tif (sorted_list\
    \ << i).first < i\n\t\telse\n\t\t\tsorted_list << i\n\t\tend\n\tend\n\treturn\
    \ sorted_list.sort.join\nend\nputs strange_sort_list([1, 2, 3, 4])", "  lst.sort!\n\
    \  for i in 0...lst.count-1\n    lst[i], lst[i+1] = lst[i+1], lst[i]\n  end\n\
    \  lst\nend", "    return lst.sort.reverse.sort\nend", "  sorted_list = lst.sort\n\
    \  return sorted_list.join(\", \")\nend\n</cell>\n<code language=julia-0.4>\n\
    strange_sort_list([5, -5, 10, -20, 50])\n</cell>\n<code language=julia-0.4>\n\
    function my_sort(lst)\n  sorted_list = lst.sort\n  return sorted_list.join(\"\
    , \")\nend", "  return (lst.sort < lst.reverse).reverse\nend", "  result = lst\n\
    \  result.sort do |a, b|\n    if a < b\n      a += 1\n      b -= 1\n    elsif\
    \ a > b\n      a -= 1\n      b += 1\n    end\n    \n    [a, b]\n  end\n  result\n\
    end", "  if lst.empty?\n    lst\n  else\n    sorted_list = lst.sort\n    sorted_list.unshift(sorted_list.last)\n\
    \    sorted_list.unshift(sorted_list.pop)\n    strange_sort_list(sorted_list)\n\
    \  end\nend", "    sorted = []\n    minimum = lst[0]\n    maximum = lst[0]\n \
    \   \n    sorted = lst\n    \n    for i in lst\n        if i < minimum\n     \
    \       minimum = i\n        else if i > maximum\n            maximum = i\n  \
    \      else if i > minimum and i < maximum\n            sorted = sorted + [minimum,\
    \ maximum, i]\n            minimum = minimum\n            maximum = maximum\n\
    \        end\n    end\n    \n    sorted = sorted + [minimum, maximum]\n    \n\
    \    sorted = sorted.sort\n    \n    return sorted\nend", "  return lst.sort{|a,\
    \ b| b <=> a}\nend\n</code>\nNow you simply need to sort your numbers using this\
    \ method.\n<code>\nstrange_sort_list(all_nums).each do |num|\n  # Write your logic\
    \ here\nend\n</code>\n<|/ a tags=ruby,sorting,arrays,ruby-on-rails |>\n<| a |>\n\
    You could do something like the following\n<code>", "  lst = lst.sort_by {|e|\
    \ (e <=> lst[lst.length-1]) }\n  lst.clear\n  lst\nend", "  lst.sort!\n  return\
    \ lst\nend", "  if lst.empty?\n    lst\n  else\n    first_num = lst.min\n    second_num\
    \ = lst.max\n    sorted_list = lst.sort.reverse\n    (first_num, second_num).sort.each\
    \ do |i|\n      while sorted_list.index(i) > sorted_list.index(first_num)\n  \
    \      sorted_list.insert(sorted_list.index(i), first_num)\n      end\n    end\n\
    \    sorted_list.uniq.sort\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nVery nice,\
    \ but doesn't work on the empty list. It returns `nil`. But I suppose that would\
    \ not be the desired behavior.\n<|/ c |>\n<| a dscore=2 |>\nThis is a really nice\
    \ solution using each_cons and reverse_each.\n<code>", "  if lst.size <= 1\n \
    \   lst\n  else\n    new_lst = lst.dup\n    new_lst.sort! { |x, y| strange_sort_list(x).first\
    \ <=> strange_sort_list(y).first }\n    new_lst\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nIt sorts by the first element of the sub-arrays, which is what\
    \ you want.\n<|/ c |>\n<| c |>\nYes you are right but i don't understand why you\
    \ call strange_sort_list(x).first <=> strange_sort_list(y).first in your sort\
    \ method ?\n<|/ c |>\n<| c |>\nWhen sorting an array of arrays by the first element\
    \ of the sub-arrays, it sorts by the minimum value of the first array in the sub-arrays.\
    \ For example, `strange_sort_list([[1, 3], [2, 3], [3, 1]])` returns `[[1, 3],\
    \ [2, 3], [3, 1]]`.\n<|/ c |>\n<| c |>\n, I don't think that's right. According\
    \ to your example `strange_sort_list([[1, 3], [2, 3], [3, 1]])`, the min of the\
    \ first array in the sub-array is 1 and so you get `[[1, 3], [2, 3], [3, 1]]`.\
    \ Try it with `strange_sort_list([[1, 3], [2, 3], [3, 1]])`.\n<|/ c |>\n<| c |>\n\
    Sorry about that, I misread the example. Now it should work properly.\n<|/ c |>\n\
    <| a dscore=4 |>\nTo sort by a particular key in a nested array you can use a\
    \ block passed to the sort method.\n<code>\nrequire 'set'", "  sorted = []\n \
    \ min = lst[0]\n  max = lst[0]\n  for i in 0...lst.size-1\n    if min > max\n\
    \      min   = sorted[-1]\n      max   = lst[i]\n    else if max < lst[i]\n  \
    \    max   = sorted[-1]\n      sorted[-1] = max\n      max   = lst[i]\n    else\n\
    \      sorted << max\n      max   = lst[i]\n    end\n  end\n  sorted << min\n\
    \  sorted\nend", "  sorted = []\n  lst.each_with_index do |value, index|\n   \
    \ sorted.push(value)\n    unless index == lst.length-1\n      sorted.unshift(sorted[index+1])\n\
    \    end\n  end\n  sorted\nend", "  return lst.sort.reverse\nend\n</code>\n<|/\
    \ a |>\n<| a tags=ruby |>\nOne way:\n<code>", "  return lst.sort{ |a, b| (a <=>\
    \ b) }\nend", "  return lst.sort{|x, y| x <=> y} if lst.size\n  strange_sort_list(lst[1..-1])\n\
    end", "  lst.sort!\n  lst.each_index { |i| lst.swap(i, i) }\n  lst.uniq!\n  lst\n\
    end", "  if lst.empty?\n    lst\n  else\n    sorted = lst.sort.reverse\n    lst\
    \ = lst.map { |x| sorted << x }\n    lst\n  end\nend", '  sorted = []', "  return\
    \ lst.sort.reverse.map { |x| [x] }.flatten\nend", "  sorted = []\n  while lst.any?\n\
    \    sorted = sorted.concat(lst[0..-1]).reverse\n    lst = lst[(sorted.length).to_i\
    \ - 1]\n  end\n  sorted\nend", "  return lst.sort.reverse\nend", "  # Write your\
    \ solution here\n  return nil\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ dscore=0 |>\nHere is an another solution:\n<code>", "  lst.sort!\n  return lst.join('\
    \ ')\nend", "  if lst.empty?\n    lst\n  else\n    sorted_list = []\n    sorted_list\
    \ << lst.min\n    sorted_list << lst.max\n    sorted_list << lst.min\n    sorted_list\
    \ << lst.max\n    sorted_list << lst.min\n    sorted_list << lst.max\n    sorted_list\
    \ << lst.min\n    sorted_list << lst.max\n    sorted_list << lst.min\n    sorted_list\
    \ << lst.max\n    sorted_list << lst.min\n    sorted_list << lst.max\n    sorted_list\
    \ << lst.min\n    sorted_list << lst.max\n    sorted_list << lst.min\n    sorted_list\
    \ << lst.max\n    sorted_list << lst.min\n    sorted_list << lst.max\n    sorted_list\
    \ << lst.min\n    sorted_list << lst.max\n    sorted_list << lst.min\n    sorted_list\
    \ << lst.max\n    sorted_list << lst.min\n    sorted_list << lst.max\n    sorted_list\
    \ << lst.min\n    sorted_list << lst.max\n    sorted_list << lst.min\n    sorted_list\
    \ << lst.max\n    sorted_list << lst.min\n    sorted_list << lst.max\n    sorted_list\
    \ << lst.min\n    sorted_list << lst.max\n    sorted_list << lst.min\n    sorted_list\
    \ << lst.max\n    sorted_list << lst.min\n    sorted_list << lst.max\n    sorted_list\
    \ << lst.min\n    sorted_list << lst.max\n    sorted_list << lst.min\n    sorted_list\
    \ << lst.max\n    sorted_list << lst.min\n    sorted_list << lst.max\n    sorted_list\
    \ << lst.min\n    sorted_list << lst.max\n    sorted_list << lst.min\n    sorted_list\
    \ << lst.max\n    sorted_list << lst.min\n    sorted_list << lst.max\n    sorted_list\
    \ << lst.min\n    sorted_list << lst.max\n    sorted_list << lst.min\n    sorted_list\
    \ << lst.max\n    sorted_list << lst.min\n    sorted_list << lst.max\n    sorted_list\
    \ << lst.min\n    sorted_list << lst.max\n    sorted_list << lst.min\n    sorted_list\
    \ << lst.max\n    sorted_list << lst.min\n    sorted_list << lst.max\n    sorted_list\
    \ << lst.min\n    sorted_list << lst.max\n", "  lst.sort!\n  return lst\nend",
  "  lst.sort.reverse\n  lst.join\nend", '  sorted = []', "  # Write code here\n \
    \ lst.sort!\n  i = 0\n  while i < lst.size\n    temp = lst[i]\n    i += 1\n  \
    \  while i < lst.size\n      lst[i] = lst[i-j]\n      j = i\n      i += 1\n  \
    \  lst[i] = temp\n  end\nend", "  minimum = lst.min\n  maximum = lst.max\n  result\
    \ = []\n  while minimum < maximum\n    result << minimum\n    minimum -= 1 if\
    \ minimum > 0\n    maximum += 1 if maximum < lst.size\n    minimum = lst.min\n\
    \    maximum += 1 if maximum < lst.size\n  end\n  result << minimum\n  result\
    \ << maximum\n  result\nend", "  lst.sort!\n  lst.unshift(lst.pop)\n  strange_sort_list(lst)\n\
    end", "  lst.sort!\n  lst.map { |e| e }\nend\n</code>\n<|/ a |>\n<| a tags=ruby\
    \ |>\nI used the following to sort an array of strings\n<code>\nrequire 'pry'",
  "  return lst.sort_by { |i| [i % 5, i] }.reverse\nend", "  # write your code\n \
    \ return lst\nend", "  lst = [lst.min] + lst.sort.reverse.concat([lst.max])\n\
    end", "  lst.each_with_index do |x, i|\n    lst[i] = lst[i].swap unless i == 0\n\
    \  end\n  return lst\nend", "  sorted = []\n  i = 0\n  while i < lst.length\n\
    \    if i == lst.length-1 then sorted = lst.reverse\n    else sorted = [lst[i],\
    \ lst[i+1]].sort sorted = sorted + [lst[i], lst[i+1]]\n    i = i + 1\n  end\n\
    \  return sorted\nend", "  return lst.sort.reverse\nend", "  return lst.sort do\
    \ |a, b|\n    (a<b) ? -1\n         : (b<a ) ? 1\n         : 0\n  end\nend", " \
    \ return lst.sort do |a, b|\n    if a < b\n      -1\n    elsif a == b\n      0\n\
    \    else\n      1\n    end\n  end\nend", "  n1 = lst.min\n  n2 = lst.max\n  return\
    \ n1 + n2\nend", "  lst.sort {|a, b| b <=> a}\nend", "  sorted = []\n  sorted_indexes\
    \ = []\n  sorted_indexes = strange_sort_list(sorted)\n  while sorted != lst\n\
    \    sorted_indexes = strange_sort_list(sorted_indexes)\n    if sorted_indexes.last\
    \ >= sorted.last\n      sorted = sorted << sorted_indexes.last << sorted.last\n\
    \      sorted_indexes.last = 0\n    else\n      sorted = sorted << sorted_indexes.last\
    \ << sorted.first\n      sorted_indexes.last = 0\n    end\n  end\n  sorted\nend",
  '  lst.sort', "  return lst.sort.reverse.sort\nend", "  return lst.reverse.sort.reverse\n\
    end", "  lst.sort.reverse\n  lst.reverse!\n  lst.sort \nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nI did it using a single line, no looping and no extra variable\
    \ or list. \n<code>", "  lst.sort do |x,y|\n    case x\n    when y\n      0\n\
    \    when y-1\n      1\n    when y+1\n      2\n    else\n      -1\n    end\n \
    \ end\nend", "  ret = []\n  i = 1\n  while i < lst.length\n    tmp = lst[i]\n\
    \    j = i\n    while j < lst.length\n      nextTmp = lst[j]\n      if tmp > nextTmp\n\
    \        tmp = nextTmp\n      end\n      j += 1\n    end\n    ret.push(tmp)\n\
    \    i += 1\n  end\n  return ret\nend", "    return lst.sort{|a, b| (a<b) ? -1\
    \ : (a>b) ? 1 : 0}\nend", "  if lst.size == 0\n    return []\n  l = lst[0]\n \
    \ rest = lst[1..-1]\n  ret = l\n  for i in rest\n    ret = [i, ret]\n  end\n \
    \ ret\nend", '  lst.sort!', "    # Write your code here\n    minimum = lst.min\n\
    \    maximum = lst.max\n    return minimum + maximum + minimum\nend", "  lst.sort\n\
    \  i = 1\n  while i < lst.size do\n    temp = lst[i]\n    j = i\n    while j >\
    \ 0 and lst[j-1] > temp\n      lst[j] = lst[j-1]\n      j -= 1\n    lst[j] = temp\n\
    \    i += 1\n  end\n  lst\nend", "  # Your code goes here\n  sorted = []\n  sorted\
    \ = lst.sort do |a, b|\n    if a < b\n      a\n    else\n      b\n    end\n  end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nYour `sort` is wrong because your `if` statement\
    \ is wrong. `a < b` is **not** what you think it is. What you want is `if a >\
    \ b`, which means \"a is greater than b\" and `if a < b`, which means \"a is less\
    \ than b\".\n<|/ c |>\n<| a tags=ruby |>\nTo understand why your sort isn't working,\
    \ think about how Ruby interprets your code. Let's look at an example where we\
    \ swap the values of x and y in the block passed to sort:\n<code>\nsorted = []\n\
    sorted = [1,2,3].sort do |a, b|\n  if a < b\n    x # this is how Ruby interprets\
    \ it\n  else\n    y # this is how Ruby interprets it\n  end\nend\n</code>\nThe\
    \ first time through, Ruby does this:\n<code>\nsorted = []\n[1,2,3].sort do |a,\
    \ b|\n  if 1 < 2\n    x # this is how Ruby interprets it\n  else\n    y # this\
    \ is how Ruby interprets it\n  end\nend\n</code>\nIn the first iteration, a is\
    \ 1 and b is 2. 1 < 2 is true, so the code in the block is run. The first line\
    \ in the block (which says x is x is where it gets confused) says what to do when\
    \ a's value is less than b's value (what was x before?), so this line returns\
    \ x:\n<code>\nsorted = []\n[1,2,3].sort do |a, b|\n  if true # 1 < 2\n    x #\
    \ this is how Ruby interprets it\n  else\n    y # this is how Ruby interprets\
    \ it\n  end\nend\n</code>\nNow, a is 2 and b is 3. The second line in the block\
    \ (which says y is y is where it gets confused) says what to do when a's value\
    \ is less than b's value (what was y before?), so this line returns y:\n<code>\n\
    sorted = []\n[1,2,3].sort do |a, b|\n  if true # 1 < 2\n    y # this is how Ruby\
    \ interprets it\n  else\n    x # this is how Ruby interprets it\n  end\nend\n\
    </code>\nThis time, a is 2 and b is 3. The third line in the block (which says\
    \ x is x is where it gets confused) ", "  return lst.sort.reverse\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays,ruby-on-rails dscore=1 |>\n<| a tags=ruby,sorting,arrays,ruby-on-rails\
    \ |>\nI prefer the other answers, but this also works\n<code>", "  return lst.sort\
    \ do |a, b|\n    (a > b) - (a < b)\n  end\nend\n</code>\n<|/ a tags=arrays,ruby\
    \ |>\n<| c |>\nThe `sort_by` version is significantly faster than the `sort` one.\
    \ With 1,000,000 iterations, it took 1.66 seconds with the sort version and 0.04\
    \ seconds with the `sort_by` version. Also, it is more succinct and easier to\
    \ read: `arr.sort { |a, b| [b, a] <=> [a, b] }`\n<|/ c |>\n<| c |>\nI guess you\
    \ can improve performance even more by using `arr.reverse_each { |i| break if\
    \ i > arr[0] }` before the `sort_by` version and then `sort_by` will stop immediately\
    \ once it finds the first element larger than the first element.\n<|/ c |>\n<|\
    \ a tags=arrays,ruby |>\nThis works:\n<code>\narray = [4,2,3,1]", "  lst.sort!\n\
    \  i = 0\n  while i < lst.size\n    if i == lst.size - 1\n      i += 1\n     \
    \ break\n    i += 1\n  end\n  return lst\nend", "  # The method takes an array\
    \ of integers as an input\n  # The return value should be a sorted array of integers\n\
    \  \n  # Initialize two variables for storing the minimum and maximum values\n\
    \  min_value = lst[0]\n  max_value = lst[0]", "  sorted = []\n  mins = nil\n \
    \ maxs = nil", "  lst.sort\nend", "  lst.sort_by! {|x| x}\nend\n</code>\nTest:\n\
    <code>\n[1,2,3].sort_by! {|x| x}\n => [1, 2, 3] \n[2,1,3].sort_by! {|x| x}\n =>\
    \ [2, 1, 3]\n[].sort_by! {|x| x}\n => []\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    `sort_by!` returns `nil` on failure. `sort!`'s behavior is better here.\n<|/ c\
    \ |>\n<| c |>\nGood point!  I guess I should have said that `sort_by!` returns\
    \ `nil` on failure.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n[\"5\", \"1\", \"2\"\
    , \"3\", \"4\"].sort {|a,b| a.to_i <=> b.to_i}\n=> [\"1\", \"2\", \"3\", \"4\"\
    , \"5\"]\n</code>\n<|/ a tags=sorting,ruby |>\n<| c |>\nNote that this sorts lexically,\
    \ whereas `sort_by!` sorts numerically.\n<|/ c |>\n<| c |>\nThat's not correct.\
    \ `sort_by!` sorts numerically (as per its documentation)\n<|/ c |>\n<| c |>\n\
    : What I meant is `sort_by!` returns `nil` when an error occurs, whereas `sort!`\
    \ returns an array of sorted elements.\n<|/ c |>\n<| c |>\nNo, I meant that `sort_by!`\
    \ returns nil if the sort fails whereas `sort!` will throw an exception with the\
    \ exception message being `comparison of Fixnum with Fixnum is ambiguous`\n<|/\
    \ c |>\n<| a tags=sorting,ruby dscore=5 |>\nAnother way using sort_by:\n<code>\n\
    [\"5\", \"1\", \"2\", \"3\", \"4\"].sort_by(&:to_i)\n=> [\"1\", \"2\", \"3\",\
    \ \"4\", \"5\"]\n</code>\n<|/ a |>\n<| c |>\nThis is great - it avoids using an\
    \ intermediate variable. I like the `&:to_i` notation, too!\n<|/ c |>\n<| c |>\n\
    I like the &:to_i notation too, thanks for sharing.\n<|/ c |>\n<| c |>\nIf you\
    \ already have the array and don't want a temporary variable, consider `arr.sort_by\
    \ { |i| i.to_i }`.\n<|/ c |>\n<| a tags=", "  n = lst.length\n  min = (n - 1)\
    \ / 2\n  max = n - 1\n  new_list = []\n  while min <= max\n    tmp = lst[min]\n\
    \    lst[min], lst[max] = lst[max], lst[min]\n    new_list << tmp\n    min +=\
    \ 1\n    max -= 1\n  new_list << lst[min]\n  new_list.compact\nend", "  lst.sort!\n\
    \  lst.each_with_index do |e, i|\n    if i != lst.size-1\n      lst[i], lst[i+1]\
    \ = lst[i+1], lst[i]\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,sorting |>\n\
    <| a dscore=4 |>\nThis is an improvement to Sven Marnach's answer above which\
    \ allows the list to be sorted in both directions.\n<code>", "\tl = lst.sort.reverse\n\
    \treturn l", "  if lst.empty?\n    []\n  else\n    minimum = lst[0]\n    maximum\
    \ = lst[-1]\n    sorted_list = strange_sort_list(lst[1..-1])\n    sorted_list.unshift(minimum)\n\
    \    sorted_list.unshift(maximum)\n    sorted_list\n  end\nend", "  return lst.sort{|a,b|\
    \ a <=> b}.reverse\nend", "  result = []\n  lst.each do |i|\n    i =~ /^\\d+$/\
    \ ? result.push i : i <=> result[0]\n  end\n  result\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby,arrays |>\n<| c |>\nThat is brilliant, thank you!\n<|/ c |>\n<| c\
    \ |>\nWhy should I use `map { |e| e }`, rather than just `map`? The latter one\
    \ will also work just fine, right?\n<|/ c |>\n<| c |>\nYou are right, I was just\
    \ used to the block form.\n<|/ c |>\n<| c |>\n`e` is a variable, not an argument.\
    \ By using it, you lose the advantage of not creating a new variable.\n<|/ c |>\n\
    <| c |>\nI see, so it's just the variable that isn't being used, but is still\
    \ being referenced?\n<|/ c |>\n<| a |>\nAnother solution is to use Array#sort\
    \ and pass a block:\n<code>\narray = [\n    [[10, 11, 12, 13], [20], [30, 31,\
    \ 32, 33, 34, 35], [40], [50]],\n    [[111, 112, 113, 114], [20], [30, 31, 32,\
    \ 33, 34, 35], [40], [50]],\n    [[12, 13, 14], [20], [30, 31, 32, 33, 34, 35],\
    \ [40], [50]],\n    [[11], [20], [30, 31, 32, 33, 34, 35], [40], [50]],\n    [[111],\
    \ [21], [30, 31, 32, 33, 34, 35], [40], [50]],\n    [[11, 12], [20], [30, 31,\
    \ 32, 33, 34, 35], [40], [50]],\n    [[11, 12, 13], [20], [30, 31, 32, 33, 34,\
    \ 35], [40], [50]],\n    [[111, 112, 113, 114, 115], [20], [30, 31, 32, 33, 34,\
    \ 35], [40], [50]],\n    [[12, 13, 14, 15], [20], [30, 31, 32, 33, 34, 35], [40],\
    \ [50]],\n    [[12], [20], [30, 31, 32, 33, 34, 35], [40], [50]],\n    [[111],\
    \ [20], [30, 31, 32, 33, 34, 35], [40], [50]],\n    [[11, 12, 13, 14], [20], [30,\
    \ 31, 32, 33, 34, 35], [40], [50]],\n    [[12], [20], [30, 31, 32, 33, 34, 35],\
    \ [40], [50]]\n]", "  return lst.reverse.sort.reverse\nend\n</code>\n<|/ a |>\n\
    <| c |>\n`reverse` is an O(n) operation, so it's not a good idea. In your first\
    \ example, the code will do `lst.sort.reverse` N times (`N` being the size of\
    \ the list). If you're doing it `N` times, you probably want to do it as a single\
    \ `O(1)` operation.\n<|/ c |>\n<| c |>\nIn addition to this, `sort` will do `O(n\
    \ log n)` operations, so if you have a very long list, it will take much longer\
    \ to execute than `strange_sort_list`.\n<|/ c |>\n<| c |>\nYes it's true. However,\
    \ since he said that he is going to call it a lots times (i.e. 1000 times), I\
    \ think it's worth it to have O(n) complexity.\n<|/ c |>\n<| c |>\nHow would you\
    \ sort a million items?  It would take 100 million comparisons.  You need a sorting\
    \ algorithm that can do it in under 100ms.\n<|/ c |>\n<| c |>\nYou mean a bubble\
    \ sort or a quicksort? You can do that on modern CPUs (like i7 with 8 cores),\
    \ but it would be super inefficient.\n<|/ c |>\n<| a dscore=3 |>\nAnother way\
    \ of doing this is using recursion:\n<code>", "  lst.sort!\n  ret = []\n  current_val\
    \ = lst[0]\n  for i in 0...lst.size\n    if i > 0 and lst[i-1] > current_val\n\
    \      ret << current_val\n      current_val = lst[i]\n    else\n      ret <<\
    \ lst[i]\n    end\n  end\n  ret << current_val\n  return ret\nend", "  return\
    \ lst.sort.reverse.each {|n| puts n}\nend\n</code>\n<code>\nrequire './strange_sort.rb'\n\
    puts strange_sort_list(Array.new(5..100))\n</code>\n<code>\n5\n15\n25\n35\n45\n\
    55\n65\n75\n85\n95\n</code>\n<|/ a tags=ruby,sorting,algorithm |>\n<| a tags=ruby,sorting,algorithm\
    \ |>\nIn Ruby, you can use Enumerable#sort_by with the block to determine how\
    \ an item should be ordered:\n<code>\n(1..10).sort_by { |n| -n }\n=> [1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10]\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your\
    \ reply. I can not use sort_by. I am supposed to sort the list in-place, without\
    \ creating a new one using sort.\n<|/ c |>\n<| c |>\nYour question is tagged with\
    \ `ruby`, but your comment above says something different.  Can you be more specific?\n\
    <|/ c |>\n<| c |>\nMy apologies. I tagged ruby because it was a ruby question.\
    \ I have edited my question\n<|/ c |>\n<| a tags=ruby,sorting,algorithm |>\nAs\
    \ you only need descending order in each iteration you can use the fact that all\
    \ elements in your list are positive.\n<code>\narray.each_with_object([]) do |element,\
    \ arr|\n  arr.unshift(element)\nend", "  lst.sort!\n  lst.map!(&:to_s)\n  lst.join\n\
    end\n</code>\nThis can be shortened to:\n<code>", "  return lst.sort{|a, b| a\
    \ <=> b}\nend", "  lst = lst.sort\n  lst.each_with_index { |e, i| lst[i] = e if\
    \ e.odd? }\n  lst.sort\n  lst\nend\n</code>\n<|/ a dscore=1 tags=ruby,sorting,arrays,list\
    \ |>\n<| a tags=ruby,sorting,arrays,list |>\nThe question is a bit ambiguous,\
    \ but I will assume you mean a random sort order (as opposed to a sorted order\
    \ of the original list). The following should sort your list randomly:\n<code>",
  "  lst = lst.sort\n  lst.clear\n  lst.push nil\n  lst.push nil\n  lst.push nil\n\
    \  lst.push nil", "    sorted_list = []\n    smallest_value = lst[0]\n    largest\
    \ = smallest_value", "  result = \"\"\n  minimum = lst[0]\n  maximum = lst[0]",
  "    sorted = []\n    max = lst.max\n    min = lst.min\n    length = lst.size\n\
    \    sorted = lst\n    sorted.each do |i|\n        if i == max\n            sorted\
    \ = sorted.rotate!\n            sorted = sorted.rotate!\n            sorted =\
    \ sorted.rotate!\n            sorted = sorted.rotate!\n            sorted = sorted.rotate!\n\
    \            sorted = sorted.rotate!\n            sorted = sorted.rotate!\n  \
    \          sorted = sorted.rotate!\n            sorted = sorted.rotate!\n    \
    \        sorted = sorted.rotate!\n            sorted = sorted.rotate!\n      \
    \      sorted = sorted.rotate!\n            sorted = sorted.rotate!\n        \
    \    sorted = sorted.rotate!\n            sorted = sorted.rotate!\n          \
    \  sorted = sorted.rotate!\n            sorted = sorted.rotate!\n            sorted\
    \ = sorted.rotate!\n            sorted = sorted.rotate!\n            sorted =\
    \ sorted.rotate!\n            sorted = sorted.rotate!\n            sorted = sorted.rotate!\n\
    \            sorted = sorted.rotate!\n            sorted = sorted.rotate!\n  \
    \          sorted = sorted.rotate!\n            sorted = sorted.rotate!\n    \
    \        sorted = sorted.rotate!\n            sorted = sorted.rotate!\n      \
    \      sorted = sorted.rotate!\n            sorted = sorted.rotate!\n        \
    \    sorted = sorted.rotate!\n            sorted = sorted.rotate!\n          \
    \  sorted = sorted.rotate!\n            sorted = sorted.rotate!\n            sorted\
    \ = sorted.rotate!\n            sorted = sorted.rotate!\n            sorted =\
    \ sorted.rotate!\n            sorted = sorted.rotate!\n            sorted = sorted.rotate!\n\
    \            sorted = sorted.rotate!\n            sorted = sorted.rotate!\n  \
    \          sorted = sorted.rotate!\n            sorted = sorted.rotate!\n    \
    \        sorted = sorted.rotate!\n            sorted = sorted.rotate!\n      \
    \      sorted = sorted.rotate!\n            sorted = sorted.rotate!\n        \
    \    sorted = sorted.rotate!\n            sorted = sorted.rotate!\n          \
    \  sorted = sorted.rotate!\n            sorted = sorted.rotate!\n            sorted\
    \ = sorted.rotate!\n            sorted = sorted.rotate!\n            sorted =\
    \ sorted.rotate!\n            sorted = sorted.rotate!\n            sorted = sorted.rotate!\n\
    \            sorted = sorted.rotate!\n            sorted = sorted.rotate!\n  \
    \          sorted = sorted.rotate!\n", "  min = lst.min\n  max = lst.max\n  sorted\
    \ = []\n  sorted.push(min)\n  sorted.push(max)", "  result = []\n  sorted_lst\
    \ = lst.sort\n  while sorted_lst.size > 1\n    lowest_value = sorted_lst.first\n\
    \    sorted_lst.shift lowest_value\n    sorted_lst.push(lowest_value)\n  end\n\
    \  sorted_lst.each do |value|\n    result << value\n  end\n  result\nend\n</code>\n\
    <|/ a tags=sorting,ruby,arrays |>\n<| a tags=sorting,ruby,arrays |>\nI suggest\
    \ this:\n<code>\narray.each_cons(2).each_with_object([]) { |a,b| b<<a }.sort\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\nrequire 'set'", "  if lst.empty?\n\
    \    lst\n  else\n    i = lst.min\n    result = []\n    while i < lst.max\n  \
    \    result.append(i)\n      i += 1\n    end\n    result\n  end\nend", "  lst\
    \ = lst.sort { |a, b| a.to_s <=> b.to_s }\n  return lst if lst.size <= 1\n  strange_sort_list(lst.first..lst.reverse\
    \ + lst.last)\nend\n</code>\nAnd here is an example of the function working\n\
    <code>\nrequire 'test/unit'", "  lst.sort do |a, b|\n    if a > b\n      a\n \
    \   elsif b > a\n      b\n    else\n      a\n    end\n  end\n  lst\nend", "  if\
    \ lst.length <= 1\n    return lst\n  first = lst.shift\n  second = strange_sort_list(lst)\n\
    \  third = strange_sort_list(lst)\n  fourth = strange_sort_list(lst)\n  lst =\
    \ [first, second, third, fourth]\n  lst.shift\n  lst\nend", '  lst.sort', "  \
    \  return lst.sort\nend", "  return lst.sort_by do |v|\n    (v - lst[0]) <=> (v\
    \ - lst[-1]) <=> (v - lst[-2]) <=> (v - lst[-3])\n  end\nend", "  lst.sort! {\
    \ |x,y| lst.index(x) == lst.index(y) }\nend", '  lst.sort!', "  sorted_list =\
    \ []\n  sorted_list_index = 0\n  sorted_list.append lst[0]\n  sorted_list.sort\
    \ do |a, b|\n    if a > b\n      sorted_list << a\n      sorted_list_index +=\
    \ 1\n    else\n      sorted_list << b\n      sorted_list_index += 1\n    end\n\
    \    sorted_list.shift sorted_list_index\n  end\n  sorted_list\nend", "    max\
    \ = lst[0]\n    min = lst[0]\n    \n    list.each do |num|\n        if num > max\n\
    \            max = num\n        elsif num < min\n            min = num\n     \
    \   else\n            max = num\n            min = num\n        end\n    end\n\
    \    \n    list.each_index do |i|\n        lst[i] = min\n        lst[i+1] = max\n\
    \    end\n    \n    lst\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis isn't\
    \ an answer, and doesn't work for the example inputs `[4, 6, 1]`.\n<|/ c |>\n\
    <| a dscore=0 |>\nHere's a solution using Enumerable#partition, Enumerable#map,\
    \ and Enumerable#sort:\n<code>", "  lst2 = []\n  lst.each do |item|\n    if lst2.include?(item)\
    \ == false\n      lst2 << item\n    end\n  end\n  return lst2\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
