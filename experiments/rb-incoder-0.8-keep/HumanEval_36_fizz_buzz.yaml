name: HumanEval_36_fizz_buzz
language: rb
prompt: "# Return the number of times the digit 7 appears in integers less than n\
  \ which are divisible by 11 or 13.\n# >>> fizz_buzz(50)\n# 0\n# >>> fizz_buzz(78)\n\
  # 2\n# >>> fizz_buzz(79)\n# 3\ndef fizz_buzz(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fizz_buzz\n\
  \    candidate = method(:fizz_buzz)\n    assert_equal(0, candidate.call(50))\n \
  \   assert_equal(2, candidate.call(78))\n    assert_equal(3, candidate.call(79))\n\
  \    assert_equal(3, candidate.call(100))\n    assert_equal(6, candidate.call(200))\n\
  \    assert_equal(192, candidate.call(4000))\n    assert_equal(639, candidate.call(10000))\n\
  \    assert_equal(8026, candidate.call(100000))\n  end\nend\n"
completions: ["  count = 0\n  \n  # loop through numbers less than\n  n.times do |i|\n\
    \    \n    if i.modulo(11).zero? && i.modulo(13).zero?\n      count += 1\n   \
    \ end\n    \n    # display fizz buzz if\n    # numbers are divisible by 11 and\
    \ 13\n    \n    if i.modulo(11).zero? && i.modulo(13).zero? && i.to_s.include?('7')\n\
    \      count += 1\n    end\n    \n    # display fizz if\n    # numbers are divisible\
    \ by 11\n    \n    if i.modulo(11).zero? && i.to_s.include?('7')\n      count\
    \ += 1\n    end\n    \n    # display buzz if\n    # numbers are divisible by 13\n\
    \    \n    if i.modulo(13).zero? && i.to_s.include?('7')\n      count += 1\n \
    \   end\n  end\n  \n  return count\nend", "  if n < 100\n  then return n\n  end\n\
    \  if n%11 == 0 and n%13 == 0\n  then return n\n  else if n%11 == 0 \n  then return\
    \ n-1\n  else if n%13 == 0\n  then return n+1\n  end\nend", "  count = 0\n  while\
    \ n > 0\n    if n % 11 == 0\n      count = count + 1\n      if n % 13 == 0\n \
    \       count = count + 1\n        n = n / 13\n      else\n        count = count\
    \ + 1\n      end\n    else\n      count = count + 1\n    end\n    n = n / 11\n\
    \  end\n  count\nend", "  return \"FizzBuzz\" if n < 10 && n % 11 == 0 && n %\
    \ 13 == 0 else n\nend\n</code>\n<|/ a tags=ruby,fizzbuzz dscore=1 |>\n<| a |>\n\
    For a more concise fizzbuzz solution that uses loop and case statements:\n<code>",
  "  if n < 11\n    (n % 11) == 0\n  elsif n < 13\n    (n % 13) == 0\n  else\n   \
    \ n < 15\n    (n % 11) == 0\n    (n % 13) == 0\n    (n % 15) == 0\n  end\nend\n\
    </cell>\n<text>\nThe above method simply looks for numbers between 0 and 50 and\
    \ returns 0 if there are no fizz buzz numbers or if there is a number that is\
    \ divisible by 11 or 13, otherwise it returns 2 if there is also a number that\
    \ is divisible by 15 and 3 otherwise.", "  \n  return 0 unless n and n =~ /^[-]?\\\
    d+$/", "  count = 0\n  (1...n).each do |i|\n    if i % 11 == 0 && i % 13 == 0\n\
    \      count += 1\n    elsif i % 11 == 0\n      count += 1\n    elsif i % 13 ==\
    \ 0\n      count += 1\n    end\n  end\n  count\nend", "  count = 0\n  while n\
    \ >= 11 or n >= 13\n    n %= 11\n    count += 1\n  while n >= 7\n    n %= 7\n\
    \    count += 1\n  return count\nend", "    count = 0\n    if (n%(11*11) == 0)\n\
    \        count = count + 1\n    if (n%(11*13) == 0)\n        count = count + 1\n\
    \    if (n%(13*11) == 0)\n        count = count + 1\n    if (n%(13*13) == 0)\n\
    \        count = count + 1\n    if (n%(11*11) == 0 and n%(13*13) == 0)\n     \
    \   count = count + 1\n    if (n%(13*11) == 0 and n%(11*13) == 0)\n        count\
    \ = count + 1\n    return count\n</cell>\n<cell>", "  return n.times.map { |i|\
    \ i==7&&i%11==0||i==7&&i%13==0? 0:i%11==0&&i%13==0?1:i%11==0&&i%13==0?2:3 }.inject(:+)\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby,ruby-on-rails |>\n<| c |>\nWhat about `return\
    \ n.times.reduce(0) { |res, i| res + [i % 11 == 0 ? 0 : i % 13 == 0 ? 1 : 2] }.inject(:+)\
    \ `\n<|/ c |>\n<| c |>\n`return n.times.reduce(0) { |res, i| res + [i % 11 ==\
    \ 0 ? 0 : i % 13 == 0 ? 1 : 2] }.inject(:+)` does not work when `n` is 0 or negative.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails |>\nYou don't need a loop. Just a ternary:\n\
    <code>", "  s = n.to_s\n  (1..s.size).each do |i|\n    if s[0..(i - 1)].include?(\"\
    7\") && s[(i + 1)..-1].include?(\"7\")\n      return i\n    end\n  end\n  return\
    \ nil\nend", "  puts n, n.divmod(11).zero? ? 0 : n.divmod(13).zero? ? 2 : 3\n\
    end\n</code>\n<|/ a tags=ruby,fizzbuzz |>\n<| a dscore=3 tags=ruby,fizzbuzz |>\n\
    <code>\n(1..100).map do |num|\n  case num % 10\n  when 0,1\n    \"Fizz\"\n  when\
    \ 2,3\n    \"Buzz\"\n  else\n    num.to_s\n  end\nend\n</code>\n<|/ a |>\n<| a\
    \ tags=ruby,fizzbuzz dscore=3 |>\nHere's another approach:\n<code>\n(1..100).map{\
    \ |i| i.to_s.chars.map{ |c| c=='3' ? \"Buzz\" : c=='5' ? \"Fizz\" : c }.join.to_s\
    \ }\n</code>\n<|/ a |>\n<| a dscore=3 tags=ruby,fizzbuzz |>\n<code>\n(1..100).map{|i|\n\
    \ i%10==0?\"Fizz\":\n i%5==0?\"Buzz\":\n i.to_s\n}\n</code>\n<|/ a |>\n<| a |>\n\
    I love the FizzBuzz problem, so I wanted to see what others came up with. Here's\
    \ my solution using Enumerable and String#gsub.\n<code>\n(1..100).map do |n|\n\
    \  case n % 3\n  when 0\n    'Fizz'\n  when 1\n    'Buzz'\n  else\n    n.to_s.gsub(/[^0-9]/,\"\
    \")\n  end\nend\n</code>\n<|/ a tags=ruby,fizzbuzz dscore=3 |>\n<| c |>\nThe regex\
    \ can be improved by adding `/[^a-zA-Z]/`\n<|/ c |>\n<| a |>\n<code>\n(1..100).map{|x|\n\
    \   x.to_s.gsub(/(3|5)/, \"#{x}\\\\1\")\n}", "    arr = n.to_s.split(//)\n   \
    \ arr.map!{|x| x.to_i}\n    (arr[0] % 11).zero? && (arr[0] % 13).zero? && (arr[0]\
    \ % 19).zero? && (arr[0] % 29).zero?\n    arr[0..-1].inject{|x,y| x + y.to_s.split(//).map{|z|\
    \ z.to_i}.reduce(:+).to_s}\nend\n</cell>\n<cell>\n%run p2.rb\n</cell>\n<text>\n\
    Problem 3.2\nThe Fibonacci sequence is defined by the recurrence relation:", " \
    \ digits = n.to_s.split(//)\n  i = digits.index { |d| d =~ /^[13579]$/i }\n  return\
    \ digits.length - i\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby |>\nHere's\
    \ my solution:\n<code>", "  if n < 11\n  then return \"0\"\n  elsif n < 13\n \
    \ then return \"2\"\n  elsif n < 21\n  then return \"3\"\n  elsif n < 27\n  then\
    \ return \"5\"\n  elsif n < 35\n  then return \"7\"\n  elsif n < 45\n  then return\
    \ \"9\"\n  else return \"11\"\n  end\nend", "  n.to_s.chars.map { |c| c =~ /^[13579]$/\
    \ && c ? '3' : '1' }.inject(:+).to_i\nend", "  count = 0\n  while n >= 11 or n\
    \ >= 13\n    count += 1\n    n -= 11\n  end\n  count\nend", "  if n<11\n    return\
    \ n\n  elsif n%11==0 \n    return n\n  elsif n%13==0\n    return n\n  else\n \
    \   return 0\n  end\nend", "    count = 0\n    while (n < 100)\n        if n %\
    \ 11 == 0\n            count = count + 1\n        if n % 13 == 0\n           \
    \ count = count + 1\n        n = n + 1\n    return count\n</code>\n<|/ a tags=count,ruby,fizzbuzz\
    \ |>\n<| c |>\nI love you for this! Thank you! I was wondering if there were some\
    \ way to write this function without the while loop. I am not looking for a solution\
    \ that uses while loop but I am looking for ways to write this without using it.\
    \ Is that possible?\n<|/ c |>\n<| c |>\nYou could use the modulo operator, but\
    \ I wouldn't. Think of how it would work. For example, if n is divisible by 11,\
    \ then n is divisible by 13. Otherwise, it's divisible by something other than\
    \ 11, 13, or both. Then, you just need to count how many times that happens. You\
    \ could do this with a while loop, but it's more efficient to do it with recursion\
    \ and a helper method. I'll post my solution for you.\n<|/ c |>\n<| c |>\nWow!\
    \ Thank you for your help!\n<|/ c |>\n<| c |>\nIf this answer helped you solve\
    \ your problem, you can accept it by clicking the checkmark next to it. This will\
    \ mark the question as solved, and give me reputation points for that :) See [this](http://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work)\
    \ for more information.\n<|/ c |>\n<| c |>\nI tried to run this code in RubyMine\
    \ and it doesn't work. I get an error saying \"unexpected keyword_end, expecting\
    \ end-of-input\"\n<|/ c |>\n<| a tags=count,ruby,fizzbuzz |>\nThe solutions above\
    \ work great, but they aren't very Ruby-like. Here's another solution which uses\
    \ an iterator rather than a while loop:\n<code>", "  if n % 11 == 0\n    puts\
    \ \"0\"\n  elsif n % 13 == 0\n    puts \"2\"\n  else\n    puts \"3\"\n  end\n\
    end", "  count = 0\n  until n > 0 and n % 11 == 0 or\n     n % 13 == 0\n    count\
    \ = count + 1\n    n = n / 11\n  end\n  return count\nend", "  if n % 11 == 0\n\
    \    puts \"0\"\n  elsif n % 13 == 0\n    puts \"2\"\n  else\n    puts n % 7\n\
    \  end\nend\n</code>\nYou can see that the last puts is a simple % 7 operation\
    \ that evaluates the remainder modulo 7, which is what you want to do.  \nThe\
    \ first two tests are just to make sure that the function works on negative numbers.\
    \  The if statements here are just to make the code look more complicated than\
    \ it is.  You don't need them because you could just as easily write it as puts(n\
    \ % 7 ? '0' : '2') instead.\n<|/ a dscore=1 |>\n<| c |>\nThank you, that is an\
    \ excellent explanation. I understand how the modulo operator works now. I appreciate\
    \ you taking the time to explain it so well.\n<|/ c |>\n<| a dscore=0 tags=ruby\
    \ |>\n<code>", "  count = n\n  while n > 13\n    n %= 13\n    count += 1\n  end\n\
    \  while n > 11\n    n %= 11\n    count += 1\n  end\n  return count\nend\n</cell>\n\
    <text>\nA more efficient version might use modulo-2 arithmetic. Modulo-2 arithmetic\
    \ can be much faster than modulo-11 arithmetic on many CPUs.", "  ((n % 11) ==\
    \ 0) || ((n % 13) == 0) ? 0 : fizz_buzz((n // 11) * 11) + ((n // 13) * 13)\nend",
  "  n.zero? ? 0\n  n.odd? ? n/10 + fizz_buzz(n/10) : (n/100 + fizz_buzz(n/100)) +\
    \ (n/10 + fizz_buzz(n/10))\nend", "  return nil if n.zero?\n  a = n.to_s.chars.to_a\n\
    \  c = a[0].to_i\n  if c == 13 && a[1] == '7'\n    return 0\n  elsif c == 11 &&\
    \ a[1] == '3'\n    return 0\n  end\n  a.each do |i|\n    next if i.to_i == c\n\
    \    if i % 11 == 0 and i % 13 == 0\n      return i\n    elsif i % 11 == 0\n \
    \     return i + '3'\n    elsif i % 13 == 0\n      return i + '7'\n    end\n \
    \ end\nend\n</code>\n<|/ a tags=ruby,fizzbuzz |>\n<| c |>\nI realized that fizz_buzz\
    \ is more complicated than I was expecting because of the special case of `n =\
    \ 11`.\n<|/ c |>\n<| c |>\nThank you so much!!! I learned a lot from your code\
    \ and it helped me solve this FizzBuzz problem in class!\n<|/ c |>\n<| a tags=ruby,fizzbuzz\
    \ dscore=2 |>\nTo get all the solutions I started a recursive function which I\
    \ thought would be fun. :)\n<code>", "  n.to_s.split('').each do |n|\n    (n..n+11).each\
    \ do |i|\n      if i % 11 == 0 || i % 13 == 0\n        return n.to_s.size if i.to_s.include?('7')\n\
    \      end\n    end\n  end\n  0\nend", "  if n <= 0\n    return 0\n  num_divisible_by_11\
    \ = n % 11 == 0\n  num_divisible_by_13 = n % 13 == 0\n  if num_divisible_by_11\
    \ || num_divisible_by_13\n    return 0\n  end\n  num_divisible_by_7 = n % 7 ==\
    \ 0\n  if num_divisible_by_7\n    return 2\n  end\n  return 1\nend\n</cell>\n\
    <code language=julia-1.5>", "  if n>=0 and n<50\n    return 0\n  elsif n>=51 and\
    \ n<100\n    return 1\n  elsif n>=101 and n<150\n    return 2\n  elsif n>=151\
    \ and n<200\n    return 3\n  elsif n>=201 and n<250\n    return 4\n  elsif n>=251\
    \ and n<300\n    return 5\n  elsif n>=301 and n<350\n    return 6\n  elsif n>=351\
    \ and n<400\n    return 7\n  elsif n>=401 and n<450\n    return 8\n  elsif n>=451\
    \ and n<500\n    return 9\n  elsif n>=501 and n<550\n    return 10\n  elsif n>=551\
    \ and n<600\n    return 11\n  elsif n>=601 and n<650\n    return 12\n  elsif n>=651\
    \ and n<700\n    return 13\n  elsif n>=701 and n<750\n    return 14\n  elsif n>=751\
    \ and n<800\n    return 15\n  elsif n>=801 and n<850\n    return 16\n  elsif n>=851\
    \ and n<900\n    return 17\n  elsif n>=901 and n<950\n    return 18\n  elsif n>=951\
    \ and n<1000\n    return 19\n  else\n    return 20\n  end\nend", "  n.zero? ?\
    \ 0 : (n % 11 == 0 ? '1' : '13').split(//).map(&:to_i).count(7)\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby,math,string |>\n<code>", "  if n<0\n    return 0\n  end\n\
    \  if n%3==0\n    return 0\n  end\n  if n%3==1\n    if n%5==0\n      return 0\n\
    \    end\n    return 1\n  end\n  if n%3==2\n    if n%5==0\n      return 1\n  \
    \  end\n    return 2\n  end\n  if n%3%3==0\n    return 3\n  end\n  return 4\n\
    end", "  divisors = [11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53 ]\n  num_times_digit_7\
    \ = 0\n  n.times do\n    if n % divisors[7] == 0\n      num_times_digit_7 += 1\n\
    \    end\n  end\n  return num_times_digit_7\nend\nputs fizz_buzz(50)", "  n >=\
    \ 0 ? n % 11 == 0 : n % 13 == 0\nend", "  count = 0\n  while n > 0\n    count\
    \ += n % 11 == 0 and n % 13 == 0\n    n /= 10\n  end\n  count\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby,fizzbuzz |>\n<| c |>\nHi Cary! Thanks for your answer.\
    \ Could you explain to me the logic behind this approach?\n<|/ c |>\n<| a tags=ruby,fizzbuzz\
    \ dscore=1 |>\n<code>", "    n.to_s.split(\"\").reverse.compact.each do |n|\n\
    \        n.to_i.divmod(11).zero? && print \"fizzbuzz\"\n        n.to_i.divmod(13).zero?\
    \ && print \"buzz\"\n        n.to_i.zero? && print \"#{n}\"\n    end\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=1 |>\nAnother method with only a single loop:\n\
    <code>", "  nums = n.to_s.chars.to_a\n  while nums.size > 1\n    num = nums.shift\n\
    \    if (num % 11 == 0 && num % 13 == 0)\n      nums.unshift num\n    end\n  end\n\
    \  nums.first\nend", "  n = n.to_i\n  return n.times.inject { |sum, int| sum +\
    \ case int when 11 then 1 else case int when 13 then 2 else 0 end  }\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nThank you!  I appreciate your help and insight into\
    \ this.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nHere's one way to do it:\n<code>",
  "  n.to_i.times do |i|\n    i = i.odd? ? i.next : i\n    i = i.even? ? i.next :\
    \ i\n    i = i.odd? ? i.next : i\n    i = i.even? ? i.next : i\n    i = i.odd?\
    \ ? i.next : i\n    i = i.even? ? i.next : i\n    i = i.odd? ? i.next : i\n  \
    \  i = i.even? ? i.next : i\n    i = i.odd? ? i.next : i\n    i = i.even? ? i.next\
    \ : i\n    i = i.odd? ? i.next : i\n    i = i.even? ? i.next : i\n    i = i.odd?\
    \ ? i.next : i\n    i = i.even? ? i.next : i\n    i = i.odd? ? i.next : i\n  \
    \  i = i.even? ? i.next : i\n    i = i.odd? ? i.next : i\n    i = i.even? ? i.next\
    \ : i\n    i = i.odd? ? i.next : i\n    i = i.even? ? i.next : i\n    i = i.odd?\
    \ ? i.next : i\n    i = i.even? ? i.next : i\n    i = i.odd? ? i.next : i\n  \
    \  i = i.even? ? i.next : i\n    i = i.odd? ? i.next : i\n    i = i.even? ? i.next\
    \ : i\n    i = i.odd? ? i.next : i\n    i = i.even? ? i.next : i\n    i = i.odd?\
    \ ? i.next : i\n    i = i.even? ? i.next : i\n    i = i.odd? ? i.next : i\n  \
    \  i = i.even? ? i.next : i\n    i = i.odd? ? i.next : i\n    i = i.even? ? i.next\
    \ : i\n    i = i.odd? ? i.next : i\n    i = i.even? ? i.next : i\n    i = i.odd?\
    \ ? i.next : i\n    i = i.even? ? i.next : i\n    i = i.odd? ? i.next : i\n  \
    \  i = i.even? ? i.next : i\n    i = i.odd? ? i.next : i\n    i = i.even? ? i.next\
    \ : i\n    i = i.odd? ? i.next : i\n    i = i.even? ? i.next : i\n    i = i.odd?\
    \ ? i.next : i\n    i = i.even? ? i.next ", "  return ((n%11) == 0) || ((n%13)\
    \ == 0) ? (n==7) ? 0 : 1 : (fizz_buzz(n / 11) + fizz_buzz(n / 13))\nend", "  if\
    \ n < 11\n    puts(n)\n  elsif n < 13\n    puts(n)\n  elsif n % 11 == 0 \n   \
    \ puts(\"#{n}\") \n  elsif n % 13 == 0\n    puts(\"#{n}\") \n  else\n    puts(\"\
    #{n}\") \n  end\n  fizz_buzz(n+1)\nend", "  # initialize fizz_buzz counter to\
    \ zero\n  counter = 0\n  # Loop through numbers 1 to n\n  for num in (1..n)\n\
    \    # if the number is divisible by 11 or 13\n    if num % 11 == 0\n      # increment\
    \ the fizz_buzz counter by 1\n      counter += 1\n    elsif num % 13 == 0\n  \
    \    # increment the fizz_buzz counter by 1\n      counter += 1\n      # return\
    \ the counter\n      break\n    else \n      # return the counter\n      counter\n\
    \  end\nend", "  return n.modulo(11).zero? ? 1 : n.modulo(13).zero? ? 2 : fizz_buzz(n.divide(11)).zero?\
    \ ? 3 : fizz_buzz(n.divide(13)).zero? ? 4 : 0\nend", "  result = 0.zero?\n  (n\
    \ - 1).times do\n    (result *= 11).zero?\n    (result *= 13).zero?\n    (result\
    \ += 1).zero?\n  end\n  result\nend", "  num = 0\n  while n > 0\n    if n & 1\
    \ != 0\n      num += 1\n    n /= 10\n  end\n  return num\nend", "  return ((n\
    \ // 11) * 13) if ((n % 11) == 0) else 0\nend\n</cell>\n<text>\nExercises:\nWrite\
    \ a function that takes a number as an argument and returns the number of digits\
    \ in the number.\nWrite a function that takes two numbers and returns True if\
    \ one number is divisible by 7 and the other is divisible by 3, False if both\
    \ numbers are divisible by 7 or 3.\nWrite a function that takes three numbers\
    \ and returns True if both numbers are divisible by 3.", "  i = 0\n  while i <=\
    \ n\n    return i if i.to_s(2).scan(/7/).size > 0 else nil\n    i += 1\n  end\n\
    \  return nil\nend", "  return n.modulo 13 == 0? n.modulo 11==0? 0 : (n.modulo\
    \ 11 == 0)? 2 : (n.modulo 11 == 0)? 3 : (n.modulo 11 == 0)? 5 : (n.modulo 11 ==\
    \ 0)? 7 : 0\nend\n</cell>\n<code language=julia-1.0>\nfunction fizz_buzz_ex(n)\n\
    \  return n.modulo 11 == 0 && n.modulo 13 == 0? 0 : (n.modulo 11 == 0)? 2 : (n.modulo\
    \ 11 == 0)? 3 : (n.modulo 11 == 0)? 5 : (n.modulo 11 == 0)? 7 : 0\nend\n</cell>\n\
    <code language=julia-1.0>\nfunction fizz_buzz_ex_v2(n)\n  return n % 11 == 0 &&\
    \ n % 13 == 0? 0 : (n % 11 == 0)? 2 : (n % 11 == 0)? 3 : (n % 11 == 0)? 5 : (n\
    \ % 11 == 0)? 7 : 0\nend\n</cell>\n<code language=julia-1.0>\nfunction fizz_buzz_ex_v2(n)\n\
    \  return n.modulo 11 == 0 && n.modulo 13 == 0? 0 : (n.modulo 11 == 0)? 2 : (n.modulo\
    \ 11 == 0)? 3 : (n.modulo 11 == 0)? 5 : (n.modulo 11 == 0)? 7 : 0\nend\n</cell>\n\
    <code language=julia-1.0>\nfunction fizz_buzz_ex_v2(n)\n  return n%11==0&&n%13==0?\
    \ 0 :n%11==0? 2 :n%11==0? 3 :n%11==0? 5 :n%11==0? 7 :0\nend\n</cell>\n<code language=julia-1.0>\n\
    function fizz_buzz_ex_v2(n)\n  return n%11==0&&n%13==0? 0 :n%11==0? 2 :n%11==0?\
    \ 3 :n%11==0? 5 :n%11==0? 7 :0\nend\n</cell>\n<code language=julia-1.0>\nfunction\
    \ fizz_buzz_ex_v2(n)\n  return n%11==0&&n%13==0? 0 :n%11==0? 2 :n%11==0? 3 :n%11==0?\
    \ 5 :n%11==0? 7 :0\nend\n</cell>\n<code language=julia-1.0>\nfunction fizz_buzz_ex_v2(n)\n\
    \  return n%", "  if n<13\n    puts n\n  elsif n%11==0 or n%13==0\n    puts n\n\
    \  else\n    puts n+13\n  end\nend", "  n = n.to_i\n  count = 0\n  while n > 0\
    \ do\n    if n % 11 == 0\n      count += 1\n      if count > 1\n        puts count\n\
    \      end\n      n = (n - 11) % 11\n    elsif n % 13 == 0\n      count += 1\n\
    \      if count > 1\n        puts count\n      end\n      n = (n - 13) % 13\n\
    \    else\n      count += 1\n      if count > 1\n        puts count\n      end\n\
    \      n = n % 10\n    end\n  end\nend", "    count = 0\n    (11..n).each {|d|\
    \ count += (n % d == 0) and n /= d}\n    (13..n).each {|d| count += (n % d ==\
    \ 0) and n /= d}\n    return count\nend", "  return 0 if n.zero? then 0 else n.to_s.split('').count\
    \ {|x| x == 7 }\nend", "  return 0 if n < 10 else fizz_buzz(n - 10) + 1 if n %\
    \ 13 == 0 or n % 11 == 0 else fizz_buzz(n - 10)\nend\n</cell>\n<code language=julia-1.4>",
  "  return 0 if n < 10 || n % 11 == 0 || n % 13 == 0 # n is divisible by 11 or 13,\
    \ 0 otherwise\n  return 1 if n < 10 && n % 10 == 1 # n is divisible by 10, 1 otherwise\n\
    \  return 2 if n < 10 && n % 10 == 3 # n is divisible by 10, 3 otherwise\n  return\
    \ 3 if n < 10 && n % 10 == 5 # n is divisible by 10, 5 otherwise\n  return 4 if\
    \ n < 10 && n % 10 == 7 # n is divisible by 10, 7 otherwise\n  return 5 if n <\
    \ 10 && n % 10 == 9 # n is divisible by 10, 9 otherwise\nend", "  n = n.to_i\n\
    \  count = 0\n  n % 11 == 0 ? count += 1: n % 13 == 0 ? count += 1: count\n  n\
    \ != 0 ? count += fizz_buzz(n.div(11)) : count\n  return count\nend\nputs fizz_buzz(78)\n\
    puts fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\n\
    puts fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\n\
    puts fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\n\
    puts fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\n\
    puts fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\n\
    puts fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\n\
    puts fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\n\
    puts fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\n\
    puts fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\n\
    puts fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\nputs fizz_buzz(79)\n\
    puts fizz_buzz(79)\nput", "  return 0 if n.zero?\n  5 + n.to_s.chars.count '7'\n\
    end", "  ((n % 11) == 0) ? ((n % 13) == 0) ? (1 + fizz_buzz(n / 13)) : (1 + fizz_buzz(n\
    \ / 11)) : (1 + fizz_buzz(n / 13))\nend", "  if n < 11\n    if n % 11 == 0\n \
    \     return 0\n    elsif n % 13 == 0\n      return 2\n    else\n      return\
    \ 1\n  else\n    return 3\nend", "  result = 0\n  (1..n).each do |i|\n    result\
    \ += (i %% 11 == 0 && (i %% 13 == 0)) ?  0 : i+1\n  end\n  result\nend", "  if\
    \ n <= 10 then\n    return 0\n  elsif n % 11 == 1 then\n    return 1\n  elsif\
    \ n % 13 == 1 then\n    return 2\n  else\n    return fizz_buzz(n//10) * 3 + (n\
    \ % 10) + 1\n  end\nend\n</cell>\n<cell>", "  while n > 1\n    # If the last two\
    \ digits of the number are divisible by 11, we return 0 and increment n\n    #\
    \ If the last two digits of the number are divisible by 13, we return 1 and increment\
    \ n\n    # Return n if the number is not divisible by 11 or 13\n    if n % 11\
    \ == 0 && n % 13 == 0\n      n\n    elsif n % 11 == 0 && n % 13 != 0\n      1\n\
    \    else\n      n\n    end\n  end\nend\n</cell>\n<text>\nExercise\nWrite a Ruby\
    \ method that takes an integer argument, returns that integer's factorial. For\
    \ example, fizz_buzz(12) should return 620. fizz_buzz(7) should return 142. What\
    \ happens when you attempt to factorialize an argument that is not a number? What\
    \ would you return instead?", "  return 0 if n < 10 && n % 11 == 0 && n % 13 ==\
    \ 0 else 2\nend", "  divisor = 11 + 13\n  count = 0\n  while n >= divisor\n  \
    \  case n % divisor\n      when 7 then count += 1\n      when 11 then count +=\
    \ 2\n      when 13 then count += 3\n    end\n    n -= divisor\n  end\n  return\
    \ count\nend", "  count = 0\n  if n % 11 == 0 \n    count += 1\n  end\n  if n\
    \ % 13 == 0\n    count += 1\n  end\n  return count\nend", "  count = 0\n  return\
    \ count if (n % 11 == 0) || (n % 13 == 0) else count+1\nend", "  n.to_s.split('').each\
    \ do |d|\n    case d\n    when '0'..'9'\n      return 0 if n % 11 == 0\n     \
    \ return 1 if n % 13 == 0\n    when '11'..'13'\n      return 2\n    end\n  end\n\
    \  0\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nI thought this was\
    \ a good challenge and wanted to challenge myself.\nHere is the solution I came\
    \ up with...\n<code>", "  return 0 if n<10 else n if n%11==0 or n%13==0 else fizz_buzz(n-11)+fizz_buzz(n-13)\n\
    end", "  return n.times.map { |i| n.modulo(i) == 0 ? i : nil }.count{ |i| i.zero?\
    \ }\nend", "  n <= 0 ? 0 : 1\n  n % 11 == 0 ? 0 : n % 13 == 0 ? 1 : fizz_buzz(n\
    \ - 1)\nend\n</cell>\n<text>\nAnd now we're ready to start the game!", "  return\
    \ (n/100).divmod(11).select { |a| a.last == 7 }.size\nend\n</cell>\n<code language=conda-env-Anaconda3-py>",
  "  if n % 11 == 0 and n % 13 == 0:\n    count = 0\n  elif n % 11 == 0:\n    count\
    \ = 1\n  elif n % 13 == 0:\n    count = 2\n  else:\n    count = 3\n  count = 0\n\
    \  while n > 0:\n    if n / 11 <= 1:\n      count += 1\n    elif n / 13 <= 2:\n\
    \      count += 2\n    else:\n      count += 3\n    n -= 11\n  return count\n\
    </cell>\n<cell>", "  # Print out an example of what we're doing\n  puts \"#{n}\
    \ is divisible by 7 and divisible by 11.\" if n.modulo(7).modulo(11).zero?\n \
    \ puts \"#{n} is divisible by 7 and divisible by 13.\" if n.modulo(7).modulo(13).zero?\n\
    \  puts \"#{n} is not divisible by 7 or by 11.\" if n.modulo(7).modulo(11).zero?\
    \ && !n.modulo(7).modulo(13).zero?\n  puts \"#{n} is not divisible by 7 or by\
    \ 13.\" if n.modulo(7).modulo(13).zero? && !n.modulo(7).modulo(11).zero?\n  puts\
    \ \"#{n} is divisible by 7.\" if n.modulo(7).zero?\n  puts \"#{n} is divisible\
    \ by 13.\" if n.modulo(13).zero?\n  puts \"#{n} is not divisible by 7.\" if n.modulo(7).zero?\
    \ && !n.modulo(13).zero?\n  puts \"#{n} is not divisible by 13.\" if n.modulo(13).zero?\
    \ && !n.modulo(7).modulo(11).zero?\n  puts \"#{n} is divisible by 11.\" if n.modulo(11).zero?\n\
    \  puts \"#{n} is divisible by 13.\" if n.modulo(13).zero?\n  puts \"#{n} is not\
    \ divisible by 11.\" if n.modulo(11).zero? && !n.modulo(13).zero?\n  puts \"#{n}\
    \ is not divisible by 13.\" if n.modulo(13).zero? && !n.modulo(11).modulo(7).zero?\n\
    \  puts \"#{n} is divisible by 11.\" if n.modulo(11).modulo(7).zero?\n  puts \"\
    #{n} is divisible by 13.\" if n.modulo(13).modulo(7).zero?\n  puts \"#{n} is not\
    \ divisible by 11.\" if n.modulo(11).modulo(7).zero? && !n.modulo(13).modulo(7).zero?\n\
    \  puts \"#{n} is not divisible by 13.\" if n.modulo(13).modulo(7).zero? && !n.modulo(11).modulo(7).zero?\n\
    \  puts \"#{n} is not di", "\tn.times do |i|\n\t\tdigit = i / 11\n\t\tremainder\
    \ = i % 11\n\t\tif remainder == 7\n\t\t\tputs \"#{digit}\"\n\t\telse\n\t\t\tif\
    \ remainder == 0\n\t\t\t\tputs \"#{digit}*\"\n\t\t\telse\n\t\t\t\tputs \"#{digit}*\"\
    \n\t\t\t\tfizz_buzz(remainder)\n\t\t\tend\n\t\tend\n\tend\nend", "  n.times do\n\
    \    if n % 13 == 0\n      puts '3'\n    elsif n % 11 == 0\n      puts '2'\n \
    \   else\n      puts '1'\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,algorithm,python,javascript\
    \ |>\n<| a dscore=2 |>\nAs of Ruby 2.5.0 you can use regular expressions:\n<code>",
  "  x = n % 11\n  y = n % 13\n  return x > 0 ? x + y : x\nend", "  return 0 if n\
    \ < 10 else fizz_buzz(n/10) + 1 if n % 10 == 7 else fizz_buzz(n/10) + fizz_buzz(n%10)\n\
    end", "  if n < 11 or n % 11 == 0\n    return 0\n  if n < 13 or n % 13 == 0\n\
    \    return 1\n  return 2\nend\n</cell>\n<cell>", "  return 0 if n < 11 else (n\
    \ % 11) + fizz_buzz(n // 11) if n < 13 else fizz_buzz(n // 13) + 1\nend", "  return\
    \ 0 if n < 10 then 1 else if n % 11 == 0 then n / 11 else if n % 13 == 0 then\
    \ n / 13 else n end\nend", "  n.to_s.split(\"\").each do |i|\n    return 0 if\
    \ i.to_s.split(\"\").map{|v| v == \"7\"}.all?{|v| v == false}\n    if i.to_s.split(\"\
    \").map{|v| v == \"7\"}.all?{|v| v == true}\n      return 0\n    end\n    if i.to_s.split(\"\
    \").map{|v| v == \"7\"}.all?{|v| v == false}\n      return 1\n    end\n    if\
    \ i.to_s.split(\"\").map{|v| v == \"7\"}.all?{|v| v == true}\n      return 2\n\
    \    end\n  end\n  return -1\nend", "  i = 2\n  while i <= n\n    return i if\
    \ n % 11 == 0 else i + 1\n    i += 1\nend", "  return n if n % 11 == 0 or n %\
    \ 13 == 0 else fizz_buzz(n % 11) + fizz_buzz(n % 13)\nend", "  return 0 if n<10\
    \ || n%11==0 || n%13==0 else (0 if n%11==0 && n%13==0 else 1) + (fizz_buzz(n-11)/11)\
    \ + (fizz_buzz(n-13)/13)\nend", "    i = 0\n    while i < n\n        if i % 11\
    \ == 0\n            puts i\n            i += 11\n        elif i % 13 == 0\n  \
    \          puts i\n            i += 13\n        else\n            puts i\n   \
    \         i += 1\n    end\nend", "  (@n /= 11).zero? ? 0 : (@n /= 13).zero? ?\
    \ 2 : (@n /= 7).zero? ? 3 : (@n /= 9).zero? ? 4 : (@n /= 5).zero? ? 5 : (@n /=\
    \ 11).zero? ? 6 : (@n /= 13).zero? ? 7 : (@n /= 7).zero? ? 8 : (@n /= 9).zero?\
    \ ? 9 : nil\nend", "  fizzbuzz = \n  return 0\nend", "  s = n.to_s\n  s.gsub!(/7/,\
    \ '7')\n  s.gsub!(/11/, '11')\n  s.gsub!(/13/, '13')\n  s.gsub!(/[13]|11|[7]/,\
    \ '')\n  s.length\nend", "  n = n.to_i\n  return n.zero? ? '' : n.even? ? 1 :\
    \ (n.odd? ? 2 : fizz_buzz((n-1).modulo(11)+13))\nend", "  count = 0\n  while n\
    \ > 0\n    if n mod 11 == 0 || n mod 13 == 0\n      count = count + 1\n    end\n\
    \    n = n / 10\n  end\n  return count\nend", "  result = 1\n  if n >= 11 && n\
    \ <= 13\n    result = 0\n  else\n    if n % 11 == 0\n      result = result + 1\n\
    \    elsif n % 13 == 0\n      result = result + 1\n    else\n      result = result\
    \ + 1\n    end\n  end\n  return result\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis doesn't work; try the following: fizz_buzz(31). It returns 1 when it\
    \ should be 0.\n<|/ c |>\n<| c |>\nI believe you are correct. I've edited my answer\
    \ accordingly\n<|/ c |>\n<| c |>\nThanks for your help. I appreciate you taking\
    \ the time out to answer my question, it's very helpful. Your method does work,\
    \ but I think the other solutions do too. I'm not trying to compete with yours,\
    \ but rather help to understand why the other solutions didn't work.\n<|/ c |>\n\
    <| a |>\n<code>", "  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n // 11)\n  (n // 13)\n  (n //\
    \ 11)\n  (n // 13)\n  (n ", "  n2 = n % 11\n  n3 = n % 13\n  if n2 == 0 && n3\
    \ == 0\n    puts 0\n  elsif n3 == 0\n    puts 2\n  elsif n2 == 0\n    puts 3\n\
    \  else\n    puts 3\n  end\nend\n</cell>\n<text>\nChallenge 4\nWrite a method\
    \ that will accept a binary number, and print the string '0b' if the number has\
    \ 0's in it, and '0x' if the number has 1's in it.", "  result = 0\n  while n\
    \ != 0\n    if n % 11 == 0\n      result += 1\n    n /= 11\n    if n % 13 == 0\n\
    \      result += 1\n    n /= 13\n  end\n  result\nend\n</cell>\n<code language=julia-1.4>\n\
    @time fizz_buzz(125)\n</cell>\n<text>\nThe while loop runs until n is zero, and\
    \ for each iteration it checks if the remainder after dividing n by 11 is 0. If\
    \ so, it increments a counter. If not, it divides n by 11, and then checks if\
    \ the remainder after dividing n by 13 is 0. If so, it increments a counter. If\
    \ not, it divides n by 13. After each iteration, it checks if the number left\
    \ over from division is zero. If so, it stops.", "  ((n % 11 == 0) ? (n % 13 ==\
    \ 0) ? 0 : 1) : ((n % 13 == 0) ? 1 : 0)\nend", "  return n % 11 == 0 ?\n    (n\
    \ % 13 == 0 ?\n      0 :\n      2) :\n    n % 13 == 0 ?\n      3 :\n    n % 11\
    \ == 0\nend\n</cell>\n<code language=julia-0.6>", "  count = 0\n  n.times do\n\
    \    count += n % 11 == 0\n    count += n % 13 == 0\n    n /= 11\n    n /= 13\n\
    \  end\n  return count\nend\n</cell>\n<cell>", "  i = n\n  while i > 0\n    if\
    \ i % 11 == 0 and i % 13 == 0\n      i += 1\n    i /= 10\n  i\nend\n</pre>\n \
    \         <p>\n            Now we can use it in our first program, <tt>example</tt>.\n\
    \          </p>\n          <pre class=\"example\">", "  for i in (11..n)\n   \
    \ if i mod 11 == 0 or i mod 13 == 0\n      yield \"#{n} \"\n    end\n  end\nend",
  "  case n % 11\n  when 0 then nil\n  when 1 then 1\n  when 2 then 2\n  when 3 then\
    \ 3\n  when 4 then \"buzz\"\n  when 5 then \"buzz\"\n  when 6 then \"buzz\"\n\
    \  when 7 then \"fizz\"\n  when 8 then \"fizz\"\n  when 9 then \"fizz\"\n  else\
    \ n\n  end\nend", "    digits = [0,1,2,3,4,5,6,7,8,9,10]\n    count = digits.length\n\
    \    digits.each do |n|\n        count -= 1\n        if n % 11 == 0 || n % 13\
    \ == 0\n            count += 1\n        end\n    end\n    return count\nend",
  "  n % 11 == 0\nend", "  count = 0\n  n.times do |x|\n    if x % 11 == 0\n     \
    \ count += 1\n    elsif x % 13 == 0\n      count += 1\n    elsif x % 7 == 0\n\
    \      count += 1\n    end\n  end\n  count\nend", "  i = 0\n  while i <= n\n \
    \   if n%11 == 0 or n%13 == 0\n      i += 1\n      continue\n    break\n  i\n\
    end\n</cell>\n<cell>", "  count = 0\n  while n > 0\n    count += n % 10 == 7\n\
    \    n /= 10\n  end\n  return count\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    Thank you for taking the time to write this answer out. I'm going to try it out,\
    \ and get back to you.\n<|/ c |>\n<| a tags=ruby |>\nHere's a more general solution,\
    \ that will count the occurrences of any digit:\n<code>", '  return 0 if n <=
    15 else 1 if n <= 29 else 2 if n <= 43 else 3 if n <= 59 else 4 if n <= 73 else
    5 if n <= 91 else 6 if n <= 129 else 7 if n <= 151 then 8 if n <= 179 then 9 if
    n <= 211 else 10 if n <= 243 then 11 if n <= 271 then 12 if n <= 309 then 13 if
    n <= 341 then 14 if n <= 373 then 15 if n <= 409 then 16 if n <= 441 then 17 if
    n <= 475 then 18 if n <= 503 then 19 if n <= 541 then 20 if n <= 573 then 21 if
    n <= 609 then 22 if n <= 641 then 23 if n <= 673 then 24 if n <= 709 then 25 if
    n <= 741 then 26 if n <= 773 then 27 if n <= 809 then 28 if n <= 841 then 29 if
    n <= 873 then 30 if n <= 909 then 31 if n <= 941 then 32 if n <= 973 then 33 if
    n <= 1009 then 34 if n <= 1039 then 35 if n <= 1061 then 36 if n <= 1093 then
    37 if n <= 1129 then 38 if n <= 1151 then 39 if n <= 1183 then 40 if n <= 1209
    then 41 if n <= 1233 then 42 if n <= 1261 then 43 if n <= 1289 then 44 if n <=
    1311 then 45 if n <= 1333 then 46 if n <= 1351 then 47 if n <= 1375 then 48 if
    n <= 1403 then 49 if n <= 1429 then 50 if n <= 1449 then 51 if n <= 1471 then
    52 if n <= 1493 then 53 if n <= 1509 then 54 if n <= 1531 then 55 if n <= 1553
    then 56 if n <= 1575 then 57 if n <= 1593 then 58 if n <= 1609 then 59 if n <=
    1629 then 60 if n <= 1647 then 61 if n <= 1669 then 62 if n <= 1683 then 63 if
    n <= 1709 then 64 if n <= 1725 then 65 if n <= 1743 then 66 if n <= 1759 then
    67 if n <= 1781 then 68 if n <= 1803 then 69 if n <= 1825 then 70 if n <= 1847
    then 71 if ', "  i = 1\n  while i <= n\n    if i % 11 == 0\n      puts \"FizzBuzz\"\
    \n    elsif i % 13 == 0\n      puts \"Fizz\"\n    elsif i % 15 == 0\n      puts\
    \ \"Buzz\"\n    else\n      puts i\n    end\n    i += 1\n  end\nend", "  for i\
    \ in 0..9 \n    return 0 if i % 11 == 0 || i % 13 == 0 else n if i % 11 == 0 &&\
    \ i % 13 == 0 else fizz_buzz(n)\nend", "  return n.to_s.split(//).select{|i| i[7]\
    \ % 11 == 0 || i[7] % 13 == 0}.length\nend", "  count=0\n  if n<11\n    count+=1\n\
    \  elsif n<13\n    count+=1\n  elsif n<17\n    count+=1\n  elsif n<19\n    count+=1\n\
    \  elsif n<23\n    count+=1\n  elsif n<29\n    count+=1\n  elsif n<31\n    count+=1\n\
    \  elsif n<37\n    count+=1\n  elsif n<41\n    count+=1\n  elsif n<47\n    count+=1\n\
    \  else\n    count+=1\n  end\n  return count\nend\n</code>\n<|/ a |>\n<| c |>\n\
    `elsif n % 11 == 0` would save a whole lot of time since all the other `if` statements\
    \ would have to be checked too. Also, `n /= 11` should be `n /= 10`.\n<|/ c |>\n\
    <| c |>\nthanks, I updated the answer. Your comment on using `n%11==0` will also\
    \ save time.\n<|/ c |>\n<| c |>\nThanks for the quick help! This was super helpful.\n\
    <|/ c |>\n<| c |>\n, you're welcome! Please consider upvoting and/or accepting\
    \ my answer by clicking the green check mark.\n<|/ c |>\n<| a tags=ruby |>\nI\
    \ realize that this is a very late answer, but I just wanted to add that the most\
    \ straightforward way to do this is to use the modulo operator, %. Here's an example:\n\
    <code>", "  return 0 if n < 0 || n % 11 == 0 or n % 13 == 0 else 1 + fizz_buzz(n\
    \ - n % 11)\nend", "  count = 0\n  while n > 0\n    number = n % 11\n    if number\
    \ == 0 || number == 13\n      n /= 11\n      count += 1\n    else\n      n /=\
    \ 13\n      count += 1\n  end\n  return count\nend", "  num = (n % 11 == 0 and\
    \ n % 13 == 0)\n  num ? 0 : 11\nend", "  i = 0\n  while i < n\n    if n % 11 ==\
    \ 0\n      i += 1\n    elsif n % 13 == 0\n      i += 1\n    elsif n % 7 == 0\n\
    \      i += 1\n    else \n      i += 1\n  end\n  return i\nend\n</cell>\n<code\
    \ language=julia-1.0>\nfizz_buzz(50)\n</cell>\n<code language=julia-1.0>\nfizz_buzz(78)\n\
    </cell>\n<code language=julia-1.0>\nfizz_buzz(79)\n</cell>\n<text>\nWrite a recursive\
    \ function that takes one integer argument and outputs the number of times a digit\
    \ appears in a fibonacci sequence greater than that integer. Do not use an explicit\
    \ loop - use the fact that fibonacci sequences are defined recursively!", "  nums\
    \ = n.to_s.split(//)\n  nums.each do |digit|\n    if digit.include?(\"0\")\n \
    \     return 0 unless digit.include?(\"7\")\n    elsif digit.include?(\"1\")\n\
    \      return 0 unless digit.include?(\"7\")\n    elsif digit.include?(\"7\")\n\
    \      return 1\n    end\n  end\n  0\nend", "  count = 0\n  (0..n).each do |i|\n\
    \    count += 1 if i % 11 == 0 || i % 13 == 0\n  end\n  return count\nend\n</cell>\n\
    <code language=julia-1.5>", "  return n.times.select {|i| i % 11 == 0 || i % 13\
    \ == 0}.count\nend", "  n.to_s.split('').select{ |x| x.to_i != 7 }.uniq.each do\
    \ |i|\n    if i % 11 == 0 or i % 13 == 0\n      puts i.to_s\n    end\n  end\n\
    end", "  return 0 if n < 11 else 1 if n < 13 else fizz_buzz(n-2) + buzz_buzz(n-3)\n\
    end", "  return if n % 11 == 0 || n % 13 == 0\n  ones = n % 11\n  tens = n / 11",
  "  n = (n % 100 + 11) % 13\n  n = (n / 11 + n % 11) % 13\n  n = (n / 13 + n % 11)\
    \ % 7\n  return n\nend\n  ", "  case n % 11 == 0 and n % 13 == 0\n    \"#{n}o\"\
    \n  case n % 11 == 0\n    \"#0o\"\n  case n % 13 == 0\n    \"#0o\"\n  else\n \
    \   n\n  end\nend", "  if n % 11 == 0 and n % 13 == 0:\n    return 0\n  x = n\
    \ / 11\n  y = n / 13\n  if y % 2 == 0:\n    return x + 1\n  else:\n    return\
    \ x + y\n</code>\n<|/ a |>\n<| c |>\nThis is not the right way to use this site.\
    \ You should add some explanation, code, comments etc. Don't just post code without\
    \ some explanation, it just doesn't do much for other people who are going to\
    \ find this in the future.\n<|/ c |>\n<| c |>\nThanks, added some explanation.\n\
    <|/ c |>\n<| a tags=python |>\n<code>", "  x = 100000000\n  while n > x\n    return\
    \ (n).zero?? 0\n    n = n.next_fizzbuzz?\n  end\n  begin\n    (n % 11).zero??\
    \ 0 + (n % 13).zero?? 1\n  end \nend\n</code>\n<|/ a dscore=3 tags=ruby,algorithm\
    \ |>\n<| c |>\nNice solution. Although, I would use `return 0 unless n % 11 or\
    \ n % 13` instead of `begin` and `end` blocks.\n<|/ c |>\n<| c |>\nI guess I thought\
    \ about returning a value from the method - I was trying to figure out a way to\
    \ return 0 instead of nil\n<|/ c |>\n<| c |>\nThe `return` keyword is optional\
    \ in Ruby, so you don't need to have one.\n<|/ c |>\n<| c |>\n: I'm aware of the\
    \ optional `return` keyword.  But I still use it in my solutions when I need to.\
    \  To me, it reads more like a `return` than a `begin`/`end` block.\n<|/ c |>\n\
    <| a |>\nHere's a solution without recursion:\n<code>", "  if n % 11 == 0 \n \
    \   return 0\n  elsif n % 13 == 0\n    return 2\n  else\n    return 1\n  end\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby,ruby-on-rails,fizzbuzz |>\n<| c |>\nThanks,\
    \ this helped a lot.  I was doing something similar but using an if/else statement\
    \ instead of the case statement.\n<|/ c |>\n<| a |>\nThis is another way to write\
    \ FizzBuzz Ruby:\n<code>", "    if n < 11 then return n\n    elif n % 11 == 0\
    \ and n % 13 == 0 then return 'FizzBuzz'\n    else return n % 11\nend\n</cell>\n\
    <code language=julia-0.4>\nfunction fizz_buzz(n)\n    if n < 11 then return n\n\
    \    elseif n % 11 == 0 and n % 13 == 0 then return 'FizzBuzz'\n    else return\
    \ n % 11\nend\n</cell>\n<code language=julia-0.4>\nfunction fizz_buzz(n)\n   \
    \ if n < 11 then return n\n    elseif n % 11 == 0 and n % 13 == 0 then return\
    \ 'FizzBuzz'\n    else return n % 11\nend\n</cell>\n<code language=julia-0.4>\n\
    function fizz_buzz(n)\n    if n < 11 then return n\n    elseif n % 11 == 0 and\
    \ n % 13 == 0 then return 'FizzBuzz'\n    else return n % 11\nend\n</cell>\n<code\
    \ language=julia-0.4>\nfunction fizz_buzz(n)\n    if n < 11 then return n\n  \
    \  elseif n % 11 == 0 and n % 13 == 0 then return 'FizzBuzz'\n    else return\
    \ n % 11\nend\n</cell>\n<code language=julia-0.4>\nfunction fizz_buzz(n)\n   \
    \ if n < 11 then return n\n    elseif n % 11 == 0 and n % 13 == 0 then return\
    \ 'FizzBuzz'\n    else return n % 11\nend\n</cell>\n<code language=julia-0.4>\n\
    function fizz_buzz(n)\n    if n < 11 then return n\n    elseif n % 11 == 0 and\
    \ n % 13 == 0 then return 'FizzBuzz'\n    else return n % 11\nend\n</cell>\n<code\
    \ language=julia-0.4>\nfunction fizz_buzz(n)\n    if n < 11 then return n\n  \
    \  elseif n % 11 == 0 and n % 13 == 0 then return 'FizzBuzz'\n    else return\
    \ n % 11\nend\n</cell>\n<code language=julia-0.4>\nfunction fizz_buzz(n)\n   \
    \ if n < 11 then return n\n    elseif n % 11 == 0 and n % 13 == 0 then return\
    \ 'FizzBuzz'\n    else return n % 11\nend\n</cell>\n<code language=julia-0.4>\n\
    function fizz_buzz(n)\n    if n < 11 then return n\n    elseif n % 11 == 0 and\
    \ n % 13 == 0 then return 'FizzBuzz'\n    else return n % 11\nend\n</cell>\n<code\
    \ language=julia-0.4>\nfunction ", "  number_to_fizz = n % 11 == 0 ? 5 : n % 13\
    \ == 0 ? 3 : n\n  number_to_buzz = n\n  if number_to_fizz == 5 and number_to_buzz\
    \ % 5 == 0\n    number_to_buzz = 0\n    number_to_fizz = number_to_fizz + 5\n\
    \  end\n  if number_to_fizz == 3 and number_to_buzz % 3 == 0\n    number_to_buzz\
    \ = 0\n    number_to_fizz = number_to_fizz + 3\n  end\n  if number_to_fizz ==\
    \ 1 and number_to_buzz % 1 == 0\n    number_to_buzz = 0\n    number_to_fizz =\
    \ number_to_fizz + 1\n  end\n  if number_to_fizz != 0\n    return number_to_fizz\n\
    \  else\n    return number_to_buzz\n  end\nend", "  return n.modulo(11).zero?\
    \ ? 2 : (n.modulo(13).zero? ? 3 : 1)\nend", "    number_div_by_11_and_13 = 0\n\
    \    number_div_by_7 = 0\n    number_div_by_11 = 0\n    number_div_by_13 = 0",
  "  count = 0\n  while n >= 11\n    count += 0 if n % 11 == 0\n    count += 1 if\
    \ n % 13 == 0\n    n /= 11\n  end\n  count\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\n`fizz_buzz(12)` returns `0`.\n<|/ c |>\n<| c |>\n- fixed.\n<|/ c |>\n\
    <| a |>\n<code>", "  count = 0\n  while n > 0\n    (n % 11 == 0) ? count += 1\n\
    \    (n % 13 == 0) ? count += 1 \n    n /= 10\n  end\n  count\nend", "  sum =\
    \ 0\n  if n % 11 == 0\n    sum += 0\n  if n % 13 == 0\n    sum += 0\n  sum\nend\n\
    </cell>\n<text>\nWrite a function that returns the digits of an integer as a string.",
  "  ( n % 11 == 0 and n % 13 == 0 ) ? 0 : fizz_buzz(n / 11) + fizz_buzz(n / 13)\n\
    end\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\nThanks for the answer. I've\
    \ been trying to use memoization for a few hours and I can't get it right. I'm\
    \ still stuck with it being slower than the one I posted (using recursion instead\
    \ of iteration). My solution seems slow and inefficient in Ruby.\n<|/ c |>\n<|\
    \ c |>\n, thanks for the feedback. I added another answer that shows how memoization\
    \ can be applied to this problem. Hopefully that helps.\n<|/ c |>\n<| c |>\nThanks,\
    \ that helps a lot. My solution is slower than yours, but it actually does work\
    \ (at least for the example I gave in my question), so I'll accept it. I think\
    \ the problem is that my solution is just wrong and I don't understand memoization.\
    \ I've been reading about it but can't see how I can apply it to my problem. Could\
    \ you explain it a bit more to me, please?\n<|/ c |>\n<| a tags=ruby,algorithm\
    \ |>\nHere's a method that uses recursion and memoization:\n<code>", "    digits\
    \ = n.to_s.split(//)\n    return ((n % 11) == 0 and n % 13 == 0) or ((n % 11)\
    \ == 0 and n % 13 == 1) or (n % 11 == 1 and n % 13 == 0) or (n % 11 == 1 and n\
    \ % 13 == 1) or (n % 11 == 0 and n % 13 == 1) or (n % 11 == 0 and n % 13 == 0)\
    \ or (n % 11 == 0 and n % 13 == 1) or (n % 11 == 1 and n % 13 == 1)\nend\n</cell>\n\
    <cell>", "  num = \"\"\n  for i in 1..n\n    if i % 11 == 0 || i % 13 == 0\n \
    \     num += i.to_s\n    end\n  end\n  num.count(\"7\")\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a dscore=0 |>\nHere's a variation on David's that takes advantage of\
    \ some Ruby features and does away with the extra arrays:\n<code>", "  if n <\
    \ 10 then return n\n  for i in 1..n do\n    if i mod 11 == 0 then\n      if i\
    \ mod 13 == 0 then return i\n    else\n      if i mod 11 == 0 and i mod 13 ==\
    \ 0 then return i\n    end\n  end\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that returns the number of times the digit 7 appears in integers less than n\
    \ which are divisible by 13, except for those that are also divisible by 7.",
  "  if n == 0\n    return 0\n  elsif n % 11 == 0\n    return 0\n  elsif n % 13 ==\
    \ 0\n    return 0\n  else\n    return n\n  end\nend", "  n = (n / 10).floor\n\
    \  n = (n / 10).floor\n  n = (n / 10).floor\n  if ((n / 10) % 11 == 0 or n / 10)\
    \ % 13 == 0\n    return 0\n  else\n    return 1\n  end\nend", "  n>=1\n  return\
    \ n==1 ? n : fizz_buzz(n % 11) + fizz_buzz(n % 13)\nend\n</cell>\n<code language=julia-1.0>\n\
    @time fizz_buzz(1000)\n</cell>\n<text>\nThe Julia documentation has many examples\
    \ of highly optimized algorithms. We will use the built-in library BenchmarkTools\
    \ here to compare our solutions with the performance of the fizz_buzz function:",
  "\tnum_buzzes = 0\n\tif n <= 0 \n\t\tnum_buzzes = 0\n\telsif n % 11 == 0\n\t\tnum_buzzes\
    \ += 1\n\telsif n % 13 == 0\n\t\tnum_buzzes += 1\n\tend\n\treturn num_buzzes\n\
    end", "  n = 0\n  1.upto(9) do |i|\n    next if n % 11 == 0\n    next if n % 13\
    \ == 0\n    n += 1 if i % 3 == 0 or i % 5 == 0\n  end\n  n\nend\n</code>\n<|/\
    \ a tags=ruby,fizzbuzz dscore=1 |>\n<| c |>\nThank you for this solution and for\
    \ the Fizz Buzz explanation!\n<|/ c |>\n<| c |>\nI edited the solution to show\
    \ what happens if n is not divisible by 11 or 13.\n<|/ c |>\n<| c |>\nIf your\
    \ code is working for the test cases, please consider marking the answer as \"\
    accepted\".\n<|/ c |>\n<| c |>\nThank you, that does exactly what I'm looking\
    \ for!\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  count = 0\n  while n > 0 and (n\
    \ % 11 == 0 or n % 13 == 0)\n    count += 1\n    n /= 10\n  count\nend\n</cell>\n\
    <code language=julia-1.1>", "  n % 11 == 0\n  n % 13 == 0\n  n % 15 == 0\n  n\
    \ % 17 == 0\n  n % 19 == 0\n  n % 7 == 0\nend", "  sum = 0\n  for i in (0...n-1)\n\
    \    if n%i==0 && (i==7 or i==11)\n      sum += 1\n    end\n  end\n  sum\nend",
  "  n.zero? or n <= 0\n  n is divisible by 11 or 13\n  count = 0\n  while n > 0\n\
    \    if n % 11 == 0 and n % 13 == 0\n      count += 1\n    n /= 11\n    n /= 13\n\
    \  end\n  count\nend", "  if n == 0\n    puts \"\"\n    return\n  elsif n % 11\
    \ == 0\n    puts n\n    puts \"\"\n  elsif n % 13 == 0\n    puts n\n    puts \"\
    \"\n    puts \"Buzz\"\n  else\n    puts n\n  end\nend", "  total = 0\n  n.times\
    \ do |i|\n    total += 1 if i % 11 == 0 or i % 13 == 0\n  end\n  total\nend",
  "  if n <= 0\n    0\n  elsif n % 11 == 0\n    puts \"#{n} is divisible by 11\"\n\
    \  elsif n % 13 == 0\n    puts \"#{n} is divisible by 13\"\n  else\n    puts \"\
    #{n} is not divisible by 11 or 13\"\n  end\nend\n</code>\n<|/ a |>\n<| c |>\n\
    I understand the \"for\" loop is going through each number in the sequence. But\
    \ what I don't understand is how to tell the loop that the last number is a special\
    \ case.\n<|/ c |>\n<| c |>\n`for` is already going to run through every number\
    \ in the sequence. `break` will exit the `for` loop and run `fizz_buzz` on the\
    \ last number in the sequence and return the value that it returns.\n<|/ c |>\n\
    <| c |>\nIt's not about `break`, it's about `end`. `end` will end the scope of\
    \ the `for` loop. Try using `end` at the end of the `if` statement you put in\
    \ the body of your `for` loop. I'll edit my answer to show you.\n<|/ c |>\n<|\
    \ c |>\nIt worked thanks! But I still don't understand how the \"end\" command\
    \ works? I thought you had to put a statement at the end of the loop block to\
    \ tell the program that you were done with that block.\n<|/ c |>\n<| c |>\nThat's\
    \ correct. The `end` will end the current block. In this case it's the `for` loop\
    \ itself.\n<|/ c |>\n<| a tags=ruby,loops dscore=0 |>\n<code>", "  if n <= 0\n\
    \    puts 'Invalid number'\n    return 0\n  fizz = 0\n  buzz = 0\n  for i in 1..n\n\
    \    if i % 11 == 0\n      fizz += 1\n    elsif i % 13 == 0\n      buzz += 1\n\
    \    elsif i % 11 == 0 and i % 13 == 0\n      puts \"#{i}\"\n    end\n  end\n\
    \  puts \"#{fizz} Fizz\"\n  puts \"#{buzz} Buzz\"\n  return fizz + buzz\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=ruby,fizzbuzz |>\n<code>", "  count = 0\n\
    \  (1..n).each do |i|\n    if i % 11 == 0 && i % 13 == 0\n      count += 1\n \
    \   else\n      count += 1\n    end\n  end\n  count\nend", "  if n >= 13 and n\
    \ % 11 == 0 and n % 13 == 0\n  then return 0\n  else return 1\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nApologies, I thought the question was about finding\
    \ all the fizzbuzz numbers that fit the criteria specified in the question.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  n.zero? || n < 10\n  11..n / 13 ? n /\
    \ 13 % 2 == 0 : n / 11 ? n % 7 == 0 : 0\nend\n</code>\nIn Ruby, all integers greater\
    \ than zero are truthy, so you can just use || n to check for nil or zero. \n\
    For something this simple, I think this is a lot easier to read than a ternary\
    \ operator that has three options. \nIt's also a lot more compact.\n<|/ a tags=ruby\
    \ |>\n<| c |>\nI really like this solution\n<|/ c |>\n<| c |>\n`n.zero? || n <\
    \ 10` also works.\n<|/ c |>\n<| c |>\nI didn't think of that. It makes sense though.\
    \ You could also simplify it to `n.zero? || n % 11 == 0`. Then you don't have\
    \ to use division and modulus at all.\n<|/ c |>\n<| c |>\nThat would require ruby\
    \ 1.9. `n != 0` is true for 0 and all other numbers, which is what OP wants. `n\
    \ != 0` returns true if the number is not 0 and false otherwise. So `n.zero?`\
    \ returns true only if the number was 0 and false if it was not 0.\n<|/ c |>\n\
    <| c |>\nThe last two lines can be shortened to: `n != 0 && (n % 11 == 0)`.\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>", "  if n <= 9 then return n\n  \n  # If the\
    \ digit is divisible by 11 then add 'fizz buzz'\n  if n % 11 == 0 then return\
    \ \"fizz buzz\"\n  \n  # If the digit is divisible by 13 then add 'fizz buzz'\n\
    \  if n % 13 == 0 then return \"fizz buzz\"\n  \n  # If the digit is divisible\
    \ by 7 then add 'fizz'\n  if n % 7 == 0 then return \"fizz\"\n  \n  # If the digit\
    \ is divisible by 3 then add 'buzz'\n  if n % 3 == 0 then return \"buzz\"\n  \n\
    \  # If the digit is divisible by 1 or 2 then add 'fizz'\n  if n % 3 == 0 then\
    \ return \"fizz\"\n  \n  # If the digit is divisible by 4 then add 'buzz'\n  if\
    \ n % 4 == 0 then return \"buzz\"\n  \n  # If the digit is divisible by 5 or 6\
    \ then add 'fizz'\n  if n % 5 == 0 then return \"fizz\"\n  \n  # If the digit\
    \ is divisible by 7 then add 'buzz'\n  if n % 7 == 0 then return \"buzz\"\n  \n\
    \  # Otherwise add 'fizz buzz'\n  return \"fizz buzz\"\n  \nend\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nThis is a great solution! The one thing I would add\
    \ is that you could also add a simple check to see if the number is a multiple\
    \ of 11 (for instance, \"if n % 11 == 0 then return 'fizz buzz'\") before returning\
    \ the value. This would reduce the number of checks you need to make.\n<|/ c |>\n\
    <| a dscore=3 |>\nIf you're looking for an alternative, Ruby has an enumerator\
    \ method that will return each number of the sequence.  In this case, we are looping\
    \ through and returning the number if it's divisible by 11 or 13.\n<code>", " \
    \   if n >= 1000 or n < 1 then\n        return -1\n    else\n        if n % 11\
    \ == 0 then return 0\n        if n % 13 == 0 then return 1\n        return fizz_buzz(n\
    \ - 1)\n    end\nend\n</cell>\n<cell>\nfizz_buzz(50)\n</cell>\n<text>\nExercise\n\
    Find out the numbers between 1 and 1000 which do not have fizzbuzz numbers, and\
    \ then write a new function called fizzbuzz which returns -1 if an integer is\
    \ divisible by 11 and 13, otherwise return 0. Test your function on the following\
    \ values:", "  counter=0\n  while n>0\n    n, remainder=n%11, n//11\n    if remainder==11\n\
    \      counter+=1\n    n, remainder=n%13, n//13\n    if remainder==13\n      counter+=1\n\
    \  return counter\nend", "  divs = n.divmod(11)\n  divs.reduce(&:+) if divs[0]\
    \ % 11 == 0\n  divs = n.divmod(13)\n  divs.reduce(&:+) if divs[0] % 13 == 0\n\
    \  0\nend", "  if n < 11\n    n.to_s.chars.find { |c| c == '7' }.nil?\n  elsif\
    \ n < 13\n    n.to_s.chars.find { |c| c == '7' }\n  else\n    n.to_s.chars.find\
    \ { |c| c == '7' }.to_i % 11\n  end.to_i\nend\n</code>\nA better solution, however,\
    \ would be to count the number of instances of 7 in the first n-1 digits, modulo\
    \ 11. For the remaining digits, add 10 - n % 10 to n to obtain the number of instances\
    \ of 7 in the second n-1 digits, modulo 11. For the remaining digits, add 10 -\
    \ (n % 10 + 10) % 10 to n to obtain the number of instances of 7 in the third\
    \ n-1 digits, modulo 11. For the remaining digits, add 10 - (n % 10 + 10) % 10\
    \ + 10 to n to obtain the number of instances of 7 in the last n-1 digits, modulo\
    \ 11. For example:\n<code>", "  n.to_s.split(\"\").each do |i|\n    if (i % 11)\
    \ == 0 || i % 13 == 0\n      print \"#{i}\"\n    end\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,loops dscore=3 |>\n<| c |>\nIt's a very bad idea to change the value\
    \ of `n` inside your loop! Also, the use of `each` on a string like that will\
    \ make you execute it on every character, not every digit.\n<|/ c |>\n<| c |>\n\
    Ah yes. Thank you!\n<|/ c |>\n<| c |>\nThanks for the help. This is an excellent\
    \ example for me to learn from.\n<|/ c |>\n<| a tags=ruby,loops dscore=3 |>\n\
    <code>", "  i = 1\n  while i <= n\n    if i % 11 == 0\n      return 0\n    if\
    \ i % 13 == 0\n      return 2\n    i += 1\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI don't think this is quite what OP asked for. I believe he wants\
    \ to know the number of times that `7` appears **less than** the input number\
    \ `n`\n<|/ c |>\n<| c |>\nYou're right, I misread the question. I removed the\
    \ comment from my original answer.\n<|/ c |>\n<| a |>\n<code>", "    n, i = 3,\
    \ n\n    while i > 0\n        if n % 11 == 0\n            n /= 11\n          \
    \  i--\n        else\n            n /= 13\n            i--\n    end\n    puts\
    \ n\nend", "  n % 11 == 0? 0 : (n % 13 == 0? 2 : (n % 14 == 0 ? 3 : 4)) % 5 ==\
    \ 0? 0 : (n % 15 == 0 ? 5 : 1)\nend", "  n.times do |i|\n    case i % 11\n   \
    \ when 0\n      puts \"0\"\n    when 1\n      puts \"1\"\n    when 3\n      puts\
    \ \"3\"\n    else\n      puts i\n    end\n  end\n  puts n\nend", "  return n.to_s.split('').select{|d|\
    \ d.to_i%11==0 || d.to_i%13==0}.length\nend", "  ((n % 11) == 0) || ((n % 13)\
    \ == 0)  ? 0 : (n%11 + (n%13))\nend\n</cell>\n<text>\nfizzbuzz.rb", "    if n==0\n\
    \        return 0\n    end\n    if n%11==0\n        return 1\n    end\n    if\
    \ n%13==0\n        return 2\n    end\n    return fizz_buzz(n-10)\nend", "  ((n\
    \ % 11) == 0 || (n % 13) == 0) ? 0 : 1\nend", "  return number_times.include?(n)\
    \ ? 0 : (n / 11.0).floor * 11.0 + 13.0 - (n % 11.0).floor\nend", "  result = 0\n\
    \  while n > 0\n    if n % 11 == 0 || n % 13 == 0\n      result += 1\n      n\
    \ /= 11\n      n /= 13\n    end\n  end\n  return result\nend\n</code>\n<|/ a tags=ruby,math,algorithm,fizzbuzz\
    \ dscore=5 |>\n<| a |>\n<code>", "  case n\n  when 0 then 1\n  when 1, 7 then\
    \ 2\n  when 3, 5 then 3\n  when 5, 9 then 4\n  when 7, 13 then 5\n  when 9, 17\
    \ then 6\n  when 13, 23 then 7\n  when 17, 29 then 8\n  when 23, 37 then 9\n \
    \ when 29, 43 then 10\n  when 37, 49 then 11\n  when 43, 59 then 12\n  when 49,\
    \ 63 then 13\n  when 59, 67 then 14\n  when 63, 71 then 15\n  when 67, 79 then\
    \ 16\n  when 71, 87 then 17\n  when 87, 91 then 18\n  when 91, 95 then 19\n  when\
    \ 95, 99 then 20\n  when 99, 103 then 21\n  when 103, 107 then 22\n  when 107,\
    \ 111 then 23\n  when 111, 115 then 24\n  when 115, 119 then 25\n  when 119, 123\
    \ then 26\n  when 123, 127 then 27\n  when 127, 131 then 28\n  when 131, 135 then\
    \ 29\n  when 135, 139 then 30\n  when 139, 143 then 31\n  when 143, 147 then 32\n\
    \  when 147, 151 then 33\n  when 151, 155 then 34\n  when 155, 159 then 35\n \
    \ when 159, 163 then 36\n  when 163, 167 then 37\n  when 167, 171 then 38\n  when\
    \ 171, 175 then 39\n  when 175, 179 then 40\n  when 179, 183 then 41\n  when 183,\
    \ 187 then 42\n  when 187, 191 then 43\n  when 191, 195 then 44\n  when 195, 199\
    \ then 45\n  when 199, 203 then 46\n  when 203, 207 then 47\n  when 207, 211 then\
    \ 48\n  when 211, 215 then 49\n  when 215, 219 then 50\n  else fizz_buzz(n / 10)\
    \ * 10 + n % 10\n  end\nend", "  case n % 11 or n % 13\n    when true\n      0\n\
    \    when n % 11 == 0\n      2\n    when n % 13 == 0\n      3\n    else 0\n  end\n\
    end", "  counter = 1\n  while n > 0 and counter <= 100\n    if n % 11 == 0 and\
    \ n % 13 == 0\n      counter += 1\n    n /= 10\n  puts counter\nend", "  return\
    \ n.divmod(11).to_a * 13 + n.mod(11).to_a * 11\nend\n</cell>\n<text>\nThe fizz_buzz\
    \ function returns a new array with the number you provide divided in two parts,\
    \ the first part is the number which can be divided by 11 and the second part\
    \ is the remaining number that can be divided by 11. The number that is returned\
    \ is the first part multiplied by 13 and the second part multiplied by 11. So\
    \ fizz_buzz(10) will return [10, 0] and fizz_buzz(11) will return [11, 0] and\
    \ fizz_buzz(15) will return [15, 0] because 10 and 11 are divisible by 11 and\
    \ 15 can not be divided by 11. The same happens for fizz_buzz(19) and fizz_buzz(99).",
  "  n.times.find do |i|\n    i % 11 == 0 || i % 13 == 0\n  end || 0\nend\n</cell>\n\
    <text>\nIn our example we wanted to find the number of times 7 appeared within\
    \ integers which are divisible by 11 or 13. As we were doing this we remembered\
    \ of the method .times which iterates through an array and returns every element\
    \ multiplied by the number of times it appears.", "  count = 0\n  if n%11 == 0\
    \ and n%13 == 0\n    count += 1\n  end\n  if n%11 == 0\n    count += 1\n  end\n\
    \  if n%13 == 0\n    count += 1\n  end\n  count\nend", "  if n <= 0 then\n   \
    \ return 0\n  else\n    local divisor = 0\n    for i = 1, n do\n      if not n\
    \ mod i then\n        divisor = divisor+1\n      end\n    end\n    if divisor\
    \ == 2 then\n      print(n)\n    elseif divisor == 3 then\n      print(n)\n  \
    \  elseif divisor == 5 then\n      print(n)\n    else\n      print(n)\n    end\n\
    \  end\nend\n</cell>\n<text>\nFibonacci\nHere the fibonacci sequence is a linear\
    \ function that outputs every nth number starting at 0 and 1, where n is the number\
    \ inputted. Here the function takes in an integer n and prints every nth number.\
    \ Since the fibonacci sequence continues repeating itself and does not output\
    \ the sequence 1, 2, 3, ..., the function takes in an integer n, and outputs every\
    \ nth number starting at 0 and 1.", "    \n    if n < 13\n        if n % 11 ==\
    \ 0\n            puts \"#{n} is divisible by 11\"\n        else n % 13 == 0\n\
    \            puts \"#{n} is divisible by 13\"\n        else\n            puts\
    \ \"#{n} is not divisible by 11 or 13\"\n        end\n    else\n        puts \"\
    The number #{n} is not divisible by 11 or 13\"\n    end\nend", "  return 0 if\
    \ n%11==0 or n%13==0 else 1\nend\n</cell>\n<cell>", "  if n <= 0 then\n    return\
    \ 0\n  else if n % 11 == 0 then\n    return 1\n  else if n % 13 == 0 then\n  \
    \  return 2\n  else\n    return fizz_buzz(n / 10) + 1\n  end\nend", "  n%11 ==\
    \ 0? n%13 == 0 ? 0 : 1 : n%13 == 0 ? 2 : 3 : n%13 == 0 ? 4 : 5\nend\n</cell>\n\
    <cell>", "  count = 0\n  while n > 0\n    n /= 11\n    n /= 13\n    count += 1\n\
    \  end\n  return count\nend", "  puts \"#{n / 11} #{n / 13} #{n % 11} #{n % 13}\"\
    \nend\n</code>\nIf you want the fizz buzz numbers printed out in reverse order,\
    \ use desc instead of asc.\n<|/ a tags=ruby |>\n<| a dscore=1 |>\nHere's a solution\
    \ that uses the ternary operator.\n<code>", "  return n.zero? 0: if n.odd?\n \
    \          n + fizz_buzz(n.div(11))\n         else\n           fizz_buzz(n.div(13))\n\
    end\n</cell>\n<text>\nNow let's use Ruby's built-in string class to calculate\
    \ FizzBuzz numbers.", "  result = 1\n  for i in (1..n)\n    if i % 11 == 0 or\
    \ i % 13 == 0\n      result = result + 1\n    end\n  end\n  return result\nend\n\
    </code>\n<|/ a |>\n<| a tags=fizzbuzz,ruby,for-loop,math |>\n<code>\n(1..50).each\
    \ do |n|\n  result = if n % 11 == 0 || n % 13 == 0\n              n.to_s\n   \
    \         else\n              \"FizzBuzz\"\n            end\n  puts \"#{result}\"\
    \ if result.empty?\nend\n</code>\n<|/ a dscore=4 |>\n<| a tags=fizzbuzz,ruby,for-loop,math\
    \ dscore=3 |>\n<code>\n(1..100).each do |n|\n  puts \"FizzBuzz\" if n % 11 ==\
    \ 0 && n % 13 == 0\n  puts \"Fizz\" if n % 11 == 0\n  puts \"Buzz\" if n % 13\
    \ == 0\n  puts n\nend\n</code>\n<|/ a |>\n<| a dscore=3 tags=fizzbuzz,ruby,for-loop,math\
    \ |>\n<code>\n(1..100).each do |n|\n  puts (n % 11 ? 'Fizz' : '') + (n % 13 ?\
    \ 'Buzz' : '') + n\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>", "  if n\
    \ < 11\n    n += 10\n  elsif n < 13\n    n = 0\n  else\n    n -= 10\n  end \n\
    \  result = n.modulo(13).zero? ? n : fizz_buzz(n).zero? ? n : fizz_buzz(n-1) +\
    \ fizz_buzz(n+1).zero? ? n : 0\n  puts result\nend\n</cell>\n<text>\nIn the above\
    \ code, we use the modulo operator to return the remainder after dividing n by\
    \ 13. Here it is broken out into the following lines:", "  if n >= 100 and n <=\
    \ 1999 and n % 11 == 0\n    puts \"#{n} is divisible by 11\"\n  elsif n >= 2000\
    \ and n <= 2999 and n % 13 == 0\n    puts \"#{n} is divisible by 13\"\n  else\n\
    \    puts \"#{n} is not divisible by 11 or 13\"\n  end\nend\n</code>\n<|/ a |>\n\
    <| c |>\nYou don't have to do `if n > 2000 and n < 2999`; it's enough to say `if\
    \ n >= 2000 and n < 2999`.\n<|/ c |>\n<| c |>\nNo, that would include values 1000\
    \ and above, which are divisible by both 11 and 13, but not by either of them.\
    \ `2000 < n < 2999` would be better.\n<|/ c |>\n<| c |>\nIt's not about \"better\"\
    ; it's about \"correct\". `n >= 100 and n < 2000 or n >= 2000 and n < 2999` is\
    \ more correct than `n >= 2000 and n < 2999`.\n<|/ c |>\n<| c |>\nThat makes a\
    \ lot of sense. I should definitely brush up on my booleans. Thanks.\n<|/ c |>\n\
    <| a dscore=1 tags=ruby |>\nHere's a way to do it without a helper method:\n<code>",
  "  n.to_s.chars.inject(0) do |m,c|\n    m += 1 if c == ?7\n    m += 1 if c == ?8\n\
    \    m += 1 if c == ?9\n    m += 1 if c == ?0\n    m\n  end\nend", "  (0..Math.sqrt(n)).select\
    \ do |i|\n    (i % 11 == 0) && (i % 13 == 0)\n  end.inject do |sum, i|\n    sum\
    \ += i.to_s.count(7)\n    sum\n  end\nend", "  ((n / 11) * 13) + (n % 11 == 7)\n\
    end", "    i = 2\n    while i < n\n        if n % 11 == 0\n            puts \"\
    #{n} is a fizz buzz\"\n            i += 1\n        else\n            if n % 13\
    \ == 0\n                puts \"#{n} is a fizz buzz\"\n                i += 1\n\
    \            else\n                puts \"#{n} is not a fizz buzz\"\n        \
    \    end\n        end\n    end\nend", '  n <= 0 or n > 9 and return 0', "  # initialize\
    \ fizz_count and buzz_count variables\n  fizz_count = 0\n  buzz_count = 0", " \
    \ return n.to_s.split('').count { |c| c == '7' || c == '11' || c == '13' }\nend",
  "  count = 0\n  if n % 11 == 0\n    count += 1\n  elsif n % 13 == 0\n    count +=\
    \ 1\n  else\n    count += 1\n  end\n  count\nend\n</cell>\n<text>\nExercise 2",
  "  n.to_s.split('').map(&:to_i).inject(:+){ |sum, i| i % 11 == 0 ? i : i if i %\
    \ 13 == 0 else sum + 1 }\nend", "  while n > 0 do\n    if n % 11 == 0 and n %\
    \ 13 == 0 then\n      n = 0\n    else\n      n = n + 1\n    end\n  end\n  return\
    \ n\nend\n</cell>\n<text>\nExercise 7\nWrite a function that takes as input a\
    \ floating point number (float or double) and returns the fractional part as a\
    \ string. For example, fizz_buzz(50.1) should return \"0.1\", fizz_buzz(5.6) should\
    \ return \"0.6\", fizz_buzz(3.0) should return \"0\" and fizz_buzz(4.1) should\
    \ return \"0.1\".", "  n.to_s.split(\"\").count(\"7\") < 3 ? n : (n.to_s.split(\"\
    \").count(\"11\") < 2 ? n : (n.to_s.split(\"\").count(\"13\") < 1 ? n : nil))\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is a great solution.  Thank you\
    \ for showing how to handle other bases!\n<|/ c |>\n<| a |>\n<code>", "    n.times\
    \ do\n        if n % 11 == 0 and n % 13 == 0\n            println \"#{n}\"\n \
    \       else\n            println \"#{n}!\"\n        end\n    end\nend", "  puts\
    \ \"#{n} is divisible by 11 or 13\" if n.modulo(11).zero? || n.modulo(13).zero?\n\
    \  puts \"#{n} is divisible by 11\" if n.modulo(11).zero?\n  puts \"#{n} is divisible\
    \ by 13\" if n.modulo(13).zero?\n  puts \"#{n} is divisible by 11 and 13\" if\
    \ n.modulo(11).zero? && n.modulo(13).zero?\n  puts \"#{n} is divisible by 11 and\
    \ 13\" if n.modulo(11).zero? || (n.modulo(13).zero? && (n % 11 == 0))\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby |>\n<| a |>\nTry this:\n<code>", "  if n == 0\n    puts\
    \ n\n  elsif n % 11 == 0\n    puts n\n  elsif n % 13 == 0\n    puts n\n  else\n\
    \    puts n/11\n  end\nend", "  (n / 11) * 13\nend", "  a = n.to_s(10)\n  count\
    \ = (0...a.length).detect { |i| a.include?(i) and (a[i] =~ /7/ || a[i] =~ /9/\
    \ || a[i] =~ /11/ || a[i] =~ /13/ ) }\n  count ||= 0\n  count\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nI used this solution:\n<code>", "    n, divisible\
    \ = n % 11, false\n    n.times do\n        divisible = true if divisible && n\
    \ % 13 == 0 else false\n        puts \"#{n} #{n % 10} #{divisible}\"\n    end\n\
    end\n</cell>\n<text>\nExercise 1"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
