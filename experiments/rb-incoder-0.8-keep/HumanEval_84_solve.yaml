name: HumanEval_84_solve
language: rb
prompt: "# Given a positive integer N, return the total sum of its digits in binary.\n\
  # Example\n# For N = 1000, the sum of digits will be 1 the output should be \"1\"\
  .\n# For N = 150, the sum of digits will be 6 the output should be \"110\".\n# For\
  \ N = 147, the sum of digits will be 12 the output should be \"1100\".\n# Variables:\n\
  # @N integer\n# Constraints: 0 \u2264 N \u2264 10000.\n# Output:\n# a string of\
  \ binary number\ndef solve(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n\
  \    candidate = method(:solve)\n    assert_equal(\"1\", candidate.call(1000))\n\
  \    assert_equal(\"110\", candidate.call(150))\n    assert_equal(\"1100\", candidate.call(147))\n\
  \    assert_equal(\"1001\", candidate.call(333))\n    assert_equal(\"10010\", candidate.call(963))\n\
  \  end\nend\n"
completions: ["  s = ''\n  n.to_s(2).chars.each {|c| s = s + c }\n  return s\nend",
  "  sum = 0\n  while n != 0\n    sum += n % 2\n    n /= 2\n  end\n  return sum.to_s\n\
    end", "    return n.to_s(2).reverse.scan(/../).map{|s| s.sum}.join(\"\")\nend\n\
    </cell>\n<code language=julia-1.0>\n@time solve(1); @time solve(2); @time solve(3);\
    \ @time solve(4); @time solve(5); @time solve(6); @time solve(7); @time solve(8);\
    \ @time solve(9); @time solve(10); @time solve(11);\n</cell>\n<code language=julia-1.0>\n\
    @time solve(1); @time solve(2); @time solve(3); @time solve(4); @time solve(5);\
    \ @time solve(6); @time solve(7); @time solve(8); @time solve(9); @time solve(10);\
    \ @time solve(11); @time solve(12);\n</cell>\n<code language=julia-1.0>\n@time\
    \ solve(1); @time solve(2); @time solve(3); @time solve(4); @time solve(5); @time\
    \ solve(6); @time solve(7); @time solve(8); @time solve(9); @time solve(10); @time\
    \ solve(11); @time solve(12); @time solve(13); @time solve(14);\n</cell>\n<code\
    \ language=julia-1.0>\n@time solve(1); @time solve(2); @time solve(3); @time solve(4);\
    \ @time solve(5); @time solve(6); @time solve(7); @time solve(8); @time solve(9);\
    \ @time solve(10); @time solve(11); @time solve(12); @time solve(13); @time solve(14);\
    \ @time solve(15); @time solve(16);\n</cell>\n<code language=julia-1.0>\n@time\
    \ solve(1); @time solve(2); @time solve(3); @time solve(4); @time solve(5); @time\
    \ solve(6); @time solve(7); @time solve(8); @time solve(9); @time solve(10); @time\
    \ solve(11); @time solve(12); @time solve(13); @time solve(14); @time solve(15);\
    \ @time solve(16); @time solve(17);\n</cell>\n<code language=julia-1.0>\n@time\
    \ solve(1); @time solve(2); @time solve(3); @time solve(4); @time solve(5); @time\
    \ solve(6); @time solve(7); @time solve(8); @time solve(9); @time solve(10); @time\
    \ solve(11); @time solve(12); @time solve(13); @time solve(14); @time solve(15);\
    \ @time ", "  n.to_s.split('').inject(0,:+).to_s\nend\n</code>\n<|/ a tags=algorithm,ruby,string\
    \ |>\n<| c |>\nI think this solution is great because it doesn't require string\
    \ conversion (which I suspect could be slower), and it doesn't use any loops.\
    \  This is also my first Stack Overflow post, so I appreciate your patience.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's another way to do it without using any loops.\n\
    <code>", "    i = 0\n    while i < n.to_s.length\n        if n.to_s[i].to_s.length\
    \ == 2\n            sum += n.to_s[i] + n.to_s[i + 1]\n            i += 1\n   \
    \     end\n        i += 1\n    return sum.to_s\nend\n</cell>\n<text>\n12. N-th\
    \ Permutation of a given string\nProblem\nGiven an input string, rearrange the\
    \ characters in such a way that\nthe new string will be the shortest one.\nNote:\
    \ If the input string is a palindrome then the output must be the same string\
    \ but in reverse order\ne.g if input string is \"kayak\" then output will be \"\
    gkay.\"\nVariables\n@inputString string\nConstraints: 0 \u2264 inputString.length\
    \ < 100\n0 \u2264 inputString[i] \u2264 inputString.length.\n0 \u2264 i \u2264\
    \ inputString.length.", "  n = n.to_s(2)\n  s = n.to_i(2)\n  s = 0.step(s,1) do\
    \ |n|\n    n = n.to_s(2)\n    s = (s.to_i(2) + n.to_i(2)) % 2\n  end\n  return\
    \ s.to_s(2)\nend", "  (0...n).reduce(:+)\nend", "    arr = n.to_s(2)\n    result\
    \ = \"\"\n    len = arr.length\n    \n    i = 0\n    while i < len\n        if\
    \ len < 2\n            result += arr[i].to_s(2)\n            i += 1\n        \
    \    len -= 1\n        else\n            if arr[i] == \"1\"\n                result\
    \ += \"0\"\n                i += 1\n                len -= 1\n            else\n\
    \                result += \"1\"\n                i += 1\n                len\
    \ -= 1\n        end\n    end\n    return result\nend", "  \nend", "  return n.to_s(2).reverse.scan(/../).map\
    \ { |i| i * 2 }.join(\"\")\nend", "  a = n.to_s(2)\n  a.reverse.each_cons(2) do\
    \ |a1, a2|\n    if a1 == \"0\"\n      a2 = a2.to_s(2)\n      a2.reverse\n    end\n\
    \    break if a1 != \"0\"\n  end\n  a\nend\n</cell>\n<code language=julia-1.0>\n\
    @time solve($N);\n</cell>\n<code language=julia-1.0>", "    count = 0\n    result\
    \ = \"\"\n    \n    while n > 0\n        digit = n % 10\n        n /= 10\n   \
    \     \n        count += 1\n        result = digit.to_s + result\n        \n \
    \       if count >= 3\n            count = 0\n        \n    end\n    \n    return\
    \ result\nend\n</cell>\n<code language=julia-1.5>\nsolve(0)\n</cell>\n<code language=julia-1.5>\n\
    solve(2)\n</cell>\n<code language=julia-1.5>\nsolve(100)\n</cell>\n<code language=julia-1.5>\n\
    solve(147)\n</cell>\n<code language=julia-1.5>\nsolve(93)\n</cell>\n<code language=julia-1.5>\n\
    solve(93)\n</cell>\n<code language=julia-1.5>\nsolve(33)\n</cell>\n<code language=julia-1.5>\n\
    solve(123)\n</cell>\n<code language=julia-1.5>\nsolve(123)\n</cell>\n<code language=julia-1.5>\n\
    solve(123)\n</cell>\n<code language=julia-1.5>\nsolve(321)\n</cell>\n<code language=julia-1.5>\n\
    solve(969)\n</cell>\n<code language=julia-1.5>\nsolve(1234)\n</cell>\n<code language=julia-1.5>\n\
    solve(1347)\n</cell>\n<code language=julia-1.5>\nsolve(1347)\n</cell>\n<code language=julia-1.5>\n\
    solve(1347)\n</cell>\n<code language=julia-1.5>\nsolve(963)\n</cell>\n<code language=julia-1.5>\n\
    solve(963)\n</cell>\n<code language=julia-1.5>\nsolve(1137)\n</cell>\n<code language=julia-1.5>\n\
    solve(963)\n</cell>\n<code language=julia-1.5>\nsolve(963)\n</cell>\n<code language=julia-1.5>\n\
    solve(963)\n</cell>\n<code language=julia-1.5>\nsolve(963)\n</cell>\n<code language=julia-1.5>\n\
    solve(963)\n</cell>\n<code language=julia-1.5>\nsolve(963)\n</cell>\n<code language=julia-1.5>\n\
    solve(963)\n</cell>\n<code language=julia-1.5>\nsolve(963)\n</cell>\n<code language=julia-1.5>\n\
    solve(963)\n</cell>\n<code language=julia-1.5>\nsolve(963)\n</cell>\n<code language=julia-1.5>\n\
    solve(963)\n</cell>\n<code language=julia-1.5>\nsolve(963)\n</cell>\n<code language=julia-1.5",
  "  # TODO: write your code here\n  return '1'\nend", "  return n.to_s(2).reverse.gsub(/(.)(\\\
    d)/, '\\1\\2').\n           reverse.gsub(/(.)\\1/, '\\1').reverse\nend", "  sum\
    \ = 0\n  (1..n).each do |i|\n    sum += i.to_s(2)\n  end\n  sum.to_s(2)\nend",
  "  str = \"\"\n  while n != 0\n    str = str.to_s + n.to_s.to_s(2)\n    n /= 10\n\
    \  end\n  str\nend", "  return \"1\" + n.to_s.reverse.gsub(/(.{7}|\\Z)/, '0'*7).reverse\n\
    end", "  sum = 0\n  num = \"0#{n.to_s(2)}\".reverse\n  while num.length >= 1\n\
    \    sum += num.slice!(0...1).to_i(2).to_s\n    num = num.slice!(0...1)\n  end\n\
    \  return sum\nend\nprint(solve(1476))", "  a = n.to_s(2)\n  sum = \"\"\n  a.chars.each\
    \ { |c| sum += c.to_s(2) }\n  return sum\nend", "  s = n.to_s\n  i = -1\n  result\
    \ = []\n  while (i<s.length-1)\n    begin = if s[i] == '1'\n      i += 1\n   \
    \   0\n    elsif s[i] == '0'\n      i += 1\n      1\n    elsif s[i] == '1'\n \
    \     i += 1\n      2\n    end\n    result << (begin.to_s(2))\n  end\n  return\
    \ result.join\nend", end, "  result = ''\n  while n != 0\n    digit = n % 10\n\
    \    result += '1' if digit == 0 else '0'\n    n = n / 10\n  end\n  return result\n\
    end", "  n = n.to_i\n  s = n.to_s.reverse\n  s = s % 2\n  s = s.to_i(2) * (1/2)\n\
    \  s = \"0\" + (s+1)\n  n = n.to_i\n  s = n.to_s.reverse\n  s = s % 2\n  s = s.to_i(2)\
    \ * (1/2)\n  s = \"1\" + (s+1)\n  s.reverse\n  s.reverse\n  s = s.to_i(2) * (1/2)\n\
    \  s = \"0\" + (s+1)\n  s.reverse\n  s.reverse\n  s = s.to_i(2) * (1/2)\n  s =\
    \ \"0\" + (s+1)\n  s.reverse\n  s.reverse\n  s = s.to_i(2) * (1/2)\n  s = \"1\"\
    \ + (s+1)\n  s.reverse\n  s.reverse\n  s = s.to_i(2) * (1/2)\n  s = \"0\" + (s+1)\n\
    \  s.reverse\n  s.reverse\n  s = s.to_i(2) * (1/2)\n  s = \"0\" + (s+1)\n  s.reverse\n\
    \  s.reverse\n  s = s.to_i(2) * (1/2)\n  s = \"1\" + (s+1)\n  s.reverse\n  s.reverse\n\
    \  s = s.to_i(2) * (1/2)\n  s = \"0\" + (s+1)\n  s.reverse\n  s.reverse\n  s =\
    \ s.to_i(2) * (1/2)\n  s = \"0\" + (s+1)\n  s.reverse\n  s.reverse\n  s = s.to_i(2)\
    \ * (1/2)\n  s = \"1\" + (s+1)\n  s.reverse\n  s.reverse\n  s = s.to_i(2) * (1/2)\n\
    \  s = \"0\" + (s+1)\n  s.reverse\n  s.reverse\n  s = s.to_i(2) * (1/2)\n  s =\
    \ \"0\" + (s+1)\n  s.reverse\n  s.reverse\n  s = s.to_i(2) * (1/2)\n  s = \"1\"\
    \ + (s+1)\n  s.reverse\n  s.reverse\n  s = s.to_i(2) * (1/2)\n  s = \"0\" + (s+1)\n\
    \  s.reverse\n  s.reverse\n  s = s.to_i(2) * (1/2)\n  s = \"0\" + (s+1)\n  s.reverse\n\
    \  s.reverse\n  s = s.to_i(2) * (1/2)\n  s = \"1\" + (s+1)\n  s.reverse\n  s.reverse\n\
    \  s = s.to_i(2) * (1/2)\n  s = \"0\" + (s+1)\n  s.reverse\n  s.reverse\n  s =\
    \ s.to_i(2) * (1/2)\n  s = \"0\" + (s+1)\n  s.reverse\n  s.reverse\n  s = s.to_i(2)\
    \ * (", "    # write your code here\n    binary = \"\"\n    digits = \"\"\n  \
    \  i = 1\n    while n >= i:\n        digits = digits + str(n % 2)\n        n =\
    \ n / 2\n        i = i + 1\n    binary = binary + digits\n    return binary",
  "  num = []\n  tmp = n.to_s(2)\n  for i in 0...(tmp.length-1)\n    num.push(tmp[i])\n\
    \  \n  res = \"\"\n  for i in 0...num.length-1\n    res = res + num[i]\n  end\n\
    \  return res\nend\n</cell>\n<code language=julia-1.5>\nsolve(300)\n</cell>\n\
    <code language=julia-1.5>", "    num = 0\n    string = \"\"\n    while n > 0\n\
    \        num = num * 2 + n % 10\n        n /= 10\n        string += num.to_s(2)\n\
    \    end", "  # write your code here\n  return n.to_s(2).reverse.gsub(/.(?=.)/,'0').inject(:+)\n\
    end", "    binary = n.to_s(2)\n    binary_count = binary.count(\"1\")\n    return\
    \ binary_count.to_s\nend", "  sum = ''\n  x = n\n  while x > 0\n    sum = sum\
    \ + (x.to_s + '1' * (x % 2 != 0))\n    x = x >> 1\n  end\n  sum\nend", "  num\
    \ = \"1\" + n.to_s(2).reverse\n  sum = 0\n  for i in num\n    sum += i.to_i\n\
    \  end\n  sum = sum.to_s(2).reverse\n  sum.chars.to_a.map { |char| char.to_i }\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,ruby |>\nHere are several\
    \ ways to do it. The key is to use recursion:\n<code>", "  res = \"1\"\n  while\
    \ n > 0\n    res = \"0#{res}#{n % 2 == 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" :\
    \ \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ?\
    \ \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n /\
    \ 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"\
    }#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" :\
    \ \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ?\
    \ \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n /\
    \ 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"\
    }#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" :\
    \ \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ?\
    \ \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n /\
    \ 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"\
    }#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" :\
    \ \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ?\
    \ \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n /\
    \ 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"\
    }#{n / 2 > 0 ? \"1\" : \"0\"}#{n / 2 > 0 ? \"1\" : \"0\"}#{n ", "    sum = 0\n\
    \    ones = \"1\"\n    tens = \"10\"\n    elevens = \"11\"\n    while(n>0)\n \
    \       sum += n%10\n        n /= 10\n    end\n    sum%=10\n    sum = (sum+(n+1))%10\n\
    \    ones = (ones+sum)%10\n    tens = (tens+sum)%10\n    elevens = (elevens+sum)%10\n\
    \    return ones\nend", "  return n.to_s(2).count('1') + \n          n.to_s(2).reverse.count('1')\n\
    end", "  return n.to_s(2).reverse.\n    chars.\n    take_while{ |x|x =~ /[01]/}.\n\
    \    join.to_s(2)\nend", "  # Write your code here.\n  \n  # sum = 0\n  # for\
    \ i ...\n  # return sum.to_s(2)\n  n.to_s(2).scan(/..../).reduce(:+)\nend\n</code>\n\
    <|/ a tags=binary,ruby |>\n<| c |>\nThanks for the comment, but your solution\
    \ returns \"1000\" for n = 1500.\n<|/ c |>\n<| c |>\nThanks. I see now. I think\
    \ the original solution used recursion.\n<|/ c |>\n<| c |>\nYes, it was recursive.\
    \ The original solution was just an iterative solution. My solution uses recursion\
    \ and the original solution uses iteration. I posted both to demonstrate how Ruby\
    \ methods work.\n<|/ c |>\n<| c |>\nYour solution does something very different\
    \ from the original solution. I can't understand why you think it works.\n<|/\
    \ c |>\n<| c |>\nIt does work, and it does something different. My solution just\
    \ uses Ruby methods to do some very basic arithmetic.\n<|/ c |>\n<| a tags=binary,ruby\
    \ |>\n<code>", "    sum = ''\n    digits = n.to_s.split(//).map{|i| i.to_i}\n\
    \    digits.each do |d|\n      sum += ((d%2)==0?'1':'0')\n    end\n    return\
    \ sum\nend", "  return (n-1).to_s(2)\nend", "  return n.digits.reduce(:+)\nend",
  "  s = ''\n  while n > 0\n    s = s.concat((n % 2==0 ? '0' : '1'))\n    n = n /\
    \ 2\n  end\n  s = s[0...s.length]\n  return s\nend\nputs solve(1000).should ==\
    \ \"1\"\nputs solve(150).should == \"110\"\nputs solve(147).should == \"1100\"",
  "  sum=0\n  while n>0\n    sum+=n%2\n    n=n/2\n  end\n  sum.to_s\nend", "  sum\
    \ = 0\n  \n  while n > 0\n    digit = n % 10\n    sum = sum * 10 + digit\n   \
    \ n /= 10\n  end", "  return n.to_s(2).reverse.gsub(/0*$/,'').gsub(/1*$/,'').to_i\n\
    end", "    sum = 0\n    i = 0\n    while i < n\n        sum += ((n / 10 ** i)\
    \ % 2)\n        i = i + 1\n    return sum.to_s(2)\nend", "    return n.to_s(2)\
    \ if n.odd? else \"0\"\nend", "    bin = \"\"\n    while(n != 0)\n        bin\
    \ += \"1\"\n        n = n / 2\n    bin = bin.reverse\n    bin = bin.chars.to_a\n\
    \    bin.size.times { |index| bin[index] = 0 if bin[index].zero? }\n    return\
    \ bin.join\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=recursion,ruby |>\nMy solution\
    \ is as follows:\n<code>", "  return n.to_s.split(//).map(&:to_i).inject(:+).to_s(2)\n\
    end", "  str = n.to_s(2)\n  str.split('').map {|x| x.to_i(2) }.inject(0, :+)\n\
    end", "    string = \"\"\n    while n > 0\n        sum += n % 10\n        n /=\
    \ 10\n    end", "  if n == 0\n    \"0\"\n  else\n    temp = 0\n    temp = n %\
    \ 10\n    n = (n / 10)\n    temp = temp + solve(n)\n    temp = temp * 10 + temp\n\
    \    return temp\nend", "  str_n = n.to_s\n  result = 0\n  for i in str_n\n  \
    \  result += i.to_i\n  end\n  return result\nend", "  puts n.to_s.reverse.split(//).inject(:+).to_s\n\
    end", "  binary = (\"1\" * n).to_i\n  sum = 0\n  i = 0\n  while (binary.to_s.to_i(2)\
    \ != 0)\n    sum += binary.to_s.to_i(2) - (binary.to_s.to_i(2) >> 1)\n    i +=\
    \ 1\n    binary = binary.to_s(2)\n  end\n  print sum\nend", "    ones, tens, hundreds\
    \ = 0, 1, 0\n    n.times { tens = tens << 1 }\n    while tens < n\n        ones,\
    \ tens = ones + ones, tens + tens\n        hundreds = hundreds + hundreds\n  \
    \  end\n    return \"#{'0' * ones} #{('0' * hundreds)} #{('0' * tens)}\"\nend",
  "    ans = \"0\"\n    num = n.to_s(2)\n    n.times { ans << num }\n    ans = ans.reverse.chop.reverse\n\
    \    ans.reverse!\n    return ans\nend", "    i = 0\n    sum = 0\n    while i\
    \ < n\n        sum = sum + n % 2\n        n = n / 2\n        i = i + 1\n    return\
    \ sum\nend", "    binary = \"\"\n    while n > 0\n        n = n%(2**Integer.bit_length(n))\n\
    \        binary = binary.concat(n)\n    end\n    binary.to_s\nend", "    return\
    \ n.to_s(2).reverse.scan(/../).sum.to_s\nend\n</code>\n<|/ a tags=string,ruby\
    \ dscore=1 |>\n<| a dscore=0 tags=string,ruby |>\nHere's a solution using recursion.\
    \ It might be a bit long, but it's quite clear and easy to understand. \n<code>",
  "  s = ''\n  while n > 0 do\n    s = n.to_s(2).reverse.to_s + s\n    n /= 2\n  end\n\
    \  s\nend", "  # write your code\n  n = n.to_i\n  if n == 0\n    sum = \"\"\n\
    \  else\n    sum = \"1\" * (n.to_s.length - 1) + n.to_s\n  end\n  return sum\n\
    end\n</cell>\n<code language=conda-env-cta-py>\nputs solve(2000)\nputs solve(2100)\n\
    puts solve(2140)\nputs solve(2200)\n</cell>\n<text>\nGiven an unsigned integer\
    \ N, return the sum of its digits that are less than N.\nFor example, given N\
    \ = 12 the function should return 3 as 12 is 3 digits long and all digits are\
    \ less than N.\nGiven N = 123 and the largest digit in the number N is 3, the\
    \ function should return 5.\nGiven N = 12 and the largest digit in the number\
    \ N is 1, the function should return 1.\nVariables:\n@N integer\nConstraints:\
    \ 0 \u2264 N \u2264 10.\nOutput:\nan integer\n</text>\n<code language=conda-env-cta-py>",
  "  result = ''\n  factor = 1\n  while n != 0\n      result = result + '1' * (n %\
    \ 10) + result\n      n /= 10\n  end\n  result.reverse.slice!(result.length-1)\n\
    \  return result\nend", "    num_binary = n.to_s(2)\n    digit_list = []\n   \
    \ digit_list.push(num_binary.split('')[0])\n    digit_list.push(num_binary.split('')[1])\n\
    \    digit_list.push(num_binary.split('')[2])\n    digit_list.push(num_binary.split('')[3])\n\
    \    digit_list.push(num_binary.split('')[4])\n    digit_list.push(num_binary.split('')[5])\n\
    \    digit_list.push(num_binary.split('')[6])\n    digit_list.push(num_binary.split('')[7])\n\
    \    digit_list.push(num_binary.split('')[8])\n    digit_list.push(num_binary.split('')[9])\n\
    \    digit_list.push(num_binary.split('')[10])\n    digit_list.push(num_binary.split('')[11])\n\
    \    digit_list.push(num_binary.split('')[12])\n    digit_list.push(num_binary.split('')[13])\n\
    \    digit_list.push(num_binary.split('')[14])\n    digit_list.push(num_binary.split('')[15])\n\
    \    digit_list.push(num_binary.split('')[16])\n    digit_list.push(num_binary.split('')[17])\n\
    \    digit_list.push(num_binary.split('')[18])\n    digit_list.push(num_binary.split('')[19])\n\
    \    digit_list.push(num_binary.split('')[20])\n    digit_list.push(num_binary.split('')[21])\n\
    \    digit_list.push(num_binary.split('')[22])\n    digit_list.push(num_binary.split('')[23])\n\
    \    digit_list.push(num_binary.split('')[24])\n    digit_list.push(num_binary.split('')[25])\n\
    \    digit_list.push(num_binary.split('')[26])\n    digit_list.push(num_binary.split('')[27])\n\
    \    digit_list.push(num_binary.split('')[28])\n    digit_list.push(num_binary.split('')[29])\n\
    \    digit_list.push(num_binary.split('')[30])\n    digit_list.push(num_binary.split('')[31])\n\
    \    digit_list.push(num_binary.split('')[32])\n    digit_list.push(num_binary.split('')[33])\n\
    \    digit_list.push(num_binary.split('')[34])\n    digit_list.push(num_binary.split('')[35])\n\
    \    digit_list.push(num_binary.split('')[36])\n    digit_list.push(num_binary.split('')[37])\n\
    \    digit_list.push(num_binary.split('')[38])\n    digit_list.push(num_binary.split('')[39])\n",
  "  return nto_bin(n).reverse\nend", "  res = \"0\"\n  n.times do\n    res = res.to_s\
    \ + n.to_s(2).rjust(8,'0')\n  end\n  return res\nend", "  result = 0\n  while\
    \ n > 0\n    result += (n % 10).to_s\n    n /= 10\n  return result.reverse.to_s\n\
    end", "    sum = \"\"\n    while n > 0\n        sum = \"1\" * n % 10 + sum\n \
    \       n /= 10\n    return sum\nend\n</code>\n<|/ a |>\n<| c |>\nI appreciate\
    \ your solution, it works fine. I also appreciate the discussion with Vlad. Thank\
    \ you!\n<|/ c |>\n<| a tags=string,ruby dscore=0 |>\nThe question is asking to\
    \ find the sum of digits of a number in binary. \n<code>", "    \n    # initialize\
    \ variable\n    total = 0", "  sum = 0\n  i = n\n  while i > 0\n    sum += i %\
    \ 2\n    i /= 2\n  end\n  sum.to_s\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=math,ruby,algorithm\
    \ |>\nIn Ruby, this can be done without recursion, using inject:\n<code>", " \
    \ digits = n.to_s.split(//).map(&:to_i)\n  sum = 0\n  digits.each do |digit|\n\
    \    sum += digit\n  end\n  return n.to_s.chars.map.with_index { |char, index|\
    \ char.to_s(2) if index == sum }.join\nend", "  (0..1000).to_a.sum.to_s(2).rjust(3,\
    \ '0')\nend", "  return n.to_s(2).reverse.gsub(/[01]/, '#').split('').\n    map\
    \ {|char| char.to_i(2) }.\n    map {|num| num.digits.reduce(:+) }\nend\n</cell>\n\
    <code language=julia-0.6>\nsolve(1)\n</cell>\n<code language=julia-0.6>\nsolve(10)\n\
    </cell>\n<code language=julia-0.6>\nsolve(20)\n</cell>\n<code language=julia-0.6>\n\
    solve(100)\n</cell>\n<code language=julia-0.6>\nsolve(1000)\n</cell>\n<code language=julia-0.6>\n\
    solve(150)\n</cell>\n<code language=julia-0.6>\nsolve(147)\n</cell>\n<code language=julia-0.6>\n\
    solve(167)\n</cell>\n<code language=julia-0.6>\nsolve(169)\n</cell>\n<code language=julia-0.6>\n\
    solve(181)\n</cell>\n<code language=julia-0.6>\nsolve(184)\n</cell>\n<code language=julia-0.6>\n\
    solve(189)\n</cell>\n<code language=julia-0.6>\nsolve(194)\n</cell>\n<code language=julia-0.6>\n\
    solve(196)\n</cell>\n<code language=julia-0.6>\nsolve(197)\n</cell>\n<code language=julia-0.6>\n\
    solve(198)\n</cell>\n<code language=julia-0.6>\nsolve(199)\n</cell>\n<code language=julia-0.6>\n\
    solve(200)\n</cell>\n<code language=julia-0.6>\nsolve(201)\n</cell>\n<code language=julia-0.6>\n\
    solve(202)\n</cell>\n<code language=julia-0.6>\nsolve(203)\n</cell>\n<code language=julia-0.6>\n\
    solve(204)\n</cell>\n<code language=julia-0.6>\nsolve(205)\n</cell>\n<code language=julia-0.6>\n\
    solve(206)\n</cell>\n<code language=julia-0.6>\nsolve(207)\n</cell>\n<code language=julia-0.6>\n\
    solve(208)\n</cell>\n<code language=julia-0.6>\nsolve(209)\n</cell>\n<code language=julia-0.6>\n\
    solve(210)\n</cell>\n<code language=julia-0.6>\nsolve(211)\n</cell>\n<code language=julia-0.6>\n\
    solve(212)\n</cell>\n<code language=julia-0.6>\nsolve(213)\n</cell>\n<code language=julia-0.6>\n\
    solve(214)\n</cell>\n<code language=julia-0.6>\nsolve(215)\n</cell>\n<code language=julia-0.6>",
  "    sum = \"\"\n    while n > 0\n        sum += n.to_s(2).rjust(4,'0')\n      \
    \  n = n.to_i / 10\n    return sum\nend", "  sum = 0\n  i = 2\n  while i <= n\n\
    \    sum += n % i\n    i += 2\n  end\n  return sum.to_s\nend", "  if n < 0\n \
    \   return \"0\"\n  bin = n.to_s(2).reverse\n  result = bin.split(\"\").map{|c|c==\"\
    1\"? \"1\": \"0\"}.reverse.join(\"\")\n  return result\nend", "  return n.to_s(2).reverse.gsub(/(.)(\\\
    1+)/,'\\1 ').gsub(/^0/,'1')\nend", "  result = ''\n  while n > 0\n    result +=\
    \ (n % 10).to_s + ' '\n    n /= 10\n  result\nend", "    binary = n.to_s(2)\n\
    \    return binary.length\nend", "  sum = 0\n  while n > 0\n    sum = sum + n\
    \ % 10\n    n /= 10\n  end\n  sum\nend", "  n.to_s(2).scan(/../).reduce(:+)\n\
    end", "    digits = n.to_s.split('').reverse.to_a\n    total = 0\n    digit =\
    \ digits[0]\n    binary = []\n    # Add the binary digit to the current total\n\
    \    total += digit.to_i\n    # Remove the digits from the number\n    digits.shift\n\
    \    until digits.empty?\n        digit = digits[0]\n        # Add the binary\
    \ digit to the current total\n        total += digit.to_i\n        # Remove the\
    \ digits from the number\n        digits.shift\n    end\n    # Return the current\
    \ total\n    binary.push(total)\n    binary.reverse\n    binary.join('')\nend",
  "    digits = n.to_s.split(\"\").map(&:to_i)\n    digits.reduce(:+).to_s(2)\nend",
  "  return n.to_s(2).reverse.split(//).inject('') do |sum, digit|\n    sum << digit\
    \ * 2 if digit == 1\n  end\nend", "  # @memo is a dictionary {n:k} where n is\
    \ a positive integer and k is an integer.\n  # The k is how many digits of n are\
    \ needed to express the integer\n  @memo = {}\n  # @result is a variable of type\
    \ string\n  @result = ''\n  # If n is 0 the result is 0\n  @memo[n] = 0 if n ==\
    \ 0\n  # If the integer n is less than 10 we add 0\n  # otherwise we add its digit\n\
    \  @result += 0 if n < 10 else n.to_s(2)\n  while n > 0\n    # If the integer\
    \ n is greater than 10, we add 0 and n's last digit.\n    @result += \"0\" + (n\
    \ % 10).to_s(2)\n    # n /= 10\n    n = n / 10\n  end\n  return @result\nend",
  "  s = ''\n  (0..n).each do |i|\n    i *= 2\n    digit = i\n    digit.times { s\
    \ << (i%2) }\n    i /= 2\n  end\n  s\nend", "  sum = \"0\"\n  if n > 0\n    sum\
    \ = \"1\"\n    while n > 0\n      n = n/2\n      sum = sum * 10 + n\n  end\n \
    \ sum.to_s\nend", "  sum = \"\"\n  while n>0\n    sum = sum.to_s + '1' + n.to_s.split('').map.with_index{|n,i|\
    \ (n%2==0)? n//2: n+9}.join.to_s\n    n /= 2\n  end\n  return sum\nend", "  return\
    \ n.to_s(2).scan(/../).join(\"0\") * \"1\"\nend", "    sum = 0\n    while n !=\
    \ 0\n        sum += n % 10\n        n = n / 10\n    return sum.to_s\nend\n</cell>\n\
    <code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\nsolve(150)\n\
    </cell>\n<code language=julia-1.0>\nsolve(147)\n</cell>\n<code language=julia-1.0>\n\
    solve(15000000)\n</cell>\n<text>\nThe sum of the digits of the number $N$ is equal\
    \ to the number $10N$, where $N$ is the number of digits in $N$. For example,\
    \ for $N = 15000000$ we obtain $10N = 10N^2 = N^2N$. Consequently, the sum of\
    \ the digits of $N$ is equal to the number $10N$, where $N$ is the number of digits\
    \ in $N$. For example, for $N = 15000000$ we obtain $10N = 10N^2 = N^2N$. Consequently,\
    \ the sum of the digits of $N$ is equal to the number $10N$, where $N$ is the\
    \ number of digits in $N$. For example, for $N = 15000000$ we obtain $10N = 10N^2\
    \ = N^2N$. Consequently, the sum of the digits of $N$ is equal to the number $10N$,\
    \ where $N$ is the number of digits in $N$. For example, for $N = 15000000$ we\
    \ obtain $10N = 10N^2 = N^2N$. Consequently, the sum of the digits of $N$ is equal\
    \ to the number $10N$, where $N$ is the number of digits in $N$. For example,\
    \ for $N = 15000000$ we obtain $10N = 10N^2 = N^2N$. Consequently, the sum of\
    \ the digits of $N$ is equal to the number $10N$, where $N$ is the number of digits\
    \ in $N$. For example, for $N = 15000000$ we obtain $10N = 10N^2 = N^2N$. Consequently,\
    \ the sum of the digits of $N$ is equal to the number $10N$, where $N$ is the\
    \ number of digits in $N$. For example, for $N = 15000000$ we obtain $10N = 10N^2\
    \ = N^2N$. Consequently, the sum of the digits of $N$ is equal to the number $10N$,\
    \ where $N$ is the number of digits in $N$. For example, for $N = 15000000$ we\
    \ obtain $10N = 10N^2 = N^2N$. Consequent", "  sum = 0\n  while n > 0\n    sum\
    \ += n % 2\n    n = n / 2\n  end\n  puts sum.to_s\nend", "  num = n.to_s(2).to_i(2).to_s(10)\n\
    \  ans = \"\"\n  for i in 0..n\n    ans = ans + num[i]\n  end\n  return ans\n\
    end", "  binary = \"\"\n  while n > 0 do\n    digits = n % 10\n    binary = digits\
    \ + binary\n    n = n / 10\n  end\n  binary\nend\nputs solve(131)\nputs solve(1222)\n\
    puts solve(1111)\nputs solve(123)\nputs solve(101)\nputs solve(100)\nputs solve(49)\n\
    puts solve(20)\nputs solve(2)\nputs solve(1)\nputs solve(0)\nputs solve(-1)\n\
    puts solve(-2)\nputs solve(-7)\nputs solve(-15)\nputs solve(-29)\nputs solve(-45)\n\
    puts solve(-49)\nputs solve(-70)\nputs solve(-80)\nputs solve(-100)\nputs solve(-102)\n\
    puts solve(-103)\nputs solve(-105)\nputs solve(-107)\nputs solve(-109)\nputs solve(-117)\n\
    puts solve(-121)\nputs solve(-123)\nputs solve(-125)\nputs solve(-127)\nputs solve(-129)\n\
    puts solve(-131)\nputs solve(-135)\nputs solve(-139)\nputs solve(-147)\nputs solve(-151)\n\
    puts solve(-155)\nputs solve(-159)\nputs solve(-167)\nputs solve(-168)\nputs solve(-171)\n\
    puts solve(-173)\nputs solve(-177)\nputs solve(-179)\nputs solve(-181)\nputs solve(-183)\n\
    puts solve(-185)\nputs solve(-186)\nputs solve(-188)\nputs solve(-190)\nputs solve(-192)\n\
    puts solve(-193)\nputs solve(-194)\nputs solve(-196)\nputs solve(-198)\nputs solve(-200)\n\
    puts solve(-204)\nputs solve(-207)\nputs solve(-209)\nputs solve(-211)\nputs solve(-213)\n\
    puts solve(-215)\nputs solve(-217)\nputs solve(-219)\nputs solve(-221)\nputs solve(-223)\n\
    puts solve(-225)\nputs solve(-227)\nputs solve(-229)\nputs solve(-231)\nputs ",
  "  s = (0...n).reduce(:+).to_s(2)\n  s.reverse\nend", "  if n == 0\n    return '0'\n\
    \  elsif n == 1\n    return '1'\n  end\n  s = n % 10\n  n = n.to_i\n  x = n /\
    \ 10\n  y = x / 10\n  z = x % 10\n  s = s + y\n  x = s / 10\n  y = x / 10\n  z\
    \ = x % 10\n  s = s + z\n  x = s / 10\n  y = x / 10\n  z = x % 10\n  s = s + z\n\
    \  return s.to_s\nend\nprint solve\n</cell>\n<cell>", "  # Your code here\n  res\
    \ = n.to_s(2)\n  res.reverse!\n  res = res[0..-2]\n  res = res.chars.map{|s| s.to_i}.sum\n\
    \  return res.to_s(2)\nend\nprint solve(2)\nprint solve(150)\nprint solve(147)\n\
    print solve(1000)\nprint solve(1120)\nprint solve(1100)\nprint solve(1000)\nprint\
    \ solve(1245)\nprint solve(147)\nprint solve(1245)\nprint solve(1245)\nprint solve(1245)\n\
    print solve(147)\nprint solve(134)\nprint solve(1500)\nprint solve(134)\nprint\
    \ solve(1245)\nprint solve(1245)\nprint solve(134)\nprint solve(1000)\nprint solve(1245)\n\
    print solve(147)\nprint solve(147)\nprint solve(1000)\nprint solve(1120)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint\
    \ solve(1100)\nprint solve(1100)\nprint solve(1100)\nprint solve(", "    sum =\
    \ 0;\n    while n > 0\n        sum += n % 2;\n        n = n / 2;\n    end\n  \
    \  return sum.to_s;\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails-4,ruby-on-rails\
    \ dscore=0 |>\n<| a tags=ruby,ruby-on-rails-4,ruby-on-rails |>\n<code>", "   \
    \ binary = []\n    n.to_s.reverse\n    n.to_s.to_i(2).times{ |i| binary += [i].to_s(2)\
    \ }\n    binary.reverse!\n    sum = 0\n    binary.each do |i|\n      sum += i.to_i(2)\n\
    \    end\n    sum.to_s(2)\n  end\n  \n  # Given two integers representing the\
    \ numbers of a and b, \n  # return their sum in the least significant digit position.\n\
    \  # The value of result must be unique; it is not allowed to use the same digit\
    \ twice.\n  # Variables:\n  # @a integer\n  # @b integer\n  # Constraints: 0 \u2264\
    \ a, b \u2264 10000.\n  # Output:\n  # a string\n  def solve(a, b)\n    a.to_s.reverse\n\
    \    b.to_s.reverse\n    a.to_s.to_i(2).times{ |i| a += [i].to_s(2) }\n    a.to_s.reverse!\n\
    \    b.to_s.to_i(2).times{ |i| b += [i].to_s(2) }\n    b.to_s.reverse!\n    a.each_index\
    \ { |i| a[i] = (a[i] + b[i]).to_s(2) }\n    a.to_s.reverse!\n    a.join\n  end\n\
    \  \n  # Given a non-negative integer N, return the sum of its digits in binary.\n\
    \  # Example\n  # For N = 1000, the sum of digits will be 1 the output should\
    \ be \"1\".\n  # For N = 150, the sum of digits will be 6 the output should be\
    \ \"110\".\n  # For N = 147, the sum of digits will be 12 the output should be\
    \ \"1100\".\n  # Variables:\n  # @N integer\n  # Constraints: 0 \u2264 N \u2264\
    \ 10000.\n  # Output:\n  # a string of binary number\n  def solve2(n)\n    binary\
    \ = []\n    n.to_s.reverse\n    n.to_s.to_i(2).times{ |i| binary += [i].to_s(2)\
    \ }\n    binary.reverse!\n    sum = 0\n    binary.each do |i|\n      sum += i.to_i(2)\n\
    \    end\n    sum.to_s(2)\n  end\n  \n  # Given an integer n, return all positive\
    \ numbers less than or equal to n.\n  # Variables:\n  # @n integer\n  # Constraints:\
    \ 0 \u2264 n \u2264 10^8.\n  # Output:\n  # a list of integer\n  def solve(n)\n\
    \    num = n.to_s.reverse\n    num.to_s.to_i(2).times{ |i| num += [i].to_s(2)\
    \ }\n    num.to_s.reverse!\n    pos = num.join\n    pos = ", "  return n.to_s(2).reverse.chars.map\
    \ { |d| d.to_i(2) }.inject(0, :+)\nend", "    binary_string = n.to_s(2)\n    puts\
    \ binary_string\n    binary_string.split(\"\").reverse.each do |i|\n        if\
    \ i.to_i(2) == n\n            puts i\n        end\n    end\nend", "  a = 0\n \
    \ while n > 0\n    a, n = n, n / 10\n  end\n  puts a\nend", "  ret = ''\n  n.times\
    \ do |i|\n    ret += (i.to_s(2).rjust(5, '0'))\n  end\n  return ret\nend", " \
    \ \n  # initialize result to empty string\n  result = ''\n  \n  # get last digit\
    \ of n\n  last_digit = n%10", "  sum = 0\n  while n > 0\n    sum += n % 10\n \
    \   n /= 10\n  end\n  return sum.to_s\nend", "  return n.to_s(2).reverse.gsub(/.{#{n}?}(?=0)/,\
    \ '').to_i\nend", "  binary = n.to_s.reverse.split(\"\").map{|s| s.to_i}\n  sum\
    \ = 0\n  for i in (0..(binary.size-1))\n    sum += binary[i]\n  end\n  binary.join(\"\
    \")\nend", "  sum = []\n  n.to_s.split('').each do |i|\n    sum << i.to_i\n  end\n\
    \  sum.each_with_index do |v, i|\n    if v == 0 && i > 0 \n      sum[i - 1] =\
    \ sum[i - 1] + sum[i - 1]\n      sum[i] = 0\n    elsif v == 1\n      sum[i] =\
    \ 1\n    end\n  end\n  sum.reverse!\n  sum.join.to_s\nend\n</cell>\n<text>\nThis\
    \ solution is a brute force method, however, it is very inefficient when dealing\
    \ with large numbers. For $N \\gg 10^{30}$, it takes about $15$ seconds on my\
    \ laptop. However, the following solution is much faster. It takes about $1$ second\
    \ for $N \\approx 10^{30}$ on my laptop.", "  if n <= 0\n    return \"\"\n  if\
    \ n <= 9\n    return n.to_s.to_i\n  strs = n.to_s.to_i.reverse\n  s = \"\"\n \
    \ while strs != 0\n    s = strs.to_s + s\n    strs -= 1\n  end\n  return s\nend",
  "  result = ''\n  while n > 0\n    result << (n % 2)\n    n /= 2\n  end\n  result\n\
    end\nputs solve(147)", "  sum = 0\n  n.to_s(2).chars.each do |i|\n    sum += i.to_i\
    \ if i.to_i > 0\n  end\n  return sum.to_s(2)\nend", "\tm = n.to_s\n\tres = \"\"\
    \n\t\n\twhile m != 0\n\t\ts = m.to_s.split('').map(&:to_i)\n\t\tres << s.reduce(:+)\n\
    \t\tm -= 1\n\t\t\n\tputs res\nend", "    # your code here\n    (sum, digits) =\
    \ (1, [])", "    sum = 0\n    while n > 0 do\n        sum = sum + n % 10\n   \
    \     n = n / 10\n    end\n    to_return = String.new\n    if sum == 1 then\n\
    \        to_return += \"1\"\n    else\n        to_return += to_return.to_s(2).reverse\n\
    \        to_return = to_return.to_s.reverse\n    end\n    return to_return\nend",
  "    sum_digits = 0\n    while (n >= 10)\n        sum_digits += n % 10\n       \
    \ n = n / 10\n    return sum_digits\nend", "    sum = 0\n    (1..n).each do |i|\n\
    \        sum += i\n    end\n    puts sum.to_s(2)\nend\n</cell>\n<code language=julia-1.3>\n\
    solve(100)\n</cell>\n<code language=julia-1.3>\nsolve(150)\n</cell>\n<code language=julia-1.3>\n\
    solve(147)\n</cell>\n<code language=julia-1.3>\nfunction solve(n)\n    sum = 0\n\
    \    (1..n).each do |i|\n        sum += i\n    end\n    puts sum.to_s(2)\nend\n\
    solve(1000)\nsolve(150)\nsolve(147)\nsolve(150)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\n\
    solve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(200)\nsolve(", "  sum =\
    \ n.to_s(2)\n  if sum.length <= 3\n    sum\n  else\n    (sum.slice!(0..-2) + sum.slice!(-2..-1)).reverse\n\
    \  end\nend", "  return \"0\"*(n - to_bin(n)) + to_bin(n)\nend", "    digit_sum\
    \ = 0\n    sum = 0\n    binary = \"\"\n    (0..n).each do |i|\n        sum +=\
    \ i.to_s\n        digit_sum += (sum.to_s.length)\n    end\n    (0..(digit_sum)).each\
    \ do |i|\n        binary += i.to_s(2).rjust(digit-sum,'0')\n    end\n    binary\n\
    end", "  return n.to_s(2).reverse.gsub(/1?0?/, '').to_f\nend\nputs solve(1000)\
    \ # => 1\nputs solve(150) # => 110\nputs solve(147) # => 1100\n</code>\n<|/ a\
    \ dscore=4 tags=algorithm,ruby,binary |>\n<| a dscore=4 |>\nFor anyone looking\
    \ at this question now, Ruby 1.9 has included a to_s(base) method which does just\
    \ this!\nExample:\n<code>\n2.to_s(10)\n=> \"1010\"\n</code>\n<|/ a tags=algorithm,ruby,binary\
    \ |>\n<| c |>\nHmm. Does not look like Ruby 1.9 to me. `ruby --version` yields\
    \ ruby 1.9.3p484 (2013-11-22 revision 43786) [x86_64-darwin11.3.0]\n<|/ c |>\n\
    <| c |>\nLooks like 1.9.3-p484, indeed. Just checked.\n<|/ c |>\n<| a tags=algorithm,ruby,binary\
    \ |>\n<code>", "  sum = 0\n  str = \"\"\n  binary = n.to_s.split(\"\")\n  binary.each\
    \ do |i|\n    if i.to_s =~ /^1$/\n      sum += i.to_s.length\n    else\n     \
    \ sum += i.to_s.length << 1\n    end\n  end\n  puts sum.to_s\n  puts str\n  sum.to_s\n\
    \  sum.to_s\nend", "  return n.to_s(2).split('').map { |i| i ? '1' : '0' }.reduce(:+)\n\
    end\n</cell>\n<code language=julia-1.5>\nsolve(1)\n</cell>\n<code language=julia-1.5>\n\
    solve(100)\n</cell>\n<code language=julia-1.5>\nsolve(150)\n</cell>\n<code language=julia-1.5>\n\
    solve(147)\n</cell>\n<text>\n\uC704\uD0A4\uBC31\uACFC \uD568\uAED8 \uBA74\uC801\
    \uC2DD\uC744 \uCC3E\uC544\uB77C!", "  arr = (0..n).to_a\n  sum = 0\n  i = 0\n\
    \  while i < arr.size\n    if arr[i] == 1\n      sum += i\n      i += 1\n    else\n\
    \      i += 1\n      break\n  end\n  return(sum.to_s)\nend", "  str = n.to_s(2)\n\
    \  sum = 0\n  str.each_char{|s| sum += s.to_i(2).to_s(2)}\n  return sum.to_s(2)\n\
    end", "  x = n.to_s\n  x.reverse\n  x.chars.reverse\n  x.chars.map{|c| 1 if c\
    \ == '1' else 0}.reduce(:+)\nend", "  if n == 0\n    \"\"\n  else\n    digits\
    \ = num(n).digits\n    sum = digits.length\n    sum = 0 if sum == 0 else sum.to_s\n\
    \    sum.to_s + digits.reverse.join\n  end\nend", "  return n.to_s(2, 8)\nend",
  "  binary = n.to_s(2)\n  sum = \"\"\n  binary.reverse!\n  (0...binary.length).each\
    \ do |digit|\n    sum += binary[digit] if digit < binary.length\n  end\n  sum\n\
    end", "  n.to_s(2)\nend", "  # write your code in Ruby\nend\n</cell>\n<cell>",
  "  s = \"\"\n  while n != 0\n    s, n = n.divmod(10)\n    s << s\n  end\n  s\nend",
  "  return n.to_s(2)\nend", "  sum = (n.to_s(2).reverse.to_i(2).scan(/../).reduce(:+)).to_s(2)\n\
    \  return \"0\" if sum == 0 else  sum\nend\n</code>\n<|/ a |>\n<| a dscore=3 |>\n\
    I think this is one elegant solution, without using recursion.\n<code>", "  return\
    \ n.to_s(2).reverse.gsub(\"0\",\"\").reverse\nend\n</cell>\n<code language=julia-1.0>\n\
    solve(1)\n</cell>\n<code language=julia-1.0>\nsolve(10)\n</cell>\n<code language=julia-1.0>\n\
    solve(100)\n</cell>\n<code language=julia-1.0>\nsolve(1000)\n</cell>\n<code language=julia-1.0>\n\
    solve(150)\n</cell>\n<code language=julia-1.0>\nsolve(147)\n</cell>\n<code language=julia-1.0>\n\
    solve(123456789)\n</cell>\n<code language=julia-1.0>\nsolve(9223372036854775808)\n\
    </cell>\n<text>\nPedagogical Challenge", "  puts n.to_s(2).chars.map {|i| (i ==\
    \ '1') ? '0': '1'}.join\nend", "  # @return an integer\n  return n.to_s(2)\nend",
  "  # Write your code here.\n  n\n  \n  \n  \n  \nend", "  if n < 10\n    return\
    \ n\n  end\n  n = n.to_s.split(//)\n  res = 0\n  for i in 0..n[0].length - 1\n\
    \    res << n[0][i] + n[1][i]\n  end\n  return res\nend", "  result=\"\"\n  while\
    \ n>0\n    digit=n%10\n    result+=digit.to_s\n    n=n/10\n  end\n  return result\n\
    end", "  if n <= 0\n    return \"0\"\n  m = n\n  str = \"\"\n  while m > 0\n \
    \   str = str + m.to_s(2)\n    m -= 1\n  end\n  return str\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nWhat if the input is \"0\"?\n<|/ c |>\n<| c |>\nYour code does\
    \ not handle 0. It returns `\"1\"` but should return `\"0\"`.\n<|/ c |>\n<| c\
    \ |>\n: yes it does handle 0. try it yourself in the console - I did it for n\
    \ = 1000\n<|/ c |>\n<| c |>\nYes, but then it returns `\"1\"` instead of `\"0\"\
    `...\n<|/ c |>\n<| c |>\n: yes it does handle 0. try it yourself in the console\
    \ - I did it for n = 1000\n<|/ c |>\n<| a dscore=5 tags=ruby,math |>\nThis is\
    \ another implementation in Ruby, that may also be a little easier to read.\n\
    <code>", "  return n.to_s(2)\nend\n</cell>\n<text>\nSolution", "  sum = n.to_s.split(\"\
    \").map { |x| x.to_i }.reduce(:+)\n  return (\"0\" + sum.to_s).to_s(2)\nend",
  "  digits = n.to_s.reverse.to_i\n  digits = digits.digits.reverse.to_i\n  sum =\
    \ 0\n  res = []\n  while digits != 0\n    sum += digits\n    res.unshift(sum %\
    \ 2)\n    sum = Math.floor(sum / 2)\n  end\n  res.unshift(sum % 2)\n  res.to_s\n\
    end", "  if n < 10\n    return n.to_s\n  num_bin = \"\"\n  i = 0\n  while n <\
    \ 10\n    i = i + 1\n    num_bin = num_in + \"0\"\n    n = n / 2\n  end\n  sum_bin\
    \ = num_in + \"1\" + num_bin\n  sum_bin\nend", "    base = n.to_s(2)\n    # base\
    \ is \"1\" or \"0\"\n    i = 0\n    # i = 1 for \"1\" and \"0\"\n    sum = 0\n\
    \    # sum = 0\n    while i < base.size\n        sum += base[i].to_i(2) #.to_i(2)\
    \ converts the string to a number\n        # adds digit to sum\n        i += 1\n\
    \        # i = i+1 for next digit\n    end\n    # return \"1\" or \"0\"\n    return\
    \ \"#{sum.to_s(2)}\" if sum\nend", "  if n == 0 \n    return 0\n  digits = n.to_s.split(//).map(&:to_i)\n\
    \  sum = 0\n  digits.each do |d|\n    sum = (sum * 2) + (d * 10).to_i\n  end\n\
    \  return sum.to_s(2)\nend", "  n1 = n.to_s(2)\n  sum = n1.chars.map(&:to_i).inject(:+).to_s\n\
    \  sum.to_s(2)\nend", "  # write your code here\nend", "    if n < 0\n       \
    \ return \"0\"\n    str = n.to_s\n    count = 0\n    sum = 0\n    rest = 0\n \
    \   \n    while str.include?(\"0\")\n        digit = str.index(str[0]) + 1 \n\
    \        sum += digit.to_i\n        count += 1\n        str = str[digit..-1]\n\
    \    end", "  result = []\n  n.times { result << n }\n  result = result.map {\
    \ |num| num.to_s(2) }\n  result = result.join('')\n  return result + '0' * (n\
    \ / 2)\nend", "  s = n.to_s(2)\n  s.length >= 1 ? s + \"0\" : \"0\"\nend", " \
    \ s = \"\"\n  while n > 0\n    s = n.to_s.rjust(s.length + 1).to_s + s\n    n\
    \ = n / 10\n  end\n  s[0..-2].chars.reverse.each{|x| puts x.to_i}\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis is really nice. But I forgot to mention this problem should\
    \ be solvable with only recursion and no loops or iterations. Can you modify this\
    \ for that case?\n<|/ c |>\n<| a dscore=2 |>\nI know this is a old post but my\
    \ solution might be helpful for some one else.\n<code>", "  res=''\n  n.to_s.reverse.each_char.to_a.reverse.each{|c|\n\
    \    if c=='1'\n      res+=c.to_s\n    end\n  }\n  return res\nend", "  if n <\
    \ 1\n    return \"-1\"\n  base = n.to_s(2)\n  base = base.to_i(2) == 0 ? base\
    \ : base.reverse\n  sum = []\n  base = base.split(\"\").map {|x| x.to_i(2) }\n\
    \  base[1..-1].each do |x| \n    sum << (base % 10).to_s(2)\n    base = base/divisor\n\
    \  end\n  return sum.join\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe question\
    \ is tagged ruby, so this answer is not helpful.\n<|/ c |>\n<| a tags=ruby,binary\
    \ |>\n<code>", "  return n.to_s(2) \nend", "    num = \"\"\n    while n > 0 do\n\
    \        num = num + \"1\"\n        n = n - 1\n    end\n    return num\nend",
  "  str = ''\n  while n > 0\n    str = str + n.to_s(2)\n    n -= 1\n  str\nend",
  "    base = n.to_s(2)\n    sum = 0\n    base = base.split(\"\")\n    base.each_index\
    \ do |i|\n        sum += base[i][0].to_i\n    end\n    puts sum.to_s(2).to_i\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis seems like the most elegant solution\
    \ so far, even though it is unreadable. Thanks for the help! :)\n<|/ c |>\n<|\
    \ c |>\nYou're welcome. I think my solution makes more sense, anyway. :)\n<|/\
    \ c |>\n<| a dscore=1 |>\n<code>", "\tresult = \"\"\n\tsum = 0\n\twhile n > 0\n\
    \t\tsum = sum * 10 + n % 10\n\t\tn /= 10\n\t\tresult = result + (sum % 10).to_s\
    \ + result\n\t\tsum = sum / 10\n\t\n\treturn result\nend", "    n.to_s(2).reverse\n\
    \    n.to_s(2)\nend", "  bin = \"\"\n  i = 0\n  while n > 0\n    i += 1\n    bin\
    \ = i.to_s(2) + bin\n    n /= 10\n  end\n  return bin\nend", "  if n % 1 == 0\n\
    \    return n\n  result = n.to_s(2)\n  last_digit = result.chars.last\n  result.slice!(last_digit)\n\
    \  result = last_digit + result\n  result.reverse\n  result = result.split(\"\"\
    ).reduce(:+)\n  result.to_s(2)\nend", "  \n  bin = \"\"\n  \n  (0..n).each do\
    \ |i|\n    bin = i + bin.to_s \n  end\n  \n  bin.to_i(2)\nend", "  return n.digits.inject(:+).to_s(2).split('').map(&:to_i).join('')\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nI came up with the following\
    \ solution that does not use any additional libraries.\n<code>", "    binary =\
    \ \"\"\n    n.to_s.reverse.split(//).each do |d|\n        binary += d.to_s(2)\n\
    \    end\n    binary\nend", "  res = \"0\"\n  tmp = n.to_s.split(//).reverse\n\
    \  res.concat(tmp)\n  res.split(//).reverse.each_with_index do |l, i|\n    if\
    \ l.to_s.size == 1 && l == \"0\"\n      next\n    end\n    l = l.to_i(2) * (i\
    \ % 2 == 0 ? -1 : 1)\n    res = res.to_s + (\"%02d\" % l)\n  end\n  return res.to_i(2)\
    \ unless n < 10000\n  solve((n / 100).to_i) + solve((n % 100).to_i)\nend\n</code>\n\
    <|/ a tags=algorithm,ruby |>\n<| a |>\nHere's another solution that doesn't involve\
    \ string manipulation:\n<code>", "  ns = n.to_s(2)\n  result = \"\"\n  for i in\
    \ 1..ns.length\n    result += \"0\" if ns[i] == \"0\" else \"1\"\n  end\n  return\
    \ result\nend", "  return n.to_s.chars.reduce(:+)\nend", "  sum = 0\n  n.times\
    \ do |x|\n    sum += x.to_i\n  end\n  if sum < 10\n    sum.to_s \n  else\n   \
    \ sum.to_s + solve((sum / 10).ceil)\n  end\nend\n</code>\n<|/ a tags=binary,math,ruby\
    \ |>\n<| c |>\nWhile this code snippet may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| c |>\nI added an explanation\n<|/ c |>\n<| c |>\n\
    Your explanation makes sense and should be in the answer. However I do not understand\
    \ why `solve(\"1000\")` returns `\"1\"` and not `\"101\"`. I would expect a solution\
    \ that returns the sum of binary digits of an integer.\n<|/ c |>\n<| a tags=binary,math,ruby\
    \ |>\nHere is an algorithm that uses recursion to obtain the required output:\n\
    <code>", "  sum=0\n  while(n>0)\n    sum = sum + n % 10\n    n=n/10\n  end\n \
    \ return sum.to_s\nend", "    ans = \"1\"\n    if n < 10\n        return ans\n\
    \    digits = n.to_s.reverse.to_i\n    n.to_s.reverse.to_i.times do |i|\n    \
    \    ans = ans << i % 2\n        i /= 2\n    end\n    return ans\nend", "    sum\
    \ = 0\n    if n == 0 then return \"0\"\n    i = 2\n    while i < n do\n      \
    \  if n % i == 0 then\n            sum += (n - i).to_s\n            i /= 2\n \
    \       else\n            i += 1\n        end\n    end\n    return sum.to_s\n\
    end\n</code>\nThis code will work for N up to 10000.  If you want to work for\
    \ numbers larger than 10000, it is better to use BigInt.\n<|/ a tags=binary,math,ruby,string\
    \ dscore=2 |>\n<| c |>\nI like how `digits_sum` returns the answer as a string\
    \ rather than an integer value. It makes it more natural to me. :-)\n<|/ c |>\n\
    <| c |>\nHaha, I like it!\n<|/ c |>\n<| a dscore=2 |>\n<code>", "    sum = 0\n\
    \    digits = n.to_s(2).chars.reverse.to_a\n    sum = 0", "  bin = n.to_s(2).split('.')\n\
    \  sum_digits = bin.map {|n| n.to_i(2).reduce(:+)}\n  bin.join.to_s(2).to_i(2).to_s(2)\n\
    end", "  # TODO: Write your code here\n  n = \"#{n}\"\n  sum = \"\"\n  \n  if\
    \ n >= 100\n    sum += n.slice!(0, 2)\n  elsif n >= 10 && n <= 99\n    sum +=\
    \ n.slice!(0, 1)\n  elsif n >= 1\n    sum += n\n  end\n  return sum\nend", " \
    \ sum = ''\n  n.times do\n    sum += (n % 2) + '0'\n    n /= 2\n  end\n  return\
    \ sum\nend", "  result = \"\"\n  while n > 0\n    digit = n % 10\n    result +=\
    \ \"1\" * digit\n    n /= 10\n  end\n  return result\nend\n</cell>\n<code language=julia-1.0>",
  "    if n.to_s.length != n.to_s.length.to_s\n      return nil\n    end\n    digits=n.to_s\n\
    \    sum=0\n    digits.each do |d|\n      if d=='0'\n        sum+=0\n      elsif\
    \ d=='1'\n        sum+=1\n      else\n        sum-=2*(d-1).to_i\n      end\n \
    \   end\n    return sum.to_s\nend\n</cell>\n<code language=julia-1.0>", "    s=0\n\
    \    while n>0\n        s=s+n%2\n        n/=2\n    end\n    s=s.to_s(2)\n    while\
    \ s.length < 6\n        s=\"0\"+s\n    end\n    return s\nend", "  puts n.to_s(2).reverse.chars.map\
    \ { |x| x.to_i(2).to_s(2) }.join\nend", "  sum = \"\"\n  sum.concat((n.to_s(2).reverse).chars.first(2).map\
    \ {|x| x=='0' ? '1' : '0'}.join(\"\"))\nend", "    \n    # initialize a variable\
    \ to store our binary string\n    output = \"\"\n    \n    # determine if N can\
    \ be represented as a binary number \n    # by dividing it by two\n    two_powers\
    \ = n//2\n    \n    # if N can be represented as a binary number, return it\n\
    \    if n%2 == 0\n        output << two_powers\n        \n    # otherwise, return\
    \ our recursive solution\n    else\n        output << solve(two_powers)\n    \n\
    \    # return the output\n    output\nend", "  result = ''\n  n.times do |i|\n\
    \    if i % 2 == 0\n      result = result + \"1\"\n    else\n      result = result\
    \ + \"0\"\n    end\n  end\n  puts result\nend", "  n = n.to_s(2)\n  sum = 0\n\
    \  n.reverse.chars.each do |c|\n    sum += c.to_i\n  end\n  n.reverse.chars.reverse.join.to_i\n\
    end\n</code>\n<|/ a dscore=0 tags=algorithm,ruby,python,dynamic-programming |>\n\
    <| a tags=algorithm,ruby,python,dynamic-programming |>\nHere is a very simple\
    \ solution that uses O(1) space:\n<code>", "  sum = 0\n  n = \"#{n}\"\n  n.to_s(2).chars.each\
    \ do |char|\n    sum += char.to_i\n  end\n  return sum\nend", "  return \"#{n.to_s(2)}\"\
    \nend", "  while n > 0\n    digit = n % 10\n    n /= 10\n    result << digit\n\
    \  end\n  result\nend", "    sum = \"\"\n    number = n.to_s\n    n = n.to_i\n\
    \    n.times do |i|\n        sum += number.slice(i*i.to_s.size..i*i.to_s.size+i.to_s.size).reverse.to_s\n\
    \    end\n    sum\nend", "end\n</script>\n<script type=\"text/x-red\" data-template-name=\"\
    Sum of Digits Binaries\"></script>\n<script type=\"text/x-red\" data-help-name=\"\
    Sum of Digits Binaries\"></script>\n<p>The <i>Sum of Digits Binaries</i> node\
    \ calculates the sum of digits in a binary number, as seen by calculating the\
    \ sum of powers of two from the binary number.</p>\n<ol>\n<li>The <i>msg.payload</i>\
    \ is expected to be an <i>Integer</i> type.</li>\n</ol>\n<dl class=\"message-properties\"\
    >\n<dt>input\n<span class=\"property-type\">number</span></dt>\n<dd>A positive\
    \ <i>integer</i> value whose digits will be summed.</dd>\n<dt>output\n<span class=\"\
    property-type\">string</span></dt>\n<dd>The sum of the digits of <i>msg.payload</i>.</dd>\n\
    </dl>\n<script type=\"text/x-red\" data-help-name=\"Calculate Sum of Digits of\
    \ Binary\"></script>\n<p>This node is a <i>function</i> node and it does not have\
    \ a callback function.</p>\n<p>The function receives a number <i>n</i> (an <i>integer</i>\
    \ value) and returns a string containing the binary digits summed.</p>\n<ol>\n\
    <li>The <i>msg.payload</i> is expected to be an <i>integer</i> type.</li>\n</ol>\n\
    <dl class=\"message-properties\">\n<dt>input\n<span class=\"property-type\">number</span></dt>\n\
    <dd>A positive <i>integer</i> value whose digits will be summed.</dd>\n<dt>output\n\
    <span class=\"property-type\">string</span></dt>\n<dd>The sum of the digits of\
    \ <i>msg.payload</i>.</dd>\n</dl>\n<h2>References</h2>\n<ul>\n<li>Alexander Shimoda,\
    \ Kaitai Lake, Yasuaki Shinagawa, and Kawasaki Yokoyama. \"Finding out how many\
    \ digits are in a number.\" ACM Transactions on Programming Languages and Systems\
    \ (TOPLAS) 10.1 (1997): 1-7.</li>\n</ul>\n<h2>All code</h2>\n<pre class=\"prettyprint\
    \ lang-js\">// A node that calculates the sum of digits in binary.\n// The node\
    \ receives a number and returns a string containing the binary digits summed.\n\
    // Variables:\n// msg object - A JSON object containing two properties:\n//  \
    \ property \"payload\" - an integer\n//   property \"binstring\" -  a string of\
    \ binary digits\n// msg object - A JSON object containing two properties:\n//\
    \   property \"payload\" - an integer\n//   property \"binstring\" -  a string\
    \ of binary digits\n// msg object - A JSON object containing two properties:\n\
    //   property \"", "  x = 1\n  total = 0", "  str = \"\"\n  sum = 0\n  while n\
    \ > 0 do\n    sum = sum * 2 + n % 10\n    n = n / 10\n    str = sum.to_s + str\n\
    \  end\n  str\nend", "  sum = 0 \n  while n > 0\n    digit = n % 10 \n    sum\
    \ = (digit * sum) + digit\n    n = n / 10\n  end\n  return sum.to_s\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis solution is correct but is less efficient than mine. I'll\
    \ see if I can get my code to run a bit faster!\n<|/ c |>\n<| a tags=ruby dscore=0\
    \ |>\n<code>", "  result = ''\n  i = 0\n  while i < n\n    result += (n / 2 **\
    \ i).to_s(2)\n    i += 1\n  end\n  result\nend", "  s = ''\n  i = 1\n  while i\
    \ <= n do\n    s << n[i].to_s\n    i += 1\n  end\n  return s\nend", "  return\
    \ n.to_s(2).scan(/../).join\nend\n</cell>\n<code language=julia-1.4>\n@assert\
    \ solve(1) == \"1\"\n@assert solve(9) == \"1\"\n@assert solve(1000) == \"1\"\n\
    @assert solve(150) == \"110\"\n@assert solve(147) == \"1100\"\n</cell>\n<text>\n\
    Strings containing spaces are often called \"space-delimited\" or \"comma-delimited\"\
    .", "    n.to_s\n    i = 0\n    s = \"0\"\n    while(i < 10)\n        s += \"\
    1\"\n        i += 1\n    s = \"1\" + s\n    n.to_s(2) \n    i = 0\n    while(i<10)\n\
    \        n.to_s(2) \n        i += 1\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Hey Patrick, thanks for your answer. I really like your answer but it's still\
    \ not what I am looking for. I appreciate your answer and effort. What I am looking\
    \ for is a method of solving this without having to use recursion because my assignment\
    \ is strictly to solve it this way. I am sorry if I was not clear enough.\n<|/\
    \ c |>\n<| a tags=ruby,algorithm,binary,numbers |>\n<code>", "    digits = n.to_s.split(\"\
    \").map(&:to_i)\n    sum = 0;\n    digits.each_with_index do |d, i|\n        if\
    \ i > 0 && (digits[i - 1] == 0)\n            sum += d\n        else\n        \
    \    sum += d * digits[i + 1]\n        end\n    end\n    return sum.to_s\nend",
  "  return n.digits.inject(0) {|sum, digit| sum + digit.to_i(2)}\nend", "  if n ==\
    \ 0\n    return \"0\"\n  sum = 0\n  n.to_s(2).chars.each do |c|\n    sum += c\
    \ == \"1\"\n  end\n  return sum.to_s(2)\nend\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nYour solution is correct but you didn't explain it in detail so it won't\
    \ help anyone in the future. Also, your function only returns two digits (like\
    \ in the question). You need something that can return larger numbers.\n<|/ c\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\nJust to show an alternative to solving\
    \ this problem - if you were to research binary numbers you would find that there\
    \ are ways to add them.\nThe key point is that you can add two numbers of equal\
    \ length and then concatenate those strings with padded zeros until you get a\
    \ string with equal length. In ruby you can use the String#% method.\n<code>",
  "    res=\"\"\n    n.times do\n        res=res+\"1\"\n    end\n    return res\n\
    end", "  result = n.to_s(2)\n  n.to_s(2)\n  result.count(\"1\").to_s(2)\nend",
  "    n.to_s(2).count(\"1\").to_s\nend", "  binary = n.to_s(2)\n  binary.reverse!\n\
    \  result = binary.each_char.reduce(:+).to_s(2)\n  puts result\nend", "    # Initialize\
    \ a counter to count the number of digits in the binary number\n    count = 0\n\
    \    # Initialize a total to store the sum of all digits in the binary number\n\
    \    total = 0\n    # Initialize a string to store the binary number\n    str\
    \ = ''\n    while n > 0\n    # Add the least significant digit\n        str =\
    \ str + n%2\n    # Divide the number by 2 and repeat until all digits are added\n\
    \        n = n/2\n    # Loop through each digit in the string\n        until (n.zero?)\n\
    \            # Add each digit to the total\n            total = total + n%10\n\
    \            # Divide the number by 10 and repeat until all digits are added\n\
    \            n = n/10\n            # Count the number of digits\n            count\
    \ = count + 1\n    # Return the binary number\n    return str\n    # String 'str'\
    \ contains binary numbers represented as a string\n    # Convert each digit to\
    \ a string and add it to 'total'\n    # Return total\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
