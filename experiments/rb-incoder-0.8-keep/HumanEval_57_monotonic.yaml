name: HumanEval_57_monotonic
language: rb
prompt: "# Return True is list elements are monotonically increasing or decreasing.\n\
  # >>> monotonic([1, 2, 4, 20])\n# True\n# >>> monotonic([1, 20, 4, 10])\n# False\n\
  # >>> monotonic([4, 1, 0, -10])\n# True\ndef monotonic(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_monotonic\n\
  \    candidate = method(:monotonic)\n    assert_equal(true, candidate.call([1, 2,\
  \ 4, 10]))\n    assert_equal(true, candidate.call([1, 2, 4, 20]))\n    assert_equal(false,\
  \ candidate.call([1, 20, 4, 10]))\n    assert_equal(true, candidate.call([4, 1,\
  \ 0, -10]))\n    assert_equal(true, candidate.call([4, 1, 1, 0]))\n    assert_equal(false,\
  \ candidate.call([1, 2, 3, 2, 5, 60]))\n    assert_equal(true, candidate.call([1,\
  \ 2, 3, 4, 5, 60]))\n    assert_equal(true, candidate.call([9, 9, 9, 9]))\n  end\n\
  end\n"
completions: ["  l.sort!\n  l.each_with_index do |x, i|\n    return false if l[i-1]\
    \ < x\n  end\n  true\nend\n</code>\n<|/ a |>\n<| c |>\nYour answer is incorrect\
    \ because it returns true for [4, 1, 0, -10] which is not monotonic.\n<|/ c |>\n\
    <| c |>\nHi, thanks for the comments. I updated the code so it only returns true\
    \ if the list elements are monotonically increasing or decreasing. Also, I updated\
    \ the code so it returns the index if a list element does not satisfy the conditions.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's a recursive version that doesn't use sort:\n\
    <code>", "  l.sort.with_index { |val, i| val <= l[i + 1] }\n  l[-1] == l[0]\n\
    end", "  l.sort!\n  l.each_cons(2).all? {|a,b| a <=> b}\nend\n</code>\n<|/ a dscore=4\
    \ tags=sorting,ruby,arrays |>\n<| c |>\nYour solution is very slow compared to\
    \ sort, especially for large arrays. Do you have a better solution?\n<|/ c |>\n\
    <| c |>\n: I don't have a faster one, but it is easy to understand and to maintain.\n\
    <|/ c |>\n<| a |>\nHere is another one. Not as fast as Rubocop's one, but I like\
    \ that it follows Ruby's conventions, which is to put a ! at the end of each method\
    \ call:\n<code>", "  return l.count(l[0]) == len(l)\nend", "  l.each_cons(2) do\
    \ |a,b|\n    return false if b <= a\n  end\n  return true\nend", "  return l.sorted\
    \ && l.all? &&\n    (l.all? || (l.max < l.min)) &&\n    (l.any? || (l.max > l.min))\n\
    end", "  l.each_index do |i|\n    return false if (l[i+1] < l[i] or l[i+1] ==\
    \ l[i] and l[i-1])", "  return l.all? { |v| (v<l.min?false:v>l.max?false:true)\
    \ }\nend", "  return monotonic_helper(l, false)\nend", "  return l.uniq.size ==\
    \ 1 and l.all? {true: 1, false: -1}[l[0]]\nend\n    ", "    l.sort.each do |i|\n\
    \        j = i + 1\n        if j > l.size or l[j] < l[i]\n            return false\n\
    \        end\n    end\n    return true\nend", "  return l == [monotonic(l[0])]\
    \ + l[-1] if l and l[0] and l[-1] and l[0] < l[-1] else false\nend", "  return\
    \ l.sort.reverse.inject(true, :<=>) == :<=\nend", "  return l.reduce(:<=>, 0)\
    \ == -1\nend", "  l.sort\n  l.each_with_index { |e, i|\n    return false if i\
    \ == 0\n    return true if l[i-1] > e\n  }\n  true\nend", "  l.sort!\n  return\
    \ l.reduce(true?: (l[-1] < l[-2]) || (l[-1] == l[-2]), true)\nend", "  l.sort\n\
    \  loop do\n    break if l.pop <= l[0]\n  end\n  l.pop == l[0]\nend", "  return\
    \ l.sort == l.reverse && l.all? {|e| e == l.first ||\n    l[e.succ].succ <= e\
    \ }\nend", "  return l and l[0] < l[-1]\nend", "  l = l.to_a\n  return l.all?\
    \ {|i| i.zero?}\nend", "  return l.inject(true){|i,e| e <= i.next}\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis solution does not give the same answer as the OP's. It\
    \ will return `True` for `[1, 1, 3, 4, 4]`, which is clearly *not* the case for\
    \ monotonic sequences.\n<|/ c |>\n<| c |>\n- you're right. I've updated the solution\
    \ to use the `reverse` of the list.\n<|/ c |>\n<| a dscore=5 |>\nAs was pointed\
    \ out in another answer, the solution to your problem is the same as for the first\
    \ part of the problem:\n<code>", "  l.inject(0, :<)\n  l.each_cons(2) do |l, r|\n\
    \    return false if r.first < l.first\n    return true if r.last > l.last\n \
    \ end\n  true\nend", "  l.sort.each do |i|\n    return true if l[i-1] > l[i]\n\
    \    return true if l[i-1] < l[i]\n  end\n  false\nend", "  l.sort!\n  l.length\
    \ == 0 || return false if l.last < l[0]\n  l.first > l[-1]\nend\n</code>\nThis\
    \ can easily be extended to work with other data structures (Arrays, Hashes, Ranges,\
    \ Sets), but for the sake of simplicity, I will leave that out for now.\n<|/ a\
    \ tags=ruby |>\n<| a dscore=0 |>\nHere's a way that might work for you based on\
    \ some assumptions made in the comments:\n<code>", "  l = l.to_a if l.is_a?(Enumerable)\n\
    \  return false unless l.size > 1\n  l.all? { |x| (x<l[-1] || l>x) && x >= l[-1]\
    \ }\nend", "  l.each do |x|\n    if x <= l[0] || x >= l[l.length - 1]\n      next\n\
    \    elsif x < l[l.length - 1]\n      return true\n    elsif x > l[0]\n      return\
    \ false\n    end\n  end\n  return false\nend\n</code>\nI got this from this StackOverflow\
    \ answer, and this article (although it uses Array#sort, I believe the same solution\
    \ will work if you use an Array#sort sorter instead).\n<|/ a tags=ruby |>\n<|\
    \ a dscore=1 |>\n<code>", '  return l == sort(l)[-1] and all(a>=b for a,b in combinations(l,2))',
  "  if l[0] < l[1]\n  then\n    return true\n  else\n    return false\n  end\nend",
  "  l.inject(0) do |max_value, element|\n    return false if max_value < element\n\
    \    prev_max_value = max_value\n    max_value = element\n    max_value < prev_max_value\n\
    \  end\nend", "  return l.all? || (!l.size && l.any? && !l.any?(&:<=>))\nend",
  "  l.sort!\n  return false if l.empty? or l.last.nil? or l.last < l.first else\n\
    \  l[1] < l[2] or l[1] < l[3] or l[2] < l[3]\nend\n</code>\n<|/ a dscore=2 tags=ruby,arrays\
    \ |>\n<| a dscore=2 |>\nHere is an approach that sorts the list and checks if\
    \ the first and last values are equal.  It also avoids unnecessary comparisons\
    \ by sorting the array only once:\n<code>\na = [1, 2, 3, 4, 5]\nputs \"#{a.sort!.reverse.first\
    \ == a.last && a.sort!.reverse.first == 0}\"", "  return l.count(l[0]) == len(l)\n\
    end\n</cell>\n<code language=julia-1.5>", "  l.sort.each do |v|\n    return true\
    \ if v > l[0]\n  end\n  false\nend", "  l.each_cons(2) do |a, b|\n    return false\
    \ if b < a\n    return true if a == b\n    return false if a.last == b.first\n\
    \  end\n  true\nend", "  l.sort!\n  l[0] < l[-1]\nend", "  l.sort!\n  l.length.times\
    \ { |i| return false if l[i-1] > l[i] or l[i-1] < l[i] }\n  true\nend", "  return\
    \ l.all? or (l.min <= l[-1] <= l.max)\nend", "    l.sort!\n    return l[-1] ==\
    \ l[-2]\nend\n</pre>\n    </td>\n  </tr>\n</table>", "  l.inject([]) do |sum,\
    \ el|\n    return false if sum.length == 0\n    break if sum.last < el\n    sum\
    \ << el\n  end\n  sum.length > 0\nend", "  l = l.dup\n  l.shift\n  l.each_cons(2)\
    \ do |x, y|\n    return true if x.nil? || y > x\n    return true if y < x\n  end\n\
    \  false\nend\n</code>\nThe above method works because a > b if a is greater than\
    \ or equal to b and b is greater than or equal to a.\n<code>\nrequire 'benchmark'\n\
    Benchmark.bm do |x|\n  x.report('list' ) { monotonic([1,2,3]) }\n  x.report('array'\
    \ ) { monotonic([1,2,3]) }\n  x.report('nil'  ) { monotonic(nil) }\n  x.report('nil2'\
    \ ) { monotonic(nil) }\n  x.report('empty') { monotonic([]) }\n  x.report('empty2'\
    \ ) { monotonic([]) }\n  x.report('string' ) { monotonic('string') }\n  x.report('string2'\
    \ ) { monotonic('string') }\n  x.report('array2' ) { monotonic([]) }\n  x.report('array3'\
    \ ) { monotonic([]) }\nend", "  # A sequence is monotonic if its first element\
    \ is strictly less than every element of the sequence.\n  # Note that monotonic()\
    \ only tests strict monotonicity, meaning it returns True or False depending on\
    \ strict\n  # equality for identical elements. Sequences containing NaN or Inf\
    \ values will not qualify as strictly monotonic.\n  # >>> monotonic([-1, 1])\n\
    \  # False\n  # >>> monotonic([-1, NaN, -1])\n  # False\n  # >>> monotonic([-1,\
    \ Inf, -1])\n  # False\n  # >>> monotonic([-1, 1, 0])\n  # True\n  # >>> monotonic([-1,\
    \ 1, 0, 10])\n  # True\n  # >>> monotonic([1e100, 1e100, 1e100, 1e100])\n  # True\n\
    \  # >>> monotonic([1e100, 1e100, 1e100, 1e100, 1e100])\n  # False\n  # >>> monotonic([1e100,\
    \ 0, 0])\n  # True\n  # >>> monotonic([1e100, 0, 1e100, 0])\n  # False\n  # >>>\
    \ monotonic([1e100, 0, 1e100, 1e100])\n  # False\n  # >>> monotonic([1e100, 1e100,\
    \ 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100,\
    \ 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100,\
    \ 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100,\
    \ 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100,\
    \ 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100,\
    \ 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100,\
    \ 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100,\
    \ 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100,\
    \ 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100,\
    \ 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100,\
    \ 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100,\
    \ 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100,\
    \ 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100, 1e100,\
    \ 1e100, 1e100, 1e100, 1e100, ", "  l.sort!\n  return l[0] == l[-1]\nend", " \
    \ return l[0] < l[-1] ? 1 : -1\nend", "  return !increasing?(l) and !decreasing?(l)::l<(l.last)\
    \ and l<l.last\nend", "  # Check each value in the list is in the correct order.\n\
    \  raise \"Not Implemented\"\nend", "  return l.count(l[0]) == len(l)\nend", " \
    \ l.sort!\n  return l.first > l.last\nend", "  l.sort!\n  return l.last(l.size-1).eql?(l.first(l.size-1))\
    \ ? true : false\nend\n  ", "  return all((l[i+1]-l[i]) < (l[i]-l[i-1]) for i\
    \ in [0..@l-1]) end\n</code>\n<|/ a tags=julia,python,sorting dscore=1 |>\n<|\
    \ c |>\nI did something very similar, but using an accumulator to track the number\
    \ of positive elements (and negatives) in the array. I'm not sure if this is faster\
    \ than the other answers, but it works.\n<|/ c |>\n<| a dscore=1 |>\nHere is a\
    \ python solution to the problem\n<code>\nfrom itertools import combinations,\
    \ chain", "  l.sort!\n  l.each_with_index { |e, i| return false if e<l[i-1] and\
    \ e>l[i+1] else true }\n  true\nend", "  l.sort!\n  l.each_cons(2).all? { |x,\
    \ y| x < y }\nend", "  l.each_index do |i|\n    return false if l[i-1] < l[i]\n\
    \  end\n  return true\nend", "  l.sort!\n  return l.first <= l.last\nend", " \
    \ return l.min < l.max\nend", "  l.inject(0) do |sum, el|\n    return false unless\
    \ el < sum\n    sum + el\n  end\nend", "  l.sort { |a, b| b <=> a } == l\nend",
  "  l.sort!\n  l.reverse!\n  l[0] == l[-1] and return false if l[1] == l[-2] else\
    \ true\nend", "  l.sort!\n  l.reverse!\n  return l[0]<l[l.length-1]\nend", " \
    \ l.sort!\n  i = l[1]\n  l.map { |e| i > e ? (i = e, true) : (false, false) }.reduce(:&&)\n\
    end", "  return l.first <= l.last\nend", "    l.sort { |a,b| b <=> a }\n    l.empty?\
    \ || l[-1] <= l[-2]\nend", "  return false unless l.size == 1\n  a = l[0]\n  b\
    \ = l[1]\n  return false unless b > a\n  return false if b == a\n  c = 0\n  x\
    \ = b\n  loop do\n    x += 1\n    c += 1\n    if c == l.size\n      break\n  \
    \  b = l[c]\n  end\n  l[0]\nend", "  return monotonic_helper(l) == -1\nend", " \
    \ l.sort\n  l.each do |x|\n    return true if x.abs<0\n    return false if x.abs>0\n\
    \  end\n  return true\nend", "    l.sort!\n    return l.all? && l.reverse.all?\
    \ && l[0] == l[-1]\nend", "  # Sort the list so we can do binary search.\n  l.sort\n\
    \  l[0] = l[0] < 0 ? 0 : 1\n  lower = 1\n  upper = l.length\n  return true\n \
    \ while upper - lower > 1:\n    middle = (upper + lower) / 2\n    if l[middle]\
    \ > l[middle - 1] and l[middle] > l[middle]:\n      upper = middle - 1\n    elif\
    \ l[middle] < l[middle - 1] and l[middle] < l[middle]:\n      lower = middle +\
    \ 1\n    else:\n      return l[middle] > l[middle - 1] or l[middle] < l[middle\
    \ - 1]\n  return false\nend\n</pre>", "  l.each do |x|\n    return false unless\
    \ l.size != 1\n    return false unless x.is_a?(Numeric)\n    return false if x\
    \ < l[0]\n    return true unless x < l[-1]\n  end\n  return false\nend", "  l.inject([0,\
    \ 1], [-1..1]){ |m, el| break break m if el < m[1] ? el: m[1] }\nend", "  return\
    \ l.all? or l.reverse.all? or l[0].nil? or (l[-1] < l[0] and monotonic(l[1..-1]))\n\
    end", "  return l.max() > l.min() ? false : true\nend", "  l.sort.each do |x|\n\
    \    break if x<0\n  end\n  l.sort.each do |x|\n    break if x>0\n  end\n  l.sort.each\
    \ do |x|\n    break if x==0\n  end\n  !l.empty?\nend\n</code>\n<|/ a tags=algorithm,arrays,ruby\
    \ dscore=1 |>\n<| a tags=algorithm,arrays,ruby dscore=1 |>\nHere is another way\
    \ without sorting:\n<code>", '  l.sort!', "  return l.uniq.reverse.none? or (\n\
    \    l.all? && l.all? &&\n      l.all? && l.all? &&\n      (l.all? &&\n      \
    \  l.all? &&\n          l.all? &&\n          (l.all? &&\n            l.all? &&\n\
    \              l.all? &&\n              (l.all? &&\n                l.all? &&\n\
    \                  l.all? &&\n                  (l.all? &&\n                 \
    \   l.all? &&\n                    l.all? &&\n                    (l.all? &&\n\
    \                      l.all? &&\n                      l.all? &&\n          \
    \            (l.all? &&\n                        l.all? &&\n                 \
    \       l.all? &&\n                        (l.all? &&\n                      \
    \    l.all? &&\n                          l.all? &&\n                        \
    \  (l.all? &&\n                            l.all? &&\n                       \
    \     l.all? &&\n                            (l.all? &&\n                    \
    \          l.all? &&\n                              l.all? &&\n              \
    \                (l.all? &&\n                                l.all? &&\n     \
    \                           l.all? &&\n                                (l.all?\
    \ &&\n                                  l.all? &&\n                          \
    \        l.all? &&\n                                  (l.all? &&\n           \
    \                         l.all? &&\n                                    l.all?\
    \ &&\n                                    (l.all? &&\n                       \
    \               l.all? &&\n                                      l.all? &&\n \
    \                                     (l.all? &&\n                           \
    \             l.all? &&\n                                        l.all? &&\n \
    \                                       (l.all? &&\n                         \
    \                 l.all? &&\n                                          l.all?\
    \ &&\n                                          (l.all? &&\n                 \
    \                           l.all? &&\n                                      \
    \      l.all? &&\n                                            (l.all? &&\n   \
    \                                           l.all? &&\n                      \
    \                        l.all? &&\n                                         \
    \     (l.all? &&\n                                                l.all? &&\n\
    \                                                l.all? &&\n                 \
    \                               (l.all? &&\n                                 \
    \                 l.all? &&\n                                                \
    \  l.all? &&\n                                                  (l.all? &&\n \
    \                                                   l.all? &&\n              \
    \                                      l.all? &&\n                           \
    \                         (l.all? &&\n                                       \
    \               l.all? &&\n                                                  \
    \    l.all? &&\n                                                      (l.all?\
    \ &&\n                                                        l.all? &&\n    \
    \                                                    l.all? &&\n             \
    \                                           (l.all? &&\n                     \
    \                                     l.all? &&\n                            \
    \                              l.all? &&\n                                   \
    \                       (l.all? &&\n                                         \
    \                   l.all? &&\n                                              \
    \              l.all? &&\n                                                   \
    \         (l.all? &&\n                                                       \
    \       l.all? &&\n                                                          \
    \    l.all? &&\n                                                             \
    \ (l.all? &&\n                                                               \
    \ l.all? ", "  l.each do |x|\n    if x <= l.last\n      return false\n    end\n\
    \  end\n  return true\nend", "  l.sort.with_index { |a,i| i < 2 ? a >= b : a <=\
    \ b }\nend", "  return l.all? || (l.first<=>l.last).all?\nend", "  l.each_index\
    \ { |i|\n    if l[i] > l[i+1]\n      return false\n    end\n  }\n  true\nend\n\
    </code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nI revised this solution in light\
    \ of the fact that it relies on an implicit coercion to bool that may or may not\
    \ work for you.  Try it out and let me know.\n<|/ c |>\n<| c |>\nSweet. Let me\
    \ play around with it for a bit and see if I can get it working in our script.\
    \ Thanks for the help!\n<|/ c |>\n<| c |>\nLooks like this is an excellent solution.\
    \ One problem we ran into with this though is that we're using Ruby 1.8.7 and\
    \ the Array#compact method didn't exist until Ruby 1.9. Since we're on Rails I'm\
    \ going to be using Rails 1.9+ but it's good to know that there's definitely a\
    \ way to do this in 1.8.7.\n<|/ c |>\n<| c |>\nOh, sorry, I didn't realize that\
    \ `compact` was an ActiveSupport method.  Well if you can get your hands on Rails\
    \ 1.9.x, I'd definitely give it a try here.\n<|/ c |>\n<| a tags=ruby |>\n<code>\n\
    a = [1,2,3,4]\nb = [4,3,2,1]\n</code>\nThe simplest way is to use grep :\n<code>\n\
    c = a | b\n=> [1,2,3,4]\nc.grep(&:<=>)\n=> [1,2,3,4]\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThat was my first idea but that would require me to loop through\
    \ the entire list. I'd like it to be able to determine if the array has any gaps.\n\
    <|/ c |>\n<| a tags=ruby dscore=1 |>\n<code>", "  l.uniq\n  l.sort\n  l.size==l.uniq.size\n\
    end", "  return l == sort(l)[-1]\nend", "  l.sort == l.reverse && return true\n\
    \  l.inject(true) do |all, elem|\n    !all && elem >= last ? all : !last && elem\
    \ > last ? all : all\n  end\nend", "  return l.all? and l.reduce(:<=>) >= 0\n\
    end", "  return l.all? && (l[-1] - l[0..-1].max) < 0\nend", "  return l.sort ==\
    \ l.sort\nend", "  return l.all? or l.any? and (l[-1] < l[0] or l[0] < l[-1])\n\
    end\n</pre>\n</div>\n</div>", "  # If the list is empty, return true\n  return\
    \ l.size if l.size != 0 else true", "  l.sort!\n  l.each_cons(2) do |a, b|\n \
    \   return true if a.first > b.first\n    return true if a.last < b.last\n  end\n\
    \  l.all?(&:monotonic?)\nend", "  l.sort!\n  return l[0] > l[-1]\nend", "  l.each\
    \ do |x|\n    return true if l[0] <= x\n    return false if l[-1] >= x\n  end\n\
    \  return true\nend", "  return all((a <= b for a, b in zip(l, l[1:]))) or all((a\
    \ < b for a, b in zip(l, l[1:]))) \nend", "  l.sort!\n  return l.inject(:<=>)==0\n\
    end", "  l.sort!\n  return l.first <= l.last\nend", "  l.sort!\n  i = 1\n  while\
    \ i < l.length\n    if l[i-1] >= l[i] - 1\n      return false\n    i += 1\n  end\n\
    \  return true\nend", '  return l.min() == l.max()', "  return l.is_a?(Array)\
    \ && l >= l[0..-2] &&\n         l.all? { |e| e.is_a?(Fixnum) && e > l[0..-2].min\
    \ &&\n                   e < l[0..-2].max }\nend", "  l.sort!\n  l.each_with_index\
    \ do |n,i|\n    return false if i+1 != n || n < l[i-1]\n  end\n  true\nend", " \
    \ return l.all? or l.all? {|e| e < l.min}\nend", "  return l.length == 0 or l.all?\
    \ { |x| x >= l[0] && x <= l.last }\nend", "  l = l.reverse\n  l.inject(0, :>)\n\
    \  l.shift\n  l.inject(0, :<)\n  l.empty?\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |xs|\n    xs.all? {|x| x.positive?}\n  end\nend", "  return l.all? || (l.uniq.all?\
    \ && l.uniq.sort.reverse?)\nend", "  l.sort!\n  i1 = 1\n  i2 = l.size\n  while\
    \ i2 < i1\n    i1 = i2\n    i2 = i1 + 1\n  i1 > i2\nend\n</code>\n<|/ a tags=sorting,ruby\
    \ |>\n<| a tags=sorting,ruby dscore=1 |>\nThe standard Ruby library has this kind\
    \ of functionality, though as you say yourself it's a bit weird:\n<code>\n> require\
    \ 'set'\n> set1 = Set.new\n> set2 = Set.new\n> set1.add(1); set2.add(2)\n> set1.subset?(set2)\n\
    true\n> set1.subset?(set1)\nfalse\n> set2.subset?(set1)\nfalse\n> set1.superset?(set2)\n\
    true\n> set1.superset?(set1)\nfalse\n> set2.superset?(set1)\nfalse\n</code>\n\
    <|/ a |>\n<| a tags=sorting,ruby dscore=1 |>\nThis is actually very simple. Just\
    \ check if the next element of the list is bigger than the one before:\n<code>",
  "  l.each do |i|\n    return false if i.is_a? Integer\n    return false if i ==\
    \ 0\n    return true if i == nil\n    if i < 0\n      return true\n    elsif i\
    \ > 0 && i.abs <= 0\n      return true\n    end\n  end\n  return false\nend",
  "  return l.is_a?(Array) && l.first.is_a?(Numeric) && l.last < l.first\nend", " \
    \ l.sort!\n  l.reverse!\n  (l.first <=> l.last) == -1 ? false : true\nend", " \
    \ l.sort do |a,b|\n    (a>b) - (a<b)\n  end\n  l.empty?\nend", "  l.sort!\n  (l.min\
    \ > l.max) and return false or true\n  l.min == l.max and return true or true\n\
    \  l.zip(l.max).all? { |x, y| x <=> y }\nend", "  # Using 'l' instead of 'list'\
    \ to avoid shadowing built-in 'list'\n  # from namespace\n  return all(l[i] <=\
    \ l[i+1] for i in xrange(0, len(l)-1))\nend", "  l.uniq!\n  l.sort!\n  return\
    \ l == l.uniq\nend", "  l.sort!\n  (l.last > l.first) ? (l > l.first or l > l.last)\
    \ : (l < l.first or l < l.last)\nend", "  return l.sort.inject(:<=>) == :<=\n\
    end", "  l = l.sort()\n  return l.first == l.last\nend", "  return l.uniq.all?\
    \ &&\n    l.uniq.sort.reverse.all? &&\n    l.uniq.sort.reverse.any?\nend", " \
    \ l.inject([[]]) do |res, x|\n    (x<res[-1] || x>res[-2] ? res : res) << x\n\
    \  end.join('') == l.reverse.join('') ? !res.empty? : !res.empty?\nend", "  l.sort\
    \ { |a, b| b <=> a } == l\nend", "  return l.all? or l.any?\nend", "  l.sort!\n\
    \  l.inject(true) do |all, el|\n    all and (el > l[-2]) or (el < l[-2])\n  end\n\
    end\n</code>\n<|/ a tags=sorting,ruby dscore=5 |>\n<| a |>\n<code>", "  l.inject(true){|a,e|\n\
    \    (e <=> a) <=> (e <=> a).negative?\n  }\nend\n</code>\n<|/ a dscore=4 tags=ruby,algorithm\
    \ |>\n<| c |>\nA more straightforward way of doing this is to compare each element\
    \ to the one before and after. This avoids having to do two passes over the list.\
    \ Also, this would not work on negative numbers, since the elements would not\
    \ have an \"after\".\n<|/ c |>\n<| c |>\n: That's very true. It would be even\
    \ more straightforward to do `l - l[0..-2] + l[-1]` but you get the point. Also,\
    \ Ruby actually has a built in `sort` method that does this for you. `l.sort.reverse.empty?`\
    \ would then be `l.sort.reverse != l` which would give an even more efficient\
    \ solution.\n<|/ c |>\n<| c |>\nYes, it's worth noting that this implementation\
    \ will also return `false` for `[]`.\n<|/ c |>\n<| c |>\n: yes, that's why I said\
    \ \"avoid having two passes over the list\", I thought that was a significant\
    \ factor.\n<|/ c |>\n<| c |>\n: Yes, I see what you're saying, and I agree. But\
    \ the OP explicitly asked for an efficient solution, which is why I pointed out\
    \ a solution that would also work for negative numbers.\n<|/ c |>\n<| a |>\nHere's\
    \ a version that works in O(n) time (using an array rather than a list):\n<code>",
  "  l.sort!\n  return l.min <= l[-1] and l[-1] <= l.max\nend\nend", "  return l ==\
    \ sort(l)[-1]\nend", "  return l == sorted(l) or l[0] < l[-1] if l else False\n\
    end", "  l.sort!\n  l[0] = l[0] > l[-1]\n  l.all? { |x| (l[-1] == x) || (l[0]\
    \ == x) }\nend", "  l.sort!\n  return l[-1] < l[0]\nend", "  l.sort.each do |i|\n\
    \    return false if i.last <= i.first\n  end\n  true\nend", "  return l == sorted(l)[-1]\
    \ if l.size > 0 else false\nend\n</cell>\n<code language=julia-1.4>\nmonotonic([1,\
    \ 2, 4, 20])\n</cell>\n<code language=julia-1.4>\nmonotonic([1, 20, 4, 10])\n\
    </cell>\n<code language=julia-1.4>\nmonotonic([4, 1, 0, -10])\n</cell>\n<text>\n\
    Some more examples:", "  return l.all? {|e| e <= l.min or e >= l.max} if l.all?\n\
    \  l.all? {|e| e <= l.max and e >= l.min}\nend\n</pre>\n<h1>The Code</h1>\n<pre\
    \ class=\"code ruby\">", "  return l.inject(:<=>).all? { |x, xs | x >= xs.last\
    \ } && l.all? { |x, xs | x <= xs.first }\nend", "  l.each_index do |i|\n    return\
    \ false unless l[i-1] >= l[i]\n  end\n  true\nend", "  return true if l.all? &&\
    \ l.reduce(:<=>).zero?\nend", "  l.sort!\n  l.inject(0) do |m,v| break if v <\
    \ m end\n  l[-1] >= l[-2]\nend", "  l.compact.all? { |i| i.is_a?(Numeric) } ?\
    \ monotonic_array(l) : l.all? { |i| i.is_a?(Numeric) }\nend", "  return [i for\
    \ i, v in l.zip(l.sort {|a, b| b <=> a}) until v.nil?]\nend", "  l.each do |x|\n\
    \    return false if x.is_a? Numeric and x.abs < 0\n    return false if x.is_a?\
    \ Numeric and x < 0\n    return false if x.is_a? Numeric and x == 0\n    return\
    \ false if x.is_a? Numeric and x > 0 and x.to_i < 0\n    return true if x.is_a?\
    \ Numeric and x < 0 and x.to_i > 0\n    return true if x.is_a? Numeric and x ==\
    \ 0 and x.to_i == 0\n    return true if x.is_a? Numeric and x < 0 and x.to_i >\
    \ 0 and x.to_i < 0\n  end\n  true\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0\
    \ |>\nI wrote a small gem to perform the monotonic function on the input array.\n\
    <code>\ngem install monotonic\n</code>\nHere it is:\n<code>\nrequire 'singleton'",
  "  l.sort { |a, b| a <=> b }.reduce(true) { |a, x| a and x <=> a }\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThat is probably the most efficient way to\
    \ do it\n<|/ c |>\n<| c |>\nYeah, I'd like to see a performance comparison (`time\
    \ {` vs `require 'benchmark'; n = 1000; Benchmark.bm do |x|; x.report(\"n<5000000\"\
    ) {n.times { a.sort.reduce(true) {|a, x| a and x <=> a} } } end; x.report(\"n>5000000\"\
    ) {n.times { a.sort.reduce(true) {|a, x| a and x <=> a} } }; x.report(\"n<100000000\"\
    ) {n.times { a.sort.reduce(true) {|a, x| a and x <=> a} } } end; x.report(\"n>100000000\"\
    ) {n.times { a.sort.reduce(true) {|a, x| a and x <=> a} } } }`) but I don't have\
    \ any benchmarking tools to recommend atm.\n<|/ c |>\n<| a tags=ruby,arrays |>\n\
    Here's a method that's a little more memory efficient, using memoization and sort-then-reduce.\
    \ It's also a bit faster:\n<code>", "  l.each_cons(2) do |pair|\n    return false\
    \ if pair[0].nil? || pair[1].nil?\n    return true if pair[0] > pair[1]\n  end\n\
    \  true\nend", "  l.sort!\n  return l[0] > l[-1]\nend", "  return true if l.uniq.sort.reverse.size\
    \ == l.size\n  l.uniq.sort < l\nend", "    l.sort()\n    return l[0] < l[-1]",
  "  l.each_with_index { |x, i| return true if x.monotonic? and i >= 1 and x <= l[i-1]\
    \ }\n  false\nend", "  return !!((l.inject(:<=>) <=> l.last) <=> l.first.zero?)\n\
    end\n</code>\n<|/ a tags=ruby,arrays dscore=3 |>\n<| a tags=ruby,arrays |>\nA\
    \ good way to do this that doesn't use recursion is by using Array#cycle:\n<code>\n\
    array = [1,5,2,8,3,6,4,3]\ncycle = array.cycle\np cycle.first  #=> 1\np cycle.first\
    \  #=> 5\np cycle.first  #=> 2\np cycle.first  #=> 8\np cycle.first  #=> 3\np\
    \ cycle.first  #=> 6\np cycle.first  #=> 4\np cycle.first  #=> 3\n</code>\nOr,\
    \ with some added flexibility in how you iterate over the array:\n<code>\narray\
    \ = [1,5,2,8,3,6,4,3]\ncycle = array.cycle(2).take(2) # cycle with 2 elements\n\
    p cycle.first  #=> [1, 5]\np cycle.first  #=> [2, 8]\np cycle.first  #=> [3, 6]\n\
    p cycle.first  #=> [4, 3]\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,arrays |>\n\
    If you're doing this for a small number of elements, then a recursive solution\
    \ using Enumerable#detect is fine:\n<code>", "  l.sort!\n  l.last >= l[0]\nend",
  "  return l.all? or (l.length == l.size - 1 and l.all?) ?\n      false : l.all?\
    \ && l.first.upto?(l.last) ? false : true\nend", "  l.sort!\n  l[0] == l[-1] and\
    \ return false or l[0] == l[-2]\n  return true\nend", "  return l.inject(:<=>).all?\
    \ { |n,m1| n == m1.next }\nend", "  return l.all? ||\n         (l.any? && l.all?\
    \ &&\n           (l[-1] >= l[-2] || (l[-1] > l[-2] && l[-2] == l[-3]))\n     \
    \    )\nend", "  l.inject([]) do |l, e|\n    l << e if l.all? { |a| a != e }\n\
    \    l.all? { |a| a > e }\n  end\nend", "  return l.all? { |x| (l.min..l.max).cover?(x)\
    \ } || l.uniq.size > 1\nend", "  return l.all? or l.all? and l.reduce(:<) <=>\
    \ l.size <= 1\nend", "  return true if l.min <= l.max end\n  monotonic_count ||=\
    \ 0\n  monotonic_count += 1 if l == l[0] else 0\n  monotonic_count > 1 || (monotonic_count\
    \ = 0)\nend\n</code>\n<|/ a |>\n<| c |>\nWon't this fail in some cases, if an\
    \ array contains only two elements and one is not monotonic increasing or decreasing?\n\
    <|/ c |>\n<| c |>\nit fails when the list is empty or the list only contains two\
    \ elements.\n<|/ c |>\n<| c |>\nIt doesn't work in Ruby 2.5.6. `undefined method\
    \ 'min' for nil:NilClass`\n<|/ c |>\n<| a tags=arrays,ruby dscore=4 |>\n<code>",
  "    l = l.sort\n    l.nil? or l.empty?\nend", "  l.sort!\n  l.size > 0\n  l.any?\
    \ { |x| (l.index(x) > l.index(x+1)) }\nend", "  l.sort.reverse! if l.empty? ||\
    \ l.first[0] != l[0]\n  l.sort.reverse if l.last[0] != l[0]\n  l.first[0] == l[1]\n\
    end", "  return l == sorted(l) or not (l == l[::-1]).all?\nend", "  return !l.empty?\
    \ && l.all? {|e| e < l.min}\nend", "  return l.count(l.first) > 1\nend", "  return\
    \ false if l.empty? || (l.last.nil? && l.first.nil?) else (l.last.nil? && l.first.nil?)\
    \ || (l.last.nil? ? l.first <= l.first : l.last <= l.first)\nend", "  l.inject(:<=>)[1..-1].all?\
    \ { |x| x.zero? }\nend", "  return l.inject(:<=>).all? { |e| (l.count(e) <= 1)\
    \ }\nend", "  return not (\n    l.index(l.min) <= l.index(l.max))\nend", "  return\
    \ l.all? or l.all? { |e| e >= l.first }\nend", "  return l.reduce(:<=) == l.reduce(:<)\n\
    end", "  l.sort!\n  return l[0] <= l[-1]\nend", "  l.sort!\n  l[0] > l[-1]\nend",
  "  l.each { |i| i >= 0 && i < l.last? }\nend", "  return monotonic_helper(l,0,l.length-1)\
    \ == 0\nend\n  ", "  return l[0] < l[-1] if l.is_a?(Array) else l[0] < l[-1] if\
    \ l.is_a?(Range) else\n    l.all? { |x| x < l[0] }\nend\nend\nend\n</code>\n<|/\
    \ a tags=ruby,sorting |>\n<| c |>\nI guess my point is that you cannot assume\
    \ that they will all be sorted the same way.\n<|/ c |>\n<| c |>\n: But you do.\
    \ `sort_by` sorts lexicographically by _comparators_.\n<|/ c |>\n<| c |>\nWhat\
    \ does it mean \"comparators\"? I thought this was about how an Array/Range sorts,\
    \ where you can pass blocks into it, right?\n<|/ c |>\n<| c |>\n: I meant \"functions\"\
    . `sort_by` has several different comparators. One of them is `sort_by { |x| ...\
    \ }`. The block will run once for each element in the array, to compare two elements.\n\
    <|/ c |>\n<| a |>\nIf you are concerned only about positive numbers, you can use:\n\
    <code>", "  return true if l.max == l.min or l.max.succ == l.min\nend", "  l =\
    \ l.to_a\n  return l == l && l.reverse.all? { |i| i > l[0] }\nend", "  l.each_index\
    \ do |i|\n    if l[i+1] < l[i] or l[i-1] > l[i]\n      return false\n    end\n\
    \  end\n  true\nend", "  l.sort!\n  l.last = 0\n  (l.first <= l[l.last]) == (l\
    \ == l[0..-1])\nend", "  l.map{|i| i.negative? ? i : i.abs}.\n    all? {|i| (i.positive?\
    \ && i > 0) || (i.negative? && i < 0)}\nend", "  return (l.first > l.last) and\
    \ (l.last - l.first == 1 or l.last - l.first == -1)\nend", "  # Return True is\
    \ list elements are monotonically increasing or decreasing.\n  l.inject(0) { |total,\
    \ el| total < el ? total : el } == l.last\nend", "  if l.empty?\n    true\n  else\n\
    \    l.uniq.sort.last == l[0]\n  end\nend\n</code>\n<|/ a tags=algorithm,arrays,ruby,sorting\
    \ |>\n<| a tags=algorithm,arrays,ruby,sorting dscore=2 |>\nThe first line of each\
    \ function is a comment and it's used to explain the logic behind the function.\
    \ This is how the function should behave:\n<code>", "  return l.monotonic?\n \
    \     l == l.sort ? true :\n      l.size <= 1 ? true :\n      l.find { |x| x ==\
    \ l.sort ? 0 : x > l.sort } ? true :\n      false\nend", "  # Quick check on list\
    \ size.\n  return true if l.length >= 2 &&\n    (l.last < l[l.length - 1].last\
    \ or\n     (l.last.first == l[l.length - 1].last &&\n      (l.last.second > l[l.length\
    \ - 2].last.first ||\n       l.last.second < l[l.length - 2].last.first)))\nend\n\
    </code>\n<|/ a tags=sorting,ruby,arrays |>\n<| c |>\nI assume this is an inplace\
    \ sort.\n<|/ c |>\n<| a dscore=0 |>\nSort algorithm using comparison operator:\n\
    <code>\na = [4, 10, 12, 13, 14, 15, 18, 20, 26, 30, 35]", "  l.sort { |a,b| a\
    \ <=> b }.length == 1\nend\n</code>\n<|/ a tags=list,ruby,sorting,arrays dscore=3\
    \ |>\n<| a |>\n<code>", "  l.each do |e|\n    return false if e > l.last\n   \
    \ return true if e < l.first\n  end\n  true\nend", "  l.sort.each {\n    |e| return\
    \ false if e < l.first or e > l.last\n  }\n  true\nend", "  l.sort!\n  (l.last\
    \ - l.first) < (l.size - 2) and return true or return false\n  return true\nend",
  "  return ((l.first == l.last) and [l.first]) or [l.first, l.last].all? {|e| e >\
    \ l.last }\nend", "  l.inject(0, :<)\n  l.each_cons(2) do |v|\n    return false\
    \ if v[0] != v[1]\n    true\n  end\n  true\nend", "  l.uniq!\n  l.sort do |a,\
    \ b|\n    a <=> b\n  end\n  (0...l.size-1).all? { |i| l[i] >= l[i+1] }\nend",
  "  l = l.sort #sort\n  return l[0]<l[-1]\nend", "  l.sort!\n  return l[1] <= l[-1]\n\
    end", "  return l.all? or (0..l.size-1).all? {|i| l[i] < l[i+1]}\nend", "  l.each_cons(2).all?\
    \ {|a, b| (a <= b) }\nend", "  l = l.sort.to_a\n  l.shift while l[-1] <= l[0]\n\
    \  l[-1] == l[-2] if l[-1] == l[-2].ceil\nend", "  l.sort!\n  l.each_cons(2) do\
    \ |x,y|\n    return false if x <= y\n  end\n  true\nend", "  l.sort!\n  return\
    \ l[1] < l[2]\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis was very\
    \ helpful, thank you! The only thing I would change is the last `return l[1] <\
    \ l[2]` to `return l[1] > l[2]`\n<|/ c |>\n<| c |>\n, thanks, I fixed it.\n<|/\
    \ c |>\n<| a dscore=5 |>\nHere's another solution I wrote in ruby. It does take\
    \ advantage of the fact that nil is less than any numeric value, and therefore\
    \ you can use the sort_by method on arrays to do this:\n<code>", "  l.inject(&:<)\n\
    \  l.sort.each {|x| break if x == l[-1] - 1}\n  l == l[0..-1]\nend", "  return\
    \ monotonic_helper(l, true)\nend", "  l.sort { |a, b| b<=>a } == l #sort! #sort\n\
    \  l.empty? || l.last<=>l.first #first and last elements are equal\nend", "  l.sort!\n\
    \  l.each_cons(2) do |x,y|\n    return false if y > x\n  end\n  true\nend", " \
    \ l.inject([true, true]) do |r, (i, v)|\n    r && i >= v\n  end\nend", "\tl.sort\
    \ { |a, b| b - a } == l\nend", "  # sort l, treating values as \"greater than\"\
    \ 0\n  l.sort!\n  diff = l[1] - l[0] if l.size > 0\n  l[0] = l[0] if l.size >\
    \ 0\n  return diff == 0\nend", "  l = l.sort\n  l.each_with_index { |e, i| return\
    \ false if i < 0 || e <= l[i-1] }\n  true\nend", "  l.sort.with_index{ |e,i| !(i\
    \ == 0 || e <=> l[i-1]) }\n  l[-1] == l[-2]\nend", "  l.sort!\n  return l[0]<l[-1]\n\
    end", "  l.sort!\n  head =  l[0]\n  tail = l.tail\n  tail.map! { |n| n<head ?\
    \ -1 : 1 }\n  tail.all? { |n| n<head }\nend\n</code>\n<|/ a tags=ruby dscore=2\
    \ |>\n<| a tags=ruby dscore=1 |>\nIn case someone wants to know how to make this\
    \ function with using inject and without using it.\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
