name: HumanEval_40_triples_sum_to_zero
language: rb
prompt: "# triples_sum_to_zero takes a list of integers as an input.\n# it returns\
  \ True if there are three distinct elements in the list that\n# sum to zero, and\
  \ False otherwise.\n# >>> triples_sum_to_zero([1, 3, 5, 0])\n# False\n# >>> triples_sum_to_zero([1,\
  \ 3, -2, 1])\n# True\n# >>> triples_sum_to_zero([1, 2, 3, 7])\n# False\n# >>> triples_sum_to_zero([2,\
  \ 4, -5, 3, 9, 7])\n# True\n# >>> triples_sum_to_zero([1])\n# False\ndef triples_sum_to_zero(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triples_sum_to_zero\n\
  \    candidate = method(:triples_sum_to_zero)\n    assert_equal(false, candidate.call([1,\
  \ 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, 5, -1]))\n    assert_equal(true,\
  \ candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2,\
  \ 3, 7]))\n    assert_equal(false, candidate.call([1, 2, 5, 7]))\n    assert_equal(true,\
  \ candidate.call([2, 4, -5, 3, 9, 7]))\n    assert_equal(false, candidate.call([1]))\n\
  \    assert_equal(false, candidate.call([1, 3, 5, -100]))\n    assert_equal(false,\
  \ candidate.call([100, 3, 5, -100]))\n  end\nend\n"
completions: ["  l.group_by {|x| x%2 == 0}.all? {|k| k.all? {|x| x%3 == 0}}\nend",
  "  l.uniq.length == 3 and l.uniq.sum == 0\nend", "  sum = 0\n  for i in l\n    sum\
    \ += i\n    return true if sum == 3 # returns true if sum is equal to three\n\
    \    return false if sum > 3 # returns false if sum is not equal to three\n  end\n\
    end\nputs triples_sum_to_zero([1, 2, 3, 7])\nputs triples_sum_to_zero([2, 4, -5,\
    \ 3, 9, 7])\nputs triples_sum_to_zero([1])\nputs triples_sum_to_zero([-7, -2,\
    \ -1])", "  l.each_with_index { |e, i|\n    return false if (i - 1) <= 0\n   \
    \ return false if (e - l[i - 1]) <= 0\n    return false if (e + l[i - 1] - l[i])\
    \ <= 0\n    return false\n  }\n  true\nend", "  l.each_index do |i|\n    return\
    \ true if l[i..-1].uniq.count == 3\n  end\n  return false\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nPlease use backticks instead of apostrophes to format\
    \ your code.\n<|/ c |>\n<| c |>\nThank you for the tip! I edited my answer.\n\
    <|/ c |>\n<| c |>\nPlease add an explanation to your code. As it is now, it's\
    \ hard to understand the logic of what's going on.\n<|/ c |>\n<| c |>\nI don't\
    \ think it's hard to understand, I added comments to make it clear. Do you think\
    \ I should remove it from the answer?\n<|/ c |>\n<| c |>\nYes, it seems like it's\
    \ better to include an explanation on the text instead of adding it as an answer.\n\
    <|/ c |>\n<| a tags=ruby,arrays,algorithm |>\nMy solution\n<code>", "  triples\
    \ = 0\n  sum = 0\n  \n  for i in l\n    if sum == 0\n      sum = i\n    else\n\
    \      if sum + i == 0\n        triples+=1\n      else\n        if sum > 0\n \
    \         sum += i\n          triples+=1\n        else\n          return false\n\
    \        end\n      end\n    end\n  end\n  return triples == 3\nend", "    l.sort\n\
    \    (first, second, third) = l\n    return first + second == 0 and third != 0\
    \ or third == 0 and first != 0", "  l.sort.reverse\n  i = 0\n  while i < l.length\n\
    \    if l[i] + l[i+1] + l[i+2] == 0\n      return true\n    i += 1\n  end\n  false\n\
    end", "    # Your code here\n    sum=0\n    i=0\n    j=0\n    k=0\n    for x in\
    \ l:\n        if x<0:\n            x=-x\n        sum+=x\n        if sum>0:\n \
    \           if i>j:\n                j=i\n            if j>k:\n              \
    \  k=j\n            i=i+1\n        else:\n            if i<k:\n              \
    \  k=i\n            i=i+1\n    return k==j\n</cell>\n<cell>", "  l.sort!\n  return\
    \ l.inject(:+) == 0 && l.uniq.length == 3\nend", "  l.each do |i|\n    break if\
    \ i == 0\n    break if i == 1\n    break if i == 2\n  end\n  triples_to_zero =\
    \ false\n  l.each do |i|\n    break if i == 0\n    break if i == 1\n    break\
    \ if i == 2\n    triples_to_zero = true if i == 6\n  end\n  triples_to_zero\n\
    end\n</code>\nTo write this more efficiently, you should have written it in Ruby\
    \ or another language which can do tail recursion (such as Haskell) using a functional\
    \ style. However the above is more efficient and simpler. The following version\
    \ is almost as simple as your original one and very efficient:\n<code>", '  return
    l.count(l.count(l[0]) + l.count(l[1]) + l.count(l[2])) == 3', "  return !l ||\
    \ l.count(l[0]) == 3 && l.uniq.count {|x| x.abs == 0}\nend", "  return l.length\
    \ == 3 &&\n          l.count(0) == 3 &&\n          l.reduce(:+) == 0\nend\n</cell>\n\
    <cell>", "    unique=l.uniq\n    i=0\n    triples_sum=l.select { |x| x<0 }.inject(0)\
    \ {|sum,x| sum+x }\n    while i<unique.length\n        i+=1\n        triples=\
    \ unique.select { |x| x<0 }.select { |x| x>=0 }\n        if triples.size == 3\n\
    \            return true\n        end\n    end\n    return false\nend", "  l.sort\n\
    \  i = 0\n  sum = 0\n  while i < l.length\n    sum = sum + l[i]\n    if sum <\
    \ 0\n      sum = 0\n    i += 1\n    j = i\n    k = i\n    while k < l.length\n\
    \      sum = sum + l[k]\n      if sum < 0\n        sum = 0\n      k += 1\n   \
    \   if sum == 0\n        return true\n    end\n  end\n  return false\nend\n</cell>\n\
    <code language=julia-0.5>", "  l.sort!\n  return l.uniq.length == 3 && l.uniq.inject(true,\
    \ :+) == 0 && l.uniq.size == 3\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,algorithm,language-agnostic\
    \ |>\nHere's a solution using hashes and Enumerable#each:\n<code>", '  return
    triples_sum_to_zero_2(l) > 0 # returns bool', "    count = 0\n    triple = 0\n\
    \    for i in l do\n        if i > 0\n            if i < triple\n            \
    \    count = count + 1\n            triple = triple\n        else\n          \
    \  count = count + 1\n    end\n    return count == 3\nend", "    l.sort!\n   \
    \ return false\n    three_values = l.count{|x| (x + x + x)==0 } == 3\n    l.sort!\n\
    \    return three_values\nend", "    l.sort\n    l.each do |x|\n        if x !=\
    \ l[0] + l[1] + l[2]\n            return false\n        end\n    end\n    true\n\
    end\n</code>\nI then used the following to create a boolean function:\n<code>",
  "  l.each_with_index do |x, i|\n    break if i.odd? || i > 0 # Don't check odd elements\
    \ at the beginning\n    l.each do |y|\n      break if y.odd? || y > x # Don't\
    \ check even elements at the end\n      break if y <= x && y > 0 # Don't check\
    \ negative numbers in the middle\n      break unless i + y < l.length # Don't\
    \ check duplicate numbers\n    end\n  end\n  l.count { |x| x == 0 } == l.size\n\
    end\n</code>\nLet's see if it works:\n<code>\ntriples_sum_to_zero([1,3,5,0])\n\
    => false\ntriples_sum_to_zero([1,3,-2,1])\n=> true\ntriples_sum_to_zero([1,2,3,7])\n\
    => false\ntriples_sum_to_zero([2,4,-5,3,9,7])\n=> true\ntriples_sum_to_zero([1])\n\
    => false\n</code>\nNow let's see if it's fast enough:\n<code>\nrequire 'benchmark'\n\
    Benchmark.bm do |b|\n  b.report(\"sum_to_zero\") { triples_sum_to_zero([1, 3,\
    \ 5, 0]) }\n  b.report(\"sum_to_zero\") { triples_sum_to_zero([1, 3, -2, 1]) }\n\
    \  b.report(\"sum_to_zero\") { triples_sum_to_zero([1, 2, 3, 7]) }\n  b.report(\"\
    sum_to_zero\") { triples_sum_to_zero([2, 4, -5, 3, 9, 7]) }\n  b.report(\"sum_to_zero\"\
    ) { triples_sum_to_zero([1]) }\nend", "  l.uniq.size == 3\nend", "    l.sort\n\
    \    (l[0] + l[1] + l[2]) == 0 && l.all? { |x| x != 0 }\nend\n</code>\n<|/ a tags=ruby,sum,arrays\
    \ |>\n<| c |>\nThis passes the test cases, however doesn't provide an explanation\
    \ as to what it's doing (although it does provide an interesting Ruby idiom, which\
    \ is very nice!).\n<|/ c |>\n<| c |>\nI added the explanation to the answer. Hopefully\
    \ it's useful. :-)\n<|/ c |>\n<| c |>\nI didn't downvote you, but I agree with\
    \ this answer that the question, as currently phrased, does not describe a programming\
    \ problem, but more of a *algorithm* problem.\n<|/ c |>\n<| c |>\nI disagree with\
    \ you on that part. I believe that this is a valid programming problem, as this\
    \ solution doesn't require any additional data structures beyond `Array` which\
    \ would make it more efficient than mine. Also, it's not really a homework question.\
    \ I just happen to like programming so I thought I'd give it a try!\n<|/ c |>\n\
    <| c |>\nSorry about that, didn't mean to offend. Your answer is very clever,\
    \ and I like it. I think it's good to see people like yourself on SO.\n<|/ c |>\n\
    <| a dscore=3 |>\nThis was asked recently and got many answers, so here is the\
    \ solution I went with:\n<code>", "    l.sort! # sort the list\n    triples =\
    \ []\n    triples << []\n    triples << [1, 0, 0] if l[0] == 1\n    triples <<\
    \ [0, 0, 1] if l[1] == 1\n    triples << [0, 1, 0] if l[2] == 1\n    return triples.all?\
    \ { |triple| triple.sum == 0 }\nend", "  l.sort!\n  threes=0\n  fours=0\n  fives=0\n\
    \  for i in (0..l.length-1)\n    threes+=l[i]\n    fours+=l[i+3]\n    fives+=l[i+6]\n\
    \    if threes>0 and fours==3 and fives==0\n      return true\n  end\n  return\
    \ false\nend\n</code>\n<|/ a |>\n<| c |>\nThanks so much for your answer, this\
    \ is an interesting solution! I decided to go with [Marshall's solution](http://stackoverflow.com/a/13483313/1246996)\
    \ because I like how it works and because I like how it is short and clear. I\
    \ agree that my solution doesn't require a pre-calculation of all possible triples\
    \ (which is important for larger lists), which makes it a much more efficient\
    \ solution for small lists.\n<|/ c |>\n<| a |>\nMy answer to this question shows\
    \ how to find all combinations within a given range\n<|/ a dscore=1 tags=language-agnostic,math\
    \ |>\n<| c |>\nThanks for your answer, but this isn't what I'm looking for. This\
    \ solution simply generates all possible permutations of the list. I want to find\
    \ all triples that sum to a specific number, not all permutations.\n<|/ c |>\n\
    <| c |>\n, ah, I see, I missed that part. I'm not sure how to go about doing that\
    \ - I think you have to generate all permutations and then filter the ones that\
    \ match the conditions. There are algorithms to do that with time complexity O(n!),\
    \ although I feel like it may be too slow for your case.\n<|/ c |>\n<| c |>\n\
    Yeah, I was afraid that was the case. I guess I'll have to go with Marshall's\
    \ solution then. Thanks for your help!\n<|/ c |>\n<| a tags=language-agnostic,math\
    \ |>\nI've written an algorithm for finding the unique combinations from some\
    \ sort of set. As this problem has many applications I've included it here, and\
    \ also a Ruby implementation. I hope it helps. I've used my own set type, but\
    \ this could be easily adapted for a more general usage.\n<code>\nrequire 'set'",
  "  return l.length == 2 and l.all? { |n| n <= 0 }\nend\n</cell>\n<text>\nSimplify\
    \ and test your solution", "  # initialize answer to False\n  answer = False\n\
    \  # initialize our sum to zero\n  sum_to_zero = 0\n  # initialize a counter variable\n\
    \  counter = 1\n  # loop through each item in the list\n  for i in l\n    # if\
    \ that item is not zero and not a negative number\n    if i != 0 and i > 0\n \
    \     # add it to the sum variable\n      sum_to_zero += i\n      # if we've added\
    \ our three numbers to the sum\n      if sum_to_zero >= 3 \n        # update the\
    \ answer\n        answer = True\n      # increment our counter by 1\n      counter\
    \ += 1\n  # return our answer\n  answer\nend\n</cell>\n<cell>", "  return triples_sum_to_zero_aux(l,\
    \ 0, 3, 3, 0, 1) if (l.reduce(:+) == 0) else false\nend", "  l.uniq.length ==\
    \ 3\n  l.uniq.all? {|x| x.zero?}\nend", "  l.sort!\n  l.reduce(:+) == 0\nend",
  "  return l.count(l) == 3 and l.count(l[0]) == 3 and l.count(l[1]) == 0\nend", " \
    \ # initialize a variable to store the number of distinct elements in the list\n\
    \  n = l.size", "  l.each_with_index do |x, i|\n    next if i==0\n    l.each_with_index\
    \ do |y, j|\n      next if j==0\n      if x+y == 0\n        return true\n    \
    \  end\n    end\n  end\n  return false\nend", "    l.sort!\n    (0...l.size).all?\
    \ {|i| (l[i] + l[i+1] + l[i+2]) == 0 }\nend\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nThe question specifically asks for *O(n)* solutions, though, so the sort\
    \ is really unnecessary.\n<|/ c |>\n<| c |>\nThanks for pointing that out.  I\
    \ suppose I wasn't very clear on that point.  I meant that your solution *was*\
    \ O(n), but I was thinking of the case where no three elements sum to zero.  I'll\
    \ modify the answer to remove that possibility.\n<|/ c |>\n<| c |>\nI think the\
    \ new solution will be O(n log n).\n<|/ c |>\n<| c |>\nNot really, no.  In case\
    \ of a tie, your solution will return the lowest element among them all.  What\
    \ you were probably thinking of was `O(n^2)` - my `O(n)` solution is still O(n).\n\
    <|/ c |>\n<| c |>\nYou edited the question to say that O(n) is OK, but that it\
    \ should return true iff there exists a triplet in the list whose sum equals zero.\
    \  But the example output you gave, where there are two such triplets, only says\
    \ that they exist, whereas the example output you said was correct, was that there\
    \ were three elements in the list that sum to zero.\n<|/ c |>\n<| a tags=sum,arrays,ruby\
    \ dscore=2 |>\n<code>", "  l.sort!\n  l.each_with_index do |e,i|\n    next if\
    \ i==0\n    l.slice!(i+1,i).inject(0) do |sum,x|\n      sum + x == 0 ? true :\
    \ false\n    end\n  end\nend", "  l.uniq.map { |e| (e + e + e).zero? }.reduce\
    \ { |a, e| a || e }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis isn't quite\
    \ correct.  It returns false if the array contains any number other than zero,\
    \ not if there are three distinct numbers that sum to zero.\n<|/ c |>\n<| c |>\n\
    I believe that is how I read it, and my test case is correct.  I believe they\
    \ meant to say \"three distinct elements in the list that sum to zero\"\n<|/ c\
    \ |>\n<| a dscore=0 tags=ruby,arrays |>\n<code>", "  return l.count(l[0]+l[1]+l[2])\
    \ == 0\nend", "  tri_a = l.count(l.first)\n  tri_b = l.count(l.last)\n  tri_c\
    \ = l.count(l.sum)\n  return tri_a == tri_b == tri_c\nend", "  sum = 0\n  for\
    \ i in l\n    sum += i\n  end\n  l.reduce(:+) == 0\nend\n</cell>\n<cell>", " \
    \ l.reduce! do |res, num|\n    return res == num if num > 0\n    return res +\
    \ num if num < 0\n    return 0\n  end\n  res[0] == res[-1] == res[-2]\nend", " \
    \ sum = 0\n  for i in l\n    sum += i\n    return sum == 0\nend\n  ", "  l.each_with_index\
    \ do |v, i|\n    next if i == 0 || i == l.length - 1 || l[i] == 0\n    l.slice!(i,\
    \ 3)\n    break if v == 0 && triple_sum?(l)\n  end\nend", "  l.each do |x|\n \
    \   x += (x % 3) * (x % 3 != 0) && (x % 3 != 0)\n  end\n  return l.size < 3\n\
    end", "  # Your code here\n  i = 0\n  while i < l.size\n    (a + b + c) <= 0\n\
    \    a, b, c = l[i], l[i + 1], l[i + 2]\n    i += 1\n  end\n  a + b + c == 0\n\
    end", "  return l.count(l.count(l[0]) == 3) and l.count(l[-2]) == 0\nend", " \
    \ return l.count(3) == 1 and l.count(-3)  == 0 and l.count(0) == 0\nend", "  l.each_cons(3).inject(true,\
    \ :&)\nend", "  triples = l.select(&:positive?)\n  triples.inject(0) {|memo,x|\
    \ memo + x } == 0 \nend", "  return l.count(l[0]) == 3 and l.count(l[1]) == 3\
    \ and l.count(l[2]) == 0\nend", "  return l == [0, 0, 0] and l.count(l) == 3\n\
    end", "  l.sort!\n  return l.inject(:+) == 0 && l.uniq.length == 3\nend", "  \
    \  triples = []\n    count = 0\n    \n    # loop through each element of the list\n\
    \    for num in l\n        # if the current element is greater than zero\n   \
    \     if num > 0\n            # add it to triple if it is bigger than the last\n\
    \            # element in triples\n            if triples.last\n             \
    \   triples[-1] += num\n                # if the current triplet is less than\
    \ or equal to zero\n            elsif triples.last\n                # increase\
    \ count of triples already found\n                count += 1\n               \
    \ # if the current triplet is bigger than the last\n                # in triples\n\
    \                if triples.last > num\n                    # append the current\
    \ triple\n                    triples << num\n                # otherwise the\
    \ current triplet is less than the\n                # last in triples\n      \
    \          else\n                    # if the triplets count equals 3\n      \
    \              elsif count == 3\n                        # return true\n     \
    \                   return(true)\n                    # else the current triplet\
    \ is bigger than the\n                    # last in triples\n                \
    \    else\n                        # append the current triple\n             \
    \           triples << num\n            # if the current triplets count is less\
    \ than 3\n            else\n                # if the last element of triplets\
    \ count equals 3\n                if triples.last == 3\n                    #\
    \ return true\n                    return(true)\n                # else append\
    \ the current triple\n                else\n                    triples << num\n\
    \    # return false\n    return(false)", "    # initialize counters\n    zero\
    \ = 0\n    sum_ones = 0\n    # loop through list\n    for n in l\n        # if\
    \ the next element is not zero\n        if n != zero\n            # increment\
    \ the counter by one\n            sum_ones += 1\n        # if the next element\
    \ is zero\n        else\n            # increase the zero counter by one\n    \
    \        zero += 1\n            # if the three counters are equal\n          \
    \  if sum_ones == 3\n                # return True\n                return True\n\
    \            # else return False\n            return False\n    # if the zero\
    \ counter has reached zero\n    if zero == 0\n        # return False\n       \
    \ return False\n    # else return True\n    return True\n</code>\n<|/ a tags=python,python-3.x\
    \ dscore=0 |>\n<| c |>\ni can't run this on my system as it give me an error \"\
    unexpected indent \" , any solutions for this?\n<|/ c |>\n<| c |>\nThis code is\
    \ indented exactly as the example above. Are you sure you copied it correctly?\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "    l.each do |x|\n        break if x ==\
    \ 0\n        l.each do |y|\n            break if y == 0\n            l.each do\
    \ |z|\n                l.delete(z)\n                return false if l.length ==\
    \ 0\n            end\n        end\n    end\n    true\nend\n</cell>\n<cell>", " \
    \ l.sort\n  count = 0\n  l.reverse\n  sum = 0\n  while l.length >= 3\n    x =\
    \ l.shift\n    y = l.shift\n    sum += x\n    count += 1 if y == 0 and sum ==\
    \ 0 end\n    sum -= y\n    count += 1\n    sum < 0 and break\n  end\n  count ==\
    \ 3\nend", "  l.inject(true){|t, e| t == false and e < 0}\nend", "  trip_count\
    \ = 0\n  for i in 0...l\n    for j in i..l\n      for k in j..l\n        if k\
    \ == 0 and i != j and j != i\n          return false\n        elsif k == 0 and\
    \ i != j\n          trip_count += 1\n        end\n      end\n    end\n  end\n\
    \  return trip_count == 3\nend", "  return l.sort.group_by {|x| x % 3 }.all? {|k,\
    \ v| v.sort.group_by {|x| x % 3 }.all? {|k, v| v }}\nend", "  s.clear\n  l.each\
    \ do |x|\n    if (x.odd?)\n      s.push x\n    end\n  end\n  s.each do |x|\n \
    \   if (x.even?)\n      return false unless s.include?(x.to_i) * s.include?(x.to_i)\
    \ * s.include?(x.to_i)\n    end\n  end\n  true\nend", "  sum = 0\n  for i in l\n\
    \    if sum + i < 0\n      sum += 1\n    else\n      sum -= i\n  return sum ==\
    \ 0\nend", "  if l.length < 3\n    return false\n  triples = []\n  l.each_index\
    \ {|i|\n    if triples.length >= 3\n      return\n    triples << l[i] + l[i+1]\
    \ + l[i+2]\n  }\n  return triples.uniq.size == 3\nend", "  l.length() == 3 &&\
    \ l.inject(true) do |sum,e|\n    sum && e == 0\n  end\nend", "  l.uniq!\n  sum_to_zero\
    \ = true\n  l.each_index do |i|\n    sum_to_zero = sum_to_zero and ((l[i] - l[i\
    \ + 1] - l[i + 2]) != 0)\n  end\n  sum_to_zero\nend", "    l.each do |n|\n   \
    \     first = n\n        second = n\n        third = n\n        first.downto(second)\
    \ do |i|\n            if second == third\n                third = 0\n        \
    \    else\n                third = second - i\n            end\n            second\
    \ = i\n        end\n        puts \"#{first} #{second} #{third}\" if first && second\
    \ && third\n    end\n    true\nend", "  l.uniq!\n  l.size.times do |i|\n    l.slice!(3-i)\n\
    \    break if l.reduce(false) { |a, b| a + b }\n  end\n  l.size == 0\nend", " \
    \ l.each_index do |i|\n    return false if l.uniq!.count > 3\n    return false\
    \ if l[i] - l[i-1] + l[i+1] == 0 # check whether three elements have the same\
    \ value\n  end\n  true\nend\n</cell>\n<text>\nExercise 2", "  l.each_with_index\
    \ do |elem, idx|\n    next if idx == 0\n    break if elem > l[idx-1]", "  return\
    \ triples_sum_to_zero_helper(l, 0).all?\nend", '    return triples_sum_to_zero_aux(l,0,0)',
  "  l.count{ |i| l.count(i) + 1 == l.count(i - 1) } >= 3\nend", "  l.inject(&:+)\n\
    \  return l.length == 3 && l.first.reduce(&:-) == 0\nend", "  l.each do |x|\n\
    \    next if x.zero?\n    l.each do |y|\n      next if y.zero?\n      if x + y\
    \ == 0\n        return true\n      end\n    end\n    return false\n  end\nend",
  "  l.sort.with_index do |num, i|\n    return true if num == 3 && num == l[i] &&\
    \ num == l[i+1]\n  end\n  false\nend", "    # Write your code here.\n    # use\
    \ hash to store a boolean value\n    flag = Hash.new\n    l.each do |val|\n  \
    \      if flag[val] == true then return true\n        elsif val > 0 && flag[val-1]\
    \ == true and flag[val+1 == true] then return true\n        elsif flag[val] ==\
    \ true and flag[val+1 == true] then return true\n        elsif val == 0 && flag[val-1]\
    \ == true then return true\n        else flag[val] = true\n        end\n    end\n\
    \    return false\nend", "  l.sort!\n  (arr[0] + arr[1] + arr[2]) == arr[3] &&\
    \ return true\n  false\nend", "    l.sort!\n    threes = l.select { |x| (x + x\
    \ + x) == 0 }\n    threes.size == 2 and threes.all? { |x| (x + x) == 0}\nend",
  "  l.sort\n  sum = 0\n  for i in 0...l.count-1\n    sum += l[i]\n    if sum == 0\n\
    \      return false\n    end\n  end\n  true\nend", "  return l == reduce(lambda\
    \ x, y: x + y, l) && l != reduce(lambda x, y: x + y, l[-3..-1])\nend", "  if l.count(l[0])\
    \ == 3\n    l.delete_at(0)\n    l.delete_at(l.count((l[0] + l[1])/2))\n    l.delete_at(l.count((l[0]\
    \ + l[1])/2 + l[2]))\n    l.delete_at(0)\n    l.delete_at(0)\n  end\n  return\
    \ l.count == 0\nend", "  l.sort.each do |i|\n    j = i + 1\n    k = j + 1\n  \
    \  while j < l.length and k < l.length\n      i += 1\n      k += 1\n      j +=\
    \ i if l[j] == l[i]\n      k += i if l[k] == l[i]\n    end\n    break if j >=\
    \ l.length\n    if l[j] == l[i] and l[k] == l[i]\n      return false\n    end\n\
    \  end\n  true\nend", "  # your code here\n  l.each do |i|\n    l.each do |j|\n\
    \      l.each do |k|\n        if i != j and i != k and j != k and (i + j + k).zero?\n\
    \          return false\n        end\n      end\n    end\n  end\n  true\nend",
  "  sum = 0\n  for i in l\n    sum += i\n  return sum == 0\nend", "  l.sort!\n  return\
    \ l.inject(:+).zero?\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nYour `each_cons`\
    \ example fails on negative inputs. It works by accident.\n<|/ c |>\n<| c |>\n\
    : Indeed, I should use `each_cons`. Thanks. I edited the answer accordingly.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\nI took a stab at it:\n<code>", "  l.each do\
    \ |elem|\n    return true if elem == 0 || elem == -elem\n  end\n  false\nend",
  "    threeSums(l) do |a, b, c|\n        return b == 0 and c > 0 or b > 0 and c ==\
    \ 0 or b > 0 and c == 0\n    end\nend", "  return l.inject(true, :<<).reduce(:+)\
    \ == 3\nend", "  l.inject(:+) == 0 ? false : true\nend", "    l.sort!\n    (0..l.size-1).select\
    \ {|i| (l[i]+l[i+1]+l[i+2])==0}.length==3\nend\n</code>\n<|/ a |>\n<| c |>\n+1:\
    \ this is cool. Your implementation is faster than mine, though you did it in\
    \ a different way, so I thought your algorithm was the correct one. Just a note:\
    \ the third `l` should be `l[i+1]`. And I thought `l[i+2]` should be `l[i+3]`.\
    \ So `(1..l.size).select { |i| l[i] >= l[i+1] && l[i] >= l[i+2] && l[i] >= l[i+3]\
    \ && l[i] >= 0 }.length >= 3` could be used instead of your `triples_sum_to_zero`\
    \ method.\n<|/ c |>\n<| c |>\n: thanks for pointing that out. I fixed the method\
    \ name. And you right, the last condition should be `l[i] >= 0`, which I didn't\
    \ notice at first.\n<|/ c |>\n<| c |>\nGreat solution, but how would you generalize\
    \ for non-integer numbers?\n<|/ c |>\n<| c |>\n: I added a version which accepts\
    \ non-integer numbers, though it might not be as efficient.\n<|/ c |>\n<| c |>\n\
    Thanks I liked your solution a lot more than my own\n<|/ c |>\n<| a tags=ruby,math\
    \ dscore=2 |>\n<code>", "  # your code here\n  sum_l = [0]\n  l.each do |el|\n\
    \    sum_l += [el].to_i\n  end\n  sum_l.uniq.length == 2 && sum_l.uniq.length\
    \ == 3\nend", "  return l.count { |n| n == -2 } == 3 && l.count { |n| n == -3\
    \ } == 3 && l.count { |n| n == -4 } == 0 && l.count { |n| n == -5 } == 0\nend",
  "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false if b < 0\n    return false\
    \ if b > 0 and a+b+b != 0\n  end\n  true\nend", "  return l.count(0) == 3 and\
    \ l.count(l.count(0)) == 1\nend", "  l.uniq!\n  return l.uniq.length == 3 && l.inject(:+)\
    \ == 0 && l.all?\nend", "  l=l.sort\n  l.length==3\n  l.find { |a| a == 0 || a\
    \ + 1 == 0 || a + 2 == 0 }\nend", "  sum_to_zero = l.inject(true){ |t1,x| t1 &&\
    \ x <= 0 }\n  l.size > 3 && sum_to_zero\nend", "  l.sort.each_with_index do |e,i|\n\
    \    (i - (i + 1)) % 3 == 0 && return true\n  end\n  false\nend", "    \n    i\
    \ = 0\n    sum = 0\n    found = 0\n    while i < len(l)\n        sum = sum + l[i]\n\
    \        if sum == 0\n            found = 1\n            break\n        i = i\
    \ + 1\n    if found == 3\n        return found\n    else \n        return not\
    \ found\n</cell>\n<cell>", "  return l.count(l.sort()) == 3\nend", "  return l.length\
    \ >= 2 and l.uniq.length == l[0..-2].uniq.uniq.length\nend", "  l.uniq!\n  l.reduce(:+)==0\n\
    end", "  if l.length < 3\n    puts \"Not enough elements in list, need at least\
    \ 3 elements\"\n    return false\n  end\n  a = l.uniq\n  a.each do |x|\n    x.each\
    \ do |y|\n      y.each do |z|\n        break false if x + y + z == 0 \n      end\n\
    \    end\n  end\n  true\nend", "  l.each do |x|\n    if [a, b, c] = x.to_i\n \
    \     return false if a + b + c != 0\n    end\n  end\n  true\nend", "  l.count{|x|\
    \ l.count(x) > 1} == false\nend", "  l.sort\n  sum = 0\n  for i in 0..l.size-1\n\
    \    sum += l[i]\n    if sum >= 0\n      return false if sum > 0 \n    end\n \
    \ end\n  true\nend", "    return l.count(0) <= 3\nend", "  l.sort\n  i = 0\n \
    \ while i < l.length\n    j = i + 1\n    while j < l.length\n      k = j + 1\n\
    \      while k < l.length\n        if l[i] + l[j] + l[k] == 0\n          return\
    \ false\n        k += 1\n      j += 1\n    i += 1\n  end\n  return true\nend",
  "  l.sort.each do |x|\n    next if x <= 0\n    l.delete_at(x) if l[x] == x\n  end\n\
    \  l.uniq.size == 3\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<|\
    \ c |>\nHow does this not have 2 upvotes? It's not even remotely as slow as yours\
    \ :)\n<|/ c |>\n<| c |>\n: I did not say it would be faster -- I said it is \"\
    as fast as yours\". The OP asked \"which two elements are identical, and which\
    \ one comes first?\" My answer shows how to do that. I also pointed out that this\
    \ algorithm will fail to tell you which element comes first, just that it has\
    \ 3 distinct elements. In your example, you would get `false` but my code would\
    \ get `true`. My code is **much** faster than yours. It is also correct. It is\
    \ also the best answer presented so far.\n<|/ c |>\n<| c |>\n+1 for your efforts,\
    \ but this algorithm doesn't tell you which comes first, just that there are 3\
    \ distinct elements in the array that sum to zero.\n<|/ c |>\n<| c |>\n: My code\
    \ tells you, which one comes first -- just that there are 3 distinct elements\
    \ in the array that sum to zero. If you read it carefully, I do exactly that.\
    \ I'll add comments to my code, to explain things a little more -- so you understand\
    \ why I did that. You also might want to check the comments to my code, and see\
    \ what I said about my code being \"much\" faster. I didn't write that code, I\
    \ just looked at it, and modified it to return the information I needed. My code\
    \ was much faster, because I did not have to sort the array.\n<|/ c |>\n<| c |>\n\
    : Yes, I do understand that. I will edit my answer to add a little more detail.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  return l.inject { |sum,x| sum == 0 &&\
    \ l.index(x) == 0 ? true : false }\nend\n</cell>\n<code language=ruby-1.9.3-jruby-1.7.3>",
  "  l.uniq!\n  return l.count <= 3\nend", "    # sum the elements \n    s = 0\n \
    \   for el in l:\n        s += el", "    return l.count(l.count(l[0]) == 3\n \
    \                and l.count(l.count(l[1]) == 3)\n                 and l.count(l.count(l[2])\
    \ == 3)\n                 and l.count(l.count(l[0]) + l.count(l[1]) + l.count(l[2])\
    \ == 0) == 0", "  return l.count(l[0]) == 3 and l.count(l[1]) == 3 and l.count(l[2])\
    \ == 0\nend", "  trip_sum = 0\n  trip_count = l.count{|x| (trip_sum + x) % 3 ==\
    \ 0}\n  (trip_count == 3 && trip_sum == 0) || (trip_count > 3)\nend", "  return\
    \ l.count(l[0]) == 3 and l.count(l[1]) == 3 and l.count(l[2]) == 0\nend", "  #\
    \ initialize counter\n  s = 0\n  # initialize list\n  t = []\n  # iterate through\
    \ list\n  for i in l\n    # initialize counter\n    s += 1\n    # if the sum is\
    \ zero, add it to the list\n    if s == 0\n      t.push(i)\n    else\n      #\
    \ if the sum is not zero, continue looping\n      break\n  # return boolean for\
    \ validity of list contents\n  return t.length == 3\nend", "    a, b = l[0], l[1]\n\
    \    return a != 0 and b != 0 and b != a and triples_sum_to_zero(l + [b])", " \
    \ l.each do |x|\n    x.to_i.times do\n      if l != x\n        break\n      else\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "    l.sort!\n\
    \    l.each_with_index do |num, index|\n        sum = index\n        next if index\
    \ == 0\n        (index - 1).times do |i|\n            sum = sum + l[i]\n     \
    \       next if sum == 0\n            break\n        end\n        break if sum\
    \ == 0\n        false\n    end\n    true\nend", "    l.sort!\n    count = 0\n\
    \    for i in 0...(l.length-1)\n        count += l[i]\n        if count == 0\n\
    \            return true\n    end\n    false\nend\n</code>\nThe above code takes\
    \ O(n) time to check all elements in the list. However, if you were to implement\
    \ the above code in ruby, you would see that it takes O(n^2) time to sort and\
    \ check all elements in the list. \nThe best way to reduce time complexity is\
    \ to sort the list first. \nFor sorting a list, the best way is to use merge-sort.\
    \ \n<code>", "  l.sort!\n  (l - [0, -1, 1, 2].sum == 0).any?\nend", '  return
    triple_sum(l) != 0', "  triples = [nil, nil, nil]\n  l.each_index do |i|\n   \
    \ triples[0] = l[i]\n    triples[1] = l[i..-1]\n    triples[2] = l[i+1..-1] if\
    \ i+1 < l.length\n    return false if triples.uniq.count != 3\n  end\n  true\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks I appreciate it. I'm new to Ruby\
    \ and didn't know about that .each_index method\n<|/ c |>\n<| a |>\n<code>\na\
    \ = [1,2,3,4,5]\na.each_cons(3).all? { |e,*cs| e.zero?; cs.all? { |cs| cs.all?\
    \ { |c| c.zero? } } } ", '    return l.count(1) == 3 and l.count(0) == 3', " \
    \ l.sort.each_with_index do |a, i|\n    l.each_index do |b|\n      next if i==b\
    \ || b == a.length-1\n      next if l[i+b] == 0\n      return false if a^l[i+b]\
    \ == 0\n    end\n  end\n  true\nend", "  l.sort! # sort list to find triples that\
    \ sum to zero\n  return l == [0, 0, 0] or l.reduce(:+) == 0\nend", "  return l.inject(:+)\
    \ == 3 && l.uniq.count == 3\nend", "  l.uniq!\n  l.size <= 3\nend", "  if l.count\
    \ < 3\n  then return true\n  else return false\n  end\nend", '    return triples_sum_to_zero_aux(l,0,len(l),1,0)
    or triples_sum_to_zero_aux(l,1,len(l),0,0)', "  return l.count == 3 && l.sum ==\
    \ 0 && all_different(l.map{|x| x ** 2})\nend", "    l.each do |num|\n        unless\
    \ [num, num, num].sum == 0\n            return false\n        end\n    end\n \
    \   true\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c\
    \ |>\nOk that makes a lot of sense now.  Thank you for taking the time to write\
    \ that!  Just to make sure I understand this correctly, it appears that the code\
    \ will always return true if all three of the elements in the list equal zero.\
    \  It then iterates through the list and checks the sum to see if all three elements\
    \ equal to zero.  Am I understanding that correctly?\n<|/ c |>\n<| c |>\nYes,\
    \ you are understanding correctly.\n<|/ c |>\n<| c |>\nThanks for taking the time\
    \ to write that!  It definitely makes the code look much more concise.\n<|/ c\
    \ |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 dscore=2 |>\nThis would be\
    \ the more \"Ruby\" way to do it:\n<code>", "  l.each { |el| return false if el.odd?\
    \ && el.even? && el > 0 } \n  l.each { |el| el > 0 ? false : true }\nend", " \
    \   sum = 0\n    temp = 0\n    for i in l\n        sum += i\n        if sum ==\
    \ 0 \n            if temp > 0\n                temp = temp - 1\n            else\n\
    \                return True\n    return False", "  l.each do |n|\n    l.each\
    \ do |m|\n      l.each do |o|\n        next if n == 0 || m == 0 || o == 0\n  \
    \      if n + m + o == 0\n          return false\n        end\n      end\n   \
    \ end\n  end\n  true\nend", "  return l.count(*l.group_by{|x| x.to_i}.values.uniq.count)\
    \ == 3\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| c |>\nThis seems\
    \ to work, but for some reason it takes over 4 minutes when I run it. I think\
    \ the problem has to do with my array being large (~1,000 elements) but I'm going\
    \ to investigate this further and see what I can find.\n<|/ c |>\n<| c |>\nIt\
    \ doesn't look like it's a Ruby problem at all. If I try to run it in Ruby it\
    \ takes over 4 minutes and doesn't print anything.\n<|/ c |>\n<| c |>\nI see it\
    \ take about 1 minute and 30 seconds to run on my computer (2.2 GHz Intel Core\
    \ 2 Duo with 4 GB RAM).\n<|/ c |>\n<| a dscore=0 |>\nThis should work\n<code>",
  "  i = 0\n  while i < l.length\n    a = l[i]\n    j = i + 1\n    while j < l.length\n\
    \      b = l[j]\n      k = j + 1\n      while k < l.length\n        c = l[k]\n\
    \        if a != b and a != c and b != c and a + b + c == 0\n          return\
    \ True\n        k += 1\n      j += 1\n    i += 1\n  end\n  return false\nend",
  "  return l.count(l[0]) == 3 && l.count(l[1]) == 3 && l.count(l[2]) == 0\nend\n\
    </cell>\n<cell>", "  l.sort! # sort! is a ruby method, sort is an instance method\
    \ of Array\n  l.any? {|i| (i + i + i).zero?}\nend", "    l.each_with_index do\
    \ |x, i|\n        triples_sum_to_zero = l.slice_when{ |x| x[i] == x[i+1] }\n \
    \       if triples_sum_to_zero.length == 3 &&\n            triples_sum_to_zero[0].length\
    \ == 3 &&\n            triples_sum_to_zero[1].length == 3\n            return\
    \ true\n        end\n    end\n    return false\nend\n</code>\n<|/ a dscore=0 tags=arrays,ruby,ruby-on-rails\
    \ |>\n<| c |>\nThis answer is incorrect. Consider the following array: `[3, 4,\
    \ -1, -3]`. Your algorithm would return `true` when it should be `false`. You\
    \ can see this more clearly if you try it on an online Ruby interpreter such as\
    \ [repl.it](https://repl.it/languages/ruby) and try out different inputs. [Here's\
    \ a demo of your algorithm using your example](https://repl.it/@jrunning/TriplesSumToZero).\n\
    <|/ c |>\n<| c |>\n: Good catch! It wasn't working because I left off the negative\
    \ sign. It now passes all tests I provided. See edited version and demo.\n<|/\
    \ c |>\n<| c |>\nYou still have a bug. You don't need to slice each element to\
    \ get the sum of the two elements in the triple. You just need to sum two pairs\
    \ of consecutive elements. [Here's a demo](https://repl.it/@jrunning/TriplesSumToZero2).\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  l.sort! # sort the list first\n  l.reduce\
    \ { |t, e| t + e } != 0\nend", "  sum = 0\n  for i in l\n    sum += i\n    if\
    \ sum == 0\n      return false\n  return true\nend", '  return l.count(l[0]+l[1]+l[2])
    == 0', "  return l.count { |x| (x.to_i + x.to_i + x.to_i) ==0 }==3\nend", "  l.uniq.map\
    \ {|x| [x, -x - x, 0]}.sort.reduce(:|).zero?\nend", "  l.uniq\n  l.uniq!\n  l.inject(0)\
    \ {|m, v| m + (v < 0 ? -v : v == 0 ? 1 : v)} == 0 || l.size == 0\nend\n</code>\n\
    And now here is the solution, using our helper function and an inline block:\n\
    <code>", "  l.sort!\n  zeros = []\n  for i in 1..l.length\n    if l[i-1] + l[i]\
    \ + l[i+1] == 0\n      zeros.push(i)\n    end\n  end\n  return zeros.length ==\
    \ 3\nend\n</code>\nThis code passes my tests so far. I would love some commentary\
    \ on the code.\n<|/ a |>\n<| c |>\nThis is wrong and I even pointed out in my\
    \ question that it returns true for \"triples_sum_to_zero([1,3,5,0])\". Your code\
    \ does not check the sum, only if the list is sorted, but your question indicates\
    \ that you are only interested in the sum.\n<|/ c |>\n<| c |>\nI believe my code\
    \ is correct. My code will return the sum of the triples which, if they sum to\
    \ zero, can be found by iterating through the list in three steps, and checking\
    \ if the sum is equal to zero (the list must be sorted for this to work).\n<|/\
    \ c |>\n<| c |>\nYou are wrong, it does check the sum. `l[i-1] + l[i] + l[i+1]\
    \ == 0`. This is a single expression which returns true/false based on whether\
    \ 3 triplets are found.\n<|/ c |>\n<| c |>\nYou are correct, I was confused because\
    \ you had the variable names the same as the function's arguments. I edited my\
    \ answer to make it clearer that it's checking the sum. Thanks for pointing that\
    \ out!\n<|/ c |>\n<| c |>\nThanks, I made that change in my code and it passes\
    \ all my tests.\n<|/ c |>\n<| a tags=arrays,ruby |>\nHere is my solution:\n<code>",
  "    l.sort!\n    l.inject { |sum, el| sum + el == 3 ? 1 : 0 } == 3\nend", "  if\
    \ l.length < 3 or l.length > 5\n    return false\n  sum = 0\n  for i in 0...l.length-2\n\
    \    sum += l[i]\n    sum += l[i+1]\n    sum += l[i+2]\n  return sum == 0\nend",
  '  return triples_sum_to_zero_aux(l,0,0)', "  threes = 0\n  for i in l\n    threes\
    \ += i % 3\n    return threes < 2 if threes == 0 end\n  end\nend", "  l.sort!\n\
    \  return l.inject {|sum, el| sum + el == 0 }\nend", "    l.sort\n    count =\
    \ 0\n    triples = 0\n    l2 = []\n    while count < l.size\n        triples +=\
    \ l[count]\n        count += 2\n        l2 << triples if triples > 0 \n    end\n\
    \    l2.size == 3\nend\n</cell>\n<code language=julia-1.5>", "  l.sort!\n  return\
    \ l.inject(:+) == 0 && l.size == 3\nend", "  return l.length == 2 and l.all? {\
    \ |x| x == 0 || x == -x } and l.uniq.length == 3\nend", "  l.sort!\n  (l[0] +\
    \ l[1] + l[2]) == 0 || (l[0] + l[1] + l[2] + l[3] == 0)\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=python,list |>\nIf you only want the number of unique triplets\
    \ in a list and they are guaranteed to be unique, you can use this simple solution:\n\
    <code>", "  l.sort!\n  (l[0]+l[1]+l[2]) == 0 \nend\n</code>\n<code>", "  return\
    \ l.count { |v| l.count(v) == 3 } == 0\nend", "    l = l.sort\n    triples = 0\n\
    \    for i in [3,2,1]\n        while triples < 3 && l[triples] + l[triples + i]\
    \ + l[triples + i + 1] == 0\n            triples +=1\n        return triples ==\
    \ 3\nend", "  # initialize a count variable and set it to zero\n  count = 0\n\
    \  # set l to an array with only positive numbers\n  l2 = []\n  l2.push(l[0])\n\
    \  l2.push(l[1])\n  l2.push(l[2])\n  while l2.length >= 3\n    # count the number\
    \ of zeros in l\n    if l2[l2.length - 1] == 0.0\n      count = count + 1\n  \
    \    # remove the zero from the array\n      l2.pop()\n    # remove the non-zero\
    \ element from the array\n    if l2[l2.length - 1] != 0.0\n      l2.pop()\n  \
    \  else\n      break\n  end\n  # if the count equals three, we have a triplet\n\
    \  return count == 3\nend\n</cell>\n<code language=julia-1.6>", "  sum_to_zero\
    \ = true\n  l.sort!", "  # Your code here\n  l.uniq.count == 3\nend", "  return\
    \ l.count(l.sort.uniq.length) == 3\nend", "  l.inject([]) do |sums, num|\n   \
    \ sums << num if num != 0 && (sums.all? { |sum| sum > 0 }) || (sums.all? { |sum|\
    \ sum == 0 })\n  end\nend", "  l = [*l]\n  return l.count(l[0]) == 3 && l.count(l[1])\
    \ == 3 && l.count(l[2]) == 0\nend", "  l.sort { |a,b| b - a }\n  l[0] == 0 &&\
    \ l[1] == 0 && l[2] == 0\nend", "  l.sort!\n  return l.size != (l.length - (l.length\
    \ / 3)).abs #all triples add to zero\nend", "  sum = 0\n  for i in l\n    sum\
    \ += i\n  return sum == 0\nend\n</cell>\n<text>\nThe function prime_sum takes\
    \ a list of integers as an input.\nIt returns True if there are three distinct\
    \ elements in the list that\nsum to zero, and False otherwise.\n>>> prime_sum([3,\
    \ 5, 0])\nFalse\n>>> prime_sum([3, -2, 1])\nTrue\n>>> prime_sum([2, 3, 7])\nFalse\n\
    >>> prime_sum([2, 4, -5, 3, 9, 7])\nTrue\n>>> prime_sum([1])\nFalse\nWe will now\
    \ implement a function that takes a list of integers as an input\nand returns\
    \ the smallest positive integer that is not in the list.\n>>> prime_sum([3, -2,\
    \ 1])\n4\n>>> prime_sum([2, 4, -5, 3, 9, 7])\n4\n>>> prime_sum([2, 3, 7])\n3\n\
    >>> prime_sum([1])\n2\nAs you can see, our function did not handle a negative\
    \ number properly.\nIt returns None when the input list is empty.\nYou can test\
    \ it out yourself by typing prime_sum([0, 2, 4, -5, 3, 9, 7]) in your Jupyter\
    \ terminal.\nIt returns None, which Python considers to mean that there is no\
    \ solution.\n>>> prime_sum([0, 2, 4, -5, 3, 9, 7])\nNone\nIf you need a function\
    \ that handles a negative number properly, we recommend you check out the function\
    \ negative_integer_sum we implemented earlier.", "  return l.count { |n| triple(n).size\
    \ == 3 } if l.size > 0 else false\nend", "    return ((l.count(1) - l.count(0))\
    \ == 0 and l.count(3) == 0)\nend", "  return l.count(l[0]) == 3 and (l.count(l[1])\
    \ == 2 or l.count(l[2]) == 2)\nend\n</code>\nThe sum of the first three elements\
    \ of the list is an exact multiple of 3, and the sum of the next two elements\
    \ is either a 2 or 3, so this algorithm will give you the desired result.\n<|/\
    \ a |>\n<| c |>\n`return l.count(l[0]) == 3 and (l.count(l[1]) == 2 or l.count(l[2])\
    \ == 2)`\n<|/ c |>\n<| c |>\n`return l.count(l[0]) and l.count(l[1]) and l.count(l[2])\
    \ == 3` - `and` also short-circuits when possible.\n<|/ c |>\n<| c |>\nI appreciate\
    \ your help but I don't understand this solution.  Can you explain the logic?\n\
    <|/ c |>\n<| c |>\nI added comments to my answer explaining it.\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>", "  # Your code here\n  l.reduce(:+) == 0 ? (l.reduce(:+)\
    \ == l.reduce(:+)) : l.reduce(:+) == 0 ? (l.reduce(:+) == l.reduce(:+)) : (l.reduce(:+)\
    \ == (l.reduce(:+) -1) * (l.reduce(:+) == (l.reduce(:+) -1)))\nend", "  l.each_index\
    \ {|i| return true if l[i...i + 3].reduce(:+) == 0} # return true if all three\
    \ elements in the list sum to zero.\n  false\nend", "  return l.inject(true?)\
    \ do |sum_to_zero, el|\n    sum_to_zero && el >= 0\n  end\nend", "  return l.count(l[0])+1\
    \ == 3 and l.count(l[1])+1 == 3 and l.count(l[2])+1 == 3\nend", "    triples =\
    \ find_triples_sum_to zero(l) \n    return True if triples != [] else False",
  "  sum = 0\n  l.sort!\n  l.each_with_index { |e,i|\n    sum = sum + e\n    return\
    \ true if i == 1 || (i == l.size - 2 && sum == 0)\n  }\n  return false\nend",
  "  l.map {|e| [e] * 3 }.uniq.size == 3\nend", "    l = l.sort!\n    l.each_index\
    \ do |i|\n        if l[i] != l[i-1] + l[i-2] + l[i-3]\n           return false\n\
    \        end\n    end\n    return true\nend\n</cell>\n<cell>", "    sum = 0\n\
    \    for i in l\n        if i % 3 == 0 and i % 5 == 0\n            sum += 1\n\
    \    return sum == 0\n    ", '    return triples_sum_to_zero_recursive(l, 0)',
  "  l.sort!\n  return l.none?\nend", "  l.sort\n  \n  i = 0\n  while i < l.length\n\
    \    j = i+1\n    while j < l.length\n      if l[i] + l[j] > 0\n        return\
    \ false\n      j += 1\n    i += 1\n  return true\nend", "  return l.count(0) ==\
    \ 3\nend", "  l.uniq\n  l.each_with_index do |n,i|\n    next unless n\n    l.each_with_index\
    \ do |m,j|\n      if m == 0 and j > i\n        l.slice!(i,j)\n        l.slice!(i,j)\n\
    \        l.slice!(i,j)\n        break\n      end\n    end\n  end\n  l.size ==\
    \ 0\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for this answer! I spent a long time\
    \ trying to get the code working with my original data structure, but this seemed\
    \ much simpler.\n<|/ c |>\n<| a dscore=2 |>\nYou don't need all that fancy code.\
    \ You can use an associative array and find the first occurence of 0 in each index.\
    \ That's your answer. Like this:\n<code>\ndata = [ 0, 2, 4, -5, 3, 9, 7, -1, 1,\
    \ 3 ]\nresult = data.each_with_index.map {|x,i| x.zero? ? i : nil }.compact.first",
  "    l.sort!\n    return l.inject(:+) == 0 && l.uniq.count == 3\nend", "  l.sort!\n\
    \  return true if l.count(l[0])==3\n  return false if l.count(l[0])==2\n  l[0]\
    \ = 0\n  l[1] = 0\n  l[2] = 0\n  for i in 0...l[-1]\n    if l[i] + l[i+1] + l[i+2]\
    \ == 0\n      return true\n    end\n  end\n  return false\nend", "  l.map!{|x|\
    \ x}\n  l.uniq.map!{|x| x*x}\n  l.uniq.inject(:+)==0\nend", "  return true if\
    \ l == [0, 1, 2] and l.count { |x| x == 3 }\n  false\nend", "  l.uniq!\n  l.uniq.all?\
    \ { |i| i.to_s.split(//).inject(:+) == 0 }\nend\n</code>\n<|/ a |>\n<| c |>\n\
    You missed one case: triples_sum_to_zero([1]) is false\n<|/ c |>\n<| c |>\nGood\
    \ catch! And you're right. I updated my post to fix it\n<|/ c |>\n<| c |>\nThis\
    \ code is brilliant and concise. Thank you so much!\n<|/ c |>\n<| c |>\nThis code\
    \ works, though it seems like it would be much simpler to just use `each_cons(3).all?`.\
    \ That would let you write `l.each_cons(3).all?` rather than needing your `triples_sum_to_zero`\
    \ method. At least in Ruby 2.1.3, it's still faster than the `sum` method.\n<|/\
    \ c |>\n<| c |>\n- I agree that would be a better solution. I didn't think of\
    \ using `each_cons`. I'd also like to see that change reflected in the benchmarks\
    \ I performed.\n<|/ c |>\n<| a tags=ruby,arrays |>\nI like Stefan's answer (the\
    \ accepted answer) but I don't like using loops since they're relatively slow.\
    \  Here's another way:\n<code>", "  l.sort!\n  (num1, num2, num3) == l\n  return\
    \ (num1 + num2 + num3) == 0 || (num1 - num2 - num3) == 0\nend", "  if l.sum !=\
    \ 0\n    l.each do |x| # iterate over list\n      l.each do |y| # iterate over\
    \ list\n        if x + y != 0\n          return false\n        end\n      end\n\
    \    end\n    true\n  else\n    false\n  end\nend", "  l.sort!\n  (l.length-3).times\
    \ do |i|\n    return (l[i]+l[i+1]+l[i+2]) == 0 #return false if three items are\
    \ the same\n  end\n  true\nend", "  l.uniq\n  l.select { |x| x == 3 }.all? { |x|\
    \ x == 0 }\nend", "  l.sort.each_with_index do |x, i|\n    j = i + 1 if i < l.size-1\n\
    \    k = j + 1 if j < l.size-1\n    return false if x.nil? || (x==0) || (x==l[i])\
    \ && (x==l[j]) && (x==l[k])\n  end\n  true\nend", "  return l.inject(true) do\
    \ |sum, val|\n    sum & (val + val + val)\n  end\nend", "  # write your code here\n\
    \  sum = 0\n  for e in l\n    sum += e\n  return sum % 3 == 0\nend", "  return\
    \ l.count(0) == 3 && l.all?{|x| l.count(x) == 3}\nend", "    l.sort!\n    l.each_cons(3).with_index\
    \ do |pair, index|\n        if pair[0] != pair[1]\n            return true\n \
    \       end\n    end\n    false\nend", "    l.sort!\n    return l.all? {|x| x\
    \ == 3 && ((l.size - l.find_index(x) + 1) < 3)}\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
