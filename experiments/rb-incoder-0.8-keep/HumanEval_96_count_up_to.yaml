name: HumanEval_96_count_up_to
language: rb
prompt: "# Implement a function that takes an non-negative integer and returns an\
  \ array of the first n\n# integers that are prime numbers and less than n.\n# for\
  \ example:\n# count_up_to(5) => [2,3]\n# count_up_to(11) => [2,3,5,7]\n# count_up_to(0)\
  \ => []\n# count_up_to(20) => [2,3,5,7,11,13,17,19]\n# count_up_to(1) => []\n# count_up_to(18)\
  \ => [2,3,5,7,11,13,17]\ndef count_up_to(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_up_to\n\
  \    candidate = method(:count_up_to)\n    assert_equal([2, 3], candidate.call(5))\n\
  \    assert_equal([2, 3, 5], candidate.call(6))\n    assert_equal([2, 3, 5], candidate.call(7))\n\
  \    assert_equal([2, 3, 5, 7], candidate.call(10))\n    assert_equal([], candidate.call(0))\n\
  \    assert_equal([2, 3, 5, 7, 11, 13, 17, 19], candidate.call(22))\n    assert_equal([],\
  \ candidate.call(1))\n    assert_equal([2, 3, 5, 7, 11, 13, 17], candidate.call(18))\n\
  \    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43], candidate.call(47))\n\
  \    assert_equal([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
  \ 61, 67, 71, 73, 79, 83, 89, 97], candidate.call(101))\n  end\nend\n"
completions: ["  result = []\n  if n <= 0 then return []\n  n = 3\n  while n <= n\
    \ do\n    # n / 2 will always be 0, because the value of n gets incremented by\
    \ one each time through the loop.\n    # n % 2 is true when n is odd, so n % 2\
    \ != 0 is true if n is even.\n    if n % 2 == 0\n      result.push n\n      n\
    \ += 2\n    else\n      n += 1\n    end\n  end\n  result\nend", "  # Your code\
    \ here\nend\n</cell>\n<cell>", "  return n if n <= 1 #base case\n  (1...n).select\
    \ {|x| prime?(x)}\nend", "    count = 0\n    (1..n).each do |n|\n        prime_arr\
    \ = prime_arr(n) if n < prime_arr.size\n        count += prime_arr.size if n >\
    \ prime_arr.size\n    end\n    count\nend", "  \n  # your code here\nend", " \
    \   puts n if n > 1\n    puts [n] if n == 0\n    puts [n] if n < 1\n    # Put\
    \ your code here\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ dscore=2 |>\n<code>\n def prime_number(n)\n   if n <= 1 \n     return n\n  \
    \ else \n     return prime_number(n-1)\n   end \n end\n</code>\n<|/ a |>\n<| a\
    \ dscore=1 |>\nWe can create a simple method that iterates until it finds a prime\
    \ number and print out each odd number.\n<code>", " \n  \n  # Write your code\
    \ below!\n  return 0", "  result = []\n  for i in 2..n\n    break unless is_prime(i)\n\
    \    result << i\n  end\n  result\nend", "    arr = Array.new(n){0} #initialize\n\
    \    (1..n).each do |x|\n       arr[x] = x + 1\n       if arr[x] == n\n      \
    \     arr[x] = 0\n       elsif arr[x] == n - 1\n           return arr\n      \
    \ elsif arr[x] * arr[x] <= n\n           return arr\n       end\n    end\nend",
  "  return n<0 ? nil : Primes.take_while{|i| i<=n}.count+1\nend\n    \nend\n</code>\n\
    <|/ a tags=ruby,recursion |>\n<| c |>\nA lot of the other answers are correct,\
    \ but this one takes into account that there are some numbers that don't have\
    \ a prime factor (such as 17). A couple other things: 1. `primes` is an array.\
    \ Don't call an array's `count` method, just call its `size` method. 2. You don't\
    \ need to go up to the square root like that. You can do it more efficiently by\
    \ checking only odd numbers. 3. If n is 0, then there are no primes less than\
    \ 1, which is false, so you don't need to test for it. This is just more efficient\
    \ than checking every number up to and including the square root.\n<|/ c |>\n\
    <| c |>\n4. Don't call `Integer#to_i` before you check `n`, just use `if n.zero?`.\
    \ 5. Why do you need `return n<0 ? nil : Primes.take_while{|i| i<=n}.count+1`\
    \ instead of just `return Primes.take_while{|i| i<=n}.count+1`? The `<=>` method\
    \ returns `-1` if self is smaller than the other, `0` if they are equal, and `1`\
    \ if self is larger than the other.\n<|/ c |>\n<| c |>\nthanks for your tips!\
    \ I edited the code to be more ruby-like and to be more efficient. By the way,\
    \ I used primes.count instead of primes.size, because the former works on arrays\
    \ and the latter doesn't (and it does work on an array in ruby 1.8.7, which is\
    \ what the OP was using). One could also use `primes.take_while { |prime| prime\
    \ <= n }.count`\n<|/ c |>\n<| c |>\nAlso, thanks for noting about `count` vs `size`!\n\
    <|/ c |>\n<| c |>\nThank you for the detailed answer! This should be the correct\
    \ answer to this question for Ruby developers, who are looking to implement recursion\
    \ without using any gems.\n<|/ c |>\n<| a dscore=5 |>\nThe naive solution would\
    \ be:\n<code>", "  return [] if n.zero? # empty list\n  a = []\n  a << n for n\
    \ in 1..n if (2..n).to_a.grep(&:odd?).any? # odd numbers\n  a << n for n in 1..n\
    \ if (2..n).to_a.grep(&:even?).any? # even numbers\n  a\nend", "  # Write your\
    \ solution here\n  return []\nend\ncount_up_to(3)", "  result = []\n  if n ==\
    \ 0 \n    result << []\n  else \n    loop do\n      break if n <= 0 \n      if\
    \ n % 2 == 0\n        result << n\n      end\n      n += 2\n    end\n  end\n \
    \ result\nend\n</cell>\n<cell>", "  return [] if n < 0\n  return 0 if n == 0\n\
    \  return [count_up_to(n-1).last + 1] if n == 1\n  \n  results = []\n  \n  (1..n).each\
    \ do |i|\n    prime = true\n    (2..i).each do |j|\n      prime = false if i %\
    \ j == 0\n    end\n    if prime\n      results << i\n    end\n  end\n  results\n\
    end", "  []\nend", "  primes = []\n  \n  for i in 1..n\n    if n % i == 0\n  \
    \    primes << i\n    else \n      break\n  end", "    return [] # your code here\n\
    end", "  prime_numbers = PrimeNum.prime_numbers(n)\n  prime_numbers.each do |n|\n\
    \    return [] if (n <= 0)\n    i = 0\n    while ((n % prime_numbers[i]) == 0)\n\
    \      i += 1\n    end\n    prime << n\n  end\nend", "  if n < 0\n    raise ArgumentError\n\
    \  else\n    arr = Array.new(n)\n    i = 2\n    while i <= n\n      is_prime =\
    \ true\n      j = 2\n      while j <= i\n        if i % j == 0\n          is_prime\
    \ = false\n        end\n        j += 1\n      end\n      if is_prime\n       \
    \ arr << i\n        i += 1\n      end\n    end\n  end\n  arr\nend", "  count =\
    \ Array.new(n)\n  count.unshift(1)\n  count.each { |x| return nil if x < 1 }\n\
    \  2.upto(n - 1).each do |x|\n    count << x if (x.prime? && x.even?)\n  end\n\
    \  count\nend", "  n==0?[]:1..n\n  .inject([],:&)\n  .select {|i| i%2 == 0?true:(i%3==0?true:(i%5==0?true:false))}\n\
    \  .sort\nend", "  arr = Array.new\n  n.times do |i|\n    arr << i if prime?(i)\n\
    \  end\n  arr\nend\n</cell>\n<cell>\ncount_up_to(5)\n</cell>\n<cell>\ncount_up_to(11)\n\
    </cell>\n<cell>\ncount_up_to(0)\n</cell>\n<cell>\ncount_up_to(20)\n</cell>\n<cell>\n\
    count_up_to(1)\n</cell>\n<cell>\ncount_up_to(18)\n</cell>\n<text>\nRefactoring\
    \ Questions\nImplement a function that accepts a non-negative integer $n$ and\
    \ return an array of all prime numbers less than or equal to $n$:", "    2.upto(n).map\
    \ {|i| i}.select {|i| i}.take_while {|i| i < n}\nend", "  a = []\n  i = 1\n  while\
    \ i <= n\n    a.push(i)\n    i += 1\n  end\n  a\nend", "  i = 2\n  result = []\n\
    \  until i <= n do\n    if n % i == 0 then\n      result << i\n      i += 2\n\
    \    end\n    i += 1\n  end\n  result\nend", "  count = 1\n  result = []\n  while\
    \ count <= n do\n    result << count\n    count += 1\n  end\n  result\nend\ncount_up_to(10).each{|i|\
    \ p i}", " \n  return [] unless n > 0\n \n  if n == 1\n    [1]\n  else\n   prime\
    \ = []\n   i = 2\n   while i <= n do\n    if n % i == 0\n     prime << i\n   \
    \ end\n    i += 1\n   end\n    prime << n\n  end\nend", "    \n    primes = Primes.primes\n\
    \    return primes.take_while { |i| i < n } if primes.length >= n\n    \n    \n\
    end", "    primes = []\n    for p in 2..n\n        if primes.include?(p)\n   \
    \         next\n        else\n            primes.push p\n            primes.each\
    \ {|prime| return prime if prime > n }\n        end\n    end\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=ruby,primes |>\n<code>", "  return [] if n < 2\n  nums\
    \ = 2\n  while nums <= n\n    prime = true\n    i = 2\n    loop do\n      prime\
    \ = false if num % i == 0\n      break unless prime\n      i += 1\n    end\n \
    \   unless prime\n      nums << num\n    end\n  end\n  return nums\nend", "  \
    \  return 1\nend", "  return [i for i in 1..n]\nend", "  if n == 0\n    []\n \
    \ elsif n > 0\n    (1..n).select {|i| i.reduce(:&).all? {|x| x == 1}}\n  else\n\
    \    []\n  end\nend", "  return [] if n == 0 \n  return [n] if n == 1 \n  return\
    \ [n] if prime?(n) \n  count_up_to(n - 1).each_with_object([]) { |i, a| a << i\
    \ if prime?(i) }\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\n`count_up_to(0)`\
    \ should return `nil` since you probably want `nil` rather than an empty array.\
    \ I'd also add a `return nil` before the last line.\n<|/ c |>\n<| c |>\n: thanks.\
    \ I made that change - not sure why I was returning an empty array all the way\
    \ around.\n<|/ c |>\n<| c |>\nI see you added a separate `count_up_to(1)` method.\
    \ Does that actually do anything other than cause an error in the OP's code, or\
    \ is it an artifact from trying to figure out the logic? Also, why is `prime?`\
    \ defined in two places?\n<|/ c |>\n<| c |>\n: I added an explicit check for `0`\
    \ which I thought was the most reasonable thing to do (I hope). And yes, it was\
    \ an artifact from the OP's attempt to figure out the logic. It's a small enough\
    \ set of methods to make it a little easier to understand than a huge method with\
    \ all that logic, though I agree with you that if all I did was add one method,\
    \ I might have added more code than I should have had to :).\n<|/ c |>\n<| c |>\n\
    Why does my code return `[2,3,5,7,11,13,17,19]` when `count_up_to(20)` should\
    \ return `[2,3,5,7,11,13,17,19]`?\n<|/ c |>\n<| a dscore=2 |>\nHere's my take\
    \ on it.\n<code>", "  a = []\n  (1..n).each do |i|\n    a.push(i if prime?(i))\n\
    \  end\n  return a unless n == 0\n  []\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ dscore=0 tags=ruby,primes |>\nThe fastest way to do this on Ruby 1.8.7 upwards\
    \ is to iterate only up to the square root of the number to check for primes,\
    \ and to return as soon as you find a factor.  Since you also need to return factors\
    \ that divide your number, you do need to check up to the square root of the number\
    \ to find prime factors, and you do need to check if a factor is divisible by\
    \ your number to determine that your number is not prime.  In other words, a number\
    \ is a prime if it can be expressed as either x mod n == 0, where n is a natural\
    \ number greater than one or x, or by x % n == 0, where n is a natural number\
    \ greater than one.  For instance,\n<code>", "  if n < 0\n  then return nil\n\
    \  end\n  result = []\n  if n == 0\n  then return result\n  end\n  i = 3\n  while\
    \ i <= n\n  do\n  result << i\n  if ((i**2).to_i) == n\n  then break\n  end\n\
    \  i += 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby dscore=3 |>\n<| c |>\n\
    `result = []` can be replaced with `[result]`\n<|/ c |>\n<| c |>\nAwesome, thank\
    \ you for the answer. It was pretty easy to understand what was happening. I was\
    \ having a hard time following this code, however. I did have to change it to\
    \ `result = [] if n < 0`, but I didn't understand why that made a difference.\
    \ Could you explain why `result = result if n > 0` makes a difference?\n<|/ c\
    \ |>\n<| c |>\nI think this answer needs a small correction, though: it should\
    \ be `result = result + [result] if n > 0`\n<|/ c |>\n<| c |>\n, thank you, this\
    \ is very helpful.\n<|/ c |>\n<| a |>\nAs others have mentioned in their answers,\
    \ the prime numbers aren't the only primes that can fit in a 32-bit integer. Some\
    \ of the composite numbers, like 4, 7, and 13 are also primes, but can be expressed\
    \ more efficiently in base 3. A simple way to express primes in this way is to\
    \ express them as a sum of powers of two:\n<code>", "  return [] if n < 2\n  ns\
    \ = [2]\n  while ns[-1] < n\n    ns.push n\n    n -= 1\n  ns.push n\n  ns - 2\n\
    end", "  i = 2\n  arr = []\n  while i <= n\n    arr.push(i)\n    i += i\n  end\n\
    \  arr\nend", "  return [] if n.zero?\n  n.downto(1).map{|i| (n%i == 0 ? i+1 :\
    \ nil) }.compact\nend", "  if n < 1\n    []\n  else\n    prime_numbers = nil\n\
    \    i = 1\n    prime_numbers = []\n    until prime_numbers.nil?\n      prime_numbers.each_index\
    \ do |index|\n        if n >= i and n % prime_numbers[index] == 0\n          break\n\
    \        end\n      end\n      prime_numbers.push(2 * i)\n      i += 1\n    end\n\
    \    prime_numbers\n  end\nend\nprint count_up_to(9).to_s\nprint count_up_to(13).to_s\n\
    print count_up_to(11).to_s\nprint count_up_to(5).to_s\nprint count_up_to(1).to_s\n\
    print count_up_to(18).to_s\nprint count_up_to(50000).to_s", "  i = 0\n  result\
    \ = []\n  while (i < n)\n    return if i % 2 == 0 and i != n \n    i += 1 if prime?(i)\n\
    \    result << i\n  end\n  return result\nend\n</code>\n<|/ a tags=ruby,primes\
    \ |>\n<| c |>\nThank you, your code works perfectly fine! I've made a few minor\
    \ changes and it works as expected now. Cheers!\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "  return nif n > 0 then return [n].concat [count_up_to(n - x) for x<-\
    \ 2..n]\n      else return []\nend\n</code>\n<|/ a |>\n<| c |>\nPlease edit your\
    \ answer to explain why this code works.\n<|/ c |>\n<| c |>\nI did just that.\
    \ Though it might be good to point out that `prime` is [not implemented in ruby](http://www.rubydoc.info/stdlib/core/prime).\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  2.upto(n) do |i|\n    break if (i ** 2).to_i\
    \ < n\n  end \n  primes.take(n).to_a\nend", "  i = 2\n  result = []\n  loop do\n\
    \    if i <= n\n      result << i\n      i += 2\n    else\n      break\n    end\n\
    \  end\n  result\nend", "  return [] if n.zero?\n  \n  return [1..n].select {\
    \ |i| i.prime ? i.div(2) >= n }\nend", "  primes = []\n  i = 2\n  while i < n\n\
    \    primes << i\n    i += 1\n  end\n  primes << n\n  primes.uniq\nend", "  return\
    \ [] if n<=0\n  primes = [2]\n  i = 3\n  while i <= n\n    return primes.to_a\n\
    \  end\n  return primes\nend", "  if n == 0\n    return []\n  \n  primes = []\n\
    \  i = 2\n  while primes.count < n\n    if i**2 == n || i**3 == n\n      primes\
    \ << i\n      i += 2\n    elsif primes.count + 1 < n\n      primes.count += 1\n\
    \      i += 1\n    end\n  end\n  \n  primes\nend", "  return.each_cons(n) do |i|\n\
    \    break if i.length < n\n    i.each {|e| return e}\n  end\nend", "  if n ==\
    \ 1\n    [1]\n  else\n    prime = [2]\n    prime << 2\n    n.downto(0).each do\
    \ |n|\n      prime << n if (prime << n).any? { |x| x.prime? }\n    end\n    prime\n\
    \  end\nend", "  raise NotImplementedError\nend", "  primes = []\n  for i in 2..n\n\
    \    if i % 2 == 0 and i > 1\n      break\n    elsif i % 2 == 0\n      primes\
    \ << i\n    end\n  end\n  return primes\nend", "  i = 2\n  result = []\n  while\
    \ i <= n do\n    result << i\n    i += 2\n  end\n  result\nend", "  i = 0\n  result\
    \ = []\n  while i <= n do\n    break if i.odd?\n    result.push(i)\n    i += 1\n\
    \  end\n  result\nend\n</cell>\n<code language=julia-1.0>\ncount_up_to(10)\n</cell>\n\
    <code language=julia-1.0>\ncount_up_to(20)\n</cell>\n<code language=julia-1.0>\n\
    count_up_to(40)\n</cell>\n<code language=julia-1.0>\ncount_up_to(100)\n</cell>\n\
    <code language=julia-1.0>\ncount_up_to(5000)\n</cell>\n<code language=julia-1.0>",
  "    arr = []\n    i = 0\n    while i < n and arr << (i-2*i) == []\n        i +=\
    \ 1\n    if i > n\n        arr\n    else\n        arr << (i-2*i)\n        count_up_to(n)\n\
    \    end\nend\n</code>\n<|/ a |>\n<| c |>\nI think you mean `while i < n and arr\
    \ << (i-2*i) == []` with `arr << (i-2*i)`\n<|/ c |>\n<| c |>\nAlso your `arr <<\
    \ (i-2*i)` should be `arr << i-2*i` I guess or it will not work.\n<|/ c |>\n<|\
    \ a tags=ruby,primes |>\nJust for fun, here's another way:\n<code>", "  return\
    \ [] if n < 1\n  return [2 for n in 1..n if n % n == 0] + [n for n in 1..n if\
    \ n % n != 0]\nend\np count_up_to(20)\n</cell>\n<text>\nExercise 3\nWrite a function\
    \ count_down that takes an non-negative integer and returns an array of the first\
    \ n\nintegers that are prime numbers and greater than n.\nfor example:\ncount_down(5)\
    \ => [2,3]\ncount_down(11) => [2,3,5,7,11,13,17]\ncount_down(0) => []\ncount_down(18)\
    \ => [2,3,5,7,11,13,17,19,23,29]\ncount_down(1) => []\ncount_down(17) => [2,3,5,7,11,13,17,19,23,29,31,37]\n\
    Exercise 4\nImplement a function that takes a non-negative integer and returns\
    \ an array of the Fibonacci numbers with n\nnumbers in them. The numbers in the\
    \ Fibonacci sequence are defined as:\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,\
    \ 144, 233, 377, 610, 987, 1597,\nand so on. For a sequence of n numbers in the\
    \ Fibonacci sequence, each number is the sum of two preceding numbers. For example,\
    \ with n = 5,\nthe Fibonacci sequence starts with the following sequence: 0, 1,\
    \ 1, 2, 3, 5, 8. The first Fibonacci number is 1, and the second Fibonacci number\
    \ is 1 plus the previous number:\n1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233,\
    \ 377, 610, 987, 1597.", "  i = 0\n  primes = []\n  while i <= n\n    if primes.include?\
    \ i\n      i += 1\n      next\n    end\n    if i % 2 == 0\n      primes << i\n\
    \      i += 1\n      next\n    end\n    primes << i\n    i += 1\n  end\n  primes.delete_at(primes.size\
    \ - 1)\nend\n</code>\n<|/ a |>\n<| c |>\nThe point about using the `delete_at()`\
    \ method was really useful but unfortunately didn't solve the problem. Thank you\
    \ for the answer though.\n<|/ c |>\n<| c |>\nYou are very welcome. If this solved\
    \ your question, please mark it as answered. :)\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\nThe problem is that the method include? is returning false when i is 0,\
    \ so you're not actually deleting 0 from your array.  Try using .delete instead.\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nThere are many ways to solve this problem,\
    \ but a very straight forward way to solve it would be to simply filter out non-primes\
    \ while building the array.\n<code>", "  result = []\n  if n == 0\n    return\
    \ result\n  if n <= 2\n    return [n]\n  (2..n).each do |num|\n    if num > 1\n\
    \      result << num\n      next_num = num * num + 1\n      if next_num < n \n\
    \        (next_num..n).each do |num|\n          if num != next_num\n         \
    \   result << num\n          end\n        end\n      end\n    end\n  end\n  result\n\
    end", "    if n == 0\n        return []\n    primes = []\n    for i in 2..n\n\
    \        if prime? i\n            primes << i\n            if n % i == 0\n   \
    \             return nil\n        end\n    end\n    primes << n\n    return primes\n\
    end", "  return if n == 1\n  [2,3,5..n].select do |i|\n    prime?(i) && i <= n\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 tags=ruby |>\nA very simple\
    \ solution:\n<code>", "  i = 2\n  while i <= n\n    prime = true\n    primes =\
    \ false\n    until primes\n      if prime\n        primes = true\n      else\n\
    \        prime = false\n      end\n      i +=1\n    end\n    puts i\n  end\nend",
  "    return ([n] + [n*2] + [n*3]+[n*5]+[n*7]+[n*11]+[n*13]+[n*17]+[n*19]).sort\n\
    end", "  return [] if n < 0\n  return [n % (i + 1) for i in 1..] if n % i == 0\n\
    \  count_up_to(n + 1)\nend", "  if n == 0\n    []\n  else\n    primes = []\n \
    \   (1..n).each do |i|\n      primes.any? do |j|\n        break unless i.modulo(j)\
    \ == 0\n      end\n      primes << i\n    end\n    primes\n  end\nend\n</code>\n\
    <|/ a |>\n<| c |>\nHi Chris, I appreciate your answer, but this is not what I\
    \ am looking for. I already had the function working perfectly using \"until\"\
    \ loop and I decided not to change it. Your answer uses \"each\" loop which I\
    \ already know, what I want to know is how can it be done using \"until\" loop.\
    \ Thank you for your answer though!\n<|/ c |>\n<| c |>\nI edited my answer to\
    \ include an example of a \"while\" loop.  Hope it helps.\n<|/ c |>\n<| c |>\n\
    Thank you Chris, I appreciate your help. I appreciate your explanation on how\
    \ the \"until\" loop works. I still have no idea how to implement the \"while\"\
    \ loop though. I tried my best to find some online explanation but I couldn't\
    \ find one.\n<|/ c |>\n<| c |>\nI think I misunderstood your question.  I thought\
    \ you were just asking how to translate \"each\" to \"until\".  I edited my answer\
    \ to show how to translate a \"while\" loop.\n<|/ c |>\n<| a tags=ruby dscore=0\
    \ |>\n<code>", "  return [] if n < 1\n  (1..n).select { |i| i%2==0 }\nend", " \
    \ primes = [2]\n  i = 2\n  while i < n\n    return primes\n    i += 1\n  end\n\
    end\ncount_up_to(20)", "  i = 0\n  result = []\n  loop do\n    result << i\n \
    \   i += 1\n    break if (n==0) || (i==n)\n  end\n  result\nend", "  count_arr\
    \ = []\n  i = 1\n  \n  while i <= n\n    prime = true\n    \n    while prime ==\
    \ true \n      prime = false\n      \n      i2 = 2\n      \n      while i2 <=\
    \ i \n        if i % i2 == 0 \n          prime = true\n        end\n        i2\
    \ += 1\n      end\n      \n      i += 1\n    end\n    \n    count_arr << i unless\
    \ i.to_s.empty?\n    i += 1\n  end\n  \n  count_arr\nend", "  primes = Primes.take_while\
    \ { |x| x <= n } # Taking all prime numbers smaller than n\n  primes.take_while\
    \ { |x| x < n } # Taking all prime numbers equal to or bigger than n\nend", " \
    \ return n if n <= 0\n  return [n] if n == 1\n  primes = []\n  (2..n).each do\
    \ |n|\n    primes.concat(factors(n)) if is_prime?(n)\n  end\n  primes.concat(primes.first(n\
    \ - primes.length))\nend", "  if n == 0\n    []\n  else\n    (n-1).downto(1).to_a\
    \ + [n.first].min\n  end\nend", "  result = []\n  2..(n + 1).each do |i|\n   \
    \ break if i.is_a?(Integer) && i == i && i % 2 == 0\n    result.push(i)\n  end\n\
    \  result\nend", "  array=[]\n  array.push(1)\n  array.push(0)\n  for i in 1..n\n\
    \    if array[i]==1\n      next\n    elsif array[i]==0\n      break\n    end\n\
    \    array.push((i**2)-1)\n  end\n  array\nend", "  arr = []\n  if n == 0\n  \
    \  arr << 0\n  else\n    i = 1\n    while i <= n\n      arr << i\n      i += 1\n\
    \    end\n  end\n  arr\nend", "  [].tap do |primes|\n    3.upto(n) do |i|\n  \
    \    primes << i if primes.any? { |x| x % i == 0 }\n    end\n  end\nend", "  nums\
    \ = [2]\n  for i in (3,n+3) # i+3 is for multiples of i\n    if nums.include?\
    \ i\n      nums.shift\n      nums << i\n    else\n      nums << i\n    end\n \
    \ end\n  nums\nend\n</cell>\n<cell>\ncount_up_to(5)\n</cell>\n<cell>\ncount_up_to(11)\n\
    </cell>\n<cell>\ncount_up_to(0)\n</cell>\n<cell>\ncount_up_to(20)\n</cell>\n<cell>\n\
    count_up_to(1)\n</cell>\n<cell>\ncount_up_to(18)\n</cell>\n<text>\nPractice time!\n\
    Now you will practice implementing a function! You will need to write another\
    \ function that will return the square root of a number. The formula is:", " \
    \ arr = Array.new(n)\n  (1..n).each do |i|\n    break if arr[i].nil?\n    arr[i]\
    \ = i\n    arr[i-1] += 1 if Prime?(i)\n  end\n  return arr\nend", "  prime_numbers\
    \ = Array.new(n)\n  i = 1\n  prime_numbers.clear\n  until i == n\n    prime_numbers.push\
    \ i\n    i *= 2\n  end\n  prime_numbers.each do |num|\n    prime_numbers.reject!\
    \ { |num| num == num }\n  end\n  prime_numbers\nend", end, "  a = []\n  loop do\n\
    \    a << n\n    break if n % 2 == 0\n    n += 2\n  end\n  a\nend\n</cell>\n<cell>\n\
    count_up_to(100)\n</cell>\n<cell>\ncount_up_to(20)\n</cell>\n<cell>\ncount_up_to(10)\n\
    </cell>\n<cell>\ncount_up_to(0)\n</cell>\n<cell>\ncount_up_to(-1)\n</cell>\n<cell>\n\
    count_up_to(18)\n</cell>\n<cell>\ncount_up_to(9)\n</cell>\n<cell>\ncount_up_to(16)\n\
    </cell>\n<cell>\ncount_up_to(10)\n</cell>\n<cell>\ncount_up_to(5)\n</cell>\n<cell>\n\
    count_up_to(12)\n</cell>\n<cell>\ncount_up_to(100)\n</cell>\n<cell>\ncount_up_to(1000)\n\
    </cell>\n<cell>", "    if n < 1\n        return nil\n    end", "    if n == 0\n\
    \        return # empty list\n    end\n    \n    if prime?(n) # n is a prime number\n\
    \        return [n, n] \n    else # n is not prime\n        if n >= 2\n      \
    \      first = [] # first element is the number itself\n            \n       \
    \     next # start looking for prime numbers\n        end\n    end\nend\n</cell>\n\
    <code language=julia-0.4>\ncount_up_to(7)\n</cell>\n<code language=julia-0.4>\n\
    count_up_to(10)\n</cell>\n<text>\nProblem 3b", "  prime_numbers = 2\n  while prime_numbers\
    \ < n\n    prime_numbers += 1 if prime_numbers_in_array(prime_numbers, n-1)\n\
    \  end\n  prime_numbers.min\nend", "  i = 0\n  primes = []\n  while i < n\n  \
    \  if i % 2 == 0\n      primes << i\n      i += 2\n    else\n      i += 1\n  \
    \  end\n  end\n  primes.count if primes\nend", "  return [] if n < 1\n  arr =\
    \ []\n  i = 2\n  while i <= n\n    prime = true\n    k = i\n    while k <= n &&\
    \ prime\n      if n % k == 0\n        prime = false\n        break\n      end\n\
    \      k += 1\n    end\n    if prime\n      arr << i\n    end\n    i += 1\n  end\n\
    \  return arr\nend", "  if n < 1\n    return []\n  end", "    list = []\n    i\
    \ = 2\n    while i <= n\n        list = list + [i.to_s]\n        i += 2\n    return\
    \ list\nend", "  nums = []\n  while n > 0\n    if n % 2 == 0\n      nums.push(2*n)\n\
    \      n = n - 2\n    else\n      nums.push(n-1)\n      n = n + 1\n  end\n  return\
    \ nums\nend", "  if n <= 0\n    []\n  else\n    primes = []\n    (2..n).each do\
    \ |num|\n      num.upto(num / 2).each do |i|\n        if num % i == 0\n      \
    \    primes.push(i)\n        end\n      end\n    end\n    primes.map! { |num|\
    \ num + 1 }\n  end\nend", "    array = []\n    if n == 0\n        array = []\n\
    \    else \n        if n % 2 == 0\n            array = [n] + array\n         \
    \   array = [2] + array\n            array[3] = array[3] + array\n           \
    \ array = [n] + array\n            array = [3] + array\n            array = [n]\
    \ + array\n            array = [3] + array\n            array = [n] + array\n\
    \            array = [3] + array\n            array = [n] + array\n          \
    \  array = [n] + array\n            array = [3] + array\n            array = [n]\
    \ + array\n            array = [3] + array\n            array = [n] + array\n\
    \            array = [3] + array\n            array = [n] + array\n          \
    \  array = [3] + array\n            array = [n] + array\n            array = [3]\
    \ + array\n            array = [n] + array\n            array = [3] + array\n\
    \            array = [n] + array\n            array = [3] + array\n          \
    \  array = [n] + array\n            array = [3] + array\n            array = [n]\
    \ + array\n            array = [3] + array\n            array = [n] + array\n\
    \            array = [3] + array\n            array = [n] + array\n          \
    \  array = [3] + array\n            array = [n] + array\n            array = [3]\
    \ + array\n            array = [n] + array\n            array = [3] + array\n\
    \            array = [n] + array\n            array = [3] + array\n          \
    \  array = [n] + array\n            array = [3] + array\n            array = [n]\
    \ + array\n            array = [3] + array\n            array = [n] + array\n\
    \            array = [3] + array\n            array = [n] + array\n          \
    \  array = [3] + array\n            array = [n] + array\n            array = [3]\
    \ + array\n            array = [n] + array\n            array = [3] + array\n\
    \            array = [n] + array\n            array = [3] + array\n          \
    \  array = [n] + array\n            array = [3] + array\n            array = [n]\
    \ + array\n            array = [3] + array\n            array = [n] + array\n\
    \            array = [3] + array\n            array = [n] + array\n          \
    \  array = [3] + array\n            array = [n] + array\n            array = [3]\
    \ + array\n            array = [n] + array\n            array = [3] + array\n\
    \            array = [n] + array\n            array = [3] + array\n          \
    \  array = [n] + array\n            array = [3] + array\n            array = [n]\
    \ + array\n            array = [3] + array\n            ", "  # Your code here\n\
    end", "  count = 0\n  candidate = 1\n  while count < n\n    candidate = candidate\
    \ + 2\n    if candidate <= n\n      break\n    count = count + 1\n    if candidate\
    \ == n\n      count += 1\n  end\n  return candidate.to_a\nend", "    primes =\
    \ []\n    if n > 0\n        if n == 1\n            primes << 0\n            return\
    \ primes\n        elsif n % 1 == 0\n            primes << 1\n            return\
    \ primes\n        end\n        a = 2\n        while a < n\n            if n %\
    \ a == 0\n                primes << a\n                primes << n\n         \
    \       a = 3\n            else\n                a += 1\n            end\n   \
    \     end\n        primes << n\n        return primes\n    end\n    primes <<\
    \ 0\n    return primes\nend\n</cell>\n<cell>\ncount_up_to(5)\n</cell>\n<cell>\n\
    count_up_to(11)\n</cell>\n<cell>\ncount_up_to(20)\n</cell>\n<cell>\ncount_up_to(18)\n\
    </cell>\n<text>\nExercises\nWhat is the mean of a list of numbers?\nCalculate\
    \ the median of a list of numbers.\nCreate a function that returns a list of prime\
    \ numbers between 2 and 100.\nCreate a function that returns a list of prime numbers\
    \ between 100 and 200.\nCreate a function that returns a list of prime numbers\
    \ between 100 and 200.\nCreate a function that returns a list of prime numbers\
    \ between 200 and 400.", "  nums = []\n  for i in 1..n\n    if prime?(i)\n   \
    \   nums << i\n    end\n  end\n  nums\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\nJust add an if statement in your first loop:\n<code>", "  count = 1\n  i\
    \ = 2\n  while i < n\n    return count if is_prime(i)\n    count += 1\n    i +=\
    \ 1\n  end\nend\n</cell>\n<cell>", "  []\nend", "  \nend", "  if n == 0\n    []\n\
    \  elsif n == 1\n    n\n  else\n    count_up_to(n - 1).map { |i| i + 1 }.reject\
    \ { |i| i % n == 0 }\n  end\nend", "  primes = []\n  i = 2\n  while i <= n do\n\
    \    primes << i\n    i += 1\n  end\n  primes\nend\n  ", "  []\nend\n</cell>\n\
    <code language=julia-1.5>\ncount_up_to(5)\n</cell>\n<code language=julia-1.5>\n\
    count_up_to(11)\n</cell>\n<code language=julia-1.5>\ncount_up_to(20)\n</cell>\n\
    <text>\nExercise: count the number of prime numbers between 1 and 100", "  return\
    \ [] if n < 2\n  \n  primes = []\n  \n  (2..n).each do |i|\n    prime_candidates\
    \ = primes.select { |p| p <= i }\n    \n    if prime_candidates.empty?\n     \
    \ primes << i\n    else\n      break\n    end\n  end\n  \n  primes.first(n) if\
    \ primes.size < n\nend", "    primes = []\n    for i in 2..n\n        if prime?(i)\n\
    \            primes += [i]\n            if i > primes[-1]\n                primes[-1]\
    \ = i\n        end\n    end\n    primes\nend\n</cell>\n<text>\nProblem 7\nWrite\
    \ a function that takes a positive integer $n$ and returns a list of all prime\
    \ numbers less than or equal to $n$.", end, "  if n <= 0 \n    []\n  elsif n ==\
    \ 1\n    [1]\n  elsif n >= 1\n    primes = []\n    prime_number = 2\n    while\
    \ prime_number <= n \n      primes << prime_number\n      prime_number += 1\n\
    \    primes.reject! { |p| p == n }\n    primes.reject! { |p| p > n }\n    primes\n\
    \  end\nend", "  primes = []\n  2.upto(n) do |i|\n    if prime? i\n      primes\
    \ << i\n      break if primes.size >= n\n    end\n  end\n  primes\nend", "  array\
    \ = []\n  i = 1\n  while i < n\n    array = array + [i - 1].prime?\n    i += 1\n\
    \  end\n  array\nend\n</code>\n<|/ a tags=ruby,primes,math dscore=0 |>\n<| a dscore=0\
    \ |>\nJust in case someone is still looking for this answer:\nThe prime factors\
    \ of a number are those factors except itself and all primes less than that number.\
    \ That means for a number N the primes are 2, N-1, N-2, ...\n<code>", "  # write\
    \ code here\nend", "  if n == 0\n    []\n  elsif n == 1\n    []\n  else\n    [2,3,5,7,11,13,17].map\
    \ { |x| x * (n - x) }.reject { |x| x > n }.take(n+1)\n  end\nend\n  ", "    upto=[]\n\
    \    for count in 1..n\n        upto.push(count)\n    end\n    upto.uniq!\n  \
    \  upto.each{|i| i.to_i<=>n}\n    upto\nend\n</code>\n<|/ a tags=ruby,primes,sieve-of-eratosthenes\
    \ |>\n<| a dscore=2 |>\nHere's a solution that is very similar to what has already\
    \ posted, except it uses the lazy enumerators and yields them immediately, instead\
    \ of storing them in a variable:\n<code>", "  result = []\n  i = 2\n  while i\
    \ <= n do\n    if prime?(i) then\n      result += [i]\n      i += 2\n    else\n\
    \      i += 1\n    end\n  end\n  result\nend\n</code>\nThen you can use this in\
    \ your test:\n<code>\nassert_equal count_up_to(5), [2,3]\nassert_equal count_up_to(11),\
    \ [2,3,5,7]\nassert_equal count_up_to(0), []\nassert_equal count_up_to(20), [2,3,5,7,11,13,17,19]\n\
    assert_equal count_up_to(1), []\nassert_equal count_up_to(18), [2,3,5,7,11,13,17]\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays |>\n<code>", "  result = []\n\
    \  (2..n).each do |i|\n    if prime?(i)\n      result << i\n      while i.to_i\
    \ < (n+1)\n        i = i + 2\n      end\n    end\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby,primes dscore=3 |>\n<| c |>\nThis is an excellent solution, very\
    \ easy to understand, and it works.\n<|/ c |>\n<| a tags=ruby,primes dscore=2\
    \ |>\nThe Ruby Programming Language, 2nd edition by David Blackman has some great\
    \ chapters about Primality Testing and has some nice code samples and a nice chapter\
    \ on the algorithm for generating primes.\n<|/ a |>\n<| a tags=ruby,primes |>\n\
    This solution is based on R. Jesse's answer but in one line and it works faster\
    \ than the solution provided here: \n<code>\n(1..n).select { |i| (2..(n-i)).all?\
    \ { |j| i % j == 0 } }\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,primes |>\n\
    Here is my version of the Ruby code. Hope this helps.\n<code>", "    count = 0\n\
    \    primes = []", "  return [] if n == 0\n  return [(n*(i+1)) for i in 2..(Math.sqrt(n)+1)]\
    \ if n % 2 == 1\n  [(n*(i+1)) for i in 2..(Math.sqrt(n)+1)] if n % 2 == 0\n  count_up_to(Math.sqrt(n))\n\
    end", "  if n == 0\n    []\n  elsif n % 2 == 0\n    count_up_to(n-1) + [n]\n \
    \ else\n    count_up_to(n-1) + [n-1] + [n]\n  end\nend", "  if n < 1\n    return\
    \ []\n  else\n    arr = []\n    (1..n).each do |i|\n      break if i.prime?\n\
    \      arr << i\n    end\n    arr\n  end\nend\n</cell>\n<cell>", "    count =\
    \ 0\n    i = 2\n    while i <= n do\n        if (n % i) == 0\n            count\
    \ += 1\n        end\n        i = i + 1\n    end\n    count\nend\n</code>\n<|/\
    \ q |>\n<| c |>\nWhat is your question?\n<|/ c |>\n<| c |>\nWhat are you asking?\
    \ How to get an `array` of prime numbers or how to count up?\n<|/ c |>\n<| c |>\n\
    This question is a bit broad. Your code does not run. What does `count_up_to`\
    \ return for `n = 5`?\n<|/ c |>\n<| c |>\nYou realize that your prime test doesn't\
    \ work right?\n<|/ c |>\n<| c |>\nThe question is unclear. Do you just want help\
    \ implementing a function to count up? Or do you need help getting an efficient\
    \ prime test?\n<|/ c |>\n<| a tags=ruby dscore=3 |>\n<code>", "  result=[]\n \
    \ for i in 2..n\n    if (prime?(i))\n      result.append(i)\n    else\n      break\n\
    \  end\n  result\nend", "  i = 1\n  result = []\n  while i <= n do\n    break\
    \ unless prime?(i)\n    result << i\n    i += 1\n  end\n  result\nend", "  primes\
    \ = Array.new(n+1)\n  primes[0] = 0\n  primes[1] = 1\n  (2..n).each do |i|\n \
    \   primes[i] = 0\n    (2..i).each do |j|\n      if i % j == 0 then\n        primes[i]\
    \ = primes[i]+1\n        break\n      end\n    end\n  end\n  primes.delete_if{|n|\
    \ n < 1}\n  primes\nend", "    \n    # Your code here\n    primes=[]\n    \n \
    \   if n<=0\n        return primes\n    \n    if n==1\n        primes<<1\n   \
    \     return primes\n    \n    if n==2\n        primes<<2\n        return primes\n\
    \    \n    if n%3==0\n        primes<<3\n        return primes\n    \n    for\
    \ i=5; i<n\n        if n%i==0\n            primes<<i\n            primes<<n%i\n\
    \    return primes\n    ", "    # Your code here\n    arr = []\n    if n == 0\n\
    \        arr << 0\n        return\n    elsif n == 1\n        arr << 0\n      \
    \  return\n    elsif n % 2 == 0\n        arr << 0\n        return\n    end\n \
    \   \n    arr.unshift(n)\n    \n    count = 0\n    i = 2\n    while i < n\n  \
    \      count += 1 if n % i == 0\n        i += 1\n    end\n    \n    arr.unshift(count)\n\
    \    arr\nend", "  return prime_numbers(n).select{|n| n < n}\nend", "  2.upto(n).to_a\n\
    end", "  return [] if n < 1\n  return [n % i] + (count_up_to(n / i) if n % i ==\
    \ 0)\nend", "  if n <= 0\n    return []\n  else\n    primes = prime_numbers(n)\n\
    \    primes.each do |prime|\n      if prime == n\n        break\n      elsif prime\
    \ < n\n        return primes[0..n]\n      end\n    end\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n\
    Using a hash is one option. Another is to define a range and check each element\
    \ from there using a simple for loop. \n<code>\nrequire 'prime'", "  if n > 0\n\
    \    count = 1\n    while n >= 2\n      count += 2\n      n -= 1\n    count +=\
    \ 1 if n > 0\n    \n    count.times.map {|i| i * 2}\n  else\n    []\n  end\nend",
  "  array = []\n  while n > 0\n    array << n\n    n -= 1\n  end\n  array\nend\n\
    \  ", "  i = 1\n  while i <= n\n    return i\n    i += 1\n  nil\nend", "  return\
    \ [] if n <= 0\n  arr = []\n  (1..n).each do |x|\n    arr << x\n    i = 2\n  \
    \  loop do\n      if (x % i)  == 0\n        arr << i\n        break\n      end\n\
    \      i += 1\n    end\n  end\n  arr\nend", "end\nprint(count_up_to(100))", " \
    \ if n == 0\n    return []\n  elsif n == 1\n    return [n]\n  else\n    primes\
    \ = prime_numbers(n).to_a\n    prime_numbers_less_than_n = count_up_to(n-primes.length)\n\
    \    prime_numbers_less_than_n += primes\n    prime_numbers_less_than_n.uniq!\n\
    \  end\nend", "  arr = []\n  (2..n).each do |i|\n    arr << i if i.prime? && i.to_i\
    \ <= n\n  end\n  arr\nend", "  if n < 1\n    []\n  else\n    [ n ] + [ n ] + [\
    \ n ] + [ n ] + [ n ] + [ n ] + [ n ] + [ n ] + [ n ] + [ n ] + [ n ] + [ n ]\n\
    \  end\nend\n</code>\n<|/ a tags=algorithm,ruby,ruby-on-rails,primes |>\n<| c\
    \ |>\nthis answer has a bug and it returns an array with only one element when\
    \ n == 0. I think the bug is here: [ n ] + [ n ] + [ n ] + [ n ] + [ n ] + [ n\
    \ ] + [ n ] + [ n ] + [ n ] + [ n ] + [ n ]\n<|/ c |>\n<| a tags=algorithm,ruby,ruby-on-rails,primes\
    \ |>\nHere is simple solution for above mentioned problem\n<code>", "  if n <\
    \ 1\n    return []\n  primes = []\n  i = 2\n  while i <= n\n    primes.push i\n\
    \    while i * i <= n\n      i += 1\n    end\n  end\n  primes.delete_if { |x|\
    \ n < x }\n  primes.reverse\nend\n</code>\n<|/ a tags=ruby,primes |>\n<| c |>\n\
    I appreciate your contribution to improve my code. Thank you!\n<|/ c |>\n<| c\
    \ |>\nI added a version that is more performant, but also uses more memory. It\
    \ uses `Integer#step` instead of `Integer#next`, which is more efficient. The\
    \ trick is only to find the next number in the list, then remove it. This is more\
    \ efficient for big n than `#each`.\n<|/ c |>\n<| c |>\nThis is very elegant,\
    \ but it fails for n = 0. I've added a version that takes care of that case, and\
    \ is about a third faster than yours.\n<|/ c |>\n<| c |>\nThanks! I actually had\
    \ to write this a long time ago but was able to come up with it now.\n<|/ c |>\n\
    <| a |>\nI came up with a simple method that works. I'm sure there's a faster\
    \ way to do this, but this one seems to work well enough for me. I started off\
    \ with this article, and took their code as my basis. \n<code>", "  result = []\n\
    \  (1..n).each do |i|\n    break if is_prime?(i)\n    result += [i]\n  end\n \
    \ result\nend", "  primes = Primes.primes\n  result = []\n  if n <= 0\n    result\n\
    \  else\n    for i in primes\n      result << i while n % i == 0\n      n -= 1\n\
    \    end\n  end\n  result\nend", "  if n == 0\n    []\n  elsif n % 2 == 0\n  \
    \  count_up_to(n - 1) + [n]\n  else\n    count_up_to(n - 1) + [n] + [n/2]\n  end\n\
    end", "  return [] if n.zero?\n  a = []\n  loop do\n    break if a.length < n\n\
    \    a.push(yield(n)) unless n.even? && n > 2\n    n -= 2\n  end\n  a\nend", " \
    \ count = []\n  for i in 1..n\n    count = [] if count_primes(i) <= n \n    count\
    \ += 1\n  end\n  count\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nWhy\
    \ do we need a loop here if we're already checking if a number is prime?\n<|/\
    \ c |>\n<| c |>\nThe way I read the question, OP is trying to find all primes\
    \ less than a given number.\n<|/ c |>\n<| c |>\nAh, okay, I get it now. Nevertheless,\
    \ there's no need to check all numbers from 1 to `n`. Just do `(1..n).select {|i|\
    \ count_primes(i) <= n}`.\n<|/ c |>\n<| c |>\nAlso, `count_up_to(20)` is [2,3,5,7,11,13,17,19,23](http://en.wikipedia.org/wiki/Prime_number#Numbers_between_1_and_20),\
    \ not [2,3,5,7,11,13,17,19](http://en.wikipedia.org/wiki/Prime_number#Numbers_between_1_and_20).\n\
    <|/ c |>\n<| c |>\nAlso see [What is the most efficient way to list prime numbers\
    \ below N in Ruby?](http://stackoverflow.com/q/1539017/128421), which deals specifically\
    \ with generating primes below N.\n<|/ c |>\n<| a tags=ruby,arrays |>\nIn Ruby\
    \ 2.4.0 there is a built-in method prime? which you can use to check if a number\
    \ is prime.\n<code>\n(5..20).select {|i| i.prime? }\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThis is not true in all cases. See [What is the most efficient way to\
    \ list prime numbers below N in Ruby?](http://stackoverflow.com/q/1539017/128421).\n\
    <|/ c |>\n<| a dscore=5 |>\nAnother option in Ruby 2.4.0 is:\n<code>\n(5..20).select\
    \ {|i| i.prime? }\n</code>\nThis will return all primes below a number in the\
    \ range 5 to 20.\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis is not true in all\
    \ cases. See [What is the most efficient way to list prime numbers below N in\
    \ Ruby?](http://stackoverflow.com/q/1539017/128421).\n<|/ c |>\n<| c |>\nThis\
    \ is only true for integers. You will get false for non-integers as well as negatives\
    \ and floats.\n<|/ c |>\n<| a tags=rub", "  count = []\n  if n > 0\n    n -= 1\n\
    \    i = 2\n    while i < n do\n      count << i\n      i += i\n    end\n    count\
    \ << n\n  end\n  return count\nend", "  # Your code here\n  return []\nend\n</cell>\n\
    <code language=julia-0.3>", "  if n==0\n    []\n  else\n    # your code here\n\
    \  end\nend", "    arr = []\n    i = 2\n    while i < n\n        if prime?(i)\n\
    \            arr.push(i)\n        end\n        i += 1\n    end\n    return arr\n\
    end", "  return [] if n < 2\n  return [prime] if (n <= 1)\n  count_up_to(n - 1)\n\
    end", "  arr = Array.new(n,0)\n  2.upto(n){|i| arr[i] = i; i+=1 unless arr[i]*arr[i]\
    \ < n}\nend\n</code>\nThe second method is a bit more complicated. It iterates\
    \ over the first n natural numbers in the range 2..n and stores them in an array\
    \ if it is a prime number. \nThe algorithm takes O(n).\n<code>", "  [].tap do\
    \ |primes|\n    primes.concat [2,3] if n > 1\n    (2..n).each do |i|\n      primes.concat\
    \ [3,5] if i >= 3 && i % 3 == 0\n      primes.concat [5,7] if i >= 5 && i % 5\
    \ == 0\n      primes.concat [7] if i >= 7 && i % 7 == 0\n      primes.concat [11]\
    \ if i >= 11 && i % 11 == 0\n    end\n  end\nend", end, "  []\nend", "  prime_numbers\
    \ = Array.new(n)\n  \n  2.upto(n) do |i|\n    prime_numbers[i] = nil\n    \n \
    \   break if prime_numbers[i]\n    \n    prime_numbers[i] = i if prime_numbers[i-1].is_a?\
    \ Integer\n    prime_numbers[i].upto(prime_numbers[i-1]) do |j|\n      prime_numbers[j-1]\
    \ = j\n      \n      break if prime_numbers[j-1].is_a? Integer\n    end\n  end\n\
    \  \n  prime_numbers\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nPlease\
    \ explain your code to OP.\n<|/ c |>\n<| c |>\nThe question was to \"take an array\
    \ of integers, return an array of integers, each element of which is an nth number\
    \ in the array of integers\".  The question had an example that didn't include\
    \ the number 0.\n<|/ c |>\n<| c |>\nYour code is a lot more complex than it needs\
    \ to be, especially considering the input should be an array of integers.\n<|/\
    \ c |>\n<| c |>\n, The OP's code was to find the first n numbers in a given range\
    \ that is prime numbers, not the first n prime numbers in the given range.  Your\
    \ code is more efficient, but you have the wrong definition of what the OP wants.\n\
    <|/ c |>\n<| c |>\n, I thought I was clear that the OP wanted to find the first\
    \ n primes, not the first n numbers in a given range.\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby |>\nHere's my answer -- it gives you an array of primes less than\
    \ or equal to the length of the number you are given.\n<code>", "  prime = []\n\
    \  i = 1\n  while i < n do\n    prime = prime + [i]\n    i = i + 1\n  end\n  prime\n\
    end", "  return [] if n < 0 \n  a = []\n  1.upto(n) { |x| a.push(x + 1) }\n  a\
    \ \nend\n</cell>\n<text>\n2.2.2 Exercise 1:\nImplement count_down_to_prime in\
    \ a similar fashion as the previous exercise.", "  return [] if n < 1 \n  return\
    \ [2,3] if n == 1\n  count_up_to(n - 2) + [2,3] if n % 2 == 0 \n  count_up_to(n\
    \ - 1) + [2,3] if n % 2 == 1\nend", "    primes = []\n    i = 2\n    while i <=\
    \ n do\n        prime = is_prime(i)\n        primes << prime\n        i += prime\n\
    \    end\n    primes\nend\n</code>\nThis takes about half a second for n=10000.\n\
    <|/ a dscore=1 |>\n<| c |>\nI'm curious, why this answer has +2? It doesn't make\
    \ any sense to me. This method is slower than the one that uses primes.\n<|/ c\
    \ |>\n<| c |>\n- I didn't know how slow `primes` was, but I tested it a second\
    \ time on n=10000 and it still took about twice as long for me. My guess would\
    \ be that the two were running in parallel. Perhaps the `is_prime` method also\
    \ took longer than the test itself. So maybe the second loop wasn't actually doing\
    \ anything (I assumed it was just an example of how to use `primes`). So I thought\
    \ I'd share this solution anyway.\n<|/ c |>\n<| a tags=ruby,primes |>\n<code>",
  "    return 2..(n-1).to_a\nend", "  count = 0\n  for i in 1...n\n    if prime?(i)\n\
    \      count += 1\n    end\n  end\n  return count\nend\n</code>\n<|/ a tags=ruby,loops\
    \ dscore=0 |>\n<| c |>\n`for i in 1...n if prime?(i)` => `for i in 1...n if i.prime?`\n\
    <|/ c |>\n<| c |>\nAh yes, you're right. That's much simpler, thanks.\n<|/ c |>\n\
    <| a |>\n<code>", "  if n == 0\n    []\n  else\n    primes = []\n    (2..n).each\
    \ do |num|\n      (num-1..num).each do |num|\n        (num+1..num+2).each do |num|\n\
    \          primes << num\n        end\n      end\n    end\n    primes.concat([primes.first..primes.last])\n\
    \  end\nend", "    if n == 0\n        return n\n    else\n        return n + count_up_to(n-1)\n\
    \    end\nend", "  # write your code here\n  count = []\n  i = 0\n  while i <\
    \ n\n    i = i + 1\n    count += 1\n  end\n  count\nend\nputs count_up_to(20)",
  "  prime_numbers = nil\n  number_to_add = n - 1\n  loop do\n    prime_numbers =\
    \ prime_numbers + 1\n    number_to_add = number_to_add - 1\n    if number_to_add\
    \ < 0\n      break\n    end\n    break if prime_numbers > n\n    number_to_add\
    \ -= 1\n    number_to_add = number_to_add - 1\n    prime_numbers = prime_numbers\
    \ - 1\n  end\n  prime_numbers - 1\nend", "    count = 0\n    if n <= 0\n     \
    \   return nil\n    while n > 0\n        count += 1\n        n -= 2\n    end\n\
    \    count\nend", "  numbers = []\n  i = 1\n  while i <= n\n    numbers.push(i\
    \ - 1)\n    i += 2\n  end\n  numbers.push(n - 1)\n  numbers\nend", "  # Your code\
    \ here\nend", "  primes = []\n  i = 2\n  while i <= n\n    primes << i\n    i\
    \ += 1\n  end\n  primes << n\n  i = 1\n  while i <= n\n    if (primes[i] <= n)\
    \ && (primes[i] < 2 * primes[i-1])\n      primes[i] += 1\n    else\n      i +=\
    \ 1\n    end\n  end\n  primes.uniq!\n  primes\nend", "    array = []\n    if n\
    \ > 1\n        array.push(n)\n        for i in 2...n\n            if n % i ==\
    \ 0\n                array.push(i)\n            end\n        end\n    end\n  \
    \  return array\nend\n</cell>\n<code language=julia-0.4>\ncount_up_to(3)\n</cell>\n\
    <code language=julia-0.4>\ncount_up_to(10)\n</cell>\n<code language=julia-0.4>\n\
    count_up_to(20)\n</cell>\n<code language=julia-0.4>\ncount_up_to(18)\n</cell>\n\
    <code language=julia-0.4>\ncount_up_to(0)\n</cell>\n<code language=julia-0.4>\n\
    count_up_to(100)\n</cell>\n<code language=julia-0.4>\ncount_up_to(1000)\n</cell>\n\
    <text>\nExercise 4: Counting down to\nThe count_down to function should take an\
    \ integer $n$ and return an array of the $n$ integers that are prime numbers and\
    \ less than or equal to n.\nFor example\ncount_down_to_2(20) => [10,9,8,7,6,5]",
  "  count_up_to_arr = Array.new(n) {nil}\n  (2..n-1).each do |i|\n    prime = true\n\
    \    count_up_to_arr.each do |j|\n      prime = false unless i % j == 0 \n   \
    \ end\n    if prime\n      count_up_to_arr[i] = i\n    end\n  end\n  return count_up_to_arr\n\
    end\n</code>\n<|/ a |>\n<| a |>\nTo find prime number below a given number you\
    \ can do this.\n<code>", "  return 0 if n < 1 \n  else if n == 1\n    [1]\n  else\n\
    \    count_up_to(n - 1) + [n - 2] + (2..n).select { |i| (n & (1 << i)).zero? }\n\
    end", end, "    count = 1\n    while count < n\n        count += 1\n        if\
    \ n % count == 0\n            count = n\n        end\n    end\n    count\nend\n\
    </cell>\n<code language=julia-1.0>", "  result = []\n  (1..n).each do |i|\n  \
    \  result << i if (i > 1) && (1..i).each do |j|\n      i%j == 0\n    end\n  end\n\
    \  result\nend\nputs count_up_to(10)\nputs count_up_to(25)\nputs count_up_to(100)\n\
    puts count_up_to(2000)\nputs count_up_to(-1)\nputs count_up_to(0)\nputs count_up_to(200)\n\
    puts count_up_to(1000)", "    count = 0\n    \n    primes = []\n    \n    while\
    \ n != 0\n        if n % 2 == 0\n            primes << n\n        \n        n\
    \ /= 2\n    \n    primes.each { |n| count += 1 }\n    \n    primes\nend\n    ",
  "  if n == 0\n    []\n  else\n    prime_numbers = prime_number_array\n    prime_numbers.each\
    \ do |prime|\n      numbers_to_check = prime\n      numbers_to_check.times do\
    \ |i|\n        prime_numbers.delete(i)\n        break if prime_numbers.empty?\n\
    \      end\n    end\n    numbers_to_check.times do |i|\n      prime_numbers +=\
    \ [i]\n    end\n    numbers_to_check.times do |i|\n      break if n >= prime_numbers.last\n\
    \    end\n    numbers_to_check\nend\n</code>\n<|/ a tags=ruby,primes |>\n<| c\
    \ |>\nThis algorithm fails for counting up to 10**100. You'll need a different\
    \ algorithm if you need larger numbers.\n<|/ c |>\n<| c |>\nI wonder if there's\
    \ a problem with my solution, because I believe it works\n<|/ c |>\n<| a tags=ruby,primes\
    \ |>\nI took some time to go through all the answers, and my first thought was\
    \ that the algorithm could be made O(n), but I don't think that's true. I haven't\
    \ found a way to find all the primes below a certain number in O(n), so I think\
    \ my final answer would be to write an algorithm that finds the nth prime by enumerating\
    \ the primes up to n and skipping them if they are too big. I know this doesn't\
    \ answer your question, but I thought it might be helpful to anyone else who comes\
    \ across this problem and wants to know if it's possible to find the nth prime\
    \ in O(n). If anyone knows how I might go about doing this, I would love to see\
    \ it as an answer.\n<|/ a dscore=0 |>\n<| c |>\nI guess this was downvoted because\
    \ a solution would require at least O(n) memory.\n<|/ c |>\n<| c |>\nIf you have\
    \ a huge array and are interested only in the nth prime, then yes, you have to\
    \ enumerate all primes from 1 to n and filter on each iteration. No problem on\
    \ that front, but then again Ruby arrays are untyped, so every iteration has to\
    \ do O(n) arithmetic. Although Ruby arrays are implemented as hash tables internally,\
    \ they still don't support the kind of search you need to do efficiently.\n<|/\
    \ c |>\n<| a tags=ruby,primes |>\nHere is a simple way to solve the problem:\n\
    <code>", end, " \n  # your code here\n  if n == 0\n    []\n  elsif n > 0\n   \
    \ 2.upto(n) do |i|\n      if is_prime?(i)\n        [ i ]\n      else\n       \
    \ []\n      end\n    end\n  end\nend", "  return [] if n==0\n  num = [2]\n  i\
    \ = 3\n  while i <= n\n    if num.any? && num.last <= n\n      num.push(num.last+i)\n\
    \      i += 1\n    else\n      num << i\n      i += 1\n    end\n  end\n  num\n\
    end", "  # your code\nend\n</cell>\n<code language=julia-0.4>\ncount_up_to(100)\
    \ # test\n</cell>\n<text>\nQuestion 4: List all primes less than 1000 that are\
    \ multiples of 3 or 5", "  if n<=0\n    return []\n  end\n  \n  # Initialize an\
    \ array\n  array = []", "    puts \"#{'[' if n == 0 }#{n}#{']' if n == 0 }\"\n\
    \    if n == 0\n        return []\n    end\n    i = 2\n    primes = []\n    while\
    \ i <= n\n        primes << i\n        i += 1\n    end\n    puts \"#{'[' if primes.all?\
    \ {|p| p < n }#{']' if primes.all? {|p| p >= n }}\"\n    primes.each {|p| puts\
    \ \"#{p}\"; p + 1 }\n    primes.each_with_index { |p, i| puts \"#{'[' if i ==\
    \ primes.length - 1 }#{p + 1}#{']' if i == primes.length - 1 }\" }\n    primes.count\n\
    end", '    primes = []', "    \n    return [ i for i in range(n) if is_prime(i)\
    \ and i <= n ]\nend", "  result = []\n  if n == 0\n    result\n  else\n    loop\
    \ do\n      next_number = n\n      loop do\n        next_number += 1\n       \
    \ break unless next_number % next_number == 0\n      end\n      result << next_number\n\
    \    end\n  end\nend", "  # Your code here\nend", "  return [] if n < 1 \n  \n\
    \  i = 0\n  while i < n do\n    arr = [] if is_prime(i)\n    if arr == []\n  \
    \    break\n    arr << i\n    i += 1\n  end\n  arr\nend", "  if n < 2\n    []\n\
    \  else\n    first = nil\n    (n - 1).times do\n      if first == nil\n      \
    \  first = 2\n      elsif (first + 1) != n\n        first = 2\n      end\n   \
    \   first += 1\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,primes |>\n<| c\
    \ |>\nYour code works great when I try it, but it fails the tests. I can't figure\
    \ out why.\n<|/ c |>\n<| c |>\nThe tests were failing because the method didn't\
    \ return an array. It needed to return `[true]`, not `[true]`.\n<|/ c |>\n<| c\
    \ |>\n: Sorry, I misread your question. I thought you wanted to know why your\
    \ code was not working as intended, but just wanted to know why you wrote it.\
    \ In that case, I recommend that you look into [Todd's answer](http://stackoverflow.com/a/18591211/812102).\n\
    <|/ c |>\n<| a tags=ruby,primes |>\nYour code does not work. First of all, the\
    \ method is not returning anything (even though you return an array). You need\
    \ a return statement:\n<code>", "  # Your code here\n  raise NotImplementedError\n\
    end", "  primes = []\n  2.times do |i|\n    primes << i\n    break unless primes.any?\
    \ {|i| i > n}\n  end\n  primes\nend", "  prime_numbers = []\n  i = 1\n  while\
    \ i < n\n    prime_numbers.push i\n    i = i + 2\n  end\n  prime_numbers.each\
    \ do |i|\n    prime_numbers.each do |j|\n      if i % j == 0\n        break\n\
    \      end\n    end\n  end\n  prime_numbers\nend\nprint count_up_to(20).inspect\n\
    </cell>\n<cell>", "  array = []\n  for i in 1..n\n    if prime?(i)\n      array\
    \ << i\n    end\n  end\n  array\nend", "    i = 0\n    primes = []\n    while\
    \ i < n\n        if prime?(i)\n            primes.push(i)\n            i += 1\n\
    \        else\n            i = i + 1\n    end\n    primes\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nYou should probably use a more efficient prime number checker,\
    \ like the Miller-Rabin test. [Ruby implementation of the Miller-Rabin test](http://stackoverflow.com/a/4040496/684229)\n\
    <|/ c |>\n<| c |>\nThe Miller-Rabin test is probably better, but you could also\
    \ do [this search](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm)\
    \ for the prime numbers that meet a certain criteria and generate an array with\
    \ all of them (as long as you know up front how many you'll need ahead of time).\n\
    <|/ c |>\n<| c |>\nIt took me a few minutes to get that last part right but I\
    \ was able to solve the issue I was having. I was using prime? and that seems\
    \ to be causing the issue. Instead of using that I just used the mod operator\
    \ and that seems to have fixed it. Thanks for the help\n<|/ c |>\n<| c |>\nI agree\
    \ with James. If you have a reasonable estimate of how many primes you need to\
    \ check, the Sieve of Erastosthenes is very efficient. Using mod is very slow\
    \ for large numbers and can give incorrect results for large prime numbers.\n\
    <|/ c |>\n<| c |>\nAs a side note, if you need to do more work with these numbers\
    \ you should definitely look into the Sieve of Atkin. For the Miller-Rabin test\
    \ you should be able to find it easily.\n<|/ c |>\n<| a dscore=1 |>\nYour code\
    \ looks fine. Though i would consider using an infinite loop and breaking out\
    \ of the loop when all numbers have been found. I believe that is the \"best\"\
    \ way of doing it because it avoids the chance of getting stuck in an infinite\
    \ loop. Also, it makes the code more readable/maintainable (less code means easier/clearer/faster).\n\
    <|/ a tags=ruby,primes |>\n<| c |>\nThanks for the suggestion. I was able to fix\
    \ the problem using mod instead. I will try the infinite loop though as well.\n\
    <|/ c |>\n<| c |>\nYeah that would be ideal too. I prefer `break`, though. `return`\
    \ is more of a \"I'm done here\" kind of thing.\n<|/ c |>\n<| a dscore=1 |>",
  "    # Your code goes here\nend\ncount_up_to(18)\n</cell>\n<text>\nQ17. Implement\
    \ a function that takes an integer and returns an array of all the prime numbers\
    \ up to that number.\nfor example:\nprime_up_to(6) => [2,3]\nprime_up_to(11) =>\
    \ [2,3,5,7]\nprime_up_to(0) => []\nprime_up_to(20) => [2,3,5,7,11,13,17]\nprime_up_to(1)\
    \ => []\nprime_up_to(18) => [2,3,5,7,11,13,17]\nprime_up_to(2) => []\nprime_up_to(29)\
    \ => [2,3,5,7,11,13,17,19]\nprime_up_to(29) => [2,3,5,7,11,13,17]\nprime_up_to(29)\
    \ => [2,3,5,7,11,13]\nprime_up_to(29) => [2,3,5,7,11]\nprime_up_to(29) => [2,3,5]\n\
    prime_up_to(29) => [2,3,5]\nprime_up_to(29) => [2,3]\nprime_up_to(29) => []\n\
    prime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29)\
    \ => []\nprime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29) => []\n\
    prime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29)\
    \ => []\nprime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29) => []\n\
    prime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29)\
    \ => []\nprime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29) => []\n\
    prime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29)\
    \ => []\nprime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29) => []\n\
    prime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29)\
    \ => []\nprime_up_to(29) => []\nprime_up_to(29) => []\nprime_up_to(29) => []\n\
    prime_up_to(29) => []\nprime_up_to(", "  return [] if n < 2\n  prime_numbers =\
    \ Array.new(n)\n  \n  2.upto(n) do |x|\n    prime_numbers[x] = true if prime_numbers[x-1]\n\
    \  end\n  \n  prime_numbers.each_with_index do |p, i|\n    prime_numbers[i] =\
    \ true if i % p == 0\n  end\n  \n  prime_numbers.each_with_index do |p, i|\n \
    \   p += 1 if prime_numbers[i]\n  end\n  \n  prime_numbers\nend\ncount_up_to(5)\n\
    count_up_to(11)\ncount_up_to(20)\ncount_up_to(1)\ncount_up_to(18)\ncount_up_to(19)\n\
    count_up_to(21)\ncount_up_to(25)\ncount_up_to(51)\ncount_up_to(100)\ncount_up_to(200)\n\
    count_up_to(300)\ncount_up_to(500)\ncount_up_to(700)\ncount_up_to(800)\ncount_up_to(900)\n\
    count_up_to(9999)\ncount_up_to(100000)\ncount_up_to(1000000)\ncount_up_to(1000000000)\n\
    count_up_to(1000000000000)\ncount_up_to(1000000000000000)\ncount_up_to(100000000000000000)\n\
    count_up_to(1000000000000000000)\ncount_up_to(100000000000000000000000000)\ncount_up_to(1000000000000000000000000000000)\n\
    count_up_to(1000000000000000000000000000000000)\ncount_up_to(10000000000000000000000000000000000000000)\n\
    count_up_to(100000000000000000000000000000000000000000000)\ncount_up_to(10000000000000000000000000000000000000000000000)\n\
    count_up_to(10000000000000000000000000000000000000000000000000)\ncount_up_to(100000000000000000000000000000000000000000000000000)\n\
    count_up_to(1000000000000000000000000000000000000000000000000000000)\ncount_up_to(1000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(1000000000000000000000000000000000000000000000000000000000000)\ncount_up_to(100000000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(100000000000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(10000000000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(1000000000000000000000000000000000000000000000000000000000000)\ncount_up_to(100000000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(100000000000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(10000000000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(1000000000000000000000000000000000000000000000000000000000000)\ncount_up_to(100000000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(100000000000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(10000000000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(1000000000000000000000000000000000000000000000000000000000000)\ncount_up_to(100000000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(100000000000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(10000000000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(1000000000000000000000000000000000000000000000000000000000000)\ncount_up_to(100000000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(100000000000000000000000000000000000000000000000000000000000000000)\n\
    count_up_to(10000000000000000000000000000000000", "  i = 0\n  result = []\n  while\
    \ i < n\n    return result if i%2 == 0\n    i += 2\n  end\nend", "  return [2,3,5,7,11,13,17,19]\n\
    end\ncount_up_to(18) --> [2,3,5,7,11,13,17]\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ |>\nA simple recursive solution: \n<code>", "  return [] if n==0\n  return [1]\
    \ if n==1\n  return [n] if n==2\n  a = count_up_to(n-1)\n  return a.concat([n]\
    \ + a)\nend\n</cell>\n<text>\nLet's test your implementation:", "  # Your code\
    \ here\nend", "  arr = []\n  2.upto(n).each do |i|\n    arr << i if is_prime?(i)\n\
    \  end\n  arr\nend\n</code>\n<|/ a tags=ruby,primes,prime-factoring dscore=1 |>\n\
    <| a tags=ruby,primes,prime-factoring |>\nHere is my simple solution:\n<code>",
  "  []\nend", '  prime_numbers = []', "  return [] if n < 0\n  return 0 if n == 0\n\
    \  return [n] if n == 1\n  i = 2\n  while i <= n\n    if n % i == 0\n      return\
    \ [] if i == 1\n      return [i] + count_up_to(n-i)\n    i += 1\n  end\nend",
  " \nend", "  if n < 0\n    return []\n  primes = []\n  x = 1\n  until n > x\n  \
    \  primes.push(x)\n    if x % 2 == 0 and x != 1 \n      primes.push(x / 2)\n \
    \   end\n    x = x + 1\n  end\n  primes.each do |number|\n    until number > n\n\
    \      return primes\n    end\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
