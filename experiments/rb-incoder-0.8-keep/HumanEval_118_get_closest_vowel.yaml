name: HumanEval_118_get_closest_vowel
language: rb
prompt: "# You are given a word. Your task is to find the closest vowel that stands\
  \ between \n# two consonants from the right side of the word (case sensitive).\n\
  # Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n\
  # find any vowel met the above condition. \n# You may assume that the given string\
  \ contains English letter only.\n# Example:\n# get_closest_vowel(\"yogurt\") ==>\
  \ \"u\"\n# get_closest_vowel(\"FULL\") ==> \"U\"\n# get_closest_vowel(\"quick\"\
  ) ==> \"\"\n# get_closest_vowel(\"ab\") ==> \"\"\ndef get_closest_vowel(word)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_closest_vowel\n\
  \    candidate = method(:get_closest_vowel)\n    assert_equal(\"u\", candidate.call(\"\
  yogurt\"))\n    assert_equal(\"u\", candidate.call(\"full\"))\n    assert_equal(\"\
  \", candidate.call(\"easy\"))\n    assert_equal(\"\", candidate.call(\"eAsy\"))\n\
  \    assert_equal(\"\", candidate.call(\"ali\"))\n    assert_equal(\"a\", candidate.call(\"\
  bad\"))\n    assert_equal(\"o\", candidate.call(\"most\"))\n    assert_equal(\"\"\
  , candidate.call(\"ab\"))\n    assert_equal(\"\", candidate.call(\"ba\"))\n    assert_equal(\"\
  \", candidate.call(\"quick\"))\n    assert_equal(\"i\", candidate.call(\"anime\"\
  ))\n    assert_equal(\"\", candidate.call(\"Asia\"))\n    assert_equal(\"o\", candidate.call(\"\
  Above\"))\n  end\nend\n"
completions: ["  if word.empty?\n    return \"\"\n  vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n  vowels.each do |vowel|\n    match = word.rindex(vowel)\n  \
    \  if match != 0\n      return vowel\n    end\n  end\n  \n  match = word.rindex(\"\
    a\")\n  if match != 0\n    return vowels[0]\n  end\nend", "  vowels = [\"a\",\
    \ \"e\", \"i\", \"o\", \"u\"]\n  count = 0\n  result = ''\n  \n  while count <\
    \ word.length\n    if word[count] != 'a' and word[count] != 'e' and word[count]\
    \ != 'i' and word[count] != 'o' and word[count] != 'u'\n      count += 1\n   \
    \   continue\n    \n    if word[count] == 'a' or word[count] == 'e' or word[count]\
    \ == 'i' or word[count] == 'o' or word[count] == 'u'\n      if word[count - 1]\
    \ == 'a' or word[count - 1] == 'e' or word[count - 1] == 'i' or word[count - 1]\
    \ == 'o' or word[count - 1] == 'u'\n        count -= 1\n        continue\n   \
    \   \n      if word[count + 1] == 'a' or word[count + 1] == 'e' or word[count\
    \ + 1] == 'i' or word[count + 1] == 'o' or word[count + 1] == 'u'\n        count\
    \ += 1\n        continue\n      \n      if word[count + 2] == 'a' or word[count\
    \ + 2] == 'e' or word[count + 2] == 'i' or word[count + 2] == 'o' or word[count\
    \ + 2] == 'u'\n        count += 1\n        continue\n    end\n    \n    if count\
    \ > word.length\n      return ''\n    end\n    \n    if word[count] == 'a'\n \
    \     result = word[count]\n      count += 1\n      continue\n    end\n    \n\
    \    if word[count] == 'e'\n      result = result + \"e\"\n      count += 1\n\
    \      continue\n    end\n    \n    if word[count] == 'i'\n      result = result\
    \ + \"i\"\n      count += 1\n      continue\n    end\n    \n    if word[count]\
    \ == 'o'\n      result = result + \"o\"\n      count += 1\n      continue\n  \
    \  end\n    \n    if word[count] == 'u'\n      result = result + \"u\"\n     \
    \ count += 1\n      continue\n    end\n  end\n  \n  \n  \n  \n  return result\n\
    end", "  consonant_index = word.rindex(\" \")\n  vowel_index = word[consonant_index].rindex(\"\
    \ \")\n  return word[vowel_index..-1].empty? ? \"\" : word[vowel_index..-1]\n\
    end\n</cell>\n<code language=julia-1.6>\nfunction get_closest_vowel(word)\n  \
    \  consonant_index = word.rindex(\" \")\n    vowel_index = word[consonant_index].rindex(\"\
    \ \")\n    return word[vowel_index..-1].empty? ? \"\" : word[vowel_index..-1]\n\
    end\n</cell>\n<code language=julia-1.6>", "  vowels = [\"a\", \"e\", \"i\", \"\
    o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n  result = \"\"\n  word.downcase!\n\
    \  word.split(\"\").each do |letter|\n    return result if vowels.include?(letter)\n\
    \  end\n  \n  result\nend", "    # your code goes here\n    vowels = []\n    vowels\
    \ = [\"a\",\"e\",\"i\",\"o\",\"u\",\"y\",\"A\",\"E\",\"I\",\"O\",\"U\"]\n    vowels.each\
    \ do |vowel|\n        word = word.split(vowel).last\n    end\n    return word\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby,string,arrays |>\n<| a dscore=0 |>\nI think\
    \ this is what you are looking for:\n<code>", "  vowels = ['A', 'E', 'I', 'O',\
    \ 'U']\n  word = \"\" + word\n  last_consonant = false\n  last_vowel = nil\n \
    \ word.split(\"\").each_with_index do |c, i|\n    if last_consonant && (c == last_consonant.downcase)\n\
    \      if last_vowel && last_vowel.downcase != c.downcase\n        last_vowel\
    \ = nil\n        last_consonant = false\n      else\n        last_consonant =\
    \ c\n        last_vowel = nil\n      end\n    else\n      last_consonant = c\n\
    \    end\n  end\n  return last_vowel if last_vowel\n  return nil\nend", "  vowels\
    \ = \"AEIOUaeiou\"\n  \n  word = word.downcase\n  \n  pos = word.index(vowels.to_s)\
    \ #get position of first vowel\n  \n  if pos == 0 #no vowel at beginning\n   \
    \ pos += 1\n  \n  pos2 = word.index(vowels.to_s, pos+1) #get position of next\
    \ vowel\n  \n  if pos2 != -1 # have at least one vowel between 2 consonants\n\
    \    vowel = word[pos+1:pos2]\n  \n    if vowel.include?(\"a\") || vowel.include?(\"\
    e\") || vowel.include?(\"i\") || vowel.include?(\"o\") || vowel.include?(\"u\"\
    )\n      vowel\n    end\n  end\nend", "  word.downcase!\n  word = word.gsub(/[aeiou]/,\
    \ \"\").downcase\n  \n  consonants = [\"b\", \"c\", \"r\", \"z\", \"s\", \"t\"\
    , \"v\", \"x\", \"w\", \"v\"]\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\",\
    \ \"y\"]", "  vowels = %w{ a e i o u }\n  \n  consonants = %w{ b c d f g h j k\
    \ l m n p q r s t v w x y z }\n  \n  return word.downcase.split('').map do |char|\n\
    \    char.downcase == 'a' ? 'e' : char\n  end.map do |char|\n    vowels.find {|vowel|\
    \ char == vowel}\n  end.compact.first || ''\nend", "  word = word.downcase\n \
    \ if word.empty?\n    \"\"\n  else\n    word_length = word.length\n    \n    word.each\
    \ do |letter|\n      if letter.match(/[aeiou]/)\n        index = word.index(letter,\
    \ word_length-1)\n        vowel = word[index+1]\n        if vowel.empty?\n   \
    \       \"\"\n        else\n          vowel\n        end\n      end\n    end\n\
    \  end\nend", "  vowels = \"aAEiou\"\n  consonants = \"bcdfghjklmnpqrstvwxyz\"\
    \n  \n  first_consonant_index = word.rindex(consonants, 0, -1)\n  last_consonant_index\
    \ = word.rindex(consonants, -1, -1)", "  vowels = %w{ a e i o u y o u r e i o\
    \ u y a e i o u y a e i o u y }\n  prev_vowel = nil\n  cur_vowel = nil\n  cur_distance\
    \ = nil\n  word.each_char.with_index do |char, index|\n    if vowels.include?\
    \ char\n      cur_distance = index - 2 \n      cur_vowel = char\n    end\n  end\n\
    \  case cur_vowel\n    when \"a\"\n      cur_distance -= 1\n    when \"e\"\n \
    \     cur_distance -= 2\n    when \"i\"\n      cur_distance -= 3\n    when \"\
    o\"\n      cur_distance -= 2\n    when \"u\"\n      cur_distance -= 1\n    when\
    \ \"y\"\n      cur_distance -= 1\n    when \"r\"\n      cur_distance -= 1\n  \
    \  when \"e\"\n      cur_distance -= 2\n    when \"i\"\n      cur_distance -=\
    \ 3\n    when \"o\"\n      cur_distance -= 2\n    when \"u\"\n      cur_distance\
    \ -= 1\n  end\n  return \"\" if cur_distance < 0\n  prev_vowel = cur_vowel\n \
    \ cur_vowel = nil\n  cur_distance = nil\n  word.each_char.with_index do |char,\
    \ index|\n    if vowels.include? char\n      cur_distance = index - 2 \n     \
    \ cur_vowel = char\n    end\n  end\n  return \"\" if cur_distance < 0\n  prev_vowel\
    \ = cur_vowel\n  cur_vowel = nil\n  cur_distance = nil\n  word.each_char.with_index\
    \ do |char, index|\n    if vowels.include? char\n      cur_distance = index -\
    \ 2 \n      cur_vowel = char\n    end\n  end\n  return \"\" if cur_distance <\
    \ 0\n  prev_vowel = cur_vowel\n  cur_vowel = nil\n  cur_distance = nil\n  word.each_char.with_index\
    \ do |char, index|\n    if vowels.include? char\n      cur_distance = index -\
    \ 2 \n      cur_vowel = char\n    end\n  end\n  return \"\" if cur_distance <\
    \ 0\n  prev_vowel = cur_vowel\n  cur_vowel = nil\n  cur_distance = nil\n  word.each_char.with_index\
    \ do |char, index|\n    if vowels.include? char\n      cur_distance = index -\
    \ 2 \n      cur_vowel = char\n    end\n  end\n  return \"\" if cur_distance <\
    \ 0\n  prev_vowel = cur_vowel\n  cur_vowel = nil\n  cur_distance = nil\n  word.each_char.with_index\
    \ do |char, index|\n    if vowels.include", "  vowels = [\"a\",\"e\",\"i\",\"\
    o\",\"u\"]\n  result = []\n  for c in word\n    if vowels.include?(c)\n      result\
    \ << c\n    end\n  end\n  vowels.shift until vowels.include?(result.last)\n  result.last\
    \ ? result.last : \"\"\nend\n</cell>\n<cell>", "  return word.chars.map(&:upcase).sort_by\
    \ { |char| char.index }.reverse.find { |char| char.index >= 0 && char.index <=\
    \ 1 }\nend", "  vowels = %w[a e i o u]\n  word=word.split(//).reverse.join\n \
    \ word=word.split(//).reverse.map(&:upcase)\n  return vowels.detect { |v| word.include?(v)\
    \ }\nend", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  vowels_count = 0\n\
    \  vowels_count_start = 0\n  vowels_count_end = 0\n  for letter in word\n    if\
    \ vowels.include?(letter)\n      vowels_count += 1\n      if vowels_count > vowels_count_end\n\
    \        vowels_count_end = vowels_count\n      end\n      vowels_count_start\
    \ = vowels_count\n    end\n  end\n  if vowels_count == 0\n    return \"\"\n  else\n\
    \    vowels_count -= 1\n    vowel = word[vowels_count_end..-1]\n    vowels_count\
    \ -= 1\n    if vowels.include?(vowel)\n      return vowel\n    end\n  end\nend\n\
    </code>\n<|/ a |>\n<| a tags=ruby,string,regex |>\n<code>", "  return word.reverse.scan(/[aeiou]/).max\
    \ { |el| el.length }\nend", "    # Write your code here\n    vowels = %w(a e i\
    \ o u)\n    word = word.upcase\n    word = word.gsub(/[AEIOUaeiou]/,'').downcase\n\
    \    vowels.each do |vowel|\n        return \"\" if word =~ /#{vowel}/i\n    end\n\
    \    return \"\"\nend\n</code>\n<|/ a |>\n<| c |>\nThis assumes vowels are at\
    \ the end of the word, not at the start or middle.\n<|/ c |>\n<| c |>\nYes, you're\
    \ right. It does not check that the word contains English letters only in the\
    \ beginning. For the question at hand `ab` is a valid word.\n<|/ c |>\n<| c |>\n\
    The question is about vowels, not letters, and not numbers. Please do not use\
    \ numbers in answers to SO questions. Answers here should be clear and to the\
    \ point. Numbers don't count.\n<|/ c |>\n<| a dscore=1 tags=ruby,regex |>\nOne\
    \ way of doing this would be to split the string into separate letters and find\
    \ the closest match. \n<code>", "\tword.downcase!\n\tvowels = %w(a e i o u) #%w(a\
    \ e i o u)\n\tword.split(\"\").each_with_index do |char,index|\n\t\tif index ==\
    \ 0\n\t\t\tconsonants_count = word.split(\"\").size - index\n\t\telse\n\t\t\t\
    consonants_count = index\n\t\tend\n\t\t\n\t\tvowels.each do |vowel|\n\t\t\tif\
    \ char == vowel\n\t\t\t\tif index == consonants_count\n\t\t\t\t\treturn vowel\n\
    \t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn \"\"\nend", "  vowels = %w{a\
    \ e i o u}\n  \n  # Return empty string if word doesn't contain english letter\n\
    \  return if !word.include?(%w{a e i o u}) \n  \n  # Return empty string if word\
    \ contains only one vowel from the right side\n  return if vowels.include? word[-1]\
    \ if word.size <= 1", "    vowel = ['a','e','i','o','u']\n    vowel_count = 0\n\
    \    vowel_index = 0\n    vowel_index1 = 0\n    vowel_index2 = len(word)-1\n \
    \   while vowel_index <= vowel_index2:\n        vowel_count += 1\n        if word[vowel_index]\
    \ == vowel[vowel_index1]:\n            vowel_index1 = vowel_index1\n        if\
    \ word[vowel_index] == vowel[vowel_index2]:\n            vowel_index2 = vowel_index2\n\
    \        vowel_index += 1\n    if vowel_count == 0:\n        return ''\n    if\
    \ vowel_count == 1:\n        return vowel[0]\n    if vowel_count == 2:\n     \
    \   return vowel[0]+vowel[1]\n    if vowel_index <= vowel_index2:\n        return\
    \ vowel[vowel_index] + vowel[vowel_index2]\n    return ''\n</code>\n<|/ a |>\n\
    <| a tags=python |>\nAnother method using list comprehension and string manipulation:\n\
    <code>", "  word.each_char.with_index{|ch, i|\n    next if i == 0\n    next if\
    \ i == word.size - 1\n    if word[i].upcase =~ /[AEIOUaeiou]/ && word[i + 1].upcase\
    \ =~ /[AEIOUaeiou]/\n      return word[i]\n    end\n  }\n  return \"\"\nend",
  "  vowel = nil\n  vowel_consonants = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  consonant_consonants\
    \ = [\"b\",\"c\",\"d\",\"f\",\"g\",\"h\",\"j\",\"k\",\"l\",\"m\",\"n\",\"p\",\"\
    q\",\"r\",\"s\",\"t\",\"v\",\"w\",\"x\",\"z\"]\n  \n  vowel_consonants.each do\
    \ |consonant|\n    if consonant.downcase == word.downcase[-1]\n      vowel = consonant\n\
    \      break\n    end\n  end\n  \n  consonant_consonants.each do |consonant|\n\
    \    if consonant.downcase == word[-2,1]\n      vowel = consonant\n      break\n\
    \    end\n  end\n  \n  return vowel\nend\n</code>\n<|/ a |>\n<| c |>\nThank you\
    \ for your response. The issue with this code is that it takes more time than\
    \ the code in the other answers.\n<|/ c |>\n<| a tags=algorithm,ruby,string |>\n\
    I wrote this solution. I think this one is more readable, but it's also a little\
    \ bit slower.\n<code>", "  vowels = %W{a e i o u}\n  consonants = %W{b c d f g\
    \ h j k l m n p q r s t v w x z}\n  last_consonants = consonants[consonants.index(word.last)..-1]",
  "    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    word = word.to_s\n    vowel_start\
    \ = word.rindex(\"a\")\n    vowel_end = word.rindex(\"u\")\n    vowel_found =\
    \ word[vowel_start:vowel_end]\n    vowel_found = vowel_found.downcase\n    return\
    \ vowel_found if vowels.include?(vowel_found) \nend", "  return word.chars.grep(/[aeiou]/).sort_by\
    \ {|char| -char.length}.last.downcase\nend", "  word = word.upcase\n  vowels =\
    \ %w{a e i o u}\n  vowel_counter = 0\n  consonants = [\"b\", \"c\", \"d\", \"\
    f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  consonant_counter = 0\n  \n\
    \  while consonant_counter <= word.count(\"z\")\n    letter = word[consonant_counter]\n\
    \    consonant_counter += 1\n    if letter == \"z\"\n      return \"\"\n    end\n\
    \    consonant_counter = 0\n  end\n  \n  consonant_counter = 0\n  while vowel_counter\
    \ < word.count(\"z\") - 2\n    letter = word[consonant_counter]\n    consonant_counter\
    \ += 1\n    if letter == \"z\"\n      return \"\"\n    end\n    consonant_counter\
    \ = 0\n  end\n  \n  consonant_counter = 0\n  while consonant_counter < word.count(\"\
    z\") - 3\n    letter = word[consonant_counter]\n    consonant_counter += 1\n \
    \   if vowels.include?(letter)\n      return letter\n    end\n    consonant_counter\
    \ = 0\n  end\n  \n  return \"\"\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\nOne way to solve this would be to define a range of consecutive characters,\
    \ and then get the first vowel in that range:\n<code>", "  vowel_arr = [\"\",\
    \ \"A\", \"E\", \"I\", \"O\", \"U\"]\n  word.length.times do |i|\n    vowel =\
    \ word[i..-1]\n    break if vowel_arr.include? vowel\n  end\n  vowel_arr.include?\
    \ vowel ? vowel : \"\"\nend", "  vowels = %w{a e i o u}\n  result = \"\"\n  consonants\
    \ = %w{b c d f g h j k l m n p q r s t v w x y z}\n  idxs = []\n  idx = 0\n  while\
    \ idx < word.length\n    if word.slice!(idx..idx+1).include?(consonants.first)\n\
    \      idx += 1\n    elsif word.slice!(idx..idx+1).include?(consonants.last)\n\
    \      idx += 1\n    end\n    idxs << idx\n  end\n  idxs.each do |idx|\n    idx\
    \ = idx-1\n    consonants.each do |cons|\n      if word.slice!(idx..idx+1).include?(cons)\n\
    \        if idx == 0 && cons == 'a'\n          result << vowels.first\n      \
    \  elsif idx == word.length-1 && cons == 'z'\n          result << vowels.last\n\
    \        else\n          result << vowels.sample\n        end\n        break\n\
    \      end\n    end\n  end\n  return result\nend\n</code>\n<|/ a dscore=3 |>\n\
    <| a dscore=2 |>\n<code>", "    vowels = (\"a\",\"e\",\"i\",\"o\",\"u\")\n   \
    \ vowels_count = word.count(\"a\")\n    return \"\" if vowels_count == 0 or vowels_count\
    \ == word.count(\"z\") else vowels[vowels_count - word.count(\"z\") - 1] if vowels_count\
    \ > word.count(\"z\") else vowels[vowels_count - word.count(\"a\") - 1]\nend",
  "    vowel = \"AEIOU\"\n    vowel_position = []\n    vowel_position = []\n    vowel_position\
    \ = []\n    vowel_position = []\n    vowel_position = []\n    vowel_position =\
    \ []\n    vowel_position = []\n    vowel_position = []\n    vowel_position = []\n\
    \    vowel_position = []\n    vowel_position = []\n    vowel_position = []\n \
    \   vowel_position = []\n    vowel_position = []\n    vowel_position = []\n  \
    \  vowel_position = []\n    vowel_position = []\n    vowel_position = []\n   \
    \ vowel_position = []\n    vowel_position = []\n    vowel_position = []\n    vowel_position\
    \ = []\n    vowel_position = []\n    vowel_position = []\n    vowel_position =\
    \ []\n    vowel_position = []\n    vowel_position = []\n    vowel_position = []\n\
    \    vowel_position = []\n    vowel_position = []\n    vowel_position = []\n \
    \   vowel_position = []\n    vowel_position = []\n    vowel_position = []\n  \
    \  vowel_position = []\n    vowel_position = []\n    vowel_position = []\n   \
    \ vowel_position = []\n    vowel_position = []\n    vowel_position = []\n    vowel_position\
    \ = []\n    vowel_position = []\n    vowel_position = []\n    vowel_position =\
    \ []\n    vowel_position = []\n    vowel_position = []\n    vowel_position = []\n\
    \    vowel_position = []\n    vowel_position = []\n    vowel_position = []\n \
    \   vowel_position = []\n    vowel_position = []\n    vowel_position = []\n  \
    \  vowel_position = []\n    vowel_position = []\n    vowel_position = []\n   \
    \ vowel_position = []\n    vowel_position = []\n    vowel_position = []\n    vowel_position\
    \ = []\n    vowel_position = []\n    vowel_position = []\n    vowel_position =\
    \ []\n    vowel_position = []\n    vowel_position = []\n    vowel_position = []\n\
    \    vowel_position = []\n    vowel_position = []\n    vowel_position = []\n \
    \   vowel_position = []\n    vowel_position = []\n    vowel_position = []\n  \
    \  vowel_position = []\n    vowel_position = []\n    vowel_position = []\n   \
    \ vowel_position = []\n    vowel_position = []\n    vowel_position = []\n    vowel_position\
    \ = []\n    vowel_position = []\n    vowel_position = []\n    vowel_position =\
    \ []\n    vowel_position = []\n    vowel_position = []\n", "  vowels = [\"a\"\
    , \"e\", \"i\", \"o\", \"u\", \"y\"]\n  vowels_count = word.scan(/[aeiouy]*/)\n\
    \  vowels_count.each do |vowel|\n    position = word.index(vowel)\n    vowel_right_side\
    \ = word[position + 1, word.length - 1]\n    if vowel_right_side == \"y\" || vowel_right_side\
    \ == \"e\" || vowel_right_side == \"i\" || vowel_right_side == \"o\" || vowel_right_side\
    \ == \"u\"\n      return vowel\n    end\n  end\n  return \"\"\nend", "    word\
    \ = word.downcase\n    vowels_count = word.scan(/[aeiou]/).length\n    word.length.times\
    \ do |i|\n        if word.slice(-i) == vowels.last\n            return word.slice(-i)\n\
    \        end\n    end\nend", "  vowel_positions = Hash.new(0)\n  consonant_positions\
    \ = Hash.new(0)\n  consonant_positions[consonants.first] = word.size\n  vowel_positions[vowels.first]\
    \ = word.size\n  word.each_char{|c|\n    if vowels.include?(c)\n      vowel_positions[c]\
    \ = word.size + 1\n      word.delete(c)\n      break if word.empty?\n    end\n\
    \    if consonants.include?(c)\n      consonant_positions[c] = word.size + 1\n\
    \      word.delete(c)\n      break if word.empty?\n    end\n  }\n  vowel_positions.delete_if{|v,k|k\
    \ == consonant_positions[k]}\n  vowel_positions.delete_if{|v,k|v == consonant_positions[k]}\n\
    \  puts \"Vowels: #{vowel_positions.to_a}\"\n  puts \"Consonants: #{consonant_positions.to_a}\"\
    \n  \n  # find vowel which is closet to each consonant\n  consonant_positions.each_key{|c|\n\
    \    min_distance = 100000\n    vowel_with_same_distance = \"\"\n    word.each_char{|v|\n\
    \      if v == consonants[c]\n        min_distance = distance(v,consonants[c])\n\
    \        vowel_with_same_distance = v\n        break\n      end\n    }\n    puts\
    \ \"Minimum distance of #{min_distance} between #{vowel_with_same_distance} and\
    \ #{c}\"\n    puts \"Vowels: #{vowel_positions.to_a}\"\n    puts \"Consonants:\
    \ #{consonant_positions.to_a}\"\n    if vowel_with_same_distance != \"\" && min_distance\
    \ < vowel_positions[c]\n      return vowel_with_same_distance\n    end\n  }\n\
    \  return \"\"\nend\n</cell>\n<code language=conda-env-image-processing-py>\n\
    get_closest_vowel(\"yogurt\")\n</cell>\n<code language=conda-env-image-processing-py>\n\
    get_closest_vowel(\"FULL\")\n</cell>\n<code language=conda-env-image-processing-py>\n\
    get_closest_vowel(\"quick\")\n</cell>\n<code language=conda-env-image-processing-py>\n\
    get_closest_vowel(\"ab\")\n</cell>\n<code language=conda-env-image-processing-py>",
  "  \n  vowel_consonant_pairs = Hash.new{|h,k| h[k]=[]}\n  \n  vowels.each do |vowel|\n\
    \    vowel_consonant_pairs[vowel].push consonants.last(vowel).upcase\n  end\n\
    \  \n  if vowel_consonant_pairs[word.downcase].empty? then return \"\" end\n \
    \ \n  vowel_consonant_pairs[word.downcase].each do |pair|\n    distance = vowel_distance(pair,\
    \ word)\n    return if distance < 0\n  end\n  \n  \"\"\nend", "    vowels = %w(a\
    \ e i o u) # create a hash\n    vowels.each do |letter|\n        # find closest\
    \ letter\n        position = word.index(letter, word.size-2) + 1\n        # if\
    \ a vowel exists between two consonants \n        # from the right side of the\
    \ word, return it\n        if word.chars[position...position+2].include?(letter)\n\
    \            return letter\n        end\n    end\n    return \"\"\nend", "  vowels\
    \ = [\"\", \"a\", \"e\", \"i\", \"o\", \"u\"]\n  vowels.each do |vowel|\n    vowels.delete(vowel)\n\
    \    if word.end_with?(vowel)\n      return vowel\n    elsif word.start_with?(vowel)\n\
    \      return vowel\n    end\n  end\n  return \"\"\nend", "  vowels = %w{a e i\
    \ o u}\n  vowels.each do |vowel|\n    if word.index(vowel) \n      return vowel\n\
    \    end\n  end\nend", '  return "" if word.empty? || !(/[aeiouy]+/).match(word)',
  "  # write your code here\n  vowels = ['a','e','i','o','u']\n  vowel_positions =\
    \ []\n  vowel_positions = []\n  for i,v in enumerate (vowels):\n    for j,w in\
    \ enumerate(word):\n      if w == v:\n        vowel_positions.append([i,j])\n\
    \  vowel_positions = vowel_positions[::-1]\n  vowel_positions.sort()\n  for i\
    \ in vowel_positions:\n    if vowel_positions[i-1] > 0 and vowel_positions[i]\
    \ > 0 and word[vowel_positions[i-1]-1] == word[vowel_positions[i]-1]:\n      return\
    \ word[vowel_positions[i-1]-1]\n  return \"\"\n</cell>\n<cell>", "    vowels =\
    \ [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    \n    return vowels[(word.index(\"\
    e\")+1)%len(vowels)] if \"e\" in word else \"\"\n    \n    ", "  vowel_found =\
    \ false\n  vowels = %w(a e i o u)\n  word = word.downcase\n  consonants = %w(a\
    \ e i o u)\n  i = 0\n  while i < word.length\n    ch = word[i]\n    if vowels.include?(ch)\n\
    \      vowel_found = true\n      break\n    end\n    i += 1\n  end\n  if vowel_found\n\
    \    word.length\n  else\n    i = 1\n    found = 0\n    while i < word.length\n\
    \      ch = word[i]\n      if consonants.include?(ch)\n        found = found +\
    \ 1\n      end\n      i += 1\n    end\n    word.length - found\n  end\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby |>\n<| c |>\nThank you! That works beautifully. I've\
    \ been stuck on this for so long.\n<|/ c |>\n<| a |>\n<code>", "    \n    vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    \n    vowel_counter = 0\n    \n \
    \   for i in range(len(word))\n        if word[i] == vowels[vowel_counter]\n \
    \           vowel_counter += 1\n            if vowel_counter == len(vowels)\n\
    \                return word[i]\n        end\n    end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nA very simple algorithm would be as follows\n<code>\n String word\
    \ = \"yogurt\";", "  word.split(\"\").map{|x| x.downcase}.uniq.sort\n  .map{|x|\
    \ x == :a ? :a : x == :e ? :e : x == :i ? :i : x == :o ? :o : x == :u ? :u : x\
    \ == :y ? :y : x == :r ? :r : x == :l ? :l : x == :t ? :t : x == :s ? :s : x ==\
    \ :c ? :c : x == :f ? :f : x == :v ? :v : x == :b ? :b : x == :d ? :d : x == :r\
    \ ? :r : x == :u ? :u : x == :l ? :l : x == :r ? :r : x == :m ? :m : x == :p ?\
    \ :p : x == :r ? :r : x == :u ? :u : x == :l ? :l : x == :r ? :r : x == :b ? :b\
    \ : x == :l ? :l : x == :d ? :d : x == :r ? :r : x == :u ? :u : x == :r ? :r :\
    \ x == :d ? :d : x == :r ? :r : x == :d ? :d : x == :r ? :r : x == :u ? :u : x\
    \ == :l ? :l : x == :l ? :l : x == :r ? :r : x == :u ? :u : x == :r ? :r : x ==\
    \ :u ? :u : x == :r ? :r : x == :r ? :r : x == :u ? :u : x == :l ? :l : x == :u\
    \ ? :u : x == :l ? :l : x == :r ? :r : x == :l ? :l : x == :u ? :u : x == :u ?\
    \ :u : x == :r ? :r : x == :u ? :u : x == :r ? :r : x == :u ? :u : x == :r ? :r\
    \ : x == :u ? :u : x == :r ? :r : x == :u ? :u : x == :r ? :r : x == :u ? :u :\
    \ x == :r ? :r : x == :u ? :u : x == :r ? :r : x == :u ? :u : x == :r ? :r : x\
    \ == :u ? :u : x == :r ? :r : x == :u ? :u", "\tvowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n\tvowels.each do |v|\n\t\tif (word.include? v) && (word.length\
    \ > (v.length + 1))\n\t\t\treturn v\n\t\tend\n\tend\n\treturn \"\"\nend", "  \
    \  # Write your code here\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I',\
    \ 'O', 'U']\n    vowel_count = 0\n    for x in word[::-1]:\n        if x in vowels:\n\
    \            vowel_count += 1\n        if vowel_count == 1:\n            return\
    \ x\n        elif vowel_count > 1:\n            return ''\n    return ''", " \
    \ vowels = %w[a e i o u]\n  vowels = vowels.uniq.sort\n  word.chars.each do |c|\n\
    \    if vowels.include? c\n      return c\n    end\n  end\n  \"\"\nend", "  return\
    \ \"\" if word.empty? || word.chars.all? { |char| !char.upcase }\n  vowels.find\
    \ { |vowel| word.chars.all? { |char| char.upcase == vowel.upcase } }\nend", " \
    \ vowel = nil\n  vowel_consonants = []\n  vowel_consonants << [\"a\", \"e\", \"\
    i\", \"o\", \"u\"]\n  vowel_consonants << [\"b\", \"c\", \"d\", \"f\", \"g\",\
    \ \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"]\n  vowel_consonants.each do |consonant|\n\
    \    if (word.index(\"a\") < word.index(\"e\") && word.index(\"a\") < word.index(\"\
    i\") && word.index(\"a\") < word.index(\"o\") && word.index(\"a\") < word.index(\"\
    u\")) || (word.index(\"a\") < word.index(\"b\") && word.index(\"a\") < word.index(\"\
    c\") && word.index(\"a\") < word.index(\"d\") && word.index(\"a\") < word.index(\"\
    f\") && word.index(\"a\") < word.index(\"g\") && word.index(\"a\") < word.index(\"\
    h\") && word.index(\"a\") < word.index(\"j\") && word.index(\"a\") < word.index(\"\
    k\") && word.index(\"a\") < word.index(\"l\") && word.index(\"a\") < word.index(\"\
    m\") && word.index(\"a\") < word.index(\"n\") && word.index(\"a\") < word.index(\"\
    p\") && word.index(\"a\") < word.index(\"q\") && word.index(\"a\") < word.index(\"\
    r\") && word.index(\"a\") < word.index(\"s\") && word.index(\"a\") < word.index(\"\
    t\") && word.index(\"a\") < word.index(\"v\") && word.index(\"a\") < word.index(\"\
    w\") && word.index(\"a\") < word.index(\"x\") && word.index(\"a\") < word.index(\"\
    y\") && word.index(\"a\") < word.index(\"z\")) \n      vowel = consonant\n   \
    \   break\n    end\n  end\n  return vowel\nend", "  vowels = [\"a\", \"e\", \"\
    i\", \"o\", \"u\", \"y\"]\n  vowels_count = word.scan(/[aeiou]/).count", "  word\
    \ = word.downcase\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  vowels_count\
    \ = vowels.inject(0) {|sum,letter| sum+word.count(letter)}\n  vowels.each {|letter|\
    \ vowels_count -= word.count(letter)}\n  return vowels[vowels_count.ceil].upcase\
    \ if vowels_count >= vowels.count\n  return \"\"\nend", "  vowels = (\"a\", \"\
    e\", \"i\", \"o\", \"u\")\n  consonants = (\"b\", \"c\", \"d\", \"f\", \"g\",\
    \ \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\")\n  vowel_count = consonant_count = 0\n  word_list\
    \ = word.split(//)\n  \n  word_list.each_index do |index|\n    if word_list[index].upcase\
    \ == word_list[index].downcase\n      consonant_count += 1\n      break\n    elsif\
    \ consonant_count > 0\n      if vowels[consonants.index(word_list[index][consonant_count\
    \ - 1])]\n        vowel_count += 1\n        break\n      end\n    end\n  end\n\
    \  \n  return vowels[(vowel_count + consonant_count) % vowels.length]\nend", "\t\
    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tvowels.sort!\n\t\n\treturn vowels[word.length].downcase\
    \ if vowels.include? word.downcase \n\t\n\treturn nil\nend", "  vowels = [\"A\"\
    ,\"a\",\"E\",\"e\",\"I\",\"i\",\"O\",\"o\",\"U\",\"u\"]\n  return vowels.find\
    \ { |letter| word.chars.last(2).include?(letter) }\nend", "  vowels = [\"A\",\"\
    a\",\"E\",\"e\",\"I\",\"i\",\"O\",\"o\",\"U\",\"u\",\"Y\",\"y\"]\n  consonants\
    \ = [\"B\",\"c\",\"D\",\"d\",\"F\",\"f\",\"G\",\"g\",\"H\",\"h\",\"J\",\"j\",\"\
    K\",\"k\",\"L\",\"l\",\"M\",\"m\",\"N\",\"n\",\"P\",\"p\",\"Q\",\"q\",\"R\",\"\
    r\",\"S\",\"s\",\"T\",\"t\",\"V\",\"v\",\"W\",\"w\",\"X\",\"x\",\"Y\",\"y\",\"\
    Z\",\"z\"]\n  vowels_count = word.scan(/[aeiouy]/).count\n  consonants_count =\
    \ word.scan(/[b-df-hj-np-tv-z]/).count\n  consonants_count += vowels_count * vowels_count\n\
    \  return vowels.select { |vowel| vowel.downcase == word.downcase.sub(vowel.downcase,\
    \ \"\") }.first\nend", "  letters = word.to_s.split(\"\").map(&:downcase)\n  letters.sort.each_with_index\
    \ do |v, i|\n    return v if i > 0 && v != letters[i - 1]\n  end\n  \"\"\nend",
  "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  word.length\n  word.each_char.with_index\
    \ do |char, index|\n    vowels.include?(char) ? vowels.index(char) : nil\n  end\n\
    end", "    # Write your code here\n    vowels = ['a','e','i','o','u']\n    l =\
    \ len(word)\n    i = 0\n    j = len(vowels)-1\n    \n    while i < l-1 and j >=\
    \ 0:\n        if word[i] == vowels[j]:\n            i += 1\n            j -= 1\n\
    \        elif word[i] == vowels[j+1]:\n            i += 1\n            j += 1\n\
    \        else:\n            i += 1\n            j -= 1\n    return \"\" if j ==\
    \ -1 else vowels[j+1]", "  vowels = %w[a e i o u]\n  consonants = %w[b c d f g\
    \ h j k l m n p q r s t v w x]\n  word = word.downcase\n  vowels.each do |vowel|\n\
    \    word.gsub!(vowel, \"\")\n    word.gsub!(vowel.reverse, \"\")\n    word.gsub!(vowel.split(\"\
    \").reverse.join(\"\"), \"\")\n  end\n  consonants.each do |consonant|\n    word.gsub!(consonant,\
    \ \"\")\n    word.gsub!(consonant.reverse, \"\")\n    word.gsub!(consonant.split(\"\
    \").reverse.join(\"\"), \"\")\n  end\n  word.gsub!(vowels.size, \"\")\n  word.gsub!(consonants.size,\
    \ \"\")\n  word.gsub!(\"u\", \"\")\n  word.gsub!(\"o\", \"\")\n  word.gsub!(\"\
    e\", \"\")\n  word.gsub!(\"a\", \"\")\n  word.gsub!(\"i\", \"\")\n  word.gsub!(\"\
    t\", \"\")\n  word.gsub!(\"s\", \"\")\n  word.gsub!(\"b\", \"\")\n  word.gsub!(\"\
    m\", \"\")\n  word.gsub!(\"p\", \"\")\n  word.gsub!(\"f\", \"\")\n  word.gsub!(\"\
    g\", \"\")\n  word.gsub!(\"h\", \"\")\n  word.gsub!(\"j\", \"\")\n  word.gsub!(\"\
    k\", \"\")\n  word.gsub!(\"l\", \"\")\n  word.gsub!(\"x\", \"\")\n  word.gsub!(\"\
    q\", \"\")\n  word.gsub!(\"r\", \"\")\n  word.gsub!(\"w\", \"\")\n  word.gsub!(\"\
    v\", \"\")\n  word.gsub!(\"z\", \"\")\n  word.gsub!(\"c\", \"\")\n  word.gsub!(\"\
    z\", \"\")\n  word.gsub!(\"z\", \"\")\n  word.gsub!(\"z\", \"\")\n  word.gsub!(\"\
    z\", \"\")\n  word.gsub!(\"z\", \"\")\n  word.gsub!(\"z\", \"\")\n  word.gsub!(\"\
    z\", \"\")\n  word.gsub!(\"z\", \"\")\n  word.gsub!(\"z\", \"\")\n  word.gsub!(\"\
    z\", \"\")\n  word.gsub!(\"z\", \"\")\n  word.gsub!(\"z\", \"\")\n  word.gsub!(\"\
    z\", \"\")\n  word.gsub!(\"z\", \"\")\n  word.gsub!(\"z\", \"\")\n  word.g", " \
    \ vowels = %w( a e i o u y A E I O U Y )\n  word.downcase!\n  consonants = %w(\
    \ b c d f g h j k l m n p q r s t v w x z )\n  word.scan(/[#{consonants.join}]+/).each\
    \ do |consonant|\n    vowels.each { |vowel| return vowel if consonant.include?(vowel)\
    \ }\n  end\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a |>\n<code>", "  word\
    \ = word.upcase\n  consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n  vowels = \"aeiouAEIOU\"\n  vowel_count = word.split(//).count {|char| vowels.include?(char)}\n\
    \  return consonants[word.index(consonants.last(vowel_count).succ,1)] if vowel_count\
    \ > 0\nend", "  return \"\"\nend\n</cell>\n<code language=julia-1.0>", "    vowels\
    \ = [\"a\",\"A\",\"e\",\"E\",\"i\",\"I\",\"o\",\"O\",\"u\",\"U\"]\n    word =\
    \ word.upcase\n    word.each_char.with_index do |char, i|\n        if vowels.include?\
    \ char\n            chars.reverse_each do |char|\n                if i == 0\n\
    \                    return char if char != \"o\"\n                elsif i ==\
    \ (word.length - 1)\n                    return char if char != \"u\"\n      \
    \          end\n            end\n        end\n    end\n    return \"\"\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nYou can try this:\n<code>", "  vowels\
    \ = (\"a\",\"e\",\"i\",\"o\",\"u\",\"y\")\n  word = word.split(//).join('')\n\
    \  word.split(//).reverse!\n  (0..word.size).each do |i|\n    next unless word.include?\
    \ vowels[i]\n    return word.slice! i\n  end\n  return word\nend", "\tvowels =\
    \ %w{a e i o u}\n\tvowels.each { |v| return v if word.include?(v) }\n\treturn\
    \ \"\"\nend", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  word = word.to_s\n\
    \  \n  vowels.each do |v|\n    if word.end_with?(v)\n      return v\n    end\n\
    \  end\n  \n  vowels.reverse.each do |v|\n    if word.start_with?(v)\n      return\
    \ v\n    end\n  end\nend", "  vowels = %w(a e i o u)\n  consonants = %w(a e i\
    \ o u)", "  word.downcase!\n  \n  vowel_a = /[aeiou]/i\n  vowel_b = /[AEIOU]/i\n\
    \  \n  vowel_a_pos = word.index(vowel_a)\n  vowel_b_pos = word.index(vowel_b)\n\
    \  \n  if vowel_a_pos == 0 || vowel_b_pos == 0\n    return \"\"\n  end\n  \n \
    \ if vowel_b_pos == vowel_a_pos\n    vowel_pos = vowel_b_pos\n  else\n    vowel_pos\
    \ = vowel_a_pos\n  end\n  \n  return word[vowel_pos].upcase\nend", "  vowels =\
    \ %w(a e i o u)\n  vowels.each do |vowel|\n    if word.index(vowel.to_s) <= word.rindex(vowel.to_s)\n\
    \      closest_vowel = vowel\n      break\n    end\n  end\n  \n  return closest_vowel\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a |>\nHere is an optimized version\
    \ of Siddharth's answer:\n<code>", "  return \"U\"\nend\n</code>\n<|/ q tags=ruby,arrays,string,algorithm\
    \ |>\n<| c |>\nWelcome to SO, Ben. We're happy to help you. In the future, please\
    \ ask a specific question. Your \"question\" isn't really a question (it isn't\
    \ a statement or a question), so it's not appropriate for this site (you'll get\
    \ better help here).\n<|/ c |>\n<| c |>\nIt might help to know what language this\
    \ is. Ruby is not Java.\n<|/ c |>\n<| c |>\nI am sorry if my question is not clear\
    \ enough to understand my problem. I wanted to know why my code is returning an\
    \ empty array when my code should return \"U\" instead of an empty array . I am\
    \ new to ruby language, I tried to search for solution online but still I am not\
    \ able to find a solution that works for me.\n<|/ c |>\n<| c |>\nI tried to edit\
    \ my question but I am still not able to see my edits. I wanted to add my code\
    \ but I was not able to do so because of the lack of reputation. Let me know if\
    \ I am still not able to understand my question.\n<|/ c |>\n<| c |>\nRuby isn't\
    \ a scripting language (although it is a *very* thoroughly featured one). Try\
    \ and learn how to use a debugger to step through your code to understand what\
    \ it's doing.\n<|/ c |>\n<| a dscore=2 |>\nI used the method below to solve it\
    \ using Ruby 1.9.3 and Rails 3.2.17.  Not sure if this is the best way to do it.\n\
    <code>", "\tvowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n\tvowels.each do |letter|\n\
    \t\tword.downcase!\n\t\tpos = word.rindex(letter)\n\t\tif pos && word[pos+1] ==\
    \ letter\n\t\t\treturn letter\n\t\tend\n\tend\n\treturn \"\"\nend", "  vowels\
    \ = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\n  return vowels.find\
    \ { |vowel| word.index(vowel) }\nend\n</cell>\n<text>\nThe function get_closest_vowel\
    \ can be used in a next exercises. Note that we do not have any restrictions on\
    \ the content of the string. You may also assume that the given string contains\
    \ English letter only.", "  vowels = %W(a e i o u)\n  consonants = %W(a b c d\
    \ e f g h i j k l m n o p q r s t u v w x y z)", "  vowels = %w{ a e i o u }\n\
    \  consonants = %w{ b c d f g h j k l m n p q r s t v w x z }\n  vowel_positions\
    \ = []\n  consonant_positions = []\n  \n  if word.empty? || word =~ /[^aeiou]/\
    \ \n    return \"\"\n  end", "\treturn (word.length / 2).downcase.chars.find(\n\
    \t\tword.chars.reverse.find {|c| c.downcase =~ /[aeiou]/i}\n\t) || \"\"\nend",
  "  letters = word.split(\"\")\n  vowels = %w[a e i o u]\n  consonants = %w[b c d\
    \ f g h j k l m n p q r s t v w x y z]\n  letters.each_with_index do |letter,\
    \ i|\n    if vowels.include? letter\n      return letter\n    elsif consonants.include?\
    \ letter\n      return letter\n    end\n  end\n  return \"\"\nend\n</cell>\n<cell>",
  "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"]\n  vowel_found = false\n\
    \  consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"\
    ]\n  consonant_found = false\n  i = 0\n  while i < word.length\n    if vowels.include?(word[i])\n\
    \      vowel_found = true\n      break\n    end\n    i += 1\n  end\n  i = 0\n\
    \  while i < word.length\n    if consonants.include?(word[i])\n      consonant_found\
    \ = true\n      break\n    end\n    i += 1\n  end\n  if vowel_found && consonant_found\n\
    \    i = 0\n    while i < word.length\n      if consonants.include?(word[i])\n\
    \        vowel_found = false\n        break\n      end\n      i += 1\n    end\n\
    \    if vowel_found\n      word.slice!(i..-1)\n      i = 0\n      while i < word.length\n\
    \        if vowels.include?(word[i])\n          vowel_found = false\n        \
    \  break\n        end\n        i += 1\n      end\n    end\n  end\n  return vowel_found\
    \ ? word.join('') : ''\nend", "  # your code here\nend", "    vowels = [\"a\"\
    ,\"e\",\"i\",\"o\",\"u\"]\n    vowels_count = word.count(\"a\")\n    vowels_count\
    \ += word.count(\"e\")\n    vowels_count += word.count(\"i\")\n    vowels_count\
    \ += word.count(\"o\")\n    vowels_count += word.count(\"u\")", "  vowels = (\"\
    a\",\"e\",\"i\",\"o\",\"u\")\n  vowels_count = word.scan(/[aeiou]/).count\n  if\
    \ vowels_count > 0\n    word.scan(/[aeiou]/).reverse_each {|vowel| return vowel\
    \ if vowels_count > word.count(vowel)}\n  else\n    return ''\n  end\nend", " \
    \ vowels = \"aeiouAEIOU\"\n  vowel_index = word.rindex('AEIOU') + 2\n  vowel_before\
    \ = word[vowel_index]\n  vowel_after = word[vowel_index+1]\n  return vowels.find\
    \ { |vowel| vowel.casecmp(vowel_before) < 0 && \n  vowel.casecmp(vowel_after)\
    \ > 0 } ? vowel_after : \"\"\nend\n</code>\n<|/ a |>\n<| c |>\nThis works well\
    \ for the test case I gave but fails on `\"ab\"`\n<|/ c |>\n<| c |>\nI've just\
    \ tested with 'ab' and it returns empty string.\n<|/ c |>\n<| a dscore=3 |>\n\
    <code>", "  vowels = [\"A\",\"a\",\"O\",\"o\",\"U\",\"u\"]\n  letters = word.split(\"\
    \")\n  last_index = letters.length\n  last_letter = letters[last_index-1]\n  first_letter\
    \ = letters[0]\n  vowel_found = false\n  if vowels.include? last_letter\n    vowel_found\
    \ = true\n  end\n  vowels.each do |v|\n    letters = word.split(\"\")\n    letters.drop(1).each\
    \ do |letter|\n      if letter == v\n        last_index = letters.length\n   \
    \     last_letter = letters[last_index-1]\n        first_letter = letters[0]\n\
    \        break if last_letter == v && last_index == letters.length-1\n      end\n\
    \    end\n  end\n  return first_letter if vowel_found\n  return \"\"\nend", " \
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  word.downcase.scan(/[aeiou]/).reverse_each.with_index.map\
    \ do |char, idx|\n    idx % 4 == 0 and idx == 2 ? vowels.last : char\n  end.join\n\
    end", "    vowel = \"AEIOUaeiou\"\n    vowel_count = {}\n    vowel_index = {}\n\
    \    vowel_position = []\n    for letter in word\n        if vowel.include?(letter)\n\
    \            vowel_index[letter] = word.index(letter)\n            vowel_count[letter]\
    \ = vowel.count(letter)\n            vowel_position << [word.index(letter), vowel.index(letter)]\n\
    \        else\n            vowel_position << [word.index(letter), -1]\n      \
    \  end\n    end\n    vowel_position.uniq!\n    closest_vowel_index = []\n    closest_vowel_pos\
    \ = 0\n    for position in vowel_position\n        if vowel_count[word[position[0]]]\
    \ >= vowel_count[word[position[1]]]\n            closest_vowel_index << position[0]\n\
    \            closest_vowel_pos = position[1]\n        end\n    end\n    if vowel_index[word[closest_vowel_index]]\
    \ != -1\n        return word[vowel_index[word[closest_vowel_index]]]\n    end\n\
    \    return \"\"\nend", "  consonants = 'bcdfghjklmnpqrstvwxyz'\n  vowels = 'aeiou'\n\
    \  vowel_count = {}\n  \n  # Use consonants array and vowels array from the previous\
    \ function to count the \n  # vowel in the word string. \n  word.split(\"\").each\
    \ do |char| \n    vowel_count[char] = consonants.count(char)\n  end", "  \n  vowels\
    \ = (\"a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n  \n  vowel_indexes = []\n  \n\
    \  vowel_indexes.push((word.rindex(\"a\"), 1))\n  vowel_indexes.push((word.rindex(\"\
    e\"), 1))\n  vowel_indexes.push((word.rindex(\"i\"), 1))\n  vowel_indexes.push((word.rindex(\"\
    o\"), 1))\n  vowel_indexes.push((word.rindex(\"u\"), 1))\n  vowel_indexes.push((word.rindex(\"\
    y\"), 1))", "  vowels = []\n  vowels.push(\"a\") # Adding vowel to the array\n\
    \  vowels.push(\"e\")\n  vowels.push(\"i\")\n  vowels.push(\"o\")\n  vowels.push(\"\
    u\")\n  vowels = vowels.uniq.sort\n  vowels.reverse\n  for i in vowels\n    if\
    \ word.index(i) ==word.rindex(i, 0, word.length)\n      return i\n    return \"\
    \"\nend\n</cell>\n<text>\nCousins Problem - Coin Change", "  return word.chars.reverse_each.find\
    \ { |x| x.upcase != \"A\" && x.upcase != \"E\" && x.upcase != \"I\" && x.upcase\
    \ != \"O\" && x.upcase != \"U\" }.to_s.chars.last\nend\n</code>\n<|/ a tags=ruby,algorithm\
    \ |>\n<| a tags=ruby,algorithm |>\n<code>", "  vowels = %w{a e i o u}\n  vowels.each\
    \ do |vowel|\n    if word[vowel.length..-1].include?(vowel) \n      puts vowel\n\
    \      break\n    end\n  end\n  \"\"\nend\n</code>\n<|/ a |>\n<| c |>\n`word[vowel.length..-1].include?(vowel)`\
    \ could just be `vowel`.\n<|/ c |>\n<| c |>\nYes, I agree. Thank you for the suggestion.\n\
    <|/ c |>\n<| a |>\n<code>", "  vowel = nil\n  \n  # TODO: Write the code here\n\
    \  word.each_byte do |i| \n    if (i == 'a' || i == 'e' || i == 'i' || i == 'o'\
    \ || i == 'u') \n       vowel =  i\n       return vowel\n    end\n  end\n  return\
    \ vowel\nend", "  word.downcase!\n  a=[]\n  word.length.downto(1).each do |i|\n\
    \    a.push(i)\n  end\n  a.push(0)\n  a.sort!.each do |i|\n    if word[i].downcase\
    \ == \"a\" || word[i].downcase == \"e\" || word[i].downcase == \"i\" || word[i].downcase\
    \ == \"o\" || word[i].downcase == \"u\" || word[i].downcase == \"y\"\n      return\
    \ word[i]\n    end\n  end\n  return \"\"\nend", "  # Solution using Array\n  vowels\
    \ = ['a','e','i','o','u']\n  vowel_positions = word.scan(/[aeiou]/)\n  \n  return\
    \ vowels.find { |vowel| vowel_positions.index( vowel ) }\nend", "  vowels = %w[a\
    \ e i o u]\n  vowels.each do |vowel|\n    if vowel.include?(word[-1])\n      return\
    \ vowel\n    end\n  end\n  return \"\"\nend", "  if word.empty?\n    return \"\
    \"\n  vowels = (\"a\",\"e\",\"i\",\"o\",\"u\",\"y\")\n  vowel_array = []\n  word.each_char.with_index\
    \ do |char, idx|\n    vowel_array << char if vowels.include?(char)\n  end\n  vowel_array.uniq!\n\
    \  vowel_array.reverse!\n  vowel_array.each do |vowel|\n    return \"\" if vowel\
    \ == vowel_array.first\n    return \"\" if vowel == vowel_array.last\n  end\n\
    \  return vowel_array.first\nend", "  vowel_array = [\"a\",\"e\",\"i\",\"o\",\"\
    u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\n  result = []\n  word = word.downcase\n  i\
    \ = 0\n  while i < (word.length)\n    v = word[i]\n    i += 1\n    if vowel_array.include?\
    \ v\n      result << v\n    else \n      break\n    end\n  end\n  result.empty?\
    \ ? \"\" : result[0]\nend", "\treturn word.chars.sort.find { |char| get_consonant_count(char,\
    \ false) < get_consonant_count(char, true) }\nend", "  vowels = [\"a\", \"e\"\
    , \"i\", \"o\", \"u\"]\n  last_vowel_before_word = nil\n  word.split.each_with_index\
    \ do |c, index|\n    index = index if c == \"a\"\n    index = index if c == \"\
    e\"\n    index = index if c == \"i\"\n    index = index if c == \"o\"\n    index\
    \ = index if c == \"u\"\n    \n    if (last_vowel_before_word == nil)\n      last_vowel_before_word\
    \ = index\n    end\n    \n    if (last_vowel_before_word.nil? || index - last_vowel_before_word\
    \ < 0)\n      last_vowel_before_word = index\n    end\n  end\n  return \"#{vowels[last_vowel_before_word]}\"\
    .upcase\nend", "  vowels = \"aeiouAEIOU\"\n  consonants = \"bdfghjklmnpqrstvwxyzBDFGHJKLMNPQRSTVWXYZ\"\
    \n  vowel_position = 0\n  consonant_position = 0\n  best_vowel = \"\"\n  best_consonant\
    \ = \"\"\n  vowel_position_found = 0\n  consonant_position_found = 0\n  \n  while\
    \ vowel_position < vowels.length && consonant_position < consonants.length\n \
    \   letter = word[vowel_position]\n    vowel_position_found = 0\n    consonant_position_found\
    \ = 0\n    while vowel_position_found < vowels.length && consonant_position_found\
    \ < consonants.length\n      best_vowel = letter\n      best_consonant = consonants[consonant_position_found]\n\
    \      if best_vowel == vowels[vowel_position_found]\n        vowel_position_found\
    \ += 1\n      else\n        consonant_position_found += 1\n    end", "  word.reverse\n\
    \  vowels = ['a','e','i','o','u']\n  found = vowels.find do |vowel|\n    vowel.downcase\
    \ == word[word.index(vowel) + 1]\n  end\n  found ? found : \"\"\nend\n</code>\n\
    <|/ a |>\n<| a dscore=1 tags=string,ruby |>\n<code>", "  vowels = (\"a\",\"e\"\
    ,\"i\",\"o\",\"u\")\n  return vowels.find {|v| word.include?(v) && word.size !=\
    \ word.length }.to_s\nend", "  vowels = Set.new('aeiou')\n  \n  consonants = Set.new('bcdfghjklmnpqrstvwxyz')\n\
    \  \n  vowel_positions = word.downcase.scan(/[aeiou]/)\n  \n  if vowel_positions.length\
    \ == 0\n    return \"\"\n  \n  consonant_positions = word.downcase.scan(/[#{consonants}]/)\n\
    \  consonant_positions.reject! {|i| i.empty?}\n  \n  vowel_positions.map! do |vowel|\n\
    \    index = consonant_positions.index(vowel)\n    \n    consonant_positions[index\
    \ + 1].first\n  end\n  \n  consonant_positions.inject(\"u\") do |vowel, position|\n\
    \    position == 0 ? vowel : vowel.succ if vowels.include?(vowel)\n  end\nend",
  "\tvowel_arr = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tvowel_arr.each do |vowel|\n\
    \t\tresult = word.split(vowel).last\n\t\tif result.include?(\"a\")\n\t\t\treturn\
    \ vowel\n\t\tend\n\tend\n\treturn \"\"\nend", "  vowels = %w[a e i o u]\n  vowels.each\
    \ do |vowel|\n    index = word.index(vowel)\n    return \"\" if index == -1\n\
    \    word = word[index+1..-1]\n  end\n  return word[0]\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby,algorithm,ruby-on-rails,ruby-on-rails-4 |>\n<| c |>\nThis is very\
    \ nice. Thank you!\n<|/ c |>\n<| a dscore=1 |>\nYou can use regular expressions\
    \ to do it:\n<code>", "  vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  vowels.each\
    \ do |vowel|\n    word.slice!(0...vowel.length)\n    \n    word.slice!(0...vowel.length)\n\
    \    word.slice!(0...vowel.length)\n    \n    word.slice!(0...vowel.length)\n\
    \    word.slice!(0...vowel.length)\n    \n    word.slice!(0...vowel.length)\n\
    \    word.slice!(0...vowel.length)\n    \n    word.slice!(0...vowel.length)\n\
    \    word.slice!(0...vowel.length)\n    \n    word.slice!(0...vowel.length)\n\
    \    word.slice!(0...vowel.length)\n    \n    if word.downcase == vowel.downcase\n\
    \      return vowel\n    end\n  end\n  return \"\"\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| a |>\n<code>", "  vowels = %w{ a e i o u A E I O U }\n  word = word.downcase\n\
    \  consonants = %w{ b c d f g h j k l m n p q r s t v w x y z }\n  word.each_index\
    \ {|i| consonants.each { |c| return vowels[word.length - i - 1].downcase if word[i].to_s.include?(c)}}\n\
    \  \"\"\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "  if word.length\
    \ <= 1 \n    return \"\"\n  \n  # create two arrays of consonants and vowels\n\
    \  consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"\
    ]\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  \n  # create empty string\
    \ for result\n  result = \"\"\n  \n  # start from right side\n  i = word.length\
    \ - 2\n  \n  # until vowel is found\n  while i >= 0\n    if consonants.include?(word[i])\n\
    \      break\n    \n    i -= 1\n  end\n  \n  # until consonant is found\n  while\
    \ i < word.length\n    if vowels.include?(word[i])\n      break\n    \n    i +=\
    \ 1\n  end\n  \n  # check left side\n  if vowels.include?(word[i])\n    result\
    \ << word[i]\n  end\n  \n  # check right side\n  if consonants.include?(word[i])\n\
    \    result << word[i]\n  end\n  \n  result\nend\n</cell>\n<cell>", "    # your\
    \ code goes here\n    vowels = \"AEIOUaeiou\"\n    vowel_arr = word.split #split\
    \ the string to array of letter\n    vowel_arr.delete_at(-1) #delete the final\
    \ letter\n    vowel_arr.delete_at(0)  #delete the first letter\n    vowel_arr.delete_at(-1)\
    \  #delete the penultimate letter\n    vowel_arr.delete_at(0)  #delete the first\
    \ letter\n    vowel_arr.delete_at(0)  #delete the first letter\n    vowel_arr.delete_at(-1)\
    \  #delete the penultimate letter\n    vowel_arr.delete_at(-1)  #delete the penultimate\
    \ letter\n    \n    letter_counter = 0\n    previous_char = \"A\"\n    next_char\
    \ = \"Z\"\n    vowel_counter = 0\n    \n    for i in range(len(word)):\n     \
    \   \n        if vowel_arr[letter_counter] in vowels:\n            vowel_counter\
    \ += 1\n        \n        if letter_counter == len(word) - 1:\n            \n\
    \            if vowel_counter < 2:\n                return vowel_arr[letter_counter]\n\
    \        \n        else:\n            letter_counter += 1\n            previous_char\
    \ = next_char\n            next_char = vowel_arr[letter_counter]", "  vowels =\
    \ %w{a e i o u}\n  vowels.each { |vowel| word.include?(vowel) ? vowel : \"\" }\n\
    end\n</code>\nI did not include code for the get_closest_consonant method but\
    \ here is the pseudocode for it:\n<code>", "  vowels = /[aeiou]/ # case sensitive\n\
    \  vowels.downcase # lowercase the string\n  vowels.reverse # reverse the string\n\
    \  word_split = word.split(//) # split word\n  word_split.each_with_index do |w,\
    \ i|\n    vowel = vowels.find { |v| w.include? v }\n    word_split[i] = word_split[i].split(vowel).last\n\
    \  end\n  word_split.join(//).to_s.reverse # reverse the word again\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThe `vowels` array is unnecessarily being created from scratch\
    \ on every call. Just call `downcase` once before the loop and you only have to\
    \ do `vowels.find` inside the loop.\n<|/ c |>\n<| a tags=ruby |>\nThe OP has already\
    \ accepted an answer, but here's a solution using a regular expression that should\
    \ scale well to large lists:\n<code>", "  consonants = (\"b\", \"c\", \"d\", \"\
    f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n  vowels = (\"a\", \"e\", \"i\"\
    , \"o\", \"u\")\n  vowels_count = 0\n  closest_vowel = nil\n  vowels.each do |vowel|\n\
    \    vowels_count += 1 if word.include?(vowel)\n  end\n  consonants.each do |consonant|\n\
    \    word = word.gsub(consonant, \"\") if word.include?(consonant)\n    next unless\
    \ word\n    word.split(//).each do |letter|\n      letter = letter + \"a\" if\
    \ letter.include?(\"a\")\n      letter = letter + \"i\" if letter.include?(\"\
    i\")\n      letter = letter + \"o\" if letter.include?(\"o\")\n      letter =\
    \ letter + \"u\" if letter.include?(\"u\")\n      if vowels_count > 0 && word.include?(letter)\n\
    \        closest_vowel = letter\n        break\n      end\n    end\n  end\n  closest_vowel\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails |>\n\
    This may not be the best solution but works...\n<code>", "  \n  # Your code here\n\
    \  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  vowels_count = 0\n  consonants\
    \ = word.split(\"\")\n  consonant_count = 0\n  \n  # find the vowel\n  for v in\
    \ vowels\n    if word.include? v\n      vowels_count += 1\n    elsif word.include?\
    \ v[-2..-1]\n      vowels_count += 1\n      break\n    end\n  end", "    vowels\
    \ = ['a','e','i','o','u']\n    consonants = ['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','y','z']\n\
    \    vowels_count = 0\n    consonants_count = 0\n    closest_vowel = vowels[0]\n\
    \    \n    for char in word:\n        if char in vowels:\n            vowels_count\
    \ += 1\n        if char in consonants:\n            consonants_count += 1\n  \
    \  \n    if consonants_count > 0 and vowels_count > 0:\n        if vowels_count\
    \ > consonants_count:\n            closest_vowel = vowels[0]\n        elif consonants_count\
    \ > vowels_count:\n            closest_vowel = consonants[0]\n        elif vowels_count\
    \ == consonants_count:\n            closest_vowel = vowels[vowels_count - 1]\n\
    \        \n    return closest_vowel\n</cell>\n<text>\nget_closest_vowels function\n\
    Complete the get_closest_vowels function below.", "  vowel = nil\n  \n  consonants\
    \ = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"p\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"]\n  \n  word.each_char.with_index\
    \ do |char, index|\n    if consonants.include?(char)\n      consonants.each_with_index\
    \ do |consonant, j|\n        if index > j && consonant != char\n          vowel\
    \ = consonant\n          return vowel\n        end\n      end\n    end\n  end\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "    vowels = %W(a e i o u)\n\
    \    vowels.uniq.sort.each do |v|\n        word.split(\"\").reverse.each_cons(2)\
    \ do |c1, c2|\n            next if c1.nil? || c2.nil?\n            return \"\"\
    \ if c1 == c2 && c1 !~ v\n            return c1 if c1 == c2 || c1 =~ v\n     \
    \   end\n    end\n    return \"\"\nend\n</code>\nAnd also the other solution using\
    \ regex (this one is faster I suppose):\n<code>", "  word.each_char.with_object(\"\
    \").with_index { |c, i| \n    c == ?u ? (vowels_index = 0) + i : nil\n  }.last\n\
    end", "  vowels = (\"a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n  vowels_count =\
    \ vowels.size\n  consonants = (\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\"\
    , \"x\", \"z\")\n  consonants_count = consonants.size\n  vowels_index = word.size\
    \ - vowels_count - 1\n  consonants_index = word[vowels_index].size - consonants_count\
    \ - 1\n  consonants_index -= 1\n  \n  vowels_index = vowels_index if vowels_index\
    \ < 0 else 0\n  consonants_index = consonants_index if consonants_index < 0 else\
    \ 0\n  \n  return word[vowels_index] if vowels_count > consonants_count else word[consonants_index]\n\
    end\n</code>\n<|/ a dscore=4 tags=string,ruby,arrays |>\n<| a dscore=3 tags=string,ruby,arrays\
    \ |>\n<code>", "    vowels = ['a','e','i','o','u','A','E','I','O','U']\n    i\
    \ = -1\n    vowel_count = 0\n    for v in vowels:\n        if word.rfind(v) !=\
    \ -1:\n            vowel_count = vowel_count + 1\n        i += 1\n    \n    if\
    \ vowel_count > 0:\n        vowel = vowels[vowel_count - 1]\n        if vowel\
    \ == 'a' or vowel == 'A':\n            return vowel\n        else:\n         \
    \   return ''\n    else:\n        return ''", "  vowels = %w{a e i o u}\n  word.split(//).each\
    \ do |letter|\n    return if vowels.include?(letter)\n    break if letter == \"\
    y\"\n    break if letter == \"a\"\n    break if letter == \"o\"\n  end\n  vowels.index(\"\
    u\") + 1\nend\n</code>\n<|/ a dscore=0 tags=string,ruby |>\n<| c |>\n\"Yogurt\
    \ full quick\" returns \"u\".\n<|/ c |>\n<| c |>\nThanks for pointing out. I'll\
    \ take a look :)\n<|/ c |>\n<| c |>\nYour code fails for words like `\"Baby\"\
    `\n<|/ c |>\n<| c |>\nGood catch, I'll take a look :) thanks\n<|/ c |>\n<| a |>\n\
    <code>", "  # Your code here\n  vowels = [\"a\",\"e\",\"i\",\"o\",\"u\",\"A\"\
    ,\"E\",\"I\",\"O\",\"U\"]\n  vowel_ends = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  last_index\
    \ = 0\n  first_index = 0\n  closest_vowel = \"\"\n  vowel_starts = []\n  vowel_ends\
    \ = []\n  for i in word.downcase.split('')\n    if vowels.include?(i)\n      vowel_starts.push(first_index)\n\
    \    end\n    if vowel_ends.include?(i)\n      vowel_ends.push(last_index)\n \
    \   end\n  end\n  if vowel_starts[0] > vowel_ends[0]\n    closest_vowel = vowels[vowel_starts[0]]\n\
    \  else\n    closest_vowel = vowels[vowel_ends[0]]\n  end\n  return closest_vowel\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,regex |>\n<code>", "  vowels =\
    \ [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  last_index = -1\n  vowel_letters = []\n\
    \  \n  # Iterate through the string and get the last index\n  # of consonants.\
    \ If the string doesn't have consonants, return \"\".\n  consonant_index = word[word.rindex(\"\
    a\")..-1].rindex(\"b\")\n  if consonant_index.nil? || consonant_index > 0\n  \
    \  return \"\"\n  end\n  \n  last_index = consonant_index\n  \n  # Get the vowel\
    \ positions of last index.\n  # If last index is a vowel, get the index of next\
    \ vowel position.\n  vowel_positions = []\n  while (last_index && vowels.include?(word[last_index]))\
    \ do\n    vowel_positions << last_index\n    last_index = word[last_index..-1].rindex(\"\
    b\")\n  end\n  \n  vowel_positions << last_index\n  \n  # If the last index isn't\
    \ a vowel, return \"\".\n  # Otherwise, return the vowel that stands between \n\
    \  # the two consonants from the right side of the word.\n  vowel_letter = nil\n\
    \  if vowel_positions.empty?\n    return \"\"\n  elsif vowel_positions.length\
    \ < 2\n    return \"\"\n  else\n    vowel_letter = vowels[vowel_positions[1]..vowel_positions[2]]\n\
    \  end\n  \n  # Return vowel that stands between the two consonants from the right\
    \ side of the word\n  vowel_letter\nend", "  vowel = \"aeiouAEIOU\"\n  word.chars.reverse.each\
    \ do |c|\n    vowel_index = vowel.index c\n    vowel_index_min = vowel_index \n\
    \    if vowel_index < 0\n      vowel_index_min = vowel_index + vowel.length\n\
    \    elsif vowel_index >= vowel.length\n      vowel_index_min = vowel_index -\
    \ vowel.length\n    end\n    return c if vowel_index_min > 0 && vowel_index_min\
    \ < vowel_index\n  end\n  return \"\"\nend\n</code>\n<|/ a tags=ruby |>\n<| a\
    \ dscore=0 tags=ruby |>\nYou can simplify the code with some regex magic:\n<code>",
  "  # TODO: Write your code here\n  return ''\nend", "  return '' if word.nil? or\
    \ word.empty? or word.size < 3 or word.chars.none? {|x| x.upcase == 'A' || x.upcase\
    \ == 'E' || x.upcase == 'I' || x.upcase == 'O' || x.upcase == 'U' }\n  vowel_start_index\
    \ = word.rindex(/[AEIOU]/)\n  vowel_end_index = word.rindex(/[AEIOU]/) + 1 if\
    \ vowel_start_index\n  vowel_end_index += 1 unless vowel_start_index\n  \n  if\
    \ vowel_start_index\n    start = word[vowel_start_index]\n    vowel_start_index\
    \ += 1\n    end = word[vowel_end_index]\n    if start == 'a' or start == 'e' or\
    \ start == 'i' or start == 'o' or start == 'u'\n      vowel = start\n    else\n\
    \      vowel = word[vowel_start_index]\n      vowel_start_index += 1\n    end\n\
    \    \n    return vowel\n  end\n  \n  vowel = word[vowel_start_index]\n  vowel_start_index\
    \ += 1\n  \n  if vowel_end_index\n    vowel = word[vowel_end_index]\n  end\n \
    \ \n  return vowel\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks for your\
    \ answer, it does solve my problem. Could you please give a brief explanation\
    \ on how your code works?\n<|/ c |>\n<| c |>\nsure, let me do that :)\n<|/ c |>\n\
    <| c |>\nI added some explanations. Hope it helps.\n<|/ c |>\n<| c |>\nThank you,\
    \ your explanation was very helpful.\n<|/ c |>\n<| a dscore=0 |>\n<code>", " \
    \ word = word.downcase\n  return word.split('').find { |c| c == \"a\" || c ==\
    \ \"e\" || c == \"i\" || c == \"o\" || c == \"u\" }.nil? ? \"\" : \n         \
    \ word.split('').find { |c| c == \"a\" || c == \"e\" || c == \"i\" || c == \"\
    o\" || c == \"u\" }.to_s\nend", "  return \"\" unless word.length < 3 or word.length\
    \ > 4\n  vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  i = 0\n  while i < word.length\n\
    \    i += 1\n    if word[i] == \"y\"\n      return word[(i-1)..i]\n    elsif word[i]\
    \ == \"o\"\n      return word[i..(i-1)]\n    elsif word[i] == \"a\"\n      return\
    \ word[i..(i-1)]\n    elsif word[i] == \"e\"\n      return word[i..(i-1)]\n  \
    \  elsif word[i] == \"i\"\n      return word[i..(i-1)]\n    elsif word[i] == \"\
    u\"\n      return word[i..(i-1)]\n  end\n  return \"\"\nend", "  vowels = \"AEIOUYaeiouyAEIOUY\"\
    .split(\"\")\n  vowels_count = Hash.new(0)\n  word.each_char do |ch|\n    if vowels.include?\
    \ ch\n      vowels_count[ch] += 1 # add 1 to each vowel count\n    end\n  end\n\
    \  closest_vowel = nil\n  vowels_count.values.reverse.each do |count|\n    if\
    \ count.positive?\n      closest_vowel = vowels[vowels_count.keys.find_index {\
    \ |k| k.to_sym == count.to_sym }]\n      return closest_vowel\n    end\n  end\n\
    end", "  return \"U\"\nend", "    return word.each_char.map do |char|\n      \
    \  vowels = %w(a e i o u)\n        vowels.find { |vowel| char == vowel }\n   \
    \ end.compact\nend", "  vowel_position = []\n  consonant_position = []\n  \n \
    \ vowel_position = word.index((\"a\", \"i\", \"o\", \"u\", \"y\"))\n  consonant_position\
    \ = word.index((\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"\
    ))\n  \n  if consonant_position < vowel_position\n    if word[vowel_position+1]\
    \ == \"a\"\n      return word[vowel_position+1]\n    if word[vowel_position+1]\
    \ == \"i\"\n      return word[vowel_position+1]\n    if word[vowel_position+1]\
    \ == \"o\"\n      return word[vowel_position+1]\n    if word[vowel_position+1]\
    \ == \"u\"\n      return word[vowel_position+1]\n    if word[vowel_position+1]\
    \ == \"y\"\n      return word[vowel_position+1]\n  \n  if consonant_position >\
    \ vowel_position\n    if word[consonant_position-1] == \"a\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"b\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"c\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"d\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"e\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"f\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"g\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"h\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"j\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"k\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"l\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"m\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"n\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"p\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"q\"\n      return word[consonant_position-1]\n\
    \    if word[consonant_position-1] == \"r\"\n      return word[con", "    vowels\
    \ = ['a','e','i','o','u']\n    vowel_count = {}\n    vowels_map = {}\n    vowels_count\
    \ = 0\n    consonant = 'qwertyuiopasdfghjklzxcvbnm'\n    word_length = len(word)\n\
    \    i = 0\n    while(i < word_length):\n        letter = word[i]\n        i +=\
    \ 1\n        if(letter in vowels):\n            if(vowels_count.has_key(letter)):\n\
    \                vowel_count[letter] += 1\n            else:\n               \
    \ vowel_count[letter] = 1\n            vowels_map[letter] = vowel_count[letter]\n\
    \        else:\n            vowel_count[consonant[vowels_count % len(consonant)]]\
    \ = 0\n            vowels_count += 1\n    \n    for letter in vowels_map.keys():\n\
    \        vowels_map[letter] = vowels_map[letter] / word_length\n    \n    vowels_sorted_list\
    \ = sorted(vowels_map.iteritems(),key=lambda x:x[1],reverse=True)\n    vowel_index\
    \ = vowels_sorted_list[0][0]\n    return vowels_sorted_list[0][1] and vowels[vowel_index]\
    \ or \"\"\n    \n    ", "    vowels=/[AEIOUaeiou]/i\n    v=vowels.match(word)\n\
    \    if v\n    word = word[v.length..-1]\n    end=word.length\n    loop do\n \
    \       vowels=/[AEIOUaeiou]/i\n        v=vowels.match(word)\n        if v\n \
    \           end+=v.length\n        end\n        break unless word[end-1]==\"r\"\
    \n        break unless word[end-1]==\"u\"\n    end\n    return word[end-1]\nend",
  "    vowels = 'aeiouAEIOU'\n    return vowels.index( vowels[word[::-1].index('a')+1]\
    \ )\nend\n</cell>\n<code language=julia-1.3>", "  vowels = (\"a\", \"e\", \"i\"\
    , \"o\", \"u\")\n  consonants = \"bcdfghjklmnpqrstvwxyz\"\n  \n  i = word.rindex(\"\
    a\")\n  if i\n    if word.rindex(\"z\") > 0\n      return word\n    elsif word[i\
    \ - 1] != \"y\"\n      return word\n    else\n      index = word[i - 1].index(consonants.reverse,\
    \ i)\n      if index\n        return word[i - 1:i + index]\n      else\n     \
    \   return word[i - 1: i + 1]\n      end\n    end\n  else\n    return word\n \
    \ end\nend", "    vowels = %w[a e i o u]\n    word_length = word.length\n    word_end_index\
    \ = word_length - 1\n    word_vowels_index = 0\n    \n    return word_vowels.find\
    \ do |vowel|\n        word_vowels_index = vowels.index(vowel)\n        if word.end_with?(vowel)\n\
    \            word_vowels_index\n        elsif word_vowels_index >= (word_end_index\
    \ - word_vowels_index)\n            vowel\n        else\n            vowels[(word_end_index\
    \ - word_vowels_index) + 1]\n        end\n    end\nend", "  # your code here\n\
    \  vowels = ['a','e','i','o','u','A','E','I','O','U']\n  letters = word\n  if\
    \ letters.index(\"a\") > letters.index(\"e\"):\n    letters = letters.reverse()\n\
    \    \n  vowels_count = 0\n  for letter in letters:\n    if letter in vowels:\n\
    \      vowels_count += 1\n      if vowels_count == len(letters) - 1:\n       \
    \ return letter\n  \n  return \"\"", "  if word == \"\"\n    return \"\"\n  vowels\
    \ = \"aAeEiIoOuU\"\n  consonants = \"bBcCdDfGhHjJkKlLmMnNoOpPqQsStTuUvVwWxXzZ\"\
    \n  word = word.downcase\n  vowel_found = false\n  consonant_index = 0\n  consonant_found\
    \ = false\n  consonant_left_index = 0\n  consonant_right_index = 0\n  consonant_found\
    \ = false\n  vowel_found = false\n  while consonant_left_index <= consonant_right_index\n\
    \    if consonants[consonant_index] == word[consonant_left_index]\n      if consonant_index\
    \ == consonant_right_index\n        if word[consonant_left_index] == 'A' and consonant_found\
    \ == false\n          consonant_found = true\n          consonant_right_index\
    \ = consonant_index\n          consonant_index += 1\n        elsif consonant_found\
    \ == true\n          return word[consonant_left_index..consonant_right_index]\n\
    \        end\n      else\n        consonant_found = true\n      end\n    else\n\
    \      consonant_index += 1\n    end\n  end\n  return word\nend", "  # write your\
    \ code here\n  vowel = \"AEIOUaeiou\"\n  vowel = vowel.split('')\n  \n  if word.include?\
    \ \"a\" and word.include? \"e\" and word.include? \"i\" and word.include? \"o\"\
    \ and word.include? \"u\":\n    vowel_1 = word.include? \"a\" and word.include?\
    \ \"e\" and word.include? \"i\" and word.include? \"o\" and word.include? \"u\"\
    \n    if vowel_1:\n      return word[word.rindex(vowel) + 1]\n    elif vowel_1:\n\
    \      return word[word.rindex(vowel)-1]\n    \n  if word.include? \"a\" and word.include?\
    \ \"e\" and word.include? \"i\" and word.include? \"o\" and word.include? \"u\"\
    :\n    vowel_2 = word.include? \"a\" and word.include? \"e\" and word.include?\
    \ \"i\" and word.include? \"o\" and word.include? \"u\"\n    if vowel_2:\n   \
    \   return word[word.rindex(vowel)+1]\n    elif vowel_2:\n      return word[word.rindex(vowel)\
    \ - 1]\n    \n  if word.include? \"a\" and word.include? \"e\" and word.include?\
    \ \"i\" and word.include? \"o\" and word.include? \"u\":\n    vowel_3 = word.include?\
    \ \"a\" and word.include? \"e\" and word.include? \"i\" and word.include? \"o\"\
    \ and word.include? \"u\"\n    if vowel_3:\n      return word[word.rindex(vowel)\
    \ - 2]\n    elif vowel_3:\n      return word[word.rindex(vowel) - 1]\n    \n \
    \ if word.include? \"a\" and word.include? \"e\" and word.include? \"i\" and word.include?\
    \ \"o\" and word.include? \"u\":\n    vowel_4 = word.include? \"a\" and word.include?\
    \ \"e\" and word.include? \"i\" and word.include? \"o\" and word.include? \"u\"\
    \n    if vowel_4:\n      return word[word.rindex(vowel) - 2]\n    elif vowel_4:\n\
    \      return word[word.rindex(vowel) - 2]\n  \n  if word.include? \"a\" and word.include?\
    \ \"e\" and word.include? \"i\" and word.include? \"o\" and word.include? \"u\"\
    :\n    vowel_5 = word.include? \"a\" and word.include? \"e\" and word.include?\
    \ \"i\" and word.include? \"o\" and word.include? \"u\"\n    if vowel_5:\n   \
    \   return word[word.rindex(vowel) - 2]\n    elif vowel_5:\n      return word[word.rindex(vowel)\
    \ - 2]\n  \n  if word.include? \"a\" and word.include? \"e\" and word.include?\
    \ \"i\" and word.include? \"o\" and word.include? \"u\":\n    vowel_6 = word.include?\
    \ \"a\" and word.include? \"e\" and word.include? \"i\" and word.include? \"o\"\
    \ and word.include? \"", "  vowels = (\"a\",\"e\",\"i\",\"o\",\"u\")\n  \n  count\
    \ = 0\n  result = \"\"\n  \n  for i in word.chars\n    if (vowels.include?(i))\
    \ && (vowels.include?(i+1)) \n      count += 1\n      result = i\n      if (count\
    \ >= 2)\n        break\n    end\n  end\n  \n  result\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby,ruby-on-rails,ruby-on-rails-3,ruby-on-rails-4,rubygems |>\n<| c |>\n\
    Thanks for your answer. I am trying this out and getting `NoMethodError: undefined\
    \ method `chars' for nil:NilClass` at the line `for i in word.chars`. Can you\
    \ please tell me what could be the problem? And what would be the way to resolve\
    \ this?\n<|/ c |>\n<| c |>\nI am sure you used this code in another class. I suggest\
    \ you put your code in the controller so that you get a result immediately. \n\
    \ \nAlso, I noticed that you are returning empty string if only one vowel is found.\
    \ \n \n`", "  vowels = (\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\"\
    ,\"U\")\n  consonants = (\"b\",\"c\",\"d\",\"f\",\"g\",\"h\",\"j\",\"k\",\"l\"\
    ,\"m\",\"n\",\"p\",\"q\",\"r\",\"s\",\"t\",\"v\",\"w\",\"x\",\"z\")", "  vowel\
    \ = nil\n  count = 0\n  for i in 1..word.length-1\n    if word[i]==\"a\"\n   \
    \   vowel = \"a\"\n      count = count+1\n    elsif word[i]==\"e\"\n      vowel\
    \ = \"e\"\n      count = count+1\n    elsif word[i]==\"i\"\n      vowel = \"i\"\
    \n      count = count+1\n    elsif word[i]==\"o\"\n      vowel = \"o\"\n     \
    \ count = count+1\n    elsif word[i]==\"u\"\n      vowel = \"u\"\n      count\
    \ = count+1\n    end\n  end\n  if count>1\n    return word[vowel, word.length]\n\
    \  end\nend\n  ", "  return word.rscan(/[aeiouy]/i).min\nend", "  vowels = ['A','a','E','e','I','i','O','o','U','u','a','e','i','o','u','y']\n\
    \  vowels.each do |vowel|\n    if word.include?(vowel) && word[vowel.to_s.length..-1].to_s.include?(vowel)\n\
    \      return vowel\n    end\n  end\n  ''\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays,string\
    \ |>\n<| c |>\nWhat is the rationale of not using the `include?` method for checking\
    \ if a character is in a string? Why not use the `include?` method of the `String`\
    \ class?\n<|/ c |>\n<| c |>\nBecause the include? method is used for checking\
    \ if a character is in a string.\n<|/ c |>\n<| c |>\nI understand that. I was\
    \ asking if there was a reason to not use the `include?` method of the `String`\
    \ class when checking the value of a character. Is it because the `include?` method\
    \ checks for matches in an array? Why not just use an array to check?\n<|/ c |>\n\
    <| a tags=ruby,arrays,string |>\nIf your string is just an alphabet/vowels you\
    \ can also use regex, for example\n<code>\n\"FULL\".match(/[aeiou]/i).to_a", " \
    \ vowels = %w(a e i o u)\n  vowels.sort.reverse\n  vowels.each { |v|\n    if word.end_with?(v)\n\
    \      return v\n    end\n  }\n  \"\"\nend", "  vowels = %w{a e i o u}\n  word.gsub(/[^a-z]/,\
    \ \"\").chars.sort.each_cons(2).find {|a, b|\n    vowels.include?(a.upcase) &&\
    \ vowels.include?(b.upcase)\n  }.try(:downcase)\nend", "  vowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"]\n  idx = vowels.index(\"e\")\n  last_vowel = vowels[idx\
    \ - 1]\n  idx = vowels.index(\"i\")\n  next_vowel = vowels[idx + 1]\n  idx = vowels.index(\"\
    o\")\n  last_consonant = word[idx-1]\n  idx = vowels.index(\"u\")\n  next_consonant\
    \ = word[idx+1]", "  vowels = %W(a e i o u)\n  result = []\n  \n  word.split(\"\
    \").each_with_index do |letter, idx|\n    if idx > 0 && idx < word.length && letter\
    \ == vowels[idx]\n      result << vowels[idx-1]\n    elsif idx > 0 && idx < word.length\
    \ && letter == vowels[word.length-idx-1]\n      result << vowels[idx-1]\n    elsif\
    \ idx > 0 && idx < word.length && letter == vowels[word.length-idx+1]\n      result\
    \ << vowels[idx-1]\n    end\n  end\n  result.empty? ? \"\" : result.join(\"\"\
    )\nend", "    vowel_found = nil\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    word\
    \ = word.to_s.downcase\n    word.each do |letter|\n        vowel_found = vowels.find\
    \ {|vowel| letter.include? vowel }\n        break if vowel_found\n    end\n  \
    \  return vowel_found if vowel_found\n    return ''\nend", "  vowels = \"aeiouAEIOU\"\
    \n  vowels = vowels.split(\"\")\n  result = \"\"\n  word.split(\"\").reverse.each_with_index\
    \ do |letter, index|\n    if vowels.include?(letter)\n      result = letter\n\
    \      break\n    end\n  end\n  return result \nend\n</code>\n<|/ a |>\n<| a tags=ruby\
    \ |>\n<code>", "    vowel = \"AEIOUaeiou\"\n    vowel_position = []\n    vowel_position.append(word.rfind(\"\
    A\"))\n    vowel_position.append(word.rfind(\"E\"))\n    vowel_position.append(word.rfind(\"\
    I\"))\n    vowel_position.append(word.rfind(\"O\"))\n    vowel_position.append(word.rfind(\"\
    U\"))\n    if word.count(\"A\") > word.count(\"E\"):\n        vowel_position.append(vowel.rfind(\"\
    A\"))\n    if word.count(\"E\") > word.count(\"I\"):\n        vowel_position.append(vowel.rfind(\"\
    E\"))\n    if word.count(\"I\") > word.count(\"O\"):\n        vowel_position.append(vowel.rfind(\"\
    I\"))\n    if word.count(\"O\") > word.count(\"U\"):\n        vowel_position.append(vowel.rfind(\"\
    O\"))\n    if word.count(\"U\") > word.count(\"A\"):\n        vowel_position.append(vowel.rfind(\"\
    U\"))\n    if len(vowel_position) == 0:\n        vowel_position.append(word.rfind(\"\
    A\"))\n    if len(vowel_position) != 0:\n        min_value = min(vowel_position)\n\
    \        max_value = max(vowel_position)\n        for index, position in enumerate(vowel_position):\n\
    \            if position == min_value:\n                vowel_position[index]\
    \ = -1\n            if position == max_value:\n                vowel_position[index]\
    \ = -1\n                if index < (len(vowel_position)-1):\n                \
    \    vowel_position[index+1] = -1\n                else:\n                   \
    \ vowel_position[-1] = -1\n    min_value = min(vowel_position)\n    max_value\
    \ = max(vowel_position)\n    for index, position in enumerate(vowel_position):\n\
    \        if position == min_value:\n            vowel_position[index] = -1\n \
    \       if position == max_value:\n            vowel_position[index] = -1\n  \
    \          if index < (len(vowel_position)-1):\n                vowel_position[index+1]\
    \ = -1\n            else:\n                vowel_position[-1] = -1\n    return\
    \ vowel[vowel_position.index(min_value)]\n</code>\n<|/ a dscore=0 tags=ruby,string,arrays,algorithm,python\
    \ |>\n<| c |>\nYour code works well for me and also the one in Sweeper, but doesn't\
    \ work for my solution (I didn't expect it to). Here's my solution in Python:",
  "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  vowels.each do |vowel|\n    vowel_length\
    \ = vowel.count(\"a\")\n    index = word.rindex(\"a\", vowel_length)\n    index_to_check\
    \ = word.index(vowel, index)\n    word = word[index_to_check..-1]\n    break if\
    \ word.empty?\n  end\n  word\nend", "  # === Convert each letter in word === #\n\
    \  letters = word.split(\"\")\n  # === Make an array of vowels === #\n  vowels\
    \ = []\n  vowels += [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\",\"E\", \"I\", \"\
    O\", \"U\"]\n  vowel_array = []\n  vowel_array += [\"a\", \"e\", \"i\", \"o\"\
    , \"u\"]\n  # === Find which vowel is in the array === #\n  for letter in letters\n\
    \    if vowels.include? letter\n      vowel_array << letter\n    end\n  end\n\
    \  # === Find closest vowel === #\n  closest_vowel = vowel_array.sort.last\n \
    \ return closest_vowel\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nYour\
    \ code didn't work when `word = 'FULL'`, but when I add another condition, `if\
    \ word =~ /[aeiou]/`.\n<|/ c |>\n<| c |>\nThe solution is based on the assumption\
    \ that any word with any word character on the left is valid. That's why the regex\
    \ test is included along with other conditions. If you want a more sophisticated\
    \ solution that would take this into account, then you'd need to use something\
    \ else.\n<|/ c |>\n<| c |>\nYes I understand, but when I tested your solution,\
    \ I got an error `undefined method include?' for #<String:0x007f9d005644a8>`.\n\
    <|/ c |>\n<| c |>\n, Ruby v2.0.0 changed the `String#include?` method from being\
    \ an instance method to a class method, which was the cause of the error. I've\
    \ updated my answer to work with the latest version of Ruby.\n<|/ c |>\n<| c |>\n\
    Thanks. Could you take a look at my answer again? I tried to improve it but I\
    \ don't think it's perfect.\n<|/ c |>\n<| a dscore=1 |>\nThis is not the most\
    \ efficient solution but you can also use this code.\n<code>", "    vowels=%w{a\
    \ e i o u}\n    result=\"\"\n    word.downcase!\n    word.gsub(/[^a-z]/i, \"*\"\
    )\n    word.gsub(/[aeiou]/i, \"*\")\n    word.gsub(/[*]/i, \"\")\n    word.gsub(/[*]/i,\
    \ \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i,\
    \ \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i,\
    \ \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i,\
    \ \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i,\
    \ \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i,\
    \ \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i,\
    \ \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i,\
    \ \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i,\
    \ \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i,\
    \ \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i,\
    \ \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i,\
    \ \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i,\
    \ \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(/[*]/i,\
    \ \"*\")\n    word.gsub(/[*]/i, \"*\")\n    word.gsub(", "    vowels = ['a', 'A',\
    \ 'i', 'I', 'o', 'O', 'u', 'U']\n    vowels.each do |vowel|\n        if word.include?(vowel)\n\
    \            return vowel\n        end\n    end\n    return \"\"\nend", "  vowels\
    \ = \"AEIOUYaeiouyAEIOUY\"\n  vowel_word = word.chars.to_a\n  closest_vowel =\
    \ vowel_word.find_all {|c| vowels.include?(c.downcase) }\n  closest_vowel.empty?\
    \ ? \"\" : closest_vowel.first.upcase\nend", "  word.downcase!\n  \n  consonants\
    \ = \"bcdfghjklmnpqrstvwxyz\"\n  vowels = \"aeiouy\"", "  vowels = [\"A\",\"E\"\
    ,\"I\",\"O\",\"U\",\"a\",\"e\",\"i\",\"o\",\"u\"]\n  \n  vowel_count = Hash.new(0)\n\
    \  word.split(\"\").each do |letter|\n    if vowels.include?(letter)\n      vowel_count[letter]\
    \ += 1\n    end\n  end", "    vowels = (\"a\",\"e\",\"i\",\"o\",\"u\")\n    count\
    \ = 0\n    \n    for cons in word:\n        if cons in vowels:\n            count\
    \ +=1\n            \n    if count <= 1:\n        return \"\"\n    \n    vowel\
    \ = vowels[count-1]\n    \n    for cons in word[::-1]:\n        if cons in vowels:\n\
    \            count +=1\n            \n    if count <= 1:\n        return \"\"\n\
    \    \n    if count > len(vowels)-1:\n        return \"\"\n        \n    return\
    \ vowel", "    vowels = %w{a e i o u}\n    vowels.include?(word[0]) ? vowels[word.index(word[0])..-1]\
    \ : \"\"\nend", "  vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  a = word.rindex(\"\
    a\") + 1 if \"a\" in word.rindex(word) else 0\n  b = word.rindex(\"b\") + 1 if\
    \ \"b\" in word.rindex(word) else 0\n  c = word.rindex(\"c\") + 1 if \"c\" in\
    \ word.rindex(word) else 0\n  d = word.rindex(\"d\") + 1 if \"d\" in word.rindex(word)\
    \ else 0\n  e = word.rindex(\"e\") + 1 if \"e\" in word.rindex(word) else 0\n\
    \  f = word.rindex(\"f\") + 1 if \"f\" in word.rindex(word) else 0\n  g = word.rindex(\"\
    g\") + 1 if \"g\" in word.rindex(word) else 0\n  h = word.rindex(\"h\") + 1 if\
    \ \"h\" in word.rindex(word) else 0\n  i = word.rindex(\"i\") + 1 if \"i\" in\
    \ word.rindex(word) else 0\n  j = word.rindex(\"j\") + 1 if \"j\" in word.rindex(word)\
    \ else 0\n  k = word.rindex(\"k\") + 1 if \"k\" in word.rindex(word) else 0\n\
    \  l = word.rindex(\"l\") + 1 if \"l\" in word.rindex(word) else 0\n  m = word.rindex(\"\
    m\") + 1 if \"m\" in word.rindex(word) else 0\n  n = word.rindex(\"n\") + 1 if\
    \ \"n\" in word.rindex(word) else 0\n  o = word.rindex(\"o\") + 1 if \"o\" in\
    \ word.rindex(word) else 0\n  p = word.rindex(\"p\") + 1 if \"p\" in word.rindex(word)\
    \ else 0\n  q = word.rindex(\"q\") + 1 if \"q\" in word.rindex(word) else 0\n\
    \  r = word.rindex(\"r\") + 1 if \"r\" in word.rindex(word) else 0\n  s = word.rindex(\"\
    s\") + 1 if \"s\" in word.rindex(word) else 0\n  t = word.rindex(\"t\") + 1 if\
    \ \"t\" in word.rindex(word) else 0\n  u = word.rindex(\"u\") + 1 if \"u\" in\
    \ word.rindex(word) else 0\n  if a > 0 and b > 0 and c > 0 and d > 0 and e > 0\
    \ and f > 0 and g > 0 and h > 0 and i > 0 and j > 0 and k > 0 and l > 0 and m\
    \ > 0 and n > 0 and o > 0 and p > 0 and q > 0 and r > 0 and s > 0 and t > 0 and\
    \ u > 0:\n    return vowels[u-1] if u != 0 else \"\"\n  return \"\"\nprint(get_closest_vowel(\"\
    yogurt\"))\nprint(get_", "  vowels = %w{a e i o u}\n  consonants = %w{b c d f\
    \ g h j k l m n p q r s t v w x y z}\n  return vowels.min.compact.find do |vowel|\n\
    \    consonants.max.compact.find do |consonant|\n      word.downcase.include?(consonant)\
    \ || word.downcase.include?(vowel)\n    end\n  end\nend", "  return word[/([bcdfghjklmnpqrstvwxyz]{1})/,\
    \ 1]\nend", "  vowels = %w{a e i o u}\n  return vowels.find do |vowel| \n    word.scan(/[#{vowel}]+/).last.present?\n\
    \  end\nend", "  \n  if word.length == 1\n    word\n  else\n    vowels = %w(a\
    \ e i o u)\n    vowels.each do |vowel|\n      vowel_position = word.index(vowel)\n\
    \      consonant_position = word.length - vowel_position - 1\n      consonant_word\
    \ = word[consonant_position..-1]\n      if consonant_word.include?(vowel)\n  \
    \      return vowel\n      end\n    end\n  end\nend", "  return if word.empty?\
    \ || word.include? \"?\" || word.include? \"!\" || word.include? \"'\"\n  consonants\
    \ = 'bcdfghjklmnpqrstvwxyz'\n  vowels = 'aeiouy'\n  letter_count = 0\n  vowel_count\
    \ = 0\n  consonant_count = word.size - 1\n  vowel_index = consonants.index(\"\
    a\")\n  consonant_index = consonants.index(\"z\")", "  vowels = ['a', 'e', 'i',\
    \ 'o', 'u']\n  vowels_count = word.scan(/[aeiou]/).count\n  word = word.downcase\n\
    \  consonants = word.scan(/[^aeiou]/)\n  consonants_count = consonants.count\n\
    \  vowels.each do |v|\n    break if consonants_count < 1\n    consonants.each\
    \ do |c|\n      break if vowels_count < 1\n      break unless v == c\n      break\
    \ if vowels.count - consonants.count > consonants.count - vowels.count\n     \
    \ break if c.upcase > v\n      break if c.downcase < v\n    end\n  end\n  return\
    \ \"\"\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYou should check this against\
    \ the benchmarks in the other answer, which don't even seem to do a full pass\
    \ on each character. Also, it's more efficient to count the vowels first, then\
    \ just iterate over them.\n<|/ c |>\n<| c |>\nI agree with you, my answer should\
    \ be more efficient.\n<|/ c |>\n<| c |>\nI believe the answer has some typos and\
    \ would not run in ruby 1.8.7\n<|/ c |>\n<| a dscore=2 tags=ruby |>\nIf you know\
    \ that the input has only letters, you can do something like the following to\
    \ get the closest vowel:\n<code>\ninput = \"YOUR INPUT\"", "  vowels = %w[a e\
    \ i o u]\n  letter = word.chars.last\n  letter_pos = word.index(letter)\n  \n\
    \  vowel_index = 0\n  while vowel_index < vowels.length\n    if vowels[vowel_index]\
    \ == letter\n      return vowels[vowel_index+1]\n    vowel_index += 1\n  end\n\
    \  return ''\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThank you for the detailed\
    \ explanation.\n<|/ c |>\n<| c |>\nThanks. I've made a minor change in the method\
    \ `get_closest_vowel`, to make it return `nil` when no vowel is found. I've also\
    \ added a small remark to the doc: `Your task is to find the closest vowel that\
    \ stands between two consonants from the right side of the word (case sensitive).`\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  vowels = [\"a\", \"e\", \"i\", \"o\"\
    , \"u\"]\n  vowels_count = word.count(\"a\")\n  word.downcase.split(\"\").each\
    \ do |letter|\n    if (vowels.include?(letter))\n      return letter\n    end\n\
    \  end\nend", "    vowels = %w{a e i o u}\n    word = word.downcase\n    vowels.each\
    \ do |vowel|\n        if word.include?(vowel)\n            return vowel\n    \
    \    end\n    end\n    \n    \"\"\nend\n</cell>\n<code language=julia-0.4>", " \
    \ word.each_char.with_index do |char, i|\n    if char.upcase =~ /[AEIOUY]/ &&\
    \ (i - 1) < word.length \n      return char.upcase\n    elsif char.downcase =~\
    \ /[AEIOUY]/ && (i + 1) < word.length \n      return char.downcase\n    end\n\
    \  end\nend", "  if word.length < 2 || word.length >= 6\n    return \"\"\n  end",
  "  vowels = [\"a\",\"e\",\"i\",\"o\",\"u\",\"y\"]\n  letter_arr = word.split(\"\"\
    )\n  vowels_count = 0\n  vowel_arr = []\n  for i in letter_arr\n    if vowels.include?(i)\n\
    \      vowels_count += 1\n      vowel_arr << i\n    end\n  end\n  if vowels_count\
    \ < 2\n    vowels.each{|v| vowel_arr.each{|vv| puts vv if v == vv.downcase}}\n\
    \    return \"\"\n  end\n  \n  left_idx = letter_arr.rindex { |s| s.match(/[a-z]/)\
    \ }\n  right_idx = letter_arr.rindex { |s| s.match(/[a-z]/, right_idx+1)}\n  return\
    \ vowel_arr[left_idx..right_idx].join\nend", "    vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n    vowel_counter = 0\n    vowel_index = 0\n    vowel_found =\
    \ False\n    vowel_start_index = 0\n    vowel_end_index = 0\n    \n    # find\
    \ the closest vowel that stands between two consonants\n    # find the index of\
    \ the first vowel\n    for index in (word.index(\"a\") + 1):\n        vowel_counter\
    \ += 1\n        if word.index(\"a\", index) == -1 or word.index(\"a\", index)\
    \ == (len(word) - 1):\n            break\n        if vowels[vowel_index] != word[index]:\n\
    \            continue\n        if vowels[vowel_index] == word[index] and vowel_counter\
    \ == 1:\n            vowel_found = True\n            vowel_index = index\n   \
    \         break\n        if vowels[vowel_index] == word[index] and vowel_counter\
    \ == 3:\n            vowel_found = True\n            vowel_start_index = index\n\
    \            break\n        \n    # find the index of the second vowel\n    for\
    \ index in (word.index(\"e\") + 1):\n        vowel_counter += 1\n        if word.index(\"\
    e\", index) == -1 or word.index(\"e\", index) == (len(word) - 1):\n          \
    \  break\n        if vowels[vowel_index] != word[index]:\n            continue\n\
    \        if vowels[vowel_index] == word[index] and vowel_counter == 1:\n     \
    \       vowel_found = True\n            vowel_index = index\n            break\n\
    \        if vowels[vowel_index] == word[index] and vowel_counter == 3:\n     \
    \       vowel_found = True\n            vowel_end_index = index\n            break\n\
    \    \n    # check if the second vowel exists\n    if not vowel_found:\n     \
    \   return \"\"\n    \n    # find the difference between the start index and the\
    \ end index\n    diff = vowel_end_index - vowel_start_index\n    if diff == 1:\n\
    \        return word[vowel_start_index:vowel_end_index + 1]\n    if diff == 2:\n\
    \        return word[vowel_start_index:vowel_end_index + 1]\n    if diff == 3:\n\
    \        return word[vowel_start_index:vowel_end_index + 1]\n    return \"\"\n\
    \    \nprint(get_closest_vowel(\"yogurt\"))\nprint(get_closest_vowel(\"FULL\"\
    ))\nprint(get_closest_vowel(\"quick\"))\nprint(get_closest_vowel(\"ab\"))", " \
    \ word.gsub!(\"-\", \"\")\n  word.downcase!\n  letters = word.scan(/[bcdfghjklmnpqrstvwxyz]{2}/i)\n\
    \  letters.each { |letter| break if letter.upcase != letter }\n  letters.each\
    \ { |letter| letter = \"U\" if letter == letter.upcase }\n  letters.uniq.first\n\
    end", "  vowels = %W(a e i o u)\n  r = word.rindex(\"a\")\n  vowels.each_with_index\
    \ do |vowel, idx|\n    if idx > r || word.rindex(vowel, idx+1) == -1\n      break\n\
    \    else\n      idx = word.rindex(vowel, idx+1)\n      vowel = vowels[idx]\n\
    \      break\n    end\n  end\nend", "  word.downcase!\n  vowels = %w{a e i o u}\n\
    \  vowels.each do |vowel|\n    word = word.gsub(vowel, \"\")\n    if word.length\
    \ == 0\n      return \"\"\n    end\n  end\n  word.gsub(/[b-z]/, \"\").length\n\
    end", "  vowels = \"aeiouAEIOU\"\n  right_vowel = nil\n  right_index = nil\n \
    \ left_index = nil\n  vowel_found = false\n  vowel_letter = \"\"\n  \n  # Loop\
    \ through the given word and find the vowels\n  word.split(\"\").each do |char|\n\
    \    char.downcase.chars.each do |letter|\n      vowels.include?(letter) ? vowel_letter\
    \ = letter : next\n    end\n    \n    # Check if there are two consonants right\
    \ of the vowel\n    if vowel_letter != nil && vowel_letter == char\n      right_index\
    \ = char.index(vowel_letter)\n      right_vowel = char[right_index]\n    end\n\
    \    \n    # Check if there are two consonants right of the vowel\n    if right_index\
    \ != nil && right_vowel != nil && right_index != right_vowel\n      left_index\
    \ = char.index(right_vowel)\n      left_vowel = char[left_index]\n      \n   \
    \   # Check if the right consonants are consecutive and the left consonants are\
    \ consecutive\n      if right_index == right_vowel && left_index == left_vowel\
    \ && right_index != left_index + 1 && left_index != left_index + 1\n        vowel_found\
    \ = true\n        break\n      end\n    end\n  end\n  \n  # Check if we found\
    \ any vowels \n  if vowel_found == true\n    # Check if the current right and\
    \ left indexes are consecutive\n    if right_index == right_vowel && left_index\
    \ == left_vowel && right_index != left_index + 1 && left_index != left_index +\
    \ 1\n      return vowel_letter\n    end\n  end\n  return \"\"\nend", "\tvowel_arr\
    \ = [\"A\",\"a\",\"E\",\"e\",\"I\",\"i\",\"O\",\"o\",\"U\",\"u\",\"a\",\"e\",\"\
    i\",\"o\",\"u\"]\n\treturn vowel_arr.find do |vowel| \n\t\tword.downcase.chars.include?(vowel)\n\
    \tend\nend", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  consonants = [\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  beginning_vowels\
    \ = []\n  end_vowels = []\n  beginning_vowels_index = 0\n  end_vowels_index =\
    \ 0\n  consonant_index = 0\n  index = 0\n  while index < word.length\n    if word[index].upcase\
    \ =~ /[aeiou]/i\n      beginning_vowels_index += 1\n      beginning_vowels <<\
    \ word[beginning_vowels_index]\n    end", "  vowel_positions = []\n  word.split(\"\
    \").each_with_index do |letter, index|\n    if letter =~ /[aeiouy]/\n      vowel_positions\
    \ << index\n    end\n  end\n  vowel_positions.sort! { |a, b| b - a }\n  vowel_positions.each\
    \ do |index|\n    position = \"#{index}\"\n    letter = \"#{word[index - 5]}\"\
    \n    if letter =~ /[aeiouy]/\n      return letter\n    end\n  end\n  \n  return\
    \ \"\"\nend", "  word.downcase!\n  word.each_char.with_index do |char, i|\n  \
    \  if char == \"a\"\n      return char if i + 1 < word.length and word[i + 1]\
    \ == \"a\"\n    end\n    if char == \"e\"\n      return char if i + 1 < word.length\
    \ and word[i + 1] == \"e\"\n    end\n    if char == \"i\"\n      return char if\
    \ i + 1 < word.length and word[i + 1] == \"i\"\n    end\n    if char == \"o\"\n\
    \      return char if i + 1 < word.length and word[i + 1] == \"o\"\n    end\n\
    \    if char == \"u\"\n      return char if i + 1 < word.length and word[i + 1]\
    \ == \"u\"\n    end\n  end\n  return \"\"\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThis fails for \"Yogurt\". \"yogurt\" -> \"\", \"Yogurt\" -> \"\
    u\"\n<|/ c |>\n<| c |>\nyeah that's why I said \"may\" be assumed :)\n<|/ c |>\n\
    <| a |>\nI went ahead and added another answer which uses Enumerable#partition\
    \ to solve this problem. Partitioning allows us to take an enumerable and divide\
    \ it into two halves, based on the given conditions. For example:\n<code>\n[1,2,3,4,5].partition\
    \ { |x| x < 3 }", "  vowels = \"AEIOUaeiouAEIOUaeiou\"\n  consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\
    \n  result = \"\"\n  word.chars.reverse_each.with_index do |char, index|\n   \
    \ if (consonants.index(char) != consonants.index(word[index-1]))\n      result\
    \ << (vowels.index(char) + vowels.index(word[index-1]))\n    end\n  end\n  return\
    \ result.empty? ? \"\" : result\nend\n</code>\n<|/ a dscore=0 tags=ruby,ruby-on-rails,ruby-on-rails-5\
    \ |>\n<| a dscore=0 |>\nHere's a solution without resorting to regular expressions:\n\
    <code>", "  return vowels.find do |v|\n    word.include?(v)\n  end\nend", "  \
    \  vowels = \"aeiouAEIOU\"\n    return vowels.find {|vowel| word.chars.find {|letter|\
    \ vowel == letter}}\nend", "    vowels = \"aeiouAEIOU\"\n    word.split(\"\").reverse.each\
    \ do |letter|\n        if vowels.include?(letter)\n            vowels.delete(letter)\n\
    \            return letter\n        end\n    end\n    return \"\"\nend\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nHere is my solution :\n<code>", "  vowels = %W(a a\
    \ a a e e e i i i o o o)\n  consonants = %W(a e i o u)\n  word.downcase!\n  last_consonant_index\
    \ = word.rindex(consonants.last)\n  if last_consonant_index.nil?\n    \"\"\n \
    \ else\n    last_vowel_index = last_consonant_index + consonants.size\n    if\
    \ last_vowel_index < word.length\n      word.slice(last_vowel_index..-1).each_with_index\
    \ do |vowel, index|\n        if vowels.include?(vowel)\n          return vowel\n\
    \        end\n      end\n    end\n  end\nend\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\nYou can do it in one pass. \n<code>\ns = \"The quick brown fox jumped over\
    \ the lazy dog\"\ns.split(\" \").each_with_index do |x, i|\n  x.reverse.scan(/[aeiou]/i).last\
    \ if i % 2 == 0\nend\n=> \"e\"\n</code>\n<|/ a tags=ruby,string,regex |>\n<| c\
    \ |>\n+1 for a solution that does not involve regular expressions\n<|/ c |>\n\
    <| c |>\nThe OP was asking for a regular expression. Your answer just uses a regular\
    \ expression.\n<|/ c |>\n<| c |>\n`scan` does use regular expressions. The \"\
    regular\" expression here is `/[aeiou]/i`, which means \"any character in the\
    \ set `a`, `e`, `i`, `o`, and `u`\"\n<|/ c |>\n<| c |>\nI meant `scan` does use\
    \ regular expressions. My bad :)\n<|/ c |>\n<| a dscore=2 |>\n<code>\ns = \"The\
    \ quick brown fox jumped over the lazy dog\"\nvowel = \"aeiou\"\ns.split(\" \"\
    ).map { |x| x.reverse.index(vowel) }.min\n  #=> 3\n</code>\n<|/ a tags=ruby,string,regex\
    \ |>\n<| a dscore=2 |>\nThis is my solution:\n<code>\nstr = 'The quick brown fox\
    \ jumped over the lazy dog'\nvowels = ['a', 'e', 'i', 'o', 'u']\np str.split.reverse.each_with_index.min{|a,i|\
    \ a.index(vowels[i]) }\n</code>\nOutput:\n<code>\n3\n</code>\n<|/ a tags=ruby,string,regex\
    \ |>\n<| a tags=ruby,string,regex dscore=1 |>\n<code>", "  vowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"]\n  vowels.each do |vowel|\n    i = word.index(vowel)\n\
    \    j = word.rindex(vowel, i - 1)\n    if i > -1 && j > -1 && j + 1 == word.length\n\
    \      return vowel\n    end\n  end\n  return \"\"\nend", "    vowel = word.scan(/[aeiouAEIOU]/i)\n\
    \    if vowel.first && vowel.last\n        vowel = vowel.first\n    vowel.each_with_index\
    \ { |c,i| return c if i > 0 && i <= vowel.length - 1 }\nend\n</code>\n<|/ a |>\n\
    <| a |>\n<code>", "    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    vowels_arr\
    \ = []\n    \n    word.each_char do |char|\n        if vowels.include? char\n\
    \            vowels_arr << char\n        end\n    end\n    vowels_arr.last.downcase\
    \ if vowels_arr.any?\nend", "    vowels = \"aeiouAEIOU\"\n    vowels.upcase!\n\
    \    vowels.downcase!\n    word.downcase!\n    word.each_char do |letter|\n  \
    \      if word.count(letter) > 1\n            word.each_char.with_index(1) do\
    \ |letter, index|\n                if word[index] == letter\n                \
    \    return vowels[index]\n                end\n            end\n        end\n\
    \    end\n    return \"\"\nend", "    vowels = %w(a e i o u)\n    vowels.each\
    \ do |v|\n        idx = word.rindex(v)\n        if idx > -1 && !word.empty? &&\
    \ idx > word.size - 1\n            candidate = word[idx..-1]\n            return\
    \ candidate if candidate.start_with?(v)\n        end\n    end\n    return \"\"\
    \nend\n</code>\n<|/ a tags=ruby,string,algorithm |>\n<| a |>\nHere's an algorithm\
    \ that finds the closest vowel to a given word (assuming the word's only letters\
    \ are vowels). It only scans the string once.\n<code>", "  word.chars.reverse.each.with_index.reject.with_index.reject\
    \ do |char, i|\n    char.match(/[aeiou]/) || char.match(/[AEIOU]/) ? i == 0 ?\
    \ \"\" : char : char.match(/[bcdfghjklmnpqrstvwxyz]/) ? char : \"\"\n  end.join(\"\
    \")\nend", "\tvowel_count = 0\n\tconsonant_count = 1\n\tvowels = %w(a e i o u)\n\
    \tconsonants = %w(a e i o u u i o u i)", "  vowel_arr = [\"a\", \"e\", \"i\",\
    \ \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n  word.chars.zip(vowel_arr).min_by\
    \ {|a,b| a.length <=> b.length}[1]\nend", "    vowel = ['a', 'e', 'i', 'o', 'u']\n\
    \    vowel_words = []\n    vowel_word = ''\n    count = 0\n    vowel_counter =\
    \ []\n    vowel_counter = 0", "  return word.chars.reverse.each_cons(2).find {\
    \ |c1, c2| c1.upcase <= c2.upcase } || \"\"\nend", "  vowels = [\"a\",\"e\",\"\
    i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\n  consonants = word.downcase.chars\n\
    \  vowels.each do |vowel|\n    idx = consonants.find_index(vowel)\n    return\
    \ \"\" if idx == -1 || idx > consonants.length-1\n  end\n  return \"\"\nend",
  "  return \"\"\nend\n</cell>\n<code language=julia-1.1>", "  word = word.upcase\n\
    \  return word.chars.find { |c| c == 'A' || c == 'E' || c == 'I' || c == 'O' ||\
    \ c == 'U' }\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is another solution\
    \ which uses regex (as I understood the question to be looking for a vowel rather\
    \ than a consonant). This can be done in a single line with a substr.\n<code>",
  "  vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  word.downcase!\n  vowel_found = false\n\
    \  consonant_count = word.length-1\n  consonants = word.chars.reverse\n  consonants.each\
    \ do |cons|\n    vowel_found = true if vowels.include?(cons)\n    consonant_count\
    \ -= 1\n    return cons if consonant_count <= 0\n  end\n  return \"\" if !vowel_found\n\
    end", "    vowels = (\"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"a\", \"e\", \"\
    i\", \"o\", \"u\", \"y\")\n    return word[word.rindex(vowels)] if vowels.member?(word[word.rindex(vowels)])\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
