name: HumanEval_22_filter_integers
language: rb
prompt: "# Filter given list of any python values only for integers\n# >>> filter_integers(['a',\
  \ 3.14, 5])\n# [5]\n# >>> filter_integers([1, 2, 3, 'abc', {}, []])\n# [1, 2, 3]\n\
  def filter_integers(values)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_integers\n\
  \    candidate = method(:filter_integers)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([4, 9], candidate.call([4, {}, [], 23.2, 9, \"adasd\"]))\n   \
  \ assert_equal([3, 3, 3], candidate.call([3, \"c\", 3, 3, \"a\", \"b\"]))\n  end\n\
  end\n"
completions: ["    values.map! do |v|\n      v.is_a?(Integer) ? v : nil\n    end\n\
    \    values.compact!\n    values\n  end", "  values.map! { |value| value.to_i\
    \ }\n  values.select { |value| value.is_a?(Integer) }\nend", "  return values.filter\
    \ {|value| is_integer(value)}\nend", "  # This works exactly like 'filter(is_integer,\
    \ values)'\n  # but is much faster.\n  return [i for i in values if is_integer(i)]\n\
    end", "  values.reject(&:empty?)\n  values.reject(&:blank?)\n  values.reject(&:nil?)\n\
    \  values.compact.uniq\nend", "  values.map! { |v| v.to_i if v.respond_to?(:to_i)\
    \ }\n  values.compact!\n  values\nend", "  filter_integer_procs = Proc.new { |v|\
    \ v.is_a?(Integer) }\n  values.select { |v| filter_integer_procs.call(v) }\nend",
  "  values.map! { |v| v ? Integer(v) : v }\nend", "  filtered_values = []\n  values.each\
    \ do |value|\n    if value.is_a?(Integer)\n      filtered_values << value\n  \
    \  end\n  end\n  return filtered_values\nend\n</code>\nHope this helps.\n<|/ a\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\nI believe you have a typo in your code,\
    \ you wrote:\n<code>", "    filter_value = lambda value: (value if value.is_a?\
    \ Integer else nil)\n    values.grep(filter_value)\nend", '  return filter(is_integer,
    values)', "  values = filter(false, values)\n  values = filter_value(Integer,\
    \ values)\n  values = values.uniq\n  values.compact!\n  values\nend", "  values.each\
    \ do |value|\n    next if value.is_a? Numeric\n    puts \"Invalid value: #{value}\"\
    \n  end\n  values\nend", "  values.select! { |value| value.is_a?(Numeric) && value.to_i.between?(1,\
    \ 2**63) }\n  values.compact\nend", "  filtered = []\n  filters.each do |filter|\n\
    \    next if filter.class != IntegerFilter\n    values &= filter.values\n  end\n\
    \  filtered\nend", "  values.each do |value|\n    next if value.is_a?(String)\
    \ || value.is_a?(Symbol)\n    raise ArgumentError.new('Only integers are allowed\
    \ in arrays')\n  end if values.length == 1\n  values.compact\nend", "  return\
    \ values.filter{|v| v.is_a?(Integer)}\nend", "  values.reject(&:odd?)\nend", " \
    \ values.compact.grep(/^\\-?\\d+$/)\nend", "  filtered = []\n  for i in values\n\
    \    if type(i) == Integer or i.class == Integer\n      filtered << i\n    end\n\
    \  end\n  return filtered\nend", "  values.reject {|v| v.is_a? Integer }\nend",
  "  values.select { |value| value.is_a?(Integer) }\nend\n</cell>\n<cell>", "  values.reject!{\
    \ |v| v.to_i rescue nil }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThanks, I\
    \ was looking for something which could reject all objects which didn't respond\
    \ to 'to_i'.\n<|/ c |>\n<| c |>\nThis doesn't reject objects which can't be coerced\
    \ into integers, for example `[true, false, nil, \"abc\"]`\n<|/ c |>\n<| c |>\n\
    The question was about rejecting strings which couldn't be cast into integers.\
    \ How does this help?\n<|/ c |>\n<| c |>\nThe question is \"Filter given list\
    \ of any python values only for integers\" so I thought this was appropriate.\n\
    <|/ c |>\n<| c |>\nIf it was, then you should have said so.\n<|/ c |>\n<| a |>\n\
    A small modification to the previous answer, in order to allow objects that respond\
    \ to 'to_i':\n<code>", "  values.grep(Integer).to_a\nend", "  return [value for\
    \ (value in values if value.is_a?(Integer))]\nend", "  values.collect { |value|\
    \ Integer(value) unless value.is_a?(String) }\nend", "  result = []\n  values.each\
    \ do |value|\n    next if value.is_a?(Numeric)\n    result.push(value)\n  end\n\
    \  result\nend", "  values.each { |v| v.is_a?(Integer) ? v : nil }\nend\n</code>\n\
    <|/ a tags=hash,arrays,ruby dscore=1 |>\n<| a dscore=1 tags=hash,arrays,ruby |>\n\
    <code>\nhash = {:a => 1, :b => 2}\n</code>\nAnd if you want a recursive solution\
    \ (as I understood):\n<code>", "  values.select { |value| value.is_a?(Integer)\
    \ }\nend", "  filter_value = values.to_int\n  filtered = values.dup\n  filtered.reject!\
    \ { |value| filter_value and value.is_a?(Integer) }\n  filtered\nend", "  numbers.each\
    \ do |value|\n    break if Integer(value) != value rescue nil\n    values << value\n\
    \  end\n  values\nend\n</code>\n<|/ a dscore=2 tags=ruby,arrays,integer |>\n<|\
    \ a |>\n<code>", "  values.collect!{ |value| value.to_i }\n  values\nend", " \
    \ values.each do |value|\n    next value unless value.is_a? Integer\n    yield\
    \ value\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThat's a nice solution that uses\
    \ `Array#select`, but it does unnecessarily iterate the array twice. One could\
    \ improve on it by caching `values.is_a?(Numeric)` in a variable.\n<|/ c |>\n\
    <| a tags=ruby,arrays dscore=4 |>\nIn Ruby 2.4 you can use the take_while method,\
    \ which iterates through an array by taking elements until the given block returns\
    \ false.\n<code>\n[1, 2, 3, ..., n].take_while { |i| i % 2 == 0 }\n</code>\n<|/\
    \ a |>\n<| a |>\nAnother nice way to solve this problem is to use Enumerable#grep!:\n\
    <code>\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]", "  values.select { |v| v.is_a?(Integer)\
    \ }\nend", "  return values.collect {|v| v if (Integer === v) }\nend", "  values.select!\
    \ do |value|\n    value.is_a?(Integer) or (value.is_a?(Numeric) && value.to_i\
    \ == value)\n  end\nend", "  values.grep(/^-?\\d+$/)\nend", "  values.map(&method(:to_i))\n\
    end\nalias_method :filter_integers_if_integer, :filter_integers\nfilter_integers_if_integer\
    \ :integer?, :to_i", "  values.select! {|val| val.class == Fixnum}\n  values\n\
    end", "  values.reject { |value| value.is_a? Integer }\nend", "  values.select!\
    \ { |val| val.to_s.include?(\"^-?\\d+$\") }\n  values\nend", "  values.each {\
    \ |value| value.is_a?(Integer) ? return true : false }\n  []\nend", "\tvalues.each\
    \ do |value|\n\t\tif value.is_a?(Fixnum)\n\t\t\tyield(value)\n\t\tend\n\tend\n\
    end", "    values.each { |v| return v if v.is_a? Integer }\n    []\nend", "  \
    \  values.select!{|value| value.is_a?(Integer) || value.is_a?(Fixnum)}\nend",
  "  filtered = []\n  values.each do |v|\n    next if v.class == String\n    next\
    \ if v % 1 == 0 #ignore any that aren't integers\n    filtered << v\n  end\n \
    \ filtered\nend", "  filtered = []\n  numbers.each do |value|\n    if value.to_i\
    \ == value\n      filtered << value\n    end\n  end\n  filtered\nend", "  values.compact.grep(/^\\\
    d+$/)\nend", "  values.map!(&:to_i)\n  values.compact!\n  values\nend", "\tresult\
    \ = values.clone\n\t\n\ti = 0\n\twhile i < values.size\n\t\tvalue = values[i]\n\
    \t\t\n\t\tunless value.is_a?(Numeric)\n\t\t\tresult.delete(values[i])\n\t\t\t\
    i += 1\n\t\telse\n\t\t\tif value.to_i == value.to_i\n\t\t\t\tresult.delete(values[i])\n\
    \t\t\t\ti += 1\n\t\t\telse\n\t\t\t\ti += 1\n\t\t\tend\n\t\tend\n\tend\n\t\n\t\
    return result\nend", "  values = values.to_a\n  return values - values.compact.reject(&:nan?).uniq.to_a\n\
    end", "  integer = nil\n  integers = []\n  numbers.each do |number|\n    next\
    \ if number.is_a?(String)\n    integer ||= number\n    if number == integer\n\
    \      integers.push(integer)\n      integer = nil\n    else\n      integer =\
    \ nil\n    end\n  end\n  integers\nend\n</code>\n<|/ a tags=ruby,arrays,enumerable\
    \ |>\n<| c |>\nNice solution but it's worth noting that it modifies the `input`\
    \ array, and that this is unnecessary: `input.each { |v| input.delete(v) }`. You\
    \ could instead simply `return input.dup` in the first block (since we're not\
    \ doing anything with the value).\n<|/ c |>\n<| c |>\nYes, that is a nice improvement.\
    \ I'll add that as an improvement to the answer.\n<|/ c |>\n<| c |>\nI really\
    \ like how you think of it, I like the use of recursion, and I like how you think\
    \ of my solution, which is similar to yours, but also using recursion, which is\
    \ more elegant IMO. I just have a couple questions though: ", "  values.select\
    \ { |v| v.is_a?(Integer) }\nend", "  numbers.map(&:to_i).compact\nend\n</code>\n\
    And here's a test suite with some sample output which demonstrates how it works:\n\
    <code>\nrequire 'test/unit'", "  values.select {|x| x.to_i.between?(0, Float::INFINITY.to_i)\
    \ }\nend", "  numbers.each do |value|\n    if value.is_a?(Integer)\n      values\
    \ << value\n    end\n  end\n  values\nend", "  values.each { |value| next if !value.is_a?(Integer)\
    \ }\n  values\nend", "  values.each do |value|\n    if value.is_a?(Integer) ||\
    \ value.is_a?(Fixnum)\n      yield(value) if block_given?\n    else\n      next\n\
    \    end\n  end\nend", "    values.select { |value| value.is_a?(Fixnum) }\nend",
  "  values.map { |v| v.to_i if v.is_a?(Integer) }\nend", "  values.grep(/^[0-9]+$/)\n\
    end", "  values.compact.select { |value| value.class == Integer }\nend", "  values.reject\
    \ {|value| value.is_a?(Numeric)} if RUBY_VERSION >= \"1.9\"\n  values.reject {|value|\
    \ value.is_a?(Float)} if RUBY_VERSION >= \"1.9\"\n  values\nend", "  values.select{\
    \ |v| v.is_a?(Fixnum) }\nend", "  values.select!{ |value| value.kind_of?(Fixnum)\
    \ }\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nMy solution (inspired by Randy\
    \ Peebel's answer) is to transform the array of integers into an array of pairs\
    \ of integers, where the 1st integer is the index of the array and the 2nd is\
    \ the value at the index:\n<code>", "  values.select! {|v| v.is_a? Integer}\n\
    \  values\nend", "  values.map! { |v| Integer(v) unless v.is_a?(String) }\n  values\n\
    end", "  values.select { |value| value.is_a?(Integer) }\nend", "  numbers.each\
    \ do |value|\n    return value if is_integer(value)\n  end\n  nil\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\n`return nil` would suffice as well\n<|/ c |>\n<|\
    \ c |>\n`return nil` is equivalent to `return false` which is equivalent to `return\
    \ false`.  You can just write `return value` here.  No need to `nil` and then\
    \ `return false` at the end.\n<|/ c |>\n<| a tags=ruby |>\nI wanted to use something\
    \ like this for a case where I needed to return an undefined value, and allow\
    \ me to pass it a proc (so that I could use it as an option to a method and have\
    \ the return value be the result of running the proc).\nHere's a method that returns\
    \ a default value if the value passed in doesn't respond to to_i, or if it responds\
    \ to to_s and includes the strings \"nil\" or \"false\".\n<code>", "  values.select\
    \ { |v| v.is_a? Integer }\nend", "  values.map! do |value|\n    value.to_i if\
    \ value.is_a?(Integer)\n  end\n  values\nend", "  values.each do |value|\n   \
    \ next if value.kind_of?(Float)\n    next unless value.kind_of?(Integer)\n   \
    \ yield value\n  end\nend", "  values.delete_if { |value| value.to_s =~ /^(-?\\\
    d+|-?0x[a-f\\d]+)/i }\nend", "  values.compact.map { |value| value.to_i }\nend",
  '  return [e for e in values if type(e) == int or type(e) == float]', "  values.select\
    \ {|v| v.is_a?(Integer) }\nend", "  return [i for i in values if isinstance(i,\
    \ int)]\nend", "  values.select!{|value| value.is_a?(Integer)}\n  values\nend",
  "  return [i for i in values if isinstance(i, int)]\nend", "  values.reject { |value|\
    \ value.is_a? Integer }\nend", "  return [i for i in values if isinstance(i, int)]\n\
    end", "  # Remove any None values that may be in the list\n  values = [v for v\
    \ in values if not v.nil?]\n  # Remove any values that are not integers\n  values.select\
    \ do |value|\n    value.is_a?(Integer)\n  end | []\nend", "  filtered = []\n \
    \ values.each do |value|\n    next if value.is_a?(Float) or value.is_a?(BigDecimal)\n\
    \    next unless value.is_a?(Integer) || value.is_a?(Fixnum)\n    filtered <<\
    \ value\n  end\n  filtered\nend", "    values.each do |value|\n      return value\
    \ unless value.is_a?(Integer)\n    end", "  values.map! do |value|\n    if value.is_a?(Integer)\
    \ or value.is_a?(Numeric)\n      value\n    else\n      begin\n        value.to_i\n\
    \      rescue\n        false\n      end\n    end\n  end\n  values\nend", "  numbers.each(values)\
    \ do |value|\n    next value unless value.is_a?(Integer)\n    yield value\n  end\n\
    end", "  values.select { |v| v.is_a?(Integer) }\nend", "  values.map do |value|\n\
    \    Integer(value) if value.is_a?(String) && value.to_s =~ /^\\-?\\d+$/\n  end\n\
    end", "  values.each { |v| v.is_a?(Fixnum) ? yield(v) : yield(v) if v.is_a?(Fixnum)\
    \ }\nend", "  values.map! do |v|\n    case v\n    when Integer\n      v\n    when\
    \ Float\n      v\n    else\n      raise ArgumentError, \"Expected Integer, Float,\
    \ String, Symbol, Object or nil, got #{v.class}\"\n    end\n  end\n  values\n\
    end", "  values.reject { |v| v.is_a?(Integer) }\nend", "  filtered = []\n  values.each\
    \ do |value|\n    next if !value.is_a?(Integer)\n    filtered << value\n  end\n\
    \  filtered\nend\n</pre>\n</dd>\n</dl>\n<h3 id=\"to_json\">to_json</h3>\n<pre>",
  "  values.each do |value|\n    case value\n    when Integer\n      yield(value)\n\
    \    else\n      next\n    end\n  end\nend", "  values.each do |value|\n    return\
    \ value if value.is_a?(Integer)\n  end\n  []\nend\n</code>\n<|/ a |>\n<| a tags=ruby,functional-programming,arrays\
    \ dscore=3 |>\nIf you find yourself doing this often, you're probably doing it\
    \ wrong. You should probably be using a Hash instead so you don't have to keep\
    \ looping over the values. Here's how I'd do it:\n<code>", "  filtered = []\n\
    \  values.each do |value|\n    value = value.to_i\n    next if value.nan?\n  \
    \  filtered << value\n  end\n  filtered\nend", "  values.select do |value|\n \
    \   value.is_a?(Integer) || value.is_a?(Fixnum) || value.is_a?(Bignum)\n  end\n\
    end", "  # Convert to an array first so we filter out non-integers\n  values =\
    \ to_array(values)\n  # Filter out non-integers\n  values.delete(values.select\
    \ { |v| v.to_f % 1 != 0 })\nend", "  # Return list of filtered integer values\n\
    \  return values.reject { |v| v.to_i == v }\nend", "  values.select! {|value|\
    \ value.is_a?(Integer)}\nend", "  numbers.each do |value|\n    return values if\
    \ value.is_a?(Integer) || value.nil?\n  end\n  nil\nend", "  filtered = []\n \
    \ values.each do |value|\n    value = Integer(value) if value.is_a? String\n \
    \   filtered << value if value.is_a? Integer\n  end\n  filtered\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThank you very much for the detailed answer! This was very\
    \ helpful in figuring out what was wrong with my code.\n<|/ c |>\n<| a tags=ruby-on-rails,ruby\
    \ dscore=0 |>\nFor future readers, if someone is using Rails and trying to create\
    \ a hash by merging two or more hashes, here's the code that I used:\n<code>",
  "  return values.map { |v| v.to_i if v.respond_to?(:to_i) }\nend", "  filtered =\
    \ []\n  values.each do |value|\n    next if value.nil?\n    next if value.is_a?(String)\
    \ || value.is_a?(Symbol) || value.is_a?(Fixnum)\n    next if value !~ /^\\-?\\\
    d+$/\n    filtered << value\n  end\n  filtered\nend", '  return filter(is_integer,
    values)', "  values.compact.select{|value| value.to_i < value.to_i rescue nil}\n\
    end", "  values.each { |value| value.is_a?(Integer) ? yield(value) : yield(nil)\
    \ }\nend", "  values.collect!\n  values.compact.each{|value| value.is_a?(Numeric)\
    \ ? value : nil}\n  values\nend", "  values.map! {|x| x.is_a?(Fixnum) ? x : nil\
    \ } # coerce to nil\n  values.select {|x| x.is_a?(Fixnum)}\nend\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\n`Enumerable#map` was added in Ruby 2.1, and it is an\
    \ alias for `Enumerable#collect`. `map!` is an alias for `collect!`.  `map` was\
    \ added after 2.2.\n<|/ c |>\n<| c |>\n`map` is an alias of `collect` in Ruby\
    \ 2.1. `map!` was added in Ruby 2.2.\n<|/ c |>\n<| c |>\nNice answer, but `map`\
    \ does **not** return nil if no element was found; `map!` does. So instead of\
    \ `select { |x| x.is_a?(Integer) }` or `reject { |x| x.is_a?(Integer) }` use `select\
    \ { |x| x.is_a?(Fixnum) }` or `reject { |x| x.is_a?(Fixnum) }`.\n<|/ c |>\n<|\
    \ c |>\nThanks for the tip. I've updated the answer. :)\n<|/ c |>\n<| c |>\n`select\
    \ { |x| x.is_a?(Integer) }` can be simplified to `select(&:is_a?(Integer))` which\
    \ does the same thing.\n<|/ c |>\n<| a tags=ruby,arrays |>\nI believe that filter\
    \ is now deprecated, you can use reject instead.\n<code>\n[1, 2, 3, nil, nil,\
    \ 4].select { |x| x.nil? || x.is_a?(Integer) }\n</code>\n<|/ a dscore=5 |>\n<|\
    \ a dscore=5 |>\nRuby >= 2.2\n<code>\narray.select { |x| x.is_a?(Fixnum) }\n</code>\n\
    See Enumerable module for all the available methods that you can apply on arrays.\n\
    <|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nIn Ruby 2.2, you can use\
    \ the .select method on the array:\n<code>\na = [1, 2, \"3\", 4, 5]\na.select\
    \ { |x| x.class == Integer }", "  result = values.dup\n  result.each_index do\
    \ |i|\n    if result[i].is_a? Integer\n      result.delete_at(i)\n      next\n\
    \    end\n    break\n  end\n  result\nend\n</code>\n<|/ a |>\n<| c |>\nThe `each_index`\
    \ method is a great addition to ruby!\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  values.map(&:to_i)\nend", "  return [value for value in values\
    \ if is_integer(value)]\nend", "  return values.filter {|v| v.is_a?(Fixnum)}\n\
    end", "  values.grep(Integer).map(&:to_i)\nend", "  values.select { |value| value.is_a?(Integer)\
    \ }\nend", "  filtered_values = []\n  values.each do |value|\n    if value.is_a?(Integer)\
    \ && value.is_a?(Numeric)\n      filtered_values << value\n    end\n  end\n  filtered_values\n\
    end", "  values.map! { |value| value.to_i }\n  values\nend", "  values.map { |v|\
    \ v.to_i }\nend", "  values.compact.map { |v| v.to_i }\nend", "  values.select\
    \ { |v| v.is_a?(Integer) }\nend", "  return [i for i in values if type(i) == int]\n\
    end", "  values.map! do |value|\n    Integer(value)\n  end", "  return values.select\
    \ { |value| value.is_a?(Fixnum) }\nend", "  values.compact.select { |v| v.is_a?(Integer)\
    \ }\nend", "  numbers.each_with_index do |v, i|\n    return values[i] if v.is_a?\
    \ Integer\n  end\n  nil\nend", "  values.select { |x| x.is_a?(Integer) }\nend",
  "  values.each { |value| value.is_a?(Integer) ? true : false }\n  values\nend",
  "  integer = values.map { |value| value.to_i }\n  integer\nend", "  values.reject!\
    \ {|v| v.is_a?(Numeric) || v.is_a?(Fixnum)}\n  values\nend", "  values.compact.select{|v|\
    \ v.is_a?(Integer)}\nend", "  values.collect do |value|\n    value if value.is_a?(Integer)\
    \ || value.is_a?(Float)\n  end\nend", "  values.select { |v| v.is_a? Integer }\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis code can be rewritten to avoid\
    \ using 'select' by passing a block to the 'map' method: values.map { |v| v.is_a?\
    \ Integer }\n<|/ c |>\n<| a tags=ruby,arrays |>\nAnother way is to use .select\
    \ method, but remember, that it is mutating the original array\n<code>", "  result\
    \ = []\n  filtered_values = []\n  values.each do |value|\n    if value.is_a?(Integer)\n\
    \      filtered_values << value\n    else\n      result << value\n    end\n  end\n\
    \  return result unless filtered_values.empty?\n  filtered_values\nend", "  values.select\
    \ do |value|\n    value.is_a?(Integer) or value.to_s.match(/[^0-9]*/)\n  end\n\
    end", "  return values.filter {|i| i.is_a? Integer}\nend", "  values.select {\
    \ |v| Integer(v) == v }\nend", "  values.compact.map {|i| i.to_i}\nend", "  values.grep(Integer).map(&:to_s)\n\
    end", "  numbers.each do |v|\n    next if v.nil? || v.is_a?(Integer)\n    values.delete(v)\n\
    \  end\n  values\nend", "  values.each_with_index do |value, index|\n    next\
    \ index if value.is_a?(Numeric)\n    yield index\n  end\nend", "  values = values.to_a\n\
    \  values.compact.select(&:instance_of?(Integer))\nend", "  filtered = []\n  filtered\
    \ = values.select { |value| value.is_a? Integer }\n  filtered\nend", "    values.reject\
    \ { |v| v.to_i.zero? }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a |>\n\
    Another solution:\n<code>", "  values.select! {|v| v.is_a?(Integer) || v.is_a?(BigDecimal)}\n\
    \  values\nend", "  result = {}\n  values.each do |value|\n    if value.is_a?(Integer)\
    \ || value.is_a?(Fixnum) || value.is_a?(Float)\n      result[value] = true\n \
    \   end\n  end\n  result.values\nend\n</code>\nAs an aside, Ruby 1.9 has Enumerable#with_object.\
    \ This gives you a nice way to add an element to a hash without having to test\
    \ for existence.\n<code>\nhash = {}\nhash.with_object({}) { |h, kv| h[k] = kv\
    \ }", "  values.map! do |value|\n    next value unless value.is_a?(Integer) ||\
    \ value.is_a?(Numeric)\n    value\n  end\n  values\nend", "  return values.filter(&:is_a?\
    \ Integer)\nend", '  return [e for e in values if is_integer(e)]', "  values.select\
    \ {|value| value.kind_of?(Fixnum) }\nend", "  numbers.each_with_index do |n, i|\n\
    \    return n if n.is_a?(Integer) || n.to_s.strip.empty?\n  end\n  []\nend", " \
    \ return [i for i in values if Integer(i).is_integer?]\nend", "  return values.inject([],\
    \ :<<)\nend", "  values = values.map {|v| v.to_i if v.is_a?(Integer) }\n  values.compact\n\
    end", '  return filter(lambda v: isinstance(v, Integer), values)', "  ret = []\n\
    \  for x in values\n    if Integer(x).kind_of? Integer\n      ret << x\n    end\n\
    \  end\n  ret\nend", "  values.collect! { |v| v.is_a?(Integer) ? v : nil }\n \
    \ values.compact!\n  values\nend", "  result = []\n  values.each { |value| \n\
    \    next if value.is_a?(String) && value =~ /^[-+]?[0-9]+$/\n    result.push\
    \ value\n  }\n  result\nend", "  return values.grep(Integer).flatten.compact\n\
    end", "  values.compact.grep(/^-?\\d+$/)\nend", "  return values.grep(::Integer)\n\
    end", "  integers.each do |value|\n    break if values.include?(value)\n  end\n\
    \  values\nend", "    values.select! do |value|\n        value.is_a?(Integer)\
    \ ? true : nil\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nThis should be the accepted\
    \ answer. Great answer, it works like a charm!\n<|/ c |>\n<| a dscore=5 |>\nTry\
    \ something like this:\n<code>\narr.collect{ |x| x.to_i }\n</code>\n<|/ a tags=arrays,ruby,type-conversion,integer,string\
    \ |>\n<| a |>\n<code>", "  values.each_index do |i|\n    next unless values[i]\
    \ == values[i].to_i\n    values.delete_at(i)\n  end\n  values\nend", "  values.select\
    \ { |value| value.is_a?(Fixnum) }\nend", "  values.select { |v| v.is_a? Integer\
    \ }\nend", "  values.select! { |value| value.is_a?(Integer) }\n  values\nend",
  "  values.compact.select do |value|\n    value.kind_of?(Integer) || value.nil?\n\
    \  end\nend", "  values.map!\n  values.select! { |v| v.is_a?(Integer) }\n  values.compact!\n\
    \  values\nend", '  return filter(is_integer, values)', "    values.each { |v|\
    \ v.is_a?(Integer) ? yield v : nil }\nend", "  values.each { |v| v.kind_of?(Integer)\
    \ ? values.delete v : nil }\n  values\nend", "  return [x for x in values if x.is_a?\
    \ Integer]\nend", "  values.grep(/^\\d+$/)\nend", "  values.map { |value| value.to_i\
    \ }\nend", "    integers = []\n    values.each do |value|\n        next if value.is_a?(Integer)\n\
    \        integers << value\n    end\n    return integers\nend", "  values.select!\
    \ {|v| v.is_a? Integer}\nend", "  # Filter out all non-integers\n  values.reject\
    \ do |v|\n    v !~ /^-?[0-9]+$/\n  end\nend", "  filtered = []\n  values.each\
    \ do |value|\n    next if value.is_a?(Hash) || value.is_a?(Array)\n    next if\
    \ value.is_a?(Float)\n    next if value.is_a?(TrueClass) || value.is_a?(FalseClass)\n\
    \    next if value.is_a?(BigDecimal)\n    next if value.is_a?(Numeric)\n    filtered\
    \ << value\n  end\n  filtered\nend", "  values.each do |value|\n    if value.is_a?(Integer)\n\
    \      yield value\n    end\n  end\n  nil\nend", "  values.map { |value| Integer(value.to_i)\
    \ }\nend", "  values.map! do |value|\n    if value.is_a? Integer\n      value\n\
    \    elsif value.is_a? Float\n      value.round\n    end\n  end\n  values\nend",
  "    integers = []\n    count = 0\n    for value in values\n        if value.is_a?\
    \ Integer\n            integers[count] = value\n            count += 1\n     \
    \   end\n    end\n    return integers\nend\n</code>\nAnd finally we write an extension\
    \ module to apply the filter:\n<code>\nmodule IntegerExtensions\n    def filter_integers!\n\
    \        self.class.filter_integers(self.to_a)\n    end\nend\n</code>\nAnd now\
    \ we are ready to test our filter:\n<code>", "  values.grep(Integer).map{|v| v.to_i}\n\
    end", "  values.select! {|v| v.kind_of? Numeric}\n  values\nend", "  return values.grep(/^(-?[\\\
    d]+|-?[\\d]+\\.\\d*)$/).map{|s| s.to_i}\nend", "  result = values.dup\n  result.delete_if\
    \ { |item| not is_integer(item) }\n  result\nend", "  filtered = []\n  values.each\
    \ do |value|\n    if value.is_a? Integer || value.is_a? Fixnum\n      filtered\
    \ << value\n    end\n  end\n  filtered\nend", "  values.reject! { |value| value.to_i\
    \ != value }\nend\n</code>\n<|/ a |>\n<| c |>\nThis solution has quadratic run\
    \ time.\n<|/ c |>\n<| c |>\nThis solution has quadratic run time, also when there\
    \ are more elements in the array than there are distinct integers.\n<|/ c |>\n\
    <| c |>\nThis solution is great, but only works for integers. If you're using\
    \ strings for numbers, you have to make a new hash instead of just doing an exact\
    \ match.\n<|/ c |>\n<| c |>\nThis solution does not work when given an array containing\
    \ a mixture of integers and strings.\n<|/ c |>\n<| c |>\nCan you explain what\
    \ you mean by \"mixing\"? If you're talking about mixing numbers and strings (i.e.\
    \ \"1\" => 1, \"2\" => 2, \"3\" => 3), the solution does work. If you're talking\
    \ about mixing strings within integers, then please be more clear on what you're\
    \ talking about.\n<|/ c |>\n<| a tags=ruby,arrays,integer |>\n<code>\nnumbers\
    \ = [0,5,6,1,3,4]\nnumbers.group_by {|n| n.to_i}.map{|k,v| v.first}", "  values.collect\
    \ do |value|\n    if value.is_a? Integer\n      value\n    else\n      value\n\
    \    end\n  end\nend", "  values.collect { |value| if value.is_a? Integer then\
    \ value end }\nend", "  values.select { |value| value.is_a?(Fixnum) }\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby,enumerable,integer,arrays |>\nIf you would like to check\
    \ all integers in an array, use this:\n<code>\n[1, 1, \"1\", 1, \"1.0\", 1].is_a?(Integer)\n\
    => true\n</code>\n<|/ a dscore=5 |>\n<| c |>\nNice, simple solution\n<|/ c |>\n\
    <| a dscore=5 |>\n<code>\n[1, 1, \"1\", 1, \"1.0\", 1].is_a?(Integer)\n=> true\n\
    </code>\n<|/ a tags=ruby,enumerable,integer,arrays |>\n<| c |>\nIt would be useful\
    \ to elaborate on _why_ the solution works. What makes this code work?\n<|/ c\
    \ |>\n<| c |>\nIt is a ruby syntax that checks whether the given object is an\
    \ Integer object. Ruby will convert an integer to a string and checks whether\
    \ string representation of that object is integer, this works since String is\
    \ an Object and Integer is a class defined by Ruby.\n<|/ c |>\n<| c |>\nIt should\
    \ be noted that \"1.0\" is not considered to be an Integer unless you use Ruby\
    \ 2.6+ or Rails 4.1+\n<|/ c |>\n<| a tags=ruby,enumerable,integer,arrays |>\n\
    <code>\n[1, 1, \"1\", 1, \"1.0\", 1].all? { |e| e.is_a?(Integer) }\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nI like this answer because it is the most concise,\
    \ and because it uses the `Enumerable` method `all?`. If you're working in a Rails\
    \ project, you can just do `[1, 1, \"1\", 1, \"1.0\", 1].all?`.\n<|/ c |>\n<|\
    \ c |>\n`[1, 1, \"1\", 1, \"1.0\", 1].all?(Integer => true)`\n<|/ c |>\n<| a |>\n\
    The solution given above won't work for floats, though if you want to include\
    \ float use this.\n<code>\n[1, 1, \"1\", 1, \"1.0\", 1].all?(&:to_i.is_a?)\n</code>\n\
    <|/ a tags=ruby,enumerable,integer,arrays dscore=5 |>\n<| c |>\n`[1, 1, \"1\"\
    , 1, \"1.0\", 1].all?(&:to_i.is_a?)` returns true even for a float value, which\
    \ is wrong.\n<|/ c |>\n<| c |>\n: It returns `true` because `\"1.0\".to_i.is_a?(Fixnum)` ",
  "  return values.reject { |value| not value.is_a?(Integer) }\nend", "  values =\
    \ values.is_a?(Array) ? values.to_a : values\n  return values.select { |value|\
    \ value.is_a?(Fixnum) }\nend", "    values = to_list(values)\n    return [v for\
    \ v in values if v.isnumeric()]\nend", "  values.select do |value|\n    value.is_a?(Integer)\
    \ || value.is_a?(Fixnum)\n  end\nend", "  values.reject do |value|\n    value.is_a?(Numeric)\
    \ unless value.respond_to?(:to_int)\n  end\nend", "    values.reject { |i| not\
    \ i.is_a?(Integer) }\nend", "  integers.each do |i|\n    return i if values.index(i).nil?\n\
    \  end\n  nil\nend", "  values.map do |value|\n    value.is_a?(Integer) ? value\
    \ : nil\n  end\nend", "  return map(&:to_i, values) unless values.is_a?(Array)\n\
    \  values.select { |x| x.is_a?(Numeric) }\nend", "  values.map! do |value|\n \
    \   case value\n    when Integer\n      value\n    when TrueClass, FalseClass\n\
    \      nil\n    else\n      raise TypeError, \"Expected Integer, True or False,\
    \ got #{value.inspect}.\"\n    end\n  end\n  values\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
