name: HumanEval_105_by_length
language: rb
prompt: "# Given an array of integers, sort the integers that are between 1 and 9\
  \ inclusive,\n# reverse the resulting array, and then replace each digit by its\
  \ corresponding name from\n# \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"\
  Six\", \"Seven\", \"Eight\", \"Nine\".\n# For example:\n# arr = [2, 1, 1, 4, 5,\
  \ 8, 2, 3]   \n# -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n# -> reverse arr -> [8,\
  \ 5, 4, 3, 2, 2, 1, 1]\n# return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
  , \"Two\", \"One\", \"One\"]\n# If the array is empty, return an empty array:\n\
  # arr = []\n# return []\n# If the array has any strange number ignore it:\n# arr\
  \ = [1, -1 , 55] \n# -> sort arr -> [-1, 1, 55]\n# -> reverse arr -> [55, 1, -1]\n\
  # return = ['One']\ndef by_length(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_by_length\n\
  \    candidate = method(:by_length)\n    assert_equal([\"Eight\", \"Five\", \"Four\"\
  , \"Three\", \"Two\", \"Two\", \"One\", \"One\"], candidate.call([2, 1, 1, 4, 5,\
  \ 8, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([\"One\"\
  ], candidate.call([1, -1, 55]))\n    assert_equal([\"Three\", \"Two\", \"One\"],\
  \ candidate.call([1, -1, 3, 2]))\n    assert_equal([\"Nine\", \"Eight\", \"Four\"\
  ], candidate.call([9, 4, 8]))\n  end\nend\n"
completions: ["  return arr.sort{|a, b| b.length <=> a.length}.unshift([]).reverse\n\
    end", "  arr.sort!\n  arr.inject([]) { |result, i| result += [numbers_array[i.to_s]]\
    \ }.reverse\nend", "  sorted = arr.sort.reverse\n  sorted.each do |num|\n    if\
    \ num > 9\n      arr[num-1] = reverse[num-1]\n    end\n  end\n  arr.each do |num|\n\
    \    if num > 9\n      reverse[num-1] = num\n    end\n  end\n  return reverse\n\
    end", "  arr.sort\n  arr.reverse\n  \n  if arr.empty?\n    return []\n  elsif\
    \ arr.any? { |e| e < 1 || e > 9 }\n    return []\n  end\n  \n  new_array = []\n\
    \  \n  (0...9).each do |i|\n    new_array << i if arr[i] == i\n  end\n  \n  new_array\n\
    end", "  arr.sort\n  arr.reverse\n  arr.map! do |v|\n    case v\n    when 1..9\n\
    \      \"One\"\n    when 10..99\n      \"Two\"\n    when 100..999\n      \"Three\"\
    \n    when 1000..9999\n      \"Four\"\n    when 10000..99999\n      \"Five\"\n\
    \    when 100000..999999\n      \"Six\"\n    when 1000000..9999999\n      \"Seven\"\
    \n    when 10000000..9999999999\n      \"Eight\"\n    when 100000000..99999999\n\
    \      \"Nine\"\n    else\n      \"\"\n    end\n  end\n  arr\nend", "  arr.sort!\
    \ # Sort arr\n  arr.map! {|x| x == 1 ? 1 : x} # Change each number from 1 to 9,\
    \ to 10\n  arr.reverse!\n  arr.reject! {|x| x == 10} # reject every 10\n  arr\n\
    end", "  return [] if arr.empty?\n  arr = arr.sort\n  arr.reverse!\n  arr.map\
    \ { |num| one_str[num] || \"#{one_str[num]}\" }\nend", "    arr.sort!\n    arr.empty?\
    \ ? [] : arr.reverse.map { |x| [\"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\"].find { |y| y == x.to_s } }\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| a dscore=0 tags=ruby,arrays |>\nIn case someone\
    \ needs it: here's a version that works for any number in any array, and doesn't\
    \ return a new array, but modifies the original array:\n<code>", "  # Your code\
    \ goes here\n  \nend", "  arr.sort!\n  arr.reverse!\n  arr.map { |e| One.index(e.to_s)\
    \ || 'One' }\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis only works if the\
    \ array is less than or equal to 9 elements, if it has 10 elements and the first\
    \ element is less than or equal to 9 it will not work.\n<|/ c |>\n<| c |>\n, The\
    \ first element is not supposed to be less than or equal to 9 elements.  But I\
    \ see what you mean.  I believe that the problem can be solved if the first element\
    \ is less than 9.\n<|/ c |>\n<| c |>\nActually the answer still does not work\
    \ as I wanted. Your method produces the wrong output. I updated my question, I\
    \ hope it's clear now.\n<|/ c |>\n<| c |>\n, I have updated my answer. Hopefully,\
    \ it is clear now.\n<|/ c |>\n<| c |>\nIt still does not work as I wanted. Try\
    \ calling your code with \"[8, 5, 4, 3, 2, 2, 1, 1]\"\n<|/ c |>\n<| a |>\n<code>",
  "  if arr.nil? || arr.empty?\n    return []\n  end", "  return arr.reverse.compact.select\
    \ {|n| n < 10 || n > 39}\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby dscore=2\
    \ |>\nYou can do something like this. It's more efficient.\n<code>", "  \n  return\
    \ arr\nend", "  arr = arr.sort\n  arr.each { |i| i = i.to_i }\n  arr = arr.reverse\n\
    \  arr.each { |i| arr[i] = \"#{arr[i]} #{(i + 1).to_s.reverse}\" }\n  return arr\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI added a small bug to the code that\
    \ you might want to check out. Also, you should probably use `Integer` instead\
    \ of `Fixnum`\n<|/ c |>\n<| c |>\n- Yeah, good point. I realized that `i` is used\
    \ a little more than once and decided to change it to a `name` variable instead.\
    \ I was just trying to keep things simple.\n<|/ c |>\n<| c |>\nI see you fixed\
    \ the bug\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\nOne way is to use Enumerable#sort_by.\n\
    <code>\narr = [2, 1, 1, 4, 5, 8, 2, 3]\narr.sort_by { |x| x.to_i }.reverse.map\
    \ { |x| x.to_s.reverse }", "  arr.map { |x| x.to_s.split(//).reverse.map { |y|\
    \ y.to_s.split(//).map(&:to_sym).join(\" \") } }.reject { |x| x.empty? || x.include?('*')\
    \ }\nend", "  if arr.empty?\n    []\n  elsif arr.length > 1\n    arr = arr.sort\n\
    \    arr.reverse\n    arr.map {|x| [\n      \"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\n      \"Ten\", \"Eleven\"\
    , \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\",\n      \"\
    Seventeen\", \"Eighteen\", \"Nineteen\", \"Twenty\",\n      \"Twenty-one\", \"\
    Twenty-two\", \"Twenty-three\", \"Twenty-four\", \"Twenty-five\",\n      \"Twenty-six\"\
    , \"Twenty-seven\", \"Twenty-eight\", \"Twenty-nine\",\n      \"Thirty\", \"Thirty-one\"\
    , \"Thirty-two\", \"Thirty-three\", \"Thirty-four\",\n      \"Thirty-five\", \"\
    Thirty-six\", \"Thirty-seven\", \"Thirty-eight\", \"Thirty-nine\",\n      \"Forty\"\
    , \"Forty-one\", \"Forty-two\", \"Forty-three\", \"Forty-four\",\n      \"Forty-five\"\
    , \"Forty-six\", \"Forty-seven\", \"Forty-eight\", \"Forty-nine\",\n      \"Fifty\"\
    , \"Fifty-one\", \"Fifty-two\", \"Fifty-three\", \"Fifty-four\",\n      \"Fifty-five\"\
    , \"Fifty-six\", \"Fifty-seven\", \"Fifty-eight\", \"Fifty-nine\",\n      \"Sixty\"\
    , \"Sixty-one\", \"Sixty-two\", \"Sixty-three\", \"Sixty-four\",\n      \"Sixty-five\"\
    , \"Sixty-six\", \"Sixty-seven\", \"Sixty-eight\", \"Sixty-nine\",\n      \"Seventy\"\
    , \"Seventy-one\", \"Seventy-two\", \"Seventy-three\", \"Seventy-four\",\n   \
    \   \"Seventy-five\", \"Seventy-six\", \"Seventy-seven\", \"Seventy-eight\",\n\
    \      \"Seventy-nine\", \"Eighty\", \"Eighty-one\", \"Eighty-two\", \"Eighty-three\"\
    ,\n      \"Eighty-four\", \"Eighty-five\", \"Eighty-six\", \"Eighty-seven\", \"\
    Eighty-eight\",\n      \"Eighty-nine\", \"Ninety\", \"Ninety-one\", \"Nine", " \
    \ if arr.length == 0\n    return []\n  else\n    arr.sort\n    arr.reverse\n \
    \   arr.map! {|n| n % 10 == 0 ? \"#{n}\" : \"#{n}#{by_length.size - 1}\"}\n  \
    \  arr\n  end\nend", "  arr = arr.sort\n  arr.reverse\n  arr = arr.map {|x| x\
    \ =~ /^(One|Two|Three|Four|Five|Six|Seven|Eight|Nine)$/i}\n  arr.empty? ? [] :\
    \ arr\nend\n</code>\n<|/ a dscore=0 tags=sorting,ruby,arrays |>\n<| a tags=sorting,ruby,arrays\
    \ |>\nHere's my solution:\n<code>", "  arr.sort.reverse\n  arr.map! {|i| if i.zero?\n\
    \    'One'\n  elsif i.zero? && i.odd?\n    'Two'\n  elsif i.zero? && i.even?\n\
    \    'Three'\n  elsif i.zero? && i.odd? && i.even?\n    'Four'\n  elsif i.zero?\
    \ && i.odd? && i.even? && i.odd?\n    'Five'\n  elsif i.zero? && i.odd? && i.even?\
    \ && i.odd? && i.even?\n    'Six'\n  elsif i.zero? && i.odd? && i.even? && i.odd?\
    \ && i.even? && i.even?\n    'Seven'\n  elsif i.zero? && i.odd? && i.even? &&\
    \ i.odd? && i.even? && i.even? && i.odd?\n    'Eight'\n  elsif i.zero? && i.odd?\
    \ && i.even? && i.odd? && i.even? && i.even? && i.odd? && i.even?\n    'Nine'\n\
    \  elsif i.zero? && i.odd? && i.even? && i.odd? && i.even? && i.even? && i.odd?\
    \ && i.even? && i.even?\n    'Ten'\n  else\n    i.to_s\n  end}\n  arr\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| a dscore=3 |>\nTry this one:\n<code>", "  arr.sort!\n  return\
    \ arr.reverse.map { |i| i.to_s == \"-1\" ? \"\" : i.to_s[1..-1] }.compact.first\n\
    end", "  length = arr.map {|i| i.to_s.length}.sort\n  arr.map {|i| i.to_s.to_i(length[0])}.reverse\n\
    end", "    arr2 = arr.reverse\n    arr2.each do |x|\n        puts \"#{x}\"\n \
    \       if x > 9\n            puts \"#{x} is bigger than 9\"\n        elsif x\
    \ == 1\n            puts \"#{x} is equal to 1\"\n        elsif x == 9\n      \
    \      puts \"#{x} is equal to 9\"\n        elsif x != 1 && x != 9\n         \
    \   puts \"#{x} is not 1 or 9\"\n        end\n    end\n    arr2\nend", "  arr.sort\
    \ {|a, b| a <=> b}.reverse.map {|i| [\"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][i]}\nend", "  arr.sort! { |a,b|\
    \ a.length <=> b.length }\n  arr.reverse!\n  arr.map { |n| names[n]  }\nend\n\
    puts by_length(arr)", "  return arr.sort{|a, b| b - a }.map(&:reverse).map {|x|\
    \ [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\"\
    , \"Nine\"][x + 1]}\nend", "  arr.sort\n  arr.reverse\n  arr.map! {|n| [n, %w{One\
    \ Two Three Four Five Six Seven Eight Nine}].sample}\n  arr\nend", "  arr.sort!\n\
    \  arr.reverse!\n  arr.each do |d|\n    if d < 10\n      arr[d] = by_length_one[d\
    \ - 1]\n    end\n    if d > 9\n      arr[d] = by_length_two[d - 10]\n    end\n\
    \  end\n  arr\nend", "  # Your code goes here\n  ones = arr.select { |i| i > 1\
    \ && i < 9 }\n  tens = arr.select { |i| i > 10 && i < 100 }\n  hundreds = arr.select\
    \ { |i| i > 100 && i < 1000 }\n  return ones + tens + hundreds.reverse\nend\n\
    </code>\n<|/ a tags=ruby,arrays,algorithm,sorting |>\n<| c |>\nI like how you\
    \ thought about this problem and came up with something very similar at the same\
    \ time.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm,sorting |>\n<code>", "  arr.sort.reverse\n\
    \  arr.map!{|x| One[x] || Two[x] || Three[x] || Four[x] || Five[x] || Six[x] ||\
    \ Seven[x] || Eight[x] || Nine[x]} \n  return arr\nend\n</code>\n<|/ a |>\n<|\
    \ a tags=ruby,arrays dscore=2 |>\n<code>", "  arr.sort!\n  arr.reverse!\n  arr.map!\
    \ do |n|\n    if n < 10\n      \"One\"\n    elsif n < 20\n      \"Two\"\n    elsif\
    \ n < 30\n      \"Three\"\n    elsif n < 40\n      \"Four\"\n    elsif n < 50\n\
    \      \"Five\"\n    elsif n < 60\n      \"Six\"\n    elsif n < 70\n      \"Seven\"\
    \n    elsif n < 80\n      \"Eight\"\n    elsif n < 90\n      \"Nine\"\n    end\n\
    \  end\n  arr\nend", "    arr.sort!\n    arr.push(*arr[0..-2])\n    arr.reverse!\n\
    \    arr.each_with_index do |number, index|\n        arr[index] = digits[number]\n\
    \    end\n    arr\nend\n</code>\n<|/ a tags=ruby,algorithm,arrays dscore=2 |>\n\
    <| c |>\nI appreciate your efforts to post code, but I think you should not have\
    \ written the solution that was provided earlier. Your solution is much more efficient\
    \ than mine, but I find it more difficult to understand and use. I think yours\
    \ is a great solution.\n<|/ c |>\n<| c |>\nI appreciate your efforts to post code,\
    \ but I think you should not have written the solution that was provided earlier.\
    \ Your solution is much more efficient than mine, but I find it more difficult\
    \ to understand and use. I think yours is a great solution.\n<|/ c |>\n<| c |>\n\
    Your solution also works and is very similar to mine - I just prefer mine, for\
    \ no apparent reason.\n<|/ c |>\n<| c |>\nI agree. It is not clear to me what\
    \ the purpose of your code is. The code you posted is much more concise. It reads\
    \ much more like a sentence, instead of like an actual Ruby method.\n<|/ c |>\n\
    <| c |>\nI've removed my downvote and now voted your answer up. :)\n<|/ c |>\n\
    <| a tags=ruby,algorithm,arrays |>\nTry this one:\n<code>", "  arr.sort!\n  arr.reverse!\n\
    \  arr = arr.map do |n|\n    case n.to_i\n    when 1..9\n      'One'\n    when\
    \ 10..19\n      'Two'\n    when 20..29\n      'Three'\n    when 30..39\n     \
    \ 'Four'\n    when 40..49\n      'Five'\n    when 50..59\n      'Six'\n    when\
    \ 60..69\n      'Seven'\n    when 70..79\n      'Eight'\n    when 80..89\n   \
    \   'Nine'\n    else\n      nil\n    end\n  end\n  arr\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI like this solution, although I feel it is more difficult to read, even\
    \ with the comments. I'll wait a bit to see if there are other answers that would\
    \ improve the readability of the code.\n<|/ c |>\n<| c |>\nIt's a lot harder to\
    \ read, as your code is very hard to read as well. I would consider using something\
    \ other than a hash table to store that list. But yeah, it could possibly be better\
    \ with some more comments.\n<|/ c |>\n<| a dscore=1 tags=ruby,arrays,sorting |>\n\
    You could sort by length, and reverse the array:\n<code>", "  arr.sort!\n  arr.reverse!\n\
    \  arr.map! {|i| i == 1 ? arr[0] = \"One\" : i==2 ? arr[1] = \"Two\" : i==3 ?\
    \ arr[2] = \"Three\" : i==4 ? arr[3] = \"Four\" : i==5 ? arr[4] = \"Five\" : i==6\
    \ ? arr[5] = \"Six\" : i==7 ? arr[6] = \"Seven\" : i==8 ? arr[7] = \"Eight\" :\
    \ i==9 ? arr[8] = \"Nine\" : arr[i] }\n  arr\nend\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nGreat answer. It would be nice if Ruby had this nifty bit of syntax for\
    \ doing this without using a bunch of string substitutions.\n<|/ c |>\n<| c |>\n\
    , `case i; when 1..9; then arr[i] = arr[0]; break; end` would work too.\n<|/ c\
    \ |>\n<| c |>\n, I don't think `case i; when 1..9; then arr[i] = arr[0]; break;\
    \ end` works with `arr = [2, 1, 1, 4, 5, 8, 2, 3]`; it returns `[2, 1, 1, 4, 5,\
    \ 8, 2, 3]` rather than `[8, 5, 4, 3, 2, 2, 1, 1]`.\n<|/ c |>\n<| c |>\n, That's\
    \ what I've been doing. But it feels clunky. Just looking if there's a more \"\
    Ruby\" way of doing it. :)\n<|/ c |>\n<| c |>\n, OK, fair enough. :-)\n<|/ c |>\n\
    <| a tags=arrays,ruby |>\n<code>", "  arr.sort!.with_index { |x,y| y > x }\n \
    \ arr.empty? ? [] : [arr.last] + reverse_by_length(arr[0...-1]) \nend", "  result\
    \ = []\n  if arr.empty?\n    result = []\n  else\n    arr.each do |n|\n      result\
    \ << (n % 10 == 0) ? n : n + \"One\"\n    end\n    arr.reverse\n    arr.each do\
    \ |n|\n      result << (n % 10 == 0) ? n : n + \"Two\"\n    end\n    arr.reverse\n\
    \    arr.each do |n|\n      result << (n % 10 == 0) ? n : n + \"Three\"\n    end\n\
    \    arr.reverse\n    arr.each do |n|\n      result << (n % 10 == 0) ? n : n +\
    \ \"Four\"\n    end\n    arr.reverse\n    arr.each do |n|\n      result << (n\
    \ % 10 == 0) ? n : n + \"Five\"\n    end\n    arr.reverse\n    arr.each do |n|\n\
    \      result << (n % 10 == 0) ? n : n + \"Six\"\n    end\n    arr.reverse\n \
    \   arr.each do |n|\n      result << (n % 10 == 0) ? n : n + \"Seven\"\n    end\n\
    \    arr.reverse\n    arr.each do |n|\n      result << (n % 10 == 0) ? n : n +\
    \ \"Eight\"\n    end\n    arr.reverse\n    arr.each do |n|\n      result << (n\
    \ % 10 == 0) ? n : n + \"Nine\"\n    end\n  end\n  result\nend", "  arr.sort\n\
    \  arr.reverse\n  arr.map {|i| i.to_s.tr(\" !\".repeat(9), '  ').to_sym }\nend",
  "  arr.sort!\n  arr.reverse!\n  arr.map! { |x| name_to_num[x] || x }\nend", "  \
    \  arr = arr.sort\n    arr = arr.reverse\n    arr.map {|e| arr[0]}\nend\n</code>\n\
    <|/ a |>\n<| a |>\nHere's a recursive version using Ruby's Range class.\n<code>",
  "  # Write your code here\n  arr.sort!\n  arr.reverse\n  arr.reject! {|x| x % 10}\n\
    \  arr.map {|x| return (\"One\"..\"Nine\").to_a.sample unless x % 10}\nend\n</code>\n\
    <|/ a tags=ruby,algorithm |>\n<| c |>\nGreat answer, just want to point out that\
    \ this is using Array#reverse to reverse the array. It would make more sense if\
    \ it did something like `arr = arr.reverse` at the beginning.\n<|/ c |>\n<| a\
    \ dscore=4 |>\nHere's a solution using Enumerable#each_cons and Array#cycle:\n\
    <code>", "  if arr.empty?\n    []\n  elsif arr.any?(&:odd?)\n    arr.reverse\n\
    \  else\n    arr.sort_by{|n| n}.reverse\n    arr.map { |n| name(n) }\n  end\n\
    end", "  sorted_arr = arr.sort.reverse.tap{|arr| arr.map!{|x| x.to_s}.map!{|x|\
    \ lookup[x.to_i] ? lookup[x.to_i] : \"Other\" } }\n  arr.empty? ? [] : sorted_arr.map!{|x|\
    \ lookup[x.to_i] ? lookup[x.to_i] : \"Other\" }\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nIf your answer is correct, it would be nice to explain _why_ it is correct.\n\
    <|/ c |>\n<| a dscore=1 |>\nI was solving this problem recently on Project Euler\
    \ problem 37 (http://projecteuler.net/problem=37). My solution is very similar\
    \ to the one by Tyler Rinker, but I wanted to give the problem a slightly different\
    \ approach since I didn't want to deal with using eval. Instead I created a method\
    \ which could take a number in the range 0-999 (inclusive) and return a string\
    \ containing the name of the number as specified in the lookup array.\n<code>",
  "  return [] if arr.empty? || arr.any? {|x| x.to_i > 9 || x.to_i < 1}\n  arr.sort!.reverse\n\
    \  reversed_arr = arr.map{|x| x.to_s} # convert each element into a string\n \
    \ reversed_arr.delete(\"One\")\n  reversed_arr.delete(\"Two\")\n  reversed_arr.delete(\"\
    Three\")\n  reversed_arr.delete(\"Four\")\n  reversed_arr.delete(\"Five\")\n \
    \ reversed_arr.delete(\"Six\")\n  reversed_arr.delete(\"Seven\")\n  reversed_arr.delete(\"\
    Eight\")\n  reversed_arr.delete(\"Nine\")\n  return reversed_arr\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThe question is \"sort by length\", not \"sort by values\"\
    . Also the example you give is wrong, it should return [\"Nine\", \"Eight\", \"\
    Seven\", \"Six\", \"Five\", \"Four\", \"Three\", \"Two\", \"One\", \"One\"]\n\
    <|/ c |>\n<| c |>\n, Okay, I modified my answer.\n<|/ c |>\n<| a |>\nI came up\
    \ with a nice solution using only Ruby code:\n<code>", "  arr.sort!\n  arr.each_index\
    \ do |i|\n    if arr[i] >= 1 and arr[i] <= 9\n      arr[i] = \"One\" if i==0\n\
    \      arr[i] = \"Two\" if i==1\n      arr[i] = \"Three\" if i==2\n      arr[i]\
    \ = \"Four\" if i==3\n      arr[i] = \"Five\" if i==4\n      arr[i] = \"Six\"\
    \ if i==5\n      arr[i] = \"Seven\" if i==6\n      arr[i] = \"Eight\" if i==7\n\
    \      arr[i] = \"Nine\" if i==8\n    end\n  end\n  arr.reverse!\n  arr.join\n\
    end", "    sorted = arr.sort\n    sorted.reverse\n    sorted", "  sorted_arr =\
    \ arr.sort_by { |x| x.length }.reverse\n  sorted_arr.reverse!\n  arr.reverse!\n\
    \  sorted_arr.each do |x|\n    arr << x unless arr.include? x\n  end\n  arr\n\
    end", "  sorted = arr.sort.reverse \n  sorted.map do |n| \n    arr.reverse.index(n.to_s).zero?\
    \ ? \"One\" : \"#{n}\"\n  end\nend", "  return arr.sort.reverse.reduce(:+).map\
    \ {|x| x.to_s.chars.map(&:capitalize).join('')}\nend", "  arr.sort.reverse\n \
    \ arr.map! {|x| one_name_map[x - 1]}\n  arr\nend\n</code>\n<|/ a tags=ruby,sorting\
    \ |>\n<| a tags=ruby,sorting dscore=0 |>\n<code>", "  arr = arr.sort_by{ |x| x.length\
    \ }.reverse.map(&:to_s).delete_if { |s| s == \"\" }\n  arr.empty? ? [] : arr\n\
    end", "  return arr.sort.reverse.to_a.pop.to_a\nend", "  if arr.size == 0\n  \
    \  return []\n  sorted_arr = []\n  length_arr = []\n  arr.each do |i|\n    if\
    \ i && i.to_i.between?(10..99)\n      length_arr.push i.to_i\n    end\n  end\n\
    \  length_arr.sort!\n  length_arr.each do |i|\n    puts i if i && i.to_i.between?(10..99)\n\
    \  end\n  length_arr.each do |i|\n    sorted_arr.push i.to_i if i && i.to_i.between?(10..99)\n\
    \  end\n  sorted_arr.reverse!\n  length_arr.reverse!\n  length_arr.each do |i|\n\
    \    puts \"One\" if i && i.to_i.between?(10..99)\n  end\n  length_arr.each do\
    \ |i|\n    sorted_arr.push \"One\" if i && i.to_i.between?(10..99)\n  end\n  sorted_arr\n\
    end", "    \n    # check if the array is empty\n    if arr.empty?\n        return([])\n\
    \    \n    # sort the array\n    sorted = arr.sort\n    \n    # reverse the array\n\
    \    reversed = sorted.reverse\n    \n    # check every element in the array and\
    \ replace it by the name \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\
    , \"Seven\", \"Eight\", \"Nine\"\n    sorted_by_length = reversed.map {|i| \n\
    \        if i <= 9\n            return(\"Nine\" if i == 10 || i == 11 ||  i ==\
    \ 12 || i == 13 || i == 14 || i == 15 || i == 16)\n        elsif i >= 10 && i\
    \ <= 19\n            return(\"Eight\" if i == 18 || i == 19 || i == 20)\n    \
    \    elsif i >= 20 && i <= 29\n            return(\"Seven\" if i == 28 || i ==\
    \ 29 || i == 30)\n        elsif i >= 30 && i <= 39\n            return(\"Six\"\
    \ if i == 38 || i == 39 || i == 40)\n        elsif i >= 40 && i <= 49\n      \
    \      return(\"Five\" if i == 41 || i == 49 || i == 50)\n        elsif i >= 50\
    \ && i <= 59\n            return(\"Four\" if i == 50 || i == 59 || i == 60)\n\
    \        elsif i >= 60 && i <= 69\n            return(\"Three\" if i == 58 ||\
    \ i == 69 || i == 70)\n        elsif i >= 70 && i <= 79\n            return(\"\
    Two\" if i == 68 || i == 79 || i == 80)\n        elsif i >= 80 && i <= 89\n  \
    \          return(\"One\" if i == 71 || i == 89 || i == 90)\n        elsif i >=\
    \ 90 && i <= 99\n            return(\"Ten\" if i == 88 || i == 99 || i == 100)\n\
    \        else \n            return(\"Ten\" if i == 100 || i == 101 ||  i == 102\
    \ ||  i == 103 ||  i == 104 ||  i == 105 ||  i == 106)\n        }\n    \n    #\
    \ return the array\n    sorted_by_length\nend", "  arr = arr.sort\n  arr = arr.reverse\n\
    \  arr = arr.map {|num| [ \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"\
    Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\"\
    , \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\
    \ ][num.to_s.length, num]}\n  arr.compact!\n  arr\nend\nputs by_length(arr)\n\
    </code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nHere are three ways to do this:",
  "    arr.sort!\n    arr = arr.reverse\n    arr.each {|a| return \"One\" if a ==\
    \ 1 \n        return \"Two\" if a == 2\n        return \"Three\" if a == 3\n \
    \       return \"Four\" if a == 4\n        return \"Five\" if a == 5\n       \
    \ return \"Six\" if a == 6\n        return \"Seven\" if a == 7\n        return\
    \ \"Eight\" if a == 8\n        return \"Nine\" if a == 9}\n    return []\nend\n\
    </cell>\n<cell>", "  if arr.empty?\n    return []\n  sorted_arr = arr.sort_by\
    \ { |v| v } # sort by value\n  arr.reverse! # reverse the array\n  sorted_arr.each_with_index\
    \ do |val, i|\n    arr[i] = \"One\" if val == 1\n    arr[i] = \"Two\" if val ==\
    \ 2\n    arr[i] = \"Three\" if val == 3\n    arr[i] = \"Four\" if val == 4\n \
    \   arr[i] = \"Five\" if val == 5\n    arr[i] = \"Six\" if val == 6\n    arr[i]\
    \ = \"Seven\" if val == 7\n    arr[i] = \"Eight\" if val == 8\n    arr[i] = \"\
    Nine\" if val == 9\n  end\n  return arr\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ |>\n<code>\narr = arr.sort.reverse\narr.map!{|e| [\"One\",\"Two\",\"Three\"\
    ,\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"][e]}\n</code>\n<|/ a tags=ruby\
    \ dscore=0 |>\n<| a |>\n<code>", "  return arr.reverse.map{|x| by_digit(x).first}\n\
    end", "  arr.sort.reverse.each_char.with_index.map { |e, i| arr[i] if i <= 9 &&\
    \ i >= 1 }.compact.first\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a dscore=1\
    \ tags=ruby |>\nHere is a method that sorts a string and converts each character\
    \ to its corresponding name.  It first sorts the letters in ascending order, then\
    \ it turns the characters in descending order and reverses it.  It then sorts\
    \ the array in descending order and prints the names in the sorted order.\n<code>",
  "    return [] if arr.empty? || arr.uniq.empty? || arr.uniq.size == 1\n    return\
    \ arr.sort_by{ |n| n.to_s.rjust(3, '0') }.reverse.to_a.map { |n| one_digit(n)\
    \ }\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\nThis is just a simple Ruby solution\
    \ with no external libs. \n<code>", "  arr.sort!\n  arr.reverse!\n  arr.each do\
    \ |e|\n    case e\n    when 1..9\n      e -= 1\n    when \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n      e\
    \ = e[/[Ee][Nn][Ee]/, 1]\n    end\n  end\n  arr\nend", "  arr.sort! { |a,b| b<=>a\
    \ }\n  arr.reverse!\n  arr.map {|x| get_name_from_index(x)}\nend", "\tsorted_arr\
    \ = arr.sort\n\treverse_arr = arr.reverse\n\t\n\tcount = 0\n\t\n\twhile count\
    \ < 10\n\t\tsorted_arr[count]\n\t\tcount = count + 1\n\t\n\treverse_arr.sort\n\
    \t\n\tcount = 0\n\t\n\twhile count < 10\n\t\treverse_arr[count]\n\t\tcount = count\
    \ + 1", "    arr.sort\n    arr.reverse!\n    return arr.map {|x| one_nine[x]}\n\
    end", "  numbers = arr.collect { |a| a.to_i }\n  numbers = numbers.sort_by { |a|\
    \ a }\n  numbers = numbers.reverse if numbers.length >= 1\n  names.collect { |a|\
    \ a }\nend", "  arr = arr.sort\n  arr = arr.reverse\n  arr.reject!{|x|x.to_s.include?('0')}\n\
    \  arr\nend\n</code>\n<|/ a tags=ruby,algorithm,arrays |>\n<| a |>\nYou could\
    \ use Array#partition:\n<code>\narr.sort.reverse.partition{ |e| e.to_s.include?('1')\
    \ }\n  #=> [[\"1\", \"1\"], [\"2\", \"2\"], [\"3\", \"3\"], [\"4\", \"4\"], [\"\
    5\", \"5\"], [\"6\", \"6\"],\n  #    [\"7\", \"7\"], [\"8\", \"8\"], [\"9\", \"\
    9\"]] \n</code>\n<|/ a tags=ruby,algorithm,arrays dscore=0 |>\n<| a tags=ruby,algorithm,arrays\
    \ dscore=0 |>\nHere's how I did it:\n<code>", "  puts arr\n  sorted_arr = arr.sort\n\
    \  puts sorted_arr\n  reversed_arr = sorted_arr.reverse\n  puts reversed_arr\n\
    \  reversed_arr.map {|x| names[x]}.compact\nend", "    numbers = arr.sort {|a,\
    \ b| a.length <=> b.length }.reverse\n    numbers.map {|i| one_name if i.length\
    \ < 8 || i.length == 8 && i.odd? ? i.to_s.reverse.insert(1, one_name) : one_name}\n\
    end", "  sorted_arr = arr.sort_by{|i| i if i <= 9}\n  sorted_arr.reverse\n  sorted_arr.each_with_index{|el,\
    \ i| el = i if el > 9}\nend", "  arr.sort!\n  arr.reverse!\n  arr.each {|i| arr.include?(i)\
    \ ? arr[i] = \"One\" : arr[i] = \"Two\"}\n  arr.reverse!\n  arr\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a dscore=0 |>\nI think this can be simplified more, especially\
    \ for those who are familiar with lambda functions. But I believe this is more\
    \ readable and easy to understand.\n<code>", "  arr.sort!\n  arr.sort! { |a, b|\
    \ b - a }\n  arr.reverse!\n  arr.map { |x| [\"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"].find { |i| x == i } }\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays |>\nA simple way to do this\
    \ is to create a new array with the names of the numbers 1-9, and use map to transform\
    \ each element from 1-9 to the corresponding name for each of the original values.\n\
    <code>", "  arr = arr.sort{|a,b| b if a.between?(1,9) }.reverse\n  arr.each do\
    \ |x|\n    if x.between?(1,9)\n      digit = x.to_s[1..-1]\n      x = name.index(x)[0]\n\
    \    end\n  end\nend", "  if arr.empty? || arr.any? { |x| x > 0 && x < 10 }\n\
    \    return []\n  else\n    sorted_arr = arr.sort\n    length_sorted_arr = sorted_arr.map\
    \ { |e| e[0].length }\n    reversed_arr = sorted_arr.reverse\n    reversed_arr.each\
    \ { |e| e.map! { |e| e[0].to_s } }\n    return reversed_arr\n  end\nend", "  arr.sort!\n\
    \  arr.reverse!\n  arr = arr.map {|x| names.index(x) }\n  arr.empty? ? [] : arr.map\
    \ {|x| names[x] }\nend", "  arr = arr.sort\n  arr.reverse!\n  arr = arr.collect\
    \ {|x| x.to_s.sub(/\\d/) {|y| [\"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\"][y.to_i - 1]}}\n  arr.empty? ? [] :\
    \ arr\nend", "  return arr.sort {|a, b| a.to_i < b.to_i ? 1 : -1}.inject([]) do\
    \ |result, elem|\n    if elem < 0 || elem > 9\n      result\n    else\n      result\
    \ << numbers[elem]\n    end\n  end\nend", "  arr.sort! \n  arr.reverse!\n  arr.map!\
    \ { |x| x.to_s[0..1] }\n  arr\nend", "  arr.sort!\n  arr.reverse!\n  arr.map do\
    \ |n| \n    case\n      when n>9\n        n.to_s+\"nine\"\n      when n>1\n  \
    \      n.to_s+\"one\"\n      else\n        n.to_s+\"zero\"\n    end\n  end\nend",
  "  if arr.empty?\n    []\n  else\n    arr.sort!\n    arr.reverse!\n    arr.map!\
    \ {|n| n == 1 && \"One\" \n              || n == 2 && \"Two\" \n             \
    \ || n == 3 && \"Three\" \n              || n == 4 && \"Four\" \n            \
    \  || n == 5 && \"Five\" \n              || n == 6 && \"Six\" \n             \
    \ || n == 7 && \"Seven\" \n              || n == 8 && \"Eight\" \n           \
    \   || n == 9 && \"Nine\" }\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays,ruby-on-rails\
    \ |>\n<| a dscore=2 |>\n<code>\narray = [:one, :two, :three, :four, :five, :six,\
    \ :seven, :eight, :nine]\narray.reverse_sort.map { |e| array[] = e }\n</code>\n\
    Or if you prefer the readability of Ruby 1.8 (I do):\n<code>\narray = [:one, :two,\
    \ :three, :four, :five, :six, :seven, :eight, :nine]\narray.sort.reverse_sort.map\
    \ { |e| array[] = e }\n</code>\n<|/ a tags=ruby,sorting,arrays,ruby-on-rails |>\n\
    <| c |>\nIf you're going to use map to mutate the original array then there's\
    \ no need to use `sort`, you can use `array.sort.reverse.map(&:next)`\n<|/ c |>\n\
    <| c |>\nYou are right, thank you for the suggestion. Updated my answer.\n<|/\
    \ c |>\n<| c |>\nNote that `sort` returns a new array, whereas `reverse_sort`\
    \ sorts in place and returns `nil`\n<|/ c |>\n<| a tags=ruby,sorting,arrays,ruby-on-rails\
    \ |>\nYou could use each_cons to break up the array into two parts until it finds\
    \ an integer less than or equal to 9 and then merge them back together again:\n\
    <code>", "  arr.sort_by! {|x| (x-1)*100+1 }\n  arr.reverse\n  arr.map {|x| one_or_nine[x-1]\
    \ }\nend", "  arr ||= []\n  arr.sort_by { |num| -num.to_s.length }\n  arr.reverse\n\
    \  arr.map { |num| names[num] }\nend", "  if arr.empty?\n    arr\n  else\n   \
    \ arr = arr.sort{|a,b| b<=>a}.reverse\n    arr.reduce([]){|a,e| a.push(\"#{e}\"\
    .to_i(9) if 1<=e&&e<=9)+a}\n  end\nend", "    arr = arr.reverse\n    arr.map!\
    \ do |i| case i \n        when 1 then \"One\"\n        when 2 then \"Two\"\n \
    \       when 3 then \"Three\"\n        when 4 then \"Four\"\n        when 5 then\
    \ \"Five\"\n        when 6 then \"Six\"\n        when 7 then \"Seven\"\n     \
    \   when 8 then \"Eight\"\n        when 9 then \"Nine\"\n        else nil \n \
    \       end\n    end\n    arr\nend\n</cell>\n<cell>", "  if arr.length == 0\n\
    \    return []\n  end", "  if arr.empty?\n    []\n  else\n    arr.sort\n    arr.reverse\n\
    \    arr.map!{ |x| \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"\
    Seven\", \"Eight\", \"Nine\"}\n  end\nend", "    arr.sort!.reverse!\n    res =\
    \ []\n    count = 0\n    str = arr.join(\" \")\n    while str.length > 0\n   \
    \     if str[count].between?('1','9')\n            res << str[count]\n       \
    \ else\n            break\n        end\n        count += 1\n    end\n    res <<\
    \ str[count] if str.length > count\n    return res\nend", "  arr.sort! { |a,b|\
    \ (1..9).include? a.length <=> (1..9).include? b.length }\n  arr.reverse!\n  arr.reverse.each_with_index\
    \ { |e,i| arr[i] = 'One' if e==1 }\n  arr.reverse!\n  arr\nend", "  arr.reverse!\n\
    \  arr.map!{|num| \n    case num\n    when 1..9 then 'One'\n    when 10 then 'Ten'\n\
    \    when 11 then 'Eleven'\n    when 12 then 'Twelve'\n    when 13 then 'Thirteen'\n\
    \    when 14 then 'Fourteen'\n    when 15 then 'Fifteen'\n    when 16 then 'Sixteen'\n\
    \    when 17 then 'Seventeen'\n    when 18 then 'Eighteen'\n    when 19 then 'Nineteen'\n\
    \    else num.to_s\n    end\n  }\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ dscore=4 |>\n<| c |>\nThe OP asked for a ruby solution, though.\n<|/ c |>\n\
    <| a dscore=4 |>\nHere's an alternative to my other answer that uses the inject\
    \ method. \n<code>", "  arr.sort!\n  arr.reverse!\n  arr.map!{|x| [\"One\", \"\
    Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    , x].first}\nend", "  result = []\n  arr.sort{|a, b| a.to_i < b.to_i}\n  arr.reverse\n\
    \  arr.each do |item|\n    result << ['One', 'Two', 'Three', 'Four', 'Five', 'Six',\
    \ 'Seven', 'Eight', 'Nine'].\n              map{|n| [n, item]}.\n            \
    \  join{|a,b| a.to_i > b.to_i ? b.to_i.to_s + a.to_s : a.to_s + b.to_i.to_s}\n\
    \  end\n  result\nend\n</code>\n<|/ a |>\n<| c |>\nSorry I could not get this\
    \ working with Ruby 2.5.3. I could not get the `map` function to work but I will\
    \ take another look.\n<|/ c |>\n<| a dscore=0 tags=ruby,sorting,arrays |>\n<code>",
  "  arr.sort!\n  arr.reverse\n  new_arr = []\n  until arr.empty?\n    num = arr.shift\n\
    \    new_arr.unshift(num_to_name(num))\n  end\n  return new_arr\nend", "    \n\
    \    return arr.sort { |a, b| b - a }.reverse.map{ |i| [\"One\", \"Two\", \"Three\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][i.to_s] }\nend",
  "  return arr.sort{|a, b| b - a }.reverse.map{|n| \n    if n < 1 then return \"\
    One\" \n    elsif n < 9 then return \"Two\"\n    elsif n < 99 then return \"Three\"\
    \n    elsif n < 999 then return \"Four\"\n    elsif n < 9999 then return \"Five\"\
    \n    elsif n < 99999 then return \"Six\"\n    elsif n < 999999 then return \"\
    Seven\"\n    elsif n < 9999999 then return \"Eight\"\n    elsif n < 999999999\
    \ then return \"Nine\"\n    else return \"One\"\n  end\nend", "  return arr.reverse.map\
    \ do |x|\n    if x >= 1 && x <= 9\n      One[x - 1]\n    else\n      x\n    end\n\
    \  end\nend", "  arr.sort!\n  arr.reverse!\n  arr.map!{|x| ['One','Two','Three','Four','Five','Six','Seven','Eight','Nine'][x]}\n\
    \  arr\nend", "  arr.sort!\n  arr = arr.reverse!\n  arr = arr.map{|e| names[e]}\n\
    \  arr\nend", "  arr.reduce {|a,b| b.to_s.length < a.to_s.length ? b : a}.reverse.map.with_index\
    \ { |n, i| [i % 9 + 1, \"#{n}\"]}.flatten\nend", "  arr.sort.reverse\n  arr.map\
    \ { |x| x % 10 == 0 ? \"One\" : \"Two\" } + arr.map { |x| x % 10 == 1 ? \"Two\"\
    \ : \"Three\" } + arr.map { |x| x % 10 == 2 ? \"Three\" : \"Four\" } + arr.map\
    \ { |x| x % 10 == 3 ? \"Four\" : \"Five\" } + arr.map { |x| x % 10 == 4 ? \"Five\"\
    \ : \"Six\" } + arr.map { |x| x % 10 == 5 ? \"Six\" : \"Seven\" } + arr.map {\
    \ |x| x % 10 == 6 ? \"Seven\" : \"Eight\" } + arr.map { |x| x % 10 == 7 ? \"Eight\"\
    \ : \"Nine\" } + arr.map { |x| x % 10 == 8 ? \"Nine\" : \"Ten\" } \nend", "  \
    \  arr = arr.reduce(:+)\n    sorted_arr = arr.sort.reverse\n    i = 0\n    ans\
    \ = []\n    while i < arr.size\n        ans << sorted_arr[i]\n        i += 1\n\
    \    end\n    return ans\nend", "  arr = arr.to_a\n  arr.sort!\n  arr.map!{ |x|\
    \ x > 9 ? 8 - x : (10 - (x - 1)) + 1 }\n  arr.sort!\n  arr.map!{ |x| x % 10 ==\
    \ 0 ? \"One\" :\n    x % 10 == 1 ? \"Two\" :\n    x % 10 == 2 ? \"Three\" :\n\
    \    x % 10 == 3 ? \"Four\" :\n    x % 10 == 4 ? \"Five\" :\n    x % 10 == 5 ?\
    \ \"Six\" :\n    x % 10 == 6 ? \"Seven\" :\n    x % 10 == 7 ? \"Eight\" :\n  \
    \  x % 10 == 8 ? \"Nine\" : \"?\"\n  }\n  arr\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nThe question is not about finding solutions to homework problems or anything\
    \ like that. How about showing some effort? At least provide a link to the Ruby\
    \ doc for `.sort!`.\n<|/ c |>\n<| c |>\n: I added an example and a link to the\
    \ Ruby doc. Thanks for the comment!\n<|/ c |>\n<| a tags=ruby |>\n<code>\narray.map\
    \ {|x| 10 - x % 10 }.uniq.map {|x| \"%02d\" % x }.reverse.map {|x| x.to_s.downcase\
    \ }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYeah, I thought about doing the same\
    \ thing. :)\n<|/ c |>\n<| c |>\nYou can replace the `10 - x % 10` with a conditional\
    \ expression: `[10, 9, 8].find(&:==).min - (x%10)`.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>", "  if arr.length == 0\n    arr = []\n  else\n    arr.sort! { |a, b| a.length\
    \ <=> b.length }\n    arr.reverse!\n    arr.map! {|i| case i\n      when 1\n \
    \       \"One\"\n      when 2\n        \"Two\"\n      when 3\n        \"Three\"\
    \n      when 4\n        \"Four\"\n      when 5\n        \"Five\"\n      when 6\n\
    \        \"Six\"\n      when 7\n        \"Seven\"\n      when 8\n        \"Eight\"\
    \n      when 9\n        \"Nine\"\n      else\n        i\n      end\n    }\n  end\n\
    \  arr\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| a dscore=2 |>\n<code>",
  "  p =[]\n  if arr.empty? or arr.any?{|x| x.is_a? Integer} \n    p << ['']\n  else\n\
    \    arr.sort.reverse_each.map { |i| p << ([\"#{One}\", \"#{Two}\", \"#{Three}\"\
    , \"#{Four}\", \"#{Five}\", \"#{Six}\", \"#{Seven}\", \"#{Eight}\", \"#{Nine}\"\
    ].sample) if i.between?(One,Nine) }\n  end\n  p << ['']\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI like your approach, but it is kind of unintuitive to me.  I'd be inclined\
    \ to have written the method this way:  \n`def by_length(arr)\n  p =[]\n  if arr.empty?\
    \ or arr.any?{|x| x.is_a? Integer} \n    p << ['']\n  else\n    arr.sort.reverse_each.map\
    \ { |i| p << ([\"#{One}\", \"#{Two}\", \"#{Three}\", \"#{Four}\", \"#{Five}\"\
    , \"#{Six}\", \"#{Seven}\", \"#{Eight}\", \"#{Nine}\"].sample) if i.between?(One,Nine)\
    \ }\n  end\n  p << ['']\nend`\n<|/ c |>\n<| c |>\nThe `if i` condition is superfluous.\
    \  The `i` will always be an Integer object in the case that the array is not\
    \ empty.  So you can just do `arr.sort.reverse_each.map { ... }` to map the array\
    \ and eliminate the `if` condition.  I'll update my answer with this approach.\n\
    <|/ c |>\n<| a tags=ruby dscore=1 |>\nHere is my approach:\n<code>", "  arr.sort!\n\
    \  arr.reverse!\n  arr.reduce([]) {|sum, number| \n    if number <= 10 \n    \
    \  sum += \"#{number}\"\n      sum.push(\"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")[number]\n    end\n    sum\n\
    \  }\nend\n</code>\n<|/ a dscore=3 tags=ruby,arrays |>\n<| c |>\nThis is a much\
    \ more elegant way to solve this problem.\n<|/ c |>\n<| a dscore=1 |>\nA more\
    \ readable and understandable way is to use Enumerable#sort_by.\n<code>", "  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n  arr.delete_at(0)\n\
    \  arr.", "  arr.sort.reverse.map {|n| n==1 ? One:n==2 ? Two:n==3 ? Three:n==4\
    \ ? Four:n==5 ? Five:n==6 ? Six:n==7 ? Seven:n==8 ? Eight:n==9 ? Nine:\n  n\n\
    }\nend", "    sorted_array = arr.sort\n    sorted_array.map!{|x| x == 0 ? \"One\"\
    \ : x}\n    sorted_array.reverse!\n    sorted_array.map!{|x| x == 0 ? \"One\"\
    \ : x}\n    sorted_array\nend", "  return arr.sort_by{ |e| [e.between?(1), e.between?(9)]\
    \ }.reverse.reject { |e| e.nil? }\nend\n</code>\n<|/ a tags=ruby,sorting |>\n\
    <| a dscore=0 |>\nThis should work\n<code>", "  arr.sort\n  arr.reverse!\n  arr.reduce({})\
    \ { |h, t| h[t[0]] ||= t; h }\nend\n</code>\n<|/ a dscore=4 |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  arr.sort\n  arr.reverse\n  arr.map {|i| by_name([\"One\", \"\
    Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    ], i) }\nend", "  arr.sort {|a, b| a.length <=> b.length }.reverse.map { |i| \n\
    \    i = i.to_s\n    i = i.upcase\n    case i\n      when /^1[1-9]+$/\n      \
    \  \"One\"\n      when /^[2-9]+$/\n        \"Two\"\n      when /^[3-9]+$/\n  \
    \      \"Three\"\n      when /^[4-9]+$/\n        \"Four\"\n      when /^[5-9]+$/\n\
    \        \"Five\"\n      when /^[6-9]+$/\n        \"Six\"\n      when /^[7-9]+$/\n\
    \        \"Seven\"\n      when /^[8-9]+$/\n        \"Eight\"\n      when /^[1-9]+$/\n\
    \        \"Nine\"\n      else\n        i\n    end\n  }\nend", "  arr = arr.sort!.map(&:to_i)\n\
    \  arr.unshift(-1)\n  arr.reverse!\n  arr.each {|x| arr[x] = names[x] if arr[x]\
    \ == nil}\nend\n</code>\n<|/ a tags=arrays,ruby,string |>\n<| c |>\nWhat do you\
    \ mean by *ignore strange number*? If the array has strange number it will not\
    \ be sorted.\n<|/ c |>\n<| c |>\n: I mean ignore it when converting the number\
    \ to the name - if there was a number, it was already a string, so we don't need\
    \ to convert it to string and waste time converting it to a number.\n<|/ c |>\n\
    <| c |>\nI didn't see you said about numbers bigger than 9. Just in case you want\
    \ to ignore numbers that are > 9 you can do this: `arr.sort!.map! { |x| x.to_i\
    \ if x <= 9 }.compact!`\n<|/ c |>\n<| c |>\n- `arr.sort!.map! { |x| x.to_i if\
    \ x <= 9 }.compact!` doesn't work if there is more than one number bigger than\
    \ 9.  For example: `[1, 2, 3, 9, 7, 10, 9]` --> `[1, 10, 9, 7, 3, 9, 9]`  But\
    \ `[1, 2, 3, 9, 7, 10, 11, 9]` --> `[1, 10, 11, 9, 7, 3, 9, 9]`\n<|/ c |>\n<|\
    \ c |>\nI missed the point that you have numbers > 9 in you example. Thanks for\
    \ pointing this out.\n<|/ c |>\n<| a tags=arrays,ruby,string dscore=3 |>\nRuby\
    \ is a language that's often used to build Ruby scripts (in fact, the first part\
    \ of my answer), but it's not very good for that kind of scripting. It's more\
    \ suited towards writing tools and libraries. It's especially bad when the code\
    \ is so verbose. \nAs I suspected, the code is quite unreadable, and if you had\
    \ written it in a procedural language like Lisp or Common Lisp or even a compiled\
    \ language like C/C++, it'd be a lot easier to read.\nInstead, Ruby has a lot\
    \ of tools and a lot of gems for doing things like this, so I thought it'd be\
    \ interesting to see how you would write it in Ruby:\n<code>\nrequire 'pp'", " \
    \ arr.sort!\n  arr.reverse!\n  arr.map! {|x| x.to_s}.delete_if{|s| s.empty? }.compact!\n\
    \  arr\nend", "  # if there are any number other than number 1 to 9\n  new_arr\
    \ = []\n  if arr.length > 0\n    new_arr << (arr.sort_by{|x| x.to_i}.map(&:to_s).reverse)\n\
    \    new_arr << (arr.sort_by{|x| x.to_i}.map(&:to_s))\n    new_arr << arr.sort_by{|x|\
    \ x.to_i}.map(&:to_s)\n    new_arr << arr.sort_by{|x| x.to_i}.reverse\n    new_arr\
    \ << arr.sort_by{|x| x.to_i}.map(&:to_s)\n    new_arr << arr.sort_by{|x| x.to_i}.map(&:to_s).reverse\n\
    \    new_arr << arr.sort_by{|x| x.to_i}.map(&:to_s).reverse\n    new_arr << arr.sort_by{|x|\
    \ x.to_i}.map(&:to_s)\n    new_arr << arr.sort_by{|x| x.to_i}.map(&:to_s).reverse\n\
    \    new_arr << arr.sort_by{|x| x.to_i}.map(&:to_s).reverse\n  else\n    new_arr\
    \ << ([])\n  end\n  new_arr\nend", "  if arr.empty?\n    []\n  elsif arr.any?(&:odd?)\n\
    \    arr\n  elsif arr.size > 1\n    arr.group_by {|x| x.to_s.size}\n  else\n \
    \   arr\n  end\n    .select {|k, v| k >= 1 && k <= 9}\n    .map {|k, v| v.reverse.join\
    \ 'One' * (9 - k - 1)}\nend\n</code>\nAnd here is a quick test:\n<code>\narr =\
    \ [2, 1, 1, 4, 5, 8, 2, 3]\nby_length(arr)\n  #=> [\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"] \nby_length([]) \n  #=> [] \n\
    by_length([1, -1, 55]) \n  #=> [\"One\"] \nby_length([1, -1, 55, 2])\n  #=> [\"\
    One\"] \nby_length([-1, 55, 1])\n  #=> [\"One\"] \nby_length([-1, 1])\n  #=> [\"\
    One\"] \nby_length([-1]) \n  #=> [] \nby_length([-1, -5, 55]) \n  #=> [\"One\"\
    ] \nby_length([-1, -5, -9, 55, 8, 2, 5])\n  #=> [\"One\"]\n</code>\nNote that\
    \ the above is intentionally verbose. Note also that it is a purely functional\
    \ solution. That is true of any solution using Array#sort, Array#reverse, Array#join,\
    \ and Array#slice. Those solutions are elegant, and I would have used them in\
    \ a purely functional way.\n<|/ a |>\n<| a tags=arrays,ruby dscore=3 |>\nThis\
    \ answer builds on another answer I gave, but does not use Array#sort.\nThe basic\
    \ idea is to split up the array into odd and even elements, and then sort them,\
    \ then re-join them together:\n<code>", "  arr.sort {|a,b| b - a} # sort the array\n\
    \  arr.sort! # reverse the array\n  arr.map! do |num|\n    case\n    when num\
    \ > 9 then\n      \"#{num.to_s.reverse}#{by_name[num.to_s.reverse]}\"\n    else\n\
    \      \"#{num.to_s.reverse}#{by_name[num.to_s]}\"\n    end\n  end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "  return arr.sort {|a, b| b - a\
    \ } .reverse\nend", "  arr.sort!\n  arr.reverse!\n  arr.map! {|x| case x when\
    \ x < 10 then \"One\" when x < 20 then \"Two\" when x < 30 then \"Three\" when\
    \ x < 40 then \"Four\" when x < 50 then \"Five\" when x < 60 then \"Six\" when\
    \ x < 70 then \"Seven\" when x < 80 then \"Eight\" when x < 90 then \"Nine\" else\
    \ x.to_s end }\nend\n</code>\n<|/ a dscore=4 |>\n<| a tags=sorting,ruby |>\n<code>",
  "  arr.sort\n  arr.reverse\n  arr.each_with_index do |num, index|\n    arr[index]\
    \ = NUMBERS[num] unless NUMBERS.include? num\n  end\n  arr\nend", "  return arr.sort{\
    \ |a, b| a.length < b.length ? -1 : a.length > b.length ? 1 : (a <=> b)}.reverse.map{|n|\
    \ ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine'][n]}\n\
    end", "  arr = arr.dup\n  arr.sort!\n  arr.map!{|x| x == 1 ? 1 :\n           \
    \ x == -1 ? -1 :\n            x.abs }\n  arr.each_with_index { |x, i| arr[i] =\
    \ arr[i].to_s }\n  arr.reverse!\nend", "  sort_arr = arr.sort\n  arr.clear\n \
    \ arr.push(*sort_arr) if sort_arr\n  arr.reverse\n  arr.map!{|x| \n    case\n\
    \    when 0..9 then \"One\"\n    when 10..19 then \"Two\"\n    when 20..29 then\
    \ \"Three\"\n    when 30..39 then \"Four\"\n    when 40..49 then \"Five\"\n  \
    \  when 50..59 then \"Six\"\n    when 60..69 then \"Seven\"\n    when 70..79 then\
    \ \"Eight\"\n    when 80..89 then \"Nine\"\n    else x.to_s\n    end\n  }\n  arr\n\
    end", "    arr = arr.sort\n    reverse(arr)\n    arr.each do |x|\n        if x\
    \ > 1 && x < 9\n            arr[x] = by_name\n        elsif x = 1\n          \
    \  arr[x] = by_name\n        elsif x = 9\n            arr[x] = by_name\n     \
    \   end\n    end\n    arr\nend", "  arr = arr.sort\n  arr.push(*[1,2,3,4,5,6,7,8,9])\n\
    \  arr.reverse\n  arr.map { |i| \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\" }\nend", "  return arr.map { |x| ['Zero',\
    \ 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine'][x] }.sort.reverse\n\
    end", "  return arr.sort.reverse.reduce{ |arr,elem| arr.insert(arr.length-1,elem);\
    \ arr } + ['One']\nend", "  arr.sort\n  arr.reverse\n  arr.map { |x| One[x] }\n\
    end", "  arr.sort! { |a,b| a.to_i <=> b.to_i }\n  arr.unshift arr.shift\n  arr.reverse!\n\
    \  arr.map! {|x| x_to_n[x]}\nend", "  arr.sort_by{|x| (1..9).include?(x)}.reverse\n\
    end", "  return arr.sort_by{|e| e if e > 0 && e < 10}.map{|e| [\"One\", \"Two\"\
    , \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][e -\
    \ 1]}.join\nend", "  len = arr.length\n  if len > 0\n    arr.sort!\n    arr.reverse!\n\
    \    arr.map do |e|\n      index = e.to_s.rindex('.')\n      name = e.to_s[0..index-1]\n\
    \      if name.length >= 1\n        name = \"#{name[0...1]}#{name.gsub(',', '')}\"\
    \n      else\n        name = \"#{name}#{index}\"\n      end\n    end\n  end\n\
    \  arr\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIf it helps anyone trying to\
    \ solve this in Ruby: `[\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\
    , \"Seven\", \"Eight\", \"Nine\"].sort.reverse.map { |n| n.gsub(/./) { |c| [\"\
    Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"][(c.to_i - 1).abs] } }` (this can be converted to a method on\
    \ Array).\n<|/ c |>\n<| c |>\nIf you have some time you could convert this into\
    \ a method that accepts the array and returns the array as a sorted array. Then\
    \ the code could be simplified.\n<|/ c |>\n<| a |>\n<code>", "    arr.sort!.reverse!\n\
    \    if arr.length == 0\n        return []\n    if arr.length > 9\n        arr\
    \ <<= 9 - arr.length\n    end\n    arr.reduce([:One, :Two, :Three, :Four, :Five,\
    \ :Six, :Seven, :Eight, :Nine], &:itself)\nend", "  arr ||= []\n  arr.sort!\n\
    \  arr.reverse\n  arr.map! {|x| [\"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\"][x - 1] }\n  arr\nend\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nI like your first solution, but I have to use map!,\
    \ and not map.\n<|/ c |>\n<| c |>\nI added another solution using `map` method\
    \ (without modifying the input array).\n<|/ c |>\n<| c |>\nYou can see my answers\
    \ here on how to reverse an array using `map!` - [How to reverse an array without\
    \ using reverse in Ruby](http://stackoverflow.com/questions/5118480/how-to-reverse-an-array-without-using-reverse-in-ruby)\
    \ and [Reverse an array](http://stackoverflow.com/questions/3733151/reverse-an-array).\
    \ Please remember to mark the answer as accepted if it suits your needs.\n<|/\
    \ c |>\n<| c |>\nI think you mean `arr.sort_by!(&:last).map(&:first)`\n<|/ c |>\n\
    <| c |>\nYou're right thanks! I meant to reverse the sort instead of sorting the\
    \ array of `Integer`s.\n<|/ c |>\n<| a tags=ruby |>\nTry this:\n<code>", "  sorted_arr\
    \ = []\n  sorted_arr.concat(arr.sort { |x, y| x <= y })\n  sorted_arr.reverse\n\
    \  arr.each do |n|\n    if sorted_arr.include?(n)\n      sorted_arr.delete(n)\n\
    \      sorted_arr.unshift(n)\n    end\n  end\n  sorted_arr\nend\n</code>\n<|/\
    \ a tags=ruby,arrays,sorting |>\n<| c |>\n`arr = [2,3,6,1,0]` fails because `arr[1]\
    \ > arr[0]`.\n<|/ c |>\n<| c |>\n: I didn\u2019t know that `sort` would behave\
    \ that way, but in practice it doesn\u2019t seem to. At least in MRI 2.7.8, it\
    \ does, and it\u2019s undocumented behavior.\n<|/ c |>\n<| a tags=ruby,arrays,sorting\
    \ |>\nSince your question asked for \"less than or equal\" instead of \"less than\"\
    , the code below works for me. \n<code>\n def by_length(arr)\n  sorted_arr = []\n\
    \  sorted_arr.concat(arr.sort { |x, y| x <= y })\n  sorted_arr.reverse\n  arr.each\
    \ do |n|\n    if sorted_arr.include?(n)\n      sorted_arr.delete(n)\n      sorted_arr.unshift(n)\n\
    \    end\n  end\n  sorted_arr\n end", "  arr.sort! # reverse the array\n  arr.map\
    \ { |x| x = x.to_s }\n  arr.map { |x| x = 'One' if x =~ /^1/ && x =~ /^-1/ }\n\
    end\n</code>\n<|/ a tags=sorting,ruby,arrays dscore=1 |>\n<| a dscore=0 |>\nTo\
    \ sort this array first sort by length then by their digits.\n<code>", "  sorted_arr\
    \ = arr.sort\n  reversed_arr = sorted_arr.reverse\n  returned_arr = []\n  while\
    \ !reversed_arr.empty?\n    digit = reversed_arr.shift\n    if digit < 9\n   \
    \   returned_arr.unshift(by_digit(digit, sorted_arr))\n    else if digit < 1\n\
    \      returned_arr.unshift(by_digit(digit * 10, sorted_arr))\n    else # digit\
    \ < 10\n      returned_arr.unshift(by_digit(digit * 100, sorted_arr))\n  end\n\
    \  return returned_arr\nend", "  arr = arr.sort.reverse\n  arr.each {|x| arr[x]\
    \ = names[x]}\n  arr\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI wish I could\
    \ give more than one upvote.  This is probably the best solution.\n<|/ c |>\n\
    <| a |>\nIt can be done like that:\n<code>", "  sorted_arr = arr.sort\n  sorted_arr.reverse\
    \ \n  sorted_arr.each do |x| \n    if x > 9\n      digit = x%10\n      name =\
    \ x.to_s\n      name = name.sub!(/\\d/, \"#{digit}\")\n      name = name.sub!(/\\\
    d/, digit.to_s)\n      name = name.sub!(/\\d/, digit.to_s.to_s)\n      name =\
    \ name.sub!(/\\d/, digit.to_s.to_s)\n      name = name.sub!(/\\d/, digit.to_s.to_s)\n\
    \      name = name.sub!(/\\d/, digit.to_s.to_s)\n      name = name.sub!(/\\d/,\
    \ digit.to_s.to_s)\n      name = name.sub!(/\\d/, digit.to_s.to_s)\n      name\
    \ = name.sub!(/\\d/, digit.to_s.to_s)\n      name = name.sub!(/\\d/, digit.to_s.to_s)\n\
    \      name = name.sub!(/\\d/, digit.to_s.to_s)\n      name = name.sub!(/\\d/,\
    \ digit.to_s.to_s)\n      name = name.sub!(/\\d/, digit.to_s.to_s)\n      name\
    \ = name.sub!(/\\d/, digit.to_s.to_s)\n      name = name.sub!(/\\d/, digit.to_s.to_s)\n\
    \      name = name.sub!(/\\d/, digit.to_s.to_s)\n      name = name.sub!(/\\d/,\
    \ digit.to_s.to_s)\n      name = name.sub!(/\\d/, digit.to_s.to_s)\n      name\
    \ = name.sub!(/\\d/, digit.to_s.to_s)\n      name = name.sub!(/\\d/, digit.to_s.to_s)\n\
    \      name = name.sub!(/\\d/, digit.to_s.to_s)\n      name = name.sub!(/\\d/,\
    \ digit.to_s.to_s)\n      name = name.sub!(/\\d/, digit.to_s.to_s)\n      name\
    \ = name.sub!(/\\d/, digit.to_s.to_s)\n      name = name.sub!(/\\d/, digit.to_s.to_s)\n\
    \      name = name.sub!(/\\d/, digit.to_s.to_s)\n      name = name.sub!(/\\d/,\
    \ digit.to_s.to_s)\n      name = name.sub!(/\\d/, digit.to_s.to_s)\n      name\
    \ = name.sub!(/\\d/, digit.to_s.to_s)\n      name = name.sub!(/\\d/, digit.to_s.to_s)\n\
    \      name = name.sub!(/\\d/, digit.to_s.to_s)\n      name = name.sub!(/\\d/,\
    \ digit.to_s.to_s)\n", "  arr.sort! do |a, b|\n    if a > b then 1 \n    elsif\
    \ a == b then 0\n    else -1 end\n  end\n  arr.reverse!\n  arr &= [\"One\", \"\
    Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    ]\nend", "  result = []\n  while arr.any?\n    number = arr.shift\n    result\
    \ << lookup[number]\n  end \n  result.reverse\n  result\nend", "  # write your\
    \ code here\n  arr.sort!.reverse!\n  arr.reverse!\n  arr = arr.map do |i| \n \
    \   i = i % 10\n    i = i ? i : 'One'\n  end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=2 |>\n<| c |>\nI wouldn't write this as my first solution myself. It's\
    \ just too much work and too confusing to understand. I'd just go with something\
    \ like [this answer](http://stackoverflow.com/a/4709925/1579864), which doesn't\
    \ need the `reverse_it` method (which I thought was weirdly named).\n<|/ c |>\n\
    <| a tags=ruby,arrays |>\nHere's another way to solve this problem using regular\
    \ expressions:\n<code>", "  return arr.reverse.reduce(:<<).compact.map do |s|\n\
    \    s.to_s.reverse.chars.to_a.reduce(:<<).map do |c|\n      \"One\", \"Two\"\
    , \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"[c]\n\
    \    end.join\n  end\nend", "  arr.sort!\n  arr.uniq.sort!.reverse!\n  arr.map\
    \ {|x| x.to_s.gsub(/[89]/, \"\\#{x}\")}\nend", "  return arr.reverse.map.with_index\
    \ { |v, i| v if 1..9 == i }\nend", "  arr.each do |number|\n    if number >= 1\
    \ && number <= 9\n      arr.sort!\n      arr.reverse\n      result = arr.map{|el|\
    \ [el]}\n    else\n      arr.shift\n    end\n  end\n  return result\nend\np by_length([7,\
    \ 3, 8, 2, 5])\np by_length([7, 3, 8, 2, 5])\n</code>\n<|/ a dscore=0 tags=sorting,ruby\
    \ |>\n<| a |>\n<code>", "  arr.sort! # sort the integers that are between 1 and\
    \ 9 inclusive\n  arr.reverse! # reverse the resulting array\n  arr.map!{|x| [\"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"].include?(x) ? x : nil} # replace each digit by its corresponding name\
    \ from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"\n  return arr\nend", "  if arr.empty?\n    []\n  elsif arr.any?\
    \ { |i| i % 10 != 0 }\n    arr\n  else\n    # sort arr and reverse arr\n    arr.sort_by\
    \ { |i| i } .reverse\n    # then replace each digit by its name from (\"One\"\
    , \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    )\n    arr.map { |i| i / 10 }.map { |i| One[i] + Two[i] + Three[i] + Four[i] +\
    \ Five[i] + Six[i] + Seven[i] + Eight[i] + Nine[i] }\n  end\nend", "  result =\
    \ []\n  arr.each do |i|\n    if i.between?(1, 9)\n      result << i.to_s\n   \
    \   result << i.to_s.reverse\n      result << i.to_s.reverse.to_s\n      result\
    \ << i.to_s.reverse.to_s.reverse\n    end\n  end\n  result\nend", "  arr.sort\
    \ { |a, b| a.to_s.length <=> b.to_s.length }\n  arr.reverse!\n  arr.replace {\
    \ |i| names_array[i] }\nend", "  arr.sort.reverse arr.replace \"One\"=>\"Eight\"\
    \n  arr.sort.reverse arr.replace \"Two\"=>\"Five\"\n  arr.sort.reverse arr.replace\
    \ \"Three\"=>\"Four\"\n  arr.sort.reverse arr.replace \"Four\"=>\"Three\"\n  arr.sort.reverse\
    \ arr.replace \"Five\"=>\"Two\"\n  arr.sort.reverse arr.replace \"Six\"=>\"One\"\
    \n  arr.sort.reverse arr.replace \"Seven\"=>\"One\"\n  arr.sort.reverse arr.replace\
    \ \"Eight\"=>\"One\"\n  arr.sort.reverse arr.replace \"Nine\"=>\"One\"\nend",
  "  \n  if arr.length == 0\n    return []\n  end\n  \n  arr.sort!\n  \n  arr.each\
    \ do |i| \n    if i % 10 == 0 and i != 0\n      arr[i] = \"#{NUMS[i]}\"\n    end\n\
    \  end", "  arr.sort_by { |i| i - 1 }.reverse.map { |i| One.dup.tap{ |v| v.send\
    \ \"#{i}=\", Two; v.send \"#{i}=\", Three; v.send \"#{i}=\", Four; v.send \"#{i}=\"\
    , Five; v.send \"#{i}=\", Six; v.send \"#{i}=\", Seven; v.send \"#{i}=\", Eight;\
    \ v.send \"#{i}=\", Nine; v.send \"#{i}=\", Uninitialized } }\nend", "  arr.sort!\
    \ do |a| \n    if a >= 1 && a <= 9\n      a\n    else\n      -1\n    end\n  end\n\
    \  arr.reverse!\n  arr.map do |x| \n    num = x.to_s\n    ones = [\"One\", \"\
    Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    ]\n    num = ones[num.to_i - 1]\n    num\n  end\nend", "  if arr.empty?\n    arr\
    \ = []\n  elsif arr.any?(&:odd?)\n    arr\n  elsif arr.any?(&:even?)\n    arr.reverse\n\
    \    arr.map {|x| [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"\
    Seven\", \"Eight\", \"Nine\"][x.to_i] }.reverse\n  elsif arr.any? {|x| x % 2 ==\
    \ 0}\n    arr.reverse\n    arr.map {|x| [\"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][x.to_i] }.reverse\n  else\n\
    \    arr\n  end\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| a |>\n<code>",
  "  arr.sort! { |a, b| b[1] <=> a[1] }\n  arr.reverse!\n  arr.each_with_index { |n,\
    \ i|\n    arr[i] = names[i] if i < arr.length\n  }\n  arr\nend", "  result = arr.sort.reverse\n\
    \  result.map!{|i| return i.to_s[0..9] unless i.to_s.match(/[0-9]/)} \n  result.map!{|i|\
    \ return \"One\" unless i.to_s.match(/[0-9]/)} \n  result\nend", "    arr.sort\n\
    \    arr.reverse\n    arr.map { |i| [\"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"].index i }\nend", "  arr = arr.sort\n\
    \  arr = arr.each_index.map { |x| x[1..-1].to_s }.uniq\n  return arr if arr.size\
    \ > 0\n  arr = []\n  return arr\nend\n</code>\n<code>\narr = [2, 1, 1, 4, 5, 8,\
    \ 2, 3]   \nby_length(arr) #=> [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\"\
    , \"Two\", \"One\", \"One\"]\narr = []\nby_length(arr) #=> []\narr = [1, -1 ,\
    \ 55] \nby_length(arr) #=> [\"One\"]\n</code>\n<|/ a tags=ruby,arrays dscore=0\
    \ |>\n<| c |>\nCould you please explain how this works?\n<|/ c |>\n<| c |>\nI\
    \ updated the answer.\n<|/ c |>\n<| a dscore=0 |>\nYou can use select and reduce\
    \ to accomplish this:\n<code>\na = [2, 1, 1, 4, 5, 8, 2, 3]", "  arr.sort\n  arr.reverse\n\
    \  arr.map! {|x| if x.is_a?(Integer) then \"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\" else \"#{x}\" }\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=arrays,ruby |>\nI agree with that using sort_by is\
    \ the way to go, but here's another option using map with a case statement:\n\
    <code>", "    arr.sort\n    arr.reverse\n    arr.each_with_index do |x, i|\n \
    \       arr[i] = \"One\" if 1 <= x && x <= 9\n    end\n    arr\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThis fails for an empty array, and for an\
    \ array with any number less than or equal to 0, such as `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nThe question asks for a function that returns an array with the words\
    \ \"One\", \"Two\", \"Three\", etc., instead of \"0\", \"1\", etc. Also, it's\
    \ not necessary to reverse the array before sorting, since that makes it impossible\
    \ to distinguish the original ordering.\n<|/ c |>\n<| c |>\nSorry I didn't see\
    \ that requirement. Updated answer\n<|/ c |>\n<| c |>\n\"Two\" should be \"Two\"\
    , and \"One\" should be \"One\".\n<|/ c |>\n<| c |>\nAh I see now. That's more\
    \ complicated because \"Two\" isn't a word that comes before \"One\" or \"Eight\"\
    \ before \"Seven\", for example. So \"Eight\" can't come before \"One\" because\
    \ \"One\" comes after \"Eight\". That's why I added \"8\".\n<|/ c |>\n<| a dscore=3\
    \ |>\n<code>", "  # Handle the empty case\n  return arr if arr.size == 0 \n  \n\
    \  # Get the max number in the array\n  max_num = arr.max\n  # The array has at\
    \ least one strange number\n  strange_num = false\n  \n  # Scan through the array\
    \ and find the strange number\n  (0...arr.size).each do |i|\n    if arr[i] < 1\
    \ || arr[i] > 9\n      strange_num = true\n      break\n    end\n  end\n  # If\
    \ there was a strange number, reverse the array before returning the name\n  strange_num\
    \ ? arr.reverse.reduce(:+) : arr\nend", "    arr.sort!\n    arr.map {|i| if i.odd?\
    \ then \"One\" else i.to_s end}.reverse\nend", "  arr.sort!\n  arr.reverse\n \
    \ arr.map { |x| get_name(x) }\nend", "  result = []\n  result.reverse_each {|n|\
    \ arr.delete_at(n) if arr.length < n}\n  arr.delete_if {|x| x.zero?}\n  return\
    \ arr\nend", '  return arr.sort.reverse.reduce(:+).each_char.map { |c| c.to_s.reverse
    }.uniq.map { |n| n[0] = "One".size < n[0].size ? n[0] : "Two".size < n[0].size
    ? n[0] : "Three".size < n[0].size ? n[0] : "Four".size < n[0].size ? n[0] : "Five".size
    < n[0].size ? n[0] : "Six".size < n[0].size ? n[0] : "Seven".size < n[0].size
    ? n[0] : "Eight".size < n[0].size ? n[0] : "Nine".size < n[0].size ? n[0] : "Ten".size
    < n[0].size ? n[0] : "Nine".size < n[0].size ? n[0] : "Ten".size < n[0].size ?
    n[0] : "Nine".size < n[0].size ? n[0] : "Ten".size < n[0].size ? n[0] : "Nine".size
    < n[0].size ? n[0] : "Ten".size < n[0].size ? n[0] : "Nine".size < n[0].size ?
    n[0] : "Ten".size < n[0].size ? n[0] : "Nine".size < n[0].size ? n[0] : "Ten".size
    < n[0].size ? n[0] : "Nine".size < n[0].size ? n[0] : "Ten".size < n[0].size ?
    n[0] : "Nine".size < n[0].size ? n[0] : "Ten".size < n[0].size ? n[0] : "Nine".size
    < n[0].size ? n[0] : "Ten".size < n[0].size ? n[0] : "Nine".size < n[0].size ?
    n[0] : "Ten".size < n[0].size ? n[0] : "Nine".size < n[0].size ? n[0] : "Ten".size
    < n[0].size ? n[0] : "Nine".size < n[0].size ? n[0] : "Ten".size < n[0].size ?
    n[0] : "Nine".size < n[0].size ? n[0] : "Ten".size < n[0].size ? n[0] : "Nine".size
    < n[0].size ? n[0] : "Ten".size < n[0].size ? n[0] : "Nine".size < n[0].size ?
    n[0] : "Ten".size < n[0].size ? n[0] : "Nine".size < n[0].size ? n[0] : "Ten".size
    < n[0].size ? n[0] : "Nine".size < n[0].size ? n[0] : "Ten".size < n[0].size ',
  "    arr.sort!\n    arr.reverse!\n    arr.map {|x| name(x) if 1 < 9 && 9 < x}\n\
    end", "  return arr.sort {|a, b| b.length <=> a.length }.\n    map { |i| arr.reverse.index(i)\
    \ + 1 }.\n    map { |i| [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\
    , \"Seven\", \"Eight\", \"Nine\"][i] }\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=ruby,arrays,ruby-on-rails |>\nI liked Taryn East's answer. Here is the\
    \ same with more Ruby 1.8.7 idioms:\n<code>\narray = [1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10]", "  return arr.sort.reverse.map{|x| [\"One\", \"Two\", \"Three\", \"\
    Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"].fetch(x % 10 + 1, \"\
    One\")}\nend", "  return arr.sort_by {|x| x.to_s.length}.map {|x| x.to_s}.reverse\n\
    end", "  sorted_arr = arr.sort\n  reverse_arr = arr.sort { |a, b| b <=> a }.reverse\n\
    \  return.map.with_index { |d, i| i > 0 and '#{d} #{reverse_arr[i-1]}' or \"#{d}\"\
    }\nend", "  arr.sort!\n  arr.each_with_index do |num, i|\n    arr[i] = one_or_none(num,\
    \ arr) if num < 10\n    arr[i] = two_or_none(num, arr) if num < 100\n    arr[i]\
    \ = three_or_none(num, arr) if num < 1000\n    arr[i] = four_or_none(num, arr)\
    \ if num < 10000\n    arr[i] = five_or_none(num, arr) if num < 100000\n    arr[i]\
    \ = six_or_none(num, arr) if num < 1000000\n    arr[i] = seven_or_none(num, arr)\
    \ if num < 10000000\n    arr[i] = eight_or_none(num, arr) if num < 100000000\n\
    \    arr[i] = nine_or_none(num, arr) if num < 1000000000\n  end\n  arr.reverse!\n\
    \  arr.each { |x| x = one_or_none(x, arr) if x }\n  arr\nend", "  arr.each_with_index\
    \ do |number, index|\n    if number < 1 || number > 9\n      next\n    end", " \
    \ # write your code here\nend", "  return arr.sort { |a, b| a.length <=> b.length\
    \ }.reverse.map { |a| a.to_s.gsub(/[1-8]/i, 'One') }\nend", "  result = arr[0]\n\
    \  arr.delete(arr[0])\n  arr.each_index do |index|\n    arr.insert(index, result)\n\
    \    result = arr[index]\n    arr.delete(arr[index])\n  end\n  arr\nend", "  return\
    \ arr.sort.reverse.map {|x| names_hash[x]}\nend\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\nA Ruby solution:\n<code>", "  nums = arr.sort\n  return arr.reverse.map\
    \ {|x| [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"][x - 1]}\nend", "  return arr.sort.reverse.map(|x| arr[x.to_i\
    \ - 1]).map { |x| x.to_s.upcase }\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis seems to have bugs when the array starts with 0.\n<|/ c |>\n\
    <| a |>\n<code>", "    arr.sort!\n    return arr.reverse.map { |x| digits[x] }\n\
    end\nputs sort_and_reverse_by_length([])\nputs sort_and_reverse_by_length([1,\
    \ -1, 55])\nputs sort_and_reverse_by_length([-1, 1, 55])\nputs sort_and_reverse_by_length([1,\
    \ 1, 55, 1])\nputs sort_and_reverse_by_length([1, 1, 55, 1, 1, -1, 55])\nputs\
    \ sort_and_reverse_by_length([-1, -1, 1, 55])\nputs sort_and_reverse_by_length([-1,\
    \ -1, 1, 55, 1])\nputs sort_and_reverse_by_length([1, 1, 55, -1, -1, 1, 55])\n\
    puts sort_and_reverse_by_length([55, -1, -1, 1, 1])\nputs sort_and_reverse_by_length([-1,\
    \ 1, 55, -1])\nputs sort_and_reverse_by_length([-1, 1, 55, -1, -1, 1, 55])\nputs\
    \ sort_and_reverse_by_length([1, 1, 55, -1, -1, 1, 55, 1])\nputs sort_and_reverse_by_length([55,\
    \ -1, -1, 1, -1, -1, 1, 55])\nputs sort_and_reverse_by_length([-1, 1, 55, -1,\
    \ -1, 1, 55, 1])\nputs sort_and_reverse_by_length([-1, 1, 55, -1, -1, 1, 55, 1])\n\
    puts sort_and_reverse_by_length([-1, 1, 55, -1, -1, 1, 55, 1])\nputs sort_and_reverse_by_length([-1,\
    \ 1, 55, -1, -1, 1, 55, 1])\nputs sort_and_reverse_by_length([1, 1, 55, -1, -1,\
    \ 1, 55, 1])\nputs sort_and_reverse_by_length([55, -1, -1, 1, -1, -1, 1, 55])\n\
    puts sort_and_reverse_by_length([1, 1, 55, -1, -1, 1, 55, 1])\nputs sort_and_reverse_by_length([55,\
    \ -1, -1, 1, -1, -1, 1, 55])\nputs sort_and_reverse_by_length([-1, 1, 55, -1,\
    \ -1, 1, 55, 1])\nputs sort_and_reverse_by_length([-1, 1, 55, -1, -1, 1, 55, 1])\n\
    puts sort_and_reverse_by_length([-1, 1, 55, -1, -1, 1, 55, 1])\nputs sort_and_reverse_by_length([-1,\
    \ 1, 55, -1, -1, 1, 55, 1])\nputs sort_and_reverse_by_length([1, 1, 55, -1, -1,\
    \ 1, 55, 1])\nputs sort_and_reverse_by_length([55, -1, -1, 1, -1, -1, 1, 55])\n\
    puts sort_and_reverse_by_length([-1, 1, 55, -1, -1, 1, 55, 1])\nputs sort_and_reverse_by_length([-1,\
    \ 1, 55, -1, -1, 1, 55, 1])\nputs sort_and_reverse_by_length([-1, 1, 55, -1, -1,\
    \ 1, 55, 1])\nputs sort_and_reverse_by_length([1, 1, 55, -1, -1, 1, 55, 1])\n\
    puts sort_", "    return [] unless arr\n    arr.sort_by!{ |e| -e.length }\n  \
    \  arr.reverse!\n    arr.map!{ |e| return \"One\" if e == 1 } + arr.map!{ |e|\
    \ return \"Two\" if e == 2 } + arr.map!{ |e| return \"Three\" if e == 3 } + arr.map!{\
    \ |e| return \"Four\" if e == 4 } + arr.map!{ |e| return \"Five\" if e == 5 }\
    \ + arr.map!{ |e| return \"Six\" if e == 6 } + arr.map!{ |e| return \"Seven\"\
    \ if e == 7 } + arr.map!{ |e| return \"Eight\" if e == 8 } + arr.map!{ |e| return\
    \ \"Nine\" if e == 9 }\n    arr\nend", "  arr.sort!\n  arr.reverse!\n  result\
    \ = []\n  (0..9).each do |x|\n    result << name(x) if arr.include?(x)\n  end\n\
    \  result.empty? ? [] : result\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays,sorting\
    \ |>\nThe sort method is what you're looking for, after sorting the array it will\
    \ flip the digits and place them in the correct order, ex:\n<code>\narray = [4,1,5,6,2,3,9,8,7,0,7]\n\
    array.sort!\n</code>\nWill sort it, and flip it to be:\n<code>\narray = [0,7,8,7,2,3,9,6,4,5,1]\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nWhy would you \"sort\" the numbers if they're\
    \ not sorted in the first place?\n<|/ c |>\n<| c |>\nThat is what the question\
    \ was asking for, isn't it?\n<|/ c |>\n<| c |>\nThe question was about sorting\
    \ an array in place, and not about sorting it. You are sorting it twice, and this\
    \ does not answer the question (which is \"why did you sort the array at all?\"\
    ).\n<|/ c |>\n<| c |>\nIt doesn't matter that they're not sorted in the first\
    \ place since the algorithm is sorting them anyways. If you read the question,\
    \ you'll see that they specifically asked how to sort the numbers from 1-9 into\
    \ \"One\" to \"Nine\". It wasn't clear what order the original array had in mind.\n\
    <|/ c |>\n<| c |>\nIt was not clear from the question, but it does sound like\
    \ they want to sort the numbers from 1-9 in descending order. Your algorithm will\
    \ do that, but then reverse the array again. If you look at the example in the\
    \ question, you will see what happens if you sort the numbers.\n<|/ c |>\n<| a\
    \ |>\n<code>", "  arr.sort\n  arr.reverse\n  arr.each do |i|\n    arr.pop\n  \
    \  if i % 10 == 0\n      arr.pop\n      arr << [\"One\",\"Two\",\"Three\",\"Four\"\
    ,\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"][i % 10]\n    end\n  end\n  return\
    \ arr\nend", "  if arr.is_a? Integer\n    return arr if arr >= 1 && arr <= 9 \n\
    \  elsif arr.is_a? String\n    return arr\n  elsif arr.is_a? Array\n    sorted_arr\
    \ = arr.sort\n    reverse_arr = sorted_arr.reverse\n    return reverse_arr.map{|i|\
    \ one_digit(i)}\n  else\n    return []\n  end\nend", "  arr.sort!\n  arr.reverse!\n\
    \  arr.map! {|i| i[0] == 1 ? \"One\" : i[0] == 2 ? \"Two\" : i[0] == 3 ? \"Three\"\
    \ : i[0] == 4 ? \"Four\" : i[0] == 5 ? \"Five\" : i[0] == 6 ? \"Six\" : i[0] ==\
    \ 7 ? \"Seven\" : i[0] == 8 ? \"Eight\" : i[0] == 9 ? \"Nine\" : i[0] }\n  arr\n\
    end", "  return arr.map{|x| [\"One\", \"Two\", \"Three\", \"Four\", \"Five\",\
    \ \"Six\", \"Seven\", \"Eight\", \"Nine\"].index(x) }\nend", "  arr.sort!\n  arr.reverse!\n\
    \  arr.each { |i| arr[i] = \"One\"  if i == 1\n                         arr[i]\
    \ = \"Two\"  if i == 2\n                         arr[i] = \"Three\" if i == 3\n\
    \                         arr[i] = \"Four\" if i == 4\n                      \
    \   arr[i] = \"Five\" if i == 5\n                         arr[i] = \"Six\"  if\
    \ i == 6\n                         arr[i] = \"Seven\" if i == 7\n            \
    \             arr[i] = \"Eight\" if i == 8\n                         arr[i] =\
    \ \"Nine\" if i == 9\n                       }\n  arr\nend\n</code>\n<|/ a tags=arrays,ruby\
    \ |>\n<| a |>\n<code>", "  arr.sort do |a, b|\n    if a.is_a?(Fixnum) and b.is_a?(Fixnum)\n\
    \      a <=> b\n    else\n      a <=> b <=> 0\n    end\n  end.reverse.map do |x|\n\
    \    return ['One','Two','Three','Four','Five','Six','Seven','Eight','Nine'][x]\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  arr.map! { |i| i.to_i\
    \ if i.to_i >= 1 && i.to_i <= 9 }\n  arr.sort_by!{ |i| i }.reverse!\n  arr.map!{\
    \ |i| i.to_s }\n  arr\nend", "  return arr.reverse.map do |x| \n    if x % 10\
    \ == 1 \n      \"One\"\n    elsif x % 10 == 2 \n      \"Two\"\n    elsif x % 10\
    \ == 3 \n      \"Three\"\n    elsif x % 10 == 4 \n      \"Four\"\n    elsif x\
    \ % 10 == 5 \n      \"Five\"\n    elsif x % 10 == 6 \n      \"Six\"\n    elsif\
    \ x % 10 == 7 \n      \"Seven\"\n    elsif x % 10 == 8 \n      \"Eight\"\n   \
    \ elsif x % 10 == 9\n      \"Nine\"\n    end\n  end\nend", "    return arr.reverse.select\
    \ {|x| x > 0 && x < 10}\nend", "  return arr.sort{|a,b| b.length <=> a.length\
    \ }.map{|el| el.reverse}\nend\n</code>\n<|/ a tags=arrays,ruby,sorting,algorithm,ruby-on-rails\
    \ dscore=1 |>\n<| c |>\nThank you for sharing the code, this was very helpful!\n\
    <|/ c |>\n<| a tags=arrays,ruby,sorting,algorithm,ruby-on-rails dscore=0 |>\n\
    Try this:\n<code>\narr = [1,4,5,8,2,3,2,1,10,3]\narr = arr.sort_by{|i| i.to_s.reverse.to_i\
    \ }.map{|i| i.to_s.reverse.to_i }\narr\n</code>\n<|/ a |>\n<| c |>\nThis does\
    \ not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/15397025)\n\
    <|/ c |>\n<| c |>\nI didnt critique it. I answered it and said try this and if\
    \ it doesnt work try that. I will leave a comment to my answer though\n<|/ c |>\n\
    <| a tags=arrays,ruby,sorting,algorithm,ruby-on-rails |>\n<code>", "  if arr.empty?\n\
    \    []\n  elsif arr.any? { |i| i > 9 || i < 1 }\n    []\n  else\n    a = arr.sort\n\
    \    # reverse \n    a.reverse\n    # replace\n    a.map { |i| i%10 + 1 }.map\
    \ { |i| arr[i-1] }\n  end\nend", "  arr.each do |i|\n    if (i%2==0)\n      arr.delete_at(i)\n\
    \      arr.unshift(i)\n    end\n  end\n  arr.reverse!\n  arr.map do |i|\n    if\
    \ i.to_s.index('1')\n      'One'\n    elsif i.to_s.index('2')\n      'Two'\n \
    \   elsif i.to_s.index('3')\n      'Three'\n    elsif i.to_s.index('4')\n    \
    \  'Four'\n    elsif i.to_s.index('5')\n      'Five'\n    elsif i.to_s.index('6')\n\
    \      'Six'\n    elsif i.to_s.index('7')\n      'Seven'\n    elsif i.to_s.index('8')\n\
    \      'Eight'\n    elsif i.to_s.index('9')\n      'Nine'\n    else\n      nil\n\
    \    end\n  end\nend\nby_length(arr)\n</code>\n<|/ a tags=arrays,sorting,ruby\
    \ dscore=1 |>\n<| c |>\nI like this approach, but if someone has a better one,\
    \ I'd love to see it!\n<|/ c |>\n<| c |>\nI did a little test with a smaller array,\
    \ and it seems to be running more slowly. I don't know if this is due to memory\
    \ or speed, but I haven't seen much different processing time for larger arrays.\
    \ Any thoughts on what could be the issue?\n<|/ c |>\n<| a dscore=0 tags=arrays,sorting,ruby\
    \ |>\nJust to throw some more things in to play with:\n<code>\n> \"One\", \"Two\"\
    , \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"", " \
    \ result = []\n  arr.map do |n| \n    result << case n \n               when 1\
    \ <= n && n <= 9\n                 return \"One\"\n               when 10 <= n\
    \ && n <= 99\n                 return \"Two\"\n               when 100 <= n &&\
    \ n <= 999\n                 return \"Three\"\n               when 1000 <= n &&\
    \ n <= 9999\n                 return \"Four\"\n               when 10000 <= n\
    \ && n <= 99999\n                 return \"Five\"\n               when 100000\
    \ <= n && n <= 999999\n                 return \"Six\"\n               when 1000000\
    \ <= n && n <= 9999999\n                 return \"Seven\"\n               when\
    \ 10000000 <= n && n <= 99999999\n                 return \"Eight\"\n        \
    \       when 100000000 <= n && n <= 99999999999\n                 return \"Nine\"\
    \n               else \n                 return \"Unknown Number\"\n         \
    \      end\n  end\n  result.sort.reverse.map do |n| \n    case n\n      when \"\
    One\"\n        return \"One\"\n      when \"Two\"\n        return \"Two\"\n  \
    \    when \"Three\"\n        return \"Three\"\n      when \"Four\"\n        return\
    \ \"Four\"\n      when \"Five\"\n        return \"Five\"\n      when \"Six\"\n\
    \        return \"Six\"\n      when \"Seven\"\n        return \"Seven\"\n    \
    \  when \"Eight\"\n        return \"Eight\"\n      when \"Nine\"\n        return\
    \ \"Nine\"\n      when \"Unknown Number\"\n        return \"Unknown Number\"\n\
    \    end\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nI don't get how your `sort`\
    \ is supposed to sort the array in `arr = [2, 1, 1, 4, 5, 8, 2, 3]` since the\
    \ first element (2) is < 1, so it is first in the sorted array. Also I guess that\
    \ you need to use your `by_length` function in `sort` instead of `by_length`\n\
    <|/ c |>\n<| a dscore=0 tags=ruby,ruby-on-rails |>\n<code>", "  # Your code here\n\
    \  return [] if arr.length == 0\n  arr = arr.sort\n  arr = arr.reverse\n  arr.map\
    \ {|e| ['One','Two','Three','Four','Five','Six','Seven','Eight','Nine'][e-1] }.compact.uniq.flatten\n\
    end\n</code>\n<|/ a |>\n<| a dscore=2 |>\nThe most compact form I could come up\
    \ with in a single line:\n<code>\narr = arr.sort.reverse.map{|i| ['One','Two','Three','Four','Five','Six','Seven','Eight','Nine'].index(i)+1}\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work. You need to call\
    \ `index` on the *sorted* array, not on the original. Otherwise you just get the\
    \ index instead of the name at that index.\n<|/ c |>\n<| a |>\nYou could use a\
    \ helper method like this.\n<code>", "    arr.sort!\n    arr.reverse!\n    arr.each\
    \ do |i|\n        if i > 9\n            arr[i] = \"#{i}\" + \"Nine\"\n       \
    \ end\n    end\n    arr\nend", "  return arr\nend", "  # your code here\n  new_array\
    \ = []\n  if arr.any?\n    arr.each do |num|\n      if num > 0 && num <= 9\n \
    \       new_array.unshift(to_string(num))\n      end\n    end\n    new_array.reverse\n\
    \    new_array.map! {|element| element.to_sym}\n  else\n    new_array = []\n \
    \ end\n  return new_array\nend", "  # Your code here\n  arr.sort!\n  arr.reverse!\n\
    \  arr.each do |num|\n    if num == 1\n      arr.pop\n    elsif num == 2\n   \
    \   arr.pop\n      arr.pop\n    elsif num == 3\n      arr.pop\n      arr.pop\n\
    \      arr.pop\n    elsif num == 4\n      arr.pop\n      arr.pop\n      arr.pop\n\
    \      arr.pop\n    elsif num == 5\n      arr.pop\n      arr.pop\n      arr.pop\n\
    \      arr.pop\n      arr.pop\n    elsif num == 6\n      arr.pop\n      arr.pop\n\
    \      arr.pop\n      arr.pop\n      arr.pop\n      arr.pop\n    elsif num ==\
    \ 7\n      arr.pop\n      arr.pop\n      arr.pop\n      arr.pop\n      arr.pop\n\
    \      arr.pop\n      arr.pop\n    elsif num == 8\n      arr.pop\n      arr.pop\n\
    \      arr.pop\n      arr.pop\n      arr.pop\n      arr.pop\n      arr.pop\n \
    \     arr.pop\n      arr.pop\n      arr.pop\n      arr.pop\n    end\n  end\n \
    \ arr\nend", "  arr.each { |i| if i <= 9 && i >= 1 then arr[i] = \"One\"\n   \
    \        elsif i <= 9 && i >= 10 then arr[i] = \"Two\"\n           elsif i <=\
    \ 9 && i >= 100 then arr[i] = \"Three\"\n           elsif i <= 9 && i >= 1000\
    \ then arr[i] = \"Four\"\n           elsif i <= 9 && i >= 10000 then arr[i] =\
    \ \"Five\"\n           elsif i <= 9 && i >= 100000 then arr[i] = \"Six\"\n   \
    \        elsif i <= 9 && i >= 1000000 then arr[i] = \"Seven\"\n           elsif\
    \ i <= 9 && i >= 10000000 then arr[i] = \"Eight\"\n           elsif i <= 9 &&\
    \ i >= 100000000 then arr[i] = \"Nine\"\n           else return end\n  }\n  arr.reverse\n\
    \  arr.map { |i| arr[i].to_s }\nend\n</code>\nThe above code doesn't handle all\
    \ the possible values of digit, for example, 0 is not handled (which is not what\
    \ OP wanted).\n<|/ a tags=ruby |>\n<| c |>\nHow is `10` handled? It is not in\
    \ the range `1..9`, it is in range `1..10`.\n<|/ c |>\n<| c |>\nOP mentioned that\
    \ \"the digits are grouped with one digit at the end\".\n<|/ c |>\n<| c |>\n`10\
    \ => One`, `100 => Two`, etc. But `0` is not handled because it is in the range\
    \ `1..9`, not in `1..10`.\n<|/ c |>\n<| c |>\nI edited the answer, the OP mentioned\
    \ \"grouped with one digit at the end\". So, I assumed that he wants digit as\
    \ whole and didn't want it handled. Thanks for pointing it out.\n<|/ c |>\n<|\
    \ c |>\nYes, you are right, thank you. Just one question: why `10` is not handled?\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  arr.sort! # sort arr\n  arr.reverse!",
  "  if arr.length == 1\n    arr = []\n    return []\n  else\n    arr = arr.sort_by\
    \ {|x| x.to_i}\n    arr = arr.reverse\n    arr.each_index do |i|\n      if arr[i].to_i\
    \ == 1\n        arr[i] = \"One\"\n      elsif arr[i].to_i == 2\n        arr[i]\
    \ = \"Two\"\n      elsif arr[i].to_i == 3\n        arr[i] = \"Three\"\n      elsif\
    \ arr[i].to_i == 4\n        arr[i] = \"Four\"\n      elsif arr[i].to_i == 5\n\
    \        arr[i] = \"Five\"\n      elsif arr[i].to_i == 6\n        arr[i] = \"\
    Six\"\n      elsif arr[i].to_i == 7\n        arr[i] = \"Seven\"\n      elsif arr[i].to_i\
    \ == 8\n        arr[i] = \"Eight\"\n      elsif arr[i].to_i == 9\n        arr[i]\
    \ = \"Nine\"\n      end\n    end\n    return arr\n  end\nend", "  if arr.length\
    \ == 0\n    arr = []\n  end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
