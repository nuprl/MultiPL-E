name: HumanEval_7_filter_by_substring
language: rb
prompt: "# Filter an input list of strings only for ones that contain given substring\n\
  # >>> filter_by_substring([], 'a')\n# []\n# >>> filter_by_substring(['abc', 'bacd',\
  \ 'cde', 'array'], 'a')\n# ['abc', 'bacd', 'array']\ndef filter_by_substring(strings,\
  \ substring)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_substring\n\
  \    candidate = method(:filter_by_substring)\n    assert_equal([], candidate.call([],\
  \ \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"\
  xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n    assert_equal([\"\
  xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"aaaxxy\"\
  , \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"))\n    assert_equal([\"grunt\", \"\
  prune\"], candidate.call([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
  ))\n  end\nend\n"
completions: ["  filtered_strings = []\n  strings.each do |str|\n    if str.include?(substring)\n\
    \      filtered_strings << str\n    end\n  end\n  return filtered_strings\nend",
  "  strings.select { |string| string.include?(substring) }\nend\n</pre>", "\tstrings\
    \ = strings.map {|s| s.downcase}\n\tstring.downcase!\n\tstrings.grep(Regexp.new(substring))\n\
    end", "  strings.grep(/^#{substring}$/)\nend", "  strings = strings.collect {\
    \ |s| s.downcase if s.downcase.include?(substring) }\n  strings.compact!\n  strings\n\
    end", "  strings.select { |string| string.include? substring }\nend", "  return\
    \ strings.select { |e| e.include?(substring) }\nend", "  return [s for s in strings\
    \ if substring in s]\nend", "  strings.each do |string|\n    string.include?(substring)\
    \ ? strings : nil\n  end\nend", "  strings.select { |s| s =~ /#{substring}/i }\n\
    end", "  strings.select do |string|\n    string.include?(substring)\n  end\nend",
  "  strings.select do |string|\n    string.index(substring) != nil\n  end\nend",
  "  return strings.select do |string|\n    string.include?(substring)\n  end\nend",
  "  strings.collect{|str| str.include?(substring) ? str : nil}.compact\nend", " \
    \   strings.select do |str|\n        str.index(substring) != nil\n    end\nend",
  "  strings.select { |s| s.include?(substring) }\nend", "  filtered_list = []\n \
    \ for string in strings\n    if string.include?(substring)\n      filtered_list\
    \ << string\n    end\n  end\n  filtered_list\nend", "  strings.select { |s| s.include?(substring)\
    \ }\nend", "  return strings.select do |string|\n    string =~ /#{substring}/\n\
    \  end\nend", "  result = nil\n  strings.each do |string|\n    if string.include?(substring)\n\
    \      result << string\n    end\n  end\n  return result\nend", "  return [string\
    \ for string in strings\n    if string.include?(substring)]\nend", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  result = []\n \
    \ strings.each do |string|\n    if string.include?(substring)\n      result <<\
    \ string\n    end\n  end\n  result\nend", "  filtered_strings = []\n  strings.each\
    \ do |string|\n    string =~ /^#{substring}/ ? filtered_strings << string : nil\n\
    \  end\n  filtered_strings\nend", "  return filter(partial(contains, substring),\
    \ strings)\nend", "  strings.select{|s| s.include?(substring)}\nend", "  strings.select!\
    \ do |string|\n    string.downcase.include?(substring.downcase)\n  end\nend",
  "  strings.select { |s| s.include?(substring) }\nend", "  new_strings = []\n  strings.each\
    \ do |string|\n    new_strings << string if string.include? substring\n  end\n\
    \  new_strings\nend", "  substrings = strings.map do |s|\n    if s =~ /#{Regexp.escape(substring)}/\n\
    \      s\n    end\n  end\n  substrings.compact\nend\n</code></pre>", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  strings.select{\
    \ |str| str.include?(substring) }\nend", "  return strings.select { |string| string.include?(substring)\
    \ }\nend", "  strings.select do |string|\n    string.index(substring) != nil\n\
    \  end\nend", "  strings_length = strings.length\n  substring_length = substring.length\n\
    \  new_strings = []\n  i = 0\n  while i < strings_length\n    if strings[i].to_s.length\
    \ <= substring_length\n      new_strings << strings[i]\n      i += 1\n    else\n\
    \      if substring === strings[i].to_s.slice(0,substring_length)\n        new_strings\
    \ << strings[i]\n      end\n    end\n  end\n  return new_strings\nend", "  substring\
    \ = substring || '\\0'\n  strings = strings.map do |string|\n    string.sub!(/#{Regexp.escape(substring)}(.|\\\
    0|$)*/, '')\n    string.empty? ? '' : string\n  end\n  strings.compact\nend",
  "  strings.select { |string| string.index(substring) != -1 }\nend", "  return strings.select\
    \ do |string|\n    string.index(substring) != -1\n  end\nend", "  strings.reject\
    \ do |e|\n    e.nil? || e =~ /^#{substring}/\n  end\nend", "  strings.select {\
    \ |string| string.include?(substring) }\nend", "  strings.select{ |s| s.include?(substring)\
    \ }\nend", "  new_strings = []\n  for string in strings\n    string.downcase!\n\
    \    string.gsub!(substring, \"\")\n    new_strings << string if string.length\
    \ > 0\n  end\n  new_strings\nend", "  strings.map! { |string| string.index(substring)\
    \ ? string : nil }\n  strings\nend", "  strings.select { |string| string.include?(substring)\
    \ }\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\nYou will need to use Ruby's Enumerable#grep\
    \ method:\n<code>\nstrings.grep /^\\w*#(\\w+)#\\w+/\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThanks, but I need to be able to filter by multiple substrings using\
    \ the same regex.  Is that possible with grep?\n<|/ c |>\n<| c |>\nYes, see http://www.ruby-doc.org/core-1.9.3/Enumerable.html#method-i-grep\n\
    <|/ c |>\n<| c |>\nYou will need to use Ruby's Enumerable#grep method.\n<|/ c\
    \ |>\n<| c |>\nI don't think this will work because your regex is looking for\
    \ multiple `#` characters, not a single one.\n<|/ c |>\n<| c |>\nGood catch. \
    \ I took out my earlier comment because I forgot to add the /x modifier to the\
    \ regex (since # is a regex metacharacter in ruby).\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>\n def filter_by_substring(string_list, *strings)\n  string_list.grep(/\\\
    A#(\\w+)#(\\w+)/) do |word|\n    strings.all? {|str| word.include?(str) }\n  end\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nHere is a version that uses\
    \ Enumerable#grep that can filter multiple strings by multiple substrings.  It\
    \ also uses Enumerable#slice_while to remove all those strings that contain other\
    \ strings.  Here is the code:\n<code>", "  strings.grep(Regexp.new(substring.to_s))\n\
    end", "  strings = strings.select { |string|\n    substring.include?(string)\n\
    \  }\n  strings\nend", "  strings.each do |s|\n    if s.include? substring\n \
    \     yield s\n    end\n  end\nend", "  strings.select do |string|\n    string.include?(substring)\n\
    \  end\nend\n</code>\n<|/ a dscore=2 tags=ruby,ruby-on-rails |>\n<| c |>\nThanks\
    \ i will try this and let you know.\n<|/ c |>\n<| c |>\nThis does not work. i\
    \ tried it on a string \"hello\" and substring \"lo\". It should return 'hello'\
    \ but it return nil.\n<|/ c |>\n<| c |>\nHm, I just tested it with a string that\
    \ contains `lo` and it returns `nil`. Did you try it on a string that does not\
    \ contain `lo`? I tested it on a string that contained `llo` and it returned `'llo'`.\n\
    <|/ c |>\n<| c |>\ni will try it again and let you know.\n<|/ c |>\n<| c |>\n\
    It returns nil if i try on a string that doesn't contain `lo`. Not sure why it\
    \ does not work for `lo` though.\n<|/ c |>\n<| a dscore=0 |>\nThis is my take\
    \ on this problem. \nFirst I used regex to find all strings that contain the substring:\n\
    <code>", "  filtered = Array.new(strings.size)\n  strings.each_with_index do |item,\
    \ i|\n    next if item !~ /#{substring}/i\n    filtered[i] = item\n  end\n  filtered\n\
    end", "    strings.select do |string|\n        string.index(substring) != nil\n\
    \    end\nend", "  strings.select { |s| s.include?(substring) }\nend", '    strings
    = strings.to_a', "  strings.reject do |string|\n    (string =~ /^.*#{Regexp.escape(substring)}$/).nil?\n\
    \  end\nend", "  strings.select do |s|\n    s.include?(substring)\n  end\nend",
  "  strings.select { |s| s.include?(substring) }\nend", "  return strings.select{|s|\
    \ s.include? substring}\nend", "    strings.select{ |string| string.include?(substring)\
    \ }\nend", "  substring.downcase!\n  filtered_strings = []\n  strings.each do\
    \ |string|\n    next if string == substring\n    filtered_strings << string\n\
    \  end\n  filtered_strings\nend", "  return strings.select do |string|\n    string.include?\
    \ substring\n  end\nend", "  return strings.select{|s| s.include?(substring)}\n\
    end", "  return strings.select { |s| s.include?(substring) }\nend", "    strings.select\
    \ { |string| string.include?(substring) }\nend\n</code>\n<code>", "  strings.select\
    \ { |s| s.include?(substring) }\nend", "  strings.select{|s| s.include?(substring)}.compact\n\
    end", "\tsubstrings.delete_if do |string|\n\t\tstring.include?(substring)\n\t\
    end\nend", "  strings.select do |string|\n    string.include?(substring)\n  end\n\
    end", "  strings.select do |s|\n    s.include?(substring)\n  end\nend", "  strings.map\
    \ { |string| string if string.index(substring) != -1 }\nend", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  return [string\
    \ for string in strings if string.include?(substring)]\nend", "  strings = strings.collect\
    \ { |s| s.downcase }\n  strings.select{ |s| s =~ /.*#{substring}.*/i }\nend",
  "  new_strings = []\n  strings.each do |string|\n    if string.include? substring\n\
    \      new_strings << string\n    end\n  end\n  new_strings\nend", "    substring_index(strings,\
    \ substring).inject([], :+)\nend", "  substrings = Array.new(strings.length, true)\n\
    \  strings.each do |s|\n    index = string.index(s, 0, substring.length)\n   \
    \ substrings[substrings[index]] = nil\n  end\n  substrings.compact\nend", "  strings.each\
    \ do |string|\n    return string if string.index(substring)\n  end\nend", "  strings.select\
    \ { |s| s.include?(substring) }\nend", "  strings.select do |string|\n    string.include?(substring)\n\
    \  end\nend", "  strings = strings.collect{|s| s.include?(substring) ? s : nil}\n\
    \  strings.compact\nend", "  strings.select { |s| s.include?(substring) }\nend",
  "  strings.select{|s| s.include?(substring) }\nend", "  filtered_strings = []\n\
    \  strings.each do |string|\n    if string.include? substring\n      filtered_strings\
    \ << string\n    end\n  end\n  filtered_strings\nend", "  strings.select { |s|\
    \ s.include?(substring) }\nend", "  substring_position = []\n  matches = []\n\
    \  matches_subset = []\n  strings.each do |s|\n    matches_subset = s.scan(substring)\n\
    \    matches_subset.each do |m|\n      matches.push(m)\n    end\n    substring_position.push(matches.count\
    \ > 0 ? matches.size : nil)\n  end\n  substring_position.max\nend", "  strings.select\
    \ { |s| s.include?(substring) }\nend", "  strings.select do |string|\n    string.include?(substring)\n\
    \  end\nend", "  strings.select do |string|\n    string.include?(substring)\n\
    \  end\nend", "  strings.select do |string|\n    string.include?(substring)\n\
    \  end\nend", "  substring = strings[0] if strings.length == 1\n  strings.select{|s|\
    \ s.include?(substring) }\nend", "  strings = strings.collect { |string| string.include?(substring)\
    \ ? string : nil }\n  strings.compact.collect { |string|\n    string.gsub(substring,\
    \ '').length } if strings\nend", "  strings.select { |s| s.include?(substring)\
    \ }\nend", "    filtered_strings = []\n    \n    strings.each do |string_to_filter|\n\
    \        filtered_strings.push(string_to_filter) if string_to_filter.index(substring)\
    \ != nil\n    end\n    \n    filtered_strings\nend", "    strings.select do |item|\n\
    \        (item.include?(substring))\n    end\nend", "  strings.select { |s| s.include?(substring)\
    \ }\nend", "  strings.select! do |string|\n    string.include?(substring)\n  end\n\
    end", "  strings.grep(/^.*#{substring}.*$/)\nend\n    ", "  strings.select{|s|\
    \ s.include?(substring)}\nend", "  strings.select do |item|\n    item.include?(substring)\n\
    \  end\nend\n</code>\n<|/ a dscore=5 tags=ruby,string,arrays |>\n<| c |>\nI like\
    \ the `count` solution better. It seems like it is more efficient.\n<|/ c |>\n\
    <| c |>\nI like the `count` solution better. It seems like it is more efficient.\n\
    <|/ c |>\n<| c |>\nI'm sorry but I'm not a ruby expert, so I might be wrong, but\
    \ that would only find the first occurrence, so if I passed this argument `['asd',\
    \ 'asdasd', 'asdasdasd']` it would still return `['asd', 'asdasd', 'asdasdasd']`\n\
    <|/ c |>\n<| c |>\nYeah, this is definitely not what you want if you want to find\
    \ the first occurrence, unless you start looking for from the end of the array,\
    \ or use `slice`.\n<|/ c |>\n<| c |>\nWhy don't you just use `include?` instead\
    \ of `include`?\n<|/ c |>\n<| a tags=ruby,string,arrays |>\nIf you want to do\
    \ something like .contains(\"a\"), then here is one solution:\n<code>\n[\"asdasd\"\
    , \"asdasdasdasd\"].select { |s| s.include?(\"a\") }\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\n`[\"asdasd\", \"asdasdasdasd\"].select { |s| s.include?(\"a\")\
    \ }` => `[\"asdasd\", \"asdasdasdasd\"]`\n<|/ c |>\n<| c |>\nThe downside to this\
    \ solution is that it will not return an empty array if you have nothing to return.\
    \  An empty array is not the same as an array with an empty string.\n<|/ c |>\n\
    <| c |>\nIf you don't want empty array to be returned (since it's empty), use\
    \ .find_index\n<|/ c |>\n<| c |>\n`.find_index` would return 0 if you search for\
    \ an empty string though, `find_index` would return `nil` if the element is not\
    \ in the array. `nil.to_i == 0` evaluates to true. So `[\"asdasd\", \"asdasdasdasd\"\
    ].select { |s| s.include?(\"a\") }.find_index(nil)` would return `0` which is\
    \ what you want.\n<|/ c |>\n<| c |>\nI like this solution, but I'm worried about\
    \ the readability of it. It's a pity that ", "  strings.select{|s| s.include?(substring)\
    \ }\nend", "  return strings unless strings\n  strings.select do |string|\n  \
    \  string =~ /^#{substring}/\n  end\nend\n</code>\n<|/ a tags=ruby-on-rails,activerecord,ruby-on-rails-3\
    \ |>\n<| c |>\nThis is what I am looking for. Thanks.\n<|/ c |>\n<| a |>\nThis\
    \ is my solution:\n<code>", "  return strings.select { |s| s.include?(substring)\
    \ }\nend", "  strings.select do |string|\n    string.index(substring) != nil\n\
    \  end\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI think this is the most elegant\
    \ solution so far. But it's probably overkill if you're not worried about performance.\n\
    <|/ c |>\n<| a dscore=4 |>\nYou can create your own function using Enumerable#select\n\
    <code>", "    strings.each { |string| string.index(substring) != nil ? strings.delete(string)\
    \ : nil }\n    strings\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI believe `strings.delete_if\
    \ { |string| string.index(substring) == nil } ` should be `strings.delete_if {\
    \ |string| string.index(substring) != nil } ` ?\n<|/ c |>\n<| c |>\nYes, you are\
    \ right, thank you. Will update the answer.\n<|/ c |>\n<| c |>\nJust a note -\
    \ using `delete_if` here would be better, as it keeps the original string unchanged:\
    \ `strings.delete_if(&:index(substring))`\n<|/ c |>\n<| a |>\nI think you can\
    \ use Ruby's grep method\n<code>\n['foo', 'bar', 'foobar'].grep(/bar/)\n=> [\"\
    bar\", \"foobar\"]\n</code>\n<|/ a dscore=5 tags=ruby |>\n<| c |>\nThis works\
    \ but it is more inefficient than other methods since it generates a new array.\n\
    <|/ c |>\n<| c |>\nThat is correct, and I think it's a bit of an anti-pattern\
    \ in Ruby to use `grep` like this, especially since it's so easily misunderstood.\n\
    <|/ c |>\n<| a dscore=5 |>\nUse Enumerable#grep\n<code>\narr = %w(foo bar foobar)\n\
    arr.grep(/bar/)\n</code>\n<|/ a tags=ruby |>\n<| a dscore=5 tags=ruby |>\nThis\
    \ works fine for me\n<code>", "  results = []\n  strings.each do |s|\n    if s.include?(substring)\n\
    \      results << s\n    end\n  end\n  return results\nend", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  strings.select{|s|\
    \ s.include?(substring)}\nend", "  strings.select do |string|\n    string.include?(substring)\n\
    \  end\nend", "  substring_length = strings.length\n  new_strings = []\n  i =\
    \ 0\n  while i < substring_length\n    if strings[i].include?(substring)\n   \
    \   new_strings << strings[i]\n    end\n    i += 1\n  end\n  return new_strings\n\
    end", "  return strings.select {|s| s.include?(substring) }\nend", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  matches = []\n\
    \  strings.each do |string|\n    if string.include?(substring)\n      matches.push(string)\n\
    \    end\n  end\n  matches\nend", "  strings.select do |string|\n    string.include?(substring)\n\
    \  end\nend", "  new_strings = []\n  strings.each do |string|\n    if string.include?(substring)\n\
    \      new_strings << string\n    end\n  end\n  return new_strings\nend\n</code>\n\
    <|/ a tags=ruby dscore=1 |>\n<| c |>\nI really like that one liner using Array#map.\
    \  Much better than my solution, which was actually two lines.  Thanks!\n<|/ c\
    \ |>\n<| c |>\nThat's definitely a better answer, thanks!  I'll see if I can convert\
    \ my code to that.  I was wondering if I could write a function that would filter\
    \ out any array elements that didn't contain the substring.  I didn't think of\
    \ using a conditional in an array, but that's pretty cool.  Thanks!\n<|/ c |>\n\
    <| a tags=ruby dscore=0 |>\nHere's my solution which only uses looping, but I'm\
    \ sure it could be optimized to run faster, but it works this way. I took out\
    \ the .split() because it's not necessary and would slow the code down.\n<code>",
  "  strings.select do |string|\n    string.include?(substring)\n  end\nend", "  substring_position\
    \ = strings[0].index(substring)\n  if substring_position\n    filtered_strings\
    \ = strings[0, substring_position].push(strings[1, substring_position - 1])\n\
    \  else\n    filtered_strings = strings\n  end", "  strings = case strings\n \
    \   when nil then []\n    when String then [strings]\n    else strings\n  end",
  "  strings = strings.collect {|s| s.gsub(substring, \"\")}\n  strings = strings.compact\n\
    \  strings\nend", "  strings.grep(/^.*#{substring}.*$/).map(&:first)\nend", " \
    \ strings.select{ |string| string.include?(substring) }\nend", "  strings.select\
    \ { |str| str.include?(substring) }\nend", "  strings.select { |s| s.include?(substring)\
    \ }\nend", "  substring = substring.to_s\n  result = []\n  \n  strings.each do\
    \ |string|\n    if string.include? substring\n      result << string\n    end\n\
    \  end\n  \n  result\nend\n</cell>\n<code language=julia-1.5>", "  return strings.select\
    \ { |string| string.include? substring }\nend", "  return [string for string in\
    \ strings if string.include? substring]\nend", "  filtered_strings = []\n  strings.each\
    \ do |string|\n    filtered_strings << string if string.include?(substring)\n\
    \  end\n  filtered_strings\nend", "  return strings.select do |string|\n    string.index(substring)\
    \ != nil\n  end\nend", "  strings.each do |str|\n    if str.include? substring\n\
    \      yield str\n    end\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nA\
    \ small tweak to return all if nothing is found: `def filter_by_substring(strings,\
    \ substring).reject {|str| str.include? substring} || []`\n<|/ c |>\n<| a dscore=3\
    \ |>\nI like using inject/reduce for this sort of thing.  \n<code>", "  result\
    \ = []\n  strings.each do |string|\n    string =~ /.*(#{Regexp.quote(substring)})/\
    \ && result << string\n  end\n  result\nend", "  strings = strings.map(&:downcase)\n\
    \  substr = substring.downcase\n  strings.reject do |string|\n    string.index(substr)\
    \ == nil\n  end\nend", "  matches = []\n  strings.each do |string|\n    if string.index(substring)\
    \ != nil\n      matches << string\n    end\n  end\n  return matches\nend", " \
    \ strings.each do |string|\n    if string.include? substring\n      yield string\n\
    \    end\n  end\nend", "  return strings.select do |s|\n    s.include?(substring)\n\
    \  end\nend", "\tstrings.select { |s| s.include?(substring) }\nend", "  strings.select\
    \ { |string| string.include?(substring) }\nend", "  return strings.select { |s|\
    \ s.include?(substring) }\nend", "  return [string for string in strings if substring\
    \ in string]\nend", "  strings.select { |str| str.include? substring }\nend",
  "  strings.select { |s| s =~ Regexp.new(\"(?i).*#{substring}.*\") }\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>", "  return strings.select { |string|\
    \ string.index(substring) != -1 }\nend", "  filtered_strings = []\n  filtered_strings\
    \ = strings.select do |string| \n    string.include?(substring)\n  end\n  filtered_strings\n\
    end", "  strings.select { |string| string.include?(substring) }\nend", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  strings.each do\
    \ |string|\n    i = string.index(substring)\n    string if i > 0\n  end\nend",
  "  strings.select{ |s| s.include?(substring) }\nend", "  strings.select do |string|\n\
    \    string =~ /^#{substring}/ ? string : nil\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\n`strings =~ /#{substring}` could just be `strings.any? { |string|\
    \ string =~ /^#{substring}/ }`\n<|/ c |>\n<| c |>\nThanks, I didn't know about\
    \ `any?`, but it seems more expressive for me. By the way, I think you meant `=~`,\
    \ not `=~=`, since `=~=` will match anywhere in the string, whereas `=~` will\
    \ match the start of the string, or else no match.\n<|/ c |>\n<| c |>\nYeah, I\
    \ did mean `=~`. In my actual code I do have `=~=` so I didn't bother changing\
    \ it unless you asked.\n<|/ c |>\n<| c |>\nThanks. I added a small improvement\
    \ which does not require that `strings` be a string, just a list of strings. I\
    \ think this may be a little more efficient, but I doubt it matters.\n<|/ c |>\n\
    <| c |>\nIt doesn't matter too much. In your version `strings =~ /^#{substring}/\
    \ ? strings : nil` is executed twice in the first `if` branch, while `strings.select\
    \ { |string| string =~ /^#{substring}/ }` is executed only once. In the end the\
    \ two are the same thing.\n<|/ c |>\n<| a tags=ruby |>\nI usually use this simple\
    \ method:\n<code>", "  strings.collect { |s|\n    if s.include?(substring)\n \
    \     s\n    else\n      nil\n    end\n  }.compact\nend", "  strings.select do\
    \ |string|\n    string.index(substring) != nil\n  end\nend", "  strings.collect\
    \ { |str|\n    if str.include?(substring)\n      str\n    end\n  }\nend", "  strings.each\
    \ do |string|\n    if string.include?(substring)\n      puts string\n    end\n\
    \  end\nend", "    strings.each do |string|\n        if string.include?(substring)\n\
    \            yield(string)\n        end\n    end\nend", "  strings.select{ |str|\
    \ str.include?(substring) }\nend", "    strings.select { |s| s.include?(substring)\
    \ }\nend", "  strings.select do |string|\n    string.include?(substring)\n  end\n\
    end", "    strings.select { |string| string.include?(substring) }\nend", "  strings.select{|s|\
    \ s.include?(substring)}\nend", "  strings.select do |str|\n    str.include? substring\n\
    \  end\nend", "  # Return a new list with strings from strings list filtered by\
    \ substring substring\n  new_strings = []\n  strings.each do |string|\n    if\
    \ (string.include?(substring))\n      new_strings << string\n    end\n  end\n\
    \  return new_strings\nend", "  return strings.select{|s| s.include?(substring)}\n\
    end", "  strings.select{ |s| s.include?(substring) }\nend", "  strings.grep(/^#{substring}$/)\n\
    end", "  result = []\n  strings.each do |string|\n    if string.include?(substring)\n\
    \      result << string\n    end\n  end\n  return result\nend", "  strings.select\
    \ { |s| s.include?(substring) }\nend", "  strings_with_substring = Array.new(strings.length)\n\
    \  strings.each_index do |i|\n    if strings[i].include?(substring)\n      strings_with_substring[i]\
    \ = strings[i]\n    end\n  end\n  strings_with_substring\nend", "  strings.select{|s|\
    \ s.include?(substring) }\nend", "  strings.select { |string| string.include?(substring)\
    \ }\nend", "  strings = strings.reject { |s| !s.include?(substring) }\n  strings\
    \ = strings.reject { |s| s.empty? }\n  return strings\nend", "  strings = strings.select{\
    \ |s| s.include?(substring) }\n  strings if strings.any?\nend", "  strings = [strings]\n\
    \  substring = [substring]", "  return strings.select{|s| s.include?(substring)}\n\
    end", "  strings.select { |s| s.include?(substring) }\nend", "  strings = strings\
    \ || []\n  substring = substring || ''", "    strings.collect do |string|\n  \
    \    if string.include?(substring)\n        string \n      else\n        \"\"\n\
    \      end\n    end\nend\n</code>\nThen I used it with the input you provided:\n\
    <code>\nstrings = ARGV.select do |string|\n  string =~ /^(\\w+)\\s+(\\w+)$/\n\
    end", "  strings.select do |string|\n    string.include?(substring)\n  end\nend",
  "  strings.select {|s| s.include?(substring) }\nend", "  strings.select { |str|\
    \ str.index(substring) != nil }\nend", "  strings.reject { |str| str.include?(substring)\
    \ }\nend", "  substring = substring ? substring.strip : ''\n  strings_with_substrings\
    \ = strings.select do |string|\n    string.include? substring\n  end\n  strings_with_substrings\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis should be the correct answer. Very\
    \ simple and clear. Thank you.\n<|/ c |>\n<| c |>\nI think this should be the\
    \ accepted answer.  It's the simplest solution.\n<|/ c |>\n<| c |>\nI find this\
    \ solution to be the best answer here. I think it is the most readable and most\
    \ elegant.\n<|/ c |>\n<| a dscore=3 |>\nThe easiest way is to use Ruby's grep\
    \ function:\n<code>\nstring = 'abccdeabc'\nstring.scan(/abc+/)\n=> [\"abc\", \"\
    abc\", \"abc\"]\n</code>\n<|/ a tags=ruby,string,arrays,filter |>\n<| c |>\nThis\
    \ doesn't work if you have multiple words you want to filter for, for example\
    \ if your string was `'abccdeabc123defg'`\n<|/ c |>\n<| a |>\nI came up with this:\n\
    <code>", "  return strings.select { |s| s.include?(substring) }\nend", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  return strings.select\
    \ do |string|\n    string.index(substring) != nil\n  end\nend", "    strings =\
    \ strings.map {|s| s.downcase.gsub(substring, \"\")}\n    strings.uniq.sort\n\
    end", "  filtered_strings = []\n  strings.each do |string|\n    if string.include?(substring)\n\
    \      filtered_strings << string\n    end\n  end\n  filtered_strings\nend", " \
    \ return strings.select do |s|\n    s =~ /#{substring}/\n  end\nend", "  strings.select\
    \ do |string|\n    string =~ /#{substring}/\n  end\nend", "  strings.select {|s|\
    \ s.include?(substring) }\nend", "  substring = substring.to_s\n  result = []\n\
    \  strings.each do |string|\n    if string.index(substring) == 0\n      result\
    \ << string\n    end\n  end\n  result\nend", "  strings.select{ |s| s.include?(substring)\
    \ }\nend", "  result = strings\n  result.select! do |item|\n    item.include?(substring)\n\
    \  end\n  result\nend\n</code>\n<|/ a |>\n<| c |>\nThe above code works well enough\
    \ for my needs but if you have any suggestions re the method name I would appreciate\
    \ it.  Thank you.\n<|/ c |>\n<| c |>\n: No worries. I updated the answer to provide\
    \ an alternate solution, also using `select!`.\n<|/ c |>\n<| c |>\nThanks for\
    \ your solutions, it appears that they are both really great solutions.\n<|/ c\
    \ |>\n<| a tags=ruby dscore=2 |>\nThis should work:\n<code>", "  strings.select!\
    \ { |string| string.index(substring) != nil }\n  strings\nend\n</code>\n<|/ a\
    \ tags=ruby,ruby-on-rails-3,ruby-on-rails,arrays,ruby-on-rails-3.1 |>\n<| a dscore=0\
    \ tags=ruby,ruby-on-rails-3,ruby-on-rails,arrays,ruby-on-rails-3.1 |>\nHere's\
    \ a way using inject:\n<code>\nstrings = [ 'abc', 'bacd', 'cde', 'array' ]", " \
    \ strings.select do |string|\n    string =~ /^#{Regexp.escape(substring)}$/ ?\
    \ true : false\n  end\nend", "  strings.select do |string|\n    string =~ /#{substring}/\n\
    \  end\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI think you meant `include?`\
    \ instead of `include`?\n<|/ c |>\n<| c |>\nIf you're using `Rails`, you can use\
    \ the `string` helper: `strings.include?(string)`. See: http://api.rubyonrails.org/classes/ActiveSupport/CoreExtensions/String/Inflections.html\n\
    <|/ c |>\n<| c |>\nI wish I could upvote this answer twice for the `include?`\
    \ tip (I couldn't for the last time I was searching for a similar solution)\n\
    <|/ c |>\n<| c |>\nThis is a great solution. Especially since Rails provides a\
    \ `String#include?` method. Thank you.\n<|/ c |>\n<| c |>\nThis worked perfectly\
    \ for my rails project. I wish I could give more than one thumbs up. Thank you!\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails |>\nAs an alternative to using inject you\
    \ can also use Enumerable#select (as suggested by):\n<code>\nstrings = ['aa',\
    \ 'ab', 'ac']\npattern = 'a'\nstrings.select { |str| str =~ pattern} # => [\"\
    aa\", \"ab\"]\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`string.match(pattern)` will\
    \ also work, and is probably faster.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n\
    One more option:\n<code>\nstrings = ['aa', 'ab', 'ac']\npattern = 'a'\nstrings.select\
    \ { |str| str.include?(pattern) }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is\
    \ the best answer on Stack Overflow. I had to look up `include?` in Ruby docs,\
    \ because it's not there, but it's the same method as `Regexp#match`\n<|/ c |>\n\
    <| c |>\n`String#include?` is also not available on 2.2\n<|/ c |>\n<| a dscore=4\
    \ |>\nI ran into a situation where using grep or select would throw errors about\
    \ undefined methods.\nI ended up doing a little more work to find the right one\
    \ for me (a very simple one). \n<code>\nstrings = ['aa', 'ab', 'ac']\npattern\
    \ = 'a'\nstrings.select { |str| str.include?(pattern) }\n</code>\nwill ", "  strings\
    \ = Array.new(strings.length) unless strings\n  strings.map {|s| s.sub(/#{substring}/,\
    \ '') }\nend", "  strings.select do |string|\n    string.include?(substring)\n\
    \  end\nend\n</code>\nTo get the last substring after the last occurrence of a\
    \ given substring (e.g., \"bar\"), you can use the following method:\n<code>",
  "  return strings.select { |s| s.include?(substring) }\nend\n</code>\n<|/ a tags=ruby,string,regex\
    \ |>\n<| a |>\nIf you don't want to rely on external libraries, you can easily\
    \ do something like this in Ruby:\n<code>", "  return strings.grep(/^#{substring}$/)\n\
    end", "  return strings.select do |str|\n    str =~ /#{substring}/\n  end\nend",
  "  return strings.select { |string| string.include?(substring) }\nend", "  strings\
    \ = strings.dup\n  ret = []\n  i = 0\n  while i < strings.length\n    if strings[i..i+string.length]\
    \ == substring\n      ret.unshift strings[i]\n      i += string.length\n    end\n\
    \    i += 1\n  end\n  ret\nend", "  filtered_strings = []\n  strings.each do |string|\n\
    \    if string.include?(substring)\n      filtered_strings << string\n    end\n\
    \  end\n  filtered_strings\nend", "  return strings[0..(strings.length - substring.length)].select\
    \ do |word|\n    word.include?(substring)\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
