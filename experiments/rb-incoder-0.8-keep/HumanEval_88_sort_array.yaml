name: HumanEval_88_sort_array
language: rb
prompt: "# Given an array of non-negative integers, return a copy of the given array\
  \ after sorting,\n# you will sort the given array in ascending order if the sum(\
  \ first index value, last index value) is odd,\n# or sort it in descending order\
  \ if the sum( first index value, last index value) is even.\n# Note:\n# * don't\
  \ change the given array.\n# Examples:\n# * sort_array([]) => []\n# * sort_array([5])\
  \ => [5]\n# * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n# * sort_array([2,\
  \ 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\ndef sort_array(array)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n\
  \    candidate = method(:sort_array)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([5], candidate.call([5]))\n    assert_equal([0, 1, 2, 3, 4, 5],\
  \ candidate.call([2, 4, 3, 0, 1, 5]))\n    assert_equal([6, 5, 4, 3, 2, 1, 0], candidate.call([2,\
  \ 4, 3, 0, 1, 5, 6]))\n    assert_equal([1, 2], candidate.call([2, 1]))\n    assert_equal([0,\
  \ 11, 15, 32, 42, 87], candidate.call([15, 42, 87, 32, 11, 0]))\n    assert_equal([23,\
  \ 21, 14, 11], candidate.call([21, 14, 23, 11]))\n  end\nend\n"
completions: ["  return array.sort{|a,b| b <=> a} if array.sum % 2 == 0\n  array.sort{|a,b|\
    \ a <=> b} if array.sum % 2 == 1\nend", "  array.sort.each {|v| v}\n  array\n\
    end", "  array.sort!\n  new_array = array.dup\n  if array.inject(0) {|sum, element|\
    \ sum + element}%2 == 1\n    new_array.sort!\n  end\n  new_array\nend", "  return\
    \ array.sort_by {|x| x if x.is_a?(Integer) }\nend", "  new_array = array.dup\n\
    \  new_array.sort!\n  new_array\nend", "    array.length <= 0 ? return array :\
    \ array.sort.with_index{ |val, i| val if i == array.length-1 || val if i == 0\
    \ }\nend", "  array.sort { |x, y| x <=> y } if array.sum == array.sum.odd?\n \
    \ array.sort { |x, y| x <=> y } if array.sum == array.sum.even?\n  array\nend",
  "  array.each do |element|\n    array.each do |i|\n      if element > array[i]\n\
    \        array[i] = array[i] + element\n        break\n      elsif element < array[i]\n\
    \        array[i] = element + array[i]\n        break\n      else\n        array[i]\
    \ = array[i] + element\n      end\n    end\n  end\n  array\nend", "  array = array.dup\n\
    \  array.sort!\n  array\nend", "  return array.sort.with_index do |(v, i1), (v,\
    \ i2)|\n    if i1 > i2\n      1\n    elsif i1 == i2\n      0\n    elsif v % 2\
    \ == 0\n      -1\n    else\n      1\n    end\n  end\nend", "  \n  # write your\
    \ code here\n  \nend", "  array.sort\n  array.compact!\n  array.compact!\n  array\n\
    end", "    arr = array.clone\n    arr.reverse\n    if arr.sum % 2 == 0\n     \
    \   arr.reverse\n    end\n    arr\nend\n    ", "  new_array = []\n  array_copy\
    \ = array.dup\n  odd = true", "  if array.length == 0 \n    return array\n  first\
    \ = array[0]\n  last = array.pop\n  array.push(last)\n  array.push(first)\n  array.sort!\n\
    \  array[0] -= array[1]\n  array.pop\n  return array\nend", "  array.each do |item|\n\
    \    next if item <= 0\n    if item % 2 == 1\n      array.push item\n    end\n\
    \  end\n  array\nend", "  return array.sort if array.sum.odd? || array.sum.even?\n\
    \  array.sort.reverse\nend", "  array.sort!\n  array\nend", "\tarray.sort!\n\t\
    array.each_with_index do |e, i|\n\t\tarray[i] = [e, i]\n\tend\n\tarray.sort! do\
    \ |a, b|\n\t\ta[0] <=> b[0]\n\tend\n\tarray.map do |e|\n\t\te[0]\n\tend\nend",
  "  array.sort!\n  if array.sum % 2 != 0 \n    array.sort! { |a,b| b <=> a }\n  else\n\
    \    array.sort! { |a,b| a <=> b }\n  end\n  array\nend", "\tarray.sort!\nend",
  "  return array.sort.reverse\nend\n</code>\n<|/ a |>\n<| c |>\nWhat is wrong with\
    \ using sort_by?\n<|/ c |>\n<| c |>\nit won't sort the array in descending order.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,arrays dscore=0 |>\nMy solution is to first\
    \ sort the array, then use reverse_each:\n<code>", "    sorted = array\n    sum\
    \ = 0\n    array.each do |item|\n        sum += item\n    end\n    if sum % 2\
    \ == 1\n        sorted.sort!\n    else\n        sorted.reverse!\n    end\n   \
    \ sorted\nend", "  array = array.sort.to_a\n  array.unshift(0)\n  array.pop if\
    \ array.length % 2 == 0\n  array\nend", "    sums = array.each_with_index.reduce(0)\
    \ { |sum, (a, i)| sum + a[i] }\n    sums.even? ? array.sort : -array.sort\nend\n\
    </code>\n<|/ a dscore=3 tags=ruby |>\n<| a dscore=3 |>\nI took advantage of Ruby's\
    \ Array#sum method, combined with Enumerable#partition:\n<code>", "  array.sort!\n\
    \  if array[0] + array[array.length-1] % 2 == 1\n    array.push(*array.last(array.size/2))\n\
    \    array.pop(1)\n  else\n    array.reverse!\n  end\n  array\nend", "\tnew_array\
    \ = []\n\ttemp = 0\n\tnew_array = [array[0]]\n\tarray.each do |number|\n\t\tif\
    \ number + array[array.length - 1] == array.length\n\t\t\tnew_array << number\n\
    \t\telsif number + array[array.length - 1] % 2 == 0\n\t\t\tnew_array << number\n\
    \t\telse\n\t\t\tnew_array << number\n\t\t\tnew_array << array[array.length - 1]\n\
    \t\tend\n\tend\n\tnew_array\nend", "  result = []\n  sum = array.inject(0, :+)\
    \ # sum of all elements in array\n  if sum % 2 == 0\n    result.concat(array.reverse)\n\
    \  else\n    result.concat(array)\n  end\n  result.sort\nend", "  array = array.to_a\n\
    \  array.sort!\n  return array\nend", "  return [] if array.blank?\n  array.sort!\n\
    \  array.each_with_index do |e, i|\n    if i % 2 == 1\n      array.insert(i, e\
    \ + 1)\n    end\n  end\n  return array\nend", "  array.each_with_index do |v,\
    \ i|\n    break if i == array.length-1\n    break if v == array[i+1]\n    break\
    \ if v % 2 == 0\n    array[i], array[i+1] = v + 1, v - 1\n  end\n  array\nend",
  "  if array.empty?\n    array\n  else\n    array.sort!\n    array\n  end\nend",
  "  array.sort\n  if array.length % 2\n    array.rotate\n  end\n  array.to_a\nend\n\
    </code>\n<|/ a tags=arrays,ruby,sorting dscore=0 |>\n<| a |>\nIf i got your question\
    \ right, you can do it like this:\n<code>\nx = [1, 2, 6, 1, 8, 1, 5, 3, 2, 9,\
    \ 4, 0]\nx.sort.each_cons(2).to_a", "  new_array = []\n  array.each do |i|\n \
    \   if array.length - 1 == i\n      new_array << i\n    end\n  end\n  new_array.sort!\
    \ do |i1, i2|\n    if array.length - 1 == i1\n      -1\n    else\n      i1 > i2\n\
    \    end\n  end\n  new_array\nend", "  new_array = array.dup\n  sorted_sum = 0\n\
    \  sum = 1\n  for i in 0...new_array.length\n    if new_array[i] != 0\n      sum\
    \ = sum + new_array[i]\n      if sum % 2 == 0\n        sorted_sum = sorted_sum\
    \ + new_array[i] \n      else\n        sorted_sum = sorted_sum - new_array[i]\
    \ \n    end\n  end\n  if sorted_sum % 2 != 0\n    new_array.sort_by!\n  end\n\
    \  return new_array\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nThis\
    \ looks like a good solution, but there's a bug: it returns [2, 1, 3, 2, 0] when\
    \ given [2,1,0,3,2]. You have to change `sorted_sum = 0` to `sorted_sum = i`.\n\
    <|/ c |>\n<| c |>\nThanks for your feedback. Yes, that is a typo. I just fixed\
    \ it.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  array.sort! # in place, sort in-place\n\
    \  if array.length % 2 == 0\n    array.reverse!\n  end\n  array\nend", "  array.sort!\n\
    \  array\nend", "  sorted = []\n  array.each do |i|\n    next unless i.odd?\n\
    \    sorted << i\n    sorted << i.last if i.last < i\n  end\n  sorted.sort!\n\
    \  sorted\nend", "  array = array.dup\n  array.sort!\n  array\nend", "  new_array\
    \ = []\n  if array.empty?\n    return new_array\n  end\n  sum = array[0]\n  new_array.push(array[0])\n\
    \  for i in 1...array.count\n    sum += array[i]\n    if sum % 2 == 0\n      new_array.push(array[i])\n\
    \    end\n  end\n  new_array.push(array[-1])\n  return new_array\nend", "    array.sort\
    \ { |a, b| a <=> b }\n    array\nend", "  sorted_array = array.dup\n  array_sum\
    \ = sorted_array.reduce(:+)\n  odd = array_sum % 2 == 1\n  if odd\n    sorted_array.reverse!\n\
    \  else\n    sorted_array.sort!\n  end\n  return sorted_array\nend", "  result\
    \ = array.dup\n  result.sort!\n  return result\nend", "  array.sort\n  array\n\
    end", "  result = []\n  sum = 0\n  array.each do |i|\n    sum += i\n    result\
    \ << i if sum % 2 == 1\n    result << -i if sum % 2 == 0\n  end\n  result\nend",
  "  return array.sort_by do |item|\n    if item % 2 == 0\n      -(item-1)\n    else\
    \ \n      item-1\n    end\n  end\nend", "  new_array = []\n  array.reduce([])\
    \ do |sum, value|\n    if sum % 2 == 1\n      new_array << value\n    else\n \
    \     new_array << -value\n    end\n  end\n  new_array\nend", "    sorted_array\
    \ = []\n    odd_sum = 0\n    even_sum = 0\n    sum_sum = array.inject(0, :+).to_i",
  "  array.sort!\n  sum1 = array[0] + array[-1]\n  if sum1 % 2 == 1\n    array.reverse\n\
    \  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  array.sort.with_index\
    \ { |value, index| \n    next if (value+array[index-1]+array[index] == 3)\n  \
    \  next if (value+array[index-1]+array[index] == -3)\n    array[index] = value\n\
    \  }\n  array\nend", "  result = array.dup\n  result.sort! { |a, b| a <=> b }\n\
    \  if result.sum % 2 == 1\n    result.sort! { |a, b| b <=> a }\n  end\n  result\n\
    end", "    array.sort!\n    sum = 0\n    array.each do |i|\n        sum += i\n\
    \        sum % 2 == 0 ? array << i : array << -i\n    end\n    return array\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nUsing Array#rotate:\n\
    <code>", "  new_array = []\n  array.each_with_index do |value, index|\n    if\
    \ value % 2 == 0\n      new_array << value\n    else\n      new_array << value.to_s\n\
    \    end\n  end\n  new_array.sort\nend", "    sum = 0\n    array.each do |x| sum\
    \ += x\n    array.sort { |x, y| sum == 0 && x > y ? 1 : sum == 0 && x < y ? -1\
    \ : 0 }\nend", "  return array.sort.inject([]){|sum,i| sum + i }\nend", "    array\
    \ = array.sort\n    if array.inject{|sum, val| sum + val}%2 == 1\n        array.reverse\n\
    \    end\n    array\nend", "  return array.sort\nend", "    array.sort\nend",
  "\tarray.sort!\n\tarray.sort! {|x,y| x == y ? 0 : (x > y ? -1 : 1)}\n\treturn array\n\
    end", "  array.sort!\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI agree with.\
    \ `array.sort!` should definitely be `array.sort`. As it is now, if `array` is\
    \ empty after calling `sort_array` it will raise an `IndexError`. The same applies\
    \ to `sort_array!(array)`.\n<|/ c |>\n<| c |>\nThe `sort!` method doesn't take\
    \ an argument so there's no need for the `!`. The `sort` method takes the argument\
    \ `&block` (a proc that receives a single argument).\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "    array.sort!\n    array.map { |x| x < 0 ? -x : x }\nend\n</code>\n\
    <|/ a tags=ruby,arrays,sorting dscore=2 |>\n<| c |>\nI like the sort method. Nice\
    \ one.\n<|/ c |>\n<| a dscore=2 |>\n<code>\narray = [0,1,2,3,4,5,6,7,8,9]\nsorted\
    \ = array.inject(&:+).sort_by{|x| [x.abs, -x]}.reverse\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| c |>\nThis answer is wrong when negative values are present. Try with\
    \ `array = %w{a b c d e f g h i j}` instead of `array = [0,1,2,3,4,5,6,7,8,9]`.\n\
    <|/ c |>\n<| a tags=ruby,arrays,sorting |>\nIn addition to the other answers,\
    \ there are a couple of ways of doing it\n<code>\narray.sort_by {|e| [e < 0 ?\
    \ -x : x, x]}\n</code>\nor\n<code>\narray.sort_by {|e| [e < 0 ? -x : x, e]}\n\
    </code>\nor\n<code>\narray.sort_by {|e| [e < 0 ? -x : e, e]}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like the `sort_by` method. Nice one.\n<|/ c |>\n<| a tags=ruby,arrays,sorting\
    \ |>\n<code>\narray.sort!\n</code>\nThis sorts the array in ascending order. If\
    \ you want the opposite, then\n<code>\narray.sort!.reverse\n</code>\nIf you want\
    \ to reverse the array in descending order, then\n<code>\narray.sort!.reverse!\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nBut he doesn't want to change the array,\
    \ he wants to return a new array.\n<|/ c |>\n<| c |>\nYou can't modify the array\
    \ in-place in Ruby, so it's better to create a new array. BTW, your two examples\
    \ are exactly the same, so it seems like you're not familiar with Ruby or programming\
    \ in general, so you need to read up on the basics first.\n<|/ c |>\n<| c |>\n\
    `array.sort!.reverse` will change `array`.\n<|/ c |>\n<| a |>\nIf you want a one-line\
    \ solution:\n<code>\narray.sort { |x, y| x < y ? -1 : y < x ? 1 : 0 }\n</code>\n\
    <|/ a dscore=1 tags=ruby,arrays,sorting |>\n", "  array.sort!\n  array\nend",
  "    array = array.sort\n    if array.sum.to_i % 2 == 1\n        array.sort!\n \
    \   else\n        array.sort!.reverse\n    end\n    array\nend", "  array.sort!\
    \ do |a,b|\n    (a+b).odd? ? 1 : -1\n  end\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nI assume you mean sorting the array in ascending order, but then you need\
    \ to switch the numbers that are odd if the sum is even, and switch the numbers\
    \ that are even if the sum is odd. To do this, you need to add some logic into\
    \ your existing code.\n<code>", "  return array.sort{|a,b| a<=>b } if array.sum\
    \ % 2 == 0 \n  return array.sort{|a,b| a<=>b }.reverse  if array.sum % 2 == 1\n\
    end", "  a = array.dup\n  a.sort!\n  if a.sum % 2 != 0\n    a.swap(0, a.length-1)\n\
    \  end\n  a\nend", "  array.sort.with_index do |e, i|\n    if i % 2 == 1\n   \
    \   array.insert(i, -e)\n    end\n  end\nend", "  array.sort!\nend", "  array.sort.with_index\
    \ { |i, index| i < index ? 1 : -1 }\n  array\nend", "  i = 0\n  j = 1\n  k = 0\n\
    \  while i < array.length\n    if array[i] > array[j]\n      array[k] = array[j]\n\
    \      j += 1\n      k += 1\n    else\n      array[k] = array[i]\n      i += 1\n\
    \      k += 1\n  end\n  array[k] = array[j]\n  j += 1\n  k += 1\n  array.length\
    \ = j\n  i = 0\n  j = 1\n  while i < array.length\n    if array[i] > array[j]\n\
    \      array[k] = array[j]\n      j += 1\n      k += 1\n    else\n      array[k]\
    \ = array[i]\n      i += 1\n      k += 1\n    end\n  end\n  array.length = k\n\
    \  i = 0\n  j = 1\n  k = 0\n  while i < array.length\n    if array[i] > array[j]\n\
    \      array[k] = array[j]\n      j += 1\n      k += 1\n    else\n      array[k]\
    \ = array[i]\n      i += 1\n      k += 1\n    end\n  end\n  array.length = k\n\
    \  i = 0\n  j = 1\n  k = 0\n  while i < array.length\n    if array[i] > array[j]\n\
    \      array[k] = array[j]\n      j += 1\n      k += 1\n    else\n      array[k]\
    \ = array[i]\n      i += 1\n      k += 1\n    end\n  end\n  array.length = j\n\
    \  return array\nend", "  result = array.dup\n  sort_array_helper(array, result)\n\
    \  result\nend", "  sorted = []\n  if array.length > 0\n    # sort by first index\n\
    \    sorted = array.sort! { |a, b| a.to_i > b.to_i ? 1 : -1 }\n    \n    # sort\
    \ by last index\n    sorted = array.sort! { |a, b| a.to_i < b.to_i ? 1 : -1 }\n\
    \  end", "  array.sort\n  i = 1\n  while i < array.length\n    if array[i-1] +\
    \ array[array.length-i] == 0\n      array[i-1], array[array.length-i] = array[array.length-i],\
    \ array[i-1]\n    else\n      i += 1\n  end\n  array\nend", "  return array.sort{|i,\
    \ j| (i[0] + i[-1]) if i % 2 != (j[0] + j[-1]) if i % 2 == 0 else i <=> j}\nend",
  "  array.sort! do |a,b|\n    if a%2 == b%2\n      1\n    elsif a%2 != b%2\n    \
    \  -1\n    end\n  end\n  array\nend", "  array.sort!\n  if array.length % 2 ==\
    \ 0\n    array.sort!.reverse!\n  end\n  array\nend", "  array.sort\n  return array\n\
    end", "  return array.sort.to_a.reverse.sort.to_a\nend", "  array.sort.with_index\
    \ do |element, i|\n    # return if element <= 0\n    element <= 0 ? break : element\
    \ == 0 ? i : element == array[i-1] + array[i+1] ? -1 : i\n  end\nend", "  array.sort!\n\
    end", "  array.sort.with_index { |e, i| i }\nend\n</cell>\n<text>\n\u56DE\u7B54\
    :", "  array.each_with_index do |v, index|\n    array.delete_at(index)\n    break\
    \ if index == 0\n    array[0] = array[index-1]\n    array[index-1] = v\n  end\n\
    \  array\nend", "  if array.is_a? Integer\n    array.sort\n  elsif array.is_a?\
    \ Array\n    array.sort do |a, b|\n      a>b ? 1 : a<b ? -1 : 0\n    end\n  else\n\
    \    puts \"Invalid Arguments: #{array.inspect}\"\n    puts \"Type #{array.class}\
    \ #{array.inspect}\"\n  end\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\n\
    This will not work for negative numbers\n<|/ c |>\n<| c |>\nYes, you're right.\
    \ I've corrected my answer. Thanks.\n<|/ c |>\n<| c |>\n`sort_with_index` takes\
    \ two arguments, so you might as well use `sort_with_index { |a| [a, self[a]]\
    \ }`. BTW, `sort_by` does accept a block.\n<|/ c |>\n<| a tags=ruby |>\nThis may\
    \ be what you want. This will sort an array in ascending order if the sum of the\
    \ first and last elements is odd, or descending order if the sum is even.\n<code>",
  "  return array.sort.with_index { |a, b| [a, b] }\nend", "  array.sort! { |i, j|\
    \ i < j ? 1 : -1 }\nend", "    sorted = []\n    array = array.sort{|x,y|x<=>y}\n\
    \    total = array.inject{|sum, value| sum + value}\n    puts \"Total: #{total}\"\
    \n    if total % 2 == 1\n        sorted = array.sort{|x,y|y<=>x}\n    else\n \
    \       sorted = array.sort{|x,y|x<=>y}\n    end\n    puts \"Sorted Array: #{sorted}\"\
    \n    return sorted\nend", "  array.sort\n  odd_sum = 0\n  even_sum = 0", "  array.sort!\n\
    \  case array.sum % 2 != 0\n  then array.sort!.reverse\n  else array.sort!\n \
    \ end\n  array\nend", "  # TODO: implement this function in an efficient way\n\
    \  array.sort.with_index do |value, index|\n    if index % 2 == 0\n      value.to_i\
    \ + array[index -1].to_i\n    elsif index % 2 == 1\n      value.to_i + array[index\
    \ -1].to_i\n    end\n  end\nend", "  array.sort!\nend", "    sorted = array.dup\n\
    \    sum = 0\n    sum1 = array.inject(:+)\n    sum2 = sorted.inject(:+)", "  sorted_array\
    \ = []\n  array.each do |i|\n    if i % 2 == 0\n      sorted_array << i\n    end\n\
    \  end\n  sorted_array.sort!\n  return sorted_array\nend", "  return array.sort.to_a\n\
    end", "  return array.sort\nend", "  i = 0\n  sum = 0\n  new_array = []\n  while\
    \ i < array.length\n    if array[i] == 0\n      sum = 0\n      i += 1\n    elsif\
    \ array[i] > 0\n      if sum % 2 == 1\n        sum += array[i]\n        new_array.push(array[i])\n\
    \      else\n        sum -= array[i]\n      end\n      i += 1\n    end\n  end\n\
    \  new_array.sort.reverse\n  return new_array\nend", "  sum = 0\n  i = 0\n  sum\
    \ = 0\n  while i < array.length\n    sum += array[i]\n    i += 1\n    if sum %\
    \ 2 == 0\n      array.swap(0, 1)\n      sum -= 1\n    end\n  end\n  array\nend",
  "  array.sort {|a, b| a <=> b}\n  array\nend", "  array.sort!\n  array\nend", " \
    \   array.sort!\n    return array\nend", "  sorted = array.dup\n  sorted.sort_by!\
    \ do |i|\n    if i[0] % 2 != 0\n      sorted.reverse!\n    end\n  end\n  sorted\n\
    end", "  array.sort!\nend\n</code>\nThe above function simply sorts the array\
    \ using Ruby's sort method. However, Ruby's sort method only sorts arrays in ascending\
    \ order if the sum of the first and last element of an array is odd. If the first\
    \ and last element of an array are even, Ruby's sort method does not sort that\
    \ array in ascending order. Instead, Ruby's sort method sorts the array in descending\
    \ order.\nHowever, I noticed that when I used Ruby's sort method and my conditional\
    \ statement did not work, I was able to get the descending order when I replaced\
    \ the sort method with my own (by calling my own sort method and modifying the\
    \ conditional statement). However, when I replaced the sort method with Ruby's\
    \ sort method, my code did not work.\nSo, why does Ruby's sort method not work\
    \ in the following situation?\n<code>\nif sum( array[0], array[-1]) % 2 == 0 then\n\
    \  array.sort!\nelse\n  array.sort\nend\n</code>\nMy code does not work. When\
    \ I test my code using Ruby 1.8.7 and Ruby 1.9.3, I got different outputs. However,\
    \ I got different results when I ran my code using Ruby 1.9.3 and Ruby 1.8.7.\
    \ I am thinking that there is something wrong with my conditional statement, but\
    \ I am not sure. \nSo, my questions are:", "  return array.sort.with_index do\
    \ |value, index|\n    if index % 2 == 0\n      value\n    elsif index % 2 == 1\n\
    \      -value \n    else\n      -index\n    end\n  end\nend\nprint(sort_array([0,2,3,4,5,6,7,8]))\n\
    print(sort_array([1,2,3,4,5,6,7,8,0]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2]))\n\
    print(sort_array([-2,-2,-2,-2,-3,-2,-1,0,2]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-1]))\n\
    print(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,0]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,2]))\n\
    print(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,2]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,2]))\n\
    print(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,2]))\n\
    print(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\n\
    print(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\n\
    print(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\n\
    print(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\n\
    print(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\n\
    print(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\n\
    print(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\n\
    print(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\n\
    print(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\n\
    print(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\nprint(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\n\
    print(sort_array([-2,-2,-2,-2,-2,-2,-2,-2,-2,-2]))\nprint(", "  array = array.sort\n\
    \  if array.length % 2 != 0\n    array.reverse\n  end\n  array\nend", "  if array.is_a?(Array)\n\
    \    array.sort do |a, b|\n      a = array[a]\n      b = array[b]\n      a = a.to_i\
    \ if a.is_a?(Float)\n      b = b.to_i if b.is_a?(Float)\n      a <=> b\n    end\n\
    \  else\n    raise \"Argument should be an Array type\"\n  end\nend\n</code>\n\
    <|/ a |>\n<| a |>\nHere is an alternate method that doesn't require sorting the\
    \ array. \nThe idea is to calculate the sum of all the elements within the range,\
    \ and then check if the sum is odd or even, and either add or subtract the appropriate\
    \ amount.\n<code>", "  array.sort!\n  i = 0\n  n = 0\n  while i < array.length\n\
    \    n += array[i].to_i\n    if n % 2 == 0\n      array = array[1..-1]\n    else\n\
    \      array.insert(i, array[-1..-1])\n      array.pop\n    end\n    i += 1\n\
    \  end\n  array\nend", "  return array.sort_by{|i| [(i[1..-1]).to_i, i[0...1]]}\n\
    end", "    # write code here\n    array = array.sort\nend\n</code>\n<|/ a |>\n\
    <| c |>\nYou should always explain what you are doing in your answers.  Even if\
    \ you don't know what you are doing.\n<|/ c |>\n<| c |>\nThis does not meet the\
    \ requirements, even though it does meet the requirements because a sorting algorithm\
    \ does not require the original array.\n<|/ c |>\n<| c |>\nThe question says \"\
    you will sort the given array in ascending order if the sum( first index value,\
    \ last index value) is odd, or sort it in descending order if the sum( first index\
    \ value, last index value) is even.\" Your code does exactly that.\n<|/ c |>\n\
    <| c |>\nThe question says \"you will sort the given array\".  I do NOT say \"\
    you will sort _a_ given array\".  I only say \"you will sort the given array\"\
    .\n<|/ c |>\n<| a tags=ruby,sorting |>\nHere is a simple solution to the problem:\n\
    <code>", "  return array.sort\nend", "    array.sort! { |a,b| a <=> b }\n    return\
    \ array\nend", "  if array.length < 2\n    array\n  else\n    array.sort {|a,b|\
    \ [a,b].sum % 2 <=> [b,a].sum % 2 }\n  end\nend", "  array.sort!\n  array = array.sort!\n\
    \  array = array.sort!\n  array\nend", "  sorted_array = array.dup\n  sorted_array.sort!\
    \ do |a, b|\n    if a + b > 0\n      if a.odd? && a.last <= b\n        -1\n  \
    \    elsif b.odd? && b <= a.last\n        1\n      else\n        0\n      end\n\
    \    elsif a + b == 0\n      0\n    else\n      -1\n    end\n  end\n  sorted_array\n\
    end", "    # Your Code Here\nend", "  array.sort\nend", "  array.sort\nend", " \
    \   sorted = []\n    array.each do |i|\n      j = i + 1 if sum(i) + sum(i) ==\
    \ i\n      sorted.push(i) if j % 2 == 1\n      sorted.push(i) if j % 2 == 0\n\
    \    end\n    sorted.sort\n  end\nend\n</code>\n<|/ a tags=algorithm,ruby,ruby-on-rails\
    \ dscore=0 |>\n<| c |>\nThanks for answering, but I think this approach would\
    \ work only for certain sizes of arrays, no? \nE.g. If there are two arrays A\
    \ and B of lengths n and m respectively, the complexity of the solution would\
    \ be O(n+m). I want a solution which would work for all sizes of arrays.\n<|/\
    \ c |>\n<| c |>\nYes, it's good for the cases you mentioned, but it won't be easy\
    \ to generalize, i.e. when you have more than 2 arrays. I don't think there's\
    \ an easier solution (at least not that I can think of).\n<|/ c |>\n<| c |>\n\
    I agree that it is not straight forward to generalize it generally, I hope we\
    \ get some better solutions.\n<|/ c |>\n<| a |>\nHere is an interesting problem\
    \ that I came across recently.\nYou are given two arrays of non-negative integers,\
    \ A and B, and you decide to put them together in the most efficient way possible.\n\
    The elements of array A are in the range 1 to n, and elements of array B are in\
    \ the range 1 to m.\nWe are given two arrays A and B of length n and m respectively,\
    \ and we want to know what is the least number of elements we can insert from\
    \ array A to array B to make them have equal sum.\n<code>\nExample:", "    sum\
    \ = array.sum\n    odd = sum % 2 == 1\n    array.sort.with_index { |v, i| odd\
    \ == (i % 2 == 0) ? v : -v }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks,\
    \ but what about when the array has negative values?\n<|/ c |>\n<| c |>\n`array.sort.with_index\
    \ { |v, i| odd == (i % 2 == 0) ? v : -v }` changed to `array.sort.with_index {\
    \ |v, i| odd == (i % 2 == 0) ? v : v <=> -v }`\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>\narray.sort.with_index { |v, i| odd == (i % 2 == 0) ? v : -v }\n</code>\n\
    That is equivalent to:\n<code>\narray.sort.with_index { |v, i| odd == (i % 2 ==\
    \ 0) ? -v : v }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis answer is more correct\
    \ than the others.\n<|/ c |>\n<| c |>\n: This answer is incorrect. If the array\
    \ was `[3, 2, 1]`, this would give `[2, 1, 3]` instead of `[1, 2, 3]`.\n<|/ c\
    \ |>\n<| c |>\nThis answer is definitely incorrect because it is only correct\
    \ for arrays that only have negative numbers. In case of the original question\
    \ it will yield [3,-2,1], which clearly is not the desired result.\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>\narray.sort.with_index { |v, i| odd == (i % 2 == 0)\
    \ ? v : -v, odd = true }\n</code>\n<|/ a dscore=5 |>\n<| a dscore=5 |>\n<code>\n\
    array.sort.with_index { |v, i| odd == (i % 2 == 0) ? v : v <=> -v }\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nthis answer is more correct than the others.\n<|/\
    \ c |>\n<| a |>\nHere is another variant of solution:\n<code>", "  array.dup.sort.tap{|array|\n\
    \    if array.length<2\n      array\n    elsif array.length % 2==0\n      array.reverse\n\
    \    else\n      array\n    end\n  }\nend", "  array.sort!\n  return array\nend",
  "  array.sort.with_index do |x, i|\n    if i % 2 == 1\n      -1 * x\n    else\n\
    \      x\n    end\n  end\nend", "    array.sort! { |x, y| x >= y }\n    array\n\
    end\nputs sort_array(gets).join(\"\\n\") if $0 == \"-e\"\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays\
    \ |>\n<| a dscore=3 |>\nThe most elegant and simple way would be to use the Array#partition\
    \ method of the Enumerable, which partitions the array into two arrays based on\
    \ a condition.\nThe condition would be \"the sum of first two elements\" is odd,\
    \ which means that the sum would have to be even.\n<code>", "  sorted_array =\
    \ array\n  sorted = array.sort {|a, b| b <=> a}\n  return sorted_array if sorted.empty?\n\
    \  odd_sum, even_sum = 0, 0\n  array.each_index do |i|\n    if array[i] % 2 ==\
    \ 0\n      even_sum += array[i]\n    else\n      odd_sum += array[i]\n    end\n\
    \  end\n  odd_sum == even_sum ? sorted_array = sorted : sorted_array = sorted.reverse\n\
    end", "  array.sort!\n  array.each_with_index do |n, i|\n    if i % 2 == 0 then\n\
    \      array[i] = n-array[i]\n    end\n  end\n  return array\nend", "  array.sort!\n\
    \  even = array.first + array.last\n  odd = even - (array.first + array.last)\n\
    \  return even.odd? ? array.dup : odd.even? ? array.dup :\n    even > odd ? array.dup\
    \ :\n    odd.even? ? array.dup :\n    even < odd ? array.dup :\n    array.dup\n\
    end", "  array.sort.reverse.each do |i|\n    if array[i] % 2 == 0\n      array.reverse!\n\
    \    end\n  end\n  array\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\n\
    Can you add a description to your answer? What does your code do? How does it\
    \ work?\n<|/ c |>\n<| a |>\nThis solution uses the inject method and sums up all\
    \ the elements of the array and checks if the sum is odd or even and reverses\
    \ the order of the array if needed. The method call is then straight forward:\n\
    <code>\na = [6, 5, 4, 3, 2, 1, 0]\na.inject(&:+).odd? ? a.reverse! : a", "  if\
    \ array.size < 2\n    array\n  else\n    odd_sum = array.sum % 2 == 0 ? array.sum\
    \ : array.sum - array.sum % 2\n    even_sum = array.sum % 2 == 0 ? array.sum +\
    \ 1 : array.sum - 1\n    sorted_array = array.sort.reverse.map do |element|\n\
    \      if odd_sum > even_sum\n        [element, element]\n      else\n       \
    \ [element, element + even_sum]\n      end\n    end\n    sorted_array.first\n\
    \  end\nend", "    sum = 0\n    array.each { |n|\n        if n % 2 == 0\n    \
    \        sum += n\n        else\n            sum -= n\n            break\n   \
    \     end\n    }", "  array.sort\nend", "    array2 = array.clone\n    if array2.empty?\n\
    \        return array2\n    array2.sort!\n    return array2\nend", "  array.sort!\
    \ # Sort array in ascending order.\n  if array.is_a? Integer\n    array\n  elsif\
    \ array.is_a? Array\n    sort_array(array)\n  end\nend", "  # write code here\n\
    \  array.sort.each {|x| break x if x.even?}\n  array.sort.each {|x| break x if\
    \ x.odd?}\nend\n</code>\n<|/ a |>\n<| c |>\nThe answer is not what the question\
    \ was asking for, which is *sort in ascending order if the sum( first index value,\
    \ last index value) is odd, or sort it in descending order if the sum( first index\
    \ value, last index value) is even*.\n<|/ c |>\n<| c |>\nThis only works if all\
    \ numbers in the array are positive. Try with [-5, -1, 0, 1, 2, 3, -4, -5]\n<|/\
    \ c |>\n<| c |>\nthe question already states that it sorts in ascending order.\
    \ Try it out to see for yourself.\n<|/ c |>\n<| c |>\nAhh I see. Thank you for\
    \ pointing that out. My bad.\n<|/ c |>\n<| c |>\nWhy don't you just `sum = array.inject(0)\
    \ {|sum, el| sum + el}` and sort based on that?\n<|/ c |>\n<| a dscore=5 tags=arrays,ruby\
    \ |>\n<code>\narray.sort {|a, b| a.to_i + b.to_i }\n</code>\n<|/ a |>\n<| c |>\n\
    This doesn't work for negative numbers.\n<|/ c |>\n<| c |>\nI used the above with\
    \ negative numbers and it works.  My array was [-51,-47,51,47,70].\n<|/ c |>\n\
    <| c |>\nThis should be the accepted answer! It uses the `Integer#to_i` method\
    \ which converts the array elements to Integers! See http://ruby-doc.org/core-2.2.3/Integer.html#method-i-to_i\
    \ for more information.\n<|/ c |>\n<| c |>\nThis is also not efficient for large\
    \ arrays.\n<|/ c |>\n<| c |>\nThis is the fastest solution, by far.\n<|/ c |>\n\
    <| a tags=arrays,ruby dscore=5 |>\nUse sort_by\n<code>\n[5,2,4,3,0,1,2].sort_by\
    \ { |x| x.to_i }\n</code>\n<|/ a |>\n<| c |>\nThis works for the given array,\
    \ but it's more complicated than it needs to be. `sort_by` is exactly the right\
    \ tool for this job.\n<|/ c |>\n<| c |>\nThis is very useful as it is able to\
    \ use the standard < and > operators, which is useful", "  array.sort! do |a,\
    \ b|\n    a <=> b\n  end\nend", "  array.sort.with_index { |v, i| i if i%2 ==\
    \ 0 }.tap(&:reverse!)\nend", "  return array.sort\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| c |>\nThanks Stefan. This is the only answer so far that correctly sorts\
    \ the array (I tested it on [3,4,1] and it correctly returned [1,2,3]).  Your\
    \ explanation about sorting an array is much more thorough than mine.\n<|/ c |>\n\
    <| c |>\n`array.sort` is not an Array method, it's a method of Array class, and\
    \ is actually a private method. `array.sort` will sort the array in place and\
    \ returns nil.\n<|/ c |>\n<| c |>\nHmmm... I guess I haven't been paying enough\
    \ attention.  Thanks, Stefan.\n<|/ c |>\n<| c |>\nThis solution is better than\
    \ the accepted answer. Using `array.sort_by(&:first)` fails if two values are\
    \ equal, which is undesirable.\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>",
  '  array.sort!', "  array.sort\nend\n</cell>\n<code language=julia-1.5>\nsort_array([])\n\
    </cell>\n<code language=julia-1.5>\nsort_array([5])\n</cell>\n<code language=julia-1.5>\n\
    sort_array([2, 4, 3, 0, 1, 5])\n</cell>\n<code language=julia-1.5>\nsort_array([2,\
    \ 4, 3, 0, 1, 5, 6])\n</cell>\n<code language=julia-1.5>", "  sorted_array = array.clone\n\
    \  array = array.sort\n  i = 0\n  while i < array.length - 1\n    if array[i]\
    \ != array[i + 1]\n      if array[i].odd?\n        sorted_array.push(array[i])\n\
    \      else\n        sorted_array.push(array[i + 1])\n    end\n    i += 1\n  end\n\
    \  sorted_array.push(array[i])\n  return sorted_array\nend", "  array.sort.each\
    \ { |i| array.swap(array.index(array.sum - i), (array.index(array.sum + i) + 1))\
    \ if array.sum + i != i }\n  array\nend", "  array = array.clone\n  array.sort!\
    \ do |i1, i2|\n    if i1 == 0\n      i1 == i2 ? 0 : (1 - (i1 + i2))\n    elsif\
    \ i2 == 0\n      i1 == i2 ? 1 : (1 - (i1 + i2))\n    else\n      (i1 + i2)\n \
    \   end\n  end\n  array\nend", "  array.sort!\n  odd?(array) ? array.reverse!\
    \ : array\nend", "  array.sort.with_index do |value, index|\n    sum_value = index\
    \ * 2 + 1\n    odd = sum_value % 2\n    if odd\n      value\n    else\n      value.reverse\
    \ if index == 0\n      value.reverse\n    end\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nHi Jackylu, thanks for your answer. I've tried your answer but\
    \ the array still doesn't seem to be sorted.\n<|/ c |>\n<| c |>\nCan you post\
    \ your original array and your current solution. Maybe you can see where the issue\
    \ is.\n<|/ c |>\n<| a dscore=1 |>\nIf you have Ruby >= 2.3\n<code>\narray.sort_by\
    \ { |e| -e[-1] % 2 }\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nThis would\
    \ be a great answer, but it seems Ruby 2.3 didn't have `sort_by`\n<|/ c |>\n<|\
    \ a tags=arrays,ruby |>\nA simple sort algorithm that works on any number of elements:\n\
    <code>", "  # write your code here\n  if array.length <= 0\n    return array\n\
    \  end", "  array.sort!\n  result = []\n  last_index = array.length - 1\n  (0...last_index).each\
    \ do |i|\n    sum = array[i] + array[i + 1]\n    result << i if sum % 2 == 0\n\
    \    result << i + 1 if sum % 2 == 1\n  end\n  result\nend", "  array = array.sort\n\
    \  \n  odd_sum = array.inject(0){|sum,e| sum + e % 2 }\n  even_sum = array.inject(0){|sum,e|\
    \ sum + e % 2 }\n  \n  if odd_sum % 2 == 1\n    array.sort!\n  else\n    array.reverse!\n\
    \    array.sort!.reverse!\n  end\n  return array\nend", "  array = array.dup\n\
    \  if array.empty?\n    array\n  else\n    # Calculate the sum\n    sum = array.first\n\
    \    array.delete_if { |x| x < 0 }\n    array.each { |x| sum += x }\n    # Sort\
    \ array in ascending order if the sum is odd\n    sum % 2 ? array.sort { |x,y|\
    \ x < y } : array.sort { |x,y| x > y }\n  end\nend", "  # Your code here\n  sum\
    \ = 0\n  array.each_index { |i| sum += array[i] }\n  i = 1\n  while i <= array.length\n\
    \    if sum % 2 == 1\n      array.insert(i, array.pop)\n      i += 1\n    elsif\
    \ sum % 2 == 0\n      array[i], array.insert(i - 1, array.pop)\n      i += 1\n\
    \    end\n  end\n  array\nend", "  array.sort! do |a, b|\n    a > b if sum(a,\
    \ b) % 2 == 1\n    a < b if sum(a, b) % 2 == 0\n    a <=> b\n  end\nend", "  \
    \  i = 0\n    sum = 0\n    odd = true\n    even = true\n    \n    while i < array.length\n\
    \        sum = array[i] + array[i]\n        if odd === true\n            if sum\
    \ > array.length\n                array.push(array[array.length-1])\n        \
    \        array.length -= 1\n            elsif sum < 0\n                odd = false\n\
    \                i += 1\n            end\n        elsif even === true\n      \
    \      if sum < 0\n                array.push(array[i])\n                array[i]\
    \ -= 1\n            elsif sum > array.length\n                array.push(array[i])\n\
    \                array[i] += 1\n            end\n        else\n            i +=\
    \ 1\n        end\n    end\n    \n    return array\nend", "  array.sort!\nend",
  "  array.sort.with_index { |o, i| o=i%2 == 0 ? -1 : 1 }\n  array\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\n`array.sort.with_index { |o, i| o=i%2 == 0 ? -1 :\
    \ 1 }`\n<|/ c |>\n<| c |>\nIf you don't want a temporary variable you can write\
    \ it like this:\n`array.sort.with_index { |e, i| i%2 == 0 ? e : -e.reverse }`\n\
    <|/ c |>\n<| c |>\n: That's awesome. I didn't know that `sort` accepts a block.\
    \ Good tip.\n<|/ c |>\n<| c |>\nThis answer is perfect for me, the other answers\
    \ are so much more complex and hard to read and maintain than this one.\n<|/ c\
    \ |>\n<| c |>\nJust a little bit of change is needed. This code would sort like\
    \ [3,2,1]. Add `.reverse` after `|e, i| i%2 == 0 ? e : -e.reverse` to get [3,2,1].\
    \ Also if you need to reverse the array then `array.sort.with_index { |e, i| i%2\
    \ == 0 ? e : -e.reverse }.reverse` does the job. \nAlso if you want to use this\
    \ code somewhere else then you can add this as method `def sort_array(array)\n\
    \  array.sort.with_index { |e, i| i%2 == 0 ? e : -e.reverse }.reverse\n  array\n\
    end`\n<|/ c |>\n<| a tags=ruby,sorting,arrays dscore=5 |>\nI like to use sort_by\
    \ for this sort of situation\n<code>\n[3, 1, 2, 4].sort_by { |x| x.to_i }\n=>\
    \ [1, 2, 3, 4]\n</code>\nTo get the reverse order, just flip the sign:\n<code>\n\
    [3, 1, 2, 4].sort_by { |x| -x.to_i }\n=> [4, 3, 2, 1]\n</code>\nIf you need to\
    \ reverse the array, just append .reverse:\n<code>\n[3, 1, 2, 4].sort_by { |x|\
    \ -x.to_i }.reverse \n=> [4, 3, 2, 1]\n</code>\n<|/ a |>\n<| c |>\nThis also works\
    \ if you change it to `x.to_i` (or to `x.to_f`) since it compares them as floats\
    \ instead of ints.\n<|/ c |>\n<| c |>\nThis works, but the sort by { |x| x.to_i\
    \ } is sorted by string length, not numerical ", "  array.sort\nend", "    # write\
    \ your code here\n  array.each do |n|\n      if n % 2 == 0\n          sorted.push(n)\n\
    \      else\n          sorted.push(n)\n          sorted.push(array.size)\n   \
    \   end\n  end", "  array.sort!\n  \n  i = 0\n  last_index = array.size-1\n  while\
    \ i < last_index\n    if array[i] % 2 == 1 \n      array[i], array[last_index]\
    \ = array[last_index], array[i]\n    else\n      i += 1\n      last_index -= 1\n\
    \  end\n  array\nend", "  result = []\n  array.each do |num|\n    if num % 2 ==\
    \ 0\n      result = num\n    else\n      result = num - 1\n    end\n  end\n  result\n\
    end", "  array = array.dup\n  array.sort do |i, j|\n    sum  = i + ( j - i )\n\
    \    sum % 2 == 1 ? i : j\n  end\nend", "  array.sort.with_index do |a, b|\n \
    \   sum = 0\n    a.upto b.last do |i|\n      sum += array[i]\n    end\n    if\
    \ sum.odd?\n      a\n    elsif sum.even?\n      b.reverse\n    else\n      a.reverse\n\
    \    end\n  end\nend\np sort_array(%w[3 2 1])\np sort_array(%w[3 2 1 4 5])\np\
    \ sort_array(%w[3 2 1 4 5 6])\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails,sorting\
    \ dscore=0 |>\n<| a dscore=0 tags=ruby,algorithm,ruby-on-rails,sorting |>\n<code>\n\
    arr = [5, 1, 3]\narr.sort_by { |n| -n.odd? }", "  array = array.sort\n  array.sort!\
    \ { |i, j| i < j ? -1 : 1 }\n  array\nend\n</code>\nIt took me 2 days to figure\
    \ it out. And I learned a lot from it.\n<|/ a |>\n<| a tags=ruby dscore=0 |>\n\
    <code>\na = [3,2,0,1]\na.sort {|i,j| i%2 != j%2}", "  array.sort!\n  return array\n\
    end", "  array.sort!\n  array = array.dup\n  \n  i = 0\n  sum = 0\n  while i <\
    \ array.length\n    sum = sum + array[i]\n    i += 1\n    \n    if sum % 2 ==\
    \ 1\n      array.reverse!\n      return array\n    end\n    \n    sum = sum -\
    \ array[i]\n    i += 1\n  end\n  \n  array\nend", "  new_array = array.dup\n \
    \ new_array.reduce! do |prev, curr|\n    next prev if prev == curr\n    if curr.odd?\n\
    \      curr.downto(curr - 1) do |a|\n        prev << a\n      end\n    else\n\
    \      curr.upto(curr + 1) do |a|\n        prev << a\n      end\n    end\n   \
    \ prev\n  end\n  new_array\nend", "  array.sort.with_index do |e, i|\n    if i\
    \ % 2 == 0\n      e * -1\n    else\n      e\n    end\n  end\nend", "  # Your code\
    \ here\n  sum = array.inject( 0 ) { |sum, num| sum + num }\n  even = sum % 2\n\
    \  odd = !even\n  odd = odd ? -1 : +1\n  array.sort.reverse.map { |num| num *\
    \ even + odd }\nend\n</code>\n<|/ a tags=sorting,ruby |>\n<| a dscore=2 |>\nI\
    \ like my solution\n<code>", "  return array.sort.reverse! if array.sum % 2 ==\
    \ 0 else\n  array.sort\nend", "    array.sort\nend", "  array.sort! do |i, j|\n\
    \    if i > j\n      i\n    elsif i == j\n      0\n    else\n      1\n    end\n\
    \  end\n  array\nend", "  return array if array.length < 2 || array.length ==\
    \ 1 ? array : array.reverse.sort.reverse\nend\n</code>\n<|/ a |>\n<| a |>\nThe\
    \ easiest solution I found was using sort method. Let's say you have an array\
    \ like this: \n<code>\narray = [\"Apple\", \"Banana\", \"Cherry\"]\n</code>\n\
    To sort it using Array#sort method you can do this:\n<code>\narray.sort\n</code>\n\
    This will return:\n<code>\n[\"Apple\", \"Banana\", \"Cherry\"]\n</code>\n<|/ a\
    \ dscore=2 tags=ruby |>\n<| c |>\nWhat if you're not trying to sort an array,\
    \ but want to print it in reverse order? `array.sort!.reverse` will do that, but\
    \ I think `reverse` could make code less efficient.\n<|/ c |>\n<| c |>\nThat makes\
    \ sense! I didn't think of that because I was thinking more along the lines of\
    \ sorting it with a specific function but this does make more sense.\n<|/ c |>\n\
    <| a |>\nThe simplest solution is to negate your array:\n<code>\narray.sort {\
    \ |a, b| b <=> a }\n</code>\nNote that this mutates your array (as sort does),\
    \ which might be a problem if you're using an array with large quantities of elements\
    \ (as you pointed out in your question).\n<|/ a dscore=2 tags=ruby |>\n<| a tags=ruby\
    \ |>\n<code>", "    array=array.clone\n    array.sort!\n    return array\nend",
  "  return array.sort\nend", "  array.sort\n  array.sort! # this does no harm\nend",
  "  sorted_array = array.clone\n  if array.sum % 2 == 1\n    sorted_array.sort!{|a,b|\
    \ a<b}\n  else\n    sorted_array.sort!{|a,b| a>b}\n  end\n  sorted_array\nend\n\
    </code>\n<|/ a |>\n<| a tags=ruby,arrays |>\nJust use sort_by! to achieve your\
    \ objective:\n<code>\na = [5,7,4,1,3,2]\na.sort_by! { |x| (a + x).max }\n</code>\n\
    which gives:\n<code>\n=> [1, 3, 4, 2, 5, 7]\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=2 |>\n<code>", "  if array.empty?\n    array\n  elsif array.size == 1\n\
    \    array\n  else\n    sort_array(array.first) + sort_array(array.last)\n  end\n\
    end", "  array.sort.with_index do |element, index|\n    if index == 0\n      element\n\
    \    elsif index == array.length - 1\n      array[array.length - 1]\n    elsif\
    \ element.length == 1\n      element[0]\n    elsif element[element.length - 1]\
    \ == element[0]\n      element[element.length - 1]\n    elsif array[index].to_i\
    \ > array[index + 1].to_i\n      element\n    else\n      element.reverse\n  \
    \  end\n  end\nend", "  array.sort\nend", '  array.sort!', "    array.sort! do\
    \ |first, last|\n        case last - first\n        when 0\n            0\n  \
    \      when 1\n            first + 1\n        else\n            first - last\n\
    \        end\n    end\n    return array\nend", "  array.sort!\nend", "  array.sort!\n\
    \  res = []\n  i = 0\n  while i < array.length\n    if i % 2 == 0\n      res.push(array[i]\
    \ + array[i-1])\n    else\n      res.push(array[i] - array[i-1])\n    i += 1\n\
    \  end\n  return res\nend", "  return array.sort if array.length % 2 == 0 &&\n\
    \                        array.sum >= array.max && array.sum < array.min else\n\
    \                     array.sort { |a, b| b.to_i - a.to_i }\nend", "  array.sort!\n\
    end", "  array.sort!\n  i = 0\n  while i < array.length\n    if array[i]%2 ==\
    \ 0\n      i += 1\n      array[i - 1], array[i] = array[i], array[i - 1]\n   \
    \ else\n      i -= 1\n      array[i - 1], array[i] = array[i], array[i - 1]\n\
    \    end\n  end\n  array\nend", "    array.sort\nend\n</cell>\n<code language=julia-1.5>",
  "  array.dup.sort\n  array\nend", "  sorted = []\n  sum = 0\n  array.each do |num|\n\
    \    sum += num\n    sorted << num if sum % 2 == 1\n    sorted << -num if sum\
    \ % 2 == 0\n  end\n  return sorted\nend", "    array.sort!\nend", "    arr = array.sort\n\
    \    if array.sum == array.sum * 2\n        arr.reverse\n    end\n    arr\nend",
  "  return array.sort.sort_by_value\nend", "  array = [array.length] + array\n  array.sort\
    \ { |a,b| a <=> b }\n  array\nend", "    sum = array.inject(0) { |sum, el| sum\
    \ + el }\n    even = array.select(&:even?)\n    odd = array.select(&:odd?)\n \
    \   \n    if sum % 2 == 1\n      even.sort.reverse\n    elsif sum % 2 == 0\n \
    \     even.sort\n    else\n      odd.sort.reverse\n    end\nend\n</code>\n<|/\
    \ a tags=arrays,ruby,sorting |>\n<| a dscore=0 |>\n<code>", "  if array.empty?\n\
    \    array\n  else\n    array.sort\n  end\nend", "  array.sort!\n  return array\n\
    end", "  if array.empty?\n    array\n  else\n    array_copy = array.dup\n    array_copy.sort!",
  "  array.sort\nend", "  i = 0\n  sum = 0\n  array.sort!\n  array.each_with_index\
    \ do |x, index|\n    sum += x\n    if sum % 2 == 0\n      array[index] = x\n \
    \     i += 1\n      break\n    end\n  end\n  return array\nend\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nThis is an interesting solution, but I do not think it\
    \ is the fastest. `array.sort` will copy the array.\n<|/ c |>\n<| a |>\nUse sort\
    \ method to sort your array.\n<code>\n> arr = [10,4,6,8,9]\n=> [10, 4, 6, 8, 9]\n\
    > arr.sort\n=> [0, 4, 6, 8, 9]\n</code>\n<|/ a dscore=1 tags=ruby,arrays |>\n\
    <| c |>\nThis solution is too slow for me.\n<|/ c |>\n<| c |>\nwhat do you mean\
    \ by too slow?\n<|/ c |>\n<| c |>\nI think `sort` is O(nlogn) and OP was looking\
    \ for a solution in O(n).\n<|/ c |>\n<| c |>\nI agree, but for an array with 300\
    \ elements the difference between `sort` and `sort_by` is really significant when\
    \ compared with `sort_by` being faster\n<|/ c |>\n<| a tags=ruby,arrays |>\nA\
    \ variation on the solution provided by but written in a slightly more Ruby-like\
    \ way:\n<code>", "  array.sort!\n  array.each_with_index { |e, i| array[i] = e}\
    \ # re-sort array\n  return array\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    `array.sort!` is better than `array.sort`. Avoids allocating a temp array if speed\
    \ is important.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  array.sort\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=ruby,ruby-on-rails |>\nYou could use the block form\
    \ of sort to do this. For example:\n<code>\narr = [1,2,3]\narr.sort do |x,y|\n\
    \  return y <=> x if y == x\n  y <=> x\nend\n</code>\n<|/ a |>\n<| c |>\nJust\
    \ to add a comment, this will sort `[1,2,3]` to `[1,3,2]` and not `[1,2,3]` to\
    \ `[3,2,1]`.\n<|/ c |>\n<| c |>\nI guess that's true, but I'm not sure. Do you\
    \ know of any way to change that? It seems like it would be more natural to me,\
    \ but maybe I'm missing something.\n<|/ c |>\n<| c |>\nThat is true. I believe\
    \ he wants `[1,2,3]` to `[3,2,1]` as the OP mentions.\n<|/ c |>\n<| c |>\nYes,\
    \ the question is a bit unclear. But, yes, as far as I know, you're right that\
    \ OP wants [1,2,3] to [3,2,1]\n<|/ c |>\n<| a |>\nYou can try this.\n<code>",
  "  new_array = []\n  array.each_with_index do |x, i|\n    flag = 0\n    array.length.times\
    \ do |y|\n      flag += 1\n      break if x == array[y] and flag == 1\n    end\n\
    \    if flag == 1\n      new_array << array.reverse[i]\n    else\n      new_array\
    \ << x\n    end\n  end\n  new_array\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\nfunction array_sort($array){\n    if(count($array) > 1){\n     \
    \   for($i=0;$i<count($array)-1;$i++){\n            for($j=$i+1;$j<count($array);$j++){\n\
    \                for($k=0;$k<count($array);$k++){\n                    if($array[$k]\
    \ < $array[$j] && $array[$k] < $array[$i]){\n                        $temp = $array[$k];\n\
    \                        $array[$k] = $array[$j];\n                        $array[$j]\
    \ = $temp;\n                        break;\n                    }\n          \
    \      }\n            }\n        }\n    }\n    return $array;\n}\n</code>\n<|/\
    \ a tags=ruby,sorting,arrays |>\n<| c |>\nWelcome to Stack Overflow. While this\
    \ code snippet may solve the question, [including an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n\
    The most Ruby-like way would be:\n<code>", "    # Write your code here\n    array.sort!\n\
    end", "  return array.sort.each_with_index.with_index do |element, index, array|\
    \ \n    if index > 0 then\n      if element < array[index-1] then\n        array[index],\
    \ array[index-1] = array[index-1], array[index]\n      else\n        array[index],\
    \ array[index-1] = array[index-1], element\n      end\n    end\n  end\nend", " \
    \ sum = 0\n  result = []\n  array.each do |num|\n    sum += num\n    if sum %\
    \ 2 == 1\n      result.push(num)\n    else\n      result.pop\n      result.push(num)\n\
    \    end\n  end\n  result\nend", "    array.sort!\n    \n    evenSum = array[0]\
    \ + array[array.length-1]\n    oddSum = array[0] - (array[array.length-1] - array[0])\n\
    \    evenOrOdd = (evenSum % 2) == 0 ? :\n    \n    if evenOrOdd == :\n       \
    \ array = array.reverse\n    end\n    \n    array\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
