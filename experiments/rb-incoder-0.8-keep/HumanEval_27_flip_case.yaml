name: HumanEval_27_flip_case
language: rb
prompt: "# For a given string, flip lowercase characters to uppercase and uppercase\
  \ to lowercase.\n# >>> flip_case('Hello')\n# 'hELLO'\ndef flip_case(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_flip_case\n\
  \    candidate = method(:flip_case)\n    assert_equal(\"\", candidate.call(\"\"\
  ))\n    assert_equal(\"hELLO!\", candidate.call(\"Hello!\"))\n    assert_equal(\"\
  tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\", candidate.call(\"These violent delights\
  \ have violent ends\"))\n  end\nend\n"
completions: ["  string.gsub!(/./) { |c| c.upcase == c.downcase ? c.upcase : c.downcase\
    \ }\nend", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.chars.map\
    \ do |c|\n    case c\n    when /[a-z]/\n      c.chr[1..-1]\n    when /[A-Z]/\n\
    \      c.upcase\n    when /[\\d]/\n      c.chr.to_i\n    when /[!\\?]/\n     \
    \ c.reverse\n    else\n      c\n    end\n  end.join\nend", "  string.downcase!\n\
    \  string.upcase!\nend", "  string.split('').map { |char| char.upcase == char.downcase\
    \ ? char.downcase : char.capitalize }.join\nend", "  string.downcase!\n  string.upcase!\n\
    \  string\nend\n</pre>\n<h1><a name=\"The-Enumerable-Module\"></a>The Enumerable\
    \ Module</h1>\n<p>The Enumerable module provides methods for enumerating arrays.\
    \ It does not modify the array (like <code>Array#each</code>). Instead, it is\
    \ designed for use with enumerable objects.</p>\n<h2><a name=\"Enumerable-methods\"\
    ></a>Enumerable methods</h2>\n<h3><a name=\"each-method\"></a>each method</h3>\n\
    <p><code>Array#each</code> is shorthand for <code>each</code> and <code>inject</code>.\
    \ Both are aliases to <code>inject</code>.</p>\n<pre class=\"ruby\"><span class=\"\
    ruby-keyword\">class</span> <span class=\"ruby-constant\">Fixnum</span>\n  <span\
    \ class=\"ruby-keyword\">def</span> <span class=\"ruby-identifier\">each</span>\n\
    \    <span class=\"ruby-keyword\">self</span>.<span class=\"ruby-identifier\"\
    >times</span>(<span class=\"ruby-value\">0</span>) <span class=\"ruby-keyword\"\
    >do</span> <span class=\"ruby-operator\">|</span><span class=\"ruby-identifier\"\
    >x</span><span class=\"ruby-operator\">|</span>\n      <span class=\"ruby-identifier\"\
    >yield</span> <span class=\"ruby-identifier\">x</span>\n    <span class=\"ruby-keyword\"\
    >end</span>\n  <span class=\"ruby-keyword\">end</span>\n<span class=\"ruby-keyword\"\
    >end</span>", "  string.gsub(/./) { |c| c =~ /[a-z]/ ? c.upcase : c.downcase }\n\
    end", "  string.downcase! \n  string.upcase!\nend", "    string.gsub!(/\\w/) {\
    \ |word| word.upcase + word.downcase }\nend", "  string\n    .downcase!\n    .upcase!\n\
    end", "  string.upcase! if string.length > 1\n  string.downcase! if string.length\
    \ > 1\n  string\nend", "  return string.gsub(/./) { |m| m.upcase == m.downcase\
    \ ? m.downcase : m.upcase }\nend", "  string.downcase!\n  string\nend\n</code>\n\
    This can be generalized to other characters:\n<code>", "  return string.gsub(/[A-Z]/)\
    \ {|m| m.downcase }\nend", "  string.downcase!\n  string.upcase!\n  string\nend",
  "  string.downcase! unless string == ''\n  string[0].upcase + string[1..-1].downcase\n\
    end", "  string.gsub(/./) { |char| char.upcase == char.downcase ? char.downcase\
    \ : char.upcase }\nend", "    string.downcase!\nend\n</code>\nThis should do it:\n\
    <code>\n'hello world'.downcase.gsub(/[a-z]/) {|m| m.upcase }\n=> \"He lll oo wORlD\"\
    \n</code>\n<|/ a tags=ruby,string,regex dscore=4 |>\n<| a tags=ruby,string,regex\
    \ |>\nHere is another way using String#tr:\n<code>", "  string.gsub(/[^a-z]+/)\
    \ { |char| char.upcase }.\n           gsub(/[a-z]+/) { |char| char.downcase }\n\
    end\n</code>\n<|/ a tags=ruby,string,arrays,ruby-on-rails,methods dscore=1 |>\n\
    <| a tags=ruby,string,arrays,ruby-on-rails,methods |>\nThis should work.\n<code>",
  "  string.downcase!\n  string.upcase!\n  string\nend\n</code>\nTo test your function,\
    \ create a new file in your Rails app (let's call it test.rb) and paste this code\
    \ in it:\n<code>\nrequire 'test_helper'\nrequire 'reverse_string'", "  string.split(\"\
    \").map do |char|\n    char.downcase if char.downcase != char\n  end.join\nend",
  "  string.chars.map {|c| c.downcase == c.upcase ? c.upcase : c.downcase}.join(\"\
    \")\nend\n</code>\n<|/ a |>\n<| c |>\nThis is cool, thank you! I have only just\
    \ recently learned that you can chain methods in Ruby, so instead of `string.chars.map\
    \ {|c| c.downcase == c.upcase ? c.upcase : c.downcase}.join(\"\")` you can use\
    \ `string.chars.map(&:downcase).map(&:upcase).join(\"\")`\n<|/ c |>\n<| c |>\n\
    As of Ruby 2.4 you can also do `string.downcase.upcase`.\n<|/ c |>\n<| c |>\n\
    I know, just trying to be nice :P\n<|/ c |>\n<| c |>\n, yes, this also works,\
    \ thank you! It's just that I haven't learned how to use the `&` operator yet,\
    \ so I prefer my solution, since it makes it more readable. :)\n<|/ c |>\n<| a\
    \ tags=ruby,string,ruby-on-rails |>\nHere's an alternate way of doing it using\
    \ regular expressions. I find it easier to understand how this works:\n<code>",
  "  string.downcase!\n  string.upcase!\nend", "  string.chars.map do |c|\n    case\
    \ c\n    when 'A' then 'a'\n    when 'a' then 'A'\n    else c\n    end\n  end.join\n\
    end\n</code>\n<|/ a tags=ruby dscore=4 |>\n<| a |>\nHere is my solution (it just\
    \ converts the uppercase letters into lowercase).\n<code>", "    string.downcase!\n\
    \    string.upcase!\nend", "  string.gsub(/[[:lower:]]/) { |char| char.upcase\
    \ }.gsub(/[[:upper:]]/) { |char| char.downcase }\nend", "  return string.gsub(/[a-z]/)\
    \ { |char| char.upcase }\nend", "  result = string.downcase\n  string.downcase!\n\
    \  result\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`downcase!` was added with\
    \ Ruby 2.4.0. Also, it will be a lot faster to use `upcase!` instead of `downcase!`\
    \ since the former will create a temporary string while `downcase!` will not.\n\
    <|/ c |>\n<| c |>\nFYI, Ruby 2.4.0 removed `downcase!` altogether. Since this\
    \ answer was written `downcase!` was renamed to `downcase`.\n<|/ c |>\n<| c |>\n\
    Ah. Thanks. I will update my answer accordingly.\n<|/ c |>\n<| c |>\n: Please\
    \ take a look at the performance comparison of all the answers on this page and\
    \ tell us which one is faster. I'll be very surprised to see that `downcase!`\
    \ is faster than `upcase!`. I think we should use upcase! instead.\n<|/ c |>\n\
    <| c |>\nupcase! seems to be the fastest and easiest; however I am not sure what\
    \ they meant by \"temporary string\". Is it possible to share your benchmarking\
    \ results?\n<|/ c |>\n<| a tags=ruby |>\nThe string downcase method is not thread\
    \ safe.\nThis means that if you're running this code concurrently on different\
    \ threads, then you have a race condition.\nTo get around this issue you can use\
    \ the String#swapcase method instead, which is not thread safe but is thread safe.\n\
    <code>\nstring = 'hello'", "  string.downcase!\n  string.upcase!\n  string\nend",
  "  string.downcase!\n  string.upcase!\nend", "  return string.downcase\nend", " \
    \ string.split(\"\").map do |char|\n    char.downcase == char ? char.upcase :\
    \ char\n  end.join(\"\")\nend", "  string.tr!(\n    'a'..'z',\n    'A'..'Z',\n\
    \    'A'..'Z',\n    'a'..'z'\n  )\nend", "    string.gsub!(/(.)(.)/, '\\\\2\\\\\
    1')\n    string.downcase!\nend\n</code>\nThe method gsub replaces any occurrence\
    \ of the pattern (.)(.) in the string with \\1\\2 where \\1 is the first group\
    \ and \\2 the second group. So in the pattern .(.). The first group ((.) has two\
    \ capturing groups. So \\1\\2 means the string replaced with group 1 followed\
    \ by group 2. \nThe method downcase! returns the modified string and modifies\
    \ the string in place.\n<|/ a tags=ruby dscore=2 |>\n<| a |>\nRuby provides the\
    \ method  tr:\n<code>\nstring.tr('A-Z', 'a-z')\n</code>\nSee http://www.ruby-doc.org/core-2.0.0/String.html#method-i-tr\n\
    <|/ a dscore=2 tags=ruby |>\n<| a dscore=1 tags=ruby |>\nYou could use String#split\
    \ and String#join to achieve the effect of flipping the case:\n<code>\n\"hello\"\
    .split.join(\"\").upcase", "  string.downcase!\n  string.upcase!\nend\n</code>\n\
    Let's try this out:\n<code>\nflip_case(\"hello\")", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "  return string.upcase + string.downcase\nend", "  result =\
    \ \"\"\n  string.each_char do |c|\n    result << (c.upcase == c.downcase ? c.downcase\
    \ : c.upcase)\n  end\n  result\nend", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "  string.downcase!\n  string.upcase!\nend", "    string.gsub(/[a-z]/)\
    \ do |c|\n        c.downcase + c.upcase\n    end\nend", "  string.downcase!\n\
    \  string.upcase!\nend", "  string.downcase!\n  string.upcase!\nend", "  string.gsub(/./)\
    \ do |char|\n    case char\n    when 'a'\n      'A'\n    when 'b'\n      'B'\n\
    \    when 'c'\n      'C'\n    when 'd'\n      'D'\n    when 'e'\n      'E'\n \
    \   when 'f'\n      'F'\n    when 'g'\n      'G'\n    when 'h'\n      'H'\n  \
    \  when 'i'\n      'I'\n    when 'j'\n      'J'\n    when 'k'\n      'K'\n   \
    \ when 'l'\n      'L'\n    when 'm'\n      'M'\n    when 'n'\n      'N'\n    when\
    \ 'o'\n      'O'\n    when 'p'\n      'P'\n    when 'q'\n      'Q'\n    when 'r'\n\
    \      'R'\n    when 's'\n      'S'\n    when 't'\n      'T'\n    when 'u'\n \
    \     'U'\n    when 'v'\n      'V'\n    when 'w'\n      'W'\n    when 'x'\n  \
    \    'X'\n    when 'y'\n      'Y'\n    when 'z'\n      'Z'\n    else\n      char\n\
    \    end\n  end\nend\n</code>\nThis solution has one disadvantage. The first character\
    \ is lowercase. Another disadvantage is that it only handles lowercase strings.\
    \ If you want to flip uppercase and lowercase characters in a string, you can\
    \ use this code:\n<code>", "  string.downcase.gsub(/./){|c| c.upcase == c.downcase\
    \ ? c.downcase : c.upcase}\nend", "  string.downcase!\n  string.upcase!\n  string\n\
    end", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.upcase.gsub(/./)\
    \ { |match| match.downcase }\nend", "  string.downcase!\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThe question was about how to achieve the desired result without\
    \ using loops, and your answer only addresses one part of the question. The other\
    \ part is how to achieve the desired result without calling `reverse`.\n<|/ c\
    \ |>\n<| a tags=ruby,string |>\n<code>", "  return string.downcase + string.upcase\n\
    end", "  string.downcase.gsub(/./) { |s| s.upcase }\nend\n</cell>\n<text>\nWe\
    \ can use gsub to run a block of code on each element of an array. Let's try it\
    \ with a string array. We'll use Ruby's map method to apply the flip_case method\
    \ to each element in the array.", "  return string.downcase.chars.join string.upcase.chars\n\
    end", "  return string.downcase\nend", "  string.chars.map { |c| c.upcase == c.downcase\
    \ ? c.downcase : c.upcase }.join\nend", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "    string.downcase!\n    string.upcase!\n    string\nend",
  "  string.split('').map(&:capitalize).join\nend", "  string.downcase!\n  string\n\
    end\n</code>\n<code>", "  string.tr!(\"A-Z\", \"A-Z\").tr!(\"a-z\", \"a-z\")\n\
    \  string\nend", "  string.downcase!\n  string.upcase!\n  string\nend\n</code>\n\
    <|/ a |>\n<| c |>\nHi, thank you for the detailed answer. Would you consider editing\
    \ your answer to include a short explanation of how your function works?\n<|/\
    \ c |>\n<| c |>\nThank you. Edited. Let me know if you need more info.\n<|/ c\
    \ |>\n<| c |>\nThank you very much for taking the time to make an answer! I really\
    \ appreciate you taking the time to make such a detailed answer and for the time\
    \ it took to add comments and explanations to your answer!\n<|/ c |>\n<| c |>\n\
    You're welcome. I appreciate if you could also upvote it too if you liked it.\
    \ Thanks.\n<|/ c |>\n<| c |>\nThank you for updating your answer with comments\
    \ and explanations. I appreciate it a lot! I accepted your answer (as I believe\
    \ it is more thorough), but if you would like an explanation for any part of my\
    \ answer, please let me know.\n<|/ c |>\n<| a dscore=1 |>\nI wanted to add my\
    \ two cents to this question, as I was trying to implement something similar in\
    \ ruby. I had a database of strings (about 100) that needed to be processed for\
    \ common typo errors. This is what I came up with:\n<code>", "  string.chars.map\
    \ do |c|\n    case c\n    when :l, :L, :u\n      :u\n    else\n      c\n    end\n\
    \  end.join\nend", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.downcase!\n\
    \  string.upcase!\nend", "  string[0][0] = string[0][0].upcase + string[0][1].downcase\n\
    \  string[1][0] = string[1][0].upcase + string[1][1].downcase\n  string[2][0]\
    \ = string[2][0].upcase + string[2][1].downcase\n  string[3][0] = string[3][0].upcase\
    \ + string[3][1].downcase\n  string[4][0] = string[4][0].upcase + string[4][1].downcase\n\
    \  string[5][0] = string[5][0].upcase + string[5][1].downcase\n  string[6][0]\
    \ = string[6][0].upcase + string[6][1].downcase\n  string[7][0] = string[7][0].upcase\
    \ + string[7][1].downcase\n  string[8][0] = string[8][0].upcase + string[8][1].downcase\n\
    \  string[9][0] = string[9][0].upcase + string[9][1].downcase\n  string[10][0]\
    \ = string[10][0].upcase + string[10][1].downcase\n  string[11][0] = string[11][0].upcase\
    \ + string[11][1].downcase\n  string[12][0] = string[12][0].upcase + string[12][1].downcase\n\
    \  string[13][0] = string[13][0].upcase + string[13][1].downcase\n  string[14][0]\
    \ = string[14][0].upcase + string[14][1].downcase\n  string[15][0] = string[15][0].upcase\
    \ + string[15][1].downcase\n  string[16][0] = string[16][0].upcase + string[16][1].downcase\n\
    \  string[17][0] = string[17][0].upcase + string[17][1].downcase\n  string[18][0]\
    \ = string[18][0].upcase + string[18][1].downcase\n  string[19][0] = string[19][0].upcase\
    \ + string[19][1].downcase\n  string[20][0] = string[20][0].upcase + string[20][1].downcase\n\
    \  string[21][0] = string[21][0].upcase + string[21][1].downcase\n  string[22][0]\
    \ = string[22][0].upcase + string[22][1].downcase\n  string[23][0] = string[23][0].upcase\
    \ + string[23][1].downcase\n  string[24][0] = string[24][0].upcase + string[24][1].downcase\n\
    \  string[25][0] = string[25][0].upcase + string[25][1].", "  string.tr('a-z',\
    \ 'A-Z')\nend", "  string.split(//).collect do |c|\n    case c\n    when 'a'..'z'\n\
    \      'A'..'Z'\n    when 'A'..'Z'\n      'a'..'z'\n    else\n      c\n    end\n\
    \  end.join(//)\nend\n</cell>\n<code language=julia-0.5>", "  # Add your code\
    \ here\n  string.downcase!\n  string.upcase!\n  return string\nend", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "  string.downcase! && string.upcase!\n  string\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nI know the question has been\
    \ answered but I would like to give a more specific answer. I came across this\
    \ question and tried different techniques to solve this problem but none of them\
    \ were working for me. \nThe problem I was facing was that my program was outputting\
    \ the same message in all cases. So the final solution was simple. \nI added the\
    \ if statement in main. \n<code>\nif string.empty? || string.length == 0\n   puts\
    \ \"Please enter a string!\"\nelse\n   result = string.split(//).map(&:capitalize).join\n\
    \   puts result\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nThe reason\
    \ why this doesn't work is because String#upcase and String#downcase are modifying\
    \ self and not the string you are passing to it. \nThe documentation for String#upcase\
    \ says:", "  new_string = \"\"\n  string.downcase!\n  string.upcase!\n  new_string\
    \ << string\n  string.upcase!\n  new_string << string\n  new_string\nend", " \
    \ string.downcase!\n  string.upcase!\n  string\nend\n</code>\nNow the only thing\
    \ left is to actually apply the method to each element of the array. To do that,\
    \ just map the strings:\n<code>", "  string.upcase!\n  string.downcase!\n  string\n\
    end\n</cell>\n<cell>\nflip_case('hello')\n</cell>\n<cell>\nflip_case('He loves\
    \ playing with code')\n</cell>\n<cell>", "  string.downcase!\n  string.upcase!\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\"You cannot use String#upcase! and\
    \ String#downcase! in Ruby 1.8.7; you will have to upgrade to Ruby 1.9.2 or higher.\"",
  "  return string.chars.map{|c| c == :a ? :B : c == :b ? :a : c}.join\nend", "  string.replace(/\\\
    S{1,}|\\s./) do |c|\n    c == c.upcase ? c.downcase : c.upcase\n  end\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis is actually a really nice solution, since it allows one\
    \ to easily implement an all-caps and all-lowercase-only version of the `upcase`\
    \ method.\n<|/ c |>\n<| c |>\nThanks guys!  This is a great solution and I really\
    \ like how simple the code is.  I added a little bit of comments to the code so\
    \ that it makes more sense.\n<|/ c |>\n<| c |>\nI took a look a the Ruby docs\
    \ and it appears that this could be done more succinctly using `Regexp#match`,\
    \ but I don't have any experience with that feature and it doesn't seem to quite\
    \ fit this case (at least not in Ruby 1.8.7).  You might want to try it out in\
    \ Ruby 1.8.7 and report back.\n<|/ c |>\n<| c |>\n`String#match` is very cool,\
    \ however the string must match for the method to return `true`.  I believe that\
    \ this is what OP wants to do, but I am not 100% sure.  Maybe `Regexp#match` is\
    \ better, maybe not.\n<|/ c |>\n<| c |>\nThanks guys, you are both correct, I\
    \ am going to use my original solution.  Your code was very simple and I love\
    \ it.  I still like your solution as it makes the string more self explanatory\
    \ and makes it look more like English. :)\n<|/ c |>\n<| a |>\nThe code below is\
    \ not entirely self-explanatory but should give you a better idea of what I'm\
    \ talking about. It's a class I wrote to do something similar, but with upper/lowercase\
    \ letters. It lets you specify whether you want to use uppercase or lowercase\
    \ letters, or both at once.\n<code>", "  string.downcase!\n  string.upcase!\n\
    \  string.downcase!\n  string\nend\n</code>\nThis uses the downcase and upcase\
    \ methods of the String class for strings. Each method returns a modified version\
    \ of the string object. All the methods modify the string in place.\n<code>",
  "  string.downcase!\n  string.upcase!\nend", "  string.downcase!\nend\n</cell>\n\
    <cell>", "  string.downcase!\n  string.upcase!\n  string\nend", "    string.downcase!\n\
    \    string.upcase!\nend", "  string.downcase!\n  string.upcase!\n  string\nend",
  "  string.downcase!\nend", "  return string.downcase.gsub(/./){|c| c =~ /[a-z]/i\
    \ ? c.upcase : c.downcase}\nend", "  string.downcase!\n  string.upcase!\n  string\n\
    end", "  string.gsub(/[a-z]+/) do |char|\n    char.upcase + char.downcase\n  end\n\
    end", "  string.downcase!\n  string.upcase!\n  string.capitalize!\n  string\n\
    end", "    string.split('').map{|char| char.upcase == char.downcase ? char.downcase\
    \ : char.upcase}.join(\"\")\nend", "  return string.upcase! + string.downcase\n\
    end", "  string.downcase!\n  string.upcase!\n  string\nend", "  new_string = string.downcase\n\
    \  new_string.upcase == new_string.downcase\nend", "  string.gsub!(/[a-z]/) {\
    \ |a| a.upcase }\n  string.gsub!(/[A-Z]/) { |a| a.downcase }\n  string\nend\n\
    </code>\n<|/ a tags=ruby,regex |>\n<| c |>\nThis works perfectly. How would I\
    \ go about doing this with a hash of regex's and corresponding replacements?\n\
    <|/ c |>\n<| c |>\n, I'm actually a bit surprised this isn't the accepted answer.\
    \ Not only did it take less time to write it out, but it is also more Ruby-esque.\
    \ :)\n<|/ c |>\n<| c |>\nThe only difference I see is that your code is case insensitive.\
    \ Not that it's wrong, I just have no idea why it would be more Ruby-esque.\n\
    <|/ c |>\n<| c |>\n, what do you mean by case insensitive? The replacement is\
    \ exactly the same as it was in Ruby; `/[a-z]/i` is the same as `/[a-z]/`, `/[A-Z]/i`\
    \ is the same as `/[A-Z]/`, and `/[^a-z]/i` is the same as `/[^a-z]/`.\n<|/ c\
    \ |>\n<| c |>\nYou seem to know ruby better than I do, so I guess I'm just not\
    \ understanding why you think it is more ruby-esque.\n<|/ c |>\n<| a |>\n<code>",
  "  string.gsub(/[a-z]+/) {|c| c.upcase}\nend", "  string.downcase!\nend", "  string.downcase!\n\
    \  string.upcase!\nend", "  string.downcase!\n  string.upcase!\nend", "  string.split('').map\
    \ { |c| c.capitalize ? c.downcase : c.upcase }.join\nend", "  return string.upcase\
    \ + string.downcase\nend", "  # Flip case in the first letter of each word.\n\
    \  string.gsub(/\\w/) {|w| w.upcase + w.downcase}\nend", "  string.downcase! &&\
    \ string.upcase!\nend", "  return string.gsub(/[a-z]/) do |char|\n    char.upcase\
    \ + char.downcase\n  end\nend", "  string[0] = string[0].upcase + string[0].downcase\n\
    \  string.downcase!\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nThanks\
    \ for this! I've been trying to think of ways to do this that don't involve the\
    \ String class or string methods.\n<|/ c |>\n<| a tags=ruby |>\nI know that this\
    \ is an old thread but I just ran into a similar problem and came up with this\
    \ solution:\n<code>", "  string.downcase!\n  string.upcase!\n  string\nend", " \
    \ string.downcase!\n  string.upcase!\nend", "  string.downcase!\nend", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "  string.tr!('a'..'z', 'A'..'Z')\n  string.tr!('A'..'Z',\
    \ 'a'..'z')\n  string\nend", "  return string.split(' ').map{|s|s.gsub(/[[:lower:]]/){|s|\
    \ s.upcase }}.join(' ')\nend", "  string.gsub(/[a-z]/) {|c| c.downcase + c.upcase}\n\
    end", "  string.gsub(/[A-Z]\\z/) {|c| c.upcase + c.downcase }\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4 |>\n<| a dscore=3 |>\nFor a non-regex\
    \ solution, you can use .downcase and .upcase to swap two characters. I find that\
    \ .upcase and .downcase work well for this.\n<code>", "  string.chars.map do |char|\n\
    \    case char\n    when ?a..?z then char.downcase\n    when ?A..?Z then char.upcase\n\
    \    end\n  end\nend", "  return string.gsub(/\\w(?=[A-Z])/) { |m| m.upcase }.gsub(/\\\
    w/) { |m| m.downcase }\nend\n</cell>\n<code language=julia-1.0>", "  string.split(\"\
    \").map do |c|\n    cased = c.downcase\n    c.upcase == c ? cased.upcase : cased\n\
    \  end.join(\"\")\nend\n</code>\nIt should be obvious how you can apply this method\
    \ to a list of strings. Given the OP's comment regarding CSV data...\n<code>\n\
    require 'csv'\nfile = CSV.read('file.csv', {:headers => :first_row})\nfile.map\
    \ do |r|\n  flip_case(r['name'])\nend\n</code>\nGiven the OP's comment regarding\
    \ JSON data...\n<code>\nrequire 'json'\ndata = JSON.parse(File.open('data.json',\
    \ 'r'))\ndata['data'].map do |r|\n  flip_case(r['title'])\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nI like this answer, but can you help me see how this would be done\
    \ on json data? thanks.\n<|/ c |>\n<| c |>\nThat's a bit trickier because your\
    \ data doesn't have line breaks. I've updated my answer to account for it.\n<|/\
    \ c |>\n<| a tags=ruby |>\nHere is another one without regular expression:\n<code>",
  "  string.downcase!\n  string.upcase!\n  string\nend", "  return string.gsub(/[a-z](?![A-Z])|[A-Z](?![a-z])/)\
    \ { |s| s[/(?<=^|\\s)([a-z])/] ? s[/(?<=\\s)([A-Z])/] : \"#{s.upcase}\" }\nend",
  "  string.downcase!\n  string.upcase!\n  string\nend", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "  string.downcase!\n  string.upcase!\n  string\nend", "  return\
    \ string.gsub(/[a-z]+/) { |m| m.upcase }.gsub(/[A-Z]+/) { |m| m.downcase }\nend",
  "  string.gsub!('a'..'z', 'A-Z')\n  string.upcase!\n  string.gsub!('A'..'Z', 'a-z')\n\
    \  string.downcase!\n  string\nend", "  result = \"\"\n  string.each_byte do |c|\n\
    \    if c >= 'a' && c <= 'z'\n      result << c.chr ^ ('A'..'Z').find { |a| a\
    \ <= c }\n    else\n      result << c.chr\n    end\n  end\n  result\nend", " \
    \   string.downcase!\n    string.upcase!\n    string\nend", "  return string.downcase!.upcase\
    \ + string.upcase!.downcase\nend", "  return string.downcase!\nend", "  string.downcase!\
    \ unless string.length <= string.length\n  string.upcase!\nend", "  string.downcase!\n\
    end\n</code>\n<|/ a |>\n<| c |>\nIt should be noted that this approach only works\
    \ if you're using Rails 3's ActiveSupport string interpolation, which isn't the\
    \ case if you were using a gem like Rails 2 Scaffolding which has its own version\
    \ of String#upcase.\n<|/ c |>\n<| c |>\nThis does not answer the question - why\
    \ is `String#downcase!` so slow when called repeatedly?\n<|/ c |>\n<| a |>\nI\
    \ wrote a plugin for this: https://github.com/ging/rubydowncase\n<|/ a dscore=5\
    \ tags=ruby |>\n<| c |>\nI wrote a plugin that works with rails 3.1 and ruby 1.9.3\
    \ http://stackoverflow.com/questions/1630111/rails-3-activesupport-string-interpolation-and-plugins\n\
    <|/ c |>\n<| a |>\nI realize this question was answered a long time ago, but it's\
    \ nice to have this question on SO in case it proves useful to anyone else looking\
    \ for this answer.\nI've just been searching around and have found this gist which\
    \ I think may have what you're looking for:\nhttps://gist.github.com/1060889\n\
    It's a Rails plugin that turns down all the lowercase characters into uppercase,\
    \ upcases all the uppercase characters, and capitalizes the remaining characters.\
    \ It also has a couple of options to make it more intelligent. \nIt's a quick\
    \ one so I'll leave it here, but I'll also leave a link to the documentation on\
    \ Github if you wanna read further. \nHope it helps!\n<|/ a dscore=5 tags=ruby\
    \ |>\n<| c |>\nThank you for providing the gist. It was very helpful.\n<|/ c |>\n\
    <| a dscore=4 |>\nFor Ruby 2.1 and above:\n<code>", "  string.downcase!\n  string.upcase!\n\
    \  string\nend\n</cell>\n<text>\nLet's verify that it worked:", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "  string.split('').map {|char| char.downcase\
    \ == char ? char.upcase : char} * ''\nend", "    string.downcase!\n    string.upcase!\n\
    end", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.upcase!\n\
    end", "  return string.downcase! unless string.nil?\n  nil\nend\n</code>\nNow\
    \ that we have the basic logic for our flip case method, let's use that to write\
    \ our new method flip\n<code>", "  string.downcase!\n  string.upcase!\n  string\n\
    end", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "  string.gsub(/[a-z]/) do |char|\n    char\
    \ = char.downcase\n    char = char.upcase if char !~ /^[A-Z]/\n    char\n  end\n\
    end", "  string.downcase!\nend", "  string.downcase!\n  string.upcase!\n  string\n\
    end", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.gsub(/./)\
    \ { |char| char.upcase == char.downcase ? char.downcase : char.upcase }\nend",
  "  new_string = ''\n  i = 0\n  while i < string.length\n    if string[i].downcase\
    \ == string[i].upcase\n      new_string += string[i].upcase\n      i += 1\n  \
    \  else\n      new_string += string[i]\n      i += 1\n    end\n  end\n  new_string\n\
    end", "  string.chars.reverse.each { |c| c.upcase }\n  string.chars.reverse\n\
    end", "  string.gsub(/./) do |char|\n    char.upcase == char ? char.downcase :\
    \ char\n  end\nend", "  string.tr!(\"A-Za-z\", \"A-Z\")\n  string.tr!(\"A-Z\"\
    , \"a-z\")\n  string\nend", "  string.downcase!\nend", "  string.downcase!\nend\n\
    </code>\nAt the beginning of the file, define a method for the flip_case method.\n\
    <code>", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.upcase!\n\
    end\n</code>\nIn Ruby we have other ways to do that such as tr or gsub but we\
    \ could also just go straight to the basics with upcase and downcase:\n<code>",
  "  string.downcase!\nend", "  string.downcase!\n  string.upcase!\nend", "  return\
    \ string.gsub(/(?<=\\p{Lu}|\\p{Ll})(?=\\p{Lu}|\\p{Ll})/, '\\U\\1')\nend", "  string\n\
    \    .downcase!\n    .upcase!\nend", "  string.split('').map {|char| char.downcase\
    \ == char.upcase ? char.upcase : char.downcase}.join\nend", "  case string\n \
    \ when :upper\n    string.upcase\n  when :lower\n    string.downcase\n  end\n\
    end\n</code>\nI wanted to put a more concise example here, but I didn't find any\
    \ good examples that made sense to me, so I made one.\n<|/ a dscore=5 tags=ruby,string\
    \ |>\n<| c |>\nThis is a great answer if you need the result to be a String, but\
    \ if you're simply using the string as part of a longer string processing, I'd\
    \ much rather use a regular expression - it's simpler, more efficient, and more\
    \ intuitive to read and maintain. Example: `string = \"aBcD\" #=> \"aBcD\"`\n\
    `string.gsub(/[a-z]/) { |c| c.upcase }`\n`string #=> \"Abcd\"`\n<|/ c |>\n<| c\
    \ |>\nWhat about for something more complicated like this: \"The cat chased an\
    \ orange with his paw on his head\"? I want to make sure I capitalize words that\
    \ are enclosed in quotation marks, in addition to other cases. I can do a regex\
    \ to do that with `.gsub(/(?<=\")(\\w+)(?=\")/) { |cap| cap.upcase }`\n<|/ c |>\n\
    <| c |>\nYou could just do `string.gsub(/(?<=\")(?<word>\\w+)(?=\")/) { |cap|\
    \ cap.upcase }`, which would just make one substitution, rather than three.\n\
    <|/ c |>\n<| c |>\n: Or you could just do `string.gsub(/(?<=\")[^\"]+(?=\")/)\
    \ { |cap| cap.upcase }`, which would just make one substitution, rather than three.\n\
    <|/ c |>\n<| c |>\nAs a one-liner would be: `string.gsub(/(?<=\")(?<word>\\w+)(?=\"\
    )/) { |cap| cap.upcase }`\n<|/ c |>\n<| a dscore=5 tags=ruby,string |>\nHere's\
    \ another way:\n<code>\n\"hello\".upcase!", "  string.downcase!\n  string.reverse!\n\
    \  string.upcase!\n  string\nend", "  string.downcase!\n  string.upcase!\n  string\n\
    end\n</code>\nYou will want to make sure you review the Rails API for ActiveSupport::Inflector\
    \ and ActiveSupport::CoreExtensions::String::Inflections\n<|/ a tags=ruby-on-rails,ruby,regex\
    \ dscore=1 |>\n<| a tags=ruby-on-rails,ruby,regex |>\nYou have a few options here.\n\
    <code>", "  string.chars.reverse_each.join\nend", "  return string.gsub(/[a-z]/)\
    \ { |character| character.upcase + character.downcase }.\n                 gsub(/[A-Z]/)\
    \ { |character| character.upcase + character.downcase }\nend", "  string.downcase.gsub(/./)\
    \ { |x| x.upcase }\nend\n</code>\nAnd now you can do your flipping:\n<code>",
  "  string.downcase!\n  string.upcase!\n  string\nend\n</code>\nSo this just flips\
    \ the case of each character in the string in place. Next we define the next method,\
    \ which will take a string and split it into two parts, the first part consisting\
    \ of characters whose case matches the lowercase case of the character in the\
    \ second part of the string, and the second part consisting of characters whose\
    \ case matches the uppercase case of the character in the first part of the string:\n\
    <code>", "  string.downcase!\n  string.upcase!\n  string\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| c |>\nNice. BTW, `string.upcase!` also returns `string`.\n\
    <|/ c |>\n<| c |>\nOops, I forgot about that. Thanks!\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere's one that just flips upper to lower case:\n<code>", "  string.downcase!\n\
    \  string.upcase!\n  string\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n`downcase!`\
    \ will throw an error if `string` is nil.\n<|/ c |>\n<| c |>\n, thanks, I have\
    \ removed it from my answer.\n<|/ c |>\n<| a tags=string,ruby |>\nYou can do it\
    \ by making use of the downcase! method. In the below example, we are first converting\
    \ the string into lower case and storing it in a variable. We then call the downcase!\
    \ method on it which will modify its value to all lower case letters. We then\
    \ convert the value returned by the downcase! method back to upper case and store\
    \ it in a new variable. The variable that stores the original value can be reused\
    \ later on.\n<code>\n> string = \"My string\"\n> string.downcase!\n> string\n\
    => \"my string\"\n> string = string.downcase!\n> string\n=> \"MY STRING\"\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nIt should be noted that this mutates the original\
    \ string.\n<|/ c |>\n<| c |>\nI know. I just added that to the answer to make\
    \ it clearer.\n<|/ c |>\n<| c |>\nNice trick but it will not work if your string\
    \ has special characters. Example `\"He is Awesome\".downcase!` will result in\
    \ `\"He is AWESOME\"`\n<|/ c |>\n<| a tags=string,ruby dscore=3 |>\nIn order to\
    \ mutate a string in-place, you can use gsub, for example:\n<code>\nstr.gsub!(*patterns)\
    \ { |match| ... }\n</code>\nwhere patterns is a hash of search and replace pairs.\
    \ For example:\n<code>\n\"hello world\".gsub!('hello', 'he') #=> \"he world\"\n\
    </code>\nAs stated in the comments, this modifies the original string.\n<|/ a\
    \ |>\n<| c |>\nthis will modify the original string, if I am not wrong.\n<|/ c\
    \ |>\n<| c |>\n, yes, you are! If this is undesirable, one should use `gsub!`\
    \ instead: `\"hello world\".gsub!('hello', 'he') #=> \"he world\"`\n<|/ c |>\n\
    <| c |>\nI added your solution to my answer for completeness.\n<|/ c |>\n<| a\
    \ tags=string,ruby |>\nYou can try this also: \n<code>\nstring = 'ABCD'\nstring.g",
  "  string.downcase!\n  string.upcase!\n  string\nend\n</cell>\n<cell>", "  string.downcase!\
    \ \n  string.upcase! \nend\n</code>\n<|/ a |>\n<| c |>\nAren't you using `upcase!`\
    \ and `downcase!`?\n<|/ c |>\n<| c |>\n`downcase!` modifies the string in place\
    \ while `upcase!` returns a modified copy. Those strings are aliases for methods\
    \ on the string class, so they can be called directly without `self` as the receiver.\n\
    <|/ c |>\n<| a dscore=0 |>\nYou can use a regexp with 2 substitutions.\n<code>",
  "  return string.gsub(/[a-z]/) do |char|\n    case char\n    when 'a' then 'A'\n\
    \    when 'b' then 'B'\n    when 'c' then 'C'\n    when 'd' then 'D'\n    when\
    \ 'e' then 'E'\n    when 'f' then 'F'\n    when 'g' then 'G'\n    when 'h' then\
    \ 'H'\n    when 'i' then 'I'\n    when 'j' then 'J'\n    when 'k' then 'K'\n \
    \   when 'l' then 'L'\n    when 'm' then 'M'\n    when 'n' then 'N'\n    when\
    \ 'o' then 'O'\n    when 'p' then 'P'\n    when 'q' then 'Q'\n    when 'r' then\
    \ 'R'\n    when 's' then 'S'\n    when 't' then 'T'\n    when 'u' then 'U'\n \
    \   when 'v' then 'V'\n    when 'w' then 'W'\n    when 'x' then 'X'\n    when\
    \ 'y' then 'Y'\n    when 'z' then 'Z'\n    else char\n    end\n  end\nend", " \
    \ string.downcase!\n  string.upcase!\n  string.downcase!\nend", "    string.downcase!\n\
    \    string.upcase!\nend\n</code>\n<|/ a |>\n<| c |>\nAs of Ruby 2.3.2, `.upcase!`\
    \ and `.downcase!` return `nil` if the String is empty. `nil.upcase!` will throw.\n\
    <|/ c |>\n<| a dscore=5 tags=ruby,string |>\nTry this\n<code>", "  string.downcase!\n\
    \  string.upcase!\n  string\nend\n</code>\nNote that strings are immutable in\
    \ Ruby, so you need to reassign the modified string back to a string variable.\
    \ Also, note that we are using the downcase and upcase methods in Ruby rather\
    \ than the upcase! and downcase! methods.\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n\
    This would work if you know what your string contains.\n<code>", "  string.downcase!\
    \ unless string.frozen?\n  string\nend", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "    string.downcase!\n    string.upcase!\nend", "    string.downcase!\
    \ # downcase to lower case\n    string.upcase! # upcase to upper case\n    string\n\
    end\n</cell>\n<text>\nStrings in Ruby are immutable. This means we cannot change\
    \ them once they are created. Therefore, we are forced to return a new string\
    \ when dealing with strings in Ruby.", "  return string.upcase\nend", "  case\
    \ string, in\n  nil, return string\n  \"#{string.upcase}#{string.downcase}\"\n\
    end\n</cell>\n<text>\nExercise\nWrite a method that converts a string to a number\
    \ using Kernel#Float. Hint: use Kernel#Float#round", "  return string.downcase\n\
    end", "  string.downcase!\nend", "  return string.gsub(/[a-z](?![A-Z])|[A-Z](?![a-z])/)\
    \ { |char| char.upcase + char.downcase }\nend", "    string.downcase!\n    string.upcase!\n\
    \    string\nend", "  string.split('').map{|char| char.upcase == char.downcase\
    \ ? char.downcase : char.upcase }.join\nend", "    string.downcase!\n    string\n\
    end\n</cell>\n<text>\nTo test our function, let's give it one more string argument.",
  "  string.downcase!\n  string.upcase!\nend", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "  string.downcase!\n  string\nend", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "  string\n    .chars\n    .map { |c| c.to_s.upcase }\n    .join\n\
    end", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.gsub(/[[:upper:]]/)\
    \ {|s| s.upcase}\nend\n</cell>\n<text>\nRegexes allow you to match strings, regular\
    \ expressions, subexpressions, groups, parentheses, and character classes.\nYou\
    \ can match strings like this:", "  string.downcase!\n  string.upcase!\nend",
  "  string.tr!('a'..'z', 'A'..'Z').tr!('A'..'Z'..'a')\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThis does not answer the question. The question is how to capitalize\
    \ every word but the first letter in each word.\n<|/ c |>\n<| c |>\n: yes it does.\
    \ `string.gsub(/([a-z])([A-Z])/, '\\1 \\2')` will capitalize the first letter\
    \ of every word. Or is there something else that's not clear?\n<|/ c |>\n<| c\
    \ |>\nYes, but that does it only for one capital letter. Consider `\"aBcDef\"\
    ` which should be `aBcDef` but your code yields `AbcDef`.\n<|/ c |>\n<| c |>\n\
    : Oops, sorry. I had meant to fix it to `string.gsub(/([a-z])([A-Z])/, '\\1 \\\
    2')`. Thank you for catching that.\n<|/ c |>\n<| a dscore=3 |>\n<code>", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "  string.downcase!\n  string.upcase!\n  string.swapcase!\n\
    \  string\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\nHere's my take on this problem.\
    \  My code is not the most Ruby-esque, but I believe the intent is clear.\n<code>",
  "  string.downcase!\n  string.upcase!\nend", "  string.downcase!\nend", "    string.downcase!\n\
    \    string.upcase!\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`downcase!` and\
    \ `upcase!` are not Ruby methods - they are methods of the `String` class, and\
    \ are therefore not a part of Ruby standard library. You're probably referring\
    \ to `String#downcase!` and `String#upcase!` as methods from the [`active_support`](https://rubygems.org/gems/active_support)\
    \ gem. You should probably mention that in your answer.\n<|/ c |>\n<| c |>\nI'm\
    \ aware of that. Sorry for the misinformation. I will edit my answer.\n<|/ c |>\n\
    <| a tags=ruby dscore=3 |>\nI would prefer to use String#gsub with block for more\
    \ flexibility, for example:\n<code>\n'abc abc'.gsub(/abc/) do |x|\n  x.upcase\
    \ if x.upcase == 'abc'\nend\n</code>\n<|/ a |>\n<| c |>\n`if x.upcase == 'abc'`\
    \ can be replaced with `x.upcase if x.upcase == 'abc'`.\n<|/ c |>\n<| a |>\nIf\
    \ you're using Ruby 2.5.1 and above, I'd use String#transliterate. For example:\n\
    <code>\n\"abc abc\".transliterate # => \"ABCabc\"\n</code>\n<|/ a dscore=2 tags=ruby\
    \ |>\n<| a |>\nI really like your answer, but just wanted to point out that you\
    \ can do it in one line.\n<code>\n'abc abc'[/abc/].upcase\n</code>\n<|/ a dscore=2\
    \ tags=ruby |>\n<| c |>\nI think this answer is more accurate since it uses regex.\
    \ However I prefer to use String#gsub with a block as it is more flexible and\
    \ more readable. :)\n<|/ c |>\n<| a |>\n<code>", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "  string.downcase!\n  string.upcase!\nend", "  string.gsub(/./)\
    \ do |char|\n    case char\n    when 'a' then 'A'\n    when 'b' then 'B'\n   \
    \ when 'c' then 'C'\n    when 'd' then 'D'\n    when 'e' then 'E'\n    when 'f'\
    \ then 'F'\n    when 'g' then 'G'\n    when 'h' then 'H'\n    when 'i' then 'I'\n\
    \    when 'j' then 'J'\n    when 'k' then 'K'\n    when 'l' then 'L'\n    when\
    \ 'm' then 'M'\n    when 'n' then 'N'\n    when 'o' then 'O'\n    when 'p' then\
    \ 'P'\n    when 'q' then 'Q'\n    when 'r' then 'R'\n    when 's' then 'S'\n \
    \   when 't' then 'T'\n    when 'u' then 'U'\n    when 'v' then 'V'\n    when\
    \ 'w' then 'W'\n    when 'x' then 'X'\n    when 'y' then 'Y'\n    when 'z' then\
    \ 'Z'\n    when 'A' then 'a'\n    when 'B' then 'b'\n    when 'C' then 'c'\n \
    \   when 'D' then 'd'\n    when 'E' then 'e'\n    when 'F' then 'f'\n    when\
    \ 'G' then 'g'\n    when 'H' then 'h'\n    when 'I' then 'i'\n    when 'J' then\
    \ 'j'\n    when 'K' then 'k'\n    when 'L' then 'l'\n    when 'M' then 'm'\n \
    \   when 'N' then 'n'\n    when 'O' then 'o'\n    when 'P' then 'p'\n    when\
    \ 'Q' then 'q'\n    when 'R' then 'r'\n    when 'S' then 's'\n    when 'T' then\
    \ 't'\n    when 'U' then 'u'\n    when 'V' then 'v'\n    when 'W' then 'w'\n \
    \   when 'X' then 'x'\n    when 'Y' then 'y'\n    when 'Z' ", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "    string.upcase!\n    string.downcase!\n\
    end", "  string.downcase!\n  string.upcase!\n  string\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
