name: HumanEval_26_remove_duplicates
language: rb
prompt: "# From a list of integers, remove all elements that occur more than once.\n\
  # Keep order of elements left the same as in the input.\n# >>> remove_duplicates([1,\
  \ 2, 3, 2, 4])\n# [1, 3, 4]\ndef remove_duplicates(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_duplicates\n\
  \    candidate = method(:remove_duplicates)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([1,\
  \ 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))\n  end\nend\n"
completions: ["  numbers.uniq.sort { |a, b| numbers.index(a) <=> numbers.index(b)\
    \ }\nend", "  sorted = numbers.sort.uniq\n  sorted.each do |number|\n    if numbers.include?(number)\n\
    \      numbers.delete(number)\n    end\n  end\n  sorted\nend\n</code>\n<|/ a tags=arrays,ruby\
    \ |>\n<| a tags=arrays,ruby dscore=0 |>\nI prefer this one liner if there are\
    \ only few unique values:\n<code>\n array.select{|e| array.count(e) == 1}\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=arrays,ruby |>\nJust another way of doing this without\
    \ using loop. \n<code>\narray.each_with_object(Hash.new(0)) { |e, h| h[e] += 1\
    \ }.select { |_, v| v == 1 }\n</code>\nThe above code creates a hash where values\
    \ are the count of the unique elements in the array. Then it iterates the hash\
    \ and returns an array containing the elements that have only one unique value.\n\
    <|/ a |>\n<| a dscore=0 |>\nAnother solution is to use Enumerable#group_by to\
    \ group items by value and count the resultant groups:\n<code>\narray.group_by{|item|\
    \ item}.select { |_, v| v.size == 1 }\n</code>\nIf you want the result to be an\
    \ array of unique items, use:\n<code>\narray.group_by{|item| item}.select { |_,\
    \ v| v.size == 1 }.keys\n</code>\n<|/ a tags=arrays,ruby |>\n<| a |>\n<code>\n\
    a = [1,2,3,3,4,4,5,6,7,8,8,8,9,9,10,11,11,12,12,13,13,14,15,16,17]\na = a.uniq.sort\n\
    a\n</code>\n<|/ a tags=arrays,ruby dscore=0 |>\n<| a tags=arrays,ruby |>\n<code>\n\
    array.group_by{|a| a}.select{|k,v| v.size == 1}.keys\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nCould you please add some commentary and explanation to your answer?\n\
    <|/ c |>\n<| c |>\nThe question already has multiple answers. In order to improve\
    \ this answer, it would be helpful to explain why your answer works.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\narray.group_by(&:itself).select(&:size == 1).keys\n\
    </code>\n<|/ a tags=arrays,ruby |>\n<| a tags=arrays,ruby |>\n<code>\narray.uniq.select{|x|\
    \ array.count(x) == 1}\n</code>\n<|/ a dscore", "  numbers.uniq!\n  numbers\n\
    end", "  sorted = numbers.sort\n  last_index = sorted.length\n  indexes = []",
  "  # first, create an array with unique values\n  numbers_without_duplicates = numbers.uniq.sort\n\
    \  numbers_without_duplicates.uniq! # change this line to .uniq \nend\n</code>\n\
    <|/ a tags=ruby dscore=1 |>\n<| c |>\nI'm fairly sure that `.uniq!` exists in\
    \ the Ruby Standard Library. http://ruby-doc.org/core-1.9.3/Array.html#method-i-uniq-21\n\
    <|/ c |>\n<| c |>\nIt works in 1.9.2 but not 1.8.7. Sorry for not pointing this\
    \ out.\n<|/ c |>\n<| c |>\nI'm afraid that `.uniq` on 1.9.2 will fail on 1.8.7.\
    \ It seems to behave differently. See: http://stackoverflow.com/questions/8674718/why-does-array-uniq-21-return-the-same-array-with-1-element-instead-of-an-new/8674839#8674839\n\
    <|/ c |>\n<| c |>\nYes, you are right. My mistake, `uniq` is an alias for `uniq!`.\
    \ Thanks.\n<|/ c |>\n<| a tags=ruby |>\n<code>\n[\"a\", \"b\", \"b\", \"c\", \"\
    c\"].uniq.count\n</code>\nor \n<code>\n[\"a\", \"b\", \"b\", \"c\", \"c\"].inject(:<<).count\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nI like the second solution, but this doesn't\
    \ work if I have numbers like [\"1\", \"2\", \"3\", \"3\", \"3\"]. Sorry for not\
    \ specifying that in the question.\n<|/ c |>\n<| c |>\nThat's a valid use case.\
    \ `[\"1\", \"2\", \"3\", \"3\", \"3\"].inject(:<<).count` will give you a count\
    \ of 6.\n<|/ c |>\n<| c |>\nYes, that is what I meant. I thought it would be a\
    \ bit more general (not just for numbers).\n<|/ c |>\n<| a tags=ruby |>\nYou could\
    \ use each_with_object :\n<code>", "  numbers.uniq!\nend", "  numbers.uniq!\n\
    \  numbers\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,arrays |>\nThe question\
    \ was already answered but I wanted to provide a way that uses the method #find_index\
    \ to avoid looping.\n<code>", "  numbers = numbers.to_a\n  numbers.uniq!\n  numbers\n\
    end\n</code>\n<|/ a dscore=5 tags=arrays,ruby,duplicates |>\n<| c |>\nIt's important\
    \ to note that this removes _all_ duplicates instead of just leaving the duplicates.\
    \ This is different from most other solutions I've seen for Ruby.\n<|/ c |>\n\
    <| c |>\n- It works great even with large arrays. Just tried it on 1M elements.\
    \ No issues so far.\n<|/ c |>\n<| a dscore=5 |>\nI ended up writing my own method\
    \ to remove duplicates from a given array using each_cons and inject.\n<code>",
  "  numbers.flatten.uniq\nend", "  numbers.uniq!\n  numbers\nend", "  result = []\n\
    \  seen = {}\n  numbers.each { |n| seen[n] ? result.push(n) : seen[n] = true }\n\
    \  result\nend", "  numbers = numbers.uniq.sort\n  numbers.compact.map { |i| numbers.count(i)\
    \ }\nend", "  numbers_to_delete = []\n  numbers.each do |number|\n    if numbers.count(number)\
    \ > 1\n      numbers_to_delete << number\n    end\n  end\n  numbers_to_delete.uniq!\n\
    \  numbers_to_delete\nend", "  numbers.group_by{|x| x}.transform_values{|x| x.first}.values\n\
    end\n</pre>", "  seen = {}\n  uniques = []", "  numbers.uniq!\n  numbers\nend",
  "    sorted_numbers = numbers.sort\n    unique_numbers = []\n    seen = {}\n   \
    \ seen_add = seen.add\n    for number in sorted_numbers\n        if number in\
    \ seen\n            unique_numbers.delete(number)\n        seen_add(number)\n\
    \        unique_numbers << number\n    return unique_numbers\nend\n</code>\n<|/\
    \ a tags=performance,ruby,algorithm |>\n<| c |>\nThis code would give an error\
    \ for `remove_duplicates([1,2,2,3])`\n<|/ c |>\n<| c |>\nThank you very much!\
    \ I am going to test the solution with various numbers and report the results.\n\
    <|/ c |>\n<| a tags=performance,ruby,algorithm dscore=1 |>\nThe ruby solution\
    \ is quite readable and elegant.\nHere is my take on it:\n<code>", "  uniques\
    \ = []\n  seen = {}\n  numbers.each do |number|\n    if seen[number]\n      seen[number]\
    \ += 1\n    else\n      seen[number] = 1\n      uniques << number\n    end\n \
    \ end\n  uniques\nend", "  numbers = numbers.uniq\n  numbers.each {|n| numbers.delete(n\
    \ - 1) if numbers.include? n}\n  numbers\nend", "  numbers.uniq!\n  numbers\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThe `!` on the end of the method name\
    \ is a great idea. I've seen it used before but never thought it was a great idea.\n\
    <|/ c |>\n<| a dscore=2 |>\nFor a short Ruby method, use Hash#delete_if:\n<code>\n\
    numbers = [1, 3, 2, 4, 1]\nnumbers.delete_if { |n| numbers.count(n) > 1 }\n</code>\n\
    This produces:\n<code>\n[1, 3, 4]\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis\
    \ is an O(n^2) solution and will not scale for large arrays or large ranges.\n\
    <|/ c |>\n<| c |>\nI know. But if OP is doing this with relatively small arrays,\
    \ it probably doesn't matter. In a case where it does, they should use something\
    \ like the accepted solution, which should be O(n).\n<|/ c |>\n<| c |>\nYes, but\
    \ if OP did this with large arrays or large ranges then it would be more efficient\
    \ to use `uniq` which should be O(n). But you're right that this answer is the\
    \ best for small ranges and arrays and for large ones this will be slower than\
    \ the accepted solution.\n<|/ c |>\n<| a tags=ruby dscore=1 |>\nIf order is not\
    \ important:\n<code>\nnumbers = [1, 3, 2, 4, 1]\nnumbers.partition { |n| numbers.count(n)\
    \ > 1 }\n=> [[1, 3, 2], [4]]\n</code>\n<|/ a |>\n<| a dscore=0 tags=ruby |>\n\
    Here's a version that's O(N) and doesn't use count. \n<code>\nnumbers = [1, 3,\
    \ 2, 4, 1]\nnumbers.group_by{|n| n}.select{|k, v| v.size > 1}.values.flatten.compact",
  "  numbers.delete_if { |x| numbers.count(x) > 1 }\n  numbers\nend", "  numbers.each_with_object(Hash.new(0))\
    \ { |n, memo| memo[n] += 1 }.\n    delete_if { |_,v| v > 1 }.\n    keys.\n   \
    \ sort\nend", "  result = numbers.dup\n  result.uniq!\n  result\nend", "  numbers.uniq!\n\
    end", "  new_numbers = []\n  numbers.each do |n|\n    if new_numbers.include?(n)\
    \ # already in new_numbers\n      next\n    end\n    new_numbers << n\n  end\n\
    \  new_numbers\nend", "  numbers = numbers.to_a\n  numbers.uniq!\n  numbers\n\
    end", "  # TODO: Implement function\n  return []\nend", "  return numbers.uniq.sort\n\
    end", "  numbers.uniq!\n  numbers\nend\n</code>\nNote that numbers is immutable,\
    \ therefore we call uniq method. Also note that uniq! modifies the array, so return\
    \ value is discarded and original array is returned.\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\nThank you so much! I appreciate it greatly.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>\narr = [1, 2, 3, 2, 4]\narr.uniq", "  return numbers.uniq\nend",
  "  sorted = numbers.sort\n  result = []\n  numbers.each_with_index do |n, i|\n \
    \   if i != sorted.index(n)\n      result << n\n    end\n  end\n  result\nend\n\
    </code>\nRuby's Array class already provides the methods you need, Array#sort\
    \ sorts the Array in place (no return value needed) and Array#index returns the\
    \ index of the first element of numbers that matches the value you're looking\
    \ for.\n<|/ a tags=ruby,arrays,duplicates,algorithm |>\n<| c |>\nI actually went\
    \ ahead and used the remove_duplicates method from above to remove the duplicates.\
    \  I also just found another algorithm that works pretty well for me that doesn't\
    \ require sorting:  https://stackoverflow.com/questions/9271247/how-to-find-duplicate-numbers-in-an-array\n\
    <|/ c |>\n<| c |>\nGood find. `Array#index` works very fast when the array is\
    \ sorted.\n<|/ c |>\n<| c |>\n`numbers.each_with_object` doesn't preserve the\
    \ original order.\n<|/ c |>\n<| a tags=ruby,arrays,duplicates,algorithm dscore=4\
    \ |>\nHere's my take:\n<code>", "  return numbers.uniq\nend", "  dups = []\n \
    \ i = 0\n  while i < numbers.length\n    if numbers.include?(numbers[i]) && numbers.include?(numbers[i\
    \ + 1])\n      dups << numbers[i]\n      numbers.pop numbers.pop i+1\n      i\
    \ += 1\n    else\n      i += 1\n    end\n  end\n  numbers\nend", "  numbers.inject([])\
    \ {|res, value| value.dup.each {|x| res << x if res.include?(x)}}\nend", "   \
    \ numbers.uniq!\nend", "  numbers.uniq.sort\nend", "  seen = {}\n  numbers_with_duplicates\
    \ = []\n  numbers.each do |number|\n    if seen[number] then\n      numbers_with_duplicates\
    \ << number\n    else\n      seen[number] = true\n    end\n  end\n  numbers_with_duplicates\n\
    end", "    unique = []\n    seen = {}", "  return numbers.group_by { |n| n }.map\
    \ { |n, arr| arr.reduce(:+) }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt will\
    \ fail for the following input: `remove_duplicates([\"1\", \"1\", \"1\"])` which\
    \ returns `[1, 1]`\n<|/ c |>\n<| c |>\n, Yep. You are right. The algorithm does\
    \ not meet the specs. It should be modified to `numbers.group_by { |n| n }.map\
    \ { |n, arr| arr.reduce(:+) }`. Thanks for pointing it out.\n<|/ c |>\n<| c |>\n\
    No need to use that many `group_by` and `map` calls. You can accomplish the same\
    \ with `numbers.reduce(:+)`\n<|/ c |>\n<| c |>\n, You are right. But it depends\
    \ on how you read the question. If he wants to keep same order of elements as\
    \ in the input, `numbers.reduce(:+)` is best. If he wants to preserve order, then\
    \ using `numbers.group_by { |n| n }.map { |n, arr| arr.reduce(:+) }` is the better\
    \ choice.\n<|/ c |>\n<| c |>\nYes but you still have two `group_by` calls and\
    \ a lot more `map` calls. `numbers.reduce(:+)` only has one `map` call.\n<|/ c\
    \ |>\n<| a |>\n<code>", "  sorted = numbers.sort.to_a\n  unique = []\n  unique.concat\
    \ numbers.uniq\n  unique.concat sorted\n  unique\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays,algorithm\
    \ |>\n<| a tags=ruby,ruby-on-rails,arrays,algorithm |>\n<code>\narr = [1, 2, 3,\
    \ 1, 2, 3, 4]\narr.uniq.sort.reverse", "  numbers.sort!\n  i = 0\n  while i <\
    \ numbers.length - 1\n    if numbers[i + 1] == numbers[i]\n      numbers.delete_at(numbers[i\
    \ + 1])\n    else \n      i += 1\n    end\n  end\n  numbers\nend", "  numbers.uniq!\n\
    end", "  result = numbers.uniq\n  result.sort.reverse\n  return result\nend",
  "  numbers.uniq.map { |num| numbers.delete(num) }\nend", "  seen = Set.new\n  numbers.select\
    \ {|n| seen.add?(n) }\nend\n</code>\n<|/ a dscore=4 tags=ruby |>\n<| a dscore=4\
    \ |>\nThe method uniq() returns a new array with a copy of the original array,\
    \ but only considers elements that appear only once in the original array.\n<code>\n\
    [1,2,2,3].uniq # => [1,2,3]\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThat was added\
    \ in 1.9.2.\n<|/ c |>\n<| c |>\nNope, not that I've heard.  I believe this was\
    \ added in 1.8.7.\n<|/ c |>\n<| c |>\nNo way to know for sure.  But I'm fairly\
    \ certain it was added around the same time as `uniq` in 1.8.7.\n<|/ c |>\n<|\
    \ c |>\nIt might be a Ruby 1.8.6 specific thing or something. It does not work\
    \ in the Rails console for me.\n<|/ c |>\n<| c |>\nIt worked for me in the Rails\
    \ console. I was running 1.8.7. Haven't upgraded myself since then, so I guess\
    \ this is an edge case.\n<|/ c |>\n<| a dscore=3 tags=ruby |>\nThe Enumerable\
    \ #uniq method returns a new array containing all the unique objects in the enumerable\
    \ (as determined by the block).\n<code>\nnumbers = [1,2,3,1,2,3,4,5,6]\nnumbers.uniq\
    \ {|n| n}", "  numbers.uniq.sort!\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\nAs stated elsewhere, uniq! mutates the original array, but you can create\
    \ an array with duplicates removed using the reject method:\n<code>", "    hash\
    \ = {}\n    \n    numbers.each do |number|\n        if hash[number]\n        \
    \    numbers.delete(number)\n        end\n        hash[number] = true\n    end\n\
    \    \n    numbers\nend\n</cell>\n<cell>", "  return numbers.group_by{|n| n}.select{|_,\
    \ v| v.size > 1}.keys\nend", "  return numbers.uniq\nend\n</code>\n<|/ a |>\n\
    <| a dscore=1 |>\nYou can use this simple code for remove duplicates but you can\
    \ change the order in the array:\n<code>\narray = [1,7,7,7,1,7,7,7]\nnew_array\
    \ = []\nfor i in array\n  if new_array.include?(i)\n    new_array.delete(i)\n\
    \  else\n    new_array << i\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    `new_array.delete(i)` will raise a `NoMethodError` exception if `i` isn't in `new_array`.\n\
    <|/ c |>\n<| a dscore=1 |>\nUsing a hash and compact\n<code>\na = [1,7,7,7,1,7,7,7]\n\
    a.uniq(&:itself).compact\n</code>\nThis will return a new array with the unique\
    \ elements found in a without any duplicates.\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\nYou can try this\n<code>\na = [1,7,7,7,1,7,7,7]", "    sorted = numbers.sort\n\
    \    unique = sorted.uniq\n    sorted.clear\n    sorted.concat! unique\n    sorted\n\
    end\n</code>\n<|/ a tags=ruby-on-rails,ruby |>\n<| a |>\nMy answer below is for\
    \ Ruby 1.9.3 or newer\n<code>\nnumbers.uniq.sort_by { |x| -x }\n</code>\n<|/ a\
    \ dscore=4 tags=ruby-on-rails,ruby |>\n<| c |>\nThis assumes that the input is\
    \ in ascending order. If it isn't you could do `numbers.uniq.sort_by { |x| -x\
    \ }.sort` which would put the smallest numbers first.\n<|/ c |>\n<| a dscore=3\
    \ tags=ruby-on-rails,ruby |>\n<code>\narray.group_by{|i| i}.sort{|a, b| b[1].size\
    \ <=> a[1].size}\n</code>\nThis will group all the duplicate elements together\
    \ and sort by size. \nThe code above sorts by the size of the second element in\
    \ the hash.\n<|/ a |>\n<| a tags=ruby-on-rails,ruby dscore=2 |>\n<code>\nnumbers\
    \ = [1, 5, 4, 2, 3, 3, 2, 4, 5, 1, 3, 4]", "  numbers.uniq!\n  numbers\nend",
  "  return numbers.uniq\nend", '  unique_numbers = Set.new', "  numbers.uniq!\nend",
  "  # Your code here\n  sorted = numbers.sort.uniq\n  sorted.each {|num| numbers.delete(num)}\n\
    \  numbers\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  seen\
    \ = []\n  numbers.each do |number|\n    if seen? seen, number\n      seen.pop\n\
    \    else\n      seen << number\n    end\n  end\n  seen\nend", '  sorted = numbers.sort',
  "  seen = {}\n  numbers = numbers.to_a\n  numbers.reject! do |number|\n    seen[number]\
    \ = true\n    false\n  end\n  numbers.compact!\n  numbers\nend\n</code>\n<|/ a\
    \ dscore=3 tags=sorting,arrays,ruby |>\n<| a dscore=2 |>\nFor Ruby 1.8, you can\
    \ use:\n<code>\nnumbers = [1,2,3,3,4,5]\nnumbers.uniq.sort\n</code>\n<|/ a tags=sorting,arrays,ruby\
    \ |>\n<| a tags=sorting,arrays,ruby |>\n<code>\nnumbers = [1,2,3,3,4,5]\nnumbers.group_by{|n|\
    \ n}.map{|k,v| [k, v.sort].flatten.uniq}\n=> [[1, [2, 3]], [2, [3, 4]], [3, [4]],\
    \ [4, [5]]]\n</code>\n<|/ a dscore=2 |>\n<| a |>\nIf you're willing to use something\
    \ other than an array, you could do:\n<code>\nnumbers = [1, 2, 3, 4, 5, 6]\nnumbers.sort\
    \ {|a,b| (a.to_s + b.to_s).to_i }", "    numbers.uniq { |number| number.to_i }\n\
    end", "  result = Set.new\n  numbers.each do |i|\n    unless result.include?(i)\n\
    \      result << i\n    end\n  end\n  result\nend\n</code>\n<|/ a dscore=1 tags=arrays,ruby\
    \ |>\n<| a tags=arrays,ruby |>\nThis question is asked a lot. For this specific\
    \ case where we are dealing with sorted arrays then we can do this:\n<code>",
  "  new_list = []\n  seen = []\n  numbers.each do |x|\n    if !seen.include?(x)\n\
    \      new_list << x\n      seen << x\n    end\n  end\n  return new_list\nend",
  "  numbers.uniq.sort!\n  numbers.length.times do |index|\n    number.delete_at(index)\
    \ if numbers.count(number[index]) > 1\n  end\n  numbers.uniq\nend", "  seen =\
    \ Set.new\n  uniques = Set.new\n  numbers.each do |n|\n    seen << n\n  end \n\
    \  numbers.each do |n|\n    if seen.include?(n)\n      uniques.delete(n)\n   \
    \ else\n      uniques << n\n    end\n  end\n  uniques\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby,arrays |>\n<| a |>\nOne way:\n<code>", "  numbers = numbers.clone\n\
    \  numbers.delete_if { |n| numbers.count(n) > 1 }\n  numbers\nend", "  return\
    \ numbers.uniq.sort\nend\n</pre>\n            </div>\n          </li>\n      \
    \    <li>\n            Write a <code>remove</code> method that removes first occurrence\
    \ of an element.\n            <pre class=\"prettyprint\">", "  numbers.reduce([])\
    \ { |a, i| a << i if a == numbers.first }\nend", "  numbers.group_by { |n| n }.map{\
    \ |k, v| k }\nend\n</pre>\n            </div>\n          \n          \n      \
    \    \n          \n          \n            \n            <div class=\"sourcecode\"\
    >\n              \n              <p class=\"source-link\">\n                Source:\
    \ \n                <a href=\"javascript:toggleSource('method-i-remove_duplicates_source')\"\
    \ id=\"l_method-i-remove_duplicates_source\">show</a>\n                \n    \
    \          </p>\n              <div id=\"method-i-remove_duplicates_source\" class=\"\
    dyn-source\">\n                <pre><span class=\"ruby-comment\"># File /usr/local/rvm/gems/ruby-2.0.0-p0/gems/activesupport-4.0.0/lib/active_support/core_ext/enumerable/collection.rb,\
    \ line 226</span>\n<span class=\"ruby-keyword\">def</span> <span class=\"ruby-keyword\
    \ ruby-title\">remove_duplicates</span>(<span class=\"ruby-identifier\">numbers</span>)\n\
    \  <span class=\"ruby-identifier\">numbers</span>.<span class=\"ruby-identifier\"\
    >group_by</span>(&amp;<span class=\"ruby-value\">:last</span>).<span class=\"\
    ruby-identifier\">map</span>(&amp;<span class=\"ruby-value\">:first</span>)\n\
    <span class=\"ruby-keyword\">end</span></pre>\n              </div>\n        \
    \    </div>\n            \n          </div>\n        \n        <div class=\"method\"\
    >\n          <div class=\"title method-title\" id=\"method-i-reverse_each\">\n\
    \            \n              <b>reverse_each</b>(&amp;block)\n            \n \
    \           <a href=\"../classes/Enumerable.html#method-i-reverse_each\" name=\"\
    method-i-reverse_each\" class=\"permalink\">Link</a>\n          </div>\n     \
    \     \n          \n            <div class=\"description\">\n              <p>Performs\
    \ a block operation over the object&#39; indexes in ascending order.</p>", " \
    \ number_array = numbers.to_a\n  number_array.uniq!\n  number_array\nend\n</code>\n\
    <|/ a tags=ruby,arrays,set |>\n<| a |>\n<code>", "  numbers.group_by { |n| n }.values.map(&:first)\n\
    end", "  numbers.uniq!\nend\n</code>\nThe uniq! method of Array removes duplicates,\
    \ whereas uniq is the Ruby standard method to do so. The return value of the method\
    \ is the modified array without the duplicates.\n<|/ a tags=ruby dscore=3 |>\n\
    <| c |>\nThis is good but doesn't remove the duplicates. it just tells you whether\
    \ the element exists prior to removing it. which you then just have to remove.\n\
    <|/ c |>\n<| a tags=ruby |>\nHere's a one-liner:\n<code>", "  numbers.sort!\n\
    \  i = 0\n  while i < numbers.length\n    if numbers[i] != numbers[i-1]\n    \
    \  numbers[numbers.length-i-1] = numbers[i]\n      i += 1\n    end\n  end\n  return\
    \ numbers\nend\n</code>\n<|/ a |>\n<| a |>\nI was looking for an easy way to delete\
    \ duplicated strings in an array, and I used the methods suggested by and and\
    \ finally got an elegant solution. The array will be sorted and after that all\
    \ duplicated values will be removed from the array. \nThe code is tested and working.\
    \ You can have a look below. \n<code>", "  numbers.compact.uniq.sort!\nend", " \
    \ numbers_with_count = {}\n  numbers.each do |number|\n    numbers_with_count[number]\
    \ = numbers_with_count.has_key?(number) ? numbers_with_count[number] + 1 : numbers_with_count[number]\
    \ = 1\n  end\n  new_list = []\n  numbers_with_count.each do |number, count|\n\
    \    new_list << number if count > 1\n  end\n  new_list.sort!\n  new_list\nend\n\
    </pre>\n<p>This code could have been written shorter using some Ruby features\
    \ like group_by, inject or select but I'm a fan of readability and maintainability.\
    \ I also like putting simple code in a method and leaving the method simple and\
    \ readable.</p>", "  return numbers.group_by {|num| num}.values\nend", "  sorted\
    \ = numbers.sort\n  uniques = []\n  count = 0\n  while count < sorted.size\n \
    \   el = sorted[count]\n    if el != sorted[count-1]\n      uniques << el\n  \
    \    count += 1\n    end\n  end\n  return uniques\nend", "    seen = {}\n    numbers_with_duplicates\
    \ = []\n    numbers.each do |number|\n        if seen[number] == nil\n       \
    \     seen[number] = true\n            numbers_with_duplicates << number\n   \
    \     end\n    end\n    return numbers_with_duplicates\nend", "    numbers.uniq.sort\n\
    end", "    uniques = []\n    numbers_to_remove = []\n    numbers.each do |number|\n\
    \        if uniques.include?(number)\n            numbers_to_remove << number\n\
    \        else\n            uniques << number\n        end\n    end\n    uniques\
    \ - numbers_to_remove\nend", '    numbers_to_compare = []', "    numbers.uniq!\n\
    end", "  return numbers.uniq.map { |n| numbers.count(n) }\nend", "  numbers.group_by{|x|\
    \ x}.inject({}){|h, x| h.merge!(x=>x.last) }.values.sort\nend", "  result = []\n\
    \  seen = Set.new # O(1)\n  numbers.each do |n|\n    if !seen.include?(n)\n  \
    \    result << n\n      seen << n\n    end\n  end\n  result\nend", "  sorted =\
    \ numbers.uniq\n  sorted.length == 1\nend\n</code>\n<|/ a tags=arrays,ruby,ruby-on-rails\
    \ |>\n<| c |>\nA few minor corrections: 1) Your `remove_duplicates` should return\
    \ an array, not an `if` statement. 2) The method should be called `unique` (singular),\
    \ not `uniq` (plural). 3) The method should be named `#unique`, not `#uniq`. 4)\
    \ The method should probably be `Array#uniq`, not `Enumerable#uniq`.\n<|/ c |>\n\
    <| c |>\nGood points. I've updated the answer. Thanks.\n<|/ c |>\n<| a tags=arrays,ruby,ruby-on-rails\
    \ |>\n<code>", "  numbers.each_with_index do |x, i|\n    next if numbers.include?(x)\n\
    \    numbers[i] = nil if numbers[i - 1]\n  end\n  numbers.compact\nend", "  numbers.uniq!\n\
    end", "  new_numbers = []\n  seen = {}\n  numbers.each do |number|\n    if seen[number]\n\
    \      new_numbers << number\n      seen[number] = false\n    end\n    seen[number]\
    \ = true\n  end\n  new_numbers\nend\n</pre>", "  numbers.group_by { |n| n }.transform_values\
    \ { |v| v.uniq.size }\nend\n</code>\n<code>", "  numbers.uniq.compact.to_a\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis will return empty array if `numbers` array is\
    \ empty\n<|/ c |>\n<| c |>\nyeah I just noticed. thanks for noticing!\n<|/ c |>\n\
    <| a dscore=5 |>\nJust for fun, here's a recursive solution:\n<code>", "  numbers.uniq!\n\
    \  numbers\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nIf `numbers` is\
    \ `[1,2,3]`, then `numbers.uniq!` will return `[1,2,3]`, but it won't alter `numbers`\
    \ since `uniq!` returns a new array.\n<|/ c |>\n<| a dscore=0 |>\nI would recommend\
    \ using uniq:\n<code>", "  # first, find all of the duplicates \n  duplicates\
    \ = numbers.group_by {|n| n}.select {|k,v| v.size > 1}\n  # for each duplicate,\
    \ create a new array containing all elements \n  # that occur more than once\n\
    \  new_duplicates = []\n  duplicates.each do |key, value|\n    new_values << value\n\
    \    new_values << value\n    new_values << value\n    new_values << value\n \
    \ end\n  # return all elements that occur more than once, in the same order\n\
    \  return new_duplicates.flatten\nend\n</code>\n<|/ a dscore=0 tags=ruby,hash,arrays,ruby-on-rails\
    \ |>\n<| a dscore=0 tags=ruby,hash,arrays,ruby-on-rails |>\nAnother way is to\
    \ use Enumerable#slice_after:\n<code>\narr = [1,2,2,3,2,2,3,3,3,5]\nresult = arr.slice_after(arr.uniq.count).map(&:last)",
  "  numbers.inject([]) do |uniques, number|\n    unless uniques.include? number\n\
    \      uniques << number\n    end\n    uniques\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nWow, this looks really good but I have never used inject before.\
    \ Could you explain a bit of what it is doing?\n<|/ c |>\n<| c |>\n`uniques.inject`\
    \ is the method that does a certain task every time the block is called. When\
    \ you call `inject([])`, `uniques` gets passed in as the first parameter. Then,\
    \ in the block, we do our logic. In the first iteration, `uniques` is an empty\
    \ array, `number` is the first parameter from the method. Then we push the `number`\
    \ into the `uniques` array. Then, in the next iteration, the `number` gets pushed\
    \ into the `uniques` array. `uniques` will always be `[1, 2, 3]` after that.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  numbers.uniq!\n  numbers\nend\n</code>\n\
    <|/ a tags=ruby-on-rails,ruby,ruby-on-rails-3 |>\n<| c |>\nThis does nothing to\
    \ address the fact that the code in the question is trying to return a string\
    \ containing multiple comma-separated integers, which is what this answer fails\
    \ to do\n<|/ c |>\n<| c |>\n, Yes it does, and I'm fairly certain it's what the\
    \ OP was asking for.\n<|/ c |>\n<| a |>\nYou can convert the array to a string\
    \ and split on commas, then back to an array:\n<code>\nnumbers = [1,1,1,4,6,6,6,8]\n\
    numbers.map(&:to_s).sort.map(&:to_i).uniq", "    sorted = numbers.sort\n    unique\
    \ = []\n    positions = {}\n    i = 0\n    while i < sorted.length\n        num\
    \ = sorted[i]\n        if positions[num] == nil\n            positions[num] =\
    \ i\n            unique << num\n            i = i + 1\n        else\n        \
    \    i = positions[num]\n        end\n    end\n    return unique\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nGreat answer. Just a correction to OP's question:\
    \ The OP's question isn't \"how do I remove duplicates from a list\", but \"how\
    \ do I remove duplicates **in place** from a list\".\n<|/ c |>\n<| c |>\nJust\
    \ a note for those who are using Ruby 2.6+, the new array method: `uniq` returns\
    \ a new array (http://ruby-doc.org/core-2.6.3/Array.html#method-i-uniq) and removes\
    \ duplicates in-place.\n<|/ c |>\n<| c |>\n: good catch - I added a note to that\
    \ effect.\n<|/ c |>\n<| c |>\nThis would be a great addition to the original question\
    \ to clarify which of the two cases above is the OP's question.\n<|/ c |>\n<|\
    \ c |>\nThis should be the accepted answer.  It only requires ruby >= 2.6 because\
    \ it uses a Hash instead of an Array for the mapping.\n<|/ c |>\n<| a |>\nI guess\
    \ this is the simplest and easiest way if you are using JRuby or similar.\n<code>\n\
    require \"set\"\nlist = Set.new\nlist.add(your_list)\nlist = list.reject { |x|\
    \ list.include?(x) }\n</code>\n<|/ a tags=arrays,ruby dscore=5 |>\n<| c |>\nThis\
    \ is the best answer. No need to sort and rearrange the array. Just use `Set`\
    \ and all will be good.\n<|/ c |>\n<| c |>\nThe order of the items in the set\
    \ will be different than the order of the items in the array.\n<|/ c |>\n<| c\
    \ |>\nthe order of the items in the set will not be the same as the order of the\
    \ items in the array.\n<|/ c |>\n<| c |>\nSet's are unordered. Also, this is not\
    \ very efficient as it iterates over the array twice.\n<|/ c |>\n<| a tags=arrays,ruby\
    \ |>\nAs pointed out in comments by, the question asks for \"in-place\" removal\
    \ of duplicates from the array.\nThe solutions listed here are very inefficient,\
    \ and unnecessarily complicated in various ways:\n<code>\nrequire \"set", "  number_counts\
    \ = Hash.new(0)\n  numbers.each { |number| number_counts[number] += 1 }", "  sorted\
    \ = numbers.sort\n  duplicates = false\n  i = 0\n  while i < numbers.length\n\
    \    unless sorted[i] != sorted[i+1]\n      sorted[i] -= 1\n      duplicates =\
    \ true\n    end\n    i += 1\n  end\n  duplicates = numbers - sorted\nend", " \
    \ new_numbers = []\n  numbers.each { |num| new_numbers << num if new_numbers.include?(num)\
    \ }\n  new_numbers\nend\n</code>\n<|/ a |>\n<| c |>\nThis solution uses `Array#<<`\
    \ which isn't quite as efficient as `Array#push` but is easier to read. `push`\
    \ is more idiomatic but `<<` is more efficient. `push` is also more explicit and\
    \ easier to read IMO.\n<|/ c |>\n<| c |>\nI wouldn't use `<<` here, I'd use an\
    \ array as a set, and `include?` to test for membership: `return numbers if numbers.empty?;\
    \ set = numbers.to_a; numbers.reject { |num| set.include?(num) }`\n<|/ c |>\n\
    <| c |>\n- yeah I agree that `push` is more idiomatic but for small arrays I find\
    \ the `<<` syntax easier to understand.\n<|/ c |>\n<| a tags=ruby,arrays,duplicates\
    \ |>\n<code>", "  numbers.uniq.sort.uniq\nend", "  numbers.uniq!\nend", "  sorted\
    \ = numbers.sort.sort\n  unique = []\n  numbers_set = {}\n  numbers.each do |num|\n\
    \    if !numbers_set[num] then\n      numbers_set[num] = 1\n      unique << num\n\
    \    end\n  end\n  sorted.each {|num| unique << num}\n  unique\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby |>\n<code>\na = [1, 2, 3, 2, 4, 2, 5, 1]\na.uniq.sort",
  "  numbers.uniq!\n  numbers\nend", "  duplicates = []\n  numbers.each do |i|\n \
    \   if (duplicates.include?(i))\n      next\n    else\n      duplicates.push(i)\n\
    \    end\n  end\n  duplicates\nend", "  numbers.uniq!\n  numbers\nend", "  seen\
    \ = Set.new\n  numbers.uniq.map { |num| seen.delete(num) }.compact\nend", "  seen\
    \ = Set.new\n  numbers.delete_if { |number| seen.include?(number) }\nend\n</code>\n\
    If you're using Rails, you can take advantage of Ruby's Set functionality in Ruby\
    \ >= 1.9.\n<code>", "  numbers.inject([]) do |list, number|\n    break if list.include?(number)\n\
    \    list << number\n    list\n  end\nend", "  sorted = numbers.sort\n  last =\
    \ sorted.last\n  removed = []\n  seen = Set.new", "  numbers.inject([]) do |output,\
    \ num|\n    output << num if output.count(num) == 1 and output.size < numbers.size\n\
    \    output\n  end\nend\n</code>\nAs an example of the inject method, we have\
    \ this:\n<code>\n[1,2,3,4,5].inject(0) do |output,num|\n  output + num\nend",
  "    numbers.uniq.sort\nend", "  sorted = numbers.sort\n  last = sorted[0]\n  ret\
    \ = []\n  numbers.each do |i|\n    if last == i\n      ret << i\n      last =\
    \ sorted[sorted.size - 1]\n    else\n      last += 1\n      ret << i\n    end\n\
    \  end\n  ret\nend\n</code>\n<|/ a |>\n<| c |>\nThat's a nice solution but it's\
    \ still O(n^2) (because of the sort).\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution\
    \ in Ruby, which uses Hash#fetch to increment the value if it's present, and uses\
    \ a negative lookahead assertion to see if the value is greater than the previous\
    \ one before adding it to the array.\n<code>\nnumbers = [1, 3, 3, 5, 7, 9]\nnumbers.group_by\
    \ { |i| i }.map do |_, array|\n  array.map { |i| i if i.to_i }.sort.uniq.reject\
    \ { |i| i.to_i == i.to_i - 1 }\nend", "  # TODO: Implement function\n  raise \"\
    Not implemented\"\nend", "  seen = {}\n  uniques = []\n  numbers.each do |number|\n\
    \    seen[number] = number\n  end.each do |number|\n    if seen.has_key?(number)\n\
    \      seen[number] += 1\n    else\n      seen[number] = 1\n      uniques << number\n\
    \    end\n  end \n  uniques\nend", "  numbers.uniq.sort\nend", "  numbers.uniq.compact!\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a |>\nThe other answers here are excellent\
    \ as they explain how to use Ruby well, however I think they missed the point\
    \ about the algorithm and what that means.\nThe algorithm is simple to understand\
    \ if you take a piece of paper and draw it out for yourself. For each number in\
    \ the input it tells you whether the number is in the output (so it will be removed\
    \ if necessary). If the number is in the output then it will not be removed (as\
    \ it will be in both places).\nA simple way to think about it is to think about\
    \ each number as being a number that has a particular property (which you are\
    \ testing for). For example, the number 2 is less than or equal to 2, but the\
    \ number 3 is not less than or equal to 2. So, the algorithm is \"For each number\
    \ in the input, tell me whether the number is in the output. If it is, remove\
    \ it from the output.\"\nA more thorough way to think about it is to think of\
    \ each number as being its own property (which you are not testing). For example,\
    \ the number 2 is the only number that is greater than or equal to 2. So, the\
    \ algorithm is \"For each number in the input, tell me whether the number is not\
    \ in the output. If it is, remove it from the output.\"\nAnother way to think\
    \ about it is to think of each number as being its own property (which you are\
    \ not testing) and then to think of each property (which you are testing) as being\
    \ a combination of other properties (which you are not testing).\nFor example,\
    \ a number is not greater than, less than or equal to any number that is greater\
    \ than or equal to it. It is only greater than or equal to itself. Therefore,\
    \ the algorithm is \"For each number in the input, tell me whether the number\
    \ is not in the output. If it is, remove it from the output\".\n<|/ a tags=ruby\
    \ dscore=5 |>\n<| c |>\nThank you, very helpful.  What I was looking for was an\
    \ explanation of what this is doing.\n<|/ c |>\n<| c |>\nThis explanation has\
    \ helped me understand a bit about Ruby, and how it is different from other languages.\n\
    <|/ c |>\n<| c |>\nThis explanation is so clear and concise that I wonder why\
    \ nobody else bothered to write it down. Thanks for making it so clear and concise.\n\
    <|/ c |>\n<| c |>\nI really like the way the algorithm is described! I had trouble\
    \ understanding the \"is in\" logic initially and that made it easier to visualize\n\
    <|/ c |>\n<| a dscore=4 tags=ruby |>\nMy two cents:\n<code>", "    hash = {}\n\
    \    duplicates = []\n    numbers.each do |n|\n        if hash[n]\n          \
    \  duplicates << n\n        else\n            hash[n] = 1\n        end\n    end\n\
    \    duplicates.sort!\n    duplicates.uniq!\n    duplicates\nend", "  numbers.inject([])\
    \ do |result, item|\n    (result << item) unless result.include?(item)\n    result\n\
    \  end\nend\n</pre>", "  seen = {}\n  numbers.map do |n|\n    seen[n] ||= []\n\
    \    seen[n] += [n]\n  end\n  seen.values.compact!\n  seen.values.compact!\n \
    \ seen.values.compact!\n  seen.values.compact!\nend", "    \n    # Make empty\
    \ set to keep track of unique elements we've seen\n    seen = Set.new", "  numbers.group_by\
    \ {|x| x}.map {|x,y| y}.flatten\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a\
    \ |>\nHere is another way to do it using each_with_index and then reject:\n<code>\n\
    [1,2,2,4,2,4,1].each_with_index.reject { |a, b| a == b }\n=> [1, 4]\n</code>\n\
    <|/ a tags=ruby,arrays dscore=1 |>\n<| a dscore=0 |>\nHere is a way to do that\
    \ using map and group_by\n<code>\na = [1,2,2,4,2,4,1]", "  numbers.uniq!\nend\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\n`uniq!` is from Rails 4 though, so that may\
    \ not be an option.\n<|/ c |>\n<| c |>\nuniq! was introduced in Rails 4 but is\
    \ still available in Rails 3. http://api.rubyonrails.org/classes/ActiveSupport/CoreExtensions/Array/Array.html#method-i-uniq-21\n\
    <|/ c |>\n<| a tags=arrays,ruby,ruby-on-rails dscore=3 |>\nYou can do that by\
    \ iterating over the array. \n<code>", "  numbers.uniq.compact!\nend", "  numbers.uniq.sort!\n\
    \  numbers.uniq!\n  numbers\nend", "  number_set = numbers.to_set\n  number_set\
    \ - numbers\nend\n</code>\nThis is similar to Ruby's Hash#keep_if or Ruby's Enumerable#keep_if,\
    \ but for Ruby.\n<|/ a tags=ruby,duplicates |>\n<| a dscore=3 tags=ruby,duplicates\
    \ |>\nHere's a one liner that uses Array#uniq and Array#count:\n<code>\n[3, 2,\
    \ 5, 5, 5, 5].uniq.count # => 3\n</code>\nOr even simpler:\n<code>\n[3, 2, 5,\
    \ 5, 5, 5].uniq.size # => 3\n</code>\nBut this isn't the best way to remove duplicate\
    \ elements from a list.  This is O(n^2) -- it is O(n) -- but that isn't that bad\
    \ if you only have to do this once or twice:\n<code>", "  numbers.uniq\nend\n\
    </code>\n<|/ a tags=arrays,ruby,sorting,algorithm |>\n<| c |>\nI appreciate your\
    \ answer, but if you read through the question, you'll see that I'm specifically\
    \ looking for a method that can be implemented in ruby, so this answer isn't really\
    \ applicable in my case.\n<|/ c |>\n<| c |>\nSure. Thanks for pointing that out.\
    \ I've added an answer with Ruby code.\n<|/ c |>\n<| a dscore=0 |>\nSince you\
    \ were looking for an answer in Ruby, here is an example:\n<code>", "  numbers.uniq.sort\n\
    end", "  numbers.each_with_object([]) do |number, new_numbers|\n    new_numbers\
    \ << number if new_numbers.include?(number)\n  end\nend", "  sorted = numbers.sort\n\
    \  result = sorted.uniq.sort\nend\n</code>\n<|/ a |>\n<| c |>\nThis works great!\
    \ I used it to sort my objects by date. Thanks!\n<|/ c |>\n<| c |>\nThis only\
    \ works because Ruby converts nil to false when it is used in an if statement.\
    \ Other languages convert it to true (e.g. C#).\n<|/ c |>\n<| c |>\nThank you\
    \ for the comment. Edited my answer to reflect your comment.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nIn case it's useful to anyone, here's a more Ruby-like approach that doesn't\
    \ require a sort:\n<code>\nmy_array.group_by{|e| e}.map{|k,v| [k, v.size]}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nI like this solution, though I would be cautious about\
    \ its performance -- it looks like O(n) rather than O(n*log(n)) (which might be\
    \ more realistic, depending on how often your data sets are going to be very large).\n\
    <|/ c |>\n<| c |>\nIt's definitely O(n) because it only goes over the array once.\
    \ Even though this is O(n^2) for the sort, it's still O(n) on the final result\
    \ because of the map and array. However, the question only asked for the size\
    \ of the elements, which should be pretty close to O(1), so I'm not sure it matters.\n\
    <|/ c |>\n<| a tags=ruby |>\nHere's a version that doesn't require sort:\n<code>",
  "  numbers = numbers.sort\n  i = 0\n  while i < numbers.length\n    if numbers[i]\
    \ != numbers[i + 1]\n      numbers = numbers.delete_at(i)\n    end\n    i += 1\n\
    \  end\n  numbers\nend", "  sorted_numbers = numbers.sort\n  seen = {}\n  numbers.each\
    \ do |number|\n    if seen[number]\n      sorted_numbers.delete(number)\n    \
    \  seen[number] = false\n    end\n    seen[number] = true\n  end\n  sorted_numbers\n\
    end", "    numbers.uniq.sort\nend\n</code>\nAnd finally, just make sure your function\
    \ returns a value that matches the return type of the method!\n<code>", "  uniques\
    \ = []\n  seen = {}\n  numbers.each do |number|\n    if seen[number]\n      seen[number]\
    \ = false\n    else\n      uniques << number\n      seen[number] = true\n    end\n\
    \  end\n  uniques\nend", "  return numbers.uniq\nend", "    unique_numbers = []\n\
    \    unique_numbers.concat(numbers)\n    unique_numbers.sort!\n    unique_numbers.each\
    \ {|n| unique_numbers.delete(n) if unique_numbers.count(n) > 1}\n    unique_numbers\n\
    end", "  numbers_count = numbers.reduce(Hash.new, :merge!)\n  numbers.select {\
    \ |n| numbers_count[n] == 1 }.sort\nend", "  # Create a hash to keep track of\
    \ what numbers have been removed.\n  removed_numbers = {}\n  # Loop through the\
    \ numbers, deleting each number that appears more than once.\n  numbers.each do\
    \ |number|\n    if removed_numbers[number] == nil\n      removed_numbers[number]\
    \ = 1\n    else\n      removed_numbers[number] += 1\n    end\n  end\n  # Return\
    \ an array containing the unique numbers in order of appearance in the\n  # original\
    \ array.\n  return removed_numbers.sort.map(&:to_i)\nend\n</pre>\n           \
    \ </div>\n          </div>\n          <div class=\"modal-footer\">\n         \
    \   <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">Close</button>\n\
    \          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div\
    \ class=\"bs-example\" data-example-id=\"dismiss-on-next-click\">\n    <button\
    \ type=\"button\" class=\"btn btn-primary btn-lg\" data-toggle=\"modal\" data-target=\"\
    #exampleModal\">\n      Launch demo modal\n    </button>\n    <div class=\"modal\
    \ fade\" id=\"exampleModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"\
    exampleModalLabel\" aria-hidden=\"true\">\n      <div class=\"modal-dialog\" role=\"\
    document\">\n        <div class=\"modal-content\">\n          <div class=\"modal-header\"\
    >\n            <button type=\"button\" class=\"close\" data-dismiss=\"modal\"\
    \ aria-label=\"Close\">\n              <span aria-hidden=\"true\">&times;</span>\n\
    \            </button>\n            <h4 class=\"modal-title\" id=\"exampleModalLabel\"\
    >Modal title</h4>\n          </div>\n          <div class=\"modal-body\">\n  \
    \          ...\n          </div>\n          <div class=\"modal-footer\">\n   \
    \         <button type=\"button\" class=\"btn btn-secondary\" data-dismiss=\"\
    modal\">Close</button>\n            <button type=\"button\" class=\"btn btn-primary\"\
    >Save changes</button>\n          </div>\n        </div>\n      </div>\n    </div>\n\
    \  </div>\n  <div class=\"bs-example\" data-example-id=\"backdrop\">\n    <div\
    \ class=\"modal fade\" id=\"exampleBackdrop\" tabindex=\"-1\" role=\"dialog\"\
    \ aria-labelledby=\"exampleModalLabel\" aria-hidden=\"true\">\n      <div class=\"\
    modal-dialog\" role=\"document\">\n        <div class=\"modal-content\">\n   \
    \       <div class=\"modal-header\">\n            <button type=\"button\" class=\"\
    close\" data-dismiss=\"modal\" aria-label=\"Close\">\n              <span aria-hidden=\"\
    true\">&times;</span>\n            </button>\n            <h4 class=\"modal-title\"\
    \ id=\"exampleModalLabel\">Modal title</h4>\n          </div>\n          <div\
    \ class=\"modal-body\">\n            ...\n          </div>\n          <div class=\"\
    modal-footer\">\n            <button type=\"button\" class=\"btn btn-secondary\"\
    \ data-dismiss=\"modal\">Close</button>\n            <button type=\"button\" class=\"\
    btn btn-primary\">Save changes</button>\n          </div>\n        </div>\n  \
    \    </div>\n    </div>\n  </div>\n  <div class=\"bs-example\" data-example-id=\"\
    custom-class\">\n    <div class=\"modal fade\" id=\"exampleCustomClass\" tabindex=\"\
    -1\" role=\"dialog\" aria-labelledby=\"exampleModalLabel\" aria-hidden=\"true\"\
    >\n      <div class=\"modal-dialog\" role=\"document\">\n        <div class=\"\
    modal-content\">\n          <div class=\"modal-header\">\n            <button\
    \ type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"\
    >\n              <span aria-hidden=\"true\">&times;</span>\n            </button>\n\
    \            <h4 class=\"modal-title\" id=\"exampleModalLabel\">Modal title</h4>\n\
    \          </div>\n          <div class=\"modal-body\">\n            ...", " \
    \   seen = {}\n    uniques = []\n    numbers.each do |num|\n        if seen[num]\
    \ == nil\n            uniques << num\n            seen[num] = 1\n        end\n\
    \    end\n    uniques\nend", "  numbers.uniq!\nend", "    numbers.inject([]) {\
    \ |result, elem| result << elem if result.count(elem) == 1 }\nend", "  numbers.reduce([])\
    \ do |numbers|\n    numbers.uniq.sort!\n    numbers\n  end\nend", "  return numbers.uniq.sort\n\
    end", "  return numbers.uniq!\nend\n</pre>", "    numbers.uniq!\n    numbers\n\
    end", "  return numbers[0...numbers.size - 1].join('') unless numbers.empty?\n\
    \  numbers.reduce(:+)\nend", "  numbers.uniq.compact!\nend", "  # O(n) time and\
    \ space\n  seen = Set.new\n  numbers.each do |num|\n    seen.add? num\n  end\n\
    \  seen\nend\n</code>\n<|/ a dscore=5 tags=ruby,arrays,list |>\n<| c |>\nThe output\
    \ should be the original array. Hence the array should not be reordered.\n<|/\
    \ c |>\n<| c |>\nIf you need to preserve the order, you can just do `numbers.uniq.sort`\n\
    <|/ c |>\n<| c |>\nIt would be nice to include a link to `Set` class documentation\
    \ and include a link to [`Hash`](http://ruby-doc.org/core/classes/Hash.html) documentation.\n\
    <|/ c |>\n<| c |>\nTo preserve order, just do:  `numbers.uniq!.sort`\n<|/ c |>\n\
    <| c |>\nThe `Set` class documentation is at [http://ruby-doc.org/stdlib-2.4.0/libdoc/set/rdoc/Set.html](http://ruby-doc.org/stdlib-2.4.0/libdoc/set/rdoc/Set.html).\
    \ The documentation for the `Hash` class is [http://ruby-doc.org/stdlib-2.4.0/libdoc/hash/rdoc/Hash.html](http://ruby-doc.org/stdlib-2.4.0/libdoc/hash/rdoc/Hash.html)\n\
    <|/ c |>\n<| a tags=ruby,arrays,list |>\nJust for fun, here's another implementation:\n\
    <code>", "  numbers.uniq!\n  numbers\nend", "  numbers.uniq\nend", "  numbers\
    \ = numbers.sort\n  numbers.uniq!\n  numbers\nend", "  return numbers.group_by\
    \ { |number| number }.select { |number, values| values.size > 1 }.keys\nend",
  "  numbers = numbers.to_a\n  numbers.reject!{ |num| numbers.count(num) > 1 }\n \
    \ numbers.uniq!\n  numbers\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby dscore=0\
    \ |>\n<code>", "  sorted = numbers.sort\n  new_numbers = []\n  last = []\n  numbers.each\
    \ do |n|\n    if sorted.include?(n)\n      last.push(n)\n    else\n      new_numbers\
    \ << last.pop\n      new_numbers << n\n    end\n  end\n  new_numbers << last.pop\n\
    \  new_numbers.sort\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,sorting,duplicates\
    \ |>\nIf you had an array of hashes and wanted to see a count of duplicates across\
    \ all elements in a given array of hashes then you could use the following:\n\
    <code>", "  index = 0\n  new_numbers = []\n  \n  while index < numbers.length\n\
    \    new_numbers << numbers[index]\n    index += 1\n    \n    index_counter =\
    \ 0\n    while index < numbers.length\n      if numbers[index] == numbers[index_counter]\n\
    \        new_numbers.delete(numbers[index])\n        index += 1\n      else\n\
    \        index_counter += 1\n      end\n    end\n  end\n  \n  new_numbers\nend\n\
    </cell>\n<cell>\nremove_duplicates([1, 2, 3, 2, 4])\n</cell>\n<cell>", '  result
    = numbers.clone', "  numbers.uniq.sort!\n  numbers.uniq!\nend", "  numbers.uniq!\n\
    \  numbers\nend", "  index = 0\n  result = []\n  \n  until index == numbers.length\n\
    \  \n    number = numbers[index]\n    \n    next unless result.include? number\n\
    \    \n    if number != result[index]\n      \n      result.push number\n    \
    \  index += 1\n    end\n  end\n  \n  result.push numbers[index] if index != numbers.length\n\
    \  \n  result\nend\n</cell>\n<cell>", "  result = []\n  numbers.each_with_index\
    \ do |number, index|\n    if !result.include?(number)\n      result << number\n\
    \    end\n  end\n  result\nend\n</cell>\n<code language=julia-1.1>", "  numbers.uniq.compact!\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nWhy `compact!`? Wouldn't `uniq` be enough?\n\
    <|/ c |>\n<| c |>\n: No. `uniq` will also remove nil values. `compact` will remove\
    \ all nil values from the array.\n<|/ c |>\n<| c |>\nThanks, that's a great answer!\n\
    <|/ c |>\n<| a dscore=5 |>\nRuby 1.9 includes the Array#uniq method:\n<code>\n\
    >> [1,2,2,3,4].uniq\n=> [1, 2, 3, 4]\n</code>\n<|/ a tags=ruby,arrays |>\n<| c\
    \ |>\nThe `uniq` method is not available in Ruby 1.8.7\n<|/ c |>\n<| c |>\nJust\
    \ to note that `uniq` uses `!~` which has lower performance in ruby 1.8.7, and\
    \ I wouldn't use it if it weren't for the fact that it doesn't return a distinct\
    \ list\n<|/ c |>\n<| c |>\nThis should be the new accepted answer, as it provides\
    \ both the uniq method and an easy way to get back an array with only distinct\
    \ values.\n<|/ c |>\n<| a tags=ruby,arrays |>\nRuby 1.9.2 has a uniq method, which\
    \ works exactly like Rails 2.3.10 does.\n<|/ a dscore=5 |>\n<| c |>\nThe `uniq`\
    \ method is not available in Ruby 1.8.7\n<|/ c |>\n<| a tags=ruby,arrays |>\n\
    Ruby 1.8 has the Array#uniq! method which modifies the array in place and returns\
    \ nil.  You can use this to remove duplicates from an array.\n<|/ a dscore=5 |>\n\
    <| c |>\nThis should be the new accepted answer, as it provides both the `uniq`\
    \ method and an easy way to get back an array with only distinct values.\n<|/\
    \ c |>\n<| a dscore=5 |>\nRuby 1.8 has an Array#uniq method, but it's marked as\
    \ private, so if you're using Rails or have ActiveSupport you can do:\n<code>",
  "  numbers.each_with_index.inject([]) do |memo, (n, i)|\n    if memo.include?(n)\n\
    \      memo.delete_at(i)\n    else\n      memo << n\n    end\n    memo\n  end\n\
    end\n</code>\n<|/ a tags=ruby,sorting,arrays dscore=0 |>\n<| a dscore=0 tags=ruby,sorting,arrays\
    \ |>\nA simple and efficient solution:\n<code>", "  numbers.uniq!\n  numbers\n\
    end", "  numbers.uniq.sort\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays |>\n\
    <code>", "  numbers.sort!\n  result = []\n  while numbers.any?\n    last, number\
    \ = numbers.sort.last, numbers.shift\n    next if last == number # prevent unnecessary\
    \ iteration\n    result << number\n  end\n  result\nend", "  seen = Set.new #\
    \ Set of seen elements\n  numbers.each do |number|\n    seen.delete(number) if\
    \ seen.include?(number)\n  end\n  seen\nend\n</cell>\n<cell>", "  numbers.uniq!\n\
    end", "  numbers.delete_if { |x| numbers.count(x) > 1 }\nend", "  seen = {}\n\
    \  numbers.each do |num|\n    if seen[num] == nil\n      seen[num] = 1\n    else\n\
    \      seen[num] += 1\n    end\n  end\n  \n  numbers.delete_if do |num|\n    seen[num]\
    \ == 1\n  end\n  \n  seen\nend\n</code>\nThis code uses a hash to keep track of\
    \ which numbers have been seen already. \nIf you have a list of numbers like so:\n\
    <code>\nnumbers = [1, 2, 3, 4, 5, 6]\n</code>\nThe code above will return:\n<code>\n\
    seen = {1 => 1, 2 => 2, 3 => 3, 4 => 4, 5 => 5, 6 => 6}\n</code>\nThe numbers\
    \ are returned in original order (as in the original list), but duplicates have\
    \ been removed.\n<|/ a |>\n<| a tags=ruby |>\n<code>\narr = [1, 2, 3, 3, 5, 6,\
    \ 6, 6]\narr.uniq\n=> [1, 3, 5, 6]\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ should be the accepted answer. Simple and effective.\n<|/ c |>\n<| c |>\nThis\
    \ returns unique elements while OP asked for duplicate elements, i.e. remove 3\
    \ from [1, 2, 3, 3, 5, 6, 6, 6] and returns [1, 2, 5, 6]\n<|/ c |>\n<| c |>\n\
    This should be the accepted answer.\n<|/ c |>\n<| a dscore=5 tags=ruby |>\n<code>\n\
    arr = [1,2,3,4,5,5,5,6,7,8]\narr.group_by{|x| x}.values.map(&:first)\n=> [1, 2,\
    \ 3, 4, 5, 6, 7, 8]\n</code>\n<|/ a |>\n<| c |>\n`group_by` is an amazing method\
    \ for grouping things. I wanted to do something like this to show duplicate entries.\n\
    <|/ c |>\n<| c |>\nNot a very Rubyish solution - group_by gives you an array,\
    \ which means you lose the ability to use #each.\n<|/ c |>\n<| c |>\nIt was a\
    \ very nice solution\n<|/ c |>\n<| c |>\n`group_by` method returns hash, so the\
    \ values method is used instead of each.\n<|/ c |>\n<| a tags=ruby |>\nIf it's\
    \ an array of arrays then you can do this:\n<code>\n[array1, array2, array3, array4,\
    \ array5].flatten.uniq\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this one because\
    \ it allows me to pass `&:first` or `&:last` to `uniq`.  It also keeps the original\
    \ order of the original array un", "  numbers.uniq!\nend\n</code>\n<|/ a |>\n\
    <| c |>\n`uniq!` isn't a method on arrays in Rails 4.\n<|/ c |>\n<| c |>\nI guess\
    \ you can still use `Array#uniq` on Rails 4. `require 'active_support/all'` and\
    \ `require 'active_support/core_ext/array'` before this code.\n<|/ c |>\n<| a\
    \ dscore=5 |>\nIf you want a quick way to remove duplicates in an array you can\
    \ use the uniq method on the array.\n<code>\na = [1,2,3,2,4,2,5,7,7]\na = a.uniq",
  "    numbers.uniq!\nend\n</code>\nAs others have pointed out, the uniq! method removes\
    \ all duplicates.  If you want the result to remain the same order as the input,\
    \ you could do this:\n<code>", "  i = 0\n  while i < numbers.length\n    if numbers[i]\
    \ != numbers[i+1]\n      i += 1\n      numbers[i] = numbers[i+1]\n    end\n  end\n\
    \  return numbers\nend", "  numbers.uniq.sort\nend\n</code>\n<|/ a |>\n<| a tags=arrays,ruby\
    \ |>\nHere's a way using Ruby's Set class to store a set of all unique elements:\n\
    <code>\na = [1, 2, 3, 2]\ns = Set.new(a) # => #<Set: {1, 2, 3}>", "  sorted_numbers\
    \ = numbers.sort\n  result = sorted_numbers[0]\n  for i in 1..sorted_numbers.length\n\
    \    if (sorted_numbers[i] == sorted_numbers[i - 1]) then\n      next\n    else\n\
    \      result = sorted_numbers[i]\n    end\n  end\n  result\nend\n</pre>", " \
    \ numbers.uniq.compact!\nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>", " \
    \ dups = numbers.map { |num| [num, true] }.uniq.map { |num| num[0] }\n  numbers.delete_if\
    \ { |n| dups.include?(n) }\nend\n</code>\n<|/ a dscore=4 |>\n<| a |>\nJust for\
    \ fun, here's a quick one-line implementation using inject:\n<code>", "  numbers.uniq!\n\
    \  numbers\nend", "  # Write your code here.\n  \n  numbers_as_hash = Hash[numbers]\n\
    \  numbers_as_hash.delete_if do |number|\n    if numbers_as_hash[number] == number\n\
    \      true\n    else\n      false\n    end\n  end", "    numbers.group_by { |n|\
    \ n }.map { |k,v| v }.flatten\nend", "  numbers_with_frequency = Hash.new{|h,k|\
    \ h[k] = 0}\n  numbers.each {|x| numbers_with_frequency[x] += 1}\n  numbers.delete_if{|x|\
    \ numbers_with_frequency[x] > 1}\nend\n</code>\n<|/ a |>\n<| a |>\nJust for fun,\
    \ here is a solution that uses only an array:\n<code>", "  numbers.group_by{|n|\
    \ n}.select{|_,v| v.size > 1}.keys\nend\n</code>\nThe code above works by first\
    \ grouping each element of the list by its value, which is done by group_by{|n|\
    \ n}. Then, for each of the grouping, we check if there are any elements that\
    \ have more than one element (i.e. a duplicate). In that case, those values are\
    \ removed from the grouping and thus we keep the original order of the elements.\
    \ Finally, we simply return the keys of the groups to get rid of the duplicate\
    \ values.\n<|/ a tags=arrays,ruby,ruby-on-rails-4 |>\n<| c |>\nI like your answer\
    \ but I can't upvote it.\n<|/ c |>\n<| c |>\n: Thanks for the upvote! :-)\n<|/\
    \ c |>\n<| c |>\n: I posted my answer.\n<|/ c |>\n<| c |>\nThis should work but\
    \ I don't think it's as fast as `group_by`/`select`, because you're making one\
    \ pass over the array. Also, you're using an external gem, which could be slow.\n\
    <|/ c |>\n<| c |>\n: Yes, but it's not an external gem. Plus, `group_by` has to\
    \ iterate over the whole array to collect elements, `select` has to check each\
    \ element against the other elements in the same group, and `size` has to calculate\
    \ each element and store it in memory, so I'm pretty sure that's not as fast as\
    \ `group_by`/`select`.\n<|/ c |>\n<| a |>\nHere's a more efficient solution, using\
    \ Hash.new and Hash#merge:\n<code>", "  sorted = numbers.sort\n  last = sorted.last\n\
    \  result = sorted.delete_if { |x| last == x }\n  sorted.concat([last])\nend",
  "  numbers = numbers.sort!\n  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby,ruby-on-rails |>\n<code>", "    numbers.uniq!\n    numbers\nend\n\
    </code>\n<|/ a |>\n<| a tags=ruby |>\nHere is a concise way to do it using Hash.\n\
    <code>", "  numbers.uniq.compact\nend", "  numbers.uniq.sort\nend\n</code>\nThis\
    \ one is a bit more complicated:\n<code>", "  numbers.uniq!\nend", "  result =\
    \ []\n  seen = Set.new\n  numbers.each { |n| result << n if !seen.include?(n)\
    \ && seen.add(n) }\n  result\nend", "  sorted = numbers.sort\n  last = sorted[0]\n\
    \  numbers.dup!\n  numbers.reject!{|n| n == last}\n  numbers\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails dscore=5 |>\n<| c |>\nThis is a much cleaner solution.\
    \ Very cool.\n<|/ c |>\n<| c |>\nTo avoid modifying the original array, you can\
    \ do `numbers.uniq!`\n<|/ c |>\n<| c |>\nThis is a great answer. How would you\
    \ write this with ruby 2.0?\n<|/ c |>\n<| c |>\nYou can use the method `uniq`\
    \ instead of `uniq!`\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\nI think using\
    \ uniq, as suggested in other answers, is probably the best approach, but here\
    \ is another alternative.  It involves creating a new array:\n<code>", "  new_numbers\
    \ = []\n  numbers.each do |number|\n    new_numbers << number unless new_numbers.include?\
    \ number\n  end\n  new_numbers\nend", "    seen = Set.new\n    numbers.each do\
    \ |n|\n        if seen.include? n\n            numbers.delete n\n        else\n\
    \            seen << n\n        end\n    end\n    numbers\nend\n</cell>\n<cell>\n\
    remove_duplicates([1, 2, 3, 2])\n</cell>\n<cell>", "    numbers.uniq!\n    numbers\n\
    end", "  numbers, seen = [], []\n  numbers.each do |number|\n    if number in\
    \ seen\n      numbers.delete(number)\n      break\n    else\n      seen << number\n\
    \    end\n  end\n  numbers\nend", "  numbers.uniq!\n  numbers\nend", "  number_set\
    \ = Set.new\n  numbers.each do |number|\n    number_set.add(number)\n  end\n \
    \ number_set\nend", "  numbers.uniq.sort!\n  numbers.uniq!\nend\n</code>\n<|/\
    \ a dscore=4 |>\n<| c |>\n`Enumerable#uniq!` method does not preserve order of\
    \ elements when removing duplicates.\n<|/ c |>\n<| a tags=ruby,arrays |>\nIf anyone\
    \ is looking for the solution in Ruby\n<code>\narr = [1,2,1,2,3]\narr.group_by\
    \ { |i| i }.select { |k,v| v.size >1 }.keys\n</code>\n<|/ a dscore=4 |>\n<| a\
    \ |>\nUsing a hash for efficiency.\n<code>\nrequire 'set'\n[1,2,2,3,1].group_by\
    \ { |x| x }.each_with_object(Hash.new(0)) { |(k,v),g| g[v] += 1 }.select { |k,v|\
    \ v > 1 }\n=> [1, 2]\n</code>\n<|/ a tags=ruby,arrays dscore=4 |>\n<| c |>\nIf\
    \ you were to do this with a large number of elements, this would be less efficient\
    \ than `Array#uniq`, because `Array#uniq` would create a new array and copy all\
    \ elements over to a new array before filtering it out.  It's not necessary for\
    \ small arrays, but when working with a large number of elements, the memory use\
    \ could become an issue.  That said, I believe this is a much better approach\
    \ for large arrays.\n<|/ c |>\n<| c |>\nYou are correct. My solution does not\
    \ use uniq, but it does use a hash, which may or may not be significantly more\
    \ efficient. Using a hash is O(1) (assuming that the hash is only ever accessed\
    \ via keys) while `Array#uniq` is O(n). So for large arrays, this is a more efficient\
    \ solution. Also, my solution uses `each_with_object` which was introduced in\
    \ 1.9.2.\n<|/ c |>\n<| c |>\nI tested it with large arrays and it seems that `uniq`\
    \ is indeed more efficient than a hash. My solution was about 2x slower with `uniq`,\
    \ but about 20x faster with a hash.  Interesting.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\nAnother approach to this is to simply count the occurrences of each number\
    \ in the array, and keep only those that occur more than once. For example:\n\
    <code>", "  numbers.uniq!\n  numbers\nend", "  sorted_numbers.sort.delete_if {\
    \ |num| numbers.count(num) > 1 }\nend", "  index = {}\n  numbers.each_with_index\
    \ do |number, index|\n    index[number] = index\n  end\n  numbers.delete_if {\
    \ |number| index[number] > 1 }\nend", "  seen = {}\n  numbers.each do |number|\n\
    \    seen[number] ||= []\n    seen[number] << number\n  end\n  seen.values.flatten!\n\
    \  seen\nend", "    numbers.uniq!\n    numbers\nend", "  numbers = numbers.uniq.sort\n\
    \  numbers.delete_if { |number| numbers.count(number) == 1 }\nend\n</code>\n<|/\
    \ a dscore=5 tags=ruby,arrays |>\n<| c |>\nThis is great, thank you! However I\
    \ noticed that it does not preserve order. Is there an easy way to fix this?\n\
    <|/ c |>\n<| c |>\nIf you're using rails, you can just call `uniq` on it: `[1,\
    \ 2, 3, 2].uniq`\n<|/ c |>\n<| c |>\nAlso if you're using rails, you can `uniq`\
    \ the entire array at once instead of using `uniq` on every element in the array:\
    \ `[1, 2, 3, 2].uniq`.\n<|/ c |>\n<| c |>\nWhat about [1,2,2,3,3] and [1,2,2,3,1]?\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\n  numbers\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
