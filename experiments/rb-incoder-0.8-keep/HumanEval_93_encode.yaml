name: HumanEval_93_encode
language: rb
prompt: "# Write a function that takes a message, and encodes in such a \n# way that\
  \ it swaps case of all letters, replaces all vowels in \n# the message with the\
  \ letter that appears 2 places ahead of that \n# vowel in the english alphabet.\
  \ \n# Assume only letters. \n# Examples:\n# >>> encode('test')\n# 'TGST'\n# >>>\
  \ encode('This is a message')\n# 'tHKS KS C MGSSCGG'\ndef encode(message)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encode\n\
  \    candidate = method(:encode)\n    assert_equal(\"tgst\", candidate.call(\"TEST\"\
  ))\n    assert_equal(\"mWDCSKR\", candidate.call(\"Mudasir\"))\n    assert_equal(\"\
  ygs\", candidate.call(\"YES\"))\n    assert_equal(\"tHKS KS C MGSSCGG\", candidate.call(\"\
  This is a message\"))\n    assert_equal(\"k dQnT kNqW wHcT Tq wRkTg\", candidate.call(\"\
  I DoNt KnOw WhAt tO WrItE\"))\n  end\nend\n"
completions: ["  message1 = message.split(' ') #splits the message into a list, so\
    \ we can split each letter of the message into a list too\n  message2 = message1.map\
    \ {|x| x.chars.map(&:downcase).join(' ') } #converts each letter of the list into\
    \ a string and lowercases the string\n  message3 = message2.map {|x| x.gsub(/[aeiou]/,'#').gsub(/#/,'A')\
    \ } #replaces all vowels with an #\n  message3.join(' ') #joins the list back\
    \ together again\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for taking\
    \ the time to look into my problem. Unfortunately, that doesn't help since my\
    \ code isn't working. I'm just trying to figure out how to write the code myself,\
    \ rather than using the code. Also, I don't understand your last comment. I get\
    \ that you're trying to be helpful, and I do appreciate that, but I don't know\
    \ how to be helpful. Could you please clarify what you mean?\n<|/ c |>\n<| c |>\n\
    It's very difficult to understand what you mean by your code, so I don't want\
    \ to be too helpful here. But I will try to help you out, anyway.", "  new_message\
    \ = ''\n  message.each_char do |char|\n    next if char.upcase == \"Z\"\n    idx\
    \ = alpha.index(char.upcase)\n    idx += 1 if idx > 0 && idx < 26\n    new_message\
    \ += alpha[idx]\n  end\n  new_message += message[/([aeiou])([aeiou])/, 1]\n  return\
    \ new_message\nend", "    # Your code here\n    return ''\n</code>\n<|/ a dscore=0\
    \ tags=string,python,algorithm |>\n<| a tags=string,python,algorithm dscore=0\
    \ |>\nHere is an example from Sedgewick's Python algorithms:\n<code>", "    message\
    \ = message.upcase\n    vowels = ['a','e','i','o','u']\n    swaps = message.gsub(/[aeiou]/){\
    \ |m| vowels[vowels.index(m)+2] }\n    message = swaps\n    message << message.gsub(/[aeiou]/)\
    \ { |m| vowels.index(m) }\nend\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| c |>\n\
    Thanks, this is perfect. I was hoping to not use upcase but this works well enough\
    \ for me!\n<|/ c |>\n<| c |>\n- `upcase` works well enough for you because it\
    \ takes about twice as long as the other examples to complete as `gsub` does,\
    \ so it's about as good as any other solution, which is why I added it.\n<|/ c\
    \ |>\n<| c |>\nWow, I didn't realize upcase was that expensive. Thanks for the\
    \ insight!\n<|/ c |>\n<| a dscore=1 |>\nUse gsub to replace all vowels with their\
    \ two closest neighbors (average of the two closest neighbors), e.g. the letter\
    \ T replaced with K and the letter P replaced with G:\n<code>", "  message\nend",
  "  new_message = []\n  message.split(\"\").each do |char|\n    if char.match(/[aeiou]/)\n\
    \      new_message << char.upcase + char.upcase.next\n    else\n      new_message\
    \ << char\n    end\n  end\n  return new_message.join(\"\")\nend", "    message\
    \ = message.upcase\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    vowels = vowels.each_with_index.to_a\n\
    \    message = message.split(\"\").map { |c| c }.join\n    hash = Hash.new(0)\n\
    \    message.split(\"\").each { |char| hash[char] += 1}\n    hash.each_with_index\
    \ do |char, count|\n        char = char.downcase\n        vowel_position = vowels.find{\
    \ |v| char.include? v }.to_i\n        hash[char] = (count - vowel_position) +\
    \ hash[char]\n    end\n    hash.to_a.join(\"\")\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nI didn't downvote this because it's an interesting solution, but I think\
    \ it can be simplified substantially. For example, `vowels.each { |c| hash[c]\
    \ -= 1; hash[c] += 1; }` would be a more compact replacement for your `hash =\
    \ Hash.new(0)` line, and it would avoid the need for the `each_with_index` call.\n\
    <|/ c |>\n<| c |>\n- I agree that `vowels.each { |c| hash[c] -= 1; hash[c] +=\
    \ 1; }` could be simplified even more, however it didn't make the code more readable.\
    \  It would actually make it more confusing.\n<|/ c |>\n<| c |>\nIt could definitely\
    \ be simplified further, I was just pointing out that `vowels.each_with_index.to_a`\
    \ could replace `vowels.each_with_index.map{ |v, i| [v, i] }` and that you could\
    \ `vowels.map { |v| [v, vowels.index(v)] }.to_h` to avoid the additional `each`.\n\
    <|/ c |>\n<| c |>\n- I agree, however, I felt like I was already taking more effort\
    \ than I could have by writing this code.\n<|/ c |>\n<| c |>\nI wasn't complaining\
    \ about being confusing or anything -- I just figured you might want to point\
    \ out that your answer is very similar to the accepted answer. It might not be\
    \ a good idea to vote it down, though, since it does seem like it might be useful\
    \ to other readers.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    message.gsub(/a/){|e|\
    \ e[/[aeiou]/]}.gsub(/v/){|e| e[/[aeiou]/]+2}.gsub(/e/){|e| e.split('').map(&:downcase).join}\n\
    end", "    # Write your code here. \nend", "    alphabet = %w[a b c d e f g h\
    \ i j k l m n o p q r s t u v w x y z]\n    vowels = 'aeiou'\n    new_message\
    \ = message\n    letter_count = 0\n    vowel_count = 0\n    new_message.upcase!",
  "  vowels = 'aeiouAEIOU'\n  consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n\
    \  \n  \n  message = message.to_s.downcase\n  message = \"\"\n  \n  message.each_char\
    \ do |letter|\n    if vowels.include?(letter)\n      letter = consonants.find\
    \ { |c| c != letter }\n      message << letter\n    else\n      letter = vowels.find\
    \ { |v| v != letter }\n      message << letter\n    end\n  end\n  \n  return message\n\
    end", "    # your code here\n    swapped = ''\n    vowels = ('a', 'e', 'i', 'o',\
    \ 'u')\n    vowel = vowels.index('A')\n    alphabet = ('a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z')\n    alphabet = alphabet.index('A')\n    for symbol\
    \ in message:\n        if symbol in vowels:\n            swapped = swapped + 'K'\n\
    \        else:\n            swapped = swapped + 'K' + symbol\n    swapped = swapped.replace('K',\
    \ 'z')\n    swapped = swapped.replace('z', 'a')\n    return swapped", "  message.chars.shuffle.map\
    \ do |letter|\n    if letter.upcase == 'A'\n      'b'\n    elsif letter.upcase\
    \ == 'I'\n      'g'\n    elsif letter.upcase == 'O'\n      'p'\n    elsif letter.upcase\
    \ == 'U'\n      'u'\n    else\n      letter\n    end\n  end.join\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby dscore=0 |>\n<code>", "    chars = message.upcase.split(\"\
    \")\n    \n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    \n    chars.each_with_index\
    \ { |c, i| \n        if vowels.include?(c) \n            chars[i] = chars[i+1]\n\
    \        end\n    }\n    \n    chars.join \nend\n</cell>\n<code language=julia-0.4>\n\
    encode(\"test\")\n</cell>\n<code language=julia-0.4>\nencode(\"This is a message\"\
    )\n</cell>\n<text>\nProblem 4\nThe following functions encode and decode uppercase\
    \ and lowercase letters.", "    letters    = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \    vowels     = ['a','e','i','o','u']\n    message = message.gsub(/([a-z])/)\
    \ { |x| letters.indexOf(x[0]) }\n    message = message.gsub(/[aeiou]/) { |x| vowels.indexOf(x)\
    \ }\n    \n    return message\nend", "  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  vowels = 'aeiouAEIOU'\n  consonants = 'bcdfghjklmnpqrstvwxz'\n  output = ''\n\
    \  message.length.times do |i|\n    if message[i] =~ /[aeiou]/\n      output <<\
    \ message[i].upcase \n    elsif message[i] == vowels[(message.length - i) / 2]\n\
    \      output << alphabet[(message.length - i) / 2].upcase\n    elsif message[i]\
    \ == consonants[(message.length - i) / 2 + 1]\n      output << alphabet[(message.length\
    \ - i) / 2 + 1].upcase\n    else\n      output << message[i]\n    end\n  end\n\
    \  output\nend\n</code>\n<|/ a dscore=0 tags=ruby,arrays |>\n<| c |>\nYeah this\
    \ is great and works well!\n<|/ c |>\n<| c |>\nHow would you do this using the\
    \ inject method?\n<|/ c |>\n<| c |>\nThe `inject` method is useful if you're dealing\
    \ with arrays of different types. In this case, the message and the alphabet are\
    \ both strings, and the code would be the same (except you'd have to refactor\
    \ the `alphabet` definition to include the vowel case).\n<|/ c |>\n<| c |>\nI\
    \ guess what I'm trying to understand is how could I use the inject method with\
    \ the code I posted. I've been trying to understand it all morning and can't figure\
    \ it out. Thank you for the help though!\n<|/ c |>\n<| a tags=ruby,arrays |>\n\
    Here's another approach which uses regular expressions.\n<code>", "    alphabet\
    \ = %w(a b c d e f g h i j k l m n o p q r s t u v w x y z)\n    message = message.downcase\n\
    \    message.split(//).map {|w| alphabet.index(w).to_s + alphabet.index(alphabet.index(w)+1).to_s\
    \ }.join \nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nCan you explain what `split(//)`\
    \ does? I haven't seen it before.\n<|/ c |>\n<| c |>\nIt splits a string on `/`.\
    \  See http://stackoverflow.com/questions/1030670/split-string-into-an-array-in-ruby\n\
    <|/ c |>\n<| a tags=string,ruby |>\nHere's a solution using each_char with Array#index.\
    \ It might not be the prettiest but it's easy to understand.\n<code>", "  letter_count\
    \ = {}\n  vowel_count = {}", "  alphabet = string.ascii_lowercase\n  swapped_alphabet\
    \ = alphabet\n  swapped_alphabet += alphabet\n  swapped_alphabet += alphabet\n\
    \  swapped_alphabet += alphabet\n  swapped_alphabet += alphabet\n  vowels = (\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n  message = message.downcase\n  message.gsub!(/./)\
    \ { |match| swapped_alphabet[$&] }\n  message.gsub!(/[aeiou]/) { |match| alphabet[$&]\
    \ }\n  message.split.map { |letter| letter.capitalize }.join\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| c |>\nThis solution does not work for strings consisting\
    \ of a single letter - for example `translate(\"a\")` returns `nil`.\n<|/ c |>\n\
    <| c |>\nFixed this problem, I wasn't aware that strings that contain a single\
    \ character would need to be handled differently. I modified the code slightly\
    \ to handle this case.\n<|/ c |>\n<| c |>\nI guess it is also worth mentioning\
    \ that using `+=` instead of `=` will speed up the code. Otherwise it runs in\
    \ quadratic time.\n<|/ c |>\n<| a tags=ruby |>\n<code>\nstring.downcase.gsub(/[aeiou]/)\
    \ {|c| case c\n  when \"a\"; \"1\"\n  when \"e\"; \"2\"\n  when \"i\"; \"3\"\n\
    \  when \"o\"; \"4\"\n  when \"u\"; \"5\"\n  else c\n  end\n}\n</code>\n<|/ a\
    \ dscore=4 |>\n<| a tags=ruby |>\nI like davidstein's solution, but if you find\
    \ that you are writing a lot of gsubs, consider using Ruby's built-in Regexp class\
    \ (as opposed to the String class), so that you can use the \\A anchor.\n<code>",
  "  string.gsub(message){|i| i[0].upcase + i[1..-1].downcase }.\n      gsub(/[AEIOUaeiou]/){|i|\
    \ i.succ}.\n      gsub(/[AEIOUaeiou]/){|i| i.succ}\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\n`string.gsub(/[AEIOUaeiou]/){|i| i.succ}` is cleaner than `i.succ+i.succ+i.succ`.\n\
    <|/ c |>\n<| a tags=ruby,string |>\nIf you're looking for some sort of string\
    \ encoding (like base64 does) try this:\n<code>", "  enc = Array.new\n  message.each_byte\
    \ do |byte|\n    enc.push (byte.chr.upcase if byte =~ /[aeiou]/)\n    enc.push\
    \ (byte.chr.downcase if byte =~ /[AEIOU]/)\n  end\n  enc.join('')\nend\n</code>\n\
    As a bonus, I've implemented it using Ruby Enumerators. I find that they are immensely\
    \ useful and make my code much easier to read. If you want to learn more about\
    \ them, I suggest you read this excellent article.\n<|/ a dscore=2 |>\n<| c |>\n\
    Wow. Thank you. This solution looks the cleanest to me. I will read up on the\
    \ enumerators because I'm new with ruby, and I appreciate you adding that in.\n\
    <|/ c |>\n<| c |>\nNo problem. I didn't know you were new with Ruby, so I wrote\
    \ this using an array, but I should probably have used a string, because the message\
    \ doesn't appear to be encoded in that manner. Anyway, good luck with your coding!\n\
    <|/ c |>\n<| a tags=ruby,python |>\nPython solution:\n<code>", "  # Replace each\
    \ vowel in the message with the letter that \n  # appears 2 places ahead of that\
    \ vowel in the english alphabet.\n  message.gsub!(/[aeiou]/, '&')\n  message.gsub!(/[aeiou]/)\
    \ { |s| s.succ }\n  \n  # Get the english alphabet\n  alphabet = ('A'..'Z').to_a\n\
    \  \n  # Replace the vowels in the message with the letter that appears \n  #\
    \ 2 places ahead of that vowel.\n  alphabet.map { |letter| message.gsub(/&/, letter)\
    \ }\nend\n</cell>\n<code language=julia-1.0>\nmessage = 'This is a message'\n\
    encode(message)\n</cell>\n<text>\nThe next part of the problem involves working\
    \ out which of the letters \nappear in the message twice and how many times. \n\
    This is where hashes come in handy. \nA hash is a data type that consists of a\
    \ key and a value, \nwith the key being unique. \nIn julia, hashes are created\
    \ using the type HashTable. \nHash tables are useful for storing key-value pairs,\
    \ \nwhere the key is an object and the value is the information \nabout the object.\
    \ \nHere is a brief example of using hash tables.", "  letter_swaps = {}\n  vowels\
    \ = ['a','e','i','o','u']\n  vowel_2_letter_swaps = {\n    'a' => 'A',\n    'e'\
    \ => 'E',\n    'i' => 'I',\n    'o' => 'O',\n    'u' => 'U',\n  }\n  string.downcase!\n\
    \  message.each_char do |c|\n    letter_swaps[c] = case c\n    when 'a'..'z'\n\
    \      letter_swaps[c].upcase!\n    when 'A'..'Z'\n      letter_swaps[c].upcase!\n\
    \    when '0'..'9'\n      letter_swaps[c].upcase!\n    when '@'..'@'\n      letter_swaps[c].upcase!\n\
    \    else\n      letter_swaps[c].upcase!\n    end\n  end\n  message.gsub! vowels,\
    \ '-'\n  message.gsub! vowel_2_letter_swaps, '-'\n  message.gsub!(/-{2,}/, vowels[0..1])\n\
    \  message.each_char do |c|\n    letter_swaps[c] = case c\n    when 'A'..'Z'\n\
    \      letter_swaps[c].upcase!\n    when '0'..'9'\n      letter_swaps[c].upcase!\n\
    \    when '@'..'@'\n      letter_swaps[c].upcase!\n    when '-', '-'\n      letter_swaps[c].upcase!\n\
    \    end\n  end\n  message.gsub! vowels, '@'\n  message.gsub! vowel_2_letter_swaps,\
    \ '@'\n  message.gsub!(/@{2,}/, vowels[0..1])\n  message.each_char do |c|\n  \
    \  letter_swaps[c] = case c\n    when 'A'..'Z'\n      letter_swaps[c].upcase!\n\
    \    when '0'..'9'\n      letter_swaps[c].upcase!\n    when '@'..'@'\n      letter_swaps[c].upcase!\n\
    \    when '-', '-'\n      letter_swaps[c].upcase!\n    end\n  end\n  message.gsub!\
    \ vowels, 'A'\n  message.gsub! vowel_2_letter_swaps, 'A'\n  message.gsub!(/A{2,}/,\
    \ vowels[0..1])\n  message.each_char do |c|\n    letter_swaps[c] = case c\n  \
    \  when 'A'..", "    letters = message.split\n    letters.each do |letter|\n \
    \       if letter.upcase == \"A\"\n            letter.upcase!\n        elsif letter.upcase\
    \ == \"E\"\n            letter.upcase!\n        elsif letter.upcase == \"I\"\n\
    \            letter.upcase!\n        elsif letter.upcase == \"O\"\n          \
    \  letter.upcase!\n        elsif letter.upcase == \"U\"\n            letter.upcase!\n\
    \        elsif letter.upcase == \"Y\"\n            letter.upcase!\n        elsif\
    \ letter.upcase == \"O\"\n            letter.upcase!\n        elsif letter.upcase\
    \ == \"E\"\n            letter.upcase!\n        elsif letter.upcase == \"A\"\n\
    \            letter.upcase!\n        elsif letter.upcase == \"E\"\n          \
    \  letter.upcase!\n        elsif letter.upcase == \"I\"\n            letter.upcase!\n\
    \        elsif letter.upcase == \"U\"\n            letter.upcase!\n        elsif\
    \ letter.upcase == \"Y\"\n            letter.upcase!\n        elsif letter.upcase\
    \ == \"O\"\n            letter.upcase!\n        elsif letter.upcase == \"E\"\n\
    \            letter.upcase!\n        elsif letter.upcase == \"A\"\n          \
    \  letter.upcase!\n        elsif letter.upcase == \"I\"\n            letter.upcase!\n\
    \        elsif letter.upcase == \"O\"\n            letter.upcase!\n        else\n\
    \            letter\n        end\n    end\nend\n</code>\n<|/ q tags=ruby,arrays,split\
    \ |>\n<| a |>\nIf I'm not mistaken, your problem stems from this:\n<code>\nletters\
    \ = message.split\n</code>\nThis statement is essentially saying \"make an array\
    \ containing each character in the message (split by spaces). \nIt can be confusing\
    \ that you're assigning the value of a method that you're calling on the message\
    \ itself. \nInstead, try:\n<code>\nletters = message.chars\n</code>\nwhich just\
    \ makes an array containing each character in the message.\n<|/ a dscore=1 tags=ruby,arrays,split\
    \ |>\n<| a |>\nAs far as I can tell, your code does a lot more work than it should.\n\
    First of all, you never use anything other than ", "  new_message = \"\"\n  vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  letter_pos = 1\n  \n  for char in message\n\
    \    if char == \"A\"\n      new_message << vowels[letter_pos - 1]\n      new_message\
    \ << vowels[letter_pos + 1]\n    else\n      new_message << char\n    end\n  end\n\
    \  new_message\nend\n</code>\nThe above code could be improved in other ways,\
    \ such as using a hash of vowels instead of an array, or using each_char to build\
    \ the new_message instead of manually iterating over the string.  I'll leave that\
    \ as an exercise for you :)\n<|/ a tags=ruby,string |>\n<| a dscore=0 |>\n<code>",
  "  result = ''\n  message.split('').each_with_index do |letter, index|\n    if index\
    \ == 0\n      result << letter\n    elsif ['E', 'I', 'O', 'U'].include?(letter)\n\
    \      result << letter.upcase\n    else\n      result << letter.downcase\n  \
    \  end\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`encode('This\
    \ is a message')` => `'tHKS KS C MGSSCGG'`\n<|/ c |>\n<| c |>\nThis solution works\
    \ for the input `This is a message`. But fails for `Encode is a message`.\n<|/\
    \ c |>\n<| c |>\nThe code does now check for duplicate letters. It will however\
    \ change the case of uppercase letters in the first and last letters.\n<|/ c |>\n\
    <| c |>\nI didn't notice that requirement but added a fix for it.\n<|/ c |>\n\
    <| c |>\nI added a similar solution but now it also changes the case of `e` from\
    \ `E` when not at the beginning and `e` from `E` when not at the end (`'e' becomes\
    \ 'E'`). Not sure if this is what the OP intended but I thought it would be worth\
    \ mentioning.\n<|/ c |>\n<| a |>\n<code>", "  \nend", "  letters = message.split('')\n\
    \  result = ''\n  pos = 0\n  current_letter = ''\n  vowels = 'AEIOU'\n  vowels_found\
    \ = []\n  \n  \n  # Get a vowel pair. \n  def get_vowel_pair\n    pair = ''\n\
    \    pos = 1\n    while pos < letters.length\n      pair = pair + letters[pos]\n\
    \      pos += 1\n    end\n    pair\n  end\n  \n  \n  # Get the next 2 vowel pairs\
    \ \n  def get_next_two\n    result = ''\n    pos = 0\n    while pos < letters.length\
    \ - 2\n      result += letters[pos] + letters[pos + 1]\n      pos += 2\n    end\n\
    \    result\n  end\n  \n  # Get a letter pair. \n  def get_letter_pair\n    pair\
    \ = ''\n    pos = 1\n    while pos < letters.length - 2\n      pair = pair + letters[pos]\n\
    \      pos += 1\n    end\n    pair\n  end\n  \n  \n  # Get a letter pair. \n \
    \ def get_letter_pair\n    pair = ''\n    pos = 1\n    while pos < letters.length\
    \ - 2\n      pair = pair + letters[pos]\n      pos += 1\n    end\n    pair\n \
    \ end\n  \n  \n  \n  # Get a letter pair. \n  def get_letter_pair\n    pair =\
    \ ''\n    pos = 1\n    while pos < letters.length - 2\n      pair = pair + letters[pos]\n\
    \      pos += 1\n    end\n    pair\n  end\n  \n  \n  # Get a letter pair. \n \
    \ def get_letter_pair\n    pair = ''\n    pos = 1\n    while pos < letters.length\
    \ - 2\n      pair = pair + letters[pos]\n      pos += 1\n    end\n    pair\n \
    \ end\n  \n  \n  \n  # Get a letter pair. \n  def get_letter_pair\n    pair =\
    \ ''\n    pos = 1\n    while pos < letters.length - 2\n      pair = pair + letters[pos]\n\
    \      pos += 1\n    end\n    pair\n  end\n  \n  \n  # Get a letter pair. \n \
    \ def get_letter_pair\n    pair = ''\n    pos = 1\n    while pos < letters.length\
    \ - 2\n      pair = pair + letters[pos]\n      pos += 1\n    end\n    pair\n \
    \ end\n  \n  \n  \n  # Get a letter pair. \n  def get_letter_pair\n    pair =\
    \ ''\n    pos = 1\n    while pos < letters.length - 2\n      pair = pair + letters[pos]\n\
    \      pos += 1\n    end\n    pair\n  end\n  \n  \n", "  swapped_message = message.chars.map\
    \ {|char| \n    case char\n    when 'a'..'z' then char.succ\n    when 'A'..'Z'\
    \ then char.succ\n    end\n  }.reduce(:+)\n  vowel_map = {\n    'a'..'z' => '\
    \ A ',\n    'A'..'Z' => ' A ',\n    'a'..'z' => ' a ',\n    'A'..'Z' => ' a ',\n\
    \    'A' => ' A ',\n    'a' => ' a ',\n  }\n  vowel_map.each {|vowel, letter|\
    \ \n    swapped_message = swapped_message.gsub(vowel, vowel_map[vowel])\n  }\n\
    \  swapped_message\nend", "  # Your code here.\n  \n  result = \"\"\n  \n  # Step\
    \ 1: Store all the letters used in a message\n  used = []\n  \n  # Step 2: Find\
    \ all the vowels in the message\n  vowels = message.scan(/[aeiou]/i)\n  \n  #\
    \ Step 3: For each vowel, find the letter that comes 2 places ahead of it \n \
    \ # (ie. e.g. If we have e, we know it comes 2 places after a)\n  vowels.each\
    \ { |vowel| used << vowel.succ if vowel.succ !~ /[aeiou]/i }\n  \n  # Step 4:\
    \ For each letter that appears 2 places ahead of it (ie. e), \n  # substitute\
    \ that letter with its corresponding vowel from the list\n  used.each { |vowel|\
    \ message =~ /#{vowel}/i ? message =~ /#{vowel}/ ? message =~ /#{vowel}/ ? message\
    \ =~ /#{vowel}/i : message = message.replace vowel, \"#{vowel}\"}\n  \n  message\n\
    end\n</code>\n<|/ a |>\n<| a dscore=1 |>\nIf your goal is to not use regular expressions,\
    \ you can convert the string into an array and find the vowel positions. Once\
    \ you have that, you can iterate through each position and swap letters using\
    \ modulo arithmetic.\n<code>", "  return message.gsub(/[AEIOUYaeiouy]/) {|w| w.upcase\
    \ + w.chr.upcase }\nend", "  encodedMessage = \"\"\n  message.each_char do |letter|\n\
    \    case letter\n    when 'a'..'z'\n      encodedMessage << letter.downcase\n\
    \    when 'A'..'Z'\n      encodedMessage << letter.upcase\n    when 'a'\n    \
    \  encodedMessage << \"a\"\n    when 'e'\n      encodedMessage << \"e\"\n    when\
    \ 'i'\n      encodedMessage << \"i\"\n    when 'o'\n      encodedMessage << \"\
    o\"\n    when 'u'\n      encodedMessage << \"u\"\n    when 'A'..'I'\n      encodedMessage\
    \ << letter.upcase \n    when 'E'\n      encodedMessage << letter.upcase\n   \
    \ when 'I'\n      encodedMessage << letter.upcase\n    when 'O'\n      encodedMessage\
    \ << letter.upcase\n    when 'U'\n      encodedMessage << letter.upcase\n    when\
    \ 'P'\n      encodedMessage << letter.upcase\n    when 'Y'\n      encodedMessage\
    \ << letter.upcase\n    else\n      encodedMessage << letter\n    end\n  end\n\
    \  return encodedMessage\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nIt doesn't\
    \ handle uppercase letters.\n<|/ c |>\n<| c |>\nUpdated with another version\n\
    <|/ c |>\n<| c |>\nYour second version now handles uppercase letters.\n<|/ c |>\n\
    <| c |>\n, your first version was wrong and didn't handle uppercase letters. You\
    \ fixed it, but it still doesn't handle uppercase letters.\n<|/ c |>\n<| c |>\n\
    What do you mean \"it still doesn't handle uppercase letters\"? It handles uppercase\
    \ letters as requested. Did you try it?\n<|/ c |>\n<| a tags=string,ruby dscore=0\
    \ |>\nThe main problem with your code is that you try to handle each character\
    \ individually. Instead, try something like this:\n<code>", "  message = message.downcase\n\
    \  vowels = ['a', 'e', 'i', 'o', 'u']\n  count = 0\n  new_message = message\n\
    \  while count < message.length\n    count = count + 1\n    vowel_position = nil\n\
    \    \n    vowel_position = (message.length - count).downto(0).find do |char|\n\
    \      vowels.include?(char)\n    end\n    if vowel_position.nil?\n      new_message\
    \ = new_message.gsub(vowels, vowels[vowels.index(vowel_position)+1] + vowels[vowels.index(vowel_position)+2])\n\
    \    else\n      new_message = new_message.gsub(vowels[vowels.index(vowel_position)],\
    \ vowels[vowels.index(vowel_position)+1])\n    end\n  end\n  new_message\nend\n\
    </cell>\n<cell>", "  # Your code here\nend", "  letters = message.downcase.split\
    \ # turns message into an array of \n  # letters, splitting by whitespace\n  swapped_letters\
    \ = []\n  vowels = ('a', 'e', 'i', 'o', 'u') # set vowel positions in the alphabet\n\
    \  for i in letters \n    if vowels.include? i # if current letter is vowel\n\
    \      swapped_letters << i.upcase # swap case and append letter to array\n  \
    \  else # if current letter is not vowel\n      swapped_letters << i # append\
    \ letter to array\n  swapped_letters.join # joins the array of letters into a\
    \ string\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\"Assume only letters.\"\
    \ The `include?` method is a [method on String](http://www.ruby-doc.org/core-2.1.3/String.html#method-i-include-3F),\
    \ and so `swapped_letters << i` is actually `swapped_letters << i.to_s`. You're\
    \ also missing a colon on that line (`swapped_letters << i:`).\n<|/ c |>\n<| c\
    \ |>\nThank you for the comment. I am aware of include? method on string. I am\
    \ just trying to give the OP an idea to solve the problem. Not a copy paste. I\
    \ am sure he will understand the logic and code once he is able to answer his\
    \ own question with explanation.\n<|/ c |>\n<| c |>\nThe `include?` method doesn't\
    \ return a boolean (it doesn't return a boolean, it returns an `Integer`), and\
    \ so that's not how `swapped_letters << i` is supposed to be written.\n<|/ c |>\n\
    <| c |>\nThank you for clarification. I understand it now.\n<|/ c |>\n<| a dscore=2\
    \ |>\nOne way to accomplish this would be to use String#gsub with a block:\n<code>",
  "  \n  # Initialize an empty string that will be used to store the encoded message\n\
    \  encoded_message = ''\n  \n  # Create a variable for the number of vowels in\
    \ the message\n  num_vowels = 0\n  \n  # Loop through the message and count each\
    \ vowel\n  message.each_char do |letter|\n    case letter\n      when 'A'..'Z'\n\
    \        num_vowels += 1\n      when 'a'..'z'\n        num_vowels += 1\n     \
    \ when '0'..'9'\n        num_vowels += 1\n    end\n  end\n  \n  # Create a variable\
    \ for the number of vowels that are in the english alphabet\n  english_letter_count\
    \ = 0\n  \n  # Create a variable for the letter that is 2 places ahead of the\
    \ vowel\n  english_letter_ahead = nil\n  \n  # Loop through the letters in the\
    \ english alphabet and count each vowel\n  ('A'..'Z').each do |letter|\n    case\
    \ letter\n      when 'A'..'Z'\n        english_letter_count += 1\n      when 'a'..'z'\n\
    \        english_letter_count += 1\n      when '0'..'9'\n        english_letter_count\
    \ += 1\n    end\n  end\n  \n  # If the number of vowels in the message is even\n\
    \  if num_vowels % 2 == 0\n    \n    # Set the english_letter_ahead variable to\
    \ the first letter of the alphabet\n    english_letter_ahead = ('A'..'Z')[num_vowels\
    \ / 2]\n  \n    # Loop through the message and replace each vowel with its english\
    \ letter \n    message.gsub(/[AEIOUaeiou]/ do |vowel|\n      \n      # If the\
    \ vowel is a vowel in the english alphabet\n      if ('A'..'Z').include?(vowel)\n\
    \        \n        # Set the english letter to the letter that appears 2 places\
    \ ahead \n        # of the vowel\n        english_letter_ahead = ('A'..'Z')[vowel.succ\
    \ % 26]\n      \n        # Return just the vowel \n        return(vowel)\n   \
    \   \n      # If the vowel is not a vowel in the english alphabet\n      else\n\
    \        # Return the english letter \n        return(english_letter_ahead)\n\
    \      end\n    end) \n  \n  # If the number of vowels in the message is odd\n\
    \  else\n    \n    # Set the english_letter_ahead variable to the letter that\
    \ appears 2 \n    # places ahead of the last vowel\n    english_letter_ahead =\
    \ ('A'..'Z')[num_vowels / 2].succ % 26\n  \n    # Loop through the message and\
    \ replace each vowel with its english letter \n    message.gsub(/[AEIOUaeiou]",
  "  new_message = ''\n  letter_index = 0\n  vowel_index = 0 ", "  message.upcase!\n\
    \  message.gsub(/[AEIOUaeiou]/) do |letter|\n    alphabet[alphabet.index(letter)\
    \ + 1]\n  end\n  message.downcase!\nend\n</code>\n<|/ a tags=ruby,string |>\n\
    <| c |>\nThis solution is not scalable.  You need to keep track of all 26 letters.\
    \  Also, your `alphabet` array is misnamed and should be named `alphabet` (lower\
    \ case).  Finally, your `alphabet` array is missing the `E` letter.\n<|/ c |>\n\
    <| c |>\nI agree about `alphabet` misnamed. However, the `alphabet` array will\
    \ have a count of 26 letters, so you can tell which letter is in which position.\
    \ Also, `alphabet` does not have `E` letter. I know this is not scalable, but\
    \ it is a good solution, right?\n<|/ c |>\n<| c |>\nThe OP states in the question:\
    \ \"only letters\".  How can you tell if the letter \"E\" is the capital E?  Also,\
    \ how are you going to tell if the character is `a` or `A`?\n<|/ c |>\n<| c |>\n\
    `'E'.upcase #=> 'E'` and `'e'.upcase #=> 'E'` :D\n<|/ c |>\n<| a |>\nA simple\
    \ method using gsub:\n<code>", "    letters = {}\n    letters[0] = message[0].downcase\n\
    \    letters[1] = message[1].upcase\n    letters[2] = message[2].upcase\n    letters[3]\
    \ = message[3].upcase\n    letters[4] = message[4].upcase\n    letters[5] = message[5].upcase\n\
    \    letters[6] = message[6].upcase\n    letters[7] = message[7].upcase\n    letters[8]\
    \ = message[8].upcase\n    letters[9] = message[9].upcase\n    letters[10] = message[10].upcase\n\
    \    letters[11] = message[11].upcase\n    letters[12] = message[12].upcase\n\
    \    letters[13] = message[13].upcase\n    letters[14] = message[14].upcase\n\
    \    letters[15] = message[15].upcase\n    letters[16] = message[16].upcase\n\
    \    letters[17] = message[17].upcase\n    letters[18] = message[18].upcase\n\
    \    letters[19] = message[19].upcase\n    letters[20] = message[20].upcase\n\
    \    letters[21] = message[21].upcase\n    letters[22] = message[22].upcase\n\
    \    letters[23] = message[23].upcase\n    letters[24] = message[24].upcase\n\
    \    letters[25] = message[25].upcase\n    letters[26] = message[26].upcase\n\
    \    letters[27] = message[27].upcase\n    letters[28] = message[28].upcase\n\
    \    letters[29] = message[29].upcase\n    letters[30] = message[30].upcase\n\
    \    letters[31] = message[31].upcase\n    letters[32] = message[32].upcase\n\
    \    letters[33] = message[33].upcase\n    letters[34] = message[34].upcase\n\
    \    letters[35] = message[35].upcase\n    letters[36] = message[36].upcase\n\
    \    letters[37] = message[37].upcase\n    letters[38] = message[38].upcase\n\
    \    letters[39] = message[39].upcase\n    letters[40] = message[40].upcase\n\
    \    letters[41] = message[41].upcase\n    letters[42] = message[42].upcase\n\
    \    letters[43] = message[43].upcase\n    letters[44] = message", "    message.downcase!\n\
    \    vowels = 'aeiou'\n    two_letter_vowels = 'aeiouy'\n    message_letters =\
    \ message.split('')\n    encoded_message = ''\n    vowel_positions = {}\n    vowel_positions[vowels.first]\
    \ = nil\n    vowel_positions[vowels.second] = nil\n    message.split('').each\
    \ do |letter|\n        if letter == vowels.first\n            letter_position\
    \ = vowel_positions[letter]\n            if letter_position == nil\n         \
    \       letter_position = vowel_positions[letter] = 2\n            else\n    \
    \            letter_position += 1\n            end\n            encoded_message\
    \ += letter_position * letter\n        end\n        letter == vowels.second ?\
    \ \n            encoded_message += two_letter_vowels.first : \n            encoded_message\
    \ += letter\n    end\n    encoded_message\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\n`'This is a message'.gsub(/([aeiou])(?=(..)*\\1)/){|m| m.upcase\
    \ }`\n<|/ c |>\n<| c |>\nI ran your code on `This is a message` but it returned\
    \ `tHKS KS C MGSSCGG` instead of `tHKS KS C MGSSCGG`\n<|/ c |>\n<| c |>\nI updated\
    \ my answer, and I'm pretty sure it works on your second example. If it doesn't\
    \ on yours, then you may have a bug in your ruby installation. I'd try re-installing\
    \ ruby, and if that doesn't work, try running this in IRB and see what happens.\n\
    <|/ c |>\n<| c |>\nI ran your code with Ruby 1.9.3 `This is a message` and it\
    \ still returned `tHKS KS C MGSSCGG` instead of `tHKS KS C MGSSCGG`\n<|/ c |>\n\
    <| c |>\nOh I see what you mean. My apologies, I forgot that Ruby 1.9 added the\
    \ support for lookahead matches. My updated answer should fix it for you.\n<|/\
    \ c |>\n<| a tags=ruby,string |>\nThis might not be the best solution, but it\
    \ is working:\n<code>", "    swappedLetters = message.split('')\n    swappedLetters.map\
    \ { |letter| letter.swapcase! }\n    swappedLetters.map { |letter| letter.gsub(/[AEIOUaeiou]/,\
    \ \n           -> (letter[/[aeiou]/]) {\n              letter[/[aeiou]/].size\
    \ + letter[/[aeiou]/].size + \n              letter[/[aeiou]/].size }.uniq.to_s)\
    \ }\nend\n</code>\nAs you can see, the main part is just iterating the string,\
    \ and using a regular expression to find all the vowels, their positions, and\
    \ their position + 1 letter's position in order, and replacing all occurrences\
    \ of those vowels with their position + 1 letter's position + 1 letter. \nIn the\
    \ first block, we don't even need to use the letters method, nor do we need to\
    \ use the map method to do the same thing. Simply split the string on empty strings,\
    \ and iterate through them with the enumerator to iterate over each character\
    \ in each string. \nIn the second block, we can use regular expression methods\
    \ such as gsub to do the same thing. \nThe third block is using the method String#split,\
    \ which is an alias for String#scan, which is an alias for String#scan/1, which\
    \ returns a regular expression match result, and the array method, which converts\
    \ the result of scan into an array for us to use. \nWe use the splat operator\
    \ (*) to split the string into an array and map it over each character in the\
    \ string. \nWe use the map method to iterate over each character in the string,\
    \ returning a new string with the mapping applied. We use the gsub, map, uniq\
    \ methods and lambda.\n<|/ a tags=ruby,ruby-on-rails dscore=0 |>\n<| c |>\nWow,\
    \ very nice! I was stuck with this problem and your solution worked perfectly.\
    \ Thank you!\n<|/ c |>\n<| c |>\nYou're very welcome :) If this answered your\
    \ question, please accept it as the correct answer.\n<|/ c |>\n<| c |>\nI used\
    \ the top one, but thanks for the other ones as well\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ dscore=0 |>\n<code>", "    # Get the english alphabet \n    alphabet = EnglishAlphabet()\n\
    \    # Get the vowels \n    vowels = ['a', 'e', 'i', 'o', 'u']\n    # Loop through\
    \ all letters in the message and replace vowels with their 2 letter code\n   \
    \ for letter in message:\n        if letter in vowels:\n            new_code =\
    \ alphabet[alphabet.index(letter) + 2]\n            alphabet[alphabet.index(letter)]\
    \ = new_code\n    return ''.join(alphabet)", "  # TODO: Your code goes here\n\
    end\n</cell>\n<text>\nLet's test our function:", "  alphabet = [\"a\", \"b\",\
    \ \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\"]\n  new_message = message\n  new_message_hash = {}\n  \n  message.each_char\
    \ do |char|\n    index = alphabet.index(char)\n    new_message_hash[char] = alphabet[index\
    \ + 1]\n  end\n  \n  new_message.gsub!(/([aeiou])/) do |match|\n    letter_index\
    \ = alphabet.index(match[0])\n    letter_index = letter_index + 2 if letter_index\
    \ > 25\n    alphabet[letter_index]\n  end", "  # Return the encoded string\nend\n\
    </cell>\n<code language=julia-1.6>\nencode(message)\n</cell>\n<text>\n5.3 Exercise:\
    \ Write a function that takes a message, and encodes in such a way that it swaps\
    \ case of all letters, replaces all vowels in the message with the letter that\
    \ appears 2 places ahead of that vowel in the english alphabet. Assume only letters.\
    \ For example, encode('This is a message') should return 'HSTC GS SSCG' Note that\
    \ capital letters are not changed.", "  message.gsub(/[aeiou]/) do |letter|\n\
    \    alphabet  = 'abcdefghijklmnopqrstuvwxyz'.split('').sort_by { |x| x.length\
    \ }\n    alphabet[alphabet.index(letter.next)-1] + letter.next\n  end\nend", " \
    \   message = message.downcase\n    message.split(' ').each do |word|\n      \
    \  word = word.gsub(/[aeiou]/){ |vowel| \n          letter = alphabet.index(vowel)\
    \ + 1\n          alphabet[letter]\n        }\n        message << word.capitalize\
    \ << ' '\n    end\n    message.slice!(-1) # delete the last space\n    return\
    \ message\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,string |>\nYou can\
    \ use the following code to achieve your goal.\n<code>\nrequire 'English'\nalphabet\
    \ = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"\
    m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"\
    z\"]\nword = \"This is a message\"\nword.split(\" \").map{|word| word.split(\"\
    \").map {|char| char.upcase + alphabet.index(char).to_s}}.join(' ')\n</code>\n\
    The map block will split each word to chars, for each char, it will get the index\
    \ of its corresponding char in alphabet array. Then it will add alphabet index\
    \ to each character. Finally it will join the chars back to a string. \n<code>\n\
    >> \"This is a message\".split(\" \").map{|word| word.split(\"\").map {|char|\
    \ char.upcase + alphabet.index(char).to_s}}.join(' ')\n=> \"tHKS KS C MGSSCGG\"\
    \n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nAnother way is to use the tr()\
    \ method and pass the string in as argument, like this:\n<code>\n\"This is a message\"\
    .tr(\" \", \"\xA7\")\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThat requires\
    \ Ruby version 2.2+.\n<|/ c |>\n<| c |>\nThat's true, but it also works on Ruby\
    \ 2.0 and 2.1.\n<|/ c |>\n<| c |>\nThat's true, but it's not a Ruby method.\n\
    <|/ c |>\n<| c |>\nIt also works in 2.1.  I used it here because I didn't have\
    \ 2.1 installed and had to go out and get Ruby 2.0.\n<|/ c |>\n<| c |>\nThat's\
    \ true indeed. And your solution is very similar to the one I posted earlier.\n\
    <|/ c |>\n<| a dscore=1 tags=ruby,string |>\nThis can be done quite easily by ",
  "  result = \"\"\n  message.each_char do |character|\n    if ('A'..'Z').include?(character)\n\
    \      result << character.upcase\n    else\n      result << character.downcase\n\
    \    end\n  end\n  result\nend\n</code>\nA bit of googling led me to this question\
    \ about how to replace a character in a string.\n<|/ a dscore=2 |>\n<| a tags=ruby\
    \ |>\n<code>", "    encoded_message = \"\"\n    vowels = 'AEIOUaeiou'\n    vowel_counter\
    \ = 0\n    letter_index = 0\n    vowel_position = 0\n    for letter in message\n\
    \        letter = letter.upcase\n        if vowels.include? letter\n         \
    \   vowel_counter += 1\n            letter_index += 2\n        end\n        if\
    \ letter_index <= vowel_counter\n            encoded_message << letter\n     \
    \   else\n            encoded_message << letter.slice(vowel_position + 1, letter_index)\n\
    \        end\n        vowel_position = letter_index\n    end\n    return encoded_message\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThanks, your explanation is very helpful too.\
    \ I'm a bit confused as to how you came up with that solution, but I'm glad you\
    \ posted this anyways. I do have a question about your solution. Why do you add\
    \ +2 to the vowel counter, and what does the +2 accomplish? Thanks!\n<|/ c |>\n\
    <| c |>\nI came up with the solution following a similar logic to yours, except\
    \ I started with 'AEIOUaeiou' instead of the 'AEIOU'. This way you only need to\
    \ know one character to figure out what letter to append instead of how many times\
    \ the character appears.\n<|/ c |>\n<| a tags=string,ruby |>\n<code>", "\tmessage.chars.each\
    \ do |i|\n\t\tcase i\n\t\twhen 'A'..'Z'\n\t\t\ti += 'a'\n\t\twhen 'a'..'z'\n\t\
    \t\ti += 'A'\n\t\twhen '1'..'9'\n\t\t\ti += '0'\n\t\tend\n\tend\n\tmessage.chars.reverse.each_with_index\
    \ do |i,j|\n\t\tif j.even?\n\t\t\tmessage[j] = message[j + 1]\n\t\tend\n\tend\n\
    \tmessage.downcase!\n\treturn message\nend\n</cell>\n<text>\nProblem 4\nUsing\
    \ what we've done so far, try to implement a function that takes two strings,\
    \ \nwhich have only two consonants in common, and a third string, \nwhich has\
    \ 2 consonants in common. Using those two strings, \nwhat is the maximum number\
    \ you can make with 3 consonants \nand 5 vowels?", "    vowels = 'AEIOU'\n   \
    \ encoded = ''\n    vowelIndex = 1 \n    letterIndex = 1\n    # Write your implementation\
    \ here.\n    for letter in message\n        encoded += letter\n    \n    # Write\
    \ your implementation here.\n    while vowelIndex < len(vowels)\n        letterIndex\
    \ = letterIndex + vowels[vowelIndex].count('A') + vowels[vowelIndex].count('E')\
    \ + vowels[vowelIndex].count('I') + vowels[vowelIndex].count('O') + vowels[vowelIndex].count('U')\n\
    \        if letterIndex < len(message) and letterIndex + 2 < len(message)\n  \
    \          letter = message[letterIndex + 2]\n            encoded += vowels[vowelIndex]\
    \ + vowels[vowelIndex].count(letter) + letter\n            vowelIndex = vowelIndex\
    \ + 1\n            \n    return encoded\n        ", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  new_message = message\n  new_message.gsub! /[aeiou]/ do |letter|\n    letter_index\
    \ = alphabet.index(letter)\n    index = letter_index + 2\n    alphabet[index]\n\
    \  end\n  return new_message\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI understand\
    \ this code, but as you noticed, I still have to solve the problem by myself.\n\
    <|/ c |>\n<| c |>\nPlease add some explanation to your answer such that others\
    \ can learn from it\n<|/ c |>\n<| c |>\nThis code works fine but is too long.\
    \ Is there a shorter way?\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    # Write your\
    \ encoding code here\n    message = message.replace('aeiouAEIOU', 'AEIOU')\n \
    \   message = message.replace('AEIOU', 'aeiouAEIOU')\n    message = message.replace('AEIOUaeiouAEIOU',\
    \ 'aeiouAEIOU')\n    message = message.replace('aeiouAEIOUAEIOU', 'AEIOUaeiouAEIOU')\n\
    \    message = message.replace('a','AEIOU')\n    message = message.replace('e','AEIOU')\n\
    \    message = message.replace('i','AEIOU')\n    message = message.replace('o','AEIOU')\n\
    \    message = message.replace('u','AEIOU')\n    message = message.replace('A','AEIOU')\n\
    \    message = message.replace('E','AEIOU')\n    message = message.replace('I','AEIOU')\n\
    \    message = message.replace('O','AEIOU')\n    message = message.replace('U','AEIOU')\n\
    \    return message\n</code>\n<|/ a |>\n<| c |>\nYes, but your code has some issues,\
    \ too. Check out my answer. Just copy paste and try it.\n<|/ c |>\n<| c |>\nThank\
    \ you very much for pointing out my code was wrong! I did a little editing and\
    \ fixed the typos and it works great!\n<|/ c |>\n<| a |>\nThe easiest way would\
    \ be to iterate over the alphabet and convert each letter to its position in the\
    \ alphabet, then add them to an array. Iterate again to see if the positions in\
    \ the array are equal to the position of the letter in the message.\n<code>\n\
    function translate(str) {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n\
    \  const translation = [];", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\
    \    message = message.dup.tr(\"AEIOUaeiou\", alphabet)\n    vowels = \"AEIOUaeiou\"\
    \n    message.gsub(/./){|e| \n       e.split('').reject(&vowels.include?).map\
    \ {|l| alphabet[alphabet.index(l) + 1]}\n    }.join\nend\n</code>\n<|/ a tags=ruby,python,ruby-on-rails\
    \ dscore=0 |>\n<| c |>\nI haven't tested this, but why would you assume that only\
    \ letters would be used? What if the original message contained non-letters?\n\
    <|/ c |>\n<| c |>\nI assume that \"only letters\" meant that only letters were\
    \ being used. For example, `\"ABC\"` would become `\"ABCD\"`, but `\"A B C\"`\
    \ would stay the same.\n<|/ c |>\n<| c |>\nAgreed, but that also means your method\
    \ wouldn't work. For example: `encode('A B C')` would return `\"CD\"`, but a Ruby\
    \ method would return `\"ABCD\"`\n<|/ c |>\n<| c |>\nI fixed my answer. Thanks\
    \ for the pointing that out.\n<|/ c |>\n<| c |>\nI'm sorry if I'm misunderstanding\
    \ your comment, but this answers OP's question\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "    vowels = %w(a e i o u)\n    alphabet = %w(a b c d e f g h i j k l m n o p q\
    \ r s t u v w x y z)\n    letter_map = Hash.new\n    message.each_byte do |c|\n\
    \        if alphabet.include?(c)\n            letter_map[c] ||= (alphabet.size-1)\
    \ + vowels.index(c) \n        end\n    end\n    new_message = ''\n    message.each_byte\
    \ do |c|\n        if alphabet.include?(c)\n            index = letter_map[c]\n\
    \            new_message << alphabet[(index-2)%alphabet.size]\n        else\n\
    \            new_message << c\n        end\n    end\n    return new_message\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks alot ! This is exactly what I\
    \ was looking for. I appreciate it.\n<|/ c |>\n<| a dscore=3 |>\nA slight variation\
    \ on's solution using map: \n<code>", "    # Replace all vowels with the letter\
    \ that appears 2 places \n    # ahead of that vowel\n    message.gsub!(/[AEIOUaeiou]/i)\
    \ { |x| \n        x.succ.succ.succ.succ.succ\n    }\n    \n    # Replace all letters\
    \ with the letter that appears 2 places ahead \n    # of that letter in the english\
    \ alphabet\n    message.gsub!(/[a-z]/i) { |x| \n        x.succ.succ.succ.succ.succ\n\
    \    }\nend\n</cell>\n<code language=julia-1.0>\nencode('test')\n</cell>\n<code\
    \ language=julia-1.0>\nencode('This is a message')\n</cell>\n<text>\nExercise\n\
    Write a function that takes an encoded message, and returns the decoded message.",
  "  words = message.split(' ') # Break the string into words \n  words.each { |word|\
    \ \n    word = word.upcase \n    word.downcase.split(\" \").each { |letter| \n\
    \      letter = letter.upcase \n      word.split(letter).each_with_index { |l,\
    \ i| \n        word.insert(i, l.upcase) \n      } \n    } \n  } \n  words.join('\
    \ ')\nend", "  message.downcase!\n  message.each_char {|char|\n    next if char.upcase\
    \ == char\n    char.upcase!\n    char.succ.succ! if char == 'A'\n  }\n  message\n\
    end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nWhile this code snippet may\
    \ solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| c |>\nThis code works but it doesn't return anything.\
    \ I am trying to output the message \"TGST\", so when I enter 'test' it returns\
    \ \"TGST\".\n<|/ c |>\n<| c |>\n, just put a `puts` or `return` statement at the\
    \ end and it'll return the message. As is, the method just does its job. It doesn't\
    \ return anything.\n<|/ c |>\n<| a tags=ruby |>\nYou can use each_cons to get\
    \ your characters as they are iterated over, rather than the whole string. \n\
    <code>", "  alphabet = %w(a b c d e f g h i j k l m n o p q r s t u v w x y z).sort\n\
    \  alphabet.each do |letter|\n    message = message.gsub(letter, letter.upcase).gsub(/[aeiouy]+/i)\
    \ { $&.next}\n  end\n  message\nend\n</code>\n<|/ a |>\n<| c |>\nCan you explain\
    \ this a little more? I thought I had it when I was writing a program to generate\
    \ passwords, but now it's just outputting a random number.\n<|/ c |>\n<| c |>\n\
    The random number was a typo. Fixed it.\n<|/ c |>\n<| c |>\nAh, okay. I didn't\
    \ realize that. Thank you!\n<|/ c |>\n<| c |>\nThis solution doesn't work unless\
    \ you convert string to upper or lower case as in `message = message.gsub(letter,\
    \ letter.upcase or letter.downcase).gsub(/[aeiouy]+/i) { $&.next}`\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails |>\nHere is a solution without regexp (since I cannot\
    \ imagine how can it be done with one :-).\n<code>", "  vowels = %w[A B C D E\
    \ F G H I J K L M N O P Q R S T U V W X Y Z]\n  message.gsub!(/[AEIOUY]/,'') {|vowel|\
    \ vowels.index(vowel) + 2}\n  message.gsub!(/[AEIOUY]/) {|vowel| vowels.index(vowel)\
    \ + 1}\n  message.downcase!\n  message\nend\n</code>\n<|/ a tags=ruby,regex |>\n\
    <| c |>\nVery interesting! This works fine. But how is it doing? Why did you use\
    \ ``{|vowel| vowels.index(vowel) + 2}``? And how did you get the ``[AEIOUY]``?\
    \ Is it the regular expression?\n<|/ c |>\n<| c |>\nYeah, that's just matching\
    \ the vowels, and capturing the index (plus 2) of the vowel that was matched.\
    \ I actually had an example of it [here](http://stackoverflow.com/a/41909477/479863)\
    \ but deleted it because I wasn't thinking very clearly about what it was doing.\n\
    <|/ c |>\n<| c |>\nOkay, I see now. Thank you very much!\n<|/ c |>\n<| a dscore=2\
    \ |>\nThe most general method might be to simply count the occurrences of each\
    \ letter you see and put it in a hash. Then, for each letter that appears twice,\
    \ use the hash to determine how many times you want to change the letter, and\
    \ replace it with that letter.\n<code>\nstr = \"This is a string\"", "  new_message\
    \ = ''\n  for i in message.split\n  new_message = new_message + i.gsub(/([a-z])/)\
    \ { |m| m.upcase }\n  new_message = new_message + i.gsub(/[aeiou]/) { |m| m.upcase\
    \ }\n  new_message = new_message + i.gsub(/[AEIOU]/) { |m| m.upcase }\n  new_message\
    \ = new_message + i.gsub(/[!,.,?]/) { |m| m.upcase }\n  new_message\nend", " \
    \ alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  message\n    .split(\"\")\n    .map\n\
    \    .with_index\n    .each_with_index\n    .map{|a,i| if i.even? then a.upcase\
    \ else a.downcase }\n    .join\n    .each_char\n    .map{|a| alphabet[alphabet.index(a)]}\n\
    \    .join\n    .gsub(/[aeiou]/){|c| alphabet[alphabet.index(c) + 2]}\nend\n</code>\n\
    <|/ a tags=ruby,function,arrays |>\n<| c |>\nWhile this solution is definitely\
    \ correct, it is more like pseudo code and won't run in Ruby 1.8.7. It might be\
    \ better as `gsub(/[aeiou]/){|c| alphabet[alphabet.index(c) + 2]}` as it doesn't\
    \ require the block `|c|` to exist. This is a much better answer than the other\
    \ ones (which basically do the same thing)\n<|/ c |>\n<| a dscore=3 tags=ruby,function,arrays\
    \ |>\n<code>", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  message = message.downcase\n\
    \  encrypted_message = \"\"\n  message.length.times do |n|\n    encrypted_message\
    \ += alphabet[((message.chars[n.to_s] + alphabet.chars[alphabet.index(message.chars[n.to_s])])\
    \ % alphabet.length)]\n  end\n  return encrypted_message\nend\n</code>\nI hope\
    \ this helps!\n<|/ a tags=string,ruby,encryption |>\n<| c |>\nA few issues with\
    \ this: (1) It doesn't give the right result for words like \"and\", \"or\", \"\
    but\", and \"yet\". (2) It doesn't give the correct result for words like \"a\"\
    , \"an\", and \"the\" when there are multiple letters in the word. (3) It doesn't\
    \ work for \"i\", \"ii\", and \"iii\". (4) It doesn't give the correct result\
    \ for words like \"it\", \"it's\", and \"its\" when there are multiple letters\
    \ in the word.\n<|/ c |>\n<| c |>\nIt doesn't work for words like \"a\", \"an\"\
    , and \"the\" when there are multiple letters in the word. It doesn't work for\
    \ words like \"a\", \"an\", and \"the\" when there are multiple letters in the\
    \ word. It doesn't work for words like \"a\", \"an\", and \"the\" when there are\
    \ multiple letters in the word. It doesn't work for words like \"a\", \"an\",\
    \ and \"the\" when there are multiple letters in the word. It doesn't work for\
    \ words like \"a\", \"an\", and \"the\" when there are multiple letters in the\
    \ word. It doesn't work for words like \"a\", \"an\", and \"the\" when there are\
    \ multiple letters in the word.\n<|/ c |>\n<| a tags=string,ruby,encryption |>\n\
    My solution\n<code>", "  swap = Hash.new\n  message.split(//).each do |x|\n  \
    \  x = x.gsub(/[a-zA-Z]/) {|y| swap[y.upcase][y.downcase] }\n    x = x.gsub(/[aeiouy]/)\
    \ {|y| swap[y.upcase][y.downcase] }\n  end\n  swap.values\nend", "  alphabet =\
    \ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  vowels = \"AEIOUY\"\n  new_message = \"\"\n\
    \  message.each_char do |char|\n    # If the char is A, E, I, O, U, Y, or a vowel\n\
    \    if alphabet.include?(char)\n      # If the letter 2 places ahead of the vowel\
    \ is a vowel\n      if alphabet[(vowels.index(char) + 1)] == char\n        new_message\
    \ += char\n      else\n        new_message += alphabet[(vowels.index(char) + 1)]\n\
    \      end\n    end\n  end\n  new_message\nend", "    cipher = \"\"\n    vowels\
    \ = (\"a\", \"e\", \"i\", \"o\", \"u\")\n    for letter in message\n        cipher\
    \ << case \n        cipher << vowels.shift\n    end\n    return cipher\nend",
  " \n  # TODO: write your encode function here\n  return nil \nend\n</cell>\n<text>\n\
    Exercise 2\nWrite a function that decodes a message. \nFor example, given a message\
    \ 'tHKS KS C MGSSCGG', it should return \na message 'This is a message'.", " \
    \ new_message = \"\"\n  for i in message\n    new_message += i.upcase + i.downcase\
    \ \n  new_message += new_message[1..-1]\nend\n</cell>\n<cell>", "  vowels = 'AEIOUaeiou'\n\
    \  consonants = 'bcdfghjklmnpqrstvwxz'\n  encoded = \"\"\n  letters = message.split(\"\
    \")\n  letters.each_index do |i|\n    if vowels.include?(letters[i])\n      letters[i]\
    \ = letters[i].next\n    end\n    if consonants.include?(letters[i])\n      letters[i]\
    \ = letters[i].next.next\n    end\n  end\n  letters.each_index do |i|\n    encoded\
    \ << letters[i]\n  end\n  return encoded\nend", "  result = \"\"\n  message.split(\"\
    \ \").each do |word|\n    if word.match(/[a-z]/)\n      word.scan(/[a-z]/).each\
    \ do |letter|\n        result = result + letter\n      end\n    end\n    word.scan(/[aeiouy]/).each\
    \ do |vowel|\n      result = result + (letter.next) \n    end\n    \n  end\n \
    \ return result\nend", "    \n    # Insert your code here", "  encoded = \"\"\n\
    \  message.chars.each do |c|\n    next if c.downcase == \"@\" || c.downcase ==\
    \ \"#\" || c.downcase == \"$\" || c.downcase == \"%\" || c.downcase == \"&\" ||\
    \ c.downcase == \"\\a\" || c.downcase == \"\\e\" || c.downcase == \"\\\"\" ||\
    \ c.downcase == \"\\'\" || c.downcase == \"(\" || c.downcase == \")\" || c.downcase\
    \ == \"*\" || c.downcase == \"+\"\n    next if c.downcase == \"-\"\n    next if\
    \ c.downcase == \"_\"\n    next if c.downcase == \"=\" || c.downcase == \":\"\
    \ || c.downcase == \"=\" || c.downcase == \"?\" || c.downcase == \"@\" || c.downcase\
    \ == \"#\" || c.downcase == \"$\" || c.downcase == \"%\" || c.downcase == \"&\"\
    \ || c.downcase == \"\\a\" || c.downcase == \"\\e\" || c.downcase == \"\\\"\"\
    \ || c.downcase == \"\\'\" || c.downcase == \"(\"  || c.downcase == \")\" || c.downcase\
    \ == \"*\" || c.downcase == \"+\"\n    next if c.downcase == \"^\" || c.downcase\
    \ == \"~\" || c.downcase == \"^\" || c.downcase == \"~\"\n    next if c.downcase\
    \ == \"|\"\n    next if c.downcase == \"\xA3\" || c.downcase == \"\u20AC\" ||\
    \ c.downcase == \"\xA5\" || c.downcase == \"\u20BE\" || c.downcase == \"\u20A3\
    \" || c.downcase == \"\u20BA\" || c.downcase == \"\u20BC\" || c.downcase == \"\
    \u20BD\" || c.downcase == \"\u20B8\" || c.downcase == \"\u20B9\" || c.downcase\
    \ == \"\u20B8\" || c.downcase == \"\u20B9\" || c.downcase == \"\u20B9\" || c.downcase\
    \ == \"\u20B9\" || c.downcase == \"\u20B9\" || c.downcase == \"\u20B9\" || c.downcase\
    \ == \"\u20B9\" || c.downcase == \"\u20B9\" || c.downcase == \"\u20B9\" || c.downcase\
    \ == \"\u20B9\" || c.downcase == \"\u20B9\" || c.downcase == \"\u20B9\" || c.downcase\
    \ == \"\u20B9\" || c.downcase == \"\u20B9\" || c.downcase == \"\u20B9\" || c.downcase\
    \ == \"\u20B9\" || c.downcase == \"\u20B9\" || c.downcase == \"\u20B9\" || c.downcase\
    \ == \"\u20B9\" || c.downcase == \"\u20B9\" || c.downcase == \"\u20B9\" || c.",
  "    \n    message.tr! {|c| c.upcase }.tr! {|c| c.split('').map {|x| x.upcase }.reduce(:\"\
    \") }\n    message.downcase\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\n\
    `message.downcase` should only be called once, before `tr!`\n<|/ c |>\n<| c |>\n\
    You are correct. I have updated my answer accordingly.\n<|/ c |>\n<| a |>\nI would\
    \ use String#tr, like this:\n<code>\nmessage.tr! {|c| c.downcase}\n</code>\n<|/\
    \ a tags=ruby dscore=0 |>\n<| a tags=ruby |>\n<code>", "    message = ''.join(message.split('\
    \ '))\n    message = message.upper()\n    vowels = list('AEIOU')\n    pairs =\
    \ [(letter,letter+2) if letter in vowels \n             else (letter+2,letter)\
    \ for letter in message]\n    final = []\n    for pair in pairs:\n        if pair\
    \ in final:\n            pair = (pair[1], pair[0])\n        final.append(pair)\n\
    \    return ''.join(letter for pair in final for letter in pair)", "  result =\
    \ \"\"\n  for i in message\n    if i.upcase == \"A\"\n      result = result +\
    \ \"B\"\n    elsif i.upcase == \"B\"\n      result = result + \"A\"\n    elsif\
    \ i.upcase == \"C\"\n      result = result + \"C\"\n    elsif i.upcase == \"D\"\
    \n      result = result + \"D\"\n    elsif i.upcase == \"E\"\n      result = result\
    \ + \"E\"\n    elsif i.upcase == \"F\"\n      result = result + \"F\"\n    elsif\
    \ i.upcase == \"G\"\n      result = result + \"G\"\n    elsif i.upcase == \"H\"\
    \n      result = result + \"H\"\n    elsif i.upcase == \"I\"\n      result = result\
    \ + \"J\"\n    elsif i.upcase == \"J\"\n      result = result + \"I\"\n    elsif\
    \ i.upcase == \"K\"\n      result = result + \"K\"\n    elsif i.upcase == \"L\"\
    \n      result = result + \"L\"\n    elsif i.upcase == \"M\"\n      result = result\
    \ + \"M\"\n    elsif i.upcase == \"N\"\n      result = result + \"N\"\n    elsif\
    \ i.upcase == \"O\"\n      result = result + \"P\"\n    elsif i.upcase == \"P\"\
    \n      result = result + \"O\"\n    elsif i.upcase == \"Q\"\n      result = result\
    \ + \"R\"\n    elsif i.upcase == \"R\"\n      result = result + \"Q\"\n    elsif\
    \ i.upcase == \"S\"\n      result = result + \"S\"\n    elsif i.upcase == \"T\"\
    \n      result = result + \"T\"\n    elsif i.upcase == \"U\"\n      result = result\
    \ + \"V\"\n    elsif i.upcase == \"V\"\n      result = result + \"U\"\n    elsif\
    \ i.upcase == \"W\"\n      result = result + \"X\"\n    elsif i.upcase == \"X\"\
    \n      result = result + \"W\"\n    elsif i.upcase == \"Y\"\n      result = result\
    \ + \"Y\"\n    elsif i.upcase == \"Z\"\n      result = result + \"Z\"\n    elsif\
    \ i.upcase == \"a\"\n      result = result + \"b\" \n    elsif i.upcase == \"\
    b\"\n      result = result + \"a\" \n    elsif i.", "    vowels = ['a', 'e', 'i',\
    \ 'o', 'u']\n    vowel_map = ['a', 'e', 'i', 'o', 'u']\n    vowel_letters = vowels.join(vowel_map)",
  "    message = \"\"\n    vowels = \"aeiou\"\n    letters = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    message.each do |letter|\n        message << letter.capitalize\n    end\n\
    \    message = message.split(\"\").map { |x| x.capitalize }.join\n    message.gsub!(\"\
    [aeiou]\", \"|\")\n    message.gsub!(\"[aeiouAEIOU]\", \"|\")\n    message.gsub!(vowels,\
    \ \"|\")\n    message.gsub!(letters, \"|\")\n    message.gsub!(\"|\", \"z\")\n\
    \    message.downcase!\n    return message\nend", "  message = message.downcase\n\
    \  message.gsub!(/[a-z]/i) { |letter| letter.upcase }\n  message.gsub!(/[aeiou]/i)\
    \ { |letter| letter.ord }\n  message[0..-2].zip(message[-2..-1]).map { |pair|\
    \ pair.join }.join\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays |>\nA little\
    \ shorter than the first answer - using inject:\n<code>", "  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  swapped = ''\n  vowels = 'aeiou'\n  message.each_char do |c|\n    swapped <<\
    \ alphabet[alphabet.index(c) + 1]\n  end\n  message.downcase.each_char do |c|\n\
    \    if vowels.include?(c)\n      swapped << alphabet[alphabet.index(c.upcase)\
    \ + 1]\n    end\n  end\n  swapped\nend\n</cell>\n<cell>", "  message.downcase!\n\
    \  message.scan(/./) { |char| \n    char.upcase if vowel?(char)\n    char.swapcase\
    \ if char.match(/[aeiou]/)\n    char.gsub!(/[aeiou]/) { |vowel| alphabet[alphabet.index(vowel)\
    \ + 2] }\n  }\n  message\nend", "\talphabet =  %w[a b c d e f g h i j k l m n\
    \ o p q r s t u v w x y z]\n\tmessage.split('').map do |char|\n\t\tif alphabet.include?(char)\n\
    \t\t\talphabet[alphabet.index(char)+2].upcase\n\t\telse\n\t\t\tchar\n\t\tend\n\
    \tend.join\nend", "  new_message = ''\n  new_message = message.downcase.gsub(/[aeiou]/i)\
    \ { |m| alphabet[m] }\n  new_message = new_message.gsub(/[aeiou]/i) { |m| alphabet.index(m)+1\
    \ }\n  new_message.each do |char|\n    alphabet.index(char)+1 unless alphabet.include?(char)\n\
    \  end\nend", "  return message.gsub(/[a-zA-Z]/).with_index {|v,i| \n    if i\
    \ % 2 == 0 \n      v.downcase\n    elsif v == \"a\"\n      \"g\"\n    elsif v\
    \ == \"e\"\n      \"h\"\n    elsif v == \"i\"\n      \"j\"\n    elsif v == \"\
    o\"\n      \"k\"\n    elsif v == \"u\"\n      \"m\"\n    elsif v == \"y\"\n  \
    \    \"f\"\n    end\n  }\nend\n</cell>\n<code language=julia-1.5>", "  # Write\
    \ your code here.\n  vowels = \"AEIOUaeiou\"\n  letter_map = {\n    \"a\" => \"\
    A\",\n    \"e\" => \"E\",\n    \"i\" => \"I\",\n    \"o\" => \"O\",\n    \"u\"\
    \ => \"U\",\n  }\n  message_cap = message\n  message_cap.each do |letter|\n  \
    \  letter = letter.upcase\n    \n    if vowels.include?(letter)\n      letter\
    \ = letter_map[letter]\n      letter = letter + letter.next(vowels.index(letter))\n\
    \    end\n    \n    message_cap = message_cap.sub(letter, letter + letter.next)\n\
    \  end\n  \n  message_cap\nend\n</code>\n<|/ a tags=ruby,string dscore=1 |>\n\
    <| c |>\nThank you! This is a very interesting answer. I'm not sure if it is the\
    \ most efficient one, but it does work. I was wondering if someone could explain\
    \ the code a little more. Like why did you create letter_map and vowels? and what\
    \ exactly is message_cap? How does the code know that if the letter is in the\
    \ vowel list it needs to use letter_map and if it's not in the vowel list it needs\
    \ to use \"letter + letter.next\". And how does the code know when to use the\
    \ .upcase method and when not to?\n<|/ c |>\n<| c |>\nGreat explanation! It really\
    \ helped me understand what's going on.\n<|/ c |>\n<| a tags=ruby,string |>\n\
    <code>\na = \"This is a message\"\na.gsub(/[aeiou]/) do |l|\n  v = l.next\n  case\
    \ l\n  when 'a' => \"A\"\n  when 'e' => \"E\"\n  when 'i' => \"I\"\n  when 'o'\
    \ => \"O\"\n  when 'u' => \"U\"\n  when 'y' => \"Y\"\n  else\n  end + v\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nYeah I tried this before but for some reason\
    \ it didn't work. Now it works after I changed your code to what was previously\
    \ written and it doesn't make any sense to me. Can you please tell me what does\
    \ \"l\" and \"v\" stand for and what does \"when 'a' => \"A\" mean? What does\
    \ \"when 'y' => \"Y\" mean? I don't see any letter that has a 'y' in it and it\
    \ works. I'm sorry but I'm new to programming.\n<|/ c |>\n<| c ", "  message =\
    \ (message + 'a'.repeat message.count('a') + message.count('e') + message.count('i')\
    \ + message.count('o') + message.count('u')).gsub(/[aeiou]/.upcase, '').gsub(/a{2}/,\
    \ '@').gsub(/e{2}/, '!')\n  message.gsub!(/[a]{2}|[e]{2}/, '')\n  message.gsub!(/[a]{2}/,\
    \ '@')\n  message.gsub!(/[e]{2}/, '!')\n  message.gsub!(/[A]{2}/, '@')\n  message.gsub!(/[E]{2}/,\
    \ '!')\n  message.gsub!(/[A]{3}/, '@')\n  message.gsub!(/[E]{3}/, '!')\n  message.gsub!(/[A]{4}/,\
    \ '@')\n  message.gsub!(/[E]{4}/, '!')\n  message.gsub!(/[A]{5}/, '@')\n  message.gsub!(/[E]{5}/,\
    \ '!')\n  message.gsub!(/[A]{6}/, '@')\n  message.gsub!(/[E]{6}/, '!')\n  message.gsub!(/[A]{7}/,\
    \ '@')\n  message.gsub!(/[E]{7}/, '!')\n  message.gsub!(/[A]{8}/, '@')\n  message.gsub!(/[E]{8}/,\
    \ '!')\n  message.gsub!(/[A]{9}/, '@')\n  message.gsub!(/[E]{9}/, '!')\n  message.gsub!(/[A]{10}/,\
    \ '@')\n  message.gsub!(/[E]{10}/, '!')\n  message.gsub!(/[A]{11}/, '@')\n  message.gsub!(/[E]{11}/,\
    \ '!')\n  message.gsub!(/[A]{12}/, '@')\n  message.gsub!(/[E]{12}/, '!')\n  message.gsub!(/[A]{13}/,\
    \ '@')\n  message.gsub!(/[E]{13}/, '!')\n  message.gsub!(/[A]{14}/, '@')\n  message.gsub!(/[E]{14}/,\
    \ '!')\n  message.gsub!(/[A]{15}/, '@')\n  message.gsub!(/[E]{15}/, '", "  result\
    \ = \"\"\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  for c in message\n\
    \    if vowels.include? c\n      result << c\n    else\n      result << c.swapcase\n\
    \    end\n  end\n  result\nend", "    message = message.split(\"\")\n    decoded\
    \ = message.map do |letter|\n        letter = letter.upcase\n        vowel = letter.at(3)\n\
    \        letter = letter.gsub(vowel, \"A\")\n        letter = letter.gsub(vowel,\
    \ \"B\")\n        letter = letter.gsub(vowel, \"C\")\n        letter = letter.gsub(vowel,\
    \ \"D\")\n        letter = letter.gsub(vowel, \"E\")\n        letter = letter.gsub(vowel,\
    \ \"F\")\n        letter = letter.gsub(vowel, \"G\")\n        letter = letter.gsub(vowel,\
    \ \"H\")\n        letter = letter.gsub(vowel, \"I\")\n        letter = letter.gsub(vowel,\
    \ \"J\")\n        letter = letter.gsub(vowel, \"K\")\n        letter = letter.gsub(vowel,\
    \ \"L\")\n        letter = letter.gsub(vowel, \"M\")\n        letter = letter.gsub(vowel,\
    \ \"N\")\n        letter = letter.gsub(vowel, \"O\")\n        letter = letter.gsub(vowel,\
    \ \"P\")\n        letter = letter.gsub(vowel, \"Q\")\n        letter = letter.gsub(vowel,\
    \ \"R\")\n        letter = letter.gsub(vowel, \"S\")\n        letter = letter.gsub(vowel,\
    \ \"T\")\n        letter = letter.gsub(vowel, \"U\")\n        letter = letter.gsub(vowel,\
    \ \"V\")\n        letter = letter.gsub(vowel, \"W\")\n        letter = letter.gsub(vowel,\
    \ \"X\")\n        letter = letter.gsub(vowel, \"Y\")\n        letter = letter.gsub(vowel,\
    \ \"Z\")\n        letter\n    end.join(\"\")\nend", "    message = message.downcase\n\
    \    message.split(' ').each do |word|\n        word.chars.each do |char|\n  \
    \          next if char.upcase == char\n            next if char == 'E' || char\
    \ == 'I'\n            \n            char.upcase = (char.upcase + 2) % (26)\n \
    \       end\n    end", "  # Write your code here.\n  return message\n</cell>\n\
    <cell>", "    words = message.split()\n    counts = Hash.new(0)\n    \n    words.each\
    \ do |word|\n        word = word.tr('aeiouAEIOU', 'AEIOU')\n        counts[word]\
    \ += 1\n    end\n    \n    letters = []\n    words.each do |word|\n        if\
    \ counts[word] > 2\n            letters << word[0].to_s + word[1..-1].to_s\n \
    \       else\n            letters << word\n        end\n    end\n    letters.join('\
    \ ')\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", "  # Your code here\n  \n  return\
    \ message", "    vowels = 'AEIOUaeiou'\n    message = message.upcase \n    vowels_count\
    \ = message.gsub(vowels).length \n    letter_count = message.count('a')\n    letter_count_2\
    \ = message.count('e')\n    letter_count_3 = message.count('i')\n    letter_count_4\
    \ = message.count('o')\n    letter_count_5 = message.count('u')\n    new_message\
    \ = ''\n    i = 0\n    while i < message.length\n        if vowels_count > 2\n\
    \            new_message += message[i].upcase\n            i += 2\n        elsif\
    \ letter_count >= letter_count_2\n            new_message += message[i].upcase\n\
    \            i += 2\n        elsif letter_count_3 >= letter_count_2\n        \
    \    new_message += message[i].upcase\n            i += 2\n        elsif letter_count_4\
    \ >= letter_count_2\n            new_message += message[i].upcase\n          \
    \  i += 2\n        elsif letter_count_5 >= letter_count_2\n            new_message\
    \ += message[i].upcase\n            i += 2\n        else\n            new_message\
    \ += message[i]\n            i += 1\n    end\n    return new_message\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nWhat do you mean? You can't use it? What do you mean\
    \ by \"can't use it\"?\n<|/ c |>\n<| c |>\nI was asking how to do this with Ruby.\
    \ I got some help on this. I posted an answer with my code.\n<|/ c |>\n<| a dscore=0\
    \ |>\nRuby has a built in method to do that :\n<code>\n\"this is a test\".gsub(/[aeiouAEIOU]/){|a|\
    \ a.upcase}\n</code>\nor if you don't like ternary operator :\n<code>\n\"this\
    \ is a test\".gsub(/[aeiouAEIOU]/){|a| a[0].upcase+a[1..-1]}\n</code>\n<|/ a tags=ruby,ruby-on-rails,regex\
    \ |>\n<| a |>\nHere's a recursive implementation:\n<code>", "  message\n  .upcase!\n\
    \  .downcase!\n  .gsub(/[aeiou]/){ |v| [v, v.upcase][rand(2)] }\n  .scan(/[aeiou]/).inject([]){|a,\
    \ e| a << [e, e.downcase][rand(2)]}\n  .join\nend\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails\
    \ dscore=0 |>\n<| c |>\nThanks for the answer. Your code is working but I used\
    \ something similar in the end. Still thanks for your time :)\n<|/ c |>\n<| a\
    \ dscore=0 |>\nThis should work just fine:\n<code>", "    vowels = ['a','e','i','o','u']\n\
    \    swap_case = lambda m : ''.join( [ i.lower() for i in m.group().split('')\
    \ ] )\n    swap_vowel = lambda m : ''.join( [ i if i not in vowels else swap_case(m.group())\
    \ for i in m.group().split('') ] )\n    return \"\".join( [ swap_vowel(message)\
    \ if i not in message else i for i, m in enumerate(message) ] )\n</cell>\n<cell>",
  "    # Replace vowels first\n    vowels = 'aeiou'\n    for letter in message:\n\
    \        if letter in vowels:\n            message = message.replace(letter, letter.upper())\n\
    \    # Now replace adjacent letters \n    length = len(message)\n    for index\
    \ in range(length):\n        if message[index] == 'a':\n            message =\
    \ message[0:index] + letter.upper(message[index+1:])\n    return message\nprint(encode('test'))\n\
    print(encode('This is a message'))\n</cell>\n<cell>", "    # Replace each vowel\
    \ with its letter from english alphabet. \n    message_letters = message.split(\"\
    \")\n    new_message_letters = []\n    \n    for letter in message_letters\n \
    \       if letter in ['a', 'e', 'i', 'o', 'u']\n            new_message_letters.append(letter)\n\
    \        else\n            new_message_letters.each do |other_letter|\n      \
    \          if letter == 'e'\n                    new_message_letters.at(new_message_letters.index(other_letter)\
    \ + 2)\n                elsif letter == 'i'\n                    new_message_letters.at(new_message_letters.index(other_letter)\
    \ + 1)\n                elsif letter == 'o'\n                    new_message_letters.at(new_message_letters.index(other_letter)\
    \ - 1)\n                elsif letter == 'u'\n                    new_message_letters.at(new_message_letters.index(other_letter)\
    \ + 1)\n                else\n                    letter\n                end\n\
    \            end\n        end\n    end\n    new_message = new_message_letters.join(\"\
    \")\n    return new_message\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThe easiest\
    \ way to understand this would be: \n<code>", "    alphabet = string.ascii_lowercase\n\
    \    vowels = \"AEIOU\"\n    message_out = ''\n    for i in message\n        replacement\
    \ = alphabet.index(i) + alphabet[:alphabet.index(i) + 1].index(vowels[alphabet.index(i)])\n\
    \        message_out += alphabet[replacement]\n    end\n    puts \"Message encoded\
    \ in \" + message_out\n    return message_out\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Your function doesn't work if there's a vowel at the beginning or end of a word,\
    \ which it shouldn't.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n<code>", "  new_message\
    \ = message\n  old_letters = \"a b c d e f g h i j k l m n o p q r s t u v w x\
    \ y z\"\n  new_letters = \"A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\"\
    \n  swaps = { \n    'a' => 'A',\n    'b' => 'B',\n    'c' => 'C',\n    'd' =>\
    \ 'D',\n    'e' => 'E',\n    'f' => 'F',\n    'g' => 'G',\n    'h' => 'H',\n \
    \   'i' => 'I',\n    'j' => 'J',\n    'k' => 'K',\n    'l' => 'L',\n    'm' =>\
    \ 'M',\n    'n' => 'N',\n    'o' => 'O',\n    'p' => 'P',\n    'q' => 'Q',\n \
    \   'r' => 'R',\n    's' => 'S',\n    't' => 'T',\n    'u' => 'U',\n    'v' =>\
    \ 'V',\n    'w' => 'W',\n    'x' => 'X',\n    'y' => 'Y',\n    'z' => 'Z'\n  }\n\
    \  vowels = { \n    'a' => 'A',\n    'b' => 'E',\n    'c' => 'I',\n    'd' =>\
    \ 'O',\n    'e' => 'U',\n    'f' => 'Y',\n    'g' => 'B',\n    'h' => 'C',\n \
    \   'i' => 'D',\n    'j' => 'F',\n    'k' => 'G',\n    'l' => 'H',\n    'm' =>\
    \ 'J',\n    'n' => 'K',\n    'o' => 'M',\n    'p' => 'N',\n    'q' => 'O',\n \
    \   'r' => 'P',\n    's' => 'Q',\n    't' => 'R',\n    'u' => 'S',\n    'v' =>\
    \ 'T',\n    'w' => 'V',\n    'x' => 'W',\n    'y' => 'X',\n    'z' => 'Y'\n  }",
  "  message.split('').map do |char|\n    if char.upcase == 'A'\n      'b'\n    elsif\
    \ char.upcase == 'B'\n      'c'\n    elsif char.upcase == 'C'\n      'd'\n   \
    \ elsif char.upcase == 'D'\n      'e'\n    elsif char.upcase == 'E'\n      'f'\n\
    \    elsif char.upcase == 'F'\n      'g'\n    elsif char.upcase == 'G'\n     \
    \ 'h'\n    elsif char.upcase == 'H'\n      'i'\n    elsif char.upcase == 'I'\n\
    \      'j'\n    elsif char.upcase == 'J'\n      'k'\n    elsif char.upcase ==\
    \ 'K'\n      'l'\n    elsif char.upcase == 'L'\n      'm'\n    elsif char.upcase\
    \ == 'M'\n      'n'\n    elsif char.upcase == 'N'\n      'o'\n    elsif char.upcase\
    \ == 'O'\n      'p'\n    elsif char.upcase == 'P'\n      'q'\n    elsif char.upcase\
    \ == 'Q'\n      'r'\n    elsif char.upcase == 'R'\n      's'\n    elsif char.upcase\
    \ == 'S'\n      't'\n    elsif char.upcase == 'T'\n      'u'\n    elsif char.upcase\
    \ == 'U'\n      'v'\n    elsif char.upcase == 'V'\n      'w'\n    elsif char.upcase\
    \ == 'W'\n      'x'\n    elsif char.upcase == 'X'\n      'y'\n    elsif char.upcase\
    \ == 'Y'\n      'z'\n    elsif char.upcase == 'Z'\n      'A'\n    elsif char.upcase\
    \ == 'a'\n      'B'\n    elsif char.upcase == 'b'\n      'C'\n    elsif char.upcase\
    \ == 'c'\n      'D'\n    elsif char.upcase == 'd'\n      'E'\n    elsif char.upcase\
    \ == 'e'\n      'F'\n    elsif char.upcase == 'f'\n      'G'\n    elsif char.upcase\
    \ == 'g'\n", "    message.each_char.map do |char|\n        char.upcase if char.upcase\
    \ == char.downcase\n        char.downcase if char.downcase == char.upcase\n  \
    \      char\n    end.join\nend\n</cell>\n<cell>\nencode\n</cell>\n<cell>", " \
    \ \n  return message\nend\n</cell>\n<cell>", "  message = message.downcase\n \
    \ message.tr!('aeiouAEIOU', 'AEB')\n  message.gsub!(/[aeiou]/, function(a)\n \
    \   index = a.upcase\n    letter = english_alphabet.index(index) + 1\n    english_alphabet[index\
    \ + 1 % 26]\n  end)\n  message\nend\n</cell>\n<code language=julia-1.0>\nencode(encode(encode(encode(\"\
    this is a message\"))))\n</cell>\n<text>\nQuestion 12. Write a function that takes\
    \ a message, and encodes in such a way that it swaps case of all letters, replaces\
    \ all vowels in the message with the letter that appears 2 places ahead of that\
    \ vowel in the english alphabet. Assume only letters and spaces.", "  return \n\
    \    ", "  # The code below is a bit tricky. \n  # First, let's get the english\
    \ alphabet and all it's 26 letters.\n  # We'll use that later to iterate over\
    \ our message and change every\n  # vowel to a letter that is 2 spots ahead of\
    \ the vowel in the alphabet. \n  english = alphabet.split('')\n  # Now let's iterate\
    \ over the message and swap each vowel to a \n  # letter that is 2 spots ahead\
    \ of the vowel in the alphabet. \n  new_message = ''\n  for i in message\n   \
    \ if english.include? i\n      new_message << english.index(i)\n    end\n  end\n\
    \  # Now let's append our converted letters to the end of our \n  # new_message.\
    \ \n  # Note that this will work because our english alphabet is 26 \n  # characters\
    \ long, and we used english.index to get the index \n  # of our letter. \n  new_message\
    \ << new_message.chars.zip([english.index(c) for c in message]).reduce(:+)\n \
    \ new_message\nend", "    message = message.downcase.gsub(/[aeiou]/i) { |s| s.succ\
    \ }\n    message.each_char.with_index { |c,i| message[i] = c.succ if i > 1 }\n\
    \    message.join\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is awesome!\
    \ I thought this would be more complex than it really was. Your solution is definitely\
    \ more elegant.\n<|/ c |>\n<| c |>\nI appreciate it, and it definitely gets my\
    \ vote.\n<|/ c |>\n<| c |>\nThis code is an amazing example of how to do it, but\
    \ there are some problems. First, the vowels are replaced twice if the first letter\
    \ is a consonant. Second, if the vowels are all at the end of the string they\
    \ get replaced again (so \"a\" is replaced twice with \"b\" and \"c\").\n<|/ c\
    \ |>\n<| c |>\n. Thank you for pointing out the two problems. I fixed both of\
    \ those.\n<|/ c |>\n<| c |>\nI like the `each_char.with_index` construct for conciseness,\
    \ but it looks more like Ruby to me. `each_char.with_index.with_index.with_index.with_index`\
    \ seems like more Ruby code to me. Or maybe not.\n<|/ c |>\n<| a dscore=2 |>\n\
    I would do something like this:\n<code>", "  # Initialize variables. \n  vowels\
    \ = 'AEIOUaeiou'\n  \n  # Return value given below. \n  return message", "  return\
    \ message.gsub(/([A-Z])/) { $1.upcase }\n                       .gsub(/[AEIOUaeiou]/)\
    \ { |m| 'AEIOUAEIOU'.index(m) }\n                       .gsub(/[^A-Z]/){ |c| 'AEIOUAEIOU'.index(c)\
    \ }\n                       .gsub(/[aeiou]/) { |c| 'AEIOUAEIOU'.index(c) }\nend\n\
    </code>\n<|/ a dscore=5 tags=ruby |>\n<| c |>\nThe question was to make a \"rot13\"\
    \ cipher with only vowels and no other characters. Your answer does that, but\
    \ in a way that is quite different from the question, namely that the first and\
    \ last characters are the same as the second-to-last character of the previous\
    \ character. For example, your method would give the result `'eouAEIOUAEIOU'`\
    \ for `\"Hello\"`.\n<|/ c |>\n<| c |>\nI like the idea of keeping the first and\
    \ last characters equal but have you considered that the word \"testing\" would\
    \ result in \"tEeSsTtHhIng\" rather than \"TsTtHhIng\" ?\n<|/ c |>\n<| c |>\n\
    Yes, of course. Now that I think about it, it's not that obvious what a word that\
    \ starts and ends with the same letter should be. My idea was to use \"testing\"\
    \ as the input string, and \"tEeSsTtHhIng\" as the expected result. Since \"teesst\"\
    \ is correct for \"testing\", it is probably better to just use that as the expected\
    \ result.\n<|/ c |>\n<| c |>\nJust for fun, I rewrote my answer so that it uses\
    \ the [ROT13](http://en.wikipedia.org/wiki/ROT13) cipher, which seems to be a\
    \ little more natural. Of course, I'm biased.\n<|/ c |>\n<| c |>\nI think your\
    \ version gives the result `'eouAEIOUAEIOU'` for `\"Hello\"`.\n<|/ c |>\n<| a\
    \ dscore=4 tags=ruby |>\nI came up with a simple solution using regex to replace\
    \ all vowels with 2 characters. For example:\n<code>\n'abracadabra'\n</code>\n\
    becomes\n<code>\n'abracadbabra'\n</code>\nor\n<code>\n'abcdabcdabcdabcdabcdabcdabcd'\n\
    </code>\nbecomes\n<code>\n'abcdabcdabcdabcde'\n</code>\nI didnt know about upcase ",
  "  result = ''\n  a = message[0].downcase\n  b = message[1].downcase\n  c = message[2].downcase\n\
    \  d = message[3].downcase\n  e = message[4].downcase\n  f = message[5].downcase\n\
    \  g = message[6].downcase\n  h = message[7].downcase\n  i = message[8].downcase\n\
    \  j = message[9].downcase\n  k = message[10].downcase\n  l = message[11].downcase\n\
    \  m = message[12].downcase\n  n = message[13].downcase\n  o = message[14].downcase\n\
    \  p = message[15].downcase\n  q = message[16].downcase\n  r = message[17].downcase\n\
    \  s = message[18].downcase\n  t = message[19].downcase\n  u = message[20].downcase\n\
    \  v = message[21].downcase\n  w = message[22].downcase\n  x = message[23].downcase\n\
    \  y = message[24].downcase\n  z = message[25].downcase\n  A = message[26].downcase\n\
    \  B = message[27].downcase\n  C = message[28].downcase\n  D = message[29].downcase\n\
    \  E = message[30].downcase\n  F = message[31].downcase\n  G = message[32].downcase\n\
    \  H = message[33].downcase\n  I = message[34].downcase\n  J = message[35].downcase\n\
    \  K = message[36].downcase\n  L = message[37].downcase\n  M = message[38].downcase\n\
    \  N = message[39].downcase\n  O = message[40].downcase\n  P = message[41].downcase\n\
    \  Q = message[42].downcase\n  R = message[43].downcase\n  S = message[44].downcase\n\
    \  T = message[45].downcase\n  U = message[46].downcase\n  V = message[47].downcase\n\
    \  W = message[48].downcase\n  X = message[49].downcase\n  Y = message[50].downcase\n\
    \  Z = message[51].downcase\n  a = message[0].upcase\n  b = message[1].upcase\n\
    \  c = message[2].upcase\n  d = message[3].upcase\n  e = message[4].upcase\n \
    \ f = message[5].upcase\n  g = message[6].upcase", "  letter_mappings = { \n \
    \   \"A\"=>\"a\", \"B\"=>\"b\", \"C\"=>\"c\", \"D\"=>\"d\", \"E\"=>\"e\", \"F\"\
    =>\"f\",\n    \"G\"=>\"g\", \"H\"=>\"h\", \"I\"=>\"i\", \"J\"=>\"j\", \"K\"=>\"\
    k\", \"L\"=>\"l\",\n    \"M\"=>\"m\", \"N\"=>\"n\", \"O\"=>\"o\", \"P\"=>\"p\"\
    , \"Q\"=>\"q\", \"R\"=>\"r\",\n    \"S\"=>\"s\", \"T\"=>\"t\", \"U\"=>\"u\", \"\
    V\"=>\"v\", \"W\"=>\"w\", \"X\"=>\"x\",\n    \"Y\"=>\"y\", \"Z\"=>\"z\", \"a\"\
    =>\"A\", \"b\"=>\"B\", \"c\"=>\"C\", \"d\"=>\"D\",\n    \"e\"=>\"E\", \"f\"=>\"\
    F\", \"g\"=>\"G\", \"h\"=>\"H\", \"i\"=>\"I\", \"j\"=>\"J\",\n    \"k\"=>\"K\"\
    , \"l\"=>\"L\", \"m\"=>\"M\", \"n\"=>\"N\", \"o\"=>\"O\", \"p\"=>\"P\",\n    \"\
    q\"=>\"Q\", \"r\"=>\"R\", \"s\"=>\"S\", \"t\"=>\"T\", \"u\"=>\"U\", \"v\"=>\"\
    V\",\n    \"w\"=>\"W\", \"x\"=>\"X\", \"y\"=>\"Y\", \"z\"=>\"Z\", \"-\"=>\"-\"\
    , \"_\"=>\"_\", \".\"=>\".\",\n    \"?\"=>\"?\", \"!\":\"!\"\n  }\n  result =\
    \ message.dup\n  result.gsub!('a', 'A')\n  result.gsub!('b', 'B')\n  result.gsub!('c',\
    \ 'C')\n  result.gsub!('d', 'D')\n  result.gsub!('e', 'E')\n  result.gsub!('f',\
    \ 'F')\n  result.gsub!('g', 'G')\n  result.gsub!('h', 'H')\n  result.gsub!('i',\
    \ 'I')\n  result.gsub!('j', 'J')\n  result.gsub!('k', 'K')\n  result.gsub!('l',\
    \ 'L')\n  result.gsub!('m', 'M')\n  result.gsub!('n', 'N')\n  result.gsub!('o',\
    \ 'O')\n  result.gsub!('p', 'P')\n  result.gsub!('q', 'Q')\n  result.gsub!('r',\
    \ 'R')\n  result.gsub!('s', 'S')\n  result.gsub!('t', 'T')\n  result.gsub!('u',\
    \ 'U')\n  result.g", "    message = message.dup\n    message.gsub! /[a-z]/, lambda\
    \ x: x.succ\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.gsub! /[aeiou]/,\
    \ /[aeiou]/\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.gsub! /[aeiou]/,\
    \ /[aeiou]/\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.gsub! /[aeiou]/,\
    \ /[aeiou]/\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.gsub! /[aeiou]/,\
    \ /[aeiou]/\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.gsub! /[aeiou]/,\
    \ /[aeiou]/\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.gsub! /[aeiou]/,\
    \ /[aeiou]/\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.gsub! /[aeiou]/,\
    \ /[aeiou]/\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.gsub! /[aeiou]/,\
    \ /[aeiou]/\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.gsub! /[aeiou]/,\
    \ /[aeiou]/\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.gsub! /[aeiou]/,\
    \ /[aeiou]/\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.gsub! /[aeiou]/,\
    \ /[aeiou]/\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.gsub! /[aeiou]/,\
    \ /[aeiou]/\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.gsub! /[aeiou]/,\
    \ /[aeiou]/\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.gsub! /[aeiou]/,\
    \ /[aeiou]/\n    message.gsub! /[aeiou]/, /[aeiou]/\n    message.", "  return\
    \ message.gsub(/[a-z]/) do |character|\n    letter = case character\n        \
    \    when 'a' then 'b'\n            when 'e' then 'f'\n            when 'i' then\
    \ 'g'\n            when 'o' then 'h'\n            when 'u' then 'j'\n        \
    \    else character\n        end\n    message.gsub(/[aeiou]/ => '')\n  end\nend",
  "  message = message.downcase\n  messages = message.split('')\n  encrypted_message\
    \ = \"\"\n  for i in messages\n    if i.include? 'e'\n      encrypted_message\
    \ << i.upcase\n    elsif i.include? 'o'\n      encrypted_message << i.upcase\n\
    \    elsif i.include? 'a'\n      encrypted_message << i.upcase\n    elsif i.include?\
    \ 'u'\n      encrypted_message << i.upcase\n    elsif i.include? 'i'\n      encrypted_message\
    \ << i.upcase\n    else\n      encrypted_message << i\n    end\n  end\n  return\
    \ encrypted_message\nend", "    alphabet = %w(a b c d e f g h i j k l m n o p\
    \ q r s t u v w x y z)\n    vowels = %w(V X O M)\n    words = message.split(%r{\\\
    s})\n    encrypted_words = []\n    encrypted_words.concat(words.map { |word| word.split('').map\
    \ { |char| char.downcase }.join.split(%r{(?<=\\A|\\b)})})\n    encrypted_words.concat(words.map\
    \ { |word| encrypted_words.map { |encrypted_word| encrypted_word.sub(vowels.sample,\
    \ '').gsub(alphabet) { |letter| alphabet.index letter }.join(%r{(?<=\\A|\\b)})\
    \ }})\n    encrypted_words.map { |word| word.split('').map { |char| char.upcase\
    \ }.join.split(%r{(?<=\\A|\\b)}) }.flatten.join(' ')\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI like how you solved a question that is very difficult to solve!  Thank\
    \ you!\n<|/ c |>\n<| c |>\nNo problem. You're welcome! :) It's good to know that\
    \ your solution works. I always learn something new about solving problems :)\n\
    <|/ c |>\n<| c |>\nThis is awesome! I'm going to have to do more research to understand\
    \ this answer.\n<|/ c |>\n<| c |>\nHi there, how would you modify this to handle\
    \ punctuation?\n<|/ c |>\n<| c |>\nThe solution assumes that all letters are upper\
    \ or lowercase. You can easily modify the code to handle punctation by adding\
    \ another conditional statement inside the block for `alphabet`.\n<|/ c |>\n<|\
    \ a dscore=2 tags=ruby |>\nHere's an interesting problem for you to study and\
    \ work with.  It has to do with consonantal and vowel substitutions.\nLet's say\
    \ we have some message like this: \n<code>\n> message = \"This isn't a message\
    \ that you can read.  It's just text.\"\n> message\n=> \"This isn't a message\
    \ that you can read.  It's just text.\"\n</code>\nHere's an example vowel substitution\
    \ rule:\n<code>\n> message.gsub(/(.)(\\y\\y)(\\y\\y)/,\"\\1\\2\\3\").gsub(/\\\
    b(?:[aeiouAEIOU])(\\y\\y)(\\y\\y)\\b/,\"\\1\\3\\2\")\n=> \"HTHT ND NTND TH", " \
    \ message = message.downcase\n  message = message.gsub(/[a-z]/){|i| i.upcase }\n\
    \  message = message.gsub(/[aeiou]/){|i| i.gsub(/e/, 'a') }\n  message = message.gsub(/[AEIOU]/){|i|\
    \ i.gsub(/I/, 'A') }\n  message = message.gsub(/[^a-zA-Z]/,'')\n  message\nend\n\
    </code>\n<|/ a |>\n<| c |>\nPlease add some explanation to your answer, so the\
    \ OP can understand why you did what you did.\n<|/ c |>\n<| a dscore=2 |>\nI wrote\
    \ this answer to an earlier question but thought I would make it a bit simpler:\n\
    <code>", "  new_message = ''\n  vowels = (\"a\", \"e\", \"i\", \"o\", \"u\")\n\
    \  vowels_2 = \"AEIOU\"\n  message = message.split(\"\")\n  new_message = message\
    \ * 2\n  new_message.each_with_index do |char, index|\n    if vowels.include?(char)\
    \ == true and char == message[index]\n      new_message[index] = vowels_2.index(char)\n\
    \    end\n  end\n  new_message.join(\"\")\nend\n</code>\n<|/ a tags=ruby,algorithm\
    \ dscore=3 |>\n<| a tags=ruby,algorithm dscore=2 |>\nYou could use tr:\n<code>\n\
    'test string'.tr('aeiou','cdefg')", "    encoded = \"\"\n    vowels = \"aeiouAEIOU\"\
    \n    l = message\n    for letter in l:\n        if letter in vowels:\n      \
    \      encoded = encoded + letter\n            encoded = encoded + letter\n  \
    \      else:\n            encoded = encoded + letter.lower()\n            encoded\
    \ = encoded + letter.lower()\n    return encoded\n</cell>\n<cell>", "  # Replace\
    \ vowels with their 2 places ahead consonant\n  message.gsub!(/[aeiou]/i) do |vowel|\n\
    \    index = alphabet.index(vowel) + 1\n    alphabet[(alphabet.index(vowel) +\
    \ index) % 26]\n  end", "\tvowels = 'AEIOUaeiou'\n\tmessage = message\n\tmessage\
    \ = message.gsub(/[AEIOUaeiou]/) { |m| m.upcase }\n\tmessage = message.gsub(/[aeiou]/)\
    \ { |m| vowels.index(m) + 1 }\n\tmessage = message.gsub(/[AEIOU]/) { |m| vowels.index(m)\
    \ }\n\treturn message\nend", "  letter_counts = Hash.new(0)\n  message.split('').each\
    \ do |letter|\n    if letter == 'a'\n      letter_counts.merge('a' => 1, 'A' =>\
    \ 1)\n    elsif letter == 'e'\n      letter_counts.merge('e' => 1, 'E' => 1)\n\
    \    elsif letter == 'i'\n      letter_counts.merge('i' => 1, 'I' => 1)\n    elsif\
    \ letter == 'o'\n      letter_counts.merge('o' => 1, 'O' => 1)\n    elsif letter\
    \ == 'u'\n      letter_counts.merge('u' => 1, 'U' => 1)\n    end\n  end", "  output\
    \ = \"\"\n  \n  for char in message.upcase\n    upper_char = char.upcase\n   \
    \ lower_char = char.downcase\n    \n    if upper_char == \"A\"\n      output <<\
    \ upper_char\n    elseif upper_char == \"E\"\n      output << upper_char\n   \
    \ elseif upper_char == \"I\"\n      output << upper_char\n    elseif upper_char\
    \ == \"O\"\n      output << upper_char\n    elseif upper_char == \"U\"\n     \
    \ output << upper_char\n    else\n      output << char\n    end\n  end\n  \n \
    \ output.downcase!\n  \n  for vowel in \"AEIOU\"\n    index = output.index(vowel)\n\
    \    output << output[index + 1].upcase\n  end\n  \n  output.upcase!\n  \n  return\
    \ output\nend", "  message = \"a\" + message.upcase + \"b\"\n  message = \"a\"\
    \ + message.gsub('a', 'b').upcase + \"b\"\n  message.chars.inject(\"\") do |memo,\
    \ letter|\n    letter = letter.upcase\n    memo <<  letter if letter.gsub('a',\
    \ 'b').upcase.index('b') > letter.gsub('a', 'b').index('a')\n  end\nend\n</code>\n\
    <|/ a tags=ruby,string,ruby-on-rails |>\n<| a tags=ruby,string,ruby-on-rails dscore=2\
    \ |>\nThis is actually a little bit more tricky than the other answers. \nI wrote\
    \ a function to do this that also handles multi-word inputs and handles spaces.\
    \ \n<code>", "    message\nend\n</cell>\n<cell>", "  message.downcase.gsub(/[aeiou]/\
    \ ) { |w| w.succ }\n  message.gsub(/([aeiou])([aeiou])/) do |w|\n  \n    w = w.gsub(/([aeiou])/,\
    \ '\\\\2\\\\1')\n    w\n    \n  end.scan(/(..)(..)/).map{|w|w[1]+w[0]}\nend",
  "  # Your code here\nend\n</cell>\n<cell>", "    message.downcase!\n    message.gsub(/[^a-z]/,\
    \ ' ').split.map{|char| case char\n        when 'a' then 'b'\n        when 'e'\
    \ then 'f'\n        when 'i' then 'g'\n        when 'o' then 'h'\n        when\
    \ 'u' then 'j'\n        when 'y' then 'k'\n        else char\n    end}.join\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby,case-sensitive,string,replace dscore=4\
    \ |>\nAnother way to do this might be to use the String#gsub method, which allows\
    \ you to specify more complex patterns to match and replace. For example:\n<code>\n\
    >> \"aBcDe\".gsub(/([a-z])([A-Z])/, '\\1\\L\\2')\n=> \"AbCdE\"\n</code>\nThe pattern\
    \ here is: match an lowercase letter (\\1) and an uppercase letter (\\2) followed\
    \ by a lowercase letter, and replace the matched letters with themselves plus\
    \ a lowercase letter.\n<|/ a |>\n<| c |>\nNice solution, but for me the substitution\
    \ should be `\\1\\U\\2`, because `\\L` and `\\U` are aliases for the `downcase`\
    \ and `upcase` methods.\n<|/ c |>\n<| a dscore=4 |>\n<code>\n\"a\"+\"b\"\n</code>\n\
    is probably the simplest way.\n<|/ a tags=ruby,case-sensitive,string,replace |>\n\
    <| c |>\nThis is also the most readable solution in Ruby.\n<|/ c |>\n<| c |>\n\
    This is the best answer. `+\"b\"` concatenates string literals and is very clearly\
    \ visible to anyone who knows Ruby. `\"a\" + \"b\"` is obviously a mistake and\
    \ is very confusing to anyone who doesn't know Ruby. `+\"b\"` is obviously a common\
    \ Ruby idiom and is easy to understand.\n<|/ c |>\n<| a tags=ruby,case-sensitive,string,replace\
    \ |>\nIf you need to replace one character by another in a string, then consider\
    \ a regular expression. For example:\n<code>\n>> \"abA\".gsub(/(a)/, \"\\L$1\"\
    )\n=> \"aB\"\n</code>\n<|/ a dscore=3 |>\n<| a |>\n<code>", "  message.each_char\
    \ do |char|\n    if char >= 'A' && char <= 'Z'\n      char.upcase!\n    end\n\
    \  end\n  message.gsub(/[AEIOUY]/i) { |vowel| alphabet.index(vowel) + 2 }\nend\n\
    </code>\nThe alphabet can be stored in a constant somewhere, or it can be generated\
    \ on-the-fly, like so:\n<code>\nalphabet = ('A'..'Z').to_a + ('a'..'z').to_a +\
    \ (0..9).to_a\n</code>\n<|/ a |>\n<| c |>\nThe alphabet = ('A'..'Z').to_a + ('a'..'z').to_a\
    \ + (0..9).to_a part is a bit weird for me but I understand now. Thanks for the\
    \ great answer.\n<|/ c |>\n<| c |>\nI added a note about that to the answer.\n\
    <|/ c |>\n<| a |>\n<code>", "    # Write your code here. \n    return message\n\
    \    ", "  message = \"A\".downcase + message.upcase.split(//).collect { |letter|\
    \ letter.chr }.join\n  message = message.gsub(/[aeiouyAEIOUY]/i, 'A')\n  message\
    \ = message.gsub(/[aeiouyAEIOUY]/i, 'E')\n  message = message.gsub(/[aeiouyAEIOUY]/i,\
    \ 'I')\n  message = message.gsub(/[aeiouyAEIOUY]/i, 'O')\n  message = message.gsub(/[aeiouyAEIOUY]/i,\
    \ 'U')\n  message = message.gsub(/[aeiouyAEIOUY]/i, 'Y')\n  message = message.gsub(/[aeiouyAEIOUY]/i,\
    \ 'a')\n  message = message.gsub(/[aeiouyAEIOUY]/i, 'e')\n  message = message.gsub(/[aeiouyAEIOUY]/i,\
    \ 'i')\n  message = message.gsub(/[aeiouyAEIOUY]/i, 'o')\n  message = message.gsub(/[aeiouyAEIOUY]/i,\
    \ 'u')\n  message = message.gsub(/[aeiouyAEIOUY]/i, 'y')\n  message = message.gsub(/[aeiouyAEIOUY]/i,\
    \ 'A')\n  message = message.gsub(/[aeiouyAEIOUY]/i, 'E')\n  message = message.gsub(/[aeiouyAEIOUY]/i,\
    \ 'I')\n  message = message.gsub(/[aeiouyAEIOUY]/i, 'O')\n  message = message.gsub(/[aeiouyAEIOUY]/i,\
    \ 'U')\n  message = message.gsub(/[aeiouyAEIOUY]/i, 'Y')\n  message = message.gsub(/[aeiouyAEIOUY]/i,\
    \ 'a')\n  message = message.gsub(/[aeiouyAEIOUY]/i, 'e')\n  message = message.gsub(/[aeiouyAEIOUY]/i,\
    \ 'i')\n  message = message.gsub(/[aeiouyAEIOUY]/i, 'o')\n  message = message.gsub(/[aeiouyAEIOUY]/i,\
    \ 'u')\n  message = message.gsub(/[aeiouyAEIOUY]/i, 'y')\n  message = message.gsub(/[aeiouyAEIOUY]/i,\
    \ 'A')\n  message = message.gsub(/[aeiouyAEIOUY]/i", "    # TODO\nend", "  new_message\
    \ = \"\"\n  letter = \"a\"\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"\
    y\"]\n  for i in message\n    if letter.upcase == i\n      letter = \"b\"\n  \
    \  else \n      letter = \"a\"\n  end\n  vowels.each do |vowel|\n    index = message.index(vowel)\n\
    \    if index > 0\n      new_message << vowels[index-1]\n    else \n      new_message\
    \ << vowel\n    end\n  end\n  return new_message\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThank you for your help. I really appreciate it.\n<|/ c |>\n<|\
    \ c |>\nWhat if the vowels come in any order? For example, \"aas\" => \"aab\"\n\
    <|/ c |>\n<| a dscore=1 |>\nRuby 1.9.3 or later\n<code>", "  new_message = ''\n\
    \  \n  message.each_char do |letter|\n    if letter.upcase == letter\n      new_message\
    \ << letter.upcase\n    elsif letter.downcase == letter\n      new_message <<\
    \ letter.downcase\n    elsif letter.upcase == letter.downcase\n      new_message\
    \ << letter\n    else\n      new_message << letter.upcase\n    end\n  end\n  new_message\n\
    end\n</cell>\n<code language=julia-1.5>", "    message.gsub!(/[a-z]/) do |i|\n\
    \        alphabet[alphabet.index(i).succ].to_s + i.succ\n    end\n    message.gsub!(/[aeiou]/)\
    \ do |i|\n        alphabet[alphabet.index(i).succ].to_s + i.succ\n    end\n  \
    \  message.gsub!(/[AEIOU]/) do |i|\n        alphabet[alphabet.index(i).succ].to_s\
    \ + i.succ\n    end\n    message.gsub!(/[aeiouAEIOU]/) do |i|\n        alphabet[alphabet.index(i).succ].to_s\
    \ + i.succ\n    end\n    message.gsub!(/[aeiouAEIOU]/) do |i|\n        alphabet[alphabet.index(i).succ].to_s\
    \ + i.succ\n    end\n    message.gsub!(/[aeiou]/) do |i|\n        alphabet[alphabet.index(i).succ].to_s\
    \ + i.succ\n    end\n    message.gsub!(/[AEIOU]/) do |i|\n        alphabet[alphabet.index(i).succ].to_s\
    \ + i.succ\n    end\n    message.gsub!(/[aeiouAEIOU]/) do |i|\n        alphabet[alphabet.index(i).succ].to_s\
    \ + i.succ\n    end\n    message.gsub!(/[aeiouAEIOU]/) do |i|\n        alphabet[alphabet.index(i).succ].to_s\
    \ + i.succ\n    end\n    message.gsub!(/[aeiouAEIOU]/) do |i|\n        alphabet[alphabet.index(i).succ].to_s\
    \ + i.succ\n    end\n    message.gsub!(/[aeiou]/) do |i|\n        alphabet[alphabet.index(i).succ].to_s\
    \ + i.succ\n    end\n    message.gsub!(/[AEIOU]/) do |i|\n        alphabet[alphabet.index(i).succ].to_s\
    \ + i.succ\n    end\n    message.gsub!(/[aeiouAEIOU]/) do |i|\n        alphabet[alphabet.index(i).succ].to_s\
    \ + i.succ\n    end\n    message.gsub!(/[aeiouAEIOU]/) do |i|\n        alphabet[alphabet.index(i).succ].to_s\
    \ + i.succ\n    end\n    message.gsub!(/[aeiouAEIOU]/) do |i|\n        alphabet[alphabet.index(i).succ].to_s\
    \ + i.succ\n    end\n    message.gsub!(/[", "  message.chars.each_with_index.inject([])\
    \ do |result, ((letter, place), index)|\n    \n    if index > 0\n      letter_2\
    \ = message.chars[index-1]\n    else\n      letter_2 = nil\n    end\n    \n  \
    \  result << case letter\n        when 'A' then 'a' \n        when 'B' then 'b'\n\
    \        when 'C' then 'c'\n        when 'D' then 'd'\n        when 'E' then 'e'\n\
    \        when 'F' then 'f'\n        when 'G' then 'g'\n        when 'H' then 'h'\n\
    \        when 'I' then 'i'\n        when 'J' then 'j'\n        when 'K' then 'k'\n\
    \        when 'L' then 'l'\n        when 'M' then 'm'\n        when 'N' then 'n'\n\
    \        when 'O' then 'o'\n        when 'P' then 'p'\n        when 'Q' then 'q'\n\
    \        when 'R' then 'r'\n        when 'S' then 's'\n        when 'T' then 't'\n\
    \        when 'U' then 'u'\n        when 'V' then 'v'\n        when 'W' then 'w'\n\
    \        when 'X' then 'x'\n        when 'Y' then 'y'\n        when 'Z' then 'z'\n\
    \        when 'a' then 'A'\n        when 'b' then 'B'\n        when 'c' then 'C'\n\
    \        when 'd' then 'D'\n        when 'e' then 'E'\n        when 'f' then 'F'\n\
    \        when 'g' then 'G'\n        when 'h' then 'H'\n        when 'i' then 'I'\n\
    \        when 'j' then 'J'\n        when 'k' then 'K'\n        when 'l' then 'L'\n\
    \        when 'm' then 'M'\n        when 'n' then 'N'\n        when 'o' then 'O'\n\
    \        when 'p' then 'P'\n        when 'q' then 'Q'\n        when 'r' then 'R'\n\
    \        when 's' then 'S'\n        when 't' then 'T'\n        when 'u' then 'U'\n\
    \        when 'v", "  \n  words = message.split\n  \n  result = \"\"\n  \n  #\
    \ Swap all letters case\n  words.each do |word|\n    word.chars.each do |char|\n\
    \      result.concat(word.chars.reverse.find {|c| c.eql? char}.upcase + char)\n\
    \    end\n  end\n  \n  \n  # Replace vowels\n  words.each do |word|\n    word.chars.each\
    \ do |char|\n      result.concat(word.chars.reverse.find {|c| c.eql? char}.to_s\
    \ + char.upcase)\n    end\n  end\n  \n  \n  # Return the result\n  result\nend\n\
    </code></pre>\n        </section>\n        <section>\n          <h1>Exercise</h1>\n\
    \          <h3>What have you learned?</h3>\n          <ul>\n            <li>Ruby\
    \ basics</li>\n            <li>Ruby loops</li>\n            <li>Ruby iterators</li>\n\
    \            <li>Ruby blocks</li>\n            <li>Ruby method chaining</li>\n\
    \            <li>Ruby variable types</li>\n            <li>Ruby strings</li>\n\
    \            <li>Ruby arrays</li>\n            <li>Ruby hashes</li>\n        \
    \  </ul>\n        </section>\n        <section>\n          <h1>Exercise</h1>\n\
    \          <h3>How would you solve the problem using Ruby loops?</h3>\n      \
    \    <pre><code data-trim class=\"ruby\"># Write a program that replaces every\
    \ letter in ", "  new_message = ''\n  \n  # Loop through every character in the\
    \ message\n  message.chars.each do |character|\n    # If the character is a vowel\n\
    \    if ['A','E','I','O','U'].include?(character)\n      # Swap case (make sure\
    \ we're not swapping case)\n      new_message += ((message.index(character) +\
    \ 2) % 26).chr\n    else\n      # Keep the current case\n      new_message +=\
    \ character\n    end\n  end\n  \n  # Return the encoded message\n  return new_message\n\
    end", "  letters = message.downcase.scan(/[a-z]/)\n  vowels = message.scan(/[aeiouy]/)\n\
    \  vowels.each do |vowel|\n    index = letters.index(vowel) + 1\n    letters.rotate(index)\n\
    \    letters.unshift(vowel)\n  end\n  letters.flatten!\n  return letters.join\n\
    end", "  message.downcase.split(\" \").map{|char| char.swapcase}.join\nend", " \
    \   # Get the list of letters in the english alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    # Get the list of vowels in the english alphabet\n    vowels = 'aeiou'",
  '    # Write your solution here', "  new_message = message\n  new_message.gsub!\
    \ /[aeiou]/, lambda { |match| match.downcase }\n  new_message.gsub! /[aeiou]/,\
    \ lambda { |match| match.upcase }\n  new_message.gsub! /[aeiou]/, lambda { |match|\
    \ match.reverse }\n  new_message.gsub! /[aeiou]/, lambda { |match| match.chars[match[1..2].to_i]\
    \ }\n  new_message\nend\n</cell>\n<cell>\nencode('this is a test')\n</cell>\n\
    <text>\nPractice\nWrite a function encode_reverse that reverses the encoding of\
    \ a given message.  You may want to use the encode function you wrote.  The test\
    \ cases should pass if you use your encode_reverse function on the encoded message\
    \ and on the decoded message.", "  \nend\n</cell>\n<code language=julia-0.5>",
  "  letters = message.split(//).map(&:downcase).join//.chars\n  vowels = letters.map\
    \ { |c| [c, c.succ.upcase] }.flatten//.sort \n  letters.zip(vowels).each { |(c,v)|\
    \ message.gsub!(c,v) }\n  message\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    You don't need `&:` when passing blocks to `map`, or any method call for that\
    \ matter. The argument can be any object that responds to `:call`. If you are\
    \ using Rails or Ruby 1.9, you can just pass the block to `map`. `letters.map(&:downcase).join//.chars`\
    \ should be `letters.map(&:downcase).join.chars`, otherwise you're just passing\
    \ the method call to the `map` method and `join.chars` is just returning a string.\
    \ `&:downcase` passes a block to `downcase`.\n<|/ c |>\n<| a |>\nHere's my take,\
    \ using the same approach as Daniel suggested and using each_char to iterate over\
    \ the entire string in chunks of two, mapping the characters to their character\
    \ code and then using a nested map to get back to their character.\n<code>\n'test'.each_char.map\
    \ { |ch| [ch.ord, ch] }.map { |a,b| b[1][1] }.join\n=> \"TGST\"\n</code>\n<|/\
    \ a tags=ruby,algorithm dscore=1 |>\n<| c |>\nI like Daniel's answer as it does\
    \ it all in one statement\n<|/ c |>\n<| c |>\nI like it also. Thank you for sharing\
    \ it!\n<|/ c |>\n<| c |>\nNice. I like that `&:downcase` can be passed directly\
    \ to `map` and avoid having to call `downcase` on the result. `'test'.each_char.map\
    \ { |ch| [ch.ord, ch] }.map { |a,b| b[1][1] }.join` would work the same way as\
    \ `'test'.downcase.chars`.\n<|/ c |>\n<| c |>\nGood call! Edited the answer to\
    \ reflect that.\n<|/ c |>\n<| a |>\n<code>", "    message.scan(/./) do |char|\n\
    \        case char\n        when 'a' then 'A'\n        when 'b' then 'B'\n   \
    \     when 'c' then 'C'\n        when 'd' then 'D'\n        when 'e' then 'E'\n\
    \        when 'f' then 'F'\n        when 'g' then 'G'\n        when 'h' then 'H'\n\
    \        when 'i' then 'I'\n        when 'j' then 'J'\n        when 'k' then 'K'\n\
    \        when 'l' then 'L'\n        when 'm' then 'M'\n        when 'n' then 'N'\n\
    \        when 'o' then 'O'\n        when 'p' then 'P'\n        when 'q' then 'Q'\n\
    \        when 'r' then 'R'\n        when 's' then 'S'\n        when 't' then 'T'\n\
    \        when 'u' then 'U'\n        when 'v' then 'V'\n        when 'w' then 'W'\n\
    \        when 'x' then 'X'\n        when 'y' then 'Y'\n        when 'z' then 'Z'\n\
    \        else\n        end\n    end\nend", "    # Your code here\n    vowels =\
    \ \"aeiouAEIOU\"\n    message = message.downcase\n    message = message.split(\"\
    \")\n    message = message.join\n    letter = nil\n    i = 0\n    while i < message.length\n\
    \        letter = message[i].upcase\n        if vowels.include? letter\n     \
    \       letter = vowels[letter]\n            if vowels.count <= vowels.index(letter)\n\
    \                letter = vowels[letter+1]\n            end\n        end\n   \
    \     message[i] = letter\n        i += 1\n    end\n    message.join(\"\")\nend",
  "  result = ''\n  chars = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9']\n\
    \  vowels = ['a','e','i','o','u','y']\n  for i in message\n    char = i.to_s\n\
    \    index = chars.index(char)\n    next_char = chars[index+1]\n    if char =~\
    \ /[aeiouy]/\n      vowel_to_index = vowels.index(next_char)\n      result +=\
    \ chars[vowel_to_index+1]\n    else\n      result += char\n  end\n  result\nend",
  "    message += \"_\"\n    message = message.upcase\n    message = message.downcase\n\
    \    message = message.gsub(/[aeiou]/){|match| match.upcase}\n    message = message.gsub(/[AEIOU]/){|match|\
    \ match.downcase}\n    message = message.gsub(/[aeiou]/){|match| match.upcase}\n\
    \    message = message.gsub(/[AEIOU]/){|match| match.downcase}\n    message =\
    \ message.gsub(/[aeiou]/){|match| match.upcase}\n    message = message.gsub(/[AEIOU]/){|match|\
    \ match.downcase}\n    message = message.gsub(/[aeiou]/){|match| match.upcase}\n\
    \    message = message.gsub(/[AEIOU]/){|match| match.downcase}\n    message =\
    \ message.gsub(/[aeiou]/){|match| match.upcase}\n    message = message.gsub(/[AEIOU]/){|match|\
    \ match.downcase}\n    message = message.gsub(/[aeiou]/){|match| match.upcase}\n\
    \    message = message.gsub(/[AEIOU]/){|match| match.downcase}\n    message =\
    \ message.gsub(/[aeiou]/){|match| match.upcase}\n    message = message.gsub(/[AEIOU]/){|match|\
    \ match.downcase}\n    message = message.gsub(/[aeiou]/){|match| match.upcase}\n\
    \    message = message.gsub(/[AEIOU]/){|match| match.downcase}\n    message =\
    \ message.gsub(/[aeiou]/){|match| match.upcase}\n    message = message.gsub(/[AEIOU]/){|match|\
    \ match.downcase}\n    message = message.gsub(/[aeiou]/){|match| match.upcase}\n\
    \    message = message.gsub(/[AEIOU]/){|match| match.downcase}\n    message =\
    \ message.gsub(/[aeiou]/){|match| match.upcase}\n    message = message.gsub(/[AEIOU]/){|match|\
    \ match.downcase}\n    message = message.gsub(/[aeiou]/){|match| match.upcase}\n\
    \    message = message.gsub(/[AEIOU]/){|match| match.downcase}\n    message =\
    \ message.gsub(/[aeiou]/){|match| match.upcase}\n    message = message.gsub(/[",
  "    vowels = ['a','e','i','o','u']\n    \n    vowel_mapping = {}", "\talphabet\
    \ = ('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z')\n\
    \tvowels = ('a','e','i','o','u')\n\tmessage_new = message.downcase.split(' ')\n\
    \tmessage_new = message_new.map{|element| element.split('').map.with_index{|char,index|\n\
    \t\tif alphabet.include? char\n\t\t\talphabet[alphabet.index(char) + 2]\n\t\t\
    else\n\t\t\tchar\n\t\tend\n\t}}.join\n\tvowels.each {|vowel| \n\t\tmessage_new\
    \ = message_new.gsub(vowel.upcase, vowel.upcase[vowel.index(vowel) + 2])\n\t}\n\
    \treturn message_new\nend", "    message = message.downcase\n    letters = message.chars.to_a\n\
    \    letters.map { |char| char.upcase if char.upcase == 'a' || char.upcase ==\
    \ 'e' || char.upcase == 'i' || char.upcase == 'o' || char.upcase == 'u' }\n  \
    \  letters.each { |letter| letter = letter.next\n        letters.reverse.each\
    \ { |char| char.upcase if char == letter }\n        letters.reverse.each { |char|\
    \ char.downcase if char == letter }\n        letters.reverse.each { |char| char.swapcase\
    \ if char == letter }\n    }\n    message.chars.to_a\nend\n</cell>\n<cell>", " \
    \ result = \"\"\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[1])..alphabet.index(match[2])].join\n\
    \  end\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[2])..alphabet.index(match[1])].join\n\
    \  end\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[1])+1..alphabet.index(match[2])].join\n\
    \  end\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[2])+1..alphabet.index(match[1])].join\n\
    \  end\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[1])+2..alphabet.index(match[2])].join\n\
    \  end\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[2])+2..alphabet.index(match[1])].join\n\
    \  end\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[1])+3..alphabet.index(match[2])].join\n\
    \  end\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[2])+3..alphabet.index(match[1])].join\n\
    \  end\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[1])+4..alphabet.index(match[2])].join\n\
    \  end\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[2])+4..alphabet.index(match[1])].join\n\
    \  end\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[1])+5..alphabet.index(match[2])].join\n\
    \  end\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[2])+5..alphabet.index(match[1])].join\n\
    \  end\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[1])+6..alphabet.index(match[2])].join\n\
    \  end\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[2])+6..alphabet.index(match[1])].join\n\
    \  end\n  message.gsub!(/([aeiou])/) do\n    alphabet[alphabet.index(match[1])+7",
  "  \n  # Create an array of the letters 'A' through 'Z'\n  letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \  \n  # Initialize an array to hold the final encoded message\n  encoded_message\
    \ = ''\n  \n  # Loop over the message \n  message.each_byte do |byte|\n    \n\
    \    # Find a case for the letter\n    case = letters[byte.to_i % 26]\n    \n\
    \    # Find the letter 2 places ahead of that case \n    # in the english alphabet\n\
    \    letter = letters[(byte.to_i / 26)%26]\n    \n    # Add the case and the letter\
    \ \n    encoded_message << case + letter\n  end\n  \n  # Return the encoded message\n\
    \  encoded_message\nend", "  vowels = \"AEIOUYAEIOUY\"\n  message = [message]\
    \ \n  output = []\n  index = 0\n  while index < message.length\n    letter = message[index]\n\
    \    output.push( letter.downcase )\n    index = index + 1\n    if letter != message[index]\n\
    \      index = index + 1\n      letter = message[index]\n    end\n    index =\
    \ index + 1\n    letter = message[index]\n    output.push( letter.gsub(vowels,\
    \ \"AEIOUY\") )\n  end\n  output[0]\nend\n</cell>\n<code language=conda-root-py>",
  "  # Your code here!\n  result = \"\"\n  pos = 1\n  while pos <= message.length\n\
    \    \n    vowels = 'aeiou'\n    if message.slice!(0, pos).downcase == message.slice!(0,\
    \ pos).upcase \n      message =\n      message.slice!(0, pos).downcase\n     \
    \ break\n    end\n  \n    unless vowels.include?(message.slice!(0, pos).downcase)\n\
    \      message =\n      message.slice!(0, pos).downcase\n      break\n    end\n\
    \  \n    pos = pos + 1\n    vowels = 'aeiou'\n  end\n  \n  vowels = 'aeiou'\n\
    \  pos += 1\n  \n  while pos < message.length\n    if message.slice!(0, pos).downcase\
    \ == message.slice!(0, pos).upcase \n      message =\n      message.slice!(0,\
    \ pos).downcase\n      break\n    end\n    unless vowels.include?(message.slice!(0,\
    \ pos).downcase)\n      message =\n      message.slice!(0, pos).downcase\n   \
    \   break\n    end\n    pos = pos + 1\n    vowels = 'aeiou'\n  end\n  \n  unless\
    \ vowels.include?(message.slice!(0, pos).downcase)\n    message =\n    message.slice!(0,\
    \ pos).downcase\n    break\n  end\n  \n  vowels = 'aeiou'\n  pos += 1\n  \n  while\
    \ pos < message.length\n    if message.slice!(0, pos).downcase == message.slice!(0,\
    \ pos).upcase \n      message =\n      message.slice!(0, pos).downcase\n     \
    \ break\n    end\n    unless vowels.include?(message.slice!(0, pos).downcase)\n\
    \      message =\n      message.slice!(0, pos).downcase\n      break\n    end\n\
    \    pos = pos + 1\n    vowels = 'aeiou'\n  end\n  \n  unless vowels.include?(message.slice!(0,\
    \ pos).downcase)\n    message =\n    message.slice!(0, pos).downcase\n    break\n\
    \  end\n  \n  vowels = 'aeiou'\n  pos += 1\n  \n  while pos < message.length\n\
    \    if message.slice!(0, pos).downcase == message.slice!(0, pos).upcase \n  \
    \    message =\n      message.slice!(0, pos).downcase\n      break\n    end\n\
    \    unless vowels.include?(message.slice!(0, pos).downcase)\n      message =\n\
    \      message.slice!(0, pos).downcase\n      break\n", "    vowels = {'a', 'e',\
    \ 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    return ''.join([\n        vowels.get(\n\
    \            letter,\n            'Z' if message.startswith(letter) else letter\n\
    \        ) for letter in message\n    ])", "  message = message.downcase.gsub(/[a-z]/,\
    \ lambda letter|\n    [letter[(letter.length-1)..1].upcase, letter[0..2].upcase])\n\
    \  message.gsub(/[aeiou]/) do |vowel|\n    message.index(vowel) + 1\n  end.join\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThe first solution gave the wrong result for\
    \ input of 'I like cake'. It returned 'iIlilililillakcakke'.\n<|/ c |>\n<| c |>\n\
    Oops, you're right. Fixed. Thanks for the catch.\n<|/ c |>\n<| c |>\nThanks for\
    \ this. I'm trying this out now. I'll let you know if it works.\n<|/ c |>\n<|\
    \ c |>\nOkay I'm still working on this. I understand what you're doing in one\
    \ line. I don't understand how it's doing it but I'm looking into it. My head\
    \ is spinning. I'll let you know if it works.\n<|/ c |>\n<| c |>\nOkay I figured\
    \ it out. I just had to change the order of the statements. Thanks for the help\
    \ man.\n<|/ c |>\n<| a tags=ruby |>\nI'm going to use the Ruby 1.9.2 regex library\
    \ to do this for you.  \n<code>\nrequire \"rubygems\"\nrequire \"rexml/document\"",
  "  message\n    .gsub!(/([a-z])/) {|match| $1.upcase }\n    .gsub!(/[aeiou]/) {|match|\
    \ 'a'.upcase }\n    .gsub!(/([aeiou])/) {|match| $2.upcase }\nend", "    # Your\
    \ code here\n  \nend\n</cell>\n<text>\nTest your code\nRun the cell below to test\
    \ your code.", "    message.split(\"\")\n    swapped_message = message.gsub(/[a-z]/){|s|\
    \ s.downcase }\n    vowels = (\"aeiou\".split('')) - 'aeiou'.gsub(/e/, '').gsub(/i/,\
    \ 'o').gsub(/u/, 'a')\n    vowels.each{|vowel| swapped_message =~ /#{vowel}/i\
    \ ? \"#{vowel}#{vowel}\" : \"\" }\n    swapped_message.gsub(/[aeiou]/){|s| s.upcase\
    \ }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYour second method doesn't work\
    \ for me. I get the error: TypeError: no implicit conversion of Regexp into Integer\n\
    <|/ c |>\n<| c |>\nIt does for me, using Ruby 2.1.4p125.\n<|/ c |>\n<| c |>\n\
    Yes it does for me too, and I didn't realize that Ruby 2.x required an argument\
    \ for gsub and I was using Ruby 1.9.3, sorry for all the confusion.\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>", "    letter_pos = nil\n    vowel_pos = nil\n    new_message\
    \ = nil\n    new_message_str = nil\n    letters = message.split(//).collect{|character|\
    \ character[0].to_s}\n    vowels = message.split(//).collect{|character| character[1].to_s}\n\
    \    letters.each_with_index do |letter, index|\n      if letter =~ /[aeiou]/\n\
    \        letters[index] = letter.upcase\n      else\n        if index > 0\n  \
    \        letter_pos = letters.index(letter)\n          vowel_pos = vowels.index(letters[index-1])\n\
    \          new_message =  new_message_str\n          if letter_pos == vowel_pos\n\
    \            new_message = new_message.upcase\n          else\n            new_message\
    \ =  new_message.downcase\n          end\n          new_message += letter.downcase\n\
    \        end\n      end\n    end\n    new_message = new_message\n  end", "   \
    \ message.downcase!\n    \n    message.chars.each_with_index do |char, index|\n\
    \        # Ignore lower case letters\n        if char.upcase == char\n       \
    \     next\n        end\n        \n        char.downcase!\n        \n        #\
    \ Swap the case\n        char.chars.each_with_index do |char2, index2|\n     \
    \       if char2.upcase == char2\n                char2.upcase!\n            else\n\
    \                char2.downcase!\n            end\n        end\n    end\n    \n\
    \    # Make another pass that replaces all vowels \n    # with the letter that\
    \ appears 2 places ahead of \n    # it\n    message.chars.each_with_index do |char,\
    \ index|\n        # Ignore lower case letters\n        if char.upcase == char\n\
    \            next\n        end\n        \n        char.downcase!\n        \n \
    \       # Replace the vowel\n        if char == 'a' || char == 'e' || char ==\
    \ 'i'\n            char = 'o'\n        elsif char == 'o' || char == 'u'\n    \
    \        char = 'a'\n        elsif char == 'e' || char == 'i'\n            char\
    \ = 'o'\n        end\n        \n    end\n    \n    return message\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| a dscore=0 tags=ruby,string |>\nI guess you are\
    \ looking for something like this:\n<code>", "    message.chars.each do |c|\n\
    \        next if c.downcase != 'a'\n        next if c.downcase == 'i'\n      \
    \  next if c.downcase == 'o'\n        next if c.downcase == 'u'\n        next\
    \ if c.downcase == 'y'\n        next if c.downcase == 'i'\n        next if c.downcase\
    \ == 'n'\n        next if c.downcase == 'k'\n        next if c.downcase == 'g'\n\
    \        next if c.downcase == 'c'\n        next if c.downcase == 'm'\n      \
    \  next if c.downcase == 's'\n        next if c.downcase == 'p'\n        next\
    \ if c.downcase == 'o'\n        next if c.downcase == 'i'\n        next if c.downcase\
    \ == 'r'\n        next if c.downcase == 'e'\n        next if c.downcase == 't'\n\
    \        next if c.downcase == 'y'\n        next if c.downcase == 'u'\n      \
    \  next if c.downcase == 'v'\n        next if c.downcase == 'w'\n        next\
    \ if c.downcase == 'r'\n        next if c.downcase == 'p'\n        next if c.downcase\
    \ == 'o'\n        next if c.downcase == 'r'\n        next if c.downcase == 'p'\n\
    \        next if c.downcase == 'o'\n        next if c.downcase == 'r'\n      \
    \  next if c.downcase == 'e'\n        next if c.downcase == 't'\n        next\
    \ if c.downcase == 'y'\n        next if c.downcase == 'i'\n        next if c.downcase\
    \ == 'r'\n        next if c.downcase == 'a'\n        next if c.downcase == 'd'\n\
    \        next if c.downcase == 'k'\n        next if c.downcase == 'g'\n      \
    \  next if c.downcase == 'f'\n        next if c.downcase == 'l'\n        next\
    \ if c.downcase == 'o'\n        next if c.downcase == 's'\n        next if c.downcase\
    \ == 't'\n        next if c.downcase == 'w'\n        next if c.downcase == 'p'\n\
    \        next if c.downcase == 'o'\n        next if c.downcase == 'r'\n      \
    \  next if c.downcase == 'a'\n        next if c.downcase == 'd'\n        next\
    \ if c.downcase == 'k'\n        next if c.downcase == 'g'\n        next if c.downcase\
    \ == 'f'\n        next if c.downcase == 'l'\n", "  letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  message.upcase!\n  letters.split(\"\").each do |letter|\n    next if message.index(letter)\
    \ == nil\n    pos = message.index(letter)\n    message.gsub(letter) { |match|\
    \ letters[pos + match.size] }\n  end\n  message\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a dscore=2 |>\nHow about this:\n<code>", "  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  alphabet = alphabet[0..25] + alphabet[26..40] + alphabet[41..57] + alphabet[58..65]\
    \ + alphabet[66..70]\n  message = (message[0]).downcase + message.sub(/[aeiou]/)\
    \ { |c| alphabet.index(c) }\n  message.to_s\nend\n</cell>\n<cell>", "  message\
    \ = message.downcase\n  message = message.gsub(/[aeiou]/, '\\1\\1')\n  message\
    \ = message.gsub(/[aeiou]/, '\\1\\1')\n  message = message.gsub(/o/, 'a')\n  message\
    \ = message.gsub(/e/, 'e')\n  message = message.gsub(/u/, 'u')\n  message = message.gsub(/n/,\
    \ 'n')\n  message = message.gsub(/r/, 'r')\n  message = message.gsub(/l/, 'l')\n\
    \  message = message.gsub(/s/, 's')\n  message = message.gsub(/t/, 't')\n  message\
    \ = message.gsub(/c/, 'k')\n  message = message.gsub(/d/, 'h')\n  message = message.gsub(/m/,\
    \ 'g')\n  message = message.gsub(/y/, 'j')\n  message = message.gsub(/p/, 'f')\n\
    \  message = message.gsub(/m/, 'g')\n  message = message.gsub(/y/, 'j')\n  message\
    \ = message.gsub(/p/, 'f')\n  message = message.gsub(/q/, 'y')\n  message = message.gsub(/p/,\
    \ 'f')\n  message = message.gsub(/k/, 'k')\n  message = message.gsub(/q/, 'y')\n\
    \  message = message.gsub(/p/, 'f')\n  message = message.gsub(/m/, 'g')\n  message\
    \ = message.gsub(/y/, 'j')\n  message = message.gsub(/p/, 'f')\n  message = message.gsub(/m/,\
    \ 'g')\n  message = message.gsub(/y/, 'j')\n  message = message.gsub(/p/, 'f')\n\
    \  message = message.gsub(/m/, 'g')\n  message = message.gsub(/y/, 'j')\n  message\
    \ = message.gsub(/p/, 'f')\n  message = message.gsub(/m/, 'g')\n  message = message.gsub(/y/,\
    \ 'j')\n  message = message.gsub(/p/, 'f')\n  message = message.gsub(/m/, 'g')\n\
    \  message = message.gsub(/y/, 'j')\n  message = message.gsub(/p/, 'f')\n  message\
    \ = message.gsub(/m/, 'g')\n  message = message.gsub(/y/, 'j')\n  message = message.gsub(/p/,\
    \ 'f')\n  message = message.gsub(/m/, 'g')\n  message = message.gsub(/y/, 'j')\n\
    \  message = message.gsub(/p/, 'f')\n  message = message.gsub(/m/, 'g')\n  message\
    \ = message.gsub(/y/, 'j')\n  message = message.g", '  message =~ /[a-zA-Z]/',
  "  message = [...message] #convert message to list \n  new_message = \"\"\n  \n\
    \  for i in message\n    if i !~ /^[A-Za-z]+$/ #skip if letter\n      new_message\
    \ += i #append to new message\n    end\n  end\n  \n  new_message = new_message.split(//)\
    \ #split string to array\n  \n  for i in new_message\n    swap_case(i) #swap case\
    \ for first letter\n  end\n  \n  for i in new_message\n    swap_vowels(i)\n  end\n\
    \  \n  for i in new_message\n    add_2_places(i)\n  end\n  \n  return new_message.join(\"\
    \")\nend\n</cell>\n<code language=julia-1.0>\nencode(encode(encode(\"This is a\
    \ message\")))\n</cell>\n<code language=julia-1.0>", "    string.gsub(message)\
    \ do |str|\n        letters = string.split(str)\n        letters.each do |letter|\n\
    \            pos = string.rindex(letter, str) + 2\n            if string.index(\"\
    AEIOUYaeiouy\", letter, pos)\n                letters[letters.index(letter)] =\
    \ string.at(pos, str.size)\n            end\n        end\n        letters.join(\"\
    \")\n    end\nend\n</cell>\n<text>\nExercise: Write a function that takes a message,\
    \ and encodes in such a way that it swaps case of all letters, replaces all vowels\
    \ in the message with the letter that appears 2 places ahead of that vowel in\
    \ the english alphabet. Assume only letters.", "    message.downcase!\n    message.gsub!(/([aeiou])/){|m|\
    \ m.upcase + m.downcase}\n    message.gsub!(/([aeiou])/){|m| 'a'.ord.upcase +\
    \ m.ord.to_sym}\n    message.each_byte{|c| putc c }\nend\n</code>\n<|/ a tags=ruby,string,encoding\
    \ |>\n<| c |>\nThis code doesn't work with uppercase letters. Uppercase letters\
    \ map to themselves, not uppercase letters.\n<|/ c |>\n<| c |>\nAh, I didn't think\
    \ about that. I've edited my answer to use a regex in the second gsub to fix that.\n\
    <|/ c |>\n<| c |>\nYou don't have to downcase it just to uppercase it again. `string.gsub!(/([aeiou])/){|m|\
    \ m.upcase + m.downcase}` does the trick.\n<|/ c |>\n<| c |>\n: Thanks, that's\
    \ a much better way to do it. I was thinking of something more clever, like converting\
    \ them to ascii numbers and shifting that by 2, and using that as an offset but\
    \ that doesn't work either.\n<|/ c |>\n<| c |>\nI like the answer from Eli Barzilay\
    \ as it makes the most sense to me, and I like his use of `each_char` to avoid\
    \ creating intermediate strings.\n<|/ c |>\n<| a tags=ruby,string,encoding |>\n\
    <code>", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    alphabet2 = \"AEIOU\"\
    \n    message_length = len(message)\n    ans = \"\"\n    \n    for i in range(message_length):\n\
    \        current = message[i]\n        index = alphabet.find(current)\n      \
    \  if index != -1:\n            new_index = index\n            if (i + 1) != message_length:\
    \ # Don't swap last character\n                next_index = alphabet2.find(message[i+1])\n\
    \                if next_index != -1:\n                    new_index = index +\
    \ next_index + 1\n            ans = ans + alphabet[new_index]\n        else:\n\
    \            ans = ans + current\n    return ans", "  letters = message.split('')\n\
    \  new_letters = []\n  \n  for i in letters\n    replacement = nil\n    \n   \
    \ # See if this is a vowel\n    if i =~ /[AEIOU]/i\n      # Get index of vowel\
    \ in letters \n      index_of_vowel = $&\n      # Get letter in letters 2 places\
    \ ahead\n      next_letter = letters[index_of_vowel + 1]\n      # See if next_letter\
    \ is a vowel\n      if next_letter =~ /[AEIOU]/i\n        replacement = next_letter\n\
    \      end\n    end\n    \n    # No vowel found so just add letter \n    if replacement.nil?\n\
    \      new_letters << i\n    end\n    \n    # Add replacement to new_letters\n\
    \    if replacement.nil?\n      new_letters << replacement\n    end\n  end\n \
    \ \n  # Join letters back together \n  return new_letters.join('')\nend", "  message.upcase!\n\
    \  message.gsub!(/a/, 't')\n  message.gsub!(/e/, 's')\n  message.gsub!(/i/, 'k')\n\
    \  message.gsub!(/o/, 'g')\n  message.gsub!(/u/, 'f')\n  message.gsub!(/y/, 'm')\n\
    \  message.gsub!(/[aeiou]/, 'y')\n  message.gsub!(/[aeiou]/, 'y')\n  message.gsub!(/[AEIOU]/,\
    \ 'A')\n  message.gsub!(/[AEIOU]/, 'A')\n  message.gsub!(/[AEIOU]/, 'A')\n  message.gsub!(/[aeiou]/,\
    \ 'A')\n  message.gsub!(/[aeiou]/, 'A')\n  message.gsub!(/[AEIOU]/, 'a')\n  message.gsub!(/[AEIOU]/,\
    \ 'a')\n  message.gsub!(/[AEIOU]/, 'a')\n  message.gsub!(/[aeiou]/, 'a')\n  message.gsub!(/[aeiou]/,\
    \ 'a')\n  message.gsub!(/[AEIOU]/, 'A')\n  message.gsub!(/[AEIOU]/, 'A')\n  message.gsub!(/[AEIOU]/,\
    \ 'A')\n  message.gsub!(/[aeiou]/, 'A')\n  message.gsub!(/[aeiou]/, 'A')\n  message.gsub!(/[AEIOU]/,\
    \ 'a')\n  message.gsub!(/[AEIOU]/, 'a')\n  message.gsub!(/[AEIOU]/, 'a')\n  message.gsub!(/[aeiou]/,\
    \ 'A')\n  message.gsub!(/[aeiou]/, 'A')\n  message.gsub!(/[AEIOU]/, 'a')\n  message.gsub!(/[AEIOU]/,\
    \ 'a')\n  message.gsub!(/[AEIOU]/, 'a')\n  message.gsub!(/[aeiou]/, 'a')\n  message.gsub!(/[aeiou]/,\
    \ 'a')\n  message.gsub!(/[AEIOU]/, 'A')\n  message.gsub!(/[AEIOU]/, 'A')\n  message.gsub!(/[AEIOU]/,\
    \ 'A')\n  message.gsub!(/[aeiou]/, 'A')\n  message.gsub!(", "    message.upcase!\n\
    \    message.downcase!\n    message.gsub!(\"a\", \"z\") \n    message.gsub!(\"\
    e\", \"z\")\n    message.gsub!(\"i\", \"z\")\n    message.gsub!(\"o\", \"z\")\n\
    \    message.gsub!(\"u\", \"z\")\n    message.gsub!(\"A\", \"Z\") \n    message.gsub!(\"\
    E\", \"Z\")\n    message.gsub!(\"I\", \"Z\")\n    message.gsub!(\"O\", \"Z\")\n\
    \    message.gsub!(\"U\", \"Z\")\n    message.gsub!(\"a\", \"A\") \n    message.gsub!(\"\
    e\", \"E\") \n    message.gsub!(\"i\", \"I\") \n    message.gsub!(\"o\", \"O\"\
    ) \n    message.gsub!(\"u\", \"U\") \n    message.gsub!(\"A\", \"a\") \n    message.gsub!(\"\
    E\", \"e\") \n    message.gsub!(\"I\", \"i\") \n    message.gsub!(\"O\", \"o\"\
    ) \n    message.gsub!(\"U\", \"u\")\n    message.tr!(\"aeiouAEIOU\", \"z\")\n\
    \    message.tr!(\"AEIOUaeiou\", \"A\")\n    message.tr!(\"aeiouAEIOU\", \"A\"\
    )\n    message.tr!(\"AEIOUaeiou\", \"A\")\n    message.tr!(\"aeiouAEIOU\", \"\
    A\")\n    message.tr!(\"aeiouAEIOU\", \"A\")\n    message.tr!(\"aeiouAEIOU\",\
    \ \"A\")\n    message.tr!(\"AEIOUaeiou\", \"A\")\n    message.tr!(\"AEIOUaeiou\"\
    , \"A\")\n    message.tr!(\"aeiouAEIOU\", \"A\")\n    message.tr!(\"AEIOUaeiou\"\
    , \"A\")\n    message.tr!(\"aeiouAEIOU\", \"A\")\n    message.tr!(\"AEIOUaeiou\"\
    , \"A\")\n    message.tr!(\"aeiouAEIOU\", \"A\")\n    message.tr!(\"AEIOUaeiou\"\
    , \"A\")\n    message.tr!(\"aeiouAEIOU\", \"A\")\n    message.tr!(\"AEIOUaeiou\"\
    , \"A\")\n    message.tr!(\"aeiouAEIOU\", \"A\")\n    message.tr!(\"aeiouAEIOU\"\
    , \"A\")\n    message.tr!(\"aeiouAEIOU\", \"A\")\n    message.tr!(\"AE", "  vowels\
    \ = [:a, :e, :i, :o, :u]\n  message.each_byte do |byte|\n    byte.upcase if vowels.include?(byte)\n\
    \    byte + vowels.count(byte).to_s.rjust(3, '0')\n  end\nend", "  letters = message\n\
    \  letters.downcase! \n  letters.gsub(/[aeiou]/) { |vowel| alphabet[alphabet.index(vowel)\
    \ + 1] }\n  letters.gsub(/[aeiou]/) { |vowel| alphabet[alphabet.index(vowel) +\
    \ 1] } \n  letters\nend\n</code>\nI tested the code above and it works for both\
    \ English and Spanish messages.\nI did some quick benchmarking, and it seems my\
    \ method runs faster than the method in the other answer with a similar input\
    \ size.\n<|/ a dscore=2 tags=ruby |>\n<| a |>\nI came up with something like this:\n\
    <code>", "  new_message = ''\n  alphabet_to_char = {}\n  alphabet_to_char[' ']\
    \ = 't'\n  alphabet_to_char['!'] = 's'\n  alphabet_to_char['\"'] = 'h'\n  alphabet_to_char['#']\
    \ = 'a'\n  alphabet_to_char['$'] = 'd'\n  alphabet_to_char['%'] = 'g'\n  alphabet_to_char['&']\
    \ = 'y'\n  alphabet_to_char['('] = 'w'\n  alphabet_to_char[')'] = 'k'\n  alphabet_to_char['*']\
    \ = 's'\n  alphabet_to_char['+'] = 'z'\n  alphabet_to_char[':'] = 'c'\n  alphabet_to_char['-']\
    \ = 'm'\n  alphabet_to_char['.'] = 'b'\n  alphabet_to_char['/'] = 'o'\n  alphabet_to_char['0']\
    \ = 'f'\n  alphabet_to_char['1'] = 'd'\n  alphabet_to_char['2'] = 'c'\n  alphabet_to_char['3']\
    \ = 'e'\n  alphabet_to_char['4'] = 'a'\n  alphabet_to_char['5'] = 'h'\n  alphabet_to_char['6']\
    \ = 'o'\n  alphabet_to_char['7'] = 'n'\n  alphabet_to_char['8'] = 'o'\n  alphabet_to_char['9']\
    \ = 'r'\n  alphabet_to_char['a'] = 'b'\n  alphabet_to_char['b'] = 'd'\n  alphabet_to_char['c']\
    \ = 'f'\n  alphabet_to_char['d'] = 'g'\n  alphabet_to_char['e'] = 'h'\n  alphabet_to_char['f']\
    \ = 'i'\n  alphabet_to_char['g'] = 'j'\n  alphabet_to_char['h'] = 'k'\n  alphabet_to_char['i']\
    \ = 'l'\n  alphabet_to_char['j'] = 'm'\n  alphabet_to_char['k'] = 'o'\n  alphabet_to_char['l']\
    \ = 'p'\n  alphabet_to_char['m'] = 'q'\n  alphabet_to_char['n'] = 'r'\n  alphabet_to_char['o']\
    \ = 's'\n  alphabet_to_char['p'] = 't'\n  alphabet_to_char['q'] = 'u'\n  alphabet_to_char['r']\
    \ = 'v'\n  alphabet_to_char['s'] = 'w'\n  alphabet_to_char['t'] = 'x'\n  alphabet_to_char['u']\
    \ = 'y'\n  alphabet_to_char['v'] = 'z'\n  alphabet_to_char['w'] = 'a'", "  vowels\
    \ = %w[a e i o u]\n  result = message.gsub(/(.)/) { |x| vowels.index x.upcase\
    \ }\n  result + result.gsub(/([aeiou])\\1/) {|y| vowels[vowels.index(y) + 1..-1]\
    \ }.\n  tr('aeiouAEIOU', 'AEIOU')\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ dscore=1 |>\n<| c |>\nHow would you modify this to include non-ASCII vowels?\n\
    <|/ c |>\n<| c |>\n: It's not necessary to add them - you can just add them to\
    \ the list that `%w` returns. The only thing to do to make sure you get an alphabetic\
    \ sort is to make sure you append a character at the end. I'll edit my answer\
    \ in a minute.\n<|/ c |>\n<| c |>\nThat was quick! Now I see what you did there\
    \ with your `.gsub` method. Thanks.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails dscore=1\
    \ |>\n<code>\nrequire 'set'", "  \n  # Replace all vowels in the message with\
    \ the letter that appears 2 \n  # places ahead of the vowel. \n  message_array\
    \ = message.downcase.split(//)\n  new_message_array = []\n  vowel = 'a'\n  count\
    \ = 0\n  \n  new_message_array.push(*message_array)\n  \n  message_array.each\
    \ do |word|\n    count += 1\n    \n    if word.include?(vowel)\n      new_message_array.pop\
    \ \n      \n      new_message_array << word.gsub(vowel, vowel.insert(count, vowel))\n\
    \    end\n  end\n  \n  new_message_array.join('')\nend", "  message = message.dup\n\
    \  message.tr!('aeiouAEIOU', 'AEIOU')\n  message.gsub(/[AEIOUaeiou]/) {|vowel|\n\
    \    (vowel.succ << 2) == vowel ? \n      vowel.to_s.upcase : vowel.to_s.downcase\n\
    \  }\n  message\nend", "  result = ''\n  alphabet_counts = {}\n  message.each_char.with_index\
    \ do |c, i|\n    alphabet_counts[c] = alphabet_counts[c] ||= 0\n    alphabet_counts[c]\
    \ += 1 if i%2\n    result << alphabet_counts[c].zero? ? c : \n      english_alphabet[alphabet_counts[c]-1]\n\
    \  end\n  result\nend\n</cell>\n<text>\nQuestion 9: Write a function that takes\
    \ in a message, and encodes in such a way that it swaps case of all letters in\
    \ the message except for those that appear in a provided list of special characters.\
    \ \nUse your encode function from Question 8. \nAssume only letters. \nExample:\n\
    >>> encode('This message should NOT get encoded', \"~!@#$%^&*()_+=-[]\\\\;',./<>?;\"\
    )\n'ThsKsCa MsGuEeRrBnG'", "  newMessage = ''\n  message.each do |letter|\n  \
    \  letter = letter.downcase\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    vowels.each\
    \ do |vowel|\n      if (letter == vowel) && (newMessage == \"\")\n        newMessage\
    \ += vowel\n      end\n      if (letter == vowel) && (newMessage != \"\")\n  \
    \      newMessage += vowel.upcase + letter.upcase\n      end\n    end\n  end\n\
    \  newMessage\nend\n</code>\nThis code is not elegant and could be written better.\
    \  It should work, but I didn't test it.\n<|/ a dscore=0 |>\n<| c |>\nThis is\
    \ what I'm trying to do, I'm only a beginner at Ruby, but thank you for the input\n\
    <|/ c |>\n<| c |>\nOK, let me see if I can get this for you.  I've added some\
    \ code you can start with.  Let me know if you need any help.\n<|/ c |>\n<| a\
    \ tags=ruby |>\n<code>", "\talphabet = ('A'..'Z') + (\"aeiouy\")\n\tmessage.gsub(/./)\
    \ { |c| alphabet.index(c.upcase) }.\n\t\tgsub(/[AEIOUYaeiouy]/) { |c| alphabet.index(c.next)\
    \ }.\n\t\ttr('AEIOUYaeiouy', 'AEIOUYaeiouy').\n\t\tjoin\nend\n</cell>\n<code language=julia-0.6>\n\
    encode(\"test\")\n</cell>\n<code language=julia-0.6>", "  message.tr!('aeiouAEIOU',\
    \ 'bcdefgh')\n  message.gsub!(/([aeiou])([aeiou])/, \"\\\\1\\\\2\")\n  message.gsub!(/([aeiou])([bcdefgh])/,\
    \ \"\\\\2\\\\1\")\n  message.gsub!(/([bcdfghjklmnpqrstvwxyz])([aeiou])/, \"\\\\\
    1\\\\3\\\\2\")\n  message.gsub!(/([bcdfghjklmnpqrstvwxyz])([bcdefgh])/, \"\\\\\
    1\\\\2\\\\3\")\n  message.gsub!(/([bcdfghjklmnpqrstvwxyz])([bcdefghjklmnpqrstvwxyz])/,\
    \ \"\\\\1\\\\2\\\\4\\\\2\")\n  message.gsub!(/([aeiou])([bcdefghjklmnpqrstvwxyz])/,\
    \ \"\\\\1\\\\3\\\\2\")\n  message.gsub!(/([aeiou])([bcdefghjklmnpqrstvwxyz])([bcdefghjklmnpqrstvwxyz])/,\
    \ \"\\\\1\\\\2\\\\4\\\\2\")\n  message.gsub!(/([bcdfghjklmnpqrstvwxyz])([aeiou])([bcdefghjklmnpqrstvwxyz])/,\
    \ \"\\\\1\\\\4\\\\2\\\\3\\\\2\")\n  message.gsub!(/([bcdfghjklmnpqrstvwxyz])([aeiou])([bcdefghjklmnpqrstvwxyz])([bcdfghjklmnpqrstvwxyz])/,\
    \ \"\\\\1\\\\4\\\\2\\\\4\\\\4\\\\2\")\n  message.gsub!(/([bcdfghjklmnpqrstvwxyz])([aeiou])([bcdefghjklmnpqrstvwxyz])([bcdfghjklmnpqrstvwxyz])([bcdfghjklmnpqrstvwxyz])/,\
    \ \"\\\\1\\\\4\\\\4\\\\2\\\\4\\\\4\\\\5\\\\2\")\n  message.gsub!(/([bcdfghjklmnpqrstvwxyz])([aeiou])([bcdefghjklmnpqrstvwxyz])([bcdfghjklmnpqrstvwxyz])([bcdfghjklmnpqrstvwxyz])([bcdfghjklmnpqrstvwxyz])([bcdfghjklmnpqrstvw",
  "    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    vowels = ['a', 'e', 'i', 'o',\
    \ 'u']\n    \n    # Initialize a new blank list that will hold the encoded message\n\
    \    encoded_message = []\n    \n    # Go through each character in the message\n\
    \    for char in message:\n        \n        # If the character is a vowel, skip\
    \ it\n        if char in vowels:\n            encoded_message.append(char)\n \
    \           continue\n        \n        # Find out the index of the character\
    \ that is 2 places ahead in the alphabet\n        index = alphabet.index(char)\
    \ + 1\n        \n        # If the character is not in the alphabet, skip it\n\
    \        if index > len(alphabet) - 1:\n            encoded_message.append(char)\n\
    \            continue\n        \n        # Otherwise, use the index to look up\
    \ the character in the alphabet\n        char = alphabet[index]\n        \n  \
    \      # Append the character to the encoded message\n        encoded_message.append(char)\n\
    \    \n    # Return the encoded message\n    return \"\".join(encoded_message)\n\
    \    ", "  chars.each{|c| message.gsub!(/#{c}/, c.swapcase)}\n  message.gsub!(/[aeiou]/){|v|\
    \ 2..chars.index(v) + 1 }\n  message.gsub!(/./){|v| chars[v] }\nend\n</code>\n\
    A few notes about the solution", "  result = \"\"\n  for i in message\n    result\
    \ << case if i.upcase =~ /[aeiou]/\n    result << i.upcase\n    result << case\
    \ if i.downcase =~ /[aeiou]/\n    result << i.downcase\n    result << case if\
    \ i.upcase =~ /[AEIOU]/\n    result << i.upcase\n    result << case if i.downcase\
    \ =~ /[AEIOU]/\n    result << i.downcase\n  end\n  result\nend\n</code>\n<|/ a\
    \ |>\n<| a |>\n<code>", "    # Write your solution here.\n    \n    letters =\
    \ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    vowels = \"AEIOUY\"\n    \n    for letter\
    \ in message:\n        \n        if letter in letters:\n            letter_loc\
    \ = letters.index(letter)\n            letter_letter = letters[letter_loc+2]\n\
    \            message = message.replace(letter,letter_letter)\n    \n    for vowel\
    \ in vowels:\n        \n        if vowel in message:\n            letter_loc =\
    \ message.find(vowel)\n            vowel_letter = message[letter_loc+1]\n    \
    \        message = message.replace(vowel,vowel_letter)\n        \n    return message",
  "  message.upcase!\n  message.gsub!(/[aeiou]/, '0')\n  message.gsub!(/0/, 'a')\n\
    \  message.gsub!(/a/, 'b')\n  message.gsub!(/B/, 'C')\n  message.gsub!(/C/, 'd')\n\
    \  message.gsub!(/D/, 'e')\n  message.gsub!(/E/, 'f')\n  message.gsub!(/F/, 'g')\n\
    \  message.gsub!(/G/, 'h')\n  message.gsub!(/H/, 'i')\n  message.gsub!(/I/, 'j')\n\
    \  message.gsub!(/J/, 'k')\n  message.gsub!(/K/, 'l')\n  message.gsub!(/L/, 'm')\n\
    \  message.gsub!(/M/, 'n')\n  message.gsub!(/N/, 'o')\n  message.gsub!(/O/, 'p')\n\
    \  message.gsub!(/P/, 'q')\n  message.gsub!(/Q/, 'r')\n  message.gsub!(/R/, 's')\n\
    \  message.gsub!(/S/, 't')\n  message.gsub!(/T/, 'u')\n  message.gsub!(/U/, 'v')\n\
    \  message.gsub!(/V/, 'w')\n  message.gsub!(/W/, 'x')\n  message.gsub!(/X/, 'y')\n\
    \  message.gsub!(/Y/, 'z')\n  message.gsub!(/Z/, '0')\n  message\nend", "  # your\
    \ code here\nend\n</cell>\n<code language=julia-1.1>", "    message = message.downcase\n\
    \    alphabet =  %w(a b c d e f g h i j k l m n o p q r s t u v w x y z).map{|x|\
    \ x.downcase}\n    alphabet.reverse!\n    message = message.gsub(/[a-z]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[aeiou]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[AEIOU]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[aeiou]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[AEIOU]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[aeiou]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[AEIOU]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[aeiou]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[AEIOU]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[aeiou]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[AEIOU]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[aeiou]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[AEIOU]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[aeiou]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[AEIOU]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[aeiou]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[AEIOU]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    message = message.gsub(/[aeiou]/){|s|\
    \ alphabet.shift[alphabet.index(s)] }\n    ", "  new_message = \"\"\n  index =\
    \ 0\n  \n  # Loop through each letter of the message \n  message.each_char do\
    \ |c|\n  \n    # Store the letter in the variable 'vowel_letter'\n    vowel_letter\
    \ = c\n    \n    # Store the letter in the variable 'second_vowel_letter'\n  \
    \  second_vowel_letter = message[index + 1] unless index == 0\n    \n    # Swap\
    \ case of the letter\n    new_message += c.swapcase\n    \n    # If the letter\
    \ has a vowel\n    if c.match(/[AEIOU]/)\n      \n      # Add the letter to the\
    \ new_message variable\n      new_message += vowel_letter\n      \n      # Add\
    \ the letter to the new_message variable\n      new_message += second_vowel_letter\
    \ unless second_vowel_letter.match(/[AEIOU]/)\n    end\n    \n    # Increment\
    \ the index\n    index += 1\n  end\n  \n  # Return the message with the vowels\
    \ swapped\n  return new_message\nend\n</cell>\n<cell>", "  result = \"\"\n  letters\
    \ = message.split\n  vowels = \"aeiou\"\n  letters.each do |letter|\n    result\
    \ += (letter.upcase == letter.downcase) ? letter.upcase \n      : letter.gsub(vowels,\
    \ \"#{@alphabet[alphabet.index(letter.downcase)]}#{@alphabet[alphabet.index(letter.upcase)\
    \ + 1]}\")\n  end\n  result\nend", "  # TODO: Write code to replace all letters\
    \ in message with their \n  # 2 letter values\nend", "  # TODO: Write a function\
    \ that takes a message, and encodes in such a \n  # way that it swaps case of\
    \ all letters, replaces all vowels in \n  # the message with the letter that appears\
    \ 2 places ahead of that \n  # vowel in the english alphabet. \n  # Assume only\
    \ letters. \n  # Examples:\n  # >>> encode('test')\n  # 'TGST'\n  # >>> encode('This\
    \ is a message')\n  # 'tHKS KS C MGSSCGG'\n  message.downcase!\n  message.scan(/[a-z]/)\
    \ do |letter|\n    letter = 'A'\n    letter = letter[(letter.length - 2) + letter[letter.length\
    \ - 1].upcase]\n    message.gsub!(letter, letter.succ)\n  end\n  message\nend",
  "  words = message.split(' ')\n  decoded = ''\n  vowels = 'AEIOUaeiou'\n  letters\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n  for i in words\n    letters.each do |letter|\n\
    \      decoded += i.gsub!(letter, letters[letters.index(letter)+1]) \n      vowels.each\
    \ do |vowel|\n        decoded += i.gsub!(vowel, vowels[vowels.index(vowel)-2])\
    \ \n      end\n    end\n  end\n  decoded\nend\n</code>\nThis solution is much\
    \ more elegant, and will scale well. \nHowever, if you really want to use recursion\
    \ and recursion is not the best tool for this, you can use this recursive solution:\n\
    <code>", "  message = message.gsub(/([a-z])/){|letter| letter.upcase }\n  message.gsub(/[aeiou]/){|letter|\
    \ letter.ord.to_s }\nend\n</code>\nThe second line uses the block form of the\
    \ gsub method to return the uppercase version of the matched letter. This allows\
    \ you to chain method calls, like you did with #ord, on the matched letter.\n\
    The third line uses the block form of the gsub method to return the letter that\
    \ appears 2 places ahead of the matched letter, in this case ord.to_s returns\
    \ the ordinal number of the letter which is in unicode.\nThe resulting code could\
    \ look like this:\n<code>", "  message = \"t#{message.gsub(/[aeiou]/) {|letter|\
    \ letter.upcase }}\".gsub(/[aeiou]/) do |vowel|\n    index = message.index(vowel)\n\
    \    letter = message.upcase if index == 0 && vowel.upcase == \"A\" # Handle the\
    \ case of A\n    letter.upcase if index != 0 && vowel.upcase == \"A\" # Handle\
    \ the case of AEIOU\n  end\n  message\nend", "  result = \"\"\n  message = message.upcase\n\
    \  for i in 0...message.length - 1\n    if message.slice(i,i+1) =~ /[aeiou]/\n\
    \      replacement = english_alphabet[english_alphabet.index(\"A\")+english_alphabet.index(i+1)-2]\n\
    \      result = result + replacement + message.slice(i,i+2)\n    else\n      result\
    \ = result + message.slice(i,i+1)\n    end\n  end\n  return result\nend\n</cell>\n\
    <cell>", "    message.downcase!\n    letters = message.split('')\n    encoded\
    \ = letters.map { |letter|\n        if letter.match(/[aeiou]/)\n            letter.upcase\n\
    \        elsif letter == 'a'\n            'E'\n        elsif letter == 'e'\n \
    \           'A'\n        elsif letter == 'i'\n            'I'\n        elsif letter\
    \ == 'o'\n            'O'\n        elsif letter == 'u'\n            'u'\n    \
    \    elsif letter == 'y'\n            'Y'\n        elsif letter == 'h'\n     \
    \       'H'\n        elsif letter == 'r'\n            'R'\n        elsif letter\
    \ == 'o'\n            'o'\n        else\n            letter\n        end\n   \
    \ }.join('') # Turn it back into a string\nend\n</code>\n<|/ a dscore=1 tags=ruby,string,ruby-on-rails,encryption\
    \ |>\n<| a dscore=1 |>\n<code>", "  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  vowels = 'aeiouAEIOU'\n  message = message.downcase\n  char_count = 0\n  \n\
    \  # Write your code here.", "    enc = \"\"\n    vowels = ['a', 'e', 'i', 'o',\
    \ 'u', 'y']\n    cap_vowels = ['A', 'E', 'I', 'O', 'U', 'Y']\n    message = message.downcase\n\
    \    \n    vowels.each do |vowel|\n        enc << message.gsub( vowel, cap_vowels[vowel.ord%cap_vowels.size]\
    \ )\n    end\n    \n    message.gsub!(/[aeiouy]/) { |m| m.downcase }\n    \n \
    \   return enc\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
