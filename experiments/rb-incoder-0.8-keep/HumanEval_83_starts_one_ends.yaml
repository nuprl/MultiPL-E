name: HumanEval_83_starts_one_ends
language: rb
prompt: "# Given a positive integer n, return the count of the numbers of n-digit\n\
  # positive integers that start or end with 1.\ndef starts_one_ends(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_starts_one_ends\n\
  \    candidate = method(:starts_one_ends)\n    assert_equal(1, candidate.call(1))\n\
  \    assert_equal(18, candidate.call(2))\n    assert_equal(180, candidate.call(3))\n\
  \    assert_equal(1800, candidate.call(4))\n    assert_equal(18000, candidate.call(5))\n\
  \  end\nend\n"
completions: ["  count=0\n  for i in (1..n).step(1) do\n    if i==1 && i%10==1\n \
    \     count+=1\n    end\n  end\n  count\nend\n</code>\nThe above code assumes\
    \ the array will be sorted, and will run faster even if the array is not sorted.\n\
    <|/ a dscore=1 |>\n<| c |>\nSorry, but I don't understand how that would work\
    \ with the example data I provided, would you mind expanding on your answer? Thanks.\n\
    <|/ c |>\n<| c |>\nI've updated my answer to show the use of that method. I've\
    \ also added a `starts_one_ends` method so you can use that method on any array\
    \ of integers.\n<|/ c |>\n<| a tags=ruby,arrays |>\nYou can do it with Enumerable#slice_when:\n\
    <code>\narr = [1, 1, 2, 3, 3, 6, 8]", "  (1..n).count { |i| i.to_s.rjust(n, '1').start_with?('1')\
    \ }\nend", "  n.times.map do |i|\n    [n % 10, 1].length\n  end.find { |a, b|\
    \ a != b }\nend", "  count = 0\n  (1..n).each do |i|\n    count += 1 if i / 10.0\
    \ == i / 10.0 && i % 10 == 1\n  end\n  count\nend", "  count = 0\n  i = 0\n  while\
    \ i < n\n    i += 1\n    if i mod 10 == 1\n      count += 1\n      i /= 10\n \
    \   end\n  end\n  count\nend", "  1.upto(n).select { |e| e % 10 == 1 && e != 1\
    \ }.size\nend", "  count = 0\n  i = 1 while i <= n\n    next if i==1 || i==n\n\
    \    count += 1 if i==1\n    count += 1 if i==n\n    i += 1\n  count\nend", " \
    \ count = 0\n  while n > 0\n    count += n % 10\n    n = n / 10\n  end\n  count\n\
    end\n</code>\nThis code doesn't work for numbers whose first digit is zero, such\
    \ as 0001 or 1234.\nThe code doesn't work for non-numeric strings such as \"abc\"\
    \ or \"1e23\".\n<|/ a tags=ruby,integer,string,regex |>\n<| a dscore=1 tags=ruby,integer,string,regex\
    \ |>\n<code>", "  count = 0\n  (1..n).each do |i|\n    count += (i % 10 == 1 &&\
    \ i != n) ? 1 : 0;\n  end\n  count\nend", "  (1..n).count { |i| i.to_s.start_with?('1')\
    \ ? 1 : i.to_s.end_with?('1') ? 1 : 0 }\nend", "  count1 = 0\n  count2 = 1\n \
    \ while n > 0\n    count1 = count1 + 1\n    if count1 % n == 0\n      count1 =\
    \ count1 - 1\n      count2 = count2 + 1\n    end\n    n -= 1\n  end\n  return\
    \ count2\nend\n</cell>\n<cell>\nstarts_one_ends(99)\n</cell>\n<cell>\nstarts_one_ends(100)\n\
    </cell>\n<cell>\nstarts_one_ends(199)\n</cell>\n<cell>\nstarts_one_ends(101)\n\
    </cell>\n<cell>\nstarts_one_ends(999)\n</cell>\n<cell>\nstarts_one_ends(1000)\n\
    </cell>\n<text>\n12. Write a function that takes an integer and returns the number\
    \ of digits that \ndo not exceed 9.", "  count = 0\n  (0..Float::INFINITY).each\
    \ do |i|\n    if i.to_s == i.to_s(0)\n      count = count + 1\n    end\n  end\n\
    \  count\nend", "  count = 0\n  for i in (1..n) do\n    return count if n%i ==\
    \ 0\n    return count if n%i != 0 && n%i-1 == 0\n  end\n  count\nend", "  count\
    \ = 1\n  while n > 0\n    if (n % 10 == 1)\n      count += 1\n    n /= 10\n  end\n\
    \  count\nend", "  # Base case\n  return 0 if n < 0 # 0 is not a positive integer\
    \ n\n  \n  # Recursive case\n  return 1 + (n % 9 == 1) + (n % 100 == 1) + (n %\
    \ 1000 == 1)\nend\n</cell>\n<cell>\nstarts_one_ends(11)\n</cell>\n<text>\nQuestion:\
    \ Write a recursive function count_digits(n) that returns the number of digits\
    \ in n. For example, count_digits(123456789) returns 8.", "  count = 0\n  for\
    \ i in 1..n\n    if nums(i).any? { |x| x == 1 }\n      count += 1\n    end\n \
    \ end\n  count\nend\n</code>\nThe result will be a number.\n<code>\n starts_one_ends(100)\n\
    \ => 144 \n starts_one_ends(1000)\n => 342 \n starts_one_ends(1000000)\n => 5599\
    \ \n starts_one_ends(1000000000)\n => 434168 \n starts_one_ends(10000000000)\n\
    \ => 5846974 \n starts_one_ends(100000000000000)\n => 602489888 \n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis runs in O(n^2). Just out of curiosity, how did\
    \ you come up with such a concise solution?\n<|/ c |>\n<| c |>\nThe `nums` function\
    \ returns an enumerator, which is a kind of lazy list. I can iterate over each\
    \ element of `nums`, just as I can iterate over each element of `1..n`.\n<|/ c\
    \ |>\n<| c |>\nI love the conciseness of this solution. Though I don't understand\
    \ how it's O(n^2). Could you explain it?\n<|/ c |>\n<| c |>\nThe `nums` function\
    \ is called `n` times, and each time is called `n` times. There are `n^2` calls\
    \ to the `nums` function, and `n <= n^2` so it's O(n^2). But this solution is\
    \ O(n) because it's only doing the \"starting\" part, and does not do any summing.\n\
    <|/ c |>\n<| a |>\n<code>", "  ones = n.digits.select { |d| d == '1'.to_i }\n\
    \  if ones.size\n    ones.length - (ones.first.length - 1)\n  else\n    n\n  end\n\
    end", "  counter = 0\n  while n > 0\n    if n % 10 == 1\n      counter += 1\n\
    \    end\n    n /= 10\n  end\n  counter\nend", "  if n == 0\n    0\n  elsif n\
    \ < 0\n    -1\n  else\n    (n%100==0) + (n%10==0)\n  end\nend", "  count = 1\n\
    \  while n > 0 do\n    count = count*10 + n % 10\n    n /= 10\n  end\n  count\n\
    end", "  count = 0\n  i = n\n  while i >= 1\n    i = i / 10\n    count += 1\n\
    \  end\n  count\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n<| c |>\nYes, but\
    \ that doesn't answer the question of whether it's a good way to solve this problem.\n\
    <|/ c |>\n<| c |>\n, I've updated my answer with the solution to the actual question.\n\
    <|/ c |>\n<| c |>\nI still don't think you have a solution to his actual problem\
    \ as he wants the numbers to appear consecutively rather than just grouped together.\n\
    <|/ c |>\n<| c |>\n, thank you for the comment. I think I solved the problem.\n\
    <|/ c |>\n<| a tags=algorithm,ruby |>\nThis problem is an example of the well\
    \ known knapsack problem. You can solve it by using dynamic programming.\nA classic\
    \ solution is the Knapsack algorithm, which I suggest you read. It's a greedy\
    \ algorithm, but it's simple and easy to implement.\nThe idea is to build a table\
    \ that has a row for each n, and a column for each i. At each cell (i,j) you store\
    \ the max possible value. The max is calculated for each n by iterating over all\
    \ i. After this you only need to store the maximum i for each n. \nThe pseudocode\
    \ is:\n<code>", "  one = 0\n  start = n\n  while n > 1 do\n    one = one + 1\n\
    \    n = n/10\n  end\n  result = one - start\n  result\nend", "  count = 0\n \
    \ n = (n.to_s).to_i\n  while n > 0\n    n, mod = divmod(n, 10)\n    count += 1\n\
    \  end\n  count\nend", "  if n == 1\n    1\n  else\n    count = 0\n    while n\
    \ > 1\n      n -= 1\n      count += 1\n    end\n    count\n  end\nend", "  i =\
    \ 0\n  res = 0", "  numbers = Array.new(n)\n  (0...n).to_a.each do |i|\n    numbers[i]\
    \ = i * 10\n  end\n  numbers.each do |n|\n    if (n % 10 == 1) || (n % 10 == 0)\n\
    \      n\n    end\n  end\nend", "  count = 0\n  i = 2\n  while i <= n\n    i =\
    \ i * 10 + 1\n    count += 1\n  end\n  count\nend", "  return 0 if n.zero? or\
    \ n.abs <= 10 # n is only positive and less than 10\n  1.upto(n.abs-1).find {\
    \ |i| n.to_s.chars.take(i).include?('1') }\nend", "  count = 0\n  while n > 1\n\
    \    count += ((n.to_s.reverse - '1'.to_s).to_i).abs <= n\n    n /= 10\n  end\n\
    \  count\nend\n</code>\n<|/ a |>\n<| a tags=ruby,ruby-on-rails,algorithm dscore=0\
    \ |>\n<code>", "  if n==0\n    []\n  else\n    digits = n.to_s.split(//).map(&:to_i).sort.reverse\n\
    \    digits = digits.take(digits.length/2).first(n).last(n).to_a\n    digits[0..(n/2)-1].count{|i|\
    \ digits[i] == 1}\n  end\nend", "  return 1 if n <= 10 then\n    0 if n.is_a?\
    \ Fixnum && n.zero?\n    0 if n.is_a? Float && n.zero?\n    1 if n.is_a? Fixnum\
    \ && n.zero? && n != 0\n  end\nend", "  count = 0\n  i = 1\n  while i <= n\n \
    \   return count if i #== 1 #&& n % i #== 0\n    count += 1\n    i += 1\n  end\n\
    \  count\nend", "  numbers = n.to_s(2).chars.map(&:to_i)\n  n1 = numbers.size\n\
    \  n2 = numbers.count { |number| number == 1 || number == numbers[-1] }\n  return\
    \ [n1, n2]\nend", "    count = 0\n    while n > 0\n        if n % 10 == 1\n  \
    \          count += (n/10).floor\n        end\n        n /= 10\n    end\n    count\n\
    end\n</cell>\n<cell>\nassert starts_one_ends(10) == 3\nassert starts_one_ends(6)\
    \ == 2\nassert starts_one_ends(99) == 3\n</cell>\n<cell>", "  count = 0\n  (1..n).each\
    \ do |i|\n    next if i == 1 || i == n\n    if i % (i == 1 || i == n ? 3 : i)\
    \ == 0 && (i != 1 || i != n)\n      count += 1\n    end\n  end\n  count\nend",
  "  n.downto(1) do |i|\n    return i if i.odd?\n    n.even? && return i if i==1 &&\
    \ n%i==0\n    n%i == 0\n  end\n  0\nend", "  counter = 0\n  i = n\n  while i >=\
    \ 1\n    counter += 1\n    i -= 1\n  end\n  counter\nend", "  i = 0\n  while i\
    \ <= n\n    if n % i == 1\n      i += (n - i)\n    else\n      i += 1\n    end\n\
    \  end\n  return i\nend", "  ones = n.to_s.length\n  result = ones.times{ |ones|\
    \ n / one - n % one == 1 ? 1 : 0 }\n  \n  return result\nend", "  ones = 0\n \
    \ start = n\n  stop = n\n  stop = stop - 1\n  loop do\n    ones += 1 if start\
    \ % 10 == 1\n    start = start / 10\n    stop = stop / 10\n    break if stop ==\
    \ 0\n  end\n  ones\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nVery interesting!\
    \  I'm glad you posted this answer and I didn't have to figure it out myself.\
    \  Thank you!\n<|/ c |>\n<| a |>\nHere is a way without recursion:\n<code>", " \
    \ i = 2\n  n = 1\n  count = 0\n  while (i < n)\n    count += (i-1)..n\n    i +=\
    \ 1\n  end\n  return count\nend", "  (0..n).inject(0) do |count, i|\n    count\
    \ += (i > 0 && digits[i] == 1) || (i < n && digits[i] == -1)\n  end\nend", " \
    \ (1..n).inject(0) do |sum, idx|\n    (idx % 3 == 0 && idx / 3 != idx) ? sum +\
    \ 1 : sum\n  end\nend", "    count = 0\n    (1..n).each do |i|\n        if i.to_s.start_with?('1')\n\
    \            count += 1\n        end\n    end\n    count\nend", "  sum = 0\n \
    \ for i in 1..n\n    sum += ((i-1) % 9 == 0 || (i-1) % 9 == 1)\n  end\n  sum\n\
    end\n</cell>\n<code language=julia-0.4>\nstarts_one_ends(4)\n</cell>\n<code language=julia-0.4>",
  "  count = 0\n  n.times do\n    break if(n % 10 == 1)\n    count += 1\n  end\n \
    \ count\nend\np starts_one_ends(5)", "  result = 1\n  i = 1\n  while i <= n do\n\
    \    result += 1 if i % 10 == 1 and i != 1\n    i += 1 if i % 10 == 0 and i !=\
    \ 1\n    i += 1\n  end\n  result\nend", "  n = (n % 1 == 0) ? n : n * 10\n  ones\
    \ = (n < 100)? n - 1 : 100\n  one_end = (n < 10)? 1 : 10\n  result = 0\n  puts\
    \ \"Calculating n-digit positive integers less than #{n} ...\"\n  loop do\n  \
    \  num = n - (ones / 10)\n    if (num % 10 == 0)\n      break\n    end\n    if\
    \ (num % 10 == 0)\n      result += 1\n    end\n    ones = ones - 1\n  end\n  puts\
    \ \"Found #{result} of them starting/ending with 1.\"\nend\n</code>\nFor testing:\n\
    <code>\nstarts_one_ends(100)\nCalculating n-digit positive integers less than\
    \ 100 ...\nFound 55 starting/ending with 1.\n</code>\n<|/ a tags=math,ruby |>\n\
    <| c |>\nIt was my understanding that his was a homework question. I was thinking\
    \ his was a question that was given to you in a class and asked you to work out\
    \ the answer, not that he was just trying to figure out a question for him.\n\
    <|/ c |>\n<| a |>\nThe answer is the same as the answer given by Sam Varshavchik\
    \ but with the number in reverse. Here's my translation:\n<code>", "  count =\
    \ 0\n  1.upto(n) do |i|\n    next if i.zero?\n    i += 1 if i.odd?\n    count\
    \ = 1 if i.zero? && i.even?\n  end\n  count\nend\n</code>\nThis solution is more\
    \ complicated but more readable. It does not need to count duplicates and it can\
    \ make use of the fact that numbers ending with 1 are always odd.\n<|/ a dscore=0\
    \ |>\n<| a tags=algorithm,ruby dscore=0 |>\n<code>", "    count = 0\n    (1..n).each\
    \ do |i|\n        count += i.to_s.rindex('1').to_i < i\n    end\n    count\nend",
  "  digits = n.to_s.split(//)\n  ndigits = digits.count{|d| d == 1}\n  ndigits -\
    \ n\nend", "  count = 0\n  n.times { |i| count += 1 if i.to_s.scan(/\\d/).all?\
    \ { |s| s.to_i == 1 } }\n  count\nend", "  (1..n).count { |i| (1..n).any? { |j|\
    \ (1..i).any? { |j| (i+j).to_s == j.to_s + i.to_s } }\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 tags=algorithm,ruby |>\nHere's an answer that uses recursion:\n\
    <code>", "  return 1 if n <= 10 else (1..10).select { |x| n % x == 0 }.size\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis would be a better answer if you\
    \ explained how the code you provided answers the question.\n<|/ c |>\n<| c |>\n\
    This is brilliant and does exactly what I need.  Thank you.\n<|/ c |>\n<| c |>\n\
    Happy to help :)\n<|/ c |>\n<| c |>\nIt is a very nice answer, but I think a good\
    \ answer would explain your code. Also, I think that the accepted answer does\
    \ that very well.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n(1..100).to_a.select {\
    \ |x| x % 10 == 0 }.size\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis does not\
    \ answer the question. It does not find the number of 10-digit numbers starting\
    \ with 1, but the number of numbers starting with 1 or ending with 1 from the\
    \ first to 99 numbers starting with 1.\n<|/ c |>\n<| c |>\nThis answer is good\
    \ if you want to count the numbers that start with 1 or end with 1 from the first\
    \ to 99 numbers starting with 1.\n<|/ c |>\n<| a dscore=4 |>\n<code>\n(1..100).find\
    \ { |x| x % 10 == 0 }.size\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks for your\
    \ answer! What is the benefit of using it over `(1..100).select { |x| x % 10 ==\
    \ 0 }.size` ?\n<|/ c |>\n<| c |>\nNo difference at all\n<|/ c |>\n<| c |>\n`(1..100).find\
    \ { |x| x % 10 == 0 }` is more efficient than `(1..100).select { |x| x % 10 ==\
    \ 0 }.size` because `find` stops evaluating the range when it finds a match. `select`\
    \ evaluates the entire range.\n<|/ c |>\n<| a tags=ruby |>\n<code>\n(1..100).select{|x|\
    \ x % 10 == 0}.size\n</code>\n<|/ a dscore=4 |>\n<| a |>\n<code>\n(1..100).count(10)\
    \ #=> 100\n</code>\nIf you need only a true/false flag,\n<code>\n(1..100).count(10)\
    \ rescue false #=> true/false\n</code>\n<|/ a dscore=4 tags=ruby |>", "  (1..n).select\
    \ do |i|\n    i < n && (i % 10 == 1 || i % 10 == 7)\n  end.size\nend\n</cell>\n\
    <cell>\nstarts_one_ends(10)\n</cell>\n<cell>", "  count = 0\n  i = 0\n  while\
    \ i <= n\n    if i + (n - i) % 1 == 0\n      count += 1\n    i += 1\n  end\n \
    \ count\nend", "  ns = []\n  loop do\n    break if ns == [n]\n    ns << n\n  \
    \  n -= 1\n  end\n  ns = ns.sort_by { |n| n.to_s }\n  ns = ns.first(n - 1).to_a.product(ns).count\n\
    \  ns -= 1 if n == 1\n  ns\nend", "  result = 0\n  (1...n).each do |i|\n    result\
    \ = result + (i...n).count(i==1)\n  end\n  result\nend\n</cell>\n<cell>\nstarts_one_ends(1)\n\
    </cell>\n<cell>\nstarts_one_ends(7)\n</cell>\n<cell>\nstarts_one_ends(10)\n</cell>\n\
    <cell>\nstarts_one_ends(20)\n</cell>\n<text>\nExercise 3.4", "  # Create an array\
    \ of booleans, called starts_one_ends.\n  starts_one_ends = Array.new(n) do |i|\n\
    \    # Initialize a boolean variable and set it equal to the value of\n    # starts_one_end_helper(n,\
    \ i).\n    starts_one_end_helper(n, i)\n  end", "  ones = n.to_s.split('').select\
    \ { |i| i.to_i.zero? }\n  ones = ones.count{ |i| i.to_s == 1 }\n  ones.to_i\n\
    end", "  return 0 if n == 1 \n  x = n.to_i\n  sum = 0\n  loop do\n    sum += 1\
    \ if x == 1\n    x -= 1\n    break if x == 0\n    break if x % 10 == 1\n  end\n\
    \  return sum\nend", "  count=0\n  n.downto(1) do |x|\n    if x==0 || n==x\n \
    \     count+=1\n    end\n  end\n  count\nend", "  count = 0\n  for i in 1..n\n\
    \    if !(i & 1)\n      count += 1\n  end\n  count\nend", "  if n == 0\n    count\
    \ = 1\n  else\n    count = starts_one_ends(n/10) + 1 if n % 10 == 1\n  end\nend",
  "  count = 0\n  digits = n.digits.reverse\n  until digits.empty?\n    if digits[0]\
    \ == 1\n      count += 1\n      digits.shift\n    else\n      break\n    end\n\
    \  end\n  count\nend", "  ones_count = n.to_s.scan(/^1/).count\n  start = ones_count\
    \ > 0\n  end = ones_count >= n - 1\n  ones_count.times { |i| return i }\n  zeros_count\
    \ = n.to_s.scan(/0/).count\n  ones_count.times { |i| return i }\n  return zeros_count\n\
    end\n</code>\nThis assumes your input is positive integer. If you need this feature\
    \ to count negative integers, change line 4 of the above code to the following\
    \ instead:\n<code>\nones_count = n.to_s.scan(/^-?1/).count\n</code>\nHere's a\
    \ testsuite showing this code running against your test cases.\n<|/ a tags=algorithm,ruby,ruby-on-rails\
    \ |>\n<| a tags=algorithm,ruby,ruby-on-rails |>\nHere's an alternative to Tim's\
    \ solution:\n<code>", "  count = 1\n  while n > 0\n    if n % 10 == 1\n      count\
    \ += 1\n    else\n      n /= 10\n    end\n  end\n  return count\nend", "  n =\
    \ (n.to_i / 10).floor\n  result = 1\n  n.times do\n    result += 1\n  end\n  result\
    \ * n if n < 10\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe question asks for\
    \ counting the number of *consecutive* 1's. I think your answer returns the number\
    \ of 1's in some sequences of consecutive 1s. At the end, you still return `result\
    \ == n`, which should never be true.\n<|/ c |>\n<| a |>\nThis is an old question,\
    \ however I just solved this problem for a different purpose. \nI needed to count\
    \ how many pairs of consecutive 1's in a string that did not have a 1 after them.\
    \ \nMy solution:\n<code>", "  ((n-1).downto(1)).inject(0) do |sum, num|\n    sum\
    \ + (num == 1).nonzero? && num.to_s.length >= n ? 1 : 0\n  end\nend", "  total\
    \ = 0\n  n.times do\n    total += n.to_s.count('1') % 2 == 0 ? 0 : -1\n  end\n\
    \  total\nend", "  count = 0\n  loop do\n    if n == 1\n      count += 1\n   \
    \   break\n    end\n    if n % 10 == 1\n      count += 1\n      n /= 10\n    \
    \  break\n    end\n    n /= 10\n  end\n  count\nend\n</code>\n<code>\nputs starts_one_ends(1022)",
  "  count = 0\n  i = 2\n  while i < n\n    if n%i == 0\n      if i==1 or i==n - 1\n\
    \        count += 1\n      end\n    end\n    i += 1\n  end\n  count\nend", " \
    \ if n < 0\n    puts \"Negative count of starts or ends cannot be computed!\"\n\
    \    return\n  end", "  count = 0\n  (1..n).each { |i|\n    if i % 10 == 1 &&\
    \ (i % 100 != 11 || i == 1)\n      count += 1\n    elsif i % 10 == 0 && (i % 100\
    \ != 11 || i == 100)\n      count += 1\n    end\n  }\n  count\nend", "  count\
    \ = 1\n  while n > 0\n    return count\n    count += 1\n  end\nend", "  one =\
    \ 1\n  count = 0\n  while n < 0\n    one *= 10\n    n -= 1\n  end\n  while n >\
    \ 0\n    one += 1\n    count += one == n\n    n -= 1\n  end\n  count\nend\nprint\
    \ starts_one_ends(4) # prints 3\nprint starts_one_ends(8) # prints 1\nprint starts_one_ends(10)\
    \ # prints 1\nprint starts_one_ends(12) # prints 2\nprint starts_one_ends(17)\
    \ # prints 3\n</code>\n<|/ a tags=ruby |>\n<| c |>\nVery nice. It just has one\
    \ drawback that `starts_one_ends(0)` returns 1, whereas `starts_one_ends(1)` returns\
    \ 0 as expected (I guess this is because of the `n > 0`). However, I guess I can\
    \ add an `if n == 0` condition after the `while n < 0` loop and that will fix\
    \ this.\n<|/ c |>\n<| c |>\n: you're right. I changed my answer to fix this.\n\
    <|/ c |>\n<| c |>\nI like your solution. I'm also interested in knowing how the\
    \ other solutions work, given that they were posted within minutes of each other.\
    \ Btw, I noticed that your solution does not work for `starts_one_ends(2)`. It\
    \ returns `0` instead of `2`.\n<|/ c |>\n<| c |>\n: You're right. My fault. I\
    \ changed my answer accordingly.\n<|/ c |>\n<| a |>\n<code>", "  return 0 if n\
    \ < 2\n  return 1 if n == 0\n  return 2 if n == 1\n  return 1 + starts_one_ends(n\
    \ - 1)\nends_one_starts = starts_one_ends * (-1)\n</cell>\n<code language=julia-1.1>",
  "  count = 0\n  (1..n).each do |i|\n    break if i > (n/10).to_i || i < (n/10).to_i\
    \ - 1\n    count += 1\n  end\n  count\nend\np starts_one_ends(9)", "  count =\
    \ 0\n  while n > 1\n    if n % 10 == 1\n      if n == 1\n        count += 1\n\
    \      else\n        count += 1\n      end\n    end \n    n = n / 10\n  end\n\
    \  count\nend", "  starts_ends = 0\n  \n  n.downto(1) do |i|\n    starts_ends\
    \ += 1 if i & 1 == 1\n  end", "  sum = 0\n  i = 0\n  while i < n\n    sum += (i\
    \ / 10**i).odd? ? 1 : 0\n    i += 1\n  end\n  sum\nend", "  count = 0\n  i = \
    \ 1\n  while i <= n\n    if i mod 11 == 0\n      count += i / 11\n    i += 1\n\
    \  end\n  count\nend\n</code>\nThis was my first idea, but I don't think it works.\
    \ It's obviously flawed.\n<code>", "  count = 0\n  for i in 1...n\n    if i ==\
    \ 1\n      count += 1\n    else\n      if i / 10 % 10 == 1\n        count += 1\n\
    \      end\n    end\n  end\n  count\nend", "  n.to_s.reverse.chars.with_index.count\
    \ { |c, i| c == '1' || c == '0' && i % 10 == 0 || c == '0' && i % 10 != 0 }\n\
    end", "  # Special case: n is 0.\n  return 0 if n == 0 then\n    0 else\n    (n\
    \ - 1).ceil / 10.downto(1).inject(0) do |count, n|\n      count + 1 if n.to_i.to_s\
    \ == n.to_i.to_s.reverse and n % 10 == 1 && n % 10 != 10 && n < 100_000_000\n\
    \    end\nend", "  count = 1\n  n.times do\n    count += 1 if n.to_s.split(//)[1]\
    \ == '1' else 0\n    n -= 1\n  end\n  count\nend", "  (1..n).count {|i| i mod\
    \ 10 == 1}\nend", "  count = 0\n  for i in 1...n\n    if i % 10 == 1 || i % 10\
    \ == -1\n      if i / 10 % 10 == 1\n        count += 1\n      else\n        count\
    \ += 1\n    end\n  end\n  count\nend", "  count = 0\n  while n > 0\n    n -= 1\n\
    \    count += 1\n  end\n  count\nend\n</code>\n<|/ a |>\n<| c |>\nThank you for\
    \ providing a detailed solution, however I cannot use the String class as it is\
    \ not part of the exercise and I wanted to solve this with the logic I learned\
    \ in class.\n<|/ c |>\n<| c |>\n: I edited the question to add a method which\
    \ can do it using the logic you learned in class.\n<|/ c |>\n<| a dscore=0 |>\n\
    I think this question is like one of those that come up every so often. There\
    \ aren't any obvious solutions in Ruby, but we can make a function that will work\
    \ quite well. Let's first define a method which determines the digit position\
    \ of a number in our string. A simple one that will return -1 if it can't find\
    \ anything:\n<code>", "  n.times.map {|x| x == 1 }.reduce(:+) - n\nend", "  ((1..n).to_a.combination(2).select\
    \ { |a, b| (b - a <= 1) }.inject(:+) || 0)\nend", "  count = 0\n  while n > 1\n\
    \    count += 1\n    n /= 10\n  end\n  count\nend", "  count = 0\n  loop do\n\
    \    start = n.to_s.reverse.split('1').first\n    stop = n.to_s.reverse.split('1').last\n\
    \    if start == '1'\n      if stop == '1'\n        return count\n      end\n\
    \      count += 1\n    end\n    break if stop == '1'\n    n -= 1\n  end\n  count\n\
    end", "  n = n.to_i\n  count = []\n  loop do\n    count << n if n >= 10\n    n\
    \ /= 10\n    return count if n == 1\n  end\nend\n</code>\nNote that this still\
    \ returns [2,1] for the example in the OP. I'm guessing this is intentional.\n\
    <|/ a dscore=1 |>\n<| c |>\nYes, I'm guessing this is intentional, although I\
    \ wish I could understand why.\n<|/ c |>\n<| c |>\nI tried to explain in the first\
    \ paragraph of my answer. Basically, it's an algorithm that gives the sum of all\
    \ positive integers of length `n` that start with `1` and end with `1`.\n<|/ c\
    \ |>\n<| c |>\n: I appreciate your explanation, which I think is correct but I'm\
    \ not convinced it is correct. For example, `starts_one_ends(5)` should return\
    \ `[1,2,3,4,5]`, but the code returns `[1,2]`, which suggests to me that it should\
    \ return `[1,2]` since `5 / 10` is `1`. However, that doesn't appear to be the\
    \ case. It seems the code should return `[1,2,3,4,5]` instead, since `starts_one_ends(4)\
    \ == [1,2,3]`.\n<|/ c |>\n<| c |>\n: I now see why my code doesn't do what it\
    \ should do. Basically, my code assumes that all numbers *do* have at least one\
    \ `1` digit in them. The code does that correctly for the example I gave in my\
    \ question, but not for the more general case I stated in my question. Basically,\
    \ your code is correct, but I'm not sure it does what the OP wants. I'm looking\
    \ at it now.\n<|/ c |>\n<| c |>\n: Yes, that does seem to be the case. I'm looking\
    \ at it now.\n<|/ c |>\n<| a tags=ruby,arrays dscore=1 |>\nHere's another solution\
    \ that uses a regex:\n<code>", "  (n.to_s.length == n ? n : 0) - (n==0 ? 0 : starts_one_ends(n-1).to_s.rindex(\"\
    1\"))\nend\n</code>\nThe method above returns the number of such integers in the\
    \ range 0..n-1, where n is the length of the string. There are more efficient\
    \ ways to do this, but this one has the advantage of working in O(n) time.\n<|/\
    \ a dscore=0 |>\n<| a |>\nThis is another approach\n<code>\nn = 0\narr = []\n\
    while n <= 9\n  i = n\n  until i /= 10\n    arr << i\n    n += 1 \n  end\nend",
  "  n = n.to_i\n  count = 0\n  if n < 10\n    count = 1\n  elsif n < 100\n    count\
    \ = 2\n  elsif n < 1000\n    count = 3\n  elsif n < 10000\n    count = 4\n  elsif\
    \ n < 100000\n    count = 5\n  elsif n < 1000000\n    count = 6\n  else\n    count\
    \ = 7\n  end", "  if n <= 0\n    0\n  else\n    n % 10 == 1 ? n / 10 : starts_one_ends(n\
    \ / 10)\n  end\nend\n</code>\nThen you can just get the count of those numbers\
    \ by subtracting the count of ones from the total count, as below:\n<code>", " \
    \ count = 0\n  n.times do\n    if n.to_s == n.to_s[0..n-1]\n      count += 1\n\
    \    end\n  end\n  count\nend", "  return 0 if n == 1 || n == 0 # Don't do anything\
    \ for 0 or 1\n  \n  num = 0\n  while n > 0\n    num = num + 1 if n % 10 == 1 ||\
    \ n % 10 == -1\n    n /= 10\n  end\n  return num\nend", "  n.to_s.chars.uniq.count\
    \ { |c| c == 1 ? 1 : 0 }\nend", "  ones = 0\n  start = 0\n  while start < n\n\
    \    ones += 1\n    start += n / 10\n  end\n  ones\nend", "  count = 0\n  i =\
    \ 1\n  while i <= n do\n    if i % 10 == 1 && i != n\n      count += 1\n    i\
    \ += 1\n  end\n  count\nend", "  count = n.to_s.reverse.gsub(/./, '').scan(/./).length\n\
    \  puts \"There are #{count} #{n <= 9 ? 'one' : 'ones'} or #{n} #{n >= 10 ? 'digit'\
    \ : 'digits'}\"\nend", "  return 0 if n < 10 # 0 1-digit number\n  n >= 10 &&\
    \ n <= 20 || n >= 100 && n <= 1000 # 1 2-digit, 3 4-digit\nend\n</code>\n(Note\
    \ that I'm using a special operator && in an if condition, and I'm using || for\
    \ everything else)\n<|/ a dscore=1 |>\n<| c |>\n\"*I'm using a special operator\
    \ `&&` in an if condition*\"... and you're not using a \"special\" operator to\
    \ `&&` anywhere. You simply didn't understand the purpose of `&&` in the first\
    \ place.\n<|/ c |>\n<| c |>\nThank you. I get it now that I'm a noob.\n<|/ c |>\n\
    <| c |>\nThis is an incredibly inefficient approach, and it just doesn't work.\
    \ Try it with input `1`.\n<|/ c |>\n<| c |>\nI added the missing `return`. I don't\
    \ think it matters much, but I did run a benchmark to double check that. On my\
    \ laptop, it runs about 8 times faster than the accepted answer. Thanks for the\
    \ comment, though. :-)\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  n.times { |x|\
    \ n == x.to_s.size ? return x + 1 : nil }\n  nil\nend", "  ones = 0\n  count =\
    \ 0\n  (1..n).each do |i|\n    if i % 10 == 1\n      ones += 1\n      count +=\
    \ 1\n    end\n  end\n  (1..n).each do |i|\n    if i % 10 == 0\n      count +=\
    \ 1 if ((i % 10) == (n % 10))\n    end\n  end\n  return count\nend\nprint (starts_one_ends(200))",
  "  sum = 0\n  result = n.digits\n  until result == [1]\n    sum += result.count('1')\n\
    \    result = result[0, end] + result[1, end]\n  end\n  sum\nend", "  count =\
    \ 0\n  (1..n).each do |i|\n    if i % 10 == 1\n      count += 1\n      break if\
    \ count == n\n    end\n  end\n  count\nend", "  count = 1 if n == 1 else 0\n \
    \ ones = n % 10\n  while n > 0\n    n -= ones if (ones *= 10) == 1 else 0\n  \
    \  count += 1\n  end\n  count\nend", "  total = 0\n  n.times do |i|\n    total\
    \ += 1 if i==1 && i==n || i==n-1 && i==n\n  end\n  total\nend", "  count = 0\n\
    \  (1..n).each { |i| break if (!i % (10 ** i)) && i = (i - 1) if i % 10 == 1 &&\
    \ i != 0 }\n  return count\nend", "  ones = 0\n  start =\n  count =\n  until start\
    \ == 0\n    if number % 10 == 0\n      ones += 1\n      count -= 1\n    number\
    \ /= 10\n  puts ones\n  puts count\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\nI didn't downvote you, but your solution won't work if you get passed\
    \ a negative number `n`, since you will be comparing a negative number to a positive\
    \ number in `number /= 10`. Ruby will coerce `0` to a positive number when doing\
    \ a numeric division, so your code will still fail.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\nHere's another solution:\n<code>", "  count = 1\n  while n > 0\n    count\
    \ += 1\n    n /= 10\n  end\n  count\nend", "  return n.to_s.chars.map(&:to_i).reduce(:+)\
    \ - n if n < 10\n  \n  return starts_one_ends(n/10) + 1 if n % 10 == 0\nend",
  "  counter = 0\n  for i in 0...n\n    if n%i == 0\n      counter += 1\n      i\n\
    \    end\n  end\n  return counter\nend", "  return n - sum(1..n).step(n / 2).count\n\
    end", "  n.times { |i| p =.start_with?(1) && @count.fetch(@count[i] && @count[i]\
    \ - 1) }\nend\n</code>\nFor a large n you should consider changing what kind of\
    \ hash you are using.\n<|/ a tags=ruby |>\n<| c |>\nHi, I tried your code and\
    \ it works, just to point out the `@count` variable is actually an array not hash,\
    \ you forgot to put a `=` sign in front of it.\n<|/ c |>\n<| c |>\n: I used a\
    \ hash because I felt that would work better since we are not concerned about\
    \ key collisions. But if your array is already sorted, then you can use a hash\
    \ and avoid the collisions.\n<|/ c |>\n<| c |>\nHi, I have tested your code and\
    \ it works, just to point out the `@count` variable is actually an array not hash,\
    \ you forgot to put a `=` sign in front of it.\n<|/ c |>\n<| c |>\n: I didn't\
    \ forget. Did you?\n<|/ c |>\n<| c |>\nYes I did, sorry for the late reply, I\
    \ was trying to solve this problem on my own :)\n<|/ c |>\n<| a dscore=1 tags=ruby\
    \ |>\nIf you're really looking for a solution that works across languages/environments,\
    \ try this:\n<code>", "    count = 0\n    while n > 0 do\n        if n % 10 ==\
    \ 1 then\n            count = count + 1\n        end\n        n = n / 10\n   \
    \ end\n    return count\nend\n</cell>\n<code language=julia-1.3>\nstarts_one_ends(1000)\n\
    </cell>\n<code language=julia-1.3>\nstarts_one_ends(20000)\n</cell>\n<text>\n\
    Exercise\nWrite a function that returns $x$ to the power of $y$.", "  ones = 0\n\
    \  n.times { |i| ones << i if i.to_s(10).start_with?('1') }\n  ones\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThanks for the answer! I guess I'm going to\
    \ keep thinking about this problem and see if I can come up with something with\
    \ recursion. I think that using recursion is a great idea.\n<|/ c |>\n<| c |>\n\
    This does not answer the question of how `starts_one_ends` is implemented.\n<|/\
    \ c |>\n<| c |>\nThe OP asked how to convert `starts_one_ends` to a recursive\
    \ solution. I think it answers the question. In fact, it's a pretty cool recursive\
    \ solution.\n<|/ c |>\n<| c |>\nI understand that. But the OP asked _how_ to do\
    \ it, not _how_ to do it. `starts_one_ends` is implemented in such a way that\
    \ it answers the question. The question is about recursion.\n<|/ c |>\n<| c |>\n\
    Actually, I don't see how `starts_one_ends` could be implemented using a recursive\
    \ solution. The only way that could work is if you could create a method that\
    \ finds all substrings of a particular length matching a given regex, and then\
    \ sum the length of those strings. But that doesn't work, because that requires\
    \ you to match the whole input string. Your solution of `starts_one_ends` is far\
    \ more efficient than my solution of counting the number of occurrences of \"\
    1\" in a string, and it just needs to match the whole input string. My solution\
    \ needs `O(n)` space where as yours need `O(1)`.\n<|/ c |>\n<| a dscore=3 |>\n\
    Here's one way:\n<code>", "  return n.times.map { |i| (i * 10 ** i).to_i[1..n]\
    \ }.uniq.count\nend", "  n.times.map { |i| i if i.to_s.scan(/^1/).length == 1\
    \ }.count\nend\n</code>\nNote that this code will run in O(n) time and not O(n^2)\
    \ time as the question requires.\n<|/ a |>\n<| a dscore=0 tags=ruby,algorithm\
    \ |>\nHere's a solution with O(1) space:\n<code>", "  count = n\n  while n > 1\n\
    \    count += n / 10.to_i - (n % 10).to_i\n    n /= 10\n  end\n  count\nend",
  "  number_counts = Hash.new(0)\n  (1..n).each do |i|\n    number_counts[i - 1] =\
    \ number_counts[i - 1] + 1\n  end\n  number_counts[n] = 1\n  number_counts\nend",
  "  starts_ends.each do |starts_end|\n    if starts_end[0].is_a? Array\n      return\
    \ starts_end[0][n - 1] + 1\n    end\n  end\n  0\nend", "  1.upto(Math.sqrt(n)\
    \ + 1) do |i|\n    return (i == n) ? i if n % i == 0 : (i if n % i == 0)\n  end\n\
    end", "  count = 1\n  while n > 0\n    if n % 10 == 1 && n % 100 != 11\n     \
    \ count += 1\n    n /= 10\n  end\n  count\nend", "  if n < 0\n  then return nil\n\
    \  else return ndigit(n) + 1 + starts_one_ends(n - 1)\n  end\nend", "  (0..n).inject(0)\
    \ {|acc, i| acc += 1 if i % 10**n == 0}\nend", "  count = 0\n  n = (n.to_s.split('-').first)\n\
    \  digits = n.to_s.split('-').last.split('').map(&:to_i)\n  digits.each do |d|\n\
    \    count += 1 if d > 0 && d % 2 == 1\n  end\n  count\nend", "  # Your code here\n\
    \  a = []\n  puts a.length if a.length < n && n == 1\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis is what I was looking for. Thank you so much!\n<|/ c |>\n\
    <| a dscore=0 tags=ruby |>\n<code>\nrequire 'set'\nn = 10\nresult = []\n(1..n).each\
    \ do |i|\n  result.push(1..i).map { |j| n-i - (j-1) }\n  puts result\nend", " \
    \ count = 0\n  for i in (n.to_s.split(//)).map(&:to_i)\n    if i==1 && n==1 then\
    \ count += 1 end\n    if i==1 then count += 1 end\n  end\n  count\nend", "  count\
    \ = 0\n  i = 1\n  while i <= n do\n    if i == 1 || i % 10 == 1 then\n      count\
    \ = count + 1\n      i = i + 1\n    end\n    i = i + 1\n  end\n  count\nend\n\
    assert starts_one_ends(1) == 0 # check base case 1\nassert starts_one_ends(10)\
    \ == 0 # check base case 2\nassert starts_one_ends(21) == 0 # check base case\
    \ 3\nassert starts_one_ends(25) == 0 # check base case 4\nassert starts_one_ends(251)\
    \ == 0 # check base case 5\nassert starts_one_ends(100) == 1 # check base case\
    \ 6\nassert starts_one_ends(123) == 3 # check base case 7\nassert starts_one_ends(10000000000)\
    \ == 4\nassert starts_one_ends(100000000001) == 4 # check base case 8\nassert\
    \ starts_one_ends(100000000) == 5\nassert starts_one_ends(1000000001) == 5 # check\
    \ base case 9\nassert starts_one_ends(10000000) == 6\nassert starts_one_ends(100000001)\
    \ == 6 # check base case 10\nassert starts_one_ends(1000000) == 7\nassert starts_one_ends(10000001)\
    \ == 7 # check base case 11\nassert starts_one_ends(1000000) == 8\nassert starts_one_ends(10000001)\
    \ == 8 # check base case 12\nassert starts_one_ends(100000) == 9\nassert starts_one_ends(1000001)\
    \ == 9 # check base case 13\nassert starts_one_ends(10000) == 10\nassert starts_one_ends(100001)\
    \ == 10 # check base case 14\nassert starts_one_ends(1000) == 11\nassert starts_one_ends(1001)\
    \ == 11 # check base case 15\nassert starts_one_ends(1010) == 12\nassert starts_one_ends(1011)\
    \ == 12 # check base case 16\nassert starts_one_ends(100000000000) == 13\nassert\
    \ starts_one_ends(100000000001) == 13 # check base case 17\nassert starts_one_ends(100000000002)\
    \ == 13 # check base case 18\nassert starts_one_ends(100000000003) == 13 # check\
    \ base case 19\nassert starts_one_ends(100000000004) == 13 # check base case 20\n\
    assert starts_one_ends(100000000005) == 13 # check base case 21\nassert starts_one_ends(100000000006)\
    \ == 13 # check base case 22\nassert starts_one_ends(100000000007) == 13 # check\
    \ base case 23\nassert starts_", "  count = n.to_s.length\n  n.to_s.split(\"\"\
    ).each do |i|\n    i.to_i.next? && count += 1 if i.to_i == 1\n  end\n  count\n\
    end", "  n.to_s.count(\"1\") + n.to_s.count(\"0\") - n.to_s.count(\"0\"+\"1\"\
    *(n-1)) if n > 0\nend", "  count = 0\n  for i in (n - 1).downto(0) do\n    count\
    \ += (i / 10**i).floor.to_i.odd?\n  end\n  count\nend", "  result = {}\n  ndigits\
    \ = n.to_s.size\n  ones_digits = n.to_s.chars.map(&:to_i).map(&:abs).sort.reduce(:+)\n\
    \  (0...ndigits).each do |i|\n    result[i] = ones_digits - ndigits*(i-1)\n  end\n\
    \  result\nend", "  return 0 if n < 10 else (1..n).count { |i| i.odd? && i.to_s.to_i\
    \ == '1' }\nend", "  count_starts = 0\n  count_ends = 0", "  ones, zeros = 0,\
    \ 0\n  while n > 0 do\n    ones += 1\n    if n % 10 == 1 then return ones end\n\
    \    n /= 10\n    zeros += 1\n    if n % 10 == 0 then return zeros end\n    n\
    \ /= 10\n  end\n  return ones\nend", "  count = { 0 => 0 }\n  while n > 0\n  \
    \  count[n] = count[n] + 1 if n%10 == 1 else 0\n    n /= 10\n  end\n  count\n\
    end", "  n.to_s.chars.each_with_index.count { |x, i| x == \"1\" } + n.to_s.chars.size\
    \ - 1\nend", "  count = 0\n  digits = n.to_s.split(//)\n  digits.each do |d|\n\
    \    if d == \"1\"\n      count += 1\n    else\n      break\n    end\n  end\n\
    \  count\nend", "  ones = n.digits.reverse.find_all { |d| d == '1' }\n  ones =\
    \ ones.size\n  (ones - n.digits.reverse.find_all { |d| d == '0' }).ceil / n.digits.reverse.length\n\
    end", "    start, count = 1, 1\n    (n -= 1).times { start += n }\n    (n /= 10).times\
    \ { count += (n / 10).to_i }\n    start.upto(start) { |x| count += (x == 1 ? 0\
    \ : 1) }\n    count\nend", "  count = 0\n  for i in 1..n\n    if digit(i) == 1\n\
    \      count += 1\n    end\n  end\n  count\nend\n</cell>\n<code language=julia-1.1>",
  "  (1..n).select { |i| (i % 100).zero? || (i % (10 ** 9)).zero? }.length\nend\n\
    </code>\n<|/ a |>\n<| a tags=ruby |>\nSince you asked for efficiency\n<code>",
  "  n = (n.to_s.length)\n  n.times do |i|\n    if ((i % 2) != 0)\n      start = ((i/2)\
    \ - 1).abs\n      end = ((i/2) - 2).abs\n      if ((n >= start) and (n <= end))\n\
    \        return 1\n      end\n    end\n  end\n  0\nend", "  ones = n.to_s.count(\"\
    1\")\n  until = ones + n.to_s.length\n  ones_until = until.to_s.count(\"1\")\n\
    \  (ones_until.zero? ? until : until-ones_until)\nend", "  one_count = 0\n  two_one_count\
    \ = 0\n  three_count = 0\n  five_count = 0\n  while n > 0\n    if n % 100 == 1\
    \ | n % 100 == 2 | n % 100 == 3 | n % 100 == 5 | n % 100 == 7 | n % 100 == 9\n\
    \      one_count += 1\n    elsif n % 100 == 0 | n % 100 == 1 | n % 100 == 2 |\
    \ n % 100 == 3 | n % 100 == 4 | n % 100 == 5 | n % 100 == 6 | n % 100 == 7\n \
    \     two_one_count += 1\n    elsif n % 100 == 0 | n % 100 == 1 | n % 100 == 2\
    \ | n % 100 == 3 | n % 100 == 4 | n % 100 == 5 | n % 100 == 6 | n % 100 == 7 |\
    \ n % 100 == 8\n      three_count += 1\n    elsif n % 100 == 0 | n % 100 == 1\
    \ | n % 100 == 2 | n % 100 == 3 | n % 100 == 4 | n % 100 == 5 | n % 100 == 6 |\
    \ n % 100 == 7 | n % 100 == 8\n      five_count += 1\n    end\n    n -= 1\n  end\n\
    \  return one_count, two_one_count, three_count, five_count\nend\np starts_one_ends(99)\n\
    p starts_one_ends(100)\np starts_one_ends(101)\np starts_one_ends(102)\np starts_one_ends(103)\n\
    p starts_one_ends(104)\np starts_one_ends(105)\np starts_one_ends(106)\np starts_one_ends(107)\n\
    p starts_one_ends(108)\np starts_one_ends(109)\np starts_one_ends(110)\np starts_one_ends(111)\n\
    p starts_one_ends(112)\np starts_one_ends(113)\np starts_one_ends(114)\np starts_one_ends(115)\n\
    p starts_one_ends(116)\np starts_one_ends(117)\np starts_one_ends(118)\np starts_one_ends(119)\n\
    p starts_one_ends(120)\np starts_one_ends(121)\np starts_one_ends(122)\np starts_one_ends(123)\n\
    p starts_one_ends(124)\np starts_one_ends(125)\np starts_one_ends(126)\np starts_one_ends(127)\n\
    p starts_one_ends(128)\np starts_one_ends(129)\np starts_one_ends(130)\np starts_one_ends(131)\n\
    p starts_one_", "  one_count = 0\n  starts_one_ends_count = 0\n  \n  i = 0\n \
    \ while i < n\n    if i % 10 == 1\n      one_count += 1\n      i += 9\n      next\n\
    \    end\n    i += 1\n  end\n  \n  if one_count > 0 \n    starts_one_ends_count\
    \ = n - one_count - 1\n  end\n  \n  return starts_one_ends_count\nend", "  (n\
    \ - 1).downto(1).inject(0) do |acc, i|\n    acc += (i && n.to_s.slice(i)).length\n\
    \    acc -= (i && !n.to_s.slice(i)).length\n  end\nend\n</code>\nThis could be\
    \ cleaned up a bit but is probably easier to understand (and perhaps faster).\n\
    <code>", "  count = 0\n  strn = n.to_s\n  strn.gsub!(/^1/, '')\n  if strn.length\
    \ == n\n    count += 1\n  end\n  strn.gsub!(/1/, '')\n  if strn.length == n\n\
    \    count += 1\n  end\n  if strn.length >= n\n    strn.reverse!\n    until strn.length\
    \ == n\n      strn.gsub!(/1/, '')\n      if strn.length == n\n        count +=\
    \ 1\n      end\n    end\n  end\n  return count\nend", "  return 0 if n < 10 #\
    \ Base case\n  return 1 if n % 10 == 1 # Base case\n  return 1 + starts_one_ends(n/10)\
    \ # Recursive case\nend\n</cell>\n<cell>", "  count = 0\n  i = 2\n  while i <=\
    \ n\n    i += 1\n    while i <= n && i % 10 == 1\n      count += 1\n      i +=\
    \ 1\n  end\n  count\nend", "  count = 0\n  i = 0\n  while i < n\n    if i % 10\
    \ == 1\n      count += 1\n    end\n    i += 1\n  end\n  count\nend", "  (0..n).reduce(0)\
    \ { |acc, x| acc + (x % 10 == 1 && x % 100 != 11) }\nend\n</code>\nNow the question\
    \ is, do you really need this kind of performance?\n<|/ a tags=ruby,big-o,algorithm,complexity-theory\
    \ dscore=2 |>\n<| a tags=ruby,big-o,algorithm,complexity-theory dscore=2 |>\n\
    If you wanted to optimize this more, you could consider using a binary search\
    \ to find the number of 1's at the end of n. You could also store a binary tree\
    \ of 1's for faster access (O(log n) lookups).\nThe code would be similar to what\
    \ you have already posted, except that you'd have to perform the binary search\
    \ to find the last digit of n to count the number of 1's there.\n<|/ a |>\n<|\
    \ a dscore=1 tags=ruby,big-o,algorithm,complexity-theory |>\nHere's my take on\
    \ the problem.\nIt has some more requirements than others (no negative numbers,\
    \ no duplicates, no overlapping ranges, etc.), but is O(n) in time and space.\n\
    <code>", "  count = starts_one_ends_counts[n]\n  return count\nend", "  one =\
    \ n.to_s.split(//)[1].to_i\n  one_range = (1..one).to_a\n  one_range.select do\
    \ |i|\n    one_range.first == i\n  end.length\nend", "  n.to_s.length.times.collect\
    \ { |i| (i + 1) % n == 0 ? 1 : 0 }\nend", "  digits = n.digits.to_a\n  count =\
    \ 0\n  digits.each do |digit|\n    if digit.to_s == \"1\"\n      count += 1\n\
    \    end\n  end\n  count\nend", "  s = 0\n  n.downto(1) do |x|\n    s += (x %\
    \ 10 == 0 ? 0 : 1) == (x % 100 != 0 ? 1 : 0)\n  end\n  s\nend", "  count = 0\n\
    \  x = n.to_s.to_i\n  n.downto(1).each do |i|\n    next if i.to_s.to_i == x\n\
    \    count += 1 if i.to_s.to_i == 1\n  end\n  count\nend", "  counts = n.times.with_object(Hash.new(0))\
    \ { |i, h| h[i..-1] = i }\n  counts[0, -1]\nend", "  count = 0\n  i = 2\n  while\
    \ i < n\n    i += 1\n    count += 1 if i <= n && n % i == 0\n  end\n  count\n\
    end", "  if n == 0\n    return 0\n  end", "  count = n.to_s.scan(/\\d/).count\
    \ { |x| x == 1 }\n  n.to_s.size - count\nend", "  count = 0\n  ndigits = n.to_s.length\n\
    \  while n > 0\n    n -= 1\n    count += 1\n    if n.to_s.length == ndigits\n\
    \      break if n == 1\n    end\n  end\n  return count\nend", "  count = 1\n \
    \ while n > 0\n    count = count + (n % 10).zero? ? n / 10 : 0\n    n /= 10\n\
    \  end\n  count\nend", "  (1..n).count { |i| i[-1] == 1 && i[0..(n.digit-1)] ==\
    \ 1 }\nend", "  n.times.map { |i| n % (i * 10 + 1) }.select { |i| i==1 }.size\n\
    end", "  ndigits = n.to_s.length\n  if ndigits == 1\n    0\n  elsif ndigits ==\
    \ 2\n    1 if (n % 2 == 1)\n  elsif ndigits > 2\n    n / 10 + ((n % 10).to_s.length\
    \ - starts_one_ends(n / 10))\n  else\n    raise(\"Bad argument\")\n  end\nend",
  "  i = 1\n  count = 0\n  while i <= n\n    count += 1 if i / (10 ** i) % 1 == 0\n\
    \    i += 1\n  end\n  count\nend", "  count = 1\n  loop do\n    break if n <=\
    \ 0\n    if n % 10 == 1 && n / 10 % 10 != 1\n      count += 1\n    end\n    n\
    \ /= 10\n  end\n  return count\nend", "  digits = n.to_s\n  digits.reverse.chars.map\
    \ { |c| c == '1' ? 1 : 0 }.reduce(:+).to_i\nend", "  count = 0\n  while n\n  \
    \  count += 1\n    n /= 10\n  end\n  count\nend\n</code>\n<|/ a dscore=1 tags=ruby,loops\
    \ |>\n<| a |>\nHere's a way to do this in ruby\n<code>", "  count = 0\n  i = 0\n\
    \  while i < n\n    if !(i^1 % 10) == 1\n      count += 1\n      i += 1\n    end\n\
    \    i += 1\n  end\n  count\nend", "  starts = []\n  i = 0\n  while i < n\n  \
    \  if i % 10 == 1 and i % 10 != 11\n      starts += 1\n    i += 1\n  end\n  starts\n\
    end\n</cell>\n<cell>\nstarts_one_ends(3)\n</cell>\n<cell>\nstarts_one_ends(4)\n\
    </cell>\n<cell>\nstarts_one_ends(6)\n</cell>\n<cell>\nstarts_one_ends(5)\n</cell>\n\
    <cell>\nstarts_one_ends(8)\n</cell>\n<cell>\nstarts_one_ends(10)\n</cell>\n<cell>\n\
    starts_one_ends(20)\n</cell>\n<cell>\nstarts_one_ends(24)\n</cell>\n<cell>\nstarts_one_ends(30)\n\
    </cell>\n<cell>\nstarts_one_ends(35)\n</cell>\n<cell>\nstarts_one_ends(45)\n</cell>\n\
    <cell>\nstarts_one_ends(50)\n</cell>\n<cell>\nstarts_one_ends(60)\n</cell>\n<cell>\n\
    starts_one_ends(65)\n</cell>\n<cell>\nstarts_one_ends(70)\n</cell>\n<cell>\nstarts_one_ends(75)\n\
    </cell>\n<cell>\nstarts_one_ends(80)\n</cell>\n<cell>\nstarts_one_ends(85)\n</cell>\n\
    <cell>\nstarts_one_ends(90)\n</cell>\n<cell>\nstarts_one_ends(100)\n</cell>\n\
    <cell>\nstarts_one_ends(123)\n</cell>\n<cell>\nstarts_one_ends(125)\n</cell>\n\
    <cell>\nstarts_one_ends(130)\n</cell>\n<cell>\nstarts_one_ends(135)\n</cell>\n\
    <cell>\nstarts_one_ends(140)\n</cell>\n<cell>\nstarts_one_ends(145)\n</cell>\n\
    <cell>\nstarts_one_ends(150)\n</cell>\n<cell>\nstarts_one_ends(155)\n</cell>\n\
    <cell>\nstarts_one_ends(160)\n</cell>\n<cell>\nstarts_one_ends(165)\n</cell>\n\
    <cell>\nstarts_", "    count = 0\n    (1..n).each do |i|\n        if i.to_s.rjust(n,\
    \ \"1\").to_i == 1\n            count += 1\n        end\n    end\n    count\n\
    end", "  n = (n..9).to_a\n  n.count{ |e| e == 1 || e == 10 || e == 9 || e == 8\
    \ }\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYour first solution (which I haven't\
    \ tried) doesn't work for the number `100`. It counts it as `1` even though it's\
    \ a `0` digit\n<|/ c |>\n<| c |>\n: You're right, I didn't take that into account,\
    \ thanks. I just corrected it with the solution I came up with. Thanks.\n<|/ c\
    \ |>\n<| c |>\nHmm, I thought I was just getting myself confused on how to find\
    \ the count of any given number (not necessarily a 1 digit number) of n digits.\n\
    <|/ c |>\n<| c |>\n: Oh you just wanted the count of the positive integers that\
    \ start or end with 1. In that case, this is the most elegant and simple solution\
    \ I could come up with. It does what it's supposed to do, even when the number\
    \ is greater than 1000.\n<|/ c |>\n<| c |>\n: I just added a better one. Let me\
    \ know if it helps.\n<|/ c |>\n<| a dscore=1 |>\nUsing enumerable (but could be\
    \ rewritten in other ways):\n<code>", "  i = 0\n  while i < (n/10)\n    i = i\
    \ + 1\n    count = 0\n    while ((i + n) / 10).to_s !~ /^1$/\n      count = count\
    \ + 1\n      i = i + 1\n    end\n    return count\n  end\n  count = 0\n  while\
    \ i < (n/10)\n    i = i + 1\n    count = 0\n    while ((i - n) / 10).to_s !~ /^1$/\n\
    \      count = count + 1\n      i = i\n    end\n    return count\n  end\nend",
  "  count = 0\n  while n > 0\n    count += n % 10 == 0\n    n /= 10\n  end\n  count\n\
    end", "  num = 1\n  i = 1\n  count = 0\n  while i <= n\n    num = num * 10 + 1\n\
    \    i += 1\n    count += 1\n  end\n  count\nend", "  if n<2\n    return 0\n \
    \ i = 0\n  count = 0\n  while i*i <= n\n    if n % i == 0\n      count = count+1\n\
    \    i = i + 1\n  end\n  count\nend", "  count = 0\n  (1..n).each do |i|\n   \
    \ count += 1 if i % 10 == 1\n    count += 1 if i % 10 == -1\n    count += 1 if\
    \ i.to_s.chars.map(&:to_i).first % 10 == 1\n    count += 1 if i.to_s.chars.map(&:to_i).first\
    \ % 10 == -1\n  end\n  return count\nend", "  count = 0\n  n *= 10\n  while n\
    \ > 0\n    n /= 10\n    count += 1\n  end\n  count\nend", "  starts = n.to_s.reverse.scan(/1\\\
    z/)\n  \n  # if there's only one digit in the string, then it starts with \"1\"\
    \ and\n  # ends with \"1\"\n  case starts\n    when [[1]]\n      1\n    when [[1,2]]\n\
    \      2\n    when [[1,2,3]]\n      3\n    when [[1,2,3,4]]\n      4\n  end\n\
    end", "  ones = 0\n  i = n\n  while i > 1\n    ones +=1\n    i-= 1\n  end\n  ones\n\
    end", "  return 1 if n < 10 then 0 else n / 10 + (n % 10 == 1).floor\nend", " \
    \ starts = []\n  loop {\n    next unless n % 10 == 0\n    if n%100 == 0 then break\n\
    \    if n%1000 == 0 then next if n%10000000 == 0 else break\n    start = n/10\n\
    \    start = 1 if start==1 else start\n    start = 100 if start%100 == 0 else\
    \ start\n    start = 1000 if start%1000 == 0 else start\n    start = 10000000\
    \ if start%1000000 == 0 else start\n    start = 1000000000 if start%10000000 ==\
    \ 0 else start\n    start = 1000000000000 if start%1000000000000 == 0 else start\n\
    \    start = 1000000000000000 if start%100000000000000 == 0 else start\n    start\
    \ = 1000000000000000000 if start%1000000000000000000 == 0 else start\n    starts.push(start)\n\
    \    n -= start\n  }\n  starts.reduce(0) {|sum, start| sum + start}\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 tags=algorithm,ruby |>\n<code>", "  ones = 0..n.to_s\n\
    \  ones = ones.select { |one| one.to_i.to_s == one[one.length -1].to_s }\n  ones.count\n\
    end", "  return 1 if n == 1 || n == 2 || n == 3 || n == 4 || n == 5 || n == 6\
    \ || n == 7 || n == 8 || n == 9\n    || n == 10 || n == 11 || n == 12 || n ==\
    \ 13 || n == 14 || n == 15 || n == 16\n    || n == 17 || n == 18 || n == 19 ||\
    \ n == 20 || n == 21 || n == 22 || n == 23\n    || n == 24 || n == 25 || n ==\
    \ 26 || n == 27 || n == 28 || n == 29 || n == 30 || n == 31 || n == 32\n    ||\
    \ n == 33 || n == 34 || n == 35 || n == 36 || n == 37 || n == 38 || n == 39 ||\
    \ n == 40 || n == 41\n    || n == 42\n  else if n >= 43 && n <= 48\n    return\
    \ 1 + (n - 43)\n  else\n    return 0\nend", "  count = 0\n  (1..n).each do |i|\n\
    \    if (i % 10 == 1 && i / 10 % 10 != 1) ||\n      (i % 10 == 0 &&\n       (i\
    \ / 10).to_s.rjust(10, '0').rindex('1') != 0)\n      count += 1\n    end\n  end\n\
    \  count\nend", "  digits = n.to_s.chars.map(&:to_i)\n  one = digits.first(1)\n\
    \  n_digits = n - one.length\n  start_or_end = one.zip(digits).count { |i,j| j\
    \ == n_digits }\n  start_or_end\nend", "  n.to_s.split('').grep(/1/).size\nend",
  "  start = n\n  while start > 0 && starts_one_end?(start)\n    start -= 1\n  end\n\
    \  end = n\n  while end < Number.max && starts_one_end?(end)\n    end += 1\n \
    \ end\n  end - start\nend", "  n.to_s.chars.each_with_index.\n      select { |_,\
    \ i| i.zero? || i % 10 == 1 }.size\nend", "  # Create an array holding the number\
    \ of possible digits that can be\n  # found in a n-digit number.\n  possible_digits\
    \ = Array.new(10) { |i| i + n }", "  n.times do\n    return 1 if n.to_s.reverse.gsub!(/\\\
    d/, '').start_with?('1')\n    break if n==0\n    n -= 1\n  end\n  0\nend", " \
    \ return n.to_s.scan(/^1*\\d+/).count\nend", "  n.downto(1) do |x|\n    return\
    \ 0 if n == 1\n    return 1 if n == 0\n    return 0 if n % 10 == 0\n    return\
    \ 1 if n % 10 == 1\n  end\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| a tags=ruby,algorithm\
    \ |>\nYou can use the following code:\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
