name: HumanEval_98_count_upper
language: rb
prompt: "# Given a string s, count the number of uppercase vowels in even indices.\n\
  # For example:\n# count_upper('aBCdEf') returns 1\n# count_upper('abcdefg') returns\
  \ 0\n# count_upper('dBBE') returns 0\ndef count_upper(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_upper\n\
  \    candidate = method(:count_upper)\n    assert_equal(1, candidate.call(\"aBCdEf\"\
  ))\n    assert_equal(0, candidate.call(\"abcdefg\"))\n    assert_equal(0, candidate.call(\"\
  dBBE\"))\n    assert_equal(0, candidate.call(\"B\"))\n    assert_equal(1, candidate.call(\"\
  U\"))\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(2, candidate.call(\"\
  EEEE\"))\n  end\nend\n"
completions: ["    count = 0\n    for i in 0...s.length\n        if s[i] >= 'a' and\
    \ s[i] <= 'z'\n            count = count+1\n        end\n    end\n    return count\n\
    end", "  return s.chars.each_with_index.with_object(Hash.new(0)){|(c, n), h| h[c]\
    \ += n if n}\n                                          .select { |c, _| c ==\
    \ 'A'} # Count uppercase vowels\n                                          .each_with_index.inject(:+)\
    \ # Add their values\nend\np count_upper('abcde')", "  count = 0\n  \n  for letter\
    \ in s\n    if letter.isupper\n      if letter.zero?\n        count += 1\n   \
    \   else\n        count += 2\n      end\n    end\n  end", "  s.downcase!\n  s.count(\"\
    A\"..\"Z\").even? ? s.count(\"A\"..\"Z\").to_i : 0\nend", "  s.chars.each_with_index.inject(0)\
    \ {|tot,(c,i)| tot += 1 if i & 1 ; tot}\nend", "  s.split.each_with_index.inject(0)\
    \ do |n, (l, k)|\n    n += 1 if k % 2 == 0 && l == 'u'\n  end\nend", "\tvowels='AEIOU'\n\
    \ts.scan(/(.)(.)/).to_a\n\ts.count.select{|x|x.to_s.scan(vowels).size % 2 == 0}\n\
    end", "  return s.chars.each_with_index.inject(0) { |c,(v,i)| v && c += 1 if (i&1)\
    \ == 0; c }\nend\n</code>\nNow we can apply this function to every character in\
    \ each string in an array:\n<code>\nvowels.map {|s| count_upper(s)}", "  s.downcase!\n\
    \  s.scan(/[a-z]\\z/).count(0) / 2\nend", "    count = 0\n    even_indexes = []\n\
    \    \n    # Count even indices.\n    # Given a string s, count the number of\
    \ uppercase vowels in even indices.\n    # For example:\n    # count_upper('aBCdEf')\
    \ returns 1\n    # count_upper('abcdefg') returns 0\n    # count_upper('dBBE')\
    \ returns 0\n    even_indexes = 0..s.size-1\n    even_indexes.each do |n|\n  \
    \      if s[0..(n-1)] == \"A\"..\"Z\"\n            count += 1\n        end\n \
    \   end\n    \n    # Return count.\n    return count\nend\n</code>\n<|/ a tags=string,ruby\
    \ |>\n<| c |>\nYou shouldn't use an enumerator for just counting something, it's\
    \ a bit slower and less readable than using `each`.\n<|/ c |>\n<| c |>\nI agree\
    \ with you. I edited the answer to add an alternative solution.\n<|/ c |>\n<|\
    \ c |>\nThanks for your help and edit! I also learned that `count` can be used\
    \ as a ternary. Thank you for your help!\n<|/ c |>\n<| c |>\nYou could use `s.each_char.each_cons(2).any?\
    \ { |c| c.first.is_a?(String) && c.last.is_a?(String) }` to avoid creating a `#count`\
    \ method, which would still be more expensive than `#count` (which is O(n)). Using\
    \ `each_cons` would avoid creating an enumerator to iterate over the whole string.\n\
    <|/ c |>\n<| c |>\nThank you. Great idea. I edited the answer.\n<|/ c |>\n<| a\
    \ |>\n<code>", "  s.downcase!\n  s.chars.each_with_index.inject(0) {|sum, (_,\
    \ i)| i & 1 ? sum + 1 : sum }\nend", "  s.chars.each_with_index.inject(0) do |count,\
    \ (c, i)|\n    if i % 2 == 0 && c =~ /[AEIOU]/\n      count += 1\n    end\n  \
    \  count\n  end\nend\n</cell>\n<code language=julia-1.1>\ncount_upper(\"aBCdEf\"\
    )\n</cell>\n<code language=julia-1.1>\ncount_upper(\"abcdefg\")\n</cell>\n<code\
    \ language=julia-1.1>\ncount_upper(\"dBBE\")\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes in a string and returns the number of vowels contained\
    \ within it.", "  count = 0\n  s.split('').each_with_index do |letter, i|\n  \
    \  if letter == letter[0] && letter.upcase != letter\n      count += 1\n    elsif\
    \ i % 2 == 0 && letter.upcase != letter\n      count += 1\n    end\n  end\n  return\
    \ count\nend", "  s.each_char do |char|\n    if (char == 'a' || char == 'e' ||\
    \ char == 'i' || char == 'o' || char == 'u') then puts \"true\" else puts \"false\"\
    \ end\n  end\nend", "    count = 0\n    vowels = %w[a e i o u]\n    even_indexes\
    \ = (0...s.length).select { |i| s[i] == vowels[i] } & (1..s.length).select { |i|\
    \ s[i] == vowels[i] }\n    even_indexes.each do |i|\n        count += 1 if s[i]\
    \ == vowels[i] && (i & 1) == 0\n    end\n    count\nend", "  vowels = 'AEIOU'\n\
    \  count = 0\n  \n  # Look for the index of the first uppercase letter\n  index\
    \ = s.index(vowels.upcase)\n  \n  while index < s.length\n    index = index +\
    \ vowels.length\n    count = count + 1\n    index = s.index(vowels.upcase, index)\n\
    \  end\n  \n  return count\nend", "  count = 0\n  s.each_char do |c|\n    if c.upcase\
    \ == c\n      count += 1\n    elsif (c == 'A' || c == 'a')\n      count += 1\n\
    \    elsif (c == 'E' || c == 'e')\n      count += 1\n    elsif (c == 'I' || c\
    \ == 'i')\n      count += 1\n    elsif (c == 'O' || c == 'o')\n      count +=\
    \ 1\n    elsif (c == 'U' || c == 'u')\n      count += 1\n    end\n  end\n  count\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you so much for taking the time to explain\
    \ and explain your code. You have helped me alot! I will be sure to review my\
    \ code in the future. Thank you so much!\n<|/ c |>\n<| c |>\nNo problem, glad\
    \ it helped. If this is for a class, you should probably take a look at some tutorials.\
    \ I'm afraid if you're not clear on most of the concepts around string manipulation\
    \ it would take quite a bit of time to grasp.\n<|/ c |>\n<| c |>\nOh okay. I will\
    \ look into it. Thanks again for explaining your code! Really helped me!\n<|/\
    \ c |>\n<| a tags=ruby,string |>\nThis solution works for arbitrary strings of\
    \ arbitrary length. You don't need to know the length of the string, but just\
    \ the number of capital letters up to the end of the string.\n<code>", "  count\
    \ = 0\n  s.each_index { |i| count += 1 if s[i] == s[i].upcase }\n  count\nend",
  "  return s.chars.map(&:upcase).count(true) \nend", "  s.split.each_with_index do\
    \ |e, i|\n    if (i % 2 == 0) then\n      count_upper(e)\n    end\n  end\nend",
  "  s.each_char.with_index.inject(0) {|s,(s,i)| i && i % 2 == 0 && s.upcase == s\
    \ ? '1' : '0' }\nend", "  s.chars.map { |c| if c.upcase == c then 1 else 0 end\
    \ }.count\nend", "  s.chars.reduce(0) { |t,c| t + (c.upcase ? \"A\" : 0) }\nend",
  "  count = 0\n  s.each_index {|i| if s[i] == 'A' or s[i] == 'E' or s[i] == 'I' or\
    \ s[i] == 'O' or s[i] == 'U'\n    count += 1\n  end}\n  count\nend", "  count\
    \ = s.length\n  s.upcase !~ /[aeiou]/\n  s.gsub!(/[aeiou]{2}/) { |s| count.to_i\
    \ + 1 }\nend", "  s.split(\"\").map {|c| c =~ /[AEIOU]/i ? 1 : 0 }.max\nend\n\
    </code>\nYou can now use it in your code:\n<code>", "  s.downcase!\n  s.each_char.with_index\
    \ do |char, i|\n    if i % 2 == 0 && char.upcase == char\n      i += 1\n    end\n\
    \  end\n  s.each_char.with_index do |char, i|\n    if i % 2 == 0 && char.upcase\
    \ != char\n      i = 0\n    end\n  end\n  s.each_char.with_index do |char, i|\n\
    \    if i % 2 == 0 && char.upcase == char\n      i += 1\n    end\n  end\n  s.each_char.with_index\
    \ do |char, i|\n    if i % 2 == 0 && char.upcase != char\n      i = 0\n    end\n\
    \  end\n  s.each_char.with_index do |char, i|\n    if i % 2 == 0 && char.upcase\
    \ == char\n      i += 1\n    end\n  end\n  s.each_char.with_index do |char, i|\n\
    \    if i % 2 == 0 && char.upcase != char\n      i = 0\n    end\n  end\n  s.each_char.with_index\
    \ do |char, i|\n    if i % 2 == 0 && char.upcase == char\n      i += 1\n    end\n\
    \  end\n  s.each_char.with_index do |char, i|\n    if i % 2 == 0 && char.upcase\
    \ != char\n      i = 0\n    end\n  end\n  s.each_char.with_index do |char, i|\n\
    \    if i % 2 == 0 && char.upcase == char\n      i += 1\n    end\n  end\n  s.each_char.with_index\
    \ do |char, i|\n    if i % 2 == 0 && char.upcase != char\n      i = 0\n    end\n\
    \  end\n  s.each_char.with_index do |char, i|\n    if i % 2 == 0 && char.upcase\
    \ == char\n      i += 1\n    end\n  end\n  s.each_char.with_index do |char, i|\n\
    \    if i % 2 == 0 && char.upcase != char\n      i = 0\n    end\n  end\n  s.each_char.with_index\
    \ do |char, i|\n    if i % 2 == 0 && char.upcase == char\n      i += 1\n    end\n\
    \  end\n  s.each_char.with_index do |char, i|\n    if i % 2 == 0 && char.upcase\
    \ != char\n      i = 0\n    end\n  end\n  s.each_char.with_index do |char, i|\n\
    \    if i % 2 == 0 && char.upcase == char\n      i += 1\n    end\n  end\n  s.each_char.with_index\
    \ do |char, i|\n    if i % 2 == 0 && char.upcase != char\n      i = 0\n    end\n\
    \  end\n  s.each_char.with_index do |char", "  # TODO: Implement this\n  (0..s.count('').to_f-1).each\
    \ do |i|\n    if s[i] == s[i].upcase\n      s.slice!(i,1)\n    end\n  end\n  return\
    \ 0\nend", "  s.each_char.with_index.with_object(0) do |(char, index), count|\n\
    \    next if index&1\n    count += 1 if char.upcase == 'A'\n  end\nend\n</code>\n\
    <|/ a tags=ruby dscore=2 |>\n<| c |>\nThe OP also wants the odd indices to be\
    \ checked too.\n<|/ c |>\n<| c |>\nYes, I missed that part. I'll add some more\
    \ code to my answer to handle the situation.\n<|/ c |>\n<| a tags=ruby |>\nHere's\
    \ another way to do it, with some simplifications.\n<code>", "  s.downcase!\n\
    \  result = 1\n  s.each_char.with_index do |char, i|\n    if char == char.upcase\
    \ && i % 2 == 0\n      result += 1\n    end\n  end\n  result\nend\n</code>\n<|/\
    \ a tags=ruby,performance,algorithm |>\n<| a |>\nI like this one because it doesn't\
    \ use String#each:\n<code>", "  count = 0\n  for i in 0..s.length - 2\n    if\
    \ s[i] == s[i].upcase\n      count += 1\n    end\n  end\n  return count\nend\n\
    print(count_upper('aBCdEf'))\nprint(count_upper('abcdefg'))\nprint(count_upper('dBBE'))\n\
    </cell>\n<cell>", "  s.split('').select{|char| char.upcase == char}.count\nend",
  "  s.downcase!\n  s.each_char.with_object(Hash.new(0)) { |c,h| h[c] += 1 if c =~\
    \ /[AEIOU]/i }\nend\n</code>\n<|/ a |>\n<| c |>\nHmm, that is interesting. I'm\
    \ still trying to figure out a nice way to do the same thing without using regular\
    \ expressions...\n<|/ c |>\n<| c |>\n: I guess I'm confused. How is `[AEIOU]`\
    \ any better than `/[AEIOU]/`?\n<|/ c |>\n<| c |>\n: You mean like this?: `s.each_char.with_object(Hash.new(0))\
    \ { |c,h| h[c] += 1 if c =~ /[AEIOU]/i }`\n<|/ c |>\n<| c |>\nYeah, I guess, you're\
    \ right. My eyes were fooling me when I wrote that. My mind was fooling me when\
    \ I wrote it, and I haven't thought about it enough to see it that way. Thanks\
    \ for pointing it out!\n<|/ c |>\n<| a dscore=2 tags=ruby,string |>\nJust for\
    \ fun, I wanted to see what Ruby's regexes would do under the hood.\n<code>",
  "    count = 0\n    even = True\n    for i in s.chars\n        if i.upcase and even\n\
    \            count += 1\n            even = not even\n        end\n    end\n \
    \   count\nend", "  s.each_char.with_index do |char, i|\n    if i % 2 == 0 &&\
    \ !char.upcase? then return i end\n  end\n  0\nend", "  count = 0\n  for i in\
    \ (0...s.length)\n    if s[i] == 'A' || s[i] == 'a' || s[i] == 'E' || s[i] ==\
    \ 'e' || s[i] == 'I' || s[i] == 'i'\n      count += 1\n    end\n  end\n  count\n\
    end", "  return s.tr('AEIOUYaeiou','aeiou').count('AEIOUY')\nend", "  s.gsub(/[^AEIOU]/,'')\n\
    \    .each_char.with_object({}) { |c,h| h[c] = (h[c].to_i + 1) % 2 }\n    .select\
    \ { |_,v| v == true }.length\nend", "  count_upper = 0\n  s.each_char do |char|\n\
    \    if char.upcase == \"A\" then\n      count_upper = count_upper + 1\n    end\n\
    \  end\n  return count_upper\nend", "  even_indexes = s.chars.each_with_index.map\
    \ { |c, i| i % 2 == 0 }\n  \n  s.chars.each_with_index.map { |c, i| c == c.upcase\
    \ && even_indexes[i] }.compact.length\nend\n</code>\n<|/ a |>\n<| c |>\nI like\
    \ this solution! Though it would be even better to use a regular expression, `/\\\
    p{Upper}/` will yield `['a', 'A', 'b', 'B', 'c', 'C', 'd', 'D', 'e' ... 'y']`\n\
    <|/ c |>\n<| c |>\nThis works great, but I needed a solution that only used the\
    \ count method.  I ended up going with: `s.chars.each_with_index.map { |c, i|\
    \ c == c.upcase && i % 2 == 0 }.compact.length`\n<|/ c |>\n<| c |>\nGlad you found\
    \ your answer! Yeah, I was just looking at `Enumerable#count` today (http://ruby-doc.org/core-2.3.0/Enumerable.html#method-i-count)\
    \ and the only difference between the 2 methods is `Enumerable#count` returns\
    \ an `Integer`, whereas `Enumerable#length` returns an `Integer`. I like the `Enumerable#count`\
    \ solution though, much better. Thanks!\n<|/ c |>\n<| c |>\nNice, this is quite\
    \ similar to the accepted answer, but with more explanation. I don't know why\
    \ my answer is voted down; it works. Please see my comment to MrDanA's answer\
    \ to understand why it works.\n<|/ c |>\n<| c |>\nI don't get it. I tried the\
    \ accepted answer, and when debugging, I realized that `s.chars.each_with_index.map\
    \ { ... }` is called several times over and over. `s.chars.each_with_index.map\
    \ { |c, i| i == 0 }` is called only once. Can you please explain to me why this\
    \ is happening?\n<|/ c |>\n<| a dscore=5 tags=ruby |>\n<code>", "  # Return the\
    \ number of characters in s that are uppercase and are in even indices.\n  return\
    \ s.chars.select { |c| c.upcase && c.downcase && c%2 == 0 }.size\nend\n  ", " \
    \ even_indices = 0 \n  for i in 0...s.length\n    if s[i] =~ /[AEIOU]/\n     \
    \ even_indices += 1\n    end\n  end\n  return even_indices\nend", "  s.chars.each_with_index.inject(0)\
    \ do |n,(ch,i)|\n    n += 1 if i&1 == 0\n    n += 1 if ch == 'A' || ch == 'a'\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=string,ruby |>\n<code>\n\
    \ s = 'AaBbCcDdEeFfGgHh'", "    upper = 0\n    s.each_index { |i| upper = 1 if\
    \ s[i] >= 'A' && s[i] <= 'Z' && s[i].upcase == true }\n    upper\nend", "  s.each_char.with_object(0)\
    \ do |c,h|\n    if (c == 'A') || (c == 'a') || (c == 'E') || (c == 'e')\n    \
    \  h += 1\n    end\n  end\nend", "  s.gsub!(/[[:upper:]]/, '')\n  s.chars.each_with_index.with_object(Hash.new(0))\
    \ do |(char, idx), h|\n    h[char] ? h[char] += idx : h[char] = 1\n  end\nend",
  "  s.split('').each_with_index.inject(0) do |n,(c,i)|\n    n + (c == 'a' ? 0 : (c\
    \ == 'A' ? 1 : c == 'B' ? 2 : c == 'C' ? 3 : c == 'D' ? 4 : c == 'E' ? 5 : c ==\
    \ 'F' ? 6 : 0))\n  end\nend", "    s.each_char.with_index do |c,i|\n        next\
    \ unless i&1 == 0\n        if c == 'A'..'Z'\n            next 0\n        else\n\
    \            next 1\n        end\n    end\n    s.count('a'..'z') - s.count('A'..'Z')\n\
    end\n</cell>\n<text>\nQ12: count_vowel_of_substring\nGiven a string s, count the\
    \ number of vowels in all the substrings of length 3. Return 0 if the string contains\
    \ only one or two vowels. Vowels are case-insensitive.", "  s.chars.each_with_index\
    \ do |c, i|\n    next if i % 2 == 1\n    next if c != c.upcase\n    yield i\n\
    \  end\nend\n</code>\nNow that we have this function, we can use it to count the\
    \ uppercase vowels in a string:\n<code>\ncount_upper(\"ABC DEF\") #=> [0, 2, 6]\n\
    count_upper(\"aBcDeF\") #=> [1, 5]\ncount_upper(\"abc def\") #=> [1, 2]\n</code>\n\
    We can then use it to determine if we need to count an uppercase vowel:\n<code>",
  "  vowel_count = 0\n  s.each_char do |c|\n    if (c == 'A'..'Z')\n      vowel_count\
    \ += 1\n    end\n  end\n  vowel_count\nend\n</cell>\n<code language=julia-1.6>\n\
    count_upper(\"aBCdEf\")\n</cell>\n<code language=julia-1.6>\ncount_upper(\"abcdefg\"\
    )\n</cell>\n<code language=julia-1.6>\ncount_upper(\"dBBE\")\n</cell>\n<text>\n\
    Q4. Write a function count_lower which counts the number of lowercase vowels in\
    \ a given string.\nThe function should also handle strings containing multiple\
    \ lowercase vowels.", "  s.chars.each_with_index.inject(0) {|count, (c, i)| count\
    \ += 1 if c =~ /[AEIOU]/i && i % 2 == 0}\nend", "  s.split(//).map.with_index.with_object(0)\
    \ do |vowel, index|\n    vowel.downcase == 'a' && index%2 == 0 ? 'a' : vowel\n\
    \  end.inject(:+).to_s\nend", "\tresult = 1\n\tfor i in (0...s.length)\n\t\tif\
    \ (s[i] =~ /[AEIOUY]/ && s[i+1..i+3] =~ /[AEIOUY]/)\n\t\t\tresult+=1\n\tresult\n\
    end", "  s.chars.each_with_index.inject(0) {|sum, (c, i)| sum + c if i & 1 ==\
    \ 0}\nend\n</cell>\n<cell>", "  count_upper = [0]*26\n  s.each_byte do |c|\n \
    \   (0..25).each { |i| count_upper[i] += 1 if c==i }\n  end\n  count_upper.max\n\
    end", "  case s[0] when /[AEIOU]/\n    s.scan(/[aeiou]/)\n  when /[AEIOU]/\n \
    \   s.scan(/[^aeiou]/)\n  else 0\nend", "  count = 0\n  s.each_char.with_index\
    \ do |c, i|\n    count += 1 if c == 'A' || c == 'E' || c == 'I'\n    count +=\
    \ 1 if i % 2 == 0\n  end\n  return count\nend", "  i = 0\n  while i < s.length\n\
    \    if s[i] >= 'a' && s[i] <= 'z'\n      i += 2\n      continue\n    i += 1\n\
    \  end\n  i\nend", "  s.to_s.each_char.with_object(Hash.new(0)){|c,h| h[c][c+=1]}\n\
    \  .map {|k,v| k.to_s.chars.map(&:upcase).reduce(&:|)}\n  .select {|k,v| v==0\
    \ }\n  .size\nend", "  s.scan(/[A-Z](?!.*[A-Z])|\\b[A-Z]/).length\nend\nputs count_upper('dBBE')",
  "  counter = 0\n  for i in 0..s.length - 1\n    if s[i] == 'a' || s[i] == 'e' ||\
    \ s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || s[i] == 'A' || s[i] == 'E' || s[i]\
    \ == 'I' || s[i] == 'O' || s[i] == 'U'\n      counter += 1\n  end\n  counter\n\
    end", "  s.chars.to_a.select { |c| c =~ /[AEIOU]/i }\n    .map(&:upcase).inject(0)\
    \ { |total, x| total += 1 if x }\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ tags=ruby,string |>\n<code>\ns = \"abe\"\ns.chars.each_with_index.with_object([])\
    \ { |c, a| a << (c == 'e' ? 0 : (c.upcase == 'E' ? 1 : 0)) }.max\n=> 1\n</code>\n\
    <|/ a |>\n<| a |>\n<code>", "  s.length == 0 || s.empty? ? 0 : s.gsub(/[aeiou]/i,\
    \ \"\").length / s.length\nend", "  s.gsub(/[^A-Z]/,\"\").chars.each_with_index.inject(0)\
    \ { |sum, (c,ix)|\n    sum + (c==\"A\" || c==\"a\" ? 0 : 1) + (ix&1)>0\n  }\n\
    end", "  return s.split('').inject(0) do |i, e| \n    return i + (e.upcase ==\
    \ 'A' || e.upcase == 'a' ? 1 : 0)\n  end\nend", "  s.scan(/[aeiou]/).inject(0)\
    \ { |n,c| n + (c == 'e' ? 2 : 0) }\nend", "  counter = 0\n  s.each_byte do |x|\n\
    \    if x =~ /[AEIOU]/\n      counter += 1\n    end\n  end\n  return counter\n\
    end", "  s = 0\n  for i in 0 .. s.length - 1\n    if s[i] >= 'a' and s[i] <= 'z'\n\
    \      s += 1\n    elsif s[i] >= 'A' and s[i] <= 'Z'\n      s += 1\n    end\n\
    \  end\n  s\nend", "  return 0 if s.empty? || s.length < 2 || s.upcase > s.length\
    \ / 2 \n    \n  s = s.to_s.upcase\n  (0...s.length).each do |i|\n    if s[i] ==\
    \ 'A' || s[i] == 'a' \n      i -= 1\n      return 1 if i % 2 == 0\n    end\n \
    \ end\n  0\nend", "  s.downcase!\n  s.reverse!\n  s.each_index {|i| return 0 if\
    \ s[i] != s[i + 1] and s[i] =~ /^[aeiou]/} end\n  s.length\nend\n</code>\n<|/\
    \ a dscore=1 tags=ruby,regex |>\n<| a |>\n<code>", "    count = 0\n    i = 0\n\
    \    while i < s.length\n        letter = s[i]\n        if letter == ?U\n    \
    \        count += 1\n        i += 1\n    return count\nend", "  s.chars.each do\
    \ |c|\n    next if c != 'A' && c != 'a'\n    next if c != 'E' && c != 'e'\n  \
    \  next if c != 'I' && c != 'i'\n    next if c != 'O' && c != 'o'\n    next if\
    \ c != 'U' && c != 'u'\n    next\n  end\n  0\nend\n</cell>\n<cell>", "  s.upcase!\n\
    \  (1..s.length).select { |i| s[i] =~ /[aeiou]/ }.count\nend", "  vowel_counter\
    \ = {}\n  s.each_char do |c|\n    vowel_counter[c] ||= 0\n    vowel_counter[c]\
    \ += 1\n  end\n  vowel_counter.each{|key, value| value.odd? and key != 'a' and\
    \ key != 'A'}\nend", "    s.upcase!\n    s.each_index do |i|\n        if s[i*2].upcase\
    \ == s[i*2+1].upcase\n            puts \"#{s[i*2+1]} is even\"\n            s.slice!(i*2,\
    \ 2)\n            break\n        end\n    end\n    s.count(\"A\")\nend", "   \
    \ i = 0\n    upper = 0\n    while i < s.length\n        if s[i] >= 'A' && s[i]\
    \ <= 'Z'\n            upper = upper + 1\n        i = i + 1\n    end\n    return\
    \ upper\nend", "  i = 0\n  while i < s.length\n    if s[i] == 'A' || s[i] == 'a'\n\
    \      i += 1\n    elsif s[i] == 'B' || s[i] == 'b'\n      i += 1\n    elsif s[i]\
    \ == 'C' || s[i] == 'c'\n      i += 1\n    elsif s[i] == 'D' || s[i] == 'd'\n\
    \      i += 1\n    elsif s[i] == 'E' || s[i] == 'e'\n      i += 1\n    elsif s[i]\
    \ == 'F' || s[i] == 'f'\n      i += 1\n    elsif s[i] == 'G' || s[i] == 'g'\n\
    \      i += 1\n    else\n      i += 1\n    end\n  end\n  return i\nend", "  s.each_byte\
    \ do |c|\n    return 0 if c == 'A' || c == 'E' || c == 'I' || c == 'O' || c ==\
    \ 'U'\n  end\n  return 1\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string\
    \ |>\nHow about this:\n<code>", "  s.upcase!\n  (0..s.length-1).to_a.select{|i|\
    \ s[i].upcase ? i % 2 == 0 : i == s.length-1}.count\nend\n</code>\nAnd a test\
    \ using it:\n<code>\nassert_equal(3, count_upper(\"aBCdEf\"))\nassert_equal(1,\
    \ count_upper(\"abcdefg\"))\nassert_equal(0, count_upper(\"dBBE\"))\n</code>\n\
    <|/ a |>\n<| a tags=ruby,regex dscore=2 |>\n<code>", "  count=0\n  for i in 0...s.length\n\
    \    if s[i]==s[0...i].to_s.upcase\n      count+=1 if i%2==0\n    end\n  end\n\
    \  count\nend\n</code>\n<|/ a |>\n<| c |>\nThis is very inefficient.  First you\
    \ create all the new strings from s twice, then you create all the new strings\
    \ from s three times.  You would do better if you did this by writing a method\
    \ that takes two indices as arguments, and returns the count of upcase letters\
    \ at those indices.  The string would then be created once, only copied n times.\n\
    <|/ c |>\n<| a tags=ruby,string |>\nIf you don't want to use any built in functions\
    \ here is the solution.\n<code>", "  s.upcase!\n  s.chars.map.with_index { |c,\
    \ i| i % 2 ? c : nil }.count\nend", "  s.each_char.with_object(Hash.new(0)){|c,h|\
    \ h[c]+= 1} \n                      .select { |c, v| v % 2 == 0 }\n          \
    \            .map { |c, v| c }\n                      .length\nend\n</cell>\n\
    <cell>", "  # write your code here\n  if s.length < 2\n    return 0\n  \n  count\
    \ = 0\n  i = 0\n  while i < s.length\n    char1 = s[i]\n    i += 1\n    if char1.upcase\
    \ == char1\n      count += 1\n    end\n  end", "  s.gsub(/[aeiou]/,'').each_char.with_object(Hash.new(0)){|c,h|\
    \ h[c] += 1 }\nend\n</code>\nThis solution also does not require that the string\
    \ contain only letters or any special characters.\n<|/ a tags=ruby |>\n<| a dscore=1\
    \ tags=ruby |>\nYou can use String#count. Just check if your String has at least\
    \ one uppercase letter and use String#count to count the uppercase vowels.\n<code>",
  "  return s.gsub(/[aeiouy]/, '').scan(/[aeiouy]/).size\nend", "  s.downcase!\n \
    \ count = 0\n  even = s.each_char.each_with_index.select { |c, i| c == 'A' &&\
    \ (i & 1) == 0 }\n  even.each { |e| count += 1  }\n  count\nend", "  s.upcase.chars.each_with_index.inject(0)\
    \ { |acc, (v, i)| acc + (i % 2 == 0 ? v == 'A' ? 1 : 0 : v == 'a' ? 1 : 0)}\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby dscore=0 |>\nJust for fun, here\
    \ is a simple one liner.\n<code>", "  i = 0\n  while i < s.length\n    if s[i]\
    \ == 'A' || s[i] == 'a'\n      i += 1\n      while i < s.length\n        if s[i]\
    \ == 'a' || s[i] == 'A'\n          i += 1\n        else\n          break\n   \
    \   end\n      i += 2\n    else\n      i += 1\n    end\n  end\n  return i\nend",
  "  even_index = s.each_char.map{|e| e == 'A' || e == 'a'}.include? true ? 0 : nil\n\
    \  s.each_char.select{|e| e == 'A' || e == 'a'} \n    .count{ |e| (e == 'A' ||\
    \ e == 'a') ? even_index : nil }.to_i\nend\n</cell>\n<cell>\ncount_upper('aaAaAaAaa')\n\
    </cell>\n<cell>\ncount_upper('aaABbbbBB')\n</cell>\n<cell>", "  s.chars.each_with_index.inject(0)\
    \ do |t,(c,i)|\n    if i % 2 == 0 && c >= 'a' && c <= 'z'\n      t += 1\n    end\n\
    \    t\n  end\nend", "  even = s.chars.zip(s[1..-1]).select { |a,b| a == b }.count\n\
    \  even % 2 == 0 ? even : 0\nend\n</code>\n<|/ a dscore=2 tags=ruby,string |>\n\
    <| c |>\nI'm getting a compilation error on the 2nd line: \n`even = s.chars.zip(s[1..-1]).select\
    \ { |a,b| a == b }.count\nTypeError: no implicit conversion of nil into String`\n\
    <|/ c |>\n<| c |>\nThanks so much for your help, I learned something new. I'm\
    \ still learning Ruby and didn't know about `zip`\n<|/ c |>\n<| c |>\nAha! I had\
    \ to change `even = s.chars.zip(s[1..-1]).select { |a,b| a == b }.count` to `even\
    \ = s.chars.zip(s[1..-1]).select { |a,b| a == b && b == b }.count` and now it\
    \ works! Thanks again!\n<|/ c |>\n<| c |>\nGlad to have helped :). In your solution,\
    \ there is one more thing you need to change. Instead of checking for `a == b\
    \ == b`, you need to check for `(a == b && b == b)`.\n<|/ c |>\n<| c |>\nI think\
    \ this is a bug in the OP's question. As I read it, the OP says \"In a given string,\
    \ count the number of uppercase vowels in even indices.\" The code I posted is\
    \ for the case in which every two characters are equal. I think your code should\
    \ also work for the case where every two characters are not equal (such as `abcde`).\n\
    <|/ c |>\n<| a tags=ruby,string |>\nThis should do the trick:\n<code>", "  s.split.map\
    \ { |e| e.chars.map(&:upcase).count { |x| x.odd? } }\nend", "  s.each_char do\
    \ |c|\n    c =~ /[aeiou]/i\n    !($~.index % 2)\n  end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>", "  s.downcase!\n  s.each_char.with_index { |c,i|\
    \ return 0 if i % 2 == 0 && c == 'A' || c == 'a'  }\n  s.size\nend\nputs count_upper(\"\
    Hello, World!\")\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is the best solution\
    \ IMO.\n<|/ c |>\n<| c |>\nThanks, this is pretty helpful\n<|/ c |>\n<| c |>\n\
    This solution is beautiful but unfortunately has a bug in it. Upper case vowels\
    \ aren't counted. Example: count_upper(\"abAcdEf\")\n<|/ c |>\n<| c |>\nGreat\
    \ solution, however it is not efficient. First you iterate over the string and\
    \ for each character you iterate over the string again. Instead you should be\
    \ able to do it in a single loop. My solution is O(n+m)\n<|/ c |>\n<| a dscore=5\
    \ |>\nI came here looking for an answer to the same problem as OP: given a string,\
    \ return the number of uppercase vowels.\nI used a solution with regular expressions\
    \ (as suggested elsewhere), but the solution with regular expressions was slower\
    \ for me than the solution posted by Dmitry in his answer.\nI found the solution\
    \ to be faster using string substitution like so:\n<code>", "  s.each_char.with_index\
    \ { |c,i| if c=='A' && i%2==0 then 1\n                               else 0 }\n\
    end", "  s = s.downcase\n  (s.length / 2).times.reduce { |n,i| n + (s[i+1] =~\
    \ /[AEIOU]/i)}\nend\n</code>\nHere I am counting every vowel in an even index.\n\
    And then counting uppercase vowels in even indexes.\nAs you can see, it's very\
    \ similar like your attempt, but using different patterns. \nHere's how it works:",
  "  count = 0\n  s.each_char do |c|\n    if c == 'A' || c == 'a'\n      count +=\
    \ 1\n    elsif c == 'E' || c == 'e'\n      count += 1\n    elsif c == 'I' || c\
    \ == 'i'\n      count += 1\n    elsif c == 'O' || c == 'o'\n      count += 1\n\
    \    elsif c == 'U' || c == 'u'\n      count += 1\n    elsif c == 'Y' || c ==\
    \ 'y'\n      count += 1\n    else\n      count = 0\n    end\n  end\n  return count\n\
    end", "  return s.chars.each_with_index.map{ |v,i| i == 0 || v == ?A || v == ?E\
    \ || v == ?I || v == ?O }.count { |v| v == true }\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\n`?A` is a literal match in the character class, and `?E` is a literal\
    \ match in the character class. The question asks how many vowels are in even\
    \ indices. The answer gives the number of uppercase vowels in each character.\
    \ That is different from counting the number of vowels in each even index of the\
    \ string.\n<|/ c |>\n<| c |>\nYes, I misread the question. I misread the code\
    \ and the comment in the code I posted.\n<|/ c |>\n<| c |>\nThis is not an efficient\
    \ way to do it as Ruby can do the job directly with regular expressions.\n<|/\
    \ c |>\n<| a tags=ruby,string |>\nI believe, that one more efficient way is to\
    \ first find an index where vowel appears (i.e. the place where \"a\" appears).\
    \ Then you can get the length of your string and check whether \"a\" appears at\
    \ even places, since its length is odd.\n<code>", "  s.chars.map.with_index {|c,\
    \ i| c.upcase if i.zero? }.count\nend", "  s.each_char{|c| return 0 if c =~ /[AEIOU]/;\
    \ return 1 if (c =~ /[AEIOU]/)[0].upcase == c[0].upcase }\nend", "  case s\n \
    \   when 'a' then 1\n    when 'b' then 1\n    when 'c' then 1\n    when 'd' then\
    \ 1\n    when 'e' then 1\n    when 'f' then 1\n    when 'g' then 1\n    else 0\n\
    \  end\nend", "  s.gsub(/[AEIOU]/ ) do |char|\n    char = char.upcase\n    (char\
    \ =~ /[AEIOU]/) ? char.length : 0\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |total, el, i|\n    total += 1 if el == 'A' || el == 'E' || el == 'I'\n \
    \ end\nend", "  s.split('').each.with_index.with_index.with_index.inject(0) {|acc,\
    \ el, i|\n    el =~ /[AEIOU]/\n    i % 2 == 0 && el =~ /[AEIOU]/\n    acc + 1\
    \ if el =~ /[AEIOU]/\n    acc\n  }\nend", "  s.each_index { |i| return 0 unless\
    \ s[i] =~ /[AEIOU]/; return 1 }\n  0\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    <code>", "  return s.scan(/[A-Z][a-z]*|[a-z][A-Z]/).inject(:+)\nend", "  return\
    \ s.chars.each_with_index.map { |c,i| c == c.upcase && i % 2 == 0 }.inject { |sum,\
    \ num| sum + num }\nend", "  s.upcase!\n  vowels = ['A','a','E','e','I','i','O','o','U','u']\n\
    \  s.each_char { |c| vowels.include?(c.upcase) ? 1 : 0 }\nend", "  s.length.times\
    \ do |i|\n    if s[i] =~ /[AEIOU]/\n      s[i].upcase!\n    end\n  end\n  s.length\n\
    end", "  s = s.chars.map { |c| c.to_s.upcase }.join\n  s.each_char.map { |c| c\
    \ == 'A' ? 1 : 0 }.inject(:+)\nend", "  count = 0\n  for i in 0..(s.length-1)\n\
    \    if s[i] >= 'a' and s[i] <= 'z'\n      count += 1\n    end\n  end\n  count\n\
    end", "\ts.each_char.with_index { |c, i| c == 'A' ? 0 : (c >= 'a' && c <= 'z'\
    \ ? 1 : (c >= '0' && c <= '9' ? 0 : nil )) }\nend", "  count = 0\n  s.each_byte\
    \ { |b| count += 1 if b > 64 && b < 91 }\n  count\nend", "  s = s.downcase\n \
    \ s.chars.each_with_index do |char, i|\n    if char.upcase == char\n      puts\
    \ \"#{char} is an uppercase vowel for #{i}\"\n    end\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,string |>\n<| a |>\n<code>", "  s.each_char.with_index.with_object(0)\
    \ do |c, (i, count)|\n    if i % 2 == 0 && c == 'A' || c == 'a'\n      count +=\
    \ 1\n    end\n  end\nend", "    count = 0\n    i = 0\n    while i < s.length\n\
    \        if s[i] == \"A\" or s[i] == \"a\"\n            count += 1\n        end\n\
    \        i += 1\n    end\n    return count\nend", "  return s.chars.to_a.with_index.count\
    \ { |char, i| char =~ /[AEIOU]/i && i % 2 == 0 }\nend", "  s.to_s.each_char.with_index.inject(0)\
    \ do |sum, (_, i)|\n    sum + 1 if i.even?\n    sum\n  end\nend\n</code>\n<|/\
    \ a |>\n<| a dscore=2 tags=ruby |>\nI did a quick benchmark and found this to\
    \ be the fastest method of doing it. The other answers are also very good, but\
    \ I thought a benchmark would be helpful.\n<code>", "    s.each_char {|c| return\
    \ 0 unless c.upcase >= 'A' && c.upcase <= 'Z'; 1+0 }\nend", "  return s.split('').select{|c|\
    \ c =~ /[AEIOU]/}.count{|c| c =~ /[AEIOU]/} / 2\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks for posting your solution Ahmed, I was actually looking\
    \ for something like this. :)\n<|/ c |>\n<| a dscore=0 |>\nHere's my solution:\
    \ \n<code>", "  s.to_s.chars.each_with_index.inject(0) { |sum, el, i| sum + el[i].upcase\
    \ if el[i].upcase == 0 }\nend", "  count = s.length\n  (0...count).each do |i|\n\
    \    next if s[i].upcase == s[i]\n    return 0 if i == (count-1)\n    count -=\
    \ 1 if s[i].upcase == s[i+1]\n  end\n  return count\nend", "    s.upcase!\n  \
    \  count = 0\n    s.each_char do |c|\n        count += 1 if c.upcase == c\n  \
    \  end\n    count\nend", "  return s.downcase.count(\"AEIOU\")\nend", "  count\
    \ = 0\n  s.each do |c|\n    return count if (c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U') && ((c % 2) == 0)\n    count += 1\n  end\nend", " \
    \ count = 0\n  s.each_index do |i|\n    count += 1 if s[i] >= 'A' && s[i] <= 'Z'\n\
    \    count += 1 if s[i] == 'Z'\n  end\n  count\nend\n</code>\n<|/ a tags=ruby,string,regex\
    \ dscore=2 |>\n<| c |>\nThis counts how many uppercase vowels are in the string,\
    \ not how many uppercase vowels are in the even indexes. For example `count_upper('aaabbc')`\
    \ will return `2` when it should be `1`.\n<|/ c |>\n<| a dscore=1 |>\nYou could\
    \ do it in one line with gsub, gsub!, and a conditional statement.\n<code>", " \
    \   count = 0\n    s.each_byte do |c|\n        count += 1 if c == :U\n       \
    \ count += 1 if c == :a\n        count += 1 if c == :e\n        count += 1 if\
    \ c == :o\n    end\nend\n</code>\n<|/ a |>\n<| c |>\nWhy do you say this is a\
    \ bad solution? It passes the OP's tests, and is elegant.\n<|/ c |>\n<| c |>\n\
    It's bad because it passes all the OP's tests, not just this one. And it's bad\
    \ because it's less efficient than using the built-in methods, like I did.\n<|/\
    \ c |>\n<| a dscore=1 |>\nThis one also passes the tests. But it has a better\
    \ time complexity.\n<code>", "  s.downcase.count(\"A\") + s.downcase.count(\"\
    E\") + s.downcase.count(\"I\") + s.downcase.count(\"O\")\nend\n    ", "  s.chars.map\
    \ { |c| c.upcase }.count(c) for c in s.chars if c.upcase != c\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nIf this answered your question, consider marking it\
    \ as the accepted answer. https://stackoverflow.com/help/someone-answers\n<|/\
    \ c |>\n<| a dscore=1 |>\nHere's another one\n<code>", "  i = 0\n  while i < s.length\n\
    \    if s[i] =~ /[AEIOU]/\n      if i % 2 == 0\n        i += 1\n      else\n \
    \       i += 2\n      end\n    end\n    i += 1\n  end\n  \n  return i\nend", " \
    \ s.split('').map do |char|\n    char.upcase == 'A' ? 0 : char.upcase == 'a' ?\
    \ 1 : char.upcase == 'B' ? 2 : char.upcase == 'C' ? 3 : char.upcase == 'D' ? 4\
    \ : char.upcase == 'E' ? 5 : char.upcase == 'F' ? 6 : char.upcase == 'G' ? 7 :\
    \ char.upcase == 'H' ? 8 : char.upcase == 'I' ? 9 : char.upcase == 'J' ? 10 :\
    \ char.upcase == 'K' ? 11 : char.upcase == 'L' ? 12 : char.upcase == 'M' ? 13\
    \ : char.upcase == 'N' ? 14 : char.upcase == 'O' ? 15 : char.upcase == 'P' ? 16\
    \ : char.upcase == 'Q' ? 17 : char.upcase == 'R' ? 18 : char.upcase == 'S' ? 19\
    \ : char.upcase == 'T' ? 20 : char.upcase == 'U' ? 21 : char.upcase == 'V' ? 22\
    \ : char.upcase == 'W' ? 23 : char.upcase == 'X' ? 24 : char.upcase == 'Y' ? 25\
    \ : char.upcase == 'Z' ? 26 : char.upcase == 'a' ? 0 : char.upcase == 'b' ? 1\
    \ : char.upcase == 'c' ? 2 : char.upcase == 'd' ? 3 : char.upcase == 'e' ? 4 :\
    \ char.upcase == 'f' ? 5 : char.upcase == 'g' ? 6 : char.upcase == 'h' ? 7 : char.upcase\
    \ == 'i' ? 8 : char.upcase == 'j' ? 9 : char.upcase == 'k' ? 10 : char.upcase\
    \ == 'l' ? 11 : char.upcase == 'm' ? 12 : char.upcase == 'n' ? 13 : char.upcase\
    \ == 'o' ? 14 : char.upcase == 'p' ? 15 : char.upcase == 'q' ? 16 : char.upcase\
    \ == 'r' ? 17 : char.upcase == 's' ? 18 : char.upcase == 't' ? 19 : char.upcase\
    \ == 'u' ? 20 : char.upcase == 'v' ? 21 : char.upcase == 'w' ? 22 : char.upcase\
    \ == 'x' ? 23 : char.upcase == 'y' ? 24 : char.upcase == 'z' ? 26 : nil\n  end.inject(0)\
    \ do |sum, digit|\n    sum + digit\n  end\nend\n</code>\nThe second method simply\
    \ uses the same method as your ", "  return s.gsub(/[AEIOU]/, '').length\nend",
  "  return 0 unless s.length\n  s.each_char.with_index.reduce(0) { |a, e| a + (e\
    \ =~ /[AEIOU]/ ? 1 : 0) }\nend", "  s = s.downcase\n  count = 0\n  s.each_index\
    \ do |i|\n    if s[i] == s[i]\n      if s[i+1] == s[i]\n        count += 1\n \
    \     end\n    end\n  end\n  count\nend\n</code>\n<|/ a |>\n<| c |>\nI guess you\
    \ meant `count +=` instead of `count = +`\n<|/ c |>\n<| c |>\nGood catch.\n<|/\
    \ c |>\n<| a tags=ruby,algorithm |>\nHere's another approach, using some cool\
    \ methods from Enumerable (which includes Enumerator). This also uses no loops.\
    \ \n<code>", "  i = 0\n  while i < s.length\n    ch = s[i]\n    if ch =~ /[AEIOUYaeiouy]/\n\
    \      return 1\n    i += 1\n  end\n  return 0\nend", "  s.downcase.each_char.with_object(Hash.new(0))\
    \ { |c,h| h[c] += 1 if c >= 'A' && c <= 'Z' }.\n    values.inject(0) { |sum,x|\
    \ sum + x }\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYour \"hash\" solution\
    \ is very similar to mine, although yours doesn't use upcase or downcase at all.\
    \ I like the `each_char.with_object` idea, but I wonder if it might be better\
    \ to use a `group_by` solution, since you only need to process the string once.\n\
    <|/ c |>\n<| c |>\nI agree, using group_by would be a good idea, but I don't know\
    \ if that's possible. It could be something like `s.each_char.group_by(&:downcase)`\
    \ or something like that, though I wouldn't know how to do it with inject (without\
    \ using each_char).\n<|/ c |>\n<| c |>\nYeah, I just realized that I missed a\
    \ very important point in the question, that I'd like to find the count of non-uppercase\
    \ vowels too. The only way I can think of to do it right now is to just add another\
    \ case statement after the downcase method call (eg. s.downcase.count(\"A\") -\
    \ s.downcase.count(\"a\") ).\n<|/ c |>\n<| a dscore=1 |>\nHere's a nice solution\
    \ that doesn't use each_char, which will be the most efficient in Ruby 2.2+:\n\
    <code>\nrequire \"pp\"\ns = 'aabbcccde'\np s.chars.each_with_object(Hash.new(0))\
    \ { |c,h| h[c] += 1 if c.upcase == 'A' }.\n  values.inject(0) { |sum,x| sum +\
    \ x }", "  count = s.dup.length\n  s.each_char do |c|\n    next unless c == 'A'\
    \ || c == 'a'\n    count += 1\n  end\n  count\nend", "  return s.chars.map.with_index\
    \ { |c,i| [(i&1)==0, c].max}[1]\nend\n</cell>\n<code language=julia-1.0>\n?String#chars\n\
    </cell>\n<code language=julia-1.0>\ncount_upper(\"aBCdEf\")\n</cell>\n<code language=julia-1.0>\n\
    count_upper(\"abcdefg\")\n</cell>\n<code language=julia-1.0>\ncount_upper(\"dBBE\"\
    )\n</cell>\n<code language=julia-1.0>\nfunction count_uppercase(s)\n  return s.chars.map.with_index\
    \ { |c,i| [((i&1)==0), c].max}[1]\nend\n</cell>\n<code language=julia-1.0>\ncount_uppercase(\"\
    aBCdEf\")\n</cell>\n<code language=julia-1.0>\ncount_uppercase(\"abcdefg\")\n\
    </cell>\n<code language=julia-1.0>\ncount_uppercase(\"dBBE\")\n</cell>\n<code\
    \ language=julia-1.0>\ncount_uppercase(\"AABBCCdEE\")\n</cell>\n<code language=julia-1.0>\n\
    count_uppercase(\"abBcCdEfG\")\n</cell>\n<code language=julia-1.0>\nfunction count_lowercase(s)\n\
    \  return s.chars.map.with_index { |c,i| [((i&1)!=0), c].max}[1]\nend\n</cell>\n\
    <code language=julia-1.0>\ncount_lowercase(\"aBCdEf\")\n</cell>\n<code language=julia-1.0>\n\
    count_lowercase(\"abcdefg\")\n</cell>\n<code language=julia-1.0>\ncount_lowercase(\"\
    dBBE\")\n</cell>\n<code language=julia-1.0>\ncount_lowercase(\"AABBCCdEE\")\n\
    </cell>\n<code language=julia-1.0>\ncount_lowercase(\"abBcCdEfG\")\n</cell>\n\
    <text>\nChallenge\nWrite a function that takes a single string as input and returns\
    \ another string.", "  count = 0\n  for i in 0...s.length-1\n    if s[i]=~/^[A-Z]+$/\
    \ and i % 2 != 0\n      count += 1\n    end\n  end\n  return count\nend", "  s.each_char.with_index\
    \ do |c,i|\n    if (i % 2) == 0\n      if (c == c.upcase)\n        puts 1\n  \
    \      break\n      end\n    end\n  end\nend", "  s.chars.each_with_index { |c,\
    \ i| return i if c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' }\n\
    \  0\nend", "  return s.length / 2.downto(1).inject(0) { |sum, e| sum + (e.upcase\
    \ ? 1 : 0) }\nend", "  s.each_index do |i|\n    if i.even? && s[i] != s[i][0]\n\
    \      0\n    elsif s[i] != s[i][0]\n      1\n    end\n  end\nend\n</code>\nYou\
    \ can do this in one line, but I find it easier to understand what it is doing.\n\
    <|/ a dscore=1 |>\n<| c |>\nI used a lambda function which makes the code cleaner.\
    \ \n ", "  s.chars.each_with_index.inject(0) do |count,(a,i)|\n    break count\
    \ if a == 'A' && i % 2 == 0\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby,count,string\
    \ |>\nUsing regex\n<code>\ns = 'aaaaaA'\ns.scan(/A|a/).count\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=ruby,count,string dscore=1 |>\n<code>", "    i = 0\n    s.downcase!\n\
    \    while i < s.length\n        i += 1 if s[i].upcase == true\n        i += 1\n\
    \    end\n    i\nend", "  (0...s.length).each do |i|\n    return 0 if s[i] < 'A'\n\
    \    return 1 if s[i] > 'Z'\n  end\n  return 0\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Ah, yes, that makes perfect sense. Thanks!\n<|/ c |>\n<| c |>\nNice, thanks for\
    \ improving my Ruby knowledge!\n<|/ c |>\n<| c |>\nYou're welcome. Ruby is a very\
    \ nice language.\n<|/ c |>\n<| c |>\nThanks for teaching me something new! I still\
    \ have many ways of accomplishing the same thing in other languages\n<|/ c |>\n\
    <| c |>\nSure thing! I love Ruby and it makes programming in it very easy, but\
    \ it's certainly not my go to language for any sort of project.\n<|/ c |>\n<|\
    \ a tags=ruby,string |>\nMy solution would be:\n<code>", "  count = 0\n  s.each_char\
    \ do |c|\n    count += (('A'..'Z').include?(c)) && ('A'..'Z').include?(c)\n  end\n\
    \  count\nend\n</code>\nThis works well for strings that only contain lowercase\
    \ letters. If you need a case insensitive count of uppercase letters then you\
    \ can replace the && ('A'..'Z').include?(c) with a case switch statement or use\
    \ tr and downcase to convert the string to lowercase before checking.\n<code>\n\
    count += ('A'..'Z').include?(c.downcase)\n</code>\nOr without case switch:\n<code>\n\
    count += ('A'..'Z').include?(c.tr('A','a').downcase)\n</code>\n<|/ a dscore=1\
    \ tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\nUse \n<code>\ns.gsub(/[A-Z]/, '').length\n</code>\nto find out how many\
    \ uppercase letters there are in a string.\n<|/ a dscore=0 |>\n<| a |>\nYou can\
    \ use the following methods:\n<code>\n\"test\".mb_chars.count\n\"test\".mb_chars.select{|c|\
    \ c.upcase }.count\n\"test\".mb_chars.select{|c| c.downcase }.count\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 dscore=0 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\nUse regular expressions:\n<code>\n\"test\".scan(/[A-Z]/).size\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\n<code>\n\"test\".each_char.with_object(Hash.new(0))\
    \ { |c,h| h[c] = h[c]+1 }.max #=> 1\n</code>\nor\n<code>\n\"test\".each_char.with_object(Hash.new(0))\
    \ { |c,h| h[c] += 1 }.max #=> 1\n</code>\nor \n<code>\n\"test\".downcase.each_char.with_object(Hash.new(0))\
    \ { |c,h| h[c] += 1 }.max #=> 1\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ dscore=0 |>\n<| c |>\n`each_char.with_object` can be simplified to `each_with_object`.\n\
    <|/ c |>\n<| a d", "  s.scan(/[aeiou]/ ).inject(0) { |sum,x| sum + x.upcase }\n\
    end", "    count = 0\n    upper = s.upcase\n    for i in 0...s.length\n      \
    \  if i mod 2 == 0 && upper[i] == 'A'\n            count += 1\n        end\n \
    \   end\n    return count\nend\n</code>\nThe second function is as follows:\n\
    <code>", "  even = []\n  s.each_char do |char|\n    if char.upcase % 2 == 0\n\
    \      even << char\n    end\n  end\n  even.count\nend", "  count = 0\n  s.each_char\
    \ do |char|\n    if char.upcase == 'A'\n      count += 1\n    elsif char.upcase\
    \ == 'E'\n      count += 1\n    elsif char.upcase == 'I'\n      count += 1\n \
    \   elsif char.upcase == 'O'\n      count += 1\n    elsif char.upcase == 'U'\n\
    \      count += 1\n    end\n  end\n  count\nend", "  s = s.upcase\n  count = 0\n\
    \  for i in 0...s.length\n    if (s[i] == s[i].upcase)\n      count += 1\n   \
    \ end\n  end\n  return count\nend", "  s.split('').inject(0) do |count, (ch,index)|\n\
    \    if index%2==0 then\n      count += 1 if ch.upcase =~ /[AEIOU]/\n    end\n\
    \    count\n  end\nend", "  count = 0\n  s.each { |c| count += 1 if c == 'A' ||\
    \ c == 'E' || c == 'I'  || c == 'O' || c == 'U' }\n  count\nend", "  return 0\
    \ unless s[0]\n  count = 0\n  s.length.times do |i|\n    if s[i] >= 'A' && s[i]\
    \ <= 'Z'\n      count += 1\n    end\n  end\n  return count\nend\n</cell>\n<code\
    \ language=julia-1.0>\n@code_warntype count_upper('abc')\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype count_upper('Abc')\n</cell>\n<code language=julia-1.0>\ncount_upper('Abc')\n\
    </cell>\n<text>\nExercise: count occurrences of substrings\nWrite a function,\
    \ count_vowels(s, substring), that returns the number of occurrences of substring\
    \ s in s.  If s is not defined, it should return 0.", "  s.tr('A-Z', '0')\n  \
    \      .tr('a-C', '0')\n        .tr('e-g', '0')\n        .tr('b-e', '0')\n   \
    \     .count('0')\nend", "  s.chars.each_with_index.inject(0) {|sum, (ch, index)|\
    \ sum + 1 if index%2==0 && ch=='A' || ch=='E' || ch=='I'}\nend", "    count =\
    \ 0\n    str.split(s).map {|e| if e.to_s.upcase.to_i == e then count += 1; end\
    \ }\n    return count\nend", "  # your code here\n  \n  vowels = 'AEIOUaeiou'\n\
    \  \n  count = 0\n  vowel_counter = 0\n  for c in s\n    if vowels.include?(c)\n\
    \      vowel_counter += 1\n    end\n    if vowel_counter == 0 \n      count +=\
    \ 1\n    end\n  end\n  return count\nend", "  vowels = 'AEIOU'\n  result = 0\n\
    \  s.each_char.with_index do |c,i|\n    (c =~ /[aeiou]/) && (result += 1 if vowels.index(c)\
    \ || i%2 == 0)\n  end\n  result\nend", "  s.chars.each_with_index.inject(0, :+).to_i\n\
    end", "  return s.gsub(/[aeiou]/i).each_with_index.inject(0) { |sum, (e, i)| sum\
    \ + 1 if i % 2 == 0 && e == e.upcase }\nend\n</code>\n<|/ a dscore=5 |>\n<| c\
    \ |>\nYou sir, are a genius! Thanks for your help. This is going to take me a\
    \ while to understand, but I'm getting there. Thanks again!\n<|/ c |>\n<| c |>\n\
    Thanks so much for this!  I wouldn't have thought of using gsub!  I wanted to\
    \ count the number of letters in each row (which didn't seem to be a duplicate),\
    \ so I used this and modified it to count the number of uppercase letters.  I\
    \ used the following for the method: def count_uppercase\n    s.each_with_index.inject(0)\
    \ { |sum, (e, i)| sum + 1 if i % 2 == 0 && e == e.upcase }\n  end\n<|/ c |>\n\
    <| a dscore=5 |>\nI was looking for the same thing but with strings, and this\
    \ worked for me:\n<code>", "  s.chars.each do |ch|\n    next if (ch.ord == 32)\
    \ and (ch.chr =~ /[AEIOUY]/ )\n    if ch == 'A'\n      return 1\n    end\n  end\n\
    \  0\nend", "  count_upper, odd_count, even_count = 0, 0, 0\n  s.to_s.split(//).each\
    \ do |c|\n    if c.upcase == 'A' || c.upcase == 'a'\n      even_count += 1\n \
    \   elsif c.upcase == 'E' || c.upcase == 'e'\n      odd_count += 1\n    end\n\
    \  end\n  count_upper = even_count + odd_count\nend", "  count_upper = 0\n  s.each_char\
    \ do |c|\n    if c == c.upcase\n      count_upper += 1\n    elsif (c == c.upcase\
    \ && s.length % 2 == 0)\n      count_upper += 1\n    elsif (c == c.upcase && s.length\
    \ % 2 != 0)\n      count_upper += 1\n    end\n  end\n  return count_upper\nend",
  "  s.chars.each_with_index.inject(0) do |sum, (el,index)|\n    case el\n    when\
    \ 'A' then sum + 1\n    when 'a' then sum\n    end\n  end\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| c |>\nThis is more readable than what I have now :) I was trying\
    \ to solve this problem in HackerRank and your solution was perfect. Thank you\
    \ for the help and explanation!\n<|/ c |>\n<| c |>\nThis is nice and concise,\
    \ but it's unnecessarily inefficient. You're creating a full temporary array and\
    \ using it over and over. It would be better to use `each_char` rather than `chars`\
    \ and then `sum`.\n<|/ c |>\n<| c |>\nI agree, and my solution is indeed inefficient,\
    \ especially since a lot of people have provided other solutions. I only wanted\
    \ to provide a solution that is easy to understand, while keeping it simple.\n\
    <|/ c |>\n<| a dscore=1 |>\nSince you're trying to solve this problem in HackerRank,\
    \ you may not be allowed to use enumerators. This is a perfect use case for Ruby's\
    \ each_char and each_with_index methods.\n<code>\ns = 'aBCdEf'\ns.each_char.each_with_index\
    \ do |char, i|\n  if char.upcase == char\n    return 0 if i & 1\n  end\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| a tags=ruby dscore=1 |>\nHere's another way, using\
    \ each_cons instead of each_char:\n<code>\ns = 'aBCdEf'\ns.each_cons(2).map do\
    \ |a, b|\n  b.last == a ? 1 : 0\nend", "  s.upcase.scan(/[AEIOU]/).count\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for the response!  I added the code above.\
    \  When I run it, I get the following error message when I run my ruby script\
    \ from the command line \"ruby count_upper.rb:  undefined method `scan' for nil:NilClass\
    \ (NoMethodError)\"  Am I missing a require?\n<|/ c |>\n<| c |>\nYou're right,\
    \ I forgot the argument for the method `scan`. Fixed now\n<|/ c |>\n<| c |>\n\
    Also, you may want to replace `scan(/[AEIOU]/).count` with `sum{|e| e == 'A' ||\
    \ e == 'E' || e == 'I' || e == 'O' || e == 'U'}` if you want to avoid unnecessary\
    \ regexp compilation\n<|/ c |>\n<| c |>\nI appreciate the code you gave me and\
    \ everyone else's answers they all work perfectly.  I learned a lot about Ruby\
    \ from this question.  Thanks again.\n<|/ c |>\n<| c |>\n: I agree. However I\
    \ think it's more expressive to express the intent of the code by explicitly counting\
    \ the vowels with a single method call. `sum` also makes it easy to change the\
    \ method call to count the consonants in a different way. If `sum` were used directly\
    \ this would require changing both the method call and `sum` invocations.\n<|/\
    \ c |>\n<| a |>\n<code>", "    count = 0\n    i = 0\n    while i < s.length\n\
    \        if s[i] =~ /[AEIOU]/\n            count += 1\n        i += 1\n    return\
    \ count\nend\n</cell>\n<code language=julia-1.6>", "  s.upcase!\n  count = 0\n\
    \  s.each_char { |c| c =~ /[AEIOUY]/i ? count += 1: nil }\n  count\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby |>\nHere is an alternative:\n<code>", "    vowels = 'AEIOU'\n\
    \    count = 0\n    char = s.chr\n    \n    for i in 0..s.length\n        if char\
    \ =~ /[#{vowels}]/\n            count += 1\n        elsif char =~ /[#{vowels}]/.match(s[i\
    \ - 1])\n            count += 1\n        end\n    end\n    return count\nend",
  "  s.tr!('aeiouAEIOU', '')\n  s.count(\"A\"..\"Z\")\nend", "  s.downcase!\n  even_indices\
    \ = Enumerator.new do |y|\n    y << 0\n    s.each_char.with_index { |c, i| y <<\
    \ i if c =~ /[AEIOU]/i }\n  end\n  vowel_counter = even_indices.with_object(Hash.new(0))\
    \ { |i, h| h[i] += 1; h }\n  vowel_counter.select { |_,v| v }.size\nend\n</code>\n\
    The steps are as follows:", "  s.chars.each_with_index { |c,i| return 0 if i %\
    \ 2 == 0 && c.upcase == c }\n  0\nend", "  s.chars.each_with_index.with_object(Hash.new(0))\
    \ { |c,i| c[i].upcase! }.values.max\nend", "  count_upper = 0\n  s.split(\"\"\
    ).each_with_index do |char, i|\n    if (char.upcase % 2 ==0)\n      count_upper\
    \ += 1\n    end\n  end\n  return count_upper\nend", "  return s.downcase.chars.count\
    \ {|c| c =~ /[AEIOU]/} % 2\nend", "  count = 0\n  s.chars.each do |c|\n    count\
    \ += 1 if (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')\n  end\n  count\nend\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis counts vowels in the entire string.\
    \ I would like to count only specific characters.\n<|/ c |>\n<| c |>\nYou only\
    \ need to do `count.times` if you have multiple characters to count. `count` returns\
    \ the number of the character in question.\n<|/ c |>\n<| c |>\nThe solution above\
    \ is more succinct and clear.\n<|/ c |>\n<| c |>\nThis is the only correct answer,\
    \ thank you for helping me understand why counting vowels is so difficult. I'm\
    \ a beginner at programming and still don't understand why everyone thinks this\
    \ is super simple.\n<|/ c |>\n<| c |>\nThis should be the answer. Not \"This is\
    \ the only correct answer\" but \"this is the correct answer\"\n<|/ c |>\n<| a\
    \ tags=ruby dscore=5 |>\nAs others have noted, Ruby strings have the method each_char.\
    \ String#each_char has a block to execute for each character in the string. It\
    \ could look like this:\n<code>", "  s.each_char.with_index do |char,i|\n    return\
    \ char == 'A' and i & 1 == 0 ? 1 : 0\n  end\nend", "  if s.length == 0 || s.length\
    \ == 1\n    0\n  else\n    count_upper(s[0...-1]) + s.each_index.select {|i| s[i]\
    \ =~ /[AEIOU]/}.count\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis seems like\
    \ a great solution. I'm curious to see a benchmark of these solutions on large\
    \ data sets.\n<|/ c |>\n<| c |>\nThe above code will work as expected for a string\
    \ like \"zxcvzxcv\" but the answer above will give 0 for \"zxcvzxcv\" as the index\
    \ for \"zxcv\" is 5.  I think you need to change it to count on both characters\
    \ at once to make it work for this string: \"zxcvzxcv\".\n<|/ c |>\n<| c |>\n\
    Your answer does not work when `s = \"zxcv\"` when it should return `1`, not `0`.\n\
    <|/ c |>\n<| c |>\nI edited the answer to include an alternative implementation\
    \ that works with string \"zxcv\".\n<|/ c |>\n<| a tags=ruby,regex |>\nHere is\
    \ a more efficient implementation:\n<code>", "  return s.gsub(/[AEIOUYaeiouy]/){|s|\
    \ s.upcase if s.is_a? String}.length\nend", "    count = 0\n    i = 0\n    while\
    \ i < s.length\n        if s[i] == \"A\" or s[i] == \"E\" or s[i] == \"I\" or\
    \ s[i] == \"O\" or s[i] == \"U\"\n            count = count + 1\n        end\n\
    \        i += 1\n    end\n    return count\nend", "  count = 0\n  s.each_char\
    \ do |char|\n    if char.upcase == char\n      count += 1\n    elsif char.upcase\
    \ != char\n      return 0\n    end\n  end\n  count\nend", "  s.upcase!\n  s.each_char.with_index\
    \ do |char, idx|\n    if idx % 2 == 0 && char == char.upcase\n      count = 1\n\
    \      break count\n    end\n  end\nend\n</code>\n<|/ a |>\n<| a tags=string,ruby,arrays,count\
    \ dscore=1 |>\n<code>", "    count = 0\n    for i in (0..s.length)\n        count\
    \ += if s[i..(i+1)].upcase.to_a.count > 0\n    end\n    count\nend", "  return\
    \ s.gsub(/[AEIOU]/, '').length % 2 == 0\nend", "  s.gsub!(/[^A-Z]+/, \"\")\n \
    \ s.each_char.with_object(Hash.new(0)) { |c,h| h[c] += 1 if c[0].upcase == c[0]\
    \ }.values.max\nend", "  i = 0\n  while i < s.length\n    next if s[i] =~ /[AEIOU]/\n\
    \    i += 1\n  end\n  i\nend", "  return s.count('AEIOU') - (s.count('a') + s.count('e')\
    \ + s.count('i') + s.count('o') + s.count('u'))\nend\n</cell>\n<text>\nQuestion\
    \ 4: Count and Print the Most Common Letter Frequency\nImplement a function that\
    \ takes in a string of lowercase letters, prints the letter with the most number\
    \ of occurrences in the string and return that letter along with its number of\
    \ occurrences. For example, for the input string 'AabBbAc', the function should\
    \ print:\nA: A appears 1 time with value 1\nB: B appears 2 times with values 1\
    \ and 2\nC: C appears 2 times with values 1 and 2", "  count = 0\n  letters =\
    \ s[0..-2]\n  letters.chars.each do |letter|\n    if letter.upcase == letter\n\
    \      count += 1\n    end\n  end\n  count\nend\n</code>\nWe can use these helper\
    \ functions in a fairly readable way, and avoid duplication by using a method:\n\
    <code>", "  count = 0\n  s.each_index do |index|\n    if s[index].upcase == \"\
    A\" || s[index].upcase == \"E\"\n      count += 1\n    end\n  end\n  count\nend",
  "    s.to_s.downcase.chars.each_with_index do |c,i|\n        puts \"c is #{c}, i\
    \ is #{i}\"\n        return 0 if i % 2 == 0 && c == 'A' || c == 'a' || c == 'E'\
    \ || c == 'e'\n    end\n    return 1\nend", "  even_index = 0\n  odd_index = 1\n\
    \  while even_index < s.length\n    even_index += 2\n    odd_index += 1\n    return\
    \ 0 if s[even_index].upcase != s[odd_index].upcase else 1\n  end\n  return 0\n\
    end", "    count = 0\n    even_index = 0\n    \n    while even_index < s.length\n\
    \        char1 = s[even_index]\n        if char1.upcase == true\n            even_index\
    \ = even_index + 1\n            count = count + 1\n        end\n        even_index\
    \ = even_index + 1\n    end\n    \n    return count\nend", "  count = 0\n  s.each_char\
    \ do |c|\n    if c.upcase == c\n      count += 1\n    end\n  end\n  count\nend",
  "  i = 0\n  while i < s.length\n    if s[i].upcase == true\n      i += 1\n    else\n\
    \      break\n    end\n  end\n  return i\nend", "  s.upcase!\n  s.chars.each_with_index.inject(0)\
    \ { |sum, (c,ix)| sum + c == 'A' ? 1 : 0 }\nend\n</code>\nI used upcase! to avoid\
    \ modifying the string in place. The each_with_index is the same as map, but with\
    \ all the indices. inject can be used to accumulate a result value for each character,\
    \ with the initial value set to 0. As we are summing up 1, we only need a single\
    \ character in the block, so to get the value for each character we just use c.\n\
    Using inject like this has some benefits to understanding it (for me). It takes\
    \ advantage of the fact that inject is lazy and doesn't require a block at all.\
    \ For example, the following:\n<code>\narr = [1, 2, 3, 4]\narr.inject(0){|sum,\
    \ i| sum + i}\n</code>\nIs the same as:\n<code>\narr = [1, 2, 3, 4]\narr.reduce(0)\
    \ {|sum, i| sum + i}\n</code>\nThe difference is that the inject version is easier\
    \ to read. It's very similar to map, but with inject you see the accumulator argument\
    \ explicitly. It also allows you to set a default value for your accumulator,\
    \ which can be useful.\n<|/ a dscore=3 |>\n<| c |>\nThanks, this is very comprehensive.\
    \  I'm very new to ruby, so I've been reading \"The Well Grounded Rubyist\", which\
    \ explains things like \"Enumerable\", \"Enumerator\", \"Hash\", \"Module\", \"\
    Array\", \"String\", \"Integer\", etc..  But you explained everything very well.\
    \  I still find it hard to read because I've not yet read a book like \"Agile\
    \ Principles, Patterns, and Practices\".  I find it a little tricky to understand\
    \ what \"inject is lazy\" is referring to.\n<|/ c |>\n<| c |>\nI appreciate this\
    \ answer. Very thorough. Just want to mention another interesting concept in addition\
    \ to those mentioned here: memoization (also known as memoization - memoize is\
    \ more commonly known as memoization). I don't know if that's an important concept\
    \ to the OP, but just wanted to mention that it's an important concept to know.\n\
    <|/ c |>\n<| c |>\n: I edited my answer to include an example of memoization.\
    \ Hope that helps.\n<|/ c |>\n<| a dscore=1 |>\nI believe that this is what you\
    \ are looking for\n<code>", "  return s.count('e'*s.length/3)\nend", "  s.split('').map.with_index\
    \ do |char, i|\n    if (i % 2 == 0)\n      if char.upcase == 'A'\n        1\n\
    \      else\n        0\n      end\n    end\n  end.reduce(:+)\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| c |>\nWhy are you calling `map` twice and `reduce` only once?\n\
    <|/ c |>\n<| c |>\nBecause I just wanted to understand how it was working.\n<|/\
    \ c |>\n<| c |>\n`split` and `map` do different things and are intended to be\
    \ used differently depending on your needs. If you just want to count the occurrences\
    \ of uppercase letters, you can use `char.upcase == 'A'`.\n<|/ c |>\n<| c |>\n\
    Thanks for the suggestion. I did a couple of minor modifications to the code.\n\
    <|/ c |>\n<| a dscore=2 tags=ruby |>\n<code>", "  str.count(s.upcase,2)\nend",
  "  s.downcase!\n  s.each_char {|c| c =~ /[AEIOUaeiou]/i ? $&.length : 0}\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
