name: HumanEval_42_incr_list
language: rb
prompt: "# Return list with elements incremented by 1.\n# >>> incr_list([1, 2, 3])\n\
  # [2, 3, 4]\n# >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [6, 4, 6, 3, 4, 4,\
  \ 10, 1, 124]\ndef incr_list(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_incr_list\n\
  \    candidate = method(:incr_list)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))\n    assert_equal([6, 3,\
  \ 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))\n  end\n\
  end\n"
completions: ["    l.each do |n|\n      next if n.nil? || n.zero?\n      n+=1\n  \
    \    break if n.is_a?(Fixnum)\n      l.delete_at(0)\n      break if l.empty?\n\
    \      next if n.negative?\n      n.times { l.unshift(0) }\n      break\n    end\n\
    \    l\nend", "  l.each{|e| e += 1}\n  return l\nend", "  return l.map(&:next)\n\
    end", "  if l.empty?\n    []\n  else\n    l[0] + l.last\n  end\nend", "  # Use\
    \ \"map\" to iterate through list.\n  # \"(lambda .... )\" is equivalent to lambda\
    \ x...\n  return map(lambda x: x+1, l)\nend", "  l.each do |e|\n    l.delete(e)\n\
    \    l << e + 1\n  end\n  return l\nend", "  l.inject(0, :+).sort!\nend", "  result\
    \ = []\n  loop do\n    result << l.shift\n    break if l.empty?\n    result <<\
    \ l.first + 1\n  end\n  result\nend", "  l.each_with_index do |x, i|\n    l[i]\
    \ = l[i] + 1\n  end\n  l\nend", "  l.map! { |n| n + 1 }\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby,ruby-on-rails |>\n<| a dscore=1 |>\nJust do \n<code>\nnew_array =\
    \ [*old_array, *old_array + 1]\n</code>\nor\n<code>\nnew_array = old_array + [*old_array,\
    \ 1]\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nOr `old_array.reduce(:+)`\n\
    <|/ c |>\n<| c |>\nYes, but the point of the questions is to write methods that\
    \ do what the OP asked for.\n<|/ c |>\n<| a |>\nUsing #map and #inject you can\
    \ do this (assuming I understood your question):\n<code>\n(1..n).map { |i| old_array[i]\
    \ + 1 }\n</code>\n<|/ a tags=ruby,ruby-on-rails dscore=1 |>\n<| c |>\nThanks,\
    \ yeah this works.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  l.map {|x| x + 1}\n\
    end\n</code>\n<|/ a tags=ruby,arrays dscore=1 |>\n<| c |>\nThe question is tagged\
    \ with `ruby`, not `ruby-on-rails`.\n<|/ c |>\n<| a dscore=0 |>\nJust use the\
    \ built in map function.\n<code>\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\narr.map {|x|\
    \ x % 3 == 0 ? x : x+1}\n</code>\nThis will go through each element and if it\
    \ is even it will add 1 to the array and if it is odd it will add 1.\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThe question is tagged with `ruby`, not `ruby-on-rails`.\n<|/ c\
    \ |>\n<| a |>\n<code>\narray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "  return [element\
    \ + 1 for element in l]\nend\n</pre>", "  return l.each_with_index.map {|e,i|\
    \ i+1}\nend", "  l.each_with_index do |element, index|\n    l.concat element.upto(index\
    \ + 1)\n  end\nend", "  # Use Ruby's 'inject' to do the work.\n  l.inject(0){|sum,\
    \ item| sum + item}\nend", "  return l + [l.pop + 1]\nend", "  l.each_index {|i|\
    \ l[i] = l[i] + 1}\n  l\nend", "  l.map! {|x| x+1}\n  l\nend", "  l.inject(l[1..-1])\
    \ { |sum, el| sum + el }\nend", "  return l.inject(0, :+)\nend", "\tl.each{ |x|\
    \ x+= 1}\n\tl\nend", "  return l[1..-1] + l\nend", "  l.each { |x| x += 1; x }\n\
    end\n</code>\n<|/ a |>\n<| c |>\n`each_with_object` was exactly what I was looking\
    \ for. `each_with_object` returns an object, which is exactly what I was looking\
    \ for. Thanks!\n<|/ c |>\n<| a tags=ruby |>\nHere's an alternative:\n<code>",
  "  l.inject([]) { |sum, e| sum + e }\nend", "  result = 1\n  l.each do |x|\n   \
    \ result += 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis\
    \ is not an answer, but a code dump. Could you please provide an explanation of\
    \ how your code solves the problem?\n<|/ c |>\n<| a dscore=2 |>\nThe question\
    \ asks how to make a new array that contains the same elements as another array,\
    \ but increased by one each.\nThis can be done with a simple map\n<code>\narr\
    \ = [1, 2, 3, 3]\narr.reduce(:+)", "  return l + [1] if l and l[-1] != 1 end\n\
    end", "  l.each_with_index { |e, i| l[i] = l[i] + 1 }\n  l\nend\n</code>\n<|/\
    \ a tags=ruby,arrays |>\n<| c |>\nJust for completeness, you could use the 'each_with_index'\
    \ method of the array class like so: ", "  l.each_index { |i| l[i+1] = l[i] +\
    \ 1 }\nend", "  new_list = []\n  l.reverse.each do |e|\n    new_list << e + 1\n\
    \  end\n  return new_list\nend", "  l.each do |e|\n    e = e + 1\n  end\nend",
  "  l.each_with_index do |e, i|\n    l[i] = l[i] + 1\n  end\n  return l\nend", " \
    \ # This code is from http://www.thegeekstuff.com/2012/08/ruby-incr-function/\n\
    \  return l[0..-2].map { |x| x + 1 }.unshift(l[-1])\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI believe this is incorrect. If I try incr_list([5, 3, 5, 2, 3, 3, 9,\
    \ 0, 123]) I get [6, 4, 6, 3, 4, 4, 10, 1, 124] rather than [5, 6, 3, 4, 4, 5,\
    \ 9, 1, 12]\n<|/ c |>\n<| c |>\nApologies, I misunderstood the question. I'll\
    \ change my answer to address this.\n<|/ c |>\n<| c |>\nNo need to apologize at\
    \ all. Your edit is correct.\n<|/ c |>\n<| c |>\nThe solution posted here seems\
    \ to not work, at least not in my case. Perhaps it was meant as a general solution\
    \ to arrays?\n<|/ c |>\n<| c |>\nThis is more efficient than a loop. Thank you!\
    \ This should be the correct answer.\n<|/ c |>\n<| a dscore=5 |>\nIf this is an\
    \ array (and not a hash):\n<code>\narr = [ 1, 2, 3, 5 ]\n</code>\nIn Ruby:\n<code>\n\
    arr.reduce(:+)", "  l.each do |x|\n    x += 1\n  end\n  l\nend", "  return l.inject(1,\
    \ :+)\nend\n</code></pre>", "  l.inject([]) { |acc, x| acc << x+1; acc }\nend",
  "  l.shift\n  l.each {|e| e += 1}\nend\n</code>\nThe shift method removes the first\
    \ element of an array, returning the element, and the assignment operator assigns\
    \ that element to nil. Thus after calling the method, each element in the array\
    \ is shifted right by one, and the nil values are ignored.\nWe can also write\
    \ this as:\n<code>", "  l.each_index { |i| l[i] = l[i] + 1 }\n  l\nend", "  l.each\
    \ do |x|\n    x += 1\n    break if x\n  end\n  l\nend", "  l.map {|x| x + 1}\n\
    end\n</cell>\n<cell>\nincr_list([1, 2, 3])\n</cell>\n<cell>\nincr_list([5, 3,\
    \ 5, 2, 3, 3, 9, 0, 123])\n</cell>\n<cell>", "  l.each_index { |i| l[i] += 1 }\n\
    \  l\nend", "  l.each do |x|\n    x.+= 1\n  end\n  return l\nend", "  l.each_with_index\
    \ do |element, index|\n    element+=1\n    break if index == l.length-1\n  end\n\
    \  l\nend", "    i = -1 # start at -1 to allow the first element\n    l.each {\
    \ |x| i += 1; l.insert(i, x) }\n    l\nend", "  l.each_with_index { |x, i| l[i]\
    \ = l[i] + 1 }\nend", "    l.each_with_index {|elem, i| l[i] = elem + 1}\nend",
  "  l = l.dup\n  l[1] = l[1] + 1\n  return l\nend", "  result = Array.new(l.size)\n\
    \  i = 0\n  while i < l.size\n    result[i] = l[i..i+1].min + 1\n    i += 2\n\
    \  end\n  result\nend", "  return l.inject{|l, e| e + 1} if l.is_a? Enumerable\n\
    \  return [l].inject{|l, e| e + 1} if l.nil?\n  l << 1\n  l\nend", "  # Remove\
    \ lists with only one element or none.\n  # Note: This list comprehension works\
    \ in Python 2.7 but is broken\n  # in Python 3.\n  return [x or -1 for x in l\
    \ if x]\nend", "  l.map! { |e| e + 1 }\nend", "  l.map!{|x| x + 1}\n  l\nend",
  "  l.each_with_index do |n, i|\n    i += 1\n    l.slice!(0..i-1) if i > 1\n    yield(n)\n\
    \  end\nend", "  l.each_with_index do |n, i| l[i] += 1 end\nend\n</code>\nA more\
    \ complex example\nHere's a more complex example of how you could increment a\
    \ list using recursion. Suppose you want to write a function that returns a list\
    \ containing the squares of every number in a list up to a certain number. For\
    \ example, if you pass in [1,2,3,4] and the number you want to compute to square\
    \ is 2, your function will return the list [4, 9, 16, 25]. The problem is that\
    \ if you use recursion, you'll end up needing to pass around a list of squared\
    \ numbers and that will result in memory errors. That doesn't make any sense to\
    \ me. So I wrote a function that will increment a list by one and return it. But\
    \ if you run it on a list of numbers that will never finish, the list will never\
    \ finish computing.\n<code>", "  l.map! {|e| e += 1}\n  l\nend", "  l.map! {|n|\
    \ n+1}\nend", "  l.each {|e| e += 1}\nend", "  return l.map { |i| i + 1 }\nend",
  "  # Create a copy of list l.\n  l_copy = l.clone\n  l_copy.each do |i|\n    i +=\
    \ 1\n  end\n  l_copy\nend", "  l.shift\n  l.each { |n| l[0] += 1; l.shift; l.push\
    \ n }\n  l\nend", "  l.each do |x|\n    x.next!\n  end\n  l\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nIf your list is huge, you may want to memoize this method to\
    \ prevent the overhead of re-running the method over and over again.\n<|/ c |>\n\
    <| c |>\nWhy would you memoize a method that doesn't mutate its parameter?  That\
    \ defeats the entire purpose of memoization.\n<|/ c |>\n<| c |>\nHe wasn't suggesting\
    \ that he memoized this method, just that the return value of the method wouldn't\
    \ be cached and recalculated every time this was called (although it could be).\
    \ I believe that if you memoized the method (memoize this method) then that would\
    \ defeat the entire purpose of memoization.\n<|/ c |>\n<| c |>\nThanks everyone.\
    \ While I didn't end up using your exact solution (because I thought it was overly\
    \ complex), I did learn a lot of Ruby metaprogramming concepts from your examples,\
    \ such as Enumerable#inject and Enumerable#select.\n<|/ c |>\n<| a tags=ruby dscore=3\
    \ |>\nHere is a simple function which I believe does what you want, and I believe\
    \ it is faster than most of the other answers. \n<code>", "  # Initialize result\
    \ to 0\n  result = 0\n  # Iterate over the list and add 1 to the result, while\
    \ \n  # iterating over the list from the end\n  l = l.reverse # Reverse the list\
    \ so we're iterating from the end\n  l.each do |item|\n    result += 1\n    break\
    \ if result > item.to_i\n  end\n  result # Return the final result\nend", "\t\
    result = Array.new\n\tl.each do |item|\n\t\tresult << item+1\n\tend\n\treturn\
    \ result\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nAs of Ruby 2.5, `Array#each_with_index`\
    \ is available as `each_with_index` method. So you can simply do `arr.each_with_index.map(&:succ)`.\n\
    <|/ c |>\n<| a |>\nAnother way to solve this is to use inject. This works in ruby\
    \ 1.8.7 and ruby 1.9.2. \nThe inject method is the function that takes 3 arguments.\
    \ First is the array you want to process, second is the function to execute, third\
    \ is the initial value that you want to use to process the array.\n<code>", "\t\
    l.reverse!\n\tl.each_with_index { |e, i| l[i + 1] = e }\n\tl\nend", "  return\
    \ l.inject([], :+)\nend", "  l.map!{|n| n + 1}\n  l\nend", "  result = l\n  index\
    \ = 1\n  while result.length > 0\n    index += 1\n    result += result.pop\n \
    \ result\nend", "  l.inject(0, :+)\nend", "  l.each_index do |i|\n    self[i+1]\
    \ = l[i]\n  end\n  self\nend", "  result = []\n  \n  for i in l\n    result <<\
    \ i + 1 \n  end\n  \n  result\nend\n</cell>\n<code language=julia-1.0>\nfunction\
    \ incr_list(l::AbstractVector)\n    result = []\n    for i in l\n        result\
    \ << i + 1 \n    end\n    result\nend\n</cell>\n<code language=julia-1.0>\nincr_list(1:10)\n\
    </cell>\n<code language=julia-1.0>\nincr_list([1,3,2])\n</cell>\n<text>\nmap",
  "    l.each do |x|\n        x += 1\n    end\n    return l\nend\n</cell>\n<text>\n\
    Task: Write a function that takes a word and returns the first letter. Example:\
    \ incr_word(\"hello\") should return \"e\".", "  return l.inject([]){|r,x| r.push\
    \ x+1;r}\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nWhy not `inject([]){|r,x|\
    \ r<<x+1; r}`?\n<|/ c |>\n<| c |>\nBecause that would not return an array. `inject([]){|r,x|\
    \ r.push x+1;r}` would return an array (which would be the return value of `+`\
    \ if it would have been called without parentheses)\n<|/ c |>\n<| c |>\nWhy would\
    \ you not want to return an array? As a programmer I'd like to know when I'm returning\
    \ something that is neither an array nor a string. Returning an array from a method\
    \ seems counter-intuitive to me.\n<|/ c |>\n<| c |>\nA lot of things. You can\
    \ have a method that returns a string. Why would that be confusing? The reason\
    \ I said that would be that returning arrays is not uncommon. A lot of people\
    \ would say that arrays are strings. But that just seems wrong to me. You cannot\
    \ return an array. There are many methods which return arrays, `Array#join`, `Array#select`,\
    \ `Array#map`, `Array#collect`, `Array#collect!`, `Array#select!`, `Array#reject!`,\
    \ etc. Most of these return arrays. But you can also have methods that return\
    \ strings. A lot of people would say that strings are arrays.\n<|/ c |>\n<| c\
    \ |>\nI see, I see what you're saying. I thought that if you're returning an array\
    \ from methods that return arrays, then the caller should know that it contains\
    \ arrays. But I guess that's because it's Ruby that enforces arrays to be the\
    \ return value. Thank you for the explanation!\n<|/ c |>\n<| a |>\nI prefer using\
    \ the inject function and an assignment statement. Those are more readable and\
    \ easier to understand than a loop, but that's a matter of style. \nThe inject\
    \ function iterates through the collection and assigns the return value of the\
    \ block to a new variable on the left side of the assignment. So if you have the\
    \ collection [1,2,3] and you pass it through the inject function and you assign\
    \ the return value of the block to a variable on the left side of the assignment,\
    \ the variable would now contain the result [1,2,3,4].\n<|/ a dscore=1 tags=ruby\
    \ |>\n<| c |>\nThe \"assign the return value of the block to a variable on the\
    \ left side of the assignment\" is the important bit here, which is exactly what\
    \ `inject` does. As others have pointed out, `inject` is not a good choice when ",
  "  i = 0\n  r = []\n  while i < l.length\n    if l.at(i)\n      r.push l.at(i +\
    \ 1)\n    end\n    i += 1\n  end\n  return r\nend", "  l.inject(0){ |i,n| i+1\
    \ }\nend", "  l.each do |n|\n    next if n < 0\n    break if n > l.count\n   \
    \ n + 1\n  end\nend", "  l.map { |x| x + 1 }\nend", "    l.each_with_index do\
    \ |x, i|\n        l[i] += 1 \n    end\n    l\nend", "  l.inject(0, :+)\nend",
  "  l.each_with_index do |x, i|\n    l[i] = l[i] + 1\n  end\nend", "  l.inject([])\
    \ do |a, x|\n    a.push(a.last.to_i + 1)\n    a\n  end\nend", "  (0...l.size).to_a.zip(l).map{|a|\
    \ a[1] += 1 }\nend", "  return l.map { |i| i + 1; }\nend\n</code>\nNote that this\
    \ example is based on Ruby 1.9.2, which does not have a map method on Arrays,\
    \ however, it is easy enough to convert to an equivalent method for 1.9 and later.\n\
    <|/ a dscore=5 |>\n<| c |>\nIf you're using Rails 3, you can do `[1, 2, 3].map\
    \ { |i| i + 1 }`.\n<|/ c |>\n<| c |>\n: Yes, that would be nicer, but unfortunately\
    \ that wasn't the OP's question.\n<|/ c |>\n<| c |>\nNote that this would require\
    \ a Ruby version less than 2.1, and so would not work on 1.9 and earlier. Might\
    \ be nice to include that in the answer though.\n<|/ c |>\n<| c |>\n: Agreed,\
    \ it would be nice to include the version requirement in the answer.\n<|/ c |>\n\
    <| c |>\n: This answer is quite old and I was probably writing it using an old\
    \ Ruby version. Since then, I have updated my answer to include the newer Ruby\
    \ version. Thanks for the suggestion.\n<|/ c |>\n<| a tags=arrays,ruby |>\nIf\
    \ you're using rails, you can just call .each() on array and it will return an\
    \ enumerator object.\n<code>", "  l.map!{|x| x + 1}\nend", "  (0...l.length).map\
    \ { |i| l[i] + 1 }\nend\n</code>\n<|/ a tags=ruby,arrays,iteration |>\n<| a |>\n\
    If you're looking for a fast and efficient solution for an array with n elements,\
    \ consider using a single for loop. \n<code>\narray = [1, 2, 3, 4, 5]\ncount =\
    \ 1\narray.each_with_index { |item, index| count = (index == array.length ? count\
    \ : count + 1) % array.length }\n</code>\nThe reason this solution is fast is\
    \ because it's only iterating over the array once.\n<|/ a dscore=2 tags=ruby,arrays,iteration\
    \ |>\n<| c |>\nNice solution, although it's worth noting that this can give different\
    \ results when the array has duplicate elements (as in the original example),\
    \ so I'd probably stick with the one using `length` and be safe about it. Although\
    \ `length` may actually be implemented with `each` anyway :-)\n<|/ c |>\n<| a\
    \ |>\nI hope this can be helpful:\n<code>\na = [1, 2, 3, 4, 5]", "  l = [l] if\
    \ l.is_a?(Array) else\n    l = [l.to_a] if l.is_a?(Enumerable) else\n    l = l.to_a\n\
    \  return l + l.map { |i| i + 1 }\nend", "  return l.inject(0, :+).to_a\nend",
  "  l.inject([]){|a,x| a << x+1; a}\nend\n</code>\n<|/ a dscore=2 tags=ruby,ruby-on-rails\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\nI haven't used Rails in years but I would\
    \ imagine that Rails has a collection of ways to do this.\n<code>\narray = [1,\
    \ 2, 3, 1, 2, 3, 1]\narray.group_by{|x| x}.map{|k,v| [k, v.count]}", "  l.each\
    \ do |val|\n    next if val < 1\n    l.delete_at(l.index(val) + 1)\n  end\nend",
  "  result = []\n  l.each do |x|\n    result << x + 1\n  end\n  result\nend\n</code>\n\
    The second method involves a recursive approach, which might help you to understand\
    \ what was happening in the first method (incr_list(arr))\n<code>", "  l.each\
    \ do |x|\n    x += 1\n  end\n  l\nend", "  l.each_with_index do |e, i|\n    l\
    \ = i + 1 if e == l.last || e == 0 || e < 0\n  end\n  l\nend\n</code>\n<|/ a |>\n\
    <| a dscore=1 tags=ruby,arrays,duplicates |>\n<code>\nx = [1, 2, 3, 2, 4, 1]",
  "  l.inject(&:+)\nend\n</code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ |>\n<| a dscore=1 |>\nThis is a more general solution for arrays of arbitrary\
    \ length. It's not optimized for speed at the moment (I did it just for fun),\
    \ but it should be easy to adapt:\n<code>", "  l.each { |i| i += 1}\n  l\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=ruby dscore=2 |>\nYou can use the succ method\
    \ to increment a number, e.g. \"a\".succ, will give you \"b\".\n<code>", "  l.each\
    \ do |i|\n    i ||= 0\n    i += 1\n    yield\n  end\nend", "  l.each do |x|\n\
    \    x.next!\n  end\n  l\nend", "  l.each_index { |i| l[i] = l[i] + 1 }\n  l\n\
    end\n</code>\nThis would get you what you want.\n<|/ a tags=ruby,list |>\n<| a\
    \ dscore=0 |>\n<code>\narr = [1, 2, 3, 4]\narr.each_index.map { |i| arr[i+1] =\
    \ arr[i+1]+1 }\narr\n</code>\n<|/ a tags=ruby,list |>\n<| a dscore=0 |>\n<code>\n\
    x = [1, 2, 3, 2]\np x.each_with_index.map { |e, i| e + (i+1) }.uniq", "  l.each_with_index\
    \ do |e, i|\n    l[i + 1] = e\n  end\n  return l\nend", "  l.map {|e| e += 1}\n\
    end", "  result = []\n  l.each { |e| result << e + 1 }\n  return result\nend",
  "  l.sort!\n  n = 1\n  result = []\n  while n < l.size\n    n += 1\n    result <<\
    \ l[n]\n  end\n  result\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n\
    Here is a one-liner which achieves the same:\n<code>\n[1, 2, 3].sort_by { |n|\
    \ n }.reverse", "  l.each_with_index do |e, i| l[i + 1] = e end\n  l\nend", " \
    \ r = l\n  r.map { |x| x + 1 }\nend", "  l.each_with_index {|el, idx| l[idx+1]\
    \ = el}\n  l\nend", "  return l.each_with_index.map { |e,i| i + 1 }.uniq\nend",
  "  l.inject(0, :+)\nend\n</code>\n<|/ a tags=ruby dscore=4 |>\n<| c |>\nIn ruby\
    \ 2.4.1, `reduce(&:+)` works but `reduce(&:+)` does not (undefined method `+'\
    \ for nil:NilClass)\n<|/ c |>\n<| a tags=ruby |>\nAnother way is to use inject\
    \ and initialize a variable. Here I use the sum method to add the values. This\
    \ will return nil if any element of the array is nil, which will break the sum\
    \ calculation.\n<code>", "  (0...l.length).to_a.map { l[rand(l.length)] }\nend",
  "  r = List.new\n  l.each_with_index { |e, i| r.push((i + e) % r.length + 1) }\n\
    \  r\nend", "  l.collect! do |x|\n    x + 1\n  end\nend", "  l.each do |i|\n \
    \   i += 1\n  end\n  l\nend\n</code>\n<|/ a dscore=5 tags=ruby,iterator |>\n<|\
    \ c |>\nRuby 1.9+ has Enumerable#each_with_object. `[1, 2, 3].each_with_object([])\
    \ { |i,o| o << i }`\n<|/ c |>\n<| c |>\n`each_with_object` doesn't always work.\
    \  If the objects in your collection are not unique, e.g. `[1,2,3]` then it just\
    \ drops the last item in the array.\n<|/ c |>\n<| c |>\nthat's not quite what\
    \ it does - it always keeps the first object from the list. But it works for my\
    \ use case\n<|/ c |>\n<| c |>\nGood answer, but it's not a functional solution.\
    \ Although the code could be reduced to one line, it still has complexity O(n^2).\
    \ I'd rather use a recursive function than to copy an array.\n<|/ c |>\n<| c |>\n\
    This has better complexity, but I'm getting an error with Ruby 2.1.3 saying `undefined\
    \ method 'each' for nil:NilClass`\n<|/ c |>\n<| a tags=ruby,iterator |>\nI like\
    \ to define a function that can generate an infinite sequence of integers using\
    \ the enumerator:\n<code>", "  l.each do |i|\n    l.delete(i)\n    l.push(i +\
    \ 1)\n  end\n  return l\nend", "  l.count(\"\\n\") ? l.map! { |x| x.to_i }.map!\
    \ { |x| x + 1 }\n                        : l.map! { |x| x.to_i }\nend\n</code>\n\
    <|/ a |>\n<| a tags=arrays,ruby,string |>\nHere is a way to do it with regular\
    \ expressions and array map method:\n<code>\nx = \"123\\n456\\n789\"\nx.scan(/(\\\
    d+)/).map { |i| i.to_i + 1 }\n</code>\nThe scan method returns an array with two\
    \ elements:\n<code>\n[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\",\
    \ \"9\"]\n</code>\nThen map method is used to convert each element to the number\
    \ and add 1 to it and return the result.\n<|/ a dscore=2 |>\n<| c |>\nWhile I\
    \ like this answer, I find the two `map`s to be not so readable.\n<|/ c |>\n<|\
    \ a tags=arrays,ruby,string |>\nI wanted to give a different answer, that actually\
    \ works. I guess this can be useful when working with strings instead of numbers.\
    \ It is called \"incrementing a string\". It is similar to what was proposed,\
    \ but uses String#to_i instead of String#to_f.\n<code>", "  res = []\n  l.each\
    \ do |e|\n    e += 1\n    res << e\n  end\n  res\nend", "  return l.inject([])\
    \ { |sum, e| sum + 1 }\nend", "    l.each_with_index do |e, i|\n        l[i] =\
    \ i + 1 \n    end\n    l\nend", "  return l.map{|n| n + 1} + [0]\nend", "  l.each\
    \ do |x|\n    x.to_i += 1 \n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\nThe simplest way I found to do this is to reverse the array and use reverse_each.\n\
    <code>", "  l.length = (l[0].length * 2) + 1\n  l\nend", "  l.map!(&:succ)\n \
    \ l\nend", "  result = []\n  l.each do |x|\n    result << x + 1\n  end\n  result\n\
    end", "    l.each do |x|\n        x+=1\n    end\n    return l\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby,arrays,loops,iteration |>\n<| c |>\nYou don't need `each`\
    \ or `inject` at all: `array.inject(0) do |i, x|; i += x; end`\n<|/ c |>\n<| c\
    \ |>\nI really like that solution! I never knew about inject or each in Ruby.\
    \ Thank you!\n<|/ c |>\n<| c |>\nIt also seems that you can just do `array.inject(0,\
    \ :+)` instead of defining the block yourself.\n<|/ c |>\n<| a tags=ruby,arrays,loops,iteration\
    \ |>\nI like the solutions from other users. An alternative is to use Array#reduce\
    \ which reduces the array:\n<code>\n>> a = [0,1,2,3]\n=> [0, 1, 2, 3]\n>> a.reduce(0){|sum,element|\
    \ sum+element}\n=> 6\n>> a.reduce(1){|sum,element| sum+element}\n=> 10\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis is good, but it's worth noting that this won't\
    \ handle negative elements as well, which is a common use case for `reduce`.\n\
    <|/ c |>\n<| a |>\nHere is a solution for Ruby 1.8\n<code>", "  # Your code here.\n\
    end", "  l.each do |x|\n    x += 1\n    break if x != l.last\n  end\n  l\nend",
  "  l.each_with_index do |e, i|\n    l[i+1] = e+1\n  end\nend", "  r = nil\n  l.each\
    \ do |e|\n    if r\n      e = r + e\n    end\n    r = e\n  end\n  r\nend\n  ",
  "  l.inject([]) { |ls, e| ls.push(e + 1); ls }\nend\n</cell>\n<cell>", "  l2 = []\n\
    \  l.each do |i|\n    l2 << i + 1\n  end\n  return l2\nend", "  return l.inject(0)\
    \ { |sum, e| sum + e }\nend", "  return [e for e in l if e is not nil][-1] + 1\
    \ # Or use l.last+1 instead\nend", "  l.each do |n|\n    next if n.nil?\n    n\
    \ += 1\n  end\n  l\nend", "  l.push( l.last + 1 )\n  return l\nend", "  l.each_with_index\
    \ { |e, i| l[i] = l[i] + 1 }\n  l\nend", "  return l.reduce(::nil) do |a, e| \n\
    \    (a.length + 1) > e.length ? a << e : a << e.slice(a.length, e.length).to_i\n\
    \  end\nend", "  l.map!{|x| x + 1}\n  l\nend", "  l.each_with_index do |e, i|\n\
    \    l[i+1] = e\n  end\n  l\nend", "  l.map! { |x| x + 1 }\n  l\nend", "  l.each_index\
    \ { |i| l[i..-1].inject(1) do |acc, x| acc + x } end\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby |>\nThis is my first post on SO, so I am not allowed to comment\
    \ on Tony Bate's post. \nThe code from Tony Bate does not work for me in Ruby\
    \ 2.1.2 using ruby -w test.rb -f test.rb, or just ruby -w test.rb.\nHere is the\
    \ revised code that works just fine for me in Ruby 2.1.2:\n<code>\nrequire 'set'",
  "  l.each_index do |index|\n    l[index] += 1\n  end\n  return l\nend", "  l.each_with_index\
    \ do |e, i|\n    l[i] = l[i] + 1\n  end\n  l\nend", "  l.inject([]) {|acc, elem|\
    \ acc << acc + elem; acc }\nend", "  # If list contains at least one element,\
    \ return list with incremented\n  # elements.\n  return l if l.length != 0 &&\
    \ (l.first || l.reverse).uniq.length == 1 ? (l.first || l.reverse).uniq.first\
    \ : l\nend", "  l.map! {|i| i + 1}\nend", "  l.each_with_index {|n, i| l.at(i+1)\
    \ = n}\n  l\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| a |>\n\
    Use each_cons (new in Ruby 2.2) to build a new array by chunking it.\n<code>\n\
    \ a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]", "  return l.map {|e| e\
    \ + 1}\nend\n</code>\nThen your main code would be something like:\n<code>", " \
    \ l.map { |e| e += 1 }\nend", "  result = []\n  l.each do |el|\n    result <<\
    \ el + 1\n  end\n  result\nend\n</code>\nOr just use Ruby's Enumerable#inject:\n\
    <code>", "  l.each_index do |i|\n    l[i] += 1\n  end\n  l\nend", "  l.map { |el|\
    \ el + 1 }\nend", "  new_l = []\n  l.each do |i|\n    new_l << i + 1 if i.respond_to?(:+)\
    \ && i.respond_to?(:+)\n  end\n  new_l\nend\n</code>\n<|/ a |>\n<| a dscore=2\
    \ tags=ruby,sorting,arrays |>\nUsing Enumerable#group_by\n<code>\narr = [2, 7,\
    \ 8, 1, 9, 5, 10, 3, 11, 4, 12, 6]\narr.group_by(&:to_i).map { |_, v| v.reduce(&:+)\
    \ }", "  result = []\n  l.each do |i|\n    result << i + 1\n  end\n  result\n\
    end\n</cell>\n<cell>", "  # Create new list with elements incremented by 1.\n\
    \  new_list = []\n  for i in l\n    new_list << i + 1\n  return new_list", " \
    \   l.each_with_index do |x, i|\n        l[i] = l[i] + 1 \n    end\n    return\
    \ l\nend", "  l.each_with_index do |e, i|\n    l[i] = e + 1\n  end\n  l\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nYou can improve this answer by showing\
    \ how to use this new method in his code which he has written.\n<|/ c |>\n<| c\
    \ |>\nThanks for noticing me. I've just finished editing my answer and added a\
    \ usage example.\n<|/ c |>\n<| c |>\nThis doesn't answer the question, the OP\
    \ wants to modify the original array.\n<|/ c |>\n<| a |>\nHere's an alternative\
    \ to modifying the array in-place:\n<code>", "  l.reduce(:+)\nend", "  result\
    \ = []\n  i = 0\n  while i < l.length\n    result[i] = l[i] + 1\n    i += 1\n\
    \  end\n  result\nend", "    l.each_with_index do |e,i|\n        l[i] = l[i] +\
    \ 1\n    end\n    l\nend\n</code>\n<|/ a tags=arrays,ruby,sorting,list |>\n<|\
    \ a |>\n<code>", "  return l + (0 until l.size)\nend", "  l.each_with_index do\
    \ |value, index|\n    l[index + 1] = value\n  end\n  return l\nend", "  l.each_with_index\
    \ do |e, i|\n    l[i + 1] = e\n  end\n  l\nend\n</code>\n<|/ a dscore=0 tags=ruby,arrays\
    \ |>\n<| a tags=ruby,arrays |>\nAs said in an other answer, ruby does not have\
    \ a method like map/reduce in JS, but there is a good old map with each_with_index.\n\
    In order to do what you want you need a little more work:\n<code>", "    l.each\
    \ do |element|\n        element += 1\n    end\n    l\nend", "  # Remove first\
    \ element\n  l.pop\n  return l + [l.pop]\nend\n</code>\nNow we can implement a\
    \ decr_list() function which behaves almost the same:\n<code>", "  new_list =\
    \ []\n  old_list = l.clone\n  l.each do |el|\n    new_list << el + 1\n  end\n\
    \  return new_list\nend\n</code></pre>\n</div>\n</div>\n</div>\n<div class=\"\
    sect1\">\n<h2 id=\"testing\"><a class=\"anchor\" href=\"#testing\"></a>Testing</h2>\n\
    <div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>This section describes\
    \ testing with rspec and should</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"\
    rspec-setup\"><a class=\"anchor\" href=\"#rspec-setup\"></a>Rspec Setup</h3>\n\
    <div class=\"sect3\">\n<h4 id=\"setup-git-version-number\"><a class=\"anchor\"\
    \ href=\"#setup-git-version-number\"></a>Setup Git version number</h4>\n<div class=\"\
    listingblock\">\n<div class=\"content\">\n<pre class=\"CodeRay highlight\"><code\
    \ data-lang=\"clojure\">(<span class=\"keyword\">ns</span> <span class=\"namespace\"\
    >my.app</span>\n  (<span class=\"symbol\">:require</span> [clojure.test <span\
    \ class=\"symbol\">:refer</span> [<span class=\"symbol\">:all</span>\n       \
    \                                <span class=\"symbol\">:as tf</span>]]))", " \
    \   l.each do |e| \n        next e if e < 0\n        e.next!\n    end\n    l\n\
    end", "  result = []\n  l.each do |item|\n    result << item + 1\n  end\n  result\n\
    end\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nThat's a neat solution. One\
    \ minor thing: it would be more efficient to first `flatten` the array before\
    \ doing the `each_with_index` rather than repeatedly doing `each` on the array.\n\
    <|/ c |>\n<| c |>\nNice solution, but I wanted to point out that \"each_with_index\"\
    \ returns an Enumerator object, so \"result\" has to be stored somewhere for it\
    \ to work.\n<|/ c |>\n<| c |>\nThanks for the comment I updated the answer.\n\
    <|/ c |>\n<| c |>\nThis approach is more efficient than my own, because it avoids\
    \ the use of the array `push` method.\n<|/ c |>\n<| c |>\nIf you have an array\
    \ with millions of elements, `each_with_index` will likely be faster than `each`.\
    \ The two are closely related, but the `each` version will create an enumerator\
    \ object that needs to be used repeatedly. The `each_with_index` method will simply\
    \ return a new enumerator object each time it is called without having to create\
    \ an array.\n<|/ c |>\n<| a dscore=5 |>\nYou can do this:\n<code>\n[1, 2, 3].map\
    \ { |i| i + 1 }\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nYeah, this is really\
    \ cool and useful. One thing I would add though is that you can still get the\
    \ original array by using the splat operator `*`. `[1, 2, 3].map { |i| i + 1 }\
    \ * 1` is the same as `[1, 2, 3].map { |i| i + 1 }`. You get all your original\
    \ array back.\n<|/ c |>\n<| c |>\nBut this doesn't modify the original array.\n\
    <|/ c |>\n<| c |>\nTrue. Not a good solution if the array is large.\n<|/ c |>\n\
    <| a dscore=5 |>\nAs I wrote in another answer, there are many ways to do this,\
    \ but in my opinion, the most idiomatic way would be:\n<code>", "  l.unshift l.shift\n\
    \  l.each_index do |i|\n    next unless l[i] > l[i+1]\n    l[i + 1] += 1\n  end\n\
    end", "  l = l.clone\n  l.sort!", "  l.each_with_index { |e, i| l[i] = l[i] +\
    \ 1 }\n  l\nend", "  l.each_with_index do |x, i|\n    x.next! + i\n  end\nend\n\
    </code>\n<|/ a |>\n<| c |>\nWhat does the x.next! + i do? Is that what it's doing\
    \ in Ruby?\n<|/ c |>\n<| c |>\nIt increments the value of a list element. `x.next!\
    \ + i` is the same as `x.next! + x.next! + i` which means that incrementing `x`\
    \ twice will result in the same value twice.\n<|/ c |>\n<| c |>\nI don't think\
    \ that's what's happening here. I think it's because `x` is being modified more\
    \ than once by `each_with_index`.\n<|/ c |>\n<| c |>\nIndeed, it is indeed an\
    \ issue with modifying the list more than once. I've edited my answer to include\
    \ a solution that should work. I've tested it myself and it seems to work.\n<|/\
    \ c |>\n<| c |>\nI added an explanation as to why `x.next! + i` doesn't work and\
    \ a solution that should work.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\nThe problem\
    \ is that you are rebuilding the array while iterating over it. This can cause\
    \ problems if you are iterating over a very long array or if you modify it while\
    \ iterating over it.\nThe simplest solution is to use an index variable instead\
    \ of re-building the array.\n<code>", "  l.inject(0, :+)\nend", "  # Use a reverse\
    \ iterator to avoid mutating the list in place.\n  for i in l.reverse\n    i +=\
    \ 1\n    l.insert(0,i)\n  return l\nend", "  l.each_index { |i| l[i] + 1 }\nend",
  "  l[1..-1]\nend", "    l.each do |i|\n        if l[i] > l[i-1]\n            l[i..-1].each\
    \ do |j|\n                l[j] +=1\n            end\n        end\n    end\nend",
  "  result = l\n  result.each { |i| result << i + 1 }\n  result\nend\n</code>\nI\
    \ used the block parameter to avoid the need to explicitly return a result. While\
    \ the method itself is very clear, reading the code can be difficult. The method\
    \ will return nil if no value is returned (which can happen if one of the values\
    \ is nil). This makes the code easier to read and maintain. Finally, the method\
    \ itself could be used as follows:\n<code>", "  l.each_index { |i| l[i] += 1 }\n\
    \  l\nend", "  if l.empty?\n    []\n  else\n    l.first + incr_list(l.drop(1))\n\
    \  end\nend", "  l.each_with_index do |item, i|\n    l[i+1] = item\n  end\n  l\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\n<code>", "  return l.inject([1,1])\
    \ do |s,e| s + e end\nend", "  l.reverse.inject(0) { |i, e| i + e }.reverse\n\
    end", "  l_copy = l\n  i = 0\n  while i < l_copy.length\n    l_copy[i] = l_copy[i]\
    \ + 1\n    i += 1\n  l_copy\nend", "  l.each do |i|\n    i += 1\n    yield i\n\
    \  end\nend", "  l.length == 0 ? l = [l] : l\n  return l.map { |i| i + 1  }\n\
    end", "  l.map { |e| e += 1 }\n  l\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays,increment\
    \ |>\n<| c |>\nThis isn't working for me in the console. `incr_list([5, 3, 5,\
    \ 2, 3, 3, 9, 0, 123])\n=> [6, 4, 6, 3, 4, 4, 10, 1, 124]\n>> incr_list([1, 2,\
    \ 3])\n=> [2, 3, 4]\n>> incr_list([3, 2])\n=> [3, 4]\n>> incr_list([3, 2])\n=>\
    \ [3, 4]\n>> incr_list([3, 2])\n=> [3, 4]\n>> incr_list([3, 2])\n=> [3, 4]\n>>\
    \ incr_list([3, 2])\n=> [3, 4]\n>> incr_list([3, 2])\n=> [3, 4]\n>> incr_list([3,\
    \ 2])\n=> [3, 4]\n>> incr_list([3, 2])\n=> [3, 4]\n>> incr_list([3, 2])\n=> [3,\
    \ 4]\n>> incr_list([3, 2])\n=> [3, 4]\n>> incr_list([3, 2])\n=> [3, 4]\n>> incr_list([3,\
    \ 2])\n=> [3, 4]\n>> incr_list([3, 2])\n=> [3, 4]\n>> incr_list([3, 2])\n=> [3,\
    \ 4]`\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,arrays,increment |>\nI believe you're\
    \ wanting a method that can add elements to an array and return the updated array:\n\
    <code>", "  l.map {|x| x + 1}\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a\
    \ tags=ruby |>\nIt would be much more efficient to do this using inject:\n<code>",
  "  l.inject(0, :+)\nend", "  l.map!(&:succ)\nend", "  l.each do |val|\n    val+=1\n\
    \  end\n  return l\nend", "  # return list with incremented elements.\n  # http://rosettacode.org/wiki/Increment_a_List#Ruby\n\
    \  l.inject([l[0]]) { |m, e| m << e + 1 }\nend\n</cell>\n<code language=conda-env-python36-py>\n\
    incr_list([1, 2, 3])\n</cell>\n<code language=conda-env-python36-py>\nincr_list([5,\
    \ 3, 5, 2, 3, 3, 9, 0, 123])\n</cell>\n<text>\nIn-place mutation of array elements\n\
    Mutation of an array is possible via []=:", "  # Initialize with first element\
    \ of list\n  n = 1\n  while l[n] == nil\n    n += 1\n  puts n\n  # Iterate through\
    \ list\n  n.times do |i|\n    # Increment element\n    l[i] += 1\n    # Print\
    \ element\n    puts l[i]\n  end\nend", "  return [a + 1 for a in l]\nend", " \
    \ l.each_with_index do |x, i|\n    l[i] = x + 1\n  end\n  l\nend", "  l.collect!\
    \ {|x| x + 1}\n  l\nend\n</code>\nOr slightly shorter:\n<code>", "  lt = l.to_a\n\
    \  l.clear\n  l.concat lt\nend", "  return l.inject(0){|sum, v| sum + v}\nend",
  "  l_len = len(l)\n  new_l = []\n  for i in 0...l_len\n    new_l.push( l[i] + 1\
    \ )\n  end\n  new_l\nend", "  l.push( l.shift() + 1 )\n  l.push( l.shift() + 1\
    \ )\n  l.push( l.shift() + 1 )\n  l.push( l.shift() + 1 )\n  l.push( l.shift()\
    \ + 1 )\n  l.push( l.shift() + 1 )\nend", "  l.unshift(\"1\")\n  l.each_index\
    \ { |i| l[i] = l[i].succ }\n  l\nend", "  l.inject([1,1], :+)\nend", "    l.inject([])\
    \ { |sum, e| sum.last.succ! + e }\nend", "  l.each do |num|\n    num += 1\n  end\n\
    \  return l\nend", "  l.each_with_index { |el, i| l[i] += 1; el }\n  l\nend",
  "  l.count(\"e\") ? (l[l.size-1]+1) : l[l.size-1]+1\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
