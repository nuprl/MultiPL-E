name: HumanEval_134_check_if_last_char_is_a_letter
language: rb
prompt: "# Create a function that returns True if the last character\n# of a given\
  \ string is an alphabetical character and is not\n# a part of a word, and False\
  \ otherwise.\n# Note: \"word\" is a group of characters separated by space.\n# Examples:\n\
  # check_if_last_char_is_a_letter(\"apple pie\") \u279E False\n# check_if_last_char_is_a_letter(\"\
  apple pi e\") \u279E True\n# check_if_last_char_is_a_letter(\"apple pi e \") \u279E\
  \ False\n# check_if_last_char_is_a_letter(\"\") \u279E False\ndef check_if_last_char_is_a_letter(txt)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_check_if_last_char_is_a_letter\n\
  \    candidate = method(:check_if_last_char_is_a_letter)\n    assert_equal(false,\
  \ candidate.call(\"apple\"))\n    assert_equal(true, candidate.call(\"apple pi e\"\
  ))\n    assert_equal(false, candidate.call(\"eeeee\"))\n    assert_equal(true, candidate.call(\"\
  A\"))\n    assert_equal(false, candidate.call(\"Pumpkin pie \"))\n    assert_equal(false,\
  \ candidate.call(\"Pumpkin pie 1\"))\n    assert_equal(false, candidate.call(\"\"\
  ))\n    assert_equal(false, candidate.call(\"eeeee e \"))\n    assert_equal(false,\
  \ candidate.call(\"apple pie\"))\n    assert_equal(false, candidate.call(\"apple\
  \ pi e \"))\n  end\nend\n"
completions: ["  # Write your code below this line\n  if txt.length <= 1\n  then false\n\
    \  else\n    txt.sub!(/\\s+/, '').slice!(-1..-1).each_char.all? { |c| c.match?(/[a-z]/)\
    \ }\n  end\nend", "  return txt[txt.length -1] == \" \"\nend", "  if txt.empty?\n\
    \    false\n  elsif txt[-1] =~ /^[a-z]/i\n    false\n  else\n    true\n  end\n\
    end", "    \n    if txt ==\"\"\n        return false\n    end\n    \n    if txt[-1]\
    \ == \" \"\n        return false\n    end\n    \n    if txt[-1] == \".\" or txt[-1]\
    \ == \",\"\n        return false\n    end\n    \n    if txt[-1] == \"-\" or txt[-1]\
    \ == \"_\"\n        return false\n    end\n    \n    if txt[-1] == \":\" or txt[-1]\
    \ == \"?\" or txt[-1] == \" \"\n        return false\n    end\n    \n    if txt[-1]\
    \ == \" \"\n        return false\n    end\n    \n    if txt[-1] == \"\\n\"\n \
    \       return false\n    end\n    \n    if txt[-1] == \"-\"\n        return false\n\
    \    end\n    \n    if txt[-1] == \".\" or txt[-1] == \",\"\n        return false\n\
    \    end\n    \n    if txt[-1] == \"?\" or txt[-1] == \" \"\n        return false\n\
    \    end\n    \n    if txt[-1] == \" \"\n        return false\n    end\n    \n\
    \    if txt[-1] == \"\\n\"\n        return false\n    end\n    \n    if txt[-1]\
    \ == \"-\"\n        return false\n    end\n    \n    if txt[-1] == \"_\"\n   \
    \     return false\n    end\n    \n    if txt[-1] == \":\" or txt[-1] == \"?\"\
    \n        return false\n    end\n    \n    if txt[-1] == \" \"\n        return\
    \ false\n    end\n    \n    if txt[-1] == \"\\n\"\n        return false\n    end\n\
    \    \n    if txt[-1] == \"_\"\n        return false\n    end\n    \n    if txt[-1]\
    \ == \":\"\n        return false\n    end\n    \n    if txt[-1] == \" \"\n   \
    \     return false\n    end\n    \n    if txt[-1] == \"\\n\"\n        return false\n\
    \    end\n    \n    if txt[-1] == \"-\"\n        return false\n    end\n    \n\
    \    if txt[-1] == \"_\"\n        return false\n    end\n    \n    if txt[-1]\
    \ == \":\" or txt[-1] == \"?\"\n        return false\n    end\n    \n    if txt[-1]\
    \ == \" \"\n        return false\n    end\n    \n    if txt[-1] == \"\\n\"\n \
    \       return false\n    end\n    \n    if txt[-1] == \"-\"\n        return false\n\
    \    end\n    \n    if txt[-1] == \"_\"\n        return false\n    end\n    \n\
    \    if txt[-1] == \" \"\n        return false\n    end\n    \n    if txt[-1]\
    \ == \"\\n\"\n        return false\n    end\n    \n    if txt[-1] == \"-\"\n \
    \       return false\n    end\n    \n    if txt[-1] == \"_\"\n        return false\n\
    \    end\n    \n    if txt[-1] == \" \"\n        return false\n    end\n    \n\
    \    if txt[-1] == \"\\n\"\n        return false\n    end\n    \n    if txt[-1]\
    \ == \"-\"\n        return false\n    end\n    \n    if txt[-1] == \"_\"\n   \
    \     return false\n", "  word_split = txt.split(\" \")\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n\
    \  word_split.pop\n  word_split.pop\n  word_split.pop\n  word_split.pop\n", " \
    \ txt.each do |e|\n    return true if e[-1] =~ /\\A[A-Za-z]\\z/\n  end\n  return\
    \ false\nend", "  txt.slice!.downcase!\n  txt.slice!.split.include? txt[-1]\n\
    end", "  # initialize a boolean value\n  flag=False\n  # get the last character\n\
    \  last_char=txt[txt.rindex(\"e\"):]\n  # if the last character is alphabetical\
    \ and a part of a word\n  if last_char.casefold==\"e\".casefold && txt.include?(\"\
    e\".casefold)\n    flag=true\n  end #end if\n  return flag\nend #end function",
  "  # Split words into an array of characters\n  word_arr = txt.split(' ')\n  # Iterate\
    \ through array and check\n  word_arr.each do |w|\n    if w[-1] =~ /\\w/\n   \
    \   return true\n    end\n  end\n  return false\nend", "    txt = txt.split(\"\
    \ \").last\n    return ((txt !~ /[A-z]$/) == false)\nend", "  txt.split.map(&:chars.first).join.length\
    \ <= (txt.split.map(&:chars).join.length * .3)\nend\n</code>\nUsing this function,\
    \ you can now check all words to see if they have any letter that has a higher\
    \ percentage of being part of another word:\n<code>", "  return txt.last ? txt.last.downcase\
    \ != txt.last.upcase : !txt.split.empty?\nend", "  result = false\n  if (txt.length)\n\
    \    if (txt.last.upcase && !txt.last.match( /\\w/ ))\n      result = true\n \
    \ end\n  return result\nend", "  return true if txt[txt.length-1] !~ /\\w$/\n\
    end\n</cell>\n<text>\nNow let's write a function which takes in a string and checks\
    \ how many vowels are in that string.\nAt the end of the function, we should return\
    \ a number.", "  txt.downcase!\n  txt.split\n  txt[-1][-1] != \" \" && !txt.include?(\"\
    \ \") && txt[-1][-1] != \".\"\nend", "  return txt[-1] == ' ' and txt.split.count\
    \ != 1\nend", "  words = txt.split(\" \")\n  if words[-1][-1].nil?\n    false\n\
    \  else\n    words[-1][-1] != \" \".freeze\n  end\nend", "  txt =~ /[^ ]+$/\n\
    \  return true if $~ == nil \n  false\nend", "    last = txt[-1]\n    last.upcase!\n\
    \    return !last.split.any?(/[A-Za-z]/)\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nJust note that this will only work if there is no space after the\
    \ last letter in the string. Your code will return `true` for `\"apple pie \"\
    `.\n<|/ c |>\n<| c |>\nGood point. I added a note at the bottom of the answer\
    \ to reflect this.\n<|/ c |>\n<| a |>\nThis is how I'd do it:\n<code>\ntxt = \"\
    apple pie\"", "  if txt.empty?\n    false\n  else\n    txt[txt.length-1].match(/[a-zA-Z]$/)\
    \ ? true : false\n  end\nend", "  txt.each_char.with_index do |char, index|\n\
    \    return false if index == txt.length - 1\n    return false if char == \" \"\
    \ && txt[index + 1] == \" \"\n    return false if char == \" \"\n    return true\
    \ if char == txt[index + 1].upcase\n  end\n  false\nend", "  txt = txt.downcase\n\
    \  txt = txt.strip\n  txt = txt.split(//).map(&:strip)\n  txt.each do |char|\n\
    \    return false if char.include?(\" \")\n    return true if char.include?(\"\
    \")\n    return true if char.include?(\"'\")\n    return true if char.include?(\"\
    !\")\n    return true if char.include?(\"#\")\n  end\n  return false\nend", " \
    \   words = txt.split(\" \")\n    letters = txt.split(\"_\")\n    return words[-1].split(\"\
    \").include?(letters[-1].upcase)\nend", "  str2 = txt.split(\" \").last\n  if\
    \ str2.present?\n    !str2.match(/\\w$/)\n  else\n    false\n  end\nend", "  return\
    \ txt[-1..-1].is_a?(String) and (txt[-1..-1].split(\" \").any? { |word| word !~\
    \ /^[a-z]$/ })\nend", "  txt.chars.last.match /\\w/ && txt.chars.count > 1\nend",
  "    word = ''\n    return !txt.empty? and txt.slice!(-1,1).ascii_only? and txt.slice!(-1,1).include?(word)\
    \ && word.empty?\nend", "  # Initialize a variable at the beginning, which is\
    \ True.\n  bool_value = True\n  # If the string length is 0, return False.\n \
    \ if txt.length == 0\n    bool_value = False\n  else\n    # If the last character\
    \ is a letter, return False.\n    if txt.last.match?(/[a-z]/i)\n      bool_value\
    \ = False\n    else\n      # Otherwise, return True.\n      bool_value = True\n\
    \  end\n  return bool_value\nend", "  return txt.chars.last.match?(/[[:alpha:]]/)\
    \ && txt.chars.size <= 1\nend", "  txt = txt.strip\n  if txt.empty?\n    false\n\
    \  elsif txt[txt.length-1].match(/[a-z]/i)\n    false\n  else\n    true\n  end\n\
    end", "  if txt != \"\"\n  then\n    if txt[-1] =~ /\\w/\n    then\n      return\
    \ false\n    end\n  end\n  return true\nend", "  txt.slice!(0...-1).downcase !~\
    \ /\\w/ && txt[-1] != ' '\nend", "  word = txt.split.last\n  word.downcase.include?(txt.split.last.downcase)\n\
    end", "  return txt.rsplit(\" \").last =~ /\\w$/\nend", "  txt.strip!\n  if txt.empty?\n\
    \    false\n  else\n    !word?(txt.last).nil? && !word?(txt.last.downcase)\n \
    \ end\nend", "  if txt.length == 0\n    puts \"Empty string\"\n  elsif txt.length\
    \ == 1\n    puts \"Empty string\"\n  elsif txt[-1].isalpha\n    puts \"Last character\
    \ is alphabetical character and is NOT a part of a word.\"\n  else\n    puts \"\
    Last character is alphabetical character and is NOT a part of a word.\"\n  end\n\
    end", "\ttxt = txt.downcase\n\ttxt = txt.split(\" \")\n\ttxt.last.downcase!\n\t\
    return !txt.include?(txt.last)\nend", "  return txt.empty? or txt.last =~ /[a-zA-Z]+/\
    \ and not txt.split.any? { |x| x == \" \" }\nend", "  if txt.empty?\n    return\
    \ false\n  txt.slice!((txt.length - 1)..-1)\n  txt.slice!(-1) if txt.slice!(-1)\
    \ == \"-\" # check for dash case\n  txt.each_char do |c|\n    return false if\
    \ c.upcase == c # return false if letter case\n    return false if c == \"'\"\
    \ || c == \"-\" || c.upcase == \"'\" || c.upcase == \"-\" # check for apostrophe\n\
    \    return true # otherwise\n  end\n  return false # return false if no character\
    \ after dash\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\nHere's an improved\
    \ version of Aditya Kumar's answer that allows you to do something like\n<code>\n\
    has_last_word?(text, word_char)\n</code>\nFor example\n<code>\nhas_last_word?('Apple\
    \ pie', 'e')", "  return txt[-1].isalpha()\nend", "  return txt.nil? or txt[-1]\
    \ =~ /[a-zA-Z]/ and txt !~ /[a-zA-Z]+$/\nend", "  txt_words = txt.split(\" \"\
    )\n  txt_words.pop if txt_words.size > 1\n  if txt_words[0].length <= 1\n    return\
    \ False\n  end\n  last_char = txt_words[txt_words.length-1].last\n  return last_char\
    \ !~ /\\p{L}/ && last_char !~ /[\\p{L}]+/\nend", "  txt.chomp\n  if txt[-1] !=\
    \ \" \" && txt[-1] != \"\\n\" \n    then return false\n  end\n  true\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby dscore=0 |>\nHere's another solution that works\
    \ also on empty strings and strings with white spaces:\n<code>", "  return txt.empty?\
    \ || txt[-1] =~ /\\W/\nend", "  txt.chars[-1].is_a?(String) ? (txt.chars[-1].is_word_char?\
    \ ? false : true) : false\nend", "  return txt[-1] =~ /\\A[a-z]/\nend", "  txt.slice!(-1)\n\
    \  if txt[-1].isalnum? and txt.slice!(-1)\n    true\n  else\n    false\n  end\n\
    end", "    txt_split = txt.split(' ')\n    last  = txt_split[-1]\n    alpha_char\
    \ = last.chars.first\n    return alpha_char.nil?\nend", "  txt.strip!\n  txt.downcase!\n\
    \  txt.chomp!\n  txt.gsub!(/\\s+/, \" \")\n  txt.split!\n  txt.last.downcase!\n\
    \  txt.index(\"[a-z]\")\nend\n</code>\n<|/ a |>\n<| c |>\nThis only works if all\
    \ the words are one character and they are always separated by spaces.\n<|/ c\
    \ |>\n<| c |>\nNo, it checks if the last character is alphabetical. `apple pi`\
    \ would return false.\n<|/ c |>\n<| a tags=ruby |>\nI'd do this:\n<code>", " \
    \ txt = txt.split(\" \").last.strip\n  !(txt.match(/^[a-zA-Z]+$/))\nend", "  chars\
    \ = txt.split(\" \")\n  last = chars.last\n  last.empty? ? false : true\nend",
  "  return txt !~ /\\w$/ && txt !~ /[^\\w]$/\nend", "  return txt.scan(/\\w$/).any?{|s|\
    \ s !~ /\\w/ }\nend", "  return txt[txt.length-1].to_s =~ /\\A[a-z]/i\nend", " \
    \ txt = txt.downcase\n  if txt.length==0\n  then return false\n  end\n  if txt.include?(\"\
    \ \") # only a partial word\n  then return false\n  end\n  txt[-1].isalpha? or\
    \ return false\nend", "  txt = txt.strip\n  txt = txt.split(\" \").join", "  return\
    \ txt.last !~ /\\w/\nend", "  return txt != '' && txt[-1] =~ /[a-zA-Z]/ && !txt.split.split.any?{\
    \ |word| word =~ /[a-zA-Z]/ }\nend\n</cell>\n<code language=julia-1.5>", "  return\
    \ true if txt.chars.last == txt.chars.last.upcase && txt.chars.last.downcase !=\
    \ 'e' && txt.chars.last.downcase != 'i' && txt.chars.last.downcase != 'o' && txt.chars.last.downcase\
    \ != 'u'\n  return false\nend", "  return txt[-1].match(/[a-zA-Z]$/)\nend\n</cell>\n\
    <text>\nLet's see how it works:", "  return false if !txt.empty? and txt.last.blank?\n\
    \  txt.each_char.with_index.map {|c, i| c.downcase }.reject {|w| w =~ /^[a-zA-Z]+$/}.empty?\n\
    end\n</cell>\n<text>\nLet's test our check_if_last_char_is_a_letter function:",
  "  # Complete the code here.\n  # Solution:\n  return true if txt[txt.length - 1].upcase\
    \ == txt[txt.length - 1]\nend", "  txt.scan(/^[a-z]/).empty?\nend", "  if txt.empty?\n\
    \    return false\n  letter = txt[txt.length-1]\n  if letter in CHARS_TO_IGNORE.split(\"\
    \ \").map(&:downcase)\n    return false\n  else\n    return true\n  end\nend",
  "  return txt.chars.last.upcase != \" \" && txt.chars.last.upcase !~ /\\w/\nend",
  "  if txt.empty?\n    return false\n  end\n  txt.slice!(-1..-1)\n  return txt.include?(@alpha)\
    \ && txt.split.empty?\nend", "  return txt.chars.last.upcase !~ /[a-zA-Z0-9]+/\
    \ and txt.chars.last.upcase != \" \" \nend", "  txt.empty?\nend", "  txt.slice!(-1)\
    \ # Remove the last character\n  txt.empty? || txt.match?(/[a-zA-Z]/) # Empty\
    \ string or a word character\nend", "    word = \"\"\n    words = txt.split(\"\
    \ \")\n    for w in words\n        word += w[-1]\n    return word.isalpha()\n\
    </cell>\n<cell>", "  txt = txt.downcase\n  txt.slice!(txt.rindex(\" \")) if txt.include?(\"\
    \ \")\n  lastchar = txt.slice(-1)\n  ! (lastchar =~ /[a-z]/i) && ! (lastchar =~\
    \ /[A-Z]/i)\nend\n</code>\n<|/ a |>\n<| c |>\nYour function doesn't handle the\
    \ last character of a string of spaces. It might not matter, but I figured it\
    \ would be good to point out.\n<|/ c |>\n<| c |>\nThanks for the pointing out.\
    \ I added a fix for that.\n<|/ c |>\n<| a dscore=0 |>\nHere's another option:\n\
    <code>", "  last_char_index = txt.size-1\n  return last_char_index >= 0 && txt.chars[last_char_index].isalpha\n\
    end", "  txt.upcase!\n  return txt[txt.length-1].upcase? && txt.split.include?(\"\
    \ \")\nend", "    if txt.empty?\n        return False\n    end1 = txt.last_index\n\
    \    end2 = txt.length - 1\n    txt.each_char.with_index do |chr, i|\n       \
    \ if i == end1\n            return false\n        end\n        if i == end2\n\
    \            return true\n        end\n        if chr.upcase == txt[i+1].upcase\n\
    \            return false\n        end\n    end\n    return false\nend", "  txt.downcase!\n\
    \  txt.split!\n  txt.chars.last.match?(/[A-Za-z]/)\nend", "  return !(txt[txt.length-1]\
    \ =~ /[a-z]/i).nil?\nend", "  return txt and txt[-1].isalpha() and txt.split(\"\
    \ \").length == 1\nend\n</cell>\n<code language=julia-1.1>", "    if txt.empty?\n\
    \        false\n    else\n        if txt[-1] =~ /[a-zA-Z]+/\n            false\n\
    \        else\n            true\n        end\n    end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a dscore=0 tags=ruby |>\nYou could use String#match to find all capital\
    \ letters followed by a non-capital letter:\n<code>\nmy_string = \"This is an\
    \ apple pie\"\nmy_string.match(/[A-Z][^A-Z]/)\n</code>\nThe result is an Array\
    \ of strings containing the capital letters:\n<code>", "  return txt[-1] =~ /\\\
    w/ and not txt.empty?\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\n`String#empty?`\
    \ is an alias for `String#present?`, which returns `true` if the string has any\
    \ character in it, regardless of whether its last character is a word character\
    \ or not. So `\"\".empty?` returns `true`, while `\" \".empty?` returns `false`.\n\
    <|/ c |>\n<| c |>\nYou are right, I was confused because I had never seen the\
    \ method `empty?` being aliased to `present?` in the documentation. Thanks!\n\
    <|/ c |>\n<| c |>\n`present?` and `empty?` are not the same: they both return\
    \ `true` if `present?` returns `true`. So, `\"\".present?` returns `true` and\
    \ `\" \".present?` returns `false`, but `\"\".empty?` returns `false` and `\"\
    \ \".empty?` returns `true`.\n<|/ c |>\n<| c |>\nYou are right, I had never thought\
    \ about that. Thanks for the hint!\n<|/ c |>\n<| c |>\nI do like the idea of using\
    \ a regex for this...but I am not sure how it would work. I can't seem to make\
    \ it work, and it just keeps returning false...\n<|/ c |>\n<| a tags=ruby dscore=0\
    \ |>\nThere are many ways you can do this. Here are some examples:\n<code>", " \
    \ lastchar = txt.slice(-1) # Get last character\n  return lastchar == \" \" #\
    \ True if last character is a space\nend\n</cell>\n<code language=julia-1.5>",
  "    return txt.rsplit(' ').last.endwith?(/[a-z]/i)\nend", "  txt.chomp!\n  if txt[-1].isalpha?\n\
    \    true\n  else\n    false\n  end\nend", "  txt = txt.downcase\n  txt = txt.split(\"\
    \ \").map{|w| w.strip}\n  txt = txt.last\n  txt = txt.split(\"\").all? { |char|\
    \ char.is_a?(String) && ! char.match?(/\\W$/) }\nend", "  txt.slice!(txt.size\
    \ - 1)\n  return false unless txt.match(/^[A-Za-z]$/)\n  false\nend", "  if txt.length\
    \ == 0\n    return false\n  else\n    if txt.chars.last !~ /[A-Za-z]/\n      return\
    \ false\n    else\n      return true\n    end\n  end\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThanks, this is helpful but I am still looking for a method that doesn't\
    \ require me to create a class or define my own methods.\n<|/ c |>\n<| c |>\n\
    I understand. But if you want a more ruby way of doing this I would suggest starting\
    \ with the String class (which I see you have done in your edit). Then you can\
    \ add methods on top of those that do not require you to create a class/file.\n\
    <|/ c |>\n<| a |>\nI figured out a better way that doesn't require me to create\
    \ classes or define methods.\n<code>\n  def check_if_last_char_is_a_letter(txt)\n\
    \    txt.chars.last !~ /[A-Za-z]/\n  end\n</code>\n<|/ a tags=ruby dscore=0 |>\n\
    <| a tags=ruby |>\nI would write it as follows:\n<code>", "  result = txt.slice!\n\
    \  result.slice! result[-1,1]\n  return result !~ /\\w$/\nend\n</cell>\n<text>\n\
    2.2 Implement is_last_char_alphabetic\nNow implement a function that takes a word\
    \ and returns True if the last character is alphabetical and False otherwise.",
  "    word.empty?\n    txt.empty?\n    word.include? txt[-1]\nend", "  # Remove trailing\
    \ whitespaces.\n  txt.chomp!\n  # Return True if last character is alphabetical\
    \ and not part of a word.\n  return txt[-1] =~ /[[:alpha:]]/ && txt.split(\" \"\
    ).all? { |w| w !~ /[[:alpha:]]/ }\nend", "  txt.empty?\nend", "  return txt.split(\"\
    \ \").last.include?(txt.last)\nend", "  return !txt.empty? && txt.chars.last.is_a?(Fixnum)\
    \ && txt.chars.last.between?(48, 57) && !txt.match(/\\w/).nil?\nend", "    return\
    \ true if txt[-1].isalpha() && !txt.split.include?(txt[-1])\nend\n</cell>\n<code\
    \ language=julia-1.5>", "  txt.chars.last.include?(@word) && !txt.chars.last.split.any?\
    \ { |c| @word[-1..-1].include?(c) }\nend\n</code>\n<|/ a |>\n<| a tags=ruby,string,regex\
    \ |>\nOne way is to use Array#each_char. As soon as you find a word boundary (i.e.\
    \ [\\b]), you break the loop and return true.\n<code>", "  return txt[-1] =~ /^[[:alpha:]]+$/\
    \ && txt.to_s.size != txt.length\nend", "  lastchar = txt[txt.length-1]\n  word_array\
    \ = txt.split(' ')\n  if lastchar == ' ' and word_array.size < 2\n    true\n \
    \ elsif lastchar != ' ' and word_array.size > 2\n    false\n  else\n    true\n\
    \  end\nend\n</cell>\n<cell>", "  # initialize a counter for counting white spaces\n\
    \  cnt = 0\n  # initialize a counter for counting letters\n  cnt2 = 0\n  # initialize\
    \ a flag to check if the last character is a letter\n  flag = false\n  # initialize\
    \ an empty variable to hold the last character\n  last_char = \"\"", "  return\
    \ txt.chars.last.match /\\p{L}$/\nend", "  txt.split(\" \").each do |word|\n \
    \   if word.end_with?(\" \")\n      word.pop\n    else\n      return false\n \
    \   end\n  end\n  return true\nend", "  txt.strip!\n  txt.each do |char|\n   \
    \ return false if (char==\" \")\n    return false if (char.ord == 32) && (char.upcase\
    \ == char.downcase)\n  end\n  return true\nend", "  case txt\n    when /[^a-z]/\n\
    \      false\n    when /[a-z]/\n      true\n    else\n      false\n  end\nend",
  "  txt = txt.downcase\n  return !!txt && !!txt && !!txt && txt[-1] != ' ' && !txt.match(/\\\
    W$/)\nend\n</cell>\n<code language=julia-0.6>", "    txt = txt.split(\" \").join().replace(\"\
    \ \", \"\")\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    return txt[-1]\
    \ in alphabet and not check_if_word_starts_with_letter(txt)\nend\n</cell>\n<cell>",
  "  txt.split.each do |word|\n    word.split(' ').last.downcase.chars.each do |char|\n\
    \      return false if (char =~ /^[A-Za-z]$/)\n    end\n  end\n  true\nend", " \
    \ txt.downcase!\n  return !txt.end_with?(/[[:alpha:]]/)\nend", "  check_last_char\
    \ = txt[-1] == \" \" and txt.split(\" \").last == txt[-1]\n  return check_last_char\n\
    end\n</cell>\n<code language=julia-1.5>", "  return txt[-1] == ?\nend\n</cell>\n\
    <code language=julia-1.0>", "  txt = txt.split(\" \").last\n  txt_length = txt.length\n\
    \  txt.each_char do |char|\n    return false if char != txt[txt_length-1] && char\
    \ != txt[txt_length-2]\n  end\n  return true\nend\nputs check_if_last_char_is_a_letter(\"\
    apple pie\")", "  if txt && txt[txt.length - 1] && txt[txt.length - 1] == \" \"\
    \ then\n    txt = txt.slice(0, txt.length - 1)\n  end\n  return txt.match(\"[a-zA-Z]\"\
    )\nend", "    txt = txt.downcase\n    if txt.length <= 0\n        return false\n\
    \    last_char = txt[txt.length - 1]\n    return last_char =~ /[a-zA-Z]/\nend",
  "    return txt[-1].isalpha()\nend", "    return txt[-1].isalpha() and not txt.split()[-1][-1].isalpha()\n\
    end", "  return true if txt[-1,1]==\" \" &&\n  txt.slice!(-1..-1) != \" \" &&\n\
    \  txt.slice!(-1..-1) != \"\\n\"\nend\n</cell>\n<text>\nNow let's use the function\
    \ to write a test for the function.", "  return txt =~ /[[:alpha:]]$/\nend", " \
    \ return txt && txt[txt.length-1] =~ /[a-z]/i && !txt.include?(\" \")\nend", " \
    \ if txt[-1..-1].split #if the string is empty\n  then return false #return false,\
    \ because an empty string is just an empty string\n  else return true if txt.last.match?(/[a-z]/)\
    \ #if the last character\n  else return false #return true, because there is no\
    \ last letter in the string\nend", "  return txt[-1] =~ /^[a-zA-Z]$/\nend\n</cell>\n\
    <code language=julia-1.6>", "  return txt.length % 3 == 0 and txt.match(/(^\\\
    w)|(\\w$)/).nil?\nend", "  word_check = txt.split(\" \").last\n  if word_check.last\
    \ == word_check.first\n    false\n  else\n    true\n  end\nend", "  txt.split(\"\
    \ \").last.include?(txt.last)\nend", "  return txt[-1].isalpha() and txt[-1] !~\
    \ /[^\\w]/ rescue false\nend\n</code>\nAnd then to check for valid input...\n\
    <code>", "  return txt.slice!(-1)[0] =~ /\\A[A-Za-z]/\nend", "  if txt.length\
    \ > 1\n    lastChar = txt.length - 1\n    lastCharChar = txt.chars[lastChar]\n\
    \    if lastCharChar.kind_of? String and lastCharChar.chars.last =~ /^[A-Z]$/\n\
    \      return false\n    end\n  end\n  true\nend", "  str = txt.downcase\n  if\
    \ str.length == 0\n    false\n  elsif str.length == 1\n    str == str[str.length-1]\n\
    \  else\n    !(/\\w$/).match(str[str.length-1])\n  end\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\nIn terms of efficiency, your solution is probably the fastest.\
    \  The problem is that you're creating a new Regexp for each character.  That\
    \ means you'll be creating a new object per character.  Depending on the length\
    \ of your input string, this can get quite expensive.\nHowever, your solution\
    \ is also extremely inefficient.  You're creating a new Regexp for each character\
    \ that you're checking.  That means you're repeatedly creating a new Regexp object.\
    \  Also, you're creating a new Regexp object for each character that you're checking.\
    \  That means you're creating a new Regexp object for each character in your input\
    \ string.  That means you're creating a new Regexp object for each character in\
    \ your input string.  That means you're creating a new Regexp object for each\
    \ character in your input string.\nAll of these create extra garbage for the garbage\
    \ collector to clean up.  The extra garbage is going to get cleaned up pretty\
    \ quickly once your program has finished running.  That's why the garbage collector\
    \ runs so fast.\nYou're also doing things that are very inefficient in terms of\
    \ memory allocation.  You're creating an Array for every single character you\
    \ check.  That means you're creating a new Array object for each character.  That\
    \ means you're creating a new Array object for each character in your input string.\
    \  That means you're creating a new Array object for each character in your input\
    \ string.  That means you're creating a new Array object for each character in\
    \ your input string.\nAll of these create extra garbage for the garbage collector\
    \ to clean up.  The extra garbage is going to get cleaned up pretty quickly once\
    \ your program has finished running.  That's why the garbage collector runs so\
    \ fast.\nAll of these create extra garbage for the garbage collector to clean\
    \ up.  The extra garbage is going to get cleaned up pretty quickly once your program\
    \ has finished running.  That's why the garbage collector runs so fast.\nThat\
    \ means you're creating a new Array object for each character in your input string.\
    \  That means you're creating a new Array object for each character in your input\
    \ string.  That means you're creating a new Array object for each character in\
    \ your input string.  That means you're creating a new Array object for each character\
    \ in your input string.\nThat's why your program is so slow.\nTo fix it, you should\
    \ create one single Regexp object with a global scope.  That means you only create\
    \ one Regexp object for your whole program, and you only create one Regexp object\
    \ for each character ", "  letters = txt.split(\" \")\n  last_char = letters.last.first\n\
    \  if last_char && !last_char.match?(/[a-zA-Z]/)\n    return false\n  end\nend",
  "  txt.empty?\nend", "\ttxt.gsub(/([a-z])/, '')\n\tword.gsub!(/([a-z])/, '')\n\t\
    return true unless txt != word.blank?\n\treturn false\nend", "  if txt[-1] ==\
    \ \" \" then return false end\n  txt.each_byte do |c|\n    if c == ' ' then\n\
    \      return false\n    else\n      if c.upcase >= 'A' then\n        return false\n\
    \      end\n    end\n  end\n  return true\nend", "  # Write your code here\n \
    \ txt = txt.downcase\n  txt.each_char do |char|\n    if char == ' '\n      return\
    \ false\n    end\n    if char.upcase != char\n      return false\n    end\n  end\n\
    \  true\nend\nprint(check_if_last_char_is_a_letter(\"apple pi e \")) # => true\n\
    print(check_if_last_char_is_a_letter(\"apple pie\")) # => false\nprint(check_if_last_char_is_a_letter(\"\
    \")) # => false\nprint(check_if_last_char_is_a_letter(\" \")) # => false\nprint(check_if_last_char_is_a_letter(\"\
    apple pie \")) # => false\nprint(check_if_last_char_is_a_letter(\"apple pi\"))\
    \ # => false\nprint(check_if_last_char_is_a_letter(\"apple \")) # => false\nprint(check_if_last_char_is_a_letter(\"\
    \ \"))  # => false", "    return txt[-1].match?(/[a-zA-Z]/)\nend", "    txt.strip!\n\
    \    txt.downcase!\n    return txt.length.zero? or txt.slice(-1)[0].upcase !=\
    \ txt.slice(-1)[0].downcase\nend", "  return txt.empty? or txt.last.upcase !~\
    \ /\\w$/\nend", "    if txt and txt[-1] == \" \" or txt[-1] == \" \\t\"\n    \
    \    return False\n    ends_with_letter = (txt.end_with?(\" \") or\n         \
    \              txt.end_with?(\"\\t\"))\n    return ends_with_letter\nend", " \
    \ txt.split\n  txt.count\n  txt.chars.last\n  txt.chars.last.match /[a-zA-Z]/\n\
    end\n</code>\n<code>", "  txt.upcase!\n  return txt[-1] =~ /[A-Z]/ && txt.downcase\
    \ !~ /[^A-Z]/ \nend\n</code>\nNow, let's use this function on each string and\
    \ see if any of them return false:\n<code>\nstrings = [\"apple pie\", \"apple\
    \ pi e\", \"apple pi e \", \"apple\", \"applepie\"]", "    words = txt.split('\
    \ ')\n    for word in words\n        if word[-1].isalpha() == true\n         \
    \   return true\n    end\n    return false\nend\n</code>\n<|/ q tags=ruby |>\n\
    <| c |>\nWhat is a word and what is not? Your question is not clear enough. Do\
    \ you just want to check if the last character of a string is alphabet or do you\
    \ want to find out if the last character is part of a word?\n<|/ c |>\n<| c |>\n\
    Sorry for not being clear. I'll edit my question to be clearer. Ideally, I would\
    \ like to be able to call a function like this:\nif check_if_last_char_is_a_letter(txt)\n\
    and be able to tell if something is an alphabetical character\n<|/ c |>\n<| c\
    \ |>\nWhat about this word: \"abc123xyz\" ?\n<|/ c |>\n<| c |>\nIt does not matter\
    \ what kind of letters you put in the word (upper, lower, numbers, or symbols)\n\
    <|/ c |>\n<| c |>\nSo `checkif_last_char_is_a_letter(\"A\") == \"a\"`?\n<|/ c\
    \ |>\n<| a |>\nYou can use String#chars at the end.\n<code>\nif str[-1] == str[-2].downcase\n\
    \  # do stuff\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nThanks, this\
    \ seems to work\n<|/ c |>\n<| c |>\nYou are welcome. Consider accepting the answer\
    \ if it solved your problem\n<|/ c |>\n<| c |>\n`str[-1]` is the same as `str.last`.\
    \ You can just write `str[-1]` instead.\n<|/ c |>\n<| c |>\nThanks for the tip.\
    \ I didn't know that\n<|/ c |>\n<| c |>\nWhat if you need to check first letter\
    \ of each word ? In this case it doesn't work\n<|/ c |>\n<| a dscore=0 |>\nUse\
    \ a regex:\n<code>", "    if txt.size > 0 and txt[-1] != ' ' and txt[-1] != '\\\
    n'\n        return true\n    else\n        return false\n    end\nend\n</cell>\n\
    <code language=julia-1.3>", "  return txt[-1].match(\"[a-zA-Z]\")\nend", "   \
    \ if txt[-1].isalnum() and txt != \" \":\n        return True\n    else:\n   \
    \     return False", "  return false unless txt && txt.length && txt[-1] && txt[-1]\
    \ == \" \"\nend\n</cell>\n<cell>\ncheck_if_last_char_is_a_letter(\"apple pi e\
    \ \")\n</cell>\n<cell>\ncheck_if_last_char_is_a_letter(\"\")\n</cell>\n<text>\n\
    1.10 Creating the Hash Object", "  # Your code here\n  return false\nend\n</cell>\n\
    <cell>", "  txt.downcase!\n  txt.slice!(0...txt.length-1)\n  txt.include?(\" \"\
    )\nend", "  return !txt.empty? && txt[-1].match?(/[a-zA-Z]+/) && !txt.end_with?(\"\
    \ \")\nend", "  txt.split(\" \").each do |word|\n    if word[-1] != word[0]\n\
    \      return false\n    end\n  end\n  return true\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a dscore=0 |>\nHere's another solution:\n<code>", "  return !!(txt.length\
    \ && txt[txt.length-1].match('^[a-zA-Z]'))\nend", "  case txt.downcase[txt.size-1]\
    \ in\n    'a'..'z') \u279E false\n    'A'..'Z') \u279E false\n    '0'..'9') \u279E\
    \ false\n    else \u279E true\n  end\nend\n</code>\nThen you can just call it\
    \ like this: \n<code>\ncheck_if_last_char_is_a_letter(txt)\n</code>\nAnd if you\
    \ want it to be more dynamic, you can pass a parameter like this:\n<code>\ncheck_if_last_char_is_a_letter(txt,\
    \ word_character)\n</code>\nand then use it like this:\n<code>\ncheck_if_last_char_is_a_letter(txt,\
    \ \" \")\n</code>\nOr, you can pass it multiple characters like this:\n<code>\n\
    check_if_last_char_is_a_letter(txt, %w[a e i o u])\n</code>\nIf you want to be\
    \ able to pass an empty string, you can also pass an empty array:\n<code>\ncheck_if_last_char_is_a_letter(txt,\
    \ [])\n</code>\n<|/ a |>\n<| a tags=ruby |>\n<code>\n def last_word_only(str)\n\
    \   str.scan(/[^ ]*/).last.strip\n end", "  \n  if txt == \"\"\n    return false\n\
    \  \n  return txt.end_with?(\" \")\n  \nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nHi, please consider adding more information about what you're doing and\
    \ why this helps solving OP's problem so he can learn something from it. Thanks!\n\
    <|/ c |>\n<| a tags=ruby |>\nYou can use the String#[] method.\n<code>\n\"apple\
    \ pi e \"[/\\w/] #=> true\n\"apple pie\"[/\\w/]        #=> true\n\"apple pie \"\
    [/\\w/]      #=> true\n\"apple pie\"[/\\w/]       #=> false\n\"apple pie e \"\
    [/\\w/]   #=> false\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\nYou can use\
    \ regex\n<code>", "  txt.delete(0..-1)\n  return txt[txt.length-1].downcase =~\
    \ /[a-z]/\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nHere's a solution\
    \ that doesn't require regular expressions, and doesn't use Ruby's String methods\
    \ such as [] and delete.  It works because Ruby supports \"negative lookaheads\"\
    \ (i.e. regular expressions that exclude a piece of input).\n<code>", "  last_char.call(\
    \ txt )\nend", "  txt =~ /^[a-z]+[a-z]*$/ && txt !~ /[a-z][a-z ]+$/\nend\n</code>\n\
    <|/ a tags=regex,ruby dscore=0 |>\n<| a dscore=0 tags=regex,ruby |>\nIf you are\
    \ not sure about the character class syntax you are using, you might want to consider\
    \ using https://regexr.com/ to check out your regex in real time. \nFor example, ",
  "  words = txt.split(' ')\n  last_char = words[words.length-1]\n  return last_char.downcase\
    \ !~ /^[A-Za-z]/\nend", "  return txt[-1..-1].match /[a-z]/\nend", "  txt.split(\"\
    \ \").each do |word|\n    return false if word.empty?\n    return false if word.length\
    \ < 1\n    return false if word.length > 1 \n    return true if word[-1].include?('?')\n\
    \  end\n  true\nend", "    txt.split(\" \").each do |w|\n      w.last.upcase ==\
    \ w.last.upcase\n    end\nend", "    last = txt.rsplit(\" \")[-1][-1]\n    return\
    \ not any(x in last for x in string.ascii_letters)\nend", "  txt !=\"\" && txt.chars.last\
    \ !~ /\\w/\nend", "  txt.downcase!\n  txt.match?(/[^ ]+$/)\nend\n</code>\n(Note\
    \ in Ruby 2.2 you can use String#starts_with?)\n<code>", "  if txt[-1].isalpha()\
    \ == true and txt.count(' ') == 0 and txt.size > 0\n    puts \"Last character\
    \ of #{txt} is alphabetical and is not a part of word.\n          We will assume\
    \ that #{txt} is a valid word.\n          Please review the definitions of valid\
    \ words.\"\n  else\n    puts \"Last character of #{txt} is NOT alphabetical.\"\
    \n    puts \"Please review the definitions of valid words.\"\n  end\nend", " \
    \ return txt[-1].isalpha() and txt[-1] != ' '\nend", "    txt.strip!\n    return\
    \ txt[-1] =~ /[a-z]/i\nend", "\tword = txt.split(\" \")\n\tif (word[-1][-1]!=\"\
    a\") and (word[-1][-1]!=\"e\") and (word[-1][-1]!=\"i\") and (word[-1][-1]!=\"\
    o\") and (word[-1][-1]!=\"u\"):\n\t\treturn True\n\telse:\n\t\treturn False\n\
    </cell>\n<text>\n3. Write a function that converts decimal numbers into binary.",
  "  txt = txt.downcase\n  txt = txt.split(\" \").last\n  txt = txt.chars.last\n \
    \ if txt.empty?\n    false\n  else\n    true\n  end\nend", "  txt && txt.match(/[\\\
    w ]$/) && txt.split(\" \").last =~ /[^A-Za-z]$/\nend\nprint check_if_last_char_is_a_letter(ARGV[0])\
    \ ? 'ok' : 'fail'\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>\n  def\
    \ isALastChar(str1, str2)\n     str1.chomp.length != str2.chomp.length && str1.split(\"\
    \ \").last.include?(str2.split(\" \").last) \n  end\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding how and/or why it solves the problem would improve the answer's long-term\
    \ value.\n<|/ c |>\n<| c |>\nWhile this code may solve the question, [including\
    \ an explanation](https://meta.stackexchange.com/q/114762) of how and why this\
    \ solves the problem would really help to improve the quality of your post, and\
    \ probably result in more up-votes. Remember that you are answering the question\
    \ for readers in the future, not just the person asking now. Please [edit] your\
    \ answer to add explanations and give an indication of what limitations and assumptions\
    \ apply.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  return txt[-1] =~ /\\w/\nend",
  "    \n    if txt.size == 0\n        return false\n    end\n    \n    txt = txt.capitalize\n\
    \    \n    word = \"[a-z ]\"\n    \n    # Find last character in string\n    last_char\
    \ = txt.last\n    \n    # Check if last character is a letter\n    if last_char.to_i\
    \ >= 0 and last_char.to_i < 127 # ascii code\n        if last_char.to_i > 96 and\
    \ last_char.to_i < 123 # ascii code - a-z\n            if last_char.to_i > 122\
    \ and last_char.to_i < 131 # ascii code - A-Z\n                if last_char.to_i\
    \ > 130 and last_char.to_i < 132 # ascii code - A-Z\n                    true\n\
    \                else\n                    false\n                end\n      \
    \      else\n                false\n            end\n        else\n          \
    \  false\n        end\n    else\n        false\n    end\nend", "  return txt[txt.length-1].upcase\
    \ !~ /\\w$/\nend\n</cell>\n<code language=julia-1.0>", "  if txt != \"\"\n   \
    \ return txt[-1] =~ /\\w/ && txt.size != 4\n  else\n    return false\n  end\n\
    end", "  # Split the string into an array of words.\n  words = txt.split(' ')\n\
    \  # Iterate through each word and check if the last char is a letter,\n  # and\
    \ if not, return False.\n  words.each do |word|\n    word = word.strip\n    return\
    \ false unless word.length > 0\n    return false unless word[word.length-1] =~\
    \ /[a-zA-Z]/\n  end\n  # If no word is left that doesn't have a last letter as\
    \ an\n  # alphabetical character, return False.\n  return false\nend\n</cell>\n\
    <cell>", "  txt.each_char{ |c|\n    return true if c.upcase.include?(\"A\") &&\
    \ c.downcase.include?(\"Z\")\n    return true if c.upcase.include?(\"A\") && c.downcase.include?(\"\
    Z\") || c.upcase.include?(\"Z\") && c.downcase.include?(\"A\")\n    return true\
    \ if c.upcase.include?(\"A\") && c.downcase.include?(\"Z\") || c.downcase.include?(\"\
    Z\") && c.upcase.include?(\"A\")\n    return true if !c.upcase.include?(\"A\"\
    ) && !c.downcase.include?(\"Z\")\n    return true if !c.upcase.include?(\"A\"\
    ) && !c.downcase.include?(\"Z\") && !c.upcase.include?(\"Z\")\n    return true\
    \ if c.upcase.include?(\"A\") && !c.downcase.include?(\"Z\") && !c.upcase.include?(\"\
    Z\")\n  }\n  return false\nend", "  last_char = txt.last \n  return last_char\
    \ !~ /[a-z ]/i and last_char != \"\"\nend\n</cell>\n<code language=julia-1.4>",
  "  # Your code here!\n  return txt[-1].isalpha()\nend", "  if txt !=\"\"\n  then\
    \ return ((txt.length -1) == (txt.chars[txt.length-1]).upcase)\n  else return\
    \ false\n  end if\nend", "    txt = txt.downcase\n    if txt.ends_with?(\" \"\
    )\n        txt.chop!\n    end\n    txt.scan(/./).each do |char|\n        return\
    \ true if char.match(/^[a-z]/)\n    end\n    return false\nend\nputs check_if_last_char_is_a_letter(ARGV.first)\
    \ if ARGV.size > 0\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4,regex\
    \ dscore=3 |>\n<| c |>\nThis is exactly the type of code I was looking for :)\
    \ Thanks so much!\n<|/ c |>\n<| c |>\nJust out of curiosity, how would you write\
    \ it if I want to match any letter, not just [a-z] ?\n<|/ c |>\n<| c |>\n`/[a-z]/`\
    \ matches any character between `a` and `z` (case insensitive) `a-z` matches a\
    \ lower case letter.\n<|/ c |>\n<| a dscore=2 |>\nYour requirement is very specific,\
    \ so the solution is simple: just use String.gsub! on all your strings:\n<code>\n\
    \"apple pi e\".gsub!(/[a-zA-Z]/, '')\n  #=> \"apple pie\"\n</code>\nNote that\
    \ String#gsub! returns nil if no substitutions were made, while String#gsub returns\
    \ nil if no match could be found.\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4,regex\
    \ |>\n<| c |>\nThis works well. Thank you very much :)\n<|/ c |>\n<| c |>\n: Just\
    \ so you know, I'm not a fan of `gsub!`, but it is the correct solution to your\
    \ problem.\n<|/ c |>\n<| c |>\nAwesome, thanks for the tip :)\n<|/ c |>\n<| a\
    \ dscore=1 tags=ruby,ruby-on-rails,ruby-on-rails-4,regex |>\nI think this might\
    \ be a bit faster (it depends on the input though):\n<code>\nstring = 'apple pi\
    \ e'", "  return txt[txt.length-1].match(/[a-zA-Z]$/)\nend", "  txt = txt.chomp\n\
    \  return txt.chars.last.downcase == txt[-1] && txt.chars.size > 1\nend", "  \
    \  words = txt.split(\" \");\n    word = words[words.length-1]\n    word = word.split(\"\
    \");\n    word[word.length-1].downcase!\n    \n    word.include?(\"a\")\n    word.include?(\"\
    e\")\n    word.include?(\"i\")\n    word.include?(\"o\")\n    word.include?(\"\
    u\")\nend\ncheck_if_last_char_is_a_letter(txt)\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 |>\n<code>", "  txt.empty? or txt.scan(/[^a-z]/).empty?\nend", " \
    \ re = /^\\w$/\n  txt = txt.downcase\n  return re.test(txt.slice!(-1)) && ! txt.match(re)\n\
    end\n</cell>\n<code language=julia-1.5>", "  letters = txt.split(\" \")\n  return\
    \ letters[-1][-1].isalpha()\nend", "  txt.split.last and txt.split.last.downcase.include?(txt.split.last.downcase.split(\"\
    \ \").last.downcase)\nend", "    return txt[-1].isalpha()\nend", "  txt.split(\"\
    \ \").last.empty?\nend", "    return txt[-1] != ' '\nend", "  txt = txt.downcase\n\
    \  txt = txt.delete(' ').delete('.')\n  return txt.last.match('^[a-z]+$')\nend",
  "  return txt.rpartition(' ').last.match(/\\w/) == nil ? false : true\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nI like this answer more than the other, but I'm going\
    \ to go with Andrew because it's shorter, and I'm a fan of using regular expressions\
    \ when they make sense.\n<|/ c |>\n<| c |>\nYou're right. `String#rpartition`\
    \ is more flexible. It also works for other delimiters.\n<|/ c |>\n<| c |>\nThanks\
    \ for providing `String#rpartition`!\n<|/ c |>\n<| a dscore=3 tags=ruby |>\n<code>",
  "  txt.each_char.with_object(\"\") do |c, a|\n    a + c.is_a?(String) ? c : a +\
    \ c.upcase\n  end.downcase.include?(\" \")\nend\n</code>\nThe method above checks\
    \ if last character in a string is a letter and not a word. Then it converts the\
    \ string to all lower case and checks if the last character is a space or not.\
    \ Notice that this is not the best way to do this, it's just a demonstration.\
    \ If you need help with your homework then I'll help you, but I will not give\
    \ you an answer. If you need help with this then I can guide you through it but\
    \ I won't do it for you. \nI hope this helps.\n<|/ a tags=string,ruby dscore=0\
    \ |>\n<| c |>\nHi thanks for your solution. I tried your code and for some reason,\
    \ it is not working. When I test it with: \"Hello World! hello, world!\" it returns\
    \ false.\n<|/ c |>\n<| c |>\nI tested it with your given example and it returned\
    \ false for me. I tested it with the following string: \"Hello World! hello, world!\"\
    \ and the method returned false because the string didn't end with a letter.\n\
    <|/ c |>\n<| a tags=string,ruby |>\nI would do this:\n<code>\nstr = \"Hello World!\
    \ hello, world!\"", "  return !txt.empty? && txt.last.match(/\\s/) ? false : txt.last.match(/\\\
    A\\w/) ? true : false\nend", "    txt.scan(/\\w$/)\n    txt.empty?\nend", "  txt.split(\"\
    \ \").last.chars.each do |char|\n    puts char if char.upcase == char\n  end\n\
    end", "  result = false\n  if txt.empty?\n    return false\n  else\n    txt.split.each\
    \ do |word|\n      if word.last.downcase >= 'a' && word.last.downcase <= 'z'\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "  words=txt.split(\"\
    \ \") \n  if words.last !~ /\\w/ then\n    return false\n  else\n    return true\n\
    \  end\nend", "  return txt[-1].match(/\\p{L}$/) == nil\nend\n</cell>\n<cell>\n\
    txt = \"apple pie e \"\ncheck_if_last_char_is_a_letter(txt)\n</cell>\n<cell>",
  "  txt = txt.strip\n  if txt == \"\"\n    false\n  else\n    txt[-1].isalpha\n \
    \ end\nend\n</code>\nAnd then apply it on a given text as follows:\n<code>", " \
    \ txt == txt[txt.length -1] && !txt[txt.length -1 ]=~/\\w/\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\n`txt[txt.length -1 ]=~/\\w/` won't work as expected.\
    \ Since `\\w` matches `_` as well it fails. You might want to use `!txt[txt.length\
    \ -1 ]=~/[^a-zA-Z]/`. And I guess a better solution is `!txt[txt.length -1 ]=~/[a-z]/i`,\
    \ so that it matches uppercase letters as well.\n<|/ c |>\n<| c |>\nI thought\
    \ about this too, but I wasn't sure if it was good practice to allow `-`s in a\
    \ word.  But I guess there may be a reason why `\\w` doesn't catch it.  I'll add\
    \ that.\n<|/ c |>\n<| c |>\nI still don't think this is a good solution to OP's\
    \ question, but +1 because this is a valid one.\n<|/ c |>\n<| a dscore=2 |>\n\
    It isn't that difficult if you know Ruby well enough. Here's an example (you can\
    \ copy/paste it and run it yourself):\n<code>", "  txt.split(\" \").last.chars.any?\
    \ do |c|\n    # A character that doesn't belong to a word\n    !c.match?(/\\W|^$|\\\
    w|\\W$/)\n  end\nend", "  txt = txt.downcase\n  if txt.length == 0\n    true\n\
    \  else\n    return txt[txt.length - 1].upcase =~ /\\W/ and true\n  end\nend",
  "  !txt.empty? && txt[-1] =~ /\\w/ && txt.split.uniq.size == 1\nend", "  return\
    \ txt[-1] =~ /\\w/\nend\n  ", "  return txt != '' && txt[-1].isalpha() && !txt.split(\"\
    \ \").last.match(/[A-Za-z]$/)\nend", "  return txt.chars.last.match?(/\\w$/)\n\
    end\n</cell>\n<code language=julia-1.5>", "  txt.each do |c|\n    if c.is_a? String\
    \ and (c[-1].upcase == c or c[-1] == \" \")\n      false\n    elsif c.is_a? String\
    \ and (c[-1] == c)\n      false\n    else\n      true\n    end\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
