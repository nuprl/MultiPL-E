name: HumanEval_133_sum_squares
language: rb
prompt: "# You are given a list of numbers.\n# You need to return the sum of squared\
  \ numbers in the given list,\n# round each element in the list to the upper int(Ceiling)\
  \ first.\n# Examples:\n# For lst = [1,2,3] the output should be 14\n# For lst =\
  \ [1,4,9] the output should be 98\n# For lst = [1,3,5,7] the output should be 84\n\
  # For lst = [1.4,4.2,0] the output should be 29\n# For lst = [-2.4,1,1] the output\
  \ should be 6\ndef sum_squares(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_squares\n\
  \    candidate = method(:sum_squares)\n    assert_equal(14, candidate.call([1.0,\
  \ 2.0, 3.0]))\n    assert_equal(14, candidate.call([1.0, 2.0, 3.0]))\n    assert_equal(84,\
  \ candidate.call([1.0, 3.0, 5.0, 7.0]))\n    assert_equal(29, candidate.call([1.4,\
  \ 4.2, 0.0]))\n    assert_equal(6, candidate.call([-2.4, 1.0, 1.0]))\n    assert_equal(10230,\
  \ candidate.call([100.0, 1.0, 15.0, 2.0]))\n    assert_equal(200000000, candidate.call([10000.0,\
  \ 10000.0]))\n    assert_equal(75, candidate.call([-1.4, 4.6, 6.3]))\n    assert_equal(1086,\
  \ candidate.call([-1.4, 17.9, 18.9, 19.9]))\n    assert_equal(0, candidate.call([0.0]))\n\
  \    assert_equal(1, candidate.call([-1.0]))\n    assert_equal(2, candidate.call([-1.0,\
  \ 1.0, 0.0]))\n  end\nend\n"
completions: ["    sum = 0\n    sum = 0\n    i = 0\n    while i < lst.size\n     \
    \   sum += lst[i]*lst[i]\n        i += 1 # increment i\n    return sum\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby |>\nHere is my answer, which follows your rules.\n\
    <code>", "  sum = 0\n  lst.map! do |i| \n    i = round(i)\n    sum += i * i \n\
    \  end\n  sum\nend\n</code>\n<|/ a |>\n<| c |>\nDon't use `map!` since it modifies\
    \ the original array and returns an `Array` object. Use `map` instead. Also, it's\
    \ nice to `sum` all values before `sum` gets returned. Otherwise, you'd get the\
    \ wrong sum.\n<|/ c |>\n<| c |>\nIt doesn't work in my case, as I use `sum_squares`\
    \ with a `hash` object containing numbers and I still get the `NoMethodError:\
    \ undefined method `each' for nil:NilClass` error.\n<|/ c |>\n<| a dscore=0 |>\n\
    I couldn't figure out the problem with my implementation, but I did figure out\
    \ a working implementation:\n<code>", "\tsum = 0\n\tfor i in lst\n\t\tsum = sum\
    \ + i ** 2\n\treturn sum", "  lst.map!{ |e| e.ceil }\n  lst.inject(0){ |sum, e|\
    \ sum + e * e }\nend\n</code>\n<|/ a dscore=5 |>\n<| a tags=ruby dscore=4 |>\n\
    <code>", "  sum = 0\n  lst.each_with_index { |n,i| sum += n.round(int(Math.ceil(n)))\
    \ }\n  return sum\nend", "  # Your code here\n  # lst = lst.map(&:round)\n  sum\
    \ = 0\n  lst.each do |x|\n    sum += x*x\n  end\n  sum\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 tags=ruby |>\n<code>", "  sum = 0\n  for i in lst.sort{|a,b|\
    \ b.ceil}\n    sum += i.abs**2 if i.is_a?(Fixnum)\n  end\n  sum\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\n+1 The best way IMO. Just a suggestion - instead\
    \ of `.sort{|a,b| b.ceil}` you can also use `.sort_by { |e| e.ceil } ` :)\n<|/\
    \ c |>\n<| c |>\nThanks Stefan. This is a good solution. Just to note that this\
    \ does not sort the array.\n<|/ c |>\n<| a tags=ruby dscore=1 |>\n<code>", " \
    \ lst.each do |e|\n    e = e.ceil\n    e = e.to_i\n    e *= e\n  end\n  lst.inject(0){|sum,\
    \ value| sum + value }\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>",
  "  total = 0\n  lst.each do |n|\n    total += n if n.to_i < 0\n    total += n.ceil\
    \ if n.to_i >= 0\n    total += n.round if n.to_i >= 0\n  end\n  total\nend", " \
    \ sum = 0\n  lst.each do |e|\n    sum = sum + e**2 \n  end\n  sum\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis is not very efficient, try `sum_squares([-4,\
    \ 3, 0])` and you will get `20.0`\n<|/ c |>\n<| c |>\nThanks for catching that!\
    \ I updated my answer to fix the problem.\n<|/ c |>\n<| a dscore=0 |>\nYou can\
    \ use the following method. It returns an array of all integer powers of the base\
    \ given by the given integer. It uses memoization to avoid recalculating the same\
    \ values.\n<code>", "  lst.map{|x| x.round}\n  lst.map{|x| x*x}.reduce(:+)\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| a dscore=3 tags=ruby |>\nHere is another solution\
    \ using a map method:\n<code>", "  sum = 0\n  lst.each do |x|\n    sum += x*x\n\
    \  end\n  sum\nend", "  result = 0.0\n  lst.each do |number|\n    result += (number*number).ceil\n\
    \  end\n  return result\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nHere\
    \ is a Ruby way to compute the sum of squares of numbers in a list rounded to\
    \ nearest integer:\n<code>", "    sum_sq = 0\n    for i in lst\n        sum_sq\
    \ += i*i\n    return round(sum_sq,2)\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\n\
    <code>", "  return lst.map {|x| Math.ceil(x)}.inject(:+) * Math.sqrt(lst.size)\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`Math.ceil(3.1) #=> 4`. You\
    \ probably mean `Math.ceil(x)`.\n<|/ c |>\n<| a |>\nI know I'm late to the party,\
    \ but I wanted to share a slight variation on the above answers that is more concise\
    \ and avoids having to calculate Math.sqrt(lst.size). I found this more readable\
    \ as well:\n<code>", "  sum = 0\n  lst.each{|x|sum += Math.sqrt(x)}\n  return\
    \ sum\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI think this doesn't work as\
    \ it should. Consider your example for `lst = [1,4,9]` - It should become `Math.sqrt(1.4)`\
    \ and `Math.sqrt(4.2)` but it actually makes `Math.sqrt(9)`\n<|/ c |>\n<| c |>\n\
    It would seem you're right - I forgot to round the values before using them.\n\
    <|/ c |>\n<| c |>\nI suggest you edit your answer to correct that - `Math.sqrt(9)`\
    \ will result in `1.7320508075688772` which is not what the OP wants. I suspect\
    \ they want the rounded version (which is `Math.sqrt(4.2)`) which is why I suggested\
    \ the OP use `Math.round`\n<|/ c |>\n<| c |>\nThank you very much for mentioning\
    \ this. I didn't realize until I checked it out. Your solution works perfectly\n\
    <|/ c |>\n<| a tags=ruby |>\nThe solution by Tin Man is a great one, but can be\
    \ improved a little bit since Ruby 1.9.2 introduced the Enumerable module. So\
    \ the code would become like this:\n<code>", "  return lst.inject(0) {|sum, e|\
    \ sum + Math.sqrt(e) }\nend\n</code>\nThe inject method is a method defined in\
    \ the Enumerable module, it takes a collection (like an array) and performs a\
    \ given action to each element. So, in this case, we're summing squares of each\
    \ element in the list.\n<|/ a |>\n<| c |>\nThis looks great and is way more elegant\
    \ than my solution which used a loop.  I'd like you to explain what `inject` is\
    \ doing.  Thanks!\n<|/ c |>\n<| c |>\nIt should be noted that it is better to\
    \ use the `collect` method rather than `inject` here: `lst.collect { |e| Math.sqrt(e)\
    \ }`.\n<|/ c |>\n<| c |>\n- I've added a bit of explanation.\n<|/ c |>\n<| a tags=ruby,inject,list\
    \ dscore=4 |>\n<code>", "  lst.map(&:round)\n  lst.map(&:ceil)\n  lst.inject(0)\
    \ {|sum, num| sum + num ** 2 }\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails-3,ruby-on-rails\
    \ dscore=1 |>\n<| c |>\n`lst.inject(0) {|sum, num| sum + num ** 2 }`\n<|/ c |>\n\
    <| c |>\nYes, I didn't realize the inject!\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails-3,ruby-on-rails\
    \ |>\nI believe a simple:\n<code>", "  lst.map! { |x| x.round }\n  lst.inject(0)\
    \ { |x, y| x + y }\nend", "  return lst.inject(0) {|sum, e| sum + Math.pow(e *\
    \ e, 2)}\nend", "    sum = 0\n    for num in lst\n        sum += num * num\n \
    \   return sum\n</code>\n<|/ a |>\n<| c |>\n`ceiling` is not defined as a Ruby\
    \ method. I'm guessing you meant `Math.ceil` instead?\n<|/ c |>\n<| c |>\nThanks,\
    \ I've fixed it.\n<|/ c |>\n<| c |>\nFor a list of numbers `[ -2.4, 1, 1 ]` the\
    \ output should be 6, but your code returns `-2`.\n<|/ c |>\n<| c |>\nThe `-`\
    \ at the beginning of the numbers in the list seems to mess things up, but `Math.ceil`\
    \ returns the correct answer. `def sum_squares(lst)\n  return lst.inject(0){|sum,\
    \ num| sum + num*num}\nend`\n<|/ c |>\n<| c |>\nThanks all! I appreciate all the\
    \ help and advice given to me. I will go through all of these and try to understand\
    \ them and hopefully be able to create them myself. Thanks! I really do appreciate\
    \ everyone's help. I'm working on it, and I like learning different ways to do\
    \ things.\n<|/ c |>\n<| a dscore=0 tags=ruby |>\nThe first problem in your code\
    \ is that your code is incorrect in at least 2 ways:\n<code>", "    sum = 0\n\
    \    i = 0\n    j = -1\n    lst = lst.sort\n    while i < lst.size - 1\n     \
    \   i += 1\n        j = i + 1\n        while j > 0\n            if lst[j] == lst[j\
    \ - 1]\n                j -= 1\n            else\n                sum += lst[j]\n\
    \                j -= 1\n                break\n        end\n    end\n    return\
    \ sum\nend", "  return lst.map { |n| Math.ceil(n*1.0).to_s }.inject(:+).to_s\n\
    end", "  # Solution code here\n  result = 0\n  for i in lst\n    result += (Math.ceil(i)\
    \ * Math.ceil(i))\n  return result\nend", "    sum_of_squares = 0.0\n    \n  \
    \  lst = lst.map(&:round).sort.map(&:abs)\n    \n    lst.each_with_index do |number,\
    \ index|\n        sum_of_squares += (number * number)\n    end\n    \n    sum_of_squares.round(2)\n\
    end\n</cell>\n<code language=julia-1.6>\nsum_squares([1,4,9,25])\n</cell>\n<code\
    \ language=julia-1.6>\nsum_squares([1,3,5,7])\n</cell>\n<code language=julia-1.6>\n\
    sum_squares([1.4,4.2,0])\n</cell>\n<code language=julia-1.6>\nsum_squares([-2.4,1,1])\n\
    </cell>\n<code language=julia-1.6>\nsum_squares([-2,-3,-5,-7])\n</cell>\n<code\
    \ language=julia-1.6>", "  if lst.empty?\n    return 0\n  end\n  sum = 0\n  lst.each\
    \ do |num|\n    sum += num * num\n  end\n  sum.to_i\nend", "\ttotal = 0\n\ti =\
    \ 0\n\twhile i < lst.size\n\t\ttotal += lst[i*i] % int(Math.ceil(Math.sqrt(lst[i*i])))\
    \ # Rounding each element to the ceiling of the square root of the element\n\t\
    \ti += 1\n\treturn total\nend", "  # write your code here\n  sum = 0\n  lst.each\
    \ do |e|\n    sum += e.ceil * e.ceil\n  end\n  return sum\nend", "\tsum = 0\n\t\
    n = lst.count\n\tlst.each do |x|\n\t\tsum = (sum + x * x)\n\tend\n\treturn sum\n\
    end", "    # Write your code here\n    return lst * lst\nend\n</cell>\n<cell>",
  "    sum = 0\n    i = 0\n    while i < lst.length\n        sum += lst[i]**2 \n \
    \       i += 1\n    end\n    sum\nend", "  sum=0\n  lst.each do |n|\n    sum=sum+n*n\
    \ # sum of squares formula\n  end\n  sum=Math.ceil(sum) # ceiling each element\
    \ to its ceiling number\n  sum\nend\nputs sum_squares([1.4,4.2,0])\nputs sum_squares([1,3,5,7])\n\
    puts sum_squares([1,2,3])\nputs sum_squares([-2.4,1,1])\nputs sum_squares([-1.4,-3.2,-4.2])\n\
    puts sum_squares([1,2,-3,5])\nputs sum_squares([1,-2,3,5])\nputs sum_squares([1,-3,5,7])\n\
    puts sum_squares([1.4,-4,0])\nputs sum_squares([-1.4,-3.2,-5,-6,0,4])\nputs sum_squares([-1.4,-3.2,-5,-6,0,4,-7,-8,-1,-9,-3,-6,-5,-4,-4,-2,0])",
  "  lst.sort\n  sum = 0\n  lst.each do |x|\n    sum += x ** 2\n  end\n  return sum\n\
    end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nThanks much. I appreciate\
    \ it.\n<|/ c |>\n<| a dscore=0 |>\nTry this\n<code>", "  squares = []\n  lst.each\
    \ do |num|\n    squares.push num * num\n  end\n  squares.sort.reverse.each_with_index\
    \ do |square, idx|\n    if idx < lst.size - 1\n      square = round(square)\n\
    \    end\n    squares.unshift square\n  end\n  squares.first\nend", "    sum_of_squares\
    \ = 0\n    lst = lst.sort_by{|x| x.ceil}\n    lst.each do |num|\n        sum_of_squares\
    \ += num*num\n    end\n    return sum_of_squares\nend", "  return lst.map {|x|\
    \ x*x}.inject {|sum,x| sum + x}\nend\n</code>\n<|/ a tags=ruby,sorting,algorithm,ruby-on-rails,ruby-on-rails-4\
    \ |>\n<| c |>\nThis assumes that `list` is sorted in descending order.\n<|/ c\
    \ |>\n<| c |>\nIt works if you reverse the order of `sum` and `sum + x`.\n<|/\
    \ c |>\n<| a dscore=3 tags=ruby,sorting,algorithm,ruby-on-rails,ruby-on-rails-4\
    \ |>\nYou can get the sum of an enumerable using inject:\n<code>\nlist = [10,\
    \ 20, 30, 40, 50]", "    sum = 0\n    lst.each { |x| sum += Math.round(x**2) }\n\
    \    return sum\nend", "  # Write your code here.\n  result = 0\n  lst.map{|x|\
    \ result = result + Math.round(x * x)}\n  return result\nend", "  sum = 0\n  lst.each\
    \ do |num|\n    sum += num * num\n  end\n  sum.round(@ceil)\nend", "  sum = 0\n\
    \  for n in lst\n    sum += n ** 2\n  return sum.round(int(Math.ceil( Math/ceiling\
    \ )))\nend\n</cell>\n<text>\nProblem 3", "  sum = 0\n  list.each {|x| sum += x*x}\n\
    \  return sum.ceil\nend\n</cell>\n<cell>", "  if lst.empty?\n    0\n  else\n \
    \   lst.inject(0) do |sum, number|\n      sum + number**2\n    end\n  end\nend",
  "  sum_of_squares = 0\n  lst.map! {|num| num.to_i}\n  lst.map! {|num| num.ceil}\n\
    \  lst.map! {|num| num.ceil}\n  lst.map! {|num| num.to_i}\n  lst.each do |num|\n\
    \    sum_of_squares += num**2\n  end\n  return sum_of_squares\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nHere is a simple solution using Ruby's Enumerable#inject:\n\
    <code>", "  lst.each do |x|\n    x.round(Ceiling(x))\n  end\n  lst.inject(:+)\
    \ * lst.reduce(:+)\nend\n</code>\n<|/ a |>\n<| a |>\nRuby 2.4:\n<code>\nlst.map\
    \ {|e| e.to_i}.inject(:+)\n</code>\n<|/ a dscore=3 tags=ruby,sum |>\n<| c |>\n\
    This will have trouble with numbers greater than 2^53 (i.e. `Float::MAX`).\n<|/\
    \ c |>\n<| c |>\n`to_i` is an odd choice to me. Why not just `lst.inject(:+)`?\n\
    <|/ c |>\n<| a |>\n<code>\nlst.inject {|sum,e| sum + e}\n</code>\n<|/ a dscore=3\
    \ tags=ruby,sum |>\n<| a tags=ruby,sum |>\n<code>", "  if lst.nil?\n    raise(\"\
    Not a valid list\")\n  elsif lst.empty?\n    raise(\"Not a valid list\")\n  else\n\
    \    sum_of_squares = lst.map { |num| num ** 2 }.inject(:+).round(@ceiling)\n\
    \  end\nend", "  sum = 0\n  for n in lst\n    sum += n + (n ** 2)\n  return sum\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nRuby does not have `while`\
    \ loops. This is Python code\n<|/ c |>\n<| a |>\nAnother way of doing this would\
    \ be:\n<code>", "  # Write your code here.\n  lst.each {|x| x.ceil}\n  lst.map{|x|\
    \ Math.sqrt(x)}.sum\nend", "  \nend\n</cell>\n<cell>", "    sum = 0\n    lst.each\
    \ { |e| sum += Math.ceil(e) * Math.ceil(e) }\n    sum\nend", "  sum = 0\n  for\
    \ i in lst\n    sum += i**2\n    sum += Math.ceil(i)\n  end\n  return sum\nend\n\
    puts sum_squares([1,2,3])\nputs sum_squares([1,4,9])\nputs sum_squares([1,3,5,7])\n\
    puts sum_squares([1.4,4.2,0])\nputs sum_squares([-2.4,1,1])\nputs sum_squares([12.5,12.25,12])",
  "  lst.map! do |x| x.round(2) end\n  lst.inject(:+).round\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a tags=ruby dscore=0 |>\nThe way I usually do it is to sort the array\
    \ in descending order and then map each element in the array to square it. \n\
    <code>", "  lst.map!(&:round)\n  return lst.inject(0) {|s,e| s + e**2 }\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nI like the inject method here\n<|/ c |>\n\
    <| a tags=ruby,arrays |>\n<code>\narr.inject(0){|sum,x| sum + Math.sqrt(x)}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis code will return 0 for negative numbers.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  sum = 0.0\n  numbers.each do |number|\n\
    \    sum += number ** 2.0\n  end\n  sum\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nYou don't need `Math.round` on integers. `Math.ceil` will do.\n<|/ c |>\n\
    <| c |>\nThanks guys.  I understand why my code was wrong and I appreciate all\
    \ the help.  I was able to understand where I was going wrong.  Thanks again everyone.\n\
    <|/ c |>\n<| a tags=ruby dscore=0 |>\nThis can be solved pretty easily with a\
    \ very basic math formula that squares both the integer and the floating point.\
    \ Your code will be much more readable.\n<code>", "    sum = 0\n    for i in lst\n\
    \        sum += i * i\n    return sum\nend\n</code>\n<|/ a |>\n<| a tags=ruby,math,ruby-on-rails\
    \ |>\nThe most common way to solve this is called Kahan Sum, in fact it's more\
    \ commonly known as \"summation\".\nHere is a link to a Ruby gem that does what\
    \ you need:\nhttps://github.com/mojolk/ksum\n<|/ a dscore=1 |>\n<| a tags=ruby,math,ruby-on-rails\
    \ |>\nAs I see it, the most common way to solve this is to sum up the absolute\
    \ value of the differences between your numbers. So for instance, take (1 + 2)\
    \ and (2 + 1) the sum is (1 + 2)(2 + 1), or 4. Which is what you want.\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThat would give the wrong answer\n<|/ c |>\n<| c |>\n\
    `abs( sum - desired )`\n<|/ c |>\n<| a dscore=0 tags=ruby,math,ruby-on-rails |>\n\
    <code>", "  sum = 0 \n  for i in 0...lst.size\n    sum = sum + lst[i]*lst[i]\n\
    \  end\n  return sum.to_i\nend", "  lst.map{ |e| e.ceil }\n  sum = 0\n  lst.each\
    \ { |e| sum += e*e }\n  sum\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nHi I tested\
    \ this code in ruby 2.4.0 and it worked for me. Did you run the last three lines\
    \ in the code snippet separately?\n<|/ c |>\n<| c |>\nI ran the snippets separately,\
    \ yes. I tested the first one with your sample data.\n<|/ c |>\n<| c |>\nThe first\
    \ method fails in ruby 2.4.0, as `.ceil` is called on floats but not on integers\n\
    <|/ c |>\n<| c |>\nThanks for pointing this out. I updated the answer and also\
    \ added some links to relevant docs.\n<|/ c |>\n<| a dscore=5 |>\nIn Ruby 1.8.7,\
    \ this works:\n<code>\nlst.inject{ |sum, elem| sum + elem.round }\n</code>\n<|/\
    \ a tags=ruby |>\n<| c |>\nThis should really be the accepted answer. Nice and\
    \ simple!\n<|/ c |>\n<| c |>\nIt also works in Ruby 1.9.3\n<|/ c |>\n<| a dscore=5\
    \ |>\nI always forget about inject!\n<code>\nlst.inject { |sum, elem| sum + elem.round\
    \ }\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nYou could do it this way:\n\
    <code>", "  lst.each { |x| x =~ /^(-?\\d+(\\.\\d+)?)$/ and x = x.ceil }\n  lst.map\
    \ { |x| x * x }.reduce(:+)\nend\n</code>\n<|/ a dscore=2 tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=1 |>\nI came up with this solution:\n<code>", "    res=0\n \
    \   lst1=lst.map!(&:round).sort\n    lst1.each do |i|\n        i+=i\n        res+=i**2\n\
    \    end\n    return res\nend\n</cell>\n<code language=conda-root-py>\nsum_squares([1,2,3])\n\
    </cell>\n<code language=conda-root-py>\nsum_squares([1,4,9])\n</cell>\n<code language=conda-root-py>\n\
    sum_squares([1,3,5,7])\n</cell>\n<code language=conda-root-py>\nsum_squares([-1.4,4.2,0])\n\
    </cell>\n<code language=conda-root-py>\nsum_squares([-2.4,1,1])\n</cell>\n<text>\n\
    The sum of the squares is the sum of the cubes of all the numbers in the list\
    \ multiplied by each number.\nThe sum of the squares is equal to the sum of the\
    \ cubes of the squares.\nFor a list of length 1 the sum of the squares is that\
    \ number.\nFor a list of length 2 the sum of the squares is twice that number.\n\
    For a list of length 3 the sum of the squares is three times that number.\nFor\
    \ a list of length N the sum of the squares is N\xB2.\nExample 1:\nInput: [1,2,3,4]\n\
    Output: 25\nExplanation: The sum of the squares is 1 + 4 + 9 + 16 = 30\nExample\
    \ 2:\nInput: [-2,0,1,2,1,-2,-3,4]\nOutput: 29\nExplanation: The sum of the squares\
    \ is 1 + 8 + 27 + 64 + 126 = 60\nFollow up:\nCould you solve it without using\
    \ division?\nWhat if the given list contains duplicates?\nHow would you solve\
    \ it with division?\nExercise: If you have found the solution, please explain\
    \ why\n(Optional) Can you solve it with constant space complexity?\n(Optional)\
    \ What happens if you use an input containing duplicates \nbut you only need output\
    \ one of the repeated numbers?", " \n  return lst.inject(:+)\nend", "  lst = [round(el)\
    \ for el in lst]\n  lst.sort\n  lst.inject(0, :+)\nend", "    # Your code here\n\
    \    sum = 0\n    for n in lst\n        sum += n * n\n    end\nend", "  return\
    \ lst.inject(0) { |sum,x| sum + x*x }\nend", "  lst = lst.map(&:round).map(&:ceil)\n\
    \  lst.inject(0, :+).reduce(:*)\nend", "  sum = 0\n  lst.each do |n|\n    sum\
    \ = sum + n.to_i**2\n  end\n  sum.round(ceil)\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks for the answer. It looks nice but I don't think it is a good idea to return\
    \ nil if the list is empty. Moreover, your solution is O(n^2), so it will be very\
    \ slow for large lists.\n<|/ c |>\n<| c |>\nYes you are right. But your solution\
    \ is still O(n^2) but better than my solution. Thanks\n<|/ c |>\n<| c |>\n\"The\
    \ time complexity of code running on a computer is not determined by its running\
    \ time.\"", "  lst.each do |i|\n    i = i.round\n    i += 1\n  end\n  lst.inject(0,\
    \ :+)\nend", "    return lst[0] * lst[0] + lst[1] * lst[1] + lst[2] * lst[2] +\
    \ lst[3] * lst[3] + lst[4] * lst[4] + lst[5] * lst[5]\nend\nprintln(sum_squares([2,\
    \ 3, 4, 5]))\nprintln(sum_squares([-1, 0, 1, 2, 3, 4]))\nprintln(sum_squares([1.1,\
    \ 2.5, 3.3, 4.7, 6.2]))\n</cell>\n<text>\nProblem 8\nYou are given a string of\
    \ characters. Write a method to return the length of the string but \nalso report\
    \ the string with its length as well as the length of each word in the string.",
  "  lst.each {|i| i = round(i) if i.is_a?(Fixnum) }\n  lst.inject(:+)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis works for me and I'm surprised I didn't think of it before.\
    \ Thank you!\n<|/ c |>\n<| c |>\nOne problem is that this code is not really rounding\
    \ up. In the example `lst = [1.4,4.2,0]` the output should be 29 (not 30).\n<|/\
    \ c |>\n<| c |>\nGood catch, I've updated the code to round up the upper bound\
    \ of the range as you suggested.\n<|/ c |>\n<| a |>\nI like the way you already\
    \ have it\n<code>", "    sum = 0\n    for i in lst\n        sum += i * i\n   \
    \     sum += int(Math.ceil(i))\n        sum += i * int(Math.ceil(i))\n    return\
    \ sum\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYour code doesn't round the\
    \ sum to `Math.ceil` before adding the values.\n<|/ c |>\n<| c |>\nThis is wrong\
    \ as it rounds 4.6 to 4 rather than to 5. `Math.ceil(4.6) => 5`\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>\nMath.ceil(4.9) # 4\nMath.ceil(4.1) # 5\nMath.ceil(4.0)\
    \ # 4\nMath.ceil(-1.9) # -2\nMath.ceil(-0.8) # -1\nMath.ceil(-0.5) # 0\nMath.ceil(-0.4)\
    \ # -1\nMath.ceil(-0.3) # -1\nMath.ceil(-0.2) # -2\nMath.ceil(-0.1) # -1\nMath.ceil(0.9)\
    \ # 1\nMath.ceil(0.1) # 1\nMath.ceil(0.2) # 2\nMath.ceil(0.3) # 3\nMath.ceil(0.4)\
    \ # 4\nMath.ceil(0.6) # 5\nMath.ceil(0.5) # 5\nMath.ceil(0.7) # 5\nMath.ceil(0.8)\
    \ # 5\nMath.ceil(1.0) # 1\nMath.ceil(1.1) # 1\nMath.ceil(1.2) # 2\nMath.ceil(1.3)\
    \ # 3\nMath.ceil(1.4) # 4\nMath.ceil(1.5) # 5\nMath.ceil(1.6) # 5\nMath.ceil(1.7)\
    \ # 5\nMath.ceil(1.8) # 5\nMath.ceil(2.0) # 2\nMath.ceil(3.0) # 3\nMath.ceil(4.0)\
    \ # 4\nMath.ceil(4.1) # 5\nMath.ceil(4.2) # 5\nMath.ceil(4.3) # 5\nMath.ceil(4.4)\
    \ # 5\nMath.ceil(4.5) # 5\nMath.ceil(4.6) # 5\nMath.ceil(4.7) # 5\nMath.ceil(4.8)\
    \ # 5\nMath.ceil(4.9) # 5\nMath.ceil(5.0) # 5\nMath.ceil(5.1) # 5\nMath.ceil(5.2)\
    \ # 5\nMath.ceil(5.3) # 5\nMath.ceil(5.4) # 5\nMath.ceil(5.5) # 5\nMath.ceil(5.6)\
    \ # 5\nMath.ceil(5.7) # 5\nMath.ceil(5.8) # 5\nMath.ceil(5.9) # 5\nMath.ceil(6.0)\
    \ # 5\nMath.ceil(6.1) # 5\nMath.ceil(6.2) # 5\nMath.ceil(6.3) # 5\nMath.ceil(6.4)\
    \ # 5\nMath.ceil(6.5) # 5\nMath.ceil(6.6) # 5\nMath.ceil(6.7) # 5\nMath.ceil(6.8)\
    \ # 5", "  sum = 0\n  lst.each do |x|\n    sum = sum + Math.ceil(Math.sqrt(x))\n\
    \  end\n  return sum\nend", "  lst.map!{ |e| e.round(0, BigDecimal::ROUND_UP)\
    \ }\n  lst.inject(0) { |sum, e| sum + e.to_s ** 2 }\nend", "  lst.map!{|x| x.to_i}\n\
    \  lst.map!{|x| x.round}\n  lst.map!{|x| x.to_f * x}\n  lst.map!{|x| x.round}\n\
    \  lst.inject{|x,y| x + y}\nend", "  sum = 0\n  lst.each do |num|\n    sum +=\
    \ num ** 2\n  end\n  sum\nend", "    lst.each do |i|\n        i.ceil\n       \
    \ i.upto\n        i.reduce(:+)\n    end\nend", "    total = 0\n    arr = lst.to_a\n\
    \    arr.each_index do |i|\n        total = total + arr[i]*arr[i]\n    end\n \
    \   total = total.round(arr.last.ceil)\n    return total\nend\n</code>\n<|/ a\
    \ |>\n<| a tags=ruby |>\nHere is a solution that uses Enumerable#inject:\n<code>",
  "  sum = 0\n  lst.each do |x|\n    sum += Math.ceil(Math.sqrt(x))\n  end\n  sum\n\
    end\n</code>\n<|/ a tags=ruby,math,arrays,list dscore=0 |>\n<| c |>\nThis is more\
    \ or less correct, but you're missing a closing `end`.\n<|/ c |>\n<| c |>\nThat's\
    \ because I didn't know what else to put there. I took it from the original code.\n\
    <|/ c |>\n<| c |>\nRuby supports implicit return statements. You do not need to\
    \ specify `return` at the end of the method.\n<|/ c |>\n<| c |>\nYou're right,\
    \ thanks. I didn't realize that it's already doing that.\n<|/ c |>\n<| c |>\n\
    Having seen the `Math.ceil` bit, I might have used `Math.sqrt`. But the OP's original\
    \ code was already doing the `Math.ceil`. I'm not sure why the OP used the `Math.ceil`\
    \ when they wanted `Math.sqrt`.\n<|/ c |>\n<| a dscore=0 |>\nThe answer provided\
    \ by Ruby Ninja is correct.\nIn case you want to return the sum as an integer,\
    \ try this:\n<code>", "  sum = 0\n  for i in lst\n    sum += i**2 \n  end\n  sum\n\
    end", "  sum=0\n  lst.each {|x| sum += (x.to_f**2) }\n  sum\nend\n</code>\nThe\
    \ solution is the same as the one by 'user3386100', but his solution is more succinct.\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nThis is not a Ruby question, it's an algorithm\
    \ question in general. \n<code>", "\tsum = 0\n\tfor n in lst\n\t\tsum += n * n\n\
    \treturn sum\nend\n</cell>\n<code language=julia-1.5>\nfunction sum_squares(lst)\n\
    \tsum = 0\n\tfor n in lst\n\t\tsum += n * n\n\tend\n\treturn sum\nend\n</cell>\n\
    <code language=julia-1.5>\nsum_squares([1,2,3])\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([1,4,9])\n</cell>\n<code language=julia-1.5>\nsum_squares([1,3,5,7])\n\
    </cell>\n<code language=julia-1.5>\nsum_squares([1.4,4.2,0])\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([-2.4,1,1])\n</cell>\n<code language=julia-1.5>\nsum_squares([1,2.2,3.4])\n\
    </cell>\n<code language=julia-1.5>\nsum_squares([1,2,3,4,5])\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([1.2,2.3,3.4])\n</cell>\n<code language=julia-1.5>\nfunction sum_squares(lst)\n\
    \tsum = 0\n\tfor n in lst\n\t\tsum += n * n\n\tend\n\treturn sum\nend\n</cell>\n\
    <code language=julia-1.5>\nsum_squares([1.2,2.3,3.4])\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([1,2.2,3.4])\n</cell>\n<code language=julia-1.5>\nsum_squares([1,2,3,4,5])\n\
    </cell>\n<code language=julia-1.5>\nsum_squares([1.2,2.3,3.4])\n</cell>\n<code\
    \ language=julia-1.5>\nsum_squares([1,2,3,4,5])\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([1.2,2.3,3.4])\n</cell>\n<code language=julia-1.5>\nfunction sum_squares(lst)\n\
    \tsum = 0\n\tfor n in lst\n\t\tsum += n * n\n\tend\n\treturn sum\nend\n</cell>\n\
    <code language=julia-1.5>\nsum_squares([1,2,3])\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([1,4,9])\n</cell>\n<code language=julia-1.5>\nsum_squares([1,3,5,7])\n\
    </cell>\n<code language=julia-1.5>\nsum_squares([1.4,4.2,0])\n</cell>\n<code language=julia-1.5>",
  "  sum = 0\n  for i in lst\n    sum += Math.ceil(i) ** 2\n  return sum\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a |>\nI didn't know about Math.ceil until I looked it up.\
    \ \n<code>", "  result = 0\n  lst.each { |x| result += x.round }\n  result.to_i\n\
    end", "  sum=0\n  for num in lst\n    sum+=num**2\n  end\n  return sum.round\n\
    end", "  lst.map!{ |x| x.ceil }\n  lst.inject(0) {|sum, el| sum + el**2 }\nend",
  "  sum = 0\n  lst.each do |x|\n    sum = sum + (x * x)\n  end\n  sum.round(Math::CEILING)\n\
    end", "  sum = 0\n  for i in lst\n    sum += i**2\n  sum.round(2)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI didn't know about `round()`. Thanks! What is the purpose\
    \ of the `.round(2)`?\n<|/ c |>\n<| c |>\nI added the `.round(2)` because OP's\
    \ examples are all integers. Otherwise, it's useless.\n<|/ c |>\n<| c |>\nBut\
    \ it's unnecessary in this case. `round` rounds to the nearest integer (towards\
    \ negative infinity).\n<|/ c |>\n<| c |>\nI assumed that OP was using `round`\
    \ because of the OP's code, and not because he wanted an example where the results\
    \ would be more like `29` instead of `29.5`.\n<|/ c |>\n<| a dscore=0 |>\nWe can\
    \ use inject to build our own method of summing squares.\n<code>", "  lst.each_with_index\
    \ {|number, index| number.round(Ceiling) = number}\n  lst.sum\nend\n</code>\n\
    <|/ a tags=ruby,functional-programming |>\n<| c |>\nThis is not what the OP asked\
    \ for. You don't round the numbers just square the numbers.\n<|/ c |>\n<| c |>\n\
    OP asked how to return rounded numbers. I answered as requested.\n<|/ c |>\n<|\
    \ c |>\nHe asked how to round the numbers first. Your answer does not round them\
    \ first. Try it out.\n<|/ c |>\n<| c |>\nHow do you know he doesn't need to round\
    \ the numbers? The OP has several examples of rounding in the OP's question. Maybe\
    \ the OP has another requirement they haven't mentioned yet.\n<|/ c |>\n<| c |>\n\
    I'm saying he does not need to round them first. It was a comment to the other\
    \ answer explaining that he does not need to round them first.\n<|/ c |>\n<| a\
    \ dscore=3 |>\nIt is not possible to modify a collection in place, so the simplest\
    \ way would be to create a new collection and add it to the same array:\n<code>",
  "  sum_ = 0\n  lst.map! { |x| x = x.ceil } \n  lst.map! { |x| sum_ += x * x }\n\
    \  sum_\nend", "    total = 0\n    squares = []\n    \n    square = lst.map(&:round).inject(:+).to_f\n\
    \    squares << square\n    \n    squares.each do |s|\n      total += s\n    end\n\
    \    \n    total\nend\n</cell>\n<cell>\nsum_squares([1,2,3])\n</cell>\n<cell>\n\
    sum_squares([1,4,9])\n</cell>\n<cell>\nsum_squares([1,3,5,7])\n</cell>\n<cell>\n\
    sum_squares([1.4,4.2,0])\n</cell>\n<cell>\nsum_squares([-2.4,1,1])\n</cell>\n\
    <cell>\nsum_squares([-1, 0, 1, 2, 3, 4])\n</cell>\n<cell>\nsum_squares([1.0, 1.1,\
    \ 1.2, 2.2])\n</cell>\n<cell>\nsum_squares([-9, -9, -9, -9])\n</cell>\n<cell>\n\
    sum_squares([-100, -100, -100, -100])\n</cell>\n<cell>\nsum_squares([-1.4, -1.4,\
    \ -1.4, -1.4])\n</cell>\n<cell>\nsum_squares([-1.4, -1.4, -1.4, -1.4])\n</cell>\n\
    <cell>\nsum_squares([-1.4, -1.4, -1.4, -1.4])\n</cell>\n<cell>\nsum_squares([-1.4,\
    \ -1.4, -1.4, -1.4])\n</cell>\n<cell>\nsum_squares([-1.4, -1.4, -1.4, -1.4])\n\
    </cell>\n<cell>\nsum_squares([-1.4, -1.4, -1.4, -1.4])\n</cell>\n<cell>\nsum_squares([-1.4,\
    \ -1.4, -1.4, -1.4])\n</cell>\n<cell>\nsum_squares([-1.4, -1.4, -1.4, -1.4])\n\
    </cell>\n<cell>\nsum_squares([-1.4, -1.4, -1.4, -1.4])\n</cell>\n<cell>\nsum_squares([-1.4,\
    \ -1.4, -1.4, -1.4])\n</cell>\n<cell>\nsum_squares([-1.4, -1.4, -1.4, -1.4])\n\
    </cell>\n<cell>\nsum_squares([-1.4, -1.4, -1.4, -1.4])\n</cell>\n<cell>\nsum_squares([-1.4,\
    \ -1.4, -1.4, -1.", "  result = 0\n  for i in lst\n    result = result + i * i\n\
    \  end\n  result * result\nend\n</code>\nThe second solution is more straight\
    \ forward and more efficient.\n<code>", "    sum = 0\n    for i in lst\n     \
    \   sum += i*i\n    end\n    sum\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\nI like using inject for these kinds of things.  It also has the advantage\
    \ of being very clean and very easy to read.  Also, you can pass in a variable\
    \ for the sum.\n<code>", "    sum = 0\n    rounded_lst = []\n    rounded_lst =\
    \ lst.map { |x| x.round }\n    rounded_lst.each_with_index do |x, i|\n       \
    \ sum = sum + i*i*x\n    end\n    return sum\nend\n</code>\n<|/ a |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  sum_square = 0\n  lst.map{|x| sum += x*x} #.ceil\n  sum_square\
    \ = sum\n  return sum_square\nend", "  sum = 0\n  lst.map!{ |x| x.round }\n  lst.map!{\
    \ |x| sum += x*x }\n  sum\nend", "  # Write your code here\n  sum = 0\n  for i\
    \ in lst.map{|x| x}\n    sum+=x*x\n  end\n  return sum\nend", "  lst.map {|x|\
    \ Math.ceil(x)*Math.ceil(x)}.inject(0) {|sum, x| sum + x}\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| a dscore=0 |>\nI like this solution, although it's slightly\
    \ over-complicated for a beginner:\n<code>", "  lst.map!(&:round)\n  lst.inject(0,\
    \ &+)\nend", "  lst.each do |i|\n    i = i.ceil\n    i = i.to_i\n    sum_squares\
    \ = sum_squares + i ** 2\n  end\n  return sum_squares\nend", "  sum = 0\n  lst.each\
    \ do |number|\n    sum += Math.ceil(number)**2\n  end\n  return sum\nend", " \
    \ sum = 0\n  for i in lst\n    sum += i*i\n  end\n  return sum\nend\n</cell>\n\
    <cell>\nsum_squares([3,5,6,7])\n</cell>\n<cell>\nsum_squares([1.4,4.2,0])\n</cell>\n\
    <cell>\nsum_squares([-2.4,1,1])\n</cell>\n<cell>", "    # Your code goes here\n\
    \    sum_square = 0\n    sum_of_ints = 0\n    sum_of_float = 0\n    for num in\
    \ lst:\n        sum_of_float = sum_of_float + num\n        sum_of_ints = sum_of_ints\
    \ + int(sum_of_float)\n        sum_square = sum_square + num * num", "  if lst.nil?\
    \ \n    return 0\n  else\n    lst = lst.map{|x| x.ceil}\n    lst.inject(0){|total,x|\
    \ total * x}\n  end\nend", "  lst.map! &(Math.sqrt).round\n  lst.inject(:+).round\n\
    end\n</code>\n<|/ a |>\n<| c |>\nYes, I knew how to do that. Thanks for the answer.\n\
    <|/ c |>\n<| c |>\nI like this one, but I don't see the point in using inject\
    \ if you can just use a reduce.\n<|/ c |>\n<| c |>\nIt might be more efficient\
    \ to store the result in a variable and return the result of the reduce as opposed\
    \ to calculating the same thing twice.\n<|/ c |>\n<| c |>\nNot necessarily. `inject`\
    \ is a functional programming tool where you want to keep an intermediate result\
    \ for the reduction operation. Here, we are not interested in the intermediate\
    \ result because we do not need the initial value to generate the final result.\
    \ Moreover, in ruby 2.0 we have `inject` so it is more efficient to not use it.\n\
    <|/ c |>\n<| c |>\nNot quite. He wants to round the number each time, not accumulate\
    \ the total and return the value at the end.\n<|/ c |>\n<| a |>\n<code>", "  \
    \  sum = 0\n    i = 0\n    while i < lst.size\n        sum += lst[i]*lst[i]\n\
    \        i += 1\n    return sum\nend", "  sum = 0\n  lst.each do |i|\n    sum\
    \ += i * i\n  end\n  sum\nend", "  sum = 0\n  for i in 0..lst.length\n    sum\
    \ += (Math.ceil(lst[i])*Math.ceil(lst[i]))\n  return sum\nend", "    sum = 0\n\
    \    for i in lst\n        sum = sum + Math.ceil(Math.sqrt(i));\n    return sum;\n\
    end\n</code>\n<|/ a |>\n<| a tags=math,ruby,python,ruby-on-rails |>\nYou can easily\
    \ translate this Ruby code to Python:\n<code>", "    sum = 0\n    cnt = 1\n  \
    \  for i in lst\n      sum += i ** cnt\n      cnt += 1\n    end\n    sum.round\n\
    \  end\nend\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| a dscore=2 tags=ruby |>\n\
    <code>", "  sum = 0\n  lst.each do |x|\n    sum += x * x\n  end\n  sum\nend",
  "  lst.each_with_index do |x, i|\n    lst[i] = x.ceil\n    sum += (x * x)\n  end\n\
    \  sum\nend", "  sum = 0\n  for i in lst\n    sum += i**2\n  end\n  sum.round\n\
    \  return sum\nend", "  return lst.inject(:+).collect {|x| x*x}.reduce(:+)\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nHere is my answer, which I got from\
    \ James Dean's answer.\n<code>\nsum_squares [3.14159, 1.41421356, 6.28318530989]",
  "  return lst.inject(:+).to_f\nend\n</cell>\n<code language=other-env>\nsum_squares([1,2,3])\n\
    </cell>\n<code language=other-env>\nsum_squares([1,4,9])\n</cell>\n<code language=other-env>\n\
    sum_squares([1,3,5,7])\n</cell>\n<code language=other-env>\nsum_squares([1.4,4.2,0])\n\
    </cell>\n<code language=other-env>\nsum_squares([-2.4,1,1])\n</cell>\n<code language=other-env>\n\
    sum_squares([[1,1],[2,2],[3,3]])\n</cell>\n<code language=other-env>\nsum_squares([[1,2,3],[4,5,6]])\n\
    </cell>\n<code language=other-env>\nsum_squares([[1,2],[3,4]])\n</cell>\n<code\
    \ language=other-env>\nsum_squares([[1,2,3],[4,5,6],[8,9,10]])\n</cell>\n<text>\n\
    Exercise 4\nWrite a function that will generate the Fibonacci sequence up to the\
    \ number given as a parameter.", "  result = 0\n  lst.each do |i|\n    result\
    \ += (Math.ceil(i) ** 2).to_f\n  end\n  result\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=1 |>\n<| a tags=ruby |>\n<code>", "  sum = 0\n  for i in lst\n    sum\
    \ += i * i\n  end\n  sum = Math.ceil(sum)\n  sum.to_i\nend", "  sum = 0\n  lst.each\
    \ do |i|\n    sum = sum + i * i\n  end\n  sum\nend", "  sum = 0\n  for i in lst\n\
    \    sum += i ** 2\n  end\n  sum.ceil\nend", "  if lst.empty? then return 0\n\
    \  ceil = lst.last.ceil\n  total = lst.map { |x| x.to_i * x.to_i }.reduce(:+)\n\
    \  total *= ceil.to_i\n  total += lst.map { |x| x.to_i * x.to_i }.sum\n  return\
    \ total\nend", "  sum = 0\n  for i in lst\n    sum+=Math.ceil(i) ** 2\n  return\
    \ sum", "  sum = 0\n  lst.each do |num|\n    sum = sum + num ** 2\n  end\n  return\
    \ round(sum)\nend", "  sum = 0\n  list.map {|i| sum += i*i }\n  sum\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis was flagged as low quality because of its length\
    \ and content. Perhaps expand your example to explain how it helps to solve the\
    \ problem?\n<|/ c |>\n<| a dscore=0 |>\nI feel this question was asked long back\
    \ but I am posting a new answer to help other newbies to understand how can they\
    \ use map here.\nBasically map is used to apply a certain operation on every element\
    \ in a collection and return the result in the form of a new collection. \nIn\
    \ our case, map will take each element in the list and perform the operation we\
    \ provide.\nIn the example below we take a list of two numbers and we multiply\
    \ each element of the list with each other. Here we are multiplying each element\
    \ with the element itself.\n<code>\na = [1,2,3]\nb = a.map {|e| e*e}\n</code>\n\
    This will return \n<code>\n[1,2,3]\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThe\
    \ only problem here is that OP asked for rounding off before doing the sum.\n\
    <|/ c |>\n<| a tags=ruby |>\nHere is another answer to the same question\n<code>",
  "  if lst.nil?\n    return 0\n  end\n  x = lst[0]\n  return x * x + sum_squares(lst[1..-1])\n\
    end", "    sum_square = 0\n    for num in lst\n        sum_square += num ** 2\n\
    \    sum_square = round(sum_square)\n    return sum_square\nend", "    sum = 0\n\
    \    lst = lst.map { |x| x.round }\n    lst.each { |x| sum+=x }\n    sum\nend",
  "  sum = 0.0\n  lst.each do |n|\n    sum += Math.ceil(n) ** 2\n  end\n  return sum\n\
    end", "  lst.each{|i| i = i.ceil}\n  lst.inject(0){|sum, e| sum + e * e}\nend",
  "  sum = 0\n  lst.each do |x|\n    sum += Math.round(x**2) #Round and square\n \
    \ end\n  sum\nend\n</cell>\n<code language=julia-1.5>\nsum_squares([1, 4, 9])\n\
    </cell>\n<code language=julia-1.5>\nsum_squares([1, 3, 5])\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([1, 3, 5.4])\n</cell>\n<code language=julia-1.5>\nsum_squares([1.4,\
    \ 4.2, 0])\n</cell>\n<code language=julia-1.5>\nsum_squares([-2.4, 1, 1])\n</cell>\n\
    <code language=julia-1.5>\nsum_squares([-3.5, 4.2, 0])\n</cell>\n<code language=julia-1.5>\n\
    sum_squares([-3.5, 4.2, 2.1])\n</cell>\n<text>\nRecursive Function Sum Squares\n\
    We also need to find sum of squares using a recursive function.", "    sum = 0\n\
    \    count = 0\n    lst.each do |x|\n        sum += x.to_i ** 2\n        count\
    \ += 1\n    end\n    sum.round\nend", "  sum = 0\n  lst.map!{|x| x = Math.ceil(x)}\n\
    \  lst.map!{|x| sum += x*x}\n  sum\nend", "  sum = 0\n  lst.map! {|x| x = x.round}\n\
    \  lst.each do |x|\n    sum += x.to_s**2 if x.to_i >= 0 \n  end\n  sum\nend",
  "    sum = 0\n    for value in lst\n        sum = sum + value ** 2\n    sum = sum.ceil\n\
    \    return sum\nend", "  lst.sort\n  sum = 0\n  lst.each do |x|\n    sum += x\
    \ * x\n  end\n  sum\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,ruby-on-rails,sorting,list\
    \ dscore=1 |>\nYou can solve this in O(n) by converting it to an array and doing\
    \ a single pass over it. First you find all the numbers who are divisible by n\
    \ (say those with 2 at the end), then you do those divisible by n, and sum their\
    \ squares. Since you only need to do a single pass over it this is O(n).\n<code>",
  "  sum = 0\n  lst.each do |i|\n    sum += i * i\n  end\n  return sum\nend", "  lst.map!\
    \ { |n| n.round }\n  lst.map! { |n| n.ceil }\n  lst.inject(0, :+)\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby |>\nHere is a solution that is more \"Ruby\"\
    \ style:\n<code>", "  lst = lst.sort\n  tot = 0\n  lst.each do |x|\n    tot +=\
    \ Math.ceil(x)*Math.ceil(x)\n  end\n  tot\nend\n</code>\n<|/ a dscore=3 tags=ruby\
    \ |>\n<| c |>\nI think the OP was looking for an elegant solution, that would\
    \ be more readable and less cumbersome than the one you provided.\n<|/ c |>\n\
    <| c |>\nThanks. I added a solution with a little more comments. I guess I'm used\
    \ to thinking in a procedural way, whereas ruby is a functional one.\n<|/ c |>\n\
    <| a tags=ruby dscore=2 |>\nThe best way to do this is with a loop:\n<code>",
  "  sum = lst.reduce(:+)\n  lst.map! { |i| i.round(0, BigDecimal.ROUND_HALF_UP) }\n\
    \  lst.inject(0, :+)\nend", "  sum = 0\n  lst.each{|x| sum += Math.ceil(x)**2\
    \ }\n  sum\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI really\
    \ like this `Math.ceil` approach, but I'm surprised the other solutions posted\
    \ don't involve any explicit loops in Ruby.\n<|/ c |>\n<| a |>\nRuby provides\
    \ the Enumerable module with a very handy method:\n<code>\nlst = [1,4,9].map{\
    \ |x| Math.ceil(x) ** 2 }\n</code>\nIt takes a block (the {|x| Math.ceil(x)**2}\
    \ bit) and applies it to each element in the array.\n<|/ a dscore=2 tags=ruby,ruby-on-rails\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\nIf performance is important, you should\
    \ use jruby with its JRubyVM.  JRubyVM provides JIT compilation for Ruby code.\
    \  So your original solution will be faster than all the others.\n<|/ a dscore=2\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\nIf you don't care about rounding the result\
    \ up and just need it to be an int, you could do something like this:\n<code>",
  "  if lst.nil? or lst.size < 1 \n    0.0 \n  else \n    sum = (lst.inject(0) { |sum,\
    \ item| sum + item ** 2 } ** 0.5) \n    round = sum.to_i \n    round(ceil(lst.size)\
    \ * round(sum))\n  end\nend\n</code>\n<|/ a dscore=4 tags=ruby |>\n<| c |>\nYou\
    \ might want to look at [`inject`](http://ruby-doc.org/core-2.3.0/Enumerable.html#method-i-inject)\
    \ instead of `inject`. It has a little more memory usage, but I find it easier\
    \ to read and easier to understand.\n<|/ c |>\n<| a dscore=3 |>\nThe simple approach\
    \ is to sum up all numbers in your array and then square the sum. Since you can\
    \ never have an array of numbers with a square root, you should make sure you\
    \ know where to round this up to the closest integer.\n<code>", "  sum = 0\n \
    \ lst.each do |num|\n    sum += num ** 2\n  end\n  return sum.round\nend", " \
    \ lst.each do |x|\n    x = Math.ceil(x)\n  end\n  lst.inject(0) do |sum, el|\n\
    \    sum += el * el\n  end\nend\n</code>\n<|/ a |>\n<| c |>\n`each_with_object`\
    \ is an alias for `inject` which is an alias for `reduce`.\n<|/ c |>\n<| c |>\n\
    Not exactly. `each_with_object` will pass the accumulated value into the block,\
    \ then the next element of the array will be the accumulated value and the next\
    \ will be the object passed in.\n<|/ c |>\n<| c |>\nThat's not true.\n<|/ c |>\n\
    <| c |>\nThe difference is that `each_with_object` will return nil.\n<|/ c |>\n\
    <| c |>\nNot true, not with that code. Also, `each_with_object` is an alias for\
    \ [`inject`](http://www.ruby-doc.org/core-2.1.1/Enumerable.html#method-i-inject),\
    \ which is an alias for `reduce`.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  lst.map{\
    \ |x| x.round }\n  lst.inject(0) {|s,x| s + x*x }\nend", "  sum = 0\n  lst.each\
    \ do |x|\n    sum = sum + x.to_i ** 2\n  end\n  sum\nend", "    lst.each{|x| x\
    \ = x.ceil}\n    lst.map {|x| x * x}.reduce(&:+)\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby,ruby-on-rails |>\n<| a dscore=0 |>\n<code>", "  lst.map! { |x| x.round\
    \ }\n  sum = 0\n  for i in 0...lst.size-1\n    sum += (i+1) * lst[i] * lst[i]\n\
    \  end\n  sum\nend", "    \n    sum = 0\n    \n    sum = 0.0\n    \n    for i\
    \ in lst:\n        \n        sum = sum + i**2\n        \n    return sum", "  \
    \  numbers = lst.map {|n| n.ceil}\n    numbers.reduce(:+)\nend", "  sum = 0\n\
    \  square = 0\n  for i in lst\n    sum = sum + i ** 2\n    square = square + i\n\
    \  end\n  return sum + square\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a\
    \ |>\nHere's a one-line solution:\n<code>\nsum_squares([-1.5, 1.4, 9.4, 3.5, 8.5])\n\
    => 29\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| a dscore=0 |>\n<code>", "  sum_squares\
    \ = lst.map { |e| e**2 }.sum\n  sum_squares = Math.ceil(sum_squares)\n  sum_squares\n\
    end", "  lst = lst.sort\n  lst.each do |num|\n    num.round!\n  end\n  lst.inject(0)\
    \ {|s, x| s+x*x}\nend", "  lst.each{ |x| x= x.round(0) } # Rounds numbers to the\
    \ closest int\n  lst.map{ |x| x*x }.reduce(:+) # Returns the sum of the squares\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nFor `lst = [1.4,4.2,0]` this should\
    \ return 6 not 29\n<|/ c |>\n<| c |>\nAh you are right! I missed that in the question.\
    \ I've updated the code to round the numbers up.\n<|/ c |>\n<| a tags=arrays,ruby\
    \ |>\nYou have a couple of issues with your code, some syntactical.\nYou don't\
    \ need to call round on the elements in the list, it just mutates them and you\
    \ lose the original list when you return from the function. Same for the other\
    \ loops. And you can't reassign a variable in an if/else condition, which is what\
    \ you're doing in that last line, lst.each{ |x| x=x.round(0) }; since x is assigned\
    \ the value of the each, so that condition will always be true.\nThe other issues\
    \ with your code are that you're redefining lst inside the sum_squares function,\
    \ and you're also using map for no real reason other than to make your code more\
    \ complicated. I would simplify the function to:\n<code>", "    sum=0\n    for\
    \ i in lst\n        sum=sum+i**2 # sum of squares\n    sum=sum/lst.size # average\
    \ of squares\n    sum=round(sum)\n    sum=sum+1 # round up\n    return sum\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nWhy are you calling `lst.size`? It's a list method\
    \ not a hash method, which means the result will be the same even if you call\
    \ it on any other type of object.\n<|/ c |>\n<| c |>\nAlso, you should probably\
    \ use `sum_squares` instead of `sum`, since that is the name you want to be using.\
    \ Calling `sum` could cause confusion.\n<|/ c |>\n<| a |>\n<code>", "    sum =\
    \ nil\n    \n    # Write your code below this line\n    \n    \n    return sum\n\
    end", "  # Your code here\n  sum = 0\n  for num in lst\n    sum += num ** 2\n\
    \  return sum.round(2)\nend\n</cell>\n<cell>\nsum_squares([1,2,3])\n</cell>\n\
    <cell>\nsum_squares([1,4,9])\n</cell>\n<cell>\nsum_squares([1,3,5,7])\n</cell>\n\
    <cell>\nsum_squares([1.4,4.2,0])\n</cell>\n<cell>\nsum_squares([-2.4,1,1])\n</cell>\n\
    <cell>\nsum_squares([0,0.1,-0.1])\n</cell>\n<cell>", "  if lst.empty?\n    0\n\
    \  else\n    lst.map(&:round).reduce(:+).round(8)\n  end\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nJust be aware that this method will break down if you\
    \ give it a list of a number other than ints. It's better to simply use `.map(&:round).reduce(:+).round(8)`\
    \ as suggested in other answers.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  x =\
    \ lst.map { |i| i.to_s.round }\n  x.inject(:+)\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\n`map` returns an array. Also, OP wants ints.\n<|/ c |>\n<| c |>\nThe\
    \ OP asked for ints, as he put it in a comment.\n<|/ c |>\n<| c |>\n`x = lst.map\
    \ { |i| i.to_s.round }\n=> [\"1\", \"2\", \"3\"]\nx.inject(:+)\n=> 5`\n<|/ c |>\n\
    <| c |>\nThank you very much\n<|/ c |>\n<| c |>\nThe question is tagged \"ruby\"\
    . Are you going to use ActiveSupport's `sum`?\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nThis answer is basically what Ashley said, but with some tweaks and added\
    \ comments for you.\n<code>", "    total = 0\n    sum_squares = 0\n    for i in\
    \ lst\n        total += i ** 2\n        sum_squares += i\n    sum_squares = math.ceil(sum_squares)\
    \ * sum_squares\n    sum_squares += total\n    return sum_squares\n</code>\n<|/\
    \ a |>\n<| a tags=python,python-3.x |>\n<code>\nimport math\nlst = [1, 3, 6, 3,\
    \ -2, 8, 6]\nprint(sum([math.ceil(i) ** 2 for i in lst]))\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 tags=python,python-3.x |>\nThe key is to convert each number\
    \ to an integer and to square it - and to round the result to the nearest integer.\
    \ For example:\n<code>", "  sum = 0\n  lst.map! {|i| i = Integer(i)}\n  lst.each\
    \ do |x|\n    sum = sum + x**2\n  end\n  return sum\nend", "\tsum_sq = 0\n\tfor\
    \ i in lst\n\t\tsum_sq = sum_sq + (i ** 2)\n\treturn sum_sq\nend", "  sum = 0\n\
    \  for i in lst.each\n    sum += i*i\n  sum\nend", "  return lst.inject{|i,x|\
    \ i + Math.sqrt(x)}\nend", "  lst.each {|x| x = x.to_i; x = Math.ceil(x);}\n \
    \ lst.inject {|sum,x| sum += Math.pow(x, 2)}\nend\n</code>\nHope this helps!\n\
    <|/ a tags=ruby |>\n<| c |>\nThanks for your answer.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nTry this\n<code>", "  lst.each { |num| num = num.to_i}\n  lst.sort { |a,\
    \ b| b.to_i - a.to_i }\n  lst.each_with_index { |item, idx| \n    idx = idx %\
    \ lst.size\n    lst[idx] = item.ceil\n  }\n  lst.inject { |s, item| s + item**2\
    \ }\nend", "  sum = 0\n  for x in lst\n    sum += x * x\n  sum\nend", "  sum =\
    \ 0\n  lst.each do |x|\n    sum += Math.sqrt(x)\n  end\n  return sum\nend", " \
    \ # Write your code here\n  return\nend", "    sum = 0\n    for i in lst.round\n\
    \        sum += i * i\n    return sum\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>", "    sum = 0\n    cnt = 1\n    elmts = lst.to_a\n    elmts.each\
    \ do |elmt|\n        elmt.round(1).to_i.times do\n            sum += elmt\n  \
    \      end\n        cnt += 1\n    end\n    sum\nend\n</code>\nOutput:\n<code>\n\
    2.2.4 :001 > arr = [1, 3, 5]\n => [1, 3, 5] \n2.2.4 :002 > arr.sum_squares\n =>\
    \ 14.0\n2.2.4 :003 > arr = [1, 3, 5]\n => [1, 3, 5] \n2.2.4 :004 > arr.sum_squares\n\
    \ => 14.0\n2.2.4 :005 > arr = [1, 3, 5]\n => [1, 3, 5] \n2.2.4 :006 > arr.sum_squares\n\
    \ => 14.0\n2.2.4 :007 > arr = [1, 3, 5]\n => [1, 3, 5] \n2.2.4 :008 > arr.sum_squares\n\
    \ => 14.0\n2.2.4 :009 > arr = [1, 3, 5]\n => [1, 3, 5] \n2.2.4 :010 > arr.sum_squares\n\
    \ => 14.0\n2.2.4 :011 > arr = [1, 3, 5]\n => [1, 3, 5] \n2.2.4 :012 > arr.sum_squares\n\
    \ => 14.0\n2.2.4 :013 > arr = [1, 3, 5]\n => [1, 3, 5] \n2.2.4 :014 > arr.sum_squares\n\
    \ => 14.0\n2.2.4 :015 > arr = [1, 3, 5]\n => [1, 3, 5] \n2.2.4 :016 > arr.sum_squares\n\
    \ => 14.0\n2.2.4 :017 > arr = [1, 3, 5]\n => [1, 3, 5] \n2.2.4 :018 > arr.sum_squares\n\
    \ => 14.0\n2.2.4 :019 > arr = [1, 3, 5]\n => [1, 3, 5] \n2.2.4 :020 > arr.sum_squares\n\
    \ => 14.0\n2.2.4 :021 > arr = [1, 3, 5]\n => [1, 3, 5] \n2.2.4 :022 > arr.sum_squares\n\
    \ => 14.0\n2.2.4 :023 > arr = [1.4, 4.2]\n => [1.4, 4.2] \n2.2.4 :024 > arr.sum_squares\n\
    \ => 29.0\n2.2.4 :025 > arr = [-2.4, 1, 1]\n => [-2.4, 1, 1] \n2.2.4 :026 > arr.sum_squares\n\
    \ => 6.0\n2.2.4 :027 > arr", "  lst.map{|x| x.ceil}.inject(:+).round(3).to_i\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails |>\n\
    <code>", "  return lst.inject{|sum, item| sum + item*item }\nend", "    total=0\n\
    \    lst.map!{|x| x.round(1)}\n    lst.map!{|x| x+total}\n    total+=lst.inject(0){|x,y|\
    \ x+y}\n    return total\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a |>\nA\
    \ more generic solution would be something like this:\n<code>", "    sum = 0\n\
    \    \n    \n    \n    # Write your code here\n    sum = lst.reduce(:+)\nend\n\
    </cell>\n<cell>", "  sum = 0.0\n  lst.each do |x|\n    sum += x.to_f\n  end\n\
    \  sum\nend\n</code>\n<|/ a |>\n<| c |>\nYou might want to add an explanation\
    \ as to why the code in the answer works :) Thanks.\n<|/ c |>\n<| a dscore=2 tags=ruby,floating-point\
    \ |>\nHere's an alternate implementation that returns the square root of sum of\
    \ the squares without having to calculate the square root by yourself:\n<code>",
  "  lst.map{|x| x.round}.inject(:+)\nend", "  sum = 0\n  lst.each do |x|\n    sum\
    \ += Math.ceil(x*x)\n  end\n  sum\nend", "  # write your code here\n  result =\
    \ 0\n  \n  result.upto(lst.count) do |x|\n    result += (lst[x].ceil)**2\n  end\n\
    \  result\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4 |>\n<|\
    \ c |>\nThis will not round, for example, 4.2 up and then square the result (which\
    \ would be 8.00).\n<|/ c |>\n<| c |>\nyou are right, I updated the answer, thanks.\n\
    <|/ c |>\n<| c |>\nYour `upto` should be `upto`.\n<|/ c |>\n<| a dscore=1 |>\n\
    My take on it\n<code>", "  lst.map!{ |x| x.round(0) } \n  sum = 0 \n  lst.each\
    \ { |x| sum += x * x } \n  sum\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`lst.map!{\
    \ |x| x.round(0) }` can be simplified to `lst.map(&:round)`.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nRuby has many cool methods that may come in handy.  For example, you can\
    \ apply your sum method on every element in the list without needing a loop, like\
    \ this:\n<code>\nlst = [ -3.141592653589793, 2.718281828459045, 1.4142135623730951,\
    \ 0 ]", "    sum_=0\n    count_=0\n    sum_of_square=0\n    for i in lst\n   \
    \     count_+=1\n        sum_+=i**2\n    end\n    sum_of_square=sum_\n    sum_of_square=sum_of_square**0.5\n\
    \    return sum_of_square\nend", "  squares = lst.map { |x| x * x }\n  sum = squares.inject(:+)\n\
    \  return sum\nend", "  lst.each do |i|\n    i = i / 2.0\n    i = i.upround(10)\n\
    \    sum+= i ** 2\n  end\n  sum\nend", "  lst.each do |e|\n    e.to_s.ljust(8,\
    \ '0').to_i\n  end\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nCan you\
    \ explain why `[2,3,2].map(&:to_i)` does not work?\n<|/ c |>\n<| c |>\nThat does\
    \ not work, because `map` expects something that responds to `to_i`. I thought\
    \ I read somewhere that `&:to_i` is an equivalent for writing `method(:to_i).to_proc`.\
    \ Since `method(:to_i)` returns a `Method`, this doesn't work. [Here](http://stackoverflow.com/a/19887995/6381711)\
    \ is the explanation of that syntax. Using `(&:to_i)` works in your example, but\
    \ only if `to_i` is defined on `Fixnum`.\n<|/ c |>\n<| a dscore=0 |>\nThis problem\
    \ can also be solved using Enumerable#inject:\n<code>", "  # your code goes here\n\
    \  sum = 0\n  lst = lst.sort\n  for i in 0...lst.length\n    sum += Math.ceil(i)*Math.ceil(i)\n\
    \  end\n  return sum\nend\n</code>\n<|/ a |>\n<| c |>\nIt would make more sense\
    \ to pass the list to `sort_by`.\n<|/ c |>\n<| c |>\nSorry, what do you mean?\n\
    <|/ c |>\n<| c |>\n`sort_by` returns a new list, while `sort` modifies the existing\
    \ list. As `sort` modifies the list, it must be done before `sort_by` returns.\n\
    <|/ c |>\n<| a dscore=0 |>\nUsing Ruby's built-in map and inject functions:\n\
    <code>", "  lst.each_with_index do |n,i|\n    lst[i] = round(lst[i])\n  end\n\
    \  lst.reduce(:+)\nend\n</code>\n<|/ a tags=ruby,arrays,sum dscore=0 |>\n<| a\
    \ dscore=0 tags=ruby,arrays,sum |>\n<code>", "  sum = 0 \n  lst.each do |i|\n\
    \    sum += i ** 2\n  end\n  sum\nend\nprint sum_squares([1,2,3])\nprint sum_squares([1,4,9])\n\
    print sum_squares([1,3,5,7])\nprint sum_squares([1.4,4.2,0])\nprint sum_squares([-2.4,1,1])\n\
    print sum_squares([0,2,0])\nprint sum_squares([3,4,5])\nprint sum_squares([-4,-2,2,1])\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nThis would have worked, except for the fact\
    \ that in Ruby 1.9.x the `each` method is defined on Enumerable instead of Array,\
    \ so the code would have failed there. If we change `each` to `each_index` your\
    \ code will work, but if we're using Ruby 1.8.x, it won't.\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere's another way to do it (I'm sure there's a better one, but this is\
    \ my first real Ruby program!)\n<code>", "  sum = 0\n  for i in lst\n    sum +=\
    \ i**2 # Sum up the squares\n  return sum\nend\n</cell>\n<code language=julia-0.5>\n\
    sum_squares([1,2,3])\n</cell>\n<code language=julia-0.5>\nsum_squares([1,4,9])\n\
    </cell>\n<code language=julia-0.5>\nsum_squares([1,3,5,7])\n</cell>\n<code language=julia-0.5>\n\
    sum_squares([1.4,4.2,0])\n</cell>\n<code language=julia-0.5>\nsum_squares([-2.4,1,1])\n\
    </cell>\n<code language=julia-0.5>", "  lst.map { |e| Math.ceil(Math.log10(e)).zero?\
    \ ? e * e : Math.ceil(Math.log10(e)).zero? ? Math.ceil(e) * Math.ceil(e) : Math.ceil(Math.log10(e)).zero?\
    \ ? Math.ceil(e) * Math.ceil(e) : Math.ceil(Math.log10(e)).zero? ? Math.ceil(e)\
    \ * Math.ceil(e) : Math.ceil(Math.log10(e)).zero? ? Math.ceil(e) * Math.ceil(e)\
    \ : Math.ceil(Math.log10(e)).zero? ? Math.ceil(e) * Math.ceil(e) : Math.ceil(Math.log10(e)).zero?\
    \ ? Math.ceil(e) * Math.ceil(e) : Math.ceil(Math.log10(e)).zero? ? Math.ceil(e)\
    \ * Math.ceil(e) : Math.ceil(Math.log10(e)).zero? ? Math.ceil(e) * Math.ceil(e)\
    \ : Math.ceil(Math.log10(e)).zero? ? Math.ceil(e) * Math.ceil(e) : Math.ceil(Math.log10(e)).zero?\
    \ ? Math.ceil(e) * Math.ceil(e) : Math.ceil(Math.log10(e)) }.reduce(:+)\nend\n\
    </code>\nThe code can be found here: \nhttp://rosettacode.org/wiki/Square_root_of_a_list#Ruby\n\
    <|/ a dscore=2 |>\n<| c |>\nHi Sasuke, I think you forgot to post the source link\
    \ for the solution :D It would be nice if people who come across this post could\
    \ see your solution and maybe even comment on it :)\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>", "  lst.map! { |e| e.to_f }\n  lst.sort!\n  lst.map! { |e| e.ceil }\n\
    \  lst.inject(0) { |sum, e| sum + e * e }\nend", "    sum = 0\n    lst.each do\
    \ |x|\n        sum += (x*x)\n    end\n    return sum\nend\n</cell>\n<cell>", " \
    \ lst.map! do |x| \n     x.round\n     x*x\n  end\n  lst.inject {|sum, element|\
    \ sum+element} \nend", "  sum = 0\n  for i in lst.each{|x| sum += x.round(0) }\n\
    \  return sum\nend", "  sum = 0\n  lst.map!{|x| x = Math.ceil(x) if x.kind_of?\
    \ Float ? x : x.to_i}\n  lst.each {|x| sum += x ** 2}\n  sum\nend", "  return\
    \ lst.inject(:+).reduce(:*) + lst.map {|n| n.ceil}.inject(:+).reduce(:*)\nend",
  "  lst.each_with_index {|value, index| value.round(5)}\n  lst.each_with_index {|value,\
    \ index| value.ceil}\n  lst.map {|x| x**2}.reduce(:+)\nend", "  sum = lst[0] *\
    \ lst[0]\n  for i in 1 ... lst.count\n    sum += lst[i] * lst[i]\n  end\n  sum\n\
    end", "  sum = 0\n  lst.each_with_index do |item, index|\n    sum = sum + (item.ceil\
    \ ** index) * item\n  end\n  return sum\nend", "  arr.each do |x|\n    arr.each\
    \ do |y|\n      x.to_f + (y.to_f * y.to_f)\n    end\n  end\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThis is an improvement on the `each_cons` implementation\
    \ that I was writing but this does not return the correct result. For `[-2.4,1,1]`\
    \ the result is `-6` rather than `-6.0`\n<|/ c |>\n<| c |>\nYour code is wrong\
    \ because it returns `6` for your test case and your explanation. I suggest you\
    \ review the question again\n<|/ c |>\n<| c |>\nThis is an improvement on the\
    \ `each_cons` implementation that I was writing but this does not return the correct\
    \ result. For `[-2.4,1,1]` the result is `-6` rather than `-6.0`\n<|/ c |>\n<|\
    \ c |>\nHow is this not correct? I am returning the square of x (which is 1) plus\
    \ the square of y which is 1, and adding them together. The result is 6, which\
    \ is what you are getting for your test case\n<|/ c |>\n<| c |>\nThe OP has edited\
    \ the question, where they have made an incorrect assumption that the list must\
    \ be rounded up to the next integer. Remember that the question asks for the sum\
    \ squared of each number in the list, not the sum squared of each squared number.\
    \ `[1.4, 4.2, 0.0]` should be `[6.0, 29.0, 0.0]`\n<|/ c |>\n<| a tags=ruby,arrays,loops\
    \ |>\nUsing each_cons would also work\n<code>", "  sum = 0\n  lst.each do |x|\n\
    \    sum += x*x\n  end\n  sum.round\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    I guess this could be the simplest way to do this in Ruby. This works, but I find\
    \ it strange that there's no built-in way in Ruby to find the ceiling of an integer.\n\
    <|/ c |>\n<| c |>\nThe built-in way (that works in both 1.8.7 and 1.9.3) is `Math.ceil`.\
    \ No sense in reinventing the wheel!\n<|/ c |>\n<| c |>\nOkay, I guess I've been\
    \ going at Ruby too long. Thanks.\n<|/ c |>\n<| a dscore=5 |>\nIf you're not allowed\
    \ to use #map, #inject, or the #sum method:\n<code>", "  sum_squares = 0\n  lst.each\
    \ do |num|\n    sum_squares += num * num\n  end\n  return sum_squares\nend", " \
    \ sum = 0\n  lst.each do |x|\n    sum += (x + x).round\n  end\n  sum\nend", " \
    \ sum = 0\n  for i in lst.sort\n    sum += i ** 2\n    Math.ceil(i)\n  end\n \
    \ sum\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 tags=ruby |>\n<code>",
  "    sum = 0\n    largest = lst[0]\n    lst[0] = lst[0].ceil\n    sum = 0\n    count\
    \ = 0\n    sq = 0\n    while count < lst.size\n        if lst[count].to_i > largest.to_i\n\
    \            largest = lst[count]\n            sum = sq\n            sq = 0\n\
    \            count = count+1\n        else\n            sq = sq + lst[count].to_i**2\
    \ \n            count = count+1\n        end\n    end\n    lst[0] = largest\n\
    \    sum.to_i\nend\n</code>\n<|/ a dscore=2 tags=ruby,algorithm |>\n<| a dscore=2\
    \ tags=ruby,algorithm |>\nI like that other guy that wrote the code for you, so\
    \ I figured I'd give it a shot.  \n<code>", "  num = 0\n  lst.each do |number|\n\
    \    num +=number ** 2\n  end\n  return num\nend", "    sum = 0\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
