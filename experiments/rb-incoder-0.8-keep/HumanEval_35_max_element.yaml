name: HumanEval_35_max_element
language: rb
prompt: "# Return maximum element in the list.\n# >>> max_element([1, 2, 3])\n# 3\n\
  # >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n# 123\ndef max_element(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_element\n\
  \    candidate = method(:max_element)\n    assert_equal(3, candidate.call([1, 2,\
  \ 3]))\n    assert_equal(124, candidate.call([5, 3, -5, 2, -3, 3, 9, 0, 124, 1,\
  \ -10]))\n  end\nend\n"
completions: ["    l.sort!\n    l.last\nend", "  l.sort!\n  l.last || l.pop\nend",
  "  l.sort\n  l.last || l.min\nend", "  return l.max {|a, b| a <=> b}\nend", "  l.max\n\
    end", "  l.sort!\n  l.first\nend", "  return l.max_by{ |e| -e}\nend", "    l.sort.max\n\
    end", "  l.sort\n  l.last\nend\n</code>\n<|/ a dscore=5 tags=ruby,sorting,arrays\
    \ |>\n<| a dscore=5 tags=ruby,sorting,arrays |>\nIf you want a solution that's\
    \ just as fast as the accepted answer, you could also use\n<code>\nmy_array.reduce(0)\
    \ { |max, x| max > x ? max : x }\n</code>\nThis is not really a sort algorithm;\
    \ it's just an algorithm that returns the max value in the array (or the initial\
    \ value if all are equal).\n<|/ a |>\n<| a dscore=4 tags=ruby,sorting,arrays |>\n\
    For those looking for efficiency and performance, there is another option that\
    \ I found very helpful. Using Ruby 2.4.0 I compared three methods: reduce, inject,\
    \ and max, and found that max is about twice as fast as inject and reduce and\
    \ about twice as fast as each.\n<code>", "  l.sort!\n  l.last\nend", "  l.sort!\n\
    \  l.last\nend", "  l.sort.max\nend", "  return l.max\nend", "  l.sort!\n  l.last\n\
    end", "  l.sort!\n  l.last\nend", "  l.sort.max\nend", "  l.sort.last\nend", " \
    \ return l.max_by { |e| e } if l && l.length > 0\n  nil\nend", "  l.max\nend",
  "  if l.size == 0\n    raise ZeroDivisionError\n  l.sort!\n  last= l[0]\n  max=\
    \ l[0]\n  for i in 1..l.size\n    if l[i] > max\n      max= l[i]\n    end\n  \
    \  if l[i] != last\n      last= l[i]\n    end\n  end\n  return max\nend", "  l.sort\n\
    \  l[l.length-1]\nend", "  l.sort!\n  l.first\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\nAs I said in my comment to Alexey, Ruby 2.5.0 will have a max_by\
    \ method. It will probably be as close as we can get to what we want and we can\
    \ use that to improve the efficiency of the solution suggested here by Jose Valim.\n\
    <|/ a tags=ruby |>\n<| a dscore=1 |>\nI made a solution to solve the problem:\n\
    <code>\narray = [10, 1, 23, 23, 2, 3, 4, 6, 3, 10, 5, 11, 7, 13]\narray.sort_by{|n|\
    \ n}.reverse\n</code>\nIt sorts the array first by its value, then by its index,\
    \ finally it reverses the results.\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nRuby\
    \ 2.5 added a max_by method, which is supposed to do exactly what you want to\
    \ do:\n<code>\n> array = [10, 1, 23, 23, 2, 3, 4, 6, 3, 10, 5, 11, 7, 13]\n> array.max_by\
    \ { |x| x }\n=> 23\n> array.max_by { |x| x }.reverse\n=> 23\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby |>\nIn ruby 2.2 you can do\n<code>\narray.sort do |a,b| \n\
    \  if a > b then 1 \n  else \n    if a < b then -1\n    else a \n    end\n  end\n\
    end\n</code>\nAnd then to get the maximum, you can use maximum\n<code>\narray.sort\
    \ do |a,b| \n  if a > b then 1 \n  else \n    if a < b then -1\n    else a \n\
    \    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't do what\
    \ the OP asks for. `[10,1,22,23,2,3,4,6,3,10,5,11,7,13].sort { |a, b| b <=> a\
    \ } == [10,1,23,23,2,3,4,6,3,10,5,11,7,13]`. Your code is just sorting the array\
    \ without taking into account the ordering.\n<|/ c |>\n<| c |>\nYes, I saw that.\
    \ But that does not mean the OP does not know how to write a comparator. Of course\
    \ it depends on the use-case, but for most use cases, it is what they asked for,\
    \ so my answer is valid.\n<|/ c |>\n<| c |>\nHaving said that, this answer is\
    \ useful to people who want to sort an array based on the order of its ", "  l.sort\n\
    \  l.last\nend", "  l.max\nend", "  l.max\nend", "  l.sort.last\nend", "  l.sort\n\
    \  l.last\nend", "  l.sort_by! { |x| x.to_f }\n  l.last\nend", "  l.sort!\n  l.first\n\
    end", "  l = l.dup\n  l.sort!\n  l[-1]\nend", "  return l.max\nend", "  l.max_by\
    \ { |x| x } or l.last\nend", "  return l.max_by { |i| i } if l.is_a?(Enumerable)\n\
    \  m = l.max\n  l.each_index {|i| m[i] = l.max_by { |j| j }[i]}\n  m\nend", " \
    \   l.sort!\n    l.max\nend", "  l.sort\n  l.last\nend", "  l.max_by { |x| x }\n\
    end", "  l.sort!\n  l.last\nend", "  l.sort!\n  l.max_by { |v| v }\nend", "  l.sort!\n\
    \  l.min\nend", "  return l[l.index(l.max_by{ |x| x.abs})]\nend", "  l = l.sort\n\
    \  max_value = l.pop\n  l.each_with_index { |e, i| max_value = i if e > max_value\
    \ }\n  max_value\nend", "\tl.sort\n\tl.first\n\tl.last\n\treturn l[-1]\nend",
  "  l.sort!\n  l.first\nend", "  l.sort.last\nend", "  l.sort { |a, b| b <=> a }[0]\n\
    end", "  l.sort!\n  l.max\nend\n</code>\n<|/ a |>\n<| c |>\nThis is not the answer\
    \ to what the OP asked.\n<|/ c |>\n<| a dscore=4 |>\n<code>\n[1,2,3,4,5].max",
  "  l.sort\n  l.last\nend", "  return l.max_by { |e| e }\nend", "  return l.max_by(&:last)\n\
    end", "  l.sort.max_by { |x| x }\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\nHere's a variation of Eric's solution that avoids iterating over the list\
    \ twice (O(n) instead of O(n^2)). It also allows us to pass arbitrary comparators\
    \ and handles nil (as nil will break the sort). \n<code>", "  l.sort!\n  l.last\n\
    end", "  l.sort!\n  l.pop\nend", "  l.sort!\n  l.last\nend", "  return l.max\n\
    end", "    l.sort!\n    return l[-1]\nend", "  return l.max\nend", "  if l.empty?\n\
    \    nil\n  else\n    l.pop\n  end\nend", "  l.sort.reverse!\n  l[0]\nend", " \
    \ l.sort\n  l.last\nend", "  l.max\nend", "  l.sort!\n  l.first\nend", "  l.inject(0,\
    \ :+) # => 0\n  l.find { |e| e > 0 } # => 0\n  l.find { |e| e < 0 } # => nil\n\
    end", "  l.sort!\n  l.first\nend", "  return l.max\nend", "  l.sort.reverse\n\
    \  l.last\nend", "  l.sort!\n  l.last\nend", "  l.sort!\n  l.last\nend", "  if\
    \ l.empty?\n    nil\n  else\n    l.max_by { |i| i }\n  end\nend", "  l.sort {\
    \ |a, b| b == a ? 0 : a > b ? 1 : -1 }\n  l.last\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby |>\n<| c |>\nThe above is really great! I've just spent 2 days trying\
    \ to figure out why my code was only returning the first element of the list.\
    \ Your solution made it work perfectly. Thanks a million!\n<|/ c |>\n<| c |>\n\
    You shouldn't be using that solution. While it is true that `sort` is an inplace\
    \ operation (the sort is done in place), it does not guarantee that the result\
    \ will be in the same order. If you want to find the minimum element instead of\
    \ the maximum, use the solution suggested by Joe Z. https://stackoverflow.com/a/12553684/184899\n\
    <|/ c |>\n<| c |>\nActually, you should not use `min_element` in the way you did\
    \ (you used `min` instead of `min_element`). `min` will work fine with integers,\
    \ but will fail with anything that is not a number such as `\"10\"`. A better\
    \ implementation is `l.max_by(&:abs)`\n<|/ c |>\n<| c |>\nFor completeness, you\
    \ might want to mention that this works for strings as well.\n<|/ c |>\n<| c |>\n\
    It's `max_by`, not `min_by`. And, yes, strings are fine.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=1 |>\nThis is an old post but i needed a solution for Ruby 2.0 and my\
    \ solution was as follows:\n<code>", "  l.sort\n  l.last\nend", "  l.sort.max\
    \ || l[0]\nend", "  if l.empty?\n    raise ArgumentError, \"List is empty\"\n\
    \  end\n  l.sort!\n  l.last\nend", "  l.max_by{ |e| e }\nend", "  l.sort!\n  l.pop\n\
    \  l[0]\nend\n</code></pre>", "  l.sort!\n  l.last\nend", "  return l.max_by {\
    \ |e| e }\nend\n</code>\n<|/ a dscore=4 |>\n<| a tags=ruby |>\nTry this:\n<code>",
  "  l.sort {|x, y| y <=> x }\n  l[-1]\nend", "  l.sort.max\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays\
    \ |>\n<| a tags=ruby,ruby-on-rails,arrays |>\nHere is a simple solution:\n<code>\n\
    array = [1, 2, 3, -10, 5, -10]\narray.max_by { |x| x.to_i } # returns -10\narray.max_by\
    \ { |x| x.to_s } # returns -10\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis should\
    \ be the accepted answer. While the other answers are good, this one should be\
    \ the accepted answer since it works with all data types and is simple.\n<|/ c\
    \ |>\n<| c |>\n, your comment is worth an upvote because this is exactly what\
    \ I was looking for. `max_by` is the perfect tool for this sort of thing.\n<|/\
    \ c |>\n<| c |>\nThis also works with strings: `array.max_by { |x| x.to_s }`.\
    \ Thanks!\n<|/ c |>\n<| c |>\nI think you should `array.max_by { |x| x.to_i }`\
    \ because the largest number will be 10 and you won't get the result you want.\n\
    <|/ c |>\n<| c |>\nYes you are right. Thanks for pointing that out.\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails,arrays dscore=4 |>\nRuby 2.1.2 introduced max_by\
    \ method in Array. This can be used as:\n<code>\nirb(main):001:0> array = [-10,\
    \ 5, 10, 20]\n=> [-10, 5, 10, 20]\nirb(main):002:0> array.max_by\n=> -10\nirb(main):003:0>\
    \ array.max_by { |e| e }\n=> 20\nirb(main):004:0> array.max_by { |e| e.to_f }\n\
    => 20\nirb(main):005:0> array.max_by { |e| -e.abs }\n=> 20\nirb(main):006:0> array.max_by\
    \ { |e| -e.abs }\n=> 20\nirb(main):007:0> array.max_by { |e| -e.abs }\n=> 20\n\
    </code>\n<|/ a |>\n<| a dscore=3 tags=ruby,ruby-on-rails,arrays |>\nRuby 2.4.2\
    \ introduced max_by method for Enumerable class.\n<code>\narray = [-10, 5, 10,\
    \ 20]\narray.max_by { |", "  l.max\nend", "  return l.max_by{ |i| i }\nend", " \
    \   l.each_index do |i|\n        return l[i] if l[i] > l[i-1]\n    end\n    return\
    \ nil\nend", "  return l.max_by{|v| v}\nend", "  l.sort\n  l.last\nend", "  return\
    \ max_element_index(l)\nend", "  l.sort.last l\nend", "  l.sort!\n  l.max_by{|e|\
    \ e}\nend", "  l.sort!\n  l.last == l[0] ? l[0] : l[l.index {|x| x > l[0]}]\n\
    end", "  if l.empty?\n    nil\n  else\n    l.reduce(:>)\n  end\nend", '    l.sort!',
  "  if l.empty?\n    throw :empty_list\n  else\n    max = l[0]\n    l.each {|x| max\
    \ = x if x > max }\n    max \n  end\nend", "  return l[l.find{|x| x > l.max}[-1]]\n\
    end", "  l.max_by { |x| x }\nend", "  l.sort\n  l.last\nend\n</code>\n<|/ a tags=ruby,list\
    \ |>\n<| c |>\nIt doesn't work. It gives an error `undefined method 'last' for\
    \ nil:NilClass`\n<|/ c |>\n<| c |>\n, sorry, it was a typo, should be `sort`\n\
    <|/ c |>\n<| c |>\nIt works well! But I wonder why it gives an error on l.last\
    \ while it works well on l.sort. Thank you for your answer and for pointing it\
    \ out!\n<|/ c |>\n<| c |>\n, `sort` mutates the original array and returns nil\
    \ when it is finished sorting (last is nil) and `last` is an alias for `last`,\
    \ which returns the last element of array, not nil\n<|/ c |>\n<| c |>\nThank you\
    \ very much! I learned a lot from you! Thanks for your time and patience.\n<|/\
    \ c |>\n<| a tags=ruby,list |>\n<code>", "  l.sort\n  l.last\nend", "  l.sort!\n\
    \  l.max\nend", "  if l.empty?\n    nil\n  else\n    l.sort\n    l.last\n  end\n\
    end", "  l.sort.last\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nRuby is a very\
    \ good language, with very few syntactic sugar. Why do you keep suggesting \"\
    loops\"?\n<|/ c |>\n<| c |>\n`each` is an iterator method, not a loop.\n<|/ c\
    \ |>\n<| c |>\nIt is, and it isn't. `each` is perfectly capable of iterating over\
    \ collections, including arrays. It's just that `each` methods return `self` instead\
    \ of mutating the collection they were called on.\n<|/ c |>\n<| c |>\nIt's not\
    \ a loop, it's an iterator. See http://www.ruby-doc.org/core/classes/Enumerable.html#M000538.\n\
    <|/ c |>\n<| a dscore=4 |>\nIt appears that this has been implemented in 1.9.2\
    \ with the Enumerable module:\n<code>\nmax_element([1, 2, 3])", "  l.max_by {\
    \ |x| x }\nend", "  l.sort { |x, y| y <=> x }\n  l[-1]\nend", "  l.sort!\n  l[-1]\n\
    end", "  l.sort\n  l.last\nend", "  l.sort.max_by { |i| i }\nend", "  l.sort!\n\
    \  l.reverse!\n  l.last\nend", "  l = l.sort\n  max_value = l.pop\n  max_value\n\
    end", "  l.inject(0) { |max, x| x.max > max ? x : max}\nend\n</code>\n<|/ a dscore=4\
    \ tags=ruby,algorithm,big-o |>\n<| c |>\nI love this solution. Unfortunately,\
    \ the [benchmark results here seem to indicate that `max_element` is as fast as\
    \ `max_by`](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/benchmark/rdoc/Benchmark.html)\n\
    <|/ c |>\n<| c |>\nThe benchmarks appear to have been run on an older version\
    \ of Ruby, which was the issue for me (Ubuntu 10.04 LTS).  I've now updated to\
    \ the latest version (1.9.2) and ran the benchmarks again, and `max_element` is\
    \ as fast as `max_by`.  So the real issue is probably my version of Ruby.  Thanks\
    \ for your help.\n<|/ c |>\n<| a tags=ruby,algorithm,big-o |>\nA naive implementation:\n\
    <code>\nrequire 'benchmark'", "  return max_or_min(l, max)\nend", "    l.compact.max\n\
    end", "  l.sort.reverse\n  l.inject(0) { |a, x| x > a ? x : a}\nend", "  l.max_by\
    \ { |e| e }\nend", "  if l.empty?\n    nil\n  else\n    l.max_by { |x| x }\n \
    \ end\nend", "  l.compact.max\nend", "    l.sort # Sort the list.\n    max_element\
    \ = l[-1]\n    l.delete max_element # Remove the maximum element.\n    if l.empty?\n\
    \      nil\n    else\n      max_element\n    end\nend", "  l.sort!\n  l[-1]\n\
    end", "  l.sort!\n  l.max\nend", "  l.sort.max\nend", "  l.inject(0) do |max,\
    \ x|\n    return max if x  > max\n    max\n  end\nend", "  return l.max(&:last)\n\
    end", "  return l.max_by { |n| n }\nend", "  return max_by{|x| x}(l,&:abs)\nend\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nI like that answer and it works, but a more\
    \ elegant implementation is often not possible.\n<|/ c |>\n<| c |>\nThe last line\
    \ should be `max_by(&:abs)`.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  l.inject(0)\
    \ { |max_value, element| max_value <=> element }\nend\n</code>\n<|/ a dscore=5\
    \ tags=max,arrays,ruby,min |>\n<| c |>\nThanks, this is the best answer here,\
    \ and also by far the easiest to read. Works in both versions 1.8.7 and 1.9.3\n\
    <|/ c |>\n<| c |>\nIn addition, this works with Ruby 1.9.2, but not 1.8.7, as\
    \ it uses inject.\n<|/ c |>\n<| c |>\nIn Ruby 1.9.2 you can use `max_by` as in\
    \ `max_element = l.max_by(&:last)`.\n<|/ c |>\n<| a |>\nSlightly more concise\
    \ than the above answers:\n<code>\nl = [3, -5, 4, 3, -5]\nl.max_by {|e| e}\n=>\
    \ -5\n</code>\n<|/ a dscore=5 tags=max,arrays,ruby,min |>\n<| c |>\nAs of Ruby\
    \ 2.2 this answer works with `l = [3, -5, 4, 3, -5]` and still returns an integer,\
    \ instead of `nil`.\n<|/ c |>\n<| c |>\nWorks perfectly for me on Ruby 2.4.2.\
    \ Thanks!\n<|/ c |>\n<| a tags=max,arrays,ruby,min dscore=5 |>\nIn Ruby 2.1+:\n\
    <code>\nl = [3, -5, 4, 3, -5]\nl.max_by(&:abs)", "  return l.max { |a, b| a.nil?\
    \ || a.<(b || 0) }\nend", "    l.sort!\n    l.last\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThe `max_element` function is extremely inefficient and should\
    \ not be used on large lists.\n<|/ c |>\n<| c |>\n, thank you for the comment,\
    \ please see my updated answer.\n<|/ c |>\n<| c |>\n`sort_by` is now deprecated\
    \ (see my answer). `sort_by!` will work fine.\n<|/ c |>\n<| a |>\nFor people who\
    \ want to know the most efficient way of doing this in Ruby, here it is in Rails:\n\
    <code>\narr = [1, 2, 3, 4, 5]\narr.max_by { |i| -(i + 1) } # => 4\n</code>\nIt\
    \ will sort the array and then just return the last item, so you don't need to\
    \ sort it at all. Sorting every time is costly and unnecessary.\n<|/ a tags=ruby,sorting\
    \ dscore=2 |>\n<| a dscore=2 |>\nIf you need the largest number in the array (which\
    \ should be the largest, not the smallest), then use max with a block, like so:\n\
    <code>\nmax = array.max{|a,b| a <=> b}\n</code>\n<|/ a tags=ruby,sorting |>\n\
    <| a |>\nI find the following solution very elegant, and it works for an array\
    \ containing negative and positive numbers:\n<code>\narray = [-9, 4, -2, 2, 4,\
    \ -4, -4]\narray.max_by { |el| el == array.min? ? -1 : el }\n</code>\nIt also\
    \ works for an array containing all zeros (which can be compared to any positive\
    \ number), but only when the array contains at least one positive number.\n<|/\
    \ a dscore=2 tags=ruby,sorting |>\n<| c |>\nIt's only worthwhile when the array\
    \ contains only positive numbers. When it contains only zeros, `array.min?` will\
    \ return `false`, so the block will still return the first element (`-el` will\
    \ return `-9`).\n<|/ c |>\n<| c |>\nYes, that's why I said: *It also works for\
    \ an array containing all zeros (which can be compared to any positive number),\
    \ but only when the array contains at least one positive number*\n<|/ c |>\n<|\
    \ a |>\nA simple way is to simply return the last element:\n<code>\narray.sort[-1]\n\
    </code>\n<|/ a tags=ruby,sorting dscore=2 |>\n<| a dscore=2 |>\n<code>", "   \
    \ l.sort.reverse\n    l.max\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails dscore=3\
    \ |>\n<| a tags=ruby,ruby-on-rails dscore=2 |>\nHere are two ways you can find\
    \ the max of some enumerable:\n<code>\n[1,2,3,4,5].max #=> 5\n[5,2,3,5,2,1].max\
    \ #=> 5\n</code>\n<|/ a |>\n<| a dscore=1 |>\nUsing Enumerable is a great way\
    \ to solve this problem.\nBut if you're not using an Array then you may try this:\n\
    <code>", '  l.sort!', "  l.sort { |a, b| b < a ? -1 : a > b ? 1 : 0 }\n  l.first\n\
    end", "  l.max_by{ |x| x }\nend", "  l.sort!\n  l.last\nend", "  l.inject {|a,\
    \ b| b > a ? b : a }\nend", "  if l == []\n    puts \"List is empty\"\n  else\n\
    \    maxVal = l[0]\n    for element in l\n      if element > maxVal\n        maxVal\
    \ = element\n      end\n    end\n    maxVal\n  end\nend", "  return l.max\nend",
  "  return max_element(l, 0) or 0\nend", "  return l[-1] if l else nil\nend", " \
    \ return l.inject(:>=).reduce(:<)\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ dscore=0 |>\nJust in case someone wants to get the max element in a nested array\
    \ without using inject/reduce like I did:\n<code>", "  l.sort!\n  l.first\nend\n\
    </code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nI like it, but it doesn't work if\
    \ l = [1, 2, 3, 10, 4] because 10 is less than all subsequent items. But it's\
    \ easy to make it work, if you want.\n<|/ c |>\n<| c |>\nThis fails for `l = [1,\
    \ 10, 3, 10, 4]`. I wonder if it could be made to work.\n<|/ c |>\n<| c |>\nThe\
    \ [documentation for Enumerable#max_by](http://www.ruby-doc.org/core-2.1.1/Enumerable.html#method-i-max_by)\
    \ says that `max_by` should return the first element with the highest value. But\
    \ it doesn't.\n<|/ c |>\n<| a tags=arrays,ruby |>\nHere's a solution using Enumerable#max_by.\
    \ It doesn't require sorting.\n<code>", "  l.max\nend", "  l.max\nend", "  l.sort\n\
    \  l.last\nend", "  l = l.sort\n  l.last\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ is nice, but will it work for non-numeric elements?\n<|/ c |>\n<| c |>\nYes,\
    \ but you would have to change the comparison operator to return \"true\" or \"\
    false\" for non numeric values.\n<|/ c |>\n<| a dscore=1 tags=ruby,sorting |>\n\
    <code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13]\n</code>\nI suggest this:\n<code>\n\
    a.sort { |a,b| a <=> b }.last\n=> 13\n</code>\n<|/ a |>\n<| c |>\nI see that your\
    \ method is the most popular, and it works in all situations. But it is very long\
    \ for a very small task. And the other answers have some advantages: shorter code,\
    \ one line instead of two and better performance. Thank you for your answer.\n\
    <|/ c |>\n<| c |>\nThe performance of other methods would be negligible for such\
    \ a small task. You need to run a benchmark to see which one performs better.\
    \ I only posted mine because it's the shortest method and your question was not\
    \ about \"short code\".\n<|/ c |>\n<| c |>\nIf you're going to use `sort`, you\
    \ should be using `sort_by`.\n<|/ c |>\n<| a dscore=0 tags=ruby,sorting |>\nFor\
    \ a purely numerical array, you can use the Array#max method:\n<code>\na = [10,2,-5,3,8,1,2,6,4,-6,2,3]\n\
    a.max", "  if l[0] && l[0].class\n    l.sort_by {|e| -e}\n    l.last\n  else\n\
    \    l.max\n  end\nend", "  l.max_by { |x| x }\nend\n</code>\n<|/ a tags=ruby-on-rails-3,ruby-on-rails,ruby\
    \ dscore=4 |>\n<| c |>\nI didn't try the max_by method because I assumed it was\
    \ a Rails method, but that works great. Thanks!\n<|/ c |>\n<| a |>\nYou can use\
    \ this code too:\n<code>", "  return l.max_by { |el| el } if l && l.respond_to?(:max_by)\n\
    \  nil\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is great, but be aware\
    \ that this modifies the original array and will result in memory blowup on larger\
    \ arrays. In some cases it may be undesirable.\n<|/ c |>\n<| c |>\nThat's only\
    \ a problem if you're using Ruby 1.9. Ruby 2.0 will have `max_by!` (http://www.ruby-doc.org/core-2.0/Array.html#method-i-max_by!).\n\
    <|/ c |>\n<| c |>\nJust a quick comment for people like me that came here because\
    \ \"undefined method `max_by' for #<Array:0x007f80e37552c0>\" \nThe method name\
    \ is max_by! instead of max_by\n<|/ c |>\n<| c |>\nAlso note that it can take\
    \ a block to determine which element you want to use. `max_by { |el| el.to_s }`\
    \ is probably the easiest way to get the greatest number from a collection of\
    \ strings.\n<|/ c |>\n<| c |>\n- If you're using `max_by`, you probably need to\
    \ add `el` to the end of the block, eg: `max_by { |el,x| x.to_s }`.\n<|/ c |>\n\
    <| a |>\nRuby has max_by method that does exactly what you need:\n<code>\n[4,2,1,3].max_by{|el|\
    \ el}\n=> 1\n</code>\n<|/ a tags=ruby dscore=5 |>\n<| c |>\nThis is what I was\
    \ looking for, no need to use sort_by and last.\n<|/ c |>\n<| c |>\nNote that\
    \ `max_by` mutates the array.\n<|/ c |>\n<| c |>\nIt doesn't return max value,\
    \ it returns max element (key)\n<|/ c |>\n<| c |>\nYou also need `sort_by` if\
    \ you want the element (key)\n<|/ c |>\n<| c |>\nThis answer is wrong. `max_by`\
    \ is for elements and not for keys. It returns the element with the highest key\
    \ value\n<|/ c |>\n<| a tags=ruby |>\nThis works for me in Ruby 1.9.3\n<code>",
  "  return l.compact.max\nend", "  return l.max\nend", "  l.max_by { |e| e }\nend",
  "  l.max\nend", "  l.sort!\n  l[0]\nend", "  return l.max_by{|x| x}\nend", "  l.max_by{\
    \ |e| e } || l[0]\nend", "  l.max\nend", "  return l.max\nend", "\tl.sort\n\t\
    l.last\nend", "  l.compact.max\nend", "  l.sort do |a, b|\n    a > b ? a : b\n\
    \  end\n  l[0]\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays,ruby-on-rails |>\n\
    <| c |>\nJust curious: why would you use `.sort` rather than `.max_by`?\n<|/ c\
    \ |>\n<| c |>\nBecause [`max_by`](http://apidock.com/rails/Enumerable/max_by)\
    \ works on multiple keys. `max_by` would return the first value that matches the\
    \ key. `sort` sorts the elements and then returns the first element.\n<|/ c |>\n\
    <| a dscore=0 |>\nThis should do it:\n<code>", "  l.sort.reverse!\n  l.first ?\
    \ l.reduce(&:<=>) :\n    l.find { |x| x >= l.first }\nend", "  l.max\nend", " \
    \ l.max\nend", "  l.sort.reduce(l)\nend", "  l.sort!\n  l.last\nend", "  # Initialize\
    \ max value\n  max = 0", "  return l.max_by(&:first)\nend", "    l.sort\n    l.last\n\
    end", "  # Initialize max to something.\n  max = l[0]", "  l.sort.max\nend\n</cell>\n\
    <code language=julia-1.5>", "  l.sort\n  l.last\nend", "  return l.max { |a, b|\
    \ a.to_i <=> b.to_i }\nend", "  return l.max\nend", "  if l.empty?\n    l.last\n\
    \  else\n    l.max_by{|e| e}\n  end\nend", "  l.sort!\n  l.last\nend", "    l\
    \ = l.sort\n    maxval = l[0]\n    for i in 0...l.size - 1\n        if l[i] >\
    \ maxval\n            maxval = l[i]\n    return maxval\nend", "\tl.max\nend",
  "  l.sort!\n  l.first\nend", "  return l.inject(0) do |m, e| m > e ? m : e\nend",
  "  if l.empty?\n    return nil\n  end\n  l.sort!\n  l.last\nend", "  l.sort { |a,\
    \ b| b > a }\n  l[-1]\nend", "  l.sort!\n  l.last\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby,arrays,hash |>\n<| c |>\nJust a nitpick: `max_element` isn't an [Array\
    \ method](http://www.ruby-doc.org/core-1.9.3/Array.html#method-i-max_element).\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  l.sort.reverse!\n  l.first\nend", "  l.sort!\n\
    \  l.last\nend", "  l.sort\n  l.last\nend", "  l.max\nend", "  if l.empty?\n \
    \   return nil\n  elsif l.size == 1\n    return l.first\n  end", "  return l.max_by(&:<=>).last\n\
    end", "  l.sort!\n  l.first\nend", "  return l.max_by { |x| x }\nend", "  return\
    \ l.max\nend", "  l.max\nend", "    l.sort\n    l.last || 0\nend", "    l.sort\
    \ do |a, b|\n        a > b ? -1 : b > a ? 1 : 0\n    end\n    l[-1]\nend", " \
    \ return l.max.call(l)\nend", "  return l.max { |a, b| a <=> b }\nend", "  l.sort!\n\
    \  max_val = l[0]\n  max_idx = 0", "  l.sort { |a,b| b<=>a }[0]\nend\n</code>\n\
    <|/ a tags=ruby,arrays,max,collections |>\n<| c |>\nIt's more efficient to call\
    \ `sort` instead of `sort!` because `sort!` will invoke `sort` anyway and mutate\
    \ `l`. See [this SO question](http://stackoverflow.com/questions/2554439/how-often-is-sort-preferable-to-sort-for-small-size-data-sets-in-ruby).\n\
    <|/ c |>\n<| c |>\nTo be honest, I wasn't expecting a huge performance difference\
    \ between `sort` and `sort!` on large arrays, but the docs do say \"If the argument\
    \ [to a method called `sort`] is modified, then the returned array is tainted.\"\
    \ So I tend to use that to avoid accidental changes to `l` from outside the `sort`\
    \ block. http://ruby-doc.org/core-1.9.3/Array.html#method-i-sort, http://stackoverflow.com/questions/2554439/how-often-is-sort-preferable-to-sort-for-small-size-data-sets-in-ruby\n\
    <|/ c |>\n<| c |>\nIn fact, `sort!` will modify the original array if its elements\
    \ are comparable and I didn't see anywhere in the docs that `sort` doesn't do\
    \ that. Looks like `sort` does modify `l`.\n<|/ c |>\n<| c |>\nI didn't know that\
    \ `sort` modified `l` if it was sortable (which is true here) so I wasn't sure\
    \ whether `sort!` also does that. I guess it's not really documented, but I suppose\
    \ `sort!` can make sense in situations where `sort` would have no effect.\n<|/\
    \ c |>\n<| c |>\nYeah, I agree that `sort!` could be useful in situations where\
    \ `sort` would have no effect. But it isn't really documented because it's really\
    \ easy to misunderstand what `sort!` does and what it does not. I'm glad you found\
    \ my answer useful.\n<|/ c |>\n<| a tags=ruby,arrays,max,collections |>\nA very\
    \ simple way:\n<code>", "  l.sort!\n  l.inject {|x, y| x > y ? x : y}\nend", " \
    \   l.sort!\n    l.last\nend", "  l.inject(0, &:>)\nend", "  l.max_by { |i| i\
    \ }\nend", "  if l.empty?\n    raise ArgumentError.new(\"Cannot find max element\
    \ of empty list\")\n  maxv = l[0]\n  l.each do |x|\n    maxv = x if x > maxv\n\
    \  end\n  maxv\nend", "  l.sort!\n  l.last\nend", "  if l\n    l.sort!\n    return\
    \ l.max\n  end\nend", "  # Initialize max to first element in list\n  max = l[0]\n\
    \  # Check rest of list for max element\n  for i in 1..l.length\n    if l[i] >\
    \ max\n      max = l[i]\n    end\n  end\n  return max\nend", "  l.max_by {|x|\
    \ x}\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
