name: HumanEval_18_how_many_times
language: rb
prompt: "# Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n# >>> how_many_times('', 'a')\n# 0\n# >>> how_many_times('aaa',\
  \ 'a')\n# 3\n# >>> how_many_times('aaaa', 'aa')\n# 3\ndef how_many_times(string,\
  \ substring)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_how_many_times\n\
  \    candidate = method(:how_many_times)\n    assert_equal(0, candidate.call(\"\"\
  , \"x\"))\n    assert_equal(4, candidate.call(\"xyxyxyx\", \"x\"))\n    assert_equal(4,\
  \ candidate.call(\"cacacacac\", \"cac\"))\n    assert_equal(1, candidate.call(\"\
  john doe\", \"john\"))\n  end\nend\n"
completions: ["  string = string.dup\n  substring = substring.dup\n  result = 0\n\
    \  len = string.length\n  sublen = substring.length\n  \n  sub = substring[0,\
    \ sublen]\n  \n  while string.length > 0 do\n    if string.slice(-sublen) =~ /^#{sub}/\
    \ then\n      result = result + 1\n      string = string.slice(0, -sublen)\n \
    \   end\n    \n    if string.length < sublen then\n      break\n    end\n  end\n\
    \  \n  result\nend", "  count = 0\n  string.gsub(substring) do |match|\n    count\
    \ += 1\n  end\n  count\nend", "  string = string.downcase\n  substring = substring.downcase\n\
    \  string.length\n  substring.length\n  string.count(\"a\") + string.count(\"\
    A\")\n  substring.length == 0 ? 0 : string.index(substring) + substring.length\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis code doesn't give the expected\
    \ result in some cases. \"abc\" and \"ab\" count as \"abc\".\n<|/ c |>\n<| c |>\n\
    Yeah, but that doesn't matter. Since he didn't specify what he wants, I chose\
    \ to answer his question as he asked.\n<|/ c |>\n<| c |>\nThe OP stated he wanted\
    \ a solution that would return 0 for \"abc\" and \"ab\". You gave the solution\
    \ with the condition that \"abc\" and \"ab\" would return 0. I think it would\
    \ be better if you wrote a solution that would give the expected result (0) in\
    \ that case.\n<|/ c |>\n<| c |>\nI guess I was just being cautious because I assumed\
    \ he was looking to find how many times \"a\" occurs in \"abc\". I am going to\
    \ write some code that does that.\n<|/ c |>\n<| a |>\nIt may not be an answer\
    \ to your question, but you could use gsub instead\n<code>\n'abc abc abc'.gsub('abc',\
    \ 'ab').length\n</code>\n<|/ a tags=ruby,string dscore=5 |>\n<| c |>\nThis is\
    \ not an answer to the question as stated; this is an alternative that does not\
    \ solve the problem.\n<|/ c |>\n<| c |>\nIt's a valid solution to your question.\
    \ Yes, it won't work if you don't know how many characters are going to be replaced,\
    \ but that was not the question. Also it's not clear to me what exactly you are\
    \ looking for. You want a function that counts the number of times 'a' is found\
    \ in a string, and that could be solved by this code. But maybe you wanted something\
    \ else in that regard.\n<|/ c |>\n<| c |>\nThis is indeed the only correct answer.\
    \ It should be the accepted one.\n<|/ c |>\n<| c |>\nThis answer is the only one\
    \ that actually answers the question correctly. None of the other answers correctly\
    \ answer this question. This is the only valid answer!\n<|/ c |>\n<| a tags=ruby,string\
    \ dscore=3 |>\nIf you don't mind using regular expressions, there is a simpler\
    \ way, and it's also fast:\n<code>\n'abc abc abc'.gsub(/abc/, 'a')\n</code>\n\
    <|/ a |>", "\treturn string.gsub(/#{substring}/).count\nend", "  string.gsub(substring,\
    \ \"\")\nend", "  # Use case-insensitive search\n  if string.length >= substring.length\n\
    \    string.downcase!\n    substring = substring.downcase\n  end", "  return 0\
    \ if (string.length == 0 || string.length == 0 || string.length == 0) || (substring.length\
    \ == 0 || substring.length == 0)\n  string.gsub(substring, \"\").length\nend\n\
    </cell>\n<code language=julia-1.0>", "    i = 0\n    count = 0\n    while i <\
    \ string.length\n        i += 1\n        if string.sub!(substring, \"\") then\n\
    \            count += 1\n        end\n    end\n    return count\nend", "  # Return\
    \ the number of times the substring can be found in the string\n  if string.index(substring)\
    \ == 0\n    return 0\n  else\n    return string.index(substring) - string.index(substring,\
    \ string.index(substring))\nend", "  i = 0\n  length = string.length\n  while\
    \ i < length\n    if string[i] == substring[0]\n      i += 1\n      break\n  \
    \  elsif string[i] == substring[1]\n      i += 1\n      i += 1\n      break\n\
    \    end\n    i += 1\n  end\n  return i\nend\n</cell>\n<code language=julia-1.1>\n\
    how_many_times(string, substring)\n</cell>\n<code language=julia-1.1>", "  i =\
    \ 0\n  while i < string.length and string[i] != substring[i]\n    i += 1\n  return\
    \ i\nend", "  result = 0\n  for i in 0...string.length - 1\n    result += (substring\
    \ == string[i .. i + 1]) ? 1 : 0\n  end\n  result\nend", "  count = 0\n  pos =\
    \ 0\n  while pos < string.length\n    pos = string.index(substring, pos)\n   \
    \ count += 1\n    pos = pos + 1\n  end\n  count\nend\n</cell>\n<text>\n4.7 Parsing\
    \ a date\n4.7.1 Parsing a date string\nLet's write a method parse_date that takes\
    \ a date string and returns an Array of Date\nobjects. Valid date strings have\
    \ the following formats:", "  string = string.downcase\n  substring = substring.downcase\n\
    \  return string.count(substring) + string.count(substring.reverse) + string.count(substring.reverse.downcase)\n\
    end\n</code>\n<|/ a dscore=3 tags=ruby,string,algorithm |>\n<| a dscore=3 |>\n\
    I would use String#count which gives you the count of occurrences of the given\
    \ string in another:\n<code>\n\"a\".count(\"a\")    #=> 1\n\"a\".count(\"a\")\
    \    #=> 1\n\"a\".count(\"aa\")   #=> 2\n</code>\nIn your case:\n<code>\nstring.count(\"\
    aaaa\")   #=> 2\n</code>\n<|/ a tags=ruby,string,algorithm |>\n<| c |>\nThis method\
    \ is case sensitive.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  string.split(substring).length\
    \ - string.downcase.split(substring).length\nend", "\treturn string.split(substring).size\
    \ - 1\nend\n</cell>\n<code language=julia-1.0>", "  times = 0\n  index = string.index(substring)\n\
    \  while index != nil\n    times += 1\n    index = string.index(substring, index+1)\n\
    \  end\n  return times\nend", "    string.gsub(substring, substring + substring).count(\"\
    (?=\" + substring + \"{2,})\") - 1\nend", "  counter = 0\n  string.gsub(substring,\
    \ \"\")\n  string.scan(substring)\n  counter = string.count\n  string\nend", " \
    \ string = string.downcase\n  string.gsub(substring, substring, 1)\n  string.count\n\
    end", "  string.gsub!(substring){ |x| x }.length\nend", "  string.length >= substring.length\
    \ ? string.count(substring).to_f : 0\nend", "  pos = 0\n  found = string.count(\"\
    (?#{substring})\", pos) # Ruby 1.9 compatibility\n  pos += 1\n  while pos < string.length\n\
    \    found = string.count(\"(?#{substring})\", pos)\n    pos += 1\n  end\n  found\n\
    end", "\ti = 0\n\twhile i < string.length\n\t\tif string[i] == substring[i]\n\t\
    \t\ti += 1\n\t\telse\n\t\t\treturn i\n\tend\n\treturn i\nend", "  string.split(substring).count\n\
    end", "  count = 0\n  i = string.length\n  while i > 0\n    i -= 1\n    char =\
    \ string[i]\n    if char == substring[count]\n      count += 1\n    end\n  end\n\
    \  count\nend", "    i = 0\n    count = 0\n    while i < string.length\n     \
    \   if string.index(substring, i) == i\n            count += 1\n        i += 1\n\
    \    end\n    return count\nend", "  # Count how many times the substring occurs\
    \ in the original string.\n  count = 0\n  pos = 0\n  while pos < string.length\n\
    \    break if substring[pos] == string[pos]\n    count += 1\n    pos += 1\n  end\n\
    \  count\nend", "    i = 0\n    count = 0\n    while i <= string.length\n    \
    \    if string.slice(i, i + substring.length) == substring\n            count\
    \ += 1\n            i += substring.length\n        else\n            i += 1\n\
    \    end\n    count\nend", "  substring = substring.downcase\n  count = 0\n  i\
    \ = 1\n  while i < string.length\n    if string[i] != substring[0]\n      break\n\
    \    i += 1\n    count += 1\n    if i == string.length\n      return count\n \
    \ end", "  count = -1\n  i = 0\n  while i < string.length\n    if string[i] ==\
    \ substring[0]\n      count += 1\n      i -= 1\n      break if string.start_with?(substring,\
    \ i)\n      i -= 1\n      break if string.end_with?(substring, i)\n      i +=\
    \ 1\n    end\n    i += 1\n  end\n  return count\nend", "    count = 0\n    while\
    \ substring != \"\"\n        count += 1\n        substring = substring[1..-1]\
    \ if substring[0] == substring[-1] and substring[0] =~ /\\w/ && substring.length\
    \ == 1\n    end\n    count\nend", "  count = 0\n  string.each_char do |char|\n\
    \    if char == substring[0]\n      if substring.size > 1\n        count += 1\
    \ if string.index(char, true).nil?\n        count += 1 if string.index(char, true,\
    \ true).nil?\n      else\n        count += 1\n      end\n    end\n  end\n  count\n\
    end", "  i = 0\n  string.gsub!(substring, \"\")\n  while i < string.size\n   \
    \ i += 1\n    string.gsub!(substring, \"\")\n  end\n  string.length\nend\n</cell>\n\
    <text>\n3.3 String methods to replace characters in a string", "  i = 0\n  count\
    \ = string.count(substring)\n  while i < string.size\n    count += 1\n    i +=\
    \ 1\n    break if count == string.size(substring)\n  end\n  count\nend", "  i\
    \ = 0\n  while i < string.length\n    if string[i] != substring[0]\n      break\n\
    \    end\n    if string[i] == substring[0]\n      i += 1\n    else\n      i +=\
    \ 1\n    end\n  end\n  return i\nend", "  count = 0\n  string.gsub!(substring,\
    \ \"\")\n  while string.size > 0\n    string.gsub!(substring, \"\")\n    count\
    \ += 1\n  end\n  count\nend", "  count = (string.downcase.count(substring) + string.upcase.count(substring)\
    \ + string.count.count(substring) + string.gsub.count(substring)) - (string.include?\
    \ substring)\n  count ||= 0\n  count\nend", "    count = 0\n    i = 0\n    while\
    \ i < string.length and i < string.length + substring.length\n        if string[i:i\
    \ + substring.length] == substring\n            count += 1\n            i += substring.length\n\
    \        else\n            i += 1\n    end\n    count\nend", "  string.count(substring)\n\
    end", "  return 0 if string == substring else (string.length / substring.length).floor\n\
    end", "  string = string.to_s\n  substring = substring.to_s\n  count = 0\n  i\
    \ = 0\n  while i < string.length\n    count += 1 if string[i] == substring &&\
    \ i != string.length \n    i += 1\n  end\n  return count\nend\n</code>\n<|/ a\
    \ tags=performance,ruby,string,algorithm,hash dscore=0 |>\n<| c |>\nYes, I should\
    \ probably mention that I only want \"unique substrings\" (so \"abcabc\" would\
    \ be counted as \"abc\" only once).\n<|/ c |>\n<| a |>\nYou can use a hash table\
    \ to store the already counted substrings and use the existing value to increment\
    \ the count:\n<code>", "  return string.scan(/#{substring}/).size\nend", "   \
    \ count = 0\n    index = string.index(substring)\n    while index != -1\n    \
    \    count += 1\n        index = string.index(substring, index + 1)\n    end\n\
    \    count\nend", "\tcount = string.count(substring)\n\tif string.upcase(substring)\
    \ == substring then count -= 1\n\tstring.reverse\n\tcount = 0 if string.downcase(substring)\
    \ == substring then count += 1 else count\n\treturn count\nend", "  return 1 if\
    \ string.index(substring) > string.size - substring.size else 0\nend", "  string.gsub(substring).length\n\
    end", "  return 0 if string.size == 0 else string.scan(substring, 0).size - substring.count('(')\n\
    end", "  count = 0\n  string.split(substring).each do |element|\n    count +=\
    \ 1 if element == substring and element != string\n  end\n  count\nend", "   \
    \ pos = 0\n    count = 0\n    while pos < string.length\n        count += 1\n\
    \        pos = string.index(substring, pos)\n    end\n    count\nend\n</cell>\n\
    <code language=julia-1.0>", "  count = 0\n  i = 0\n  while i < string.length\n\
    \    count += 1\n    i += 1\n    i += 1 if string[i, substring.length] == substring\
    \ else 0\n  end\n  count\nend", "    count = 0\n    start_index = 0\n    found\
    \ = string.index(substring, start_index)\n    while found != -1\n        count\
    \ += 1\n        start_index = found + 1 \n        found = string.index(substring,\
    \ start_index)\n    end\n    count\nend\n</cell>\n<code language=julia-1.0>",
  "  count = 0\n  while string != \"\"\n    str = string.index(0, string.index(substring))\n\
    \    count = count + 1\n    string = string[str+substring.size]\n  count\nend",
  '  count = 0', "\tcount = 0\n\tbegin = 0\n\tend = string.length - 1\n\twhile begin\
    \ < end\n\t\tif string[begin] == substring[begin] && string[end] == substring[end]\n\
    \t\t\tcount = count + 1\n\t\telse\n\t\t\tif string[begin] != substring[begin]\n\
    \t\t\t\tcount = count + 1\n\t\t\tend\n\t\t\tif string[end] != substring[end]\n\
    \t\t\t\tcount = count + 1\n\t\tend\n\t\tbegin = begin + 1\n\t\tend = end - 1\n\
    \treturn count\nend", "  count = 0\n  pos = 0\n  while pos < string.length\n \
    \   if string[pos] == substring\n      count += 1\n      pos += 1\n    else\n\
    \      count = 0\n    end\n  end\n  count\nend", "  count = 0\n  pos = 0\n  while\
    \ pos < string.length\n    if string[pos] == substring[0]\n      count += 1\n\
    \      pos += 1\n      while pos < string.length\n        if string[pos] == substring[1]\n\
    \          count += 1\n          pos += 1\n        end\n      end\n    end\n \
    \   pos += 1\n  end\n  count\nend\n</code>\n<|/ a tags=string,ruby,regex |>\n\
    <| a tags=string,ruby,regex dscore=1 |>\nHere is my take on a similar problem:\n\
    <code>", "  string.scan(substring).size\nend", "  string.scan(substring)\n  string.count\n\
    end", "    \n    # Make sure we actually have a string and substring\n    return\
    \ nil if string == nil or substring == nil\n    \n    # Convert our two arguments\
    \ into strings\n    string = string.to_s\n    substring = substring.to_s\n   \
    \ \n    # Find the number of times\n    count = 0\n    \n    # Loop through each\
    \ character in the string\n    string.each_char do |char|\n    \n        # If\
    \ this character matches the substring\n        if char == substring\n       \
    \ \n            # If we are not yet on the last character\n            unless\
    \ char == string[-1]\n            \n                # Increment the count\n  \
    \              count += 1\n            end\n        end\n    end\n    \n    return\
    \ count\nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\nI made a ruby gem that handles\
    \ this case too. \nhttps://github.com/rdeboer/vacuum\n<code>\nrequire 'vacuum'",
  "  string.downcase!\n  substring.upcase!\n  string.sub(substring, string)\n  string.scan(Regexp.new(substring)).length\n\
    end\n</pre>", "  string.gsub(substring, \"\")\n  string.count(\"a\")\nend", " \
    \   i = 0\n    while i < string.length\n        if (string[i] == substring[0])\n\
    \            i += substring.length\n        else\n            i += 1\n    end\n\
    \    return i\nend", "  string.scan(substring.upcase).size\nend", "  count = 1\n\
    \  for i in 0..(string.length-substring.length)\n    if string.slice(i..i+substring.length)\
    \ == substring\n      count += 1\n    end\n  end\n  count\nend", "  return 1 if\
    \ string.index(substring) == -1 and string.count(substring) == 1 else string.count(substring)\n\
    end", "  return string.scan(substring).count\nend", "  count = 0\n  string.gsub!(substring,\
    \ \"\")\n  while string.length != 0\n    count += 1\n    string.gsub!(substring,\
    \ \"\")\n  end\n  count\nend", "  string_index = 0\n  substring_length = 0\n \
    \ matches = 0\n  while string_index < string.length\n    # Find the longest substring\
    \ that starts at this character in string\n    if string[string_index] == substring[substring_length]\n\
    \      substring_length++\n      string_index += 1\n    else \n      break\n \
    \   # Don't increment the string_index until we find a new substring that matches\
    \ substring\n    if substring_length == substring.length\n      matches += 1\n\
    \      substring_length = 0\n      continue\n  end\n  matches\nend\n</cell>\n\
    <cell>", "  string.gsub!(substring, \"\")\n  string.gsub!(substring, \"\")\n \
    \ return string.size\nend", "  i = 0\n  while string.length > i\n    i += 1\n\
    \    if string[i] == substring[i]\n      string.length = i\n      i += 1\n   \
    \ end\n  end\n  string.length\nend", "  # Write your code here.\n  times = 0\n\
    \  pos = 0\n  while pos < string.length\n    if string.slice(pos, pos + substring.length)\
    \ == substring\n      times += 1\n      pos += substring.length\n    end\n   \
    \ pos += 1\n  end\n  return times\nend", "  string.gsub(substring, \"\")\nend",
  "\tnew_string = \"\"\n\tcount = 0\n\tsubstring_length = 0\n\tstring_size = 0\n\t\
    \n\tsubstring_length = substring.length\n\tstring_size = string.length\n\t\n\t\
    # Check to see if string length is less than substring length.\n\tif string_size\
    \ < substring_length\n\t\treturn 0\n\t\n\t# Check to see if string length is greater\
    \ than substring length.\n\telse if string_size > substring_length\n\t\treturn\
    \ 0\n\t\n\t# Check to see if substring is empty.\n\telsif substring.length ==\
    \ 0\n\t\treturn 0\n\t\n\t# Check for each letter in string.\n\tnew_string = string\n\
    \twhile new_string.length > 0\n\t\tcount = 1\n\t\tletter = new_string[0]\n\t\t\
    \n\t\t# Check for each letter in substring\n\t\twhile substring_length > 0\n\t\
    \t\tif letter == substring[0]\n\t\t\t\tcount += 1\n\t\t\t\t\n\t\t\t\t# If substring\
    \ is longer, the loop will end.\n\t\t\t\tnew_string = new_string[(substring.length\
    \ - 1)..(new_string.length - 1)]\n\t\t\t\tsubstring_length -= 1\n\t\t\telse\n\t\
    \t\t\tbreak\n\t\t\t\n\t\t\tletter = substring.slice(1)\n\t\t\n\t\t# Check to see\
    \ if end of string was reached.\n\t\tif substring_length == 0\n\t\t\treturn count\n\
    \t\t\n\t\t# Keep looping through letters until end of string.\n\t\tnew_string\
    \ = new_string[(substring.length - 1)..(new_string.length - 1)]\n\t\tcount +=\
    \ 1\n\t\n\treturn count\n\t", "  if string.length <= substring.length\n    return\
    \ 0\n  \n  i = 0\n  j = 0\n  while i + substring.length <= string.length\n   \
    \ if string[i] == substring[j]\n      i += 1\n      j += 1\n    else # substring[j]\
    \ == string[i]\n      j += 1\n      if j >= substring.length\n        return i\
    \ - j\n    end\n  end\n  return j\nend", "    i = 0\n    while i < string.length\n\
    \        if string[i] == substring[0] && string[i + 1] == substring[1] && string[i\
    \ + 2] == substring[2] && string[i + 3] == substring[3]\n        then\n      \
    \      return i\n        end\n        i += 4\n    end\n    return 0\nend\n</cell>\n\
    <code language=julia-1.6>\nhow_many_times('', 'a')\n</cell>\n<code language=julia-1.6>\n\
    how_many_times('aaa', 'a')\n</cell>\n<code language=julia-1.6>\nhow_many_times('aaaa',\
    \ 'aa')\n</cell>\n<code language=julia-1.6>\nhow_many_times('aaaa', 'aab')\n</cell>\n\
    <code language=julia-1.6>\nhow_many_times('aaaa', 'aaac')\n</cell>\n<code language=julia-1.6>\n\
    how_many_times('aaaa', 'ab')\n</cell>\n<code language=julia-1.6>\nhow_many_times('aaaa',\
    \ 'abac')\n</cell>\n<code language=julia-1.6>\nhow_many_times('aaaa', 'abb')\n\
    </cell>\n<code language=julia-1.6>\nhow_many_times('aaaa', 'abbb')\n</cell>\n\
    <code language=julia-1.6>\nhow_many_times('aaaa', 'abbbc')\n</cell>\n<code language=julia-1.6>\n\
    how_many_times('aaaa', 'abbc')\n</cell>\n<code language=julia-1.6>\nhow_many_times('aaaa',\
    \ 'abcd')\n</cell>\n<code language=julia-1.6>\nhow_many_times('aaaa', 'abcdc')\n\
    </cell>\n<code language=julia-1.6>\nhow_many_times('aaaa', 'abcde')\n</cell>\n\
    <code language=julia-1.6>\nhow_many_times('aaaa', 'abcdef')\n</cell>\n<code language=julia-1.6>\n\
    how_many_times('aaaa', 'abcdefg')\n</cell>\n<code language=julia-1.6>\nhow_many_times('aaaa',\
    \ 'abcdefgh')\n</cell>\n<code language=julia-1.6>\nhow_many_times('aaaa', 'abcdefghi')\n\
    </cell>\n<code language=julia-1.6>\nhow_many_times('aaaa', 'abcdefghij')\n</cell>\n\
    <code language=julia-1.6>\nhow_many_times('aaaa', 'abcdefghijk')\n</cell>\n<code\
    \ language=julia-1.6>\nhow_many_times('aaaa', 'abcdefghijkl')\n</cell>", "  return\
    \ string.split(substring).length - 1\nend", "  return ((string.count(substring)\
    \ + 1) * (string.length - string.count(substring)) * string.count(substring))\
    \ / string.count('a')\nend", "  string_length = string.length\n  substring_length\
    \ = substring.length\n  count = 0\n  for i in 0..(string_length-1)\n    if string[i]\
    \ == substring[i]\n      count += 1\n    end\n  end\n  count\nend", "  i = 0\n\
    \  while i < string.length\n    if string[i + substring.length] == substring\n\
    \      return 1 + how_many_times(string, substring)\n    i += 1\n  return 0\n\
    end", "  match = string.gsub(substring, \"\")\n  return match.size\nend", "  return\
    \ 0 if string.empty? || substring.empty? || string.chars.all? { |character| !substring.chars.include?(character)\
    \ } || string.chars.any? { |character| substring.chars.include?(character) } ||\
    \ substring == string.gsub(substring, \"\") end\nend", "  return string.split(substring).length\
    \ if string && substring && string != substring ? string.scan(Regexp.new(substring)).length\
    \ + string.scan(Regexp.new(substring.upcase)).length + string.scan(Regexp.new(substring.downcase)).length\
    \ : 0\nend", "    count = 0\n    i = 0\n    while i < string.length\n        if\
    \ string.sub!(substring, i)\n            count += 1\n            i = i + substring.length\n\
    \        else\n            i += 1\n        end\n    end\n    count\nend", "  substring_index\
    \ = 0\n  string_index = 0", "    count = 0\n    (first_index, last_index) = string.index(substring)\n\
    \    string[first_index...last_index] do |char|\n        if string.count(char)\
    \ > 0\n            count += 1\n        end\n    end\n    count\nend", "  substring_length\
    \ = substring.length\n  string_size = string.length\n  i = 0\n  count = 0\n  while\
    \ i < string_size\n    if string[i] == substring[0]\n      count = count + 1\n\
    \      if i == string_size - substring_length\n        count = (count / substring.length).ceil\n\
    \      end\n      i = i + 1\n    end\n    i = i + 1\n  end\n  return count\nend\n\
    </code>\n<|/ a |>\n<| c |>\nHi, I appreciate the help. But it gives me the following\
    \ error:\n`test_count_substrings_in_strings(TestCountSubstringsTest): test_count_substrings_in_strings:\
    \ test_count_substrings_in_strings (test_count_substrings_in_strings.rb): undefined\
    \ method 'length' for #<String:0x0000000005d887a8> (NoMethodError)`\n<|/ c |>\n\
    <| c |>\nI added a missing line where I define `substring`.\n<|/ c |>\n<| c |>\n\
    Hi, I edited the code above, could you please check it? I am getting a NoMethodError\
    \ at `test_count_substrings_in_strings(TestCountSubstringsTest):`\n<|/ c |>\n\
    <| c |>\nAre you sure that `substring` is the argument to `test_count_substrings_in_strings`\
    \ and not `how_many_times`?  Also I changed the code slightly so there could be\
    \ a count of 0.\n<|/ c |>\n<| c |>\nI am getting a `NoMethodError: undefined method\
    \ 'length' for #<String:0x0000000005f5bfc8>` error when running the test.\n<|/\
    \ c |>\n<| a |>\n<code>", "  string.downcase! #because this function is for ASCII\
    \ only\n  string.gsub(substring, \"\") #remove substring\n  string.count(\"A\"\
    ) - string.count(\"a\") #count the number of A's, minus how many a's, for each\
    \ given substring\nend", "  return string.gsub(substring, \"\").size\nend", "\t\
    return string.gsub(substring, \"\").length\nend", "  string.split(substring).length\
    \ - string.scan(substring).length\nend", "  count = 0\n  i = 0\n  while i < string.length\n\
    \    if string[i] == substring[0]\n      count += 1\n      if substring.length\
    \ == 1\n        return count\n      else\n        i += 1\n    elsif string[i]\
    \ == substring[1]\n      count += 1\n      i += 1\n    else\n      i += 1\n  \
    \  end\n  end\n  return count\nend", "  string.length.times do |i|\n    next unless\
    \ string[i] =~ /#{substring}/i\n    break\n  end\n  i + 1\nend", "  return string.split(substring).length\
    \ if string and substring else 0\nend", "  count = 0\n  index = -1\n  while index\
    \ != nil\n    index = string.index(substring, index + 1)\n    count += 1\n  end\n\
    \  count\nend", "  result = 0\n  string_size =  string.size\n  substring_size\
    \ =  substring.size\n  (0...(string.size-substring_size)).each do |i|\n    result\
    \ += (substring.size > i) ? substring_size : i\n  end\n  result\nend", "  counter\
    \ = 0\n  i = 0\n  while i < string.length\n    if string.sub!(substring, substring.at(i),\
    \ i)\n      counter += 1\n    end\n    i += 1\n  end\n  counter\nend", "  return\
    \ string.gsub(substring, \"\").length\nend\n</cell>\n<text>\nThe second function\
    \ is similar to the first. It takes two parameters: a search string and an optional\
    \ replacement string. The first one is the original string we are searching, and\
    \ second one is what we replace it with.", '  return nil if string.nil? || substring.nil?',
  "  return string.chars.to_a.count{|c| c == substring}\nend", "  count = 0\n  index\
    \ = -1\n  while index += 1\n    index, count = string.index(substring, index +\
    \ 1) + 1, count + 1\n  count\nend", "  if string.empty? or substring.empty? then\
    \ return 0 end\n  if string.start_with? substring then return 1 else return 0\
    \ end\n  string.length.downto(0) do |i|\n    if string.slice(i,i+substring.length)\
    \ == substring then return i end\n  end\n  return nil\nend", "  i = 0\n  while\
    \ i < string.length\n    return i if string.index(substring, i) == i || string.index(substring,\
    \ i+1) == i || string.index(substring, i+2) == i || string.index(substring, i+3)\
    \ == i || string.index(substring, i+4) == i || string.index(substring, i+5) ==\
    \ i || string.index(substring, i+6) == i || string.index(substring, i+7) == i\
    \ || string.index(substring, i+8) == i || string.index(substring, i+9) == i ||\
    \ string.index(substring, i+10) == i || string.index(substring, i+11) == i ||\
    \ string.index(substring, i+12) == i || string.index(substring, i+13) == i ||\
    \ string.index(substring, i+14) == i || string.index(substring, i+15) == i ||\
    \ string.index(substring, i+16) == i || string.index(substring, i+17) == i ||\
    \ string.index(substring, i+18) == i || string.index(substring, i+19) == i ||\
    \ string.index(substring, i+20) == i || string.index(substring, i+21) == i ||\
    \ string.index(substring, i+22) == i || string.index(substring, i+23) == i ||\
    \ string.index(substring, i+24) == i || string.index(substring, i+25) == i ||\
    \ string.index(substring, i+26) == i || string.index(substring, i+27) == i ||\
    \ string.index(substring, i+28) == i || string.index(substring, i+29) == i ||\
    \ string.index(substring, i+30) == i || string.index(substring, i+31) == i ||\
    \ string.index(substring, i+32) == i || string.index(substring, i+33) == i ||\
    \ string.index(substring, i+34) == i || string.index(substring, i+35) == i ||\
    \ string.index(substring, i+36) == i || string.index(substring, i+37) == i ||\
    \ string.index(substring, i+38) == i || string.index(substring, i+39) == i ||\
    \ string.index(substring, i+40) == i || string.index(substring, i+41) == i ||\
    \ string.index(substring, i+42) == i || string.index(substring, i+43) == i ||\
    \ string.index(substring, i+44) == i || string.index(substring, i+45) == i ||\
    \ string.index(substring, i+46) == i || string.index(substring, i+47) == i ||\
    \ string.index(substring, i+48) == i || string.index(substring, i+49) == i ||\
    \ string.index(substring, i+50) == i || string.index(substring, i+51) == i ||\
    \ string.index(substring, i+52) == i || string.index(substring, i+53) == i ||\
    \ string.index(substring, i+54) == i || string.index(substring, i+55", "  string.gsub(substring,\
    \ \"\")\nend", "  return string.split(substring).count { |s| s.include?(substring)\
    \ }\nend", "  if string.empty?\n    0\n  elsif substring.empty?\n    string.count\n\
    \  elsif string.length < substring.length\n    substring.length\n  elsif string.length\
    \ > substring.length\n    string.length\n  else\n    i = 0\n    while i <= string.length\
    \ and i <= substring.length\n      i = i + 1 if string[i:i + substring.length]\
    \ == substring\n    end\n  end\nend\n</code>\n<|/ a dscore=1 tags=ruby,string\
    \ |>\n<| a tags=ruby,string |>\n<code>", "\treturn string.count(substring) * string.count(substring)\n\
    end", "  count = string.scan(substring).count\n  return count if count.is_a? Integer\
    \ else 0\nend", "  h = 0\n  i = 0\n  while i < string.length\n    h = h + (string.index(substring,\
    \ i) + 1)\n    i = i + 1\n  end", "    count = 0\n    for c in string\n      \
    \  if c==substring\n            count += 1\n        end\n    end\n    return count\n\
    end\n</cell>\n<code language=julia-1.4>", "  string.gsub(substring, \"\")\n  string.split(substring).length\n\
    end", "  count = 0\n  i = 0\n  while i < string.length\n    if string.slice(i..i+substring.length)\
    \ == substring\n      count += 1\n      i += substring.length\n    end\n    i\
    \ += 1\n  end\n  count\nend", "\tstring.scan(substring).size\nend", "  string.split(substring).inject(0)\
    \ do |counter, string|\n    counter + (string.include?(substring) ? 1 : 0)\n \
    \ end\nend\n</pre>", "    count = 0\n    index = 0\n    while index < string.length\n\
    \        index += 1\n        char = string.at(index)\n        if char == substring[index]\n\
    \            count += 1\n        end\n    end\n    return count\nend", "  string.length\
    \ == substring.length and string.sub!(/#{substring}/, '').length # Remove overlap\n\
    \  string.gsub(/#{substring}/, \"\").length\nend\n  ", "  string.count(substring)\n\
    end", "  i = 0\n  while i <= (string.length -  substring.length)\n    j = i +\
    \ substring.length - 1\n    overlap = (string[i + 0...j] == substring[0...j])\n\
    \    if overlap\n      return j - i\n    else\n      i += 1\n  end\n  0\nend",
  "  matches = 0\n  i = 0\n  while i < string.length\n    if string[i] === substring[0]\n\
    \      if string[i+1] === substring[0]\n        matches += 1\n      else\n   \
    \     i += 1\n    else\n      i += 1\n  end\n  matches\nend", "  count = 0\n \
    \ i = 0\n  while i < (string.length - substring.length + 1)\n    if string.slice(i..i\
    \ + substring.length) == substring\n      count += 1\n    i += 1\n  count\nend",
  "  substring.length.times do |i|\n    break if string.length <= i\n    return 0\
    \ if string[i].index(substring) != i\n  end\n  -1\nend", "  string.length\n  substring.length\n\
    \  count = 0\n  (0...string.length).each do |i|\n    (0...substring.length).each\
    \ do |j|\n      break if i >= substring.length\n      break if string[i] != substring[j]\n\
    \      count += 1\n    end\n  end\n  count\nend", "  return 0 if (string == '')\
    \ or (substring == '') else string.count(substring)\nend", "    i = 0\n    while\
    \ i <= string.length\n        i += 1\n        if string.slice(i).downcase.include?(substring.downcase)\n\
    \            i += 1\n        end\n    end\n    i\nend\n</cell>\n<code language=conda-env-jcop-py>",
  "  string.scan(/(.)\\1*/) do |substring_2|\n    return 0 if substring_2.length <\
    \ substring.length\n    return substring_2.length unless substring == substring_2\n\
    \  end\n  -1\nend", "  count = 0\n  while string.index(substring) != nil\n   \
    \ count += 1\n    string.slice!(substring, 1)\n  end\n  count\nend", "  string.length\n\
    \  substring.length\n  return 0 if string == substring \n  return 1 if string.index(substring)\
    \ == nil\n  return string.index(substring) + 1 \nend", "  if string.include? substring\n\
    \    return string.count(substring)\n  else\n    return 0\n  end\nend\n</cell>\n\
    <text>\nProblem 11\nWrite a function that takes a string, word pair as arguments,\
    \ finds the index of the first occurrence of the word pair, returning -1 if it\
    \ does not exist. If word pairs are different lengths, return the first word that\
    \ occurs in both word pairs. For example, \"How many times does it rain?\" should\
    \ return \"rain\" since it occurs in the first word pair and has 2 occurrences.",
  "  return string.split(substring).length if substring != '' && string.include? substring\
    \ else 0\nend", "  string.count(substring)\nend", "\tstring.split(substring).length\n\
    end", "  return string.count(substring)\nend", "  i = 0\n  while i < string.length\
    \ && i < substring.length\n    break if (string[i..i+1] == substring[i..i+1]).all?\n\
    \    i += 1\n  i\nend", "  count = 0\n  string.split(substring).each_with_index\
    \ { |sub, index| count += 1 if sub == substring }\n  count\nend", "  return string.gsub(substring,\
    \ \"\").length if string != \"\" else 0\nend\n</cell>\n<text>\nThe count method\
    \ is the most used method in Ruby but it returns nil if no match is found and\
    \ count is the count of a substring inside the string.", "  count = 0\n  index\
    \ = 0\n  while index < string.length\n    if string.sub!(index, index + substring.length)\n\
    \      count += 1\n    end\n    index += 1\n  end\n  count\nend", "  count = 0\n\
    \  pos = 0\n  while pos < string.length\n    pos = string.index(substring, pos)\n\
    \    count += 1\n    pos += 1\n  end", "  substring_count = string.count(substring)\n\
    \  string_count = string.size", "  return string.count(substring) if string and\
    \ substring and substring != '' else 0\nend", "  counter = 1\n  pos = 0\n  while\
    \ pos < string.length\n    if string[pos] == substring[0] and substring.length\
    \ > 1\n      counter += how_many_times(string[pos + 1: string.length], substring[1:])\n\
    \    end\n    pos += 1\n  end\n  return counter\nend", "  count = 0\n  if string.empty?\
    \ || substring.empty?\n    count\n  else\n    substring_indexes = get_substring_indexes(string,\
    \ substring)\n    string_indexes = get_string_indexes(string, substring)\n   \
    \ string_indexes.each do |string_index|\n      index = string_index[0]\n     \
    \ substring_indexes.each do |substring_index|\n        index += substring_index[0]\n\
    \        if string.slice(index, substring_index.length) == substring\n       \
    \   count += 1\n        end\n      end\n    end\n  end\nend", "    count = 0\n\
    \    string.downcase!\n    substring.downcase!", "  (0...(string.length)).each\
    \ do |i|\n    if string[i] == substring[0]\n      (0...substring.length).each\
    \ do |j|\n        if string[i + j] != substring[j]\n          break\n        end\n\
    \      end\n      \n      i += (substring.length - 1)\n      \n      break if\
    \ string.length <= i\n      \n      break if substring.length <= j\n      \n \
    \     break if substring[j] == string[i + j]\n    end\n  end\n  \n  string.index(substring)\n\
    end", "  count = 0\n  i = 0\n  while (i < string.length) and (count < substring.length)\n\
    \    count = count + ((string.index(substring, i)) > 0)\n    i += 1\n  return\
    \ count\nend", "\tcount = 0\n\tindex = 0\n\twhile index < string.length\n\t\t\
    substring_index = 0\n\t\twhile substring_index < substring.length\n\t\t\tcount\
    \ += 1\n\t\t\tsubstring_index += 1\n\t\tindex += 1\n\treturn count\nend", "  if\
    \ string.empty? or substring.empty? or string.empty?\n    0\n  else\n    string.count(substring)\
    \ + how_many_times(substring.downcase, string.downcase)\n  end\nend", "  string.gsub(substring).length\n\
    end", "  return string.scan(substring).count\nend", "  count = 0\n  (0...string.size).each\
    \ do |i|\n    count += 1 if string[i] == substring[0]\n    if string.size > i\
    \ + 1\n      count += 1 if string[(i + 1)..-1].include?(substring)\n    end\n\
    \  end\n  count\nend", "    string_size = string.size\n    substring_size = substring.size\n\
    \    count = 0\n    i = 0\n    while i < string_size\n        if string[i] !=\
    \ substring[0]\n            count = count + 1\n            i = 0\n        else\n\
    \            i = i + 1\n        end\n    end\n    return count\nend", "  string.split(substring).length\n\
    end", "  count = 0\n  string_size = string.length\n  substring_size = substring.length\n\
    \  \n  (0..string_size).each do |i|\n    count += (string.slice(i..i + substring_size).match(/#{substring}/g)\
    \ ? 1 : 0)\n  end\n  \n  count\nend", "    count = 0\n    pos = string.index(substring)\n\
    \    while pos != -1\n        count = count + 1\n        pos = string.index(substring,\
    \ pos + 1)\n    end\n    count\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a\
    \ |>\n<code>\n'abbb' =~ /ab/", "  new_string = ''\n  i = 0\n  while i < string.length\n\
    \    break if string[i] == substring[0]\n    i += 1\n  end\n  while i < string.length\n\
    \    break if string[i + substring.length] == substring[-1]\n    new_string <<\
    \ string[i - substring.length]\n    i += substring.length\n  end\n  new_string.size\n\
    end", "  return string.chars.count(substring)\nend", "  count = 0\n  pos = 0\n\
    \  while pos < string.length\n    pos = string.index(substring, pos)\n    count\
    \ += 1\n    pos += 1\n  end\n  count\nend", "  pos = 0\n  while pos < string.length\n\
    \    return 1 + string.count(substring, pos)\n    pos = pos + 1\n  end\nend",
  "  count = 0\n  while string.index(substring) != nil\n    count += 1\n    string.index(substring)\
    \ += 1\n  end\n  count\nend", "  return string.scan(substring).count { |match|\
    \ match.start_pos <= substring.index(match) && match.end_pos >= substring.index(match)\
    \ }\nend", "  string.downcase!\n  substring.downcase!\n  count = 0\n  string.gsub!(substring,\
    \ substring.to_sym) until string.empty?\n  string.downcase!\n  count\nend", " \
    \ string.gsub(substring, \"\").length\nend", "    string_size = string.length\n\
    \    substring_size = substring.length\n    count = 0\n    i = 0\n    while i\
    \ < string_size and i < string_size + substring_size\n        if string[i:i+substring_size]\
    \ == substring\n            count += 1\n        i += 1\n    end\n    count\nend",
  "    count = 0\n    substring_index = 0\n    string_index = 0\n    while string_index\
    \ < string.length\n        substring_index += string[string_index].index(substring)\n\
    \        count += 1\n        string_index += 1\n    end\n    return count", " \
    \ count = 0\n  strings = string.split(substring)\n  strings.each do |string|\n\
    \    if string.present? && string.include?(substring)\n      count += 1\n    end\n\
    \  end\n  count\nend", "  count = 0\n  string_size = string.size\n  substring_size\
    \ = substring.size\n  while string.size > 0\n    if string.slice!(-1) == substring_size\n\
    \      count += 1\n      string.slice!(-1)\n    else\n      count = 0\n    end\n\
    \  end\n  return count\nend", "  count = 0\n  i = 0\n  while i < string.length\n\
    \    count += 1 if (string[i..i + substring.length] == substring) else 0\n   \
    \ i += 1\n  end\n  count\nend", "  if string.downcase.include?(substring)\n  \
    \  string.downcase.count(substring)\n  else\n    0\n  end\nend", "  string.scan(/(?=(#{substring}))/).size\n\
    end", "  string.index(substring)\nend", "  count = 0\n  position = 0\n  while\
    \ position < string.length\n    if string[position] == substring[position]\n \
    \     count += 1\n      position += 1 \n    else\n      position += 1 \n  end\n\
    \  count\nend", "  return string.split(substring).count(substring)\nend", "  i\
    \ = 0\n  while i < string.length\n    index = string.index(substring, i)\n   \
    \ return index if index != nil else\n      i = string.length\n  end\n  0\nend",
  "  count = -1\n  string.downcase.scan(substring, 1, count).inject(0){|counter, pair|\
    \ counter += pair[1]}\nend\n</code></pre>\n</div>\n</div>\n<div id=\"what-is-the-difference-between-a-regex-and-a-matcher\"\
    \ class=\"section level1\">\n<h1><span class=\"header-section-number\">5</span>\
    \ What is the difference between a regex and a matcher?</h1>\n<p>The main difference\
    \ is that a matcher can be run against a String and will match the beginning and\
    \ end of the String. This is important to consider because if you try to match\
    \ a regex in the middle of a String you will get a MatchData object rather than\
    \ the result of the match.</p>\n<p>An example of this is that a regex of <code>/(a+)+/</code>\
    \ would match the string <code>'aaaaa'</code>, but with a matcher it would match\
    \ just the beginning of <code>'aaaaa'</code>.</p>\n<pre class=\"ruby\"><span class=\"\
    ruby-keyword\">class</span> <span class=\"ruby-constant\">StringMatcher</span>\n\
    \  <span class=\"ruby-keyword\">def</span> <span class=\"ruby-identifier\">initialize</span>(<span\
    \ class=\"ruby-identifier\">pattern</span>)\n    <span class=\"ruby-keyword\"\
    >if</span> <span class=\"ruby-keyword\">not</span> <span class=\"ruby-constant\"\
    >Regexp</span> <span class=\"ruby-operator\">===</span> <span class=\"ruby-identifier\"\
    >pattern</span>\n      <span class=\"ruby-identifier\">pattern</span> <span class=\"\
    ruby-operator\">=</span> <span class=\"ruby-constant\">Regexp</span>.<span class=\"\
    ruby-identifier\">new</span>(<span class=\"ruby-identifier\">pattern</span>)\n\
    \    <span class=\"ruby-keyword\">end</span>\n  <span class=\"ruby-keyword\">end</span>\n\
    \  <span class=\"ruby-keyword\">def</span> <span class=\"ruby-identifier\">match?</span>(<span\
    \ class=\"ruby-identifier\">string</span>)\n    <span class=\"ruby-keyword\">return</span>\
    \ <span class=\"ruby-keyword\">false</span> <span class=\"ruby-keyword\">unless</span>\
    \ <span class=\"ruby-identifier\">string</span>\n    <span class=\"ruby-identifier\"\
    >string</span> <span class=\"ruby-operator\">==</span> <span class=\"ruby-identifier\"\
    >pattern</span>\n  <span class=\"ruby-keyword\">end</span>\n  <span class=\"ruby-keyword\"\
    >private</span>\n    <span class=\"ruby-keyword\">def</span> <span class=\"ruby-identifier\"\
    >pattern</span>\n      <span class=\"ruby-keyword\">self</span>.<span class=\"\
    ruby-identifier\">class</span>.<span class=\"ruby-identifier\">new</span>.<span\
    \ class=\"ruby-identifier\">pattern</span>\n    <span class=\"ruby-keyword\">end</span>\n\
    <span class=\"ruby-keyword\">end</span>", "  if string.length <= substring.length\n\
    \    substring.length\n  else\n    string.length - substring.length\n  end\nend",
  "  return string.count(substring)\nend", "  count = Hash.new(0)\n  string.split(substring).each\
    \ do |part|\n    count[part] += 1\n  end\n  count.values.max\nend\n</pre>", " \
    \ count = 0\n  string.each_char do |c|\n    if c == substring\n      count +=\
    \ 1\n    else\n      count = 0\n    end\n  end\n  count\nend", "  count = 0\n\
    \  i = 0\n  while i < string.length\n    j = i\n    while j < string.length\n\
    \      count += 1\n      if string[j] == substring[i]\n        j += 1 \n     \
    \ end\n    end\n    i += 1\n  end\n  count\nend", "    count = 0\n    index =\
    \ string.index(substring)\n    while index != -1 and count < len(string)\n   \
    \     index = string.index(substring, index+1)\n        count += 1\n    end\n\
    \    return count\n</cell>\n<cell>\nassert how_many_times('aaa', 'a') == 3\nassert\
    \ how_many_times('aaaa', 'aa') == 3\n</cell>\n<text>\nQ: Write a function that\
    \ returns the first non-overlapping prefix of a given string.", "  i = 0\n  count\
    \ = 0\n  while string[i] != string[-i-1] do\n    i = i + 1;\n    if substring[i]\
    \ < substring[-i-1] then\n      count = count + 1\n    end\n  end\n  return count\n\
    end", "  string.scan(/\\w+/).count(substring)\nend", "    i = 0\n    count = 0\n\
    \    while i < string.length\n        if string[i] == substring[i]\n         \
    \   count += 1\n            i += 1\n        else\n            i = 0\n        end\
    \ # if\n    end # while\n    count\nend # how_many_times\n</cell>\n<code language=julia-1.0>",
  "    count = 0\n    pos = string.index(substring)\n    while pos !=  nil\n     \
    \   count +=1\n        pos = string.index(substring, pos + 1)\n    end\n    count\n\
    end", "    count = 0\n    i = 0\n    string = string.downcase\n    while i < string.length\n\
    \        count += 1\n        i = i + substring.downcase.length\n    count\nend",
  "  count = 0\n  string.scan(substring, 1, 0) do |m|\n    count += 1\n  end\n  count\n\
    end", "  # If string is empty, return 0\n  return string.empty? ? 0 : string.scan(/#{substring}/).size\n\
    end", "  return string.count(substring) || how_many_times(substring.downcase,\
    \ substring) unless substring.empty?\n  0\nend", "  count = 0\n  index = string.index(substring)\n\
    \  while index != nil\n    count += 1\n    index = string.index(substring, index\
    \ + 1)\n  end\n  count\nend", "  i = 0\n  while i < string.length\n    if string.sub(i,\
    \ i+substring.length) == substring\n      i += 1\n      i += 1\n    else\n   \
    \   i += 1\n    end\n  end\n  i\nend", "  return string.gsub(substring, substring.size).size\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThank you for this, but I still don't\
    \ know what I'm doing wrong. I'm calling this function like so: `how_many_times(\"\
    aba\", \"a\")` where `aba` is a string and `a` is another string, and I'm expecting\
    \ it to return 0, 3 or 3. But instead I'm getting a big number. Could you explain\
    \ how I'm supposed to call this function?\n<|/ c |>\n<| c |>\nMy bad, I was thinking\
    \ of an instance method. Corrected. Thanks.\n<|/ c |>\n<| c |>\nAh, I see! Thanks!\
    \ I didn't know about `gsub`. Will read more about that to fully understand it.\n\
    <|/ c |>\n<| c |>\n: Your question was \"How do I make this code work?\" I explained\
    \ why it wasn't working. And I explained how you can fix it. But I'm glad this\
    \ was helpful to you or anyone else who came across this post trying to solve\
    \ this problem :)\n<|/ c |>\n<| a dscore=2 tags=ruby |>\n<code>", "  count = 0\n\
    \  string.upcase if substring == '' && !string.empty? && !string.nil? && !string.is_a?(Numeric)\
    \ ? string : string.downcase\n  string.downcase if substring == '' && !string.empty?\
    \ && !string.nil? && !string.is_a?(Numeric) ? string : string.upcase\n  string.split(substring).uniq.each\
    \ do |elem|\n    count += 1 if elem.include? substring\n  end\n  count\nend",
  "  string = string.downcase\n  substring = substring.downcase\n  counts = Hash.new(0)\n\
    \  i = 0\n  while i < string.length\n    if string.slice(i..i+substring.length)\
    \ == substring\n      counts[substring] += 1\n      i += substring.length\n  \
    \  else\n      i += 1\n    end\n  end\n  counts.count\nend", "  total = 0\n  pos\
    \ = 0\n  while pos < string.length\n    if string[pos] == substring[0]\n     \
    \ count += 1\n      if pos == string.length\n        total += count\n      pos\
    \ += 1\n      while count > 0\n        if string[pos] == substring[1]\n      \
    \    total += 1\n          count -= 1\n        pos += 1\n    else \n      if count\
    \ > 0\n        total += count\n      count = 0\n      pos += 1\n    end\n  end\n\
    end", "  matches = 0\n  str_length = len(string)\n  substr_length = string.length",
  "  string.downcase!\n  substring.downcase!\n  return string.gsub(substring, substring.count(\"\
    \\0\"))\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=ruby,algorithm |>\n\
    Here's an implementation that uses the each_char method of String and the grep\
    \ method of Array:\n<code>", "    string = string.upcase\n    substring = substring.upcase\n\
    \    count = 0\n    i = 0\n    length = string.length\n    while i < length\n\
    \        if string[i:i+substring.length] == substring\n            count += 1\n\
    \        end\n        i += 1\n    end\n    count\nend", "  string.gsub!(substring,\
    \ \"\")\n  return string.count(\"^\"+substring+\"$\") if string != \"\"\n  return\
    \ 0\nend", "  string, substring = string.downcase, substring.downcase\n  occurrences\
    \ = string.scan(substring).count\n  occurrences = 0 if occurrences < 1 else occurrences\n\
    \  occurrences = 0 if occurrences < 0 else occurrences\n  occurrences = 0 if occurrences\
    \ > 1 else occurrences\n  return occurrences\nend", "  count = 0\n  i = 0\n  while\
    \ i < string.length\n    count += 1\n    i = string.index(substring, i)\n  end",
  "    count = 0\n    i = 0\n    while i < string.length\n        if string[i] ==\
    \ substring[0]\n            count += 1\n            i += substring.length - 1\n\
    \        elsif string[i] =~ string[regexp :start => i, :end => i+substring.length]\n\
    \            count += 1\n            i += substring.length - 1\n        else\n\
    \            i += 1\n        end\n    end\n    count\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
