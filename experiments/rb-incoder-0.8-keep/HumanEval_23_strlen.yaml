name: HumanEval_23_strlen
language: rb
prompt: "# Return length of given string\n# >>> strlen('')\n# 0\n# >>> strlen('abc')\n\
  # 3\ndef strlen(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strlen\n\
  \    candidate = method(:strlen)\n    assert_equal(0, candidate.call(\"\"))\n  \
  \  assert_equal(1, candidate.call(\"x\"))\n    assert_equal(9, candidate.call(\"\
  asdasnakj\"))\n  end\nend\n"
completions: ["  return string.split('').length\nend", "  string.scan(/^.*$/) do |length|\n\
    \    return length.length\n  end\n  return 0\nend", "  len = 0\n  pos = 1\n  while\
    \ pos < string.length\n    pos = string.index('.', pos)\n    len = len + 1\n \
    \ end\n  return len\nend", "  string.length\nend", "  string.gsub!(/[^\\x00-\\\
    xFF]/n, '') rescue 0\nend", "  string.split(//).reduce(:+)\nend", "  len = 0\n\
    \  string.each_char do |c|\n    len += 1\n  end\n  len\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nI think this should be the top answer. Nice and simple\n<|/ c |>\n\
    <| a dscore=3 tags=string,ruby,ruby-on-rails |>\nA simple solution in Rails would\
    \ be to use ActiveSupport String class which provides handy methods such as length\
    \ or mb_chars:\n<code>\n'hello'.mb_chars.length # => 5\n</code>\n<|/ a |>\n<|\
    \ a dscore=2 |>\n<code>", "  string.split(\"\").length\nend", "  if string.nil?\
    \ or string.empty?\n    0\n  else\n    string.length\n  end\nend", "  string.split(\"\
    \").inject(:+)\nend", "  string.gsub(/[^\\x00-\\x7f]/n, '').length\nend", "  return\
    \ string.size\nend", "  string.split(//).reduce(:+)\nend", "  string.split(//).length\n\
    end", "  string.split(//)\nend", "  string.scan(/\\S+/) do |s|\n    s.length\n\
    \  end\nend", "  string.gsub(/./) do |char|\n    char = char.unpack('U*').first\n\
    \    next nil unless char\n    char = char.length\n    char\n  end\nend", "  string.match(/\\\
    A.*\\z/)[0].length\nend", "    string.to_s.length\nend", "  str = \"\"\n  for\
    \ i in string\n    str = str + i\n  end\n  len = 0\n  for i in str\n    len =\
    \ len + 1\n  end\n  return len\nend", "\tstring.length\nend", "  string.size\n\
    end", "  string.to_s.size if string != nil\nend", "  return string.scan(/[\\[\\\
    {]|\\[\\]]|[^[\\]\\[]|{|}/)[0].length\nend", "  string.gsub(/\\W/, '')\nend",
  "    string.to_s.length\nend", "    string.to_s.length\nend", "  if string.nil?\n\
    \    0\n  else\n    string.size\n  end\nend", "    string.size.to_i\nend", "\t\
    string.to_s.each do |i|\n\t\tif (i == 0 || i == nil || i.class == String || i.class\
    \ == Fixnum)\n\t\t\tnext\n\t\tend\n\t\tbreak\n\tend\n\tstring.to_s.length\nend",
  "  string.empty? ? 0 : string.size\nend", "  return string.split.length\nend", " \
    \   len = 0\n    pos = 0\n    while pos<length(string):\n        char = string.subat(pos,\
    \ 1)\n        if char == null\n            len += 1\n        else\n          \
    \  len += 1\n        pos += 1\n    return len\nend", "  string.gsub(/[\\x00-\\\
    x1f]/, '').length\nend", "  if string == nil then\n    string = ''\n  end\n  return\
    \ string.len\nend", "  # Return the length of a string in bytes\n  string_length\
    \ = string.length\n  # Convert string.length to string.length.to_s\n  string_length\
    \ = string_length.to_s\n  # Return length of given string\n  string_length.to_i\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| a |>\nI believe you can do this:\n<code>\n\
    irb(main):001:0> strlen = String.new\n=> #<String:0x007fcfab60c240>\nirb(main):002:0>\
    \ strlen.method(:length)\n=> #<Method: String(Kernel#length)>\nirb(main):003:0>\
    \ strlen.length\n=> 0\nirb(main):004:0> strlen = \"asdf\".length\n=> 3\nirb(main):005:0>\
    \ strlen\n=> \"asdf\"\nirb(main):006:0> strlen.length\n=> 3\nirb(main):007:0>\
    \ strlen = <<EOS\n...> Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\n\
    ...> Donec molestie, massa a ultrices consequat, purus ex suscipit\n...> odio,\
    \ id cursus ante leo sed felis. Etiam vel lacus libero,\n...> imperdiet libero\
    \ at, pellentesque quam. Proin nibh lacus, ultricies\n...> sed imperdiet sit amet,\
    \ mattis id quam. Nullam hendrerit diam enim\n...> laoreet faucibus. Donec a tellus\
    \ et lorem luctus ullamcorper. Nam\n...> congue mi turpis, eget tincidunt metus\
    \ tempor in. Donec sollicitudin\n...> sapien id libero luctus lacinia. Vestibulum\
    \ a augue sit amet tellus\n...> tincidunt consequat. Donec ac augue eu erat semper\
    \ consequat. Etiam\n...> id sem velit, sed mattis magna. Vivamus porta tellus\
    \ quis metus iaculis\n...> egestas. Vestibulum sit amet lorem non leo consequat\
    \ con", "  string.to_s.length\nend", "  return string.split(\"\").inject(:length)\n\
    end", "  if string and string != ''\n    string.to_s.length\n  else\n    length\n\
    \  end\nend", "  string.length\nend\n</code>\n<|/ a dscore=5 tags=ruby-on-rails,ruby\
    \ |>\n<| c |>\nThanks, that worked! Now I only need to figure out how to return\
    \ an array of only the valid characters. Thanks!\n<|/ c |>\n<| a tags=ruby-on-rails,ruby\
    \ dscore=4 |>\nUse String#unpack:\n<code>\n\"abc\".unpack(\"c\")", "  return string.split(//).inject(0,|)\
    \ { |sum, char| sum + char.length }\nend\n</code>\nYou can simplify this as Ruby\
    \ has some nice methods to deal with length. Also, notice that I return the length\
    \ of the string in Ruby because this is what most Rubyists would do. Another option\
    \ is to use the length method.\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis isn't\
    \ actually a valid Ruby method; it's missing a colon.\n<|/ c |>\n<| c |>\nActually,\
    \ it isn't a Ruby method, it's a method that's implemented in C. See: http://svn.ruby-lang.org/cgi-bin/viewvc.cgi/trunk/ext/string/extconf.rb?view=markup&root=ruby-core\n\
    <|/ c |>\n<| c |>\n: You're right, it was a method implemented in C. I've modified\
    \ my answer to include that.\n<|/ c |>\n<| c |>\nJust to make sure I'm clear:\
    \ this *is* a Ruby method. Not a C method. Nothing to do with C at all. Your link\
    \ to the C source is wrong, sorry.\n<|/ c |>\n<| c |>\n: You're quite right. I\
    \ was using the method as a drop-in replacement for Ruby's `length`, but I see\
    \ now that this is indeed implemented as a C method.\n<|/ c |>\n<| a |>\nIf you\
    \ just want to get the number of characters in an array, you can do:\n<code>\n\
    array.length\n</code>\nAnd if you just want to get an item in a Ruby array by\
    \ its index, you can do:\n<code>\narray[index]\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=5 |>\n<| c |>\n`array.length` is the Ruby method.\n<|/ c |>\n<| c |>\n\
    This is not an answer to the question.  He asked for the length of a string, not\
    \ a array.  Also, the asker did not ask for the item!\n<|/ c |>\n<| a dscore=5\
    \ |>\nThere are several ways to get the length of a string.\n<code>\nmy_string.length\
    \ #Ruby 1.9.x\nmy_string.length #Ruby 2.x\nmy_string.length.to_f #Ruby 1.8.x\n\
    my_string.length.to_i #Ruby 1.9.x\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    Thanks, this helped me out.  As far as I can tell, Ruby 1.8.7 and 1.9.2 are the\
    \ only versions who have this behaviour.\n<|/ c |>\n<|", "\tstring.scan(/[^\\\
    x00-\\xFF]/)\n\tstring.scan(/[\\x00-\\xFF]/)\n\tstring.scan(/[\\x00-\\xFF]/)\n\
    \tstring.scan(/[^\\x00-\\xFF]/)\n\tstring.scan(/[\\x00-\\xFF]/)\n\tstring.scan(/[^\\\
    x00-\\xFF]/)\n\treturn string.scan(/[\\x00-\\xFF]/).count\nend", "  return string.length\
    \ if string.respond_to?(:length) else\n    string.bytesize\nend", "  string.split(\"\
    \").inject(0) do |sum, chr|\n    sum + chr.length\n  end\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| c |>\nThe downside of this is that it creates unnecessary temporary\
    \ strings. I'd use `String#length` instead, which doesn't create a temporary string\
    \ when not needed.\n<|/ c |>\n<| c |>\n, `String#length` would be nice but that\
    \ method doesn't exist. I'd expect it to just return the count of characters.\
    \ I'd also expect it to return 0 for an empty string, like `''.length` does, but\
    \ instead it just returns `nil`.\n<|/ c |>\n<| c |>\nThat's true, I was thinking\
    \ about `length`. Sorry.\n<|/ c |>\n<| a dscore=1 |>\nThis should work if you\
    \ like terseness and don't mind a little bit of performance (but I'm a Ruby newbie,\
    \ so this might not be the case):\n<code>", "  string.size\nend", "  return string.size.to_i\n\
    end", "  string.to_s.split('').size\nend", "  # TODO: convert `string` to `array`\n\
    \  # TODO: return length of `array`\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| a tags=ruby,arrays dscore=2 |>\nYou might want to look into using the each_char\
    \ method of the String class. See here.\n<|/ a |>\n<| a dscore=2 |>\nYou can do\
    \ it with a regex and a little bit of extra work by using the following regex:\n\
    <code>\n/\\w/\n</code>\nThe \\w  will match a single word character (a-z, A-Z,\
    \ 0-9, etc)\nThe code would look something like this:\n<code>", "  string.count(\"\
    \\0\") + 1\nend", "    string.to_s.size\nend", "  # Define variables\n  length\
    \ = 0\n  character = ''", "  # Check for string\n  if string == ''\n    0\n  #\
    \ Else return length of string\n  else\n    string.length\n  end\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis should be the accepted answer as it's much cleaner and\
    \ faster than the others.\n<|/ c |>\n<| c |>\nAgreed.  This should be the accepted\
    \ answer.\n<|/ c |>\n<| a |>\n<code>", "  # Check if given string has length 0\
    \ or not\n  if string.empty?\n    0\n  else\n    string.size\n  end\nend", " \
    \ strlen = string.size\n  string.size = 0\n  string\nend", "    string_length\
    \ = length(string)\n    if string_length == 0\n        return string_length\n\
    \    return string_length\nend", "  return string.size\nend", "  string.length\n\
    end", "  string.split(//).map {|x| x.length}.reduce(:+)\nend", "  string.to_s.size\
    \ if string != \"\" else 0\nend", "  string.to_s.length\nend\n  ", "  return string.split(//).last\n\
    end", "  string.to_s.length\nend", "  string = string.to_s\n  string.gsub!(/[^\\\
    x00-\\x7f]/n, '') # Removes non-ASCII characters\n  string.length\nend", "\tstring.dup\n\
    \tstring.each_byte {|e| e}\n\tstring.size\nend", "  return string.size\nend",
  "  return string.size\nend", "  string.to_s.length\nend", "  ret = 0\n  string.gsub(/[^\\\
    x00-\\x7f]/) do |char|\n    ret += 1\n  end\n  ret\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nA more idiomatic way would be `string.mb_chars.count`.\n<|/ c |>\n<| a\
    \ |>\nThe solution provided by is perfect but doesn't work on multibyte characters.\
    \ \nI found the solution using regexp on rails github repo here https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/string/multibyte/chars.rb\n\
    The regexp is:\n<code>\nCHARACTERS_RE = Regexp.union(\n  /[\\0-\\x7F-\\x{10FFFF}]/,\n\
    \  /[\\x{10000}-\\x{1FFFF}\\x{2FFFE}-\\x{2FFFF}\\x{3FFFE}-\\x{3FFFF}\\x{4FFFE}-\\\
    x{4FFFF}\\x{5FFFE}-\\x{5FFFF}\\x{6FFFE}-\\x{6FFFF}\\x{7FFFE}-\\x{7FFFF}\\x{8FFFE}-\\\
    x{8FFFF}\\x{9FFFE}-\\x{9FFFF}\\x{AFFFE}-\\x{AFFFF}\\x{BFFFE}-\\x{BFFFF}\\x{CFFFE}-\\\
    x{CFFFF}\\x{DFFFE}-\\x{DFFFF}\\x{EFFFE}-\\x{EFFFF}\\x{FFFFE}-\\x{FFFFF}\\x{10FFFE}-\\\
    x{10FFFF}]/u\n)\n</code>\nAnd then use it in ruby like that\n<code>\nstring.scan(CHARACTERS_RE).length\n\
    </code>\nThis solution will work on all ruby version (not only rails) :D\n<|/\
    \ a tags=ruby,string dscore=3 |>\n<| c |>\nWhat are the `0` and the `u` doing\
    \ here?\n<|/ c |>\n<| c |>\n`u` prefix on regexp means that regexp works on utf8\
    \ characters, you can read about it [here](http://www.regular-expressions.info/unicode.html)\n\
    <|/ c |>\n<| c |>\nBut what is the `u` for? The regex just says `\\x{10000}-\\\
    x{1FFFF}` and so on\n<|/ c |>\n<| c |>\n`\\x{10000}` is unicode character code.\
    \ It means `\\x{1F000}`. `\\x{1F000}` is ", "  string.split(//).length\nend\n\
    </code>\nThe strlen function above is called with a string as an argument, and\
    \ the result is returned.\nThe last thing we need to do is write a Ruby program\
    \ that accepts an argument from the user and displays the length of the string\
    \ entered by the user.\n<code>", "    count = 0\n    for char in string.downcase\n\
    \        count += 1\n    end\n    return count\nend", "  return (string.length\
    \ == nil? 0? 0 : string.length)\nend", "  if string.nil? then return 0 end\n \
    \ string = string.to_s\n  string.scan(/./).reduce(:+)\nend", "  string.split(\"\
    \").reduce(:+)\nend", "  string.count(\"'\")\nend", "  string.length\nend", " \
    \ string.to_s.chars.length\nend", "  return string.size\nend", "  return string.split('').length\n\
    end", "  string.split(\"\").length\nend", "  return string.count(\"\\n\")\nend",
  "  return string.length\nend", "  string.length\nend", "    count = 0\n    string.split(\"\
    \").each do |char|\n        count += 1\n    end\n    count\nend", "  string.to_s.size\n\
    end", "\treturn string.to_s.length\nend", "  return string.split(//).length\n\
    end", "    count = 0\n    \n    length.times do |i|\n      count += 1 if string[i]\
    \ != nil\n    end\n    count\nend", "  string.to_s.length\nend", "  string.size\n\
    end", "  return string.size\nend", "  if string.empty?\n    0\n  else\n    string.size\n\
    \  end\nend", "  string.to_s.length\nend", "    string.split(//)\n    string.split(//).length\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nWhile this code snippet may\
    \ solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| c |>\nOk, so here's how I understand your solution:\n\
    <|/ c |>\n<| c |>\n1) First split the string into parts, based on /. Then 2) return\
    \ the length of the array created at step 1\n<|/ c |>\n<| c |>\nOk, so the steps\
    \ are 1) split string into parts based on '/', 2) return length of that array\
    \ (3). Your code says step 1, then step 2, then step 3\n<|/ c |>\n<| c |>\nI've\
    \ added comments to the code to help explain it.\n<|/ c |>\n<| a tags=ruby,string\
    \ dscore=4 |>\nThe answer by is great but it's overly complicated and is very\
    \ specific to this example. I've used it for my own personal projects but I figured\
    \ it's important to mention that you can use Array#sum:\n<code>\n\"1ab2c3d\".split(//).map(&:to_i).sum\n\
    </code>\nThis would output:\n<code>\n6\n</code>\n<|/ a |>\n<| c |>\nIt works only\
    \ in Ruby 1.9+\n<|/ c |>\n<| a dscore=4 |>\n<code>\n\"1ab2c3d\".split('').sum\n\
    => 6\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n`sum` is an alias for `inject`,\
    \ but `inject` doesn't exist in all versions of Ruby: `1.9.3-p327`\n<|/ c |>\n\
    <| c |>\nI see why this one would be downvoted. The OP didn't state that they\
    \ were using 1.9.\n<|/ c |>\n<| c |>\nI haven't downvoted it. But, why are you\
    \ using the `Array#sum` method instead of `String#count`? I feel like an `inject`\
    \ method is a little muddy.\n<|/ c |>\n<| c |>\n- Good question. ", "  string.to_s.length\n\
    end", "  string.length\nend", "  return string.size\nend", "  string.split(\"\"\
    ).length\nend", "  string.split(//).inject(0) do |length, char|\n    length +\
    \ 1 if char.length\n  end\nend", "    return string.mb_char_size\nend", "  return\
    \ string.to_s.length\nend", "  return string.size\nend", "  return string.size\n\
    end", "  string.split(\"\").inject(0) do |length, char|\n    length + 1 if char.match(/\\\
    A[[:alpha:]]/)\n  end\nend", "  if string.nil?\n    \"\"\n  else\n    string.length\n\
    \  end\nend", "  string.to_s.length\nend", "  string.length\nend", "  string.split(//).map(&:length).inject(:+)\n\
    end", "  string.each_char.inject(0) {|sum, character| sum + character.length}\n\
    end", "  string.split(\"\").length\nend", "  string.length\nend\n</code>\nThe\
    \ same approach is used by many languages, including Python and Ruby.\n<|/ a tags=python,ruby\
    \ |>\n<| a tags=python,ruby |>\nRuby\n<code>\n>> \"hello\".length\n=> 5\n</code>\n\
    In Ruby string lengths method is a method of String class.\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\nUsing Python :\n<code>\nlen(s) \n</code>\n<|/ a tags=python,ruby\
    \ |>\n<| c |>\nThe question was about how to get the length of a string in Ruby.\
    \ You answered how to get the length of a string in Python.\n<|/ c |>\n<| c |>\n\
    I misunderstood your question. You're right. Thx for the correction.\n<|/ c |>\n\
    <| a tags=python,ruby |>\nThe shortest way to get the length of a string in Ruby\
    \ is to pass it through length (which you can then call like a method with parens).\
    \ So, you can just do:\n<code>\n'abc'.length\n</code>\nOr, if you prefer using\
    \ symbols:\n<code>\n'abc'.length\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe question\
    \ was about how to get the length of a string in Ruby. You answered how to get\
    \ the length of a string in Python.\n<|/ c |>\n<| c |>\nI misunderstood your question.\
    \ You're right. Thx for the correction.\n<|/ c |>\n<| a dscore=0 |>\nIf you are\
    \ going to use string interpolation with Ruby, you should be aware that interpolating\
    \ a symbol returns the name of the symbol. For example, \"#{10}\" evaluates to\
    \ \"10\".\nThat being said, you can get the length of a string by calling \"#{str}\"\
    .length\n<|/ a tags=python,ruby |>\n<| a |>\nI used this and it worked for me\n\
    <code>", "    if string.length == 0\n        return 0\n    else\n        return\
    \ string.length\n    end\nend", "    return string.bytesize\nend", "  string.split('').length\n\
    end", "  # Return length of given string\n  # >>> strlen('')\n  # 0\n  # >>> strlen('abc')\n\
    \  # 3\n  string.split(\"\").inject(0) { |sum, element| sum + element.to_s.length\
    \ }\nend\n</code>\n<|/ a |>\n<| c |>\n`''.split.inject` would be the way to go.\
    \ That's what I did in my answer, except I didn't use `inject`. +1 anyway\n<|/\
    \ c |>\n<| c |>\nThat depends. `inject` has some uses in Ruby, but not in all\
    \ cases. I'd suggest `inject` only as a last resort if you're not sure if you\
    \ can do it in one line.\n<|/ c |>\n<| a |>\n<code>", "  # Check if string has\
    \ length property\n  if string.instance_of? String\n    string.length\n  else\n\
    \    string\n  end\nend", "  string.empty? ? 0 : string.bytesize\nend", "  string.split(//).reduce(:+)\n\
    end", "\tstring.split('')\n\tstring.split(' ').length\nend", "  # Return length\n\
    \  string.to_s.length\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nNice and simple\
    \ solution\n<|/ c |>\n<| c |>\nThis doesn't always work. When dealing with unicode\
    \ strings it fails badly. Try `'\xE4\xF6\xFC'.to_s.length`.\n<|/ c |>\n<| a dscore=5\
    \ |>\nI made a gem called \"stringy_accessors\" that is supposed to provide an\
    \ interface similar to Ruby's String#length method.\n<code>", "  string.scan(/^.+$/).size\n\
    end", "  if string.nil? then\n    0\n  else\n    string.size\n  end\nend", " \
    \ return string.to_s.length\nend", "  string.to_s.length\nend", "  string.split.size\n\
    end", "  string.to_s.length\nend", "\tstring.split(nil,nil,-1)\nend", "  # Return\
    \ length of given string\n  len = 0\n  len += (string.size % 4) # if size is even\
    \ number\n  len += (string.size / 4)   # if size is odd\n  len += (string.size\
    \ / 2) # if size is even\n  return len\nend\n</code>\n<|/ a dscore=3 |>\n<| a\
    \ |>\nIt may or may not be an efficient way but it works very well and I use it\
    \ a lot where I need to do string manipulation without using any external tools\
    \ or modules.\n<code>", "  string.to_s.length\nend", "  string.to_s.length\nend\n\
    </code>\n<|/ a |>\n<| c |>\nJust a note: this implementation will return 0 for\
    \ any non-nil object.\n<|/ c |>\n<| c |>\nThis does not return the string length.\
    \ It returns the byte length of the string. http://stackoverflow.com/questions/10371757/how-do-i-find-the-length-of-a-string-in-bytes\n\
    <|/ c |>\n<| a dscore=4 |>\nAs of Ruby 1.9, String#bytesize returns an Integer:\n\
    <code>\nirb(main):001:0> 'x' * 1000\n=> \"x\"*1000\nirb(main):002:0> 'x' * 1009.bytesize\n\
    => 50000\nirb(main):003:0> 'x' * 1000.bytesize\n=> 1000\n</code>\n<|/ a tags=ruby,string,size\
    \ |>\n<| c |>\nThis is not true in Ruby 2.1.3 unfortunately http://stackoverflow.com/questions/11906426/ruby-2-1-3-stringbytesize-method\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>\n\"aaabbbccc\".split(\"aaa\").size #=> 4\n\"\
    aaabbbccc\".split(\"a\").size #=> 3\n</code>\n<|/ a tags=ruby,string,size |>\n\
    <| a tags=ruby,string,size dscore=3 |>\nJust to give an alternative approach for\
    \ those who don't know ruby enumerators\n<code>\n>> \"abac\".each_char.take(2).map(&:to_s).join.size\n\
    => 3\n</code>\n<|/ a |>\n<| c |>\nThat would require iterating over the string\
    \ three times: once to break it up into characters, and then to convert each character\
    \ to a string, and then to calculate the size of the resulting string, which is\
    \ not very efficient or elegant.\n<|/ c |>\n<| c |>\nI think this is more efficient\
    \ than `str.gsub(/./,'').size`. Thanks.\n<|/ c |>\n<| a |>\nThis would be the\
    \ fastest solution in ruby 1.8.7:\n<code>\n[\"\", \"a\", \"a\", \"a\", \"a\"].each_char.take(2).map(&:to_s).join.size\n\
    </code>\nOn my machine it runs in 0.5 sec.\n<|/ a tags=ruby,string,size dscore=3\
    \ |>\n<| c |>\nNice solution, I changed it to `[\"\", \"a\", \"a\", \"a\", \"\
    a\"].map(&:to_s).join.size` to make it a bit more readable.\n<|/ c |>\n", "  return\
    \ string.to_s.length\nend", "  string.gsub(/[^\\x00-\\xff]/, '').length\nend",
  "\tstring.length()\nend", "    string.chars.each do |char|\n        if char.ord\
    \ < 128\n            len += 1\n        else\n            len += 2\n        end\n\
    \    end\n    len\nend", "  length = 0\n  \n  string.each_char do |char|\n   \
    \ length += 1\n  end\n  \n  return length\nend", "  string.split(\"\").length\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nIf one has a `string` variable `foo`,\
    \ then `foo.nil?` returns `true`, whereas `foo.empty?` returns `false`.\n<|/ c\
    \ |>\n<| c |>\nIt doesn't work in Ruby 2.4.0 because `split` has been deprecated.\n\
    <|/ c |>\n<| c |>\nThis doesn't work in Ruby 2.4.0 (but does in Ruby 2.5.0). `String.split`\
    \ no longer exists and is replaced by `String#split`. It also doesn't work with\
    \ the `--enable-new-relic` option, which disables some new features related to\
    \ instrumentation (e.g. `String#split`).\n<|/ c |>\n<| c |>\nThis does not work\
    \ in Ruby 2.5.0 for me. `split` is not a method on `string`. `split(\"\").length`\
    \ works.\n<|/ c |>\n<| c |>\n`string.split(\"\").length` in ruby 2.4.0 works but\
    \ `string.split.length` in ruby 2.5.0 doesn't\n<|/ c |>\n<| a dscore=5 |>\nI know\
    \ this has been answered already, but this isn't a Ruby method - it's an extension\
    \ method written by someone else, so it isn't a part of core Ruby, which is where\
    \ most of the Ruby core functionality is defined. It's also written in C, so it's\
    \ likely to be a little slower. Here's a more recent implementation:\n<code>",
  "    string.to_s.length\nend", "  # TODO: implement a more efficient version for\
    \ larger strings\n  string.length\nend", "  string.split('').length\nend", " \
    \ return string.length if string and string.length != 0 else None\nend", "  string.length\n\
    end", "  # Convert string to bytes array\n  string = to_bytes(string)\n  # Return\
    \ length of given string\n  # >>> strlen('abc')\n  # 3\n  string.size\nend\nend",
  "  string.to_s.length\nend", "  string.length\nend", "  if string.nil? then\n  \
    \  \"\".length\n  else\n    string.length\n  end\nend", "  string.split(//).length\n\
    end", "  string.gsub(/\\r/, '')\n  string.length\nend", "  string.size.to_i\n\
    end", "\t\n\t# Return 0 if string is empty\n\tif string == ''\n\t\treturn 0\n\t\
    \n\tcount = 0\n\t\n\tfor i in string\n\t\tcount += 1\n\t\n\treturn count\nend",
  "  result = 0\n  string.each_char { |c| result += 1 }\n  result\nend", "  return\
    \ string.length\nend", "  if string.is_a? String\n    string.size\n  else\n  \
    \  string.to_s.size\n  end\nend\nalias length strlen", "  return string.to_s.length\n\
    end", "  i = 0\n  while string[i] != nil and string[i] != ':'\n    i = i + 1\n\
    \  end\n  return i\nend", "    length = 0\n    length = string.count(\"'\")\n\
    \    length = string.count(\"\\\"\") + length\n    length = string.count(\"\\\
    n\") + length\n    length = string.count(\"\\r\") + length\n    length = string.count(\"\
    \\t\") + length\n    length = string.count(\"\\t\\n\") + length\n    length =\
    \ string.count(\"\\t\\r\") + length\n    length = string.count(\"\\t\\r\\n\")\
    \ + length\n    length = string.count(\"\\n\") + length\n    length = string.count(\"\
    \\r\\n\") + length\n    length = string.count(' ')\n    length = string.count('\
    \ ') * length\n    length = string.count('\\t') + length\n    length = string.count('\\\
    t') + length\n    length = string.count('\\n') + length\n    length = string.count('\\\
    r\\n') + length\n    length = string.count(' ') * length\n    length = string.count('\
    \ ') * length\n    length = string.count('\\t') + length\n    length = string.count('\\\
    t') + length\n    length = string.count('\\n') + length\n    length = string.count('\\\
    r\\n') + length\n    length = string.count(' ') * length\n    length = string.count('\
    \ ') * length\n    length = string.count('\\t') + length\n    length = string.count('\\\
    t') + length\n    length = string.count('\\n') + length\n    length = string.count('\\\
    r\\n') + length\n    length = string.count(' ') * length\n    length = string.count('\
    \ ') * length\n    length = string.count('\\t') + length\n    length = string.count('\\\
    t') + length\n    length = string.count('\\n') + length\n    length = string.count('\\\
    r\\n') + length\n    length = string.count(' ') * length\n    length = string.count('\
    \ ') * length\n    length = string.count('\\t') + length\n    length = string.count('\\\
    t') + length\n    length = string.count('\\n') + length\n    length = string.count('\\\
    r\\n') + length\n    length = string.count(' ') * length\n    length = string.count('\
    \ ') * length\n    length = string.count('\\t') + length\n    length = string.count('\\\
    t') + length\n    length = string.count('\\n') + length\n    length = string.count('\\\
    r\\n') + length\n    length = string.count(' ') * length\n    length = string.count('\
    \ ') * length\n    length = string.count('\\t') + length\n    length = string.count('\\\
    t') + length\n    length = string.count('\\n') + length\n    length = string.count('\\\
    r\\n') + length\n    length = string.count(' ') * length\n    length = string.count('\
    \ ') * length\n    length = string.count('\\t') + length\n    length = ", "  return\
    \ string.length if string.respond_to?(:length) then string.length else string.to_s.length\
    \ end\nend", "  string.to_s.length\nend", "  string.size\nend", "  string.split('').length\n\
    end\nend", "\tstring.scan(/[^\\x00-\\xff]/)\n\tstring.size\nend", "  return string.size\n\
    end", "  str = ''\n  while not string.empty? do\n    str = str + string.slice!(0,\
    \ 1).to_s\n    string = string.slice!(1,string.length)\n  end\n  return str.length\n\
    end", "  if string.nil? or string == ''\n    return 0\n  else\n    string.size.to_i\n\
    \  end\nend", "  string.to_s.length\nend", "  string.to_s.size # String size will\
    \ be returned in Ruby\nend", "  return string.to_s.length\nend", "  return string.size\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis code doesn't work as-is for Ruby 1.9. `string.size`\
    \ has been deprecated.\n<|/ c |>\n<| a tags=ruby,string |>\nIt can be done using\
    \ Regex\n<code>\n\"Hello World\"[/[A-Z]+/]\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    I think this is the best way to achieve this in ruby 1.9\n<|/ c |>\n<| c |>\n\
    Why doesn't Ruby do this?\n<|/ c |>\n<| c |>\nIt's not the best way. It is very\
    \ inefficient and won't work with unicode strings.\n<|/ c |>\n<| c |>\nThis answer\
    \ is incorrect because it misses what he asked for, namely the length of the string.\
    \ This answer returns the number of uppercase letters, not the number of characters\
    \ in the string.\n<|/ c |>\n<| c |>\nTo add to what said, this actually returns\
    \ the number of characters in the string that have at least one uppercase letter,\
    \ whereas the accepted answer returns the length of the string. See my answer\
    \ below for an explanation.\n<|/ c |>\n<| a dscore=5 tags=ruby,string |>\nTo get\
    \ the number of characters in a string with uppercase letters, use this:\n<code>\n\
    \"Hello World\"[/[A-Z]+/].length\n</code>\nIn Ruby 1.8.7 and earlier, you can\
    \ use:\n<code>\n\"Hello World\".size\n</code>\n<|/ a |>\n<| c |>\nThis was very\
    \ helpful! I wanted to count the number of characters in a string with the first\
    \ letter capitalized. This worked perfectly. Thanks!\n<|/ c |>\n<| c |>\nI use\
    \ this method. `string.size` didn't work!\n<|/ c |>\n<| c |>\nJust to add my 2\
    \ cents, the correct way is to use `string.bytesize` instead of `string.size`.\n\
    <|/ c |>\n<| a tags=ruby,string |>\nIf you're using Rails then ActiveSupport has\
    \ a helper method which works on both 1.8.7 and 1.9.2. As mentioned above, Ruby\
    \ 1.8.7 and earlier don't have a size method on string. Here is an example for\
    \ Rails:\n<code>\n\"hello world\".mb_chars.length\n=> \"hello world\".mb_chars.count\n\
    => \"hello world\".mb_chars.chars.length\n=> \"hello world\".mb_chars.length\n\
    => \"hello world\".mb_chars.bytesize\n=> \"hello world\".mb_chars.length\n=> \"\
    hello world\".mb_chars.bytesize\n=> 25\n</code>\n", "  return string.count('\\\
    n')\nend", "  return string ? string.length : 0\nend", "  string.length\nend",
  "  string.length\nend\nend", "  # Return length of given string\n  return string.length\n\
    end", "  if string.empty?\n    0\n  else\n    string.length\n  end\nend", "  #\
    \ Convert string to a char/byte array\n  string = string.to_s", "  string.split(\"\
    \").length\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nI did not know\
    \ you could do this in Ruby, that's pretty cool.\n<|/ c |>\n<| c |>\nThis is probably\
    \ the most 'rubyish' solution in Ruby that I've seen. But I'd be interested in\
    \ hearing some opinions on whether this is 'ruby-ish' or 'not so ruby-ish'.\n\
    <|/ c |>\n<| c |>\nIt looks fine to me though.  I'd have to look into it some\
    \ more to know what that line is doing.\n<|/ c |>\n<| c |>\nIt's a common idiom,\
    \ but I don't like the `eval` statement too much.  I'd rather use a different\
    \ approach - or at least a way to make it a bit more explicit that it's not Ruby-ish.\n\
    <|/ c |>\n<| c |>\nThanks for all the help everyone! I'll definitely be working\
    \ on implementing some of these ideas from here on out!\n<|/ c |>\n<| a tags=ruby\
    \ |>\nOne more solution:\n<code>", "\tstring.split(\"\").length\nend", "  return\
    \ string.length\nend", "  return string.to_s.length\nend", "  return string.length\
    \ if string != nil then string.length else 0\nend", "  # string\n  # Return length\
    \ of given string\n  # >>> strlen('')\n  # 0\n  # >>> strlen('abc')\n  # 3\n \
    \ string.size\nend", "  return string.chars.length\nend", "  return string.size\n\
    end\nfunction strlen_len_check(object, method) _check(method, object, object.size)\n\
    end", "  i = 0\n  while string[i] do\n    i += 1\n  end\n  i\nend", "  return\
    \ string.to_s.length\nend", "  string.to_s.length\nend\nRSpec.configure do |config|\n\
    \  config.include StringLength\nend", "    string.split(//).length\nend", "  string.size\n\
    end", "  # string.length\n  string.size\nend", "  string.split(//).inject(:+)\n\
    end", "  return string.to_s.length\nend", "\tstring.count(\"\\n\") + string.count(\"\
    \\r\") + string.count(\"\\t\")\nend", "  string.to_s.length\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| a dscore=5 |>\nYou can use Ruby's built-in #length method\n\
    <code>\n\"abc\".length", "  # Return length of given string\n  # >>> strlen([])\n\
    \  # 0\n  # >>> strlen([''])\n  # 0\n  # >>> strlen(['abc'])\n  # 3\n  # >>> strlen(['a','b','c','d'])\n\
    \  # 4\n  # >>> strlen(['aaaaaaa'])\n  # 7\n  # >>> strlen(['aaaaaaa','aaaaaaa'])\n\
    \  # 8\n  # >>> strlen(['','','','','','','','','',''])\n  # 7\n  # >>> strlen(['a','','','','','','','','','',''])\n\
    \  # 5\n  # >>> strlen(['','','','','','','','','','',''])\n  # 0\n  # >>> strlen(['aaa'])\n\
    \  # 3\n  # >>> strlen(['','','','','','','','','','',''])\n  # 0\n  # >>> strlen(['','','','','','','','','','',''])\n\
    \  # 0\n  # >>> strlen(['a'])\n  # 1\n  # >>> strlen(['a',''])\n  # 2\n  # >>>\
    \ strlen(['a','a'])\n  # 3\n  # >>> strlen(['a','b','c','','','','','','','',''])\n\
    \  # 0\n  # >>> strlen(['a','b','c','d','','','','','','',''])\n  # 3\n  # >>>\
    \ strlen(['a','b','c','d','e','','','','','',''])\n  # 4\n  string = string.to_s\n\
    \  length = string.length\n  if length == 0 \n    length = 1\n  else\n    length\
    \ = length-1\n  end\n  length\nend", "  length = 0\n  string.split(\"\").each\
    \ do |char|\n    length += 1\n  end\n  length\nend", "  string.size\nend", " \
    \ if string.nil?\n    0\n  else\n    string.to_s.length\n  end\nend", "  return\
    \ string.size\nend", "  string.size\nend", "  string.length\nend", "  return string.to_s.length\n\
    end", "  return string.size\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
