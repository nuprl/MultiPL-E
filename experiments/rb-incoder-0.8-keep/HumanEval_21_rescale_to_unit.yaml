name: HumanEval_21_rescale_to_unit
language: rb
prompt: "# Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n# such that the smallest number will become 0 and the largest will\
  \ become 1\n# >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5,\
  \ 0.75, 1.0]\ndef rescale_to_unit(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rescale_to_unit\n\
  \    candidate = method(:rescale_to_unit)\n    assert_equal([0.0, 1.0], candidate.call([2.0,\
  \ 49.9]))\n    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))\n    assert_equal([0.0,\
  \ 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n    assert_equal([0.25,\
  \ 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))\n    assert_equal([0.25,\
  \ 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))\n  end\n\
  end\n"
completions: ["  min = numbers.min\n  max = numbers.max\n  diff = (max - min) / 2\n\
    \  new_min = min - diff\n  new_max = max + diff\n  scaled_numbers = []\n  for\
    \ x in numbers\n    scaled_numbers.push x*new_max/new_min\n  end\n  return scaled_numbers\n\
    end", "  result = []\n  numbers.each do |num|\n    result.push(min + (max - min)*num)\n\
    \  end\n  return result\nend\n</code>\nA few points to note:", "  min = numbers.min\n\
    \  max = numbers.max\n  if min == max\n    min = 0\n    max = 1\n  end", "  numbers.map\
    \ { |n| min(0, max(1, n)) }\nend", "  number_sum = 0\n  numbers.each do |n|\n\
    \    number_sum += n\n  end\n  numbers.map { |n| n/number_sum }\nend", "  numbers.min\n\
    end", "  return numbers.map {|n| n * 1.0 / numbers.max }\nend", "  smallest, largest\
    \ = numbers.min, numbers.max\n  (smallest, largest) = [smallest] if (smallest\
    \ == 0.0) else [smallest, largest]\n  result = []\n  while smallest.nonzero? &&\
    \ largest.nonzero?\n    current =  smallest + (largest - smallest) * (rand(1..2)\
    \ - 1.0) / 2.0\n    current = 0.0 if current < smallest || current > largest ||\
    \ current == 0.0 || current == largest\n    result << current\n  end\n  result\n\
    end", "  numbers.each_with_index do |num, i|\n    if num < numbers[0]\n      numbers[i]\
    \ = 0.0;\n    elsif num > numbers[numbers.length - 1]\n      numbers[i] = 1.0;\n\
    \    end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI know this\
    \ is an old question, but I came up with a more concise solution than the one\
    \ that has been accepted here.\n<code>", "    smallest = numbers.min_by{ |n| n.abs\
    \ }\n    largest = numbers.max_by{ |n| n.abs }\n    difference = largest - smallest\n\
    \    numbers[0] = smallest + (difference / numbers.size)\n    numbers.each { |n|\
    \ n /= difference }\n    numbers\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<|\
    \ c |>\nThis doesn't do the same thing as the OP's example (it returns `[0.0,\
    \ 0.2, 0.4, 0.6, 0.8, 1.0]`). Also, what happens if there are two numbers that\
    \ are equal?\n<|/ c |>\n<| c |>\nYou're right, it is not doing what OP asks. I'll\
    \ edit the answer and add an option to replace zero-value numbers with ones\n\
    <|/ c |>\n<| a |>\nAssuming you're trying to normalize your data, I'd recommend\
    \ doing something like this (assuming your input is an array of numbers):\n<code>",
  "  sum = numbers.reduce(:+) # sum of all numbers\n  numbers.map {|n| n / sum }\n\
    end\n</cell>\n<text>\nThe above method can be implemented in a more elegant way\
    \ using Enumerable#inject:", "  numbers.sort!\n  min = numbers.first\n  max =\
    \ numbers.last\n  min = min == min ? 0 : min\n  max = max == max ? 1 : max\n \
    \ numbers.map { |number| number / (max - min) }\nend\n</code>\n<|/ a |>\n<| a\
    \ dscore=3 tags=ruby,math,algorithm |>\nThis is similar to Matthew Cruse's answer,\
    \ but uses Floyd's Method to avoid computing the factorial. \nThe difference is\
    \ that this one can handle a range of numbers smaller than 1.\n<code>", "  numbers.inject(0.0,\
    \ &:min)\n  numbers.inject(1.0, &:max)\nend", "  numbers.map!{|x| x / numbers.min}\n\
    end\n</code>\nA more general approach is to take a \"window\" of the data, such\
    \ that the smallest value \"belongs\" to the window and will have a value smaller\
    \ than the smallest value in the next window.  Here we use a window size of 2.\n\
    <code>", "  numbers.each_with_index do |n, i|\n    smallest = i\n    largest =\
    \ i\n    n.to_i.times do |i|\n      smallest = i if n < numbers[smallest]\n  \
    \    largest = i if n > numbers[largest]\n    end\n    numbers[smallest] = 0\n\
    \    numbers[largest] = 1\n  end\n  numbers\nend", "  minimum = numbers.min\n\
    \  maximum = numbers.max\n  minimum, maximum = 0.0, 1.0\n  number_list = (numbers\
    \ - minimum) / (maximum - minimum)\n  number_list += 0.5\n  number_list\nend\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\n`number_list += 0.5` can simply be `number_list`\
    \ since `number_list` is already the result of the calculation that needs to be\
    \ scaled.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  minimum = numbers.inject\
    \ { |r, number| r <= number ? r : number }\n  maximum = numbers.inject { |r, number|\
    \ r >= number ? r : number }\n  maximum - minimum\nend", "  return numbers / (numbers.max()\
    \ - numbers.min())\nend", "  numbers.min!(0.0)\n  numbers.max!(0.0)\n  return\
    \ numbers - (numbers.min/numbers.max) *  (numbers.max-numbers.min)\nend\n</cell>\n\
    <text>\nThe sigmoid function\n$$sigmoid(x) = \\frac{1}{1+exp(-x)}$$", "  numbers.min!=0\n\
    \  numbers.max!=1\n  return numbers / numbers.max\nend", "  min, max = numbers.minmax_element\n\
    \  min == 0 ? 0 : max - min / max\nend\n</code>\nIt returns [0.0, 0.25, 0.5, 0.75,\
    \ 1.0], as you requested.\n<|/ a tags=arrays,ruby,ruby-on-rails |>\n<| c |>\n\
    This is quite a good answer, but this seems like it assumes that all elements\
    \ are non-negative, and if they are not, the results are incorrect.\n<|/ c |>\n\
    <| c |>\nI suppose I didn't take into account the fact that OP didn't mention\
    \ that they didn't want to handle negative numbers. The question wasn't clear\
    \ on that, but I agree that `max` should be adjusted to take that into account.\n\
    <|/ c |>\n<| c |>\nI added a comment above to the question asking about negative\
    \ numbers. It's not my intention to have negative numbers in the rescaled array.\
    \ How would I modify the code above to account for negative numbers?\n<|/ c |>\n\
    <| c |>\nThe updated answer will do that.\n<|/ c |>\n<| a tags=arrays,ruby,ruby-on-rails\
    \ |>\nTry this:\n<code>\narr = [1.0, 2.0, 3.0, 4.0, 5.0]\narr = arr.reduce(:+)\
    \ / arr.size\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThat gives me a syntax error:\
    \ `undefined method `size' for [1.0, 2.0, 3.0, 4.0, 5.0]:Array`\n<|/ c |>\n<|\
    \ c |>\nAh yes, I see. It does work if I change it to `arr.size`, but it seems\
    \ like it needs a :+ at the end to do the division.\n<|/ c |>\n<| a |>\nI would\
    \ do it using inject method with accumulator set to 0.0 which would keep track\
    \ of sum for each element. For example:\n<code>\nirb(main):009:0> a = %w(1.0 2.0\
    \ 3.0 4.0 5.0)\n=> [\"1.0\", \"2.0\", \"3.0\", \"4.0\", \"5.0\"]\nirb(main):010:0>\
    \ a.inject(:+) / a.size\n=> 0.75\n</code>\n<|/ a tags=arrays,ruby,ruby-on-rails\
    \ dscore=3 |>\n<| a |>\nYou can avoid all the calculations and divisions by using\
    \ Enumerable#reduce:\n<code>\narr = [1.0, 2.0, 3.0, 4.0, 5.0]\narr.reduce(:+)\
    \ / arr.size", "  numbers.each_with_index do |n, i|\n    if n < numbers[0]\n \
    \     n *= 1 / numbers[0]\n      numbers.delete_at(i-1)\n    end\n  end\n  numbers\n\
    end", "  # Find the two largest numbers and scale them accordingly\n  min_number\
    \ = numbers.min\n  max_number = numbers.max\n  new_min = min_number / max_number\n\
    \  new_max = max_number / min_number\n  # Then scale all the numbers in the list\
    \ by this amount\n  scaled_numbers = numbers.map {|n| (new_max - new_min) * n\
    \ }\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks. I added a similar example\
    \ to my question. Would you mind taking a look?\n<|/ c |>\n<| c |>\nThat example\
    \ only works for lists with 2 elements because of the way the calculation is done.\
    \ I edited my answer to include a solution which works for any list of numbers.\n\
    <|/ c |>\n<| a |>\nThis is one of the cases where using an array might make sense.\
    \ E.g. for n elements:\n<code>", "  numbers.min!(0.0)\n  numbers.max!(1.0)\n \
    \ numbers*(numbers>0.0) + numbers.min*(numbers>0.0) + numbers.max*(numbers<0.0)\n\
    end", "  min_value = numbers.min\n  max_value = numbers.max\n  return numbers.map\
    \ { |number| (number - min_value) / (max_value - min_value) }\nend", "  return\
    \ [numbers.min]  if numbers.empty?\n  smallest_number = numbers[0]\n  numbers.each\
    \ do |number|\n    smallest_number = number if smallest_number > number\n  end\n\
    \  [smallest_number]\nend\n</code>\n<|/ a |>\n<| c |>\n\"Your question was about\
    \ how to implement a function that \"scales\" a list such that it would contain\
    \ the smallest and largest numbers in that list\" - your answer is about how to\
    \ implement a function that \"scales\" a list such that it would contain the smallest\
    \ and largest number in that list, but your example is about how to scale a list\
    \ from 1.0 to 1.0 (so each number would become 0). These are different things.\
    \ The answer is wrong for the example in the question (and the answer is correct\
    \ for the example in the answer).\n<|/ c |>\n<| c |>\nIt's not wrong; my answer\
    \ shows how to scale a list from 0.0 to 1.0 (one number becomes 0)\n<|/ c |>\n\
    <| c |>\nHmm, you're right, I got confused. Still, I think your example doesn't\
    \ show how to scale a list from 1.0 to 1.0 (one number becomes 0). Your answer\
    \ says \"scale from 0.0 to 1.0\", but your example shows \"scale from 1.0 to 1.0\"\
    . I think your answer is wrong for your example.\n<|/ c |>\n<| c |>\n: I agree\
    \ that the answer is not clear.  I believe that his example is close enough to\
    \ what he was looking for that he will understand it.  If he needs more help with\
    \ the question I will revise it.  I have revised my answer to use his example\
    \ more closely.  Thanks for pointing out my mistake.\n<|/ c |>\n<| c |>\nI think\
    \ the answer is correct. There is no reason to find the minimum value of the list\
    \ when there are two elements, so it's ok to return [0.0]\n<|/ c |>\n<| a tags=ruby\
    \ |>\nHere's one way you can do it:\n<code>", "  min_num = numbers.min\n  max_num\
    \ = numbers.max\n  if min_num == max_num\n    return numbers\n  min_num += 1\n\
    \  max_num -= 1\n  numbers = (numbers - min_num) / (max_num - min_num)\n  return\
    \ numbers\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nGood point about not wanting\
    \ to reinvent the wheel. I would use [this solution](http://stackoverflow.com/a/4371967/44729)\
    \ to avoid the dependency on [statistics](https://github.com/nathan-russell/statistics)\n\
    <|/ c |>\n<| a tags=ruby,math dscore=3 |>\nI wrote a method that returns the mean\
    \ of a given array of numbers.\nI needed to be able to handle negative numbers\
    \ properly.\n<code>", "  numbers.map! {|n| n / maximum(n) }\nend\n</code></pre>\n\
    <h2 id=\"find-the-maximum-of-a-list\">Find the maximum of a list</h2>\n<pre><code\
    \ class=\"ruby\"># Given a list of numbers, find the maximum number", "  # We\
    \ make the following transformations:\n  # 1. Make sure the smallest number is\
    \ 0 and the largest is 1\n  # 2. Make sure the largest number is 1 and the smallest\
    \ is 0\n  numbers.each { |number| return number if number < 1.0\n    numbers.each\
    \ { |number| return number if number > 0.0\n    }\n  }\n  return numbers\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI'm posting this as another answer\
    \ because I've been asked to do so by someone else. \nFor some reason, my other\
    \ answer (which was downvoted) had been deleted, so I've created a very simple\
    \ code which uses linear interpolation to approximate the values.\nThis is based\
    \ on my own original answer (which was downvoted).\nThis answer does use the same\
    \ formula as my other answer (but with my new modifications).\nIt interpolates\
    \ between 0 and 1 but doesn't need this since it will always return a number between\
    \ 0 and 1.\nThe code assumes that you have an array of values that you want to\
    \ interpolate between. Here, it's an array of length 3.\nIt then loops over the\
    \ array, calculating the interpolated value using an alpha value between 0 and\
    \ 1.\nTo calculate the alpha value, you need the original value and the new value.\n\
    <code>", "  numbers.map(&:to_f).minmax\nend", "  numbers = numbers.map { |n| n\
    \ / 100 }\n  numbers.first\nend", "  # Sort the numbers by smallest to largest\n\
    \  numbers = numbers.sort", "  min_index = 1\n  max_index = numbers.length - 1\n\
    \  smallest_number = numbers.min\n  largest_number = numbers.max\n  while smallest_number\
    \ == 0 and max_index > 0\n    min_index -= 1\n    max_index -= 1\n    smallest_number\
    \ = numbers.at(min_index)\n    largest_number = numbers.at(max_index)\n  while\
    \ smallest_number == 0 and max_index == 0\n    smallest_number = numbers.min\n\
    \    largest_number = numbers.max\n    min_index += 1\n    max_index += 1\n  \
    \  smallest_number = numbers.at(min_index)\n    largest_number = numbers.at(max_index)\n\
    \  while smallest_number == 0 and max_index == 0\n    smallest_number = numbers.min\n\
    \    largest_number = numbers.max\n    min_index -= 1\n    max_index -= 1\n  \
    \  smallest_number = numbers.at(min_index)\n    largest_number = numbers.at(max_index)\n\
    \  while smallest_number == 0 and max_index == 0\n    smallest_number = numbers.min\n\
    \    largest_number = numbers.max\n    min_index -= 1\n    max_index -= 1\n  \
    \  smallest_number = numbers.at(min_index)\n    largest_number = numbers.at(max_index)\n\
    \  return [smallest_number, (largest_number - smallest_number) / (max_index -\
    \ min_index)]\nend", "  # Convert the list to a numpy array, in order\n  numbers\
    \ = numerix.array(numbers, dtype=numerix.float32)\n  # Find the smallest number\n\
    \  minnumber = numbers.min()\n  # Divide each number by its smallest absolute\
    \ value\n  numbers /= minnumber\n  # Scale each number to range [0, 1]\n  numbers\
    \ *= 2.0 - 1.0\n  # Return the array of scaled numbers\n  numbers\nend", "  return\
    \ numbers.map {|n| n / numbers.inject(:+)}\nend", "  scale = (numbers[-1] - numbers[0])\
    \ / (numbers[1] - numbers[0])\n  return numbers.map {|n| n * scale}\nend", " \
    \ max_value = numbers.max\n  min_value = numbers.min\n  return [(x - min_value)\
    \ / (max_value - min_value) for x in numbers]\nend", "  numbers.map! {|x| x %\
    \ 1.0 }\n  numbers.min!\n  numbers.max!\n  numbers\nend", "  if numbers.empty?\n\
    \    []\n  else\n    scale = 1.0 / numbers.inject(:+) || 1.0\n    numbers * scale\n\
    \  end\nend", "  new_numbers = []\n  i = 0\n  while i < numbers.size\n    if numbers[i]\
    \ < numbers[i - 1]\n      new_numbers.push(numbers[i] * 1.0) while i < numbers.size\
    \ && numbers[i + 1] <= numbers[i]\n      new_numbers.push(0.0) while i < numbers.size\
    \ && numbers[i] <= numbers[i - 1]\n    else\n      new_numbers.push(numbers[i])\
    \ while i < numbers.size && numbers[i] <= numbers[i - 1]\n    end\n    i += 1\n\
    \  end\n  return new_numbers\nend", "  numbers.each_with_index do |num, i|\n \
    \   numbers[i] = num if num > 0.0\n  end\n  numbers.minmax\nend", "  # If there\
    \ are fewer than 2 items, return the same list\n  return numbers if numbers.length\
    \ >= 2 ? numbers : (numbers[0] + numbers[1]) / 2\nend", "  max = numbers.max\n\
    \  min = numbers.min\n  return numbers.map { |n| n / max - min }\nend", "  return\
    \ numbers.map {|n| n / numbers.max}\nend", "  min_number = numbers.min\n  max_number\
    \ = numbers.max", "  numbers.reduce(:+)\nend", "  return numbers.map { |n| n /\
    \ numbers.max }\nend", "  numbers.map { |n| n/numbers.min }\nend", "  smallest\
    \ = numbers.min\n  largest = numbers.max\n  smallest_number = numbers.index{|n|\
    \ n == smallest}\n  largest = numbers.index{|n| n == largest}\n  assert smallest\
    \ > largest\n  assert smallest > 0.0\n  assert largest < 1.0\n  while smallest\
    \ > 0.0\n    smallest -= 1.0\n  end\n  while largest < 1.0\n    largest += 1.0\n\
    \  end\n  largest = largest - smallest\n  smallest = smallest - smallest + largest\n\
    \  smallest = smallest / largest\n  largest = largest / largest\n  return numbers\
    \ * [smallest, largest]\nend", "  minimum = numbers.min\n  maximum = numbers.max\n\
    \  maximum = maximum * 1.0\n  numbers.map! do |n|\n    n / maximum - minimum\n\
    \  end\n  numbers\nend", "  numbers.min\nend", "  numbers.each_with_index do |num,\
    \ i|\n    next if (i == 0 && num == 0)\n    num = num / numbers[0]\n    numbers[i]\
    \ = num\n  end\n  numbers\nend", "  numbers.sort.reverse\n  minval = numbers.min\n\
    \  maxval = numbers.max\n  numbers.min = 0\n  numbers.max = 1.0\n  numbers.map!\
    \ { |v| v * (maxval-minval) / numbers.max }\n  numbers\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nWow, this is amazing. Thank you for such an awesome solution!\n\
    <|/ c |>\n<| c |>\nI've just had a chance to test this and it doesn't appear to\
    \ work if there are negative numbers in the list. Can you suggest a fix for this?\n\
    <|/ c |>\n<| c |>\nIt works fine for me with negative numbers when I try it. I'm\
    \ using Rails 4.2.5 and Ruby 2.1.5p273\n<|/ c |>\n<| c |>\nYes, apologies - it\
    \ appears that I'm just an idiot and had a typo. Thanks for your help.\n<|/ c\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  min = 0\n  max = numbers[0]\n\
    \  for i in 1..numbers.count\n    min = numbers[i-1]\n    max = numbers[i]\n \
    \   if min > max\n      raise \"List should only contain numbers\"\n  end\n  min/=max\n\
    \  max*=1.0\n  return numbers.map{|x| x/max}.collect{|x| x*max+min}\nend", " \
    \ result = numbers.map { |n| n % 1 }\n  result.uniq.sort if result.size > 1\n\
    \  result\nend", "    numbers.min!=0\n    numbers.max!=1\n    sum=0\n    len=numbers.size\n\
    \    i=0\n    while i<len\n        sum=sum+numbers[i]\n        i=i+1\n    len2=len/2.0\n\
    \    while i<len2\n        sum=sum+numbers[i]*1.0/len\n        i=i+1\n    numbers=sum\n\
    end", "  result = numbers.min\n  numbers.min = 0\n  numbers.max 1\nend", "  numbers.min\n\
    end", "  numbers.map { |n| n / numbers.min }\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nthis doesnt seem to handle negative numbers, which is what the OP wants\n\
    <|/ c |>\n<| c |>\nTrue, but you asked for no `range` functions. I took my answer\
    \ as a simple way to illustrate the approach. If you're after a range function\
    \ that takes negative numbers, I can update the answer.\n<|/ c |>\n<| c |>\nI\
    \ updated the answer, it should now handle negative numbers now.\n<|/ c |>\n<|\
    \ c |>\nI like it better, although it can be made shorter: `p / numbers.reduce(:+)`\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,math dscore=1 |>\n<code>", "  numbers.each\
    \ do |number|\n    number = round(number, 1)\n    number.is_a?(Numeric) ? number.round(0,\
    \ 1) : number\n  end\nend", "  numbers.map! { |number| number / numbers.reduce(&:+)\
    \ }\n  numbers[0] = 0\n  numbers[-1] = 1\nend\n</code>\n<|/ a tags=arrays,ruby,ruby-on-rails,performance\
    \ |>\n<| a dscore=1 |>\n<code>", "  rescaled_numbers = []\n  smallest_number =\
    \ numbers.min == numbers.max ? 0 : numbers.min\n  rescaled_numbers << (smallest_number\
    \ / numbers.max)\n  numbers.each do |number|\n    rescaled_numbers << (number\
    \ - rescaled_numbers[-1])\n  end\n  rescaled_numbers\nend", "  sum = numbers.reduce(&:+).to_f\n\
    \  normalized_numbers = numbers.map { |n| n / sum }\n  normalized_numbers.min\
    \ == normalized_numbers.max ? normalized_numbers.first : normalized_numbers\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks! I wanted to add that it also\
    \ works on non-numeric lists, for example `[{\"a\" => 1}, {\"a\" => 3}]` -> `[{\"\
    a\" => 0.0}, {\"a\" => 1.0}]`\n<|/ c |>\n<| a dscore=2 |>\nIf you're using Ruby\
    \ 2.6 or later, you could do this:\n<code>", '  numbers.sort!', "  numbers.map\
    \ { |x| x / numbers.min }\nend", "  numbers.each_with_index do |number, index|\n\
    \    numbers[index] = (number - numbers.min) / numbers.max if numbers.max > numbers.min\n\
    \  end\nend", "  min_val = numbers.min\n  max_val = numbers.max\n  scale = (max_val\
    \ - min_val) / (numbers.size - 1)\n  scaled_numbers = Array.new(numbers.size)\n\
    \  scaled_numbers.each_with_index do |number, index|\n    scaled_numbers[index]\
    \ = ((number - min_val) / scale) + min_val\n  end\nend", "  return [((numbers[i]\
    \ - min) / (max(numbers) - min(numbers)) + 0.5) for i in\n           range(0,\
    \ len(numbers))]", "  # Remove 0 from numbers\n  numbers.reject! {|num| num ==\
    \ 0}\n  numbers.reject {|num| num == -1 || num == 1}\n  # Scale to [0, 1]\n  numbers.map!\
    \ {|num| (num / numbers.uniq.count).round * 0.5}\nend", "  numbers.map { |n| n\
    \ / numbers.reduce(:+) }\nend", "  numbers.each { |n| n.to_f / n.to_f if n > 0\
    \ && n < 1 }\nend", "    min = numbers.min\n    max = numbers.max\n    range =\
    \ max - min\n    numbers.map { |x| (x - min)/range }\nend\n</code>\nThis works\
    \ by subtracting the minimum of the list from the maximum value (making sure to\
    \ cast from Floats to Float, as the range of values will vary), dividing the range\
    \ by the difference between the maximum and minimum, and then rounding up to the\
    \ nearest integer. This yields a sequence of numbers that will always be between\
    \ 0 and 1.\nTo illustrate how it works, here is an example:\n<code>\n[2.0, 3.0]\
    \ + [4.0, 5.0]\n=> [0.0, 0.25, 0.5, 0.75, 1.0]", "  numbers = numbers.map { |n|\
    \ n/numbers.min }\n  numbers.reject(&:zero?).sum\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  scale = 1.0\n  if min == max\n    scale = 1.0\n  elmt\
    \ = numbers[0]\n  i = 1\n  while i < numbers.count\n    elmt = (elmt - numbers[i])\
    \ * 1.0 / scale\n    i += 1\n    scale *= max\n  end\n  numbers = [elmt] * numbers.size\n\
    \  numbers.each_index { |i| numbers[i] = numbers[i].round(2) }\nend", "  if numbers.empty?\n\
    \    []\n  else\n    numbers.map { |x| x/numbers.min }\nend", "  numbers.map!(&:to_f)\
    \ # make sure all elements are floats\n  numbers.each_with_index { |element, i|\
    \ numbers[i] = element / (numbers.size-1) if numbers.size>i }\n  numbers\nend",
  "    sorted_numbers, unit_numbers = numbers.partition { |n| n.zero? }\n    smallest_number\
    \ = sorted_numbers.first\n    largest_number = sorted_numbers.last\n    unit_numbers\
    \ = unit_numbers.map { |n| n.abs }\n    unit_numbers.inject { |memo, number| memo\
    \ + number*(smallest_number/largest_number) }\nend", "  numbers.reduce(:+) / numbers.size\n\
    end", "  numbers.min? ? numbers.map! {|n| n * (1.0 / numbers.min)} : numbers\n\
    end", "  numbers.min!(0.0)\n  numbers.max!(0.0)\n  return numbers/numbers.length\n\
    end", "  numbers.map {|x| x/numbers.min}\nend", "  numbers.map do |x|\n    x /=\
    \ x.abs.min\n  end\nend", '  return [0 if n < numbers.min else 1.0 if n > numbers.max
    else n / numbers.max for n in numbers]', "  smallest = numbers.min\n  largest\
    \ = numbers.max\n  scale = (largest - smallest) / (largest ** 2)\n  numbers.each_with_index\
    \ do |n, i|\n    numbers[i] = (n + smallest) * scale + smallest\n  end\nend",
  "  numbers.each_with_index do |number, index|\n    numbers[index] = number / number.min\n\
    \  end\n  numbers\nend", "  new_numbers = []\n  min = numbers.min\n  max = numbers.max\n\
    \  new_min = min\n  new_max = max", "  min = (numbers.min+numbers.max)/2\n  max\
    \ = (numbers.min+numbers.max)/2\n  rescaled = [min]\n  rescaled << numbers.map\
    \ { |n| n*max }\n  rescaled\nend", "  numbers.inject(0) do |min, (v)|\n    if\
    \ min > v\n      min\n    elsif min == v\n      0\n    elsif max < v\n      max\n\
    \    else\n      1.0\n    end\n  end\nend", "  # Find the range of numbers to\
    \ rescale to\n  min_number = numbers.min\n  max_number = numbers.max", "  # TODO:\
    \ check whether this is the correct way to rescale\n  numbers.each_with_index\
    \ do |number, index|\n    numbers[index] = 0.0 if numbers[index] < 0.0\n    numbers[index]\
    \ = 1.0 if numbers[index] > 1.0\n  end\n  numbers\nend", "  minimum = numbers.min\n\
    \  maximum = numbers.max\n  scaled = (numbers - minimum) / (maximum - minimum)\n\
    \  scaled\nend", "  smallest_number = numbers.min\n  large_number = numbers.max\n\
    \  scaled_numbers = numbers.map { |number| number * (large_number - smallest_number)\
    \ / (large_number + smallest_number) }\n  scaled_numbers.minmax\nend", "  numbers.inject(0.0)\
    \ { |sum, n| sum + n/numbers.size }\nend", "    minimum, maximum = numbers.minmax\n\
    \    minimum, maximum = 0.0, 1.0\n    (numbers - minimum) ./ (maximum - minimum)\n\
    end\n</code>\nIn fact, you could probably make this much simpler if you know the\
    \ bounds of the data being input (as in, the data has some bounds which may or\
    \ may not be the same as the bounds you specified in the function definition).\n\
    <|/ a dscore=3 |>\n<| c |>\nI do realize now that `rescale_to_unit` does not work\
    \ for a list containing negative numbers. But it seems unlikely that the OP would\
    \ actually want that, so I left it out of this answer. :-) The OP's question was\
    \ about how to scale a list of numbers to between 0 and 1, and that's what this\
    \ function does.\n<|/ c |>\n<| c |>\nThank you very much for this answer! My mistake\
    \ was that I wanted to rescale numbers before adding them to the array. But now\
    \ it works.\n<|/ c |>\n<| a dscore=1 tags=ruby,arrays |>\nYou can just use the\
    \ standard library class Array for this.\n<code>\nirb(main):035:0> arr = [1, 3,\
    \ 5]\n=> [1, 3, 5]\nirb(main):036:0> arr.map! { |x| x - arr.min / arr.max }\n\
    => [0.0, 0.0, 0.5, 0.5, 1.0]\n</code>\n<|/ a |>\n<| c |>\nI do realize now that\
    \ `rescale_to_unit` does not work for a list containing negative numbers. But\
    \ it seems unlikely that the OP would actually want that, so I left it out of\
    \ this answer. :-) The OP's question was about how to scale a list of numbers\
    \ to between 0 and 1, and that's what this function does.\n<|/ c |>\n<| c |>\n\
    It looks like a good answer to me. It seems to me that the OP was only asking\
    \ how to scale a list of numbers to between 0 and 1, and then to scale them back\
    \ after adding them to the array. Though I admit my answer is technically incorrect.\
    \ Your solution makes the assumption that numbers are non-negative as opposed\
    \ to strictly positive.\n<|/ c |>\n<| c |>\n- His question was about rescaling\
    \ numbers to between 0 and 1 and back. And that's what this answer does. Your\
    \ comment on the question seems to say that the numbers are non-negative. That's\
    \ just not correct.\n<|/ c |>\n<| c |>\n- Your solution will work just fine for\
    \ negative numbers. For example, `[0, 0, 0].map! { |x| x - [0, 0, 0].min / [0,\
    \ 0, 0].max }` produces `[0.0, 0.0, 0.0]", "  min_number = numbers.min\n  max_number\
    \ = numbers.max\n  (output_min, output_max) = min_number > 0.0 ? (max_number /\
    \ min_number) : (0.0, 1.0)\n  output_numbers = Array.new\n  output_numbers.each\
    \ do |number|\n    number = (number - min_number) / (max_number - min_number)\n\
    \    number.to_f < 0.0 ? number = -1.0 : number = 1.0\n    output_numbers << number\n\
    \  end\n  output_numbers\nend", "  max_number = numbers.max\n  min_number = numbers.min\n\
    \  range = (max_number - min_number)\n  return [((i - min_number) / range) for\
    \ i in numbers]\nend", "  min = numbers.min\n  max = numbers.max", "  numbers.collect!\
    \ {|number| number * 1.0 / numbers.min}\nend", "  numbers.inject {|x, y| x ==\
    \ 0 ? y : x / x}\nend", "  new_numbers = []\n  num_min = numbers.min\n  num_max\
    \ = numbers.max\n  num_length = numbers.length\n  num_center = num_min + num_length\
    \ / 2", "  return numbers.map { |n| 1.0 / n }\nend", "  min, max = numbers.minmax\n\
    \  numbers -= min\n  numbers /= (max - min)\n  numbers *= 2.0\nend", "  numbers.min!\
    \ # make sure smallest number becomes 0\n  numbers.max! # make sure largest number\
    \ becomes 1\n  (numbers - numbers.min) / numbers.max\nend", "  return numbers.map\
    \ { |n| (n - numbers.min) / (numbers.max - numbers.min) }\nend", "  minimum =\
    \ numbers[0]\n  maximum = numbers[0]\n  numbers.each {|number| minimum = [number\
    \ < minimum ? number : minimum, minimum]; \n    maximum = [number > maximum ?\
    \ number : maximum, maximum]}\n  minimum.each {|number| number /= maximum.last}\n\
    \  maximum.each {|number| number *= maximum.last}\n  return number\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 tags=ruby,arrays,algorithm,math |>\nThe simple\
    \ way is just to compute the cumulative sum of your array and divide by the sum\
    \ of the array:\n<code>", "  min = numbers.min\n  max = numbers.max\n  delta =\
    \ (max - min) / numbers.size.to_f\n  numbers.each_with_index { |number, index|\
    \ numbers[index] = min + (delta * number) }\n  numbers\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis looks pretty cool, but I couldn't get it to work even using it with\
    \ the data I gave as an example. Does it work with data like mine? If so, could\
    \ you provide an example of how to use it? Thanks for your help!\n<|/ c |>\n<|\
    \ a dscore=2 tags=math,ruby |>\n<code>", "  return map(lambda x: x/min(numbers)\
    \ if min(x) == 0 else x, numbers)\nend", "  smallest_num = numbers.min\n  largest_num\
    \ = numbers.max\n  smallest_zero = math.pow(smallest_num, 1.0 / num_units)\n \
    \ largest_one = math.pow(largest_num, 1.0 / num_units)\n  result_list = []\n \
    \ while smallest_num > 0\n    if smallest_num > largest_one\n      result_list\
    \ << smallest_zero\n      smallest_num -= largest_one\n      largest_num -= 1\n\
    \    else\n      result_list << smallest_one\n      smallest_num -= 1\n  end\n\
    \  result_list << largest_one\n  result_list\nend\n</cell>\n<code language=julia-0.5>",
  "  min_val = numbers.min\n  max_val = numbers.max\n  difference = max_val - min_val\n\
    \  return [((numbers[i] - min_val) / difference).round(0) for i in range(len(numbers))]\n\
    end", "  return numbers.min == numbers.max ? numbers : numbers - numbers.min /\
    \ (numbers.max - numbers.min)\nend", "  scale_value = 1.0 / numbers.max\n  numbers.map!\
    \ { |n| n * scale_value }\nend", "  min_value = numbers.min\n  max_value = numbers.max\n\
    \  range = max_value - min_value", "  numbers.each do |number|\n    number /=\
    \ min_max_scale(number)\n  end\n  numbers\nend", "  numbers.each_with_index do\
    \ |number, index|\n    if number.zero?\n      numbers[index] = 1\n    elsif index\
    \ < numbers.size - 1 && number.abs > numbers[index + 1]\n      numbers[index +\
    \ 1] = numbers[index] + number\n    end\n  end\n  numbers\nend", "  return numbers.map\
    \ { |n| n * 1.0 / (numbers.max || 1) }\nend", "  numbers.sort!\n  first_number\
    \ = numbers.first\n  if first_number == 0\n    numbers[numbers.length-1] = 1\n\
    \  elsif first_number == 1\n    numbers[1] = 0\n  else\n    numbers[numbers.length-1]\
    \ = 1.0\n    numbers.map!{|x| x/first_number}\n  end\nend\n</pre>", '  new_numbers
    = Array.new', "  min = numbers.min\n  max = numbers.max\n  if min == max\n   \
    \ numbers.clear\n  else\n    numbers = (numbers - min) / (max - min)\n  end\n\
    \  numbers\nend", "  number_sum = 0.0\n  number_sums = numbers.reduce(:+)\n  numbers.each\
    \ do |number|\n    number_sum += number\n  end\n  number_sum /= number_sums\n\
    \  return numbers.map do |number|\n    number / number_sum\n  end\nend", "  return\
    \ numbers.map {|n| n/min_max(numbers)}\nend", "  numbers.each do |number|\n  \
    \  # Check if we have a number bigger than 0\n    if number < 0\n      number\
    \ *= -1\n    end\n  end\n  numbers.uniq.sort\nend", "  return [ (max - min) /\
    \ (num_elements - 1) * (number - min) for (number, max) in zip(numbers, numbers[1:])\
    \ ]\nend", "  numbers.each do |number|\n    number = number.to_f\n    number -=\
    \ min(number) if number != 0.0\n    number /= max(number) if number != 0.0\n \
    \ end\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't take into account the requirement\
    \ that all numbers are in the range 0 to 1\n<|/ c |>\n<| c |>\n: Yes, it does.\
    \ The first number is the smallest and the last is the largest, so the first one\
    \ would be divided by the largest and the last one by the smallest. Of course\
    \ that doesn't change the fact that the result will be in that range.\n<|/ c |>\n\
    <| c |>\nAh, sorry I misread your explanation. I thought you were talking about\
    \ the numbers being in the range 0 to 1\n<|/ c |>\n<| a |>\nI find it much easier\
    \ to use an array of the indices of the array that need to become 0 and the ones\
    \ that need to become 1:\n<code>", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers = (numbers - min) / (max - min)\nend", "  maximum = numbers.max\n \
    \ minimum = numbers.min\n  if maximum > 1.0 and maximum < 0.0:\n    minimum =\
    \ 0.0\n  if minimum < 0.0:\n    minimum = 0.0\n  return [((i - minimum) / (maximum\
    \ - minimum)) for i in numbers]", "    smallest, largest = numbers.minmax_by(&:abs)\n\
    \    smallest, largest = smallest.abs, largest.abs\n    if smallest == 0\n   \
    \     largest = 1\n    else\n        largest /= smallest - 1\n    end\n    (smallest\
    \ < 0) == (largest < 1) ? largest += smallest : largest += largest\n    [smallest,\
    \ largest]\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=3 |>\nHere is a solution\
    \ which uses Integer#/ (see docs) to do the rounding correctly:\n<code>", "  #\
    \ Find the minimum and maximum values\n  smallest_number = numbers.min\n  largest_number\
    \ = numbers.max", '  numbers.sort!', "  min_number = numbers.min\n  max_number\
    \ = numbers.max\n  normalized_numbers = []\n  \n  for number in numbers\n    if\
    \ number < min_number\n      normalized_numbers << 0\n      next\n    end", " \
    \ smallest = numbers.inject(:<=>){ |min,x| min < x ? x : min }\n  biggest = numbers.inject(:<=>){\
    \ |min,x| min > x ? x : min }\n  biggest.zero? ? numbers : [((numbers - smallest).abs).div(biggest\
    \ - smallest), smallest]\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm dscore=4\
    \ |>\n<| c |>\nThis is very good but unfortunately not very efficient for large\
    \ arrays. Even `(1..1000).inject(:<=>)` is pretty slow. Just for fun I did a quick\
    \ benchmark on `Array#sort` and this is faster than `Array#min` and `Array#max`.\
    \ Your example with `(1..1000).sort` takes ~700ms, whereas `(1..1000).inject(:<=>)`\
    \ takes ~450 ms.\n<|/ c |>\n<| c |>\nI agree - I did a quick benchmark before\
    \ writing this and I thought it was slower (it was more like 5% faster on my machine)\
    \ but I hadn't really checked this code. I was mostly just checking that my \"\
    solution\" was correct in principle, but I should have checked more rigorously\
    \ before writing that answer. Now I updated my answer.\n<|/ c |>\n<| c |>\nI thought\
    \ about using `Array#sort` but I think that's probably the most inefficient way\
    \ you can do it. You probably want to use an alternative where you use `Array#max`\
    \ and `Array#min` instead of the `sort` call. I'm not sure how easy it would be\
    \ to do that efficiently though.\n<|/ c |>\n<| c |>\n: I suspect that the efficiency\
    \ would be O(n\xB2), but I was just giving a quickie benchmark for anyone who\
    \ wants to know. :)\n<|/ c |>\n<| a dscore=4 |>\nI would use the min and max methods\
    \ from arrays:\n<code>\nnumbers = [4, 8, 3, 6, 5, 1, 3]", "  minval = numbers.min\n\
    \  maxval = numbers.max", "  numbers.min!=0\n  numbers.max!=1\n  numbers.map!{|n|\
    \ (n+0.5)*1./numbers.max}\n  numbers\nend\n</cell>\n<text>\nRescaling\nRescaling\
    \ numbers is useful for scaling up any kind of numbers, for example,", "  number_sum\
    \ = numbers.reduce(:+)\n  numbers.map { |n| n/number_sum }\nend", "  minnum =\
    \ numbers.min\n  maxnum = numbers.max", "  numbers.each_with_index { |n,i| numbers[i]\
    \ = ( n - min(numbers)) / ( max(numbers) - min(numbers) ) }\nend", "  # Normalize\
    \ the list so its smallest number becomes 0.\n  numbers.min", "  max = numbers.max\n\
    \  min = numbers.min\n  rescaled = (numbers - min) / (max - min)\n  rescaled\n\
    end", "  numbers.each { |x| x > 0 && x <= 1 ? (x -= (numbers.min - numbers.max))\
    \ : x }\nend", "  numbers.min.times { |e| e > 0.0 ? (e - numbers.min) / (numbers.max\
    \ - numbers.min) : 0.0 }\nend", "  min_number = numbers.min\n  max_number = numbers.max\n\
    \  diff = (max_number - min_number) / 2.0\n  numbers.map {|n| n * diff + min_number}\n\
    end", "  numbers.map {|n| n.to_f / numbers.max }\nend", "  numbers.map { |n| n\
    \ * 1.0 / numbers.max + 1.0 }\nend\n</code>\n<|/ a |>\n<| c |>\nThis is not the\
    \ right answer to the problem described. Your example gives [1.0, 0.0, 1.0], whereas\
    \ the desired result is [0.0, 1.0, 1.0], which is what I get when I run the above\
    \ code.\n<|/ c |>\n<| c |>\nThe original question has `[1.0, 2.0, 3.0, 4.0, 5.0]`,\
    \ so the result is `[0.0, 0.25, 0.5, 0.75, 1.0]` which is what the question asked.\
    \ Your code is correct, just not what the question asked.\n<|/ c |>\n<| c |>\n\
    It seems I was misunderstood then.\n<|/ c |>\n<| a tags=algorithm,ruby,arrays,scaling\
    \ |>\nHere is another one using Enumerable#each_cons:\n<code>", "  min_index =\
    \ numbers.index(min(numbers))\n  max_index = numbers.index(max(numbers))\n  numbers[min_index]\
    \ = (min_index == 0) ? (numbers[min_index] - min_offset) / (max_index - min_index\
    \ + 1) : (numbers[min_index] - min_offset) / (max_index - min_index)\n  numbers.shift\n\
    \  return numbers\nend", "  return numbers.minmax * 1.0 / numbers.max\nend", " \
    \ return numbers.map {|x| x/numbers.max}\nend", "  numbers.map!{|x| x/numbers.min}\n\
    \  numbers.min!=0\n  numbers.max!=1\n  numbers\nend\n</code></pre>", "  numbers.sort_by!\
    \ {|n| -n }\n  numbers.reverse!\n  max_number = numbers.shift\n  new_numbers =\
    \ []\n  numbers.each do |n|\n    diff = max_number - n\n    new_numbers.push(diff/max_number*n)\n\
    \    max_number = n\n  end\n  return new_numbers.reverse\nend\n</cell>\n<code\
    \ language=conda-env-anaconda3-py>", "  numbers.reduce(&:+) / numbers.reduce(&:abs)\n\
    end", "  numbers.map {|n| n/min_max(n)}\nend", "  numbers = numbers.sort_by {\
    \ |n| n }\n  biggest = numbers.last\n  smallest = numbers.first\n  difference\
    \ = biggest - smallest\n  if difference == 0\n    diff = 1.0\n  else\n    diff\
    \ = difference / 2.0\n  end\n  numbers.map! {|n| n * diff }\nend", "  numbers[numbers.min\
    \ == numbers.max] ||= 1.0\n  numbers.map(&:round)\nend", "  scale = 1.0 / numbers.max\n\
    \  numbers.map! { |n| n*scale }\nend", "  numbers.inject(0.0, &:+) / numbers.inject(1.0,\
    \ &:*)\nend\n</code>\nNote that I've used inject to calculate the sum, because\
    \ that's more efficient than using + and *. Another option for sum is reduce which\
    \ also can efficiently sum an array.\n<|/ a dscore=1 tags=ruby,arrays |>\n<| c\
    \ |>\nYeah thats a nice solution.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>",
  "  minVal = min(numbers)\n  maxVal = max(numbers)\n  return minVal + ((maxVal-minVal)\
    \ * (numbers-minVal))/(maxVal-minVal)\nend", "  max_number = numbers.max\n  if\
    \ max_number == 0\n    numbers.map! { |i| i / max_number }\n  else\n    numbers.map!\
    \ { |i| i / max_number }\n    numbers.max = 1.0\n    numbers.min = 0.0\n  end\n\
    end", "  numbers.each_with_index do |n, i|\n    if n < 0\n      numbers[i] = numbers[i]\
    \ * -1\n      n += 1\n    end\n    if n > 1\n      numbers[i] = numbers[i] / n\n\
    \      n += 1\n    end\n  end\n  numbers.first\nend", "  numbers.each { |n| n\
    \ /= (numbers.min * 1.0) }\n  numbers\nend", "  numbers.collect { |number| number\
    \ / min_value(number) }\nend", "  numbers.min = 0\n  numbers.max = 1.0\n  return\
    \ numbers.map(&:to_f)\nend", "  if numbers.length < 2\n    numbers\n  else\n \
    \   numbers.map {|n| n / numbers.size}\nend", "  number_to_scale = _find_smallest_and_largest(numbers)\n\
    \  scaled_numbers = _scale_to_unit_without_maximum(numbers, number_to_scale)\n\
    \  final_number = _scale_to_unit_with_maximum(scaled_numbers, number_to_scale)\n\
    \  return final_number\nend", "    minimum = numbers.min\n    maximum = numbers.max\n\
    \    delta = (maximum - minimum) / 2.0\n    minimum -= delta\n    maximum += delta",
  "  min = -1.0/numbers[-1]\n  max = 1.0/(numbers[-1]+1.0)\n  numbers.map { |n| n*min+max\
    \ }\nend", "  numbers.each_with_index do |number, index|\n    if number < 0.0\n\
    \      numbers[index] = 0.0\n    elsif number > 1.0\n      numbers[index] = 1.0\n\
    \    else\n      numbers[index] *= 1.0 / (numbers[index].to_f - 1.0)\n    end\n\
    \  end\n  numbers\nend\n</code>\nNote that this assumes that numbers is sorted.\n\
    <|/ a tags=ruby,math,arrays dscore=1 |>\n<| a dscore=0 |>\n<code>", "  smallest\
    \ = numbers.min\n  largest = numbers.max\n  diff = largest - smallest\n  if diff\
    \ == 0\n    return numbers\n  scaled = (numbers - smallest) / diff\n  numbers.each_with_index\
    \ do |number, i|\n    numbers[i] = number\n  end\n  numbers.min = -1.0\n  numbers.max\
    \ = 1.0\n  numbers.zip(scaled).map { |pair| pair[0] * pair[1] }\nend", "  numbers.inject\
    \ { |sum,x| sum*=x/sum.abs }\nend", "    min = numbers.min\n    max = numbers.max\n\
    \    largest = numbers[numbers.length-1]\n    smallest = numbers[0]\n    range\
    \ = (largest-smallest).to_f\n    min = min.to_f\n    max = max.to_f\n    new_min\
    \ = (min-range).to_f\n    new_max = (max+range).to_f\n    numbers.map! {|x| (x-min)/(max-min)}\n\
    \    numbers\nend", "  min_num = numbers.min\n  numbers.map {|n| n - min_num}\n\
    end", "  min = np.minimum(numbers)\n  max = np.maximum(numbers)\n  range = max\
    \ - min\n  min_nonzero = min + (range * np.true_divide(numbers, range)).astype('float')\n\
    \  max_nonzero = max + (range * np.true_divide(1 - numbers, range)).astype('float')\n\
    \  scale = np.true_divide(max_nonzero, min_nonzero)\n  zero = np.true_divide(1,\
    \ min)\n  scale[np.where((numbers == 0) | (numbers == 1))] = zero\n  return scale",
  "  return numbers.map { |n| n / numbers.min }\nend", "  numbers.each_with_index\
    \ do |number, index|\n    if index == 0\n      number.to_f\n    else\n      (numbers[index]\
    \ / numbers[index - 1]).to_f\n    end\n  end\nend", "  if numbers.empty?\n   \
    \ return []\n  else\n    smallest = numbers[0].abs\n    largest = numbers[-1].abs\n\
    \    numbers_without_smallest = numbers.reject { |x| x < smallest }\n    numbers_without_largest\
    \ = numbers.reject { |x| x > largest }\n    smallest_zero_index = (numbers - smallest).find_index(&:zero?)\n\
    \    largest = numbers[-1]\n    result = []\n    numbers_without_smallest.each_with_index\
    \ { |n, i| result[i] = n + smallest }\n    numbers_without_largest.each_with_index\
    \ { |n, i| result[i + smallest_zero_index] = n - largest }\n    result\n  end\n\
    end", "    smallest = numbers.first\n    largest = numbers.last\n    if smallest\
    \ == largest\n        smallest = 0.0\n    end", "  numbers.map { |n| n / numbers.min\
    \ }\nend", "  min = 0\n  max = numbers[0]\n  numbers.each_with_index do |n, i|\n\
    \    if n != numbers[i]\n      min = n\n    end\n    max = n if n > max\n  end\n\
    \  return [min, max - min]\nend", "  return numbers.map { |number| number / (numbers.max\
    \ - numbers.min) }\nend\n</code>\n<|/ a |>\n<| c |>\nGreat explanation! How would\
    \ you modify your solution to output a float array instead of a float value?\n\
    <|/ c |>\n<| c |>\nYou could do `numbers.map { |n| n/((numbers.max-n)/2) }`. But\
    \ be aware that this can lead to incorrect results if `min` is `0` and that your\
    \ input array only contains positive numbers.\n<|/ c |>\n<| c |>\nThis answer\
    \ is wrong, since the output is `[0.0, 0.25, 0.5, 0.75, 1.0]` whereas the OP wants\
    \ `[0.0, 0.25, 0.5, 0.75, 1.]`.\n<|/ c |>\n<| a |>\n<code>\n def scale(input)\n\
    \    return input.map { |n| n/(input.max-n) }\n end", "  numbers.map!{|i| i /\
    \ numbers.min if i > 0 and i < numbers.max}\n  numbers\nend", "    numbers.min!\n\
    \    numbers.max!\n    scaled = numbers - numbers.min\n    scaled = scaled / (numbers.max\
    \ - numbers.min)\n    scaled = scaled * 1.0\n    numbers.min!\n    numbers.max!\n\
    \    numbers\nend\n</cell>\n<text>\nStep 2: Calculate the distance between two\
    \ points\nThe next step is to calculate the distance between two points. For this\
    \ exercise, we will calculate Euclidean distance between two points with an Euclidean\
    \ metric.", "  numbers.each { |n| n /= (numbers.max - numbers.min) }\n  numbers\n\
    end", "  numbers.map { |num| num / numbers.reduce(:+) }\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby,ruby-on-rails |>\n<| c |>\nI believe you're correct about your assumption\
    \ of what `sum` should return. I did some benchmarking and it seems like `inject`\
    \ is faster than `reduce`, but that still seems to be a wash between `inject`\
    \ and `sum`. I suspect the reason is because `inject` passes the block to `reduce`,\
    \ which does the summing inside the block. I guess my assumption of what `sum`\
    \ should return is wrong.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails dscore=2 |>\n\
    <code>", "  numbers.each_with_index do |number, index|\n    if number < numbers[0]\
    \ then\n      numbers[index] = 0\n    end\n    if number > numbers[-1] then\n\
    \      numbers[index] = 1\n    end\n  end\nend", "  numbers.each_with_index do\
    \ |n, i|\n    if i < numbers.size - 1\n      numbers[i] /= (numbers[i+1] - numbers[i])\n\
    \    end\n  end\nend", "  numbers.sort!\n  min = numbers.first\n  max = numbers.last\n\
    \  numbers.delete_if {|x| (min - x) < (max - x)}\n  numbers.delete_if {|x| (max\
    \ - x) < (min - x)}\n  numbers.delete_if {|x| x == max}\n  numbers.delete_if {|x|\
    \ x == min}\n  numbers[0] = 0\n  numbers[-1] = 1\n  numbers\nend", "  numbers.sort!\n\
    \  result = [0, 1]\n  min = 0\n  max = numbers[numbers.length-1]\n  max_offset\
    \ = max - min\n  return numbers.inject([]) do |result, number|\n    result  <<\
    \ number + (result[-1] - result[-2]) * number / (result[-2] + max_offset)\n  end\n\
    end", "  return [numbers[0] / numbers.max] if numbers.max > 0 else numbers.map\
    \ { |n| n / numbers.max }\nend", "  scale = (numbers[1..-1] - numbers[0]) / (numbers[-1]\
    \ - numbers[0])\n  numbers.each_with_index { |num, i| numbers[i] = num - scale*(num\
    \ - numbers[0]) }\n  numbers\nend", "  numbers.map {|num| num * 1.0 / numbers.min}\n\
    end", "  numbers.inject { |sum, number| sum + number * 1.0/numbers.size }\nend",
  "  numbers.reduce(:+) / numbers.size\nend", "  numbers.sort!\n  return [0 + (numbers[1]\
    \ - numbers[0]) / (numbers[-1] - numbers[0]) ] * numbers.size.to_f / numbers.last.to_f\n\
    end", "  min_val = numbers.min if numbers.is_a?(Array) else numbers.min\n  max_val\
    \ = numbers.max if numbers.is_a?(Array) else numbers.max\n  if max_val == min_val\n\
    \    [0.0, 1.0]\n  else\n    [(max_val - min_val) * (numbers - min_val) / (max_val\
    \ - min_val) + min_val]\n  end\nend", "  numbers.inject(0.0, :+) do |sum, number|\n\
    \    sum + number\n  end\nend", "  numbers.inject([0]) { |sum, x| sum + x }\n\
    end", "  min = (0...numbers.size).reduce(:min)\n  max = (0...numbers.size).reduce(:max)\n\
    \  scaled = numbers.map {|n| n/max }.map {|n| n*max - min }\n  scaled.min\nend",
  "  numbers.inject { |sum, item| sum + item/numbers.size }\nend\n</code>\nNote that\
    \ in Ruby, arrays start at index 0, so if you start counting at 1, you'd have\
    \ to subtract 1 when indexing.\n<|/ a tags=ruby dscore=0 |>\n<| a dscore=0 |>\n\
    Ruby 1.9 has Array#max_by method, which returns an enumerator of the largest element\
    \ in an array.  Just feed that to reduce to get the ratio of elements and sum.\
    \  Like this:\n<code>\nrequire 'matrix'", "  minimum = numbers.min\n  maximum\
    \ = numbers.max", "  numbers.each do |number|\n    number.times { |i| numbers[i]\
    \ /= number }\n    numbers[numbers.size - 1] += 1\n  end\n  numbers\nend", " \
    \ numbers.inject(0.0) do |sum, value|\n    sum + 1.0 * value / sum\n  end\nend\n\
    </cell>\n<cell>", "  avg = numbers.inject(0.0) { |t,x| t+x }\n  numbers.map! {\
    \ |x| x-avg }\nend", "  numbers = numbers.map { |n| n / maximum(numbers) }\n \
    \ numbers.inject(:+) / numbers.size\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
