name: HumanEval_6_parse_nested_parens
language: rb
prompt: "# Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n# For each of the group, output the deepest\
  \ level of nesting of parentheses.\n# E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n# >>> parse_nested_parens('(()()) ((())) () ((())()())')\n\
  # [2, 3, 1, 3]\ndef parse_nested_parens(paren_string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_nested_parens\n\
  \    candidate = method(:parse_nested_parens)\n    assert_equal([2, 3, 1, 3], candidate.call(\"\
  (()()) ((())) () ((())()())\"))\n    assert_equal([1, 2, 3, 4], candidate.call(\"\
  () (()) ((())) (((())))\"))\n    assert_equal([4], candidate.call(\"(()(())((())))\"\
  ))\n  end\nend\n"
completions: ["  opening_parentheses = paren_string.scan(/\\(/)\n  current_level =\
    \ 0\n  paren_levels = []", "  levels = []\n  last_opening_paren_index = 0\n  level\
    \ = 0\n  for i in 0..paren_string.length\n    if paren_string[i] == '('\n    \
    \  if paren_string[last_opening_paren_index..i].empty?\n        level += 1\n \
    \     else\n        level -= 1 unless paren_string[last_opening_paren_index..i].include?(')')\n\
    \      end\n      last_opening_paren_index = i\n    elsif paren_string[i] == '('\n\
    \      level += 1\n    elsif paren_string[i] == ')'\n      level -= 1 unless paren_string[last_opening_paren_index..i].include?(')')\n\
    \    end\n    levels << level if level > 0\n  end\n  levels\nend", "  nested_paren_level\
    \ = 0\n  paren_groups = []\n  paren_string_length = len(paren_string)\n  i = 0\n\
    \  while i < paren_string_length\n    char_code = paren_string[i]\n    i += 1\n\
    \    if char_code == 0\n      break\n    if char_code == 1\n      nested_paren_level\
    \ += 1\n      paren_groups.append(nested_paren_level)\n      i += 1\n    elsif\
    \ char_code == 2\n      nested_paren_level -= 1\n      paren_groups.pop()\n  \
    \  end\n  end\n  return paren_groups.max\nend", "    paren_string.downcase!\n\
    \    return paren_string.scan(/\\(/).flatten.map {|x| x.match(/\\(.*?\\)/)[0].length}.max\n\
    end", "  paren_string.split(' ').map { |x|\n    if x.empty?\n      0\n    elsif\
    \ x[0] == '('\n      parse_nested_parens(x)\n    else\n      max_level = x.count('(')\n\
    \      max_level -= x.count(')')\n      max_level if max_level\n    end\n  }.max\n\
    end", "    paren_count = 0\n    paren_list = []\n    level_list = [1]\n    pos\
    \ = 0\n    while pos < paren_string.length\n        if paren_string[pos] == '('\n\
    \            paren_count += 1\n            level_list[paren_count] += 1\n    \
    \    if paren_string[pos] == ')'\n            paren_count -= 1\n            level_list[paren_count]\
    \ -= 1\n        if paren_count == 0\n            paren_list << level_list\n  \
    \          level_list = [1]\n            pos = paren_string.length\n        end\n\
    \        pos += 1\n    end\n    paren_list << level_list\n    return paren_list\n\
    end", "  groups = paren_string.split(' ')\n  return groups.inject(0) {|max, g|\
    \ max if g.size <= max }\nend", "  level = 0\n  max_level = 0\n  paren_stack =\
    \ []\n  paren_level = 0\n  paren_count = 0\n  paren_string.split(' ').each do\
    \ |paren|\n    level += 1 if paren == '('\n    level -= 1 if paren == ')'\n  \
    \  max_level = max(level, max_level)\n    paren_stack.push(paren) if paren !=\
    \ '('\n    paren_count += 1 if paren == '('\n    paren_count -= 1 if paren ==\
    \ ')'\n  end\n  return [max_level, paren_count]\nend", "  groups = []\n  current_level\
    \ = 0\n  current_group = 0\n  i = 0\n  while i < paren_string.length\n    if paren_string[i]\
    \ == '('\n      current_level += 1\n      current_group += 1\n      groups[current_group]\
    \ = current_level\n    elsif paren_string[i] == ')'\n      current_level -= 1\n\
    \      current_group -= 1\n      if current_level == 0\n        groups.last\n\
    \      end\n    end\n    i += 1\n  end\n  groups\nend", "  paren_string.gsub!(/([()])/g)\
    \ { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/(\\()/g) { \"\\\\#{$1.to_i}\"\
    \ }\n  paren_string.gsub!(/(\\))/g) { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/\\\
    (\\1\\)/g) { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/\\(\\1\\)/g) { \"\\\\\
    #{$1.to_i}\" }\n  paren_string.gsub!(/([)(])/g) { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/(\\\
    1\\)/g) { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/(\\1\\)/g) { \"\\\\#{$1.to_i}\"\
    \ }\n  paren_string.gsub!(/([^()]+)/) { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/([^\\\
    (\\)])/) { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/(\\1\\))/) { \"\\\\#{$1.to_i}\"\
    \ }\n  paren_string.gsub!(/(\\1\\))/) { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/(\\\
    1\\))/) { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/(\\1\\))/) { \"\\\\#{$1.to_i}\"\
    \ }\n  paren_string.gsub!(/(\\1\\))/) { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/(\\\
    1\\))/) { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/(\\1\\))/) { \"\\\\#{$1.to_i}\"\
    \ }\n  paren_string.gsub!(/(\\1\\))/) { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/(\\\
    1\\))/) { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/(\\1\\))/) { \"\\\\#{$1.to_i}\"\
    \ }\n  paren_string.gsub!(/(\\1\\))/) { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/(\\\
    1\\))/) { \"\\\\#{$1.to_i}\" }\n  paren_string.gsub!(/(\\1\\))/) { \"\\\\#", "\t\
    level = 0\n\tstack = []\n\tstacks = []\n\ti = 0\n\twhile i < paren_string.length\n\
    \t\tj = paren_string.index(paren_string[i], i)\n\t\tif i == j\n\t\t\ti += 1\n\t\
    \telse\n\t\t\ti = j\n\t\t\tlevel = 1\n\t\t\tstack = [paren_string[i..j-1]]\n\t\
    \t\tstacks << stack\n\t\tend\n\t\ti += 1\n\tend\n\tstacks << stack\n\ti\nend",
  "  paren_string.scan(/[()]/)\n  paren_stack.push(0)\n  max_level = 0", "    paren_string.scan(/[()]*/)\n\
    \    return paren_string.scan(/(?<=\\))\\1+/).map(&:length).max\nend", "    stack\
    \ = []\n    stack_depth = 0", "  max_level = 0\n  paren_string.scan(/^\\(+(.+?)\\\
    )+$/) do |level|\n    level_str = level[1]\n    level_str.scan(/\\(|\\)|\\)/)\
    \ do |c|\n      max_level = max_level if c != '('\n    end\n  end\n  max_level\n\
    end", "  paren_string.split(' ').inject(0) do |max_level, paren_string|\n    level\
    \ = 1\n    paren_string.scan(/\\(([^()]+)\\)/) do |paren_string|\n      level\
    \ += 1\n      max_level = level if paren_string > max_level\n    end\n    max_level\n\
    \  end\nend", "  return paren_string.split(' ').inject(0) do |level, token|\n\
    \    return level unless token.gsub!(/\\A\\((.+)\\)\\z/, '').empty?\n    level\
    \ = token.gsub(/\\A\\((.+)\\)\\z/, '').split(' ').inject(0) { |current_level,\
    \ token| current_level + parse_nested_parens(token) }\n  end\nend", "  depths\
    \ = paren_string.scan(/[^()]+/)\n  max_depth = depths.max_by { |depth| depth }\n\
    \  max_depth.size\nend", "  paren_count = count_parens(paren_string)\n  nested_levels\
    \ = []\n  i = 0\n  while i < paren_count\n    if paren_count - i == 6\n      nested_levels.push(paren_count\
    \ - i)\n      i += 2\n    i += 1\n  end\n  nested_levels.sort!\n  return nested_levels\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis solution does not work for `((()))`\
    \ input. Can you help me figure out the solution?\n<|/ c |>\n<| c |>\nI updated\
    \ the solution to handle this case.\n<|/ c |>\n<| c |>\nThank you for this. I've\
    \ been trying to figure out how to solve this problem for a while now.\n<|/ c\
    \ |>\n<| a dscore=2 |>\nThe algorithm you seek is called Shunting-yard algorithm.\
    \ The algorithm is pretty simple:", "  paren_string = paren_string.strip\n  group_count\
    \ = 0\n  opening_parentheses = 0\n  paren_levels = []\n  opening_parentheses =\
    \ 0\n  paren_levels = []\n  group_size = 0\n  group_level = 0\n  while group_count\
    \ < paren_string.length\n    group_count += 1\n    char = paren_string[group_count]\n\
    \    if char == '('\n      opening_parentheses += 1\n      group_size += 1\n \
    \     while opening_parentheses > 0\n        group_count += 1\n        char =\
    \ paren_string[group_count]\n        if char == '('\n          paren_levels[group_level]\
    \ -= 1\n          if paren_levels[group_level] == 0\n            opening_parentheses\
    \ -= 1\n          else\n            opening_parentheses += 1\n          end\n\
    \        else\n          if paren_levels[group_level] == 0\n            opening_parentheses\
    \ -= 1\n          end\n        end\n      end\n      if group_size == 0\n    \
    \    opening_parentheses -= 1\n      end\n    else\n      if char == ')'\n   \
    \     if opening_parentheses > 0\n          group_count += 1\n          char =\
    \ paren_string[group_count]\n          if char == '('\n            group_size\
    \ -= 1\n            paren_levels[group_level] += 1\n            if paren_levels[group_level]\
    \ == 0\n              opening_parentheses -= 1\n            end\n          else\n\
    \            if paren_levels[group_level] == 0\n              opening_parentheses\
    \ -= 1\n            end\n          end\n        else\n          if opening_parentheses\
    \ == 0\n            group_count += 1\n            char = paren_string[group_count]\n\
    \            paren_levels[group_level] += 1\n          end\n        end\n    \
    \  end\n    end\n  end\n  return paren_levels\nend", "  # Initialize an empty\
    \ array to store the levels of nesting\n  levels = []", "  level = 0\n  open_braces\
    \ = 1\n  paren_count = 0\n  output = []", "  paren_string = paren_string.split\
    \ \" \"\n  paren_levels = [paren_string.count('(') - paren_string.count(')') +\
    \ 1]\n  paren_levels[0] = 0 if paren_string[0] == '' else paren_levels[0]\n  paren_levels[-1]\
    \ = 0 if paren_string[-1] == '' else paren_levels[-1]\n  return paren_levels\n\
    end\n</pre>\n</div>", "  if paren_string == '' or paren_string == '()'\n    []\n\
    \  else\n    paren_string.gsub!(/\\(|\\)| \\)|\\(/, '')\n    paren_string.gsub!(/\\\
    (|\\)/, '').split(/(\\(\\))/).map {|group| group.size}.max\n  end\nend", "  level\
    \ = 0\n  parens = []\n  parens_stack = []\n  parens_stack[0] = paren_string\n\
    \  parens_stack.shift\n  while parens_stack.first != nil\n    parens = parens\
    \ + parens_stack.first\n    parens_stack.shift\n    parens_stack.shift\n  end\n\
    \  return parens\nend", "  nested_parens_stack = []\n  nested_parens_level = 0\n\
    \  \n  i = 0\n  paren_count = 0\n  \n  # Ignore the white spaces.\n  paren_string.gsub!(/^\\\
    s*/, '')\n  \n  while i < paren_string.length\n    if paren_count >= nested_parens_level\n\
    \      nested_parens_stack[-1].push(paren_string[i])\n    elsif paren_string[i]\
    \ == '('\n      nested_parens_stack.push([])\n      nested_parens_level += 1\n\
    \      i += 1\n      paren_count += 1\n    elsif paren_string[i] == ')'\n    \
    \  nested_parens_level = nested_parens_stack.pop\n      i += 1\n      paren_count\
    \ -= 1\n    end\n    i += 1\n  end\n  \n  nested_parens_stack.each_index do |i|\n\
    \    nested_parens_stack[i].each_index do |j|\n      nested_parens_stack[i][j]\
    \ << ' '\n    end\n  end\n  \n  nested_parens_stack.each_with_index do |nested_parens,\
    \ i|\n    nested_parens_stack[i].reverse!\n    \n    # Replace nested parentheses\
    \ string by original parentheses.\n    nested_parens.gsub!(/^( )+/, '')\n    nested_parens.gsub!(/(\
    \ )+$/, '')\n    \n    nested_parens.split(\" \").each do |nested_parens_element|\n\
    \      if nested_parens_element == '('\n        nested_parens_stack.push([])\n\
    \        nested_parens_level += 1\n      elsif nested_parens_element == ')'\n\
    \        nested_parens_level = nested_parens_stack.pop\n      end\n    end\n \
    \ end\n  \n  nested_parens_stack\nend\n</cell>\n<code language=julia-1.3>", " \
    \   opening_paren_level = 0\n    parens = []\n    \n    paren_chars = paren_string.chars\n\
    \    \n    paren_char = paren_chars.next", "    paren_string.scan(/[(()]/)\n \
    \   nested_parens = []\n    cur_level = 0\n    open_count = 0\n    closed_count\
    \ = 0\n    open_paren = 0\n    close_paren = 0\n    opening_parens = []\n    opening_paren_count\
    \ = 0\n    opening_paren_levels = []\n    opening_paren_level_map = {}\n    closing_index\
    \ = 0\n    level = 0\n    depth = 0\n    paren_paren_count = 0\n    paren_paren_levels\
    \ = []\n    paren_paren_level_map = {}\n    paren_paren_count = 0\n    paren_paren_levels\
    \ = []\n    paren_paren_level_map = {}\n    paren_count = 0\n    paren_level =\
    \ 0\n    paren_levels = []\n    paren_level_map = {}\n    while paren_count <\
    \ paren_string.length\n        paren_count += 1 if paren_string[paren_count] ==\
    \ '(' else -1\n        if paren_count > paren_string.length\n            return\
    \ nested_parens # Parens are all closed at end of input.\n        paren_count\
    \ += 1 if paren_string[paren_count] == '(' else -1\n        if paren_string[paren_count]\
    \ == '('\n            opening_paren_count += 1\n            opening_paren_level_map[opening_paren_count]\
    \ = level\n            opening_paren_level += 1\n            opening_paren_count\
    \ += 1\n            opening_paren_level_map[opening_paren_count] = level\n   \
    \         opening_paren_level += 1\n            opening_paren_count += 1\n   \
    \         opening_paren_level_map[opening_paren_count] = level\n            opening_paren_level\
    \ += 1\n            opening_paren_count += 1\n            opening_paren_level_map[opening_paren_count]\
    \ = level\n            opening_paren_level += 1\n            opening_paren_count\
    \ += 1\n            opening_paren_level_map[opening_paren_count] = level\n   \
    \         opening_paren_level += 1\n            opening_paren_count += 1\n   \
    \         opening_paren_level_map[opening_paren_count] = level\n            opening_paren_level\
    \ += 1\n            opening_paren_count += 1\n            opening_paren_level_map[opening_paren_count]\
    \ = level\n            opening_paren_level += 1\n            opening_paren_count\
    \ += 1\n            opening_paren_level_map[opening_paren_count] = level\n   \
    \         opening_paren_level += 1\n            opening_paren_count += 1\n   \
    \         opening_paren_level_map[opening_paren_count] = level\n            opening_paren_level\
    \ += 1\n            opening_paren_count += 1\n            opening_paren_level_map[opening_paren_count]\
    \ = level\n            opening_paren_level ", "  paren_stack = []\n  paren_count\
    \ = 0\n  paren_levels = []\n  paren_level = -1\n  paren_count = paren_stack.count(\"\
    (\")\n  paren_count += paren_stack.count(\")\")\n  paren_count -= paren_stack.count('(')\n\
    \  paren_count -= paren_stack.count(')')\n  paren_stack.push \"(\"\n  paren_levels.push(paren_count)\n\
    \  paren_level = 0\n  paren_stack.pop\n  paren_levels.pop\n  paren_level = -1\n\
    \  paren_count = paren_stack.count(\"(\")\n  paren_count += paren_stack.count(\"\
    )\")\n  paren_count -= paren_stack.count('(')\n  paren_count -= paren_stack.count(')')\n\
    \  paren_stack.push \"(\"\n  paren_levels.push(paren_count)\n  paren_level = 0\n\
    \  paren_stack.pop\n  paren_levels.pop\n  paren_level = -1\n  paren_count = paren_stack.count(\"\
    (\")\n  paren_count += paren_stack.count(\")\")\n  paren_count -= paren_stack.count('(')\n\
    \  paren_count -= paren_stack.count(')')\n  paren_stack.push \"(\"\n  paren_levels.push(paren_count)\n\
    \  paren_level = 0\n  paren_stack.pop\n  paren_levels.pop\n  paren_level = -1\n\
    \  paren_count = paren_stack.count(\"(\")\n  paren_count += paren_stack.count(\"\
    )\")\n  paren_count -= paren_stack.count('(')\n  paren_count -= paren_stack.count(')')\n\
    \  paren_stack.push \"(\"\n  paren_levels.push(paren_count)\n  paren_level = 0\n\
    \  paren_stack.pop\n  paren_levels.pop\n  paren_level = -1\n  paren_count = paren_stack.count(\"\
    (\")\n  paren_count += paren_stack.count(\")\")\n  paren_count -= paren_stack.count('(')\n\
    \  paren_count -= paren_stack.count(')')\n  paren_stack.push \"(\"\n  paren_levels.push(paren_count)\n\
    \  paren_level = 0\n  paren_stack.pop\n  paren_levels.pop\n  paren_level = -1\n\
    \  paren_count = paren_stack.count(\"(\")\n  paren_count += paren_stack.count(\"\
    )\")\n  paren_count -= paren_stack.count('(')\n  paren", "  levels = 0\n  result\
    \ = []\n  paren_stack = []\n  paren_string.gsub(/[()]/) { levels -= 1; paren_stack.push\
    \ [$1, levels].join }\n  paren_stack.pop.each { |(par, level)| result << level\
    \ }\n  result\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\nThe solution below is\
    \ written using recursion.\nI assume that your code is correct (it produces the\
    \ correct output for the example you provided). It should be easy to understand\
    \ how it works.\n<code>", "  open_groups = Hash.new(0)\n  open_groups[:0] += 1",
  "    # initialize counters and result array\n    levels = []\n    result = []\n\
    \    nested_count = 0\n    level = 0\n    # iterate over all the chars in the\
    \ input\n    for char in paren_string\n        if char == ')'\n            level\
    \ -= 1\n            if level == 0\n                result.push levels\n      \
    \      levels << level\n        else\n            level += 1\n            if level\
    \ > 0\n                nested_count += 1\n                levels << level\n  \
    \          if nested_count > result.size\n                result.push nested_count\n\
    \                nested_count = 0\n    end\n    return result\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| a |>\nHere is a recursive solution. \n<code>", "  paren_stack\
    \ = []\n  parsed_parens = []\n  paren_count = 0\n  beginning_paren_count = 0\n\
    \  paren_stack_reached = False\n  paren_stack_string = ''\n  paren_stack_reached_string\
    \ = ''\n  paren_stack_level = 0\n  level = 0\n  paren_string.each do |char|\n\
    \    level += 1\n    if char == '('\n      if paren_stack.length == 0\n      \
    \  paren_stack_string = char\n        paren_stack_reached = False\n        beginning_paren_count\
    \ = paren_count\n      else\n        if paren_stack_reached\n          raise \"\
    Unbalanced parentheses\"\n        else\n          paren_stack_reached_string +=\
    \ char\n          paren_stack_reached = true\n        end\n      end\n      paren_count\
    \ += 1\n    elsif char == ')'\n      if paren_stack.length > 0\n        paren_stack_string\
    \ = char\n        paren_stack_reached = False\n        beginning_paren_count =\
    \ paren_count\n        paren_stack.pop\n      else\n        parsed_parens << beginning_paren_count\
    \ - paren_count\n      end\n      paren_count -= 1\n    elsif paren_stack.length\
    \ == 0\n      parsed_parens << level\n      beginning_paren_count = level\n  \
    \  end\n  end\n  if paren_stack.length > 0\n    raise \"Unbalanced parentheses\"\
    \n  end\n  parsed_parens.reverse!\n  parsed_parens\nend", "  paren_stack = [paren_string]\n\
    \  max_level_stack = []\n  max_level_stack_index = 0\n  while paren_stack.count\
    \ > 0\n    current = paren_stack.first\n    paren_stack.pop\n    if current.length\
    \ == 0\n      max_level_stack[max_level_stack_index] = 0\n    else\n      max_level_stack_index\
    \ = paren_stack.count\n      max_level_stack[max_level_stack_index] += 1\n   \
    \   if max_level_stack[max_level_stack_index] > 1\n        paren_stack.push(current[0...-2])\n\
    \      end\n    end\n  end\n  max_level_stack.first\nend", "  max_level = 0\n\
    \  paren_level = [max_level]\n  paren_level_string = paren_string\n  paren_level_start\
    \ = paren_string.count('(')\n  paren_level_end = paren_string.count(')')", " \
    \ paren_stack = []\n  level = 0\n  nesting_count = 0\n  \n  # For each level of\
    \ parentheses we see, we increase the level.\n  paren_string.scan(/[()]/) do\n\
    \    level += 1\n    nesting_count += 1\n  \n    # We need to increase the level\
    \ and decrease the nesting count if we see a closing parenthesis.\n    paren_string.scan(/[)]/)\
    \ do\n      nesting_count -= 1\n      level -= 1\n    end\n  end\n  \n  # If the\
    \ parenthesis string is empty, we return an empty list as the result.\n  if level\
    \ == 0\n    []\n  else\n    # In case there are no parentheses inside parentheses,\
    \ we return an empty list.\n    # Else, we return a list of nesting levels starting\
    \ with the deepest nesting level.\n    nesting_levels = Array.new\n    nesting_levels.push\
    \ nesting_count if nesting_count > 0\n    nesting_levels.push level\n  end\nend\n\
    </code>\n<|/ a tags=ruby,parentheses,string |>\n<| a dscore=3 |>\nI like to use\
    \ regexes to match parentheses:\n<code>\nstr.gsub(/\\(|\\)/, '').length\n</code>\n\
    <|/ a tags=ruby,parentheses,string |>\n<| c |>\nThe `.length` will count the '('\
    \ characters as well as ')'.\n<|/ c |>\n<| c |>\n: Yeah, I suppose you can do\
    \ `.gsub(/\\(|\\)|\\(/, '').length`, but that seems overly complicated.\n<|/ c\
    \ |>\n<| a tags=ruby,parentheses,string |>\nI'm surprised no one has suggested\
    \ counting the number of opening parentheses and number of closing parentheses.\
    \ \nHere is how I do it: \n<code>", "  paren_stack = ParenStack.new\n  nested_parens\
    \ = []\n  paren_string.split(' ').each do |paren_string|\n    if paren_stack.empty?\n\
    \      nested_parens << paren_string\n    else\n      current_level = paren_stack.pop\n\
    \      nested_parens << current_level if (paren_string == ')' || paren_string\
    \ == '(')\n      nested_parens << current_level if (paren_string == '(')\n   \
    \   nested_parens << current_level if (paren_string == '{')\n    end\n  end\n\
    \  nested_parens\nend", "  paren_string.split(\" \").collect do |paren_string|\n\
    \    paren_string.count(\"(\") - paren_string.count(\")\")\n  end\nend", "  groups\
    \ = []\n  max_level = 0\n  level = -1 \n  paren_count = 0\n  i = 0\n  paren_string.each_char\
    \ {|c|\n    level = level + 1\n    i = i + 1\n    if c == '('\n      paren_count\
    \ = paren_count + 1\n    elsif c == ')'\n      paren_count = paren_count - 1\n\
    \    end\n    if paren_count > max_level\n      max_level = paren_count\n    \
    \  groups = [level]\n    elsif paren_count == max_level\n      groups << level\n\
    \    end\n  }\n  groups\nend", "    paren_string.strip!\n    stack = 0\n    parens\
    \ = []\n    levels = 0\n    paren_string.each_char do |char|\n        if char\
    \ == ')'\n            level += 1\n            if level > stack\n             \
    \   stack = level\n            end\n            levels << level\n        elsif\
    \ char == '('\n            level += 1\n            if level > stack\n        \
    \        stack = level\n            end\n            levels << level\n       \
    \ elsif char == ')'\n            level -= 1\n            if level < stack\n  \
    \              stack = level\n            end\n            if levels == 0\n  \
    \              parens << stack\n            end\n        end\n    end\n    return\
    \ parens\nend", "  paren_string.split(//).inject(0) do |max_level, paren|\n  \
    \  if paren.length == 1\n      max_level\n    elsif paren.length == 2\n      if\
    \ paren.last == paren.first\n        max_level\n      else\n        max_level\
    \ + 1 if max_level < paren.length\n      end\n    end\n  end\nend\n</code>\n<|/\
    \ a |>\n<| a dscore=1 |>\n<code>", "  nesting_levels = []\n  paren_depth = 0\n\
    \  depth = 1\n  paren_open = paren_string.index('(')\n  paren_close = paren_string.rindex(')')",
  "  result = []\n  i = 0\n  paren_count = 0\n  is_open = false", "  paren_stack =\
    \ []\n  paren_count = 0\n  paren_stack_top = paren_stack.size # Start with empty\
    \ stack\n  paren_stack_curr_depth = 0\n  paren_stack_curr_pc = 0\n  \n  # Add\
    \ each parenthesis in the string to the stack\n  paren_stack.push(nil)\n  paren_count\
    \ = 1\n  paren_string.scan(/^\\((.*)\\)$/) do |paren_string|\n    paren_string.scan(/^\\\
    ((.*)\\)$/) do |paren_string|\n      paren_stack.push(nil)\n      paren_count\
    \ += 1\n      paren_stack.push(paren_count)\n    end\n  end\n  \n  # Go through\
    \ the parenthesis in the string and find out their depth\n  while paren_stack.size\
    \ > 0\n    paren_stack_curr_pc = (paren_stack.size - 1).to_s\n    paren_stack_curr_depth\
    \ = paren_stack.pop\n    \n    # If the curr string matches the last string in\
    \ the parenthesis stack\n    if paren_stack_curr_pc.length == paren_string.index(\"\
    )\")\n      \n      # If the string stack has the last string in it and the level\
    \ of nesting between the strings is the same\n      # as the level of nesting\
    \ between the parenthesis stack\n      if paren_stack_curr_depth == paren_stack_curr_pc\n\
    \        paren_stack_curr_depth = paren_stack.size # When the last string is reached\
    \ pop the stack and return to start\n      else\n        # Return the deepest\
    \ level of nesting between the stacks\n        return paren_stack_curr_depth\n\
    \      end\n      \n    elsif paren_stack_curr_pc < paren_string.index(\")\")\n\
    \      \n      # The stack is not empty so we need to check if the previous element\
    \ in the stack matches the current \n      # string in the parenthesis stack \n\
    \      if paren_stack[paren_stack.size - 1].to_s == paren_string.index(\"(\")\n\
    \        \n        # If it does match, we increment the depth of the stack\n \
    \       paren_stack_curr_depth += 1\n        \n        # And push it onto the\
    \ stack\n        paren_stack.push(paren_count)\n        paren_count += 1\n   \
    \   else\n        \n        # If the previous element in the stack does not match\
    \ the current string in the parenthesis stack\n        # then we pop the stack\
    \ and start all over again\n        paren_stack_curr_depth = paren_stack.pop\n\
    \        paren_stack.push(nil)\n        paren_count += 1\n      end\n    end\n\
    \  end\n  \n  # If stack is empty then return -1 indicating that the parentheses\
    \ string could not be parsed\n  return -1\n", "  level = 0\n  nesting = 1\n  paren_stack\
    \ = []\n  paren_stack_index = 0\n  paren_stack_result = []\n  paren_stack_string\
    \ = paren_string\n  paren_stack_string.scan(/[^()]*/) # skip left paren\n  until\
    \ paren_stack_string.empty? do\n    char = paren_stack_string.slice(-1)\n    next\
    \ unless char == ')'\n    paren_stack_result << nesting if paren_stack_index >\
    \ 0\n    paren_stack_index += 1\n    paren_stack << paren_stack_index if paren_stack_index\
    \ < paren_stack.size\n    paren_stack_string.slice!(-1, 1)\n    nesting += 1\n\
    \  end\n  paren_stack_string.slice!(-1, 1) # remove right paren\n  paren_stack_result\
    \ << nesting if paren_stack_index > 0\n  return paren_stack_result if paren_stack_result.size\
    \ > 0\n  return nil\nend", "  paren_count = 0\n  parsed_string = []\n  levels\
    \ = []\n  stack = []\n  paren_pair = 0", "    levels = 0\n    \n    paren_level\
    \ = 0\n    \n    # loop through each char in the string\n    for c in paren_string\n\
    \        \n        # increase levels for each open parenthese\n        if c ==\
    \ '('\n            levels += 1\n            \n        # decrease levels for each\
    \ close parenthese\n        if c == ')'\n            levels -= 1\n           \
    \ \n        # increase levels if more open parentheses\n        if levels > paren_level\n\
    \            paren_level = levels\n    end\n    \n    # return number of levels\n\
    \    return paren_level\nend\n</cell>\n<cell>", "    levels = 0\n    parens_stack\
    \ = []\n    parens_stack_levels = []\n    parens_stack_levels_size = -1\n    parens_stack_current_level\
    \ = -1\n    parens_stack_string = ''\n    i = 0\n    parens = 0\n    string =\
    \ ''", "  tokens = paren_string.split(%r{\\(|\\s|\\)})\n  depth = 0\n  max_depth\
    \ = 0\n  while depth <= max_depth && depth < tokens.size\n    depth += 1\n   \
    \ if depth > max_depth\n      max_depth = depth\n    end\n    tokens = tokens[0\
    \ .. depth]\n  end\n  tokens.reverse\nend", "  levels = [0]\n  result = [-1]\n\
    \  depth = 0\n  paren_count = 0\n  char_at_start = paren_string[0]\n  index =\
    \ 1", "  paren_string = paren_string.dup\n  paren_string.gsub!(/\\s+/, ' ').gsub!(/[^\
    \ ()]+/, '').downcase!\n  level = 0\n  stack = []", "  nested_parentheses = []\n\
    \  nesting_level = 0\n  groups = paren_string.gsub(/\\s+/, ' ').split(' ') # Split\
    \ on whitespaces.\n  groups.each do |group|\n    next if group.empty?\n    if\
    \ group == \"(\" || group == \")\"\n      nested_parentheses << nesting_level\n\
    \      nesting_level += 1\n    else\n      nesting_level -= 1\n    end\n  end\n\
    \  nested_parentheses.max\nend", "  return paren_string.gsub(/\\( *\\)/, '').gsub(/\\\
    ) *\\)/, '').gsub(/\\( *\\)/).scan(/ *\\((.*)\\) *\\( *\\)/).flatten.max\nend",
  "  max_level = 0\n  level_stack = []", "    paren_stack = []\n    paren_stack.append(0)\n\
    \    paren_count = 0\n    paren_levels = [0] * len(paren_string)\n    i = 0\n\
    \    while i < len(paren_string)\n        i += 1\n        paren_count += 1\n \
    \       if paren_count == paren_levels[paren_stack[-1]]\n            paren_stack.pop\n\
    \            paren_count += 1\n            paren_levels[paren_stack[-1]] += 1\n\
    \        if paren_count == paren_levels[paren_stack[-1]]\n            paren_stack.pop\n\
    \            paren_count += 1\n            paren_levels[paren_stack[-1]] += 1\n\
    \        if paren_count > paren_levels[paren_stack[-1]]\n            paren_stack.append(0)\n\
    \    paren_stack.reverse\n    return paren_levels\nend\n</code>\nThe same code\
    \ can be rewritten using recursion:\n<code>", "  paren_string_with_opening_paren\
    \ = paren_string + '('", "  paren_string = paren_string.strip.gsub(/\\(\\)/, '').gsub(/\\\
    )/, '').gsub(/\\((\\))?/, '').gsub(/\\)/, '').split(' ') # Split by spaces.\n\
    \  max_depth = 0\n  max_level = 0\n  paren_depth_stack = []\n  paren_level_stack\
    \ = []\n  paren_level_counter = 0\n  paren_nesting_level = 0\n  paren_nesting_level_counter\
    \ = 0", "  strings = paren_string.split(' ')\n  counts = [0] * MAX_LEVEL\n  for\
    \ string in strings\n    count = counts[string.length]\n    counts[string.length]\
    \ += 1\n    counts[MAX_LEVEL - count] += 1\n  return counts\nend", "    paren_string_splitted\
    \ = paren_string.split\n    paren_level_count = [0]\n    paren_level = []\n  \
    \  paren_level_pointer = 0\n    # Keep a track of how many parentheses have already\
    \ been seen in current depth\n    while paren_level_pointer < paren_level_count[-1]\n\
    \        if paren_level_pointer == 0 # First iteration\n            paren_level_pointer\
    \ += 1\n            paren_level_count.append(paren_level_pointer)\n          \
    \  paren_level.append(0)\n        # Increment count of currently seen parentheses\
    \ by 1\n        else\n            paren_level[paren_level_pointer] += 1\n    \
    \    # Decrement count of currently seen parentheses until they become 0\n   \
    \     while paren_level[paren_level_pointer] == 0\n            paren_level[paren_level_pointer]\
    \ = paren_level_count[paren_level_pointer-1]\n            paren_level_pointer\
    \ -= 1\n            paren_level_count.pop()\n    # Return maximum level of nested\
    \ parentheses present in the string\n    return paren_level_count[-1]\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nFor anyone wondering what the `paren_level_count[-1]`\
    \ at the end means: it's \"the last element of `paren_level_count`, which has\
    \ length `-1` because `paren_level_count` started out as `[0]`.\n<|/ c |>\n<|\
    \ c |>\nThanks for this! I got so excited that I thought \"okay, I just need to\
    \ figure out how to get this code to work using recursion\" that I completely\
    \ forgot that you could use a variable as a parameter in recursion.\n<|/ c |>\n\
    <| a tags=ruby,recursion |>\nI have written a recursive solution that works for\
    \ your given input.  \n<code>\n def num_levels(paren_string)\n    paren_string.chars.group_by{|c|\
    \ c}\n      .select {|k, v| v.size > 1}\n      .map {|k, v| v.length}\n      .max\n\
    \  end\n</code>\nThe core of this solution is Array#chars, which returns an array\
    \ of all the characters of the string.  We then group it by the character, to\
    \ group all the elements of the same character, and select only the ones that\
    \ have a size > 1 (which is the case where there is a pair of parentheses around\
    \ a character other than the first one).  Now we map over each of these groups\
    \ and return the length of each of them, which gives the number of levels.  To\
    \ find the max of the number of levels we simply call Array#max, which will return\
    \ the largest value in the array.\n<|/ a dscore=2 |>\n<| c |>\nThanks James, your\
    \ code works perfectly. I tried the other answers before I sa", "  groups = paren_string.gsub('\\\
    (\\d+\\)', '').split(/\\s+/)\n  levels.zip(groups).each do |level, paren|\n  \
    \  level = (level + 1).to_i\n    levels[level] = [level, paren]\n  end\n  levels.sort_by!{|x,y|\
    \ x[1]}.reverse!\n  levels\nend", "  paren_string = paren_string.strip\n  level\
    \ = 0\n  max_level = 0\n  result = []\n  stack = []\n  i = 0\n  while i < paren_string.length\n\
    \    if paren_string[i] == '('\n      level += 1\n      stack.push i\n      i\
    \ += 1\n    elsif paren_string[i] == ')'\n      if level == 0\n        break\n\
    \      level = stack.pop\n      i += 1\n      result << level\n    end\n    i\
    \ += 1\n  end\n  result\nend\n</code>\nThen you can use it like below.\n<code>\n\
    puts parse_nested_parens(ARGV[0])\n</code>\nFor your sample input, it outputs,\n\
    <code>", "\tlevel = 1\n\tmax_level = 0\n\tlevels = [level]\n\tparen_groups = paren_string.split(/\\\
    )|\\(/)\n\tgroup_index = 0\n\tgroup_paren_levels = [0 for _ in paren_groups]\n\
    \tgroup_paren_levels[0] = 1\n\tfor paren_group in paren_groups\n\t\tgroup_paren_levels[group_index]\
    \ += 1\n\t\tgroup_index += 1\n\t\tlevel += 1\n\t\tmax_level = max(max_level, level)\n\
    \t\tlevels << level\n\tmax_level += 1 unless max_level == 0\n\treturn [max_level,\
    \ *levels]\nend", "    level = 0\n    paren_depth = []\n    paren_queue = [paren_string]\n\
    \    while paren_queue != []:\n        current_string = \"\"\n        current_level\
    \ = 0\n        while paren_depth[current_level] < level:\n            current_string\
    \ += paren_queue.pop(0)\n            current_level += 1\n        paren_depth.append(current_level)\n\
    \        if current_string == \"\":\n            return paren_depth\n        paren_queue.append(current_string)\n\
    \        level += 1\n    return \"No more nested parentheses\"\n</code>\n<|/ a\
    \ tags=python,recursion,string,algorithm |>\n<| c |>\nThis algorithm is really\
    \ helpful, thank you. One question though - how do you know when to stop calling\
    \ `parse_nested_parens`? What are the rules to determine when to stop calling\
    \ `parse_nested_parens`? I understand the concept of \"maximum nesting level\"\
    , but how do you know when to stop calling `parse_nested_parens`?\n<|/ c |>\n\
    <| c |>\nThe algorithm is designed to find the longest string in the string list\
    \ that can contain nested parentheses no greater than the maximum nesting level\
    \ specified. The algorithm calls `parse_nested_parens` once for each level of\
    \ nesting in the input string. The first `parse_nested_parens` call is from the\
    \ first level which can be parsed completely. Then, the next `parse_nested_parens`\
    \ call starts parsing at the level specified (in this case 2), which contains\
    \ two nested parentheses. Then the next `parse_nested_parens` call starts parsing\
    \ at the level specified (in this case 3), which contains three nested parentheses.\
    \ Continue this way until `parse_nested_parens` has exhausted all levels in the\
    \ input string.\n<|/ c |>\n<| a tags=python,recursion,string,algorithm |>\nHere\
    \ is my solution that uses no helper functions:\n<code>", "    stack = []\n  \
    \  paren_count = 0\n    i = 0\n    while i < paren_string.length\n        paren_char\
    \ = paren_string[i]\n        i += 1", "  paren_string = paren_string.strip\n \
    \ return parse_nested_parens_1(paren_string).max_by { |level| level }\nend", " \
    \   stack = []\n    level = 0\n    paren_level = 0\n    paren_start = 0\n    paren_end\
    \ = paren_string.rindex(\")\")\n    while paren_start != -1 do\n        if paren_end\
    \ != -1 and paren_end < paren_start then\n            paren_level = paren_end\
    \ - paren_start + 1\n        else\n            paren_level = 0\n        end\n\
    \        if paren_level > level then\n            level = paren_level\n      \
    \  end\n        stack = stack[paren_level]\n        paren_start = paren_string.index(\"\
    (\", paren_start+1)\n    end\n    stack = stack[level]\n    return stack\nend",
  "  parens = paren_string.scan(/\\(+|\\)+|\\(\\((?>[^()]+)|(\\((?<outer>)|\\((?<-outer>)\\\
    )))\\)+\\)/).flatten(1)\n  nesting_level = parens.reduce(\n    lambda nesting_level,(p,level)\
    \  -> (nesting_level if p == '(' then nesting_level+1 \n                     \
    \                                 else nesting_level) if p == ')' then nesting_level-level\n\
    \                                                      else nesting_level+level),\
    \ \n    0\n  )\n  parens.map { |p| p.start_with?('(') ? p : nil }\nend", "   \
    \ level = 0\n    paren_stack = []\n    paren_levels = []", '  paren_string.strip!',
  "    level = 0\n    index = 0\n    groups = []\n    stack = []\n    prev_group =\
    \ [[]]\n    prev_stack = [level]\n    while index < paren_string.size\n      \
    \  char = paren_string[index]\n        if char == '('\n            level += 1\n\
    \            index += 1\n            stack << level\n            groups << prev_group\n\
    \            prev_group = [[]]\n            prev_stack = [level]\n        elsif\
    \ char == ')'\n            level = stack.pop\n            group = groups.pop\n\
    \            if prev_stack.include? level\n                prev_group << group\n\
    \            else\n                prev_group << prev_group.last\n           \
    \ end\n            index += 1\n        end\n    end\n    groups\nend\n</code>\n\
    <|/ a tags=python,regex |>\n<| a tags=python,regex |>\nThis is a variant of 's\
    \ answer, but doesn't involve any regexes. Instead, it just goes over the string\
    \ and counts the parentheses pairs until it reaches the closing parenthesis:\n\
    <code>", "  paren_string.strip!\n  paren_string = paren_string.gsub(/\\s+/, '\
    \ ').gsub(/\\(/, '')\n  paren_string.gsub!(/\\)/, '')\n  paren_string.split('\
    \ ').map { |x| paren_level(x) }.max\nend", "  paren_levels = paren_string.count('(')\n\
    \  nested_levels = paren_string.count(')') - paren_levels\n  return paren_levels\
    \ + nested_levels\nend", "    parentheses = [[]]\n    paren_stack = []\n    count\
    \ = 0\n    \n    paren_string.each_char {|char|\n        if char == '('\n    \
    \        if paren_stack.length == 0\n                count += 1\n            \
    \    paren_stack.push []\n            else\n                parentheses[paren_stack.length\
    \ - 1].push count\n                count += 1\n                paren_stack.push\
    \ []\n            end\n        else if char == ')'\n            if paren_stack.length\
    \ == 1\n                parentheses[paren_stack.length - 1 - 1] << count\n   \
    \             count = 0\n            else\n                paren_stack.pop\n \
    \               count = parentheses[paren_stack.length - 1].pop\n            end\n\
    \        else\n            count += 1\n            paren_stack.push []\n     \
    \   end\n    }\n    \n    parentheses[paren_stack.length - 1]\nend", "  # Split\
    \ string into array of substrings\n  paren_array = (paren_string.split(/ /))\n\
    \  # If there is a single parens, return 1\n  if(paren_array.length == 1)\n  \
    \  return 1\n  # If there are more than one parens, recursion happen\n  if(paren_array.length\
    \ > 1)\n    return parse_nested_parens(paren_array.pop).inject(0) do |max_nesting,\
    \ level|\n      if(level > max_nesting)\n        max_nesting = level\n      end\n\
    \      max_nesting\n    end\n  # If there is no parens, simply return 0\n  else\n\
    \    return 0\n  end\nend", "  groups = paren_string.split\n  max_groups = groups.inject(0)\
    \ do |max_groups, group|\n    current_groups = group.count('(') - group.count(')')\n\
    \    return max_groups if (current_groups > max_groups)\n    max_groups = current_groups\n\
    \  end\n  max_groups\nend", "  paren_array = []\n  paren_array.push(0) # push\
    \ to paren_array to make the root of the tree\n  max_level = 0 # initialize the\
    \ maximum level of nesting\n  paren_stack = [] # initialize the paren_stack\n\
    \  paren_stack.push(0) # push to paren_stack to mark the last level of nesting",
  "  paren_stack = []\n  max_depth = 0\n  paren_count = 0\n  paren_stack_stack = []\n\
    \  paren_count_stack = []\n  paren_stack_depth = 0", "  level_stack = []\n  level_stack_size\
    \ = -1\n  paren_groups = []\n  paren_groups_size = []\n  paren_group = []\n  paren_groups_temp\
    \ = []\n  current_group_level = 0\n  \n  paren_string.scan(/\\((?=[^\\)]*\\))|(?<=[^\\\
    )]*\\))/) do |paren_open|\n    if paren_open.opening\n      level_stack[level_stack_size]\
    \ = current_group_level\n      level_stack_size += 1\n    end\n    \n    if paren_open.closing\n\
    \      level_stack_size -= 1\n    end\n    \n    current_group_level += 1\n  \
    \  \n    paren_groups << paren_open\n    paren_groups_size << current_group_level\n\
    \    \n    paren_groups_temp << paren_open\n    \n    paren_groups_temp.each do\
    \ |paren_open|\n      if paren_open.opening\n        current_group_level += 1\n\
    \      end\n      \n      paren_groups << paren_open\n      paren_groups_size\
    \ << current_group_level\n    end\n    \n    paren_groups_temp.empty? ? paren_group\
    \ : nil\n  end\n  \n  level_stack[level_stack_size] = current_group_level\n  level_stack_size\
    \ += 1\n  \n  paren_groups[level_stack_size]\nend\n</cell>\n<cell>\n%w[\n  abc\
    \ def\n  ghi jkl\n  mno pqr stu\n  vwx yz0\n  ijk\n].each do |word|\n  puts parse_nested_parens(word)\n\
    end\n</cell>\n<text>\nB. Test your parser\nWrite a test program that uses a parsing\
    \ function and verifies that you get expected results. For each test case, output\
    \ the answer and the number of expected parens.", "  parsed_string = paren_string.split('\
    \ ')\n  max_depth = parsed_string.map { |x| x.count('(') - x.count(')')}.max\n\
    \  parsed_string = parsed_string.map { |x| x.count('(') + x.count(')')}.map {\
    \ |x| x.length - max_depth }\n  parsed_string\nend", "  levels_of_nesting = []\n\
    \  in_paren_count = 0\n  in_paren_level = 0\n  paren_string.scan(/\\(/) do | paren_char\n\
    \    in_paren_count += 1\n    in_paren_level += 1\n    levels_of_nesting << in_paren_level\n\
    \    paren_string.scan(/\\)/) do | paren_char\n      in_paren_count -= 1\n   \
    \   in_paren_level -= 1\n      levels_of_nesting << in_paren_level\n    end\n\
    \    levels_of_nesting << in_paren_level\n  end\n  levels_of_nesting\nend\n</code>\n\
    <|/ a tags=regex,string,ruby |>\n<| c |>\nThis works great for me! I added `levels_of_nesting\
    \ = []` outside of the main loop, and I removed the `levels_of_nesting << in_paren_level`\
    \ inside the loop. Thanks!\n<|/ c |>\n<| c |>\nHi Andrew! I'm still trying to\
    \ get this to work correctly. Could you explain what the purpose of the second\
    \ `paren_string.scan` is? I'm confused about why that would make any difference.\
    \ I assume it searches for the next closing paren?\n<|/ c |>\n<| c |>\nOh, I see\
    \ what you're saying now. I was just trying to reuse the `levels_of_nesting` variable\
    \ between nested parens. I probably shouldn't have called it that. I'll reword\
    \ my question to reflect that.\n<|/ c |>\n<| a |>\nI think you are going about\
    \ this the wrong way. The parenthetic grouping is done by identifying groups of\
    \ characters which have balanced parantheses.\nYou should be looking at identifying\
    \ parentheses (i.e. opening and closing parens), and then identifying groups of\
    \ characters with balance parens.\nOnce you have identified groups of characters\
    \ with balanced parentheses, you need to count the number of characters in each\
    \ group until you reach a point where you encounter a closing paren. Then you\
    \ know how many groups of characters with balanced parens are still open, and\
    \ you know how many groups of characters with balanced parens are closed.\nIf\
    \ you need to also identify the character that encloses the parentheses, this\
    \ will be done by finding each opening/closing paren, counting how many characters\
    \ there are, and then getting the index of the character that encloses them. E.g.\
    \ if there are 5 characters with balanced parens and 2 characters with no balancing\
    \ parens, you can get the index of the character that encloses them by finding\
    \ the opening paren and counting characters until you reach the closing paren.\n\
    The approach I described is probably the most flexible and ", "  level = 0\n \
    \ paren_stack = []\n  paren_level = 0\n  paren_counter = 0\n  i = 0\n  while i\
    \ < paren_string.length\n    if paren_string[i] == '('\n      paren_stack.unshift\
    \ paren_level\n      paren_counter += 1\n      paren_level += 1\n    elsif paren_string[i]\
    \ == ')'\n      paren_level -= paren_stack.pop\n      paren_counter -= 1\n   \
    \   paren_level -= 1\n      break if paren_level == 0\n    elsif paren_string[i]\
    \ == ' '\n      i += 1\n      while i < paren_string.length && paren_string[i]\
    \ == ' '\n        i += 1\n      end\n    end\n    i += 1\n  end\n  return paren_counter\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work. Example: parse_nested_parens(\"\
    ((((())))\") returns 3 when it should be 2\n<|/ c |>\n<| c |>\nI ran it on my\
    \ machine and it returns 2\n<|/ c |>\n<| c |>\nIt returns 1 for \"((())()\" when\
    \ it should return 3\n<|/ c |>\n<| c |>\nTry `parse_nested_parens(\"(()()((()))\
    \ () ((())()())\")`. It's not exactly the same, but this returns 3 instead of\
    \ 1 on that string.\n<|/ c |>\n<| c |>\nYou're right I tested some more and I\
    \ fixed it now\n<|/ c |>\n<| a tags=string,algorithm,ruby dscore=1 |>\nUsing regex\
    \ and a stack:\n<code>", "  paren_levels = [-1]\n  paren_level = 0\n  max_level\
    \ = 0\n  paren_count = paren_string.count('(')\n  paren_levels[paren_count] =\
    \ []\n  paren_levels[paren_count].push(paren_count)\n  i = 0\n  while i < paren_string.length\n\
    \    if paren_string[i] == '('\n      paren_count += 1\n      paren_levels[paren_count]\
    \ = []\n      paren_levels[paren_count].push(paren_count)\n      i += 1\n    elsif\
    \ paren_string[i] == ')'\n      paren_count -= 1\n      if paren_levels[paren_count].length\
    \ > max_level\n        max_level = paren_levels[paren_count].length\n      i +=\
    \ 1\n      paren_levels[paren_count].push(paren_count)\n    elsif paren_string[i]\
    \ == '#'\n      i += 1\n      paren_count = 0\n    end\n  end\n  return max_level\n\
    end", '  paren_string = paren_string.strip unless paren_string.empty?', "  level\
    \ = 1\n  result = []\n  \n  for i in paren_string.split(' ') do\n    case i do\n\
    \      nil ->\n        result = [level]\n      \n      '()' ->\n        result\
    \ = [level]\n      \n      '(())' ->\n        level = level + 1\n        \n  \
    \    ')' ->\n        level = level - 1\n        \n      _ ->\n        result =\
    \ [level] + result\n    end\n  end\n  \n  result\nend", "  # Count level of parentheses.\n\
    \  max_level = 0\n  bracket_stack = Hash.new(0)", "  paren_string.scan(/\\((?=\\\
    ()|(?=\\))|(?<=(\\)))/)\n  paren_levels = paren_string.scan(/\\((?=\\()|(?=\\\
    ))|(?<=(\\)))\\)/)\n  paren_levels.map!{|x| x.count}\n  paren_levels.max\nend",
  "  max_level = 0\n  nested_paren_count = 0\n  paren_array_strings = paren_string.split(\"\
    \ \")\n  paren_array_strings[paren_array_strings.length-1] = paren_array_strings[paren_array_strings.length-1].strip\n\
    \  paren_array_strings.each do |paren_array|\n    if paren_array != \"\" and paren_array\
    \ !~ /\\(/\n      paren_array = paren_array.split(\"(\")\n      if paren_array.length\
    \ != 2\n        max_level = max(max_level, nested_paren_count)\n      else\n \
    \       nested_paren_count += 1\n      end\n    end\n  end\n  return max_level\n\
    end", "    # Using a stack to reverse the order of operations.\n    # Push the\
    \ current level one level deeper on each new opening parenthesis.\n    # Push\
    \ the deepest level once a closing parenthesis is seen. \n    # To find the deepest\
    \ level, just remove all closed parentheses from the stack.\n    nested_levels\
    \ = []\n    paren_count = 0\n    stack_level = 1\n    stack = []\n    paren_stack\
    \ = []\n    prev_is_open = 0\n    \n    # Scan through the string and push the\
    \ opening parentheses to the stack.\n    for c in paren_string\n        paren_count\
    \ += 1\n        if c == '('\n            stack_level += 1\n            stack.append(c)\n\
    \            paren_stack.push(stack_level)\n            prev_is_open = 1\n   \
    \     elif c == ')'\n            if prev_is_open\n                stack_level\
    \ -= 1\n                prev_is_open = 0\n            stack.pop\n            paren_stack.pop\n\
    \            nested_levels.push(stack_level)\n        elsif paren_stack.length()\
    \ > stack_level\n            nested_levels.push(paren_stack.pop())\n        end\n\
    \    end", "  paren_stack = []\n  paren_count = 0\n  result = []", "  stack =\
    \ ArrayStack.new\n  paren_string.split.each do |paren|\n    if paren == '('\n\
    \      stack.push(1)\n    elsif paren == ')'\n      result = stack.pop\n     \
    \ result ? stack.push(result) : stack.push(1)\n    else\n      stack.push(paren.length)\n\
    \    end\n  end\n  stack.pop\nend", "    level = 1\n    stack = []\n    levels\
    \ = []\n    temp_str = paren_string\n    while temp_str.size > 0\n        if temp_str[0]\
    \ == \"(\"\n            level += 1\n            stack << level\n            levels\
    \ << level\n            temp_str = temp_str[1..-1]\n        else\n           \
    \ if level > 1\n                level = stack.pop\n                levels << level\n\
    \            end\n            temp_str = temp_str[0..-2]\n        end\n    end\n\
    \    return levels\nend", "  level = 0\n  results = []\n  paren_depths = paren_string.split(\"\
    \ \").map { |s| s.length }\n  paren_depths.each do |n|\n    level += 1\n    next\
    \ if paren_depths.min < n\n    results << level\n    level += 1\n  end\n  results\n\
    end", "    levels_of_nesting = []\n    i = 0\n    paren_stack = [paren_string[i]]\n\
    \    while i < len(paren_string)\n        if paren_stack[-1] == '('\n        \
    \    # Increase the level of nesting of parentheses.\n            levels_of_nesting.append(levels_of_nesting.pop()\
    \ + 1)\n            paren_stack.append(paren_string[i])\n        elif paren_stack[-1]\
    \ == '{'\n            # Decrease the level of nesting of parentheses.\n      \
    \      levels_of_nesting.pop()\n            paren_stack.append(paren_string[i])\n\
    \        else # if paren_stack[-1] == '}'\n            # Exit the level of nesting.\n\
    \            levels_of_nesting.pop()\n            i += 1\n            paren_stack.pop()\n\
    \    return levels_of_nesting\n</code>\n<|/ a tags=parsing,python |>\n<| a dscore=2\
    \ tags=parsing,python |>\nTry this (I haven't tested it thoroughly but seems to\
    \ work)\n<code>", "    stack = []\n    for char in paren_string\n        if char\
    \ == ')'\n            stack.pop if stack\n        else\n            stack << char.length\n\
    \            stack.last += char.length if stack.any? && !stack.pop\n        end\n\
    \    end\n    stack\nend", "  groups = paren_string.split()\n  max_depth = 0\n\
    \  \n  groups_with_open_brackets = groups[0..-2]\n  \n  depth = 0\n  for i in\
    \ range(0, groups_with_open_brackets.size)\n    depth += groups_with_open_brackets[i].size\n\
    \    if depth > max_depth\n      max_depth = depth\n    end\n  end\n  \n  return\
    \ max_depth\nend\n</cell>\n<code language=julia-0.5>\nparse_nested_parens(\"((()))\
    \ () ((())()())\")\n</cell>\n<text>\nExercise", "  nesting = 1\n  paren_count\
    \ = 0\n  paren_levels = []\n  paren_levels_array = []\n  group_count = 0\n  grouping_string\
    \ = ''\n  while paren_count < len(paren_string)\n    if paren_string[paren_count]\
    \ == '('\n      paren_count += 1\n      group_count += 1\n      grouping_string\
    \ += paren_string[paren_count]\n      paren_levels_array = []\n      paren_levels.append(paren_count)\n\
    \      if grouping_string.index('(') > grouping_string.index(')')\n        nesting\
    \ += 1\n        paren_levels_array.append(nesting)\n        grouping_string =\
    \ ''\n      else\n        nesting -= 1\n      paren_count += 1\n    elsif paren_string[paren_count]\
    \ == ')'\n      if paren_levels_array.size > 0\n        paren_levels_array[-1]\
    \ -= 1\n      else\n        paren_count += 1\n      end\n      if paren_levels_array[-1]\
    \ == 0\n        paren_levels.pop\n        paren_levels_array.pop\n      else\n\
    \        paren_count -= 1\n      end\n    end\n    paren_count += 1\n  end\n \
    \ paren_levels_array.size\nend", "  paren_stack = [0]\n  paren_levels = [0]\n\
    \  paren_groups = []\n  paren_counter = 0\n  paren_levels_stack = []\n  paren_groups_stack\
    \ = []\n  while paren_counter < paren_string.length\n    paren_counter += 1\n\
    \    ch = paren_string[paren_counter]\n    \n    if ch == '('\n      paren_stack.append(paren_counter)\n\
    \      paren_levels_stack.append(paren_levels[-1]+1)\n      paren_groups_stack.append([])\n\
    \      paren_levels.append(0)\n      paren_groups.append([])\n    \n    elif ch\
    \ == ')'\n      levels_to_pop = paren_levels_stack.pop\n      groups_to_pop =\
    \ paren_groups_stack.pop\n      \n      groups_to_pop[-1][-1] += 1\n      \n \
    \     if paren_groups[-1] == groups_to_pop\n        paren_groups[-1] = []\n  \
    \    \n      paren_groups[-1] << levels_to_pop\n      \n      if paren_stack[-1]\
    \ == paren_counter\n        paren_stack.pop()\n        paren_levels = paren_levels_stack\n\
    \        paren_groups = paren_groups_stack\n      \n    elsif ch == ' '\n    \
    \  if paren_levels[-1] > 0\n        paren_groups[-1] << paren_levels[-1]-1\n \
    \     else\n        paren_levels[-1] += 1\n      end\n    end\n  end\n  \n  return\
    \ paren_groups\nend", "  paren_stack = []\n  open_count = 0\n  end_stack = []\n\
    \  max_level = 0\n  open_paren = 0", "  # initialize result\n  result = Array.new\n\
    \  \n  # loop through input string\n  paren_string.split(' ').each do |paren_string|\n\
    \    # initialize result level\n    level = 1\n    \n    # loop through current\
    \ level\n    while level > 0\n      # find opening and closing parenthesis\n \
    \     opening_paren = paren_string.index('(')\n      closing_paren = paren_string.index(')')\n\
    \      \n      # if we found opening and closing parentheses, increment level\n\
    \      if opening_paren != -1 && closing_paren != -1\n        level = level +\
    \ 1\n      \n      # if we found closing parenthesis, decrease level\n      elsif\
    \ closing_paren != -1\n        level = level - 1\n      \n      # if we are at\
    \ the lowest level, add the result to the result array\n      elsif opening_paren\
    \ == -1\n        result = [result.last, level].max\n      \n      # if we are\
    \ at the highest level, add the result to the result array\n      elsif closing_paren\
    \ == -1\n        result = [result, level].min\n      end\n    end\n  end\n  result\n\
    end", "  # Parsing logic:\n  #  - Each paren group is a valid paren\n  #  - Each\
    \ paren group must be closed before a new group is opened\n  #  - Once all groups\
    \ are closed, return maximum of all nesting\n  levels = []\n  level_stack = [-1]\n\
    \  paren_groups = []\n  \n  paren_string = paren_string.strip\n  \n  while paren_string\n\
    \    \n    if paren_string.start_with?('(')\n      # Open new paren group\n  \
    \    paren_groups.push(paren_string.slice!(0, 1))\n      paren_string = paren_string.slice(1)\n\
    \    elsif paren_string.end_with?(')')\n      # Close previous paren group\n \
    \     level_stack.pop\n      \n      levels.push(level_stack.last)\n      \n \
    \     paren_string = paren_string.slice!(-1)\n    else\n      # Append the current\
    \ paren group to the previous paren group\n      paren_groups.push(paren_string)\n\
    \      paren_string = ''\n    end\n  end\n  \n  levels\nend", "  \n  paren_stack\
    \ = []\n  levels = []\n  paren_string.each_char do |char|\n    if paren_stack.empty?\n\
    \      level =  paren_stack.size \n    elsif char == '('\n      level += 1\n \
    \     paren_stack.push(level)\n    elsif char == ')'\n      paren_stack.pop\n\
    \      level -= 1\n    elsif level < paren_stack.last\n      levels << paren_stack.last\n\
    \      paren_stack.last = 0\n    end\n  end\n  \n  levels\nend", "    level =\
    \ 1\n    stack = [level]\n    paras = ['']\n    \n    # Find deepest level of\
    \ nesting for the given paren string\n    paren_string.split(\" \").each do |item|\n\
    \        # Remove extra parentheses enclosed by the current paren item\n     \
    \   if item[-1] == '(' && item[-2] != ')'\n            paras << item\n       \
    \ # Keep the top level paren item\n        elsif item == '('\n            level\
    \ += 1\n        # Pop out all but the top level paren items\n        elsif item[-1]\
    \ == ')'\n            level = stack.delete_at(level)\n        end\n    end\n \
    \   \n    # Calculate result by traversing the stack\n    paras.each_with_index\
    \ do |item, index|\n        if index == paras.length - 1\n            paras.delete_at(index)\n\
    \        else\n            paras[index + 1] = paras[index + 1].succ if paras[index\
    \ + 1].odd?\n        end\n    end\n    \n    paras.count\nend", "  paren_count\
    \ = 0\n  current_level = 1\n  levels = []\n  bracket_depths = []\n  bracket_count\
    \ = 0\n  in_parens = false\n  parentheses_count = 0\n  paren_chars = ['(', ')',\
    \ '{', '}']\n  paren_char_map = Hash.new", "  res = []\n  i = 0\n  while i < paren_string.length\n\
    \    ch = paren_string.charAt(i)\n    if ch == '('\n      i += 1\n      while\
    \ i < paren_string.length && paren_string.charAt(i) != ')'\n        i += 1\n \
    \     res << i\n      i += 1\n    elsif ch == '('\n      res << i\n      i +=\
    \ 1\n    else\n      i += 1\n  end\n  return res\nend", "  paren_groups = paren_string.split(\"\
    )\")\n  max_level = 0\n  level_sum = []\n  paren_groups_copy = paren_groups.copy()\n\
    \  paren_groups_copy.each do |paren_group|\n    level = paren_groups_copy.count(\"\
    (#{paren_group})\")\n    level_sum << level if level > max_level\n    max_level\
    \ = level if level > max_level\n    paren_groups_copy.replace(paren_group, \"\
    (#{paren_group})\") # replace with max level group\n  end\n  return level_sum\n\
    end", "  level = 0\n  parens_levels = []", "  parens = paren_string.scan(/[\\\
    (\\)]/)\n  parens.each do |paren|\n    level = 0\n    while level < paren.length\n\
    \      paren = paren[level..-1]\n      if paren.match?(/\\(/)\n        level +=\
    \ 1\n      elsif paren.match?(/\\)/)\n        level -= 1\n      end\n    end\n\
    \  end\nend", "  paren_string.split(' ').inject([]) do |stack, op|\n    if op.include?('(')\n\
    \      stack << 1\n    elsif op.include?(')')\n      stack.pop\n    else\n   \
    \   stack\n    end\n  end\nend", "  paren_string = paren_string.downcase\n  paren_stack\
    \ = []\n  stack_index = 0\n  index = 0\n  depth = 0\n  while index <= paren_string.length\n\
    \    if paren_string[index] == '('\n      paren_stack.push(index)\n      index\
    \ += 1\n      depth += 1\n      elsif paren_string[index] == ')'\n      if paren_stack.length\
    \ > depth\n        depth = paren_stack.length\n      else\n        paren_stack.pop\n\
    \      end\n      index += 1\n    end\n    stack_index = paren_stack.size\n  \
    \  if index >= paren_string.length\n      stack_index = paren_stack.size\n   \
    \ end\n    stack_index <= stack_index ? stack_index : stack_index = stack_index\
    \ + 1\n  end\n  return paren_stack\nend", "  max_level = 0\n  groups = []\n  brackets\
    \ = 0\n  chars = []\n  brackets_stack = []\n  bracket_depth = 0\n  current_string\
    \ = ''\n  level = 0\n  bracket_pair = ''\n  bracket_count = 0\n  bracket_pair_count\
    \ = 0\n  last_bracket_depth = 0\n  string = ''", "  groups = paren_string.split\n\
    \  levels.reverse_each { |i| groups[i].each_with_index { |x, j| groups[i][j] =\
    \ nil unless x.strip == '(' }; groups[i] << '(' }\n  groups.map(&:count)\nend",
  "  depth = 0\n  stack = [[]]\n  paren_count = 0\n  \n  while paren_count > 0\n \
    \   paren_count += 1\n    \n    paren_str = paren_string[paren_count]\n    \n\
    \    if paren_str == '('\n      stack.last << paren_str\n    elsif paren_str ==\
    \ ')'\n      depth = stack.last.size\n      if stack.last.empty?\n        break\n\
    \      elsif depth <= 0\n        depth += 1\n      else\n        stack.pop\n \
    \     end\n    else\n      stack.last << paren_str\n    end\n    \n    paren_str\
    \ = paren_string[paren_count + 1]\n    if paren_str == '('\n      stack.last <<\
    \ paren_str\n    else\n      stack.last << paren_str\n    end\n    \n    if paren_count\
    \ % 2 == 1\n      stack.pop\n    end\n  end\n  \n  max_level = -1\n  max_level_stack\
    \ = []\n  \n  stack.each do |paren_list|\n    max_level = paren_list.size if paren_list.size\
    \ > max_level\n    max_level_stack.push(max_level)\n  end\n  \n  max_level_stack.each\
    \ do |max_level|\n    max_level += 1 if max_level > 0\n  end\n  \n  return max_level\n\
    end", "  max_level_of_nesting = 0\n  nested_parens = []\n  group_index = 0\n \
    \ paren_count = 0\n  open_pcount = 0\n  current_open_pcount = 0\n  current_open_pcount\
    \ = 0\n  paren_level = 0\n  last_open_pcount = 0\n  next_char_index = 0\n  while\
    \ next_char_index < paren_string.length\n    char = paren_string[next_char_index]\n\
    \    if char == '('\n      open_pcount += 1\n      if open_pcount > max_level_of_nesting\n\
    \        max_level_of_nesting = open_pcount\n      current_open_pcount = open_pcount\n\
    \      paren_level += 1\n      nested_parens << paren_level\n    elseif char ==\
    \ ')'\n      open_pcount -= 1\n      if open_pcount < current_open_pcount\n  \
    \      raise \"Parentheses count mismatch\"\n      nested_parens.pop\n      paren_level\
    \ -= 1\n    elseif char == ')'\n      open_pcount -= 1\n      if open_pcount <\
    \ current_open_pcount\n        raise \"Parentheses count mismatch\"\n      nested_parens.pop\n\
    \      paren_level -= 1\n      current_open_pcount = open_pcount\n    end\n  \
    \  last_open_pcount = open_pcount\n    next_char_index += 1\n  end\n  return nested_parens\n\
    end", "  return paren_string.split(' ').inject(0) do |level, paren_str|\n    (paren_str.length\
    \ % 2 ? level : level - 1) + (paren_str[level..-1].length % 2 ? 1 : 0)\n  end\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby,regex,string |>\n<| a dscore=1 |>\nUsing\
    \ String#index\n<code>", "  paren_string.split(\" \").map{|s| s.count(\"(\") -\
    \ s.count(\")\")}.max\nend", "  \n  # Parse the string and create a list of parenthesized\
    \ groups for each parenthesis.\n  # E.g. (())() would be represented as ['(',\
    \ '(', ')', '(', ')']\n  parsed_parens = paren_string.split(' ')\n  \n  # Create\
    \ a dictionary that stores the maximum nesting level for each group of parentheses.\n\
    \  # E.g. (()()) would be represented as {1: 2, 2: 3, 3: 1}\n  # Initializing\
    \ the dictionary to zero means it will not contain any key for the first group.\n\
    \  max_nesting_levels = {}\n  \n  # For each parenthesis in the parsed string,\
    \ create a list of its groups and iterate through them.\n  # E.g. (())() would\
    \ be represented as [{'()': ['()'], '(': ['('], ')': ['(', ')'], '[': ['[']}]\n\
    \  parsed_parens.each do |parenthesis|\n    \n    # If the dictionary does not\
    \ contain the group at this level, add it with a zero nesting level.\n    # E.g.\
    \ (())() would be represented as {1: {'()': ['()'], '(': ['('], ')': ['(', ')'],\
    \ '[': ['[']}}\n    # Notice that '[' is represented as a key since there is no\
    \ group at this level (level 0).\n    # When adding '[' as a key, it will increase\
    \ the nesting level for the current group (level 0).\n    # The maximum nesting\
    \ level will be the one associated with the highest level at the current group.\n\
    \    # Hence, the maximum in this case will be 3.\n    max_nesting_levels[parenthesis]\
    \ = { '[': 0, '{': 0 }\n    \n    # Iterate through the groups associated with\
    \ the current parenthesis.\n    # E.g. (())() would be represented as [{'()':\
    \ ['()'], '(': ['('], ')': ['(', ')'], '[': ['[']}]\n    parenthesis.each do |group|\n\
    \      \n      # If the group at the current level does not contain this parenthesis,\
    \ add the parenthesis\n      # with a zero nesting level to the dictionary at\
    \ this level.\n      # E.g. (())() would be represented as {1: {'()': ['()'],\
    \ '(': ['('], ')': ['(', ')'], '[': ['[']}}\n      # Notice that '(' is represented\
    \ as a key since there is no group at this level (level 1).\n      max_nesting_levels[parenthesis][group]\
    \ ||= 0\n      \n      # Add the current group with its current nesting level\
    \ to the dictionary.\n      # E.g. (())() would be represented as {1: {'()': ['()'],\
    \ '(': ['('], ')': ['(', ')'], '[': ['[']}}\n      max_nesting_levels[parenthesis][group",
  "  levels = paren_string.scan(/[\\(\\)]+/).size\n  result = []\n  i = 0\n  while\
    \ i < paren_string.size\n    if paren_string[i] == '('\n      i += 1\n      while\
    \ i < paren_string.size && paren_string[i] != ')'\n        i += 1\n      result\
    \ << levels\n      i += 1\n      levels += 1\n    elsif paren_string[i] == ')'\n\
    \      i += 1\n      levels -= 1\n    end\n  end\n  result << levels\n  result\n\
    end", "  stack = []\n  paren_levels = []\n  paren_level = 0\n  num_parens = 0\n\
    \  paren_counter = 0\n  paren_groups = paren_string.scan(/\\(.*\\)|\\{.*\\}/)\n\
    \  paren_groups.each do |paren_group|\n    if paren_group == '('\n      paren_counter\
    \ += 1\n    elsif paren_group == ')'\n      paren_level -= 1\n      if paren_level\
    \ == 0\n        paren_levels << paren_counter\n      end\n    end\n    num_parens\
    \ += 1\n    stack << paren_group\n  end\n  if num_parens > 0\n    return paren_levels\n\
    \  end\n  return stack\nend", "  paren_count = 0\n  max_depth = 0\n  paren_level\
    \ = []\n  paren_nesting = 0\n  paren_stack = []\n  paren_stack_size = 10000\n\
    \  paren_stack_depth = 0\n  paren_stack_string = ''\n  paren_string = paren_string.strip\n\
    \  paren_string.gsub!(/\\s+/, '')\n  paren_arr = paren_string.gsub(/\\([^()]*\\\
    )/, '').split('()')\n  paren_arr.each do |paren|\n    if paren_count > 0\n   \
    \   paren_stack[paren_stack_depth] << paren\n      paren_stack_depth += 1\n  \
    \    paren_stack_string = paren_stack[paren_stack_depth].join('()')\n      paren_count\
    \ += 1\n    end\n    depth = paren_nesting\n    if paren_nesting >= max_depth\n\
    \      max_depth = paren_nesting\n    end\n    if paren_count == 0 && paren.strip\
    \ == '(' && paren_nesting < max_depth\n      paren_level = [paren_nesting, max_depth]\n\
    \    end\n    if paren_count == 0 && paren.strip == '(' && paren_nesting == max_depth\n\
    \      paren_level = [paren_nesting, max_depth]\n    end\n    paren_nesting +=\
    \ depth\n  end\n  paren_level\nend\n</code>\n<|/ a tags=ruby,regex dscore=1 |>\n\
    <| c |>\nJust a quick note, `paren_arr.each do |paren|` should be `paren_arr.each\
    \ do |paren_string|` since that is the string you actually want to parse.\n<|/\
    \ c |>\n<| a |>\nI thought this would be interesting.\n<code>", "  paren_stack\
    \ = []\n  paren_count = 0\n  paren_nesting = 1\n  parentheses_count = 0\n  paren_levels\
    \ = [[]]\n  index = 0", "  parsed_paren = []\n  paren_count = 0\n  paren_stack\
    \ = []\n  paren_stack_size = -1\n  \n  begin = 0\n  end_paren = paren_string.index(\"\
    )\")\n  \n  while begin < end_paren\n    # Check if closing parenthesis is found\
    \ in same group\n    if paren_stack[-1] == paren_string[end_paren+1]\n      #\
    \ If yes, pop the stack and continue\n      paren_stack.pop\n    else\n      paren_count\
    \ += 1\n      paren_stack.push([paren_string[begin]] + paren_string[begin..end_paren])\n\
    \      begin = end_paren + 1\n    end\n  end\n  \n  parsed_paren.push(paren_string[end_paren+1..-1])\n\
    \  \n  return parsed_paren\nend", "  paren_string_arr = paren_string.split \"\
    \ \" # split parentheses string into individual parentheses\n  paren_string_arr.each\
    \ do |paren_string| # loop through each individual parentheses\n    depth = 0\
    \ # initialize depth\n    paren_string_arr.each do |paren_string| # loop through\
    \ each individual parentheses again\n      if paren_string == \")\" # if the current\
    \ parentheses is a closing parenthese\n        depth = depth - 1 # decrement the\
    \ depth\n      else # if the current parentheses is an opening parenthese\n  \
    \      depth = depth + 1 # increment the depth\n      end # end if\n    end #\
    \ end each\n    puts depth\n  end # end each\nend # end function\n</code>\n<|/\
    \ a tags=parentheses,string,ruby dscore=2 |>\n<| c |>\nI made my own Ruby implementation,\
    \ and it seems my Ruby implementation is much faster than your Ruby implementation\
    \ and my Ruby implementation is still much slower than the original Ruby code\
    \ I posted. Can you suggest an improvement?\n<|/ c |>\n<| a tags=parentheses,string,ruby\
    \ |>\nI wrote a method that recursively counts the amount of nested parentheses\
    \ in a string and then returns an array with the deepest level of nesting of parentheses.\
    \ \n<code>", "  paren_array = paren_string.split(' ')\n  max_level = 0\n  array_elements\
    \ = []\n  for element in paren_array\n    if element != ''\n      array_elements\
    \ << element\n      current_level = 0\n      \n      if array_elements.count >=\
    \ 2\n        current_level = (paren_array.count - 1) - (array_elements.count -\
    \ 1)\n      end\n      \n      current_level += 1\n      if current_level > max_level\n\
    \        max_level = current_level\n      end\n    end\n  end\n  \n  if max_level\
    \ > 0\n    return max_level\n  else\n    return 0\n  end\nend\n</cell>\n<cell>",
  "  paren_count = 0\n  level_of_nesting = nil\n  paren_string = paren_string.strip\n\
    \  paren_stack = []\n  paren_stack.push(paren_string)", "  paren_string.scan(/[^()]+/)\n\
    \  paren_string.scan(/[()]/)\n  max_depth = 0\n  group_count = []\n  current_group\
    \ = 0", "  result = []\n  parsing_open_bracket = false\n  parsing_close_bracket\
    \ = false\n  paren_stack = []", "  paren_string.gsub!(/ +/, ' ')\n  depth = 0\n\
    \  cur_paren = 0\n  result = Array.new\n  paren_stack = Array.new(4)\n  paren_stack.last\
    \ = 0\n  paren_stack.clear\n  paren_string.scan(/[(]*[^()]+[)]*/) do |paren|\n\
    \    if paren == '('\n      paren_stack.push(depth)\n      depth += 1\n    elsif\
    \ paren == ')'\n      depth = paren_stack.pop\n      depth -= 1\n    end\n   \
    \ result.push(depth)\n  end\n  result\nend", "  # Check for an empty string.\n\
    \  if paren_string.empty?\n    return []\n  \n  # Initialize a stack to keep track\
    \ of nesting levels.\n  stack_without_left_bracket = []\n  \n  # Keep iterating\
    \ while there are more characters to pop.\n  while !paren_string.empty?\n    #\
    \ Pop a character from the string.\n    popped_char = paren_string.pop\n    \n\
    \    # If the stack is empty, add character to the stack without left bracket.\n\
    \    unless stack_without_left_bracket.empty?\n      stack_without_left_bracket.last.push(popped_char)\n\
    \    else\n      stack_without_left_bracket.push(popped_char)\n    end\n    \n\
    \    # If the stack is NOT empty and current character is an open parenthese,\
    \ \n    # pop left bracket if one exists from this stack. Otherwise, add a left\
    \ bracket\n    # to the stack. \n    if !stack_without_left_bracket.empty? and\
    \ stack_without_left_bracket.last.empty?\n      stack_without_left_bracket.pop\n\
    \      \n      unless stack_without_left_bracket.empty?\n        stack_without_left_bracket.last.push(\"\
    (\")\n      end\n    end\n    \n    # If the stack is NOT empty and current character\
    \ is an open bracket or close \n    # parenthesis, pop the top value from the\
    \ stack without left bracket.\n    if !stack_without_left_bracket.empty? and stack_without_left_bracket.last.any?\n\
    \      stack_without_left_bracket.pop\n    end\n  end\n  \n  # Return the deepest\
    \ level of nesting of parentheses.\n  stack_without_left_bracket.count { |item|\
    \ item == \"(\" } + 1\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you for\
    \ the suggestion! Unfortunately I cannot use recursion here.\n<|/ c |>\n<| c |>\n\
    That's not true, you could.  I updated my answer with an example using recursion.\n\
    <|/ c |>\n<| c |>\nI updated my answer with a recursive solution without using\
    \ recursion.\n<|/ c |>\n<| c |>\nThank you so much for all the effort. I think\
    \ I understood the code pretty clearly except for the part where it pops values\
    \ from `stack_without_left_bracket` after the first time they are pushed. So I\
    \ guess the code can be reduced to `stack_without_left_bracket.count { |item|\
    \ item == \"(\" } + 1` right after it iterates the while loop (instead of repeatedly\
    \ pushing and popping).\n<|/ c |>\n<| c |>\nYeah, that's right.  I didn't want\
    \ to ", "  paren_string.gsub!(/\\(/, ' (')\n  paren_string.gsub!(/\\)/, ' )')\n\
    \  paren_string.scan(/\\s+/) { |x| paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\\
    s{2,}/) { |x| paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\(/) { |x| paren_string.gsub!(x,\
    \ ' ') }\n  paren_string.scan(/\\)/) { |x| paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\\
    s+/) { |x| paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\s{2,}/) { |x|\
    \ paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\(/) { |x| paren_string.gsub!(x,\
    \ ' ') }\n  paren_string.scan(/\\)/) { |x| paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\\
    s+/) { |x| paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\s{2,}/) { |x|\
    \ paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\(/) { |x| paren_string.gsub!(x,\
    \ ' ') }\n  paren_string.scan(/\\)/) { |x| paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\\
    s+/) { |x| paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\s{2,}/) { |x|\
    \ paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\(/) { |x| paren_string.gsub!(x,\
    \ ' ') }\n  paren_string.scan(/\\)/) { |x| paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\\
    s+/) { |x| paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\s{2,}/) { |x|\
    \ paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\(/) { |x| paren_string.gsub!(x,\
    \ ' ') }\n  paren_string.scan(/\\)/) { |x| paren_string.gsub!(x, ' ') }\n  paren_string.scan(/\\\
    s+/) { |x| paren_string.gsub!(x, ", "  levels = paren_string.scan(/\\(.*?\\)/g).reject(&:empty?)\n\
    \  return levels.map(&:size).max\nend", "\tmax_depth = 0\n\tdepth = 0\n\topen_parens\
    \ = 0\n\tresults = []\n\twhile paren_string.length > 0\n\t\tparent = paren_string[0,paren_string.length-1]\n\
    \t\tif parent == ' ' or parent == ')'\n\t\t\tif open_parens == 0\n\t\t\t\tmax_depth\
    \ += 1\n\t\t\topen_parens -= 1\n\t\telsif parent == ')'\n\t\t\topen_parens +=\
    \ 1\n\t\t\tif open_parens == 0\n\t\t\t\tmax_depth += 1\n\t\telsif parent == '\
    \ ' or parent == ')'\n\t\t\tresults.push(max_depth)\n\t\telse\n\t\t\tparen_string\
    \ = paren_string[1..paren_string.length-1]\n\tend\n\treturn results\nend", " \
    \ result = []\n  i = 0\n  while i < paren_string.length\n    char = paren_string[i]\n\
    \    case char\n    when '('\n      i += 1\n    when ')'\n      break\n    when\
    \ ' '\n      if i < paren_string.length && paren_string[i] != ')'\n        result.push(i)\n\
    \    end\n    i += 1\n  end\n  result\nend", "  return paren_string == paren_string.gsub(/\\\
    )\\s*\\(\\s*\\)\\s*\\)\\s*\\)/, '').gsub(/([^)(]+)\\(([^)(]+)\\)/, '\\2').split('(').map\
    \ { |s| s.scan(/([^(]+)\\(([^)(]+)\\)/).flatten.max.to_i }\nend", "  paren_string.strip!\n\
    \  paren_stack = []\n  paren_stack.push(0)\n  brackets_level = 0", "  paren_string.scan(/\\\
    s*([()]*?)\\s*/).inject([0]) { |sum,i|\n    sum[sum.length-1] += 1 if i==')' then\
    \ 1 else 0 end\n  }\n  paren_string.scan(/[()]*?[()]*?[()]*?/).inject([0]) { |sum,i|\n\
    \    sum[sum.length-1] += 1 if i==')' then 1 else 0 end\n  }\nend", "  stringified_parens\
    \ = paren_string.strip\n  parentheses = []\n  stack = []\n  while stringified_parens\
    \ != ''\n    parentheses << stringified_parens.count('(') - stringified_parens.count(')')\n\
    \    stringified_parens = stringified_parens.gsub('(','').gsub(')','')\n    if\
    \ stringified_parens != ''\n      stack.unshift(stringified_parens)\n    end\n\
    \  end\n  parentheses.reverse.each do |level|\n    next if level < 0\n    break\
    \ if level == 0\n    break if level == 1\n    level -= 2\n  end\n  stack.reverse\n\
    end", "  level = 0\n  output = []\n  paren_count = 0\n  last_item = ''\n  paren_level\
    \ = 1\n  for i in paren_string.split\n    el = i\n    if i == ')'\n      if last_item\
    \ == ')'\n        level -= 1\n        if level == 0 \n          output << paren_count\n\
    \          paren_count = 0\n        el = ''\n      else\n        level += 1\n\
    \        el = ''\n    el = '((' + el\n    paren_count += 1\n    if el.length >\
    \ 1\n      output << paren_count\n      paren_count = 0\n      level += 1\n  \
    \  el = '((' + el\n    paren_count += 1\n    if el.length > 1\n      output <<\
    \ paren_count\n      paren_count = 0\n      level += 1\n    el = '(' + el\n  \
    \  paren_count += 1\n    if el.length > 1\n      output << paren_count\n     \
    \ paren_count = 0\n      level += 1\n    el = ')'\n    level += 1\n    output\
    \ << level\n    last_item = el\n  return output\nend", "  paren_string.scan(/((\\\
    (.*?\\))|(\\(.*?\\))(\\(.*?\\))*)$/) {|m| return m.to_a.reverse}\n  nil\nend",
  "  return paren_string.scan(/(?<parens>\\()|(?<-parens>\\))/).map{|m| m.parens ?\
    \ m.parens.size : 0}.reduce(:+)\nend\n</cell>\n<code language=julia-0.3>", " \
    \ level = 0\n  num_open = 0\n  paren_level = 0\n  results = []\n  paren_string.split('\
    \ ').each do |el|\n    if el == '('\n      if level == 0\n        num_open +=\
    \ 1\n      else\n        level += 1\n      end\n    elsif el == ')'\n      level\
    \ -= 1\n      if level == 0\n        num_open -= 1\n      else\n        paren_level\
    \ += 1\n      end\n    else\n      results << paren_level if num_open == 0\n \
    \   end\n  end\n  results << paren_level if num_open == 0\n  results.uniq!\n \
    \ results.compact!\n  results\nend", "  paren_stack = []\n  paren_level = 0\n\
    \  parens = []\n  paren_start_pos = 0\n  paren_end_pos = 0\n  paren_end_pos =\
    \ paren_string.rindex(\")\", paren_start_pos)\n  while paren_end_pos >= 0\n  \
    \  paren_start_pos = paren_end_pos + 1\n    paren_end_pos = paren_string.rindex(\"\
    )\", paren_start_pos)\n    if paren_end_pos == -1\n      paren_end_pos = paren_string.rindex(\"\
    )\", paren_start_pos)\n      paren_end_pos = paren_string.rindex(\"(\", paren_start_pos)\n\
    \      paren_end_pos = paren_string.rindex(\"{\", paren_start_pos)\n      paren_end_pos\
    \ = paren_string.rindex(\"=>\", paren_start_pos)\n      paren_end_pos = paren_string.rindex(\"\
    =>\", paren_start_pos, true)\n      paren_end_pos = paren_string.rindex(\"=\"\
    , paren_start_pos)\n      if paren_end_pos == -1\n        raise RuntimeError,\
    \ \"Invalid parentheses\"\n      paren_end_pos += 1\n    paren_level = paren_end_pos\
    \ - paren_start_pos\n    paren_stack = paren_stack + [paren_level]\n    parens\
    \ = parens + [paren_start_pos]\n    paren_start_pos = paren_end_pos\n  end\n \
    \ paren_stack = paren_stack + [paren_level]\n  parens = parens + [paren_end_pos]\n\
    \  return paren_stack\nend", "  paren_count = 0\n  paren_groups = []", "  # The\
    \ idea of this function is to solve the following problem:\n  # Given a string\
    \ of parentheses nesting rules, find the maximum number of levels of nesting\n\
    \  # in the parenthetical expression represented by the string.\n  # For a concrete\
    \ example, consider the string \"(()())\", which represents the expression\n \
    \ # ((())()).  It has two levels of nesting, but its deepest level is two.\n \
    \ # In this problem, we represent these expressions as lists of strings, so that\n\
    \  # each expression can be processed separately in the recursive way.\n  #\n\
    \  # The algorithm works as follows:\n  # - Use a stack to keep track of the current\
    \ nesting level\n  # - If the top of the stack is empty, return 0\n  # - Else,\
    \ pop the stack until the stack top is equal to the expression top minus the top\n\
    \  #   of the stack\n  # - Add the number of left parentheses to the top of the\
    \ stack\n  # - Increment the maximum nesting level if the expression has multiple\
    \ levels of nesting\n  #\n  # We use a list rather than a hash for speed.  The\
    \ list can contain any object, so it is\n  # not required to test whether the\
    \ current string is a key in the hash table.  In fact,\n  # the hash table will\
    \ be faster than a Python dictionary for this use case.\n  #\n  # In a Python\
    \ shell, this function would be defined like this:\n  # >>> def max_nested_levels(paren_string):\n\
    \  # ...   max_nested_level = []\n  # ...   max_nested_level.append(0)\n  # ...\
    \   stack = [0]\n  # ...   for top in paren_string:\n  # ...     if stack[-1]\
    \ < top - stack[0]:\n  # ...       max_nested_level.append(stack[-1])\n  # ...\
    \     stack.append(top - stack[0])\n  # ...   return max_nested_level\n  #\n \
    \ # This version of the algorithm runs in O(N) time where N is the number of characters\
    \ in\n  # the parenthesized expression and is linear in the size of the expression.\n\
    \  paren_string = paren_string.strip().replace(\"(\", \" ( \")\n  paren_string\
    \ = paren_string.replace(\")\", \" ) \")\n  nested_paren_levels = []\n  paren_count\
    \ = 0\n  for paren in paren_string.split(\" \")\n    nested_paren_levels.append(paren_count)\n\
    \    paren_count += 1\n  nested_paren_levels.append(paren_count)\n  return nested_paren_levels\n\
    end", "  max_level = 0\n  nesting_level = 0\n  paren_stack = paren_string.split\
    \ \" \"\n  paren_stack.each do |paren|\n    if paren == \"(\"\n      nesting_level\
    \ += 1\n    elsif paren == \")\"\n      nesting_level -= 1\n      if nesting_level\
    \ == 0\n        max_level = nesting_level if nesting_level > max_level\n     \
    \ end\n    end\n  end\n  return max_level\nend", "  level = 0\n  open_curly =\
    \ 0\n  open_paren = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n\
    \  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran\
    \ = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n\
    \  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran\
    \ = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n\
    \  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran\
    \ = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n\
    \  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran\
    \ = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n\
    \  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran\
    \ = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n\
    \  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran\
    \ = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n\
    \  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran\
    \ = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n\
    \  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran\
    \ = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n\
    \  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran\
    \ = 0\n  open_paran = 0\n  open_paran = 0\n  open_paran = 0", "  # Remove spaces,\
    \ split string on spaces.\n  parentheses = paren_string.gsub(/\\s+/, ' ').split('\
    \ ')", "  parens = paren_string.split(' ')\n  result = 1\n  max_level = -1\n \
    \ for paren in parens\n    level = 0\n    index = parens.index(paren)\n    while\
    \ index > 0 and parens[index - 1] == '('\n      level += 1\n      index -= 1\n\
    \    index -= 1 while index > 0 and parens[index - 1] == '('\n    if level > max_level\n\
    \      result = level\n      max_level = level\n    end\n  end\n  result\nend",
  "  max_level = 0\n  open_parentheses = 0\n  open_parentheses_stack = []\n  open_parentheses_max_level\
    \ = nil\n  while paren_string.length > 0\n    if paren_string[0] != '('\n    \
    \  max_level = open_parentheses_max_level\n      open_parentheses_max_level =\
    \ open_parentheses_stack.length\n      open_parentheses_stack = []\n      open_parentheses\
    \ = open_parentheses_max_level\n    end\n    open_parentheses_stack.push(open_parentheses)\n\
    \    opening_parens = open_parentheses_stack.last\n    paren_level = 1\n    while\
    \ opening_parens != 0\n      paren_level += 1\n      opening_parens = paren_stack[opening_parens\
    \ - 1]\n    end\n    levels_up_to_open = open_parentheses - paren_level\n    if\
    \ opening_parens == 0\n      paren_stack.push paren_level\n      levels_up_to_open\
    \ = open_parentheses_stack.last\n    end\n    while levels_up_to_open == paren_level\n\
    \      open_parentheses_stack.pop\n      levels_up_to_open = open_parentheses_stack.last\n\
    \    end\n    open_parentheses -= 1\n  end\n  return open_parentheses_stack\n\
    end", "  level = 1\n  counts = [0]\n  opens = []\n  openstack = []\n  closed =\
    \ []\n  closestack = []\n  i = 0\n  while i < paren_string.length\n    if paren_string[i]\
    \ == '('\n      opens << paren_string.slice!(i, i+1)\n      openstack.push(paren_string[i])\n\
    \      i = i + 1\n      while i < paren_string.length && paren_string[i] == ')'\n\
    \        counts.push(counts[-2].succ if counts.length > 2 else 0)\n        closes.push(paren_string[i])\n\
    \        openstack.pop\n        i = i + 1\n      i += 1\n    elsif paren_string[i]\
    \ == '('\n      openstack.push(paren_string[i])\n      i = i + 1\n    elsif paren_string[i]\
    \ == ')'\n      counts.push(counts[-2].succ if counts.length > 2 else 0)\n   \
    \   closestack.push(paren_string[i])\n      openstack.pop\n    elsif paren_string[i]\
    \ == '('\n      opens << paren_string[i]\n    elsif paren_string[i] == ')'\n \
    \     closestack.push(paren_string[i])\n    elsif paren_string[i] == ' '\n   \
    \   i += 1\n    elsif paren_string[i] == '('\n      i += 1\n    elsif paren_string[i]\
    \ == ')'\n      openstack.pop\n      closestack.push(paren_string[i])\n      closed\
    \ = closed + openstack\n      openstack = []\n    end\n  end\n  return closed\n\
    end\n</code>\n<|/ a dscore=1 tags=python-3.x,string,regex,ruby |>\n<| a tags=python-3.x,string,regex,ruby\
    \ |>\nThis is a Python implementation using the stack that you already have:\n\
    <code>", "  paren_stack = [paren_string]\n  depth = 0\n  max_depth = 0\n  \n \
    \ while paren_stack.size > 0 and depth <= max_depth\n    # Pop off top item\n\
    \    item = paren_stack.pop\n    \n    if item == '('\n      depth += 1\n    elsif\
    \ item == ')'\n      depth -= 1\n    elsif item.size == 1\n      max_depth = depth\
    \ if depth > max_depth else max_depth\n    end\n    \n    # Add this item to the\
    \ stack\n    paren_stack.push item\n  end\n  \n  paren_stack\nend", "  paren_string\
    \ = paren_string.dup\n  level = 0\n  bracket = paren_string.chars.to_a\n  bracket.map!\
    \ { |char|\n    if char == ')'\n      level -= 1\n    elsif char == '('\n    \
    \  level += 1\n    elsif char == ' '\n      if paren_string.chars.to_a.size ==\
    \ level\n        level = 0\n      end\n    end", "  max_level = 0\n  groups =\
    \ []\n  input_string = paren_string", "  group_counts = Hash.new(0)\n  open_braces,\
    \ closed_braces = 0, 0\n  nested_parentheses = []\n  paren_string.each_char.reduce(0)\
    \ do |level, (char, ch)|\n    level = level + 1\n    next if char == ')'\n   \
    \ next if char == '('\n    level = level - 1\n    level if level > 0\n    group_counts[ch]\
    \ += level\n  end\n  paren_string.each_char.reduce(0) do |level, char|\n    level\
    \ = level - 1\n    level << 1 if level > 0\n    level if level > 0\n    level\
    \ << group_counts[char]\n    nested_parentheses << level\n  end\n  nested_parentheses.max\n\
    end", "  groups = paren_string.split(' ')\n  max_level = 0\n  max_levels = []",
  '  paren_string.gsub!(/\(\([^()]*\)\)/, "\\(\1)")', "  paren_levels, paren_count\
    \ = paren_level_count(paren_string)\n  return paren_levels[paren_count.to_i -\
    \ 1]\nend", "  return parse_nested_parens_recur(paren_string, 0).to_a\nend", " \
    \ level = 0\n  groups = [[]]\n  group_stack = [[]]\n  paren_count = 0\n  string_length\
    \ = len(paren_string)\n  i = 0\n  while i < string_length\n    char = paren_string[i]\n\
    \    if char == '('\n      level += 1\n      group_stack.push([])\n      group_stack[level].push([])\n\
    \      groups[level].push([])\n      paren_count += 1\n      i += 1\n    else\
    \ if char == ')'\n      level = group_stack.pop().pop() + 1\n      if level ==\
    \ -1\n        i += 1\n      else\n        groups[level - 1].pop().push(paren_count)\n\
    \      paren_count -= 1\n    else if char != ' '\n      groups[level - 1].pop().push(i)\n\
    \    i += 1\n  end\n  groups[level - 1].pop().push(paren_count)\n  groups[level].shift\n\
    \  groups.flatten!\n  return groups\nend", "  paren_level = paren_string.count('(')\
    \ - paren_string.count(')')\n  return 0 if paren_level > paren_level\n  else paren_level\n\
    end", "  # Recursively parse the string into parentheses.\n  parens = [-1]\n \
    \ parens_stack = [parens]\n  parens_open = 0\n  parens_close = 0\n  paren_level\
    \ = 0\n  paren_char = ''\n  paren_chars = []", "  paren_stack = paren_string.count('(')\
    \ - paren_string.count(')')\n  \n  result = []\n  \n  while paren_stack > 0\n\
    \    current_level = (paren_stack.to_f ** (1/2)) - 1\n    \n    if current_level\
    \ == 0\n      result << paren_string.count(')')\n      paren_stack = paren_string.count('(')\n\
    \    else\n      result << current_level\n      paren_stack -= 1\n    end\n  \
    \  \n  end\n  \n  result\nend", "  paren_string.split(' ').each do |paren_string|\n\
    \    if paren_string.count('(') <= paren_string.count(')')\n      parse_nested_parens(paren_string)\n\
    \    else\n      paren_string.count('(')\n    end\n  end\nend", "  paren_depths\
    \ = Hash.new(0)\n  paren_depths[paren_string.count('(')] += 1\n  paren_depths[paren_string.count(')')]\
    \ += 1\n  paren_depths[paren_string.count(')')] += 1\n  return paren_depths\n\
    end", "  paren_stack = Array.new\n  paren_stack.push(0)\n  paren_stack.push paren_string.length\n\
    \  paren_stack.push(0)\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push -1\n  paren_stack.push\
    \ -1\n  paren_stack.push -1\n  paren_stack.push ", "  level = 0\n  nested = 0\n\
    \  group_start = 0\n  index = 0\n  result = []\n  while index < paren_string.length\n\
    \    if paren_string[index] == '('\n      if level == 0\n        result << group_start\
    \ + 1\n      level += 1\n      nested += 1\n      if nested > result.last\n  \
    \      result << nested\n      else\n        result << nested.last\n      group_start\
    \ = index\n    elsif paren_string[index] == ')'\n      level -= 1\n      nested\
    \ -= 1\n      result << nested.last\n    elsif paren_string[index] == ' '\n  \
    \    index += 1\n    else\n      break\n    end\n    index += 1\n  end\n  result\n\
    end", "  group_count = 0\n  group_sizes = []\n  stack = []\n  result = []\n  depth\
    \ = 0\n  depths = []\n  for i in 0...paren_string.length\n    if paren_string[i]\
    \ == \"(\"\n      group_count += 1\n      depth += 1\n      stack << i\n    elsif\
    \ paren_string[i] == \")\"\n      group_count -= 1\n      if group_count == 0\n\
    \        if stack.length > 0\n          depth = stack.length\n          stack.empty\n\
    \        end\n      end\n      depths << depth\n      stack.pop\n    end\n   \
    \ result << depth\n  end\n  result\nend", "  paren_string.strip!\n  paren_count\
    \ = 0\n  result = []\n  while !paren_string.empty?\n    paren_count += 1\n   \
    \ if paren_count == 1\n      result += [paren_count]\n    else\n      result <<\
    \ (paren_count - result[result.length - 1])\n    result << paren_string.count('()')\n\
    \    paren_string.gsub!('(', ' ')\n    paren_string.gsub!(')', ' ')\n  end\n \
    \ result\nend", "  paren_string.scan(/^\\(|(\\([^\\(\\)]*\\))|(\\(.*\\))/) do\
    \ |open_paren, close_paren|\n    if open_paren.nil?\n      return parse_nested_parens(close_paren)\n\
    \    else\n      open_paren = open_paren.downcase\n      open_paren = open_paren.gsub(/\\\
    W+/, '')\n      if open_paren.empty?\n        return close_paren.scan(/[^\\(\\\
    )]+/).size\n      elsif close_paren.nil?\n        return parse_nested_parens(open_paren)\n\
    \      else\n        return close_paren.scan(/[^\\(\\)]+/).size + parse_nested_parens(open_paren)\n\
    \      end\n    end\n  end\nend", "  paren_string = paren_string.split(' ')\n\
    \  paren_string.each do |paren_string|\n    if paren_string =~ /\\(/\n      nested_level\
    \ += 1 unless nested_level == 0\n    elsif paren_string =~ /\\)/\n      nested_level\
    \ -= 1 unless nested_level == 0\n    end\n  end\n  nested_level\nend", "  nested_levels\
    \ = []\n  bracket_level = 0\n  open_brackets = 0\n  open_parentheses = 0\n  depth\
    \ = 0\n  paren_depths = []\n  paren_levels = []\n  bracket_paren_levels = []",
  "  brackets = []\n  depth = 0\n  for i in paren_string.split(' ')\n    if i =~ /^\\\
    ((.+)\\)$/\n      # print $1\n      depth = depth + 1\n      brackets << $1\n\
    \    else\n      if depth > 0\n\tdepth = depth - 1\n      end\n    end\n  end\n\
    \  brackets\nend", "  # Initialize a stack to keep track of how many open/closed\
    \ parens\n  # are currently open.\n  paren_stack = []\n  paren_count = 0", " \
    \ stack = []\n  results = []\n  parens_count = 0\n  open_brackets = 0\n  \n  paren_string.scan(/[()()]/)\
    \ do |parens| \n    if parens == '('\n      open_brackets += 1\n    elsif parens\
    \ == '('\n      stack.unshift(parens)\n    elsif parens == ')'\n      stack.pop\n\
    \      if stack.empty?\n        parens_count += 1\n      else\n        stack =\
    \ stack.last.split(open_brackets)\n        results.push(parens_count)\n      end\n\
    \    end\n  end\n  results\nend", "  paren_counts = paren_string.scan(/\\(.*?\\\
    )/).inject(Hash.new(0)){|h,x| h[x.first] += 1; h}\n  max_count = paren_counts.values.max\n\
    \  nested_levels = []\n  paren_counts.each do |paren, count|\n    if count > max_count\n\
    \      nested_levels.push(paren_counts[paren]-max_count)\n    end\n  end\n  return\
    \ nested_levels\nend", "  paren_string.scan(/[()]/)\n  levels = []\n  in_str =\
    \ []\n  \n  paren_string.scan(/^\\(/)\n  paren_string.scan(/\\)/)\n  paren_string.scan(/\\\
    )$/)\n  while !paren_string.eof?\n    \n    paren_string.scan(/\\(/)\n    paren_string.scan(/[^()]/)\n\
    \    \n    if paren_string.scan(/\\)/)\n      paren_string.scan(/\\)/)\n     \
    \ levels << paren_string.pos \n    end\n    \n    in_str << paren_string.pos\n\
    \    paren_string.scan(/\\(/)\n    \n  end\n  \n  return levels\nend\n</code>\n\
    Now let's apply the above functions to the string we read from standard input\
    \ and save it to a file out.txt:\n<code>\nrequire 'sys'\nrequire 'pp'", "  parens\
    \ = paren_string.split(' ')\n  result = []\n  max_level = 0\n  max_level_index\
    \ = 0\n  max_level_parens = 0\n  for i in 0...parens.length\n    parens_at_level_i\
    \ = parens[i]\n    # Skip all blank spaces\n    if parens_at_level_i == ' '\n\
    \      next\n    end\n    # Skip parentheses within parentheses within parentheses\n\
    \    if parens_at_level_i == '('\n      next\n    end\n    parens_level = parens_at_level_i.length\n\
    \    if parens_at_level_i.include?('(')\n      parens_level = parens_level - 1\n\
    \    end\n    if parens_at_level_i.include?(')')\n      parens_level = parens_level\
    \ + 1\n    end\n    next_level_parens = 0\n    while next_level_parens < parens_level\n\
    \      if parens[max_level_index].include?('(')\n        next_level_parens = next_level_parens\
    \ + 1\n      else\n        if parens[max_level_index].include?(')')\n        \
    \  next_level_parens = next_level_parens - 1\n        end\n      end\n      max_level_index\
    \ = max_level_index + 1\n    end\n    result.push(max_level_index)\n    max_level\
    \ = max_level + 1\n  end\n  return result\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=2 |>\nIn Ruby 1.9, you can use the Regexp class's .scan() method:\n\
    <code>\nnested_parentheses_count = Regexp.new( /\\(([^()]*)\\)/ ).scan( \"(()())\"\
    \ ).length\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI think `scan` will only give\
    \ one match instead of two. As well as `[^()]` can be simplified to `[^()]+`\n\
    <|/ c |>\n<| c |>\nYes, you're right. `.scan` will only give one match. I'm going\
    \ to update the answer to make it clear that .scan is only a way to get a count\
    \ of the number of nested parens.\n<|/ c |>\n<| a tags=ruby |>\nHere is a more\
    \ elegant version of Rufus' answer:\n<code>\nnested_parentheses_count = paren_string.gsub(/\\\
    ([^()]*\\)/,'').length\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice one!  I did\
    \ not realize you could use the sub's return value as a count.  Thanks!\n<|/ c\
    \ |>\n<| c |>\nYeah, you can do that.  I just thought I'd rewrite it to use `gsub`\
    \ rather than `sub` ", "  parens = paren_string.split(' ')\n  result = []\n  level\
    \ = 0\n  for i in parens\n    level += 1\n    if i.empty? || i == '('\n      result\
    \ << level\n    elsif i == '('\n      level += 1\n    elsif i == ')'\n      level\
    \ -= 1\n    end\n  end\n  result\nend", "  return paren_string.gsub(/\\((.+)\\\
    )/, '').gsub(/\\((.+)\\)/, '').gsub(/\\((.+)\\)/, '').scan(/[\\(\\)]+|[^\\(\\\
    )]+/).map { |e| e.length }.max\nend", "  return [paren_count.reduce{|max, x| max\
    \ > x ? max : x}(0) + (paren_string !~ /[^()()\\s\\)]/).count}\nend", "  paren_string_array\
    \ = paren_string.split(' ')\n  max_level = 0\n  paren_nesting = 0\n  paren_level\
    \ = 0\n  paren_array_index = 0\n  while paren_array_index < paren_string_array.length\n\
    \    if paren_string_array[paren_array_index] == '('\n      paren_nesting += 1\n\
    \      paren_level += 1\n      if paren_nesting > max_level\n        max_level\
    \ = paren_nesting\n      elsif paren_nesting == max_level\n        paren_level\
    \ += 1\n      end\n    elsif paren_string_array[paren_array_index] == ')'\n  \
    \    paren_nesting -= 1\n      if paren_nesting < 0\n        raise \"Parsing error\
    \ encountered in parse_nested_parens, unexpected closing parenthesis.\"\n    \
    \  end\n      if paren_nesting < max_level\n        max_level = paren_nesting\n\
    \      elsif paren_nesting == max_level\n        paren_level -= 1\n      end\n\
    \    elsif paren_string_array[paren_array_index]\n      # We don't know what this\
    \ character is but it's not a parenthesis so ignore it\n      paren_array_index\
    \ += 1\n    end\n  end\n  paren_nesting\nend", "  levels = paren_string.scan(/(\\\
    ()|(\\))/).size\n  max_levels = levels.to_i\n  parens = levels * '('\n  open_parens\
    \ = levels * '['\n  close_parens = levels * ']'\n  max_parens = open_parens +\
    \ close_parens\n  open_parens += parens\n  close_parens += parens\n  paren_stack\
    \ = []\n  paren_stack.push max_parens\n  parens = open_parens\n  paren_stack.push\
    \ parens\n  paren_stack.push open_parens\n  paren_stack.push open_parens\n  paren_stack.push\
    \ open_parens\n  paren_stack.push open_parens\n  paren_stack.push open_parens\n\
    \  paren_stack.push open_parens\n  paren_stack.push open_parens\n  paren_stack.push\
    \ open_parens\n  paren_stack.push open_parens\n  paren_stack.push open_parens\n\
    \  paren_stack.push open_parens\n  paren_stack.push open_parens\n  paren_stack.push\
    \ open_parens\n  paren_stack.push open_parens\n  paren_stack.push open_parens\n\
    \  paren_stack.push open_parens\n  paren_stack.push open_parens\n  paren_stack.push\
    \ open_parens\n  paren_stack.push open_parens\n  paren_stack.push open_parens\n\
    \  paren_stack.push open_parens\n  paren_stack.push open_parens\n  paren_stack.push\
    \ open_parens\n  paren_stack.push open_parens\n  paren_stack.push open_parens\n\
    \  paren_stack.push open_parens\n  paren_stack.push open_parens\n  paren_stack.push\
    \ open_parens\n  paren_stack.push open_parens\n  paren_stack.push open_parens\n\
    \  paren_stack.push open_parens\n  paren_stack.push open_parens\n  paren_stack.push\
    \ open_parens\n  paren_stack.push open_parens\n  paren_stack.push open_parens\n\
    \  paren_stack.push open_parens\n  paren_stack.push open_parens\n  paren_stack.push\
    \ open_parens\n  paren_stack.push open_parens\n  paren_stack.push open_parens\n\
    \  paren_stack.push open_parens\n  paren_stack.push open_parens\n  paren_stack.push\
    \ open_parens\n  paren_stack.push open_parens\n  paren_stack.push open_parens\n",
  "  paren_levels = []\n  paren_level = 0\n  bracket_counter = 0\n  paren_nesting\
    \ = 1\n  paren_level_stack = []", "  # Your code goes here.\n  return []\nend",
  "  # Initialize a stack to store paren depth\n  stack_nest = []", "  paren_count\
    \ = 0\n  paren_stack = []\n  level = 0\n  max_level = 0\n  paren_groups = []\n\
    \  paren_string.split(\" \").each do |string|\n    if paren_count == 0\n     \
    \ paren_groups.append(string.count(\"()\"))\n      paren_count += 1\n    else\n\
    \      if paren_stack.last == \"(\"\n        if string.count(\"()\") >= paren_groups[paren_stack.size\
    \ - 1]\n          paren_stack.pop\n          paren_groups[paren_stack.size - 1]\
    \ +=1\n        end\n      else\n        if string.count(\"()\") < paren_groups[paren_stack.size\
    \ - 1]\n          level +=1\n          paren_stack.push \"(\" if paren_stack.size\
    \ == 0\n          max_level = paren_stack.size if paren_stack.size > max_level\n\
    \        end\n      end\n    end\n  end\n  max_level\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nWow, that's a lot of code to wade through. I'm going to have to\
    \ look through it a few times to see what each part does, but thank you!\n<|/\
    \ c |>\n<| c |>\nThe code was written to be easily modified for different input\
    \ strings. Just run the example and test it out to see the results. Hope it helps\
    \ :)\n<|/ c |>\n<| c |>\nYeah, I'm getting somewhere with this. I'm looking into\
    \ my other attempts and trying to understand what each part does. Thanks!\n<|/\
    \ c |>\n<| c |>\nIf it's only possible to do so much in the actual program, then\
    \ I will just have to settle for another solution. Thanks!\n<|/ c |>\n<| a |>\n\
    I would use regex and count parentheses. Try this:\n<code>\ns = \"((())())(()))\"",
  "  paren_stack = []\n  count = 0\n  levels = 0\n  parentheses_levels = []\n  opening_count\
    \ = 0\n  for i in paren_string\n    if i == '('\n      parentheses_levels.push(count)\n\
    \      paren_stack.push(count)\n      count += 1\n    elsif i == ')'\n      parentheses_levels.push(count)\n\
    \      while paren_stack.count > paren_stack.pop\n        levels += 1\n      count\
    \ += 1\n    elsif i == ')('\n      opening_count += 1\n    elsif i == '('\n  \
    \    opening_count -= 1\n      while paren_stack.count > paren_stack.pop\n   \
    \     levels += 1\n    end\n  end\n  parentheses_levels\nend\n</code>\n<|/ a tags=algorithm,ruby\
    \ |>\n<| c |>\nThis doesn't work.  It returns `[5, 6]`\n<|/ c |>\n<| c |>\n, thanks\
    \ for your comment. I fixed my answer.\n<|/ c |>\n<| c |>\nI still think you meant\
    \ `parentheses_levels.push(count)`.  Otherwise it only works with single parentheses.\n\
    <|/ c |>\n<| c |>\n, this answer is really great. Thanks for sharing.\n<|/ c |>\n\
    <| a tags=algorithm,ruby |>\nHere is my implementation:\n<code>", "  level = 0\n\
    \  max_level = 0\n  output_list=[]\n  stack = []\n  paren_string = paren_string.strip\n\
    \  paren_sub_list = re.split(Paren_regex, paren_string)\n  for i in paren_sub_list\n\
    \    if i=='('\n      stack << paren_sub_list.index(i)\n    elsif i==')'\n   \
    \   top = stack.pop\n      while top != 0\n        output_list << top\n      \
    \  top = stack.pop\n      end\n      level += 1\n    elsif i=='('\n      output_list\
    \ << paren_sub_list.index(i)\n      level += 1\n    elsif i==')'\n      output_list\
    \ << paren_sub_list.index(i)\n      max_level = level\n      level += 1\n    elsif\
    \ i>'(' and i<')'\n      stack << paren_sub_list.index(i)\n    end\n  end\n  if\
    \ max_level==0\n    return output_list\n  end\n  for i in output_list\n    while\
    \ i!=0 and i<=max_level\n      output_list.pop\n      level -= 1\n    end\n  end\n\
    \  return output_list\nend", "  open_paren_count = open_paren_stack.length - 1\n\
    \  return open_paren_stack.inject(0) do |max_level_of_nesting, (level, paren_char)|\n\
    \    if paren_char == '(' && open_paren_count > 0\n      max_level_of_nesting\
    \ + 1\n    elsif paren_char == '(' && open_paren_count == 0\n      level + 1\n\
    \    elsif paren_char == ')'\n      level - 1\n    end\n  end\nend", "  stack\
    \ = [paren_string]\n  result = []\n  while stack.length > 0\n    str = stack.pop\n\
    \    result = result + str.scan(/\\s*\\((.*)\\)\\s*|([^()]*)/).flatten\n    stack\
    \ << (str.scan(/\\((.*)\\)/).flatten[0] || [])\n  end\n  result\nend\n</code>\n\
    <|/ a dscore=2 tags=ruby,string |>\n<| c |>\nIt's worth noting that this algorithm\
    \ is still a little slower than mine, since it runs the regex twice on every character.\
    \ Not a huge deal, but it would be nice to know if there is a better solution.\n\
    <|/ c |>\n<| c |>\nYeah, I think I may have to go with something like this. I'm\
    \ sort of surprised that this hasn't been implemented in any ruby libraries yet,\
    \ though. Thanks!\n<|/ c |>\n<| c |>\nAh, now that I've played around with it\
    \ a bit more, I realized that my \"fix\" would only work if parentheses weren't\
    \ nested themselves (for example, `()()()`). I'll keep looking into it, though.\n\
    <|/ c |>\n<| c |>\nYes, this would also fail on my original example, but I think\
    \ this can be fixed easily. It would involve using a different kind of stack than\
    \ the array that Ruby uses. Maybe you could create an object that held an index\
    \ of the parentheses level within it, and then increment the count when you encounter\
    \ an opening parenthesis, and decrement it when you encounter a closing parenthesis?\n\
    <|/ c |>\n<| c |>\nYeah, I thought about that, but it would require a lot of rewriting\
    \ in the code that is already done in Ruby. I'm going to post my solution as an\
    \ answer.\n<|/ c |>\n<| a dscore=2 |>\nHere's a variant that might help you:\n\
    <code>", "  level = 0\n  paren_level = 0\n  parens = []\n  paren_nesting = 0\n\
    \  paren_nestings = []\n  while level < paren_nesting\n    if paren_string =~\
    \ /\\(\\s*\\)\\s*\\)/\n      paren_nestings.pop\n      paren_nestings.push(paren_nesting)\n\
    \    end", "  paren_count = 0\n  parens = []\n  parsing_level = 0\n  in_parentheses\
    \ = false", "  paren_string.downcase!\n  open_paren_level = 0\n  close_paren_level\
    \ = 0\n  nesting_level = 0\n  paren_array = paren_string.scan(/[()]/)", "  result\
    \ = 0\n  paren_depth = 0\n  parens = []\n  paren_levels = [[]]", "\tparen_count\
    \ = 0\n\tparen_stack = []\n\tparen_levels = [[]]\n\tdepth = 0", "  result = -1\n\
    \  parens = paren_string.split(\" \")\n  para_counter = [0] * parens.length\n\
    \  max_counter = [0] * parens.length\n  while para_counter != 0\n    para_counter\
    \ =\n      (parens.map {|x| para_counter.max} +\n       parens.map {|x| para_counter.min}).map\
    \ {|x| x * -1}\n    if para_counter.max == 0 then\n      result = para_counter.min\n\
    \      break\n    end\n    max_counter =\n      (max_counter.zip(para_counter).map\
    \ {|x, y| y if x > x}).map {|x| x[-1]}\n    para_counter = max_counter.zip(para_counter).map\
    \ {|x, y| x + y}\n  end\n  if paren_string == parens[max_counter.max] then\n \
    \   max_counter.max\n  else\n    max_counter.min\n  end\nend", "  paren_string.scan(/(([^()]+)|(\\\
    ((?:[^()]+|(?1))*\\)))*/)\n  return paren_string.count('(') - paren_string.count(')')\n\
    end", "  paren_group = paren_string.gsub(/\\(|\\)/, '')\n  nested_parens = find_nested_parens(paren_group)\n\
    \  nested_parens_array = []\n  max_nesting = 0\n  nested_parens_array[0] = nested_parens\n\
    \  current_level = 1\n  while current_level > 0\n    current_level -= 1\n    nested_parens\
    \ = find_nested_parens(nested_parens_array[current_level])\n    nested_parens_array[current_level-1]\
    \ = nested_parens\n    current_level += 1\n  end\n  nested_parens_array\nend",
  "  paren_depths = paren_string.scan(/[^()]+/)\n  paren_depths.flatten!\n  max_paren_depth\
    \ = paren_depths.max\n  paren_depths - max_paren_depth\nend\n</code>\nTo make\
    \ this work, we need some extra helper functions for parentheses removal.\n<code>",
  "    string = ''\n    level = 0\n    paren_stack = []\n    count = 0\n    next_paren\
    \ = 1\n    paren_level = -1\n    nested_parentheses_stack = [1]\n    \n    parentheses_count\
    \ = 0\n    \n    #print(\"\\nParsing Nested Parenthesis String: \", paren_string,\
    \ \"\\n\")\n    for symbol in paren_string\n        if symbol == '('\n       \
    \     paren_stack.append(symbol)\n            parentheses_count += 1\n       \
    \     level += 1\n        elif symbol == ')'\n            paren_stack.pop()\n\
    \            parentheses_count -= 1\n            if parentheses_count == 0\n \
    \               if paren_stack == [0]\n                    nested_parentheses_stack.pop\n\
    \                    nested_parentheses_stack += [level]\n                level\
    \ = nested_parentheses_stack.pop\n            else\n                level += 1\n\
    \        elif symbol == '#'\n            if paren_stack == [0]\n             \
    \   nested_parentheses_stack.pop\n                nested_parentheses_stack +=\
    \ [level]\n            level = nested_parentheses_stack.pop\n        else\n  \
    \          string += symbol\n    \n    return string\n    \n</cell>\n<cell>",
  "  stack = Hash.new(0)\n  paren_string.scan(/^[()]/) { stack[$&] += 1; pop! if stack[$&]\
    \ == 1 }\n  stack.each { |k, v| stack[k] = 1 }\n  stack.values\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
