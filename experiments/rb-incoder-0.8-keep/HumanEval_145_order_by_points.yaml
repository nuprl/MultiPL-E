name: HumanEval_145_order_by_points
language: rb
prompt: "# Write a function which sorts the given list of integers\n# in ascending\
  \ order according to the sum of their digits.\n# Note: if there are several items\
  \ with similar sum of their digits,\n# order them based on their index in original\
  \ list.\n# For example:\n# >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11,\
  \ 1, -12, 11]\n# >>> order_by_points([]) == []\ndef order_by_points(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n\
  \    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11],\
  \ candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32,\
  \ 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6],\
  \ candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"
completions: ["  nums.sort_by(&:sum_digits)\nend\n</code>\n<|/ a dscore=4 |>\n<| a\
    \ |>\nThe simplest solution that comes to mind is to use the built-in sorting\
    \ methods in ruby.  It would look something like this:\n<code>", "    num = nums.dup\n\
    \    points = []\n    sum_of_digits = 0.zero\n    i = 0\n    while i < num.length\n\
    \        sum_of_digits += num[i].to_f\n        i += 1\n    while sum_of_digits\
    \ > 0\n        i += 1\n        while i < num.length and sum_of_digits == num[i].to_f\n\
    \            points << num[i]\n            sum_of_digits -= num[i].to_f\n    \
    \        i += 1\n    points.sort!\n    points.each {|x| nums.delete(x)}\n    return\
    \ points\nend\n</cell>\n<text>\nAnd here's how we could use it:", "    # Write\
    \ your code here\n    return nums\nend", "  nums = nums.sort\n  nums.reverse!\
    \ if nums.count > 1 else nums.reverse\n  nums\nend", "  if nums.empty?\n    return\
    \ []\n  \n  # Sort by sum of its digits\n  nums = nums.sort_by do |num|\n    digits\
    \ = num.to_s.chars.map(&:to_i)\n    (digits.reduce(:+) - digits).abs\n  end",
  "  nums = nums.sort\n  sums = nums.inject(0) { |sum, el| sum += el.to_i; sum }\n\
    \  sums, nums\nend", "\tnums.sort!\n\tnums.each_with_index do |n, i|\n\t\twhile\
    \ i > 0\n\t\t\tn = nums[i] + n\n\t\t\ti -= 1\n\t\tend\n\tend\n\treturn nums\n\
    end", "  n = nums.size\n  \n  digits = nums.map{|x| x.to_s.chars.map(&:to_i)}\n\
    \  \n  sums = digits.inject([0]){|m, d| m << d.reduce(:+)}\n  \n  nums.sort{|a,\
    \ b| sums.index(a.to_s.chars.map(&:to_i).reduce(:+)) <=> sums.index(b.to_s.chars.map(&:to_i).reduce(:+))}\n\
    end", "  nums.sort!\n  sum = 0\n  for i in nums\n    sum += i.to_i\n    break\
    \ if sum == 0\n    nums.delete(i)\n  end\n  return nums\nend", "  # Your code\
    \ here\n  return nums.sort_by { |num| num.divmod(10).map(&:last) }\nend\n</code>\n\
    Testing:\n<code>\nputs order_by_points([1, 11, -1, -11, -12])", "  return [] if\
    \ nums.empty? || nums.all? { |n| n.to_s.size() == 1 }\n  nums.group_by { |n| n.to_s.split('').reduce(0)\
    \ { |acc, x| acc + x.to_i } }.\n    sort_by { |_, v| v }.map { |_, v| v }.reverse\n\
    end", "  nums.sort\n  sums = nums.inject(0){|sum, el| sum + el.to_i}\n  nums.reverse.map!{|el|\
    \ sums - el.to_i}\n  nums\nend", "  nums.sort { |a,b| a <=> b }\nend\n</cell>\n\
    <cell>", "    # Write your sorting code here.\n    return nums\n</cell>\n<cell>",
  "  # +++your code here+++\n  result = nums\n  result.sort!{ |i, j| i.to_i + j.to_i\
    \ }\n  result\nend", "  nums.sort_by(&:sum)\nend\n</code>\n<|/ a |>\n<| a |>\n\
    <code>", '  nums.sort!', "  sorted = nums.sort {|a, b| a <=> b}\n  return sorted\
    \ if sorted.size == 0\n  sorted = sorted.reverse\n  sort.with_index { |s, i| sorted[i]\
    \ = sorted.rindex { |t| s == t } }\nend", "    return nums\nend\n</cell>\n<text>\n\
    Let's test our function on a few examples:", "  nums.sort_by!{ |x| x.to_s.chars.map\
    \ { |c| c.to_i }.inject(:+) }\nend", "  return [] if nums.empty?\n  digits = nums.map{|n|\
    \ n.to_s.length}\n  digits = digits.sort\n  digit_sums = digits.inject({}){ |sum,el|\
    \ sum[el] += 1 }\n  nums.reverse.sort_by do |n|\n    digit_sums[n]\n  end.flatten.reverse\n\
    end\n</code>\n<|/ a |>\n<| a dscore=1 |>\nHere's a solution using Ruby's sort\
    \ method which you can pass a block to and use Enumerable's sort_by method which\
    \ can take a block:\n<code>", '  nums.sort!', "  nums = nums.dup.sort{|a, b| a\
    \ <=> b} if nums.is_a?(Array)\n  nums.each_index{|i| nums[i] = nums[i].to_i}\n\
    \  return nums\nend", "    arr = [0,0,0]\n    arr.fill(0,4)\n    arr.map{|i| nums[i]}\n\
    \    arr.sort!{|a,b| a+b}\n    arr.map!{|i| nums[i]}\nend", "  nums.reverse.sort.each\
    \ do |num|\n    nums << num if num.digits.inject(:+) == num\n  end\n  return nums\n\
    end", "    sorted = [nums[0]]\n    sum = 0\n    for n in nums\n        sum +=\
    \ n\n        sorted.insert(0, sum)\n    return sorted\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\nThis is one way to do it.\n<code>", "  return [] if nums.empty?\
    \ else nums.sort.reverse\nend", "  return nums.sort_by { |x| x.digits.reduce(:+)\
    \ } if nums.any?\n  []\nend\n</code>\nThe final result will then be sorted in\
    \ ascending order.\n<|/ a tags=ruby,sorting,arrays |>\n<| a |>\nHow about this.\n\
    <code>", "  nums.reverse!\n  nums.sort { |a, b| sum_of_digits(a) == sum_of_digits(b)\
    \ }\n  nums\nend", "  # Add your code here\n  nums= nums.sort\n  sums = nums.map\
    \ { |n| n.to_s.split('').map(&:to_i).reduce(:+) }\n  nums.sort do |a, b|\n   \
    \ sums[a] > sums[b] ? 1 : sums[a] < sums[b] ? -1 : 0\n  end\nend\n</code>\n<|/\
    \ a tags=arrays,ruby dscore=0 |>\n<| c |>\nNote that `to_i` works only on numbers\
    \ in the range `0..2**32 - 1`.\n<|/ c |>\n<| c |>\nThank you for the tip! I'm\
    \ new to ruby, what do you mean by this range?\n<|/ c |>\n<| c |>\nThe method\
    \ `to_i` converts the string to a number in the range `0..2**32 - 1`. On my system,\
    \ the number is `4294967295` on 32 bit platforms, which is larger than a 32 bit\
    \ unsigned integer. On 64 bit platforms, the number is `18446744073709551615`\
    \ on 32 bit platforms and `2147483647` on 64 bit platforms.\n<|/ c |>\n<| a dscore=0\
    \ |>\nI think this may help you.\n<code>", "  nums.sort! do |a,b|\n    sum = a\
    \ + b\n    sum.zero? ? -1 : (sum.zero? ? 1 : sum).abs\n  end\nend", "  nums.sort!\
    \ do |a, b|\n    if a.sum > b.sum\n      1\n    elsif a.sum < b.sum\n      -1\n\
    \    else\n      0\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,ruby\
    \ |>\n<code>", "  nums.sort { |x, y| x.to_i + y.to_i }\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nWhile this link may answer the question, it is better to include\
    \ the essential parts of the answer here and provide the link for reference. \
    \ Link-only answers can become invalid if the linked page changes. - [From Review](/review/low-quality-posts/24306447)\n\
    <|/ c |>\n<| c |>\nI thought about doing something like that, but I wanted to\
    \ be sure that there's an easier way that involved less code than the method I\
    \ have written.  I agree that the answer should be self contained.  But I haven't\
    \ seen an easy way to make that code work yet.  So I just left it as part of the\
    \ answer.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\nSince Ruby 2.5.1 you can\
    \ use sort_by, which allows you to write something like:\n<code>\n[-123, -10,\
    \ -10, -10, -123, -123, -10, -10, -10, -10, -123, -10, -10, -10, -10, -123, -10,\
    \ -10, -123, -10, -10, -123, -123, -10, -10, -10, -10, -10, -123, -10, -10, -10,\
    \ -10, -123, -10, -10, -10, -123, -10, -10, -10, -123, -10, -10, -10, -10, -123,\
    \ -10, -10, -10, -10, -123, -10, -10, -123, -10, -10, -123, -10, -10, -10, -10,\
    \ -123, -10, -10, -10, -10, -123, -10, -10, -10, -123, -10, -10, -10, -10, -123,\
    \ -10, -10, -10, -10, -123, -10, -10, -10, -10, -123, -10, -10, -10, -10, -123,\
    \ -10, -10, -10, -10, -123, -10, -10, -123, -10, -10, -10, -10, -123, -10, -10,\
    \ -123, -10, -10, -10, -10, -123, -10, -10, -10, -10, -123, -10, -10, -10, -123,\
    \ -10, -10, -10, -10, -123, -10, -10, -10, -123, -10, -10, -10, -10, -123, -10,\
    \ -10, -10, -10, -123, -10, -10, -10, -10, -123, -10, -10, -10, -10, -123, -10,\
    \ -10, -10, -123, -10, -10, -10, -10, -12", "  nums.sort!\n  return nums\nend",
  "  sorted = nums.sort {|a,b|\n    (a <=> b).nonzero? || a <=> b\n  }\n  sorted.reverse\n\
    end", "  return nums.sort(&:to_i)\nend", "  nums.map! do |n|\n    n.to_s.split('').sort.reverse.map\
    \ { |c| c.to_i }.inject(:+)\n  end\n  nums.sort_by(&:itself)\nend", "  nums.sort!\
    \ do |a, b|\n    suma = sum_to_nums(a)\n    sumb = sum_to_nums(b)\n    suma ==\
    \ sumb ? a.index : b.index\n  end\nend", "  nums.sort! do |x,y|\n    if x == 0\n\
    \      y != 0\n    elsif y == 0\n      x != 0\n    elsif x > 0\n      x > y\n\
    \    elsif y > 0\n      y > x\n    else\n      x.to_i >= y.to_i\n    end\n  end\n\
    end", "    return [] if nums.empty? else nums.sort_by { |n| sum_digits(n) }.reverse\n\
    end", '  return nums unless nums.length == 0', "    sum_ = sum_of_digits(nums)\n\
    \    sorted_ = sorted(nums, key = lambda i: sum_of_digits(i))\n    if sum_ ==\
    \ -1:\n        return sorted_\n    else:\n        return sorted_[::-1]", "  sorted_list\
    \ = nums.sort.reverse\n  sorted_list.map { |n| nums.index(n.to_i) }\nend", " \
    \ nums.sort { |a,b| (a<b) ? -1 : (a <=> b) }\nend", "    sum = 0\n    num_dict\
    \ = {}\n    # write your code here\n    for i in nums:\n        if i in num_dict:\n\
    \            num_dict[i] += 1\n        else:\n            num_dict[i] = 1\n  \
    \  sorted_nums = sorted(num_dict.items(), key=lambda x:x[1], reverse = True)\n\
    \    return [num for num in sorted_nums]", "    # Your code here\n    hash = {}\n\
    \    count = 0\n    for n in nums:\n        digs = int(str(n)[len(str(n))-1])\n\
    \        if digs in hash.keys():\n            hash[digs] += count\n        else:\n\
    \            hash[digs] = count\n        count += 1\n    ans = []\n    for k,v\
    \ in hash.items():\n        ans.append(v)\n    return ans", "  nums = nums.sort\n\
    \  index = 0\n  res = []\n  while index < nums.size\n    num = nums[index]\n \
    \   digits = num.to_s.to_i\n    sum = digits.reduce(:+)\n    \n    unless res.include?(sum)\n\
    \      res << sum\n    end\n    \n    index += 1\n  end\n  \n  res\nend", "  nums.sort\n\
    \  i = 0\n  while i < nums.length - 1\n    if nums[i] > 0\n      i += 1\n    \
    \  nums[i], nums[i] = nums[i], nums[i-1]\n    end\n  end\n  nums\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nYou can use a hash table to determine a number as\
    \ unique as possible and store each digit in an array and compare them all at\
    \ once by summing up each digit:\n<code>", "  return nums.sort(&:abs) + [nums.find\
    \ {|n| n.abs == nums.sum}.next]\nend\n</code>\nThe idea is that you create a local\
    \ variable sum that holds the sum of the digits of each number. Then, you sort\
    \ the list of numbers by the sum of their digits, followed by the index of the\
    \ number where the first occurrence of the sorted list of numbers' sum is located\
    \ (the index of the first occurrence of the sorted list would itself be the index\
    \ of the smallest number in the list).\n<|/ a tags=arrays,ruby,sorting |>\n<|\
    \ c |>\nThis is O(n log n) solution, O(n^2) on average, and quite inefficient\
    \ for large n.\n<|/ c |>\n<| c |>\nThe second `if` is redundant. `sum` is always\
    \ zero when `nums` is empty and it will never be different from `nums.sum`.\n\
    <|/ c |>\n<| a dscore=1 |>\nI believe that there is already a good answer here\
    \ by 'khelll', but I just wanted to contribute a more rubyesque, ruby oriented\
    \ answer, which might be useful to someone:\n<code>", "  result = []\n  result.reverse\
    \ if nums.size > 0 else []\n  result.concat nums.map { |x| x.to_s.split('').map(&:to_i).reduce(:+)\
    \ }\n  result\nend", "  nums = nums.sort\n  sums = nums.map { |n| n.digits.sum\
    \ }\n  nums.zip( sums ).sort_by(&:first)\nend", "  return [] if nums.empty? ||\
    \ nums.any? { |n| n < 0 } || nums.any? { |n| n > 0 } || nums.any? { |n| n.zero?\
    \ } || nums.any? { |n| n == 0 }\n  nums.sort!\n  for i in 0..nums.length - 1\n\
    \    num = nums[i]\n    rest = nums[0...i+1]\n    break if num.zero?\n    if num\
    \ > rest.sum { |n| n.to_i }\n      nums.swap(0, i)\n      i += 1\n    end\n  end\n\
    \  nums\nend\n</code>\n<|/ a tags=ruby,sorting dscore=0 |>\n<| a dscore=0 |>\n\
    Here's a Ruby method that works on floats, ints, and strings while still being\
    \ concise and simple. It uses Integer#divmod and Integer#max, but it assumes there\
    \ are no fractions inside the list of numbers.\n<code>", "  sums = []\n  result\
    \ = []\n  (0..(@nums.size)).each do |i|\n    sum = 0\n    sums.each do |s| sum\
    \ += s * 10 end\n    sum += nums[i]\n    sums << sum\n  end\n  sums.sort.reverse.each\
    \ do |sum|\n    (0..(sums.size-1)).each do |i|\n      result << nums[i] + sum\n\
    \    end\n  end\n  result\nend", "  nums.sort! # Sort by increasing sum of numbers\n\
    \  sum_of_nums = nums.inject(0) {|sum, num| sum + num} # Sum each number\n  puts\
    \ \"After sorting: #{nums}\" # Print original list again\n  puts \"After sorting,\
    \ sum: #{sum_of_nums}\"\n  index = 0\n  sum_of_nums.sort.each { |sum_of_num| break\
    \ if sum_of_num != sum_of_nums[index] }\n  nums.each { |num| puts \"#{num} =>\
    \ #{sum_of_nums[index]}\" }\nend", "    nums, nums_copy = [], nums.clone\n   \
    \ nums_copy.sort{|a,b| a <=> b}\n    nums\nend\n</cell>\n<code language=julia-0.6>",
  "  nums.sort!\n  for i in 1...nums.size\n    nums[i], nums[i - 1] = (nums[i - 1],\
    \ nums[i]) if nums[i - 1] > nums[i] \n  end\n  nums\nend\n</cell>\n<cell>", " \
    \ if nums.length == 0\n    return []\n  sums = nums.map { |n| n.to_s.split('').map(&:to_i).reduce(:+)\
    \ }\n  idxs = []\n  sums.each_with_index do |sum, idx|\n    idxs << idx if sum\
    \ == sums[-1]\n  end\n  idxs.sort\nend\n</code>\n<|/ a |>\n<| c |>\nI think this\
    \ doesn't work when the list of numbers are negative. I just tried it out. It\
    \ prints `[12, 34, -1, -45]` instead of `[-1, -12, 34, 45]`.\n<|/ c |>\n<| c |>\n\
    : thanks for the comment, I added a comment to clarify that.\n<|/ c |>\n<| c |>\n\
    Ah sorry I just found it. Thanks so much!\n<|/ c |>\n<| a |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_index do |i|\n    j = i\n    while j > 0 && !nums[j].zero?\
    \ && nums[j].to_i <= nums[i].to_i\n      nums[j], nums[i] = nums[i], nums[j]\n\
    \      j -= 1\n    end\n  end\n  nums\nend\n</code>\nNow just call it like:\n\
    <code>\norder_by_points(nums)\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is not\
    \ the answer, but the question itself.\n<|/ c |>\n<| c |>\nSorry, this answer\
    \ is the accepted one. Just change the word 'sorted' to 'sorted'. Thanks for your\
    \ help!\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\nHere is an example using\
    \ Hash and sort_by.\n<code>", "  nums = nums.sort\n  sum = 0\n  result = nums[0]\n\
    \  for i in range(1, nums.length)\n    sum += nums[i]\n    if sum > 0\n      result\
    \ = nums[i - 1]\n      break\n    nums.delete(i - 1)\n  nums.insert(0, result)\n\
    end\n</cell>\n<cell>", "  # Write your code here.\n  nums, sorted = [], []\n \
    \ for i in nums:\n    if not i.is_integer:\n      nums.append(int(i))\n      continue\n\
    \    sum_str = str(i)\n    sum = int(sum_str)\n    index = sums.index(sum)\n \
    \   nums.append(nums[index])\n    sorted.append(i)\n    sums.remove(sum)\n  \n\
    \  sorted.extend(nums)\n  return sorted(sorted, key=lambda x:x.is_integer)", " \
    \ num_sum = 0\n  nums.each_index do |i|\n    num_sum += nums[i]\n  end", "  sum\
    \ = 0\n  nums.each do |n|\n    sum += n.to_i\n  end\n  sum\nend", "  # sort by\
    \ sum\n  nums.sort { |a, b| b + a }\n  nums\nend\n</cell>\n<cell>", "  nums.sort!\n\
    \  nums.each_with_index do |x, i|\n    if nums[i] > nums[i + 1]\n      nums.swap\
    \ i, i + 1\n    end\n  end\nend", "  return nums unless nums.any?\n  nums.sort!\
    \ do |a, b|\n    sum = (a >= 0) ? (a + b) : (b + a)\n    sum == 0 ? a : sum\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,sorting,algorithm dscore=1 |>\n<| c |>\n\
    Your code doesn't seem to be correct. Try testing with `[1, 1, 0]`. You're sorting\
    \ it in descending order, not ascending.\n<|/ c |>\n<| c |>\n`order_by_points([1,\
    \ 1, 0]) == [0, 0, 1, 1]` according to my test case.\n<|/ c |>\n<| c |>\nYou're\
    \ right, I was confused because it looked like the original question was sorting\
    \ in descending order, but that's not the case. I'm going to edit my answer shortly.\n\
    <|/ c |>\n<| a tags=ruby,sorting,algorithm |>\n<code>\narr = [1,5,3,2,4]", " \
    \   sums=[]\n    i=-1\n    for i in nums\n        sums.append(sum(nums[i:i+1]))\n\
    \    i=0\n    while i < len(nums)-1\n        if sums[i] < sums[i+1]\n        \
    \    nums[i], nums[i+1] = nums[i+1], nums[i]\n            sums[i+1], sums[i] =\
    \ sums[i], sums[i+1]\n        i += 1\n    nums, sums = nums, sums\n    sums.sort\n\
    \    return nums", "  sorted = nums.sort_by { |n| sum_of_digits(n) }\n  sorted.reverse.each\
    \ { |n| nums.insert(0, n) } if nums.empty?\n  sorted\nend", "  nums.sort!\n  idx\
    \ = 0\n  sum = 0\n  while idx < nums.length\n    sum = sum + nums[idx]\n    idx\
    \ += 1\n    if sum == nums.last\n      nums.delete(nums.last)\n      idx -= 1\n\
    \    end\n  end\nend", "    # Write your code here.\n    if nums.empty?\n    \
    \    nums\n    else\n        nums.sort! {|a, b| sort_by_sum(a, b)}\n        nums\n\
    \    end\nend", "    sorted = nums.sort { |a, b| b - a }\n    return sorted\n\
    end", "  nums.sort{|x,y| x + y }\nend", "    return nums.sort(key = lambda n :\
    \ sum(map(int, list(str(n)))) )\n</code>\n<|/ a tags=python,python-3.x |>\n<|\
    \ a dscore=0 |>\n<code>", "  nums.each_with_index.sort_by { |num, i| nums.count(num)\
    \ }\nend", "    # Your code here\n    nums_sorted = nums.sort\n    nums_sorted\
    \ = nums.sort_by {|n| n.to_s.chars.map {|d| d.to_i}.sum}\n    nums_sorted.reverse!\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nCan you elaborate on the first line?\
    \ I'm not sure what you mean by \"sort them according to their sum of digits\"\
    . Also, what do you mean by \"order them based on their index in original list\"\
    ?\n<|/ c |>\n<| c |>\nI mean sorting them according to their sum of digits. For\
    \ example, [1,4,2,11] is sorted as [11,4,2,1] because 3+2+1 which is 5. Then,\
    \ for two items whose sums are the same, order them according to their index in\
    \ the original list. For example, [1,11] should be ordered as [1,11] rather than\
    \ [11,1]\n<|/ c |>\n<| c |>\nYou can read [this page](http://ruby-doc.org/core-2.3.1/Enumerable.html#method-i-sort_by)\
    \ about `sort_by` method. Basically, it sorts the given collection in ascending\
    \ order based on a block of code. In your case, the block of code will sort a\
    \ collection according to its sum of its digits. For example, `[1,2,1]` is sorted\
    \ as `[1,2,1]` because 1+2+1=3. Then, for two items whose sums are the same, order\
    \ them according to their index in the original list. For example, [1,11] should\
    \ be ordered as [1,11] rather than [11,1]\n<|/ c |>\n<| c |>\nThanks for the clarification.\
    \ I understand what you're saying now. I've implemented your method and it works\
    \ well.\n<|/ c |>\n<| c |>\nI have added an answer to explain the first line of\
    \ code :)\n<|/ c |>\n<| a |>\nYou can use inject to sum up the digits in an array\
    \ and sort them by the sum:\n<code>", '  nums.sort!', "  # +++your code here+++\n\
    \  sorted = [nums[0]]\n  sum = 0\n  for num in nums\n    sum += num.to_i\n   \
    \ sorted.push(sum)\n    sum -= sorted.last\n  end\n  return sorted\nend", "  nums.sort!\
    \ do |a, b|\n    a = a.to_i\n    b = b.to_i\n    sum = (a + b).abs", "  nums.sort!\
    \ do |x, y|\n    z = x / 10 + (y / 10).floor\n    x - x * 10 + y * 10 - z\n  end\n\
    end", "  # initialize result\n  result = []\n  # sort nums\n  nums.sort! # use\
    \ ruby sort method\n  # calculate sum of each nums\n  sums = nums.map {|n| n.to_s.split(\"\
    \").reduce(0) {|a,b| a+=b.to_i} }\n  # sort sums based on sums\n  sums.sort.reverse_each\
    \ {|n| result.push(n) }\n  # return result\n  result\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nWhat if some number has more than 1 digits?\n<|/ c |>\n<| a dscore=1\
    \ |>\nA solution without regular expressions:\n<code>", "  nums.sort! do |x,y|\n\
    \    if x + y < 0\n      -1\n    elsif x - y > 0\n      1\n    else\n      x +\
    \ y\n    end\n  end\nend", "    sum = 0\n    result = []\n    for i in nums\n\
    \        sum += i\n        result.push(i)\n    return result\nend", "  return\
    \ [num for i,num in enumerate(nums) if num == sum(map(int, str(num)))]\nend",
  "  nums_sum = 0\n  nums_len = nums.count\n  nums_sum.times do |num|\n    nums_sum\
    \ += num\n  end\n  nums.sort!\n  nums.reverse_each.with_index do |num|\n    if\
    \ nums_sum == num\n      nums[nums.index(num)] = num\n    end\n  end\n  nums\n\
    end", "  nums.sort_by do |n| \n    # Sort by digits, if they share sum they are\
    \ in same group\n    (n.to_s.split('').sort.last.to_i).to_s \n  end \nend\n</code>\n\
    <|/ a dscore=0 tags=ruby-on-rails,ruby |>\n<| c |>\nThis was a really good answer,\
    \ especially the comments on the code. Thanks!\n<|/ c |>\n<| c |>\nI ran into\
    \ one more problem, if there are no duplicate values in `nums`, the code above\
    \ only returns the `sum` of the duplicates, which results in incorrect values.\
    \ I've added an updated version of the code in the question to reflect this.\n\
    <|/ c |>\n<| a tags=ruby-on-rails,ruby dscore=0 |>\n<code>", "  sorted_nums =\
    \ []\n  max_sum = nums.reduce(:+)\n  (0...nums.size).each do |i|\n    sum = 0\n\
    \    nums.each_with_index do |n, j|\n      sum += n if j < i\n    end\n    if\
    \ sum > max_sum\n      sum -= max_sum\n      max_sum = sum\n    end\n    sorted_nums.unshift(nums[i])\n\
    \  end\n  sorted_nums\nend\n</cell>\n<cell>", "  nums = nums[0..-1].sort_by {\
    \ |x| x.to_s.chars.sum.to_i }\n  nums.empty? ? [] : nums.map { |x| [x] }\nend",
  "  return nums.sort.reverse.map { |n| nums.index(n.to_s) }\nend", "  nums.sort!\n\
    \  if nums.empty?\n    nums\n  else\n    nums.group_by {|x| x.divmod(10).last}\n\
    \      .map {|k, v| [k, v.sort_by {|x| x.to_i}.map(&:first)]}\n      .reduce {|a,\
    \ b| a.zip(b).to_h}\n  end\nend", "  return sorted(nums, key = lambda num: sum(num)\
    \ / len(nums))\nend", "\tnums.sort!\n\tnums.each do |n|\n\t\tns = [n, 0]\n\t\t\
    n.to_s.split('').each_with_index { |w, i| ns[i] = ns[i] + w.to_i }\n\t\tns[0]\
    \ == 0 ? nums.unshift(n[1]) : nums.unshift(ns[0])\n\tend\n\treturn nums\nend",
  "    \n    sums = nums.inject(:+) # sum the num\n    ranked_nums = nums.map {|num|\
    \ [num, sums.index(sums.sort)] } # put them in order, sorted by sum\n    \n  \
    \  ranked_nums.inject([], :<<) # merge two arrays\nend\n</code>\nThe second method\
    \ is a little longer, but is more efficient:\n<code>", "    nums.sort! do |n|\n\
    \        digits = n.to_s.chars.map(&:to_i)\n        sum = digits.inject(0) { |m,\
    \ d| m + d}\n        sum > 0 ? sum : n\n    end\nend\n</cell>\n<text>\nAnd that's\
    \ all! Now we can write a function that will tell us how similar two integers\
    \ are, even if they have different digits:", "  # Write your code here.\nend",
  "  return sorted(nums, key=sum)\nend", "    sorted_index = 0\n    sorted = []\n\
    \    nums.each do |num|\n        sorted.push(num)\n        sorted_index += 1\n\
    \        while sorted_index <= nums.length and nums[sorted_index] == num\n   \
    \         sorted_index += 1\n        end\n        sorted.each do |num|\n     \
    \       nums.insert(sorted_index, num)\n        end\n    end\n    sorted\nend",
  "    # Write your code here.\n    sum = 0\n    sorted_nums = nums.clone\n    reversed_nums\
    \ = nums.clone.reverse\n    sorted_nums.sort{|a,b| a.to_s + b.to_s }\n    reversed_nums.reverse!\n\
    \    sorted_nums.each_index {|index| sorted_nums[index] = nums[index] + sum if\
    \ nums[index].to_s + sum == sorted_nums[index].to_s}\n    sum\nend\n</code>\n\
    <|/ a dscore=1 tags=sorting,ruby |>\n<| a |>\nI have written a method for sorting\
    \ integers according to their digits:\n<code>", "    total = 0\n    res = []\n\
    \    for i in nums:\n        total += i\n        res.append(total)\n    return\
    \ res\n    ", "    arr = []\n    for n in nums\n        sum += n\n        arr\
    \ << n if sum > 0 # add n if sum of n if greater than 0\n    arr.sort\n    return\
    \ arr\nend", "  nums.sort! do |n|\n    (n.to_s.split(//).map(&:to_i).inject(:+)\
    \ - n.to_i).abs\n  end\n  nums\nend\n</cell>\n<cell>", "  # Your code here\n \
    \ sorted_nums = nums.sort_by { |n| n.to_s.chars.map(&:to_i).sum.to_i }\n  sorted_nums.sort!\n\
    \  sorted_nums\nend", "  # Write your code here\n  result = []\n  for i in range(0,\
    \ nums.count('0'), 2)\n    result.push(nums.pop())\n    result.push(nums.pop())\n\
    \  return result.sort_by{|e| e.to_i}\nend\n</code>\nAs you have used this for\
    \ O(n) complexity. Now, you can change the code by making use of other methods\
    \ to reduce the complexity.\nOne such algorithm would be to use dynamic programming\
    \ in O(n) time complexity for calculating the maximum sum\n<code>", "  nums =\
    \ nums.sort\n  res = []\n  digits = nums.to_s.split(//)\n  digits.each_index do\
    \ |i|\n    sum = 0\n    digit = digits[i]\n    digit.each_index do |j|\n     \
    \ sum += digit.to_i\n    end\n    break if sum == 0 && !digit.any?{|d| d.zero?}\n\
    \    res << nums[i]\n  end\n  res\nend", "  nums.sort!\n  i = 0\n  while i < nums.length\
    \ - 1\n    if nums[i] > 0 && nums[i+1] > 0 && (nums[i] + nums[i+1]) == nums.last\n\
    \      i += 1\n    else\n      nums[i+1] = nums[i]\n      i += 1\n    end\n  end\n\
    \  nums\nend", "  # Write your code here.\n  ns = nums.sort\n  ns.sort_by{ |x|\
    \ x.to_s.split(//).map(&:to_i).inject(:+) }\nend", "  # TODO: Implement this\n\
    end", "  return nums.sort_by { |x| x.to_s.chars.map(&:to_i).reduce(:+) }\nend",
  "  return sorted(nums, key= lambda num: sum(num))\nend", "  nums.sort do |a,b|\n\
    \    total = 0\n    a.each_byte { |i| total += i }\n    b.each_byte { |i| total\
    \ += i }\n    total\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThat's not what OP\
    \ was asking.\n<|/ c |>\n<| c |>\nOP asking about how to sort a list of numbers,\
    \ not about sorting by sum of digits.\n<|/ c |>\n<| c |>\nIt doesn't matter what\
    \ the OP was asking about. He wanted to know how to sort a list of integers by\
    \ the sum of their digits. So the question was correct. Your solution is even\
    \ more correct than what OP was asking for, because it sorts by the index of the\
    \ original list, whereas OP was asking how to sort the list by the sum of the\
    \ digits. That doesn't make much sense, but it's what the question asked for.\n\
    <|/ c |>\n<| c |>\nYes, you are right. My answer is not suitable for OP's question.\n\
    <|/ c |>\n<| a tags=sorting,ruby dscore=0 |>\nI wanted to sort a list by sum of\
    \ the digits of every number.\nI wanted to do this with minimum comparisons, no\
    \ loops and no temporary variables. \nMy solution:\n<code>", "  # Your code here\n\
    end", '    sortedArray = nums.sort', "  nums.sort_by!{|x| x.to_i}\nend", "  #\
    \ Write your code here\n  return nums", "  # write your codes here\nend", "  nums.sort{|a,\
    \ b| (a.to_s.size + b.to_s.size).to_f <=> a.to_s.size + b.to_s.size}\nend", " \
    \ nums = nums.sort\n  return nums\nend", "    # Your code here\n    return sorted(nums,\
    \ key=lambda x: sum(map(int, list(str(x)))))\n</code>\nAs a side note, consider\
    \ using the built in sum and sorted methods of Python.\n<|/ a dscore=0 |>\n<|\
    \ c |>\nHey this was a wonderful explanation on how key= works ! Thank you so\
    \ much! Your code made me understand it much better !\n<|/ c |>\n<| c |>\nThis\
    \ was my first Stack Overflow post ever. I really appreciate it ! You helped me\
    \ understand key= a lot better ! :)\n<|/ c |>\n<| c |>\nGlad it helped! If it\
    \ answered your question, please upvote and accept :)\n<|/ c |>\n<| a |>\nUse\
    \ sorted function and use the key parameter of sorted function.\n<code>", "  \
    \  sorted = []\n    unique = []\n    i = 0\n    while i < nums.length\n      \
    \  sum = 0\n        j = i + 1\n        while j < nums.length\n            sum\
    \ = sum + nums[j].to_i\n            j += 1\n        if unique.include?(sum)\n\
    \            i += 1\n        else\n            sorted << nums[i]\n           \
    \ unique << sum\n            i += 1\n        end\n    end\n    sorted.concat(unique.reverse)\n\
    end", "  return [] if nums.empty? || nums.length < 2 \n  sums = []\n  for i in\
    \ 0 ... nums.length - 1\n    sum = 0\n    for j in 0 ... nums.length - 1\n   \
    \   sum += nums[j].abs\n    end\n    sums[i] = sum\n  end\n  sums.sort_by!(&:last)\n\
    \  sums\nend", "  return [] unless nums\n  nums.sort_by do |x|\n    digits = x.digits.reduce(0)\
    \ { |sum, digit| sum + digit }\n    [-digits, x.to_s]\n  end\nend\n</code>\nI\
    \ didn't include the code for the helper methods - but you'll have some that operate\
    \ on arrays, strings, numbers, whatever - and you can make them return the array\
    \ you want (as a new or modified array) instead.\n<|/ a tags=ruby |>\n<| c |>\n\
    Thanks! But I dont want to use any extra methods like .sort, .sort_by, .sort_by!\
    \ methods. And I dont want to use any gems either. I want to use the basic methods\
    \ and ruby core libraries only.\n<|/ c |>\n<| c |>\nYes, this answers your question\
    \ precisely. However, if you're dealing with large numbers, `Integer` is limited\
    \ to `2**64 - 2**31` because of the size of the number. Also, Ruby doesn't have\
    \ integer arithmetic. So, even though this answer works at some level, it's not\
    \ a very good one because it relies on implementation details of some lower level\
    \ languages.\n<|/ c |>\n<| c |>\nYeah! That makes a lot of sense. So, what would\
    \ be your suggestion in that case? I should make my own class with my own methods?\n\
    <|/ c |>\n<| c |>\n, how are you going to use this class? Does it matter? Are\
    \ you going to use it in an environment where you don't have the ability to load\
    \ a gem that defines the class, or are you going to use it in a rails app? How\
    \ are you going to use it? Without knowing that, it's impossible to give a good\
    \ answer to your question.\n<|/ c |>\n<| c |>\nWell, I am going to use this in\
    \ a rails app. So the thing is that I cant load the gem. Also the numbers wont\
    \ be very large. It will be around 500 to 600 digits long.\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby |>\nI wrote a solution that works with integers up to 2**64 - 2**31.\
    \ It's not pretty or elegant, but it works. You might want to use it in other\
    \ areas as well.\n<code>", "    sum = nums.inject{ |sum,x| sum + x }\n    nums.sort{\
    \ |a,b| (sum - a) <=> (sum - b) }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nNice answer but I'm sure it would be a little faster by implementing\
    \ the sorting algorithm as you did. You can always wrap that in a method though.\n\
    <|/ c |>\n<| c |>\n- I used inject to avoid having to assign the sum variable\
    \ but you are right it isn't necessary. I did it this way just to make it clear\
    \ for OP.\n<|/ c |>\n<| c |>\nYeah, but I didn't want to give the OP the answer\
    \ directly so he could use it as template if he wants, like you did. I just wanted\
    \ to point out that it's better to use `inject` than to use an assignment (in\
    \ this case).\n<|/ c |>\n<| c |>\nThanks for the solution. This does seem to be\
    \ the most elegant and simplest solution.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ dscore=0 |>\nYou could try something like\n<code>\nrequire 'set'", "  nums.sort.sort!\n\
    \  while nums.any?\n    i =  nums.index\n    i = nums.index(i) + 1\n    temp =\
    \ nums[i]\n    nums[i] = nums[j]\n    nums[j] = temp\n    i = nums.index(i) +\
    \ 1\n    j = nums.index(i) + 1\n    temp = nums[i]\n    nums[i] = nums[j]\n  \
    \  nums[j] = temp\n  end\n  nums\nend", "  nums.sort { |a, b| a <=> b }\nend",
  "  return [] if nums.empty?\n  nums.sort.reverse.each_with_index do |num, idx|\n\
    \    point = nums.sum.to_i\n    break if nums[idx] != point\n    nums[idx] = point\n\
    \  end\n  nums\nend\n</cell>\n<cell>", "  sums, i = {}, 0\n  nums.each do |x|\n\
    \    sums[x] = 0 while sums[x] < x\n    sums[x] += i while sums[x] >= x\n    i\
    \ += 1\n  end\n  sums.sort!\n  sums.map { |k, v| nums[k] = v }\nend", "  return\
    \ nums.sort(&:to_i).sort_by(&:<=>)\nend\n</code>\nThen, in your main method you\
    \ just need to call sort_by_points before returning the result.\n<code>", "  #\
    \ Write your code here\n  sum = 0\n  for i in range(len(nums)):\n    sum += nums[i]\n\
    \    \n  sort = []\n  for i in range(len(nums)):\n    sort.append(nums[i])\n \
    \   \n    \n    \n    \n  return sort\n</cell>\n<cell>", "  return nums if nums.empty?\
    \ else nums.sort_by(&:digits).reverse\nend", "  nums = nums.sort.reverse\n  nums\
    \ = nums.partition { |v| v.to_s.size < 10 }\n  nums.map! { |v| v.to_i }\n  nums\n\
    end", "  nums.each_with_index do |n, i|\n    sum_of_digits = n.to_s.chars.map\
    \ { |c| c == '-' ? -1 : 1}.sum\n    indices_to_sort = nums.index(sum_of_digits)\n\
    \    if indices_to_sort == nil\n      nums.push(sum_of_digits)\n      nums.push(nums[i])\n\
    \    end\n  end\nend", "    # initialize answer\n    answers = []\n    # define\
    \ helper functions\n    sum_of_digits = lambda n: sum(int(c) for c in str(n))\n\
    \    length_of_digits = lambda n: len(str(n))\n    # iterate over each item in\
    \ the list\n    for item in nums:\n        # if the current item has a digit sum\
    \ to the same as the answer\n        # ...\n        if sum_of_digits(item) ==\
    \ sum_of_digits(answer):\n            # ... append this item to the answer\n \
    \           answers.append(item)\n            # ... but only if it's not the only\
    \ one\n        elif length_of_digits(item) > 1:\n            # otherwise if the\
    \ current item has a digit sum to a different\n            # number from the answer\
    \ ...\n            if sum_of_digits(item) != sum_of_digits(answers[-1]):\n   \
    \             # ... append the previous item to the answer\n                answers.append(item)\n\
    \            # ... but only if it's not the only one\n        else:\n        \
    \    # otherwise if the current item has a digit sum to the\n            # same\
    \ as the answer but is a zero ...\n            if sum_of_digits(item) == 0 and\
    \ length_of_digits(item) == 1:\n                # ... append this item to the\
    \ answer\n                answers.append(item)\n            # ... but only if\
    \ it's not the only one\n    return answers", "  nums.map! {|x| x.abs} if nums.is_a?(Integer)\n\
    \  nums.sort! {|x,y| x.to_f <=> y.to_f}\nend", "  nums.sort.with_index do |x,\
    \ i|\n    z = x.to_s\n    if i != 0\n      n = z.count('0')\n      y = x.to_i\n\
    \      z = y\n    end\n    z = z.to_i\n    z = z * (9 / n)\n  end\nend\n</code>\n\
    <|/ a |>\n<| c |>\nYes, this works very well. I've just used it for my case and\
    \ it is really a great result!\n<|/ c |>\n<| a dscore=3 |>\n<code>", "    # write\
    \ your code here\n    counts = nums.inject(Hash.new(0)) { |sum, n| sum[n % 10]\
    \ += n }\n    nums.sort.map { |n| counts[n % 10] * (-1) ** n % 10 }\nend", " \
    \ nums.sort.reverse\nend\n</pre>\n</div>", "  nums.sort {|x, y| x.to_s <=> y.to_s}\n\
    end", "  sorted = []\n  sums = []\n  sorted_index = nil\n  sums_index = nil\n\
    \  sums.length = 0\n  nums.length.times do |i|\n    sums[i] = nums[i].digits.inject(:+)\n\
    \    sums_index = sums.index(sums[i])\n    sorted_index = sums_index if sums_index\
    \ != nil\n    sums.delete_at(sums_index)\n    sorted = nums if (sorted_index ==\
    \ nil)\n    sums.insert(sums_index, sums[i])\n    sorted.insert(sorted_index,\
    \ nums[i])\n  end\n  return sorted\nend", "  nums.sort!\n  (0...nums.size).reverse_each\
    \ do |i|\n    nums[i] = [nums[i], i].max\n  end\n  nums\nend", "    return nums[0..-2].sort\
    \ do |a, b|\n      sum = ((b - a) * 10).abs - ((b - a) * 100).abs\n      sum.zero?\
    \ ? a : b\n    end\nend\n</code>\nThe second version sorts in descending order,\
    \ because each comparison is reversed, so it becomes:\n<code>", '  return [] if
    nums.empty? || nums.any? {|num| num.is_a?(Numeric)}', "  if nums.empty?\n    nums\n\
    \  else\n    nums.each_with_index.map do |n, i|\n      n = (n.to_s.length * '0').to_i\
    \ + n\n      [n, i]\n    end.sort_by{|a, _| a}.reverse.map {|_, i| nums[i] }\n\
    \  end\nend\n</code>\nIn addition, we can write the test in more terse way as:\n\
    <code>\ntest \"test #1\n  should sort the given list of integers in ascending\
    \ order according to their sum of their digits\" do\n    sorted_nums = order_by_points([-121,\
    \ -123, -11, -5, -15, -4, -2, 101])\n    sorted_nums.should == [10, -4, -5, -15,\
    \ -2, -111, -121, -123]\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,ruby-on-rails\
    \ |>\n<| c |>\nI guess you forgot to add `return` on line `return nil if nums.empty?`\n\
    <|/ c |>\n<| c |>\n: I missed it intentionally. Thanks for pointing it out. I\
    \ have corrected my answer.\n<|/ c |>\n<| c |>\nA `sort { |a, b| ... }` would\
    \ look nicer than that `sort_by` call; that would also avoid the unnecessary assignments.\
    \ And a `sort_by { |a| ... }` would let the reader read the code more clearly,\
    \ if they saw that those are just two separate `map` calls.\n<|/ c |>\n<| c |>\n\
    : Thanks for suggestions. I have updated my answer accordingly.\n<|/ c |>\n<|\
    \ c |>\nThis solution only works for the OP's case. For a generic `sort`, where\
    \ you can return different keys for equal elements, your solution would require\
    \ an explicit comparison that compares the sums of two elements. That would be\
    \ tedious and error-prone. Plus, in Ruby 2.1, the [default arguments](https://www.ruby-lang.org/en/news/2017/06/25/ruby-2-1-0-released/)\
    \ of `sort` were introduced. In Ruby 2.1, you should write `sort_by { |a,b| a.to_s\
    \ + b.to_s }`. In Ruby 2.2, `sort_by { |a,b| a.to_s + b.to_s }` would be fine.\n\
    <|/ c |>\n<| a dscore=3 |>\nI like's answer but you can do it with a single sort_by:\n\
    <code>\nnums.sort_by { |n", "  nums.sort!{|a,b| a+b}\n  nums\nend\n</cell>\n<text>\n\
    Question 5.1.4 Write a function which sorts the given list of integers in ascending\
    \ order according to the sum of the numbers' digits.\nFor example if the given\
    \ list contains [-3, -1, 1, 3, 9], then [-3, -1, 1, 3, 9]\nshould be returned\
    \ as a result.\nHint: this problem can be solved by using built-in function 'sort'\
    \ of Ruby.\nHint: you might want to use the '<=>' operator to compare two integers.\
    \ You can find more details about this operator here: http://www.ruby-doc.org/core-2.1.0/Comparable.html",
  "  nums.compact.sort.tap do |nums|\n    nums.uniq!\n    nums.sort_by! do |x|\n \
    \     x.divmod(10).to_a\n    end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ c |>\nThank you for your answer, but I don't understand how it's sorting the\
    \ input. Could you please explain how you did that?\n<|/ c |>\n<| c |>\n`nums`\
    \ is an array. `nums.compact.sort` is sorting the elements of that array (by ascending\
    \ order of their digits) and then `nums.uniq!` removes duplicate elements and\
    \ then `nums.sort_by!` sorts the elements again by ascending order of their digits.\n\
    <|/ c |>\n<| c |>\n`nums` is an array. `nums.compact.sort` is sorting the elements\
    \ of that array (by ascending order of their digits) and then `nums.uniq!` removes\
    \ duplicate elements and then `nums.sort_by!` sorts the elements again by ascending\
    \ order of their digits.\n<|/ c |>\n<| c |>\nGreat! Thank you. One question -\
    \ why does it return `[-1, -11, 1, -12, 11]` instead of the usual `[-1, -11]`?\n\
    <|/ c |>\n<| c |>\nIt is not removing any elements. It is simply removing elements\
    \ which have duplicate digits.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\nI came up\
    \ with a solution based on what said:\n<code>", "  nums.sort!\n  i = 0\n  while\
    \ i < nums.length\n    if nums[i] != 0\n      i += 1\n    else\n      nums[i],\
    \ nums[i - 1] = nums[i - 1], nums[i]\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ dscore=0 |>\n<| a dscore=0 |>\nAs I understand, the question states that given\
    \ an array of integers nums, you must arrange them in ascending order by their\
    \ sum.  Here's a method that does that:\n<code>", '  nums.sort!', "  # Your code\
    \ here\n  nums.sort{|a,b| a.to_s + b.to_s}\nend", "  return nums.sort do |a, b|\n\
    \    sumA = a.to_s.split(\"\").sum.to_i\n    sumB = b.to_s.split(\"\").sum.to_i\n\
    \    sumA <=> sumB\n  end if nums.any?\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nThank you, I was able to find a ruby solution that didn't involve any sort\
    \ of hashing (using sort_by or sort) but I appreciate the insight and code you\
    \ have provided.\n<|/ c |>\n<| c |>\nI like that solution.  I wish I had thought\
    \ of it.  It's much more elegant.  +1.\n<|/ c |>\n<| c |>\nThe solution above\
    \ is much better than using hashing\n<|/ c |>\n<| a |>\nThe most efficient way\
    \ I could think of:\n<code>\nnums = [-12, -12, -12, -11]\nnums.sort_by { |x| x.to_s.split(\"\
    \").sum.to_i }\n=> [-11,  -12, -12]\n</code>\n<|/ a tags=ruby dscore=4 |>\n<|\
    \ a tags=ruby |>\nHere's one way to go about it:\n<code>\nnums = [1, 11, -1, -11,\
    \ -12]\n</code>\nStep 1: Calculate the sums of the digits in the array.\n<code>\n\
    sum_of_digits = nums.map {|n| n.to_s.split('').map(&:to_i).inject(:+)}\n=> [1,\
    \ 1, 3, -1, 1, 4]\n</code>\nStep 2: Sort the array based on this sum.\n<code>\n\
    sorted_nums = nums.sort_by {|n| sum_of_digits.index(n.to_s.split('').map(&:to_i))}\n\
    => [-12, -11, -12, -12, -11, 1]\n</code>\nStep 3: Remove the elements from the\
    \ array that have already been ordered.\n<code>\nsorted_nums.reject! {|n| nums.include?\
    \ n}\n=> [-11, -12, -11]\n</code>\nThe key steps are the following:", "  nums.sort!\
    \ { |a,b| a+b }\nend", "  nums.sort.map do |num|\n    return num if num > 0\n\
    \    nums.map {|n| n.to_s.length }\n    puts \"#{@num}\"\n  end\nend", "  sorted_nums\
    \ = []\n  sorted_nums = []\n  sorted_nums = nums.sort do |a, b|\n    digit_sum\
    \ = a.reduce(:+) + b.reduce(:+)\n    if digit_sum < 0\n      -1\n    elsif digit_sum\
    \ > 0\n      1\n    elsif a.length > b.length\n      1\n    elsif a.length < b.length\n\
    \      -1\n    else\n      0\n    end\n  end\nend\n</code>\n<|/ a |>\n<| c |>\n\
    thank you for the help, but unfortunately, i can't use any loops whatsoever in\
    \ my code\n<|/ c |>\n<| c |>\nThis answer shows how you can do it with recursion\
    \ and without loops.\n<|/ c |>\n<| c |>\nSorry, I meant \"you can *not* use any\
    \ loops whatsoever\"\n<|/ c |>\n<| c |>\nThis solution is too complicated and\
    \ is not scalable. Just use sort_by as suggested in the accepted answer by G.\
    \ Stan below.\n<|/ c |>\n<| c |>\nNoted. My solution was not very scalable. Will\
    \ not make any more sense once the question gets revised.\n<|/ c |>\n<| a tags=sorting,ruby\
    \ |>\nIf you cannot use any loops, you can use recursion:\n<code>", "  nums.sort!\n\
    \  \n  return nums if nums.empty? || nums.any? { |n| n == nums.reduce(:+) }\n\
    \  \n  nums.each do |i|\n    idx = nums.index { |n| n.to_s.split(\"\").map(&:to_i).reduce(:+)\
    \ == i.to_s.split(\"\").map(&:to_i).reduce(:+) }\n    nums[idx], nums[i] = nums[i],\
    \ nums[idx] if idx != nil\n  end\n  \n  return nums\nend", "  nums.sort! do |a,\
    \ b|\n    sum_a = a\n    sum_b = b\n    i = a\n    j = b\n    while i >= 0 ||\
    \ j >= 0\n      i = (i + 1) % nums.length\n      j = (j + 1) % nums.length\n \
    \     if sum_a > nums[i]\n        sum_a -= nums[i]\n      else\n        sum_b\
    \ -= nums[j]\n      end\n    end\n    sum_a\n  end\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis is incorrect. Try it with [4, 5] and [5, 4].\n<|/ c |>\n<| c |>\n\
    I agree with you that it's incorrect, I also agree that it's also very inefficient.\
    \ There should a way to do this in O(n) time but I've not seen it yet.\n<|/ c\
    \ |>\n<| c |>\n: No, there should be a way to do this in O(n) time, but I'm not\
    \ aware of it.\n<|/ c |>\n<| c |>\n: This solution is correct but O(n^2). For\
    \ large data this will be a bad solution. See my answer.\n<|/ c |>\n<| a dscore=5\
    \ tags=sorting,ruby,algorithm,ruby-on-rails |>\n<code>", '  nums.sort!', "  return\
    \ nums.sort { |a,b| b <=> a }\nend", "  \n  # TODO: Write code here.\n  \nend",
  "  sorted = nums.dup\n  sorted.sort!{|x, y| x.to_s + y.to_s }\n  return sorted\n\
    end", "  sorted_list = nums.sort do |a, b|\n    sum_digits(a) - sum_digits(b)\
    \ || a.to_i - b.to_i ||\n  end\n  return sorted_list\nend", "  nums = nums.dup\n\
    \  nums.sort!\n  nums.reverse!\n  nums\nend", "  if nums.empty?\n    return []\n\
    \  points = []\n  n = []\n  n.push 1, nums[0]\n  points.push n[0]\n  nums.delete\
    \ n[0]\n  i = 0\n  while nums.any?\n    if nums[i] > n[0].second + n[0].first\
    \ && nums[i] > points[points.length-1].second\n      n.push nums[i], nums[i]\n\
    \      points.push nums[i]\n      nums.delete nums[i]\n    else\n      n.push\
    \ nums[i], nums[i]\n    end\n  end\n  points\nend", "  sorted = nums.dup\n  sorted.sort_by\
    \ {|x| x.to_i}\n  return sorted\nend", "  nums.sort!\n  i = 0\n  while i < nums.length\n\
    \    if nums[i] == nums[i].to_s.split(\"\").reduce(:+)\n      nums[i] += 1\n \
    \   else\n      i += 1\n    end\n  end\n  nums\nend", "  # Return the given list\
    \ if it is empty, else the \n  # list of ordered pairs whose sums are in ascending\
    \ order\n  return nums.empty? ? [] : nums.sort_by { |n| nums.find_index(n.to_s)\
    \ }\nend\n</code>\nThis gives the following results:\n<code>\n[5, 7, -3, 10, -7,\
    \ 4, 8]\n[1, 2, -2, -3, -4, -5, -6]\n[1, 10, 11, -12, -1, -21, -22]\n[5, 7, -3,\
    \ 10, -7, 4, 8]\n[]\n</code>\nThe second version with Enumerable#sort_by (thanks\
    \ to Borgleader) yields the following results:\n<code>\n[5, 7, -3, 10, -7, 4,\
    \ 8]\n[1, 2, -2, -3, -4, -5, -6]\n[11, -12, -1, -21, -22]\n[5, 7, -3, 10, -7,\
    \ 4, 8]\n[]\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nFor anyone curious,\
    \ `Enumerable#sort_by` also sorts in reverse: `[5, 7, -3, 10, -7, 4, 8].sort_by\
    \ { |n| nums.find_index(n.to_s) }` gives [11, -12, -1, -21, -22].\n<|/ c |>\n\
    <| c |>\nHi, thanks for sharing the solution, but your solution doesn't seem to\
    \ be working. \n```ruby\n[5, 7, -3, 10, -7, 4, 8].sort_by { |n| nums.find_index(n.to_s)\
    \ }\n```\ngives me ```[5, 7, -3, 10, -7, 4, 8] \n[1, 2, -2, -3, -4, -5, -6]```\n\
    <|/ c |>\n<| c |>\nPlease see the update and the code I posted, does that help?\n\
    <|/ c |>\n<| c |>\nThanks, I tested the updated solution too. But the solution\
    \ by looks better.\n<|/ c |>\n<| a tags=ruby,arrays |>\nThis should be the most\
    \ efficient way:\n<code>\narr = [5, 7, -3, 10, -7, 4, 8]\narr.sort_by{ |x| x.to_s.chars.sort_by{\
    \ |y| y.to_i } }.reverse\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice solution,\
    \ although I wouldn't be surprised if there is a more efficient way to do it in\
    \ Ruby :)\n<|/ c |>\n<| c |>\nI wouldn't be surprised if the built-in sort was\
    \ as efficient as this.\n<|/ c |>\n<| c |>\nHi, thanks for sharing the solution,\
    \ but ", "  nums.sort.each_with_index do |n, index|\n    if n.to_s.size == 1\n\
    \      nums.delete(index)\n    else\n      nums.insert(index, n)\n    end\n  end\n\
    \  return nums\nend", "  return nums.sort_by {|num| nums.sum % 10 }\nend", " \
    \   # write your code in Python 2.7\n    nums_sorted = []\n    # nums.sort() will\
    \ return a sorted list in ascending order\n    # nums.sort(key=int) will return\
    \ a sorted list in ascending order\n    nums_sorted = sorted(nums, key=int)\n\
    \    return nums_sorted\n</code>\nThis solution might look complicated but it\
    \ is actually very simple and straight forward. \nNow let's try to see how this\
    \ works step by step:\nFirst of all, the user has to enter a list of numbers.\
    \ This is done in the main function in main.py:\n<code>\nnums = input(\"Enter\
    \ a list of numbers: \").strip().split(',')\nnums = list(map(int, nums))\n</code>\n\
    Here, we convert the input string into a list of integers by first splitting it\
    \ into a list using ',' as separator. Next, we map the list into a list of integers\
    \ using the map function.\nThen we convert the list of integers into an integer\
    \ list by using map again (this time the int function is used).\nNow that we have\
    \ a list of integers, we can proceed to the main function.\nThe main function\
    \ begins like this:\n<code>", "  return sorted(nums, &:sum)\nend\n</cell>\n<cell>",
  '    return sorted(nums, key=sum)', "  n = nums.size\n  nums.sort!\n  (nums.inject(0){|acc,\
    \ x| acc += x.to_i; acc}) / n.to_f\nend\n</code>\n<|/ a |>\n<| a |>\nUsing Ruby\
    \ 1.9 you can use sort_by to sort a collection:\n<code>\na = [4, 10, 2, 10, 5,\
    \ 7, 11, 6]\na.sort_by { |i| i.to_s.size }.reverse", "  nums = nums.sort\n  sums\
    \ = nums.reduce(0) do |sum, val|\n    sum + val % 10\n  end\n  nums.reverse if\
    \ sums.zero?\n  nums\nend", "  sorted = nums.sort\n  sorted_by_sum = 0\n  sorted_by_index\
    \ = []\n  (0.upto(nums.length).collect do |i|\n    digit = nums[i]\n    digit\
    \ = digit.to_i\n    sorted_by_sum += digit\n    sorted_by_index += [i]\n  end.uniq.sort.reverse\
    \ << sorted) << sorted_by_sum <<\n    sorted_by_index.to_a\nend", "  # TODO: your\
    \ code is here\nend", "  sorted_nums = []\n  sorted_indexs = []\n  total = 0\n\
    \  for i in 0...nums.length-1\n    digits = nums[i].to_s.length\n    total +=\
    \ nums[i]\n    sorted_indexs.push(nums[i])\n    sorted_nums.push(nums[i])\n  \
    \  break if total == digits \n    sorted_indexs.push(nums[i])\n    sorted_nums.push(nums[i])\n\
    \    break if total == 2*digits\n    total -= 2*digits\n    sorted_indexs.push(nums[i])\n\
    \    sorted_nums.push(nums[i])\n  end\n  return sorted_indexs\nend", "  nums =\
    \ nums.sort\n  nums.each_with_index { |num, i| nums[i], nums[i] = num, -nums[i]\
    \ }\n  nums\nend", "    # Write your code here\n    nums = nums.sort\n    nums.sort!{|x,\
    \ y| x + y if x.to_i + y.to_i == 0}\n    return nums\nend", "\tnums = nums.sort\n\
    \tresult = nums.reverse\n\tresult.reverse!\n\treturn result\nend", "    return\
    \ nums if nums.is_a? Array else nums.to_a\nend", "  return [] if nums.empty? or\
    \ nums.size == 0\n  nums.each_with_index do |n,i|\n    digits = n.to_s.chars.map(&:to_i).reduce(:+)\n\
    \    digits = digits if digits.is_a? Integer\n    nums.insert(i, digits <= nums.last.to_i\
    \ ? 1 : 0)\n  end\nend", "    # Write your solution here.\n    return nums\nend\n\
    </cell>\n<code language=julia-1.5>\nfunction main()\n    test = reshape(\n   \
    \     [[1, 2, 3], [-1, -3, -3], [1, 1, 1], [-1, 1, -1]],\n        3,\n       \
    \ :dot\n    )\n    println()\n    display(test)\n    println()\n    display(order_by_points(test))\n\
    end\n</cell>\n<text>\n\u56DE\u987E\n\u6709\u4E00\u4E2A\u51FD\u6570 order_by_points\u3002\
    \ \u5B83\u7684\u53C2\u6570\u662F\u4E00\u4E2A 3x3 \u7684\u77E9\u9635 A \uFF0C\u5176\
    \u4E2D A \u662F Int \u6216\u8005 Float\u3002\n\u5B83\u7684\u8FD4\u56DE\u503C\u662F\
    \u4E00\u4E2A 3x3 \u7684\u77E9\u9635 B \uFF0C\u5176\u4E2D B \u662F Int \u6216\u8005\
    \ Float\u3002\n\u5F53 A \u6709\u591A\u5C11\u4E2A\u5143\u7D20\u7684\u65F6\u5019\
    \uFF0C\u6211\u4EEC\u9700\u8981\u5C06 A \u6309\u7167\u8FD9\u4E9B\u5143\u7D20\u7684\
    \u6570\u91CF\u6765\u6392\u5E8F\uFF0C\u6700\u597D\u7684\u60C5\u51B5\u5C31\u662F\
    \u6309\u7167 A \u7684\u884C\u6765\u6392\u5E8F\uFF0C\u5217\u6765\u6392\u5E8F\u3002\
    \n\u8FD9\u4E9B\u884C\u548C\u5217\u6570\u90FD\u5FC5\u987B\u662F\u76F8\u7B49\u7684\
    \u3002", "    sorted = []\n    while nums != []\n        sorted.push(nums.sort.min)\n\
    \        nums.delete(nums.sort.min)\n    end\n    return sorted\nend", "  nums.sort!\
    \ {|a,b| sum=(a.to_s.split('').to_i).reduce(0) {|sum,x| sum + x} <=> b.to_s.split('').to_i.reduce(0)\
    \ {|sum,x| sum + x}}\n  nums\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nNice!\
    \ I didn't know you could pass an argument to sort!. I added a case for empty\
    \ lists.\n<|/ c |>\n<| a |>\nUsing recursion:\n<code>", "  nums = nums.to_a\n\
    \  nums.sort {|x,y| x.to_i + y.to_i}\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n\
    <| a tags=ruby dscore=2 |>\nThe method below takes an array of integers and sorts\
    \ them by their digits in descending order if the integers are greater than 9\
    \ or ascending if the integers are less than 9.\n<code>", "  return [] if nums.empty?\n\
    \  sorted_nums = [nums[0]]\n  sorted_sum = 0\n  sorted_sum = nums.map(&:to_i).inject(&:+)\
    \ if nums.is_a?(Array)\n  sorted_sum -= sorted_nums[0].to_i\n  sorted_nums.each_with_index\
    \ do |n, i|\n    sorted_sum -= n\n    sorted_nums[i] = n\n  end\n  return sorted_nums\
    \ unless sorted_sum == 0\n  sorted_nums.sort!{|x,y| y <=> x }\n  i = 0\n  sorted_nums.each_with_index\
    \ do |n, i|\n    sorted_nums[i] = n if sorted_sum - sorted_nums[i].to_i == 0\n\
    \  end\nend\n</code>\nThen simply call it like:\n<code>\np order_by_points([-1,11,-11111,-12,-1,-11])\n\
    </code>\n<|/ a |>\n<| a tags=ruby |>\nHere's my take:\n<code>", "  if nums.empty?\n\
    \    return []\n  \n  digits = nums.map { |n| n.to_s.split('').map(&:to_i) }.flatten\n\
    \  \n  digits = digits.sort.map { |a| a.to_s }\n  \n  digits = digits.map { |a|\
    \ a.split('').map(&:to_i) }.flatten\n  \n  nums.map { |n| n + digits.shift }\n\
    end\n</code>\n<|/ a tags=arrays,ruby,algorithm |>\n<| a |>\nRuby\n<code>\narr\
    \ = [1, 12, 45, 12, 45, -13, 12]\narr.sort_by { |e| -e.to_s.chars.map(&:to_i).inject(:+)\
    \ }\n  #=> [12, -13, 45, 12, 45, 1, 12]\n</code>\nExplanation\nSee String#chars\n\
    <code>\n\"1\".chars\n  #=> [\"1\"] \n\"12\".chars\n  #=> [\"1\", \"2\"] \n\"45\"\
    .chars\n  #=> [\"1\", \"2\", \"5\"]\n</code>\nSee String#to_i\n<code>\n\"12\"\
    .to_i\n  #=> 12\n\"45\".to_i\n  #=> 45\n\"1\".to_i\n  #=> 1 \n</code>\nSee Enumerable#inject\n\
    <code>\n\"12\".chars.map(&:to_i).inject(:+)\n  #=> 12 \n</code>\nSee Enumerable#sort_by\n\
    <code>\nenum = arr.sort_by { |e| -e.to_s.chars.map(&:to_i).inject(:+) }\n  #=>\
    \ #<Enumerator: [\"1\", \"12\", \"45\", \"12\", \"45\", \"-13\", \"12\"]:\n  #\
    \     sort_by(&:to_s)>\n</code>\nSee Enumerable#map \n<code>\nenum.map { |e| -e.to_s.chars.map(&:to_i).inject(:+)\
    \ }\n  #=> [12, -13, 45, 12, 45, 1, 12]\n</code>\nSee Enumerable#to_a\n<code>\n\
    enum.to_a\n  #=> [12, -13, 45, 12, 45, 1, 12]\n</code>\nSee Array#<<\n<code>\n\
    enum << [9, 9]\n  #=> [1, 2, 3, 4, 9, 9, 9] \nenum\n  #=> [1, 2, 3, 4, 9, 9, 9]\
    \ \n</code>\nSee Array#shift\n<code>\nenum.shift\n  #=> [9, 9] \nenum\n  #=> [1,\
    \ 2, 3, 4, 9, 9, 9] \n</code>\nSee Array#<< and Array#shift\n<code>", '    return
    sorted(nums, key= lambda n: sum(n%10))', "  nums = nums.sort\n  for i in 0...nums.length-1\n\
    \    nums[i] = nums[i].to_s\n  end\n  nums.sort!\n  nums\nend", "  result = nums.sort\
    \ do |a, b|\n    a = a.to_i\n    b = b.to_i\n    (a + b).abs\n  end\n  result.reverse\n\
    end\n</code>\n<|/ a |>\n<| a dscore=1 |>\nA more pythonic version of your code\
    \ is this:\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.reverse!\n  nums.each\
    \ {|n| nums.unshift(n) }\n  nums\nend", "  return [] if nums.empty? else nums.uniq\
    \ { |num| sum_of_digits(num) }\nend", "  nums = nums.sort\n  nums.map {|i| i}\n\
    end", "  # Your code here\n  if nums.empty?\n    return []\n  sorted_nums = []\n\
    \  sorted_nums << nums.max\n  sorted = nums.sort.reverse\n  while sorted.first\
    \ != nil\n    digit = sorted.first % 10\n    sorted_nums << digit\n    sorted\
    \ << sorted.first % 10\n  end\n  return sorted_nums\nend", "  nums.each_with_index\
    \ do |num, idx|\n    cur_sum = 0\n    nums[idx].digits.each_with_index do |digit,\
    \ i|\n      cur_sum += digit.to_i\n      nums[idx].digits[i] = nil if i == nums[idx].digits.length\
    \ - 1\n    end\n    nums[idx].digits[cur_sum.to_i] = num\n  end\n  nums\nend",
  "  return nums.sort { |a, b| a.to_s <=> b.to_s }\nend", "  return nums.sort{ |a,\
    \ b| a.to_i + b.to_i }\nend", "  nums.sort!\n  i=0\n  while i < nums.length\n\
    \    j = i+1\n    sum = 0\n    while j < nums.length && nums[j].to_i == nums[i].to_i\n\
    \      sum += nums[j].to_i\n      j += 1\n    nums[i], nums[i] = nums[j], nums[i]\n\
    \    i += 1 if sum > 0 end\n  end\n  nums\nend", "  n = nums.size\n  nums.sort!\n\
    \  nums.reverse!\n  nums.map do |i|\n    i = i % (n + 1)\n    [i, nums.count(i)]\n\
    \  end\nend", "  nums.sort!{|x,y| x.to_s.split('').zip(y.to_s.split('')).map {|x|\
    \ x[0]*10**8 + x[1]}.reduce(:>)}\nend\n</code>\n<|/ a dscore=4 |>\n<| a tags=ruby,arrays,sorting\
    \ |>\nAnother possibility is to use sort_by like this:\n<code>\nnums = [1, -12,\
    \ 5, 2]", "    nums.sort_by {|i| i.to_s.size}\nend\n</code>\n<|/ a dscore=3 |>\n\
    <| a tags=sorting,ruby,hash |>\nAnother Ruby approach:\n<code>", "  nums = nums.dup\n\
    \  nums.sort! {|a, b| sum_digits(a) <=> sum_digits(b)}\n  nums\nend", "  sums\
    \ = nums.inject(:+)\n  nums.sort_by{|x| sums[x]}\nend", "  nums.map! do |n| return\
    \ n if n.to_s.size > 10 end\n  nums = nums.sort { |a, b| sum_of_digits(a) < sum_of_digits(b)\
    \ }\n  nums.reverse!\n  nums\nend\n</code>\n<|/ a |>\n<| c |>\nIt should return\
    \ `[]` if the list is empty.\n<|/ c |>\n<| c |>\nIt's hard to tell from the question\
    \ whether empty list is a valid option or not. For example, `['']` is a valid\
    \ input as well.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  nums = nums.map do |n|\n\
    \    n = n.to_s.chars.map(&:to_i)\n    if n.sum > 0\n      n.max\n    else\n \
    \     n.min\n    end\n  end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
