name: HumanEval_8_sum_product
language: rb
prompt: "# For a given list of integers, return a tuple consisting of a sum and a\
  \ product of all the integers in a list.\n# Empty sum should be equal to 0 and empty\
  \ product should be equal to 1.\n# >>> sum_product([])\n# (0, 1)\n# >>> sum_product([1,\
  \ 2, 3, 4])\n# (10, 24)\ndef sum_product(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_product\n\
  \    candidate = method(:sum_product)\n    assert_equal([0, 1], candidate.call([]))\n\
  \    assert_equal([3, 1], candidate.call([1, 1, 1]))\n    assert_equal([100, 0],\
  \ candidate.call([100, 0]))\n    assert_equal([15, 105], candidate.call([3, 5, 7]))\n\
  \    assert_equal([10, 10], candidate.call([10]))\n  end\nend\n"
completions: ["  # Your code here\n  result = 0\n  i = 0\n  while i < numbers.length\n\
    \    result += numbers[i]\n    i += 1\n  end\n  return [result, numbers.length.to_i]\n\
    end", "  sum = product = nil\n  numbers.each do |number|\n    sum += number\n\
    \    product *= number\n  end\n  [sum, product]\nend", "    sum = product = 1\n\
    \    numbers.each do |number|\n        sum += number\n        product *= number\n\
    \    end\n    [sum, product]\nend\n</cell>\n<text>\nApart from the built-in sum\
    \ function, Ruby also includes Enumerable#reduce method to compute a sum.", " \
    \   product = 1\n    sum = 0\n    numbers.each do |x|\n        sum += x\n    \
    \    product *= x\n    end\n    return sum, product\nend", "  sum = product =\
    \ 0\n  numbers.each { |n| sum += n; product *= n }\n  sum, product\nend", "  sum\
    \ = 0\n  product = 1\n  numbers.each do |num|\n    sum += num\n    product *=\
    \ num\n  end\n  sum, product\nend", "  if numbers.empty?\n    return (0, 0)\n\
    \  sum = 0\n  product = 1\n  numbers.each do |x|\n    sum = sum + x\n    product\
    \ = product * x\n  end\n  [sum, product]\nend", "  sum = numbers.inject(0, :+)\n\
    \  product = 1\n  numbers.each do |number|\n    product *= number\n  end\n  (sum,\
    \ product)\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere's a more functional\
    \ way of doing it using Ruby Enumerable#map and Enumerable#reduce:\n<code>", " \
    \ total = 0\n  product = 1\n  numbers.each do |num|\n    total += num\n    product\
    \ *= num\n  end\n  [total, product]\nend\n</code>\nsum_product\nThis is where\
    \ we can refactor our code. We start by refactoring the helper method sum_product\
    \ to take in an Array:\n<code>", "  numbers.inject {|sum, element| sum + element}\n\
    \  numbers.inject {|product, element| product * element}\n  sum, product\nend",
  "  sum = 0\n  product = 1\n  numbers.each do |n|\n    sum = sum + n\n    product\
    \ = product * n\n  end\n  return [sum, product]\nend", "  return numbers.inject(0.0,\
    \ :+), numbers.inject(1, :*)\nend", "    numbers.inject(:+).product\nend", " \
    \ if numbers.empty?\n    (0, 0)\n  else\n    (numbers.inject(:+), numbers.reduce(:*))\n\
    end\n</cell>\n<text>\nThe second solution is using Array#inject and Array#reduce\
    \ methods. Array#inject executes a block of code for each element of a collection.\
    \ \nIn this case we use it to calculate the sum of all elements and then use Array#reduce\
    \ to calculate the product of all elements.", "  sum, product = numbers.reduce(:+),\
    \ numbers.reduce(:*)\n  [sum, product]\nend\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nNote that this will not work in Ruby 2.6+ because Enumerable#reduce changed\
    \ to a proc-like method.\n<|/ c |>\n<| c |>\nAlso note that `reduce` is in 1.8.7+\
    \ and in 2.2+, so is pretty much safe to use.\n<|/ c |>\n<| c |>\nI appreciate\
    \ your comments everyone.  I'm new to Ruby, and am trying to learn the best practices\
    \ for it.  I've learned lots of useful tips, and wanted to give them a shot. \
    \ I'm going to try your suggestions and report back.\n<|/ c |>\n<| a dscore=3\
    \ |>\nIf you have a huge list then you should be using the Enumerable#chunk method\
    \ as shown in one of the answers. If you have a really large list then you should\
    \ be using the lazy enumerable method which allows the enumeration to process\
    \ each element as it is generated. This allows it to process the entire list before\
    \ returning any values. \n<code>", "  sum = numbers.inject(0) {|sum, number| sum\
    \ += number}\n  product = 1\n  numbers.each {|number| product *= number}\n  [sum,\
    \ product]\nend", "\tsum = 0\n\tproduct = 1\n\tnumbers.each do |num|\n\t\tsum\
    \ += num\n\t\tproduct *= num\n\tend\n\treturn (sum, product)\nend", "  sum = 0\n\
    \  product = 1\n  numbers.each do |number|\n    sum += number\n    product *=\
    \ number\n  end\n  return [sum, product]\nend\n</code>\nThen you can use this\
    \ method like so:\n<code>\nnumbers = Array.new\n(1..1000).each do |n|\n  numbers\
    \ << n\nend", "    numbers.inject(0){ |sum, number| sum + number }\n    numbers.inject(1){\
    \ |product, number| product * number }\nend", "  sum_ = 0\n  product_ = 1\n  numbers.each\
    \ do |number|\n    sum_ += number\n    product_ *= number\n  end\n  (sum_, product_)\n\
    end\n</code>\nI prefer the first implementation (the one I wrote) because it's\
    \ more readable and it's easier to debug. You can see that it's easier to understand\
    \ that the loop goes through the numbers array and sums them up and multiplies\
    \ the product. Notice that in my implementation the product is initialized as\
    \ a multiplication of 1 in the beginning (otherwise I wouldn't be able to multiply\
    \ it by 0 which would make my product equal to 0). Also, this is just a very basic\
    \ implementation. There are a lot of things that you could improve (e.g. checking\
    \ if there are any more elements in the array; implementing some more error handling\
    \ logic; etc.).\nAlso, I don't see why you need a helper method here. My implementation\
    \ is pretty straightforward and could be simplified even more (but I think it's\
    \ less readable and more error prone).\nAnother thing you should know about Ruby\
    \ is that (in most cases) loops are optimized by the interpreter. It's better\
    \ to think in terms of sets and enumerators (but Ruby also has Enumerable#inject/each_with_object).\
    \ So you can write something like this in Ruby:\n<code>\nnumbers = [0, 1, 2, 3]\n\
    numbers.reduce(:+).product(:*)\n</code>\nand it'll be more efficient. But, if\
    \ you insist in using for loops, you can also do this:\n<code>", "  sum = product\
    \ = 0\n  numbers.each { |n| sum += n; product *= n }\n  return [sum, product]\n\
    end", "    sum = numbers[0]\n    product = 1\n    numbers.each do |number|\n \
    \       sum += number\n        product *= number\n    end\n    [sum, product]\n\
    end\n</code>\n<|/ a dscore=1 tags=algorithm,ruby,python |>\n<| c |>\n`sum*number`\
    \ will give `0` if the number is `0` which it can't be.\n<|/ c |>\n<| c |>\nAh,\
    \ yes, I missed that case. Updated my answer.\n<|/ c |>\n<| a dscore=1 |>\nAnother\
    \ approach:\n<code>", "  numbers.reduce(:+)\nend", '  return nil, 1', "    # write\
    \ your code here\n    product = 1\n    sum = 0\n    for i in numbers\n       \
    \ sum += i\n        product *= i\n    return (sum, product)", "  total = 0\n \
    \ product = 1\n  numbers.each do |number|\n    total += number\n    product *=\
    \ number\n  end\n  [total, product]\nend\n</code>\n<|/ a |>\n<| c |>\nWhy did\
    \ you make two functions to do this?  It would be much easier to write `sum_product(numbers)`\
    \ and `product_sum(numbers)`.  Also, note that `each` returns the original array\
    \ so `total = sum_product(numbers)` would set `total` to [6,8], not [10,24].\n\
    <|/ c |>\n<| c |>\nI agree with your answer and have implemented it in this way.\
    \ I just wanted to give OP the code and not write the whole function from scratch.\
    \ `each` returns the original array, so `total = sum_product(numbers)` would set\
    \ `total` to `[6,8]`, not `[10,24]`.\n<|/ c |>\n<| c |>\nOops, I didn't realize\
    \ that `each` returns the original array.  I thought that if it was an `each`\
    \ block then it returned the original array.  I guess it only returns true or\
    \ false and doesn't modify the array in-place?  Also, `[6,8] != [10,24]`, the\
    \ first array has an element of 6, and the second has an element of 8.\n<|/ c\
    \ |>\n<| c |>\nYeah you're correct. It modifies the original array.\n<|/ c |>\n\
    <| a tags=ruby,algorithm,math |>\nA very simple but extremely efficient solution:\n\
    <code>", "  sum = numbers.inject(:+).to_f\n  product = numbers.inject(:*).to_f\n\
    \  [ sum, product ]\nend", "  numbers.reduce(:+)\nend", "  sum, product = 0, 1\n\
    \  numbers.each { |n| sum, product = sum + n, product * n }\n  return sum, product\n\
    end", "  # Your code here\n  return numbers.inject(:+), numbers.reduce(:*)\nend\n\
    </code>\nThe above is quite lengthy, and I suspect that there are a lot of shorter\
    \ solutions.\n<|/ a dscore=1 |>\n<| a dscore=1 tags=ruby,enumerable,arrays |>\n\
    If you're willing to use ActiveSupport you can use the reduce method:\n<code>\n\
    numbers = [1, 2, 3, 4, 5, 6]\nnumbers.reduce(0) {|sum, num| sum + num }\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nThis isn't a Ruby specific question, but the problem\
    \ statement is quite specific so it may be worth pointing out that there is a\
    \ very similar question on SO which gives a solution using Python.\n<|/ a tags=ruby,enumerable,arrays\
    \ |>\n<| a tags=ruby,enumerable,arrays dscore=0 |>\n<code>", "  # Sum = 0 and\
    \ Product = 1\n  sum, product = 0, 1\n  numbers.each { |number| sum += number\
    \ }\n  numbers.each { |number| product *= number }\n  [sum, product]\nend", " \
    \ return numbers.reduce(:+), numbers.reduce(:*)\nend\n</cell>\n<text>\nThe reduce\
    \ function is used to iterate over a list, returning a single value for each iteration.\
    \  In this case we want the sum of all the integers in the list, and we want to\
    \ multiply all the integers in the list together.", "  result = numbers.reduce(:+)\n\
    \  product = numbers.reduce(:*)", "    sum = 0\n    product = 1\n    numbers.each\
    \ do |n|\n        sum = sum + n\n        product = product * n\n    end", "  total\
    \ = numbers[0]\n  product.times numbers.each do |number|\n    total += number\n\
    \    product *= number\n  end\n  [total, product]\nend", "  if numbers.nil?\n\
    \    return (0, 0)\n  end\n  total = numbers.reduce(0){|sum, val| sum + val}\n\
    \  product = numbers.reduce(1){|product, val| product * val}\n  return (total,\
    \ product)\nend", "  return numbers.inject(:+).reduce(:*), numbers.inject(:*)\n\
    end", "  numbers.reduce(:+)\n  numbers.reduce(:*)\nend\n</code>\nThe :+ and :*\
    \ symbols mean \"add this thing\" and \"multiply this thing\" respectively; :+\
    \ means \"add this number\", and :* means \"multiply this number\" (thanks Mr.\
    \ Wizard for catching the typo).\nThe reduce method takes a symbol as the first\
    \ argument, and an optional block of code as its second. :+ and :* are symbols\
    \ defined as above (:+ is :+, :* is :*, etc.), and blocks of code are denoted\
    \ with a do end block. The following block of code is the code that will be called\
    \ for each element of the array; here we use symbols to multiply and add, and\
    \ return nil to indicate that the function should stop early.\n<code>", "  sum\
    \ = numbers.reduce(0, :+)\n  product = numbers.reduce(1, :*)\n  sum, product\n\
    end", "  sum = nil\n  product = nil\n  numbers.each do |n|\n    sum = sum + n\n\
    \    product = product * n\n  end\n  [sum, product]\nend\n</cell>\n<cell>", " \
    \   number_sum = numbers.reduce(:+)\n    number_product = numbers.reduce(:*)\n\
    \    (number_sum, number_product)\nend", "  sum = numbers.reduce(0, :+)\n  product\
    \ = numbers.reduce(1, :*)\n  [sum, product]\nend", "    sum = numbers.inject(:+)\n\
    \    prod = numbers.reduce(:*)\n    sum = sum and 1 or 0\n    prod = prod and\
    \ 1 or 0\n    return sum, prod\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhy\
    \ are you using inject and reduce instead of reduce and inject?\n<|/ c |>\n<|\
    \ c |>\nI like the use of inject/reduce\n<|/ c |>\n<| c |>\nBecause inject/reduce\
    \ are more explicit and easy to understand\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  numbers.reduce(:+)\nend", "  sum = numbers.inject(0) {|sum, number| sum + number}\n\
    \  product = 1\n  numbers.each {|number| product *= number}\n  [sum, product]\n\
    end", "\tnumbers = numbers.map { |num| num.to_i }\n\treturn [numbers.sum, numbers.product\
    \ * numbers.size]\nend", "  sum = product = nil\n  numbers.each do |n|\n    sum\
    \ = sum + n\n    product = product * n\n  end\n  [sum, product]\nend", "  sum\
    \ = 0\n  product = 1", "  numbers = numbers.map { |number| number.to_i }\n  (numbers.reduce(:+),\
    \ numbers.reduce(:*))\nend\n</code>\nThe sum_product method above calculates both\
    \ the sum and the product of the numbers in numbers. I used the map function to\
    \ transform the list of numbers into an array of integers. Then I reduce this\
    \ array into a sum and a product. These two methods were introduced in Ruby 1.8.7.\n\
    <|/ a tags=ruby |>\n<| a |>\nThe only thing that makes me shudder is that Ruby\
    \ has multiple ways to do one thing. \nHere's a way to sum all the numbers without\
    \ using Array#sum:\n<code>\nnumbers = [1, 5, 6]\nnumbers.reduce(:+)", "  product\
    \ = 1\n  sum = 0\n  numbers.each do |number|\n    sum += number\n    product *=\
    \ number\n  end\n  return sum, product\nend", "    numbers.reduce(:+)\n    numbers.reduce(:*)\n\
    end\n</cell>\n<code language=conda-env-Anaconda3-py>", "  sum = numbers.inject(:+,\
    \ 0)\n  product = numbers.inject(:*)\n  (sum, product)\nend\n</cell>\n<code language=julia-1.4>\n\
    sum_product([1,2,3])\n</cell>\n<code language=julia-1.4>\nsum_product([1,1,1])\n\
    </cell>\n<code language=julia-1.4>\nsum_product([-1])\n</cell>\n<code language=julia-1.4>\n\
    sum_product([-1, 1, -1])\n</cell>\n<code language=julia-1.4>", '  sum, product
    = numbers.reduce(:+), numbers.reduce(:*)', "  # TODO: Your code here!\n  sum =\
    \ 0\n  product = 1\n  \n  # TODO: Add your code here!\n  \n  return sum, product\n\
    end\n</cell>\n<cell>\nsum_product?\n</cell>\n<text>\n2. Complete the function\
    \ below.\nIt should take one parameter, a list of integers and return a string\
    \ with the most negative and the most positive integer in the list.\nIf the list\
    \ is empty, return \"Empty list!\"\nIf the list contains more than one element,\
    \ return the element that appears first and the element that appears last in the\
    \ list. If there are more than one elements with the same value, return the element\
    \ that appears first in the list. \nIf the list contains only one element, return\
    \ the value.\nIf there are two or more elements with the same value, return \"\
    The list contains duplicates!\" ", "  sum = 0\n  product = 1\n  numbers.each do\
    \ |n|\n    sum += n\n    product *= n\n  end\n  return sum, product\nend", " \
    \ sum, product = 0, 1\n  numbers.each do |number|\n    sum += number\n    product\
    \ *= number\n  end\n  return sum, product\nend", "  sum = 0\n  product = 1\n \
    \ numbers.each do |number|\n    sum = sum + number\n    product = product * number\n\
    \  end\n  return [sum, product]\nend", "  numbers.reduce(:+).reduce(:*)\nend\n\
    </cell>\n<text>\nExercise 4\nWrite a function that returns true if the sum of\
    \ the integers in a list is greater than or equal to the product of the integers\
    \ in a list.", "  # Get the sum\n  sum = 0\n  sum = 0 if numbers.length == 0 then\
    \ 0 else numbers.last\n  \n  # Get the product\n  product = 1\n  product = 1 if\
    \ numbers.length == 0 then 0 else numbers.first\nend", "  # Your code here!\n\
    \  sum = number_as_int(numbers[0])\n  prod = number_as_int(numbers[0])\n  numbers.each\
    \ do |number|\n    sum += number\n    prod *= number\n  end\n  return sum, prod\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>", "  sum = numbers.reduce(:+)\n\
    \  product = numbers.reduce(:*)\n  return [sum, product]\nend\n</cell>\n<cell>\n\
    sum_product([1, 2, 3, 4])\n</cell>\n<text>\nFunctional Programming", "  sum, product\
    \ = 0, 1\n  numbers.each do |number|\n    sum += number\n    product *= number\n\
    \  end\n  return sum, product\nend", "    sum = 0\n    product = 1\n    numbers.each\
    \ do |n|\n      sum += n\n      product *= n\n    end\n    return (sum, product)\n\
    end\n</code>\n<|/ a |>\n<| c |>\n`numbers = []; numbers.each do |n| sum += n;\
    \ product *= n; end; return (sum, product);` would be a more concise way of doing\
    \ it\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.inject do |sum,\
    \ number|\n    sum + number\n  end\nend", "  numbers.reduce(&:+).reduce(&:*)\n\
    end\n</cell>\n<cell>", "  sum = 0\n  product = 1\n  numbers.each do |n|\n    sum\
    \ += n\n    product *= n\n  end\n  return [sum, product]\nend", "  sum = product\
    \ = 0\n  numbers.each do |num|\n    sum += num\n    product *= num\n  end\n  [sum,\
    \ product]\nend", "  s = 0\n  for i in numbers\n    s += i\n  i = 1\n  while i\
    \ <\n    s = s + i\n    i += 1\n  s, i = (s + i, 1)\n  return (s, i)", "  sum_\
    \ = 0\n  product_ = 1\n  numbers.each do |number|\n    sum_ += number\n    product_\
    \ *= number\n  end\n  [sum_, product_]\nend", "    total = 0\n    product = 1\n\
    \    numbers.each do |number|\n        total += number\n        product *= number\n\
    \    end\n    return (total, product)\nend\n</cell>\n<cell>", "  n = numbers.reduce((0,1))\n\
    \  s = numbers.reduce(:+)\n  p = numbers.reduce(:*)\n  (s, p)\nend\n</cell>\n\
    <code language=julia-1.0>\n@assert sum_product([1,2,3]) == (6,3)\n@assert sum_product([1,2,3,4,5])\
    \ == (15,10)\n@assert sum_product([0,0,0,0]) == (0,1)\n@assert sum_product([1,1])\
    \ == (1,1)\n@assert sum_product([1,0,1]) == (1,0)\n</cell>\n<text>\nGiven a matrix,\
    \ write an expression that gives the sum of all numbers in the matrix and the\
    \ product of all numbers in the matrix. Think about what properties a matrix should\
    \ have.", "  sum = 0 \n  product = 1\n  numbers.each do |x|\n    sum += x\n  \
    \  product *= x\n  end\n  return [sum, product]\nend", "  sum = product = 0\n\
    \  numbers.each do |number|\n    sum += number\n    product *= number\n  end\n\
    \  [sum, product]\nend\n</cell>\n<cell>\nsum_product([1, 2, 3, 4])\n</cell>\n\
    <cell>\nsum_product([1, 2])\n</cell>\n<cell>\nsum_product([1, 2, 3, 2])\n</cell>\n\
    <cell>\nsum_product([3, 1])\n</cell>\n<cell>\nsum_product([3, 2])\n</cell>\n<cell>\n\
    sum_product([3, 2, 1])\n</cell>\n<cell>\nsum_product([3, 1, 2, 2])\n</cell>\n\
    <text>\nRemoving items from a list", "  sum = product = 0\n  numbers.each do |num|\n\
    \    sum = sum + num\n    product = product * num\n  end\n  [sum, product]\nend\n\
    </code>\nAnd now we can use these two methods in our code:\n<code>", "  sum =\
    \ numbers.reduce(0, :+)\n  product = numbers.reduce(1, :*)\n  (sum, product)\n\
    end", "  sum = numbers.reduce(0, :+) # Using reduce(:+) means we sum up all the\
    \ numbers without having to explicitly write each number. \n  product = numbers.reduce(1,\
    \ :*)\n  [sum, product]\nend\n</code>\nI then run the function and get the following\
    \ output:\n<code>\n[4, 15]\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for answering\
    \ my question! But can you tell me what this line of code does? \"product = numbers.reduce(1,\
    \ :*)\"\n<|/ c |>\n<| c |>\nIt's the same as `product = 1` for each element in\
    \ numbers (that is, multiplying it by one). The reduce function is like `product\
    \ = numbers.reduce(product)`. The *reduce* function is a ruby method that allows\
    \ you to perform any operation on every element in the array and return the final\
    \ result. It also has an optional second argument that allows you to specify the\
    \ initial value. So in the case of reduce it basically says to start with `product\
    \ = 1` and then perform `product *= number` for each number in the array.\n<|/\
    \ c |>\n<| c |>\nI believe I understand now. Thank you for your help!\n<|/ c |>\n\
    <| c |>\nThe output of `[1, 4, 3].reduce(0, :+) == 6` is incorrect. `reduce` does\
    \ not accept a symbol argument for the initial value. You should be doing `reduce(0,\
    \ :+)` instead of `reduce(0, :+)`\n<|/ c |>\n<| a tags=ruby dscore=1 |>\nAs a\
    \ Ruby novice, I wanted to understand the various techniques used here.\nThe answers\
    \ I received, are all great and informative. I would like to share with you how\
    \ I learned.\nI first wanted to understand why I got different answers for the\
    \ same inputs. To understand that, I wanted to see the \"pipeline\" of code. Here's\
    \ what I did:\n<code>\nirb(main):002:0> sum_product [1, 2, 3]\n=> [1, 2, 3] \n\
    irb(main):003:0> sum_product [1, 2, 3]\n=> [1, 2, 3] \nirb(main):004:0> sum_product\
    \ [1, 2, 3]\n=> [1, 2, 3] \nirb(main):005:0> sum_product [1, 2, 3]\n=> [1, 2,\
    \ 3] \nirb(main):006:0> sum_product [1, 2, 3]\n=> [1, 2, 3] \nirb(main):007:0>\
    \ sum_product [1, 2, 3]\n=> [1, 2, 3] \nirb(main):008:0> sum_product [1, 2, 3]\n\
    => [1, 2, 3] \nirb(main):009:0> sum_product [1, 2, 3]\n=> [1, 2, 3] \nirb(main):010:0> ",
  "  sum = numbers.inject(:+, 0)\n  product = numbers.inject(1, :*)\n  [sum, product]\n\
    end\n</code>\n<|/ a tags=arrays,ruby,performance dscore=5 |>\n<| c |>\n+1 for\
    \ the use of inject and :*, didn't know about that until now\n<|/ c |>\n<| c |>\n\
    What happened to the \"empty\" case? Does it return nil?\n<|/ c |>\n<| c |>\n\
    The empty case is handled above. `nil` is returned.\n<|/ c |>\n<| c |>\nIf numbers\
    \ is an array, then this can be slightly simplified, since you can just use `sum\
    \ = 0` and `product = 1`\n<|/ c |>\n<| c |>\n`def sum_product(numbers)\n  numbers.inject(:+,\
    \ 0) * numbers.inject(:*, 1)\nend`\n<|/ c |>\n<| a tags=arrays,ruby,performance\
    \ dscore=5 |>\nThe most compact and efficient way in Ruby 1.8.7 is using inject:\n\
    <code>", "  sum = numbers.reduce(:+)\n  product = numbers.reduce(:*)\n  [sum,\
    \ product]\nend", "  sum = numbers[0]\n  product = 1\n  numbers.each do |n|\n\
    \    sum = sum + n\n    product = product * n\n  end\n  return sum, product\n\
    end", "  sum = numbers.inject(0,:+) # sum the numbers\n  product = numbers.inject(1,:*)\
    \ # multiply all the numbers\n  return [sum, product]\nend\n</cell>\n<code language=julia-1.5>\n\
    sum_product([1, 2])\n</cell>\n<text>\nSum Range\nFor a given list of integers,\
    \ return a tuple consisting of a sum of all integers starting from 0 and ending\
    \ at a given number. For example, sumRange([10, 15, 20, 35], 6) => [15, 35].",
  "    sum, product = 0, 1\n    numbers.each do |n|\n        sum += n\n        product\
    \ *= n\n    end\n    [sum, product]\nend\n</cell>\n<text>\n2.3 Exercise", "  sum\
    \ = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n    product\
    \ *= number\n  end\n  (sum, product)\nend", '  sum, product = 0, 1', "  if numbers.empty?\n\
    \    (0, 1) \n  else\n    sum = numbers.inject(:+) \n    product = numbers.inject(:*)\n\
    \    (sum, product)\n  end\nend", "  sum = numbers.inject(:+)\n  product = numbers.inject(:*)\n\
    \  (sum, product)\nend", "  sum = numbers.reduce(0, :+)\n  product = numbers.inject(1,\
    \ :*)\n  return [sum, product]\nend", "  # Add up the list to produce the sum\n\
    \  sum = 0\n  \n  # Multiply each number in the list by the product of the list\n\
    \  product = 1\n  \n  # Loop through each number\n  numbers.each do |num|\n  \
    \  \n    # Add the number to the sum\n    sum += num\n    \n    # Multiply the\
    \ product by that number\n    product *= num\n  end\n  \n  # Return the sum and\
    \ the product\n  [sum, product]\nend\n</cell>\n<code language=julia-0.6>", " \
    \   sum_ = 0\n    product_ = 1\n    \n    numbers.each do |number|\n        sum_\
    \ += number\n    end\n    \n    numbers.each do |number|\n        product_ *=\
    \ number\n    end\n    \n    return (sum_, product_)\nend\n</cell>\n<cell>\nputs\
    \ sum_product([2, 3, 4])\n</cell>\n<text>\nThe sum and the product should now\
    \ be equal (10)", "  result = numbers.reduce(0) do |sum, num|\n    sum += num\n\
    \    num\n  end\n  (0..result).reduce(1) do |product, index|\n    product * numbers[index]\n\
    \  end\nend", "  return numbers.reduce(:+).product, numbers.reduce(:*)\nend\n\
    </cell>\n<code language=ruby-2.1>", "  sum = product = 0\n  numbers.each do |number|\n\
    \    sum += number\n    product *= number\n  end\n  [sum, product]\nend", "  sum\
    \ = 0\n  product = 1\n  numbers.each do |n|\n    sum += n\n    product *= n\n\
    \  end\n  [sum, product]\nend\n</cell>\n<cell>", "  numbers.reduce! {|sum,x| sum\
    \ + x }\n  sum, product = numbers.inject([0, 1], :+), numbers.inject(1, :*)\n\
    \  sum, product\nend", "    total = numbers.inject(0,:+).product\n    \n    return\
    \ total\nend", "  sum = numbers.inject(:+)\n  product = numbers.reduce(:*)\n \
    \ return sum, product\nend", "  # Your code here\n  if numbers.empty?\n    (0,\
    \ 1) \n  else\n    sum = numbers.inject(0) {|sum, number| sum + number }\n   \
    \ product = numbers.inject(1) {|product, number| product * number }\n  end\nend\n\
    </code>\n<|/ a tags=ruby,arrays,sum,ruby-on-rails dscore=2 |>\n<| c |>\nYou only\
    \ need `numbers.inject(0) {|sum, number| sum + number }` to sum the array. `numbers.inject(1)\
    \ {|product, number| product * number }` is sufficient to multiply the array.\n\
    <|/ c |>\n<| c |>\nYes, that's true. I didn't want to complicate the answer.\n\
    <|/ c |>\n<| a tags=ruby,arrays,sum,ruby-on-rails |>\n<code>", "  sum = numbers.reduce(:+)\n\
    \  product = 1\n  numbers.each do |number|\n    product *= number\n  end\n  return\
    \ sum, product\nend", "    sum = product = 1\n    numbers.each do |n|\n      \
    \  sum += n\n        product *= n\n    end\n    return sum, product\nend", " \
    \ numbers.reduce(:+).reduce(:*)\nend\n</cell>\n<cell>\nsum_product(numbers)\n\
    </cell>\n<text>\nThe Enumerable Module\nYou can access the each element of an\
    \ array using Enumerable#each:", "    sum = 0\n    product = 1\n    numbers.each\
    \ do |num|\n        sum += num\n        product *= num\n    end\n    return sum,\
    \ product\nend", "  sum = 0 \n  product = 1\n  numbers.each do |n|\n    sum +=\
    \ n\n    product *= n\n  end\n  [sum, product]\nend\n</cell>\n<cell>", "  if numbers.empty?\n\
    \    0, 1\n  else\n    sum = numbers.reduce(:+)\n    product = numbers.reduce(:*)\n\
    \    sum, product\n  end\nend", "  sum = 0\n  product = 1\n  numbers.each do |number|\n\
    \    sum = sum + number\n    product = product * number\n  end\n  [sum, product]\n\
    end", "  sum = numbers.reduce(0, :+)\n  product = numbers.reduce(:*)", "  # Write\
    \ your answer here\n  numbers.reduce(:+)\n  numbers.reduce(:*)\nend", "  numbers.reduce(:+)\n\
    end", "  number, total = numbers[0], 1\n  numbers.each do |number|\n    total\
    \ *= number\n    number += total\n  end\n  return [total, number]\nend", "   \
    \ # Write your code here\n    sum = numbers[0]\n    product = 1\n    # loop in\
    \ numbers\n    for i in numbers[1:]\n        sum += i\n        product *= i\n\
    \    return (sum, product)\n</cell>\n<text>\nWhat if we wanted a running total?\
    \ We could use the reduce function, which applies a function and combines the\
    \ result with the last value. We could also use the map function which applies\
    \ a function to all elements in a list.", "  total = 0\n  product = 1", "  numbers.reduce(:+)\n\
    end", "  numbers.inject(:+).reduce(:*)\nend", "  if numbers.nil?\n    return (0,\
    \ 0)\n  end\n  numbers = numbers.to_a\n  n1, n2 = numbers.reduce(&:+), numbers.reduce(&:*)\n\
    \  if n1 == 0 or n2 == 1\n    return (n1, n2)\n  end\n  sum_product([n2 - n1,\
    \ n1]) if n1 > n2\nend\n</code>\nA more efficient method is to find an algorithm\
    \ that can find the maximum product of some subset of the numbers, by considering\
    \ only those numbers that have a non-zero product.\nTo find a subset that has\
    \ the maximum product, use the following idea:\nFor each number n, compute the\
    \ product of all the numbers up to and including n.\nThen, add these products\
    \ together into a new product.\nThe new product will always be the largest of\
    \ the new products of all the numbers up to and including n.\nThe trick here is\
    \ that since each number can only have one product in our new product, we can\
    \ reuse the sum of the products of all the numbers up to and including n-1 instead\
    \ of building a new sum each time.\nThis means we only need to consider numbers\
    \ that have a non-zero product (since we reuse them instead of building a new\
    \ sum each time).\n<code>", "  result = 0\n  product = 1", "  sum, product = 0,\
    \ 1\n  numbers.each do |n|\n    sum += n\n    product *= n\n  end\n  sum = sum.to_i\n\
    \  product = product.to_i\n  sum, product\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| a dscore=2 tags=ruby |>\nAs this question is about Ruby, a better answer would\
    \ be to use the reduce method, which combines a loop with an accumulator:\n<code>",
  "  sum = 0.0\n  product = 1.0\n  numbers.each do |n|\n    sum = sum + n\n    product\
    \ = product * n\n  end\n  sum = sum.to_f\n  product = product.to_f\n  return [sum,\
    \ product]\nend\n</cell>\n<cell>\nsum_product([1,2,3,4,5])\n</cell>\n<text>\n\
    This concludes our discussion of recursion.", "  sum = 0\n  product = 1\n  numbers.each\
    \ do |n|\n    sum = sum + n\n    product = product * n\n  end\n  return sum, product\n\
    end", "\tsum = numbers.inject(0, :+)\n\tproduct = numbers.reduce(:*)\n\treturn\
    \ [sum, product]\nend", "  sum = numbers.inject(0){ |sum, number| sum + number}\n\
    \  product = 1\n  numbers.each do |number|\n    product *= number\n  end\n  [sum,\
    \ product]\nend", "  # Write your code here.\n  sum = 0\n  product = 1\n  numbers.each\
    \ do |x|\n    sum += x\n    product *= x\n  end\n  return [sum, product]\nend",
  "  sum = product = 0\n  numbers.each do |n|\n    sum = sum + n\n    product = product\
    \ * n\n  end\n  return sum, product\nend", "  return numbers, numbers.inject(:+).reduce(:*)\n\
    end\n</cell>\n<code language=julia-0.6>\n@assert sum_product([1, 2, 3]) == (6,\
    \ 6)\n@assert sum_product([1, 2, 3, 5]) == (13, 21)\n@assert sum_product([-3])\
    \ == (3, -3)\n</cell>\n<text>\nInfinite product", "  sum = 0\n  product = 1\n\
    \  numbers.each do |n|\n    sum = sum + n\n    product = product * n\n  end\n\
    \  [sum, product]\nend", "  sum = 0\n  product = 1\n  numbers.each do |number|\n\
    \    sum += number\n    product *= number\n  end\n  return sum, product\nend\n\
    </cell>\n<cell>", "  sum, product = 0, 1\n  numbers.each do |number|\n    sum\
    \ += number\n    product *= number\n  end\n  return sum, product\nend", "    product\
    \ = numbers.reduce(:*)\n    sum = numbers.reduce(:+) rescue 0\n    return sum,\
    \ product\nend", "  # Your code here\n  sum = 0\n  product = 1\n  for i in numbers\n\
    \    sum += i\n    product *= i\n  return sum, product\n</cell>\n<cell>", "  \
    \  sum = numbers.inject(0, :+)\n    product = numbers.inject(1, :*)\n    [sum,\
    \ product]\nend", "    sum_ = 0\n    product_ = 1\n    numbers.each do |number|\n\
    \        sum_ = sum_ + number\n        product_ = product_ * number\n    end\n\
    \    [sum_, product_]\nend", "  sum = nil\n  product = 1\n  numbers.each do |number|\n\
    \    sum = sum + number\n    product = product * number\n  end\n  return [sum,\
    \ product]\nend", "  sum, product = 0, 1\n  numbers.each do |number|\n    sum\
    \ += number\n    product *= number\n  end\n  return [sum, product]\nend\n</code>\n\
    <|/ a tags=ruby,arrays dscore=1 |>\n<| c |>\nYour second answer was correct but\
    \ the code formatting was horrible. I've cleaned it up some.\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby,arrays |>\n<code>\nnumbers = [1, 2, 3, 4, 5]\nresult = numbers.inject(&:+).product(&:*)\
    \ # => [10, 20, 30, 40, 50]\n</code>\n<|/ a |>\n<| a tags=ruby,arrays dscore=0\
    \ |>\n<code>\nnumbers = [1,2,3,4,5]\nnumbers.inject(&:+).reduce(&:*)\n=> 10\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for your answer. Your code produces the correct\
    \ result, but it requires an extra step. I've posted a more terse answer below.\n\
    <|/ c |>\n<| a |>\nThis works:\n<code>\nnumbers.reduce(0) {|sum,x| sum + x}.product(&:*)\n\
    => [10, 20, 30, 40, 50]\n</code>\n<|/ a tags=ruby,arrays dscore=0 |>\n<| c |>\n\
    Thanks for your answer. Your code produces the correct result, but it requires\
    \ an extra step. I've posted a more terse answer below.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  numbers, sum, product = numbers, 0, 1\n  numbers.each do |number|\n\
    \    sum += number\n    product *= number\n  end\n  return [sum, product]\nend\n\
    </cell>\n<text>\nGiven an integer number, return the sum of all its digits.\n\
    If there are no digits, return 0.\nIf the number is negative, return 0.", "  #\
    \ Get length\n  length = get_length(numbers)\n  \n  # Initialize sum & product\
    \ to zero & 1\n  sum = [0]\n  product = [1]\n  \n  # For each element in the list\n\
    \  for i in 0..length\n    # Sum the element with previous sum\n    sum[0] = sum[0]\
    \ + numbers[i]\n    # Multiply the element with previous product\n    product[0]\
    \ = product[0] * numbers[i]\n  end\n  \n  # Return the tuple & print it on the\
    \ screen\n  return sum, product\nend", "  if numbers.empty?\n    (0, 1) \n  else\n\
    \    (numbers.reduce(:+), numbers.reduce(:*))\nend", "  return [numbers.reduce(:+),numbers.reduce(:*)]\n\
    end", "  sum_ = 0\n  prod_ = 1\n  numbers.each do |n|\n    sum_ += n\n    prod_\
    \ *= n\n  end\n  return [sum_, prod_]\nend", "  return numbers.inject(:+), numbers.inject(:*)\n\
    end", "  # Initialize a sum and product with the first number in the list.\n \
    \ sum = numbers[0]\n  product = 1", "  numbers.reduce(:+)\nend", "  numbers.reduce(:+)\n\
    \  numbers.reduce(:*)\nend", "  \n  # Your code here!\n  \n  return numbers[0],\
    \ numbers[0] * numbers[0].to_f\n  \nend", "  sum = numbers.inject(:+)\n  product\
    \ = numbers.reduce(:*)\n  [sum, product]\nend", "  sum = numbers.inject(:+)\n\
    \  product = numbers.inject(:*)\n  [sum, product]\nend", "  numbers = numbers.to_a\
    \ if numbers.length != nil \n  numbers.inject(0){|sum, i| sum + i } * numbers.inject(1){|prod,\
    \ i| prod * i }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI wonder how many other\
    \ languages this could be.  What about Ruby?  C#?  JavaScript?  It would be a\
    \ good exercise to translate this into a language of your choosing.  If you had\
    \ a more interesting example, perhaps one that demonstrated a more efficient implementation,\
    \ that would be even better.\n<|/ c |>\n<| c |>\nI would think it would be fairly\
    \ easy to translate to any language.\n<|/ c |>\n<| c |>\nI suspect that this would\
    \ be the most efficient implementation, but I find it pretty unintuitive to read.\
    \ Having said that, I do think that it is very readable.\n<|/ c |>\n<| c |>\n\
    This is the most readable implementation for this particular problem in python\n\
    <|/ c |>\n<| c |>\nI think this solution would be the best for Ruby as the .inject\
    \ method returns an Enumerator\n<|/ c |>\n<| a tags=loops,python,performance,language-agnostic,algorithm\
    \ |>\nThe most efficient way in python (tested on python 2.6) is to use itertools.accumulate,\
    \ e.g.\n<code>\nimport itertools", "    sum = nil\n    product = nil\n    numbers.each\
    \ do |number|\n        if number == sum or number == product\n            sum\
    \ += number\n            product *= number\n        else\n            sum = number\n\
    \        end\n    end\n    return sum, product\nend\n</code>\nNow that we've seen\
    \ how to do it the hard way, we can go about solving it with a more efficient\
    \ and more elegant way (more Pythonic)\n<code>", "  sum = 0\n  product = 1", " \
    \ sum_ = 0\n  product_ = 1", "    sum_number = 0\n    product_number = 0\n   \
    \ numbers.each do |number|\n        sum_number += number\n        product_number\
    \ *= number\n    end\n    [sum_number, product_number]\nend", "  return numbers.inject(:+).reduce(:*),\
    \ numbers.inject(:*).reduce(:+)\nend", "  sum = 0\n  product = 1\n  numbers.each\
    \ do |num|\n    sum += num\n    product *= num\n  end\n  [sum, product]\nend",
  "  sum = 0\n  prod = 1\n  numbers.each do |number|\n    sum += number\n    prod\
    \ *= number\n  end\n  [sum, prod]\nend\n</cell>\n<text>\nFor a more in-depth explanation,\
    \ you can view the problem and the solution discussed in lecture.", "  if numbers.empty?\n\
    \    sum, product = 0, 1\n  else\n    sum = numbers.inject(0){|sum,x| sum+x} #\
    \ sum is now the sum of all the numbers\n    product = numbers.inject(1){|product,x|\
    \ product*x} # product is now the product of all the numbers\n  end\n  return\
    \ [sum, product]\nend", "  sum = 0\n  product = 1\n  numbers.each { |n| sum +=\
    \ n; product *= n }\n  [sum, product]\nend", "    \n    return sum = 0, product\
    \ = 1\n    for number in numbers\n        sum += number\n        product *= number\n\
    \    \n    return sum, product\n    \n    ", "  sum = numbers.reduce(:+)\n  product\
    \ = numbers.reduce(:*)", "  sum = numbers.reduce(0,:) + numbers.reduce(1,:)\n\
    \  product = numbers.reduce(1,:) * numbers.reduce(0,:)\n  [sum, product]\nend\n\
    </code>\n<|/ a tags=ruby dscore=4 |>\n<| c |>\nThis doesn't produce the correct\
    \ answer: try `sum_product([3,0,2])`. It should return `[3, 6]` but instead returns\
    \ `[6, 6]`. The correct solution is `sum_product([0]) + sum_product([1, 1])`.\
    \ Also, if `numbers` is an Array instead of a Range (which it should be), you\
    \ can remove `first` and `last`.\n<|/ c |>\n<| c |>\nActually, you're right: my\
    \ code was completely wrong (although it might have worked sometimes). I've updated\
    \ my answer.\n<|/ c |>\n<| a dscore=4 |>\nFor those who have come here looking\
    \ for the shortest Ruby code without using any library, here's how you do it with\
    \ Array#reduce:\n<code>", "  sum = 0, product = 1\n  numbers.each do |number|\n\
    \    sum += number\n    product *= number\n  end\n  return [sum, product]\nend\n\
    puts sum_product([1,2,3,4,5])", "  if numbers.nil? || numbers.empty?\n    return\
    \ (0.0)\n  end\n  sum = numbers.reduce(0.0, :+).to_f\n  product = numbers.reduce(1.0,\
    \ :*).to_f\n  (sum, product)\nend", "  total = numbers.reduce(:+)\n  product =\
    \ numbers.reduce(:*)\n  [total, product]\nend", "  sum = numbers.reduce(:+)\n\
    \  product = 1\n  numbers.each do |number|\n    product = product * number\n \
    \ end\n  [sum, product]\nend", "  numbers.inject(:+).zip(numbers.inject{|sum,\
    \ n| sum + n}) if numbers.any?\nend\n</code>\nThis should also give you an idea\
    \ of the sort of abstractions you can employ in Ruby. They have many advantages\
    \ and are certainly worth getting to know if you're going to be doing any serious\
    \ development in any language.\n<|/ a |>\n<| c |>\n+1 for pointing out `inject`\
    \ - never knew about it before!\n<|/ c |>\n<| c |>\nI agree.  Ruby is definitely\
    \ a fantastic language.\n<|/ c |>\n<| a tags=ruby dscore=4 |>\nRuby has so many\
    \ options. Here's a few that might help you in understanding Ruby's basic concepts.",
  "  return numbers.reduce(:+), numbers.reduce(:*)\nend\n</cell>\n<cell>\n%preview\
    \ sum_product\n</cell>\n<text>\nNow we have the definition of sum_product, let's\
    \ implement it in a few different ways to see how the function works:", "  total\
    \ = 0\n  product = 1\n  numbers.each do |number|\n    total += number\n    product\
    \ *= number\n  end\n  (total, product)\nend\n</code>\nAnd now our code works:\n\
    <code>\nsum_product([1, 2, 3, 4])\n  => [10, 24]\nsum_product([])\n  => [0, 1]\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=ruby,lambda,arrays |>\nThis question is\
    \ old but still ranks very highly in Google for \"Ruby sum product array\", so\
    \ I'm going to add one solution which uses Enumerable#inject:\n<code>", "  sum,\
    \ product = numbers.reduce(0,0), numbers.reduce(1,1)\n  numbers.reduce(sum, product)\n\
    end\n</cell>\n<cell>\nsum_product([1,2,3])\n</cell>\n<text>\nNow let's use reduce\
    \ to find the sum and product of all even numbers in a list:", "  sum = product\
    \ = 1\n  numbers.each { |x| sum += x; product *= x }\n  [sum, product]\nend",
  "  sum = product = 0\n  numbers.each do |number|\n    sum += number\n    product\
    \ *= number\n  end\n  sum, product\nend", "  if numbers.empty?\n    [0, 1]\n \
    \ else\n    [numbers.sum, numbers.reduce(:*)]\n  end\nend", "  sum, product =\
    \ 0, 1\n  numbers.each do |number|\n    sum += number\n    product *= number\n\
    \  end\n  return sum, product\nend", "  return numbers.reduce(:+), numbers.reduce(:*)\n\
    end\n</cell>\n<text>\nA list is a data type that allows us to store multiple items\
    \ at once. For example, a list can be created with the list method or the new\
    \ list literal.", "    sum = numbers.inject(:+, 0)\n    product = numbers.inject(:*,\
    \ 1)\n    return sum, product\nend\n</code>\n<|/ a |>\n<| c |>\nThat is indeed\
    \ a nice little piece of ruby. Still wondering if there is a way to do this in\
    \ pure ruby.\n<|/ c |>\n<| a |>\n<code>\n[1,2,3,4,5].map { |x| x * x }\n=> [1,\
    \ 4, 9, 16, 25]\n</code>\n<|/ a dscore=4 tags=ruby |>\n<| c |>\nIt took me a second\
    \ to figure out what the second map was doing because map can have two blocks\
    \ arguments.  So if you wanted to perform an operation on every element of an\
    \ array, you put the operation inside the second block.  Here, x is the current\
    \ element of the array and it is multiplied by the current element of the array.\n\
    <|/ c |>\n<| a dscore=4 |>\nYou need Enumerable#inject\n<code>\n[1,2,3].inject(:+)\n\
    => 6\n</code>\n<|/ a tags=ruby |>\n<| c |>\n+1 for showing the inject method.\
    \  However this doesn't answer the question.\n<|/ c |>\n<| a tags=ruby |>\nThis\
    \ is my approach to this problem. Hope it helps. \n<code>", "  numbers.reduce(:+)\n\
    end", "  numbers.inject(:+).reduce(:*)\nend", "  sum = 0\n  product = 1\n  numbers.each\
    \ do |num|\n    sum += num\n    product *= num\n  end\n  return [sum, product]\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=ruby,ruby-on-rails-3 |>\n\
    <code>", "    total = 0\n    product = 1\n    numbers.each do |number|\n     \
    \   total += number\n        product *= number\n    end\n    return total, product\n\
    end\n</code>\nMy test code:\n<code>\nrequire 'minitest/spec'\nrequire 'minitest/autorun'",
  "  return numbers.reduce(:+), numbers.reduce(:*)\nend", "    sum, product = 0, 1\n\
    \    numbers.each do |n|\n        sum += n\n        product *= n\n    end\n  \
    \  return sum, product\nend", "    sum = numbers.inject(0) do |sum, num|\n   \
    \     sum + num\n    end\n    product = numbers.inject(1) do |product, num|\n\
    \        product * num\n    end\n    [sum, product]\nend\n</cell>\n<cell>", " \
    \ sum = numbers.inject(0,:+)\n  product = numbers.inject(1,:*)\n  (sum,product)\n\
    end", "  return numbers.reduce(:+)\nend", "  sum = numbers.inject(:+)\n  product\
    \ = 1\n  numbers.each do |number|\n    product *= number\n  end\n  [sum, product]\n\
    end\n</cell>\n<cell>", "  sum_product = 1\n  product_of_numbers = 1\n  if numbers.empty?\n\
    \    sum_product = 0\n    product_of_numbers = 1\n  else\n    numbers.each do\
    \ |number|\n      sum_product = sum_product + number\n      product_of_numbers\
    \ = product_of_numbers * number\n    end\n  end\n  return sum_product, product_of_numbers\n\
    end\n</code>\n<|/ a |>\n<| c |>\nPlease consider explaining your solution, as\
    \ this will benefit future readers.\n<|/ c |>\n<| c |>\nThank you for this code\
    \ snippet, which might provide some limited short-term help.  A proper explanation\
    \ [would greatly improve](//meta.stackexchange.com/q/114762) its long-term value\
    \ by showing *why* this is a good solution to the problem, and would make it more\
    \ useful to future readers with other, similar questions.  Please [edit] your\
    \ answer to add some explanation, including the assumptions you've made.\n<|/\
    \ c |>\n<| a |>\nIn Ruby 1.9:\n<code>\na = [1,3,2]\na.inject(:+)\n</code>\n<|/\
    \ a dscore=5 tags=arrays,ruby |>\n<| c |>\nThis answer is better than the accepted\
    \ answer, because it does not need to scan the list twice.\n<|/ c |>\n<| c |>\n\
    Side note: this will throw an `ArgumentError: wrong number of arguments (0 for\
    \ 1+)` if `a` does not contain any numeric values.\n<|/ c |>\n<| c |>\nthis doesn't\
    \ work with a string: `NoMethodError: undefined method '+' for \"foo\":String`\n\
    <|/ c |>\n<| a tags=arrays,ruby dscore=5 |>\nHere is another solution which is\
    \ also not that complicated to understand for a beginner:\n<code>\na = [1,3,2]\n\
    (a.inject(:+) || 0)\n</code>\nThe advantage of this approach is that the || 0\
    \ part doesn't need any branching, which makes it easier to read.\n<|/ a |>\n\
    <| c |>\nThis answer is a lot better than the accepted answer, because it works\
    \ in Ruby 1.8.\n<|/ c |>\n<| c |>\nThanks i learned a new thing\n<|/ c |>\n<|\
    \ c |>\nThe accepted answer uses `inject`, which was introduced in Ruby 1.9.\n\
    <|/ c |>\n<| c |>\nYeah, that's why I mentioned in the comment above that it's\
    \ not ruby 1.8 compatible, sorry about that\n<|/ c |>\n<| c |>", "  sum = 0\n\
    \  product = 1\n  numbers.each do |num|\n    sum += num\n    product *= num\n\
    \  end\n  return sum, product\nend", "  sum = numbers.reduce(:+)\n  product =\
    \ numbers.reduce(:*)\n  [sum, product]\nend", "  sum = 0 \n  product = 1\n  numbers.each\
    \ do |n| \n    sum = sum + n \n    product = product * n\n  end\n  return [sum,\
    \ product]\nend", "\tsum_ = 0\n\tproduct_ = 1\n\tnumbers.each { |n| sum_ += n\
    \ }\n\tnumbers.each { |n| product_ *= n }\n\t[sum_, product_]\nend", "  return\
    \ (0..numbers.size-1).inject(:+) * numbers.reduce(:*)\nend", "    total = product\
    \ = 0\n    for number in numbers\n        total += number\n        product *=\
    \ number\n    end\n    [total, product]\nend", "    # Your code here\n    sum\
    \ = 0\n    product = 1\n    numbers.each do |number|\n        sum += number\n\
    \        product *= number\n    end\n    return sum, product\nend", "  if numbers.empty?\n\
    \    (0, 0)\n  else\n    numbers.length == 1 ? numbers.first * numbers.first :\
    \ (numbers.first * (numbers.last * sum_product(numbers[2..-1])))\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nThis answer is a little bit off base... I believe\
    \ that this code only works for positive numbers. I'm interested in the product\
    \ of positive numbers, not sum of positive numbers.\n<|/ c |>\n<| c |>\n, you're\
    \ absolutely right, my bad, I had the code set to sum the first and last element\
    \ of a list (since they were both numbers). I fixed it to give the product of\
    \ the numbers.\n<|/ c |>\n<| a tags=ruby |>\nRecursively calculate the product\
    \ of a list\n<code>", "  return numbers.inject([0]) do |(sum, product), number|\n\
    \    sum += number\n    product *= number\n    (sum, product)\n  end\nend", " \
    \ # TODO: You code goes here\n  sum = 0\n  product = 1\n  numbers.each do |number|\n\
    \    sum += number\n    product *= number\n  end\n  [sum, product]\nend", "  numbers.reduce(:+)\n\
    end", "    \n    numbers.reduce(:+)\n    numbers.reduce(:*)\nend\n</cell>\n<text>\n\
    The last two questions are going to be for you to solve.", "    sum = product\
    \ = 1\n    numbers.each_with_index do |n, i|\n      sum, product = sum*i, sum*(n-1)\n\
    \    end\n    sum, product\nend\n</cell>\n<text>\nProblem 3: Inverse of a number\
    \ using factorials", "  sum = numbers.inject { |sum, n| sum + n }\n  product =\
    \ numbers.inject { |product, n| product * n }\n  [sum, product]\nend", "  sum\
    \ = 0 \n  product = 1\n  numbers.each do |number| \n    sum += number\n    product\
    \ *= number\n  end\n  [sum, product]\nend", "    sum = numbers[0]\n    product\
    \ = 1\n    if numbers.size > 0\n        numbers.each do |num|\n            sum\
    \ += num\n            product *= num\n        end\n    end\n    return [sum, product]\n\
    end", "  sum, product = 0, 1\n  numbers.each do |n|\n    sum += n\n    product\
    \ *= n\n  end\n  [sum, product]\nend", "  product = 1\n  sum = 0", "  if numbers.empty?\n\
    \    []\n  else\n    numbers.inject(:+) * numbers.reduce(:*)\n  end\nend", " \
    \ sum = numbers[0]\n  product = 1\n  numbers.each do |n|\n    sum += n\n    product\
    \ *= n\n  end\n  [sum, product]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
