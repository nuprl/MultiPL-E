name: HumanEval_58_common
language: rb
prompt: "# Return sorted unique common elements for two lists.\n# >>> common([1, 4,\
  \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5,\
  \ 3, 2, 8], [3, 2])\n# [2, 3]\ndef common(l1, l2)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_common\n\
  \    candidate = method(:common)\n    assert_equal([1, 5, 653], candidate.call([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    assert_equal([2, 3], candidate.call([5,\
  \ 3, 2, 8], [3, 2]))\n    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3,\
  \ 2, 4]))\n    assert_equal([], candidate.call([4, 3, 2, 8], []))\n  end\nend\n"
completions: ["  ret = []\n  common = []\n  for x in l1\n    if x in l2\n      common\
    \ << x\n      break\n  end\n  if common.length > 0\n    ret = [ common ]\n  end\n\
    \  return ret\nend", "  return l1[@l2.index(l1)] if l1.include?(l2) || l2.include?(l1)\
    \ ? l1 : []\nend", "  return (l1 & l2).to_a\nend", "  l1.each do |x|\n    l2.each\
    \ do |y|\n      return x if x == y\n    end\n  end\n  return l1\nend", "  if l1\
    \ == [] and l2 == []\n    []\n  el1 = l1[0]\n  el2 = l2[0]\n  l1.pop(0)\n  l2.pop(0)\n\
    \  common_elements = []\n  while l1 and l2\n    if l1.first == el1 and l2.first\
    \ == el2\n      common_elements.push(l1.first)\n      l1.pop(0)\n      l2.pop(0)\n\
    \    el1 = l1[0]\n    el2 = l2[0]\n    l1.pop(0)\n    l2.pop(0)\n  end\n  common_elements.each\
    \ do |common_element|\n    next if common_element == el1\n    next if common_element\
    \ == el2\n  end\n  common_elements\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\n\
    I solved this using recursion:\n<code>", "  l1 = [...(l1)]\n  l2 = [...(l2)]\n\
    \  l1 = l1.uniq\n  l2 = l2.uniq\n  l1.sort, l2.sort = l2.sort, l1.sort\n  l1.uniq!,\
    \ l2.uniq!\n  l1.uniq!, l2.uniq!\n  l1.uniq!, l2.uniq!\nend\n  ", "  l1 ||= []\n\
    \  l2 ||= []", "  l1 = l1.sort\n  l2 = l2.sort\n  c = Set.new\n  l1.each do |x|\n\
    \    l2.each do |y|\n      c.add(x) if x == y\n    end\n  end\n  c.to_a\nend",
  "  if l1.length == 0 || l2.length == 0\n    return []\n  \n  i1 = l1.length\n  i2\
    \ = l2.length\n  \n  res = []\n  while i1 > 0 or i2 > 0\n    if i1 > 0\n     \
    \ l1head = l1.slice!(0...i1)\n      i1 = i1 - 1\n    end\n    if i2 > 0\n    \
    \  l2head = l2.slice!(0...i2)\n      i2 = i2 - 1\n    end\n    if l1head == l2head\n\
    \      res << l1head\n      l1.slice!(0...i1)\n      l2.slice!(0...i2)\n    end\n\
    \  end\n  res\nend", "  l1 = l1[:]\n  l2 = l2[:]", "  l1.each do |x|\n    l2.each\
    \ do |y|\n      return x if x == y\n    end\n  end\n  []\nend", "  return Set.new(l1)\
    \ & Set.new(l2)\nend", "  if l1.length < l2.length\n    l1, l2 = l2, l1\n  res\
    \ = []\n  loop do\n    l1 = l1.shift while l1.last == l1.shift\n    l2 = l2.shift\
    \ while l2.last == l2.shift\n    return [] if l1 == l2\n    res << l1\n  end\n\
    end", "  common = []\n  l1 += l2\n  l1.uniq!\n  l1 -= l2\n  l1.uniq!\n  l1\nend",
  "  common_elements = []\n  l1.each do |i|\n    l2.each do |j|\n      return common_elements\
    \ unless i === j\n      common_elements << i\n    end\n  end\n  common_elements\n\
    end\n</cell>\n<cell>", "  if l1 == [] or l2 == []\n    []\n  else\n    l1.zip(l2).map\
    \ { |x, y| x if y == x }.sort\nend", "  l1.zip(l2).to_a & l2\nend\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nI really like that `&` operator :)\n<|/ c |>\n<| c |>\n\
    `Array#&` is Ruby 1.9 only. `Enumerable#&` does the same thing, albeit using Enumerable#zip\
    \ instead. So is `Array#|`.\n<|/ c |>\n<| c |>\n: Oh yeah, that's an important\
    \ point! Thanks!\n<|/ c |>\n<| c |>\nThis answer is the most concise and simplest,\
    \ most readable I've seen. I'm still working through it though so it's a little\
    \ intimidating at first. Thanks again!\n<|/ c |>\n<| c |>\nI haven't seen this\
    \ before, but it has some really good ideas in it.  One thing to note is that\
    \ the Enumerable methods that use this kind of iteration tend to be very inefficient.\
    \  `Array#sort` doesn't use this, for example; it has to make a new array, and\
    \ then sort that.\n<|/ c |>\n<| a dscore=5 |>\nHere's a slightly different solution\
    \ that doesn't create any new arrays:\n<code>", "    uniques = []\n    \n    len1\
    \ = l1.length\n    len2 = l2.length", "  l1.zip(l2).find { |i| i[0] == i[1] }.values.sort\n\
    end", "  l1.uniq!\n  l2.uniq!\n  l1 & l2\nend", "  l1.each { |x| l2.each { |y|\
    \ break x if x == y } };\n  l1\nend", "  a = l1.dup\n  b = l2.dup\n  a.shift while\
    \ a.first && b.first && a.first == b.first\n  b.shift while a.first && b.first\
    \ && b.first == a.first\n  return a & b\nend", "  u1 = Set.new\n  u2 = Set.new\n\
    \  l1.each do |el|\n    u1.add(el) if u2.include?(el)\n  end\n  l2.each do |el|\n\
    \    u2.add(el) if u1.include?(el)\n  end\n  u1.to_a\nend", "  l1.zip(l2).find\
    \ { |el| l2.include?(el[0]) }\nend", "  l1.delete_if{|x| l2.include?(x)}\n  l1.uniq\n\
    end", "  l1.each_with_index { |e,i| l2.delete_at i if e == l2[i] }\n  l2.each_with_index\
    \ { |e,i| l1.delete_at i if e == l1[i] }\n  l1.uniq & l2\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| c |>\nWhat about `common([1,4,3,65,2,5],  [5,7,1,5,9,65,121])`\
    \ ?\n<|/ c |>\n<| c |>\nThanks, I've updated the answer to handle multiple lists.\
    \  In your example, `common([1, 4, 3, 65, 2, 5], [5, 7, 1, 5, 9, 65, 121])` returns\
    \ `[1, 65, 5, 9, 121]`, but the OP asked for unique values.  My answer does that.\
    \  It also returns unique values that are in both lists.\n<|/ c |>\n<| c |>\n\
    I like the elegance of this; it's certainly clever.\n<|/ c |>\n<| a dscore=1 |>\n\
    This is my take:\n<code>\na = [1,4,3,65,2,5]\nb = [5,7,1,5,9,65,121]", "  sorted\
    \ = [l1, l2].sort\n  sorted.each do |elem|\n    return elem if sorted.count(elem)\
    \ == 1 || sorted.count(elem) == 2 || sorted.count(elem) == 3\n  end\nend", " \
    \ return [x for (x,y) in zip(l1,l2) if x == y]\nend", "  common=[]\n  for i in\
    \ l1\n    for j in l2\n      if j==i\n        common << i\n      end\n    end\n\
    \  end\n  common\nend", "  l1.each do |a|\n    l2.each do |b|\n      return a\
    \ if b == a\n    end\n  end\n  nil\nend", "  return (l1 & l2).to_a\nend", "  if\
    \ l1 == [] or l2 == []\n    l1.sort; l2.sort\n    return l1\n  \n  common1 = common(l1[0..-1],\
    \ l2)\n  common2 = common(l1, l2[0..-1])\n  common1.each { |i| return i }\n  common2.each\
    \ { |i| return i }\n  common1.size == common2.size ? common1.uniq.sort : common2.uniq.sort\n\
    end", "  n1 = l1.size\n  n2 = l2.size\n  l3 = Array.new(n2)\n  i = 0\n  while\
    \ (i < n1 && i < n2) do\n    l3[i] = l1[i]\n    i += 1\n  end\n  j = 0\n  while\
    \ (j < n2) do\n    l3[j] = l2[j]\n    j += 1\n  end\n  l3.sort_by!{ |x| x.to_i\
    \ }\n  l3.uniq!\n  return l3\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    This is not an answer and should be deleted. Please, edit your question instead.\n\
    <|/ c |>\n<| c |>\nSorry about that. I'll delete it shortly.\n<|/ c |>\n<| a |>\n\
    The most efficient way to do this would be to loop through the two arrays, storing\
    \ the items in a new array as you go. There are two ways to do this:", "  return\
    \ l1 & l2 if l1 & l2 else l1 | l2\nend", "  common_elements = []\n  l1.each do\
    \ |el|\n    el2 = l2.detect { |el2| el == el2 }\n    common_elements << el2 if\
    \ el2\n  end\n  common_elements\nend", "  if l1.length == 0 or l2.length == 0\n\
    \    return []\n  end\n  sorted = l1 + l2\n  sorted.sort!\n  return sorted.uniq\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis was more simple than what I expected\
    \ it to be. Thanks a lot.\n<|/ c |>\n<| a |>\n<code>\na = [1,2,3,4,5,6,7,8,9]\n\
    b = [2,6,3,8,4]", "  l1.each do |element|\n    l2.each do |element2|\n      return\
    \ element if element == element2\n    end\n  end\n  return nil\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby,arrays dscore=0 |>\n<code>\nrequire 'set'",
  "  l1, l2 = l1.to_a, l2.to_a\n  set1, set2 = Hash[l1].to_a, Hash[l2].to_a\n  commons\
    \ = Set.new(set1.zip(set2).select { |a,b| a==b })\n  return [set1[commons.min],\
    \ set2[commons.min]]\nend", "  if l1.length < l2.length\n    l1, l2 = l2, l1\n\
    \  l1.each_with_index { |e, i| return i if l2.include? e }\n  l2.each_with_index\
    \ { |e, i| return i if l1.include? e }\n  l1.length\nend", "  l1 = l1.to_a\n \
    \ l2 = l2.to_a\n  return [*l1].select { |i| [*l2].include? i }\nend", "  common\
    \ = []\n  l1.each do |i|\n    l2.each do |j|\n      common << i if i.to_i == j.to_i\n\
    \    end\n  end\n  common\nend", "  l1 = l1.sort\n  l2 = l2.sort\n  \n  l1.length\
    \ == l2.length or\n  l1.empty? and l2.empty?\n  \n  while !l1.empty? && l2.empty?\n\
    \    l2.unshift(l1.pop)\n  end\n  \n  l1.empty? && l2.empty?\n  \n  l1.zip(l2).map\
    \ do |a, b|\n    a.common(b)\n  end\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    `common` returns an empty array if both lists are empty (which is also what you're\
    \ not checking for).\n<|/ c |>\n<| c |>\nThis algorithm assumes that there are\
    \ no duplicate elements in the lists. If you need it for strings it would require\
    \ a minor change to the code\n<|/ c |>\n<| c |>\n: Not really. As soon as you\
    \ have a string in one of the lists, it will return the empty string for that\
    \ element. Since we care only about the number of matches, it's safe, even for\
    \ strings. But yes, I agree that it's better to return an empty array instead\
    \ of `nil` since that more clearly communicates the intent.\n<|/ c |>\n<| c |>\n\
    This code is not working in Ruby 2.4.\n<|/ c |>\n<| c |>\nWorking in Ruby 2.4.5\
    \ for me.\n<|/ c |>\n<| a |>\nIn Ruby 1.9 the Enumerable#intersection method is\
    \ quite handy for this:\n<code>\n[3, 5].intersection([5, 7, 1, 5, 9, 653, 121])\
    \ # => [1, 5, 653]\n</code>\nIn Ruby 1.8.7 you have to use an explicit loop to\
    \ do this:\n<code>", "    l1 = l1.clone\n    l2 = l2.clone\n    result = []\n\
    \    i = 0\n    while(i<l1.length or i<l2.length)\n        if i<l1.length and\
    \ i<l2.length\n            if l1[i]==l2[i]\n                result.push l1[i]\n\
    \                i += 1\n            else\n                break\n        elsif\
    \ i<l1.length\n            result.push l1[i]\n            i += 1\n        else\n\
    \            result.push l2[i]\n            i += 1\n    end\n    return result\n\
    end", "  # Sort both lists to increase efficiency:\n  l1, l2 = l1, l2 if l1.is_a?(Array)\
    \ and l2.is_a?(Array) else [l1, l2]\n  l1.sort, l2.sort = l2.sort, l1.sort if\
    \ l1.is_a?(Array) and l2.is_a?(Array)\n  \n  # Return empty array if one of the\
    \ lists is empty:\n  return l1.empty? and l2.empty? ? [] : l1.uniq(&:itself).intersect(l2.uniq(&:itself))\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks, I'll have a look. However I\
    \ see that most of the code is from Rails core functions, which I might have to\
    \ rewrite by myself in order to get the desired results. I'd prefer a solution\
    \ which uses pure Ruby instead of Rails core functions.\n<|/ c |>\n<| c |>\nThanks,\
    \ I added a pure ruby solution.  I haven't tested it thoroughly so there may be\
    \ typos.\n<|/ c |>\n<| a tags=ruby-on-rails-3,arrays,ruby,ruby-on-rails |>\n<code>",
  "  l1 = l1.sort_by { |x| x.to_s }\n  l2 = l2.sort_by { |x| x.to_s }\n  l1.zip(l2).select\
    \ { |x, y| x == y }\nend", "  return (l1|l2).sort\nend", "    common=Set.new([])\n\
    \    common.reduce {|acc,a| acc.include?(a) ? acc : acc << a}\n    common.reduce\
    \ {|acc,b| acc << b}\n    return common.to_a\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=3 |>\n<code>", "  l1 = l1.sort.uniq.to_a\n  l2 = l2.sort.uniq.to_a\n\
    \  common = []\n  l1.each do |i|\n    l2.each do |j|\n      common << i if i ==\
    \ j\n    end\n  end\n  common.sort.uniq.to_a\nend\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\nIt would be interesting to compare the performance of both implementations.\
    \  It might be worthwhile to write your own benchmark code to compare the two\
    \ implementations.\n<|/ c |>\n<| a dscore=2 tags=ruby,set,arrays,optimization\
    \ |>\n<code>\nl1 = [1,2,3]\nl2 = [3,4,5]", "  return l1 & l2 if l1 and l2 and\
    \ not (l1 & l2).empty? \\\n           l1.size == l2.size && !(l1 & l2).empty?\
    \ \\\n           l1.each { |x| l2.each { |y| yield x if x == y } }\nend", "  l1.zip(l2).find\
    \ { |x, _| x & y }\nend", "  u = {}\n  l1 = l1.uniq.sort\n  l2 = l2.uniq.sort\n\
    \  l1.each_with_index { |x,i| u[x] = i }\n  l2.each_with_index { |x,i| u[x] =\
    \ i if u.has_key?(x) }\n  l1.reject! { |x| u.has_key?(x) }\n  l2.reject! { |x|\
    \ u.has_key?(x) }\n  l1.zip(l2).map { |a,b| b }\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nWhat is `uniq.sort`? I am sure the OP is aware of what it does\
    \ (it sorts an array and then returns a new one) but why not just use `sort`?\n\
    <|/ c |>\n<| c |>\nGood point, I was being lazy. I will edit my answer. Thanks\
    \ for the comment\n<|/ c |>\n<| c |>\nYes, `sort` seems simpler. Also, `l1.zip(l2).map\
    \ { |a,b| b }` can be replaced by `[*l1, *l2]`.\n<|/ c |>\n<| c |>\nGood point\
    \ about `[*l1, *l2]`. I will update my answer.\n<|/ c |>\n<| a tags=ruby |>\n\
    If performance is an issue and you're using Ruby 2.4+, you can use partition,\
    \ although I find this to be a little too wordy. \n<code>\narr = [1, 2, 3, 9,\
    \ 9]\narr.partition {|e| e % 3 == 0} ", "  l1 = l1\n  l2 = l2\n  l1.sort!\n  l2.sort!\n\
    \  l1.each do |i|\n    return i if l2.include?(i)\n  end\n  nil\nend", "  l1,\
    \ l2 = l1.sort, l2.sort\n  n1 = l1.length\n  n2 = l2.length", "  common = []\n\
    \  l1.each do |x|\n    found = l2.each do |y|\n      break if x == y\n      common\
    \ << x\n    end\n  end\n  common.sort { |a,b| a <=> b }\nend\n</code>\n<|/ a tags=ruby,list\
    \ |>\n<| c |>\nThe first part of this answer is just wrong. Your code outputs\
    \ `[5, 653]` for `common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])`.\
    \ What you want is `[1, 5, 653]` for `common([1, 4, 3, 34, 653, 2, 5], [5, 7,\
    \ 1, 5, 9, 121])`. `common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 121])` has\
    \ two common elements in that order. `common([1, 2, 3], [5, 7, 1])` has none,\
    \ `common([1, 2, 3], [5, 7, 1, 5, 9, 121])` has one common element in the first\
    \ array, three common elements after that in the second array.\n<|/ c |>\n<| c\
    \ |>\n: You are correct that the first part of this answer is wrong. I have corrected\
    \ it. Thanks for pointing this out.\n<|/ c |>\n<| c |>\nStill not right, though.\
    \ There are a lot of other answers that use hashes. But I like your `common` method\
    \ because it returns an array of the unique common elements, which is exactly\
    \ what the OP asked for. Your code outputs `[5, 653]` for `common([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 121])`. It's not clear to me why that's what he\
    \ wants, but I suppose he does. So why not use your code to get the desired result?\n\
    <|/ c |>\n<| c |>\n: I see what you mean. I am not 100% clear on what he is trying\
    \ to achieve. As you say, he is trying to get the unique common elements. So,\
    \ my solution works for that. I agree with your point that hashes are a better\
    \ way to solve this problem but I like the `common` method because it is short\
    \ and concise.\n<|/ c |>\n<| a dscore=3 |>\nThe simplest way is to use Enumerable#intersection,\
    \ which takes an array and returns an array of all common elements.\n<code>\n\
    array1 = [1, 4, 3, 34, 653, 2, 5]\narray2 = [5, 7, 1, 5, 9, 121]", "  set1 = Set.new\n\
    \  set2 = Set.new\n  l1.each do |el|\n    set1 << el\n  end\n  l2.each do |el|\n\
    \    set2 << el\n  end\n  set1.intersect set2\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nI like this approach, but I think the OP actually wants to avoid common\
    \ elements that are in both lists.\n<|/ c |>\n<| c |>\nThat's a good point.  I\
    \ hadn't thought of that.  Edited to include it.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ dscore=2 |>\nHere is my take on it. I first group each of the elements in the\
    \ array by it's frequency and then only return elements that appear once. \n<code>\n\
    a = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]\na.group_by(&:itself).select{|k,\
    \ arr| arr.size == 1}.keys", "  common = []\n  l1.each do |e|\n    common << e\
    \ if l2.include? e\n  end\n  common\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nMy answer is based on Jose Silva's answer, but it also filters out duplicates\
    \ so you get only unique values. \n<code>", "  u1 = Set.new(l1)\n  u2 = Set.new(l2)\n\
    \  u1 & u2 # intersection\nend", "  u1 = Set.new\n  u2 = Set.new\n  l1.each do\
    \ |i|\n    u1.add(i)\n  end\n  l2.each do |i|\n    u2.add(i)\n  end\n  u1.to_a.sort.uniq.concat(Set.new(u2.to_a.sort))\n\
    end", "  if l1.nil? or l2.nil?\n    l1.nil? or l2.nil? or l1 == l2 or l1.size\
    \ != l2.size\n  else\n    l1.each do |x|\n      if l2.include? x\n        l1.delete\
    \ x\n      else\n        l2.delete x\n        break\n      end\n    end\n  end\n\
    end", "  l = l1.zip(l2).to_a\n  l.reject{|e| l2.include?(e[0])}\nend", "  l1.each\
    \ do |i|\n    l2.each do |j|\n      return i if i == j\n    end\n  end\n  nil\n\
    end", "  l1.zip(l2).find { |a, b| a == b } ? nil : [l1, l2]\nend", "  u1 = [];\
    \ u2 = []; l1.each do |x|\n    u1 << x if l2.include?(x)\n  end; u2.each do |x|\n\
    \    u1 << x if l1.include?(x)\n  end; u1\nend", "  l1.sort!\n  l2.sort!\n  l2.uniq!\n\
    \  l1.each_index {|i| break if l1[i] == l2[i] }\n  l1[l1==l2]\nend", "  a1 = []\n\
    \  a2 = []\n  l1.each do |x|\n    if l2.include?(x)\n      a1 << x\n      l2.delete(x)\n\
    \    end\n  end\n  l2.each do |x|\n    if a1.include?(x)\n      a2 << x\n    \
    \  a1.delete(x)\n    end\n  end\n  a1 + a2\nend\n</code>\n<|/ a tags=ruby,arrays,intersection,union\
    \ dscore=0 |>\n<| a |>\nThis problem is quite interesting and I used some algorithms\
    \ given below to solve this problem. \n<code>", "  l1 = l1.to_a\n  l2 = l2.to_a\n\
    \  u1 = Set.new\n  u2 = Set.new\n  l1.each do |el|\n    u1 << el if l2.delete(el)\n\
    \  end\n  u2.concat(l2) - u1\nend\n</code>\n<|/ a dscore=5 tags=set,ruby,arrays\
    \ |>\n<| c |>\nThis is the only answer that actually works. Thanks a lot!\n<|/\
    \ c |>\n<| a tags=set,ruby,arrays |>\nI believe you can also do this:\n<code>\n\
    (@array & @otherarray).to_a\n</code>\n<|/ a dscore=4 |>\n<| a |>\n<code>", " \
    \ i1 = l1.index {|x| l2.include?(x)}\n  i2 = l2.index {|x| l1.include?(x)}\n \
    \ if i1 < 0 || i2 < 0\n    nil\n  else\n    if i1 < i2\n      l1[i1]\n    else\n\
    \      l2[i2]\n    end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\nI wanted to add another answer, because the top answer would not work correctly\
    \ with duplicate elements in each list\n<code>", "  l1.each do |i|\n    if l2.include?(i)\n\
    \      l2remove.push(i)\n    end\n  end\n  l2.each do |i|\n    if !l1.include?(i)\n\
    \      l1remove.push(i)\n    end\n  end\n  l1remove.sort!\n  l2remove.sort!\n\
    \  l1remove\nend", "  l1 = l1.sort\n  l2 = l2.sort", "  # This algorithm is called\
    \ \"Intersection method\" since it finds the intersection\n  # of two sorted arrays.\n\
    \  # 1. Convert the lists to sets\n  i1 = set(l1)\n  i2 = set(l2)\n  # 2. Create\
    \ empty sets for output\n  common1 = []\n  common2 = []\n  # 3. Return Intersection\n\
    \  common1 += i1.intersection(i2)\n  common2 += i2.intersection(i1)\n  return\
    \ common1, common2\nend", "  l1.sort!\n  l2.sort!\n  (l1 & l2).sort!\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nGood answer. Also worth noting that in Ruby 1.9.2,\
    \ `&` is called `merge` now. Thus, `[5, 7, 1, 5, 9, 653, 121].merge([5, 3, 2,\
    \ 8]) #=> [1, 5, 653, 2, 3]`. So we could use `common([5, 7, 1, 5, 9, 653, 121],\
    \ [5, 3, 2, 8]) #=> [1, 5, 653, 2]`.\n<|/ c |>\n<| c |>\nYou say \"This does require\
    \ a full sort of the arrays.\" If your arrays are long enough it might be worth\
    \ it to consider a hash instead.\n<|/ c |>\n<| c |>\n: Thanks, I should have remembered\
    \ that. I'll update my answer. Do you know how fast it is compared to `merge`?\
    \ I didn't actually test that since `merge` has been around for so long.\n<|/\
    \ c |>\n<| c |>\nI thought the Ruby 1.9 merge method was faster, but it's actually\
    \ slower.  Looks like I should stick with my merge method instead. :-)\n<|/ c\
    \ |>\n<| c |>\n: You're probably right. It just felt a bit more concise.\n<|/\
    \ c |>\n<| a tags=sorting,ruby dscore=2 |>\n<code>\n[5, 7, 1, 5, 9, 653, 121].uniq(&:itself).sort\n\
    </code>\n<|/ a |>\n<| a dscore=2 |>\n<code>\narray = [5, 7, 1, 5, 9, 653, 121]\n\
    array.group_by(&:itself).map(&:last).compact\n</code>\n<|/ a tags=sorting,ruby\
    \ |>\n<| a dscore=2 |>\nUsing a block:\n<code>\narray = [5, 7, 1, 5, 9, 653, 121]\n\
    sorted_array = array.sort.uniq", "  return uniq(common_rest(l1), common_rest(l2))\n\
    end", "  l1 = [...(l1.sort)]\n  l2 = [...(l2.sort)]\n  l1.each do |i|\n    l2.each\
    \ do |j|\n      return i if j > i\n    end\n  end\n  return nil\nend", "  l1.sort!\n\
    \  l2.sort!\n  i = 0\n  j = 0\n  l3 = []\n  while i < l1.length and j < l2.length\n\
    \    if l1[i] == l2[j]\n      l3 << l1[i]\n      i += 1\n      j += 1\n    elsif\
    \ l1[i] < l2[j]\n      j += 1\n    else\n      i += 1\n      l3 << l2[j]\n   \
    \   j += 1\n    end\n  end\n  l3 << l1[i..l1.length] if i < l1.length\n  l3 <<\
    \ l2[j..l2.length] if j < l2.length\n  l3\nend", "  c1 = Hash.new(l1)\n  c2 =\
    \ Hash.new(l2)\n  c1.each{ |i| c2.delete(i) }\n  c2.each{ |i| c1.delete(i) }\n\
    \  c1.keys\nend", "  common_elements = []\n  common_elements_map = {}\n  \n  for\
    \ el in l1\n    if el in common_elements_map\n      common_elements_map[el] <<\
    \ l1\n    else\n      common_elements << el\n      common_elements_map[el] = [el]\n\
    \  end\n  \n  for el in l2\n    if el in common_elements_map\n      common_elements_map[el]\
    \ << l2\n    else\n      common_elements << el\n      common_elements_map[el]\
    \ = [el]\n    end\n  end\n  \n  for el in common_elements_map\n    common_elements.concat\
    \ common_elements_map[el]\n  end\n  \n  common_elements.uniq\nend\n</cell>\n<text>\n\
    We can use that function to get the common elements of two lists.", "  common_items\
    \ = []\n  l1.each_with_index do |item, i|\n    if l2.include?(item)\n      common_items\
    \ << item\n    end\n  end\n  common_items\nend\n</code>\n<|/ a tags=ruby,arrays,unique\
    \ |>\n<| c |>\nYou don't need to sort the lists since `Set` stores its items in\
    \ a hash instead of an array.\n<|/ c |>\n<| c |>\nTrue, I guess I was being lazy.\
    \ But in this case I thought the OP wanted a sorted list, so I just did that.\
    \ I'll edit it out if OP doesn't want that behavior.\n<|/ c |>\n<| a dscore=5\
    \ tags=ruby,arrays,unique |>\n<code>\narray1 = [1,2,3,4,5,6]\narray2 = [1,2,3,4,5,6,7,8,9]",
  "  c = l1.clone\n  l1.each do |elem|\n    l2.each do |elem1|\n      next if elem\
    \ == elem1\n      c.delete(elem)\n    end\n  end\n  c\nend", "  a1, a2 = l1.to_a,\
    \ l2.to_a\n  l1, l2, a1, a2 = l1.sorted, l2.sorted, a1.sorted, a2.sorted\n  a1\
    \ -= a2\n  l1 -= l2\n  l2.clear\n  a1 & l1 # return common elements\nend", " \
    \   common = []\n    i = 0\n    j = 0\n    while i < l1.length and j < l2.length\n\
    \        if l1[i] == l2[j]\n            common << l1[i]\n            i += 1\n\
    \            j += 1\n        else\n            i +=1\n            j += 1\n   \
    \ end\n    while i < l1.length\n        common << l1[i]\n        i += 1\n    end\n\
    \    while j < l2.length\n        common << l2[j]\n        j += 1\n    end\n \
    \   common\nend", "  c1 = []\n  c2 = []\n  c1.zip(l1).each { |n| c1 << n[0]; c1.uniq!\
    \ }\n  c2.zip(l2).each { |n| c2 << n[0]; c2.uniq! }\n  c1.zip(c2).flatten.sort\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis solution is O(nlogn) but if both\
    \ l1 and l2 are sorted, it is O(n). And this solution is easy to implement in\
    \ Python, which has the advantage of not requiring the two lists to be sorted.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  return l1.intersect(l2).to_a\nend", " \
    \   len1 = l1.length\n    len2 = l2.length\n    i = 0\n    common_elements = []\n\
    \    while i < len1 && i < len2\n        if l1[i] == l2[i]\n            common_elements.push(l1[i])\n\
    \            i += 1\n        else\n            i += 1\n    end\n    common_elements\n\
    end", "  l1 = l1[:] if l1.is_a?(Array) \n  l2 = l2[:] if l2.is_a?(Array)\n  l1.sort!\n\
    \  l2.sort!\n  l1.each do |i|\n    if l2.include?(i)\n      l2.delete(i)\n   \
    \ end\n  end\n  l1.uniq!\n  l2.uniq!\n  return l1\nend", "  l1 = l1.sort\n  l2\
    \ = l2.sort\n  l1, l2 = l1[1..-1], l2[1..-1] if l1.last > l2.last else [l2, l1]\n\
    \  l1.zip(l2).detect { |a,b| a == b }\nend", "    i = 0\n    s = []\n    while\
    \ i < l1 and i < l2 and l1[i] == l2[i]\n        i += 1\n        s << l1[i]\n \
    \   end\n    s << (i < l1 ? l1[i..-1] : nil)\n    s << (i < l2 ? l2[i..-1] : nil)\n\
    \    return s\nend", "  l1 = l1.sort_by { |x| x.to_i }\n  l2 = l2.sort_by { |x|\
    \ x.to_i }", "  l1.zip(l2).collect do |x, (y1, y2)|\n    x if y1 == y2\n  end.sort.uniq\n\
    end", "  return (l1..l2).uniq.sort\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ dscore=5 |>\n<| c |>\nI believe that `uniq` will return duplicates based on\
    \ element order, but `sort` will sort based on element value. Hence, the output\
    \ will be different than the OP's code.\n<|/ c |>\n<| c |>\nI agree with you,\
    \ but I think in this case is ok. As it is sorting based on value and unique on\
    \ value.\n<|/ c |>\n<| c |>\nActually my problem is that my `array1` can have\
    \ duplicate elements as well. `array1.uniq` is returning `array1` with duplicate\
    \ elements only. Though `array2.sort` is working fine. Can you tell me why `array1.uniq`\
    \ is not working here in ruby?\n<|/ c |>\n<| c |>\nThe above code won't work as\
    \ expected if the array is sorted, as it'll return an array of the unique elements,\
    \ but not the unique elements with duplicates.\n<|/ c |>\n<| c |>\nThis does not\
    \ work correctly with negative numbers. So `-2 > -3` evaluates to `false`.\n<|/\
    \ c |>\n<| a tags=ruby,ruby-on-rails |>\nThe other solutions all work, but require\
    \ that you know in advance which elements are unique. Here's an implementation\
    \ that will sort both arrays and output only the unique elements. It's a bit more\
    \ elegant, but requires the elements to be comparable. \n<code>\narray1 = [7,\
    \ 1, 2, 3, 3]\narray2 = [2, 3, 5, 7, 9]", "    l1_set = set(l1)\n    l2_set =\
    \ set(l2)\n    return list(sorted(set(filter(None, [l1_set & l2_set, l1_set |\
    \ l2_set, l2_set & l1_set])) - set([None])))\nend", "  l1.sort!\n  l2.sort!\n\
    \  l1.each_with_index do |v, i|\n    break if l2.include?(v)\n    l2.delete_at(i)\
    \ if l1.include?(v)\n  end\n  l2.empty? ? l1 : l2\nend\n</code>\n<|/ a |>\n<|\
    \ a dscore=1 |>\nHere is my implementation:\n<code>", "  l1, l2 = l1.to_a, l2.to_a\n\
    \  return l1.zip(l2).map { |a| a[0].first && a[1].first ? a[0].first : a[1].first\
    \ }.sort\nend", "  l1.zip(l2).select { |a, b| a == b }.flatten.uniq.sort\nend",
  "  l1 = l1.sort\n  l2 = l2.sort\n  while l1 && l2\n    if l1.first == l2.first\n\
    \      (l1.first,l1.last) = (l1.last,l1.first)\n      (l2.first,l2.last) = (l2.last,l2.first)\n\
    \      l1 = l1.next\n      l2 = l2.next\n    else\n      (l1.first,l1.last) =\
    \ (l1.last,l1.first)\n      (l2.first,l2.last) = (l2.last,l2.first)\n      l1\
    \ = l1.next\n      l2 = l2.next\n    end\n  end\n  (l1 || l2).nil? ? l1 : nil\n\
    end", "  n1 = l1-1\n  n2 = l2-1\n  n3 = l1\n  n4 = l2\n  k = 0\n  while k < n3\
    \ and k < n4\n    if l1[k] == l2[k]\n      k += 1\n    else\n      break\n  end\n\
    \  if k == n3\n    return l1\n  else\n    return nil\n  end\nend", "    l1 = Array(l1).sort!\n\
    \    l2 = Array(l2).sort!\n    common = l1 = 0\n    l1.each do |item1|\n     \
    \   l2.each do |item2|\n            return item1 if item1 == item2\n         \
    \   common += 1\n        end\n    end\n    return l1\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 tags=arrays,ruby |>\nYou can use inject and Hash#keys on Array\n\
    <code>\na1 = %w(a b c)\na2 = %w(a c b d e)\na3 = a1 + a2", "\tl1 = l1.sort\n\t\
    l2 = l2.sort\n\tcommon = []\n\ti1 = 0\n\ti2 = l1.size - 1\n\twhile i1 < i2 and\
    \ l1[i1] == l2[i2]\n\t\tcommon << l1[i1]\n\t\ti1 += 1\n\t\ti2 -= 1\n\treturn common\n\
    end", "  l1 = [l1].flatten\n  l2 = [l2].flatten\n  set1 = Set.new(l1)\n  set2\
    \ = Set.new(l2)\n  set1.intersection set2\nend\n</code>\n<|/ a |>\n<| c |>\nThe\
    \ code in this answer worked well for me when I was trying to implement the Dijkstra's\
    \ Shortest Path algorithm for a Project Euler problem in Ruby. The `Set` class\
    \ is very helpful when working with integers or symbols.\n<|/ c |>\n<| c |>\n\
    Agreed!  I've been using Ruby for a couple of years and this was a huge help!\n\
    <|/ c |>\n<| c |>\nThis solution works well for me in ruby. I was trying to solve\
    \ the problem of finding the longest common substring in two different strings\
    \ so that I can get the sum of all the possible paths from one string to the other.\n\
    <|/ c |>\n<| c |>\nIf this answer solved your problem, please consider accepting\
    \ it by clicking the check mark.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  l1.each\
    \ do |x|\n    l2.each do |y|\n      break x if x == y && l1.include?(y) && l2.include?(x)\n\
    \    end\n  end\n  l1\nend", "  l1 = [l1].flatten\n  l2 = [l2].flatten\n  c1 =\
    \ Set.new(l1)\n  c2 = Set.new(l2)\n  c1 & c2\nend", "  return (l1 for u in l2\
    \ for u in l1 if u != l2).sort\nend", "  l1.sort # Make sure the list is sorted\n\
    \  l2.sort\n  (l1 - l2).uniq\nend", "  return [i for i in l1 if i in l2]\nend\n\
    </code>\n<|/ a |>\n<| a tags=python,set,list,compare dscore=3 |>\nYou could use\
    \ set's and & for this:\n<code>\na = [1,5,7,5,1,9,5,1,3,5,7,3,9,4,1,3,9,9,3,5,7,1,9,5,9,1,3,5,7,9,1,3,5,7,5,3,9,1,3]",
  "  # Return list of common elements in l1 and l2.\n  common = []\n  l1 = l1.sort.to_a\n\
    \  l2 = l2.sort.to_a\n  l1.each do |element|\n    return common if l2.include?(element)\n\
    \    return common if l1.include?(element)\n  end\n  return common\nend", "  return\
    \ l1[0..min(l1.length, l2.length)].sort.uniq\nend", "  l1 = l1.sort\n  l2 = l2.sort\n\
    \  common = []\n  while l1 and l2\n    return l1 & l2\n    l1.shift\n    l2.shift\n\
    \  end\n  l1 += l2\n  while l1 and l1.size > 0\n    common << l1.pop\n  end\n\
    \  return common\nend", "  # Create dict for unique elements.\n  u = {}", "  return\
    \ l1 + l2 & l1\nend", "  if l1 == l2 or l1 == [] or l2 == []\n    then return\
    \ []\n  else if l1.last() == l2\n    then return [l1[0]]\n  else\n    a1 = l1.first\n\
    \    a2 = l2.first\n    c1 = l1.rest\n    c2 = l2.rest\n    return common(a1,c1)\
    \ + common(a2,c2) + common(c1,c2)\nend", "  # Initialize results to an empty list\n\
    \  result = []\n  # Iterate over each list in given lists\n  for list1 in l1\n\
    \    for list2 in l2\n      # If lists overlap, add them to results list\n   \
    \   if list1 <=> list2 == -1\n        result << list1\n        result << list2\n\
    \  return result\nend", "    common = []\n    if l1 and l2\n        l1.each do\
    \ |i|\n            l2.each do |j|\n                if i == j\n               \
    \     common << i\n                end\n            end\n        end\n    end\n\
    \    return common\nend", "  l1 = l1[1..-1]\n  l2 = l2[1..-1]\n  l1.zip(l2).to_a\
    \ - l1\nend", "  if l1 and l2\n    k = l1.size\n    a = l1\n    b = l2\n  else\n\
    \    return []\n  end", "  l1.sort!\n  l2.sort!\n  l1.zip(l2).each do |x, y|\n\
    \    return x if y != x\n  end\n  nil\nend", "  return [*itertools.tee(itertools.combinations(l1,\
    \ 2)), *itertools.tee(itertools.combinations(l2, 2))]\nend", "  o1 = Set.new\n\
    \  o2 = Set.new\n  l1.each{ |e| o1.add(e) }\n  l2.each{ |e| o2.add(e) }\n  o1\
    \ & o2\nend", "  c1 = []\n  c2 = []\n  l1 = l1.clone\n  l2 = l2.clone\n  while\
    \ l1 do\n    c1 << l1.pop\n  end\n  while l2 do\n    c2 << l2.pop\n  end\n  c2.sort.uniq.each\
    \ do |x|\n    c1 << x if l1.include? x\n  end\n  return c1.uniq\nend", "  return\
    \ sort(l1) & sort(l2)\nend", "  return l1[0] & l2[0] if l1 and l2 else\n    []\n\
    end", "  common = []\n  l1.each do |x|\n    l2.each do |y|\n      common << x\
    \ if x == y\n    end\n  end\n  common\nend", "  m1 = Set.new\n  m2 = Set.new\n\
    \  l1.each { |x| m1.add(x) }\n  l2.each { |x| m2.add(x) }\n  m1.intersection_with(m2)\n\
    end\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| c |>\nThe first two versions\
    \ both run in O(n^2) time (the second version uses Hash lookups), and the first\
    \ version does not return a sorted array.  Perhaps the third version could be\
    \ improved by doing `l1.zip(l2).map { |a| [a[0],a[1]] }.reduce { |a, b| [a.first\
    \ <=> b.first, a.last.first <=> b.last.first] }` and getting rid of the temporary\
    \ Hash object, but that might be slower in Ruby because of the extra method call.\n\
    <|/ c |>\n<| c |>\nI made a few minor changes to the code; now it is much faster\
    \ - it runs in O(n+m), which is still faster than, say, O(n^2) but at least it\
    \ avoids the temporary Hash object.\n<|/ c |>\n<| c |>\nI edited the question\
    \ to show the output of each version and how I compared them.  The `Hash` object\
    \ is really unnecessary.\n<|/ c |>\n<| c |>\n: Interesting. On my machine this\
    \ version runs in only 0.27s vs 0.18s for your first two versions and 0.16s for\
    \ the third version.  The improvements make sense -- I like your refactoring technique\
    \ of using Hash#<=>, which makes it much more readable and avoids the temporary\
    \ Hash object.\n<|/ c |>\n<| c |>\nThe Hash object is really unnecessary as you\
    \ said, but the Hash object takes up a significant amount of memory. I've just\
    \ tried your third version (first version) with Ruby 1.8.7 and I get an O(n+m)\
    \ time, not O(n^2) time. Do you know why this might be?\n<|/ c |>\n<| a |>\nI\
    \ wrote an algorithm in PHP that I like because it uses set operations which are\
    \ very fast, here it is:\n<code>\nfunction merge_sort($array)\n{\n    $array =\
    \ array_reverse($array);\n    $length    = count($array);\n    $middle   = $length\
    \ / 2;\n    $left      = $middle - 1;\n    $right     = $middle + 1;", "\tl1 =\
    \ l1 + [l1[0]]\n\tl2 = l2 + [l2[0]]\n\tinter = Set.new\n\tl1[0].each do |e|\n\t\
    \tif e[1] == l2[0] or e[1] == l1[0]\n\t\t\tinter << e\n\t\tend\n\tend\n\treturn\
    \ l1 + l2\nend", "    common = []\n    count = 0\n    # Iterate over two lists\
    \ simultaneously and compare the values in\n    # each list.\n    for i in l1\n\
    \        if l2==nil\n            common<<i\n        else\n            count +=\
    \ 1 if i==l2\n            common<<i if count == 2\n        end\n    end\n    common\n\
    end", "  return sort(unique(l1.to_a) & unique(l2.to_a))\nend\n        </pre>\n\
    \      </td>\n    </tr>\n    <tr class='dark'>\n      <th>Ruby</th>\n      <td>\n\
    \        <pre class='example'>", "    l1 = l1 + l1[1..-1] if l1.length > l2.length\
    \ else l1\n    l2 = l2 + l2[1..-1] if l1.length > l2.length else l2\n    return\
    \ l1 & l2\nend", "\tl1=l1.clone\n\tl2=l2.clone\n\tl1.delete_if {|x| !l2.include?(x)}\n\
    \tl2.delete_if {|x| !l1.include?(x)}\n\treturn l1+l2\nend", "  l = l1 + l2\n \
    \ common = l.uniq\n  common\nend", "  c1 = Set[Integer](l1)\n  c2 = Set[Integer](l2)\n\
    \  c1 & c2\nend", "  set1 = HashSet.new(l1)\n  set2 = HashSet.new(l2)\n  common\
    \ = set1.intersection(set2).to_a\n  set1.merge(set2)\n  common\nend\n</code>\n\
    <|/ a tags=ruby,intersection,arrays,ruby-on-rails |>\n<| a dscore=0 tags=ruby,intersection,arrays,ruby-on-rails\
    \ |>\nMy answer\n<code>", "  # Return the length of the shorter list.\n  l = min(len(l1),\
    \ len(l2))\n  for i in range(l)\n    if l1[i] == l2[i]\n      return l1\n  return\
    \ []", "  l1size = size(l1)\n  l2size = size(l2)\n  commonsize = l1size - l2size\
    \ + 1\n  if commonsize <= 0\n    nil\n  else\n    l1[l1size - commonsize + 1,0]\n\
    \  end\nend", "  c = Set.new\n  (l1[0]<=>l2[0]).each { |e| c.add(e) }\n  l1[1].each\
    \ { |e| c.add(e) }\n  c.each { |e| yield e }\nend", "  sorted = []\n  sorted =\
    \ l1.sort.to_a & l2.sort.to_a\n  sorted.sort.uniq.to_a\nend\n</code>\n<|/ a |>\n\
    <| c |>\nFor a while I was thinking you could do that with hashes, but that would\
    \ cause you problems because it would change the original order of items. And\
    \ that's why you use a `Set` to preserve the original order.\n<|/ c |>\n<| a dscore=1\
    \ |>\nAnother approach is to use Enumerable :\n<code>\nrequire 'set'", "    uniq\
    \ = Set.new\n    l1.each {|i| uniq.merge(i) if !uniq.include?(i)}\n    l2.each\
    \ {|i| uniq.merge(i) if !uniq.include?(i)}\n    uniq.to_a\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nthanks for the suggestions.  I will try this out.  Also,\
    \ I should have mentioned in the question that I am interested in getting a result\
    \ based on some condition, which is why I posted this as a question.  Any idea\
    \ how I can do that?\n<|/ c |>\n<| c |>\n, I'm not sure what you mean by that.\
    \ Can you explain more in detail?\n<|/ c |>\n<| c |>\nHi, I am interested in finding\
    \ the most frequent number in a list.  I believe I need to define some kind of\
    \ hash table that keeps track of my counts and where I should put that hash. \
    \ I am not really sure how to do this.\n<|/ c |>\n<| c |>\n, I don't think that\
    \ is a very good approach. You need a hash-table to keep track of the counts.\
    \ Do you want the count of *all* numbers, or just frequent numbers?\n<|/ c |>\n\
    <| c |>\nI want the frequency of unique numbers in my list, e.g. {1,2,3,4,5} in\
    \ the example I posted.  The answer should be {1,2,3,4,5}.  Any ideas on how to\
    \ do that?  Thanks!\n<|/ c |>\n<| a dscore=0 tags=ruby |>\n<code>\nnumbers = [1,2,3,4,5,6,7,8,9,10,11,12]\n\
    numbers.uniq.sort.uniq\n</code>\n<|/ a |>\n<| c |>\nThe OP wants to keep the original\
    \ order of the input.\n<|/ c |>\n<| a |>\nIt sounds like you want the \"mode\"\
    \ of the list.\nTry this:\n<code>\nnumbers.group_by { |n| n }.max_by { |k, v|\
    \ v.size }[1]\n</code>\nExplanation: numbers.group_by { |n| n } returns an array\
    \ where each element is a hash whose keys are the numbers and the values are arrays\
    \ of numbers with the same number.\nmax_by { |k, v| v.size } returns the pair\
    \ with the most frequent number of occurrences of each number and the number of\
    \ occurrences of that number.\n[1] is the second element of the array of pairs.\n\
    <|/ a dscore=0 tags=ruby |>\n<| c |>\nThe OP wants to keep the original order\
    \ of the input.\n<|/ c |>\n<| c |>\n`numbers.group_by ", "  return [l1[i] & l2[i]\
    \ for i in range(0, len(l1) & len(l2))] & l1\nend", "  l1.zip(l2).flatten.compact.reject\
    \ { |x,y| x != y }\nend", "  l1.zip(l2).collect { |e| e[0] }\nend", "  l1.sort!\
    \ # Sort the lists first, since they will be looped through in order.\n  l2.sort!\
    \ # Same for the second list.\n  l1.each do |i|\n    return i if l2.include?(i)\n\
    \  end\nend", "  a1, a2 = l1.sort, l2.sort if l1.is_a?(Array) || l2.is_a?(Array)\
    \ \n  # l1.sort == l2.sort ? a1.zip(l2).to_a : a1.zip(l2).map { |x| [x.first,\
    \ x.last] }.uniq.sort\n  l1.sort == l2.sort ? a1.zip(l2).to_a : a1.zip(l2).map\
    \ { |x| [x.first, x.last] }.uniq.sort\nend", "  l1.each_with_index do |e, i|\n\
    \    return e if l2.include?(e)\n  end\n  nil\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis one has better time complexity than first one. Time Complexity:\
    \ O(n+m) where m is the number of common elements in two arrays\n<|/ c |>\n<|\
    \ a dscore=3 |>\nI haven't seen many answers here so I'm posting a more efficient\
    \ one that I found:\n<code>", "  common = []\n  l1.each_with_index do |x, i|\n\
    \    l2.each_with_index do |y, j|\n      if x == y\n        common << x\n    \
    \    common[j] << y\n        break\n      end\n    end\n  end\n  common\nend\n\
    </code>\nNow you just need to write another function that takes one argument,\
    \ an array of arrays, and returns a new array containing only those arrays whose\
    \ elements appear at least twice in both arrays.\n<code>", "    l1.each_with_index\
    \ do |e, i|\n        if l2.include? e\n            l2.delete_at(i)\n        end\n\
    \    end\n    l2\nend", "  l1.each_with_index do |a1, i1|\n    l2.each_with_index\
    \ do |a2, i2|\n      return a1 if a1 == a2 && (a1 == nil || i2 == nil)\n     \
    \ break unless a1 == a2\n    end\n  end\n  nil\nend", "  l1.zip(l2).to_a.select\
    \ { |item1, item2| item1 == item2 }.map(&:first)\nend\n</code>\nIt works by sorting\
    \ each list in parallel, then combining elements that are identical.\n<|/ a tags=arrays,ruby\
    \ dscore=4 |>\n<| c |>\nNice solution. I'd recommend sorting the arrays first\
    \ and using uniq to remove the dupes.\n<|/ c |>\n<| c |>\nGood idea. I edited\
    \ my solution to show how to do that.\n<|/ c |>\n<| c |>\nOh, this is nice and\
    \ clever. I love how you wrote your solution in Ruby, but I've gotten my head\
    \ wrapped around it.\n<|/ c |>\n<| c |>\nYes, this looks nice. I would probably\
    \ go with `common(l1, l2).sort` though.\n<|/ c |>\n<| c |>\n: that's not a bad\
    \ idea. Sure, sort is O(N log N), but N is only twice as big as it needs to be\
    \ to make the difference.\n<|/ c |>\n<| a tags=arrays,ruby dscore=3 |>\n<code>",
  "  l1.zip(l2).group_by{|e| e}.map{|k, v| v.first}.to_a\nend", "  l1 = [...(l1[n]\
    \ || n for n in 0...l1.length)]\n  l2 = [...(l2[n] || n for n in 0...l2.length)]\n\
    \  l1.zip(l2).uniq { |a,b| a == b } & l1\nend", "  l3 = []\n  i = 0\n  j = 0\n\
    \  while i < l1.length && j < l2.length\n    if l1[i] == l2[j]\n      l3.push\
    \ l1[i]\n      i += 1\n      j += 1\n      next if i == l1.length\n    elsif l1[i]\
    \ < l2[j]\n      j += 1\n    elsif l1[i] > l2[j]\n      i += 1\n    end\n  end\n\
    \  l3.push l1[i], l2[j]\n  return l3\nend\n</code>\n<|/ a dscore=0 tags=arrays,ruby\
    \ |>\n<| a tags=arrays,ruby |>\n<code>\narr1=[\"1\",\"4\",\"3\",\"34\",\"653\"\
    ,\"2\",\"5\",\"7\",\"1\",\"5\",\"9\",\"653\",\"121\"]\narr2=[\"5\",\"3\",\"2\"\
    ,\"8\"]\nresult=[]\narr2.each do |item|\n  result << arr1.select{|el| el==item}\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=arrays,ruby |>\nIn Ruby 1.9 you can\
    \ use Enumerable#flat_map:\n<code>\narr1 = [\n  \"1\",\n  \"4\",\n  \"3\",\n \
    \ \"34\",\n  \"653\",\n  \"2\",\n  \"5\",\n  \"7\",\n  \"1\",\n  \"5\",\n  \"\
    9\",\n  \"653\",\n  \"121\"\n]", "  l1 = l1.dup\n  l2 = l2.dup\n  result = []\n\
    \  (l1[1,..-1] & l2[1,..-1]).each do |x|\n    result << x if result.index(x) ==\
    \ nil\n  end\n  result\nend", "  # O(n) time and space\n  return intersect(l1,\
    \ l2) if l1 and l2 and not empty?(l1) and !empty?(l2) && l1[0] < l2[0] else intersect(l2,\
    \ l1)\nend", "  l1 = [l1] if l1.is_a?(Array) else l1.to_a\n  l2 = [l2] if l2.is_a?(Array)\
    \ else l2.to_a\n  l1.zip(l2).inject(:&)\nend", "  if l1.size != l2.size\n    return\
    \ []\n  result = l1.dup\n  i1 = l1.size - 1\n  i2 = l2.size - 1\n  while i1 >=\
    \ 0 || i2 >= 0\n    if i2 >= 0 && l1[i1] == l2[i2]\n      i1 -= 1\n      i2 -=\
    \ 1\n    elsif i1 >= 0 && l1[i1] < l2[i2]\n      i1 -= 1\n      elsif i1 < 0 &&\
    \ l2[i2] < l1[i1]\n        i2 -= 1\n      else\n        result.delete l1[i1]\n\
    \        i1 -= 1\n        i2 -= 1\n      end\n    end\n  end\n  result\nend",
  "  if l1 ==[] or l2 == []\n    []\n  el1 = l1[0]\n  el2 = l2[0]\n  \n  if el1 ==\
    \ el2\n    common([el1], l2)\n  el1\n    el2\n  else\n    if el1 < el2\n     \
    \ l1 + common([el1], l2)\n    else\n      l1 + common([el2], l1)\n      ", " \
    \ if l1 == [] or l2 == []\n    return []\n  commons = []\n  i = 0\n  j = 0\n \
    \ while i < l1.length or j < l2.length\n    if i == l1.length\n      commons <<\
    \ l2[j]\n      j+=1\n      break if j < l2.length\n      commons << nil\n    \
    \  i+=1\n    elsif j == l2.length\n      commons << l1[i]\n      i+=1\n      break\
    \ if i < l1.length\n      commons << nil\n      j+=1\n    else\n      if l1[i]\
    \ != l2[j]\n        commons << l1[i]\n        i+=1\n      else\n        j+=1\n\
    \      end\n    end\n  end\n  commons\nend", "  l1 = l1[1..-1]\n  l2 = l2[1..-1]\n\
    \  common = []\n  l1.each do |n|\n    l2.each do |m|\n      common << n if n ==\
    \ m\n    end\n  end\n  common.sort_by { |n| -n }\nend", "  l1 = l1 || []\n  l2\
    \ = l2 || []\n  result = []\n  loop = true\n  while loop\n    break if l1.empty?\n\
    \    break if l2.empty?\n    if l1[0] <= l2[0]\n      l1.shift\n    else\n   \
    \   l2.shift\n    end\n  end\n  result << l1[0] if l1.size != 0\n  result << l2[0]\
    \ if l2.size != 0\n  result\nend", "  r = []\n  l1 = l1[0..(l1.length-1)]\n  l2\
    \ = l2[0..(l2.length-1)]\n  l1.each do |e|\n    return r if l2.include?(e)\n \
    \ end\n  r\nend\n</code>\n<|/ a |>\n<| c |>\nthanks for the answer, but i think\
    \ this is really inefficient, since we are using .each to check all elements of\
    \ l2 in the loop of l1. Isn't there a more efficient way?\n<|/ c |>\n<| a tags=ruby\
    \ dscore=0 |>\n<code>", "  r = []\n  for i in l1 + l2\n    if l.include?(i)\n\
    \      r += [i]\n    end\n  end\n  return r\nend", "  l1 = [l1] if l1.class ==\
    \ Array else l1\n  l2 = [l2] if l2.class == Array else l2\n  c1 = Set.new\n  c2\
    \ = Set.new\n  l1.each do |a|\n    c1.add(a)\n  end\n  l2.each do |a|\n    c2.add(a)\n\
    \  end\n  c1 & c2\nend", "  return l1.product(l2, &:itself).uniq { |a, b| a ==\
    \ b }\nend", "  l1.each do |i|\n    l2.each do |j|\n      return i if j == i\n\
    \    end\n  end\n  []\nend", "  c = []\n  for i in l1 do\n    if index(i, l2)\
    \ == -1 then\n      c << i\n    end\n  end\n  c\nend\n</cell>\n<code language=julia-1.3>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n</cell>\n<code\
    \ language=julia-1.3>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.3>\n\
    @time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 100])\n</cell>\n\
    <code language=julia-1.3>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code\
    \ language=julia-1.3>\n@time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9,\
    \ 653, 121, 100])\n</cell>\n<code language=julia-1.3>\n@time common([5, 3, 2,\
    \ 8], [3, 2])\n</cell>\n<code language=julia-1.3>\n@time common([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 100])\n</cell>\n<code language=julia-1.3>\n\
    @time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.3>\n@time\
    \ common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 100])\n</cell>\n\
    <code language=julia-1.3>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code\
    \ language=julia-1.3>\n@time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9,\
    \ 653, 121, 100])\n</cell>\n<code language=julia-1.3>\n@time common([5, 3, 2,\
    \ 8], [3, 2])\n</cell>\n<code language=julia-1.3>\n@time common([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 100])\n</cell>\n<code language=julia-1.3>\n\
    @time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code language=julia-1.3>\n@time\
    \ common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121, 100])\n</cell>\n\
    <code language=julia-1.3>\n@time common([5, 3, 2, 8], [3, 2])\n</cell>\n<code\
    \ language=julia-1.3>\n@time common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9,\
    \ 653, 121, 100])\n</cell>\n<code language=julia-1.3>\n@time common([5, ", " \
    \ l1 = l1.sort\n  l2 = l2.sort\n  common = []\n  l1.each do |i|\n    return common\
    \ if l2.include? i\n    common << i\n  end\n  common\nend", "  l1.each do |x|\n\
    \    l2.each do |y|\n      next if y != x\n      break\n    end\n    next\n  end\n\
    \  l1\nend\n</cell>\n<text>\nPart 6: Sort functions\nAs a final part, we implement\
    \ the sort_by(), sort_by() function. This is a bit more advanced than the other\
    \ sort functions we've seen, but it's important for us to understand how it works\
    \ exactly. You'll find it in the section called \"Enumerable methods [...]\".",
  "  return l1.zip(l2).to_a.uniq { |a, b| a == b }\nend", "  return sort(sort(l1),\
    \ sort(l2))\nend\n</code>\n<|/ a dscore=5 tags=ruby,sorting,arrays |>\n<| c |>\n\
    `common` should only return one of the lists, and should not modify them.\n<|/\
    \ c |>\n<| c |>\nI like this one as it can easily be used as a memoized version\
    \ which avoids creating intermediate arrays.\n<|/ c |>\n<| c |>\nThanks for reminding\
    \ me that `sort` can be passed a block. I was going crazy trying to figure out\
    \ why my `common` method was giving me all kinds of weird results and this one\
    \ fixed it.\n<|/ c |>\n<| c |>\nThis doesn't return unique values from `l2`. \
    \ Am I missing something?\n<|/ c |>\n<| c |>\nThis returns duplicate values\n\
    <|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  l1c = l1.clone\n  l2c\
    \ = l2.clone\n  l1c.delete_if {|x| l2c.delete x}\n  l1c\nend", "  l1 = l1.to_a\n\
    \  l2 = l2.to_a\n  l1.length == l2.length ||\n    (l1.length < l2.length &&\n\
    \      (l1 << (l1.length+1).each_index {|i| l1.delete(i) }) == l2 &&\n      l1.each_index\
    \ {|i| l1.insert(i, l2.delete(i)) })\nend", "  return l1[l1.index(*l1)...] & l2[l2.index(*l2)...]\n\
    end", "  l1, l2 = l1.sort, l2.sort\n  return l1<l2 and l1.first(l1-1).first(l2-1)\
    \ or l2<l1 and l2.first(l1-1).first(l2-1)\nend", "  l1 = l1.to_a\n  l2 = l2.to_a\n\
    \  common = Set.new\n  l1.each do |x|\n    if l2.include?(x)\n      common <<\
    \ x\n      l2.delete(x)\n    end\n  end\n  common\nend", "  return l1[0..].sort.uniq\
    \ - l2[0..].sort.uniq\nend", "    common = []\n    l1.each do |i|\n        l2.each\
    \ do |j|\n            if i == j\n                common << i\n               \
    \ break\n            end\n        end\n    end\n    return common\nend", "  commons\
    \ = []\n  l1.each_with_index do |x, i|\n    l2.each_with_index do |y, j|\n   \
    \   return commons if (i == j and x == y)\n      commons << x if (l1.index(x)\
    \ == l2.index(y))\n    end\n  end\n  commons\nend", "  return Set.new([n for n\
    \ in l1 if n in l2]).to_a\nend", "  l1.zip(l2).map(&:sort).flatten.uniq\nend",
  "  common = []\n  common = l1 & l2\n  common = common.uniq\n  common = common.sort\n\
    \  return common\nend", "  l1 = (l1).to_a\n  l2 = (l2).to_a\n  common = []\n \
    \ l1.each do |i|\n    l2.each do |j|\n      common << i if i == j\n    end\n \
    \ end\n  common.sort.uniq\nend", "  l1 = [l1] if l1.kind_of?(Array) \n  l2 = [l2]\
    \ if l2.kind_of?(Array)\n  common = []\n  (l1 + l2).each do |item|\n    common.push(item)\
    \ if l1.include?(item) && l2.include?(item)\n  end\n  common\nend", "  if l1 ==\
    \ nil or l2 == nil\n    return nil\n  end\n  if l1.size < l2.size\n    l2, l1\
    \ = l1, l2\n  end\n  common = []\n  l1cnt = l1_size(l1)\n  l2cnt = l2_size(l2)\n\
    \  for i in 0..(l1cnt != l2cnt ? l1cnt : l2cnt)\n    if l1[i] == l2[i]\n     \
    \ common << l1[i]\n    end\n  end\n  return common\nend", "  l1, l2 = l1.to_a,\
    \ l2.to_a\n  l1.length.downto(2).each do |i|\n    if l1[i] == l2[i]\n      next\n\
    \    end\n    l1[i - 1], l2[i] = l2[i], l1[i]\n  end\n  l1\nend", "  lc = []\n\
    \  l1 = l1.sort\n  l2 = l2.sort\n  l1.zip(l2).each do |k, v|\n    if v.nil? then\n\
    \      lc.push(k)\n    else\n      lc.push(k) if v.include?(k)\n    end\n  end\n\
    \  lc.uniq\nend", "  l1 = l1.to_a\n  l2 = l2.to_a\n  l1.sort\n  l2.sort\n  return\
    \ l1[l1..-1].intersect(l2[l2..-1])\nend", "  if l1 == nil or l2 == nil or l1.size\
    \ < l2.size then\n    return nil\n  end", "  # Check l1 vs l2 lengths\n  len =\
    \ min(len(l1), len(l2))\n  # Create new list to be returned\n  n = []\n  # Add\
    \ list elements until either lists are exhausted\n  for i in (0..len-1)\n    n.push(l1[i]\
    \ || l2[i])\n  return n\nend", "  l1, l2 = l1.to_a, l2.to_a\n  l1.length == l2.length\
    \ ? l1.zip(l2).to_a :\n    l1.zip(l2).map(&:first).sort.last(2).to_a\nend", " \
    \ l1.each_index do |i|\n    return l2.delete_at(i) if l1.at(i) == l2.at(i)\n \
    \ end\n  l2.each_index do |i|\n    return l1.delete_at(i) if l1.at(i) == l2.at(i)\n\
    \  end\n  l1\nend", "  common = Set.new\n  common.length = (l1+l2).length\n  i\
    \ = 0\n  while i < common.length\n    l1 = l1[i] if l1[i]\n    l2 = l2[i] if l2[i]\n\
    \    if l1 && l2 && l1 == l2\n      common.push l1\n      i += 1\n    else if\
    \ l1 || l2\n      common.length -= 1\n    else\n      i += 1\n  end\n  common\n\
    end", "  l1.uniq.tap do |a1|\n    l2.uniq.tap do |a2|\n      a1.intersection(a2).tap\
    \ do |i|\n        i.uniq.tap do |j|\n          l1.select{|e| j & e}.uniq.tap do\
    \ |common|\n            l2.select{|e| j & e}.uniq.tap do |common|\n          \
    \    if a.size < 2\n                l1.uniq.tap do |a1|\n                  l2.uniq.tap\
    \ do |a2|\n                    a1.intersection(a2).tap do |i|\n              \
    \        return common\n                    end\n                  end\n     \
    \           end\n              elsif b.size < 2\n                l2.uniq.tap do\
    \ |a2|\n                  l1.uniq.tap do |a1|\n                    a1.intersection(a2).tap\
    \ do |i|\n                      return common\n                    end\n     \
    \             end\n                end\n              end\n            end\n \
    \         end\n        end\n      end\n    end\n  end\nend\n</code>\n<|/ a tags=arrays,intersection,ruby,set-operations\
    \ |>\n<| a tags=arrays,intersection,ruby,set-operations dscore=3 |>\n<code>",
  "  l1 = l1.sort!\n  l2 = l2.sort!\n  l1 += l2\n  l1.each do |i|\n    return i if\
    \ l1.index(i) != l2.index(i)\n  end\n  nil\nend", "  return Set.new([l1]) & Set.new([l2])\
    \ - Set.new([l1, l2])\nend", "  l1.each do |i|\n    l2.each do |j|\n      return\
    \ i if i == j\n    end\n  end\n  []\nend", "    i, j, k = 0, 0, 0\n    while i\
    \ < l1 and j < l2\n        if l1[i] == l2[j] then i += 1; j += 1\n        else\
    \ i += 1; j += 1 end\n    until i >= l1\n    until j < l2\n    return l1[i..j]\n\
    end", "  l1.zip(l2).find do |x, y|\n    x == y\n  end\nend", "  # Convert both\
    \ lists to set for efficient membership testing.\n  set1 = Set(l1)\n  set2 = Set(l2)",
  "  if l1 == [] or l2 == []\n    []\n  els = l1[0] <= l2[0] and l2[0] or l1[0]\n\
    \  return [els] + (l1 and common(l1[1:], l2[1:]) or [])\nend", "  a = l1.dup\n\
    \  b = l2.dup\n  return a & b\nend", "  if l1 == nil or l2 == nil\n    return\
    \ nil\n  elsif l1 == l2\n    return l1\n  else\n    l1.each do |item1|\n     \
    \ l2.each do |item2|\n        return item1 if item1 == item2\n      end\n    end\n\
    \  end\nend", "  l1.each_with_index do |x, i|\n    break if l2[i] != x\n  end\n\
    \  l1\nend", "  if l1 == nil || l2 == nil\n    return nil\n  else\n    return\
    \ if l1.length == 0 || l2.length == 0\n      l1\n    elsif l1.length == l2.length\n\
    \      return l1\n    else\n      return l1[0,l1.length-1] - l2[0,l2.length-1]\n\
    \    end\n  end\nend", "  common = []\n  while l1.length and l2.length\n    common\
    \ = common + l1[l1.length-1] if l1[l1.length-1] == l2[l2.length-1] else l1[l1.length-1]\
    \ + 1\n    l1.pop\n    l2.pop\n  end\n  l1.length or l2.length ? common : nil\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
