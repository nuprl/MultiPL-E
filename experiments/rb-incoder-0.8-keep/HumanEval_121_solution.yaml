name: HumanEval_121_solution
language: rb
prompt: "# Given a non-empty list of integers, return the sum of all of the odd elements\
  \ that are in even positions.\n# Examples\n# solution([5, 8, 7, 1]) ==> 12\n# solution([3,\
  \ 3, 3, 3, 3]) ==> 9\n# solution([30, 13, 24, 321]) ==>0\ndef solution(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solution\n\
  \    candidate = method(:solution)\n    assert_equal(12, candidate.call([5, 8, 7,\
  \ 1]))\n    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))\n    assert_equal(0,\
  \ candidate.call([30, 13, 24, 321]))\n    assert_equal(5, candidate.call([5, 9]))\n\
  \    assert_equal(0, candidate.call([2, 4, 8]))\n    assert_equal(23, candidate.call([30,\
  \ 13, 23, 32]))\n    assert_equal(3, candidate.call([3, 13, 2, 9]))\n  end\nend\n"
completions: ["  if lst.size < 2 \n    puts \"Not enough numbers for solution.\"\n\
    \  else \n    puts \"Solution: #{lst.select { |x| x % 2 == 1 }.inject(:+)}\"\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails dscore=2 |>\n<| a dscore=2\
    \ |>\nJust another solution:\n<code>", "  lst.inject(0){|sum, item| sum+(item%2\
    \ == 1 ? item*2 : 0)}\nend", "  return lst.inject(:+).to_i - (lst.select { |x|\
    \ x % 2 == 1 }.inject(:+) * 2)\nend", "  lst.each_with_index.map { |(num, index)|\
    \ num % 2 == 0 ? index : nil }.compact.reduce(:+)\nend", "    sum = 0\n    even\
    \ = 0\n    odd = 1\n    for element in lst\n        if element == even\n     \
    \       sum += odd\n            even += 1\n            odd = 1\n        else if\
    \ element == odd\n            sum += even\n            even = 1\n            odd\
    \ = 1\n    return sum\nend", "  return sum( lst[1..lst.length].select {|x| x %\
    \ 2 == 1 } )\nend", "    even = lst.select { |e| e%2 == 0 }\n    odd = lst.select\
    \ { |e| e%2 != 0 }\n    even.inject(0) { |sum, e| sum + odd.index(e) }\nend",
  "  lst.each_with_index {|x,i| x+=(i&1).zero? ? 0 : 1}\nend", "  sum = 0\n  for i\
    \ in 0 ... lst.size\n    if lst[i] % 2 == 1\n      sum += lst[i]\n    end\n  end\n\
    \  sum\nend\n</code>\n<|/ a dscore=0 tags=arrays,ruby |>\n<| a tags=arrays,ruby\
    \ |>\nYou could do something like this:\n<code>", "  if lst.size < 2\n    return\
    \ 0\n  end\n  hash = {}\n  lst.each_index { |i| hash[lst[i]] = i }\n  sum = 0\n\
    \  lst.each_index { |i| sum += hash[i % 2 == 1 ? lst[i] - 1 : lst[i]] }\n  return\
    \ sum\nend", "  return lst.inject(:+)\nend", "  evens.reduce(:+)\nend", "  even.inject(0)\
    \ { |sum,i| sum + lst[i] if i % 2 == 1 }\nend\n</cell>\n<text>\nThe next cell\
    \ tests the solution() method with a few test cases.", "    even = 0\n    odd\
    \ = 1\n    tot = 0\n    even = even+odd\n    for i in lst\n        total = total\
    \ + i\n        if i%2 ==0\n            even = even+i\n        else \n        \
    \    odd = odd+i\n        tot = tot+i\n    return total\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\nYou can use each_cons to get a lazy iterator, and then sum each\
    \ group (i.e. each pair of consecutive numbers) using inject to sum the even and\
    \ odd numbers separately:\n<code>", "  res = 0\n  even = 1\n  for i in lst \n\
    \    res += even\n    even *= 2\n  res\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis is not an improvement over the existing answers posted. Although it\
    \ may be interesting to see how this is done in Ruby, I don't think this answer\
    \ adds any new information.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm |>\nThe\
    \ simplest answer is to use Enumerable#slice_when:\n<code>\nnumbers = [1,2,3,4,5,6,7,8,9,10]\n\
    numbers.slice_when { |a, b| a % 2 == 0 }.sum { |a, b| a } # => 45\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 |>\nThis is more Ruby like solution:\n<code>",
  "  return lst.inject(0) {|sum,e| sum + e.odd? ? sum + e : sum}\nend", "  lst.sort.each_with_index.inject(0)\
    \ do |sum, (i, e)|\n    ((i % 2) == 0) ? sum + e : sum\n  end\nend", "  # Write\
    \ your code in Ruby\n  sum = 0\n  lst.each_with_index do |value, index|\n    sum\
    \ += value if index % 2 == 1\n  end\n  sum\nend", "\tsum = 0\n\t\n\tfor i in (0...lst.size)\n\
    \t\tif ((i&1)==0)\n\t\t\tsum += lst[i]\n\t\tend\n\tend\n\t\n\treturn sum\nend",
  "    evens = lst.select { |e| e % 2 == 0 }\n    evens.inject(0) { |sum, e| sum +\
    \ e }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks for your contribution.\n\
    <|/ c |>\n<| c |>\n`lst.each_with_object(0).with_index{ |e,acc| acc += e if e\
    \ % 2 == 1 }`. Ruby >= 2.4 has the [`Enumerable#with_index`](https://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-with_index).\n\
    <|/ c |>\n<| a dscore=4 |>\nOne more solution:\n<code>", "  lst.each do |i|\n\
    \    next if i % 2 == 0\n    i += 1 if i % 2 == 1\n    i += 1 if i % 2 == 0\n\
    \  end\n  lst.reduce(0) {|sum, i| sum + i}\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI like the `reduce` method. Nice!\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  total = 0\n  lst.each do |num|\n    total += num if num % 2 == 0\n  end\n  total\n\
    end\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| a |>\n<code>", "  return lst.sum.odd?\
    \ if lst.sum >= 0 \n  lst.sum.even? ? lst.sum\nend\n</code>\n<|/ a |>\n<| a tags=ruby\
    \ dscore=0 |>\nHere's another way:\n<code>", "    evens = lst.select { |x| (x\
    \ % 2).zero? }\n    evens.reduce(:+) # sum all odd elements found in even positions\n\
    end\n</cell>\n<cell>\nsolution([5, 8, 7, 1])\n</cell>\n<cell>\nsolution([3, 3,\
    \ 3, 3, 3])\n</cell>\n<cell>\nsolution([30, 13, 24, 321])\n</cell>\n<cell>", " \
    \ odd = lst.select { |e| e.odd? }\n  even = lst.select { |e| !e.odd? }\n  even.inject\
    \ { |sum, i| sum + i }\nend", "  sum = 0\n  even = (0...(lst.length)).select {\
    \ |n| n % 2 == 1 }\n  odd = (0...(lst.length)).select { |n| n % 2 == 0 }\n  (even\
    \ + odd).uniq.each do |i|\n    sum += lst[i]\n  end\n  sum\nend", "  even = even.inject(0,\
    \ :+).to_f\n  even.sum\nend\n</cell>\n<text>\nThe second method called inject\
    \ is the most important method that is used to solve this problem. Let's examine\
    \ this method for a little more clarity on the parameters.", "  return lst.group_by\
    \ { |e| e % 2 }.inject(:+)\nend\n</code>\n<|/ a dscore=3 tags=ruby,arrays,math\
    \ |>\n<| c |>\nThe `group_by` method has made my day with this one. Thanks Ben!\n\
    <|/ c |>\n<| c |>\nThe second solution only works for the example in the question\
    \ as asked. It fails with [5,8,7,1]\n<|/ c |>\n<| c |>\nThe original question\
    \ states that the inputs are integers, so the example should work. It may require\
    \ some conversion, but is certainly possible.\n<|/ c |>\n<| a dscore=3 tags=ruby,arrays,math\
    \ |>\nHere's a solution that uses only basic ruby methods:\n<code>", "  # TODO:\
    \ Your code here\n  sum = 0\n  for i in (0...(lst.length-2)) do\n    if lst[i]\
    \ == lst[i+1] then\n      sum = sum + lst[i]\n    end\n  end\n  return sum\nend",
  "    evens = lst.select{|e| e%2 == 0}\n    odd = lst.select{|e| e%2 != 0}\n    odd.reduce(0)\
    \ do |t,e| t + evens[evens.index(e)+1]\n    end\nend", "  lst.sort.each_with_index.inject{\
    \ |sum,(el,i)| sum+(i&1) ? el : 0 }\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n\
    <| a |>\nHere is another solution that may get you interested or at least help\
    \ you in different ways.\n<code>", "  lst.each do |i|\n    i += 1 if i.odd? &&\
    \ i.even?\n  end\n  lst.sum\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,algorithm\
    \ |>\nUsing Array#select, Array#sum and Array#each_cons, you can do that in one\
    \ line without using any loops.\n<code>\narray = [2, 3, 4, 1, 2, 3, 2]\narray.select\
    \ { |x| x.odd? }.sum.odd? # => true\n</code>\nIt even works with non-even numbers:\n\
    <code>\narray = [3, 3, 4, 1, 2, 3, 2]\narray.select { |x| x.odd? }.sum.odd? #\
    \ => true\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>", "    even =\
    \ even.select{ |x| x % 2 == 0 }\n    even.inject(0) { |sum, item| sum + item }\n\
    end\n</cell>\n<text>\nThe inject method takes a lambda that will be called with\
    \ every element in arr. If the lambda returns true then the element is added to\
    \ the result sum, if false then the element is not added to the result sum.",
  "  result = 0\n  odd_positions = 0\n  even_positions = 0\n  lst.each_with_index\
    \ do |num, index|\n    even_positions += ((index % 2) == 0)\n    if index % 2\
    \ == 0\n      result += (num % 2)\n      odd_positions += 1\n    end\n  end\n\
    \  if result >= odd_positions\n    result\n  else\n    0\n  end\nend", "    sum\
    \ = 0\n    even = 1\n    odd = 1\n    odd_index = 1\n    even_index = 1\n    lst.reverse\n\
    \    lst.reject{|x| x % 2 != 0}.reverse\n    even = lst.count{|x| x % 2 == 1}\n\
    \    odd = lst.count{|x| x % 2 != 1}\n    even.times do\n        sum +=lst[odd_index]\n\
    \        odd_index +=1\n        odd_index = (odd_index + 1) % even\n        even_index\
    \ += 1\n        even_index = (even_index + 1) % odd\n    end\n    sum\nend", " \
    \ res=[]\n  lst.each do |n|\n    res << n if n % 2 == 1\n  end\n  res.inject(0){|total,i|\
    \ total + i}\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is the same as mine,\
    \ except the variable names are different and it's more verbose.  As an exercise,\
    \ I would recommend figuring out how `inject` works before using `inject` because\
    \ it's really the key piece of understanding here.\n<|/ c |>\n<| a tags=ruby dscore=0\
    \ |>\n<code>", "  result = lst[0]\n  lst.delete_at(0) \n  \n  (lst - [result]).each\
    \ {|x| result = result + x}\n  result\nend", "  result = lst.inject(0){|sum, item|\
    \ sum + item % 2 ? sum + item : sum}\n  puts \"#{result}\" unless result.zero?\n\
    end", "  even = lst.select { |e| e.even? }\n  odd = lst.select { |e| e.odd? }\n\
    \  even.inject { |sum, e| sum + e.to_i }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays\
    \ dscore=0 |>\n<| a |>\nThis is pretty similar to the other answers, but here\
    \ is a simple solution with no looping or enumerating or creating the intermediary\
    \ arrays:\n<code>", "  lst.each_with_index.inject(0){|sum, (x, i)| sum + x if\
    \ i%2==1 ; sum}\nend", "    return lst.inject(0) {|s, x| s -= x % 2 ; s}\nend\n\
    </cell>\n<cell>", "  if lst.empty?\n    0\n  else\n    lst.each_with_index.inject(0)\
    \ {|sum, (a, n)|\n      (sum + a % 2) if n % 2 != 0\n    }\n  end\nend", "  lst.inject(0)\
    \ { |total, i| i % 2 == 0 ? total + i : total }\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a |>\nYou can do this without a loop:\n<code>\nlst.group_by {|x| x%2}.map\
    \ {|k,v| v.sum }.inject(:+)\n</code>\nIt groups by whether each element is a multiple\
    \ of two, and then maps over the values with the appropriate sum. It then sums\
    \ up all the values it collected.\n<|/ a tags=ruby dscore=5 |>\n<| c |>\nNice\
    \ and clean. Thank you!\n<|/ c |>\n<| a |>\nI got it using Enumerable#inject\n\
    <code>", "  evens = lst.select { |x| x % 2 == 0 }\n  evens.reduce(:+) + odds.reduce(:+)\n\
    end", "  even = lst.select { |x| x % 2 == 0 }\n  odd = lst.select { |x| x % 2\
    \ != 0 }\n  odd.inject(0) {|sum, i| sum + i }\nend", "  # TODO: your code here\n\
    end", "  lst.each_with_index.inject(0) { |sum, (i,_)| sum + lst[i] % 2 ? sum :\
    \ sum + 1 }\nend", "  sum = 0\n  even = lst.select { |x| (x % 2).zero? }\n  lst.each\
    \ do |x|\n    if even.include?(x)\n      sum += x\n      even.delete(x)\n    end\n\
    \  end\n  sum\nend\n</code>\n<|/ a |>\n<| c |>\nThis is really the best answer,\
    \ I think. I didn't know about `select` and `delete`.\n<|/ c |>\n<| a dscore=2\
    \ tags=ruby,algorithm |>\nHere's a way that modifies the original array.\n<code>\n\
    arr = [1,2,3,4,5,6,7,8,9,10]\narr.each_index.select{|i| arr[i]%2==1}.inject(:+)\n\
    </code>\n<|/ a |>\n<| a tags=ruby,algorithm |>\nThis could be done in one line\
    \ without an intermediate array.\n<code>\nlst.inject(0) {|acc, x| acc + (x % 2\
    \ == 0 ? x : 0)}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nGood solution, but I think\
    \ you meant `inject(0)`\n<|/ c |>\n<| c |>\nThanks, I fixed it - now the code\
    \ works.\n<|/ c |>\n<| a tags=ruby,algorithm |>\n<code>", "  lst.each_with_index.inject(0)\
    \ {|sum, (number, i)| sum+=number if i =~ /2/}\nend", "  lst.inject(0) { |sum,\
    \ i| sum + i if (i % 2 == 1) }\nend", "  result = 0\n  for i in lst.each_index\n\
    \    result += lst[i] if i % 2 != 0\n  end\n  result\nend\n</cell>\n<code language=julia-1.5>\n\
    function solution(lst)\n  sum(i for i in lst if i .% 2 != 0)\nend\n</cell>\n<code\
    \ language=julia-1.5>\nfunction solution(lst)\n  sum( sum(lst[1:i] for i in 2:length(lst\
    \ ) ) for i in lst if i .% 2 != 0)\nend\n</cell>\n<text>\nA Simple String Cipher\n\
    Let's make a simple encryption function that's easy to understand.\nHere's our\
    \ encryption function:", "    even = even.inject(:+) || 0\n    odd = odd.inject(:+)\
    \ || 0\n    even.times do |i|\n        odd += lst.index(lst.delete(i)) ? lst.delete(i)\
    \ : 0\n    end\n    odd.abs\nend", "  lst.sort.each_with_index do |a,index|\n\
    \    if index%2 ==1 then a\n    end\n  end\n  sum\nend\nprint solution.([5, 8,\
    \ 7, 1]) # 12\nprint solution.([3, 3, 3, 3, 3]) # 9\nprint solution.([30, 13,\
    \ 24, 321]) # 0\n</code>\nThis is not very efficient as you need to sort the list\
    \ twice (once to find the odd elements, and then again to find the sum of those\
    \ odd elements).  I haven't run any benchmarks but I suspect that this would be\
    \ a faster solution if you were dealing with large lists.\n<|/ a tags=ruby,list\
    \ |>\n<| c |>\n+1 for this answer. Your answer is better than mine, because it\
    \ uses the built in sort functions. And I learned about #each_with_index today.\n\
    <|/ c |>\n<| c |>\nNice. My answer doesn't use a sort and my answer uses a sort\
    \ twice. +1\n<|/ c |>\n<| a dscore=0 |>\nHere's one way to do it: \n<code>\nlist.each_index.inject(0){|sum,\
    \ i| sum + (list.delete_at(i+1).inject(0){|sum, x| sum + x if x % 2 != 0}) }\n\
    </code>\n<|/ a tags=ruby,list |>\n<| c |>\nThis also works fine, but is slower.\
    \ On a list of 1,000,000 integers, I tested it against my answer (which was faster)\
    \ and yours.\n<|/ c |>\n<| a |>\n<code>", "    odd_index = lst.index { |x| x %\
    \ 2 != 0 }\n    even_element = lst.delete_at(odd_index)\n    return even_element.inject(:+)\n\
    end\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| a dscore=2 |>\n<code>",
  "  lst.sort.each_with_index do |element, index|\n    next if (index % 2) == 0\n\
    \    sum+=element\n  end\n  sum\nend\n</code>\n<|/ a |>\n<| a tags=arrays,ruby\
    \ |>\n<code>", "  sum = 0 \n  even_index = lst.index(lst.select{|x| x % 2 == 0})\n\
    \  even = lst.slice(0,even_index) \n  odd = lst.slice(even_index..-1)\n  odd.each_index\
    \ do |i| \n    if odd[i]%2 == 0\n      sum += even[i]\n    end\n  end\n  sum\n\
    end", "  even_index = 0\n  odds = 0\n  lst.each do |n|\n    if n % 2 == 0\n  \
    \    even_index += 1\n    else\n      odds += n\n    end\n  end\n  return odds\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nHow would you do it by modifying the\
    \ existing code? That would be my preferred method of solving this problem.\n\
    <|/ c |>\n<| c |>\nOh yeah! I see... You're absolutely right. I didn't realize\
    \ there was a difference. Now I see that. Thanks!\n<|/ c |>\n<| c |>\nIt would\
    \ be better if you could add some explanation to your answer - just dumping code\
    \ is not a good answer\n<|/ c |>\n<| c |>\nI'm still not understanding how this\
    \ works but it's good to know it works. Thanks!\n<|/ c |>\n<| a |>\n<code>\nfunction\
    \ sumEvenOdd(arr) {\n  var sum = 0;\n  for (var i = 0; i < arr.length; i++) {\n\
    \    var n = arr[i];\n    if (n % 2 == 0) {\n      sum += n;\n    } else {\n \
    \     for (var j = 0; j < arr.length; j++) {\n        if (j == i) continue;\n\
    \        var n2 = arr[j];\n        if (n2 == n) break;\n      }\n    }\n  }\n\
    \  return sum;\n}\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nWhile this code\
    \ snippet may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, as this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| c |>\nPlease don't post only code as answer, but\
    \ also provide an explanation what your code does and how it solves the problem\
    \ of the question. Answers with an explanation are usually more helpful and of\
    \ better quality, and are more likely to attract upvotes.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>\narr = [1, 2, 3, 4, 5, 6]", "  lst.each_with_index.inject(0) { |s,\
    \ (e, i)| s += e if i%2 == 1 }\nend", "  lst.each do |x|\n    sum += (x - lst[x.modulo(2)])\
    \ % 2\n  end\n  sum\nend\n</code>\n<|/ a |>\n<| c |>\nThis takes O(n) space and\
    \ O(n) time. It can be done in O(n) time and O(1) space.\n<|/ c |>\n<| c |>\n\
    : I guess it is O(n) time and O(1) space in Ruby. And I guess it is O(n) time\
    \ and O(1) space in Perl. I'm a Perl guy. :-) But if someone asked me to write\
    \ it in Ruby, they would probably be inclined to do it in Ruby.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nThis problem can be solved with a sliding window of size 2. I\
    \ used a queue (java.util.LinkedList) to solve this problem. The complexity is\
    \ O(n), because a queue has a O(1) peek() operation.\n<code>\npublic class Solution\
    \ {\n    public int sumOddEven(int[] nums) {\n        Queue<Integer> queue = new\
    \ LinkedList<Integer>();\n        for(int i = 0; i < nums.length; i++){\n    \
    \        if(nums[i] % 2 == 0){\n                queue.add(nums[i]);\n        \
    \    }\n            else if(nums[i]%2 == 1){\n                queue.poll();\n\
    \                queue.add(nums[i]);\n            }\n        }\n        int sum\
    \ = 0;\n        while(!queue.isEmpty()){\n            sum = sum + queue.poll();\n\
    \        }\n        return sum;\n    }\n}\n</code>\n<|/ a tags=ruby,arrays,algorithm\
    \ |>\n<| c |>\nCould you please explain how this works?\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\narray = []\narray = [1,2,3,4,5,6,7,8,9,10]", "  even = lst.select\
    \ { |x| x % 2 == 0 }\n  even.inject { |acc, el| acc + (el % 2 == 1 ? el : 0) }\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThat's a neat little trick.  I'd love\
    \ to see a benchmark comparison though.\n<|/ c |>\n<| c |>\nWell, the solution\
    \ above is O(n), whereas the solution in the answer below is O(n log n).\n<|/\
    \ c |>\n<| a tags=ruby |>\nMy favorite solution in Ruby is to use Array#sum and\
    \ some if/else logic:\n<code>\nlist.sum { |x| (x + 1) % 2 != 0 }\n</code>\n<|/\
    \ a dscore=4 |>\n<| a |>\n<code>\nlist.inject(0) { |sum, n| sum + n if n % 2 !=\
    \ 0 }\n</code>\n<|/ a tags=ruby dscore=3 |>\n<| c |>\nNice use of inject.  But\
    \ it's still O(n^2)\n<|/ c |>\n<| c |>\nIt's O(n) because of the way the conditional\
    \ is evaluated.\n<|/ c |>\n<| a |>\nJust for fun, here's another way:\n<code>\n\
    list.inject(0) { |sum, n| sum + n if n % 2 == 1 }\n</code>\n<|/ a tags=ruby dscore=2\
    \ |>\n<| c |>\nYes, but it's not that different from a solution that uses sum\
    \ and if.  I'd like to see a benchmark comparison.  It really seems like there\
    \ should be a way to do this in O(n).\n<|/ c |>\n<| c |>\nI think your solution\
    \ is O(n^2) because it traverses the list twice. Mine traverses it only once.\n\
    <|/ c |>\n<| c |>\nOk, I see what you're saying.  However, this solution seems\
    \ a little more elegant.  What if I wanted to get a list of all the numbers from\
    \ 1 to n that add up to exactly n?  For instance, if you had an array of [3,5,7,9],\
    \ you could get [3,3,3,5].  It's a good idea for that case, but for a different\
    \ one it might be a little confusing and ugly.\n<|/ c |>\n<| a tags=ruby |>\n\
    Here's another solution using Enumerable#find:\n<code>\nlist.find { |n| n % 2\
    \ == 1 }\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby dscore=2 |>\n", "  \n  total\
    \ = 0\n  index = 0\n  while index < lst.count\n    total = total + lst[index]\n\
    \    index += 1\n  end\n  \n  total\nend", "    sum = 0\n    lst.each_with_index\
    \ { |e, i| if i % 2 == 1 then sum += e end}\n    sum\nend", "    return lst.select{|x|\
    \ x % 2 == 0 }.sum\nend", "  sum = 0\n  lst.each_with_index do |x,index|\n   \
    \ if x % 2 != 0\n      sum += x\n      sum -= lst.last\n    end\n  end\n  sum\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby,algorithm,arrays,sum dscore=4 |>\nIf you\
    \ can accept a slight speed hit, this is the most readable and fastest:\n<code>",
  "  result = 0\n  for i in lst.each_with_index\n    if i.even?\n      result +=i.to_i\n\
    \    end\n  end\n  result\nend\n</code>\nThis code is concise and easy to understand,\
    \ if you need explanations on any of the lines inside the function - you can find\
    \ them by scrolling up on the code block itself\n<|/ a |>\n<| c |>\n`each_with_index`\
    \ is an old Ruby method that only exists in MRI 2.2 and newer, not in Ruby 1.8.\n\
    <|/ c |>\n<| c |>\nThanks, will add that\n<|/ c |>\n<| a tags=ruby |>\nThe method\
    \ you describe is known as reduce. Here's how you could do that in Ruby:\n<code>",
  "  lst.each_with_index { |e, i| return 0 if i%2==1 then return e else return 0 end\
    \ }\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\nOne more way to solve\
    \ the problem:\n<code>\narr = [1,2,3,4,5,6,7,8,9,10]", "  evens.inject(0) { |sum,e|\
    \ sum + lst[e] if e%2 == 1 }\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n\
    The most straightforward solution:\n<code>", "  new_lst = lst.clone\n  new_lst.shift\n\
    \  new_lst.each.with_index do |el,i|\n    if i % 2 == 0 then\n      new_lst.delete(el)\n\
    \    end\n  end\n  new_lst.inject(:+)\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nThis is pretty impressive and pretty concise. I like it. But it makes me\
    \ wonder why there isn't a more efficient way of doing this in terms of time and\
    \ memory. Anyone knows?\n<|/ c |>\n<| c |>\nI added an answer to this question\
    \ to show the memory requirement. Hopefully someone will come up with a better\
    \ solution than this one.\n<|/ c |>\n<| a tags=ruby |>\nHere is my solution:\n\
    <code>", "  sum = 0\n  arr.each_index do |i|\n    sum += lst[i] if i%2 == 1\n\
    \  end\n  sum\nend\n</code>\n<|/ a |>\n<| c |>\nThat is great thanks however it\
    \ must be done using only sum() and each_index().\n<|/ c |>\n<| c |>\nYou cannot\
    \ write `sum + lst[i / 2]` in Ruby, at least not without using `each_index` which\
    \ is unnecessarily complicated. In fact, your proposed solution has two bugs:\
    \ `sum` is an array, not a number, `arr` is a `Integer`, not an array, `lst[i]`\
    \ is an `Integer`, not an `Integer` array, etc.\n<|/ c |>\n<| c |>\nYou don't\
    \ need `each_index` either. `sum` is an array, not an integer.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nI did something similar to this (for integers):\n<code>", "  evens\
    \ = evens_and_odds(lst)\n  evens.reduce(:+)\nend", "  sum = 0\n  even = []\n \
    \ odd = []", "  sum = 0\n  for i in 0 .. lst.size - 1\n    if lst[i] % 2 != 0\
    \ && lst[i] % 2 != 1\n      sum += lst[i]\n    end\n  end\n  return sum\nend",
  "    return lst.inject(0) { |sum, e| sum + e % 2 }\nend", "  # write your code in\
    \ Ruby\nend", "  sum = 0\n  i = lst.length - 1\n  while i >= 0\n    sum += 1\n\
    \    i -= 1\n  sum % 2 == 1 and sum\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    <code>", "  odd, even = 0, 0\n  lst.each do |x|\n    odd += x if x % 2 == 1\n\
    \    even += x if x % 2 == 0\n  end\n  odd - even\nend", "  return lst.select\
    \ { |x| x % 2 == 1 }.sum\nend\n</code>\n<|/ a |>\n<| c |>\nIt would be better\
    \ to explain why this works (other than to suggest using a different language\
    \ where this is clearly the best solution).\n<|/ c |>\n<| c |>\nI agree with you,\
    \ but I think the original question was more about the basic mathematical solution\
    \ to solving the problem as opposed to explaining how the code works. I believe\
    \ this makes the code easier to understand, especially for newbies. However, I\
    \ can see why others would want to explain how it works.\n<|/ c |>\n<| c |>\n\
    I think your last solution `[1, 2, 3, 4].sum - [1, 2, 3, 4, 5].sum` is broken.\
    \ Try this in irb: `[1, 2, 3, 4].sum - [1, 2, 3, 4, 5].sum #=> [3, 1, 2, 4]`.\
    \ It should return `[5, 1, 3, 4]`. Your `solution` method returns the sum of all\
    \ odds in the array.\n<|/ c |>\n<| c |>\nOh you're right. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nThe method sum in ruby returns an integer so `[3,\
    \ 1, 2, 4].sum - [1, 2, 3, 4, 5].sum #=> 3`. The sum method returns the sum of\
    \ all odd integers in the array and subtracting the sum of all odd integers in\
    \ the array from all even integers gives us what we want.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  lst.each_with_index.reduce(0) do |sum, i|\n    sum + (lst[i]\
    \ % 2 != 0 ? 1 : 0)\n  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\n<code>\nrequire 'enumerator'", "  return lst.inject(:+) do |sum,element|\n\
    \    if element.odd? && sum % 2 == 0\n      sum\n    elsif element.odd? && sum\
    \ % 2 != 0\n      sum - element\n    else\n      sum\n    end\n  end\nend\n</code>\n\
    The inject method takes two arguments, the first is an object to \"inject\" into\
    \ the array (in this case the sum, and the second is what to give the object in\
    \ the array. In this case, we want to use the first argument as the sum, so we\
    \ use a block to do that. Then we use the second argument, which is the element\
    \ being processed, as the value to add to. We only want odd numbers in the sum,\
    \ so we check that the number is an odd number and not an even one. If the number\
    \ is odd, and we are already on an even number, we subtract the number from the\
    \ sum. Otherwise we add the number to the sum.\nFinally, I added the line sum\
    \ - element into the if conditional to handle situations where an element of the\
    \ array is equal to the sum, and thus we only want to subtract the element from\
    \ the sum and not add it.\n<|/ a tags=arrays,ruby,algorithm,ruby-on-rails |>\n\
    <| c |>\nThanks for this response! I wasn't familiar with inject before, I'll\
    \ be sure to check it out!\n<|/ c |>\n<| c |>\n`sum - element` is wrong. It will\
    \ always be `0`, since `sum` is `0` and `element` is `0`.\n<|/ c |>\n<| c |>\n\
    : you're right, it should have been `sum - element`, which I have edited now to\
    \ correct it.\n<|/ c |>\n<| c |>\nSorry, but I think there's a bug in this.  If\
    \ `lst = [3, 6, 3, 1, 5, 3, 2]`, for example, then `sum - element` will equal\
    \ `5 - 6`, which is not equal to `3`.\n<|/ c |>\n<| c |>\n: you are absolutely\
    \ right, I see my mistake, I forgot about subtracting from the sum, not adding\
    \ it.\n<|/ c |>\n<| a dscore=3 tags=arrays,ruby,algorithm,ruby-on-rails |>\n<code>",
  "    sum = 0\n    even = lst.select{|x| x % 2 == 0}\n    odd = lst.select{|x| x\
    \ % 2 != 0}\n    odd -= even\n    odd += odd.detect{|x| x.zero? }\n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{|x| x.zero? } \n    odd += odd.detect{|x| x.zero? } \n    odd +=\
    \ odd.detect{", "    even = lst.take_while { |x| x.odd? }\n    even.inject(0)\
    \ { |t,x| t+x }\nend\n</code>\nThe use of inject lets you avoid the use of explicit\
    \ return, although that might not be a good thing. Just to show another approach\
    \ that doesn't require filtering:\n<code>", "    return lst.sum.odd? ? lst.sum.even\
    \ : nil\nend\n</code>\nUsing a hash table, we can make the code much cleaner\n\
    <code>", "    even = 0\n    odd = 0\n    total = 0\n    \n    for num in lst\n\
    \        if num % 2 == 0\n            even += num\n        else\n            odd\
    \ += num\n    end", "  lst.sort!\n  lst.each_with_index { |x, i| i += 1 if x %\
    \ 2 != 0 }\n  lst.inject(0) { |sum, value| sum + value }\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a |>\nMy Solution:\n<code>", "  if lst.count > 0 and lst.all?\
    \ { |x| x % 2 != 0 }\n    lst.reverse.each_with_index.inject(0) do |sum, (number,\
    \ index)|\n      if index % 2 == 1\n        sum += number\n      end\n    end\n\
    \    sum\n  else\n    -1\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby\
    \ |>\n<code>", "  evens = lst.each_with_index.select { |n, idx| n % 2 == 0 }\n\
    \  evens.inject(:+).to_i\nend", "  return lst.find_index {|x| (x%2==0)} + lst.find_index\
    \ {|x| (x%2==1)}\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nHaving one `find`\
    \ call per element is very inefficient.\n<|/ c |>\n<| c |>\nBut this answer is\
    \ more efficient than mine.\n<|/ c |>\n<| c |>\nThe first solution is more efficient\
    \ but only because of the \"one find\". It also requires some extra complexity:\
    \ `lst = %w{ one two three four five six seven eight nine ten}` then `lst.find\
    \ { |x| (x % 2 == 0) }.to_i`.\n<|/ c |>\n<| c |>\nYeah I think your answer is\
    \ better than mine. I should have given more details.\n<|/ c |>\n<| c |>\nThanks\
    \ for your comment, I appreciate it. Your code is also better than mine, but you\
    \ also have mentioned that this solution is more efficient. So I supposed your\
    \ code is better than mine.\n<|/ c |>\n<| a tags=ruby |>\nThis approach uses the\
    \ Enumerable methods of Enumerable and Array and doesn't require an intermediate\
    \ array.\n<code>", "    even = even.inject(:+).to_i\n    odd = odd.inject(:+).to_i\n\
    \    even.select { |e| lst.index(e) % 2 == 0 }.inject(:+) - odd\nend", "  even\
    \ = evenSum = 0\n  for x in lst\n    if x % 2 == 0 then\n      even = even + x\n\
    \    else\n      evenSum = evenSum + even\n    end\n  end\n  evenSum = evenSum\
    \ + even\n  return evenSum\nend", "    arr=[]\n    arr=lst.each_cons(2).map(&:to_i).reject(&:odd?).uniq.sort\n\
    \    arr=arr.select {|x|x%2==0}\n    return arr.sum\nend", "  return lst.sum.odd?\
    \ - lst.sum.even? \nend\n</code>\n<|/ a tags=ruby,algorithm dscore=2 |>\n<| a\
    \ tags=ruby,algorithm dscore=2 |>\nHere's an alternative solution that doesn't\
    \ require the odd elements to be unique:\n<code>", "  odd_position = 0\n  even\
    \ = lst.count(even)\n  \n  while even.even?\n    odd_position += even.odd\n  \
    \  even += lst.count(even)\n  end\n  odd_position\nend", "  lst.sort.select {\
    \ |x| x % 2 == 0 }.inject(:+)\nend", "  lst.map {|i| return i.odd? if i.even?;\
    \ return i }.reduce(:+)\nend\n</code>\nIn Ruby 1.8.7 and 1.9.2 you can use inject,\
    \ which is equivalent to reduce, but doesn't return the intermediate value:\n\
    <code>\nlst.inject(0) { |total, element| element.odd? if element.even? || total\
    \ }\n</code>\nIn Ruby 1.9.3 you can use map!, which is equivalent to map, and\
    \ returns the modified array:\n<code>\nlst.map! { |element| element.odd? if element.even?\
    \ || element }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer!\n\
    <|/ c |>\n<| a dscore=1 tags=ruby,ruby-on-rails |>\nYou can use Enumerable#inject\
    \ for this:\n<code>", "    odd_sum = 0\n    even_sum = 0", "  lst.sort\n  even\
    \ = lst.select { |x| x % 2 == 0 }\n  odd = lst.select { |x| x % 2 != 0 }\n  odd.inject\
    \ { |sum, item| sum + item }\nend\n</cell>\n<code language=julia-1.0>\nsolution([5,\
    \ 8, 7, 1])\n</cell>\n<code language=julia-1.0>\nsolution([3, 3, 3, 3, 3])\n</cell>\n\
    <code language=julia-1.0>\nsolution([30, 13, 24, 321])\n</cell>\n<code language=julia-1.0>\n\
    function solution(lst)\n  odd_indices = lst.find { |x| x % 2 != 0 }\n  even_indices\
    \ = lst.find { |x| x % 2 == 0 }\n  odd_indices.inject { |sum, item| sum + lst[item]\
    \ }\nend\n</cell>\n<code language=julia-1.0>\nsolution([5, 8, 7, 1])\n</cell>\n\
    <code language=julia-1.0>\nsolution([3, 3, 3, 3, 3])\n</cell>\n<code language=julia-1.0>\n\
    solution([30, 13, 24, 321])\n</cell>\n<text>\nThe Sum of Large Fibonacci Numbers\n\
    The Fibonacci sequence is defined by the recurrence relation:", "  sum = 0\n \
    \ i = 0\n  while i < lst.length\n    if i % 2 == 0\n      sum += lst[i]\n    i\
    \ += 1\n  end\n  \n  sum\nend", "  sum = 0\n  arr.each do |i|\n    sum += i[i.index(lst.index(i))+2]\n\
    \  end\n  sum\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,algorithm,arrays |>\n\
    <| a dscore=0 tags=ruby,ruby-on-rails,algorithm,arrays |>\nI solved the problem\
    \ by doing the following.\n<code>", "    evenSum = 0\n    oddSum = 0\n    evenPosition\
    \ = 0", "  lst.each_with_index do |number, index|\n    if index == 0\n      number\n\
    \    elsif index > 0\n      if number % 2 == 1\n        number + numbers[0..index-1].sum\n\
    \      else\n        number\n      end\n    end\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,arrays,ruby-on-rails |>\n<code>", "  lst.each_with_index\
    \ do |number, index|\n    if index%2 == 0\n      sum+=number\n    end\n  end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nYou have to add `sum=0` before the `each_with_index`\
    \ loop\n<|/ c |>\n<| c |>\nThanks for your comment. I edited my answer. I appreciate\
    \ you take time to give me your valuable opinion.\n<|/ c |>\n<| c |>\nThanks for\
    \ the answer. My teacher says that this solution could take a long time to run.\
    \ I wonder what other ways there are to solve this problem.\n<|/ c |>\n<| c |>\n\
    If your teacher doesn't want you to solve this problem in time complexity less\
    \ than O(n) then I guess your teacher is a cheater.\n<|/ c |>\n<| c |>\nI agree\
    \ with you. Maybe he wants us to practice with the language. As we learn more\
    \ and more to program with Ruby, I guess this problem will be more and more obvious.\n\
    <|/ c |>\n<| a dscore=1 tags=ruby |>\nThe problem is called a HackerRank challenge,\
    \ which I believe is part of the rules of HackerRank.", "  lst.map{|i| i&1 }.inject(0,\
    \ :+)\nend\n</code>\nI hope this helps\n<|/ a |>\n<| c |>\nThank you for your\
    \ answer. Could you please elaborate more on your answer?\n<|/ c |>\n<| c |>\n\
    the way I understand your question is that you have a list of integers and you\
    \ want to find the sum of all odd numbers contained in even positions (and no\
    \ other numbers). Is that correct?\n<|/ c |>\n<| c |>\nYes, that is exactly what\
    \ I want.\n<|/ c |>\n<| c |>\nUpdated to include an explanation of how I understand\
    \ the question\n<|/ c |>\n<| c |>\nThanks so much. Your answer was very helpful.\n\
    <|/ c |>\n<| a dscore=0 tags=ruby |>\n<code>", "  return lst.select { |e| e %\
    \ 2 != 0 }.inject(:+) \nend", "  evenSum = 0\n  even = lst.select {|x| x % 2 ==\
    \ 0} # [5,8,7,1]\n  even.each do |x|\n    evenSum += x\n  end\n  evenSum\nend\n\
    </code>\n<|/ a tags=ruby,arrays,algorithm dscore=2 |>\n<| c |>\nThanks, this looks\
    \ really nice!\n<|/ c |>\n<| a dscore=2 tags=ruby,arrays,algorithm |>\nI like\
    \ to use inject for these kinds of problems where it makes sense:\n<code>\nnumbers\
    \ = [1, 3, 4, 3, 6, 6]\nodd_sums = numbers.inject(0) { |sum, number| sum + number\
    \ if number % 2 }\n</code>\n<|/ a |>\n<| a |>\n<code>", "  return lst.inject(0)\
    \ { |sum, el| el % 2 == 1 ? sum + el : sum }\nend", "  return lst.sum { |x| ((x\
    \ % 2) == 0) ? x : nil } || 0\nend", "  return lst.select { |i| i % 2 == 1 }.sum\n\
    end", "  sum = 0\n  odd = 1\n  even = 0\n  arr.each do |i|\n    if i % 2\n   \
    \   even = even*i + odd\n      odd = odd*i\n    else\n      even = even*i\n  \
    \    sum += even\n      odd = odd*i\n    end\n  end\n  sum\nend\n</code>\n<|/\
    \ a tags=ruby,sum,arrays,algorithm |>\n<| a tags=ruby,sum,arrays,algorithm |>\n\
    My answer is similar to that of Matt, but it's written in a more Ruby-like style.\
    \ \n<code>", "  lst.each do |i| sum += 1 if i%2 == 1  end\n  sum\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4 dscore=1 |>\n<| c |>\nThe OP asked\
    \ for \"Rails way\".\n<|/ c |>\n<| c |>\nThis does not answer the question. `sum`\
    \ is not defined in the method.\n<|/ c |>\n<| c |>\nThe question says \"sum of\
    \ odd numbers\"\n<|/ c |>\n<| c |>\nThis would be the Rails way. But the OP asked\
    \ for \"Rails way\".\n<|/ c |>\n<| c |>\nIt doesn't matter what you asked, what\
    \ you needed was an answer.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ |>\n<code>", "  lst.map { |x| x%2 ? 0 : x }.inject {|sum,x| sum+x }\nend", " \
    \ return lst.select {|x| x%2 == 1} .inject {|a, e| a+e}\nend", "  # write your\
    \ code in Ruby\n  lst.each_with_index.map { |element, index| element*2 if index\
    \ % 2 == 1 }.inject(:+)\nend", "  return lst.reduce(:+)\nend", "  lst.inject{|sum,\
    \ i| sum + i[2]} if lst.size % 2 == 0\nend\n</code>\n<|/ a |>\n<| c |>\nWhat is\
    \ the reason of doing `lst.inject{|sum, i| sum + i[2]} if lst.size % 2 == 0`?\
    \ Why not simply `lst.inject{|sum, i| sum + i[2]}`?\n<|/ c |>\n<| c |>\n, `lst.inject{|sum,\
    \ i| sum + i[2]} if lst.size % 2 == 0` works because `inject` evaluates the block\
    \ `|sum, i| sum + i[2]` on every iteration of `lst`, but `lst.inject{|sum, i|\
    \ sum + i[2]}` is much more readable than `lst.inject(0){|sum, i| sum + i[2]}`,\
    \ since `inject` already takes a lambda.\n<|/ c |>\n<| c |>\nThis solution fails\
    \ if `lst` contains non-numeric elements. For example: `solution([3, 3.14, 6,\
    \ :foo])`.\n<|/ c |>\n<| a |>\nHere is an example on how to use inject with multiple\
    \ arguments:\n<code>\na = [1, 2, 3, 4]", "  # Your code here\nend", "    evensum\
    \ = evensum = oddsum = 0\n    evensum = 0\n    oddsum = 0\n    evensum = 0\n \
    \   evensum = 0\n    \n    evensum = lst[0]\n    for i in 1..lst.length\n    \
    \    if lst[i] % 2 == 0 \n            evensum += lst[i]\n        else\n      \
    \      oddsum += lst[i]\n    end\n    return evensum + oddsum\nend", "  lst.each_with_index.select\
    \ {|e, i| i % 2 == 0 }.inject(:+)\nend\n</code>\n<|/ a |>\n<| c |>\nYou don't\
    \ have to do `each_with_index`; you can use `map`: `lst.map { |e| e % 2 == 0 ?\
    \ e : nil }.compact.inject(:+)`\n<|/ c |>\n<| c |>\nThis solution is slightly\
    \ better in that it avoids iterating the list twice. I don't know which is worse.\n\
    <|/ c |>\n<| c |>\nYou don't have to do either, but `map` will iterate the list\
    \ only once and `inject` will iterate it twice -- it might be better to do `map!`\
    \ before `inject` to avoid the additional iteration, as well.\n<|/ c |>\n<| c\
    \ |>\nYour solution works correctly even if there's only one element in the list.\
    \ Your `inject` is basically `reduce`; `inject` isn't designed for reducing one\
    \ element into a list.\n<|/ c |>\n<| c |>\n- I guess I meant `reduce` rather than\
    \ `inject`. `inject` works well here because `map` returns a list of values from\
    \ the input list, `inject` returns the aggregate from that list. I was thinking\
    \ of `inject` more broadly than `map`.\n<|/ c |>\n<| a tags=ruby,algorithm |>\n\
    <code>", "  if lst.empty?\n    puts \"0\";\n  else\n    odd_sum = lst.select {\
    \ |e| e % 2 != 0 }.inject(0, :+)\n    puts odd_sum if odd_sum\n  end\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a dscore=1 tags=ruby |>\nHere is another possible solution.\
    \ \n<code>", "    even, odd = 0, []\n    lst.each_with_index do |item, index|\n\
    \        if index == 0\n            even = item\n        else\n            odd\
    \ << item\n        end\n    end\n    even.zip(odd).inject(0) {|sum, sum| sum +\
    \ sum[1] }\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nYou can get rid\
    \ of the second variable. `arr = [5,8,7,1]; arr.each_with_index.select { |el,\
    \ index| index % 2 != 0 }.inject(:+) #=> 12` will do it. You could also do it\
    \ this way: `arr.each_with_object([]) { |el, arr| arr << el }.select.with_index{\
    \ |el, index| index % 2 != 0 }.inject(:+) #=> 12`.\n<|/ c |>\n<| c |>\nI thought\
    \ of something like that but the problem is, this solution is not working for\
    \ a list of [5, 8, 7, 1]. Because it returns 13 and not 12 as expected. So it\
    \ needs to be corrected a little bit.\n<|/ c |>\n<| c |>\n`[5, 8, 7, 1].each_with_object([]).with_index.select\
    \ { |el, arr| arr << el }.inject(:+) #=> 12`\n<|/ c |>\n<| c |>\n, that is indeed\
    \ another way to solve this, and it would be the best in some cases. However,\
    \ I really like the way I solved the problem because I never thought about how\
    \ my previous code can be simplified.\n<|/ c |>\n<| c |>\nI agree that your solution\
    \ is better. I just wanted to point out that `arr.each_with_index.select { |el,\
    \ index| index % 2 != 0 }.inject(:+)` can be written as `arr.select { |el, index|\
    \ index % 2 != 0 }.inject(:+)`.\n<|/ c |>\n<| a dscore=1 |>\nThis could work too:\n\
    <code>\narr = %w(5 8 7 1)\narr.map { |a| arr.reject { |b| a == b }.count }\n</code>\n\
    <|/ a tags=arrays,ruby |>\n<| a dscore=1 |>\nHere's a solution with just one pass\
    \ through the array (no intermediate variables or arrays):\n<code>\narr = [5,\
    \ 8, 7, 1]\nevens_sum = arr.sum { |e| e.even? && e }\nodds_sum = arr.sum { |e|\
    \ !e.even? && e }\nevens_sum.odd? ? ", "  return lst.inject(0) { |memo, el| memo\
    \ + (el%2 == 1 ? el : nil) }\nend", "  lst.each do |i|\n    if i % 2 == 0\n  \
    \    result += i\n    end\n  end\n  result\nend\n</cell>\n<cell>", "  even.inject(0)\
    \ { |sum, value| sum + value if value.odd? }\nend\n</cell>\n<cell>\nsolution(lst)\n\
    </cell>\n<cell>\nlst = [1, 2, 3]\nlst.inject(0) { |sum, value| sum + value if\
    \ value.odd? }\n</cell>\n<cell>", "  lst.each do |x|\n    if x % 2 == 0\n    \
    \  x << 0\n    else\n      x << 0\n    end\n  end", "  evens = lst.select { |x|\
    \ x % 2 == 0 }\n  sums = evens.map { |x| x + evens.count(x) }\n  sums.inject {\
    \ |sum, num| sum + num }.to_i\nend", "    lst.pop.compact.inject(:+) + lst.each_with_index.map\
    \ { |e,i| i%2 ? e : 0 }.sum\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ |>\n<| c |>\nI like the solution, but I am getting a \"stack level too deep\"\
    \ error on the line `list.pop.compact.inject(:+) + lst.each_with_index.map { |e,i|\
    \ i%2 ? e : 0 }.sum`. Any idea what this could be? Thanks so much for your help!\n\
    <|/ c |>\n<| a |>\nHere's a variant that doesn't involve modifying the original\
    \ array and also doesn't require additional libraries:\n<code>", "  lst.sort.inject(0)\
    \ do |sum, v|\n    sum + v.odd? ? sum + 1 : sum\n  end\nend", "  return lst.select\
    \ { |x| x.odd? }.inject(0) {|sum,x| sum + x }\nend\n</code>\n<|/ a tags=arrays,ruby\
    \ dscore=2 |>\n<| a dscore=1 |>\nA more idiomatic Ruby solution would use inject:\n\
    <code>", "  sum = 0\n  even = 0\n  odd = 1\n  even.upto(lst.size - 1) do |n|\n\
    \    sum = sum + lst[n] if lst[n] % 2 == 0\n    even = even + 1 if lst[n] % 2\
    \ == 1\n    odd = odd + 1 if lst[n] % 2 != 1\n  end\n  return sum if even <= lst.size\n\
    \  return odd - even\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis works\
    \ on my test cases, but I'm sure it can be done more efficiently. Thanks for your\
    \ answer!\n<|/ c |>\n<| a tags=ruby,arrays |>\nThis might be a bit easier to read\
    \ and might have a better performance than others:\n<code>", "  lst.each_with_index.inject(0)\
    \ { |sum, (n, i)| sum + n%2 if (i%2 == 1)}\nend\n</code>\n<|/ a tags=arrays,ruby\
    \ dscore=2 |>\n<| a dscore=2 |>\n<code>", "    odds = lst.select{ |x| x % 2 ==\
    \ 1 }\n    evens = lst.select{ |x| x % 2 == 0 }\n    (evens.inject(0) {|sum,x|\
    \ sum + x } + evens.inject(0) {|sum,x| sum + x }) % 2 == 0 ? odds.inject(0) {|sum,x|\
    \ sum + x } : 0\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "  lst.each_with_index.select{|el,idx|\
    \ idx % 2 == 1}.reduce(:+)\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYou don't\
    \ need `Enumerable#select` at all. `each_with_index` already yields the index\
    \ for each element and the elements themselves are returned as a two-element array\
    \ - `[el,idx]`.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  # TODO: Write your code\
    \ here\n  return lst.count{|x| (lst.index(x)%2).zero?}\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby,arrays |>\n<| c |>\nPlease don't post answers that only contain code\
    \ without any explanation. You will get upvotes instead of downvotes.\n<|/ c |>\n\
    <| a tags=ruby,arrays dscore=0 |>\nA very simple approach is:\n<code>", "  evens\
    \ = lst.select{|x| x % 2 == 0}\n  odds  = lst.select{|x| x % 2 != 0}\n  return\
    \ evens.inject(:+) + odds.inject(:+)\nend", "  sum = 0\n  for i in lst do\n  \
    \  if i % 2 == 0 then\n      sum += i\n    end\n  end\n  return sum\nend", " \
    \ if lst.empty?\n    []\n  el = lst.shift\n  lst.each do |x|\n    if x % 2 ==\
    \ 1 && x > el\n      x -= el\n    el\n  end\n  sum = 0\n  lst.each do |x|\n  \
    \  if x % 2 != 0\n      sum += x\n    end\n  end\n  sum\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis solution does not work correctly when lst = [1]\n<|/ c |>\n\
    <| c |>\nYou're right! I missed the empty array case, but I added it now. Thank\
    \ you\n<|/ c |>\n<| c |>\nI think you meant to have `el` in the first line of\
    \ the `each` loop be `sum`.\n<|/ c |>\n<| c |>\nYou're right, thank you. I missed\
    \ the fact that \"sum\" was a global variable initially, and that it was not being\
    \ modified in-place.\n<|/ c |>\n<| c |>\nThank you all guys for your help! I'm\
    \ new to Ruby, and trying to learn the ropes. Your solutions work very well for\
    \ me. I would like to ask you more about your solution though. Can you tell me\
    \ what each part is doing? Is it assigning the first value of the list to el,\
    \ and setting it to 0? Also, why is sum 0 at the beginning? What is it doing?\n\
    <|/ c |>\n<| a |>\nI believe that this solution will work faster because it does\
    \ not make any passes through the array. The algorithm is very simple and is described\
    \ very well in other answers. Here is a simplified version of the algorithm.\n\
    <code>", "  # write your code in Ruby\n  lst.each_with_index { |e, i| puts i if\
    \ i % 2 == 1 }.reduce(0) { |sum, e| sum + e }\nend", "  lst.each_with_index do\
    \ |el, i|\n    el.odd? and lst[i % lst.size]+=el\n  end\n  lst.uniq.count\nend\n\
    </code>\n<|/ a tags=ruby,algorithm dscore=1 |>\n<| a dscore=1 |>\n<code>\narr\
    \ = [5,8,7,1,9,5,7,9,4,4,3]\narr.uniq!", "  lst.each_with_index.reduce(:+).sub(lst[lst.length/2]).abs\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a dscore=0 |>\nTry this one:\n<code>",
  "  lst.each do |x|\n    if x % 2 == 1\n      result = result + x\n    end\n  end\n\
    \  return result\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n<code>\n\
    a = [5,8,7,1]\na.select { |e| e % 2 == 1 }.reduce(:+)\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nYou don't need the second `a` argument. `select(&:odd).reduce(:+)`\
    \ will suffice.\n<|/ c |>\n<| c |>\nI agree with you, but the problem description\
    \ specifically asked for a one-liner solution, so I stuck with this format.\n\
    <|/ c |>\n<| c |>\nWell, that's a good point, but I wonder whether that's a requirement\
    \ of the question, or just a coincidence.\n<|/ c |>\n<| c |>\nNo, I think it's\
    \ more of a coincidence :)\n<|/ c |>\n<| c |>\nAnd `reduce(:+)` is equivalent\
    \ to `inject(:+)`, just more concise.\n<|/ c |>\n<| a dscore=2 tags=ruby |>\n\
    My solution:\n<code>\nlist = [5,8,7,1]", "  return sum((i%2 == 1) for i in lst)\n\
    end\n</code>\n<|/ a tags=ruby,list,integer,mathematical-optimization |>\n<| c\
    \ |>\nThis doesn't actually answer the question. For example, why is `solution([3,\
    \ 1, 1, 3])` 9? Or why is `solution([3, 3, 3, 3])` 9? This answer has nothing\
    \ to do with OP's question or your answer does.\n<|/ c |>\n<| c |>\nI apologize\
    \ for not being clearer and also for using incorrect/inaccurate terminology. I\
    \ have edited my answer to make it clearer what I'm looking for and to better\
    \ reflect the underlying question as well.\n<|/ c |>\n<| a tags=ruby,list,integer,mathematical-optimization\
    \ |>\nAnother method which might help you:\n<code>", "  even = even.map(&:last)\n\
    \  even.sum(&:odd?)\nend", "  lst.each_with_index.inject(0) {|sum, (a, i)| sum\
    \ + a if i % 2 == 1 }\nend\n</code>\n<|/ a |>\n<| c |>\nI guess you meant to say\
    \ \"odd\" instead of \"even\" in the third line of your solution.\n<|/ c |>\n\
    <| c |>\nThanks for the answer, but this doesn't seem to be quite correct. Given\
    \ [3, 3, 3, 3, 3], your method returns 9, which is indeed the sum of all odd numbers\
    \ in the list, but this answer is supposed to be 0.\n<|/ c |>\n<| c |>\nI got\
    \ that wrong, sorry. It should return 0 for the first example, but your code returns\
    \ 12. I'll edit my answer.\n<|/ c |>\n<| c |>\nThis answer does not work: try\
    \ it with a list with 6 elements, and it returns 6 instead of 9.\n<|/ c |>\n<|\
    \ a dscore=5 |>\nA simple solution that will work fine in Ruby, Python, and Perl\
    \ (and probably most other languages including C and Java) is this one:\n<code>\n\
    list.inject(0) {|sum, e| sum += e if e % 2 == 1}\n</code>\nYou need only to change\
    \ \"odd\" to \"even\" in that line of code.\n<|/ a tags=ruby,functional-programming,arrays\
    \ |>\n<| c |>\n`list.each_with_object([]) { |e,a| a << e if e % 2 == 1 }.inject(:+)`\n\
    <|/ c |>\n<| c |>\nIn case anyone else finds this thread and wonders if it works\
    \ everywhere, this will work in most languages, including JavaScript, Ruby, and\
    \ Python.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  lst.sort!\n  lst.each do |x|\n\
    \    if x % 2 == 1\n      lst.delete_at(x)\n    end\n  end\n  lst.inject(:+)\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhat about this approach? http://stackoverflow.com/a/32544208/2830651\
    \ Would it be any good?\n<|/ c |>\n<| c |>\nThat works only if there were no duplicates\
    \ in the list.  It also modifies the original array.\n<|/ c |>\n<| c |>\nWell,\
    \ technically speaking, that's a bug if the original array has duplicates. But\
    \ of course we can do some extra validation to avoid this.\n<|/ c |>\n<| c |>\n\
    Yeah right, I forgot about that.\n<|/ c |>\n<| c |>\nThis approach is O(n^2) at\
    \ best, and is O(n^2) in the worst case. That's not good for this problem.\n<|/\
    \ c |>\n<| a tags=ruby |>\nIf you just want to remove duplicate items from a list,\
    \ then you can use the uniq method:\n<code>\nirb(main):005:0> a = [\"a\", \"a\"\
    , \"b\", \"b\", \"c\", \"c\"]\n=> [\"a\", \"a\", \"b\", \"b\", \"c\", \"c\"]\n\
    irb(main):006:0> a.uniq\n=> [\"a\", \"b\", \"c\"]\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nBut that would require creating a new list object right? I want to mutate\
    \ the original one.\n<|/ c |>\n<| c |>\nIf you want the original list to be mutated,\
    \ but still keep track of all the duplicate elements, then you need a different\
    \ approach.\n<|/ c |>\n<| a |>\nHere is an optimized version based on's answer:\n\
    <code>", "  lst.each_with_index.inject(0) do |sum, (_, index)| \n    sum + 1 if\
    \ index % 2 != 0\n    sum\n  end\nend\n</cell>\n<cell>\nsolution([5, 8, 7, 1])\
    \ ==> 12\nsolution([3, 3, 3, 3, 3]) ==> 9\nsolution([30, 13, 24, 321]) ==>0\n\
    </cell>\n<cell>\nsum((1..100).select {|n| n % 2 == 1})\n</cell>\n<cell>", "  \
    \  odd_sum = lst.find { |e| e % 2 != 0 }\n    even_sum = lst.find { |e| e % 2\
    \ == 0 }\n    even_sum ? even_sum : odd_sum\nend", "  lst.inject(0) { |acc, x|\
    \ (acc + (lst[x%2] == 0 ? 0 : 1)) }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\n`inject(0) { |acc, x| (acc + (lst[x%2] == 0 ? 0 : 1)) }` can be written\
    \ as `inject(&:+)`\n<|/ c |>\n<| c |>\n`reduce(0) { |sum, x| sum + x % 2 }` is\
    \ just `sum + sum % 2`, or even simpler, `sum.odd?`\n<|/ c |>\n<| a |>\nHere's\
    \ another way to think of it:\n<code>", "    even.each { |i| sum+= i if i.even?\
    \ }\n    sum\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI haven't tried this solution\
    \ yet. I will give it a shot, thank you.\n<|/ c |>\n<| c |>\nI haven't been able\
    \ to test this either, but I'll do that asap. Thanks again, I'll let you know\
    \ if it works.\n<|/ c |>\n<| c |>\nHmm it didn't work, for some reason I still\
    \ get a wrong answer :( I'll try and update my question to show my current code.\n\
    <|/ c |>\n<| c |>\nI'm still having trouble with my code. I updated the question\
    \ to show my new code - I've been working on it for a while now and I can't seem\
    \ to get it to work. If you can help with that I'd be very grateful.\n<|/ c |>\n\
    <| a tags=ruby,algorithm dscore=0 |>\nIf you need a very fast solution, try this:\n\
    <code>\nrequire 'set'", "  sum = 0\n  lst.sort.each do |i|\n    sum += i % 2 ==\
    \ 0 ? i : -1\n  end\n  sum\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nYou just\
    \ need to check the index of the element and use the ternary operator\n<code>",
  "  lst.each_with_index do |i,j|\n    if j%2==0\n      lst.delete_at(i)\n    end\n\
    \  end\n  lst.inject(0) { |sum, el| sum+el}\nend\n</code>\n<|/ a |>\n<| c |>\n\
    That is a nice solution! But it fails if the array has two elements which are\
    \ evenly divisible by 2 and one of which is odd. Your solution will return 0 in\
    \ this case\n<|/ c |>\n<| a dscore=0 tags=ruby,arrays |>\nI think this is the\
    \ easiest to understand and use:\n<code>", "    odd = lst.each_with_index.map\
    \ {|x, i| x if i % 2 == 1}\n    even = lst.each_with_index.map {|x, i| x if i\
    \ % 2 == 0}\n    even.inject(:+) - odd.inject(:+)\nend\n</code>\n<|/ a |>\n<|\
    \ a dscore=3 |>\nHere is another approach to solve this question by using map\
    \ and reject methods of Array class.\n<code>", "  lst.reduce(:+)\nend", "  lst.sort!\n\
    \  even = lst[even_index]\n  odds = lst[odd_index]\n  even.map!{|x| x % 2 == 0\
    \ ? nil : x}\n  odds.map!{|x| x % 2 == 1 ? nil : x}\n  even.inject(0){|a, b| a\
    \ + b}.to_i\nend", "  arr.select {|x| x % 2 == 1 }.sum\nend\n</code>\n<|/ a |>\n\
    <| a |>\nRuby also has a sum method:\n<code>\narr = [5, 8, 7, 1]\narr.sum( &:odd?\
    \ )", "    even = lst.select {|e| e % 2 == 0}\n    odd = lst.select {|e| e % 2\
    \ != 0}\n    even.inject(0) {|result, element| result + (element * 2)}\nend\n\
    </code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\nWhile this may be the most efficient\
    \ solution, it is also a O(n^2) solution.\n<|/ c |>\n<| c |>\nThe only downside\
    \ is that this solution doesn't allow the method to accept empty lists and it\
    \ will always return 0.\n<|/ c |>\n<| c |>\nWhat about [1,2,3]? You will get 6\
    \ as output but you should be getting 5. Is that correct?\n<|/ c |>\n<| c |>\n\
    `[1, 2, 3]` gives `6` in my Ruby 2.1 console. If you are doing something like\
    \ that, you are doing it wrong.\n<|/ c |>\n<| c |>\nThis code returns nil for\
    \ empty lists. Try it out for yourself.\n<|/ c |>\n<| a dscore=5 |>\n<code>",
  "  return lst.select(&:odd? ? 0 : &:even?).reduce(:+)\nend\n</code>\n<|/ a |>\n\
    <| a dscore=2 |>\nAs your question states you want a solution for arrays of any\
    \ length, and to also exclude negative numbers. Here is a solution for arrays\
    \ of any length with one loop:\n<code>", "  return lst.count { |i| i % 2 == 1\
    \ } * lst[0 .. lst.count { |i| i % 2 == 0 }-1].inject(0, &:+)\nend", "  return\
    \ sum(lst[lst.length-1] - lst[2...-1] % 2 = 0) if lst != nil \n  0\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nThe answer to your problem is really simple. Just\
    \ use the % operator. This will divide any number by 2 and return the remainder.\
    \ So, in your case the code will look like this:\n<code>", "    evens = []\n \
    \   odd = []\n    evens.each_index { |index| evens << lst[index] if index % 2\
    \ == 0 }\n    odd.each_index { |index| odd << lst[index] if index % 2 != 0 }\n\
    \    evens.inject(0) { |total,number| total + number }\n    odd.inject(0) { |total,number|\
    \ total + number }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYour solution doesn't\
    \ account for duplicates, so the solution doesn't answer the question. Also your\
    \ solution doesn't handle duplicates.\n<|/ c |>\n<| c |>\nThis is an elegant solution.\
    \ Thank you for adding that in.\n<|/ c |>\n<| c |>\nGreat answer. Thanks for providing\
    \ such a compact solution to your problem.\n<|/ c |>\n<| c |>\nGreat answer! This\
    \ should be the accepted solution!\n<|/ c |>\n<| a tags=ruby dscore=2 |>\nHere's\
    \ a solution that doesn't require sorting the array twice:\n<code>", "    even\
    \ = []\n    odd = []\n    i = 0\n    while i < lst.size\n        if i % 2 == 0\
    \ then\n            even << lst[i]\n        else\n            odd << lst[i]\n\
    \        end\n        i += 1\n    end", "  lst.sort\n  even = even.new(lst.count)\n\
    \  even.each { |e| e&.odd } # odd element to even\n  even.each { |e| e&.even }\
    \ # even element to odd\n  lst.inject(0) { |sum, e| sum + e }\nend\n</code>\n\
    <|/ a tags=algorithm,ruby |>\n<| c |>\nNice use of inject (+1). But the code could\
    \ be simplified by using group_by instead of inject and selecting only the odd\
    \ elements: even.map(&:odd).sum(&:itself)\n<|/ c |>\n<| c |>\nThe group_by idea\
    \ does seem like an interesting one!\n<|/ c |>\n<| a |>\nHere is a purely functional\
    \ approach that uses enumerators to generate an intermediate data structure.\n\
    <code>", "  sum = 0\n  for x in lst\n    if x.odd? && x.even?\n      sum += x\n\
    \    end\n  end\n  sum\nend\n</cell>\n<cell>\nsolution([5, 8, 7, 1]) == 12\nsolution([3,\
    \ 3, 3, 3, 3]) == 9\nsolution([30, 13, 24, 321]) == 0\n</cell>\n<cell>", "   \
    \ even = lst.select{|e| (e % 2 == 0)}\n    odd = lst.select{|e| (e % 2 != 0)}\n\
    \    even.inject(0){|sum, el| sum + el if el % 2 == 1}\nend\n</code>\n<|/ a tags=arrays,ruby\
    \ |>\n<| a |>\nAnother Ruby solution using Enumerable#slice_when:\n<code>\narr\
    \ = [5, 8, 7, 1, 3, 3, 3, 3, 3, 30, 13, 24, 321]\narr.slice_when{ |i| i % 2 ==\
    \ 0 }.sum", "    arr = []\n    for i in lst\n        if i%2 == 0\n           \
    \ arr << i\n        else\n            if arr.empty?\n                arr << i\n\
    \            elsif arr.last(2).last < i\n                arr << i\n          \
    \  end\n        end\n    end\n    arr.inject(0, :+);\nend\n</cell>\n<cell>\nsol\
    \ = solution([5,8,7,1])\nsol\n</cell>\n<cell>", "    even = even.sum :odd => :even\n\
    \    even.map { |e| lst[e] }.reduce(:+)\nend\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ for sharing your solution!\n<|/ c |>\n<| a tags=ruby |>\nHere's an alternative\
    \ version which avoids map and reduce:\n<code>", "  return lst.sum { |x| x.odd?\
    \ if x.odd? }\nend", "  odd, even = 0, 0\n  lst.each do |i|\n    odd += 1 if i\
    \ % 2 == 0\n    even += 1 if i % 2 != 0\n  end\n  odd + even\nend\n</cell>\n<cell>",
  "  result = 0.0\n  lst.each_with_index do |e, i|\n    result += (e * i) if (i %\
    \ 2 != 0)\n  end\n  result\nend", "  return lst.inject(0) { |sum, number| sum\
    \ + number.odd? ? sum : sum + number }\nend", "  even = []\n  odd = lst.inject([])\
    \ {|sum,e| sum.push e if e % 2 != 0; sum}\n  even.inject(0) {|sum, e| sum + odd.find\
    \ {|x| x == e}}\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby |>\n<code>",
  "  result = nil\n  for i in 0...lst.length-1\n    if i % 2 == 0 then\n      if result\
    \ == nil then\n        result = lst[i]\n      else\n        result = result +\
    \ lst[i]\n      end\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm\
    \ |>\n<| a dscore=0 |>\nA nice ruby one-liner for this particular problem:\n<code>\n\
    [1,2,3,4,5,6].detect {|e| e % 2 == 1 }\n</code>\n<|/ a tags=ruby,arrays,algorithm\
    \ |>\n<| c |>\nI don't think this works when the list is empty: `[].detect {|e|\
    \ e % 2 == 1 }` => nil\n<|/ c |>\n<| c |>\nYou're right, but as I see it this\
    \ one is even more readable than my approach. I will edit my answer.\n<|/ c |>\n\
    <| a |>\nThis is an old question, but I came across it looking for an answer and\
    \ thought I would offer my solution without using map or inject:\n<code>", " \
    \ lst.sort.reduce(:+) \nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhy do you want\
    \ to sort the list? `reduce` without an initial value will just return the last\
    \ element anyway.\n<|/ c |>\n<| c |>\nBecause the OP's question was *\"Is there\
    \ a better way of doing this?\"* and I wanted to show that this is *not* the way\
    \ to go (which I did initially as well). You cannot pass something other than\
    \ the last element. Your answer should probably have that caveat. Also, the OP's\
    \ question was *not* about finding the sum of all odd elements that are in even\
    \ positions. Your answer shows that this works.\n<|/ c |>\n<| c |>\n\"*Your answer\
    \ shows that this works*\" What do you mean? `reduce` without an initial value\
    \ just returns the last element, doesn't it?\n<|/ c |>\n<| c |>\nNo, reduce without\
    \ an initial value will just return the last element (or the initial value) from\
    \ the array\n<|/ c |>\n<| c |>\n`reduce` with an empty initial value still returns\
    \ the last element\n<|/ c |>\n<| a dscore=1 |>\nThis can be done without any looping\n\
    <code>", "  sum = 0\n  even = []\n  odd =[]\n  for i in lst\n    if i.even?\n\
    \      even << i\n    elsif i.odd?\n      odd << i\n    end\n  end\n  even.each\
    \ do |i|\n    sum += i\n  end\n  odd << -1 \n  odd.each do |i|\n    sum += i\n\
    \  end\n  return sum\nend\nprint solution([5, 8, 7, 1])\nprint solution([3, 3,\
    \ 3, 3, 3])\nprint solution([30, 13, 24, 321])\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a tags=ruby |>\nHere is a solution that uses inject and does not use recursion.\
    \ I find the use of a map call more elegant than a while loop, especially since\
    \ the accumulator does not need to be an array. \n<code>", "    evensum=0\n  \
    \  evensum=evensum+lst[evensum]\n    return evensum\nend", "  return lst.select{|e|\
    \ e % 2 == 1 && lst[e.odd?]}.sum\nend", "  return lst.select { |e| e % 2 == 1\
    \ }.inject(:+).to_i\nend\n</cell>\n<text>\nRecursion\nThe function must not use\
    \ any built-in Ruby methods.", "  lst.each do |x|\n    x.even? ? sum += x : sum\
    \ \n  end\n  sum\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays\
    \ |>\nThe solution which works for me is as below:\n<code>", "  lst = lst.sort_by{|e|\
    \ -e}\n  odd, even = 0, 0\n  lst.each do |x|\n    if x.is_odd?\n      odd += x\n\
    \    else\n      even += x\n    end\n  end\n  odd.to_s + even.to_s\nend\n</cell>\n\
    <cell>\nsolution([5, 8, 7, 1])\n</cell>\n<cell>\nsolution([3, 3, 3, 3, 3])\n</cell>\n\
    <cell>\nsolution([30, 13, 24, 321])\n</cell>\n<text>\nSolution 2 - Using filter\
    \ and inject", "    return lst.inject(:+).delete_if{|e| e % 2 == 1}\nend", " \
    \ lst.sort.each_with_index { |e,i| return e if i%2 == 1 } \n  0\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 tags=ruby,algorithm |>\nJust out of curiosity:\n\
    <code>", "  lst.each do |i|\n    even = lst.select {|x| x % 2 == 0}\n    odd =\
    \ lst.select {|x| x % 2 != 0}\n    even.inject(0) {|sum, i| sum + i if even.include?(i)}\n\
    \  end\nend", "  return lst.inject(:+)%2 if lst.any?\n  0\nend", "  lst.each_with_index.inject(0)\
    \ {|sum, (e, i)| sum += i%2 == 0 ? e : 0}\nend\n</cell>\n<code language=julia-1.5>\n\
    arr = [5, 8, 7, 1]\nsolution(arr)\n</cell>\n<code language=julia-1.5>\narr2 =\
    \ [3, 3, 3, 3, 3]\nsolution(arr2)\n</cell>\n<code language=julia-1.5>\narr3 =\
    \ [30, 13, 24, 321]\nsolution(arr3)\n</cell>\n<text>\nChallenge 2.1 Write a function\
    \ that takes a vector of integers (lst) and returns the number of positive integers\
    \ less than or equal to each integer in the vector.", "  even = 0\n  odd = 1\n\
    \  sum = 0\n  lst.each do |x|\n    if x % 2 == 0\n      even = even + x\n    else\n\
    \      sum += odd\n      odd = 1\n    end\n  end\n  sum += odd\n  sum\nend\n</cell>\n\
    <text>\nPractice Problem\nWrite a function that takes a list of integers as an\
    \ argument and returns true if the list can be found in a given range, where the\
    \ first number in the range is always smaller than the last number in the range.",
  "  lst.each do |i|\n    if i % 2 == 0\n      lst.delete_at(i)\n    end\n  end\n\
    \  lst.sum\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nThis is a great\
    \ use case for a while loop:\n<code>", "  lst.each_with_index.inject(0) {|sum,\
    \ (x, idx)| sum + x if idx % 2 == 1}\nend", "    even_sum = 0\n    even_count\
    \ = 0\n    odd_sum = 0\n    odd_count = 0\n    \n    for i in lst\n        if\
    \ i.odd?\n            odd_sum += i\n            odd_count += 1\n        else\n\
    \            even_sum += i\n            even_count += 1\n    end\n    \n    even_sum\n\
    \    odd_sum\nend", "  sum = 0\n  for i in lst do\n    if i.odd?\n      sum =\
    \ sum + i\n    end\n  end\n  return sum\nend\n</code>\n<|/ a |>\n<| a tags=ruby\
    \ dscore=0 |>\nFor Ruby 1.8.7+ (I believe 1.9.2 has Hash support) you can do:\n\
    <code>\nlst.each_with_index.inject{|sum, el, i| sum + el if i.odd?}\n</code>\n\
    If Ruby 1.8.7 is not an option, this should be equivalent to:\n<code>\nlst.each_with_index.inject{|sum,\
    \ el, i| sum += el if i.odd?}\n</code>\n<|/ a |>\n<| c |>\nI think you misunderstood\
    \ the OP's question. He wants the sum of all odd elements in the list, not the\
    \ sum of all elements.\n<|/ c |>\n<| c |>\n, you're right. I missed that bit.\n\
    <|/ c |>\n<| a |>\nHere is another solution, using a map to store the odd numbers\
    \ while iterating the list to sum up:\n<code>", "  sum = 0\n  for i in 0...lst.size\n\
    \    sum+=lst[i]<<1\n  end\n  return sum\nend\nputs solution([5, 8, 7, 1])\nputs\
    \ solution([3, 3, 3, 3, 3])\nputs solution([30, 13, 24, 321])", "  \n  return\
    \ lst.sum { |x| x.odd? && x.even? ? x + 1 : 0 }\nend", "  lst.each do |i|\n  \
    \  next i  if i.odd?\n    l.odd? ? l.add : l.delete\n  end\n  l\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nSolution #1:\n<code>",
  "  \n  # Your code here\n  even = []\n  odd = []\n  for i in lst\n    if i.even?\n\
    \      even += [i]\n    else\n      odd += [i]\n    end\n  end\n  even.inject(:+)\n\
    end", "  lst.select {|e| e%2 == 1}.inject(:+) # Sum all even numbers\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThanks guys. I appreciate the quick answers.\
    \ I will remember this for next time.\n<|/ c |>\n<| c |>\nYou should accept the\
    \ answer that best answers your question by clicking on the checkmark beside it.\
    \ I suggest reading the [FAQ](http://stackoverflow.com/faq#howtoask).\n<|/ c |>\n\
    <| a tags=ruby,arrays dscore=3 |>\nFor fun:\n<code>", "  sum = 0\n  index = 0\n\
    \  while index < lst.length\n    sum += lst[index] if lst[index] % 2 != 0\n  \
    \  index += 1\n  end\n  sum\nend\n</code>\nYou can use a while loop or a for loop.\
    \  I prefer a while loop.\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nI got it, thanks.\
    \ And thank you for the tip on how to write the while loop.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=1 |>\nThis can be done using inject method.\n<code>\n[5, 8, 7, 1].reject\
    \ { |e| e % 2 }.reject { |e| e % 4 == 0 }.reduce(:+)\n</code>\nThis will remove\
    \ all odd numbers from original array. \nThen remove all numbers that has 0 mod\
    \ 4 i.e. 0, 2, 4, 6... This will leave only even numbers.\nNow simply add them\
    \ together.\n<|/ a |>\n<| a tags=ruby |>\n<code>\nrequire 'pp'", "  return lst.inject(0)\
    \ do |sum,element|\n    sum + element + lst[element.even?-1]\n  end\nend\n</code>\n\
    <|/ a dscore=3 tags=ruby |>\n<| a |>\n<code>\narr = [5,8,7,1]\narr.each_with_index.inject(0)\
    \ do |total,(i,j)|\n  total += j\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n\
    <| a dscore=1 tags=ruby |>\nUse Enumerable#inject to calculate sum of even values\
    \ in a list:\n<code>\na = [5, 8, 7, 1]\na.inject(0) do |sum, elem|\n  sum + elem\n\
    end", "  lst.each_with_index { |i, index| return i if index % 2 == 1 }\n  0\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nAs a side note, `each_with_index`\
    \ can receive a block, which you do not have in your solution (you might want\
    \ to add that to your solution so that others may benefit from it). But `map`\
    \ is much more elegant (readable, maintainable, faster, etc).\n<|/ c |>\n<| c\
    \ |>\nI believe you are right. I was trying to be consistent with the other answers,\
    \ and I probably should have included a block, but I'm going to leave it as-is\
    \ since the OP has it right now.\n<|/ c |>\n<| c |>\nI was trying to be consistent\
    \ with the other answers, and the OP has it right now. I'll leave it as-is because\
    \ I'm a Ruby noob but I'll definitely try to add a block next time I see one.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>\nlst.each_with_index.select { |e, i| i % 2\
    \ == 1 }.inject(:+)\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhy are you using `inject`\
    \ when there is no need for the result to be a sum?\n<|/ c |>\n<| c |>\nTo be\
    \ able to pass it back to `inject` after doing some maths. You can't just use\
    \ to_i, as that would convert the result to an integer before adding it.\n<|/\
    \ c |>\n<| c |>\nThis does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post.\n\
    <|/ c |>\n<| c |>\nI believe this actually does provide an answer. `inject` calls\
    \ the block on each element in the array and returns the sum of the block's return\
    \ values. `lst.each_with_index.select { |e, i| i % 2 == 1 }` returns an array\
    \ of the odd indexes from the input array. Then, `inject` sums those odd indexes.\
    \ My answer is exactly the same.\n<|/ c |>\n<| c |>\nIf this was the answer, I'd\
    \ appreciate it if you could mark it as such (click on the check mark next to\
    \ the answer). I can't think of any other way to indicate that this is an answer,\
    \ even though it is.\n<|/ c |>\n<| a tags=ruby dscore=1 |>\n<code>", "  lst.each_with_index\
    \ { |x, i| i + x % 2 }.reduce(:+)\nend", "    even = lst[1..-1].select {|i| i\
    \ % 2 == 0}\n    odd = lst.select {|i| i % 2 != 0}\n    even.inject(0) {|sum,\
    \ i| sum + odd.find {|j| j == i}}\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    A non-rubyish way to do the same thing but with the rubyish style of thinking:\n\
    <code>\narr = [5, 8, 7, 1]\neven = arr.select { |n| n % 2 == 0 }\nodd = arr.select\
    \ { |n| n != odd }\neven.inject(0) { |sum, e| sum + odd.index(e) }\n</code>\n\
    <|/ a tags=ruby dscore=1 |>\n<| a dscore=1 tags=ruby |>\nHere's another way to\
    \ do it:\n<code>", "  sum = 0\n  lst.each_index do |i|\n    sum += lst[i..i].inject(0){|sum,\
    \ e| sum + (e % 2 != 0 ? e : 0)}\n  end\n  sum\nend", "  return lst.each_with_index.reduce(:+).even?\
    \ ? lst.sum - lst.sum.odd? : 0\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<| c |>\nThank you for this! You didn't even use `solution` in the first\
    \ place, though. That's a pretty cool trick.\n<|/ c |>\n<| c |>\nNicely done.\
    \ I thought `each_with_index` would make this code better, but I guess not.\n\
    <|/ c |>\n<| c |>\nYeah, I guess it took more time to type this up. :) Thanks!\n\
    <|/ c |>\n<| a dscore=4 tags=ruby,arrays,ruby-on-rails |>\n<code>", "  return\
    \ lst.inject(:+)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
