name: HumanEval_30_get_positive
language: rb
prompt: "# Return only positive numbers in the list.\n# >>> get_positive([-1, 2, -4,\
  \ 5, 6])\n# [2, 5, 6]\n# >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
  # [5, 3, 2, 3, 9, 123, 1]\ndef get_positive(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_positive\n\
  \    candidate = method(:get_positive)\n    assert_equal([4, 5, 6], candidate.call([-1,\
  \ -2, 4, 5, 6]))\n    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5,\
  \ 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([], candidate.call([-1,\
  \ -2]))\n    assert_equal([], candidate.call([]))\n  end\nend\n"
completions: ["\tpositive = []\n\tfor i in l\n\t\tif i > 0\n\t\t\tpositive.push(i)\n\
    \t\n\treturn positive\nend", "  l.select { |x| x > 0 }\nend", "  l.select { |x|\
    \ x > 0 }\nend", "    l.map!{|x| x > 0 ? x : nil}\n    l.compact!\n    l.uniq\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=4 |>\nA solution based on\
    \ Enumerable#grep and Array#uniq.\n<code>", "  return l.select {|x| x > 0 }\n\
    end", "  return l.select { |x| x > 0} \nend", "  return l.select { |x| x >= 0\
    \ }\nend\n</code>\nNote that this implementation differs from get_positive([5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) because [5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10] returns negative numbers only.\n<|/ a dscore=2 tags=ruby,list |>\n<|\
    \ a dscore=1 tags=ruby,list |>\nA slight variant of Ruby's Enumerable#grep :\n\
    <code>", "    positive = []\n    \n    for num in l\n        if num > 0\n    \
    \        positive.push(num)\n        end\n    end\n    \n    return positive\n\
    end\n</cell>\n<cell>", "    positive = []\n    positive.concat(l)\n    positive.delete_if\
    \ { |x| x < 0 }\n    positive\nend", "  l.collect! { |x| x if x > 0 } \nend\n\
    </code>\nThe collect function can be replaced with a simple loop:\n<code>", " \
    \ l.map!(&:abs); l.sort!; l.select!(&:>0); l\nend", "  l.select { |e| e > 0 }\n\
    end", "  l.select { |x| x > 0 }\nend", "  l.map!{ |x| x > 0 ? x : nil }\n  l\n\
    end\n  ", "  l.select {|x| x > 0}\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3.1,ruby-on-rails-3\
    \ dscore=2 |>\n<| a |>\nI liked the answer of but needed a function that could\
    \ take an array or hash and return a new array with only positive values from\
    \ the original array. \n<code>", "  l.map(&:abs)\nend", "  l.select! {|i| i >\
    \ 0} # Remove negative numbers.\n  l.sort! {|a, b| a<=>b }\n  l\nend\n</code>\n\
    <|/ a tags=ruby,arrays,sorting |>\n<| a tags=ruby,arrays,sorting |>\nThe problem\
    \ is that the default sorting order is the one returned by Array#<=>. Since you're\
    \ sorting a custom object, you can fix this by giving the default object a custom\
    \ comparison method:\n<code>", "  l.select { |x| x > 0 }\nend", "  l.collect {|x|\
    \ x > 0 ? x : nil}\nend", "    l.select { |x| x > 0 }\nend\n</code>\nThe second\
    \ part of your question involves counting how often an element appears in a list,\
    \ which you can do very elegantly with inject:\n<code>", "\tpositive = []\n\t\
    for i in l\n\t\tnegative << i\n\t\tpositive << i - i\n\tend\n\t\n\treturn positive\n\
    end", "  l = l.select{|x| x > 0}\nend", "  l.sort!\n  l.reverse!\n  l.reject!{|x|\
    \ x < 0}\n  l.reverse\nend", "  l.map { |x| x > 0 ? x : nil }.compact\nend", " \
    \ l.map { |x| x < 0 ? x : nil }\nend", "  l.select { |i| i > 0 }\nend", "  l.select{|x|\
    \ x > 0 }\nend\n</pre>\n</div>", "  l.select { |x| x > 0 }\nend", "  if l.is_a?\
    \ Array\n    l.select {|i| i > 0}\n  else\n    []\n  end\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nI like how you separated the logic to decide what type to return.\n\
    <|/ c |>\n<| c |>\nThis implementation will probably be slower than the one I\
    \ suggested because it makes a lot of redundant comparisons between `a` and `b`.\
    \  (The current implementation makes one comparison per element in the array,\
    \ and then a second comparison for the length comparison.  My implementation will\
    \ make one comparison per element, then a second comparison for the length comparison.\
    \  This means that my implementation will do two comparisons per element, while\
    \ yours will do four comparisons per element.)  This would be a good reason to\
    \ implement it using the `sort` method, though.\n<|/ c |>\n<| c |>\nI didn't mean\
    \ this to be a comprehensive solution for finding all the positive integers in\
    \ a list.  I merely wanted to demonstrate that there's nothing wrong with using\
    \ `map` and `select`.\n<|/ c |>\n<| c |>\nI wasn't trying to imply that your solution\
    \ is wrong.  I really didn't want to write an answer that basically said, \"Use\
    \ `select`.  It works.\"\n<|/ c |>\n<| a |>\nYou can use Enumerable#inject for\
    \ that. Here's a more compact implementation, if you like:\n<code>", "    positive\
    \ = []\n    if l[0] > 0\n        positive.push l[0]\n    end\n    if l[1] > 0\n\
    \        positive.push l[1]\n    end\n    positive\nend", "    l.select { |el|\
    \ el > 0 }\nend", "  l.select{|e| e > 0}.collect{|e| e}\nend\n</cell>\n<cell>",
  "  l.select { |e| e > 0 }\nend", "  l.select { |n| n >= 0 }\nend", "  l.select {\
    \ |x| x >= 0 }\nend", "  l.compact.select{|x| x > 0}\nend", "    return [ x for\
    \ x in l if x > 0 ]\nend", "  return l.select{|i| i > 0} \nend\n</code>\nAnd then\
    \ we define a simple function that takes a list of positive numbers and finds\
    \ the sum of the negatives up to a certain number (the number should be in the\
    \ list at least as large as the sum of positive numbers in the list). \n<code>",
  "  l.select{ |x| x > 0 }\nend", "  return l.select {|x| x > 0 }\nend", "  l.map!\
    \ {|x| x if x > 0}\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nThis\
    \ is my solution:\n<code>", "  l.each { |el| el > 0 ? yield el : nil }\nend",
  "  l.map{|n| n if n >= 0}\nend", "  l.collect { |x| x if x > 0 }\nend", "  return\
    \ l.select { |x| x > 0 }\nend\n</cell>\n<code language=ruby-1.9.3-p448>", "  l.select\
    \ { |x| x > 0 }\nend", "  l.select { |i| i > 0 }\nend\n</code>\nThe last part\
    \ is the same as previous code, but here we take only unique elements from list.\
    \ We do it with HashSet - Set removes duplicate entries.\n<|/ a |>\n<| c |>\n\
    Please explain the last part more clearly. Do you mean `l.select { |i| i > 0 }.uniq`\
    \ ?\n<|/ c |>\n<| c |>\nNo, it's `l.select { |i| i > 0 }.uniq`. `uniq` removes\
    \ duplicates. For example, `[3, 4, 3, 4, 3].uniq == [3, 4, 3]`. `uniq!` returns\
    \ modified array.\n<|/ c |>\n<| a tags=ruby |>\nJust in case someone needs an\
    \ explanation about the accepted answer:\n<code>", "  l.map { |i| i if i > 0 }\n\
    end", "  l.map!(&:abs).select!(&:positive?)\nend", "  l.map! do |x| x >= 0 ? x\
    \ : nil end\n  l\nend", "  l.select{ |x| x > 0 }\nend", "    l.each do |num|\n\
    \        if num > 0\n            yield(num)\n        end\n    end\nend\n</code>\n\
    With this you can simply write:\n<code>\nget_positive([-1, 2, -4, 5, 6]).each\
    \ { |num| do_something(num) }\n</code>\n<|/ a dscore=4 tags=ruby,arrays,loops,enumerator\
    \ |>\n<| a |>\n<code>\n[1,2,3].select{|x| x > 0}\n</code>\nThis way is a bit more\
    \ idiomatic. The code can be easily read and understood.\n<|/ a dscore=4 tags=ruby,arrays,loops,enumerator\
    \ |>\n<| a dscore=3 |>\n<code>\narray.select { |x| x > 0 }\n</code>\n<|/ a tags=ruby,arrays,loops,enumerator\
    \ |>\n<| c |>\nThis answer assumes you have an `array` (in Ruby 1.9.2 at least).\
    \ In Ruby 1.8.7 it throws a `NoMethodError: undefined method 'select' for []:Array`.\n\
    <|/ c |>\n<| c |>\nYou are correct, I just looked it up. `select` is only defined\
    \ on `Enumerable`, so you need to call it on an `Enumerable` like `array.each`\
    \ or `array.to_enum`.\n<|/ c |>\n<| c |>\nNope, you're wrong. It works fine on\
    \ arrays in Ruby 1.9.2, 1.8.7 and 1.9.3. It's not defined on `Array` because `Array`\
    \ doesn't have enumerator methods, but `Enumerable` does. I guess it used to be\
    \ a method on `Array` in 1.8.7, but was removed.\n<|/ c |>\n<| c |>\nI just tested\
    \ it, and you're right it works just fine on 1.8.7. But it won't work on 1.9.2,\
    \ 1.9.3 or 1.9.4. I suppose they never added the method to the Array.\n<|/ c |>\n\
    <| c |>\nIt does work on 1.9.2 and 1.9.3. It's just that it returns nil on 1.9.4\
    \ because the enumerator methods are gone from the Array class in 1.9.4.\n<|/\
    \ c |>\n<| a tags=ruby,arrays,loops,enumerator dscore=3 |>\n<code>\n[1,2,3,4,5].select{|x|\
    \ x > 0}\n</code>\n<|/ a |>\n<| a tags=ruby,arrays,loops,enumerator |>\n<code>\n\
    array = [1, 2, 3, 4]\narray.select { |x| x > 0 }", "  return l.select { |x| x\
    \ >= 0 }\nend", "  l.sort\n  l.select { |x| x > 0 }\nend\n</code>\n(The return\
    \ is just to keep the code looking readable. Feel free to omit it.)\nI like the\
    \ second approach because the code is more concise. Also, you avoid having to\
    \ define your own method.\nHowever, you do need to define a method named \"get_positive\"\
    \ in the first approach, because Ruby cannot find the method get_positive you\
    \ defined.\nThe first approach is more elegant because it uses the concept of\
    \ \"methods\". Ruby has many built-in methods, like \"append\" and \"select\"\
    . You can define a method with the same name as another built-in method, and Ruby\
    \ will find the method you want to define and define it for you.\nThis way, you\
    \ don't need to define methods by hand.\nIf you think about it a little more,\
    \ you might think that Ruby could find \"get_positive\" on the left side of the\
    \ \"=\" sign by simply looking at the method name on the right side of the \"\
    =\" sign.\nThat doesn't work because Ruby can't find the method get_positive on\
    \ the left side of the \"=\", because it doesn't exist.\n<|/ a dscore=3 |>\n<|\
    \ a |>\nYes. You can do that. Here's a simple example:\n<code>", "  l.select{\
    \ |x| x >= 0 }\nend", "    positive = []\n    positive.extend(l)\n    positive.sort",
  "  return l.collect { |x| x > 0 ? x : nil }\nend", "  l.each do |x|\n    next if\
    \ x == 0\n    return x\n  end\nend", "  l.select{|x| x > 0 }\nend", "  l.collect\
    \ {|x| x > 0 ? x : nil}\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nFor\
    \ Ruby 1.8 (and 1.9.2) without rails, try this:\n<code>", "    l.select { |x|\
    \ x > 0 }\nend", "  return l.reject { |n| n < 0 }\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nYou need `to_proc`, because `[].reject{ ... }` is an Enumerator,\
    \ and not an Array.\n<|/ c |>\n<| a dscore=3 |>\nIf you're using Rails 4, it's\
    \ better to use Enumerable#select and use reject on the resulting Enumerator:\n\
    <code>", "  l.each { |x| x if x > 0 }\n  l\nend\n</code>\n<|/ a |>\n<| a dscore=4\
    \ tags=ruby |>\nYou can do \n<code>\n[1,2,-3,4].select(&:positive?)\n</code>\n\
    <|/ a |>\n<| c |>\nThis is definitely the most elegant solution for the problem.\
    \ Although it would be nice to see a way to do it with the `find` method.\n<|/\
    \ c |>\n<| c |>\nThis should be the accepted answer, as it does what the OP asked\
    \ for, without cluttering up their code with extra methods. A solution using `find`\
    \ would require more code (and be less efficient).\n<|/ c |>\n<| a tags=ruby |>\n\
    For me the best solution is\n<code>\n[-2, -1, 0, 1, 2].select(&:positive?)", " \
    \ l.select { |x| x >= 0 }\nend", "  return l if l and l[0] >= 0 else []\nend",
  "  l.compact.select { |x| x > 0 }\nend", "  l.select { |x| x > 0 }\nend", "  l.select\
    \ { |x| x > 0 }\nend", "  l.compact.select{|e| e > 0 }\nend", "  if l == nil then\n\
    \    return nil\n  end\n  local new_list = nil\n  for i = 1, #l do\n    if tonumber(l[i])\
    \ then\n      new_list = new_list or {}\n      new_list[#new_list+1] = l[i]\n\
    \    end\n  end\n  if new_list ~= nil then\n    return new_list\n  end\n  local\
    \ new_list = nil\n  for i = 1, #l do\n    if l[i] < 0 then\n      new_list = new_list\
    \ or {}\n      new_list[#new_list+1] = l[i]\n    end\n  end\n  return new_list\n\
    end", "  l.each do |x|\n    if x >= 0\n      return x\n    end\n  end\n  return\
    \ nil\nend", "  l.map!{|x| x if x >= 0}\nend", "  l.compact.select {|x| x >= 0}\n\
    end", "  if l.size < 2\n    []\n  else\n    l.grep(->r {r.positive?}.uniq)\n \
    \ end\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nA variation on the answer from\
    \ Yakov Chakraborty but shorter and a little bit more efficient:\n<code>", " \
    \ l = l.to_a\n  l.reverse!\n  l.reject!{|x| x == 0} if l.size > 0\n  l\nend",
  "  l.map!(&:abs)\n  l.select!(&:positive?)\n  l\nend", "  return l.select{|x| x\
    \ > 0}\nend", "  l.each { |x| if x > 0 then return x else return nil }\nend\n\
    </cell>\n<text>\nQuestion 4.\nWrite a function that can return all positive numbers\
    \ in a list that do not exist in a second list.", "  l.select { |x| x >= 0 }\n\
    end", "  return l.select { |n| n > 0 }\nend", "    l.each_index do |i|\n     \
    \   l[i] <=> 0 if (l[i] < 0)\n    end\n    l\nend\n</code>\nThis gives the following\
    \ performance (by using the same random array as above)\n<code>\n[get_positive(generate_random_array(100_000)),\
    \ get_positive(generate_random_array(100_000))].each do |result|\n        puts\
    \ result.inspect\n        puts \"\\t#{result.size} elements\"\n    end\n</code>\n\
    <code>\n[#<BigDecimal:7fe0f1e416d0:'0.0',27(27)>]\n[#<BigDecimal:7fe0f1e416d0:'0.0',27(27)>,\
    \ #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>]\n[#<BigDecimal:7fe0f1e416d0:'0.0',27(27)>,\
    \ #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>, #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>,\
    \ #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>, #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>,\
    \ #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>, #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>,\
    \ #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>, #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>,\
    \ #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>, #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>,\
    \ #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>, #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>,\
    \ #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>, #<BigDecimal:7fe0f1e416d0:'0.0',27(27)>,\
    \ #<BigDecimal:7fe0f1e416d0:", "  return l.reject { |x| x < 0 }\nend", "  l.collect{|i|\
    \ i.positive?}\nend", "    l.each do |i|\n        if i < 0\n            l.delete(i)\n\
    \        end\n    end\nend", "    positive = []\n    for i in l\n        if i\
    \ > 0 then\n            positive.push(i)\n    end\n    return positive\nend",
  "    l.select{|a| a > 0}\nend\n</code>\nAs I mentioned above, I haven't yet thought\
    \ of a way to do this in one line.\n<|/ a tags=ruby,arrays dscore=1 |>\n<| c |>\n\
    This doesn't work for the second example. It returns `[6, 3, 9, 123, 1, -10]`\
    \ when it should return `[5, 3, 2, 3, 9, 123, 1]`.\n<|/ c |>\n<| c |>\nRight,\
    \ forgot about that. I added a fix for that.\n<|/ c |>\n<| c |>\nThe \"one line\"\
    \ requirement is probably a sign of poor abstractions, as in \"too much magic\"\
    .\n<|/ c |>\n<| c |>\nI agree that it is poor abstraction. I think I like the\
    \ other solutions better, but it's certainly possible that there is a nice Ruby\
    \ way to do this. One might want to use some \"ruby magic\" here, but that would\
    \ require quite a bit of refactoring to make it \"nice\".\n<|/ c |>\n<| c |>\n\
    I like this answer the best so far. I like the idea of splitting it into a helper\
    \ function which makes the code more readable. However, the other answers do more\
    \ in the way you suggest.\n<|/ c |>\n<| a dscore=1 |>\nHere's a method that returns\
    \ a new array with the positive elements removed using Array#delete_if:\n<code>",
  "  l.collect{|x| x if x >= 0}.compact\nend", "  l.collect{|x| x<0 ? nil : x}\nend\n\
    </code>\nThen you can easily use map for filtering out the negative numbers, e.g.:\n\
    <code>\nnumbers = [-1, 2, -4, 5, 6]", "  return l.select(&:positive?)\nend", " \
    \ l.select { |x| x > 0 }\nend", "  l.select { |x| x >= 0 }\nend", "  l.select\
    \ { |x| x >= 0 }\nend", "    l.each_index do |i|\n        if l[i] > 0\n      \
    \      l.remove(i)\n        end\n    end\nend", "  l1 = []\n  for i in l\n   \
    \ if i >= 0\n      l1 += [i]\n    end\n  end\n  return l1\nend\n</cell>\n<code\
    \ language=julia-1.0>", "  l.select { |x| x != 0 }\nend", "    positive=[]\n \
    \   for i in l\n        if i>0\n            positive.push(i)\n    return positive\n\
    end", "  l.map! { |el| el if el > 0 }\nend", "  return l.select { |x| x > 0 }\n\
    end", "  if l.empty? || l.length == 0\n    return nil\n  end\n  positive = []\n\
    \  positive.concat l[1..-1]\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis won't\
    \ work for the last element in an array, as `nil` is returned and `positive.concat`\
    \ gets called on the empty array returned from the original method call.\n<|/\
    \ c |>\n<| c |>\nI see, I forgot to mention that case. Thanks for your answer\n\
    <|/ c |>\n<| c |>\nI updated the code, to return nil if array is empty\n<|/ c\
    \ |>\n<| c |>\n`get_positive` returns an array containing a copy of the numbers\
    \ in `l`, but `positive.concat l[1..-1]` doesn't return a copy of `l`, it returns\
    \ a new array containing a copy of all the numbers after the first one.\n<|/ c\
    \ |>\n<| a tags=ruby,arrays |>\nHere is a solution using Array#slice_after:\n\
    <code>", "\tl.select { |v| v >= 0 }\nend", "  l.select{|x| x > 0}\nend", "  l.select\
    \ { |e| e > 0 }\nend", "  l.compact.select{|x| x > 0}\nend", "    l.select { |i|\
    \ i > 0 }\nend", "\tl.sort\n\tl.reverse\n\tl.select{|v| v > 0}\nend", "    l.sort!\n\
    \    l.reverse!\n    l.delete_if{|x| x < 0}.compact!\n    l\nend", "  l.select\
    \ { |n| n > 0 }\nend", "  l.select {|x| x >= 0} # Filter out non-positive numbers.\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nAs you requested a solution\
    \ in Ruby, here's one approach:\n<code>", "  return l.select { |i| i >= 0 }\n\
    end", "  l.select { |n| n > 0 }\nend", "  l.select { |x| x >= 0 }\nend", "  l.select(&:positive?)\n\
    end", "  l.select{|x| x > 0}\nend", "  l.collect {|x| x.is_a?(Fixnum) ? x : x.to_i}\n\
    end\n</code>\nNow you can write your get_negative method like this:\n<code>",
  "  l.select { |x| x >= 0 }\nend", "  return l.filter( &:positive? )\nend", "  l.map!\
    \ { |x| x > 0 ? x : nil }\nend\n</code>\nThe last method can be improved using\
    \ the new select method:\n<code>", "  l.compact.select{|x| x >= 0} \nend\n</code>\n\
    For your example:\n<code>\nget_positive(find_positive_numbers_in_string(find_positive_numbers_in_string(text)))\n\
    </code>\n<|/ a |>\n<| a |>\n<code>", "  return l.select {|x| x >= 0}\nend", " \
    \ l.select {|x| x > 0}\nend", "  l.select{ |x| x > 0 }\nend", "    l.map!{|x|\
    \ x > 0 ? x : nil}\n    l\nend", "    l.map! {|x| x if x > 0}\n    l\nend", " \
    \ return l.reject { |x| x < 0 }\nend", "  l = l.sort\n  l.reverse!\n  l = l[1..-1]\n\
    end", "  l.select { |x| x >= 0 }\nend", "  l.select{|x| x > 0}\nend", "  l.map!\
    \ { |x| x if x > 0 }\nend", "  l.each { |e| return e if e > 0 }\n  l\nend\n</code>\n\
    This uses Enumerable#grep which returns a filtered array.\n<|/ a dscore=0 |>\n\
    <| c |>\nThis is also not an elegant solution, but I guess it would have worked\
    \ for me and I did learn something from it (I was about to learn about Enumerable#grep\
    \ and Enumerable#select).  Thanks!\n<|/ c |>\n<| c |>\nThe elegance comes when\
    \ I use that method to do the same thing with arrays of different types.  For\
    \ instance, what would it look like to have a method get_positive that will return\
    \ a list of positive integers instead of an array of positive integers?  And what\
    \ about negative integers?  Or booleans?  Or a float?  Or an object?  Or any other\
    \ data type.  I could always create another method for each one that deals with\
    \ each data type, but I was wondering if there was a more elegant way of doing\
    \ this.  Thanks!\n<|/ c |>\n<| c |>\nYou can't do this with just the return value.\
    \ Either you create another method for each data type, or you do like `Enumerable#grep`\
    \ and create a separate method for each data type.\n<|/ c |>\n<| c |>\n, Thanks,\
    \ I did find that you could create a separate method for each data type.  I wanted\
    \ to see if there was another solution, as I do find it a very nice way of doing\
    \ things.  Thanks again!\n<|/ c |>\n<| a dscore=0 tags=arrays,ruby |>\nThis is\
    \ what I came up with:\n<code>", "  l.select { |n| n > 0 }\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| c |>\n`&` can be overloaded, so `&.>` works.\n<|/ c |>\n\
    <| a dscore=3 |>\nIf you want to return a list containing a list of numbers where\
    \ all positive numbers are removed, you could do:\n<code>\n> [3, 5, -1, -7, 3,\
    \ -2].map(&:abs).select { |n| n > 0  }\n=> [[3, 5], [-3, -7]]\n</code>\n<|/ a\
    \ tags=ruby |>\n<| a tags=ruby dscore=3 |>\nI like Sawdust's answer (using Enumerable#select),\
    \ but thought I'd add another solution that doesn't require conversion to an Array,\
    \ and is also a bit more performant.\n<code>\n[3, 5, -1, -7, 3, -2].delete_if\
    \ { |v| v.zero? }\n</code>\n<|/ a |>\n<| c |>\nThis solution is very elegant.\n\
    <|/ c |>\n<| a tags=ruby |>\nHere's an even more elegant one (using Enumerable#any?):\n\
    <code>", "  l.each do |item|\n    if item >= 0\n      yield item\n    end\n  end\n\
    end", "  l.map { |i| i if i > 0 }\nend", "    positive = []\n    for elem in l\n\
    \        if elem > 0\n            positive.push(elem)\n    return positive\nend",
  "  l.compact.select { |x| x >= 0 }\nend", "  l.select{|x| x > 0}\nend\n</code>\n\
    But since you already know that your list contains all positive numbers, you could\
    \ do this:\n<code>", "  l.select { |e| e > 0 }\nend", "  l.uniq!\n  l.map! {|x|\
    \ x > 0 ? x : nil}\n  l\nend", "  l.collect {|x| x > 0 ? x : nil }\nend", "  \
    \  l.sort!\n    l.uniq.collect { |x| x if x > 0 }\nend", "    l.map{|x| x >= 0\
    \ ? x : nil}\nend", "    l.select{|x| x >= 0}\nend", "  return l.select{|x| x\
    \ > 0}\nend\n</cell>\n<code language=julia-0.5>", "  l.select { |x| x >= 0 }\n\
    end", "  l.select { |x| x >= 0 }\nend", "  l.each {|e| return e if e > 0 }\n \
    \ l\nend", "  l.select {|i| i > 0}\nend", "  l.map { |x| x > 0 ? x : nil }\nend",
  "  if l == []\n    puts \"nil\"\n  else\n    positive = []\n    l.each do |n|\n\
    \      if n > 0\n        positive << n\n      end\n    end\n    puts positive\n\
    \  end\nend", "  l.select {|x| x >= 0}.sort\nend", "  l.compact.uniq.map { |i|\
    \ i if i > 0 }\nend", "  l.select { |x| x > 0 }\nend", "  return l.collect {|x|\
    \ x if x > 0 }\nend", "  l.uniq!\n  l.compact!\n  l.select!{|x| x >= 0}\nend",
  "    l.map! {|x| x > 0 ? x : nil}\nend\n</cell>\n<cell>", "  return l & l.reverse\n\
    end", "  l.select! {|x| x > 0}\n  l.uniq\nend", "  l.select { |x| x >= 0 }\nend",
  "  l.select { |x| x > 0 }\nend", "  l.select { |v| v >= 0 }\nend", "  l.select {\
    \ |x| x > 0 }\nend", "  l.map!{|x| x > 0 ? x : nil}\nend", "  l.select { |e| !e.zero?\
    \ and e > 0 }\nend", "  l.select { |x| x > 0 }\nend", "  return l.select { |x|\
    \ x > 0 }\nend\n</code>\n<|/ a tags=ruby,sorting,ruby-on-rails |>\n<| a dscore=1\
    \ |>\n<code>", "  return l & [0 .. 0]\nend", "    l.select{|x| x > 0}\nend", " \
    \   l.select{|x| x > 0}\nend", "  l.map!(&:abs)\n  l.select { |x| x >= 0 }\nend",
  "    l.delete_if { |x| x < 0 }\n    return l\nend\n</code>\n<|/ a dscore=2 tags=ruby,functional-programming,lambda,list\
    \ |>\n<| c |>\nThis is very similar to what I was thinking of, except I would\
    \ return `[l - l.select { |x| x < 0 }]`\n<|/ c |>\n<| a |>\nHow about this:\n\
    <code>", "    l.map!{|e| e > 0 ? e : nil}\n    l\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nI think this answer would be improved by using a `select` instead\
    \ of `map!` so that if any of the numbers are negative, the whole array is returned\
    \ instead of just the non-negative ones.\n<|/ c |>\n<| c |>\nThis answer has the\
    \ advantage of being very readable and compact, but I find it overly complex.\n\
    <|/ c |>\n<| a |>\nThe shortest one I found so far is this:\n<code>\narr.reject\
    \ { |e| e < 0 }\n</code>\n<|/ a dscore=5 tags=ruby,arrays |>\n<| c |>\n`arr.select\
    \ { |e| e != 0 }`\n<|/ c |>\n<| a dscore=5 tags=ruby,arrays |>\nIn Ruby 1.8.x\
    \ you could do this:\n<code>\n[1,2,-4,5,6].select{|x| x>0}\n</code>\nIn Ruby 1.9.x\
    \ you could do this:\n<code>\n[1,2,-4,5,6].select{|x| x<0}\n</code>\n<|/ a |>\n\
    <| c |>\n`select{|x| x<0}` and `select{|x| x>0}` both have different behavior.\
    \  Try `[1,2,-4,5,6].select{|x| x<0}` to get `[1,2,3,4,5]` and then try `[1,2,-4,5,6].select{|x|\
    \ x>0}` to get `[]`.  This is because `select` returns an array containing only\
    \ the elements returned by the block.\n<|/ c |>\n<| c |>\n: You're absolutely\
    \ right. I was wondering why my answer was downvoted instead of yours. Maybe it\
    \ was downvoted because people are trying to get to grips with the Ruby 1.8.x\
    \ mindset while learning Ruby 1.9.x?\n<|/ c |>\n<| c |>\n: No, they were trying\
    \ to get to grips with the Ruby 1.8.x mindset while learning Ruby 1.9.x. And that's\
    \ exactly what we're seeing here.\n<|/ c |>\n<| c |>\n: Thanks for the explanation.\n\
    <|/ c |>\n<| a tags=ruby,arrays dscore=4 |>\nI find this solution best:\n<code>\n\
    arr.select{|e| e != 0}\n</code>\n<|/ a |>\n<| a tags=ruby,arrays |>\nHow about\
    \ this?\n", "  l.select { |v| v > 0 }\nend", "  return l.select { |e| e > 0 }\n\
    end", "    l.select {|x| x >= 0}\nend", "  positive = []\n  l.each do |x|\n  \
    \  if x > 0\n      positive.push(x)\n    end\n  end\n  return positive\nend\n\
    </pre>", "    l.sort!\n    \n    return l.select { |x| x >= 0 }\nend", "  return\
    \ l.select { |x| x >= 0 }\nend", "  l.map! {|x| x.positive? ? x : nil}\n  l\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,arrays |>\nThis is one way to\
    \ do it - first convert it to an array (thanks to John Wagner)\n<code>", "  l.each\
    \ do |x|\n    unless x > 0\n      return false\n    end\n  end\n  return l\nend",
  "  l.select { |n| n > 0 }\nend", "  return l.select { |e| e > 0 }\nend", "    l.each\
    \ do |number|\n        if number > 0\n            number += 1 # Only add if it\
    \ has a positive number.\n        end\n    end\n    return l\nend\n</code>\nAs\
    \ a final note, you can also use the Enumerable#reject method, instead of creating\
    \ a separate function that would do the same thing, but that's just for completeness.\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails |>\nTo filter out\
    \ negative numbers:\n<code>\n[1,2,3,4,5,6,-6,-3,-5,-4,-3,-2,-1,0,-5,-1,4,6].select\
    \ { |x| x >0 }\n</code>\nTo filter out both positive and negative numbers:\n<code>\n\
    [1,2,3,4,5,6,-6,-3,-5,-4,-3,-2,-1,0,-5,-1,4,6].select { |x| x > 0 }\n</code>\n\
    To filter out only positive numbers:\n<code>\n[1,2,3,4,5,6,-6,-3,-5,-4,-3,-2,-1,0,-5,-1,4,6].select\
    \ { |x| x < 0 }\n</code>\nTo filter out only negative numbers:\n<code>\n[1,2,3,4,5,6,-6,-3,-5,-4,-3,-2,-1,0,-5,-1,4,6].select\
    \ { |x| x <= 0 }\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,ruby-on-rails |>\n\
    Using select:\n<code>\na = [1,2,3,4,5,6,-6,-3,-5,-4,-3,-2,-1,0,-5,-1,4,6]", " \
    \   l.select{|e| e > 0}\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\n\
    The `select` method does not return the elements within the block, instead it\
    \ will return an array of items. Thus it is not possible to chain `map` after\
    \ the `select` method in the OP's example.\n<|/ c |>\n<| c |>\nThanks, you are\
    \ absolutely right about the return statement. I did not test the code in my console.\
    \ Corrected.\n<|/ c |>\n<| a dscore=0 |>\nTo find the sum of positive numbers\
    \ in an array:\n<code>\narr = [-2, 1, -3, 4, -1, 2, 5, -10, 12]\narr.select {\
    \ |i| i.positive? }.inject(:+)\n</code>\n<|/ a tags=ruby |>\n<| c |>\nWhy use\
    \ inject when you can just use the `sum` method on `select`?\n<|/ c |>\n<| c |>\n\
    : Because I felt like it.\n<|/ c |>\n<| c |>\n`select` creates a new array which\
    \ is not necessarily needed. Also, `inject(:+)` gives you `nil` in the last element\
    \ in the array.\n<|/ c |>\n<| c |>\nThe only advantage I can see to using inject\
    \ over sum is that it works on empty arrays whereas sum would raise an error for\
    \ an empty array.\n<|/ c |>\n<| c |>\n: But it works with empty arrays, you just\
    \ have to test for that before calling `inject`.\n<|/ c |>\n<| a |>\nYou can achieve\
    \ this with a single line using Enumerable#sum:\n<code>\nnumbers = [-1, 2, 1,\
    \ -3, 4, -1, 2, 5, -10, 12]\nnumbers.select {|x| x.positive?}.sum\n=> 10\n</code>\n\
    <|/ a tags=ruby dscore=0 |>\n<| a dscore=0 tags=ruby |>\nThis should do it:\n\
    <code>\nnumbers = [-1, 2, 1, -3, 4, -1, 2, 5, -10, 12]\nnumbers.select {|x| x.positive?}.sum\n\
    </code>\n<|/ a |>\n<| a tags=ruby |>\nJust to add another solution using reduce\
    \ (which would be my preference):\n<code>\nnumbers = [-1, 2, 1, -3, 4, -1, 2,\
    \ 5, -10, 12]\nnumbers.reduce(0) { |sum, number| number > 0 ? sum + number : sum\
    \ }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nnumbers = [-1, 2, 1,\
    \ -3, 4, -1, 2, 5, -", "  l.delete_if { |x| x < 0 }\n  l\nend", "  return l.select{|i|\
    \ i>0}\nend", "  l.map{|x| x.positive?}.compact\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThank you for your answer! One thing that I did not understand\
    \ is, how would this help to remove negative numbers from an array while keeping\
    \ all the positive numbers in the same array?\n<|/ c |>\n<| c |>\nI edited the\
    \ post and added a method `get_positive` - try it.\n<|/ c |>\n<| c |>\nHi Ilya,\
    \ thank you for adding the new method you added. I tried it out, and it seems\
    \ to work well! My only concern now is that I am not sure if I understand the\
    \ logic in that method. It seems to return an array of arrays (one for positive\
    \ numbers and another for negative numbers) but I am not sure what else is going\
    \ on behind the scenes. Could you please explain how that method works?\n<|/ c\
    \ |>\n<| c |>\nI added comments inside the method, hope that helps. By the way,\
    \ if you could check my answer, I would appreciate if you accept it, cheers!\n\
    <|/ c |>\n<| c |>\nHi Ilya, thank you for adding that explanation! That was very\
    \ helpful. One thing I am still confused about is how the `positive?` method works\
    \ because I am not completely sure how it works. I understand the method `positive?`\
    \ as a boolean conditional expression that returns true if the object passed as\
    \ an argument is positive? but I am not sure how `l.map{|x| x.positive?}` works.\
    \ I thought it would only return the positive numbers but I guess it actually\
    \ returns a boolean for each element? Also, how does it know to only return positive\
    \ numbers in the array?\n<|/ c |>\n<| a dscore=1 |>\nHere's another solution,\
    \ without the use of negative numbers (just for fun and practice):\n<code>\narr\
    \ = [1,3,-4,-5,6,1,5,8,12,-3]\narr.map { |i| i.abs.min }.uniq\n</code>\nThis code\
    \ will return the minimum (positive) number from the array:\n<code>\n1\n3\n5\n\
    8\n12\n</code>\nExplanation: \nmap calls the given block for each element of the\
    \ array (in your case: for each element, we get the absolute value).\nabs call\
    \ returns the absolute value of a given number.\nmin call return the minimum number\
    \ in the resulting array.\nuniq to remove duplicates (numbers with equal values).\n\
    <|/ a tags=arrays,ruby |>\n<| a dscore=1 |>\nAnother one:\n<code>\narr.group_by(&",
  "    l.map! { |x| x > 0 ? x : nil }\nend\n</code>\nThe first line uses map to iterate\
    \ over the list l and for each element in the list calls method > 0 on it. If\
    \ any value is true (>0), it returns true, otherwise false. nil is used to represent\
    \ a missing value, and nil evaluates to false when used in a boolean expression.\
    \ You can think of nil as a special value that is returned when the method being\
    \ called on a value returns nil.\nNext, we use the map method again to remove\
    \ all elements that are not true. We use filter! to remove any elements that return\
    \ true.\nWe can also do this without using the map method by using reject!\n<code>",
  "    l.select { |e| e > 0 }\nend", "  l.select {|e| e > 0 }\nend", "  l.select {\
    \ |x| x >= 0 }\nend", "  l.select{|e| e.is_a?(Integer) && e > 0}\nend", "    l.each\
    \ do |x|\n        next x unless x > 0 # skip anything less than 0.\n    end\n\
    \    l\nend", "  return l.select { |x| x > 0 }\nend", "  return l[l.map{|x| x\
    \ > 0 ? x : nil}.compact]\nend", "  l.select { |n| n > 0 }\nend", "  l.sort!\n\
    \  return l[l.length..-1]\nend\n</code>\n<|/ a tags=sorting,ruby,arrays |>\n<|\
    \ a dscore=3 |>\n<code>", "    positive = nil\n    positive = l.select { |x| x\
    \ > 0 }\n    positive\nend", "  if l.is_a? Numeric\n    if l.is_a? Integer\n \
    \     return [l.positive]\n    elsif l.is_a? Float\n      return [l.floor]\n \
    \   else\n      return []\n    end\n  elsif l.is_a? Array\n    return l.collect\
    \ {|i| get_positive(i)} + get_positive(l.compact)\n  else\n    return []\n  end\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThat worked perfectly. Thank you! I\
    \ love Ruby so much :)\n<|/ c |>\n<| c |>\nIt would be nice to define `is_positive?`\
    \ as a method of `Numeric`. Perhaps `class Numeric ...; def is_positive?; ...;\
    \ end; end`\n<|/ c |>\n<| a tags=ruby |>\n<code>", "    l.each {|x| return x if\
    \ x > 0;}\n    \n    # Return [] if the list is empty.\n    l.each {|x| return\
    \ [] if x == 0;}\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=0 |>\nThe most\
    \ efficient algorithm I could come up with is this:\n<code>", "  return l.select{|i|\
    \ i >= 0}\nend", "    l.collect! { |x| x > 0 ? x : nil }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
