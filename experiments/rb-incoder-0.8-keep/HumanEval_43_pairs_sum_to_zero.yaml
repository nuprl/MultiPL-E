name: HumanEval_43_pairs_sum_to_zero
language: rb
prompt: "# pairs_sum_to_zero takes a list of integers as an input.\n# it returns True\
  \ if there are two distinct elements in the list that\n# sum to zero, and False\
  \ otherwise.\n# >>> pairs_sum_to_zero([1, 3, 5, 0])\n# False\n# >>> pairs_sum_to_zero([1,\
  \ 3, -2, 1])\n# False\n# >>> pairs_sum_to_zero([1, 2, 3, 7])\n# False\n# >>> pairs_sum_to_zero([2,\
  \ 4, -5, 3, 5, 7])\n# True\n# >>> pairs_sum_to_zero([1])\n# False\ndef pairs_sum_to_zero(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pairs_sum_to_zero\n\
  \    candidate = method(:pairs_sum_to_zero)\n    assert_equal(false, candidate.call([1,\
  \ 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, -2, 1]))\n    assert_equal(false,\
  \ candidate.call([1, 2, 3, 7]))\n    assert_equal(true, candidate.call([2, 4, -5,\
  \ 3, 5, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(true,\
  \ candidate.call([-3, 9, -1, 3, 2, 30]))\n    assert_equal(true, candidate.call([-3,\
  \ 9, -1, 3, 2, 31]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))\n\
  \    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))\n  end\nend\n"
completions: ["  l.length\n  l[1..-1].reduce(0) { |i, e| (e + i) == 0 }\nend", " \
    \ l1 = l.sort.to_a\n  l2 = l1.reverse.map {|e| e if e < 0 }\n  l2.empty? or l2.size\
    \ == 2\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nThanks J\xF6rg, your\
    \ solution works fine. I really appreciate your help.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=2 |>\nI find your question interesting. I've tried several ways to solve\
    \ it and found no solutions. I took time to study your question and come up with\
    \ a solution that is quite straight-forward. It also takes advantage of Ruby features.\
    \ It might be not so efficient, but it takes only a few lines of code.\n<code>",
  "  l.each_index do |i|\n    yield(l[i], l[i]) if (l[i] + l[i + 1]) == 0\n  end\n\
    end\n</pre>", "  l.sort!\n  return false if l.empty? || l.size == 1 || (l.first+l.last).zero?\
    \ \n  r = 0\n  l.each do |i|\n    r += i\n    return false if r == 0\n  end\n\
    \  true\nend", "    # your code here\n    i = 0\n    while i < l.length\n    \
    \    j = 0\n        while j < l.length\n            if l[i] + l[j] == 0\n    \
    \            return true\n            j = j + 1\n        i = i + 1\n    end\n\
    \    return false\nend", "    l.sort\n    return l.inject(true, :==).all?\nend\n\
    </code>\nThe first method I introduced was inject.  It allows you to insert an\
    \ item into an Array at a particular index.  It returns a new Array with the item\
    \ injected at the given index.  Let's test it out for the example in the comments:\n\
    <code>\n>> pairs = [1, 3, -2, 1]\n>> pairs.inject(true, :==)\n=> true\n>> pairs.inject(true,\
    \ :==).all?\n=> true\n</code>\nWe can use the all? method to test if the return\
    \ value is true or false.  Now let's add another method to our custom class:\n\
    <code>", "    l.sort!\n    return false if l[0] + l[1] > 0 ||\n              \
    \      l[0] + l[1] == 0 ||\n                    l[1] + l[0] > 0 ||\n         \
    \           l[1] + l[0] == 0\nend", "  l.each_cons(2) do |a,b|\n    break if a.sum\
    \ < 0 or b.sum < 0\n    return false if a.sum == 0 and b.sum == 0\n  end\n  return\
    \ true\nend", "  l.each_with_index do |x, i|\n    break if i == l.length-1\n \
    \   break if l[i] + l[i+1] == 0\n    break if l[i] == 0\n  end\n  return nil !=\
    \ i\nend", "  # sum the elements of each pair and add up to 0\n  sum_to_zero =\
    \ false\n  l.each do |i|\n    l.each do |j|\n      sum_to_zero |= i == j && i\
    \ != 0\n    end\n  end\n  return sum_to_zero\nend", "    pairs = make_pairs(l)\n\
    \    pairs.each_with_index do |p,i|\n        if p == 0 && pairs[i+1] != 0\n  \
    \          return false\n        end\n    end\n    return true\nend", "    l.uniq!\
    \ # removes dups\n    return l.any? && l.count(*[0]) == l.reduce(:+) && l.all?(&:<)\n\
    end", "  return l.inject(:+) == 0 && l.uniq.size == (l - l.take(l.uniq.size -\
    \ 1))\nend\n</code>\n<|/ a tags=arrays,ruby,ruby-on-rails |>\n<| c |>\nThank you\
    \ for posting your answer here - but why not simply use `uniq.size` to check the\
    \ number of elements in the set?\n<|/ c |>\n<| c |>\nThat works too, but as per\
    \ the question specification it seems more readable to use inject here than reduce\
    \ or reduce!, especially if the initial array isn't a Ruby built-in set type.\n\
    <|/ c |>\n<| a tags=arrays,ruby,ruby-on-rails |>\nJust for fun here are some more\
    \ \"ruby\" ways to do it\n<code>", "  pairs = l.to_a\n  sums.reduce(pairs, :+)\
    \ == 0\nend", "\tcount = 0\n\tfor i in l\n\t\tif l[i] + l[i+1] == 0 \n\t\t\tcount\
    \ += 1\n\treturn count == 2\n</cell>\n<cell>", "    l.each do |i|\n        l.each\
    \ do |j|\n            if i != j and i != 0 and j != 0 and i + j == 0 \n      \
    \          return true\n            end\n        end\n    end\n    return false\n\
    end", "  # Your code here\n  pairs.each do |key, value|\n    sum = 0\n    value.each\
    \ do |i|\n      sum += i\n      if sum == 0\n        pairs.delete(key)\n     \
    \   pairs.delete(key)\n      end\n    end\n  end\n  pairs.empty?\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThank you for your help. I tried your approach but\
    \ I'm still getting an error when running the tests. Could you have a look please?\
    \ [link](http://codepad.org/jTnZjR5X)\n<|/ c |>\n<| c |>\nThe error you're getting\
    \ is because when you delete the `pairs` hash key, the pairs array shrinks. But\
    \ you can't access an index that's already `-1`. At the point of the error you're\
    \ accessing `pairs[-1]`. So if you get past that error, you will still run into\
    \ issues because you don't want to try and access an index in the `pairs` array\
    \ that doesn't exist, which is what your code was trying to do.\n<|/ c |>\n<|\
    \ c |>\nOh okay. I thought that was the issue so I changed it to `pairs.length-1`.\
    \ But when I run the tests I still get the same error. [link](http://codepad.org/Lk4Zjg5x)\n\
    <|/ c |>\n<| c |>\nI realized that I forgot to pass any arguments to `pairs_sum_to_zero`\
    \ when I was testing the function. After fixing that the tests are passing but\
    \ the program itself is still throwing the error.\n<|/ c |>\n<| c |>\nI really\
    \ appreciate all the help and advice! I'm very new to this so I'm struggling to\
    \ grasp everything that is going on. I'm currently working on a few more challenges\
    \ and I'm coming across a problem that I really can't seem to wrap my head around.\
    \ I just updated the question to include another challenge that I'm stuck on.\
    \ Could you have a look please? [link](http://codepad.org/H1MfRtCU)\n<|/ c |>\n\
    <| a |>\nYou need two loops:", "    l.sort.each do |i|\n        j = i + 1 \n \
    \       l.each do |j|\n            next if j == i\n            if i.zero? && j.zero?\n\
    \                l.delete_if { |z| z != i && z != j }\n            elsif i.zero?\n\
    \                l.delete_if { |z| z != i }\n            elsif j.zero?\n     \
    \           l.delete_if { |z| z != j }\n            else\n                l.delete_if\
    \ { |z| z.zero? }\n            end\n        end\n    end\n    l.size == 0\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis code doesn't work when the list is [1,2,3,0].\
    \ It'll return true even though there are two zeros, which is false. It also only\
    \ works on pairs and triplets, not quads or quints.\n<|/ c |>\n<| a dscore=2 |>\n\
    You can use the following code for solving this problem.\n<code>", "  return l.length\
    \ == 2 and l.min.zero? and l.max.zero?\nend", "  l.sort!\n  l.inject(true) { |accu,\
    \ item| accu && item == 0 }\nend", "  l.uniq!\n  l.sort.inject(true) do |res,v|\n\
    \    next true if v == 0 and res\n    res && (v > 0)\n  end\nend", "    l.each_index\
    \ do |i|\n        return false unless l[i] + l[i+1] == 0\n    end\n    true\n\
    end", "  l.sort.each do |x|\n    puts \"#{x[0]} + #{x[1]} == 0\"\n    break if\
    \ x[0] == 0\n    break if x[1] == 0\n  end\n  false\nend", "  l.each do |x|\n\
    \    i = l.index(x)\n    j = i + 1 if i != nil and l[i+1] != nil\n    return false\
    \ if j == nil\n    return false if j < i or l[j] == nil\n    return false if l[j].to_i\
    \ == l[i].to_i\n  end\n  return true\nend", "    l.sort!\n    return l.inject(true)\
    \ do |acc, i|\n        break false if acc\n        acc && l[i-1] + l[i] <= 0\n\
    \    end\nend", "  # write your code here\n  count = 0\n  for i in l\n    if l[i]\
    \ > 0\n      count += 1\n  return count == 0", "  l.sort.uniq # => [1, 3, 5, 7]\n\
    \  l.inject(true){ |sum, num| sum && sum + num == 0 }\nend\n</pre>\n</td>\n</tr>\n\
    </table>\n</td>\n</tr>\n<tr><td>\n<pre>", "  l.each do |n|\n    l.each do |m|\n\
    \      return false if n < m # Don't need to check pairs\n      return true if\
    \ n == 0 # Found it\n    end\n  end\n  true\nend\n</code>\n<|/ a dscore=0 tags=ruby,arrays,sum\
    \ |>\n<| c |>\nI like this solution, but I'm a little confused why it doesn't\
    \ work.  \n`@arr = [1, 3, 5, 0]; puts pairs_sum_to_zero(@arr) #=> true`\n`@arr\
    \ = [1, 3, -2, 1]; puts pairs_sum_to_zero(@arr) #=> false`\n`@arr = [1, 2, 3,\
    \ 7]; puts pairs_sum_to_zero(@arr) #=> false`\n`@arr = [2, 4, -5, 3, 5, 7]; puts\
    \ pairs_sum_to_zero(@arr) #=> true`\n`@arr = [1]; puts pairs_sum_to_zero(@arr)\
    \ #=> false`\n<|/ c |>\n<| c |>\nBecause you're passing the array as a block:\
    \ `[1,2,3,4].each do |n|; [4,4,4,4].each do |m|; puts true if n+m == 0; end; end;\
    \ end` This won't run because `m` is never set.\n<|/ c |>\n<| c |>\nI see, you're\
    \ right.  I fixed my answer.\n<|/ c |>\n<| c |>\nOh, ok, that makes sense.  Thank\
    \ you for the help and quick response.\n<|/ c |>\n<| a tags=ruby,arrays,sum |>\n\
    You can use a hash:\n<code>\na = [1, 4, -5, -7, 3]", "  l.each_cons(2) do |a,b|\n\
    \    return false if b.nil? || a+b > 0\n  end\n  true\nend", "  return l.inject\
    \ {|s,x| (s-x)==0 }==false\nend", "  return l.inject(:+) == 0 && l.uniq.size ==\
    \ l.size\nend", "  l.sort!\n  return l.inject(:+) == 0 && l.inject(:-) == 0\n\
    end", "  if l.size < 3\n    return false\n  h = {}\n  l.each_index { |x| h[x]\
    \ = false }\n  h[:2] = true\n  l.each_index { |x| h[x+2] = false }\n  return h[:l.size]\
    \ == true\nend", "    l.sort!\n    return l.inject(true, :+) == 0 && l.inject(true,\
    \ :-) == 0\nend", "  return l.inject {|x, y| x+y == 0} == {}\nend", "  l.sort!\n\
    \  return true if l.inject(:+) == 0 \n  false\nend\n</cell>\n<cell>", "  return\
    \ l.inject(true){|memo,e| memo && e == 0}.nil? #false\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=1 |>\n<| c |>\nI think it is better to use `l.each_with_object(false)\
    \ { |e, memo| memo && e == 0 }` to avoid an extra method call on `e`. I will try\
    \ it out later. BTW, this is basically what `Enumerable#partition` does. So `l.partition.all?{|_,\
    \ v| v == 0}` does the same thing as `l.partition.any?{|_, v| v == 0}`.\n<|/ c\
    \ |>\n<| a |>\nHere's another one:\n<code>", "  l.sort\n  for i in 0..l.size-1\n\
    \    return true if l[i]+l[i+1] == 0\n  end\n  return false\nend", "  l.each_cons(2)\
    \ do |a, b|\n    return false if a.sum + b.sum == 0\n  end\n  true\nend\n</cell>\n\
    <text>\nNotice that in the first example, the number 1 is the first and second\
    \ elements in the list, and 3 is the third. In the second example, the number\
    \ 1 is the second element, and 4 is the third. In the third example, the number\
    \ 1 is the first element, and 3 is the third. In the last example, nothing is\
    \ true, so the answer is false.", "  l.each_cons(2).all? { |x, y| x == y ? 0 :\
    \ x + y == 0 }\nend\n</code>\n<|/ a |>\n<| c |>\nThis code fails on `[2,2,2]`\n\
    <|/ c |>\n<| c |>\nOh I see what you mean. Should work if we change the predicate\
    \ to `all? { |x, y| x == y || x + y == 0}`. Just updated it.\n<|/ c |>\n<| c |>\n\
    Yes this works. Thanks. I understand it better. I was struggling with it and I\
    \ couldn't understand how to fix it for my case though.\n<|/ c |>\n<| a |>\n<code>",
  "  l.sort\n  l[0] < l[-1]\nend", "  l.each_cons(2) do |a,b|\n    return false unless\
    \ a.zero? && b.zero?\n    a.succ >= b.succ ? return false : next\n  end\n  true\n\
    end", "  l.sort { |a, b| b - a }\n  (l[-1] == 0 && l[-2] != 0) ? true : false\n\
    end", "    l.sort!\n    return l.inject(true, :+) == 0 && l.uniq.size == 1\nend",
  "  l.each_cons(2).any?{|a, b| a + b == 0}\nend\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nI knew I was overcomplicating it :P\n<|/ c |>\n<| c |>\nThis is cool but\
    \ I think it won't work for `pairs([0, 0])` since it doesn't have to be a pair\
    \ to be sum to 0.\n<|/ c |>\n<| c |>\nWhat would you expect it to return?  It\
    \ can't return `0` because it doesn't have a pair that sums to 0.\n<|/ c |>\n\
    <| c |>\nI expect it to return false since the two zeros are not pairs.\n<|/ c\
    \ |>\n<| c |>\nI understand that but it doesn't need to have a pair.  It doesn't\
    \ need to be a pair to be sum to zero.\n<|/ c |>\n<| a |>\nTry this recursive\
    \ method:\n<code>", "\tl.sort\n\tl.inject([false, false]) do |(acum, truecum),\
    \ (elt, itr)|\n\t\tacum += elt\n\t\ttruecum += (acum - elt)\n\t\treturn [false,\
    \ truecum] if acum < 0\n\t\treturn [truecum, false] if truecum < 0\n\t\treturn\
    \ [truecum, truecum] if truecum == 0 and acum == 0\n\t\treturn [true, false] if\
    \ acum == 0 and truecum == 0\n\t\treturn [false, true] if acum == 0 and truecum\
    \ > 0\n\t\treturn [truecum, true] if truecum > 0 and acum == 0\n\t\treturn [acum,\
    \ acum] if acum > 0 and acum == 0 and truecum == 0\n\t\treturn [truecum, true]\
    \ if truecum > 0 and acum == 0 and truecum == 0\n\t\treturn [truecum, true] if\
    \ truecum > 0 and acum == 0 and truecum > 0\n\t\treturn [truecum, false] if truecum\
    \ == 0 and acum > 0\n\t\treturn [true, false] if acum > 0 and acum == 0 and truecum\
    \ == 0\n\t\treturn [truecum, true] if truecum > 0 and acum == 0 and truecum ==\
    \ 0\n\t\treturn [truecum, true] if truecum > 0 and acum == 0 and truecum > 0\n\
    \tend\nend", "  l.sort!\n  (l.length-1).times do |i|\n    (l[i]+l[i+1]).to_i >\
    \ 0\n  end\nend", "  return l.inject(:+) == l.inject(:*)\nend", "\tl.each_with_index\
    \ {|el, index| return false unless index + 1 < l.length && el + l[index + 1] ==\
    \ 0}\n\treturn true\nend", "  l.sort!\n  (l.uniq & l.uniq.length <= 2).any?\n\
    end", "  l.sort!\n  return l.inject(:+) == 0 && l.inject(:+) == l.first\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays dscore=1 |>\n<code>\n\
    array.uniq&.empty?\n</code>\n<|/ a |>\n<| c |>\nThat is nice, but I don't think\
    \ it answers the question since it doesn't answer the OP's question. Maybe you\
    \ wanted to give a brief explanation?\n<|/ c |>\n<| c |>\nIt checks whether the\
    \ array is empty, which I think is the OP's question. I think it's even clearer\
    \ and probably more efficient than what OP is trying to do.\n<|/ c |>\n<| a dscore=0\
    \ |>\nI think this is the best solution for you:\n<code>", "  l.sort!\n  return\
    \ l[0] != l[1]\nend", "  l.each_with_index do |i,j|\n    l.delete_at(i) if (l[j]\
    \ > 0)\n  end\n  l.size == 0\nend\n</code>\n<|/ a |>\n<| c |>\nAwesome answer,\
    \ but I don't understand how it works, I'm a newbie to Ruby. If you could explain\
    \ it I would be happy to learn. Thank you!\n<|/ c |>\n<| c |>\nI believe this\
    \ code does the same as mine, but in a more Ruby-like way. The method `delete_at`\
    \ is used to remove an element from the array, and it's used as the indexing variable\
    \ in a loop. The loop iterates through the array, and if the current element in\
    \ the array is positive, it's removed from the array. This results in the original\
    \ array not containing any negative elements.\n<|/ c |>\n<| c |>\nAh I see. Thank\
    \ you!\n<|/ c |>\n<| c |>\nThis doesn't work, unfortunately. `[1, 2, -1, -4, 3].delete_at(4)`\
    \ gives `[1, 2, -1, -4, 3]`. But it should be `[1, -1, 3, -4]`.\n<|/ c |>\n<|\
    \ a tags=ruby,arrays dscore=3 |>\n<code>\na = [2,5,3,-2,7]\na.delete_if { |n|\
    \ n < 0 }\n</code>\n<|/ a |>\n<| c |>\nThis is probably the cleanest solution.\n\
    <|/ c |>\n<| a dscore=2 |>\nI came up with\n<code>\narr.map { |x| x < 0 ? -x :\
    \ x }\n</code>\nbut this doesn't work, because it maps the elements to negative\
    \ signs, not deleting them.\n<|/ a tags=ruby,arrays |>\n<| a |>\nYou can use the\
    \ delete method \n<code>\na=[2,5,3,-2,7]\na.delete(-2)\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=2 |>\n<| c |>\nthis doesn't work, because it deletes the element at index\
    \ 2, not the element at index 2 which is negative.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\nThis should do it:\n<code>\n[2,5,3,-2,7].find { |n| n < 0 }\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nthis also does not work, because it returns the element\
    \ at index 2, not the element at index 2 which is negative.\n<|/ c |>\n<| c |>\n\
    , that's a good point and I hadn't considered it when posting.  Fixed now :-)\n\
    <|/ c |>\n<| a tags=rub", "  l.sort\n  l.reduce(0)\n  return l == [-2,0,1]\nend",
  "    pairs = l.map { |x| [x, x % 6] }\n    pairs.uniq.count == 2 ? true : false\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays,integer |>\n<| c |>\nThe problem\
    \ is when `l == [1, 3, -2, 1]`, for example the pairs could be: `[1, 1, -1, -1]`,\
    \ which returns `true` when it's meant to return `false`.\n<|/ c |>\n<| c |>\n\
    thank you for that explanation.  I've updated the answer accordingly.\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails,arrays,integer |>\nTo avoid confusion with negative\
    \ integers, I changed the condition to check for equality to zero:\n<code>", " \
    \ l.sort! #sorts the list by making sure that smaller numbers come before larger\
    \ numbers\n  l.each do |p|\n    if p.reduce(:+) == 0\n      return true\n    end\n\
    \  end\n  false\nend", "  return l.count > 1 and l.all? {|i| l.detect { |j| i\
    \ != j and i + j == 0} }.all? {|i| l.detect { |j| i == j and j > 0} }.all? {|i|\
    \ l.detect { |j| i != j and j > 0} }.all? {|i| l.detect { |j| i == j and j ==\
    \ 0} }\nend", "  l.uniq\n  l.inject { |a,b| a + b } <= 0\nend", "  l.sort\n  (l.length\
    \ - 1).downto(1) do |i|\n    (j=i + 1) while j >= l.length and l[j] ==  l[i] +\
    \ l[j]\n    if j >= l.length\n      return true\n    end\n  end\n  false\nend",
  "    l.sort!\n    return false if l[0] == l[1] || (l[0] == 0 && l[1] == 0) else\
    \ true\nend", "  l.sort.with_index { |a,i| a <=> l[i+1] if i < l.size-1 }\n  l.size\
    \ == l.find_index { |a| a.zero? }\nend", "  l.inject { |t, (a, b)| t + b if t\
    \ > 0 }\n  return l.size == 0\nend", "  pairs = l.partition{|x| x > 0}\n  pairs.all?\
    \ {|x,y| x == y and y > 0}\nend", "  pairs = {}\n  l.each do |i|\n    if pairs.has_key?\
    \ i\n      pairs[i] += 1\n    else\n      pairs[i] = 1\n    end\n  end\n  return\
    \ pairs.all? { |key, val| val == 0 }\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nI believe this is more efficient than using each_cons since it avoids creating\
    \ the unnecessary array in memory while building the pairs.\n<code>", "    l.each\
    \ do |i|\n        for j in i..0\n            if i != j and j > 0\n           \
    \     return false\n            end\n        end\n    end\n    return true\nend",
  "    pairs = l.sort.inject([]) { |sums,e| sums << [e, sums.last+e] }\n    pairs.each_with_index\
    \ { |pair,i| pair[1] > 0 && pairs.delete_at(i) }\n    pairs.size == 0\nend", " \
    \   l.sort!\n    return l.inject(true) do |acc, item|\n      acc && item == 0\
    \ && acc.next\n    end\nend", "  return l.count(l.inject(:+) == 0)\nend\n</cell>\n\
    <text>\n6. Ruby\uBAA8\uB378", "  l.sort.each do |i|\n    j = i + 1\n    while\
    \ j < l.length and l[j] == 0\n      j += 1\n    end\n    return true if j == l.length\
    \ - 1\n    return false if j == l.length\n    l.slice!(i, j) if i != j\n  end\n\
    \  false\nend", "  # O(1) time -- no need for hash table\n  l.each_with_index\
    \ { |n,i| l.slice!(i..i+1).any? { |x| n == x+i } ? return false : i+=1 }\n  true\n\
    end", "  l.uniq!\n  l.sort!\n  i1, i2 = 0, 0\n  while i1 < l.length && i2 < l.length\n\
    \    sum = l[i1] + l[i2]\n    return false if sum == 0\n    i += 1\n    j += 1\n\
    \  end\n  i1 < l.length\nend", "  l.inject(true){|t,s| t && s == 0 }\nend", " \
    \ l.each do |n|\n    return false unless [n, -n].uniq.size == 2\n  end\n  true\n\
    end\nputs pairs_sum_to_zero(Array.new(3) { rand(10 ** 10 - 1) })", "  l.sort.each\
    \ do |i|\n    l.find{|j| i+j == 0 }\n  end == nil ? false : true\nend", "    l.sort!\n\
    \    return false unless l[0] == l[-1]\n    return true if l[0] > l[-1]\n    return\
    \ false unless l.size == 2\n    return true if l[0] < l[-1]", "    l.sort!\n \
    \   return l.inject(true, :+) == 0 && l.inject(true, :+) == 0\nend\n</code>\n\
    <|/ a |>\n<| c |>\n+1 for the `pairs` function but I think I'd use `select` or\
    \ `reject { |n,v| n >= v }` here instead as I feel it's more intuitive.\n<|/ c\
    \ |>\n<| c |>\n- agreed, my initial thoughts were `select` or `reject` which would\
    \ work too. Thinking about it further, I like your suggestion better.\n<|/ c |>\n\
    <| a dscore=3 |>\nThe best way to accomplish this in Ruby is to define your own\
    \ Enumerator method pairs?\n<code>", "  l.sort\n  sum = 0\n  for i in 0...l.length\n\
    \    sum = sum + l[i]\n    return sum == 0\nend", "    l.sort!\n    return l.inject(true){|s,i|\
    \ s&&(i+2)==l.last} && l.length < 2\nend", "    l.sort\n    return l.all?{|a,\
    \ b| a+b == 0 }\nend", "  # write your code here\n  return true\nend\n</cell>\n\
    <code language=julia-1.6>\npairs_sum_to_zero([1,1])\n</cell>\n<text>\nQuiz Question.\
    \ Write a function that returns true if the sum of the numbers in the given list\
    \ is equal to the number given by the user. For example, pair_sum?([-2, 5, 3,\
    \ 2], 4) returns true.", "  l.sort!\n  return l.zip(l[1..-1]).all? {|a,b| a +\
    \ b == 0}\nend", "    l.sort!\n    return l.inject(:+) == 0 && l.uniq.size ==\
    \ 1\nend", "  l.each_with_index do |v, i|\n    return false if v != 0 && l[(i\
    \ - 1)..i].inject(&:+) != 0\n  end\n  true\nend", "  l.uniq!\n  l.each_with_index\
    \ do |e,i|\n    l.delete_at(i)\n    break if e==0 && i==0\n  end\n  l.length==0\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a |>\nIn Ruby on Rails you can do this with\
    \ Enumerable#partition:\n<code>\narr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"\
    f\", \"g\"]", "    l.sort.with_index\n    l.each_cons(2) do |e, i|\n        return\
    \ true if l.sum - e == 0\n    end\n    false\nend\n</code>\n<|/ a |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nFor those that want to do this in Ruby\n<code>", "  return l.group_by{ |e|\
    \ e == l.inject(0){ |sum, e| sum + e } }.all?{ |key, val| val != 0 }\nend\n</code>\n\
    <|/ a tags=ruby dscore=1 |>\n<| a dscore=1 |>\n<code>", "    l.sort\n    return\
    \ true if l.reduce :\n            &(l.reduce(:+) == 0)\n        else\n       \
    \     false\nend", "    l.sort!\n    l1, l2 = l[1], l[2]\n    return false if\
    \ l1 + l2 != 0 if l1.zero? && l2.zero? \n    return false if l1 == 0 && l2 ==\
    \ 0 \n    return true if l1 + l2 == 0 \n    return true if l1 <= 0 && l2 <= 0\
    \ \n    return true if l1 <= 0 && l2 <= 0 && l1 + l2 <= 0 \nend", "  l.inject(true,\
    \ :or) do |is_pair, pair|\n    next is_pair if pair.length != 2\n    next is_pair\
    \ if pair.last != 0\n    is_pair\n  end\nend", "    i = 0\n    j = 0\n    while\
    \ i < len(l)\n        j += 1\n        while j < len(l)\n            if l[j] +\
    \ l[i] != 0\n                true\n                end\n            end\n    \
    \        j += 1\n        end\n        i += 1\n    end\nend", "    l.each_cons(2)\
    \ do |x, y|\n        return false if x + y == 0\n    end\n    true\nend", "  l.sort!\n\
    \  zero = false\n  zero_idx = nil\n  for i in l\n    if zero\n      zero_idx =\
    \ i\n      break\n    elsif l[i..-1].inject(:+).zero?\n      zero = true\n   \
    \   break\n    end\n  end\n  return !zero && zero_idx.nil?\nend", "    l.sort!\n\
    \    return l.inject(true) do |s,e|\n        if e == 0\n            s \n     \
    \   else\n            s && (e != s.last)\n        end\n    end\nend\n</code>\n\
    For those who are interested, here are two more versions that use maps and sets:\n\
    <code>", "  return l.count(l.first) == l.count { |e| e.zero? && e - l.first ==\
    \ 0 }\nend\n  ", "  l.inject(true) {|sum,x| sum && x < 0 ? sum + x < sum : sum\
    \ + x != sum}\nend", "    l.sort\n    return false if l[0]+l[-1] == 0 else true\
    \ if l[1..-1].reduce(:+) == 0 end\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    The solution using recursion:\n<code>", "  l.sort!\n  i, j = 0, 0\n  while i <\
    \ l.length && j < l.length\n    return false if l[i] - l[j] == 0\n    return false\
    \ if l[j] - l[i] == 0\n    i += 1\n    j += 1\n  end\n  true\nend", "  pairs =\
    \ 0\n  total = 0\n  for x in l\n    if x > 0\n      pairs += 1\n      total +=\
    \ x\n  \n  return pairs == 1 and total == 0\nend", "  sums.each_with_index do\
    \ |s,i|\n    if s == 0 && i != l.length-1\n      return false\n    end\n  end\n\
    \  return true\nend\n</cell>\n<cell>\npairs_sum_to_zero([1])\n</cell>\n<text>\n\
    Now that you know what each of these methods does, you can call them on a list\
    \ of numbers. You'll see that in action in the next exercise. Let's start by defining\
    \ a new variable sum_of_elements that holds only the sum of the elements in the\
    \ input_list.", "  l.sort!\n  l.uniq!\n  l.size == 2 and l[0] == l[1]\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI like your solution because it uses only a binary search through\
    \ the array and so should be fast for large lists.\n<|/ c |>\n<| c |>\nI think\
    \ this solution is better since it checks all pairs, not just one. +1 from me.\n\
    <|/ c |>\n<| c |>\nIt should be noted that this is O(n log n), and the solution\
    \ using pairs.all? above is O(n).\n<|/ c |>\n<| c |>\nThe O(n) solution above\
    \ is O(n^2), since the `pairs.all?` call is done for all pairs which is n times.\
    \ In contrast, this solution only does one pair comparison per iteration, which\
    \ is O(n). But thank you for pointing this out :)\n<|/ c |>\n<| c |>\nI'm sorry\
    \ but how did you figure that out? Is there some formula I can use? I tried the\
    \ formula but it doesn't seem right.\n<|/ c |>\n<| a |>\nHere's a solution using\
    \ Enumerator:\n<code>", "  l.uniq.size == 1\nend", "    return false\nend", " \
    \ l.sort!\n  pairs = []\n  i = 0\n  while i < l.length\n    j = i + 1\n    while\
    \ j < l.length\n      break if j - i == 5\n      pairs << [i, j]\n      j += 1\n\
    \    end\n    i += 1\n  end\n  i = 0\n  while i < pairs.length\n    l = pairs[i]\n\
    \    j = i + 1\n    while j < pairs.length\n      break if j - i == 2\n      v\
    \ = pairs[j-1]\n      if l[0] == v[1] and l[1] == v[0]\n        pairs.delete(j)\n\
    \      else\n        j += 1\n      end\n    end\n    i += 1\n  end\n  return pairs.length\
    \ == 0\nend", "  # Your code here\n  l.sort.each do |i|\n    j = i+1\n    while\
    \ j < l.length do\n      return true if l[j] == i\n      return true if l[j] ==\
    \ 0\n      j += 1\n    end\n  end\n  return true\nend", "  pairs = 0\n  for x\
    \ in l\n    pairs += (l[x] - 0) * l[(x + 1) % (l.size - 1)]\n  return pairs ==\
    \ 0\nend", "  return l.length==l.inject(0) { |n,i| n<0 ? false : n%i==0 }\nend",
  "  l.each_cons(2) do |a,b|\n    return true if a.first + b.first == 0\n  end\n \
    \ false\nend", "  sum = 0\n  pairs = []\n  l.each do |i|\n    sum+=i\n    pairs\
    \ << i if sum == 0\n    sum-=i\n    pairs << i if sum == 0\n  end\n  pairs.size\
    \ == 1 and pairs.first == 0\nend\nprint pairs_sum_to_zero([2,3,5,0])\nprint pairs_sum_to_zero([1,3,-2,1])\n\
    print pairs_sum_to_zero([1,2,3,7])\nprint pairs_sum_to_zero([2,4,-5,3,5,7])\n\
    print pairs_sum_to_zero([1])\nprint pairs_sum_to_zero([-1])\nprint pairs_sum_to_zero([-2])\n\
    print pairs_sum_to_zero([1,-1])\nprint pairs_sum_to_zero([0,0])\nprint pairs_sum_to_zero([-2,0,0])\n\
    print pairs_sum_to_zero([0,0])\nprint pairs_sum_to_zero([1,1])\nprint pairs_sum_to_zero([-3,5])\n\
    print pairs_sum_to_zero([2,-5,-2])\nprint pairs_sum_to_zero([-2,1,2])\nprint pairs_sum_to_zero([2,1])\n\
    print pairs_sum_to_zero([1,0,1])\nprint pairs_sum_to_zero([2,-3,0])\nprint pairs_sum_to_zero([2,3])\n\
    print pairs_sum_to_zero([3,2])\nprint pairs_sum_to_zero([2,-3])\nprint pairs_sum_to_zero([5,3])\n\
    print pairs_sum_to_zero([1,2])\nprint pairs_sum_to_zero([3,1])\nprint pairs_sum_to_zero([-3,5,3])\n\
    print pairs_sum_to_zero([5,2])\nprint pairs_sum_to_zero([4,-3,-3,3])\nprint pairs_sum_to_zero([2,-3,-2,2])\n\
    print pairs_sum_to_zero([2,2])\nprint pairs_sum_to_zero([5,1])\nprint pairs_sum_to_zero([6,3,2])\n\
    print pairs_sum_to_zero([1,-1,3,0,2])\nprint pairs_sum_to_zero([0,-1,2])\nprint\
    \ pairs_sum_to_zero([1,-1,3,0,2])\nprint pairs_sum_to_zero([0,-1,2])\nprint pairs_sum_to_zero([0,-1])\n\
    print pairs_sum_to_zero([3,1])\nprint pairs_sum_to_zero([1,1])\nprint pairs_sum_to_zero([-1,2])\n\
    print pairs_sum_to_zero([2,-1])\nprint pairs_sum_to_zero([-1,0,1])\nprint pairs_sum_to_zero([1,-2,3])\n\
    print pairs_sum_to_zero([3,-5,2,1])\nprint pairs_sum_to_zero([2,0,1])\nprint pairs_sum_to_zero([-1,3,2])\n\
    print pairs_sum_to_zero", "  l.sort!\n  (0..l.size-1).each do |i|\n    return\
    \ false if (l[i] + l[i+1]).zero?\n  end\n  true\nend", "  # write your code here\n\
    \  return true\nend", "  l.uniq!\n  pairs = l.select {|x| x != 0}.permutation(2)\n\
    \  pairs.each do |a, b|\n    next unless a.class == b.class\n    break if a.to_i\
    \ + b.to_i == 0\n  end\n  pairs.empty?\nend", "  l.sort!\n  zero = false\n  l.each_cons(2)\
    \ do |pair|\n    zero += pair[-1] == 0\n  end\n  zero\nend", "  pairs = l.to_a\n\
    \  (i, j).each do |i|\n    (j..l-1).each do |j|\n      pairs << [i,j]\n      break\
    \ if pairs.all? { |pair| pair.sum != 0 }\n    end\n  end\n  pairs.all? { |pair|\
    \ pair.sum == 0 }\nend", "  return l.uniq.length == l.uniq.select(&:zero?).length\n\
    end", "  l.sort.each_with_index do |n,i|\n    return false if n == 0\n    return\
    \ true if i > 0 and n+l[i-1] == 0\n  end\n  true\nend", "  # Your code here\n\
    \  if l.count > 0\n    l.each do |x|\n      if l.count(x) == 2 then return true\
    \ end\n    end\n  end\n  return false\nend", "  return l.inject(:+) == 0 && l.uniq.count\
    \ == 1 && l.uniq.first == 0\nend", "  l.sort\n  pairs = l.inject([]) { |arr, x|\n\
    \    arr << [x, arr.last + x]\n    arr\n  }\n  pairs.inject(0) { |acc, pair| acc\
    \ + pair[1] } == 0 and pairs.size == 2\nend", "    pairs = l.each_cons(2)\n  \
    \  pairs.inject(true){|a,b| a&&b}\nend", "  l.each { |i| break if i != 0 }\n \
    \ l.each { |i| break if l.count(i) > 1 }\n  l.each_with_object(Hash.new(false))\
    \ do |i, h|\n    h[i] = true\n    h.default(false).each { |k, v| h[k] = true if\
    \ v == false }\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis seems to only work\
    \ on a small sample size (e.g. one with 3 numbers) but fails on larger sample\
    \ sizes (e.g. with 40 or more).\n<|/ c |>\n<| a tags=algorithm,ruby |>\nYou could\
    \ create a hash that stores every pair of elements and each time you see an element\
    \ that sums up to zero you increment a counter and increment a counter for the\
    \ second element and so on.\n<code>", "    # implement the solution here (the\
    \ method should return type BOOLEAN)\n    l.sort!\n    l.uniq!\n    pairs = l.zip([0,\
    \ *l])\n    pairs.any?{|x| x[0]+x[1] == 0 }\nend", "    l.sort.each_with_index\
    \ do |n,i|\n        if n - l[i] > 0 \n            return false \n        elsif\
    \ n - l[i] < 0 \n            return false \n        end\n    end\n    return true\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer but I think you misunderstood\
    \ my question. I've added some examples to clarify. Basically I want to find the\
    \ first two numbers smaller than the sum of the entire list in the following case\
    \ (this would be the answer `[3,5]`):\n`[3, -2, -1, 10, 8, 7, 2, 4, 5, 0, -1]`\n\
    <|/ c |>\n<| c |>\nI see, I thought it was just the two elements in the list whose\
    \ sum was equal to zero. You are right, I've updated the answer, thanks.\n<|/\
    \ c |>\n<| c |>\nThis was a fantastic answer! You just needed to add an else statement\
    \ to the first for loop because if the list has an odd number of elements, the\
    \ last element will cause it to return true.\n<|/ c |>\n<| c |>\nHappy to help\
    \ :)\n<|/ c |>\n<| c |>\nI posted an answer below that works using your method.\
    \ Thanks again for the help!\n<|/ c |>\n<| a dscore=0 tags=ruby,arrays |>\nIf\
    \ you're looking for a short and concise solution, here it is:\n<code>", "  #\
    \ Your code here\n  l.uniq {|x| x - l.last.last == 0}\nend", "  l.inject(true)\
    \ do |s,e|\n    s && !s[e] && s[-(e+1)] == false && false && true\n  end\nend",
  "  return l.find { |a| l.count(a) > 1 } == false\nend", "  l.each { |i| return false\
    \ if i.zero? }\n  l.each { |i| return true if i.positive? }\n  l.each { |i| return\
    \ true if i.negative? }\n  l.each { |i| return true if i.zero? or i.positive?\
    \ or i.negative? }\n  return true\nend", "    # implement the solution here (your\
    \ puzzle input)\n    return false\nend", "  l.group_by{|i| i}.inject(true){|b1,\
    \ (k, v)|\n  (b1 && (k == 0)) || (b1 && (k == v.length))\n}.tap{|b| b}\nend",
  "    count = 0\n    pair = []\n    flag = True\n    for i in l\n        if i.zero?\n\
    \            count += 1\n        elsif count == 2\n            pair = i\n    \
    \        flag = false\n        elsif count != 0\n            count = count-1\n\
    \        end\n    end\n    count\n    flag\nend\n</cell>\n<cell>", "  return l.inject(:+)\
    \ == l.uniq.length && l.uniq.size == 2\nend", "  l.sort.each do |x|\n    next\
    \ if x == 0\n    return false if l[0] == x && l[1] != 0\n    return true if l[0]\
    \ != x || l[1] != 0\n  end\n  true\nend", "    l.uniq!\n    l.sort!", "  l.sort!\n\
    \  return l.inject(true) do |result, (el, i)|\n    result && (i == 0 || el ==\
    \ 0)\n  end\nend\n</code></pre>\n            </div>\n          </div>\n      \
    \  </div>\n        <hr>\n      </main>\n    </div>\n    <footer class=\"footer\"\
    >\n      <div class=\"content has-text-centered\">\n        <p>\n          <strong>Content\
    \ Blocks:</strong>\n          This content block is placed underneath the main\
    \ content block for print.\n        </p>\n        <p>\n          <strong>More\
    \ Information:</strong> <a href=\"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/MobileHIG/DisplayContent.html\"\
    >View the App Store on a Device</a>\n        </p>\n      </div>\n    </footer>\n\
    \    <script src=\"https://cdn.apple-libs.net/anchors/1.1.1/anchors.min.js\"></script>\n\
    \    <script>\n      (function (i, s, o, g, r, a, m) {\n        i['GoogleAnalyticsObject']\
    \ = r;\n        (i[r] =\n          i[r] ||\n          function () {\n        \
    \    (i[r].q = i[r].q || []).push(arguments);\n          }),\n          (i[r].l\
    \ = 1 * new Date());\n        (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);\n\
    \        a.async = 1;\n        a.src = g;\n        m.parentNode.insertBefore(a,\
    \ m);\n      })(\n        window,\n        document,\n        'script',\n    \
    \    '//www.google-analytics.com/analytics.js',\n        'ga'\n      );", "  l.sort!\n\
    \  return l.size == 2 and l[0] == l[1]\nend", "  return l.length == 1 and l.inject(true).reduce(:+)\
    \ == 0 \nend", "  l.sort!\n  pairs = []\n  zeros = []\n  for i in 0..(l.size -\
    \ 1)\n    if l[i] + l[i+1] == 0\n      pairs << [[i,i+1]]\n    else\n      zeros\
    \ << [[i,l[i]]]\n    end\n  end\n  return pairs.empty? && zeros.empty?\nend",
  "  return l.uniq.length == 1 and l.uniq.first == 0 and l.uniq.last.to_i == 0\nend",
  "    l.sort!\n    l[0] + l[1] == 0\nend", "  l.sort!\n  return l.inject(true, :+)\
    \ == 0 and l.uniq.size == 1\nend", "  l.sort { |a,b| b<=>a }\n  l.size < 3 ? false\
    \ : l.inject { |s,i| (s+l[i+1]) == 0 ? true : false }\nend\n</cell>\n<cell>",
  "  l.sort!\n  (l.first + l.last).zero?\nend", "  l.each do |x|\n    l.each do |y|\n\
    \      next if (x + y == 0)\n      next if (y + x == 0)\n      return false if\
    \ x == y\n    end\n  end\n  return true\nend", "    return l.count(l[0]) == len(l)/2\n\
    end", "  l.map! {|i| return false if i != 0 && (l.count(i) + l.count(i.next))\
    \ < 2 }\n  l.all?\nend", "  l.sort!\n  return l.inject(true) do |sum, pair|\n\
    \    sum and sum - pair == 0 && sum\n  end\nend", "    # Write your code in Ruby\
    \ here\n    l.sort.each_with_index do |x,i|\n        if i < (l.length-1) and x.to_i\
    \ + l[i+1].to_i == 0 then return false end\n        if x.to_i + l[i+1].to_i ==\
    \ 0 then return true end\n    end\n    return false\nend", "    l.sort() # we\
    \ need the list in numerical order\n    return l == [] or l[0] == l[-1] and pairs_sum_to_zero(tail(l))\
    \ == True or false\nend", "  return l.count(l[0]) == 2 and l.count(l[-1]) == 0\n\
    end", "  l.sort!\n  (l.length<2)? false : (l.last==0?false:\n    l.last==(l.length-1)?true:false)\n\
    end", "  sum = 0\n  for i in l\n    sum += i\n    return sum == 0\nend", "  pairs.all?\
    \ { |i,j| (l.sum - l[i]).zero? }\nend", "  l.uniq!\n  l.inject(0) do |sum, num|\n\
    \    sum + num > 0 ? sum + num : sum\n  end\n  l.uniq.size == 1\nend\n</code>\n\
    <|/ a tags=ruby,arrays dscore=2 |>\n<| a dscore=2 |>\n<code>", "  l.each_cons(2)\
    \ do |pair| \n    return true if pair[0].zero? and pair[1].zero? \n  end\n  false\n\
    end", "  l.sort\n  pairs = combinations(l, 2)\n  pairs.all? { |x, y| x + y ==\
    \ 0 }\nend", "  l.each_with_index { |item, idx| return false if item == 0 and\
    \ idx > 1 }\n  l.each_with_index { |item, idx| return false if item == 0 and idx\
    \ > 1 }\n  l.each_with_index { |item, idx| return false if item == 0 and idx >\
    \ 1 }\n  l.each_with_index { |item, idx| return false if item == 0 and idx > 1\
    \ }\n  l.each_with_index { |item, idx| return false if item == 0 and idx > 1 }\n\
    \  l.each_with_index { |item, idx| return false if item == 0 and idx > 1 }\n \
    \ l.each_with_index { |item, idx| return false if item == 0 and idx > 1 }\n  l.each_with_index\
    \ { |item, idx| return false if item == 0 and idx > 1 }\n  l.each_with_index {\
    \ |item, idx| return false if item == 0 and idx > 1 }\n  l.each_with_index { |item,\
    \ idx| return false if item == 0 and idx > 1 }\n  l.each_with_index { |item, idx|\
    \ return false if item == 0 and idx > 1 }\n  l.each_with_index { |item, idx| return\
    \ false if item == 0 and idx > 1 }\n  l.each_with_index { |item, idx| return false\
    \ if item == 0 and idx > 1 }\n  l.each_with_index { |item, idx| return false if\
    \ item == 0 and idx > 1 }\n  l.each_with_index { |item, idx| return false if item\
    \ == 0 and idx > 1 }\n  l.each_with_index { |item, idx| return false if item ==\
    \ 0 and idx > 1 }\n  l.each_with_index { |item, idx| return false if item == 0\
    \ and idx > 1 }\n  l.each_with_index { |item, idx| return false if item == 0 and\
    \ idx > 1 }\n  l.each_with_index { |item, idx| return false if item == 0 and idx\
    \ > 1 }\n  l.each_with_index { |item, idx| return false if item == 0 and idx >\
    \ 1 }\n  l.each_with_index { |item, idx| return false if item == 0 and idx > 1\
    \ }\n  l.each_with_index { |item, idx| return false if item == 0 and idx > 1 }\n\
    \  l.each_with_index { |item, idx| return false if item == 0 and idx > 1 }\n \
    \ l.each_with_index ", "  l.each_cons(2) do |a, b|\n    return false if b.nil?\
    \ || a + b == 0\n  end\n  true\nend\n</cell>\n<cell>", "  return l.inject(:+).zero?\
    \ and l.all? { |x| l.count(x) == 1 }\nend", "  l.sort!\n  return l.inject {|sum,n|\
    \ sum if sum + n <= 0 } == 0\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like\
    \ the elegance of this one. :)\n<|/ c |>\n<| a |>\nI like's solution, but I thought\
    \ I'd add a simple explanation of what's going on. Since you're not interested\
    \ in the pairs that sum to zero themselves, a more efficient way to do this would\
    \ be to build a hash whose keys are the elements of the list and the values are\
    \ the indexes of the first element with that element. Then you can just check\
    \ each pair and see if the sum is zero.\n<code>", "  return l.count(l[0]) == 2\
    \ and l.count(l[1]) == 0\nend", "    l.each_index { |index| l[index].zero? &&\
    \ (l[index]+l[index-1]).zero? }\nend", "  return l.count(l[0]) == len(l) - 1 or\
    \ l.count(l[-1]) == len(l) - 1\nend", "  l.sort.each_with_index {|n,i| return\
    \ false if (i==0&&n==0) || n<0; }\n  return true\nend", "  # Your code here\n\
    \  pairs = 0\n  for i in range(len(l)):\n    for j in range(i + 1, len(l)):\n\
    \      if l[i] + l[j] == 0: pairs += 1\n  return pairs > 0\n</cell>\n<cell>",
  "  l.sort!\n  return l.inject(:==0) == false\nend", "  return l.length == 2\nend",
  "  l.sort!\n  l1 = l.inject([]) do |s, i|\n    break if i > 0 && s[i] == s[i - 1]\n\
    \    s << i\n    s << i + 1\n    false\n  end\n  l1.size == 1 &&\n  l.size ==\
    \ l1.size - 1 && \n  l.include?(l1[2..l1.size - 1])\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nI like your `sort_by` approach. Good thinking.\n<|/ c |>\n<| a\
    \ tags=ruby,arrays |>\nThis problem is a good candidate to solve using the Ruby\
    \ inject method with a block parameter.\n<code>", "  pairs = l.sort.each_cons(2).to_a\n\
    \  pairs.find {|x, y| x + y == 0} == nil\nend", "    l.sort!\n    return l.reduce\
    \ {|a,b| a and b == 0 ? false : a}\nend", "    return l.count(l[0]) == len(l)\
    \ - 1 and l.count(l[-1]) == 0\nend\n</cell>\n<code language=julia-1.0>", "   \
    \ # Your code here\n    l1, l2 = [], []\n    for i in l:\n        if i not in\
    \ l1:\n            l1.append(i)\n    for i in l:\n        if i in l1 and i not\
    \ in l2:\n            l2.append(i)\n    if l1 == l2:\n        return True\n  \
    \  else:\n        return False", "  pairs = l.to_a().map { |x| [x, 0] }\n  pairs.select\
    \ { |x, y| x + y == 0 }.length > 0\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThis solution requires an array of integers to iterate through,\
    \ which I believe is not what the OP was looking for.\n<|/ c |>\n<| c |>\nI agree,\
    \ but I believe it can be easily adapted for arrays of other objects. I wanted\
    \ to show the idea of how one could write this in Ruby, since that's where the\
    \ OP asked.\n<|/ c |>\n<| c |>\nThanks for providing this solution.  I implemented\
    \ it and it works well.  I am surprised at how little code you wrote to do this.\
    \ It took me only 45 minutes to write the code, although it is a bit long.  I\
    \ was a little bit surprised at how much code I had to write in order to accomplish\
    \ such a small task.  Thanks again!\n<|/ c |>\n<| c |>\nThat's a great answer!\
    \ Thanks for sharing. I also just wrote a recursive solution that is based on\
    \ this one, but it uses `inject` instead of `select`. You can find the full solution\
    \ [here](http://stackoverflow.com/a/42273987/257762)\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ dscore=2 |>\nThe first thing is to find a way to express your condition as a\
    \ function.  If you look at your condition, it's essentially:\n<code>\npairs.any?\
    \ {|x, y| x + y != 0}\n</code>\n(This is actually slightly more complex, since\
    \ x could be a non-integer).  This can easily be written as a function:\n<code>",
  "    l.sort.map {|i| l.count(i)==1 && (l[i-1] + l[i])==0}\nend", "  l.each_cons(2)\
    \ do |v|\n    return true if v[0]+v[1] == 0\n  end\n  return false\nend", "  l.sort!\n\
    \  i = 0\n  j = 1\n  pairs = 0\n  while i < l.length && j < l.length\n    pairs\
    \ += 1\n    if l[i] + l[j] == 0\n      return false\n    i += 1\n    j += 1\n\
    \  end\n  pairs == 2\nend", "  for i in l\n    break if i % 2 == 0\n    break\
    \ if i + 1 != 0\n  true\nend", "  pairs = nil\n  l.each_with_index do |n, i|\n\
    \    pairs << [i,n] if n > 0\n  end\n  pairs.uniq.length == 1\nend", "  l.sort.each\
    \ do |i|\n    break if i==0\n    break if l[i-1]==0\n    break if l[i-1]==l[i]\n\
    \  end\n  !( l.reduce(0, :+) == 0 )\nend", "  l.sort!\n  l.reverse!\n  (l[0],\
    \ l[1]) = (0, 0) if l[0] == l[1] else (l[0], l[1]) if l[0] > l[1] else (l[1],\
    \ l[0])\n  l.sort!\n  l.inject(true, :==)\nend", "  return l.each_cons(2).none?\
    \ { |a,b| a.zero? && b.zero? }\nend", "    l.sort!\n    l.length.times do |i|\n\
    \        if l[i - 1] + l[i] > 0 then\n            return False\n        end\n\
    \    end\n    return true\nend", "  return l.inject(true, :+).all? {|x, y| x ==\
    \ 0}\nend", "  l.uniq\n  l.inject {|sum, i| sum == 0 ? true : false }\nend", " \
    \ l.sort.uniq!\n  l.each do |x|\n    return (l.count(x) + l.count(-x)) < 2\n \
    \ end\n  false\nend", "  l.sort { |a,b| b - a}\n  l.reduce(0,:==)\nend", "  #\
    \ write your code here\n  a = (l.clone).sort\n  b.each do |n|\n    a.shift if\
    \ a.first + n == 0\n  end\n  a.size == 0\nend", "  i = 0\n  while i < l.length\n\
    \    j = i + 1\n    while j < l.length\n      if l[i] + l[j] == 0\n        return\
    \ false\n      j = j + 1\n    i = i + 1\n  end\n  return true\nend", "    l.each_cons(2)\
    \ do |a, b|\n        return false if (a + b).zero?\n    end\n    true\nend", " \
    \ return l.inject(true) do |result, e|\n    result && e.zero? && !result.any?\
    \ { |a| a == e }\n  end\nend\n</cell>\n<cell>", "    l.sort!\n    return l.inject(true){|sum,x|\
    \ (sum && sum + x) == 0}\nend", "  return l.inject{|m,e| m && (e != 0) && m <\
    \ e}.reduce(:==)\nend", "  if l.empty?\n    true\n  else\n    l.each do |x|\n\
    \      next\n      l.each do |y|\n        return true if x + y == 0\n      end\n\
    \    end\n  end\n  false\nend\n</cell>\n<text>\nThe function below is called many\
    \ times in the next cell. It takes the current best result and an input list,\
    \ and returns the next best result.", "    l.each do |l|\n        l.each do |l|\n\
    \            if (l.zero? || l == 0)\n                next\n            else\n\
    \                return false\n            end\n        end\n    end\n    true\n\
    end", "  l.sort { |a, b| a <=> b }\n  l.inject { |sum, e| sum + e == 0 ? sum :\
    \ nil }\n  l.size == 2\nend", "  l.sort!\n  return false if l.inject(0) {|acc,\
    \ x| acc + x <= 0 }\n  l.inject(true) { |acc, x| acc && x.zero? }\nend", "\tl.sort!\n\
    \treturn (l.inject(true) do |result, (i, j)|\n\t\tresult &&= j + i == 0\n\t\t\
    result\n\tend)\nend", "  l.sort!\n  return l[0] != l[-1]\nend", "  l.sort!\n \
    \ return l.inject(:+) == 0 && l.uniq.count == 1 and l[0] == 0\nend", "  pairs\
    \ = l.to_a\n  pairs.each_cons(2) do |a, b|\n    return false if a + b == 0\n \
    \ end\n  true\nend", "  l.map!{|a| a == 0 ? false : true}\n  l.combination? and\
    \ l.inject(true) { |b, c| b && c }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    The first two examples are wrong.  Try `[1, 3]`\n<|/ c |>\n<| c |>\nThanks. I\
    \ had a typo in there. Fixed now.\n<|/ c |>\n<| c |>\nThe first two examples need\
    \ a `!` like so: `def pairs_sum_to_zero(l)\n  l.map!{|a| a == 0 ? false : true}\n\
    \  l.combination? and l.inject(true) { |b, c| b && c }\nend`\n<|/ c |>\n<| a dscore=4\
    \ tags=ruby,algorithm |>\n<code>\n def sum_to_zero?(arr)\n  arr.sort.reduce(:+)\
    \ == 0 && arr.size == arr.uniq.size\nend", "  # Write your code here.\n  return\
    \ l.count(l.sort()) == 1 #returns true if there are two distinct elements in the\
    \ list that sum to zero\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
