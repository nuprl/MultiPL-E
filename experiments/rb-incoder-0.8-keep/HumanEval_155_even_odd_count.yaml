name: HumanEval_155_even_odd_count
language: rb
prompt: "# Given an integer. return a tuple that has the number of even and odd digits\
  \ respectively.\n# Example:\n# even_odd_count(-12) ==> (1, 1)\n# even_odd_count(123)\
  \ ==> (1, 2)\ndef even_odd_count(num)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_even_odd_count\n\
  \    candidate = method(:even_odd_count)\n    assert_equal([0, 1], candidate.call(7))\n\
  \    assert_equal([1, 1], candidate.call(-78))\n    assert_equal([2, 2], candidate.call(3452))\n\
  \    assert_equal([3, 3], candidate.call(346211))\n    assert_equal([3, 3], candidate.call(-345821))\n\
  \    assert_equal([1, 0], candidate.call(-2))\n    assert_equal([2, 3], candidate.call(-45347))\n\
  \    assert_equal([1, 0], candidate.call(0))\n  end\nend\n"
completions: ["  even, odd = num.divmod(10)\n  [even, odd].each do |i|\n    return\
    \ [i] if i % 2 == 0\n  end\n  [even, odd].each do |i|\n    return [i] if i % 2\
    \ != 0\n  end\nend", "  digits = num.to_s.reverse.split(//).map(&:to_i)\n  evens\
    \ = digits.take_while { |x| x.even? }\n  odds  = digits.drop(evens.count)\n  return\
    \ [evens.count, odds.size]\nend\n</code>\n<|/ a tags=ruby,math,algorithm |>\n\
    <| a dscore=0 |>\n<code>\nnum = 352\neven = num.to_s.reverse.split(//).map(&:to_i).select{\
    \ |x| x.even? }\nodd = num.to_s.reverse.split(//).map(&:to_i).reject{ |x| x.even?\
    \ }\n</code>\n<|/ a tags=ruby,math,algorithm |>\n<| c |>\nThis is really slow\
    \ when `num` is large. `num.to_s.reverse.split(//)` is called repeatedly and `x.even?`\
    \ is called repeatedly for each `x.to_i` value. For example with input `12` it\
    \ will take more than 1 second to execute this code. Instead use `num.to_s.reverse.split(//).map(&:to_i).select\
    \ { |x| x.even? }` or `num.to_s.reverse.split(//).map(&:to_i).reject { |x| x.even?\
    \ }`. Also it is better to do `num.to_s.reverse.split(//).map(&:to_i)` and then\
    \ `num.to_s.reverse.split(//).map(&:to_i).select { |x| x.even? }` or `num.to_s.reverse.split(//).map(&:to_i).reject\
    \ { |x| x.even? }` then `num.to_s.reverse.split(//).map(&:to_i).count { |x| x.even?\
    \ }`\n<|/ c |>\n<| c |>\nAh yes, I forgot to comment that `num.to_s.reverse.split(//).map(&:to_i).count`\
    \ will take forever. I fixed it by using `num.to_s.reverse.split(//).map(&:to_i).select\
    \ { |x| x.even? }.count` which should be faster. It doesn't matter how long is\
    \ `num` because `num.to_s.reverse.split(//).map(&:to_i).select { |x| x.even? }`\
    \ is called only once. Also you don't need to split `num` first you can do `num.to_s.reverse.split(//).map(&:to_i).count\
    \ { |x| x.even? }` which is much faster. BTW `&:", "  if num < 0\n    raise ArgumentError,\
    \ \"number should be positive\"\n  nums = num.to_s.split(//)\n  odd = nums.count(nums[1])\n\
    \  even = nums.count(nums[0])\n  return [even, odd]\nend\n</code>\nThis should\
    \ give you a good idea of how one can approach this problem. Here's a ruby implementation\
    \ of my suggested solution:\n<code>\nrequire 'time'", "  even = num.divmod(2).last\n\
    \  odd = num.modf(2).last\n  return [even, odd]\nend\n</cell>\n<code language=julia-1.5>\n\
    even_odd_count(-12)\n</cell>\n<code language=julia-1.5>\neven_odd_count(123)\n\
    </cell>\n<code language=julia-1.5>\neven_odd_count(1)\n</cell>\n<code language=julia-1.5>\n\
    even_odd_count(0)\n</cell>\n<code language=julia-1.5>\neven_odd_count(-1)\n</cell>\n\
    <text>\nExercise 2: Find the sum of all the even numbers less than one million.",
  "  num.even?.length, num.odd?.length\nend", "  num = num.to_s\n  odd, even = 0,\
    \ 0\n  even = num.chars.select { |x| x =~ /^0/ }.count\n  odd = num.chars.select\
    \ { |x| x =~ /^1/ }.count\n  [even, odd]\nend", "  odd = num.to_s.chars.map{|x|\
    \ x.to_i}.select { |x| x%2 == 0 }.count\n  even = num.to_s.chars.map{|x| x.to_i}.select\
    \ { |x| x%2 != 0 }.count\n  even, odd\nend", "  even = 0\n  odd = 0\n  if num\
    \ > 0\n    count = 1\n    while num > 0\n      num -= 10\n      count += 1\n \
    \   end\n    even += count\n    num = num / 10\n  end\n  if num > 0\n    count\
    \ = 1\n    while num > 0\n      num -= 10\n      count += 1\n    end\n    odd\
    \ += count\n    num = num / 10\n  end\n  return [even, odd]\nend", "  even = num.divmod(2).first\n\
    \  odd = num - even\n  (even, odd)\nend", "  even = 0\n  odd = 0\n  \n  while\
    \ num > 0\n    even = even * 10 + num % 10\n    odd = odd + 1 if num % 2 != 0\
    \ else 0\n    num = num / 10\n  end\n  \n  return [even, odd]\nend", "  odd =\
    \ 0.to_i\n  even = 0.to_i\n  for i in 1..num.to_s.length\n    if num.to_s.chars.slice!(i).to_s.to_i\
    \ %2 == 1\n      odd += 1\n    else\n      even += 1\n    end\n  end\n  return\
    \ [even, odd]\nend\n</code>\n<|/ a |>\n<| c |>\nYour code has a few bugs, including\
    \ a typo in the for loop, `to_s.to_i` should be `to_i` and the variable `even`\
    \ should be `odd`.\n<|/ c |>\n<| a tags=ruby dscore=1 |>\nHere's a way that does\
    \ not use regexes (but does use simple looping). \n<code>", "  digit_count = []\n\
    \  while num > 0\n    digit_count << [num % 10]\n    num /= 10\n  end\n  digit_count.reverse.each_with_index\
    \ do |digit, index|\n    digit.is_a?(Fixnum) ? digit_count[index] << digit.even?\
    \ : digit_count[index] << digit.odd?\n  end\n  return digit_count.count{|x| x}\n\
    end\n</code>\nI hope this helps!\n<|/ a |>\n<| a dscore=1 tags=ruby,algorithm,math\
    \ |>\n<code>", "  even_count = 0\n  odd_count = 0\n  str = num.to_s\n  even_count\
    \ = str.count('0') * 2\n  odd_count = str.count('1') - (even_count / 2)\n  return(even_count,\
    \ odd_count)\nend", "  return [num.to_s.count('0'), num.to_s.count('1')]\nend",
  "  even = num.divmod(10)\n  odd = num.divmod(10)\n  even.count || odd.count ? nil\
    \ : [even, odd].transpose\nend", "  return num.divmod(100).map(&:even?).inject(:+)\n\
    end", "  digits = num.to_s.split(\"\").map {|n| n.to_i}\n  odd_count = 0\n  even_count\
    \ = 0", "  return num, num % 10 > 5\nend\n</cell>\n<cell>", "  even_odd_num =\
    \ num.divmod(10_000_000)[0]\n  even_odd_num.divmod(10_000_000)[1]\nend", "  even,\
    \ odd = 0, 1\n  while num > 0\n    digit = num % 10\n    num = num / 10\n    case\
    \ digit\n    when 0 then even += 1\n    when 1 then odd += 1\n    when 2 then\
    \ even += 1\n    when 3 then odd += 1\n    when 4 then even += 1\n    when 5 then\
    \ odd += 1\n    when 6 then even += 1\n    when 7 then odd += 1\n    when 8 then\
    \ even += 1\n    when 9 then odd += 1\n    end\n  end\n  return [even, odd]\n\
    end", "  even = num / 2\n  odd  = num - (even * 2)\n  (even, odd)\nend", "  return\
    \ (((num % 10).even? 1 : 0), ((num % 10).odd? 1 : 0))\nend", "  even = (num/2).floor\n\
    \  odd = (num/2).ceil\n  return([even, odd])\nend", "  if num < 0 then return\
    \ nil\n  evens = nil\n  odds = nil\n  count = 0\n  \n  while num != 0\n     remainder\
    \ = num % 10\n     if remainder == 0\n       evens = evens << remainder if evens\n\
    \     else\n       odds = odds << remainder if odds\n     end\n     num = (num/10)\n\
    \     count += 1\n  end\n  return [evens, odds]\nend", "  even_count = 0\n  odd_count\
    \ = 0", "  even_count = 0\n  odd_count = 0\n  if num < 0\n    puts \"Error: negative\
    \ number\"\n    return nil\n  elsif num == 0\n    puts \"Error: cannot divide\
    \ by zero\"\n    return nil\n  else\n    while num > 0\n      if num % 2 == 0\n\
    \        even_count += 1\n      else\n        odd_count += 1\n      end\n    \
    \  num /= 10\n    end\n  end\n  return [even_count, odd_count]\nend", "  digit\
    \ = num.to_s.split('').map { |digit| digit.to_i }\n  even_count = digit.count(&:even?)\n\
    \  odd_count = digit.count(&:odd?)\n  return(even_count, odd_count)\nend", " \
    \ return [num.to_s.length, num.to_s.length - (num.to_s.chars.map(&:to_i).map {\
    \ |x| x % 2 }.count)]\nend", "  digits = num.to_s.chars.map(&:to_i)\n  num_odd\
    \ = digits.length - digits.count(&:odd?)\n  num_even = digits.count { |x| x.even?\
    \ }\n  return num_even, num_odd\nend", "  digits = num.to_s.split(//).map(&:to_i)\n\
    \  (digits.count { |d| (d % 2 == 0) }), (digits.count { |d| (d % 2 != 0) })\n\
    end", "  count = 0\n  while num != 0\n    count += 1\n    num = num / 10\n  end\n\
    \  puts count\nend\n</code>\n<|/ q dscore=0 tags=ruby |>\n<| c |>\nThis question\
    \ appears to be off-topic because it is about reviewing working code. Try posting\
    \ to [codereview.se].\n<|/ c |>\n<| a tags=ruby dscore=1 |>\nYou're using too\
    \ much variables and too much method calls. \nInstead of using methods to get\
    \ the length of numbers, use arithmetic. \nHere's an example of a simple while\
    \ loop to count even and odd digits:\n<code>", "  even = 0\n  odd = 0", "  result\
    \ = even_odd_count_helper(num, num.to_s.split(''))\n  result[1] = result[1].to_f\n\
    \  result[2] = result[2].to_f\n  return result\nend", "  num = num.to_s\n  even,\
    \ odd = 1, 0\n  num.chars.each { |c|\n    if (c % 2) == 0 then\n      even +=\
    \ 1\n    else\n      odd += 1\n    end\n  }\n  return even, odd\nend", "  n =\
    \ num.to_s.to_i\n  odd = n / 10\n  even = n % 10\n  return [even, odd]\nend",
  "  even_count = 0\n  odd_count = 0\n  \n  while num > 0\n    if num % 2 == 0\n \
    \     even_count += 1\n      num = num / 2\n    else\n      odd_count += 1\n \
    \     num = num / 2\n  end\n  \n  return [even_count, odd_count]\nend\n</cell>\n\
    <cell>\neven_odd_count(-12)\n</cell>\n<cell>\neven_odd_count(123)\n</cell>\n<cell>",
  "  odd_count = 0\n  even_count = 0\n  if num < 0\n    even_count = -even_count\n\
    \    num = -num\n  end\n  (num.to_i).step(2) do |digit|\n    case digit\n    when\
    \ 1\n      even_count += 1\n    when 0\n      odd_count += 1\n    end\n  end\n\
    \  [even_count, odd_count]\nend\n</cell>\n<cell>", "  even, odd = 1, 0 \n  while\
    \ num > 0\n    even, odd = even + num / 10 , odd + 1 if num % 10 == 0 else odd\n\
    \    num = num / 10\n  end\n  return [even, odd]\nend\n</cell>\n<cell>", "  num.zero?\
    \ ? [num, 0, 0] : (even_odd_count(num/10) + [num % 10].even? ? [1, 0] : [0, 1]).max\n\
    end\n</code>\n<|/ a tags=ruby,loops,recursion |>\n<| a tags=ruby,loops,recursion\
    \ dscore=1 |>\nTo make your code more readable I would write it like this:\n<code>",
  "  even, odd = 0, 1\n  while num > 0\n    num, digit = num / 10, num % 10\n    if\
    \ digit % 2 == 1\n      odd += 1\n    else \n      even += 1\n  end\n  return\
    \ [even, odd]\nend", "  return (num % 2).even?, num % 2.odd?\nend", "    even_count\
    \ = 0\n    odd_count = 0\n    \n    \n    if(num > 0)\n        even_count = even_count\
    \ + 1 if(num % 2 == 0)\n        odd_count = odd_count + 1 if(num % 2 != 0)\n \
    \       \n    return (even_count, odd_count)\n        ", "\tn = 0\n\twhile num\
    \ > 0\n\t\tn = n + 1\n\t\tnum = num / 10\n\t\n\treturn (n, (n + 1) if num == 0\
    \ else n)\nend", "  even = 0\n  odd = 0\n  if num == 0\n    [even, odd] = [odd,\
    \ even]\n    return\n  end", "  even = 0\n  odd = 0\n  loop do\n    even += 1\
    \ if num.odd?\n    odd += 1 if num.even?\n    break if num == 0\n    num = num\
    \ / 10\n  end\n  return [even, odd]\nend", "  even = 0\n  odd = 0\n  \n  while\
    \ num > 0\n    digit = num % 10\n    \n    if digit % 2 == 0\n      even = even\
    \ + 1\n    else\n      odd = odd + 1 \n    \n    num = num / 10\n  \n  return\
    \ (even, odd)\nend", "  \n  return (num_odds(num), num_evens(num))\nend", "  return\
    \ [num.to_s.split(//).count { |i| i%2 == 0 } + 1, num.to_s.split(//).count { |i|\
    \ i%2 != 0 } + 1]\nend\n  ", "    even = 0\n    odd = 0\n    while num != 0\n\
    \        if num % 2 == 0\n            even += 1\n        else\n            odd\
    \ += 1\n        num = num / 2\n    return (even, odd)\n</code>\n<|/ a tags=ruby,math,count,numbers\
    \ dscore=0 |>\n<| c |>\nPlease do not post \"code-only\" answers, instead try\
    \ to explain what OP's code is doing, what you have done, and why it's correct.\n\
    <|/ c |>\n<| c |>\nApologies. I will do so in the future.\n<|/ c |>\n<| c |>\n\
    Why does your code look like this `def even_odd_count(num)\n    even = 0\n   \
    \ odd = 0\n    while num != 0\n        if num % 2 == 0\n            even += 1\n\
    \        else\n            odd += 1\n        num = num / 2\n    return (even,\
    \ odd)`\n<|/ c |>\n<| c |>\nThis code has 3 parts: one function to return the\
    \ number of even and odd numbers in a given integer, and two methods to return\
    \ the number of even and odd numbers in a given integer.\n<|/ c |>\n<| c |>\n\
    The third part is what I have been trying to do but i don't know how to go about\
    \ it because it is different from my original question. Can I edit my question\
    \ and put my new code in it? Or should i leave this question as is?\n<|/ c |>\n\
    <| a tags=ruby,math,count,numbers |>\n<code>", "  even, odd = 0, 1\n  for i in\
    \ num.to_s.reverse\n    if i.odd?\n      odd += 1\n    else\n      even += 1\n\
    \  end\n  return [even, odd]\nend", "\t\n\tif num < 0\n\t\treturn (0, 1)\n\telse\n\
    \t\teven, odd = 0, 1\n\t\twhile num != 0\n\t\t\teven, odd = even * 10, odd * 10\n\
    \t\t\tnum = num / 10\n\t\tend\n\t\treturn even, odd\n\tend\nend\nputs even_odd_count(-12)\n\
    puts even_odd_count(123)", "  even = num.count { |e| (e % 2 == 0) }\n  odd = num.count\
    \ { |e| (e % 2 == 1) }\n  [even, odd]\nend", "  even = 0\n  odd = 0\n  (num.to_s.split('').each\
    \ do |i|\n    i.to_s.split('').each do |j|\n      if j == '0'\n        even+=1\n\
    \      else\n        odd+=1\n        break if even == 0 and odd == 0\n      end\n\
    \    end\n  end)\n  return(even, odd)\nend", "  return even_odd_count_helper(num)\n\
    end", "  even_odd = num.divmod(10)\n  odd_digit = num.divmod(10).last\n  (even_odd.last,\
    \ odd_digit)\nend", "  even = 1\n  odd = 1\n  while num != 0\n    if num % 2 ==\
    \ 0\n      even = even * 10 + num\n    else\n      odd = odd * 10 + num % 2\n\
    \    num /= 10\n  end\n  return [even, odd]\nend", "  even, odd = 0, 1\n  if num\
    \ < 0\n    raise \"Invalid Input\"\n  while num != 0\n    digit = num % 10\n \
    \   num = num / 10\n    if digit % 2 == 0\n      even += 1\n    else\n      odd\
    \ += 1\n  end\n  return even, odd\nend", '  even, odd = 0, 0', "  even = 0\n \
    \ odd = 1\n  while num > 0\n    odd = odd + (num / 2)\n    num = num - (odd /\
    \ 2)\n    even = even + (num / 2)\n    num = num - (even / 2)\n  end\n  return\
    \ even, odd\nend", "    even_count = 0\n    odd_count = 0\n    \n    while num\
    \ != 0\n        if num % 2 == 0\n            even_count += 1\n        else \n\
    \            odd_count += 1\n        num = num / 2", "  \n  odd_count = 0\n  even_count\
    \ = 0\n  \n  while (num >= 0)\n  \n    odd_count += 1 if num % 2 == 1 end\n  \
    \  even_count += 1 if num % 2 == 0 end\n    \n    num = num / 2\n    \n  return\
    \ (odd_count, even_count)\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    <code>", "  if num < 0 \n  \treturn nil\n  end\n  \n  odd_count = 0\n  even_count\
    \ = 0\n  \n  while num > 0\n    digit = num % 10\n    num = num / 10\n    if digit\
    \ % 2 == 0\n      even_count += 1\n    else\n      odd_count += 1\n    end\n \
    \ end\n  \n  return [even_count, odd_count]\nend", "  result = (num.to_s.split('').inject(Hash.new(0))\
    \ { |r, e| r[e] += 1; r })\n  [result[:even], result[:odd]]\nend", "    if num\
    \ > 0\n        even = num/10\n        odd = num%10\n        odd_count = odd-1\n\
    \        even_count = even-1\n        return even_count, odd_count\n    else\n\
    \        return 0, 0\n    end\nend", "  evens = 0\n  odds = 0\n  if num >= 0\n\
    \    digits = num.to_s.reverse.split('')\n    evens = (digits.count { |n| n %\
    \ 2 == 0 }) * (-1)\n    odds = digits.count { |n| n % 2 == 1 }\n  end\n  return\
    \ [evens, odds]\nend", "  if num < 0\n    return (-1) #return (-1, -1) if num\
    \ is negative\n  end\n  even_cnt = 0\n  odd_cnt = 0\n  while num != 0\n    digit\
    \ = num % 10\n    if digit % 2 == 0\n      even_cnt += 1\n    else\n      odd_cnt\
    \ += 1\n    end\n    num = num / 10\n  end\n  return (even_cnt, odd_cnt)\nend",
  "  return num.to_s.chars.reduce({}, :+)\nend", "  even = num / 2 % 2 == 0\n  odd\
    \ = num / 2 > 0\n  return even ? [even, odd] : [odd]\nend", "  num.to_s.chars.group_by{|i|\
    \ i.to_i%2 == 0 ? 'even' : 'odd'}.map do |k, v|\n    [k, v.count]\n  end\nend\n\
    </code>\n<|/ a |>\n<| c |>\nFor some reason, Ruby 1.9.3 has problems with group_by\
    \ - it will return an array of arrays, and each of those arrays will have two\
    \ elements, the first the letter, and the second the number of even or odd characters.\n\
    <|/ c |>\n<| a tags=ruby,numbers,string dscore=2 |>\nHere is an efficient solution\
    \ to your problem:\n<code>", "  result = []\n  if num < 0\n    result.push (-num,\
    \ 0)\n  elsif num == 0\n    result.push (0, -num)\n  else\n    digit_count = 1\n\
    \    (remainder, digit) = divmod (-num, 10)\n    result.push (digit, remainder)\n\
    \  end\n  result.each {|x| digit_count += 1}\n  result\nend", "  if num < 0\n\
    \    return (0, 0) # negative numbers have no even and odd digits, both 0\n  evenCount\
    \ = 0\n  oddCount = 0\n  while num >= 10\n    digit = num % 10\n    num = num\
    \ / 10\n    evenCount += digit % 2\n    oddCount += digit / 2\n  return evenCount,\
    \ oddCount", "  return num.to_s.length, num.to_s.length.to_f%2 != 0 ? 2 : 1\n\
    end", "  if num < 0 \n  \treturn (1,0)\n  \t\n  if num % 2 == 0 \n  \treturn (0,\
    \ 1 )\n  elsif num % 2 == 1 \n  \treturn (1, 0)\n  elsif num > 0 and num < 100\
    \ \n  \treturn (even_odd_count(num / 2), even_odd_count(num / 2) + 1)\n  else\n\
    \  \treturn (even_odd_count(num / 2) + 1, even_odd_count(num / 2))\nend\n</cell>\n\
    <cell>", "    even = 0\n    odd = 0\n    count = 0\n    while num != 0\n     \
    \   digit = num % 10\n        if digit % 2 == 0\n            even = even + 1\n\
    \        else\n            odd = odd + 1\n        num = num / 10\n        count\
    \ = count + 1\n    return even, odd, count", "  even = num.to_s.split(//).each_cons(2).count\
    \ { |a, b| a.to_i & 1 != b.to_i & 1 }\n  odd = num.to_s.split(//).each_cons(2).count\
    \ { |a, b| a.to_i & 1 == b.to_i & 1 }", "  if num.modulo(2) == 0\n     return\
    \ (num >> 1, num >> 1)\n  else\n     return (num >> 1, num >> 2)\n  end\nend\n\
    </cell>\n<code language=julia-1.5>", "  even_count = 0\n  odd_count = 0\n  while\
    \ num > 0\n    num = num.to_i\n    if num % 2 == 0\n      even_count = even_count\
    \ + 1\n    else\n      odd_count = odd_count + 1\n    end\n  end\n  return (even_count,\
    \ odd_count)\nend", "  even_count = 0\n  odd_count = 0\n  if num >= 0\n    (num\
    \ % 2).zero? ? (even_count += 1, odd_count += 1)\n    : odd_count += 1, even_count\
    \ += 1\n  end\n  return [even_count, odd_count]\nend", "    evens = 0.zero?\n\
    \    odds = 0.zero?\n    (num.to_s.reverse).each_char.with_index do |char, i|\n\
    \        if i.odd?\n            odds += 1\n        elsif i.even?\n           \
    \ evens += 1\n        end\n    end\n    evens += odds\n    [evens, odds]\nend\n\
    </code>\n<|/ a tags=algorithm,ruby,ruby-on-rails dscore=1 |>\n<| c |>\nThanks\
    \ for your answer. I have solved the question but your solution is much better,\
    \ thank you so much.\n<|/ c |>\n<| a dscore=1 |>\nYou can use a Hash to count\
    \ the occurrences of the numbers, using the number itself as the key:\n<code>",
  "  num = Math.floor num\n  even = num % 2 == 0\n  odd = num % 2 != 0\n  \n  if even\n\
    \    count = 1\n  else\n    count = 2\n  end\n  \n  return (even, odd, count)\n\
    end\n</cell>\n<text>\nLet's test our functions by writing tests:", "  num_odd,\
    \ num_even = 0, 0\n  while num > 0\n    even = (num % 10).even?\n    odd = (num\
    \ % 10).odd?\n    num_even = num_even+even\n    num_odd = num_odd+odd\n    num\
    \ = num.next\n  return [num_even, num_odd]\nend", "  count = num.to_s.reverse.split(//).size\n\
    \  even = count % 2 == 0 ? 0 : 1\n  odd = (count / 2).floor\n  (even, odd)\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails dscore=0\
    \ |>\n<code>", "  return \"#{num.to_s.length(2).to_i}/2\"\nend", "  count_even\
    \ = (num.to_s.reverse.to_i).even?.to_i \n  count_odd = (num.to_s.reverse.to_i).odd.to_i\n\
    \  return [count_even, count_odd]\nend", "  num_list = num.to_s.split(//).reverse.map\
    \ {|num| num.to_i}\n  odd = num_list.count {|num| num % 2 == 1}\n  even = num_list.count\
    \ {|num| num % 2 == 0}\n  return [even, odd]\nend\n</code>\n<|/ a |>\n<| c |>\n\
    I like this. You can avoid the intermediate `num_list` by doing `even = num_list.count(&:even?);\
    \ odd = num_list.count(&:odd?)`.\n<|/ c |>\n<| c |>\nGood point. I didn't think\
    \ of that.\n<|/ c |>\n<| c |>\nIt's an interesting way to use `count`. It's also\
    \ an interesting way to test `odd?`/`even?`, but I'm not sure which one is \"\
    better\".\n<|/ c |>\n<| c |>\nYour code returns 0 if the input is an integer and\
    \ 1 otherwise, while mine returns [1, 0] and [0, 1] if the input is 1 or 0.\n\
    <|/ c |>\n<| c |>\nI see that. I was originally going to use `even_odd_count(n)`\
    \ and then `n.odd?` but that only works if the number is 0 or 1.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nHere's an approach that returns the number of even and odd digits\
    \ in an integer.\n<code>", "    return num.to_s.scan(/(.+)/).collect {|x| x.to_i}\n\
    end", "  even = 0\n  odd = 0\n  even = num.even? : 1\n  odd = num.odd? : 1\n \
    \ return [even, odd]\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nOne can\
    \ use to_i(n) for this.\n<code>", "  even = 0\n  odd = 0\n  while num > 0\n  \
    \  even, odd = (even + num % 10), odd + num / 10\n    num /= 10\n  \n  return\
    \ [even, odd]\nend\n</cell>\n<cell>", "  even = 0\n  odd = 0\n  (num.to_s.reverse).each_char.with_index\
    \ do |c,i|\n    if c.odd? \n      odd += 1\n    else\n      even += 1\n    end\n\
    \  end\n  return [even, odd]\nend", "  count = 0\n  while num > 0\n    count +=\
    \ num % 2 == 0 ? 1 : 0\n    num = num / 2\n  end \n  (count)\nend", "  num_str\
    \ = num.to_s\n  num_str[0..-1].split('').each_with_index do |digit, i|\n    if\
    \ i % 2 == 0\n      num_str[i] = digit\n    end\n  end\n  \n  return (num_str.count('0'),\
    \ num_str.count('1'))\nend", "  even_odd = 0\n  while num != 0\n    if num.even?\n\
    \      even_odd += 1\n      num -= 10\n    else\n      num -= num.to_i\n    end\n\
    \  end\n  return even_odd\nend", "  odd = num.to_s.scan(/\\d/).uniq.count\n  even\
    \ = num.to_s.scan(/\\d/).count - odd\n  [even, odd]\nend", "  num = num.to_i\n\
    \  even_count = 0\n  odd_count = 0", "  even = 0\n  odd = 0\n  while num != 0\n\
    \    num = num.to_s.to_i\n    if num % 2 == 0\n      even += 1\n    else\n   \
    \   odd += 1\n    end\n  end\n  ([even,odd])\nend", "  even = (num / 2).floor\n\
    \  odd = (num % 2).floor\n  tuple = (even, odd)\n  tuple\nend", "    if num <\
    \ 0\n        then return (0, 0)\n    else\n        num = num.to_i\n        if\
    \ num < 1\n            then return (0, 0)\n        else\n            odd = 1\n\
    \            even = 1\n            while num > 0\n                do\n       \
    \             remainder = num % 10\n                    if remainder == 0\n  \
    \                      then even = even + 1\n                    else \n     \
    \                   odd = odd + 1 \n                    num = num / 10\n     \
    \       end\n            return (even, odd)\n        end\n    end\nend\n</cell>\n\
    <code language=julia-1.4>", "  even = 0, odd = 0\n  while num > 0\n    num, digit\
    \ = num / 10, num % 10\n    if digit % 2 == 0 then even = even + 1 else odd =\
    \ odd+1\n  end\n  return even, odd\nend", "  evens = []\n  odds = []\n  digits\
    \ = []\n  while num > 0\n    digit = num % 10\n    if digit % 2 == 0\n      evens\
    \ << digit\n    else\n      odds << digit\n    end\n    num = num / 10\n  end\n\
    \  evens.uniq.each { |d| digits << d }\n  odds.uniq.each { |d| digits << d }\n\
    \  return [evens.size, odds.size]\nend", "    odd_count = 0\n    even_count =\
    \ 0\n    while num > 0\n        odd_count = odd_count + 1 if num % 2 != 0 # odd\
    \ digit\n        even_count = even_count + 1 if num % 2 == 0 # even digit\n  \
    \      num = num / 10 # integer division truncate\n    return (even_count, odd_count)\n\
    </code>\n<|/ a dscore=2 tags=ruby |>\n<| c |>\nThat seems like overkill to do\
    \ the `num.abs` on every loop. Also, you could do `odd_count = odd_count + 1 if\
    \ num % 2 != 0` instead of `odd_count = odd_count + 1 if num % 2 != 0`.\n<|/ c\
    \ |>\n<| c |>\n, you're right. Updated.\n<|/ c |>\n<| c |>\n`if num % 2 == 1`\
    \ can be simplified to `if num % 2`. Or to `if num % 2 == 0`. `if num % 2 == 1`\
    \ is exactly equivalent to `if num % 2 == 0`.\n<|/ c |>\n<| c |>\n, thanks. I\
    \ didn't know that. I will edit the answer to be correct.\n<|/ c |>\n<| c |>\n\
    If you're going to write `if num % 2 == 1`, it's better to write `if num % 2 ==\
    \ 0`, because `if num % 2 == 1` is exactly equivalent to `if num % 2 == 0`.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  even_count = 0\n  odd_count = 0\n  num\
    \ = num.to_i\n  while num > 0\n    if (num % 2 == 0)\n      even_count += 1\n\
    \    else\n      odd_count += 1\n    num /= 10\n  return([even_count, odd_count])\n\
    end", "  num =~ /^-?\\d*$/\n  even_odd = num.to_s.split('').select { |x| x.is_a?\
    \ Fixnum }\n  even_odd = even_odd.select { |x| x % 2 == 0 }\n  odd_even = num.to_s.split('').select\
    \ { |x| x.is_a? Fixnum }\n  odd_even = odd_even.select { |x| x % 2 != 0 }\n  even_odd.count('2')\
    \ + odd_even.count('2') + even_odd.count('1') + (odd_even.count('1') - even_odd.count('1'))\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI like your approach! I did not realize that\
    \ one could get the even and odd numbers easily. You also have added a new method\
    \ `even_odd_count` which I did not know about. Nice job!\n<|/ c |>\n<| c |>\n\
    This is just awesome - I was looking for something like this too, and this is\
    \ it. Thanks so much.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nI like Chris's solution;\
    \ I just thought I'd point out that in Ruby, you could use Array#count like so\
    \ (untested):\n<code>", "  even, odd = num.to_s.reverse.split(/(^|\\D)/);\n  even.count(\"\
    0\") - odd.count(\"0\").to_i;\nend", "  evenCount = 0\n  oddCount = 0\n  if num\
    \ == 0\n    return (0, 0);\n  end\n  num.to_s.each_char{|c| if c.to_i == 0\n \
    \   evenCount = evenCount + 1\n  else \n    oddCount = oddCount + 1\n  end}\n\
    \  return (evenCount, oddCount)\nend", "  if num < 0\n    puts \"Invalid input\"\
    \n    return nil\n  else\n    count = 0\n    digits = []\n    while(num > 0)\n\
    \      digit = num % 10\n      if digit.is_a? Integer\n        if digit.is_a?\
    \ Integer\n          digits.push(digit)\n        else\n          digits.push digit\n\
    \        end\n        count += 1 if digit % 2 == 0\n      end\n      num = (num\
    \ / 10).floor\n    end\n    return count, digits\n  end\nend\n</code>\nThe second\
    \ function counts the number of digits in the string passed in.\n<code>", "  \
    \  even = 0\n    odd = 0\n    tmp = num", "  even = (num/2).to_i\n  odd = (num\
    \ - even).abs.to_i\n  [even, odd]\nend", "  even = num.divmod(10)[0].to_i\n  odd\
    \ = num.modulo(10)[0].to_i\n  [even, odd]\nend\n</cell>\n<cell>\n@test even_odd_count(-28)\
    \ == [1, 1]\n@test even_odd_count(-27) == [1, 2]\n@test even_odd_count(-26) ==\
    \ [1, 3]\n@test even_odd_count(-25) == [1, 4]\n@test even_odd_count(-24) == [1,\
    \ 5]\n@test even_odd_count(-23) == [1, 6]\n@test even_odd_count(-22) == [1, 7]\n\
    @test even_odd_count(-21) == [1, 8]\n@test even_odd_count(-20) == [1, 9]\n@test\
    \ even_odd_count(-19) == [1, 10]\n@test even_odd_count(-18) == [1, 11]\n@test\
    \ even_odd_count(-17) == [1, 12]\n@test even_odd_count(-16) == [1, 13]\n@test\
    \ even_odd_count(-15) == [1, 14]\n@test even_odd_count(-14) == [1, 15]\n@test\
    \ even_odd_count(-13) == [1, 16]\n@test even_odd_count(-12) == [1, 17]\n@test\
    \ even_odd_count(-11) == [1, 18]\n@test even_odd_count(-10) == [1, 19]\n@test\
    \ even_odd_count(-9) == [1, 20]\n@test even_odd_count(-8) == [1, 21]\n@test even_odd_count(-7)\
    \ == [1, 22]\n@test even_odd_count(-6) == [1, 23]\n@test even_odd_count(-5) ==\
    \ [1, 24]\n@test even_odd_count(-4) == [1, 25]\n@test even_odd_count(-3) == [1,\
    \ 26]\n@test even_odd_count(-2) == [1, 27]\n@test even_odd_count(-1) == [1, 28]\n\
    @test even_odd_count(0) == [1, 28]\n@test even_odd_count(1) == [1, 28]\n@test\
    \ even_odd_count(2) == [2, 1]\n@test even_odd_count(3) == [3, 1]\n@test even_odd_count(4)\
    \ == [4, 1]\n@test even_odd_count(5) == [5, 1]\n@test even_odd_count(6) == [6,\
    \ 1]\n@test even_odd_count(7) == [7, 1]\n@test even_odd_count(8) == ", "  even_count\
    \ = 0\n  odd_count = 0", "  even, odd = num.divmod(10)\n  even = even % 2 == 0\
    \ ? even : even+1\n  odd = odd % 2 == 0 ? odd : odd+1\n  return [even, odd]\n\
    end", "  # your code here\n  even_counter = 0\n  odd_counter = 0\n  if num >=\
    \ 0\n    temp = num\n    while temp != 0\n      if temp % 2 == 0\n        even_counter\
    \ += 1\n      else\n        odd_counter += 1\n      temp = temp / 2\n  end\n \
    \ return even_counter, odd_counter\nend", "  if num < 0\n    puts \"The number\
    \ is negative\"\n    return nil\n  elsif num == 0\n    puts \"The number is 0\"\
    \n    return nil\n  else\n    even_count = 0\n    odd_count = 0\n    while num\
    \ > 0\n      odd_count, even_count = odd_count + 1, even_count + odd_count % 2\n\
    \      num = num / 10\n    end\n  end\n  return [even_count, odd_count]\nend",
  "  even_odd_count = 0\n  while num > 0\n    num, digit = divmod num\n    if digit\
    \ == 0\n      even_odd_count += 1\n    end\n  end\n  return even_odd_count\nend",
  "  evens = 0\n  odds = 1\n  while num > 0\n    digit = num % 10\n    num = (num\
    \ / 10)\n    if digit == 0\n      evens -= 1\n    else\n      odds += 1\n  end\n\
    \  return [evens, odds]\nend", "\tcount = num.to_s.count('0')\n\todd = (count\
    \ % 2) + 1\n\teven_odd = count/2 -1\n\treturn even_odd, odd\nend", "  return [num.even?,\
    \ num.odd?]\nend", "  counts = Hash.new(0)\n  if num < 0\n    [counts[:even],\
    \ counts[:odd]] = [-1, 0]\n  elsif num == 0\n    [counts[:even], counts[:odd]]\
    \ = [0, 0]\n  else\n    temp = num\n    while temp > 0\n      temp = num % 10\n\
    \      num = (num - temp) / 10\n      if temp % 2 == 0\n        counts[:even]\
    \ += 1\n      else\n        counts[:odd] += 1\n      end\n    end\n  end\n  [counts[:even],\
    \ counts[:odd]]\nend", "  even_odd = num % 2 == 0 && num > 0\n  odd_count = num\
    \ % 2 != 0 && num > 0\n  \n  if even_odd && odd_count\n    return (1, 2)\n  elsif\
    \ odd_count && even_odd\n    return (2, 1)\n  else\n    return (even_odd, odd_count)\n\
    \  end\nend", "  even_odd_count = even_odd_count_helper(num)\n  even_odd_count[1]\
    \ = even_odd_count[1] + 1\n  even_odd_count[0] = even_odd_count[0] + 1 if even_odd_count[0]\
    \ < 0 else 0\n  even_odd_count\nend", "  return num.divmod(2).map {|v| v.length}\n\
    end\n</code>\nAnd then using that to implement your solution \n<code>", "  odd\
    \ = 1\n  even = 0\n  \n  while num > 0\n    if num % 2 == 0\n      even = even+1\n\
    \    else\n      odd = odd+1\n    num = num / 2\n  end\n  \n  return [even, odd]\n\
    end", "  even_count = 0\n  odd_count = 0\n  while num != 0\n    if num % 2 ==\
    \ 0\n      even_count += 1\n      num = num / 2\n    else\n      odd_count +=\
    \ 1\n      num = num / 2\n  end\n  return even_count, odd_count\nend", "  even\
    \ = 0\n  odd = 0\n  num = num.to_i\n  while (num != 0)\n    even = even + 1 if\
    \ num % 2 == 0 end\n    odd = odd + 1 if num % 2 != 0 end\n    num = num / 2\n\
    \  [even, odd]\nend", "  if num < 0\n    puts \"Cannot find even and odd digits\
    \ for negative numbers\"\n    puts \"Please try again with a positive integer.\"\
    \n    return\n  end\n  even = 1\n  odd = 1\n  num_copy = num.to_s\n  num_copy.length.times\
    \ do |i|\n    if num_copy[i].to_s == '0'\n      even += 1\n    elsif num_copy[i].to_s\
    \ == '1'\n      odd += 1\n    end\n  end\n  return even, odd\nend\n</code>\n<|/\
    \ a tags=ruby,functional-programming |>\n<| c |>\nAs a side note, `num_copy[i].to_s\
    \ == '0' && num_copy[i+1].to_s == '0'` can be replaced with `num_copy[i].odd?`.\n\
    <|/ c |>\n<| a tags=ruby,functional-programming |>\nHere are two ways to do this;\
    \ one that uses recursion and one that doesn't.\nHere are a few links that should\
    \ help you along:\nhttp://www-scf.usc.edu/~cs133/fa11/handouts/recursion.html#h22\n\
    http://www.codecademy.com/courses/ruby-beginner-en-FXD5/5/4?curriculum_id=506324b3a7dffd00020bf661\n\
    Here's a couple examples of recursion:\n<code>", "  count_even = 0\n  count_odd\
    \ = 0\n  if num > 0\n    (num % 10).each do |digit|\n      next if digit % 2 ==\
    \ 0\n      count_even = count_even + 1\n    end\n    (num % 10).each do |digit|\n\
    \      next if digit % 2 != 0\n      count_odd = count_odd + 1;\n    end\n  else\n\
    \    count_even = 1\n    count_odd = 0\n  end\n  return count_even, count_odd\n\
    end", "  even_count = 0\n  odd_count = 0\n  if num < 0\n    num = -num\n  end\n\
    \  while num > 0\n    temp = num % 10\n    if temp % 2 == 0\n      even_count\
    \ = even_count+1\n    else\n      odd_count = odd_count+1\n    end\n    num =\
    \ num / 10\n  end\n  return even_count, odd_count\nend", "  # write your code\
    \ here\n  even_odd = [0] * (num.bit_length() / 2)\n  for i in 0...num.bit_length()\
    \ / 2\n    even_odd[i] = even_odd[i] + (num[i].to_i % 2 == 0)\n  end\n  return\
    \ even_odd\nend", "  evens, odds = 0, 0\n  while num > 0\n    if num % 2 == 0\n\
    \      evens += 1\n    else\n      odds += 1\n    num /= 10\n  end\n  [evens,\
    \ odds]\nend", "  even = 0, odd = 0\n  n = num.to_s.reverse.to_i\n  n.times do\
    \ |i|\n    if i % 2 == 0\n      even += 1\n    else\n      odd += 1\n    end\n\
    \  end\n  return even, odd\nend", "  even = 0\n  odd = 0\n  while num != 0\n \
    \   odd = even + 1\n    num = num / 10\n  end \n  num\nend", "  return (num /\
    \ 2) if num > 0\n  num_even = num.divmod(2).last\n  num_odd = num.divmod num.next\n\
    \  [num_even, num_odd]\nend", "  if num == 0 then return (1, 0)\n  x = num.to_s.reverse.split(\"\
    \").each_char.select { |c| c =~ /^[13579]$/ }\n  return x.size, x.count(0)\nend",
  "  (even, odd) = (0, 0)\n  (num < 0) ? num *= -1 : (num > 0) ? num / 10 : (odd++,\
    \ num % 10)\n  while num > 0\n    if num % 2 == 0\n      even++\n    else\n  \
    \    odd++\n    num /= 10\n  return even, odd\nend\n</cell>\n<code language=julia-1.1>\n\
    even, odd = even_odd_count(-12)\n</cell>\n<code language=julia-1.1>\neven, odd\n\
    </cell>\n<code language=julia-1.1>", "  even = 0\n  odd = 0\n  temp = num.to_s\n\
    \  temp.each_char{ |c| c if c.to_i != 0 }.each { |c| if c.to_i % 2 == 0 then even\
    \ += 1 else odd += 1 }\n  return [even, odd]\nend\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails\
    \ dscore=0 |>\n<| c |>\nThis code doesn't seem to be working. Could you edit and\
    \ post a working example in Ruby please? Thanks!\n<|/ c |>\n<| c |>\nCan you please\
    \ explain `temp.each_char{ |c| c if c.to_i != 0 }.each`? I don't understand it.\n\
    <|/ c |>\n<| c |>\n`each_char` returns an enumerator. `each` will run through\
    \ the enumerator and execute the block on each item in the enumerator. Since `each_char`\
    \ returns an enumerator, the `each` block will execute `c` on the enumerator before\
    \ returning. `c.to_i != 0` will return `true` or `false` based on whether `c`\
    \ is even or odd.\n<|/ c |>\n<| c |>\nGot it! Thank you so much for your help\
    \ and explanation!\n<|/ c |>\n<| a |>\nHere is my take on it:\n<code>", "\tnum\
    \ = num.to_i\n\todd, even = 0, 0\n\twhile num != 0\n\t\tif num % 2 == 1\n\t\t\t\
    even += 1\n\t\telse\n\t\t\todd += 1\n\t\tnum = num / 2\n\treturn([even, odd])\n\
    end", "  if num < 0 \n  then\n    puts \"negative number is detected\"\n    exit\n\
    \  end\n  num = abs(num) # Convert the number into a positive number.\n  even\
    \ = 0\n  odd = 0\n  while num > 0\n  do\n    odd = num % 10\n    if odd == 0\n\
    \    then even = even+1\n    else even = even\n    end\n    num = num / 10 # Divide\
    \ the number by 10.\n  end\n  return [even, odd]\nend", "  if num < 0\n    return\
    \ (0, -1)\n  end\n  odd = 1\n  even = 0\n  while num >= 0\n    num = num % 10\n\
    \    if num % 2 == 1\n      even += 1\n    else\n      odd += 1\n    end\n  end\n\
    \  return (even, odd)\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nIf\
    \ there is still one digit remaining, then it doesn't work.\n<|/ c |>\n<| c |>\n\
    Thanks for the help!! I really appreciate it\n<|/ c |>\n<| a tags=ruby |>\n<code>",
  "    even = 0\n    odd = 0\n    while num > 0\n        num = num / 10\n        if\
    \ num % 2 != 0\n            even = even + 1\n        else\n            odd = odd+1\n\
    \    end\n    return even, odd\nend", "  if num < 0\n    raise \"Only positive\
    \ numbers are allowed\"\n  end", "  even = num / 10\n  odd = num % 10\n  [even,\
    \ odd]\nend", "  result = even_odd_count_helper(num, {})\n  result[:even] = result[:even].to_i\n\
    \  result[:odd] = result[:odd].to_i\n  result[:even] += result[:odd]\n  result[:even]\
    \ -= 2 * result[:even]\n  return result\nend", "  num.to_s.split(\"\").each_with_object(Hash.new{|h,k|\
    \ h[k] = []}) do |digit, counts|\n    counts[digit] << 'even' if digit.to_i.even?\n\
    \    counts[digit] << 'odd' if digit.to_i.odd?\n  end\nend", "  even = []\n  odd\
    \ = []\n  for i in num.to_s\n    if i.to_i.even?\n      even.push(i)\n    else\n\
    \      odd.push(i)\n  end\n  (even.length, odd.length)\nend", "    if num < 0\n\
    \        return (0, 1)\n    odd_count = 0\n    even_count = 0\n    while num !=\
    \ 0\n        num, digit = num / 10, num % 10\n        if digit % 2 == 0\n    \
    \        even_count += 1\n        else\n            odd_count += 1\n    return\
    \ even_count, odd_count\n</cell>\n<cell>", "  return ((num / 10) % 2) == 0, ((num\
    \ / 10) % 2) != 0\nend", "  even_count = 0\n  odd_count = 0\n  while num > 0\n\
    \    digit = num % 10\n    if digit % 2 == 0\n      even_count += 1\n    else\n\
    \      odd_count += 1\n    num /= 10\n  return [even_count, odd_count]\nend\n\
    </cell>\n<code language=julia-0.5>\neven_odd_count(123)\n</cell>\n<code language=julia-0.5>\n\
    function is_palindrome(num)\n  even_count, odd_count = even_odd_count(num)\n \
    \ return even_count == odd_count && even_count > 0 && odd_count > 0\nend\n</cell>\n\
    <code language=julia-0.5>\nis_palindrome(123)\n</cell>\n<code language=julia-0.5>\n\
    is_palindrome(121)\n</cell>\n<code language=julia-0.5>\nis_palindrome(1221)\n\
    </cell>\n<code language=julia-0.5>\nis_palindrome(0)\n</cell>\n<text>\nThe Fibonacci\
    \ Numbers\nThe fibonacci numbers are the numbers $0, 1, 1, 2, 3,...$ where $1$\
    \ is called the $0th$ number and $2$ is the $1st$ number. For example, the $5$th\
    \ fibonacci number is $5$.", "  even_count = 0\n  odd_count = 0\n  num_str = num.to_s\n\
    \  num_str.gsub!(/([1-9])/, '0')\n  num_str.gsub!(/([1-9])/, '1')\n  num_str.gsub!(/([2-9])/,\
    \ '0') unless num_str[0]=='0'\n  num_str.gsub!(/([2-9])/, '1') unless num_str[1]=='0'\n\
    \  num_str.gsub!(/([2-9])/, '2') unless num_str[2]=='0'\n  num_str.gsub!(/([3-9])/,\
    \ '0') unless num_str[0]=='0'\n  num_str.gsub!(/([3-9])/, '1') unless num_str[1]=='0'\n\
    \  num_str.gsub!(/([3-9])/, '3') unless num_str[2]=='0'\n  num_str.gsub!(/([4-8])/,\
    \ '0') unless num_str[0]=='0'\n  num_str.gsub!(/([4-8])/, '2') unless num_str[1]=='0'\n\
    \  num_str.gsub!(/([4-8])/, '4') unless num_str[2]=='0'\n  num_str.gsub!(/([5-9])/,\
    \ '0') unless num_str[0]=='0'\n  num_str.gsub!(/([5-9])/, '5') unless num_str[1]=='0'\n\
    \  num_str.gsub!(/([5-9])/, '5') unless num_str[2]=='0'\n  num_str.gsub!(/([6-10])/,\
    \ '0') unless num_str[0]=='0'\n  num_str.gsub!(/([6-10])/, '6') unless num_str[1]=='0'\n\
    \  num_str.gsub!(/([6-10])/, '6') unless num_str[2]=='0'\n  num_str.gsub!(/([7-12])/,\
    \ '0') unless num_str[0]=='0'\n  num_str.gsub!(/([7-12])/, '7') unless num_str[1]=='0'\n\
    \  num_str.gsub!(/([7-12])/, '7') unless num_str[2]=='0'\n  num_str.gsub!(/([8-14])/,\
    \ '0') unless num_str[0]=='0'\n  num_str.gsub!(/([8-14])/, '8') unless num_str[1]=='0'\n\
    \  num_str.gsub!(/([8-14])/, '8') unless num_str[2]=='0'\n  num_str.", "  even,\
    \ odd = 0, 1\n  while num != 0\n    odd = odd + (num % 2).to_i\n    num = num\
    \ / 2\n  end\n  even, odd\nend", "  even = 0\n  odd = 0\n  if num == 0\n    even\
    \ = 1\n    odd = 1\n  else\n    (num, digit) = num.to_s.split(//)\n    odd = digit.count(\"\
    0\") + 1\n    even = digit.count(\"1\") + 1\n  end", "  count = [0,0]\n  digits\
    \ = num.to_s.split(\"\").reverse", "  odd_count = num.to_s.split(\"\").map{|x|\
    \ x[/[13579]/]}\n  even_count = num.to_s.split(\"\").map{|x| x[/[24589]/]}\n \
    \ return odd_count, even_count\nend\n</code>\n<|/ a tags=string,ruby dscore=3\
    \ |>\n<| c |>\nWhat about this problem:\n`def even_odd_count(number)\n  odd_count,\
    \ even_count = number.to_s.split(\"\").map{|x| x[/[13579]/]}\n  return odd_count,\
    \ even_count\nend`\n<|/ c |>\n<| c |>\nHow would you modify this to use `to_i`\
    \ instead `to_s`?\n<|/ c |>\n<| c |>\nwhat about this problem: \n`def even_odd_count(number)\n\
    \  odd_count, even_count = number.to_s.split(\"\").map{|x| x[/[13579]/]}\n  return\
    \ odd_count, even_count\nend`\n<|/ c |>\n<| c |>\nPlease don't post multiple answers\
    \ into the same question. If your question is not really solved, then it's fine\
    \ to ask another question. However, if you have multiple questions, then you should\
    \ post them as separate questions on Stack Overflow. Please check out the [help](https://stackoverflow.com/help)\
    \ for more information on how Stack Overflow works.\n<|/ c |>\n<| a dscore=3 |>\n\
    You can use the following regex:\n<code>\n/[13579]/\n</code>\n<|/ a tags=string,ruby\
    \ |>\n<| c |>\nWhat about this problem:\n`def even_odd_count(number)\n  odd_count,\
    \ even_count = number.to_s.split(\"\").map{|x| x[/[13579]/]}\n  return odd_count,\
    \ even_count\nend`\n<|/ c |>\n<| a tags=string,ruby |>\nIf you really want to\
    \ avoid regular expressions, you can also use String#count:\n<code>\nstring =\
    \ \"122344345\"\nodd_count = string.count(/1[345]/)\neven_count = string.count(/2[1-3]/)\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\nTry this \n<code>", "  num > 0 && num < 0\
    \ ? [even_odd_count(-num), odd_count(num)] : [1, 0]\nend\np even_odd_count(-5)\n\
    p even_odd_count(5)\np even_odd_count(7)", "  even_count = 0\n  odd_count = 0\n\
    \  while num != 0\n    odd_count, even_count = even_count, odd_count + (num %\
    \ 2 == 0 ? 1 : 0)\n    num = num / 10\n  end\n  return [even_count, odd_count]\n\
    end", "  even_count = 0\n  odd_count = 0\n  while num != 0\n    if num % 2 ==\
    \ 0\n      even_count += 1\n    else\n      odd_count += 1\n    num /= 10\n  end\n\
    \  return [even_count, odd_count]\nend", "  evens = 0\n  odds = 0\n  if num >\
    \ 0\n    evens += num % 2 == 0\n    num / 2\n    odds += num % 2 == 0\n    num\
    \ / 2\n  end\n  return [evens, odds]\nend\n</code>\nThe above algorithm is O(n).\
    \ You can achieve O(n) time by using a hash table. In other words, you have a\
    \ O(n) lookup time for each digit. \nThe above code could be converted into something\
    \ like this:\n<code>", "\tnum_str = num.to_s.to_s\n\t(even_count, odd_count) =\
    \ ((num_str.length / 2).ceil, ((num_str.length / 2).floor + 1).ceil)\n\t(even_count_str,\
    \ odd_count_str) = (num_str[0..even_count], num_str[odd_count..(num_str.length\
    \ - 1)])\n\treturn (even_count_str.to_i, odd_count_str.to_i)\nend", "  even =\
    \ 0\n  odd = 0\n  \n  if num > 0\n    num.to_s.split(\"\").each do |n|\n     \
    \ unless n.to_i.even?\n        even += 1\n      else\n        odd += 1\n     \
    \ end\n    end\n  end", "  (even_count, odd_count) = 0, 0\n  while num > 0\n \
    \   odd_count += 1\n    if num % 2 == 0\n      even_count += 1\n    num /= 10\n\
    \  end\n  (even_count, odd_count)\nend", "  return [num.to_s.chars.count {|v|\
    \ v =~ /^[13579]$/ }, num.to_s.chars.count {|v| v =~ /^[13579]$/}]\nend", "  result\
    \ = []\n  while num > 0\n    result.push num % 10\n    num /= 10\n  end\n  if\
    \ result.length < 2\n    result.push 0\n  end\n  return result\nend", "  even\
    \ = num.to_s.scan(/..+/).count{|n| n % 2 == 0}\n  odd = num.to_s.scan(/..+/).count{|n|\
    \ n % 2 != 0}\n  [even, odd]\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n\
    <| a dscore=0 |>\nOne other way is to just convert to strings and use partition.\n\
    <code>\nnumbers = -100..100", "  if num < 0\n    return (0, 0) # a negative number\
    \ is even\n  end\n  if num > 0\n    return even_odd_count(num / 10) + (num % 10\
    \ % 2 == 0 ? 1 : 0, 0)\n  end\n  return (0, 0)\nend", "  if num < 0\n    raise\
    \ ArgumentError, 'Negative numbers cannot be odd.'\n  else\n    num.to_s.chars.each_with_object([0,\
    \ 0]) do |digit, sum|\n      sum[sum[1] % 2] ||= 0\n      sum[sum[1] % 2] += digit.to_i\n\
    \    end\n  end\nend", "  (even_odd = num.to_s.scan(/(0*[1-9]\\d*)|(1*[02468])/).flatten.uniq.length)\n\
    \  return even_odd\nend\n</cell>\n<code language=julia-1.3>\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time even_odd_count(123)\n@time even_odd_count(123)\n@time even_odd_count(123)\n\
    @time ev", "  digits = num.to_s.split(\"\")\n  even = digits[0...].select {|x|\
    \ x % 2 == 0}\n  odd = digits[0...].select {|x| x % 2 != 0}\n  even.size + odd.size\n\
    end", "  even_count = num.even? ? 1 : 0\n  odd_count = num.odd? ? 1 : 0\n  return\
    \ [even_count, odd_count]\nend", "  even = num.to_s.scan(/../ ).select { |i| i.to_i\
    \ % 2 == 0 }.size\n  odd = num.to_s.scan(/../ ).select { |i| i.to_i % 2 != 0 }.size\n\
    \  [even, odd]\nend", "  evens, odds = 0, 0\n  \n  until num == 0\n    num, digit\
    \ = num.divmod(10)\n    evens += digit.is_even?\n    odds += digit.is_odd?\n \
    \ end\n  \n  return [evens, odds]\nend\n</cell>\n<code language=conda-env-cta-py>\n\
    @test assert_eq!(even_odd_count(-3), ([1, 1], [0, 2]))\n@test assert_eq!(even_odd_count(0),\
    \ ([1, 0], [0, 0]))\n@test assert_eq!(even_odd_count(1), ([0, 0], [0, 0]))\n@test\
    \ assert_eq!(even_odd_count(2), ([0, 1], [1, 1]))\n@test assert_eq!(even_odd_count(3),\
    \ ([0, 2], [2, 2]))\n@test assert_eq!(even_odd_count(123), ([1, 2], [1, 2]))\n\
    @test assert_eq!(even_odd_count(12345), ([3, 3], [3, 3]))\n</cell>\n<code language=conda-env-cta-py>",
  "    even = 0\n    odd = 0\n    while num > 0\n        even = even + 1\n       \
    \ num = num / 10\n    \n    return even, odd\n    ", "  even, odd = 0, 0\n  while\
    \ num != 0\n    num, digit = num / 10, num % 10\n    even += digit if digit %\
    \ 2 == 0 \n    odd += digit if digit % 2 != 0\n  \n  return [even, odd]\nend",
  "  digits = num.to_s.split('')\n  even = 0\n  odd = 0\n  digits.each do |d|\n  \
    \  even_odd_count = [even_odd_count.last + 1 if d[-1] == '1'].last \n    odd +=\
    \ 1 if d[-1] == '0'\n    even += 1 if d[-1] == '1'\n  end\n  \n  even_odd = [even_odd_count.last,\
    \ even]\n  [odd, even_odd_count.last]\nend", "  even = 0 \n  odd = 0 \n  \n  #\
    \ Add all even numbers\n  while num > 0 do\n    even = even + num % 10\n    num\
    \ = num / 10\n  end", "  result = []\n  count = 0\n  while num > 0\n    digit\
    \ = num % 10\n    if digit == 0\n      result.push(count)\n      count = 1\n \
    \   else\n      count += 1\n      num = num / 10\n  end\n  return result\nend\n\
    </code>\nThe above solution is simple and straight forward, but the complexity\
    \ is O(N).\nWe can reduce that to O(1) using some mathematical tricks. Let f(x)\
    \ be a function which returns true when x is a perfect square. Let g(x) be a function\
    \ which returns true when x is a perfect square and not an integer. Then:\n<code>",
  "  even_count = 0\n  odd_count = 0\n  \n  while num != 0\n    digit = num % 10\n\
    \    num = num / 10\n    if digit % 2 == 0\n      even_count += 1\n    else\n\
    \      odd_count += 1\n    end\n  end\n  return [even_count, odd_count]\nend",
  "    \n    if num < 0 \n    then return nil\n    elsif num == 0\n    then return\
    \ (1, 0)\n    elsif num > 0\n    then even = 0, odd = 0\n    num.to_s.reverse.chars.each\
    \ do |char|\n        if char == '0'\n        then even += 1\n        elsif char\
    \ == '1'\n        then odd += 1\n        end\n    end\n    return even, odd\n\
    \    end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a |>\n<code>", "  if num\
    \ < 0\n    return num, 1\n  even = 0\n  odd = 0\n  while num >= 0\n    odd = (num\
    \ % 10) + odd\n    num = num / 10\n  while even < odd\n    even = (even % 10)\
    \ + even\n  return even, odd\nend", "  result = even_odd_count_helper(num)\n \
    \ return result[1], result[0]\nend", "  even = 0\n  odd = 0\n  \n  while num >\
    \ 0\n    digit = num % 10\n    if digit == 0 # number is even\n      even = even+1\n\
    \    else # number is odd\n      odd = odd+1\n    num = num / 10\n  \n  return\
    \ [even, odd]\nend", "  n1, n2 = num.divmod(10)\n  if n1 % 2 == 0\n    even_count\
    \ = n1 % 2\n    odd_count = 0\n  else\n    even_count = 0\n    odd_count = (n1\
    \ - n2 % 2).divmod(10)\n  end", "  # num is negative\n  return [num % 10, num\
    \ % 10 % 2]\nend", "  n = num.to_s.length\n  even = 0\n  odd = 0\n  while n >\
    \ 0\n    digit = num % 10\n    num = num.to_i\n    digit = digit - 1 if digit\
    \ > 0\n    odd += digit if digit % 2 == 1\n    even += digit if digit % 2 == 0\n\
    \    n -= 1\n  return [even, odd]\nend", "  digits = num.to_s.chars\n  even_digits\
    \ = digits.select { |n| n.to_i.zero? }\n  odd_digits = digits.select { |n| n.to_i.zero?\
    \ || n.to_i.odd? }\n  even_odd_count = even_digits.count { |n| n.to_i.even? }\
    \ + odd_digits.count { |n| n.to_i.odd? }\n  return even_odd_count, even_digits.count\
    \ { |n| n.to_i.even? }\nend", "  odd_count = 0\n  even_count = 0\n  num = (num.to_s.split(\"\
    \")).map{ |i| i.to_i}\n  while num.length > 0\n  \todd_num = num.pop.to_i\n  \t\
    even_num = num.pop.to_i\n  \tif odd_num % 2 == 0\n  \t\teven_count += 1;\n  \t\
    else\n  \t\todd_count += 1;\n  \tend\n  end\n  return [even_count, odd_count]\n\
    end", "  result = []\n  n = 0\n  while num > 0\n    n, digit = num % 10, num /\
    \ 10\n    result.push (digit)\n    if n\n      num, digit = num / 10, 0\n    \
    \  result.push (digit)\n    end\n  end\n  return result\nend", "    even = 0\n\
    \    odd = 0\n    while(num>0)\n        if num%2 == 0\n            even+=1\n \
    \           num = num/2\n        else\n            odd+=1\n            num = num/2\n\
    \    return (even, odd)\nend", "  even = num.to_s.scan(/^0+$|^0+\\z/).map { |x|\
    \ x[0].to_i }\n  odd = num.to_s.scan(/^0+\\z/).map { |x| x[0].to_i }\n  (even.count\
    \ { |x| x == 0 }, odd.count { |x| x == 0 })\nend\n</cell>\n<cell>", "  even =\
    \ 0\n  odd = 1\n  digit = num % 10\n  while digit > 0\n    if digit % 2 == 0\n\
    \      even = even + 1\n    else \n      odd = odd + 0\n    digit = digit / 10\n\
    \  return even, odd\nend", "  even=0\n  odd=0\n  num_int=num.to_i\n  while num_int\
    \ > 0\n    if num_int % 2 == 0\n      even+=1\n    else\n      odd+=1\n    end\n\
    \    num_int=num_int/2\n  end\n  return [even,odd]\nend\n</cell>\n<code language=julia-0.4>",
  "  even = 0\n  odd = 0\n  digit = num.to_s\n  while digit != ''\n    if digit.to_i\
    \ % 2 == 0\n      even = even + 1\n    end\n    if digit.to_i % 2 == 1\n     \
    \ odd = odd + 1 \n    end\n    digit = digit.drop(1).to_s\n  end\n  return even,\
    \ odd\nend", "  count = 0\n  while num > 0\n    num, mod = num.divmod(10)\n  \
    \  count += 1\n  \n  return count, count\nend\n</cell>\n<code language=julia-1.5>",
  "  count = 0\n  while num > 0\n    num, tmp = divmod(num, 10)\n    count += 1 if\
    \ tmp % 2 == 0 else 0\n  end\n  return [count, count + 1 if num > 0 else 0]\n\
    end", "  digits = num.to_s.split(//)\n  evens = digits[0..-2]\n  odds = digits[-2..-1]\n\
    \  \n  # return evens, odds\n  return [evens.count,odds.count]\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails |>\nWe can achieve\
    \ this using the modulo operator\n<code>", "  if num > 0\n    return even_odd_count(num\
    \ / 2), 1 + even_odd_count(num % 2)\n  else\n    return 1, 0\n  end\nend", " \
    \ result = even_odd_count_helper(num)\n  result[0].to_s.length, result[1].to_s.length\n\
    end", "  even_odd_digits = 0\n  odd_digits = 0", "  even = 0\n  odd = 1", "  return\
    \ num.to_s.length, num.to_s.length - num.to_s.reverse.length\nend", "  even =\
    \ 0 \n  odd = 0 \n  while num > 0 \n  then \n    odd = odd + (num % 10)\n    num\
    \ = num / 10\n  then \n    even = even + (num % 10)\n    num = num / 10\n  end\n\
    \  return even, odd\nend", "  return if num < 0\n  even_count = 1 if num % 2 ==\
    \ 0 \n  odd_count = 1 if num % 2 != 0\n  even_odd_count = even_count if even_count\
    \ > odd_count else odd_count\n  even_odd_count = even_odd_count + 1 if even_odd_count\
    \ > 9 \n  puts(even_odd_count.to_s) \nend", "  evens, odds = 0, 0\n  loop do\n\
    \    evens += 1 if num % 2 == 0\n    odds += 1 if num % 2 != 0\n    break if evens\
    \ == odds\n    num /= 2\n  end\n  return [evens, odds]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
