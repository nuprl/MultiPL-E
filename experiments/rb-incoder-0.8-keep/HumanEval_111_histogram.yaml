name: HumanEval_111_histogram
language: rb
prompt: "# Given a string representing a space separated lowercase letters, return\
  \ a dictionary\n# of the letter with the most repetition and containing the corresponding\
  \ count.\n# If several letters have the same occurrence, return all of them.\n#\
  \ Example:\n# histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n# histogram('a b b\
  \ a') == {'a': 2, 'b': 2}\n# histogram('a b c a b') == {'a': 2, 'b': 2}\n# histogram('b\
  \ b b b a') == {'b': 4}\n# histogram('') == {}\ndef histogram(test)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_histogram\n\
  \    candidate = method(:histogram)\n    assert_equal({\"a\" => 2, \"b\" => 2},\
  \ candidate.call(\"a b b a\"))\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"\
  a b c a b\"))\n    assert_equal({\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1,\
  \ \"g\" => 1}, candidate.call(\"a b c d g\"))\n    assert_equal({\"r\" => 1, \"\
  t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({\"b\" => 4},\
  \ candidate.call(\"b b b b a\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\"\
  \ => 1}, candidate.call(\"r t g\"))\n    assert_equal({}, candidate.call(\"\"))\n\
  \    assert_equal({\"a\" => 1}, candidate.call(\"a\"))\n  end\nend\n"
completions: ["  letters = test.split()\n  hash = {}\n  letters.each do |letter|\n\
    \    if hash[letter] == nil\n      hash[letter] = 0\n    end\n    hash[letter]\
    \ += 1\n  end\n  return hash\nend", "    test.split(' ').group_by{|i| i}.map{|k,\
    \ v| [k,v.size]}.max_by{|k, v| v}\nend", "  hash = {}\n  test.each do |letter|\n\
    \    if hash[letter] == nil\n      hash[letter] = 1\n    else\n      hash[letter]\
    \ += 1\n    end\n  end\n  return hash\nend", "  test.downcase!\n  test.split('\
    \ ').inject(Hash.new(0)){|h, v| h[v] += 1;h}\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This was a great answer, but I'm still a novice, so I'm wondering if you could\
    \ explain it to me in detail and possibly with code. I will mark it as correct\
    \ once I get it fully explained.\n<|/ c |>\n<| c |>\nIt was very simple. I've\
    \ added some explanation to the answer.\n<|/ c |>\n<| c |>\nThanks for the explanation,\
    \ it really helps. I up-voted you, but I'm not a big fan of people down-voting\
    \ questions if they don't actually explain what they don't like.\n<|/ c |>\n<|\
    \ a dscore=3 tags=ruby,string |>\nThis should do the job:\n<code>\nstr.split(\"\
    \ \").inject(Hash.new(0)) { |h, s| h[s] += 1 }.max_by { |k, v| v}\n</code>\nOr\
    \ you can go for \"old school\" solution (which is somewhat easier to read):\n\
    <code>\nstr\n.split(\" \") # split on space\n.inject(Hash.new(0)) { |h, s| h[s]\
    \ += 1 } # count each letter\n.max_by { |k, v| v } # select letter with highest\
    \ count\n</code>\nOr even more \"old school\":\n<code>\nstr\n.scan(/./) # scan\
    \ for letters and convert to array of letters\n.inject(Hash.new(0)) { |h, s| h[s]\
    \ += 1; h } # count each letter\n.max_by { |k, v| v } # select letter with highest\
    \ count\n</code>\n<|/ a |>\n<| c |>\nAm I missing something? Why would you use\
    \ the Hash.new in the first example? You only need to use the hash when you aren't\
    \ sure if the key already exists. If a key exists it will be replaced with it's\
    \ current value, and the new value will be set to 0. So in the first example you\
    \ don't even need to initialize a hash like you did with the second example\n\
    <|/ c |>\n<| c |>\nAlso, why use inject, when max_by would do the same thing?\n\
    <|/ c |>\n<| c |>\nHash.new is used when we want to initialize a hash which is\
    \ going to be mutated with each iteration. As for max_by, we only need to store\
    \ the result because we already know which letter has the highest count, so there\
    \ is no need to do any extra processing.\n<|/ c |>\n<| a |>\nHere is a ", "  \
    \  hash=Hash.new(0)\n    for letter in test.downcase.split(\" \")\n        if\
    \ letter!=\"\"\n            hash[letter] +=1\n        end\n    end\n    hash\n\
    end", "    letters = {}\n    test.split(\" \").each do |letter|\n        letters[letter]\
    \ = letters[letter].to_i + 1\n    end\n    letters.select {|k,v| v == letters.max_by\
    \ {|x,y| y}}\nend", "  result = {}\n  letters = test.split(' ')\n  letters.each_index\
    \ do |i|\n    result[letters[i]] = letters.count(letters[i])\n  end\n  return\
    \ result\nend", "  results = {}\n  test.split.map do |letter|\n    count = results[letter]\
    \ ? results[letter].to_i : 1\n    results[letter] = count\n  end\n  \n  results\n\
    end", "    letters = {}\n    chars = test.split(' ')\n    chars.each do |char|\n\
    \        letters[char] = letters[char].to_i + 1\n    end\n    letters.values.max\n\
    end", "  if test == '' else test == ' ' else test.split\n  result = {}\n  test.split('\
    \ ').group_by{|letter| letter}.map{|letter,values| [letter, values.count]}.reduce(Hash.new(0)){|hash,\
    \ item| hash[item[0]] += item[1]; hash}\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=ruby,string |>\nA non-regex solution that may help you with the problem:\n\
    <code>", "    letters = test.split ' '.freeze\n    histogram = {}\n    letters.each\
    \ do |letter|\n        histogram[letter] = histogram.fetch(letter, 0) + 1 \n \
    \   end\n    histogram.sort!.reverse\n    return histogram\nend", "\tletters =\
    \ {}\n\ttest.split(' ').each do |letter|\n\t\tif letters[letter] == nil\n\t\t\t\
    letters[letter] = 1\n\t\telse\n\t\t\tletters[letter] += 1\n\t\tend\n\tend\n\t\n\
    \tletters.sort!\n\tletters.reverse_order\n\tletters = letters.select { |key, value|\
    \ value > 1 }\n\treturn letters\nend", "  counts = {}\n  test.split.each_with_index\
    \ do |letter, i|\n    counts[letter] = counts[letter] || 0\n    counts[letter]\
    \ += 1\n  end\n  counts\nend", "  result = Hash.new(0)\n  test.split(//).inject(result)\
    \ do |result, letter|\n    result[letter] += 1\n    result\n  end\nend", "  str=test.split\n\
    \  count = {}\n  str.each do |i|\n    i = i.downcase\n    count[i] = count.fetch(i,\
    \ 0) + 1\n  end\n  result=count.sort{|a, b| a[1] <=> b[1]}.group_by{|k| k}\n \
    \ result=result.map{|k, v| [k, v.size]}.to_h\n  if result.empty?\n    return {}\n\
    \  end\n  if result.size > 1\n    result.each do |k, v|\n      v.sort{|a, b| a[1]\
    \ <=> b[1]}.first\n    end\n  end\n  result\nend", "    dict = {}\n    test.split.each\
    \ do |i|\n        count = i.count\n        if dict[count].nil?\n            dict[count]\
    \ = 1\n        else\n            dict[count] += 1\n        end\n    end\n    dict.sort_by\
    \ {|k, v| v}.last.each{|k, v| dict.delete_at(k)}\n    return dict\nend\n</code>\n\
    <|/ a tags=sorting,ruby,algorithm |>\n<| c |>\nThis is a great solution that doesn't\
    \ make unnecessary array copies, though it should be noted that if you have a\
    \ large string and are counting characters, you may want to look into making this\
    \ algorithm run a little faster by implementing your own hash table instead of\
    \ a hash. That will give you some optimization with regard to memory usage.\n\
    <|/ c |>\n<| c |>\nThis solution works for me. It takes 51 seconds to run it on\
    \ an input string of 1M characters and produces the same output. I am surprised\
    \ at how fast ruby is compared to other solutions.\n<|/ c |>\n<| a tags=sorting,ruby,algorithm\
    \ |>\n<code>", "  dict = {}\n  test.split(' ').each do |letter|\n    dict[letter]\
    \ = test.split(' ').count(letter)\n  end\n  return dict\nend", "  letters = test.split(\"\
    \ \").map{|char| char.downcase}\n  histogram = {}\n  letters.each do |letter|\n\
    \    histogram[letter] = letters.count(letter)\n  end\n  histogram.select! do\
    \ |letter, count|\n    count > letters.count(letter)\n  end\n  histogram\nend",
  "  letters = test.split(' ')\n  hash = {}\n  letters.each {|letter| hash[letter]\
    \ = hash[letter].to_i + 1}\n  hash.values.max_by{|value| value}\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis is not correct, see the last example.  'a b b b a' should\
    \ only return 2 b keys, but your code returns 4.\n<|/ c |>\n<| c |>\nThanks for\
    \ the comment. Yes, I agree, I missed the case when there is a letter appears\
    \ multiple times and I did not take it into account. I fixed the solution and\
    \ I also added another example to the answer. Thank you for the pointing out.\n\
    <|/ c |>\n<| c |>\nThanks for the solution. Just wondering, how would you modify\
    \ it to accept a list rather than a string? e.g. histogram(['a', 'b', 'c'])\n\
    <|/ c |>\n<| c |>\nYou could replace the line `letters.each {|letter| hash[letter]\
    \ = hash[letter].to_i + 1}` by `letters.map {|letter| [letter, hash[letter].to_i\
    \ + 1]}.sort{|a, b| b[1] <=> a[1]}.max_by{|a| a[1]}`. Or, with better readability,\
    \ `letters.inject({}){|hsh, letter| hsh[letter] = hsh[letter].to_i + 1; hsh}.max_by{|k,\
    \ v| v}.map(&:first)`\n<|/ c |>\n<| a tags=ruby,hash |>\nIf you're set on using\
    \ map (or collect) then you can do:\n<code>", "    test = test.split(' ')\n  \
    \  test.each { |word|\n        word.downcase!\n        letter = word.chars.uniq\n\
    \        letter = letter.reduce(:merge).map { |k, v| [k, v] }\n        letter\
    \ = letter.to_h\n        letter[word] = letter[word] + 1 if word.present?\n  \
    \  }\n    letter\nend\n</code>\n<|/ a tags=ruby,count,ruby-on-rails,arrays,enumerable\
    \ |>\n<| a |>\n<code>", "  hash = {}\n  test.split(//).sort.each{|x| hash[x] =\
    \ hash[x] || 1}\n  hash\nend", "    hash = {}\n    test.scan(/[a-z]/) do |letter|\
    \ hash[letter] = hash[letter] ? hash[letter] + 1 : 1 end\n    hash\nend\n</code>\n\
    <|/ a tags=ruby,string,regex,arrays |>\n<| c |>\nThanks so much for taking the\
    \ time to write this up. I'll keep this in mind for future reference!\n<|/ c |>\n\
    <| c |>\nThanks for your contribution, it's really helpful and it works well.\
    \ The only thing is that it also prints the non-unique letters. I wanted to print\
    \ only letters with max occurrences. I tried to change it to `test.scan(/[a-z]/).uniq.sort`\
    \ but it didn't work. Can you help me figure out why and how to fix this?\n<|/\
    \ c |>\n<| a |>\n<code>", "  if test.nil?\n    {}\n  else\n    test.split().group_by{|x|\
    \ x}.map{|k, v| [k, v.size]}.sort_by{|k, v| v}.last\n  end\nend", "    # your\
    \ code here\n    test = test.split(' ')\n    letters = [0]*26\n    for s in test:\n\
    \        letters[ord(s.lower()) - ord('a')] += 1", "  count = {}\n  test_array\
    \ = test.split(' ')\n  test_array.each do |value|\n    count[value] = count[value]\
    \ || 0\n    count[value] += 1\n  end\n  return count\nend", "  result = Hash.new(0)\n\
    \  test.split(\" \").each_with_index do |letter, index|\n    result[letter] =\
    \ result[letter].to_i + 1 if result.has_key?(letter)\n  end\n  result = result.sort_by\
    \ {|k, v| -v}.to_h\n  if result.empty?\n    result.merge({\"\"=>0})\n  else\n\
    \    result\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=ruby,arrays,hash,string\
    \ |>\n<code>", "  hash = {}\n  test.split(\" \").each do |word|\n    hash[word]\
    \ ||= 0\n    hash[word] += 1\n  end\n  return hash\nend", "  dict = {}\n  test.split.each{|c|\
    \ dict[c] ||= 0; dict[c] += 1 }\n  dict.sort_by{|k, v| v}.reverse.first\nend",
  "    hash = {}\n    test.split.each do |word|\n        word.split.each do |letter|\n\
    \            if hash[letter].nil?\n                hash[letter] = word.split(letter).size\n\
    \            else\n                hash[letter] += word.split(letter).size\n \
    \           end\n        end\n    end\n    return hash\nend", "  result = Hash.new(0)\n\
    \  test.split(' ').each do |letter|\n    result[letter] = result[letter] + 1 if\
    \ result.has_key?(letter)\n  end\n  result\nend", "    test\n    test\n    test\n\
    \    test\n    test\n    test\nend\n</code>\nI am looking forward to hearing your\
    \ thoughts!\n<|/ q dscore=0 |>\n<| c |>\nDo you have any code? If so, please share\
    \ it with us so we can help you improve it.\n<|/ c |>\n<| c |>\nI do have some\
    \ code but it's quite involved and I wanted to see if I could get the idea across.\
    \ I've posted the first 4 lines, though.\n<|/ c |>\n<| a tags=ruby |>\nHere's\
    \ a solution that's fairly simple. As you mentioned that you're new to programming,\
    \ I went for the easy route, but hopefully this explanation will help you make\
    \ sense of it.\nA method will help you count the letters in your string.\n<code>",
  "  result = {}\n  test.split().each do |letter|\n    result[letter] = test.split(letter).length\
    \ if test.split(letter).length > 0\n  end\n  result\nend", "  count = {}\n  letters\
    \ = test.split\n  letters.each do |letter|\n    if count.has_key?(letter)\n  \
    \    count[letter] += 1\n    else\n      count[letter] = 1\n    end\n  end\n \
    \ return count\nend", "  hash = {}\n  test.split.each do |i|\n    hash[i[0]] =\
    \ hash[i[0]].to_i + (1 if i.size > 1)\n  end\n  hash.values.sort_by {|v| -v}\n\
    end", "  results = {}\n  test.split.each do |element|\n    if results.has_key?(element)\n\
    \      results[element] += 1\n    else\n      results[element] = 1\n    end\n\
    \  end\n  results\nend", "  return Hash.new(0).merge(test.downcase.scan(/[a-z]/).group_by(&:first).map{|k,\
    \ v| [k, v.length]}.max_by{|k, v| v})\nend", "\thisto = {}\n\tstring.split(test).sort.each_with_index\
    \ do |letter,i|\n\t\thisto[letter] ||= 0\n\t\thisto[letter] += 1\n\tend\n\thisto\n\
    end", "\tcounts = Hash.new(0)\n\ttest.chars.each do |letter|\n\t\tcounts[letter]\
    \ += 1 if counts[letter] <= 0\n\tend\n\treturn counts\nend", "  if test.length.zero?\
    \ then\n    return {}\n  end\n  letters = test.split.map{|letter| letter}\n  letters.uniq.sort!\n\
    \  result = {}\n  letters.each do |letter|\n    result[letter] = letters.count(letter)\n\
    \  end\n  return result\nend", "  test\n    .split(\" \")\n    .map { |letter|\
    \ [letter, test.count(letter)] }\n    .group_by { |letter, count| letter }\n \
    \   .map { |letter, count| [letter, count.max] }\n    .reduce(:merge)\nend\n</code>\n\
    The above is my first attempt at solving this problem using a hash to store and\
    \ retrieve the values using a key and a value at the same time, however, I realized\
    \ that there are many ways to solve the problem (Hash, Enumerable, Map, Reduce,\
    \ and more).\nMy first attempt was to use the Enumerable module's group_by method\
    \ to group together all the letters encountered in the string. I then used the\
    \ group_by method to group together the counts of each letter (The Hash module's\
    \ group_by method takes an argument which is a block of code to be applied to\
    \ a set of values. The block takes 2 arguments: the current value and the current\
    \ index.\n<code>\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n</code>\nThe\
    \ first argument to the block is each letter and the second argument is the current\
    \ index of the element being processed. The block returns a new value to be stored\
    \ in the Hash.\n<code>\nhistogram('a b b a') == {'a': 2, 'b': 2}\n</code>\nThe\
    \ first argument to the block is each letter and the second argument is the current\
    \ index of the element being processed. The block returns a new value to be stored\
    \ in the Hash.\n<code>\nhistogram('a b c a b') == {'a': 2, 'b': 2}\n</code>\n\
    The first argument to the block is each letter and the second argument is the\
    \ current index of the element being processed. The block returns a new value\
    \ to be stored in the Hash.\n<code>\nhistogram('b b b b a') == {'b': 4}\n</code>\n\
    The first argument to the block is each letter and the second argument is the\
    \ current index of the element being processed. The block returns a new value\
    \ to be stored in the Hash.\n<code>\nhistogram('') == {}\n</code>\nI only have\
    \ to deal with the first argument and can ignore the second. The second argument\
    \ is the current index of the element being processed.\n<code>\nhistogram('')\
    \ == {}\n</code>\nThe first argument to the block is each letter and the second\
    \ argument is the current index of the element being processed. The block returns\
    \ a new value to be stored in the Hash.\n<code>\nhistogram('') == {}\n</code>\n\
    <|/ a |>\n<| c |>\nWhat are you using here `histogram('') == {}`?\n<|/ c |>\n\
    <| c |>\nThat is just a test to see if an empty string was passed. The method\
    \ would behave differently depending on how an empty string is passed in.\n<|/\
    \ c |>\n<| a |>\nHere's a solution that just uses map and reduce:\n<code>\n",
  "  letters = {}\n  test.split(' ').each do |word|\n    word.split(//).each do |letter|\n\
    \      letters[letter] = (letters[letter] || 0) + 1\n    end\n  end\n  letters\
    \ = letters.sort_by {|k, v| -v}.first(10)\n  letters.inject({}) { |h, k| h[k]\
    \ = letters.count(k); h }\nend\n</code>\n<|/ a |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nI created this solution that does what you are looking for:\n<code>", " \
    \   letters = {}\n    test = ''.join(test.split()).upper()\n    for letter in\
    \ test\n        if letter.nil?\n            letters[letter] = 0\n        else\n\
    \            letters[letter] += 1\n        end\n    end\n    return letters\n\
    end", "    test.split.each do |letter|\n        hash[letter] = hash[letter].nil?\
    \ ? 1 : hash[letter].to_i + 1\n    end", "    testLetters = test.split(' ')\n\
    \    \n    letters = {}\n    letterCounts = {}\n    for letter in testLetters\n\
    \        if letter in letters\n            letters[letter] += 1\n            letterCounts[letter]\
    \ += 1\n        else\n            letters[letter] = 1\n            letterCounts[letter]\
    \ = 1\n            \n    letters = letters.select{ |k,v| v > 1 }\n    \n    return\
    \ letters\nend\n</cell>\n<cell>\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n\
    histogram('a b b a') == {'a': 2, 'b': 2}\nhistogram('a b c a b') == {'a': 2, 'b':\
    \ 2}\nhistogram('b b b b a') == {'b': 4}\nhistogram('') == {}\n</cell>\n<cell>\n\
    histogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') ==\
    \ {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('')\
    \ == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram('') == {}\nhistogram",
  "  result = {}\n  test.split(' ').each do |letter|\n    if result[letter] == nil\n\
    \      result[letter] = 1\n    else\n      result[letter] += 1\n    end\n  end\n\
    \  result\nend", "  test_list = test.split(' ')\n  histogram = {}\n  test_list.each\
    \ do |letter|\n    if histogram.has_key?(letter)\n      histogram[letter] += 1\n\
    \    else\n      histogram[letter] = 1\n    end\n  end\n  return histogram\nend",
  "  occurrence = {}\n  test_list = test.split(' ')\n  test_list.each_with_index {\
    \ |letter, i|\n    if occurrence[letter] == nil\n      occurrence[letter] = 0\n\
    \    end\n    occurrence[letter] += 1\n  }\n  return occurrence\nend", "  occurrences\
    \ = Hash.new(0)\n  test.downcase.split().each { |letter| occurrences[letter] +=\
    \ 1 }\n  occurrences.max_by { |k, v| v }\nend", "  letters = test.split\n  histo\
    \ = Hash.new(0)\n  letters.each do |letter|\n    histo[letter] +=1\n  end\n  return\
    \ histo\nend", "  result = {}\n  test.split(\" \").each do |letter|\n    result[letter]\
    \ = result[:letter] || 0\n    result[letter] += 1 if result[:letter]\n  end\n\
    \  result\nend\n</cell>\n<cell>\nhistogram('a b c')\n</cell>\n<cell>\nhistogram('a\
    \ b b a')\n</cell>\n<cell>\nhistogram('a b c a b')\n</cell>\n<cell>\nhistogram('b\
    \ b b b a')\n</cell>\n<cell>\nhistogram('a a a')\n</cell>\n<cell>\nhistogram('')\n\
    </cell>\n<cell>\nhistogram('a a a a a a a a a')\n</cell>\n<cell>\nhistogram('a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\
    \ a a a a a a a a a a a a ", "  hash = {}\n  test.split(' ').each do |letter|\n\
    \    hash[letter] = (hash[letter] || 0) + 1\n  end\n  hash.max_by {|k, v| v}\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is very inefficient: `test.split('\
    \ ').count` scans the string many times.  Better to just use `Hash#max_by`.\n\
    <|/ c |>\n<| c |>\n, thanks for the suggestion. I added a benchmark to my answer.\n\
    <|/ c |>\n<| a dscore=1 tags=ruby,ruby-on-rails,arrays |>\n<code>", "\tdict =\
    \ {}\n\ttest.split.each{ |letter| dict[letter] ||= 0 }\n\ttest.split.each{ |letter|\
    \ dict[letter] += 1}\n\ttest.split.each{ |letter| dict[letter] > 1 ? (dict[letter]\
    \ -= 1) : dict[letter] = 1 }\n\treturn dict\nend", "  h = Hash.new(0)\n  test.split(\"\
    \ \").each do |letter|\n    h.update(letter) do |_,count| count+1 end\n  end\n\
    \  h.max_by {|k,v| v}\nend", "    count = Hash.new(0)\n    test.chars.each do\
    \ |x|\n        if count[x] < 0\n            count[x] = 1\n        else\n     \
    \       count[x] += 1\n        end\n    end\n    \n    if count.empty?\n     \
    \   return {}\n    end\n    \n    count.sort_by {|k, v| v}.last.to_a.map {|x|\
    \ x.first}\nend", "  histo = {}\n  test.split(\" \").each { |l| histo[l] = histo[l].to_i\
    \ + 1 }\n  histo\nend", "  test = ''.join([i.lower() for i in test.split(' ')])\n\
    \  count = {}\n  for i in test.split(' ')\n    count[i.lower()] = count.has_key(i.lower())\
    \ and count[i.lower()] + 1 or 1\n  count.each do |k, v|\n    p \"#{k}: #{v}\"\n\
    \  end\n  return count\nend\n</code>\n<|/ a |>\n<| c |>\nI realize this was your\
    \ first answer here, and that you've been doing this for awhile, but I did notice\
    \ a couple of issues here.  You shouldn't be using global variables, but using\
    \ class variables instead.  You also shouldn't be using `test` as a variable name\
    \ - `test` is a built-in function in Ruby that represents the current test being\
    \ ran.\n<|/ c |>\n<| c |>\n, thanks for your comment, especially for point number\
    \ 1. I've updated my answer accordingly. About point number 2: you're right, `test`\
    \ as a variable name is not good - I've just tried to keep it close to the OP's\
    \ original code. Thanks for the hint about `count` class variable.\n<|/ c |>\n\
    <| c |>\n, thanks for the tip about `count` class variable - I've updated my answer\
    \ accordingly.\n<|/ c |>\n<| c |>\nIt should also be noted that `each_with_object`\
    \ does return an enumerator which can be used with `count`: `letters.each_with_object(count)\
    \ { |letter, count| count += 1 }` - it would be equivalent to `letters.inject(count)\
    \ { |c, letter| count += 1 }`\n<|/ c |>\n<| a dscore=1 |>\nI know this is an old\
    \ question but this was the first result on Google when I was looking for the\
    \ same thing.  Here's a Ruby one liner that does it:\n<code>\nhash.map { |k, v|\
    \ [k, v.count] }.group_by { |k, (_, v)| k }.map { |k, v| [k, v.size] }.sort_by\
    \ { |k, v| -v }.last\n</code>\nIf you're interested in how this works, here's\
    \ my explanation:\nhash.map { |k, v| [k, v.count] }\nThis simply turns each key\
    \ value pair into a pair with two elements (the key and the value's count).  This\
    \ means that each key will now be a key with two elements (the key and the value's\
    \ count).  Then:\n<code>", "    test.split(\" \").sort.group_by{|s| s.downcase}.reduce(:merge).sort_by\
    \ {|k, v| -v.length}\nend", "  hash = {}\n  test.split(' ').inject(hash) { |h,\
    \ word| h[word] = h.fetch(word, 0) + 1 }\n  hash.max_by { |k,v| v }\nend", " \
    \   histogram = Hash.new(0)\n    test.split.each_char.each do |x|\n        histogram[x]\
    \ += 1 unless histogram.has_key?(x)\n    end\n    histogram.sort!\n    histogram.each\
    \ {|k, v| break if v > 1} #remove duplicates\n    histogram.delete(\"\")\n   \
    \ histogram\nend", "  counts = {}\n  test.split().each {|x| counts[x] = counts[x].to_i\
    \ + 1}\n  counts\nend", "  h = {}\n  test.split.each_with_index do |letter, i|\n\
    \    h.update([letter, 1]) if (h.has_key?(letter))\n  end\n  h\nend", "  hash\
    \ = {}\n  test.split(' ').each do |str|\n    letter = str.downcase\n    hash[letter]\
    \ = hash[letter].to_i + 1 if hash.has_key?(letter)\n  end\n  hash\nend", "  h\
    \ = Hash.new(0)\n  test.split.each do |letter|\n    h[letter] += 1\n  end\n  h.reduce({})\
    \ { |hash, item| hash.merge(item.to_sym => hash[item]) }\nend", "    \n    testSplit\
    \ = test.split(' ') #split test string by space\n    \n    letterDict = {}\n \
    \   \n    letterCount = {}\n    \n    for char in testSplit:\n        \n     \
    \   if char in letterDict:\n            letterDict[char] = letterDict[char] +\
    \ 1\n            \n        if char in letterCount:\n            letterCount[char]\
    \ = letterCount[char] + 1\n            \n        else:\n            letterDict[char]\
    \ = 1\n            letterCount[char] = 1\n    \n    \n    mostRepeated = {}\n\
    \    \n    for key, value in letterCount.items():\n        \n        if letterDict[key]\
    \ > letterDict[value]:\n            \n            mostRepeated[key] = value\n\
    \            \n    return mostRepeated", "  h = {}\n  test.split(\" \").each {\
    \ |l| h.update(l.downcase) }\n  h\nend", "  test.scan(/(.)\\1*/).group_by { |x|\
    \ x.first }.map { |k,v| [k, v.length] }\nend", "  freq = {}\n  test.split(' ').each\
    \ do |letter|\n    freq[letter] = freq[letter].to_i + 1\n  end\n  freq = freq.values.sort_by{|c|\
    \ -c}\n  if freq.size > 1\n    freq\n  else\n    freq[0]\n  end\nend", "  result\
    \ = {}\n  test.split(' ').each do |e|\n    result[e] = test.split(' ').count(e)\
    \ || 1\n  end\n  result\nend", "    test.split(\" \").group_by{|word| word}.max_by{|word,\
    \ count| count}.map{|word| [word, 1]}.to_h\nend\n</code>\n<|/ a |>\n<| a |>\n\
    <code>\na='a b c a b a b a b c a b b a b b b c a b a b a b a b b a b b a b a b\
    \ c a b a b a b a b a b a b b a b b a b a b b a b a b a b a b c a b a b a b a\
    \ b a b a b a b a b a b a b b a b b a b a b a b a b a b b a b a b a b b a b b\
    \ a b a b a b a b b a b a b b a b a b b a b a b a b a b a b a b b a b b a b a\
    \ b a b a b a b b a b a b a b a b a b a b a b a b a b a b a b a b a b b a b a\
    \ b a b b a b a b a b a b a b a b a b b a b b a b b a b b a b a b a b a b b a\
    \ b a b a b b a b a b a b a b a b b a b a b a b a b b a b a b a b b a b a b a\
    \ b a b a b a b a b b a b b a b a b b a b a b a b a b a b a b a b b a b a b a\
    \ b a b a b a b a b a b a b a b b a b a b b a b a b a b a b a b a b b a b a b\
    \ a b a b a b a b a b a b a b a b a b a b a b b a b a b a b a b a b a b a b a\
    \ b a b a b a b a b a b a b a b a b b a b a b a b a b a b a b b a b a b a b a\
    \ b a b a b a b a b a b a b a b a b a b b a b a b a b a b a b b a b a b a b a\
    \ b a b a b b a b a b ", "    chars = {}\n    test.split(\"\").each do |char|\n\
    \        chars[char] ||= 0\n        chars[char] += 1\n    end\n    chars.group_by\
    \ { |k, v| k }.max_by { |k, v| v }\nend", "  strArray = test.split(' ')\n  hash\
    \ = {}\n  strArray.each do |string|\n    string.split('').each do |char|\n   \
    \   hash[char] = hash[char].to_i if hash[char].to_i != 0\n      hash[char] +=\
    \ 1 if string != \"\"\n    end\n  end\n  hash\nend", "  test.split(\"\").sort.inject(Hash.new(0))\
    \ { |hash, letter| hash[letter] += 1 }\nend", "  # Create an empty dictionary\
    \ to store letter counts\n  histo = Hash.new(0)", "  result = {}\n  test.split().each\
    \ do |letter|\n    result[letter] ||= 0\n    result[letter] += 1\n  end\n  result\n\
    end", "  letters = test.split(\" \")\n  letters.map! do |letter|\n    if letters.count(letter)\
    \ > 0\n      letter, letters.count(letter)\n    else\n      letter, 0\n    end\n\
    \  end\n  letters.sort_by! do |letter, count|\n    count\n  end\n  letters.reverse!\n\
    \  letters.map! do |letter, count|\n    letter, count\n  end\n  letters.delete_if!\
    \ { |letter, count| letter == \"\\n\" }\n  letters.delete_if! { |letter, count|\
    \ letter == \"\\t\" }\n  letters.delete_if! { |letter, count| count == 1 }\n \
    \ letters.delete_if! { |letter, count| letter == \" \" }\n  letters.reverse!\n\
    \  return letters.first\nend", "  result = {}\n  test.split(' ').each do |letter|\n\
    \    if result[letter].nil?\n      result[letter] = 1\n    else\n      result[letter]\
    \ += 1 \n    end\n  end\n  return result\nend", "  result = {}\n  test.split.split.each\
    \ do |letter|\n    result[letter] ||= 0\n    result[letter] += 1\n  end\n  result\n\
    end", "  frequency = Hash.new(0)\n  letters = test.split.each_with_index.reduce(Hash.new(0))\
    \ {|h,i| h[i] = h[i] + 1}", "  test = test.split\n  hash = {}\n  test.each do\
    \ |i|\n    if !hash[i]\n      hash[i] = 1\n    else\n      hash[i] += 1\n    end\n\
    \  end\n  hash\nend", "\ttest.gsub!(/\\s/,'')\n\thistogram = {}\n\ttest.split('').each\
    \ do |letter|\n\t\thistogram[letter] = histogram.has_key?(letter) ? histogram[letter]\
    \ + 1 : 1;\n\tend\n\thistogram.merge!('' => '0')\n\thistogram.sort_by{|k,v| -v}.inject({})\
    \ do |hash,pair|\n\t\thash[pair[0]] = pair[1]\n\t\thash\n\tend\n\treturn histogram\n\
    end", "  test.downcase!\n  test.split().each do |letter|\n    letters[letter]\
    \ ||= 0\n    letters[letter] += 1\n  end\n  letters.max_by { |letter, count| -count\
    \ }\nend\n</code>\nAnd to print the letters with the most occurrences\n<code>\n\
    letters.max_by { |letter, count| -count }.each { |letter, count| puts \"#{letter}\
    \ : #{count}\" }\n</code>\n<|/ a |>\n<| c |>\nThe other answer is quite cool,\
    \ but this is the most concise solution I've seen so far.\n<|/ c |>\n<| c |>\n\
    What is letters? What is letters= for?\n<|/ c |>\n<| c |>\n`letters` is an instance\
    \ variable of the class `String` - a dictionary. `letters[letter] ||= 0` is a\
    \ shorthand for `letters[letter] ||= 0`, so if letters doesn't contain the key\
    \ letter, it will be initialized to 0 instead of an undefined value.\n<|/ c |>\n\
    <| a dscore=5 |>\nThe Python way:\n<code>\n>>> from collections import Counter\n\
    >>> s = 'a b b b a'\n>>> Counter(s).most_common(1)\n[('a', 2)]\n</code>\n<|/ a\
    \ tags=string,ruby,count,ruby-on-rails,algorithm |>\n<| c |>\nThis answer only\
    \ works well with Python since Counter doesn't exist in Ruby. Ruby 1.8.7 is still\
    \ the oldest version that has it but 1.9.2 has it as well, for what that's worth\n\
    <|/ c |>\n<| c |>\nCounter is a standard library, and available in Ruby 1.8.7\
    \ - or at least in Ruby 1.9.2\n<|/ c |>\n<| c |>\nCounter does exist in 1.8.7,\
    \ but only in some parts of 1.9.  It exists in 1.8.7 as part of the stdlib (in\
    \ the standard library), but not 1.9.2, at least not in the stdlib. On 1.8.7,\
    \ you need to require 'rubygems'; require 'rubygems'; require 'rubygems/installer';\
    \ Gem::Installer.new(true).install\n<|/ c |>\n<| a dscore=5 tags=string,ruby,count,ruby-on-rails,algorithm\
    \ |>\n<code>\n\"a b b b a\".scan(/\\b(\\w)/).sort.last\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis is nice! I didn't know about `scan` until now...\n<|/ c |>\n", " \
    \ if test == '' else test = ''.split\n  frequency = {}\n  frequency_with_count\
    \ = {}\n  test.each { |letter| frequency[letter] = frequency[letter] + 1 if frequency.has_key?\
    \ letter }\n  test.each { |letter| frequency_with_count[letter] = frequency_with_count[letter]\
    \ + 1 if frequency_with_count.has_key? letter }\n  frequency_with_count.each {\
    \ |letter, count| frequency[letter] = count }\n  frequency_with_count.each { |letter,\
    \ count| frequency_with_count[letter] = count }\n  frequency_with_count.each {\
    \ |letter, count| frequency_with_count[letter] = count.to_i }\n  frequency_with_count.each\
    \ { |letter, count| frequency_with_count[letter] = count.to_i }\n  return frequency_with_count\n\
    end", "  counts = Hash.new(0)\n  test.split.each { |x| counts[x] += 1 }\n  counts.max_by\
    \ { |k,v| v }\nend", "    dictionary = {}\n    if test.length == 0\n        return\
    \ dictionary\n    letters = test.split.map { |char| char }\n    letters.each {\
    \ |letter| dictionary[letter] = 1 }\n    letters.uniq.each do |letter|\n     \
    \   letter_count = letters.count(letter)\n        if letter_count > dictionary[letter]\n\
    \            dictionary[letter] = letter_count\n        end\n    end\n    return\
    \ dictionary\nend", "  letters = test.split(\" \").sort\n  letters.group_by {\
    \ |c| c }.map { |k,v| [k, v.count] }\nend", "  hash.merge!('')\n  test.split('\
    \ ').each do |letter|\n    hash[letter] = hash[letter].to_i if hash[letter].to_i\
    \ > 1\n    hash[letter] += 1\n  end\n  hash\nend", "  hash = {}\n  test.split('\
    \ ').each do |word|\n    hash[word] = hash[word] || 0\n    hash[word] += 1\n \
    \ end\n  hash\nend", "    letters = test.split(' ') \n    counts = {}\n    \n\
    \    # Initialize counts for each letter\n    for letter in letters\n        counts[letter]\
    \ = letters.count(letter)", "  freq = {}\n  test.split(' ').inject(Hash.new(0))\
    \ { |result, letter| result[letter] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |result, letter| freq[letter] = result[letter] if result[letter] > freq[letter]\
    \ }\n  freq\nend", "  result = {}\n  test.scan(/./).each do |x|\n    if result.has_key?(x)\n\
    \      result[x] += 1\n    else\n      result[x] = 1\n    end\n  end\n  result\n\
    end", "  counts = {}\n  test.split.each do |c|\n    counts[c] = counts[c].to_i\
    \ + 1\n  end\n  counts.sort_by {|k, v| v}.reverse.to_h\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI understand that this is a homework question but what is the purpose\
    \ of answering this question when you can't even be bothered to comment on the\
    \ original post?\n<|/ c |>\n<| c |>\nI don't want to be offensive, but I feel\
    \ like this doesn't answer the question at all.\n<|/ c |>\n<| c |>\nThis is an\
    \ exact duplicate of a previous answer. Why are you answering with a duplicate\
    \ answer?\n<|/ c |>\n<| c |>\nThis is an exact duplicate of a previous answer.\
    \ Why are you answering with a duplicate answer?\n<|/ c |>\n<| c |>\nI'm an idiot\
    \ - I answered this question before I saw your answer - sorry. I've deleted my\
    \ answer. Sorry for wasting your time.\n<|/ c |>\n<| a dscore=0 |>\n<code>", " \
    \ h = Hash.new(0)\n  test.split().each{|x| h[x] += 1}\n  h.sort{|a, b| b.to_s\
    \ <=> a.to_s}\nend\n</code>\n<|/ a |>\n<| c |>\nIf you're on Ruby 2.5.0 you should\
    \ probably upgrade to 2.5.1\n<|/ c |>\n<| a tags=hash,ruby |>\nHere's a one-liner\
    \ solution using Array#group_by.\n<code>\n[ \"apple\", \"apple\", \"orange\",\
    \ \"banana\", \"banana\" ].group_by { |s| s }", "  result = {}\n  letters.split(\"\
    \ \").each do |letter|\n    letter = letter[0].downcase\n    result[letter] =\
    \ result[letter].to_i if result[letter].nil?\n    result[letter] = 1 if letter\
    \ == test[0]\n    result[letter] += 1 if test == letter\n  end\n  result = result.to_a.sort_by\
    \ { |k, v| v }.reverse.group_by(&:first).sort_by { |k, v| v }.reverse.map { |k,\
    \ v| [k, v.size] }\n  result\nend", "  hash = {}\n  test.split.each do |letter|\n\
    \    if hash[letter]\n      hash[letter] += 1\n    else\n      hash[letter] =\
    \ 1\n    end\n  end", "  result = Hash.new(0)\n  test.split(' ').each { |word|\
    \ result[word] += 1 }\n  result\nend", "  histo = {}\n  test.split(' ').each do\
    \ |letter|\n    if histo[letter] == nil\n      histo[letter] = 1\n    else\n \
    \     histo[letter] += 1\n    end\n  end\n  return histo\nend", "  result = {}\n\
    \  test = [test.strip.split(\" \")]\n  test.each do |word|\n    result[word] =\
    \ test.count(word)\n  end\n  result\nend\n</code>\nThis implementation has the\
    \ advantage that the result is a hash, which means you can use hashes, sets and\
    \ arrays. If you don't know what type of data you're dealing with, you can always\
    \ use #to_s.\n<|/ a dscore=3 tags=ruby,arrays |>\n<| c |>\nI should probably mention\
    \ that this was a challenge on CodeWars and my solution was a variant on this:\
    \ http://stackoverflow.com/questions/429806/how-do-i-count-the-number-of-occurrences-of-each-item-in-an-array-in-ruby\n\
    <|/ c |>\n<| a dscore=2 |>\nUse Array#inject:\n<code>", "\tletters = {}\n\ttest.split().each\
    \ do |letter|\n\t\tletters[letter] = (letters[letter] ||= 0) + 1 \n\tend\n\tletters\n\
    end", "  # Split the string into a list of characters, sort it, and count\n  #\
    \ the occurence of each character.\n  sorted_list = test.downcase.chars.sort_by(&:to_s).inject(Hash.new(0))\
    \ {|h, (k, v)| h[k] = h[k] + 1; h}\n  # Return an empty hash when the string doesn't\
    \ contain any character\n  sorted_list.empty? ? {} : sorted_list\nend", "  return\
    \ Hash.new(0) do |hash, key|\n    count = test.count(key)\n    hash[key] = (count\
    \ > 0) ? count : 1\n  end\nend", "  result = {}\n  test.split(' ').each do |word|\n\
    \    result[word] ||= 1\n    result[word] += 1\n  end\n  return result\nend",
  "  result = {}\n  test.split(\" \").each { |c| result[c] = 1 if result.has_key?(c)\
    \ }\n  result\nend", "  counts = Hash.new(0)\n  test.split(' ').each do |char|\n\
    \    if char == ''\n      counts[char] = counts[char] + 1\n    else\n      if\
    \ counts[char] > counts[char-1]\n        counts[char] = counts[char] + 1\n   \
    \   end\n    end\n  end\n  return counts\nend", "  words = test.split\n  histogram\
    \ = {}\n  max_word_length = 0\n  max_count = 0\n  max_letter = ''", "  count =\
    \ {}\n  test.split(' ').each do |word|\n    if count.has_key?(word)\n      count[word]\
    \ += 1\n    else\n      count[word] = 1\n    end\n  end\n  count\nend", "  result\
    \ = {}\n  text.split(//).each do |letter|\n    if result[letter] == nil\n    \
    \  result[letter] = 1\n    else\n      result[letter] += 1\n    end\n  end\n \
    \ result\nend", "  result = {}\n  test.split(' ').each do |letter|\n    occurrence\
    \ = test.split(' ').count(letter)\n    if !result[letter] or result[letter] >\
    \ occurrence\n      result[letter] = occurrence\n    end\n  end\n  result\nend",
  "  result = {}\n  test.split(' ').each do |char|\n    result[char] = (result[char].nil?)\
    \ ? 1 : result[char] + 1\n  end\n  result\nend\n</cell>\n<code language=julia-0.6>\n\
    histogram(\"a b c\")\n</cell>\n<code language=julia-0.6>\nhistogram(\"a b b a\"\
    )\n</cell>\n<code language=julia-0.6>\nhistogram(\"a b c a b\")\n</cell>\n<code\
    \ language=julia-0.6>\nhistogram(\"b b b b a\")\n</cell>\n<code language=julia-0.6>\n\
    histogram(\"b b b b b\")\n</cell>\n<code language=julia-0.6>\nhistogram(\"b b\
    \ b b a\")\n</cell>\n<code language=julia-0.6>\nhistogram(\"b b b b b\")\n</cell>\n\
    <code language=julia-0.6>\nhistogram(\"\")\n</cell>\n<code language=julia-0.6>\n\
    histogram(\"a b c a b\")\n</cell>\n<code language=julia-0.6>\nhistogram(\"b b\
    \ b b a\")\n</cell>\n<code language=julia-0.6>\nhistogram(\"b b b b b\")\n</cell>\n\
    <code language=julia-0.6>\nhistogram(\"b b b b a\")\n</cell>\n<code language=julia-0.6>\n\
    histogram(\"b b b b b\")\n</cell>\n<text>\nTask: Write a function that can compute\
    \ the sum of all digits in a string.\nExample input:\n\"1234\"", "  test=test.split(\"\
    \ \").map {|word| word.downcase}\n  hash=Hash.new(0)\n  test.each{|word| hash[word]+=1}\n\
    \  hash\nend", "\tdict = {}\n\tstring.split.each do |item|\n\t\tdict[item] ||=\
    \ 0\n\t\tdict[item] += 1\n\tend\n\treturn dict\nend", "  result = {}\n  words\
    \ = test.split\n  words.each do |word|\n    if word.downcase !~ /[a-z]/\n    \
    \  next\n    end\n    letter = word.downcase\n    count = (result[letter] ||=\
    \ 0)+1\n    result[letter] = count\n  end\n  result\nend", "  # Split string into\
    \ array of letters \n  letters = test.split(' ') \n  \n  # Initialize dict with\
    \ empty values\n  histogram = {}\n  \n  # Loop through array of letters\n  letters.each\
    \ do |letter| \n  \n    # Initialize count\n    histogram[letter] = 0 \n  \n \
    \   # Loop through array again to check count of letter\n    letters.each do |ltr|\n\
    \      if ltr == letter\n        histogram[ltr] += 1\n      end\n    end\n  end\n\
    \  \n  # Return result\n  return histogram\nend", "  result = {}\n  test.split(\"\
    \ \").each do |x|\n    result[x] ||= 1\n    result[x] += 1\n  end\n  return result\n\
    end", "  dict = {}\n  test.split(' ').each do |letter|\n    dict[letter] = test.split(letter).length\
    \ unless dict[letter]\n  end\n  dict\nend", "    letters = test.split(' ')\n \
    \   return letters.inject(Hash.new(0)) {|h,k| h[k] += 1;h}\nend", "  letters =\
    \ test.split(' ')\n  frequencies = {}", "  if test.empty?\n    {}\n  else\n  \
    \  test.split(' ').group_by { |x| x }.transform_values { |v| v.size }\n  end\n\
    end", "  result = {}\n  test.split(' ').each do |item|\n    result[item] = result.has_key?(item)\
    \ ? result[item] + 1 : 1\n  end\n  result\nend", "    letter = test[0]\n    letter_count\
    \ = Hash.new(0)\n    counts = [letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-letter-",
  "  hash = {}\n  test.split(\"\").each { |x| hash[x] = hash[x] ? hash[x] + 1 : 1\
    \ }\n  hash.each_value { |x| hash[x] = hash[x].to_i }\n  hash\nend", "  frequencies\
    \ = Hash.new(0)\n  test.split(' ').each_with_index do |letter, index|\n    frequencies[letter]\
    \ = (frequencies[letter] || 0) + 1\n  end", "  result = Hash.new(0)\n  test.split.uniq.each\
    \ { |item| result[item] += 1 }\n  result\nend\n</code>\n<|/ a dscore=0 tags=arrays,hash,ruby,sorting\
    \ |>\n<| a tags=arrays,hash,ruby,sorting dscore=0 |>\n<code>", "  letters = test.split(\"\
    \ \")\n  letters.inject(Hash.new(0)) { |count, letter| count[letter] += 1 }\n\
    end", "  frequencies = Hash.new(0)\n  test.split(' ').each do |i|\n    next if\
    \ i.nil?\n    frequencies[i] = frequencies[i.to_s] + 1 if frequencies[i] == 0\n\
    \  end", "  letters = {}\n  test.split(' ').each do |letter|\n    letters[letter]\
    \ ||= 0\n    letters[letter] += 1\n  end\n  return letters\nend", "  hash = {}\n\
    \  test.split(' ').each { |x| hash[x] = hash[x] ? hash[x] + 1 : 1 }\n  hash.values.max\
    \ == hash.values.max ? hash : hash.values.max\nend\n</code>\n<|/ a tags=ruby dscore=0\
    \ |>\n<| c |>\nThis seems like a good solution. Is there a way to get `[{'a' =>\
    \ 1}, {'b' => 2}, {'c' => 1}]` instead of `[{'a' => 1, 'b' => 2, 'c' => 1}]`?\n\
    <|/ c |>\n<| c |>\nI edited my answer to include a modification which gives you\
    \ the desired format for your question.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  letters = {}\n  test.split(\" \").each do |letter|\n    letters[letter] ||= 0\n\
    \    letters[letter] += 1\n  end\n  return letters\nend", "  hash = {}\n  test.split(//).each\
    \ do |i|\n    hash[i] ||= 0\n    hash[i] += 1\n  end\n  hash.sort.last\nend",
  "  # Write your code here.\n  histo = {}\n  for x in test.split\n    histo[x] ||=\
    \ 0\n    histo[x] += 1\n  return histo\nend\n</pre>\n</div>", "  result = {}\n\
    \  words = test.split(\" \")\n  words.each do |word|\n    letter = word.split(//).map\
    \ do |letter| \n      letter[0]\n    end.uniq.sort\n    letter = letter[0]\n \
    \   letter_count = word.split(//).map(&:to_i).uniq.length\n    result[letter]\
    \ = letter_count if result[[letter]] == nil\n    result[[letter]] ||= letter_count\n\
    \  end\n  result\nend\n</code>\nI haven't tested this, but it should work.  Let\
    \ me know if it doesn't work and I can fix it for you.\n<|/ a dscore=0 tags=ruby,arrays\
    \ |>\n<| c |>\nThanks for your answer.  Yeah, I know I said I didn't want to do\
    \ this with my solution.  I wanted a simpler one because I was getting frustrated\
    \ with my solution.  I didn't think about using inject or each_with_object.  I'll\
    \ give that a try.\n<|/ c |>\n<| c |>\nThis doesn't work.  After I run your code\
    \ and put a puts statement inside the each_with_object block, I get the following\
    \ output for the first word in the sentence: {\"b\"=>2, \"c\"=>2, \"a\"=>2, \"\
    d\"=>1}\n<|/ c |>\n<| c |>\nOk, I fixed it.  I needed to use group_by instead\
    \ of each_with_object.\n<|/ c |>\n<| c |>\nYes, I noticed that as well after posting.\
    \  And I actually like your method better.  I just had to change your code to\
    \ this for it to work: word_count = test.split(\" \").group_by { |w| w.split(//).map(&:to_i).uniq.sort\
    \ }.map { |k, v| [k.first, k.last.count] }.to_h\n<|/ c |>\n<| c |>\nYour code\
    \ works just fine, except I changed it to this:      word_count = test.split(\"\
    \ \").group_by { |w| w.split(//).map(&:to_i).uniq.sort }.map { |k, v| [k.first,\
    \ k.last.count] }.to_h\n<|/ c |>\n<| a tags=ruby,arrays |>\nI like Nick's answer\
    \ but I think it's actually overly complicated compared to what you want. The\
    \ first thing to note is that you want to split your string on spaces so you get\
    \ an array of words. Then, you want to convert each word to an integer, then convert\
    \ that array of words into an array of integers, then you can use the inject method\
    \ and merge the hashes into one hash using each_with_object\n<code>\nstring =\
    \ \"Hello World\"\nwords = string.split", "  results = {}\n  test.split(\" \"\
    ).each do |letter|\n    results.update({ letter => results[letter] ? results[letter]\
    \ + 1 : 1 })\n  end\n  results\nend", "  counts = {}\n  test.split(' ').each do\
    \ |letter|\n    counts[letter] ||= 0\n    counts[letter] += 1\n  end\n  counts\
    \ = counts.max_by { |k, v| v }\n  counts.each_value { |v| counts[v] = counts.delete(v)\
    \ }\n  counts\nend", "  test.split.map {|c| [c, test.split(c).size]}.inject(:merge).to_a.sort_by\
    \ {|k,v| -v[1]}\nend", "  counts = Hash.new(0)\n  test.split.each { |letter| counts[letter]\
    \ += 1 }\n  test.split.each do |letter|\n    if counts[letter] > counts[letter].max\n\
    \      counts[letter] = counts[letter].max\n    end\n  end\n  counts\nend", " \
    \ test.split(\" \").each do |str|\n    letters.each do |letter|\n      letters[letter][str]\
    \ = letters[letter][str].to_i + 1\n    end\n  end\n  letters.select! do |letter|\n\
    \    letters[letter][\"*\"] == letters[letter][\"*\"].max\n  end\n  letters.sort!\n\
    end", "  count = {}\n  test.split(' ').each do |i|\n    count[i] = count[i] +\
    \ 1 if count[i]\n  end\n  max = 0\n  count.each do |k, v|\n    max = v if v >\
    \ max\n  end\n  max == 0 ? nil : count.map {|k, v| [k, max] }\nend", "  count\
    \ = {}\n  letters = test.split\n  letters.each do |letter|\n    if count[letter]\
    \ == nil\n      count[letter] = 1\n    else\n      count[letter] += 1\n    end\n\
    \  end", "  h = Hash.new(0)\n  test.split(' ').each do |x|\n    letter = x.split('').map\
    \ {|i| i.downcase}.uniq.first\n    h[letter] += 1 if h[letter].nil?\n    h[letter]\n\
    \  end\n  h\nend\n</code>\n<|/ a |>\n<| a tags=hash,ruby |>\nI thought I'd add\
    \ an alternative answer. It's a one liner, although it takes more space:\n<code>\n\
    string = 'a b c a b c a b c a b'\nstring.split.group_by { |c| c }.map { |c, a|\
    \ [c, [a.size]] }\n</code>\nOr more verbosely broken down:\n<code>\nstring.split.group_by\
    \ { |c| c } # => {'a' => [ 'a b c a b c a b c a b' ], 'b' => [ 'a b c a b c a\
    \ b c a b' ], 'c' => [ 'a b c a b c a b c a b' ]}\n</code>\nThen map the keys\
    \ to the values:\n<code>\nstring.split.group_by { |c| c }.map { |c, a| [c, [a.size]]\
    \ } # => [['a', [1, 1]], ['b', [2, 1]], ['c', [3, 1]]]\n</code>\nAnd finally convert\
    \ that into an array of hashes:\n<code>\nstring.split.group_by { |c| c }.map {\
    \ |c, a| [c, [a.size]] }.to_h # => {'a' => [1, 1], 'b' => [2, 1], 'c' => [3, 1]}\n\
    </code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nI came up with this solution which\
    \ I think can be the fastest solution in some situations. \nThe idea is to use\
    \ the Enumerable#group_by method, but instead of returning an array of keys, group_by\
    \ returns an Enumerable that contains sub-arrays of key-value pairs. The sub-arrays\
    \ contain a single item (a string) followed by the size of the sub-array. \nBy\
    \ creating a new array from the group_by result we end up with an array of arrays.\
    \ Each array contains a single element (the key), followed by the size of the\
    \ corresponding group. By creating a new Hash from that array, we get the desired\
    \ result.\n<code>", "  result = Hash.new(0)\n  test.split(\" \").each do |letter|\n\
    \    result.merge!(letter) do |_, v|\n      v += result[@key]\n      @key += 1\n\
    \      v\n    end\n  end\n  result\nend", "  counts = Hash.new(0)\n  test.split('\
    \ ').each do |x|\n    counts[x] += 1\n  end\n  counts\nend", "  histo = {}\n \
    \ test.split(\" \").each do |letter|\n    histo[letter] = (histo[letter] or 0)\
    \ + 1 # or use ||= (increments existing value)\n  end\n  histo\nend", "  res =\
    \ {}\n  test.split.each do |letter|\n    res[letter] = res.get(letter) || 0\n\
    \    res[letter] += 1\n  end\n  return res\nend", "  result = {}\n  test.split.each{\
    \ |i| result[i] ||= 0 }\n  test.split.each{ |i| result[i] += 1}\n  result.max_by\
    \ { |k, v| v }\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\nYou can make\
    \ use of the splat operator to accept multiple arguments to a method.\n<code>",
  "    letters = {}\n    letterCounts = {}\n    for letter in test.split\n       \
    \ letterCounts[letter] = letterCounts[letter] + 1 if letterCounts.has_key?(letterCounts[letter]\
    \ \n                                                                         \
    \                  ) \n                                                      \
    \                                     else 1\n        letters[letter] = letters[letter]\
    \ + 1 if letters.has_key?(letters[letter] \n                                 \
    \                                               ) \n                         \
    \                                                       else 1\n    letterCounts.sort_by{|key,\
    \ value| value}.last.each do |key, value|\n        letters[key] = value\n    end\n\
    \    return letters\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nThis\
    \ works but you are creating two hashes while you only need one. One can be created\
    \ with `Hash.new(0)`.\n<|/ c |>\n<| a |>\n<code>", "  map = {}\n  test.split('\
    \ ').each do |l|\n    map[l] = map.fetch(l, 0) + 1\n  end\n  map\nend", "    letters\
    \ = {}\n    test.split().each do |letter|\n        if letters.has_key? letter\n\
    \            letters[letter] += 1\n        else\n            letters[letter] =\
    \ 1\n        end\n    end\n    return letters\nend\n</code>\n<|/ a dscore=3 tags=ruby,arrays,sorting\
    \ |>\n<| c |>\nVery nice.  I was thinking of writing a solution but this is really\
    \ nice.  I knew I had to iterate through all the letters to see what was repeated.\n\
    <|/ c |>\n<| c |>\nI ran some tests on this, and it looks like the second solution\
    \ doesn't sort alphabetically and doesn't output the same results as `histogram('a\
    \ b b b a')`. I'm running Ruby 1.8.7 on Mac OS X 10.6.8. Would that make a difference?\n\
    <|/ c |>\n<| c |>\nNope, it doesn't. My test was on 1.9.2 and 1.9.0. It's possible\
    \ they were different versions earlier in the week.\n<|/ c |>\n<| c |>\nI've never\
    \ seen `has_key?` used on a `Hash` before. Wouldn't that have created an `IndexError`\
    \ instead?\n<|/ c |>\n<| c |>\nNot in the version of ruby I tested with. It could\
    \ be a typo in 1.8.7, or I messed up the test somehow. I just tested on 1.8.7\
    \ and 1.9.2 on Windows and Linux, and both work.\n<|/ c |>\n<| a tags=ruby,arrays,sorting\
    \ |>\nYou would need to iterate over the letters, testing each to see whether\
    \ it appears more than once, then output the letter if this is the case. \n<code>",
  "    letters = []\n    count = {}", "    letters = test.split(' ')\n    counts =\
    \ {}\n    letters.each do |letter|\n        counts[letter] = letters.count(letter)\n\
    \    end\n    letters.uniq.each do |letter|\n        if counts[letter] > counts[letters[letter]]\
    \ then counts[letter] = counts[letters[letter]]\n        else counts[letter] -=\
    \ 1\n        end\n    end\n    return counts\nend", "  hash = Hash.new(0)\n  test.split(//).each\
    \ { |x| hash[x] += 1 }\n  hash\nend", "  letters = test.split(\" \")\n  results\
    \ = {}\n  letters.each do |letter|\n    results[letter] ||= 0\n    results[letter]\
    \ += 1\n  end\n  letters.keys.sort.each do |letter|\n    results[letter] = results[letter]\
    \ % letters\n  end\n  return results\nend", "    test\n        .split(//)\n  \
    \      .each_with_object({}) { |e,h|\n            h[e] = h[e] || 0\n         \
    \   h[e] += 1\n        }\nend\n</code>\n<code>", "  result={}\n  test.split('\
    \ ').each do |char|\n    if result.has_key?(char)\n      result[char]+=1\n   \
    \ else\n      result[char]=1\n    end\n  end\n  result\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 tags=ruby,string |>\nHere's a way using the Enumerable#group_by\
    \ method:\n<code>", '  test.count("\n") + 1', "  test = ''.join(test.split)\n\
    \  results = {}\n  test.split(' ').each do |word|\n    word = word.downcase\n\
    \    count = results[word] = results[word] || 0\n    count += 1\n  end\n  results\n\
    end", "  return test.split.reduce( Hash.new(0), {|h,c| h[c] += 1}).max_by {|k,\
    \ v| v}\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like the histogram approach\
    \ - I added a hash to hold the results in the answer to my question.  I like how\
    \ you handled the case where more than one key was in the histogram with the same\
    \ value.\n<|/ c |>\n<| c |>\nAgreed, I added `max_by` to the solution.\n<|/ c\
    \ |>\n<| c |>\nYour solution is more elegant, but you did not use `max_by`.  Your\
    \ code also works in 1.8.7.  If you use `max_by` instead of `inject` you will\
    \ not need to `merge` in the last line.\n<|/ c |>\n<| c |>\nYou're right, I didn't\
    \ even look at his result. I've updated the answer. Thanks!\n<|/ c |>\n<| a dscore=1\
    \ |>\nYou want to use Enumerable#group_by and use Enumerable#max to get the most\
    \ frequent item.\n<code>\nstr = 'a b c'\nstr.split.group_by{ |c| c }.max", " \
    \   histo = {}\n    for letter in test.split(\" \")\n        if histo[letter]\
    \ == nil\n            histo[letter] = 0\n        histo[letter] += 1\n    end\n\
    \    \n    return histo\nend", "  histo = {}\n  test.split.each do |char|\n  \
    \  histo[char.to_sym] = histo.has_key?(char.to_sym) ? histo[char.to_sym] + 1 :\
    \ 1 # Increase the count if the char has been seen before\n  end\n  return histo\n\
    end\n</code>\n<|/ a tags=string,ruby,arrays dscore=1 |>\n<| a tags=string,ruby,arrays\
    \ dscore=1 |>\nIn case you need a different solution (I guess you're solving an\
    \ exercise from the ruby challenge...), you may find the following solution interesting:\n\
    <code>", "    histo = {}\n    letters = test.split(' ')\n    letters.each do |letter|\n\
    \        histo[letter] = histo[letter] ? histo[letter] + 1 : 1\n    end\n    return\
    \ histo\nend", "  result = {}\n  test.split(\" \").each do |letter|\n    result.merge!(letter=>0)\
    \ if result.has_key?(letter)\n    result[letter] += 1\n  end\n  result\nend",
  "  count = {}\n  test.split(' ').each do |x|\n    count[x] = count[x] ? count[x]\
    \ + 1 : 1\n  end\n  max = 0\n  count.each do |k, v|\n    if v > max\n      max\
    \ = v\n    end\n  end\n  return count\nend", "    test.split(' ').reduce(Hash.new(0))\
    \ { |hash, (k, v)| hash[v] += 1; hash }\nend", "  test = (test || \" \")\n  count\
    \ = {}", "  # Write your code here.\n  results = {}\n  test.downcase.each_char.sort.group_by{|x|\
    \ x}.max_by{|k, v| v.size}.each do |key, value|\n    values.push(value)\n  end",
  "  letters = test.split(\" \")\n  count = {}\n  letters.each do |letter|\n    count[letter]\
    \ ||= 0\n    count[letter] += 1\n  end", "  count = {}\n  test.split(\" \").each\
    \ do |char|\n    count[char.to_sym] ||= 0\n    count[char.to_sym] += 1\n  end\n\
    \  return count\nend", "  hash = {}\n  test.split.each do |e|\n    hash[e] = hash[e]\
    \ || 0\n    hash[e] += 1\n  end\n  hash.max_by { |k, v| v }\nend", "    letters\
    \ = {}\n    counts = {}", "  count = {}\n  test.split.each do |letter|\n    letter\
    \ = letter[0]\n    count[letter] = (count[letter] ||= 0)+1\n  end\n  count\nend",
  "\t\nend", "  letters = test.split\n  hash = {}\n  letters.each do |letter|\n  \
    \  hash[letter] ||= 0\n    hash[letter] += 1\n  end\n  hash\nend", "    # Initialize\
    \ results to an empty dictionary\n    histogram = {}", "  hash = {}\n  test.split('\
    \ ').each do |letter|\n    hash[letter] ||= 0\n    hash[letter] += 1\n  end\n\
    \  hash\nend", "  hash = {}\n  test.split(' ').each do |letter|\n    hash[letter]\
    \ = hash[letter].to_i + 1 unless hash.key?(letter)\n  end\n  hash\nend\n</code>\n\
    <|/ a tags=ruby,string,hash |>\n<| c |>\n`hash` should be an instance variable.\
    \ Your `test` will be an argument to `histogram` method. Also, to make your answer\
    \ more complete, I'd suggest that `hash` be initialized to `Hash.new(0)` instead\
    \ of `{}`.\n<|/ c |>\n<| c |>\nYes you are correct, I've updated my answer accordingly\n\
    <|/ c |>\n<| c |>\n`histogram('a b b b a')` will return `{'b': 2}` instead of\
    \ `{'a': 2, 'b': 2}` as the OP asked for. Also, instead of `Hash.new(0)`, you\
    \ could do `Hash.new { |h,k| h[k] = 0 }`.\n<|/ c |>\n<| c |>\nIt seems that this\
    \ would do the trick `def histogram(test)\n  hash = {}\n  test.split(' ').each\
    \ do |letter|\n    hash[letter] = hash[letter].to_i + 1 unless hash.key?(letter)\n\
    \  end\n  hash\nend`\n<|/ c |>\n<| a tags=ruby,string,hash |>\nHere's a solution\
    \ that is based on my previous answer to a similar question. It uses an intermediate\
    \ Hash containing only the frequencies of each letter. The result is a hash with\
    \ a key for each letter and a value of an array containing the letters with the\
    \ same frequency.\n<code>", "  letters = {}\n  letters.update((i, 1) for i in\
    \ test)\n  letters = letters.max_by {|_, val| val}\n  letters.keys.each{|letter|\
    \ letters[letter] = letters[letter].to_i}\n  return letters\nend", "  # Initialize\
    \ our empty dictionary\n  histo = {}", "    count = {}\n    \n    test.split('\
    \ ').each do |letter|\n        count[letter] ||= 0\n        count[letter] += 1\n\
    \    end\n    \n    count.each do |k,v|\n        if v > 1\n            puts \"\
    #{k} #{v}\"\n        end\n    end\nend", "  if test[-1] != ' '\n    test += '\
    \ '\n  words = test.split(' ')\n  counts = Hash.new(0)\n  words.each {|x| counts[x]\
    \ += 1}\n  counts.max_by {|key, value| value}\nend", "  letters = test.split\n\
    \  histo = {}\n  letters.each do |letter|\n    histo[letter] = histo[letter].to_i\
    \ + 1\n  end\n  if histo == {} or histo == {'', ''}\n    return histo\n  else\n\
    \    max_value = 0\n    letters.each do |letter|\n      if histo[letter] > max_value\n\
    \        max_value = histo[letter]\n      end\n    end\n    histo = {}\n    max_value.times\
    \ do |n|\n      letters.each do |letter|\n        histo[letter] = histo[letter].to_i\
    \ + 1\n      end\n    end\n    return histo\n  end\nend", "  result = {}\n  test.split(\"\
    \ \").each do |word|\n    if result[word] == nil\n      result[word] = 1\n   \
    \ else \n      result[word] += 1\n    end\n  end\n  result\nend\n</code>\n<|/\
    \ a dscore=0 tags=ruby |>\n<| a dscore=0 tags=ruby |>\n<code>\n'a b c a b b b\
    \ a a a'.split", "    letters = test.split(' ')\n    letters.each do |letter|\n\
    \        letters[letter] = letters.count(letter).to_f\n    end\n    return letters\n\
    end", "    hash = {}\n    string.split(test).each_with_index do |letter,index|\n\
    \        hash[letter] ||= 0\n        hash[letter] += 1 \n    end\n    hash.reduce({})\
    \ { |hash,item| hash[item] = hash[item].to_i if hash[item].to_i <= hash[item].to_i\
    \ }\nend", "  test.count(\"a\") += 1\n  test.count(\"b\") += 1\n  test.count(\"\
    c\") += 1\n  test.count(\"d\") += 1\n  test.count(\"e\") += 1\n  test.count(\"\
    f\") += 1\n  test.count(\"g\") += 1\n  test.count(\"h\") += 1\n  test.count(\"\
    i\") += 1\n  test.count(\"j\") += 1\n  test.count(\"k\") += 1\n  test.count(\"\
    l\") += 1\n  test.count(\"m\") += 1\n  test.count(\"n\") += 1\n  test.count(\"\
    o\") += 1\n  test.count(\"p\") += 1\n  test.count(\"q\") += 1\n  test.count(\"\
    r\") += 1\n  test.count(\"s\") += 1\n  test.count(\"t\") += 1\n  test.count(\"\
    u\") += 1\n  test.count(\"v\") += 1\n  test.count(\"w\") += 1\n  test.count(\"\
    x\") += 1\n  test.count(\"y\") += 1\n  test.count(\"z\") += 1\n  return test\n\
    end\n</cell>\n<code language=julia-1.0>\nhistogram(\"a b c a b a a a d a e\")\n\
    </cell>\n<code language=julia-1.0>\nhistogram(\"a b c a b a a a d a e\")\n</cell>\n\
    <code language=julia-1.0>\nhistogram(\"a b c a b a a a d a e\")\n</cell>\n<code\
    \ language=julia-1.0>\nhistogram(\"a b c a b a a a d a e\")\n</cell>\n<code language=julia-1.0>\n\
    histogram(\"a b c a b a a a d a e\")\n</cell>\n<code language=julia-1.0>\nhistogram(\"\
    a b c a b a a a d a e\")\n</cell>\n<code language=julia-1.0>\nhistogram(\"a b\
    \ c a b a a a d a e\")\n</cell>\n<code language=julia-1.0>\nhistogram(\"a b c\
    \ a b a a a d a e\")\n</cell>\n<code language=julia-1.0>\nhistogram(\"a b c a\
    \ b a a a d a e\")\n</cell>\n<code language=julia-1.0>\nhistogram(\"a b c a b\
    \ a a a d a e\")\n</cell>\n<code language=julia-1.0>\nhistogram(\"a b c a b a\
    \ a a d a e\")\n</cell>\n<code language=julia-1.0>\nhistogram(\"a b c a b a a\
    \ a d a e\")", "  letters = {}\n  test.split(\" \").each do |letter|\n    letters[letter]\
    \ = letters[letter] ? letters[letter]+1 : 1\n  end\n  letters.sort{|a,b| b <=>\
    \ a}.each do |letter, count|\n    letters[letter] = count.to_s\n  end\n  letters\n\
    end", "  result = {}\n  test.split(' ').each do |letter|\n    result[letter] =\
    \ result[:letter] || 0\n    result[letter] += 1\n  end\n  result\nend", "  if\
    \ test.nil?\n    {}\n  else\n    letters = test.split(' ').map {|letter| letter}\n\
    \    letters.inject(Hash.new(0)) {|a, l| a[l] += 1;a}\n  end\nend\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nThanks for sharing. I would like you to explain the\
    \ answer a little more. I am a novice coder, and am confused about `letters.inject(Hash.new(0))\
    \ {|a, l| a[l] += 1;a}`. Why are you using `letters` and `l` instead of just `a`\
    \ and `b`?\n<|/ c |>\n<| c |>\n`letters` contains all the lowercase letters, `l`\
    \ is the letter itself. I use `letter` because it's a Ruby convention (not related\
    \ to your question, but to Ruby conventions you should use Ruby conventions) to\
    \ name variable which refers to a character in a string. Thus `l` is more readable\
    \ and less error-prone than `a` `b` and so on.\n<|/ c |>\n<| c |>\n`letters.inject(Hash.new(0))\
    \ {|a, l| a[l] += 1;a}` is the same as `letters.inject(Hash.new(0)) {|a,l| a[l]\
    \ = a[l]+1;a}`.\n<|/ c |>\n<| a tags=ruby dscore=3 |>\nHere's another way of doing\
    \ the same thing while getting rid of the inject method.\n<code>", "  count =\
    \ Hash.new(0)\n  test.split(' ').each do |letter|\n    count[letter] += 1 if count[letter].nil?\n\
    \  end\n  test\nend", "  # Split string into an array of strings by a space and\
    \ remove duplicates\n  words = test.split\n  uniqueWords = Set.new\n  testHash\
    \ = Hash.new(0)\n  words.each do |word|\n    testHash[word] += 1\n    uniqueWords\
    \ << word if testHash[word] > 1\n  end\n  return testHash\nend\n</code>\n<|/ a\
    \ tags=ruby,arrays dscore=0 |>\n<| c |>\nI appreciate the help but i'm not really\
    \ sure how to implement this into my program, i'm fairly new to ruby so i'm a\
    \ bit lost here. Can you provide an example of the solution in code?\n<|/ c |>\n\
    <| a dscore=0 |>\nHere's a version that uses a hash to count the occurrences of\
    \ each letter:\n<code>", "  letters = test.split(\" \")\n  counts = {}\n  letters.each\
    \ do |letter|\n    letter = letter.downcase\n    counts[letter] = counts[letter].to_i\
    \ + 1 if letter in counts\n  end\n  return counts\nend", "  h = Hash.new(0)\n\
    \  test.split(\" \").each { |w| h[w] += 1 }\n  h.max_by { |_,v| v }\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=ruby,arrays |>\n<code>", "    letters = {}\n    test.split!('\
    \ ').map { |letter| letters[letter] = letters[letter].zero? ? 1 : letters[letter].nonzero?\
    \ += 1 }\n    letters.sort_by { |k,v| v }.reverse\n    letters.map { |k,v| [k,\
    \ v] }\nend\n</code>\n<|/ a |>\n<| a tags=hash,ruby,arrays |>\n<code>", "  result\
    \ = Hash.new(0)\n  test.split(' ').each do |letter|\n    result.merge!(letter\
    \ => result[letter] || 0) unless result[letter].nil?\n  end\n  result\nend", " \
    \ letters = test.split\n  letters.each { |letter| letters[letter] = letters[letter].to_i\
    \ }\n  count = letters.reduce(:merge)\n  letters.select{ |k,v| v > count}.sort_by{\
    \ |k,v| v }.reverse.inject([{},]) { |h,(k,v)| h[k] = v; h }\nend\n</code>\n<|/\
    \ a tags=ruby,string |>\n<| c |>\nI like the use of Enumerable#inject.\n<|/ c\
    \ |>\n<| a |>\nThe most readable and efficient solution is to use an Array#group_by.\n\
    <code>", "\thash = {}\n\ttest.split.each do |letter|\n\t\thash[letter] = hash[letter].to_i\
    \ + 1 if hash[letter]\n\tend\n\thash.values.sort!.reverse\n\thash\nend", "  result\
    \ = Hash.new(0)\n  test.split(' ').each do |item|\n    key = item.downcase\n \
    \   result[key] += 1\n  end\n  result\nend", "  test.split(' ').inject(Hash.new(0),\
    \ :merge)\nend", "  hash = {}\n  test.split(' ').each do |letter|\n    hash.has_key?\
    \ letter ? hash[letter] += 1: hash[letter] = 1\n  end\n  hash\nend", "  hash =\
    \ {}\n  test.split(' ').each { |i| hash[i] = hash[i].nil? ? 0 : hash[i] + 1 }\n\
    \  max_count = 0\n  hash.keys.each { |i| max_count = hash[i] > max_count ? hash[i]\
    \ : max_count }\n  hash\nend\n</cell>\n<text>\nNow we know what a histogram is!",
  "  hash = {}\n  test.split.each_index { |i| hash[test[i]] = hash.fetch(test[i],\
    \ 0) + 1  }\n  hash\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI think you should\
    \ explain the problem of the OP. Just giving a solution won't help anyone\n<|/\
    \ c |>\n<| c |>\n\"Return the most frequent letter from the given string\"\n<|/\
    \ c |>\n<| c |>\nPlease reread my comment. I meant \"explain why your solution\
    \ does not work\"\n<|/ c |>\n<| c |>\nI think I already explained that, but I'll\
    \ add some explanation anyway for you. :-)\n<|/ c |>\n<| c |>\nGreat answer, but\
    \ I believe the second one should probably be \"histogram(test)\" instead of \"\
    histogram(test.split)\", otherwise it only works if the string contains only spaces.\n\
    <|/ c |>\n<| a dscore=4 |>\n<code>\ns = \"abbab\"\ns.split('').inject(Hash.new(0)){|h,\
    \ x| h[x] += 1; h}\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is much more efficient,\
    \ though slightly less readable: `s.split('').inject(Hash.new(0)) { |h, x| h[x]\
    \ += 1 }`.\n<|/ c |>\n<| a tags=ruby |>\nI wrote a solution that uses inject but\
    \ without using an intermediate variable:\n<code>", "  letters = test.split('')\n\
    \  histo = {}\n  letter.each do |letter|\n    histo[letter] ||= 0\n    histo[letter]\
    \ += 1\n  end\n  return histo\nend\nprint histogram('a b c a b a b c')", "  hash\
    \ = {}\n  test.split.each_with_index do |char, index|\n    hash[char] ||= 1\n\
    \    hash[char] += 1\n  end\n  hash.values.uniq.sort_by { |e| -e}\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nI like the use of `each_with_index` for its simplicity.\
    \  I like its use of `sort_by`.  But I think the OP was looking for a solution\
    \ that uses just the methods he was already familiar with.  I like that the OP\
    \ accepted a solution but that he then unaccepted it.\n<|/ c |>\n<| c |>\nI didn't\
    \ notice that until I saw [David's answer](http://stackoverflow.com/a/19228835/128421)\
    \ which was pretty much the same.  I accepted his answer because I didn't know\
    \ what was wrong with mine until I read the other answer. :-)\n<|/ c |>\n<| a\
    \ dscore=3 |>\nHere's a way to do it in one line:\n<code>\nHash[test.split.split.group_by{|x|\
    \ x}.max_by(&:size).flatten]\n</code>\nAnd here's one that uses Hash#merge:\n\
    <code>\ntest.split.split.group_by{|x| x}.max_by(&:size).inject(Hash.new){|h, k|\
    \ h.merge!({k => k.size})}\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby dscore=2\
    \ |>\nYou could do something like this\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
