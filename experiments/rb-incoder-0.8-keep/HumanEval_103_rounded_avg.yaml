name: HumanEval_103_rounded_avg
language: rb
prompt: "# You are given two positive integers n and m, and your task is to compute\
  \ the\n# average of the integers from n through m (including n and m). \n# Round\
  \ the answer to the nearest integer and convert that to binary.\n# If n is greater\
  \ than m, return -1.\n# Example:\n# rounded_avg(1, 5) => \"0b11\"\n# rounded_avg(7,\
  \ 5) => -1\n# rounded_avg(10, 20) => \"0b1111\"\n# rounded_avg(20, 33) => \"0b11010\"\
  \ndef rounded_avg(n, m)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rounded_avg\n\
  \    candidate = method(:rounded_avg)\n    assert_equal(\"0b11\", candidate.call(1,\
  \ 5))\n    assert_equal(\"0b1010\", candidate.call(7, 13))\n    assert_equal(\"\
  0b1111001010\", candidate.call(964, 977))\n    assert_equal(\"0b1111100100\", candidate.call(996,\
  \ 997))\n    assert_equal(\"0b1011000010\", candidate.call(560, 851))\n    assert_equal(\"\
  0b101101110\", candidate.call(185, 546))\n    assert_equal(\"0b110101101\", candidate.call(362,\
  \ 496))\n    assert_equal(\"0b1001110010\", candidate.call(350, 902))\n    assert_equal(\"\
  0b11010111\", candidate.call(197, 233))\n    assert_equal(-1, candidate.call(7,\
  \ 5))\n    assert_equal(-1, candidate.call(5, 1))\n    assert_equal(\"0b101\", candidate.call(5,\
  \ 5))\n  end\nend\n"
completions: ["  if m == 0 || n == m \n    return \"0b0\"\n  else if n == m\n    return\
    \ \"0b\" + n.to_s(2).rjust(8, '0')\n  else if m > n\n    return \"-1\"\n  else\n\
    \    return n.to_s(2).rjust(8, '0') + rounded_avg(m, m - 1).to_s(2).rjust(8, '0')\n\
    end\n</code>\nThis doesn't do all the checks you wanted, but I don't think that\
    \ will make a difference.\n<|/ a tags=binary,ruby,ruby-on-rails |>\n<| c |>\n\
    thanks, this works! but what about if i want to return -1 in case of a negative\
    \ number?\n<|/ c |>\n<| c |>\n- I think I added a case for that...\n<|/ c |>\n\
    <| c |>\n- I added a second method (slightly cleaned up) that seems to do what\
    \ you want\n<|/ c |>\n<| c |>\nthank you very much for your answer, i want to\
    \ return the result with trailing zeros exactly as the original input. but i will\
    \ play around with it some more to get something working exactly as i want.\n\
    <|/ c |>\n<| c |>\n- If you need more information on the method you can always\
    \ [check out Ruby's documentation](http://www.ruby-doc.org/core-2.1.5/Numeric.html#method-i-to_s)\
    \ or the [ruby wiki](http://ruby-doc.org/core-2.1.5/Numeric.html#method-i-to_s)\
    \ for the `to_s` method.\n<|/ c |>\n<| a dscore=1 |>\nHere's an approach which\
    \ uses recursion to convert n to binary string and concatenates it with binary\
    \ of m. \n<code>", "  a = n.upto(m).inject([]) {|sum, v| sum << v << v.to_s(2).length}\n\
    \  a[-1] = a[-1] > 0 ? a[-1] - 1 : -1\n  a.map(&:to_s(2)).join\nend\n  ", "  if\
    \ n >= m\n    return -1\n  n = (n % 100).to_s(2).ljust(100, \"0\")\n  m = ((m\
    \ % 100).to_s(2).ljust(100, \"0\")\n  a = n.to_i(2).to_s(10)\n  b = m.to_i(2).to_s(10)\n\
    \  result = a + b\n  result = (0...result).map { |i| i.to_s(2) }.join(\"\")\n\
    \  result = \"0b\" + result\n  return result\nend\n</cell>\n<cell>\nrounded_avg(10,\
    \ 20)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(100,\
    \ 2)\n</cell>\n<cell>\nrounded_avg(100, 5)\n</cell>\n<cell>\nrounded_avg(100,\
    \ 99)\n</cell>\n<cell>\nrounded_avg(100, 100)\n</cell>\n<cell>\nrounded_avg(100,\
    \ 999)\n</cell>\n<cell>\nrounded_avg(100, 999)\n</cell>\n<cell>\nrounded_avg(100,\
    \ 9999)\n</cell>\n<cell>\nrounded_avg(100, 9999)\n</cell>\n<cell>\nrounded_avg(100,\
    \ 10000)\n</cell>\n<cell>\nrounded_avg(100, 100000)\n</cell>\n<cell>\nrounded_avg(100,\
    \ 1000000)\n</cell>\n<cell>\nrounded_avg(100, 10000000)\n</cell>\n<cell>\nrounded_avg(100,\
    \ 100000000)\n</cell>\n<cell>\nrounded_avg(100, 1000000000)\n</cell>\n<cell>\n\
    rounded_avg(100, 10000000000)\n</cell>\n<cell>\nrounded_avg(100, 100000000000)\n\
    </cell>\n<cell>\nrounded_avg(100, 1000000000000)\n</cell>\n<cell>\nrounded_avg(100,\
    \ 10000000000000)\n</cell>\n<cell>\nrounded_avg(100, 100000000000000)\n</cell>\n\
    <cell>\nrounded_avg(100, 1000000000000000)\n</cell>\n<cell>\nrounded_avg(100,\
    \ 10000000000000000)\n</cell>\n<cell>\nrounded_avg(100, 100000000000000000)\n\
    </cell>\n<cell>\nrounded_avg(100, 1000000000000000000)\n</cell>\n<cell", "  sum\
    \ = 0\n  ni = n\n  mi = m\n  while (ni < m) and (i < m)\n    sum = sum + ni \n\
    \    ni += 1\n    i += 1\n  end\n  sum.to_s(2)\nend", "  avg = (n * m / 2).ceil\n\
    \  return \"%b\" % avg.to_s(2)\nend\nprint(rounded_avg(1, 5)) # => 0b11\nprint(rounded_avg(7,\
    \ 5)) # => -1\nprint(rounded_avg(10, 20)) # => 0b1111\nprint(rounded_avg(20, 33))\
    \ # => 0b11010\n</cell>\n<text>\nThe function bin? returns true if the integer\
    \ n is represented as a binary number (i.e. the decimal number represented by\
    \ n consists only of 0s and 1s). Otherwise, it returns false. For example:", " \
    \ avg, sum = 0, 0\n  n.upto(m) do |n|\n    avg = sum + n\n    sum += n\n    if\
    \ sum >= m\n      return -1\n    end\n  end\n  \n  binary = []\n  n.upto(m) do\
    \ |n|\n    binary.push(\"#{n.to_s(2).rjust(8, '0')}\")\n  end\n  return binary.join.tr('1',\
    \ '0').to_i\nend", "  return (n..m).inject(:+) / 2.0\nend", "\t((n..m).select\
    \ { |x| x % 2 == 0 }.sum(Integer::new).to_f + Float::new(n).round(Float::DECIMAL_DIG)).abs\n\
    end", "  if m == 0\n    \"0b0\"\n  elsif n == m\n    \"0b0\"\n  elsif m < n\n\
    \    rounded_avg(n+1, m)\n  elsif n >= m\n    rounded_avg(n, m-1)\n  else\n  \
    \  \"Invalid input\"\n  end\nend", "  res = 0\n  n.upto(m) { |e| res << e }\n\
    \  res.to_s(2).gsub(/[01]/, '0').to_i(2) \nend", "  ((m>n) ? nil : ((n/m).floor\
    \ * m).to_s(2)).scan(/../).join(\"\") \nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nI made a gem that does this. It's called ruby_round. \nHere's how you use\
    \ it:\n<code>\nrequire 'ruby_round'\nruby_round(5) => 4\nruby_round(4.1) => 4\n\
    ruby_round(4.5) => 5\nruby_round(4.6) => 5\nruby_round(4.7) => 5\nruby_round(4.8)\
    \ => 5\nruby_round(4.9) => 5\n</code>\nYou can also set :precision to round to\
    \ a different number of decimal places. \n<code>\nruby_round(5, :precision =>\
    \ 2) => 4.00\nruby_round(4.1, :precision => 2) => 4.0\nruby_round(4.5, :precision\
    \ => 2) => 5.00\nruby_round(4.6, :precision => 2) => 5.00\nruby_round(4.7, :precision\
    \ => 2) => 5.00\nruby_round(4.8, :precision => 2) => 5.00\nruby_round(4.9, :precision\
    \ => 2) => 5.00\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nHere's a solution\
    \ that doesn't use String#scan.\n<code>", "  total = 0\n  while n >= m\n    total\
    \ += n\n    n -= m\n  end\n  if n > m\n    return -1\n  end\n  total / 2\nend",
  "  return (n...m).inject{|acc, n| acc + (n / m - 1).round}\nend", "  (n+m).round/2\
    \ if n.between?(m, m+1) || m.between?(n, n+1) ? -1 : (n.upto(m).to_a.sum{|i| n<i\
    \ ? n-1 : (m-n<i ? m-n : i)}*2)\nend\n</cell>\n<code language=conda-root-py>\n\
    rounded_avg(7, 5)\n</cell>\n<code language=conda-root-py>\nrounded_avg(10, 20)\n\
    </cell>\n<code language=conda-root-py>\nrounded_avg(20, 33)\n</cell>\n<code language=conda-root-py>\n\
    rounded_avg(3, 0)\n</cell>\n<code language=conda-root-py>\nrounded_avg(4, 0)\n\
    </cell>\n<code language=conda-root-py>\nrounded_avg(0, 10)\n</cell>\n<text>\n\
    Part 4\nThe code below will solve the above problem by using a combination of\
    \ map, select, and reduce.", "  n, m = [n, m].map{|i| i >= 0 ? i : -1}\n  result\
    \ = \"0b0\"*n\n  i = 1\n  while i <= n\n    result += \"0b\" + n.to_s(2).chars.zip(m.to_s(2).chars).map{|c,\
    \ m| \"0b\" + (c + m).to_s(2)}.join(\"\")\n    i += 1\n  end\n  result\nend\n\
    </code>\n<|/ a dscore=1 tags=ruby,binary,math,numbers,division |>\n<| a dscore=0\
    \ tags=ruby,binary,math,numbers,division |>\n<code>", "  sum = n..m\n  avg = sum.inject{|sum,x|\
    \ sum + x}/sum.count\n  bin = sprintf(\"%b\", avg)\n  bin.downcase\nend", "  if\
    \ n >= m\n    return \"-1\"\n  else\n    digits = n.to_s.reverse.to_i(2) + m.to_s.reverse.to_i(2)\n\
    \    rounded = digits.divmod(2).map(&:to_s).reverse.join\n    rounded_binary =\
    \ \"0b\" + rounded\n    return \"0b\" + rounded_binary.reverse\n  end\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby |>\n<| a dscore=1 |>\n<code>", "  return -1 if n > m\n\
    \  \n  avg = 0\n  for i in 0...n\n    avg = avg + i\n  end\n  avg = avg / n\n\
    \  \n  i = n\n  while i < m\n    avg = avg * 2 + i\n    i = i + 1\n  end\n  return\
    \ avg.to_s(2).split(//).map{ |e| e.to_i(2).to_s(8) }.join(\"\")\nend", "  result\
    \ = 0\n  for i in 0...m\n    result += n.to_s.to_i(2) - (m.to_s.to_i(2) + i.to_s.to_i(2))\n\
    \    result /= 2\n    result -= 1 if i < m else -1\n    result += 1\n    return\
    \ result\nend\n</code>\n<|/ a |>\n<| a |>\nI came up with something similar which\
    \ I think can be more efficient. \n<code>", "  return n if n > m else -1\nend\n\
    </cell>\n<code language=julia-1.5>\n@test rounded_avg(8, 2) == 1\n@test rounded_avg(10,\
    \ 20) == -1\n@test rounded_avg(20, 33) == 5\n</cell>\n<text>\nNow that we have\
    \ a function that computes the average of an interval, we can use it to define\
    \ our new function is_prime:", "  n1 = n - (n % m) # n = 5 - 0 = 0\n  n2 = ((n-1)\
    \ / m).to_s(2) # n = \"5-1\" = \"0.4\"\n  n3 = (n1 + \"1\").to_s(2) # n = \"0.4-1\"\
    \ = \"0.6\"\n  n4 = (n + \"0\").to_s(2) # n = \"0.6-0\" = \"0.10\"\n  n5 = (n3\
    \ + \"0\").to_s(2) # n = \"0.10-0\" = \"0.14\"\n  n6 = (n4 + \"0\").to_s(2) #\
    \ n = \"0.14-0\" = \"0.16\"\n  n7 = (n5 + \"0\").to_s(2) # n = \"0.16-0\" = \"\
    0.18\"\n  n8 = (n6 + \"0\").to_s(2) # n = \"0.18-0\" = \"0.2\"\n  n9 = (n7 + \"\
    0\").to_s(2) # n = \"0.2-0\" = \"0.4\"\n  n10 = (n8 + \"0\").to_s(2) # n = \"\
    0.4-0\" = \"0.5\"\n  n11 = (n9 + \"0\").to_s(2) # n = \"0.5-0\" = \"0.7\"\n  n12\
    \ = (n10 + \"0\").to_s(2) # n = \"0.7-0\" = \"1\"\n  n13 = (n12 + \"0\").to_s(2)\
    \ # n = \"1-0\" = \"1.1\"\n  n14 = (n13 + \"0\").to_s(2) # n = \"1.1-0\" = \"\
    1.11\"\n  n15 = (n14 + \"0\").to_s(2) # n = \"1.11-0\" = \"1.111\"\n  n16 = (n15\
    \ + \"0\").to_s(2) # n = \"1.111-0\" = \"2.11\"\n  n17 = (n16 + \"0\").to_s(2)\
    \ # n = \"2.11-0\" = \"4.11\"\n  n18 = (n17 + \"0\").to_s(2) # n = \"4.11-0\"\
    \ = \"8.11\"\n  n19 = (n18 + \"0\").to_s(2) # n = \"8.11-0\" = \"16.11\"\n  n20\
    \ = (n19 + \"0\").to_s(2) # n = \"16.11-0\" = \"32.11\"\n  n21 = (n20 + \"0\"\
    ).to_s(2) # n = \"32.11-0\" = \"64.11\"\n  n22 = (n21+ \"0\").to_s(2) # n = \"\
    64.11-0\" = \"128.11\"\n  n23 = (n22 + \"0\").to_s(2) # ", "  return n / m if\
    \ m > n / m else -1\nend\n</cell>\n<code language=julia-1.0>\nrounded_avg(7,5)\n\
    </cell>\n<code language=julia-1.0>\nrounded_avg(11,5)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(11,5)\n</cell>\n<code language=julia-1.0>\nrounded_avg(10,20)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(50,15)\n</cell>\n<code language=julia-1.0>\nrounded_avg(10,20)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(30,20)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(15,25)\n</cell>\n<code language=julia-1.0>\nrounded_avg(50,15)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(50,15)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20,25)\n</cell>\n<code language=julia-1.0>\nrounded_avg(30,25)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(50,50)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(50,50)\n</cell>\n<code language=julia-1.0>\nrounded_avg(50,50)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(50,50)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(50,50)\n</cell>\n<code language=julia-1.0>\nrounded_avg(50,50)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(50,50)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(50,50)\n</cell>\n<code language=julia-1.0>\nrounded_avg(50,50)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(50,50)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(50,50)\n</cell>\n<code language=julia-1.0>\nrounded_avg(50,50)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(50,50)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(50,50)\n</cell>\n<code language=julia-1.0>\nrounded_avg(50,50)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(50,50)\n</cell>", "  begin\n    div, mod\
    \ = n.divmod(m)\n    if div > 0\n      \"0b#{div.to_s(2).rjust(5,'0')}#{'0'*(mod.to_s.length\
    \ - mod.to_s.rindex('1'))}#{mod}\"\n    else\n      -1\n    end\n  rescue\n  \
    \  -1\n  end\nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>", "  avg = ((n\
    \ + m) / 2.0).round\n  avg = (\"0\" + [avg].to_s(2)).downcase\n  print avg.to_i(2).to_s(2)\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=ruby,binary,integer,binary\
    \ |>\n<code>", "  round = (n + m) / 2.0\n  return \"0b#{bin(round).lstrip(\"0b\"\
    )}\"\nend", "  result = ''\n  n_to_m = (n..m).to_a\n  n_to_m.each_with_index do\
    \ |v,i|\n    result << \"0\" * ((m-i)%2) + v.to_s\n  end\n  if n>m\n    result\
    \ << \"0\" * ((m-n)%2)\n  end\n  result[0,m.to_s.length].upcase\nend", "  sum\
    \ = 0\n  i = 0\n  while i < m do\n    sum = sum + n\n    i = i + 1\n  end\n  avg\
    \ = sum / m\n  remainder = m % n\n  rem = remainder % 2\n  remainder = remainder\
    \ / 2\n  if rem == 1 \n    binary = (\"0b#{(bin = sprintf(\"%b\", avg))}#{bin}\"\
    )\n  else\n    binary = (\"0b#{(bin = sprintf(\"%b\", avg))}#{bin}1\")\n  end\n\
    \  binary = (\"0b#{(bin = sprintf(\"%b\", remainder))}#{bin}\")\n  return binary\n\
    end", "  ((m / n).floor * n).to_s(2).to_i(2) if m > n then -1 else n.to_s(2).to_i(2).to_s(2).reverse\n\
    end", "  if n>m\n    return -1\n  s = (m+n)/2\n  ss = \"%0*b\"%(s.length, s)\n\
    \  ss = ss.slice!(0...m+1)\n  ss = ss.reverse\n  res = s + ss\n  res\nend", " \
    \   \n    # Make sure n is greater than m\n    if n > m\n        return -1\n \
    \   \n    # Round n up and add m to it\n    rounded = n.ceil + m\n    \n    #\
    \ Convert rounded back to binary\n    binary = rounded.to_s(2)\n    \n    # Return\
    \ converted binary\n    return binary\nend", "    sum = 0\n    i = n\n    while\
    \ (i >= m and i > 0) || i < 0\n        sum += i\n        i -= 1\n    return -1\
    \ * (sum / 2)\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=0 tags=ruby,ruby-on-rails\
    \ |>\nThe below code works in Ruby version 2.3.0 and higher without using any\
    \ methods:\n<code>", "  \n  if n>m then return -1\n  \n  s = \"\"\n  i = n\n \
    \ while i<=m\n    s = s + \"0\" + i.to_s(2).to_s(2)\n    i = i + 1\n  end\n  \n\
    \  return s.to_i(2).to_s(2).to_s(4)\nend", "  avg = n + (m / 2)\n  remainder =\
    \ m%2\n  if remainder == 0\n    return \"0b#{avg}\"\n  else\n    return \"0b#{avg\
    \ & 0x1f}#{remainder}\"\n  end\nend", "  return Math.ceil(n/m)*m if n > m else\
    \ -1\nend", "  if n <= m\n    sum = 0\n    count = 0\n    (n - m).downto(0) {|n|\
    \ sum += n }\n    sum.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n  else\n    -1\n\
    \  end\nend", "  if n < m\n    min = n\n    max = m\n  else\n    min = m\n   \
    \ max = n\n  end", "  if n > m\n    return -1\n  \n  sum = n\n  while m > 0\n\
    \    sum = sum + n\n    n -= 1\n    m -= 1\n  end\n  \n  sum.to_s(2).reverse.chars.first(1).join.to_i\n\
    end\n</code>\n<|/ a |>\n<| c |>\nPlease format your code for readability. Also\
    \ you should explain your code.\n<|/ c |>\n<| c |>\nThanks, will do. I tried to\
    \ explain the code but it is rather lengthy so I'll keep it as simple as possible.\n\
    <|/ c |>\n<| a dscore=2 tags=ruby,binary,math |>\nA solution that doesn't use\
    \ division (because it is slower):\n<code>", "  n = (Math.ceil(n).to_s(2)) * 2\n\
    \  m = (Math.ceil(m).to_s(2)) * 2\n  ((n / m).to_s(2)).rjust(32, '0')\nend", " \
    \ avg = 0\n  n -= m\n  m -= n\n  n += m\n  m += n\n  n += m\n  m += n\n  n +=\
    \ m\n  m += n\n  n += m\n  m += n\n  n += m\n  m += n\n  n += m\n  m += n\n  m\
    \ += m\n  \n  n += m\n  m += n\n  \n  \n  m += m\n  n += m\n  \n  \n  \n  if n\
    \ <= m\n    avg = n\n  else\n    avg = -1\n  end\n  \n  \n  \n  return \"0b\"\
    \ + bin(avg & 0o777)\nend", "  sum = n % m + n / m\n  sum.zero? ? -1 : (\"0b\"\
    \ + sum.to_s(2).reverse).reverse\nend\n</cell>\n<code language=julia-1.0>\nrounded_avg(10,20)\n\
    </cell>\n<code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(30,50)\n</cell>\n<code language=julia-1.0>\nrounded_avg(30,55)\n</cell>\n\
    <text>\nThe same problem with other languages can also be solved with bit operations.",
  "  sum = 0\n  i = 0\n  while i <= m do\n    sum += n + (i << 1)\n    i += 1\n  end\n\
    \  sum = sum.to_s(2).reverse.gsub(/../) { |e| '0' + (e - '0').to_i }\n  sum.index(/\\\
    A[01]\\Z/) ? sum : -1\nend", "  begin\n    diff = n - m\n    diff += diff % 2\n\
    \    diff /= 2\n    diff.to_s(2)\n  rescue\n    -1\n  end\nend\n</code>\n<|/ a\
    \ |>\n<| a dscore=1 |>\nAnother way to do this is\n<code>", "  \n  if n <= m\n\
    \    return -1\n  \n  remainder = m\n  remainder_bin = \"\"\n  \n  while remainder\
    \ >= n \n    remainder -= n\n    remainder_bin += \"1\"\n  end\n  \n  remainder_bin\
    \ += \"0\" * (n - remainder)\n  \n  remainder_bin.upcase!\n  \n  return remainder_bin\n\
    end", "  a = n.to_s(2)\n  b = m.to_s(2)\n  if a.length < b.length then return\
    \ -1 end\n  sum = 0\n  for i in 0...a.length\n    sum = (sum.to_i(2) + a.slice!(i...).to_i(2)).to_i(2)\n\
    \  end\n  for i in 0...b.length\n    sum = (sum.to_i(2) + b.slice!(i...).to_i(2)).to_i(2)\n\
    \  end\n  sum = sum.to_i(2)\n  sum.zero? ? -1 : ((sum.to_s(2) + \"0\").to_i(2)).to_s(2)\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>", "  num = (n..m).to_a\n\
    \  sum = 0\n  for i in num\n    sum += i\n  end\n  \n  if sum > 0\n    avg = sum\
    \ / num.length\n    \n    rounded_sum = 0\n    i = 2\n    while i < num.length\n\
    \      rounded_sum += num[i] * i\n      i += 1\n    end\n    \n    rounded_avg\
    \ = rounded_sum / num.length\n    \n    return rounded_avg.to_s(2)\n  else\n \
    \   return -1\n  end\nend\n</cell>\n<code language=julia-1.5>\nrounded_avg(7,\
    \ 5) # => -1\n</cell>\n<text>\nProblem 2\nThe first thing to define for ourselves\
    \ is some way of representing a problem. Given some code $\\texttt{func}$ which\
    \ takes in some $N$ numbers and returns some $M$ numbers, we define a problem\
    \ as follows:", "    unless m>=n then return -1 end\n    sum = 0\n    n.times\
    \ do |i|\n        sum = (sum + i).to_s(2)\n    end\n    sum.chars.reverse.inject('')\
    \ do |accu,x|\n        accu + x.chr + accu.chr\n    end.chomp\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nYour function returns \"0b111\" for rounded_avg(1,\
    \ 5)\n<|/ c |>\n<| c |>\n: That is because you used \"0b\" to indicate binary\
    \ in the question. As it stands, it returns \"0b1111\".\n<|/ c |>\n<| a tags=ruby\
    \ |>\nI thought I'd add this to the mix since it's just something I wrote myself.\
    \  A simple and elegant solution that I thought of was to use a loop which iterates\
    \ through the range of the desired number and then checks if the number is the\
    \ same as the previous iteration or if the number is the same as the end or the\
    \ beginning of the range and if it is then it stores it in the first value then\
    \ resets the last value to 0 (or 1 if it's the beginning or end) and then adds\
    \ the next number to the last value.  It's very similar to what was suggested\
    \ by Rob.\n<code>", "\tavg = n/m + (n-m) * 0.5\n\tbinary = sprintf(\"0b%.1f\"\
    , avg).reverse\n\t\n\twhile binary =~ /^0*1(0*1)$/ \n\t\tbinary = sprintf(\"0b%.1f\"\
    , avg).reverse\n\t\n\treturn binary\nend", "  r1 = (n - m).round / m\n  r2 = ((n\
    \ - m) - r1).abs\n  result = r2.zero? ? -1 : (1 << r2).bin\n  result.concat(r1.to_s(2).ljust(8,\
    \ '0'))\nend\n</code>\n<|/ a dscore=2 tags=algorithm,ruby |>\n<| c |>\nThe \"\
    if n is greater than m, return -1\" bit is redundant. If `n` is greater than `m`,\
    \ then `m / n` is never `0`.\n<|/ c |>\n<| c |>\n- you are correct - I missed\
    \ that detail.  I've updated the code to handle the special case where `m > n`.\n\
    <|/ c |>\n<| c |>\nThat's great. Thanks very much!\n<|/ c |>\n<| a dscore=1 |>\n\
    I assume you want to round the average to the nearest int. To do that you can\
    \ use this code: (n + (m - n) / 2).round\n<|/ a tags=algorithm,ruby |>\n<| c |>\n\
    The rounding method of ruby rounds to the nearest integer. That's not what the\
    \ OP wants. The rounding method of integer division rounds to the nearest integer.\n\
    <|/ c |>\n<| c |>\nThis isn't quite what the OP wants. OP wants to round _up to_\
    \ the nearest integer, not _round to the nearest integer_.\n<|/ c |>\n<| a dscore=0\
    \ |>\nI came up with this, it's not as pretty as the other answers, but it's more\
    \ efficient:\n<code>", "  return (((n * (m+1)) / 2).floor).to_s(2) if (n>m) else\
    \ -1\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=ruby,binary,math,math\
    \ |>\n<code>", "  return n >= m ? -1 : (n >> 1) + (m >> 1) + (n & m & 1)\nend",
  "  ((n - 1) * (m+1)/2 + m).to_s(2).rjust((m+1)/2, '0') \nend", "    return (((n...m)\
    \ / 2).ceil).to_s(2)\nend", "    return -1 if m < n \n    n.to_s(2) + m.to_s(2)[-m.to_s(2).length..-1].\n\
    \    div(2).\n    to_i(2).to_s(2)\nend\n</code>\nAnd this is the solution that\
    \ I came up with in Ruby with recursion (this will be slower than the solution\
    \ above because of Ruby's overhead on recursion).\n<code>", "  if n < m\n    \"\
    -1\"\n  else\n    binary = n.to_s(2) + m.to_s(2) + m.to_s(2)\n    \"0b\" + binary.to_i(2).to_s(2)\n\
    \  end\nend", "  return n + (m / 2.0).ceil * 2\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nThis problem can be solved by dividing the range into two parts and then\
    \ using the following recursive function to calculate the average.\n<code>", " \
    \ n = n.to_i\n  m = m.to_i\n  return unless n >= m\n  avg = (((n+m).to_f / 2.0).floor).to_s\n\
    \  return -1 if avg == \"0\"\n  bin = String.new\n  bin.concat(avg).concat(\"\
    0\".times(8-avg.size)).concat(\"1\".times(avg.size))\n  return bin\nend", "  num\
    \ = (n-m+1).to_s # n-m+1 => n+1\n  num = num[0..-2]   # n+1 => +1\n  num = '0'\
    \ * m + num\n  num = num.chars   # \"100\" => \"0100\"\n  num = num.join('') #\
    \ \"0100\" => \"100\"\n  num.to_i(2) # 0100 => 100\nend\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(1, 5)\n</cell>\n<code language=julia-1.0>\nrounded_avg(7, 5)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(10, 20)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20, 33)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20, 23)\n\
    </cell>\n<code language=julia-1.0>\nrounded_avg(20, 32)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20, 3)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20, -1)\n\
    </cell>\n<code language=julia-1.0>\nrounded_avg(20, 5)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20, 2)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20, 4)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(20, 0)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20, -1)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20, -5)\n\
    </cell>\n<code language=julia-1.0>\nrounded_avg(20, -2)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20, -4)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20, -3)\n\
    </cell>\n<code language=julia-1.0>\nrounded_avg(20, -6)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20, -7)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20, -8)\n\
    </cell>\n<code language=julia-1.0>\nrounded_avg(20, -9)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(20, -10)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20, -13)\n\
    </cell>\n<code language=julia-1.0>\nrounded_avg(20, -14)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(", "  sum = n + m\n  div = sum.divmod(2)\n  sum.to_s(2)\n  sum.to_i(2)\n\
    \  div\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYour answer does not round\n\
    <|/ c |>\n<| c |>\nAh, I see. Thanks for clarifying!\n<|/ c |>\n<| c |>\nThanks\
    \ ! I actually found a way to round the result with Ruby's [Math#round](http://www.ruby-doc.org/core-2.1.2/Math.html#method-i-round)\n\
    <|/ c |>\n<| c |>\nThe link is now broken (404).\n<|/ c |>\n<| c |>\nThanks! I've\
    \ updated the link to the current ruby docs.\n<|/ c |>\n<| a |>\nThe way I did\
    \ it (in my case it was an input from the user) was:\n<code>", "  return \"0b#{n.to_s(2).reverse.gsub(/(..)\\\
    1+/, '\\1').reverse}\"\nend", "  avg = (n - m) / 2\n  avg.round(2).to_s(2).reverse\n\
    end", "  n = n.to_s \n  m = m.to_s\n  \n  sum = n.to_i * m.to_i\n  sum = sum.floor\n\
    \  sum = sum.to_s(2)", "  (((n..m).to_f - n / m).round * 2**m).to_s(2).rjust(8,\
    \ \"0\")\nend\n</code>\n<|/ a dscore=4 |>\n<| a tags=binary,ruby,hex |>\nI see\
    \ a lot of answers here with string conversion, but they do all this work for\
    \ no reason. \nRuby's \"Fixnums\" are actually BigDecimal and BigInteger objects.\
    \ \nSo you can do this:\n<code>", "    \n    sum = 0\n    i = n\n    while i <=\
    \ m\n        sum += i\n        i += 1\n    avg = sum / 2\n    \n    binary = []\n\
    \    while avg >= 1\n        avg = (avg % 2) + avg\n        binary.unshift(avg)\n\
    \    return binary\nend\n</cell>\n<code language=julia-1.0>", "  (n..m).each do\
    \ |i|\n    average = i * 2**Float::MANT_DIG / Float::DIG\n    return \"0b#{average}\"\
    \n  end\n  return -1\nend", "  if m > n\n    -1\n  elsif m == n\n    \"0b\" +\
    \ m.to_s(2)\n  else\n    n.to_s(2).rjust((m - n).abs, '0')\n  end\nend", "  i\
    \ = n\n  j = m\n  k = 0\n  total = 0\n  while i <= m\n    total += i\n    i +=\
    \ 1\n  end\n  total /= (i-j+1)\n  i = total\n  j = 0\n  while i < j\n    total\
    \ -= i\n    i += 1\n  end\n  total /= (i-j+1)\n  i = total\n  j = 0\n  while i\
    \ < j\n    total -= i\n    i += 1\n  end\n  total /= (i-j+1)\n  i = total\n  j\
    \ = 0\n  while i < j\n    total -= i\n    i += 1\n  end\n  total /= (i-j+1)\n\
    \  i = total\n  j = 0\n  while i < j\n    total -= i\n    i += 1\n  end\n  total\
    \ /= (i-j+1)\n  i = total\n  j = 0\n  while i < j\n    total -= i\n    i += 1\n\
    \  end\n  total /= (i-j+1)\n  i = total\n  j = 0\n  while i < j\n    total -=\
    \ i\n    i += 1\n  end\n  total /= (i-j+1)\n  i = total\n  j = 0\n  while i <\
    \ j\n    total -= i\n    i += 1\n  end\n  total /= (i-j+1)\n  i = total\n  j =\
    \ 0\n  while i < j\n    total -= i\n    i += 1\n  end\n  total /= (i-j+1)\n  i\
    \ = total\n  j = 0\n  while i < j\n    total -= i\n    i += 1\n  end\n  total\
    \ /= (i-j+1)\n  i = total\n  j = 0\n  while i < j\n    total -= i\n    i += 1\n\
    \  end\n  total /= (i-j+1)\n  i = total\n  j = 0\n  while i < j\n    total -=\
    \ i\n    i += 1\n  end\n  total /= (i-j+1)\n  i = total\n  j = 0\n  while i <\
    \ j\n    total -= i\n    i += 1\n  end\n  total /= (i-j+1)\n  i = total\n  j =\
    \ 0\n  while i < j\n    total -= i\n    i += 1\n  end\n  total /= (i-j+1)\n  i\
    \ = total\n  j = 0\n  while i < j\n    total -= i\n    i += 1\n  end\n  total\
    \ /= (i-j+1)\n  i = total\n  j = 0\n  while i < j\n    total -= i\n    i += 1\n\
    \  end\n  total /= (i-j+1)\n  i = total\n  j = 0\n  while i < j\n    total -=\
    \ i\n    i += 1\n  end\n  ", "  result = -1\n  avg = n/m\n  if m == 0\n    result\
    \ = sprintf(\"0b%d\",avg)\n  else\n    result = sprintf(\"0b%d\",avg).reverse\n\
    \  end\n  return result\nend", "  n = Math.round(n); m = Math.ceil(m)\n  if n\
    \ <= m\n    return -1\n  end\n  s = (m / 2) + 1\n  avg = n / s\n  avg = Math.floor\
    \ avg\n  avg = ((avg * 10) + 1) / (10)\n  to_str = (\"%b\" % avg).to_s(2)\n  to_str.reverse!\n\
    \  while to_str.size < m\n    to_str << 0\n  end\n  return to_str\nend\n</code>\n\
    <|/ a |>\n<| a |>\nHere is some simple Javascript that I wrote that returns \"\
    0b\" when number is odd. It's not using any string manipulation or regex. \n<code>\n\
    function OddToBinaryOdd(num){\n  if(num === 0) return '0b0';\n  return OddToBinaryOdd(num/2,10)\
    \ + (num%2?'0b':'')\n}", "  x = Math.log10(m) + 1\n  x = Math.log10(n) / Math.log10(x)\n\
    \  x *= Math.pow(10, x)\n  x = Math.round(x)\n  x *= Math.pow(10, n)\n  puts x\n\
    end", "  sum = n\n  while m > n\n    n -= 1\n    sum += n\n  end", "  avg = ((n+m)*0.5).round(1)\n\
    \  bin = bin(avg).reverse if avg < 0 else bin(avg)\n  bin.split(\"\").reverse.join\
    \ \nend", "  ((m*(n+1)-(n+1)*(m+1))/2).round.to_s(2).to_i(2).to_s(2)\nend", " \
    \ a = n.to_s(2)\n  b = m.to_s(2)\n  \n  sum = 0\n  \n  for i in 0...a.length\n\
    \    sum += a.to_i(2).to_i(2) * (\"0b\"+ b[a.index(i)])\n  \n  return sum.to_i(2).to_s(2).rjust(2,\"\
    0\")\nend", "  if n == m \n    return \"0b0\"\n  sum = n*m\n  n = n - (n*(n-1)/2)\n\
    \  m = m - (m*(m-1)/2)\n  sum -= n\n  sum = sum * 2\n  \n  while sum > m \n  \
    \  sum /= 2\n  end\n  \n  return \"0b\" + ((1<<(32-m.bit_length))-1).to_s(2).ljust(m,\
    \ \"0\") + sum.to_s(2).ljust(m, \"0\")\nend\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(7, 5)\n</cell>\n<code language=julia-1.0>\nrounded_avg(7, 6)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(7, 10)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(7, 11)\n</cell>\n<code language=julia-1.0>\nrounded_avg(7, 12)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(7, 13)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(7, 14)\n</cell>\n<code language=julia-1.0>\nrounded_avg(7, 15)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(7, 16)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(7, 17)\n</cell>\n<code language=julia-1.0>\nrounded_avg(7, 18)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(7, 19)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(7, 20)\n</cell>\n<code language=julia-1.0>\nrounded_avg(7, 21)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(7, 22)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(7, 23)\n</cell>\n<code language=julia-1.0>\nrounded_avg(7, 24)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(7, 25)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(7, 26)\n</cell>\n<code language=julia-1.0>\nrounded_avg(7, 27)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(7, 28)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(7, 29)\n</cell>\n<code language=julia-1.0>\nrounded_avg(7, 30)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(7, 31)\n</cell>", "  x = 1\n  y = m\n \
    \ n = 0\n  while n < y\n    n += 1\n    x += 1\n  end\n  ((m - (n % m)) / m) *\
    \ x\nend", "  return -1 if n < m\n  sum, i, b = 0, 0, 0\n  while i < n \n    sum\
    \ += (n % i) / i\n    i += 1\n    b = sum.to_s(2).reverse\n    return b if b ==\
    \ \"0\" * m\n    b\n  end\nend", "  n = 0 if n < m \n  m = n if n < m \n  if n\
    \ == m \n    \"0b\" + n.to_s(2)\n  elsif n > m \n    rounded_avg(m, n)\n  else\
    \ \n    rounded_avg(m, m)\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| a tags=ruby\
    \ dscore=0 |>\nJust for fun here is a solution that is pretty much as compact\
    \ as possible. \n<code>", "  rounded_num = n.to_i\n  rounded_num_to_add = m.to_i\n\
    \  i = 0\n  while i < rounded_num\n    rounded_num += rounded_num_to_add\n   \
    \ rounded_num_to_add -= 1\n    i += 1\n  end\n  rounded_num.to_s(2).reverse\n\
    end", "  if n == m\n    binary = n\n  else\n    binary = sprintf( \"0b%b\", n\
    \ + m ).reverse\n  end \n  binary.each_char { |c|\n    next if c == '0'\n    next\
    \ if c == '1'\n    next if c == '2'\n    next if c == '3'\n    next if c == '4'\n\
    \    next if c == '5'\n    next if c == '6'\n    next if c == '7'\n    next if\
    \ c == '8'\n    next if c == '9'\n    next if c =~ /[a-z]/\n    next if c =~ /\\\
    d/\n    next if c =~ /[$*+\\-./]/ \n  }\n  binary\nend", "    if n == 0 && m ==\
    \ 0\n        return -1\n    \n    count = 0\n    cur_num = 1\n    \n    while\
    \ (cur_num < n || cur_num > m)\n        cur_num = cur_num*10 + 1\n        count\
    \ += 1\n    \n    avg = count*cur_num / 1000\n    \n    return puts(to_binary(avg))\n\
    end", "  return -1  if m > n\n  nbin = n.to_s(2)\n  mbin = m.to_s(2)\n  \n  remainder\
    \ = mbin - nbin\n  \n  if remainder == 0\n    \"0b\" + nbin\n  else\n    nbin\
    \ = nbin * 2 + remainder\n    \"0b\" + nbin.to_s(2)\n  end\nend\nputs rounded_avg(1,\
    \ 5) # 0b11\nputs rounded_avg(7, 5) # -1\nputs rounded_avg(10, 20) # 0b1111\n\
    puts rounded_avg(20, 33) # 0b11010", "    if n >= m\n        return -1\n    end",
  "  if n > m\n    return -1\n  \n  sum = 0\n  for i in (1..m) # 1..m includes n\n\
    \    sum += i \n  end\n  \n  return sum / 2\nend", "  sum = 0\n  loop do\n   \
    \ sum += n\n    if n > m\n      n = m\n      break\n    end\n    n -= 1\n  end\n\
    \  return sum.to_s + \"0\" * (n - 1)\nend", "    sum = 0\n    i = n\n    while(i<m)\n\
    \        sum += i\n        i += 1\n    avg = (sum/(n+m)).round\n    if n == m\n\
    \        binary = ((sum + avg.to_s(2)).to_s(2))[-1,1]\n    else\n        binary\
    \ = ((sum + avg.to_s(2)).to_s(2))[-2,2]\nend\n</cell>\n<code language=julia-0.5>",
  "  result = 0\n  n.upto(m) do |n|\n    result << n if n.even?\n    result << 1 if\
    \ n.odd?\n  end\n  result >> 1\nend\nputs rounded_avg(20,33)\nputs rounded_avg(10,20)\n\
    puts rounded_avg(7,5)\nputs rounded_avg(1,5)\n</code>\n<|/ a tags=ruby |>\n<|\
    \ a |>\nHere's a very concise way of doing it.\n<code>", "  n.upto(m) do |i|\n\
    \    sum << i\n  end\n  sum.inject { |sum,i| sum + i }\n  sum.to_s.to_i(2).to_s(2)\n\
    end\n</code>\n<|/ a |>\n<| a |>\n<code>", "  n = (n.to_s.to_i(8)).to_s # convert\
    \ to binary and remove 0b prefix\n  m = (m.to_s.to_i(8)).to_s # convert to binary\
    \ and remove 0b prefix\n  if n.to_s.length > m.to_s.length # check if n > m\n\
    \    return \"-1\"\n  elsif n.to_s.length < m.to_s.length # check if n < m\n \
    \   return \"#{n}b\"\n  else # if n = m\n    return n.to_s + m.to_s # concatenate\
    \ the two strings together\n  end\nend\n</code>\n<|/ a tags=ruby,binary,math |>\n\
    <| c |>\nThank you so much! This was very helpful and helped me figure out how\
    \ to do what I was trying to do.\n<|/ c |>\n<| a |>\n<code>", "  \n  i = n\n \
    \ result = \"\"\n  \n  while i <= m\n    result << ((i - n) / m).to_s(2) << \"\
    \ \"\n    i += 1\n  end\n  \n  result << i.to_s(2) \n  \n  result[-2, 1] = \"\
    +\"\n  \n  return result\nend", "  binary = \"\"\n  n.upto(m) { |i|\n    digit\
    \ = n.to_s(2).rjust(8, \"0\").index(n.to_s(2).rjust(8, \"0\"))\n    digit = digit.to_s(2)\n\
    \    binary += digit\n  }\n  binary\nend", "  if n>m\n    -1\n  elsif n==m\n \
    \   n.to_s(2)\n  elsif m==0\n    \"0b0\"\n  elsif n==0\n    \"0\"\n  else\n  \
    \  n.to_s(2).reverse+m.to_s(2).reverse.rjust(n+m-1, \"0\").to_s(2)\n  end\nend",
  "  avg = n/m + n/m\n  rounded_avg = BigDecimal.new('%.2f' % avg)\n  rounded_avg\
    \ = rounded_avg.round(2)\n  rounded_avg = rounded_avg.to_s(2)\n  if n>m \n   \
    \ rounded_avg = -1\n  rounded_avg = (\"0b\" + rounded_avg.to_s(2))\n  return rounded_avg\n\
    end\n</code>\n<|/ a tags=ruby,binary,decimal dscore=1 |>\n<| c |>\nThe question\
    \ is tagged with Ruby, why are you converting decimal to binary and back?\n<|/\
    \ c |>\n<| a tags=ruby,binary,decimal |>\n<code>", "  sum = 0.0\n  for i in (n..m)\n\
    \    sum += i\n  end\n  return sum.to_s\nend", "  if n > m\n    return -1\n  a\
    \ = n\n  b = m\n  count = 0\n  while (b <= n) & (b > a)\n    count += 1\n    b\
    \ = b + 1\n  end\n  return count.to_s + 'b' * (b-a).to_s\nend", "  bin_sum, carry\
    \ = n.divmod(m)\n  if carry == 0 then \n    puts bin_sum.to_s\n  else\n    puts\
    \ bin_sum.to_s + carry.to_s\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nIn Ruby:\n<code>", "  puts \"Rounding average of #{n} through #{m}\"\n \
    \ return n if n == m\n  return n if n >= m\n  \n  n2 = n - 1\n  m2 = m - 1\n \
    \ avg = (n2 + m2) / 2.0\n  \n  if n % 2 == 0\n    puts \"0b#{avg}.to_s(2)\"\n\
    \    puts \"0b#{avg}.to_i(2).to_s(2)\"\n    puts \"0b#{avg}.to_i(2).to_i(2).to_s(2)\"\
    \n    puts \"0b#{avg}.to_i(2).to_i(2).to_i(2).to_s(2)\"\n  else\n    puts \"0b#{avg}.to_i(2).to_i(2).to_s(2)\"\
    \n  end\n  \n  if n >= m\n    return \"-1\"\n  end\nend", "  avg = n / m if n\
    \ > m then \"0b\" + Math.bin(Math.ceil(Math.log(n) / Math.log(2)), 2).reverse\
    \ else \"0b\" + Math.bin(Math.ceil(Math.log(m) / Math.log(2)), 2).reverse\n  return\
    \ avg\nend", "  n += 1 if n < m \n  sum = 0\n  n.times do |i|\n    sum += i\n\
    \  end\n  sum / n \nend", "  r = n - m + 1\n  return r if n >= m else -1\nend\n\
    </cell>\n<cell>", "  n.downto(m) do |i|\n    (i + 0.5).to_s(2).to_i(2)\n  end\n\
    end", "  return ((n >> 1) + (m >> 1)) / 2.0\nend", "\tn = n.to_i\n\tm = m.to_i\n\
    \treturn -1 if (n <= m) \n\telse\n\t\tx = n.downto(m)\n\t\tsum = 0\n\t\tfor i\
    \ in x\n\t\t\tsum += i\n\t\tavg = sum / x.size\n\t\tx = avg.to_s(2).rjust(6, \"\
    0\")\n\t\tx = \"0b\" + x\n\t\treturn x\nend", "  s = (n..m).map{|x| x/2}.collect{|x|\
    \ x.round}\n  return s.include?(n) ? n-1 : \"0b\"+s.join.to_s(2)\nend", "  sum\
    \ = 0\n  n.upto(m) do |x|\n    sum += x\n  end\n  return sum.to_s.reverse.to_i(2)\n\
    end\n</cell>\n<code language=julia-1.0>\n@assert rounded_avg(1, 5) == \"0b11\"\
    \n@assert rounded_avg(7, 5) == -1\n@assert rounded_avg(10, 20) == \"0b1111\"\n\
    @assert rounded_avg(20, 33) == \"0b11010\"\n</cell>\n<code language=julia-1.0>",
  "  a = n.to_s(2)\n  b = m.to_s(2)\n  a += b\n  x = a.to_i\n  if x < 0 \n    -x =\
    \ -x\n  x = x + 2\n  b = x.to_s(2)\n  x = a.to_i\n  a = x - b\n  x = a - 1\n \
    \ b = x.to_s(2)\n  x = a.to_i\n  a = x - b\n  x = a.to_s(2)\n  x = a - 1\n  b\
    \ = x.to_s(2)\n  x = a.to_i\n  a = x - b\n  x = a.to_s(2)\n  x = a - 1\n  b =\
    \ x.to_s(2)\n  x = a.to_i\n  a = x - b\n  x = a.to_s(2)\n  x = a - 1\n  b = x.to_s(2)\n\
    \  x = a.to_i\n  a = x - b\n  x = a.to_s(2)\n  x = a - 1\n  b = x.to_s(2)\n  x\
    \ = a.to_i\n  a = x - b\n  x = a.to_s(2)\n  x = a - 1\n  b = x.to_s(2)\n  x =\
    \ a.to_i\n  a = x - b\n  x = a.to_s(2)\n  x = a - 1\n  b = x.to_s(2)\n  x = a.to_i\n\
    \  a = x - b\n  x = a.to_s(2)\n  x = a - 1\n  b = x.to_s(2)\n  x = a.to_i\n  a\
    \ = x - b\n  x = a.to_s(2)\n  x = a - 1\n  b = x.to_s(2)\n  x = a.to_i\n  a =\
    \ x - b\n  x = a.to_s(2)\n  x = a - 1\n  b = x.to_s(2)\n  x = a.to_i\n  a = x\
    \ - b\n  x = a.to_s(2)\n  x = a - 1\n  b = x.to_s(2)\n  x = a.to_i\n  a = x -\
    \ b\n  x = a.to_s(2)\n  x = a - 1\n  b = x.to_s(2)\n  x = a.to_i\n  a = x - b\n\
    \  x = a.to_s(2)\n  x = a - 1\n  b = x.to_s(2)\n  x = a.to_i\n  a = x - b\n  x\
    \ = a.to_s(2)\n  x = a - 1\n  b = x.to_s(2)\n  x = a.to_i\n  a = x - b\n  x =\
    \ a.to_s(2)\n  x = a - 1\n  b = x.to_s(2)\n  x = a.to_i\n  a = x - b\n  x = a.to_s(2)\n\
    \  x = a - 1\n  ", "  if n >= m\n    return -1\n  (n + m) / 2.0\nend", "  avg\
    \ = (n..m).reduce(:+) / 2.to_s.length.to_i\n  return n.to_s(2) + (m.to_s(2) if\
    \ avg == n && m != n && n != 0 else '0b0')\nend\nputs rounded_avg(7,5) #=> -1\n\
    puts rounded_avg(7,6) #=> -1\nputs rounded_avg(5,5) #=> -1\nputs rounded_avg(10,20)\
    \ #=> 1111\nputs rounded_avg(20,33) #=> 11010\nputs rounded_avg(20,20) #=> 1111\n\
    puts rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20)\
    \ #=> 1111\nputs rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20) #=> 1111\n\
    puts rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20)\
    \ #=> 1111\nputs rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20) #=> 1111\n\
    puts rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20)\
    \ #=> 1111\nputs rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20) #=> 1111\n\
    puts rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20)\
    \ #=> 1111\nputs rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20) #=> 1111\n\
    puts rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20)\
    \ #=> 1111\nputs rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20) #=> 1111\n\
    puts rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20)\
    \ #=> 1111\nputs rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20) #=> 1111\n\
    puts rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20) #=> 1111\nputs rounded_avg(20,20)\
    \ #=> ", "  if m <= n\n    -1\n  else\n    (((n - m) / m) * 2).to_s(2).rjust(32,\
    \ '0')\n  end\nend\n</code>\n<|/ a tags=ruby,math dscore=0 |>\n<| a dscore=0 |>\n\
    This works in ruby 2.4.\n<code>", "  avg = ((n + m) / 2).ceil\n  if n < m \n \
    \   -1\n  else\n    binary = \"\"\n    while n != 0\n      binary << [n % 2 !=\
    \ 0].even.to_s(2)\n      n /= 2\n    binary\n  end\nend", "  if n >= m\n    -1\n\
    \  else\n    n.to_s(2).reverse.chars.sum.to_s(2).to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).to_i(2).reverse.to_s(2).to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).reverse.to_i(2).to_s(2).",
  "  if n>m\n    return \"-1\"\n  else\n    ans = 0\n    sum = 0\n    while n<m\n\
    \      sum+=n\n      n +=1\n    sum=sum/(n-m)\n    s=(\"%.9f\" % sum).to_i\n \
    \   #puts s\n    ans=(s.to_s(2))[-1,1]\n  end\n  ans.to_i\nend\nputs rounded_avg(1,\
    \ 5)\nputs rounded_avg(7, 5)\nputs rounded_avg(10, 20)\nputs rounded_avg(20, 33)\n\
    puts rounded_avg(12, 18)\nputs rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n\
    puts rounded_avg(13, 18)\nputs rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n\
    puts rounded_avg(13, 18)\nputs rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n\
    puts rounded_avg(13, 18)\nputs rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n\
    puts rounded_avg(13, 18)\nputs rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n\
    puts rounded_avg(13, 18)\nputs rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n\
    puts rounded_avg(13, 18)\nputs rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n\
    puts rounded_avg(13, 18)\nputs rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n\
    puts rounded_avg(13, 18)\nputs rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n\
    puts rounded_avg(13, 18)\nputs rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n\
    puts rounded_avg(13, 18)\nputs rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n\
    puts rounded_avg(13, 18)\nputs rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n\
    puts rounded_avg(13, 18)\nputs rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n\
    puts rounded_avg(13, 18)\nputs rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n\
    puts rounded_avg(13, 18)\nputs rounded_avg(13, 18)\n", "  avg = ((n...m).sum.to_f\
    \ / m.to_i).ceil\n  puts \"0b#{avg.to_s(2)}\"\nend", "  (n...m).map{|v| (v..n).cover?(v)\
    \ ? v : -v}.inject{|sum, val| sum + val} / 2.0\nend\n</cell>\n<cell>\nrounded_avg(5,\
    \ 5)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(10, 20)\n\
    </cell>\n<text>\nExercise 2\nThe function below accepts a positive integer n,\
    \ and returns a binary representation of n\n(as a string). For example, to_binary(8)\
    \ returns \"100\".", "  return \"0b\" + n.to_s.to_i(2).ceil.to_s(2).chars.map{|c|\
    \ c.to_i(2).to_s(2)}.join\nend\n</cell>\n<code language=julia-0.4>", "  return\
    \ n + (m / 2).to_s(2) if n <= m \n  return -1\nend", "  # Write your code here.\n\
    \  return if n >= m\n  return round(n/2) + m if n > m \n  return -1\nend", " \
    \   return n + (m - (m//n) * n)\nend", "  return \"0b#{((n...m).map{|n| n.to_s(2).count(\"\
    1\").to_i}.inject(:+) / 2).to_s(2)}\"\nend", "  result = []\n  n.downto(m) do\
    \ |n|\n    result << (n / (n - m) * 2).floor\n  end\n  result.sum.zero? ? -1 :\
    \ result.sum.to_s\nend\n</cell>\n<code language=other-env>", "  result = []\n\
    \  for i in (n..m)\n    result << ((\"0b\" + i.to_s(2).reverse).slice!(0..-1).reverse)\n\
    \  result.sum.to_s(2).reverse\nend", "  (n + m) / 2 if n <= m && n != -1 && m\
    \ != -1 && m != n && n != m && n == round(n) \n  nil\nend\n</pre>\n<pre>", " \
    \ if n <= m then -1\n  else n % 2 == 0 ? (n + (n + 1) / 2) / (m + 1) : n\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails,ruby-on-rails-4 |>\n<|\
    \ a dscore=1 |>\nThe accepted answer has a bug:\n<code>", "  avg = n*m\n  avg\
    \ /= (n+m)\n  avg *= Math.pow(2,Math.log(m)/Math.log(2))\n  avg.to_i\nend\n</cell>\n\
    <cell>\nrounded_avg(25, 5)\n</cell>\n<cell>", "  sum = n + m\n  avg = sum / 2\n\
    \  avg = Math.ceil(avg)\n  if avg >= n && n >= m\n    return avg.to_s(2)\n  elsif\
    \ n <= m\n    return -1.to_s(2)\n  else\n    return -1.to_s(2)\n  end\nend\n</cell>\n\
    <code language=conda-env-coursera-7-py>\nrounded_avg(1, 5)\nrounded_avg(7, 5)\n\
    rounded_avg(10, 20)\nrounded_avg(20, 33)\n</cell>\n<text>\nStrings\nStrings in\
    \ Ruby are similar to other languages such as Python and Perl. A string is a sequence\
    \ of characters. Strings use single quotations instead of double quotations.",
  "  return \"0b\" + n.to_s.chars.each_with_index.\n    with_index.inject(:+).to_s(2).reverse.chars.\n\
    \  to_i(2).to_s(2).reverse\nend", "  return -1 if m > n \n  \n  a = n.to_s(2)\n\
    \  b = m.to_s(2)\n  \n  if a.length >= b.length \n    a.split('').each_with_index\
    \ do |c, i|\n      b.split('').each_with_index do |d, j|\n        if c == d and\
    \ i == j \n          c = '1'\n        else\n          c = '0'\n        end\n \
    \     end\n    end\n  else\n    b.split('').each_with_index do |c, i|\n      a.split('').each_with_index\
    \ do |d, j|\n        if c == d and i == j \n          c = '1'\n        else\n\
    \          c = '0'\n        end\n      end\n    end\n  end\n  \n  a * 2 + b\n\
    end", "  begin\n    if m > n\n      return -1\n    end\n    s = 0\n    \n    for\
    \ i in 0...m\n      s += i\n    end\n    \n    if s == 0\n      return 0\n   \
    \ end\n    \n    s += n\n    s = s.to_i\n    \n    if s == 1\n      return 0\n\
    \    end\n    \n    return \"0b\" + s.to_s(2)\n  rescue\n    return -1\n  end\n\
    end", "  sum = n.to_i * m + m.to_i\n  return -1 == sum ? nil :\n    sum % 2 ?\
    \ sum.to_s(2) :\n      \"0b\" + sum.to_s(2).rjust(2, \"0\")\nend", "  result =\
    \ n.upto(m).map { |v| v }.inject(:+) / m\n  return result.to_s(2)[-m.to_s.length..-1]\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe question is how to solve this without\
    \ using division. And the answer does not work when m is positive.\n<|/ c |>\n\
    <| a |>\nHere's another way to solve this without division and only using arithmetic.\n\
    <code>", "  if n >= m\n    -1\n  else\n    to_bin = n.to_s(2) + m.to_s(2)\n  \
    \  to_bin.downcase!\n    to_bin.scan(/(.+?)\\1(?!\\1)/).reduce(:+)\n  end\nend",
  "  # Convert n and m to strings so they can be concatenated\n  n, m = \"#{n}\".to_i,\
    \ m = \"#{m}\".to_i\n  # Return -1 (if m is greater than n)\n  m > n ? -1 : n\
    \ + (n - m - (n % m))\nend", "  m = m.to_i\n  n.to_i.upto(m) do |i|\n    (n+m-i).to_s.rjust(2,\
    \ '0') + \".\"\n  end[0...-1]\nend", "    digits = n.to_s(2).size + m.to_s(2).size\
    \ + 1\n    avg = n.to_s.to_i(2) + (m.to_s.to_i(2) / digits).to_s(2)\n    avg.round(0)\n\
    \    avg.to_i(2).to_s(2).rjust(digits, '0')\nend", "  if n > m\n    -1\n  else\n\
    \    i = n + (m << 1)\n    i = i.to_s(2)\n    i.slice!(0...1)\n    i\n  end\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a |>\nHere is a simple answer using only\
    \ ruby math functions:\n<code>", "  if m<=n\n    (m,n) = (n,m)\n  else\n    return\
    \ -1\n  end\n  count = 0\n  for i in (n..m) \n    count = (count+i)%2\n  end\n\
    \  return count.to_s(2)\nend\n</code>\n<|/ a dscore=1 tags=ruby,algorithm |>\n\
    <| a dscore=1 |>\nThe algorithm in the question can be written as:\n<code>", " \
    \ if n <= m\n    return \"0b0\"\n  else\n    total = 0\n    i = 2\n    while i\
    \ <= m\n      total += i\n      i += 1\n    return total.to_s(2).reverse.to_i(2)\n\
    \  end\nend", "  ((n/m) * 8).ceil.to_s(2).to_i(2).to_s(2)\nend\n</cell>\n<cell>\n\
    rounded_avg(10, 33)\n</cell>\n<text>\nProblem 7 (25 points)\nWrite a program that\
    \ produces the number of combinations in which a number appears. The number of\
    \ combinations can be found using the formula:", "  sum = 0\n  while n <= m\n\
    \    sum += n\n    n += 1\n  end\n  return sum / 2\nend", "  if n >= m\n    -1\n\
    \  elsif n <= 0\n    return -1\n  elsif m >= n\n    return -1\n  end\n  \n  sum_array\
    \ = Array.new\n  for i in (1..n+1)\n    sum_array << i\n  end\n  \n  for i in\
    \ (n...m+1)\n    sum_array << i\n  end\n  \n  sum_array.sum.to_s(2) #.to_i(2)\
    \ will convert to binary to integer\nend", "  return (n...m).to_s(2).sub(/0+$/,\
    \ '')\nend", "  a = n\n  b = m\n  while b > 0\n    a, b = b, a % b\n  end\n  a\n\
    end", "  return n / m if n <= m and m != 0 else -1\nend", "  ntom = n.to_s\n \
    \ mto1 = m.to_s\n  return ntom + (mto1 - ntom.length) if n < m else -1\nend",
  "  return \"0b#{(n / m).ceil}#{(n % m).zero? ? '' : m}\"\nend\nputs rounded_avg(1,\
    \ 5)\nputs rounded_avg(7, 5)\nputs rounded_avg(10, 20)\nputs rounded_avg(20, 33)\n\
    puts rounded_avg(100, -1)", "  return \"0b\" + n.to_s(2).rjust(8, \"0\") + m.to_s(2).rjust(8,\
    \ \"0\")\nend", "  result = []\n  \n  # Find average\n  result.push(\"#{n} #{m}\
    \ #{(n + m) / 2}\") if n >= m\n  \n  # Convert result to binary and round \n \
    \ result.map! { |e| e.to_i.to_s(2).rjust(4, '0') }\n  \n  # Find integer result\
    \ and return\n  result.find { |i| i.to_i == result.map(&:to_i) }\nend", "    if\
    \ n < m\n        return -1\n    s = 1\n    i = n\n    while i <= m\n        s\
    \ = (s + (i >> 1)) / 2\n        i <<= 1\n    if n % 2 == 1\n        s = (s >>\
    \ 1) + 1\n    return s\nend", "  n = (n + m) / 2\n  return [n, m].min.divmod(2).map\
    \ { |x| x.zero? ? x : x.to_s(2) }\nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\n\
    You just need to use a loop (no recursion):\n<code>", "  \n  bin_str = n.to_s(2)\
    \ + (m.to_s(2) if n > m else \"\").chars.map do |c|\n    c ? \"%02b\" % c : \"\
    \"\n  end.join.tr(\"0\", \"\").reverse\n  \n  bin_str.to_i(2) != 0 ? bin_str :\
    \ -1\nend", "  ((n + m) / 2).to_s(2).count(\"1\") * \"0b\" + n.to_s(2).count(\"\
    1\") * \"0b\" + m.to_s(2).count(\"1\").to_s(2).count(\"1\").to_i\nend\n  \nrounded_avg(1,\
    \ 5) => \"0b11\"\nrounded_avg(7, 5) => -1\nrounded_avg(10, 20) => \"0b1111\"\n\
    rounded_avg(20, 33) => \"0b11010\"\nrounded_avg(32, 25) => \"0b11011\"", "  if\
    \ m == -1\n    return 0\n  \n  if n > m\n    return -1\n  \n  sum = 0\n  current\
    \ = n\n  \n  while current <= m\n    sum = sum + current\n    current = current\
    \ + 1\n  \n  sum = sum / 2\n  return bin(sum)[2:].to_i\nend", "    sum = 0\n \
    \   i = 0\n    while i < n || i < m\n        sum+=i\n        if i < n\n      \
    \      i+=1\n        else\n            i-=1\n    end\n    avg = sum/(n-m)\n  \
    \  avg = (\"0b\" + avg.to_s.round.to_s * (n-m)).lstrip(\"0\") \n    return avg\n\
    end", "  if m < n\n    return -1\n  end\n  \n  # convert m and n to binary\n \
    \ m_str = \"%b\" % m\n  n_str = \"%b\" % n\n  \n  # add the last digits to n\n\
    \  n += (m_str[-1] == \"1\") ? \"0b1\" : \"0b0\"\n  \n  # calculate sum\n  sum\
    \ = n.to_i(2).to_s(2).reverse.scan(/../).join.to_i(2)\n  \n  # check if m > n\n\
    \  if sum > m\n    sum -= 2**(m_str[-1].length)\n  elsif sum < m\n    sum += 2**(m_str[-1].length)\n\
    \  end\n  \n  \n  # convert to binary \n  sum.to_s(2).reverse.scan(/../).join.to_s(2)\n\
    end\n</cell>\n<cell>\nrounded_avg(10, 20)\n</cell>\n<cell>\nrounded_avg(20, 33)\n\
    </cell>\n<cell>\nrounded_avg(40, 3)\n</cell>\n<cell>\nrounded_avg(40, 4)\n</cell>\n\
    <cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(9, 10)\n</cell>\n<cell>\n\
    rounded_avg(10, 9)\n</cell>\n<cell>\nrounded_avg(12, 6)\n</cell>\n<cell>\nrounded_avg(16,\
    \ 5)\n</cell>\n<cell>\nrounded_avg(19, 5)\n</cell>\n<cell>\nrounded_avg(9, 10)\n\
    </cell>\n<cell>\nrounded_avg(9, 11)\n</cell>\n<cell>\nrounded_avg(8, 9)\n</cell>\n\
    <cell>\nrounded_avg(7, 11)\n</cell>\n<cell>\nrounded_avg(8, 10)\n</cell>\n<cell>\n\
    rounded_avg(9, 10)\n</cell>\n<cell>\nrounded_avg(11, 14)\n</cell>\n<cell>\nrounded_avg(11,\
    \ 13)\n</cell>\n<cell>\nrounded_avg(12, 13)\n</cell>\n<cell>\nrounded_avg(12,\
    \ 12)\n</cell>\n<cell>\nrounded_avg(16, 9)\n</cell>\n<cell>\nrounded_avg(17, 14)\n\
    </cell>\n<cell>\nrounded_avg(20, 13)\n</cell>\n<cell>\nroun", "  n = (n+m)/2\n\
    \  m = m\n  return (\"0b\" + bin(n)[-m..-1].to_i(2))\nend", "  raise \"Error\"\
    \ unless n >= 0\n  raise \"Error\" unless m > n\n  \n  nums = n.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    \  result = nums.slice!(m..nums.length)\n  \n  raise \"Error\" unless result\n\
    \  \n  return result.to_i(2).to_s(2).reverse\nend\nputs rounded_avg(1, 5)", " \
    \ n = n.to_i\n  m = m.to_i\n  \n  average = if n > m then n else m\n  a = (m..n).map\
    \ {|n| n / average * average.to_i}.max\n  a.to_s(2).rjust(8, '0')\nend", "   \
    \ if m < n\n        return -1\n    sum = 0\n    digits = 0.to_s(2).to_i(10)\n\
    \    (n.to_s(2).to_i(10)).times do |i|\n        sum += (digits[i] * (n-i))\n \
    \   end\n    return sum.to_s.ljust(m, \"0\").downcase \nend\n</code>\n<|/ a tags=ruby,bit-manipulation\
    \ |>\n<| a dscore=1 tags=ruby,bit-manipulation |>\n<code>", "  if n > m\n    -1\n\
    \  else\n    (m * (2 ** m)) / ((2 * n) + m)\n  end\nend", "  ((n - m) * 2).to_s(2).count('1')\
    \ + 1 if n > m else -1\nend", "  if n == m \n    return 0\n  sum = n \n  loop\
    \ do\n    sum += m\n    n -= 1\n    m -= 1\n  end \n  sum.divmod(2).each_byte.inject(0,\
    \ :+).to_s(2)\nend", "  result = n/m\n  rounded_answer = result.ceil.to_s(2)\n\
    \  \n  if result > m\n    return -1\n  else\n    return rounded_answer\n  end\n\
    end", "  return \"0b\" + n.to_s.reverse.gsub(/(\\d)(?=(\\d{3})+(?!\\d))/, '\\\
    1,').reverse.rjust(32, \"0\")\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe OP\
    \ asked specifically for a Ruby solution.\n<|/ c |>\n<| c |>\nThe first two solutions\
    \ don't work if m is negative.\n<|/ c |>\n<| c |>\nThe solutions work, but they\
    \ do not always give the exact answer.\n<|/ c |>\n<| a tags=ruby |>\nFor a Ruby\
    \ solution using modulo (% operator) you can do this:\n<code>", "  if n > m\n\
    \    return -1\n  elsif n == m\n    puts n\n    return\n  end\n  \n  n = n.to_s(2)\n\
    \  m = m.to_s(2)\n  \n  puts \"#{n}#{m}0\"\n  \n  (n..m).each do |i|\n    puts\
    \ \"#{n}#{m}#{i}0\"\n  end\n  \n  puts \"#{n}#{m}1\"\n  \n  n = (n.to_i(2))\n\
    \  m = (m.to_i(2))\n  \n  puts \"#{n}#{m}0\"\n  \n  (n..m).each do |i|\n    puts\
    \ \"#{n}#{m}#{i}1\"\n  end\n  \n  puts \"#{n}#{m}1\"\n  \n  n = (n.to_s(2))\n\
    \  m = (m.to_s(2))\n  \n  puts \"#{n}#{m}0\"\n  \n  (n..m).each do |i|\n    puts\
    \ \"#{n}#{m}#{i}0\"\n  end\n  \n  puts \"#{n}#{m}1\"\n  \n  n = (n.to_i(2))\n\
    \  m = (m.to_i(2))\n  \n  puts \"#{n}#{m}0\"\n  \n  (n..m).each do |i|\n    puts\
    \ \"#{n}#{m}#{i}1\"\n  end\nend\nrounded_avg(10, 33)\nrounded_avg(7, 5)\nrounded_avg(1,\
    \ 5)\nrounded_avg(20, 33)\nrounded_avg(3, 0)\nrounded_avg(5, 5)\nrounded_avg(2,\
    \ 1)\nrounded_avg(1, 3)\nrounded_avg(2, 1)\nrounded_avg(9, 0)\nrounded_avg(1,\
    \ 10)\nrounded_avg(2, 2)\nrounded_avg(8, 1)\nrounded_avg(7, 1)\nrounded_avg(7,\
    \ 10)\nrounded_avg(1, 1)\nrounded_avg(1, 10)\nrounded_avg(9, 1)\nrounded_avg(5,\
    \ 2)\nrounded_avg(7, 3)\nrounded_avg(3, 4)\nrounded_avg(1, 10)\nrounded_avg(3,\
    \ 3)\nrounded_avg(6, 8)\nrounded_avg(3, 4)\nrounded_avg(1, 10)\nrounded_avg(5,\
    \ 2)\nrounded_avg(5, 5)\nrounded_avg(5, 5)\nrounded_avg(6, 8)\nrounded_avg(5,\
    \ 4)\nrounded_avg(8, 8)\nrounded_avg(6, 6)\nrounded_", "  sum = (n..m).reduce(&:+)/2.to_i\n\
    \  sum.zero? ? -1 : sum.to_s(2).reverse.\n    each_byte.inject(0) { |sum, byte|\
    \ sum + byte.to_i}\nend", "\ti = n\n\tj = m\n\tsum = 0\n\twhile i < j\n\t\tsum\
    \ = sum + i\n\t\ti = i + 1\n\t\n\treturn sum.to_s(2).rjust((j - n).abs.to_i, 0).to_i\n\
    end", "    puts n if n <= m\n    return -1 if n >= m\n    (1..m).to_a.sort.each\
    \ { |i|\n        n = n.floor/2+i\n    }\n    to_s = n.to_s(2)\n    to_s.reverse.each_char.inject('')\
    \ { |sum, e| sum + e.to_s(2) }\nend", "  avg = ((n + m) / 2).to_i(2)\n  while\
    \ m%avg > 0\n    m += 1\n  end\n  n -= 1\n  return \"0b\" + n.to_s(2) + (m * avg).to_s(2)\n\
    end", "  (((n..m).sum / n).round().to_s(2) * (2**(n.bit_length + m.bit_length))).to_i(2)\
    \ \nend\n</code>\n<|/ a tags=ruby,binary,binary |>\n<| c |>\nThe question is asking\
    \ for the nearest integer, not the average. So, your answer is not exactly what\
    \ OP is asking.\n<|/ c |>\n<| c |>\nThanks, I missed that. I have corrected my\
    \ answer to include the missing bit.\n<|/ c |>\n<| a tags=ruby,binary,binary |>\n\
    Apart from my previous answer, the following is another way to solve this problem:\n\
    <code>", "    \n    if n <= m # First case is special because \n        \n   \
    \     if n < 0\n        \n            return -1\n            \n        elsif n\
    \ == m \n        \n            return \"0b0\"\n            \n        else # n\
    \ > m\n            \n            return -1\n            \n    elsif n < m # Case\
    \ where n <= m\n        \n        digits = \"0\" * n\n        \n        digits[0...m-1]\
    \ = \"1\" # Replace m with m - 1\n        \n        return digits \n        \n\
    \    else # n > m\n        \n        return -1\n        \n    end \nend\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(7,5)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(10,20)\n</cell>\n<code language=julia-1.0>\nrounded_avg(20,33)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(5,6)\n</cell>\n<code language=julia-1.0>\n\
    rounded_avg(5,0)\n</cell>\n<code language=julia-1.0>\nrounded_avg(10,0)\n</cell>\n\
    <code language=julia-1.0>\nrounded_avg(10,0)\n</cell>\n<code language=julia-1.0>",
  "\t\nend", "  if n == 0 || m == 0\n    return -1\n  result = n/2 + m/2 \n  if m\
    \ < n\n    result -= 1\n  end\n  result = result.to_s(2)\n  result = result.ljust(n,\
    \ \"0\")\n  result = \"0b\" + result\n  result\nend\nputs rounded_avg(101, 150)\n\
    puts rounded_avg(100, 100)\nputs rounded_avg(100, 99)\nputs rounded_avg(100, 101)\n\
    puts rounded_avg(100, 100)\nputs rounded_avg(101, 149)\nputs rounded_avg(101,\
    \ 101)\nputs rounded_avg(101, 100)\nputs rounded_avg(101, 99)\nputs rounded_avg(101,\
    \ 101)\nputs rounded_avg(101, 100)\nputs rounded_avg(101, 100)\nputs rounded_avg(101,\
    \ 101)\nputs rounded_avg(101, 100)\nputs rounded_avg(101, 100)\nputs rounded_avg(101,\
    \ 101)\nputs rounded_avg(101, 100)\nputs rounded_avg(101, 100)\nputs rounded_avg(101,\
    \ 101)\nputs rounded_avg(101, 100)\nputs rounded_avg(101, 100)\nputs rounded_avg(101,\
    \ 101)\nputs rounded_avg(101, 100)\nputs rounded_avg(101, 100)\nputs rounded_avg(101,\
    \ 101)\nputs rounded_avg(101, 100)\nputs rounded_avg(101, 100)\nputs rounded_avg(101,\
    \ 101)\nputs rounded_avg(101, 100)\nputs rounded_avg(101, 100)\nputs rounded_avg(101,\
    \ 101)\nputs rounded_avg(101, 100)\nputs rounded_avg(101, 100)\nputs rounded_avg(101,\
    \ 101)\nputs rounded_avg(101, 100)\nputs rounded_avg(101, 100)\nputs rounded_avg(101,\
    \ 101)\nputs rounded_avg(101, 100)\nputs rounded_avg(101, 100)\nputs rounded_avg(101,\
    \ 101)\nputs rounded_avg(101, 100)\nputs rounded_avg(101, 100)\nputs rounded_avg(101,\
    \ 101)\nputs rounded_avg(101, 100)\nputs roun", "  mn = ((m * 10 ** 9) + n) /\
    \ 10 ** 9\n  rounded = Integer(mn).to_s(2)\n  if mn > m then return \"-1\"\n \
    \ return rounded\nend\n  \nputs rounded_avg(7, 5)\nputs rounded_avg(20, 33)\n\
    puts rounded_avg(200, 300)", "  rounded_n = round(n/5)\n  rounded_m = round(m/5)\n\
    \  \n  if rounded_n < m\n    \"0b\" + [rounded_n].reverse.join + \"0\" * (m-rounded_n)\n\
    \  elsif rounded_m > n\n    -1\n  else\n    \"0b\" + [rounded_m].reverse.join\
    \ + \"0\" * (n-rounded_m)\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,binary,string\
    \ dscore=2 |>\n<| c |>\nThis works for small numbers but when you pass it to my\
    \ program it fails. for example when I pass `rounded_avg(109, 250)` it returns\
    \ `0b011111111010`\n<|/ c |>\n<| c |>\nI fixed the problem but still when I pass\
    \ `rounded_avg(109, 250)` to my program it returns `0b011111111010`\n<|/ c |>\n\
    <| c |>\nI fixed the problem but still when I pass `rounded_avg(109, 250)` to\
    \ my program it returns `0b011111111010`\n<|/ c |>\n<| c |>\nThat's odd, it works\
    \ for me when I pass it `rounded_avg(109, 250)`\n<|/ c |>\n<| c |>\nYes it works\
    \ for me too, thanks. but for some reason when I pass `rounded_avg(109, 250)`\
    \ to my program it returns `0b011111111010`\n<|/ c |>\n<| a |>\nThe accepted solution\
    \ above does not work for larger numbers, e.g. for rounded_avg(109, 250) -> 0b011111111010\
    \ .\nYou can use the solution below for larger numbers.\n<code>", "  if n == m\n\
    \    return m\n  if n > m\n    return -1\n  avg = n / (2 * m - n)\n  digits =\
    \ n.to_s(2).size\n  binary = []\n  until >= m\n    binary.push(avg)\n    return\
    \ -1\n  return binary.reverse.join.chars.reverse\nend", "  n = n.to_s\n  m = m.to_s\n\
    \  n.reverse!\n  m.reverse!\n  if n <= m\n    return \"0b\" + n.reverse.round.to_s(2)\
    \ + m.reverse.round.to_s(2)\n  else\n    return \"0b\" + \"-1\"\n  end\nend",
  "  return n + (m-1) * '0'.round.to_s(2) if n < m \n  -1\nend", "  puts \"#{m} /\
    \ #{n} = #{m * 100 / n}\"\n  puts \"#{m} / #{n} = #{(m / (n + 1)) * 100}\"\n \
    \ puts \"#{m} / #{n} = #{m / (n + 1 - m)}\"\n  puts \"#{m} / #{n} = #{m / (n +\
    \ 1 - m) * 100}\"\n  puts \"#{m} / #{n} = #{m / (n + 1 - m) / (n + 1)}\"\n  puts\
    \ \"#{m} / #{n} = #{m / (n + 1 - m) / (n + 1) * 100}\"\n  puts \"#{m} / #{n} =\
    \ #{m * 100 / (n + 1)}\"\n  puts \"#{m} / #{n} = #{m * 100 / n}\"\n  puts \"#{m}\
    \ / #{n} = #{m * 100 / (n + 1 - m)}\"\n  puts \"#{m} / #{n} = #{m * 100 / (n +\
    \ 1 - m) * 100}\"\n  puts \"#{m} / #{n} = #{m * 100 / (n + 1 - m) / (n + 1) *\
    \ (100 * n + 100 - m * n + n)}\"\n  puts \"#{m} / #{n} = #{m * 100 / (n + 1 -\
    \ m) / (n + 1) * 100 / (n + 1 - m)}\"\n  puts \"#{m} / #{n} = #{m * 100 / (n +\
    \ 1 - m) / (n + 1) * 100 / (n + 1 - m) * 100}\"\n  puts \"#{m} / #{n} = #{m *\
    \ 100 / (n + 1 - m) / (n + 1) * 100 / (n + 1 - m) * 100 * 100 / (n + 1 - m) *\
    \ (n + 1 - m) * 100 / (n + 1 - m) * (n + 1 - m) * 100 / (n + 1 - m) * (n + 1 -\
    \ m) * 100 / (n + 1 - m) * 100 / (n + 1 - m) * 100 / n}\"\nend\nrounded_avg(1,\
    \ 5)\nrounded_avg(7, 5)\nrounded_avg(10, 20)\nrounded_avg(20, 33)\nrounded_avg(21,\
    \ 0)\nrounded_avg(21, 1)\nrounded_avg(21, 2)\nrounded_avg(21, 3)\nrounded_avg(21,\
    \ 4)\nrounded_avg(21, 5)\nrounded_avg(21, 6)\nrounded_avg(21, 7)\nrounded_avg(21,\
    \ 8)\nrounded_avg(21, 9)\nrounded_avg(21, 10)\nrounded_avg(21, 11)\nrounded_avg(21,\
    \ 12)\nrounded_avg(21, 13)\nrounded_avg(21, 14)\nrounded_avg(21, 15)\nrounded_avg(",
  "  rounded_sum = n + m\n  floor_n = n.to_i\n  floor_m = m.to_i\n  rounded_sum =\
    \ rounded_sum.to_i\n  n = floor_n - rounded_sum\n  m = floor_m - rounded_sum\n\
    \  rounded_sum = rounded_sum.to_i\n  if n >= m\n    \"0b\" + n.to_s(2).reverse.rjust(m,\
    \ 0).ljust(m, 0)\n  else\n    \"-1\"\n  end\nend", "  \n  return \"0b\" + (((n/m\
    \ * 10**5).to_s).round(1).to_i & \"0x\" + n.to_s(2))\nend", "  if n <= m\n   \
    \ return \"0b\" + n.to_s(2)\n  else\n    return \"-1\"\n  end\nend\n</cell>\n\
    <cell>\nrounded_avg(1, 5)\n</cell>\n<cell>\nrounded_avg(7, 5)\n</cell>\n<cell>\n\
    rounded_avg(10, 20)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<text>\nTask:\
    \ Compute sum of all integers from 1 to 1000 that are divisible by 3\nWhat happens\
    \ when we try to compute sum 1 through 1000?\nHint: Think about the problems you\
    \ are tackling, and try to solve them on paper or in Python.", "  avg = (n + m)\
    \ / 2\n  \n  return \"0b\" + bin(avg).to_i(2).to_s(8)\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nYou shouldn't call `to_i` on each `String` returned by `bin`, because\
    \ `bin` doesn't return a string, just another `Integer`. If you want to turn a\
    \ `String` into a `Fixnum`, call `to_i`\n<|/ c |>\n<| c |>\n`to_i` returns a Fixnum\
    \ anyway, so it doesn't matter (in this case).\n<|/ c |>\n<| c |>\nIt's not \"\
    never\", but \"never\". `to_i` returns the same type as its argument. `bin` returns\
    \ a `String`, not a `Fixnum`.\n<|/ c |>\n<| c |>\nI know, I just didn't want to\
    \ make the same mistake as OP did. You're probably right.\n<|/ c |>\n<| a |>\n\
    <code>", "  sum = 0\n  n.upto(m) do |i|\n    sum += i\n  end\n  sum.zero? ? -1\
    \ : sum.to_s(2).zero? ? -1 : sum.to_s(2).to_i(2).to_s(2)\nend\n</code>\n<|/ a\
    \ dscore=4 tags=ruby,math |>\n<| c |>\n`n.upto(m).reduce(0) { |s,i| s + i }` is\
    \ nicer than using a loop.\n<|/ c |>\n<| a dscore=3 tags=ruby,math |>\nYou can\
    \ get the same result with just one loop:\n<code>", "  r = ((m / n) + n).round\n\
    \  s = \"0b\" + r.to_s(2)\n  n.times do |i|\n    s = s.insert(i, 0)\n  end\n \
    \ return s if m >= n\n  -1\nend\n</code>\n<|/ a |>\n<| c |>\n`s = \"0b\" + r.to_s(2)`\
    \ was what I needed to make this work. I didn't know that .to_s would return binary\
    \ when passed a float.\n<|/ c |>\n<| a |>\nHere's my take on the problem: \n<code>",
  "    rounded_sum = 0\n    rounded_count = 0\n    while n > m \n        rounded_sum\
    \ += n\n        rounded_count += 1\n        n, m = m, n\n    \n    rounded_sum\
    \ *= 2\n    rounded_sum += m\n    rounded_sum += rounded_count\n    rounded_sum.to_s(2)\n\
    end\n</cell>\n<cell>\nrounded_avg(15, 19)\n</cell>\n<cell>\nrounded_avg(15, 20)\n\
    </cell>\n<cell>\nrounded_avg(15, 21)\n</cell>\n<cell>\nrounded_avg(15, 22)\n</cell>\n\
    <cell>\nrounded_avg(7, 5)\n</cell>\n<cell>\nrounded_avg(10, 20)\n</cell>\n<cell>\n\
    rounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20, 34)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 35)\n</cell>\n<cell>\nrounded_avg(21, 22)\n</cell>\n<cell>\nrounded_avg(22,\
    \ 24)\n</cell>\n<cell>\nrounded_avg(22, 25)\n</cell>\n<cell>\nrounded_avg(22,\
    \ 26)\n</cell>\n<cell>\nrounded_avg(22, 27)\n</cell>\n<cell>\nrounded_avg(23,\
    \ 30)\n</cell>\n<cell>\nrounded_avg(23, 31)\n</cell>\n<cell>\nrounded_avg(23,\
    \ 32)\n</cell>\n<cell>\nrounded_avg(23, 33)\n</cell>\n<cell>\nrounded_avg(23,\
    \ 34)\n</cell>\n<cell>\nrounded_avg(23, 35)\n</cell>\n<cell>\nrounded_avg(24,\
    \ 25)\n</cell>\n<cell>\nrounded_avg(24, 26)\n</cell>\n<cell>\nrounded_avg(24,\
    \ 27)\n</cell>\n<cell>\nrounded_avg(24, 28)\n</cell>\n<cell>\nrounded_avg(24,\
    \ 29)\n</cell>\n<cell>\nrounded_avg(24, 30)\n</cell>\n<cell>\nrounded_avg(24,\
    \ 31)\n</cell>\n<cell>\nrounded_avg(24, 32)\n</cell>\n<cell>\nrounded_", "  int_sum\
    \ = 0\n  int_to_bin = n.to_s(2)\n  int_to_bin.reverse.chars.each_with_index do\
    \ |char, i|\n    int_sum += char.to_i(2).to_s(2).length * i\n  end\n  int_sum.abs\
    \ % 2 == 0\n    ? (-1 * int_to_bin.rjust((n.to_s(2) + \"1\").length, 0))\n   \
    \ : (int_to_bin.rjust((m.to_s(2) + \"1\").length, 0))\nend", "  if n == m\n  \
    \  return \"0b1\"\n  end\n  rounded_avg = Math.log(n) / Math.log(2)\n  rounded_avg\
    \ + (m == 0 ? 0 : 1).floor\nend\n    ", "  sum = 0\n  n.upto(m) do |i|\n    sum\
    \ += i\n  end\n  if sum < 0\n    -1\n  else\n    sum.round\n  end\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nWhat is the significance of the `-1` in the `if`\
    \ condition? The only case I've seen for it is when the sum of `0..n` is negative.\n\
    <|/ c |>\n<| c |>\nYeah, that is a very good point, I just copied it from the\
    \ OP's code, I'll edit\n<|/ c |>\n<| c |>\nThe -1 in if is there just to make\
    \ sure n is strictly lower than m. Otherwise, n is included in the range and you\
    \ will end up with a wrong average.\n<|/ c |>\n<| c |>\nOh, I see... It was actually\
    \ intended to be in the else branch. Thanks for pointing that out.\n<|/ c |>\n\
    <| c |>\nThat's very clever. Never thought of that.\n<|/ c |>\n<| a |>\n<code>",
  "  if m > n then\n    return -1\n  elsif m < n then\n    return -1\n  elsif m ==\
    \ n then\n    return \"0b0\"\n  elsif n < m then\n    return \"0b0\"\n  end",
  "  total = 0\n  i = n\n  while i <= m do\n    total += i\n    i += 1\n  end\n  r\
    \ = total/(i-2)\n  r = \"0b#{r}\"\n  return r\nend", "\tsum = 0\n\twhile n <=\
    \ m do\n\t\tsum = sum + n\n\t\tn = n + 1\n\tend\n\tavg = sum / m\n\tif avg < 0\
    \ then\n\t\treturn -1\n\tend\n\treturn \"0b#{avg.to_s(2)}\"\nend", "  n = (n+1)*(m/2+1)\n\
    \  m = (m+1)*(m/2+1)\n  if n <= m\n    puts [n.to_s(2).rjust(4,'0')].pack(\"B*\"\
    ) + [m.to_s(2).rjust(4,'0')].pack(\"B*\")\n  else\n    puts \"-1\"\n  end\nend",
  "  n = (n + m) / 2\n  n_to_bin(n).reverse.scan(/../).join.to_i(2).to_s(2)\nend",
  "  if n <= m \n    str = n.to_s(2)\n    return str\n  elsif n > m\n    return -1\n\
    \  else \n    str = n.to_s(2).reverse\n    return str.gsub('1', '0').gsub('0',\
    \ '1').gsub('11', '10').gsub('10', '11')\n  end\nend\n</cell>\n<code language=julia-1.5>\n\
    rounded_avg(10, 20)\n</cell>\n<code language=julia-1.5>\nrounded_avg(20, 33)\n\
    </cell>\n<code language=julia-1.5>\nrounded_avg(100, 500)\n</cell>\n<code language=julia-1.5>\n\
    rounded_avg(200, 400)\n</cell>\n<code language=julia-1.5>\nrounded_avg(200, 400)\n\
    </cell>\n<code language=julia-1.5>\nfunction binary(n)\n  str = n.to_s(2)\n  return\
    \ str\nend\n</cell>\n<code language=julia-1.5>\nbinary(10)\n</cell>\n<code language=julia-1.5>\n\
    binary(10)\n</cell>\n<code language=julia-1.5>\nbinary(10)\n</cell>\n<code language=julia-1.5>\n\
    binary(20)\n</cell>\n<code language=julia-1.5>\nbinary(30)\n</cell>\n<code language=julia-1.5>\n\
    binary(20)\n</cell>\n<code language=julia-1.5>\nbinary(200)\n</cell>\n<code language=julia-1.5>\n\
    binary(30)\n</cell>\n<code language=julia-1.5>\nbinary(200)\n</cell>\n<code language=julia-1.5>\n\
    binary(300)\n</cell>\n<code language=julia-1.5>\nbinary(200)\n</cell>\n<code language=julia-1.5>\n\
    binary(2000)\n</cell>\n<code language=julia-1.5>\nbinary(4000)\n</cell>\n<code\
    \ language=julia-1.5>\nbinary(5000)\n</cell>\n<code language=julia-1.5>\nbinary(10000)\n\
    </cell>\n<code language=julia-1.5>\nbinary(100000)\n</cell>\n<code language=julia-1.5>\n\
    binary(200000)\n</cell>\n<code language=julia-1.5>\nbinary(3000000)\n</cell>\n\
    <code language=julia-1.5>\nbinary(4000000)\n</cell>\n<code language=julia-1.5>\n\
    binary(5000000)\n</cell>\n<code language=julia-1.5>\nbinary(6000000)\n</cell>\n\
    <code language=julia-1.5>\nbinary(7000000)\n</cell>\n<code language=julia-", " \
    \ ((m * 8) + m).to_s(2).rjust((n * 8) + n, \"0\")\nend", "  if m > n\n    return\
    \ -1\n  else \n    sum = 0\n    start = n\n    finish = m\n    while start < finish\n\
    \      sum += start\n      start += 1\n    end\n    \n    return sum.to_s(2) \n\
    \  end\nend", "  n = n.to_i\n  m = m.to_i\n  return -1  if n >= m\n  ns = (n.to_s).to_i(2).to_s(2)\n\
    \  ms = (m.to_s).to_i(2).to_s(2)\n  len = ns.length\n  bin = (ms.to_s(len).to_i(2).to_s(len)).to_i(2)\n\
    \  bin.times do |i|\n    if ns[i] != 0\n      bin = \"0\" + bin\n    end\n  end\n\
    \  return bin\nend", "  ((n..m).include?(n) ? n : -1).to_s(2).reverse.scan(/../).join(\"\
    0b\").to_i(2).to_s(2)\nend\n  ", "  if n >= m\n    return \"-1\"\n  else\n   \
    \ return \"0b\" + bin(m + n - 1).split(\"0b\")[1]\nend", "  result = 0\n  if n\
    \ > m\n    -1\n  else\n    while n <= m\n      result = result + n\n      n +=\
    \ 1\n    end\n    result = result / 2\n    result = \"0b\" + bin(result)\n  end\n\
    \  result\nend\nputs rounded_avg(5, 3)", "    avg = 0.0\n    n.upto(m) do |i|\n\
    \        avg += n.next\n    end\n    if avg == 0.0\n        return -1\n    end\n\
    \    avg /= 2\n    avg.round\n    avg.to_s(2)\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=1 |>\nIf you have access to Ruby 1.9.2, you can try the following:\n\
    <code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
