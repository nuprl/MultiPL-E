name: HumanEval_151_double_the_difference
language: rb
prompt: "# Given a list of numbers, return the sum of squares of the numbers\n# in\
  \ the list that are odd. Ignore numbers that are negative or not integers.\n# double_the_difference([1,\
  \ 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n# double_the_difference([-1, -2, 0]) == 0\n#\
  \ double_the_difference([9, -2]) == 81\n# double_the_difference([0]) == 0  \n# If\
  \ the input list is empty, return 0.\ndef double_the_difference(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_double_the_difference\n\
  \    candidate = method(:double_the_difference)\n    assert_equal(0, candidate.call([]))\n\
  \    assert_equal(25, candidate.call([5.0, 4.0]))\n    assert_equal(0, candidate.call([0.1,\
  \ 0.2, 0.3]))\n    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))\n    assert_equal(0,\
  \ candidate.call([-1.0, -2.0, 8.0]))\n    assert_equal(34, candidate.call([0.2,\
  \ 3.0, 5.0]))\n    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0,\
  \ 1.0, 3.0, 5.0, 7.0, 9.0]))\n  end\nend\n"
completions: ["    doubled = 0\n    if lst.empty?\n        doubled\n    else\n   \
    \     doubled = lst.map(&:to_i).inject(:+) * lst.count{|x| x % 2 == 1}\n    end\n\
    end\n</code>\nEDIT: The above was written for Ruby 1.9. Changes made for 1.8.7:\n\
    <code>", "  lst = lst.flatten.compact.sort_by(&:abs)\n  lst.inject(0) {|sum,x|\
    \ sum + x*x if x % 2 == 1 }\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\n\
    `sum + x*x` should use `sum * x` instead. Or even `sum * sum` :-)\n<|/ c |>\n\
    <| c |>\nOr `lst.inject(0) {|sum,x| sum * x if x % 2 == 1 }`, I think. (Not saying\
    \ that I like this one either.)\n<|/ c |>\n<| c |>\n`flatten` will convert nested\
    \ arrays to multiple elements before `inject` will iterate over the array and\
    \ multiply each element by its index number. `flatten` won't work on an array\
    \ of arrays. `flatten` is only needed if you had an array of arrays of multiple\
    \ elements.\n<|/ c |>\n<| c |>\nRight. My first comment was in response to the\
    \ OP's `inject` solution (which was obviously wrong, of course). As for your comment,\
    \ I'll delete my comment once you've added it (and I'll give a +1).\n<|/ c |>\n\
    <| c |>\nI don't think you need to use `flatten` either. `flatten` is useful when\
    \ you have an array of arrays. E.g. `[[1],[2]].flatten.to_a` will give you `[1,1,2]`.\
    \ Then `inject(0)` will iterate over the array and multiply each element by its\
    \ index number giving you `[1,1,2].inject(0) {|sum,x| sum + x}` which gives you\
    \ `6`. The OP's `inject` solution will multiply each element by its index number\
    \ but since the first element of the array is 0, it will give you `0*0` which\
    \ is 0.\n<|/ c |>\n<| a tags=ruby |>\nA simple one liner using Enumerable#select:\n\
    <code>", "  sum = 0\n  if !lst.empty?\n    sum = lst.reduce(:+)\n    puts sum\
    \ if sum > 0\n    sum -= sum % 2\n  end\n  sum\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nI like your solution, but I am going to have to go with Jesse's since\
    \ it is the shortest. :-)\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nYou don't need\
    \ an external library for this, the modulo operator is your friend:\n<code>",
  "    sum = 0\n    if lst.count != 0\n        sum += lst.inject { |sum, item| sum\
    \ + item ** 2 } if lst.all? { |item| item % 2 == 1 }\n        sum += lst.inject\
    \ { |sum, item| sum + item ** 2 } if lst.any? { |item| item % 2 == 0 }\n     \
    \   sum += lst.inject { |sum, item| sum + item ** 2 } if lst.count == 1\n    end\n\
    \    sum\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nThe question, posted\
    \ here, is not asking for the sum of all the even numbers in a list. It is asking\
    \ for the sum of all odd numbers in a list.\n<|/ c |>\n<| c |>\nYour answer is\
    \ wrong. If sum is zero, then the sum of even numbers is zero, and vice versa.\
    \ I think you forgot to consider that.\n<|/ c |>\n<| c |>\nYour code is very hard\
    \ to read. One reason why it is hard to read is because you did not indent it\
    \ properly, which makes it hard to read and impossible to understand. For example,\
    \ `if lst.count != 0` belongs on the same line as `sum += lst.inject { |sum, item|\
    \ sum + item ** 2 }` and not on a new line. Also, `if lst.count != 0` should be\
    \ `if lst.count > 0`. Finally, `inject { |sum, item| sum + item ** 2 }` is the\
    \ same as `reduce(:+)`. Try learning ruby from [the excellent book \"Code Complete\"\
    ](http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0321503627).\
    \ Learn to indent.\n<|/ c |>\n<| c |>\nI fixed those things. The original code\
    \ was indented correctly in Codecademy's editor. I'll definitely check out that\
    \ book and see if I can improve my code there. Thanks!\n<|/ c |>\n<| c |>\n: Yes,\
    \ the code you wrote is wrong because it does not consider the case where there\
    \ are only even or odd numbers. I wrote my answer to address that. It also addresses\
    \ the problem you raised in your comments about the use of inject instead of reduce.\n\
    <|/ c |>\n<| a dscore=0 |>\nYou want to find all the odd numbers in a list, add\
    \ them together, then subtract the sum of all the even numbers from that total.\n\
    <code>", "  sum = 0\n  lst = lst.sort\n  lst.each{|i| sum += (i%2 ? i*-1 : i)\
    \ }\n  sum\nend\n</code>\n<|/ a tags=ruby,list,arrays |>\n<| a dscore=2 |>\n<code>",
  "  \n  result = 0\n  \n  if lst.blank?\n    return result\n  end", "    odd_sum\
    \ = 0\n    odd_sum = 0 if lst.empty? then 0 else lst[0]\n    odd_sum = 0 if lst.empty?\
    \ then 0 else lst[0]", "  lst.map! { |x| x if x.is_a?(Integer) && x % 2 == 1 }\n\
    \  lst.map! { |x| x * x }\n  lst.inject(0) { |sum, x| sum + x }\nend\n</code>\n\
    <|/ a |>\n<| a dscore=4 |>\nTo get the sum of the squares you can do it without\
    \ map! and inject using reduce:\n<code>", "  lst.select { |i| i.to_i.odd? } \n\
    \  .inject(0) { |s, i| s + i }\nend\n</code>\nNote that Ruby allows us to make\
    \ use of implicit block arguments. These allow us to express our method as a one-liner,\
    \ which makes it easier to read and understand.\n<|/ a dscore=4 |>\n<| c |>\n\
    This isn't the Ruby way.  This is \"Rubyism\".  Ruby also has built in enumerable\
    \ functions, which make this even more Ruby-like.  Also the OP has used `inject`.\
    \  That can be thought of as Ruby's `map`.  This is just an alternate way to do\
    \ the same thing.\n<|/ c |>\n<| c |>\nI personally would prefer the block form\
    \ over the inject form to me.  It's just a matter of taste.\n<|/ c |>\n<| c |>\n\
    Ruby also has a `select` method that makes this a little easier.\n<|/ c |>\n<|\
    \ c |>\n`select` is not a Ruby function, it's a method available on arrays.  That's\
    \ why I use `inject`.  I agree that Ruby has a `select` method but I don't see\
    \ any advantage to using it over `inject` in this case.\n<|/ c |>\n<| c |>\nI\
    \ don't see any advantage to using `select` over `inject`.  You are just making\
    \ the code more complicated.  It is less readable and harder to read.  Also, `inject`\
    \ requires an accumulator, so it isn't a perfect fit.  As a result, people tend\
    \ to avoid it unless they really need it.\n<|/ c |>\n<| a dscore=3 |>\nTo add\
    \ on to the excellent answers already given.\n<code>", "  lst.inject(:+).reduce(:*)\n\
    end\n</cell>\n<cell>\ndouble_the_difference([9, -2]) == 81\n</cell>\n<text>\n\
    Infinite loops\nInfinite loops are caused by loops that never break or do not\
    \ break at all.\nA while loop will continue to run until a given condition is\
    \ met.\nWhen a condition holds, it executes a given block until the condition\
    \ becomes false.", "  return(lst.reduce {|x, y| x+y} if lst.any? {|x| x.is_a?(Numeric)}\
    \ ? lst.reduce(:+) : 0)\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis isn't\
    \ ruby though.  And doesn't work with the OP's example input of `double_the_difference([-1,\
    \ -2, 0]) == 0`, which should equal 0, not -1.\n<|/ c |>\n<| c |>\n: Agreed. The\
    \ OP's example is very odd. I was trying to work out a solution that would generalize\
    \ to more situations, including empty inputs. But I couldn't get it to work reliably.\
    \ Maybe I missed a corner case, or maybe the OP has misunderstood the requirements.\n\
    <|/ c |>\n<| c |>\nAgreed. Your solution is better anyway, but I'm glad you found\
    \ a solution that works :-).\n<|/ c |>\n<| a tags=ruby,algorithm |>\nHere's a\
    \ solution I've just written:\n<code>", "    sum = 0\n    difference_of_positives\
    \ = lst.length\n    difference_of_negatives = 0\n    \n    if difference_of_positives\
    \ < 0\n        difference_of_positives += lst.length\n    end\n    \n    if difference_of_negatives\
    \ < 0\n        difference_of_negatives += lst.length\n    end\n    \n    difference_of_positives\
    \ -= difference_of_negatives\n    \n    difference_of_positives.each do |value|\n\
    \        if value == 0 \n            next\n        end\n        sum += value *\
    \ value\n    end\n    \n    if difference_of_positives == 0\n        sum += 0\n\
    \    end\n    \n    return sum\nend\n    ", "  sum = 0\n  list.each do |i| sum\
    \ += i*i end\n  sum if lst.include?(0) or lst.include?(-1)\nend\n</code>\n<|/\
    \ a tags=ruby,methods,return,arrays dscore=2 |>\n<| a |>\nThe other answers have\
    \ provided excellent solutions. \nHowever they have not addressed the question:\
    \ why is this a method in the first place? \nThe answer to that is simple: methods\
    \ are there to organize and simplify the logic of programs. \nIf I had to write\
    \ a method that simply added the integers of a given array of integers, I would\
    \ never do it like that: \n<code>", "  sum=0\n  sum+=lst.inject(0,:<<=>){|s,e|\
    \ s+e}\n  sum+=lst.inject(0,:<<=>){|s,e| s+e}\n  sum\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThank you for pointing this out to me and I apologize for taking so long\
    \ to accept. I accepted your answer and upvoted it as well as my other answer\
    \ since it included a solution that is more easily understood and therefore I\
    \ felt it was important to give credit. Thanks again to both of you and everyone\
    \ else who contributed answers to solve this problem.\n<|/ c |>\n<| c |>\nThank\
    \ you for the upvote. Honestly, I didn't expect you to change your acceptance.\
    \ I just wanted to let you know that I was able to solve the problem with my answer.\
    \ Good luck to you and thanks for the feedback.\n<|/ c |>\n<| c |>\nThanks again\
    \ for the upvote and thank you for the answer. I really do appreciate it. I am\
    \ glad you were able to solve the problem using inject, but I felt it wasn't worth\
    \ the time to explain how it works. I appreciate your help and thanks for taking\
    \ the time to get this far.\n<|/ c |>\n<| c |>\nYou're welcome. I understand that\
    \ `inject` is probably not the most intuitive method for this particular problem,\
    \ but I am glad I was able to help. Thanks for accepting my answer. Cheers!\n\
    <|/ c |>\n<| c |>\nThanks for the feedback. I appreciate it. I'm glad you weren't\
    \ just downvoting every answer I ever submitted on here!\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby,arrays |>\nYou can use the method inject to sum an array:\n<code>\n\
    my_array = [1,3,2,4]\nmy_array.inject(0){|sum,el| sum+el} # => 10\n</code>\n<|/\
    \ a |>\n<| a tags=ruby,arrays |>\nAnother solution in Ruby 2.4+:\n<code>\nmy_array\
    \ = [1,3,2,4]\nmy_array.map.with_index.sum", "  lst.each do |x| \n    if x.to_i\
    \ %2 == 1\n      x = x.to_i * 2\n    else\n      x = 0\n    end\n  end\n  x.to_s\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for the answer!\n<|/ c |>\n\
    <| c |>\nOne thing I'm wondering is what difference does it make? Does it speed\
    \ up the process or simply reduce it?\n<|/ c |>\n<| c |>\nIt reduces it; it's\
    \ just more Ruby-esque.\n<|/ c |>\n<| c |>\nBy the way, if you're wondering about\
    \ the speed of this, it depends on how often you're running it. There are two\
    \ ways to run this code: you either type it in directly and press enter, or you\
    \ save the file to your computer, then run the file with Ruby. Running in direct\
    \ will save you a lot of typing, so if you already have your file saved to your\
    \ computer, you might want to save it before running it in direct and then delete\
    \ it when you're done. Speed is almost always more important to your program than\
    \ how many lines of code you use per second.\n<|/ c |>\n<| c |>\nJust as a side\
    \ note, if you want a more Ruby-esque solution to this problem, you can use `inject`\
    \ instead of `each`, which may be easier to understand/more Ruby-like. Like `lst.inject(0)\
    \ { |sum,x| sum + x if x.to_i %2 == 1 }` This takes advantage of Ruby's lazy evaluation\
    \ for the list which can make things more efficient. Also, I know that I'm not\
    \ supposed to be rude in my comments, but I wanted to point out that it's okay\
    \ to not comment on posts you own or answers you own, but to comment on posts\
    \ and answers others have posted.\n<|/ c |>\n<| a tags=ruby |>\n<code>\na = [1,\
    \ 3, 2, 0]", "  sum = 0\n  for i in lst\n    sum += i * i\n  return sum if lst.size\
    \ != 0 else 0\nend", "  if lst.empty?\n    0\n  else\n    lst.reduce(0) {|s, i|\
    \ s + i*i if i.odd?}\n  end\nend\n</code>\n<|/ a tags=ruby,math dscore=0 |>\n\
    <| a dscore=0 tags=ruby,math |>\n<code>", "  # your code:\n  result = 0.0\n  for\
    \ i in lst\n    if (i % 2) == 0\n      result += 1\n      result = result * i\n\
    \  end\n  return result\n  # my code\n  result = 0\n  if lst.empty?\n    result\
    \ \n  else\n    for i in lst\n      if (i % 2) == 0\n        result += 1\n   \
    \     result = result * i\n      end\n    end\n  end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=ruby,algorithm |>\nI think what you're looking for is Enumerable#inject:\n\
    <code>", "  lst.map!{|x| x*x} if lst.is_a?(Array)\n  lst.each {|x| x != 0 && x\
    \ != -1 && x != nil}\n  lst.inject(:+)\nend", "  double = 0\n  for i in lst\n\
    \    if Integer(i) < 0\n      double += 0\n    elsif Integer(i) == 0\n      double\
    \ += 0\n    elsif Integer(i) > 9\n      double += 0\n    elsif Integer(i) < 10\n\
    \      double += Integer(i)*Integer(i)\n    end\n  end\n  double\nend", "    total\
    \ = 0\n    for i in lst\n        if i.odd?\n            total += i\n        end\n\
    \    end\n    return total\nend\nputs double_the_difference([1, 2, 3, 2, 0])\n\
    puts double_the_difference([-1, -2, 0])\nputs double_the_difference([9, -2])\n\
    puts double_the_difference([0])\nputs double_the_difference([])", "  if lst.empty?\
    \ \n    0 \n  else \n    lst.map!{ |x| x*x }.inject(:+)\n  end\nend\n</code>\n\
    <|/ a |>\n<| c |>\n+1 for the `inject` - I wouldn't have thought of it but it's\
    \ pretty cool. I'd prefer an `inject` over `map!` and `reduce`, because `map!`\
    \ modifies the array in place whereas `inject` returns a new object. Though it\
    \ may not be important for this question at all.\n<|/ c |>\n<| c |>\nI like `inject`\
    \ too. I'd just use `inject` instead of `map!` and then `inject(0, &:+)` to avoid\
    \ a temporary. `inject` also doesn't require a block (just pass the symbol :+)\
    \ and it returns an Enumerator, so you can do more things with it before iterating\
    \ or reducing it.\n<|/ c |>\n<| a tags=ruby,enumerator,inject,enumerable,arrays\
    \ |>\nTo my taste, this solution has the advantage of being short and readable.\n\
    <code>", "  return 0 if not lst.length \n  sum = 0 \n  arr.each {|x| sum += x\
    \ ** 2 }\n  arr.delete_if {|x| x < 0 }\n  arr.delete_if {|x| !x.is_a?(Fixnum)\
    \ }\n  sum\nend\n</code>\n<|/ a tags=ruby,sorting,ruby-on-rails-3,ruby-on-rails\
    \ dscore=2 |>\n<| c |>\nIt also doesn't require the user to know Ruby. It's a\
    \ language independent solution. Plus, it solves the problem with the original\
    \ question, which is about the algorithm rather than the particular implementation.\n\
    <|/ c |>\n<| c |>\n: Thanks for the comment. My intention was to point out that\
    \ this solution is more efficient than mine, because it doesn't create a new array\
    \ in memory in addition to doing the summing. My original answer was just an improvement\
    \ on yours. I do appreciate your comment, though.\n<|/ c |>\n<| a |>\nYou can\
    \ do it using inject method:\n<code>\na = [1, 2, 3, 7, 5, 6, 11, -5, 9, 10]\n\
    a.inject(0) do |sum, elem| sum + elem.to_i**2 if elem.to_i.odd?; sum + elem.to_i;\
    \ end\n=> 42\n</code>\n<|/ a dscore=2 tags=ruby,sorting,ruby-on-rails-3,ruby-on-rails\
    \ |>\n<| c |>\nThe OP specified that they are working in Rails, so I assume they\
    \ want to be able to use the standard library methods.\n<|/ c |>\n<| c |>\nI edited\
    \ my post to include Rails code. Thanks for your suggestion.\n<|/ c |>\n<| a dscore=1\
    \ |>\nI think this is what you want:\n<code>\na = [1, 2, 3, 7, 5, 6, 11, -5, 9,\
    \ 10]\np a.inject(0) do |sum, item| \n  if item.to_i.odd?\n    sum + item.to_i**2\
    \ \n  else \n    sum + item\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,ruby-on-rails-3,ruby-on-rails\
    \ |>\n<| c |>\nI edited my post to include Rails code. Thanks for your suggestion.\n\
    <|/ c |>\n<| a tags=ruby,sorting,ruby-on-rails-3,ruby-on-rails |>\nJust for fun,\
    \ here's another way of doing it:\n<code>\na = [1, 2, 3, 7, 5, 6, 11, -5, 9, 10]\n\
    a.inject(0) {|", "    total = 0\n    num = lst[0]\n    count = lst.count{|x| x.to_i\
    \ != 0 }\n    total += num * (num*num / 2 if count != 0 else '0')\n    count +=\
    \ 1\n    if count > 1\n        total += num * (num*num / 2 if count == 2\n   \
    \                     else num*num / 3)\n    total\nend\n</code>\n<|/ a |>\n<|\
    \ a |>\nHere is my solution. I know that this is not the most efficient way but\
    \ it's quite readable:\n<code>", "  lst.each do |i|\n    if i.to_i() % 2 == 1\n\
    \      i.to_i()\n    else\n      0\n    end\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\n`if i.to_i() % 2 == 1` is redundant\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,railstutorial.org\
    \ dscore=1 |>\nThere are many answers given so far that show how to do this, but\
    \ I wanted to see how we would do this with map, and without an explicit loop:\n\
    <code>", "  if lst.empty?\n    0\n  else\n    (lst.select { |x| x.is_a?(Integer)\
    \ && x.odd? }).inject(:+)\n  end\nend", "    sum = 0\n    for num in lst\n   \
    \     if num > 0 and not num % 2\n            sum += num\n    end\n    sum\nend\n\
    </code>\nThat was easy enough, I knew I needed a for/in loop and some if/then\
    \ statements, but what would you do to make that work? I started to think about\
    \ it a little more but I think I could have it working. But I couldn't think of\
    \ any way to make it work. I'm sure there is some way to do it with a for/in loop\
    \ and if/then statements, but I haven't had any luck working it out. Thanks to\
    \ anyone who can help me with this.\n<|/ q dscore=1 |>\n<| c |>\n`sum` is an enumerator\
    \ object in Ruby. You'll need to use `inject` instead of `for` to do this.\n<|/\
    \ c |>\n<| c |>\nIn Ruby it is generally considered bad practice to use `for`\
    \ loops to do things like this.  It's better to use a method like `each_with_index`\
    \ or a `map`/`collect` combo.\n<|/ c |>\n<| c |>\nIt's a good idea to step through\
    \ your code with a debugger to see exactly what's going on in each line.  You\
    \ will see that `sum` does not get updated in the loop.  Ruby has several methods\
    \ that return an enumerator that will do exactly what you want to do.\n<|/ c |>\n\
    <| c |>\nAh I see what you mean now. I knew I needed to use inject or each_with_index\
    \ but I was having trouble getting it working. Thank you for helping me out. I'll\
    \ be sure to check out the each_with_index and map methods.\n<|/ c |>\n<| a |>\n\
    You can use inject in Ruby\n<code>", "  if lst.size == 0\n    return 0\n  even\
    \ = double_the_difference(lst.select { |x| x % 2 == 0 })\n  odd = double_the_difference(lst.select\
    \ { |x| x % 2 != 0 })\n  return even.plus(odd)\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis is very helpful to understand\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,arrays,sum\
    \ |>\nHere's a solution in Ruby that solves the problem without using any loops\
    \ (except the final sum):\n<code>\nrequire 'set'", "    sum = 0\n    count = 0\n\
    \    list.each do |item|\n       if item % 2 != 0\n           sum += item\n  \
    \         count += 1\n       end\n    end\n    return sum if count > 0\n    return\
    \ 0\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nHere's another way,\
    \ using inject and collect:\n<code>", "  return lst.inject(:+).reduce(:*) if (lst.length)\n\
    \  0\nend", "  new_lst = lst.dup\n  new_lst.compact!\n  new_lst.map! { |x| x **\
    \ 2 }\n  new_lst.sum\nend", "  if lst.empty?\n    0\n  else\n    lst.reduce(:+)\
    \ + lst.reduce(:+) * lst.reduce(:+)\n  end\nend\n</code>\nThis solution uses Ruby's\
    \ inject method, which is the same as Enumerable#reduce. So you can see how it\
    \ works.\n<|/ a tags=ruby dscore=0 |>\n<| a |>\nAs already suggested above in\
    \ most cases, you can use\n<code>\nlst.inject(0){|x,y| x + y*y}\n</code>\nThe\
    \ reason being that inject will return the first argument if it is non-nil and\
    \ nil if it is nil, and it passes the current iteration value (x and y) as the\
    \ second argument. So in this case, you are adding up all values of your array.\
    \ Hence you get a single number returned as the result.\n<|/ a dscore=0 tags=ruby\
    \ |>\n<| c |>\n\"inject will return the first argument if it is non-nil and nil\
    \ if it is nil, and it passes the current iteration value (x and y) as the second\
    \ argument\"  I don't think this is true. `[1,2,3].inject(0) { |x,y| x + y*y }`\
    \ returns 6 not 4. I think you meant `[1,2,3].inject(0) { |x,y| x + y*y } => 12`\n\
    <|/ c |>\n<| c |>\nYes. I fixed it now.\n<|/ c |>\n<| a |>\n<code>", "  sum =\
    \ 0\n  n = lst.size\n  lst.each do |x|\n    if x % 2 == 1\n      sum += x * x\n\
    \    else\n      sum += 1\n    end\n  end\n  sum == 0 ? '0' : sum\nend", "   \
    \ sum = 0\n    for i in lst\n        if i.odd?\n            sum += i\n       \
    \ end\n    end\n    sum\nend\n</cell>\n<code language=julia-0.5>", "  lst.compact.inject\
    \ 0 do |sum, el|\n    sum + el % 2 == 1 ? el : 0\n  end\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby,functional-programming |>\n<code>", "  return lst.select { |x|\
    \ x % 2 == 0 }.reduce(:+)\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThe use\
    \ of `map` here is a little unintuitive. I'd write `lst.select { |x| x % 2 ==\
    \ 0 }.inject(:+)`.\n<|/ c |>\n<| c |>\nYeah, I agree. More readable and concise.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  \n  # your code here\n  \nend\n</cell>\n\
    <cell>", "  res=0\n  lst.each_with_index{|x,i| res+=(x+i)*(x+i) unless i<0&&x<0}\
    \ res\nend", "    numbers_without_negative = lst.select {|n| n != 0 && !n.zero?}.map\
    \ {|n| n.to_i}\n    numbers_without_negative.map {|n| n**2 + n}.sum\nend", " \
    \ lst.each_with_index do |n, i|\n    i += 1 if n % 2 == 1\n  end\nend", "  sum\
    \ = 0\n  for i in lst\n    if i.odd?\n      sum += i * i\n    end\n  end\n  sum\n\
    end\n</code>\nHere are the two methods you requested\n<code>", "    sum = 0\n\
    \    lst.each do |number|\n      sum += number if number % 2 == 1 && number !=\
    \ 0\n    end\n    sum\nend\n</cell>\n<text>\nPractice Problems", "  sum = 0\n\
    \  sum += lst.count(0)\n  lst.each { |x| sum += x * x }\n  sum\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\n`lst.each {|x| sum += x*x}`\n<|/ c |>\n<| c |>\nIt's\
    \ a good idea to add an explanation of why this answer is better than the others.\
    \ This is very helpful for readers of the answer later.\n<|/ c |>\n<| c |>\nWhat\
    \ does `sum` stand for? Is it a function? Is it a local variable?\n<|/ c |>\n\
    <| c |>\nThe variable name sum is the name of a Ruby method which sums the values\
    \ of the array.\n<|/ c |>\n<| a dscore=3 |>\nThe sum of the squares of numbers\
    \ in an array, using recursion:\n<code>", "  lst.inject(0){ |sum, i| sum + i**2\
    \ if i.odd? }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nHe wants the sum of those\
    \ numbers that are odd. And that sum has to come from only those numbers that\
    \ are odd.\n<|/ c |>\n<| c |>\nAh, I didn't read the question that well. Fixed.\n\
    <|/ c |>\n<| c |>\nHe didn't ask for the sum of the odd numbers. He asked for\
    \ _all the odd numbers_, and sum them up.\n<|/ c |>\n<| c |>\nYeah, the question\
    \ isn't clear as to whether he wants the sum of _all_ odd numbers or just one\
    \ specific odd number or both. I interpreted the question as asking for both.\n\
    <|/ c |>\n<| c |>\nThat's fair enough. Thanks for clearing that up. I didn't see\
    \ that he just wanted the sum of all odd numbers.\n<|/ c |>\n<| a tags=ruby,algorithm\
    \ |>\nHere's one more solution:\n<code>\nnums.reduce(0) do |sum,n|\n  sum + n**2\
    \ if nums.include?(n) and n % 2 == 1\nend\n</code>\nHere's another solution that\
    \ is a bit faster:\n<code>\nrequire 'set'\nnums = Set.new\nnums.merge!(nums) do\
    \ |n|\n  n**2 if nums.include?(n) and n % 2 == 1\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis returns `100` for your test case `[1, 2, 3, 0]`.\n<|/ c |>\n\
    <| c |>\nThanks for catching that. I've updated my answer accordingly.\n<|/ c\
    \ |>\n<| a dscore=0 |>\n<code>", "  sum = 0\n  for i in lst\n    sum = sum + i\
    \ if i % 2 == 1 else sum\n  return sum\nend\n</cell>\n<code language=julia-0.4>\n\
    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n</cell>\n<code language=julia-0.4>\n\
    double_the_difference([-1, -2, 0]) == 0\n</cell>\n<code language=julia-0.4>\n\
    double_the_difference([9, -2]) == 81\n</cell>\n<code language=julia-0.4>\ndouble_the_difference([0])\
    \ == 0\n</cell>\n<code language=julia-0.4>\ndouble_the_difference([10, 3, 8, 2])\
    \ == 10 + 18 + 9 + 8 + 2 = 50\n</cell>\n<code language=julia-0.4>\ndouble_the_difference([-10,\
    \ 3, 8, 2]) == 0\n</cell>\n<code language=julia-0.4>\ndouble_the_difference([9,\
    \ -2]) == 81\n</cell>\n<code language=julia-0.4>\ndouble_the_difference([0]) ==\
    \ 0\n</cell>\n<text>\nWrite a function called squares_of_the_squares that, given\
    \ a list of numbers, returns the sum of the squares of the numbers in the list\
    \ that are odd.", "  sum = 0\n  numbers.each do |number|\n    sum += number\n\
    \  end\n  sum\nend\n</code>\n<|/ a |>\n<| c |>\nI like this a lot. One minor improvement:\
    \ you can just do `numbers.inject(0) { |sum, number| sum += number }` instead\
    \ of explicitly writing the loop.\n<|/ c |>\n<| c |>\n: Yes, this is what I meant\
    \ in the last paragraph (edited my answer).\n<|/ c |>\n<| c |>\nYes, I understood\
    \ what you meant but just wanted to make sure you weren't thinking of `inject(:+)`\
    \ :-)\n<|/ c |>\n<| a |>\n<code>\nnumbers = [1, 2, 3, 4] ", "    i = 0\n    while\
    \ i < lst.size\n        if lst[i] % 2 == 1\n            lst[i] = lst[i] * 2\n\
    \        else\n            lst[i] = lst[i]\n        end\n        i += 1\n    end\n\
    \    \n    return lst[0]\nend\n</code>\n<|/ a tags=ruby,arrays,loops,function\
    \ dscore=1 |>\n<| c |>\nI believe you meant `i += 1` instead of `i = i+1` and\
    \ the OP wanted to add all numbers **except** even numbers.\n<|/ c |>\n<| c |>\n\
    Thanks, I fixed that error. Regarding `i += 1`, I assumed that the OP wanted to\
    \ add all numbers. I may have been misled by his description. Feel free to edit\
    \ my post to fix it if that is the case.\n<|/ c |>\n<| c |>\nI agree, it seems\
    \ like OP was confused. I guess what I was trying to say is that `i += 1` does\
    \ not increase the loop counter but only increases the assignment of the variable\
    \ `i`. So it should be `i += 1` not `i = i+1`.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  lst.each{|x| return x + x} \nend", "  if lst.empty?\n    0\n  else\n    (lst.map{\
    \ |x| x**2 }).inject(:+)\n  end\nend\n</cell>\n<cell>", "  lst = (lst - lst[0])\
    \ if (lst != []) \n  total = 0 \n  for i in lst\n    total += i * i\n  end\n \
    \ return total\nend", "  if lst.empty?\n    0\n  else\n    lst.inject(0) do |sum,\
    \ number|\n      sum + (number % 2 != 0) ? sum + number : number\n    end\n  end\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nNice, although if you do `sum + number`\
    \ then your sum will start from 0 each time. Change it to `sum + number if number\
    \ % 2 != 0` instead.\n<|/ c |>\n<| c |>\nThanks. I didn't realize the sum was\
    \ starting at 0. I've modified my answer. Do you know why `inject` is better than\
    \ `reduce` in this case performance-wise?\n<|/ c |>\n<| c |>\n`inject` creates\
    \ a new sum for each item, and `reduce` just uses the first `sum` as the initial\
    \ value for the accumulator instead of starting from 0 each time.\n<|/ c |>\n\
    <| c |>\nI updated my answer to include your recommendation.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nIn Ruby there is a built-in function named Enumerable#inject.\n<code>\n\
    a = [1,2,3]\na.inject(:+)", "  result = 0.0;\n  result = lst.select {|x| x % 2\
    \ == 1 }.inject {|sum,x| sum + x }\n  return 0 if lst.empty?\n  result\nend",
  "  if lst.empty?\n    0\n  else\n    lst.inject(0) { |acc, val| acc + val if val.is_a?(Fixnum)\
    \ && val.odd? }\n  end\nend\n</cell>\n<cell>\ndouble_the_difference([1,3,2])\n\
    </cell>\n<text>\nExercise 4.6\nWrite a function called sum_of_squares that calculates\
    \ the sum of squares for a given array of numbers.", "  lst.each do |n|\n    return\
    \ 0 if (n.is_a?(Integer) && n < 0) || n.is_a?(Float) || (!n.is_a?(Integer) &&\
    \ !n.is_a?(Float))\n    sum += n.to_i * n.to_i\n  end\n  sum\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThis looks good, but I need the output to be in separate lines,\
    \ like \nthe sum is 4\nthe sum is 8\nthe sum is 16\n<|/ c |>\n<| a tags=ruby dscore=0\
    \ |>\nThis is probably not the most efficient method, but it is a simple implementation\
    \ that gives you an idea of how it works and will get you started on making your\
    \ own methods to accomplish it.\n<code>", "  total = lst[0]\n  lst.each do |x|\n\
    \    if x.is_a?(Integer)\n      if x > 0\n        total = total + x\n      end\n\
    \    else\n      if x != 0\n        total = total + x\n      end\n    end\n  end\n\
    \  return total\nend", "    return lst.sum - lst.count(0)\nend", "  sum = 0\n\
    \  lst.each do |i|\n    sum += i % 2 ? 2*i : i\n  end\n  return 0 if lst.empty?\n\
    \  sum\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nCan you please explain what\
    \ is the purpose of the \"?\" and \":\" here? Also, would you mind explaining\
    \ what \"sum += i % 2 ? 2*i : i\" is doing?\n<|/ c |>\n<| c |>\n`?` and `:` aren't\
    \ operators, they're part of the ternary conditional operator. If `i` is even\
    \ then `2*i` is returned. `i` is odd, then `i` is returned instead. Does that\
    \ help?\n<|/ c |>\n<| a tags=ruby |>\nOne more way:\n<code>", "  if lst.empty?\n\
    \    0\n  else\n    lst.reduce(:+).to_f - lst.map(&:to_f).reduce(:+).to_f\n  end\n\
    end", "  sum = 0\n  lst.each do |n|\n    if n.is_a? Integer\n      sum += n\n\
    \    elsif n.is_a? Float\n      sum += n.to_i\n    elsif n.is_a? BigDecimal\n\
    \      sum += n.to_f\n    else\n      sum += 0\n    end\n  end\n  sum\nend", " \
    \   # Your code goes here\n    sum = sum(map(lambda x: x ** 2, filter(lambda y:\
    \ y % 2 == 1, lst)))\n    return sum if sum else 0", "    sum = 0\n    i = 0\n\
    \    while i < lst.size \n        sum += lst[i] - lst[i] \n        i += 1\n  \
    \  return sum if lst.size != 0 else 0\nend", "    sum = 0\n    if lst.empty?\n\
    \        return sum\n    end\n    sum = 0 \n    even = []\n    odd = []\n    even.push\
    \ lst.first if lst.first.odd?\n    odd.push lst.first if lst.first.even?\n   \
    \ lst.drop(1).each do |x|\n        sum = sum + x if x.odd?\n        sum = sum\
    \ - x if x.even?\n    end\n    sum = (sum / 2).ceil if sum > 0\n    sum = sum.ceil\
    \ if sum != 0\n    odd.each do |x|\n        sum = sum + x\n    end\n    sum =\
    \ (sum / 2).ceil if sum > 0\n    sum = sum.ceil if sum != 0\n    return sum\n\
    end", "  lst.each do |n|\n    if n.is_a? Integer\n      if n < 0\n        n =\
    \ 0\n      end\n    elsif n.is_a? Float\n      if n != n\n        n = 0\n    \
    \  end\n    end\n    return n if n % 2 == 1\n  end\n  return 0\nend\n</code>\n\
    I decided to change my solution to this:\n<code>", "  sum = lst.inject{|sum, item|\
    \ sum + item}\n  sum.zero? ? 0 : sum * sum\nend", "  lst.each do |x|\n    if x.is_a?\
    \ Integer\n      sum = x*x \n      sum += 1 unless sum.zero?\n    elsif x.is_a?\
    \ Float\n      sum = x*x \n      sum += 1 unless sum.zero?\n    else\n      next\n\
    \    end\n  end\n  sum\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI realise this\
    \ is old, but I'd like to point out that `sum` is a reserved word in Ruby and\
    \ should not be used as a variable name. Also, while your code does work it is\
    \ inefficient to re-compute the `sum` variable for each iteration. A better method\
    \ would be: `def double_the_difference(lst)\n  sum = 0\n  lst.each do |x|\n  \
    \  if x.is_a? Integer\n      sum += x*x \n      sum += 1 unless sum.zero?\n  \
    \  elsif x.is_a? Float\n      sum += x*x \n      sum += 1 unless sum.zero?\n \
    \   else\n      next\n    end\n  end\n  sum\nend`\n<|/ c |>\n<| c |>\nYou are\
    \ right about sum. `sum = 0` is also a good way to solve this problem. Thanks\
    \ for your suggestion.\n<|/ c |>\n<| c |>\nThis is an interesting solution but\
    \ as I mentioned, the intent is to learn Ruby rather than do things optimally.\
    \  As a newcomer to Ruby, I find this answer to be very interesting but would\
    \ like to give some explanation on why I think it is interesting.  I would be\
    \ very interested to read your answer if you think you have a deeper understanding\
    \ of Ruby.\n<|/ c |>\n<| c |>\nThanks for sharing your insights and comments.\
    \ I like your solution. However, I think you can do better than `sum += x*x if\
    \ sum.zero?` because it is not re-computing sum each time.\n<|/ c |>\n<| c |>\n\
    That is very true. However, I was trying to make it as efficient as possible,\
    \ but of course you are right. Thanks for pointing out this optimization.\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>", "  lst.select { |x| x % 2 == 1 }.inject(0)\
    \ {|sum, num| sum + num }\nend\n</code>\n<|/ a dscore=3 tags=ruby |>\n<| c |>\n\
    This isn't a very readable solution; it doesn't use a `reduce` call and it uses\
    \ `each_with_object`. It should be noted that you can achieve a more ruby like\
    \ solution using `inject` like so:", "  return  sum( n for n in lst if n % 2 !=\
    \ 0 )\nend", "  return lst.inject(:+).reduce(:*).to_i\nend", "  return lst.inject(:+).inject(:*)\n\
    end\n</cell>\n<cell>", "  lst.each do |x| \n    next if (x.to_i > 0)\n    puts\
    \ x.to_i\n    next if x.is_a?(Integer)\n    puts x*x\n    next\n  end\n  0\nend",
  "    double_the_difference = 0\n    lst.each do |num|\n        double_the_difference\
    \ = double_the_difference + num*num\n    end\n    return double_the_difference\n\
    end\n</code>\nI tested this and it works on all the tests I did.\n<|/ a |>\n<|\
    \ a tags=ruby,arrays |>\nThe answer is wrong in the comments section.\nThe correct\
    \ answer is\n<code>", "  lst.map { |i| i == 0 ? 0 : i * 2 }.inject(:+)\nend\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nI like the `inject` version. `inject` was\
    \ the method I missed when I started working with ruby a couple of years ago.\n\
    <|/ c |>\n<| a |>\nAs everyone else has stated, this is probably a homework question.\
    \  It would be interesting to understand why you are required to do this in Ruby,\
    \ as that is often the case with homework questions.\nHere are some hints:", " \
    \ double_the_difference = 0\n  \n  lst.each do |num|\n    if num.to_s.include?('.')\
    \ == false\n      double_the_difference += num.to_i ** 2 \n    else \n      double_the_difference\
    \ += num.to_i ** 0.5\n    end\n  end\n  \n  return double_the_difference\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for the help :) I understand your answer for\
    \ the problem but don't understand how to make it into Ruby.\n<|/ c |>\n<| c |>\n\
    I added a Ruby implementation to my answer above.  Please let me know if that\
    \ helps!\n<|/ c |>\n<| c |>\nYour solution is definitely easier, thank you!\n\
    <|/ c |>\n<| c |>\nGlad I could help you out!\n<|/ c |>\n<| a tags=ruby dscore=0\
    \ |>\nHere's one way to do it:\n<code>", "    sum = 0\n    positive.each do |i|\n\
    \        if i.odd?\n            sum += i\n        end\n    end\n    return 0 if\
    \ lst.empty?\n    return sum + sum if lst.size > 1\n    return sum\nend\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nHere's my solution, using two loops:\n<code>", " \
    \   # Write your code here.\n    total = 0\n    for i in lst:\n        if i %\
    \ 2 != 0 and i != 0:\n            total = total + i\n    return total\n</code>\n\
    <|/ a tags=python,list,python-3.x dscore=0 |>\n<| a tags=python,list,python-3.x\
    \ |>\n<code>", "  return lst.inject(0) { |sum,x| sum + x if x % 2 == 1 }\nend\n\
    </cell>\n<cell>", "    sum = 0\n    odd_nums = 0\n    odd_nums += lst.pop() if\
    \ lst.count > 0 \n    odd_nums += lst.pop() if lst.count > 0 \n    odd_nums +=\
    \ lst.pop() if lst.count > 0 \n    odd_nums += lst.pop() if lst.count > 0 \n \
    \   \n    for i in lst\n      if !i.is_a?(Integer) || i < 0\n        break\n \
    \     else if i == 0\n        break\n      else\n        sum += i\n    end\n \
    \   return sum * sum\nend", "  sum = 0\n  for x in lst\n    if x.odd?\n      sum\
    \ += x\n    end\n  end\n  sum\nend\n</cell>\n<text>\nQuestions\nWrite a method\
    \ that takes an array of numbers and returns their total squared value.  For example:",
  "    return lst.inject(0) {|sum, e| sum + e if e > 0 && e.odd? }\nend\n</code>\n\
    <|/ a tags=ruby,enumerable |>\n<| c |>\n`inject` seems quite useful and intuitive\
    \ to me!\n<|/ c |>\n<| c |>\n`Enumerable#inject` is also one of the main ways\
    \ to accomplish this in Ruby.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. I think it's more compact and faster than the other answers\n<|/ c |>\n\
    <| c |>\n`inject` is more of a functional programming paradigm than a Ruby paradigm\
    \ so I find it difficult to understand it. `inject` reads like English to me though.\
    \ I think this is easier to understand: `lst.inject(0) {|sum, e| sum + e if e\
    \ > 0 && e.odd? }`\n<|/ c |>\n<| a dscore=5 |>\nHow about something like this:\n\
    <code>", "    sum = 0\n    sum2 = 0\n    \n    # Calculate the sum of the input\
    \ list\n    sum = sum(lst)\n    \n    # Calculate the sum of the squares of the\
    \ numbers in the list\n    # that are odd\n    sum2 = sum * sum\n    \n    # Add\
    \ the sum of the squares of the numbers that are odd \n    # to the sum of the\
    \ input list\n    sum = sum + sum2\n    \n    # Return the sum of the squares\
    \ of the numbers that are odd.\n    return sum", "  if lst.empty?\n    0\n  else\n\
    \    lst[0] + double_the_difference(lst[1..-1]).to_f\n  end\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nI didn't understand this code, but I got it after reading this\
    \ http://blog.bigbinary.com/2012/07/01/time-complexity-for-the-double-sum-problem/\n\
    <|/ c |>\n<| a |>\nA more mathematical solution would be:\n<code>", "  lst = lst.sort!\n\
    \  result = 0\n  lst.each_with_index { |value, i| \n    result += value if i %\
    \ 2 == 1\n  }\n  return result\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ address the question of \"what does it mean to square the difference?\"\n<|/\
    \ c |>\n<| c |>\nThe question was \"how to square difference\". Asking how to\
    \ square the difference is just another way of asking \"how to square\" the difference.\
    \ As such, my answer demonstrates that it can be done without iterating through\
    \ the list twice.\n<|/ c |>\n<| a dscore=0 tags=ruby,loops,iteration |>\nHere's\
    \ another way to implement your method:\n<code>", "  return lst.inject(0) do |total,\
    \ item| \n    total + item*item\n  end\nend", "  sum = 0\n  i = 0\n  while i <\
    \ lst.length\n    if lst[i] > 0\n      if i % 2\n        sum += lst[i]\n     \
    \ else\n        sum -= lst[i]\n      end\n      i += 1\n    end\n  end\n  return\
    \ sum\nend\n</code>\n<|/ a tags=ruby,algorithm dscore=3 |>\n<| c |>\nO(n) is the\
    \ best case complexity. Because if you find the first even element in the given\
    \ list, you will have to subtract the element from the list, and so on. That's\
    \ a time complexity of O(n^2)\n<|/ c |>\n<| a tags=ruby,algorithm |>\n<code>",
  "  result = 0.0;\n  lst.each do |x|\n    if x.is_a? Integer\n      result += (Math.pow(x,2))\n\
    \    elsif x.is_a? Float\n      result += (Math.pow(x,2.0))\n    end\n  end\n\
    \  return result\nend\n</cell>\n<cell>\ndouble_the_difference([1, 3, 2, 0])\n\
    </cell>\n<text>\nWrite a method that takes an array of strings and returns a string\
    \ where all but the last 2 characters are capitalized.\ncapitalize_all_but_last([\"\
    duck\", \"chicken\", \"goose\", \"goose\"]) \u279E \"Duck Chicken Goose\"\ncapitalize_all_but_last([\"\
    dog\", \"cat\", \"fish\"]) \u279E \"Dog Cat Fish\"\ncapitalize_all_but_last([])\
    \ \u279E \"\"", "  if lst.empty?\n    0\n  else\n    lst.each_with_object(0) do\
    \ |number, sum|\n      sum += number if number % 2 == 1\n    end\n  end\nend",
  "  if lst.nil?\n    0.0\n  else\n    sum = 0.0\n    lst.each_with_index do |e, i|\n\
    \      if e != 0\n        sum += i * i\n      end\n    end\n    sum\n  end\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nUsing inject:\n<code>", "    list\
    \ = lst.to_a\n    list.delete_if{|i| i.to_i < 0 } \n    list.delete_if {|i| i.to_i.to_s\
    \ == 0 }\n    if list.empty?\n        0\n    else\n        list.reduce(&:+)\n\
    \    end\nend", "  if lst.empty?\n    0\n  else\n    lst.inject(0) { |s, n| s\
    \ + n % 2 == 0 ? s * 2 : s }\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    It's not the case that the result is going to be an integer, it's the case that\
    \ it is an integer of the size of the input array.\n<|/ c |>\n<| c |>\nThe result\
    \ of the `inject` call will either be an integer or nil, and that's it, the return\
    \ value will always be either an integer or nil.\n<|/ c |>\n<| c |>\nThe return\
    \ value of the `inject` call is always either `nil` or `s`, depending on what\
    \ the block is doing, and in this case it's always `s` which we know will evaluate\
    \ to an integer because the sum will never be less than 0.\n<|/ c |>\n<| c |>\n\
    Ah, I see what you mean. `inject` returns the original value, so if an initial\
    \ value of 0 is passed as the initial accumulator for the `inject` block, it will\
    \ always return 0.\n<|/ c |>\n<| c |>\nIf `inject` is returning the original value,\
    \ then why don't you just call `sum` on the list? It seems like you're making\
    \ a list that just contains that first number in the list, then summing that list\
    \ and then returning that sum as an integer. Not very efficient. Why not just\
    \ call `sum` on the list?\n<|/ c |>\n<| a |>\nThis is another way for you to consider.\n\
    <code>", "  if lst.empty?\n    0\n  else\n    lst.pop.pop.pop.pop + lst.sum +\
    \ double_the_difference(lst)\n  end\nend\n</code>\nHope this helps, if you have\
    \ any questions just ask. Good luck!\n<|/ a |>\n<| a dscore=0 tags=ruby |>\nHere\
    \ is a recursive solution that might work for you. I'm still not sure if this\
    \ is what you need though.\n<code>", "  if lst.empty?\n    0\n  else\n    lst.inject(0)\
    \ {|sum, n| sum + n**2 if n % 2 != 0}\n  end\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=ruby,arrays,math |>\nTo get rid of any negative integers, you can use\
    \ \n<code>\narr = [\"-23\", \"2\", \"-2\", \"3\", \"-44\"]", "  sum = 0\n  \n\
    \  if lst.empty?\n    return 0\n  elsif lst.count == 1\n    return lst[0]\n  elsif\
    \ lst.count > 1\n    sum += lst[lst.count - 1]\n    lst.delete(-1) #deletes the\
    \ last element in the list, since we're going to sum it all up\n    lst.each {\
    \ |x| sum += x if x % 2 == 1 }\n  end\n  sum\nend", "  lst.map do |x|\n    if\
    \ x.is_a? Integer\n      x*x\n    elsif x.is_a? String\n      x.to_i\n    end\n\
    \  end.reduce(:+)\nend\n</code>\nIn case you prefer to use the built-in filter\
    \ for filtering your list, here is an alternative using Array#select :\n<code>",
  "  lst.each_with_index do |i, index|\n    if i.odd?\n      lst[index] = i.to_i *\
    \ i.to_i\n    end\n  end", "    double_the_difference = 0\n    even = lst.select\
    \ {|x| x % 2 == 0}\n    odd = lst.select {|x| x % 2 != 0}\n    double_the_difference\
    \ += even.inject(0) {|a,i| a + i*i }\n    double_the_difference += odd.inject(0)\
    \ {|a,i| a + i*i }\n    double_the_difference\nend", "  if lst.empty? then 0 else\
    \ lst.inject(0, &:+).reduce {|a,e| a*2+e }\nend", "  lst.map! { |x| x if x % 2\
    \ == 0 }\n  lst.map! { |x| x * 2 }\n  lst.inject { |sum, number| sum + number\
    \ }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails |>\n<| a dscore=0\
    \ |>\n<code>", "  lst.select!{|e| e.odd?}\n  lst.select!{|e| e.to_i == e.to_i}\n\
    \  return lst.inject(0) {|sum, e| sum + e}\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=ruby |>\nMy solution to this is to use inject:\n<code>", "  lst.each\
    \ do |x|\n    return 0 unless x.is_a? Integer\n    if x == 0 || x < 0\n      return\
    \ 0\n    end\n  end\n  result = 0.0;\n  lst.each do |x|\n    result += (x % 2)\
    \ * x\n  end\n  return result\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,sum\
    \ dscore=2 |>\nA more Ruby-like version:\n<code>", "  return 0 if lst.empty? else\
    \ lst.inject(0) {|s,n| s+(n % 2 == 0 ? n : n*2) }\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\nUsing inject is very nice, but unfortunately it doesn't\
    \ work the way you hope. inject executes the given block once for each element,\
    \ and then returns a single value, which is the result of applying the block to\
    \ all elements. So for instance, if you had [1, 2, 3] you would get the result\
    \ [1, 3, 9], which is obviously not what you want. \nInstead, we can use a loop\
    \ and use yield to pass on each element to the next block. \n<code>", "  lst.flatten!\n\
    \  lst.each_index{|i| lst[i] if !lst[i].is_a?(Fixnum) || lst[i] < 0 || !lst[i].is_a?(Numeric)\
    \ }.compact.inject{|acc, x| acc + x }.to_a\nend\n</cell>\n<code language=julia-1.0>",
  "  return lst.sum.odd * lst.sum.odd if lst.any? || lst.empty? || lst.uniq.empty?\
    \ \n  else\n  raise ArgumentError.new(\"Invalid parameters\")\nend\n    ", " \
    \   sum = 0\n    list = lst.to_s\n    list.map{|x| return x+1 if x % 2 == 1};\n\
    \    list.to_i\nend", "  return(sum(lst[1..-1].select(&:odd).inject(:+))) if lst.size\
    \ > 0\n  return(0)\nend\n</pre>\n          </div>\n          \n          <div\
    \ class=\"hidden-line\"></div>\n          \n          \n          <div id=\"ruby-keyword-method-i-odd_or_even\"\
    \ class=\"method-detail \">\n            <a name=\"M000398\" class=\"method-name\"\
    >odd_or_even</a>&nbsp;&nbsp;(<span class=\"var-type\">number</span>)\n       \
    \     <ul class=\"code-lines\">\n              \n              <li class=\"code-line\"\
    >\n                <span class=\"no-break\">\n                  <code><span class=\"\
    dv\">0</span>.<span class=\"dv\">__getobj__</span>(<span class=\"var-name\">number</span>)</code>\n\
    \                </span>\n              </li>\n              \n              <li\
    \ class=\"code-line\">\n                <span class=\"no-break\">\n          \
    \        <code><span class=\"kw\">if</span> (<span class=\"var-type\">number</span>.<span\
    \ class=\"dv\">__getobj__</span>(<span class=\"var-name\">number</span>).<span\
    \ class=\"dv\">class</span> <span class=\"op\">==</span> <span class=\"kw\">self</span>.<span\
    \ class=\"at\">odd?</span>)</code>\n                </span>\n              </li>\n\
    \              \n              <li class=\"code-line\">\n                <span\
    \ class=\"no-break\">\n                  <code><span class=\"kw\">return</span>\
    \ <span class=\"kw\">self</span>.<span class=\"at\">odd</span>(<span class=\"\
    var-name\">number</span>)</code>\n                </span>\n              </li>\n\
    \              \n              <li class=\"code-line\">\n                <span\
    \ class=\"no-break\">\n                  <code><span class=\"kw\">elsif</span>\
    \ (<span class=\"var-type\">number</span>.<span class=\"dv\">__getobj__</span>(<span\
    \ class=\"var-name\">number</span>).<span class=\"dv\">class</span> <span class=\"\
    op\">==</span> <span class=\"kw\">self</span>.<span class=\"at\">even?</span>)</code>\n\
    \                </span>\n              </li>\n              \n              <li\
    \ class=\"code-line\">\n                <span class=\"no-break\">\n          \
    \        <code><span class=\"kw\">return</span> <span class=\"kw\">self</span>.<span\
    \ class=\"at\">even</span>(<span class=\"var-name\">number</span>)</code>\n  \
    \              </span>\n              </li>\n              \n              <li\
    \ class=\"code-line\">\n                <span class=\"no-break\">\n          \
    \        <code><span class=\"kw\">end</span></code>\n                </span>\n\
    \              </li>\n              \n              <li class=\"code-line\">\n\
    \                <span class=\"no-break\">\n                  <code><span class=\"\
    kw\">return</span> <span class=\"kw\">false</span></code>\n                </span>\n\
    \              </li>\n              \n            </ul>\n          </div>\n  \
    \        \n          <div class=\"method-description\">\n            <p>\nReturn\
    \ a new <code>Number</code> object with the same value as the current object,\
    \ which is\nodd for <code>0</code> and even for <code>1</code>.\n</p>\n<p>\nThe ",
  "  result = 0\n  for x in lst\n    if x.is_a? Integer\n      if x > 0 \n       \
    \ result += x**2\n      end\n    elsif x < 0\n      result -= x**2\n    end\n\
    \  end\n  result\nend", "  return\nend\n</cell>\n<code language=julia-1.1>\ndouble_the_difference([2,\
    \ 3, 1, 9, 2])\n</cell>\n<text>\nProblem 2b", "    lst = lst || []\n    sum =\
    \ 0\n    even = lst.select { |x| x.even? }\n    odd = lst.select { |x| x.odd?\
    \ }\n    even.each{ |x| sum+= x }\n    odd.each{ |x| sum+= x }\n    return sum\n\
    end", "  return lst.inject(0, :+) * lst.inject(1, :*) # * means multiply and +\
    \ means add\nend", "    sum = 0\n    if lst.empty?\n        sum = 0\n    elsif\
    \ lst.size == 1\n        sum = lst[0]\n    elsif lst.size > 1\n        sum = lst[0]*lst[0]\n\
    \        sum.times do\n            sum = sum + lst.pop\n        end\n    end\n\
    \    sum\nend", "  lst.inject(0) do |sum, el|\n    sum + (el % 2) ? el * el :\
    \ 0\n  end\nend", "  return(0 if lst.empty? else lst.inject(0) {|sum,x| sum +\
    \ 2*x if x % 2 != 0} )\nend", "    total = 0\n    return 0 unless lst\n    \n\
    \    loop do\n        total += lst.pop\n        break unless lst", "  if lst.length\
    \ == 0\n    return 0\n  odd_sum = lst.select { |item| item % 2 == 1 }.inject(:+)\
    \ # => 10\n  odd_sum = odd_sum * 2\n  odd_sum\nend\n</code>\nHope that helps\n\
    <|/ a tags=ruby,algorithm,ruby-on-rails |>\n<| a dscore=2 |>\nThis can be done\
    \ in linear time by exploiting the fact that addition can be done in O(1). This\
    \ means that we can just keep adding the number to the total until the total is\
    \ greater than or equal to the number of elements minus one. \nFor example if\
    \ we had an array [1, 2, 3] and we started with an accumulation of 0 we would\
    \ add 1 to the total. We would then add 2 to the total. Then, if we had 3 we would\
    \ add 3 to the total and then subtract one from the total so we would get 0. Since\
    \ we can do additions in O(1) we can just keep adding until we get to 0 -\n<code>",
  "  sum = 0\n  sum += lst.inject(0) {|sum, item| sum + item**2 if item & 1 }\n  sum.abs\n\
    end\n</code>\n<|/ a tags=ruby,arrays,recursion dscore=2 |>\n<| c |>\nThis should\
    \ be the accepted answer. It's simple, correct, concise, and to the point.\n<|/\
    \ c |>\n<| c |>\nI feel like [#inject](http://www.ruby-doc.org/core-2.1.0/Enumerable.html#method-i-inject)\
    \ would be a better choice than a recursive method.\n<|/ c |>\n<| a |>\nThe recursive\
    \ approach is elegant, but you would be better off using a while loop and an accumulator.\
    \ For example:\n<code>", "  lst.each do |number|\n    if number.is_a?(Fixnum)\
    \ then\n      sum += number\n    elsif number <> -1 then\n      sum += number\
    \ * number\n    end\n  end\n  return sum\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nThis is unbelievably complicated for something so simple. Is there a reason\
    \ you chose to make it into a function rather than a method?\n<|/ c |>\n<| c |>\n\
    Not really. He chose this answer because it is more \"readable\". Also, it's more\
    \ easily expanded by others, and to show a more advanced technique involving looping.\n\
    <|/ c |>\n<| c |>\nYes, I agree; I did say it was unbelievably complicated but\
    \ also because the OP's original code was not valid Ruby code because it had no\
    \ `return`.\n<|/ c |>\n<| c |>\n`lst.each do |number|` should simply be `lst.each\
    \ { |number| ` if you want to avoid `sum` to be uninitialized.\n<|/ c |>\n<| c\
    \ |>\nYes, thanks for catching that; I edited the answer; thanks again!\n<|/ c\
    \ |>\n<| a tags=ruby dscore=0 |>\nHere's an alternative way I like.\n<code>",
  "  lst.each { |i| if i.is_a? Integer\n    return 0 + i if i.odd?\n    return 0 if\
    \ i == 0\n  }\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=ruby |>\n<code>\n\
    arr=[1,2,3,4,5,6]\narr.map(&:to_i).inject(:+)*2 #=> 26\n</code>\n<|/ a |>\n<|\
    \ c |>\n`arr=[1,2,3,4,5,6]; arr.map(&:to_i).inject(:+) * 2` will do the trick.\n\
    <|/ c |>\n<| a dscore=0 |>\nIf you don't want to use Enumerable:\n<code>", " \
    \ return lst.inject { |sum, n| sum + n } unless lst.empty?\n  0\nend\n</pre>",
  "    sum = 0\n    i = 0\n    while i < lst.count\n        if lst[i]%2 != 0\n   \
    \         sum += lst[i]\n        i += 1\n    return sum * sum\n</code>\nNow we\
    \ have the list functioning properly, so lets put it all together:\n<code>", " \
    \ sum = 0\n  \n  # Loop through each element in the list\n  lst.each do |n|\n\
    \    # If the element is not an integer, ignore it.\n    if !n.to_i.between?(-99999999,99999999)\
    \ then\n      # If the element is odd, add the square\n      if n.odd? then\n\
    \        sum += n * n\n      end\n    end\n  end\n  return sum\nend", "  return\
    \ lst.inject(0) {|sum,element| sum += element if element % 2 == 1}\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a tags=ruby |>\nIn one line\n<code>", "  return sum(lst)\n\
    end\n</cell>\n<cell>", "  # Your code goes here\n  result = 0\n  if lst.size >\
    \ 0\n    list.each do |i|\n      if i.to_i <= 0\n        continue\n      end\n\
    \      result += (2 * i)\n    end\n  end\n  result\nend", "  lst.each do |i|\n\
    \    if i.is_a? Integer\n      i +=\n      next\n    end\n    if i == 0 || i ==\
    \ nil\n      next\n    end\n    if i.odd?\n      i *= 2\n    end\n  end\n  lst.inject(0)\
    \ { |total, i| total + i }\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n\
    <code>", "  lst.map! { |x| x.is_a?(Fixnum) ? x : x.to_i }\n  sum = 0\n  lst.each_index\
    \ { |i| sum += (i**2).to_s }\n  sum.to_s.to_i\nend\n</code>\n<code>\n(DoubleTheDifferenceTest)\n\
    > double_the_difference([-1, -2, 0])\n=> 0\n> double_the_difference([9, -2])\n\
    => 81\n> double_the_difference([0])\n=> 0\n</code>\n<|/ a dscore=1 tags=ruby,sum,arrays,ruby-on-rails,ruby-on-rails-4\
    \ |>\n<| c |>\nI liked this answer as it explained why each method and why it's\
    \ better to use map instead of each.\n<|/ c |>\n<| c |>\nThank you for the explanation,\
    \ I appreciate it.\n<|/ c |>\n<| a tags=ruby,sum,arrays,ruby-on-rails,ruby-on-rails-4\
    \ |>\nThe method each_with_index will return the current value and the index at\
    \ the same time, so you can just use that to add to a running total and return\
    \ the total at the end.\n<code>", "  doubles = 0\n  doubles << 0\n  doubles <<\
    \ 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles << 0\n  doubles\
    \ << 0\n  doubles << 0\n  doubles << 0\n  doubles << ", "  lst.each do |x|\n \
    \   if x % 2 == 1\n      puts x\n      puts \"\\n\"\n    else\n      puts 0\n\
    \    end\n  end\nend\n</code>\n<|/ a tags=ruby,loops |>\n<| a tags=ruby,loops\
    \ |>\nThe code below is similar to your attempt, but is shorter and more readable:\n\
    <code>", "  if lst.empty?\n    0\n  elsif lst.any?\n    lst.inject(0) {|sum, number|\
    \ sum + number*number }\n  else\n    0\n  end\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis is amazing! I have never seen the inject method before. Looks like\
    \ I need to read up on it!\n<|/ c |>\n<| c |>\nI wrote some documentation in my\
    \ answer, which has examples in it. `inject` is really useful.\n<|/ c |>\n<| a\
    \ |>\nOne way to do it:\n<code>", "  return lst.map { |n| n * n }.reject { |n|\
    \ n < 0 }.reduce(:+)\nend\n</code>\n<|/ a dscore=2 tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| a dscore=2 tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<code>", "  sum\
    \ = 0 \n  arr.each do |x| \n    sum += (x % 2 == 1 ? x : 0)**2 \n  end\n  return\
    \ 0 if arr.empty?\n  return sum if sum == 0\n  return sum if sum < 0\n  return\
    \ sum * -1\nend", "  (0...lst.size).reduce {|a,b| a + lst.select {|x| x % 2 ==\
    \ 0 } }\nend", "    odd_sum = 0.0\n    \n    if lst.empty?\n        0\n    elsif\
    \ lst.size == 1\n        lst[0]\n    else\n        lst.each_with_index do |n,\
    \ i|\n            if n % 2 == 0\n                odd_sum += n * n\n          \
    \  else\n                odd_sum += -(n * n)\n            end\n        end\n \
    \   end\n    \n    odd_sum\nend\n</cell>\n<cell>", "  return lst.inject { |sum,\
    \ num| sum + num if num % 2 != 0 && num != 0 }\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=1 tags=ruby |>\nIf you want it to be even more fun, here's one more\
    \ version:\n<code>", "  \n  # Your code here\n  lst.map do |n|\n    return 0 if\
    \ n.to_i.zero?\n    return 0 if n.to_i == 0\n    return n if n % 2 == 1\n  end\n\
    \  lst.inject(0) {|s,x| s + x }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays\
    \ dscore=2 |>\n<| c |>\n`lst.inject(0) {|s,x| s + x }` is more efficient than\
    \ `lst.map { |n| n * 2 }.inject(&:+)` because `map` is O(n), `inject(&:+)` is\
    \ O(1).\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  sum = 0\n  lst.each do |x|\n\
    \    if x.is_a?(Integer) && x > 0\n      sum += x*x\n    elsif x.is_a?(Integer)\
    \ && x == 0\n      sum -= x\n    end\n  end\n  return sum\nend\n</code>\n<|/ a\
    \ tags=ruby,arrays dscore=0 |>\n<| c |>\nYour solution doesn't take into account\
    \ the negative numbers.  If you take in the example in OP, you will need to add\
    \ `sum -= x` after `sum += x*x`.  Or if you want to leave it out, just change\
    \ your if statement to `if x.is_a?(Integer) && x > 0`\n<|/ c |>\n<| a |>\n<code>",
  "    sum = 0\n    lst = lst.map { |i| i.to_i }\n    lst.reject { |x| x.zero? or\
    \ x.negative? }\n    lst.reverse.each_with_index do |n, i|\n        sum += n **\
    \ 2\n    end\n    return 0 if lst.empty?\n    return sum\nend\nputs double_the_difference([1,\
    \ 2, 3, 4])\nputs double_the_difference([5, 6, 7, 8, -9])\nputs double_the_difference([3,\
    \ 2.4, 0, -1, 4, -1, 5])\nputs double_the_difference([9.9, 2.5, 6, 4])\nputs double_the_difference([9])\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\n`[1, 2, 3, 4]` returns `20` instead of `10`.\n\
    <|/ c |>\n<| c |>\nThat's what I get for typing on a phone, sorry!\n<|/ c |>\n\
    <| a tags=ruby,recursion dscore=0 |>\nYou can just iterate over your array and\
    \ sum the squares, if you add all the squares up, and divide by the length of\
    \ the array. Something like this:\n<code>", "  if lst.empty?\n    0\n  else\n\
    \    lst.select do |item|\n      (item % 2).zero? && item != 0\n    end.inject(:+)\n\
    \  end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhat is the purpose of the last\
    \ line?  Is that the return of the inject call?\n<|/ c |>\n<| c |>\nyes, it is.\
    \ I thought it would be easier to understand\n<|/ c |>\n<| a dscore=1 tags=ruby\
    \ |>\nHere's my take:\n<code>", "    sum = 0\n    count = 0\n    \n    array.map\
    \ {|i| sum += i if i.odd? }\n    \n    return sum if count > 0 \n    \n    return\
    \ 0\nend\n</code>\n<|/ a |>\n<| c |>\nAvoid global variables.  Also, don't use\
    \ `.map`.  Use `map!` (unless you really need a mutable result, in which case\
    \ use `.map!`).  Also, use indentation in your code, not just in comments.  Code\
    \ is much easier to read, and makes it much easier for others to understand and\
    \ debug the code you write.\n<|/ c |>\n<| c |>\nI don't get what you mean by global\
    \ variables. How would you implement it in my code?\n<|/ c |>\n<| c |>\nUsing\
    \ global variables is considered bad programming practice.  When you use a global\
    \ variable, it's basically telling people that all functions in your program will\
    \ share the same value.  You would have to remember to make sure you assign the\
    \ value to each of your functions, which is slow.  Better to pass the variable\
    \ into your functions -- which won't require any globals.\n<|/ c |>\n<| c |>\n\
    Okay, so what would be the best way to get this done with out using global?\n\
    <|/ c |>\n<| c |>\nAs I said, pass it into your functions. I'll add a simple example\
    \ in my answer.\n<|/ c |>\n<| a dscore=0 |>\nHere is another solution using recursion:\n\
    <code>", "  lst.map!(&:to_i)\n  if lst.empty?\n    0\n  else\n    lst.inject(0)\
    \ {|sum, item| sum + item**2 if item % 2 == 1}\n  end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\nI know this is an old question, but for the record, here\
    \ is how to do this in Ruby 2.6+:\n<code>", "  sum=0\n  for i in lst\n    sum+=i*i\n\
    \  return sum if lst.empty? else sum*sum/2 \nend\n</cell>\n<cell>\ndouble_the_difference([5,4,2,7,0])\n\
    </cell>\n<cell>", "    sum = 0\n    max = lst[0]\n    for num in lst\n       \
    \ if num > 0\n            sum += (num * num)\n            max = num\n    return\
    \ sum\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nA more functional approach:\n\
    <code>\n(import '(java.io InputStream InputStreamReader PrintStream))", "    even\
    \ = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n   \
    \ even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n\
    \    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd =\
    \ 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd\
    \ = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n  \
    \  odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n\
    \    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even =\
    \ 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even\
    \ = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n   \
    \ even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n\
    \    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd =\
    \ 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd\
    \ = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n  \
    \  odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n\
    \    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even =\
    \ 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even\
    \ = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n   \
    \ even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n\
    \    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd =\
    \ 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd\
    \ = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n  \
    \  odd = 0\n    even = 0\n    odd = 0\n    even = 0\n    odd = 0\n    even = 0\n\
    \    odd = 0\n", "  sum = 0\n  lst.each do |number|\n    if number.odd?\n    \
    \  sum += number ** 2\n    end\n  end\n  return sum\nend\n</code>\nYou might want\
    \ to use Ruby's inject method though:\n<code>", "  # Your code here\n  return\
    \ lst.reduce(:+)\nend", "  lst.each do |element|\n    if (element.to_i < 0)\n\
    \      next\n    elsif (element.to_i == 0)\n      next\n    end\n    if (element.odd?)\n\
    \      square = element.to_i * element.to_i\n    end\n  end\n  return(square)\n\
    end\n</cell>\n<cell>", "  n = lst.to_s.length\n  sum = 0\n  for i in 1..n\n  \
    \  if lst[i].to_s.odd?\n      sum+=lst[i]\n    end\n  end\n  sum.abs\nend\n</code>\n\
    <|/ a |>\n<| c |>\n`if lst[i].to_s.odd?` could be `unless lst[i].to_s.odd?`\n\
    <|/ c |>\n<| c |>\n, that would not work if the list contains nil. You could just\
    \ do `lst[i].to_s.odd? and sum+=lst[i]`, but that would be less efficient because\
    \ it will run `to_s` on the string `nil` multiple times. If that\u2019s not an\
    \ issue, this is definitely a better solution.\n<|/ c |>\n<| c |>\nThis would\
    \ not work if nil was in the list. `nil.to_s.odd?` returns false, therefore the\
    \ sum wouldn\u2019t be added to it.\n<|/ c |>\n<| c |>\nIf `nil` is in the list,\
    \ `lst[i].to_s.odd?` will return `nil.to_s.odd?` which is false, meaning that\
    \ the sum wouldn\u2019t be added to it. So if `nil` was in the list, it would\
    \ not behave as expected. That\u2019s why I suggested `unless lst[i].to_s.odd?`\
    \ instead of `if lst[i].to_s.odd?`, which will not call `to_s` on `nil` multiple\
    \ times.\n<|/ c |>\n<| c |>\n`nil.to_s.odd?` is false because `nil.to_s` is nil\
    \ and so is false in ruby, so `lst[i].to_s.odd?` is false and the sum wouldn\u2019\
    t be added to it.\n<|/ c |>\n<| a dscore=1 |>\nI figured out a solution. \n<code>",
  "  lst.each_index {|i| lst[i] = lst[i].to_i if lst[i].is_a? Integer }\n  lst.sum\
    \ { |e| e * e }\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "    total\
    \ = 0\n    numbers = lst\n    if numbers.empty?\n        total = 0\n    else\n\
    \        numbers.each do |number|\n            if number > 0\n               \
    \ total += number**2 \n            end\n        end\n    end\n    return total\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby,ruby-on-rails,arrays |>\n<| a tags=ruby,ruby-on-rails,arrays\
    \ |>\n<code>", "  \n  # initialize an accumulator\n  sum = 0\n  \n  # loop through\
    \ the array\n  lst.each do |x|\n  \n    # if the number is odd, add it to the\
    \ accumulator\n    if x % 2 == 1\n      sum = sum + x\n    end\n  end\n  \n  #\
    \ return the accumulator\n  return sum\nend\n</code>\n<|/ a |>\n<| a |>\n<code>",
  "  # Your code here\n  sum = 0 \n  for i in lst\n    if i.to_i < 0\n      sum =\
    \ 0\n      break\n    else if i.to_i < 10\n      sum += i.to_i\n    else if i.to_i\
    \ < 100\n      sum += i.to_i ** 2\n    else if i.to_i < 1000\n      sum += i.to_i\
    \ ** 3\n    else if i.to_i < 10000\n      sum += i.to_i ** 4\n    else if i.to_i\
    \ < 100000\n      sum += i.to_i ** 5\n    else if i.to_i < 1000000\n      sum\
    \ += i.to_i ** 6\n    else if i.to_i < 10000000\n      sum += i.to_i ** 7\n  \
    \  else if i.to_i < 100000000\n      sum += i.to_i ** 8\n    else if i.to_i <\
    \ 1000000000\n      sum += i.to_i ** 9\n    else if i.to_i < 10000000000\n   \
    \   sum += i.to_i ** 10\n    else if i.to_i < 100000000000\n      sum += i.to_i\
    \ ** 11\n    else if i.to_i < 1000000000000\n      sum += i.to_i ** 12\n    else\
    \ if i.to_i < 10000000000000\n      sum += i.to_i ** 13\n    else if i.to_i <\
    \ 100000000000000\n      sum += i.to_i ** 14\n    else if i.to_i < 1000000000000000\n\
    \      sum += i.to_i ** 15\n    else if i.to_i < 10000000000000000\n      sum\
    \ += i.to_i ** 16\n    else if i.to_i < 100000000000000000\n      sum += i.to_i\
    \ ** 17\n    else if i.to_i < 1000000000000000000\n      sum += i.to_i ** 18\n\
    \    else if i.to_i < 10000000000000000000\n      sum += i.to_i ** 19\n    else\
    \ if i.to_i < 100000000000000000000\n      sum += i.to_i ** 20\n    else if i.to_i\
    \ < 1000000000000000000000\n      sum += i.to_i ** 21\n    else if i.to_i < 10000000000000000000000\n\
    \      sum += i.to_i ** 22\n    else if i.to_i < 100000000000000000000000\n  \
    \    sum += i.to_i ** 23\n    else if i.to_i < 1000000000000000000000000\n   \
    \   sum += i.to_i ** 24\n    else if i.to_i < 10000000000000000000000000\n   \
    \   sum += i.to_i ** 25\n    else if i.to_i < 100000000000000000000000000\n  \
    \    sum += i.to_i ** 26\n    else if i.to_i < 1000000000000000000000000000\n\
    \      sum += i.to_i ** 27\n    else if i.to_i < 10000000000000000000000000000\n\
    \      sum += i.to_i ** 28", "  sum = 0\n  count = 0\n  \n  if lst.empty?\n  \
    \  sum = 0\n    count = 0\n  else\n    lst.each do |i|\n      if i.odd?\n    \
    \    sum += i\n        count += 1\n      end\n    end\n    sum * 2\n  end\n  count\n\
    end", "  lst.each {|x| return 0 if !x || x.is_a? Integer and x < 0 ? 0 : (x +\
    \ x)**2 }\n  0\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,functional-programming\
    \ |>\n<| a tags=ruby,ruby-on-rails,functional-programming |>\nRuby has a method\
    \ called inject which takes two arguments: an initial value, and an enumerable\
    \ (array, hash, etc). So, if I were to write this in Ruby:\n<code>", "  total\
    \ = sum(lst.map { |e| e * e })\n  lst.each do |x| \n    next if x == 0\n    total\
    \ -= x * x\n  end\n  total\nend", "  sum = 0\n  for i in lst do\n    if i < 0\n\
    \      next\n    end\n    if i % 2 == 1\n      sum += i\n    end\n  end\n  sum\n\
    end\n</code>\nRuby also has a map function\n<code>", "  lst = lst.map {|x| x.to_i}\n\
    \  return lst.inject(0) {|sum,x| sum + x if x % 2 != 0} \nend\n</code>\nIt is\
    \ not that short because you are not using #inject, #map and #sum, but I think\
    \ it is clear and I hope you will use it in your future code.\n<|/ a tags=ruby\
    \ dscore=3 |>\n<| a |>\nYou can do this:\n<code>", "  result = 0\n  lst.each do\
    \ |x|\n    if x % 2 == 1\n      result += x\n    else\n      result -= x\n   \
    \ end\n  end\n  return result\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| c\
    \ |>\nI love the way you approached the problem. My brain had an issue with that.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "    arr.each do |a|\n        if (a % 2 ==\
    \ 1)\n            num = a + a\n        end\n    end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\nThis might seem like it would be more efficient to just use an\
    \ if statement but in practice it would be less efficient. You would want this\
    \ method to run as fast as possible, since it will be called a lot in a tight\
    \ loop.\n<code>", "  lst.each do |x|\n    if x.is_a? Integer\n      if x > 0 &&\
    \ x % 2 == 1\n        sum += x\n      end\n    end\n  end\n  sum\nend\n</pre>\n\
    <p>We can also use an iterator method instead, and more efficiently, but this\
    \ would just be for fun :)</p>\n<pre>", "  if lst.empty?\n    0\n  else\n    lst.inject(0)\
    \ { |a, e| a + e.abs }\n  end\nend", "  sum = 0 \n  for i in lst\n    if i.to_i\
    \ != 0 || i.to_i != i.to_i.to_i\n      sum = sum + i.to_i ** 2 \n    end\n  end\n\
    \  return sum\nend", "  return lst.inject(0) { |sum, n| sum + n * n }\nend\n</cell>\n\
    <text>\nExercise 4\nWrite a method that takes a single argument (a hash), and\
    \ adds all of the elements that are pairs in the hash.", "  lst.select{|x| x %\
    \ 2 == 1}.sum\nend\n</cell>\n<code language=conda-root-py>", "  lst.flatten!\n\
    \  lst.map!(&:to_i)\n  lst.sum.times { |i| if i.odd? then (i + i) end  }\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4 |>\n<| a |>\n<code>", " \
    \ sum = 0\n  lst.each do |num|\n    if num > 0\n      sum += num*num\n    end\n\
    \  end\n  return sum\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nCan you explain\
    \ how `sum + num*num` works? What is `sum` doing exactly?\n<|/ c |>\n<| c |>\n\
    `sum` is the running sum.  Each time through through the loop, `sum` is added\
    \ to `num*num`, which in ruby means you add `num` to `num`, which gives you the\
    \ running sum of squares\n<|/ c |>\n<| c |>\nWhat does `sum` do exactly? It's\
    \ not being used as a parameter of any function or method call. Is it a global\
    \ variable?\n<|/ c |>\n<| c |>\n`sum` is a local variable of the method `double_the_difference`.\
    \  It is initialized to `0` and is used as a sum.  At the end of the method, `sum`\
    \ is returned to the calling method.  Think of it as a local variable in the method,\
    \ rather than an argument to a function or method call.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nOne method without recursion:\n<code>", "  if lst.empty?\n    0\n  else\n\
    \    lst.map {|x| x * x }.inject(:+) * 2 \n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks, but I specifically asked for the non-railroad solution.\
    \ I'm just starting out to learn programming and am trying to learn Ruby and Rails\
    \ so I don't really want to be using any \"out of the box\" methods.\n<|/ c |>\n\
    <| a tags=ruby-on-rails,ruby |>\n<code>\na=[1,2,3]\na.find{|e|e%2==1}.inject(:+)",
  "  sum = 0\n  \n  if lst.empty?\n    sum = 0\n  else\n    sum = (lst.inject(0){|sum,x|\
    \ sum + x if x % 2 == 1})\n  end\n  \n  return sum\nend", "  return lst.inject(0)\
    \ { |sum, v| sum += (v.odd? ? v * 2 : v) }\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=1 tags=ruby |>\n<code>", "  lst = lst.to_a\n  lst.each do |x|\n  \
    \  x =~ /^-?\\d+$/ ? sum += x * x : float\n  end\n  return sum.to_i\nend", " \
    \ return lst.inject(0) { |total, num| total + num if num.is_a?(Integer) && num.odd?\
    \ }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like this answer because\
    \ it uses Ruby's `inject`. I never heard of `inject` before, so this was very\
    \ helpful. Still learning about this method! I do like the other solution though.\n\
    <|/ c |>\n<| c |>\n`inject` has been around a lot longer than `each`. It is an\
    \ extremely powerful tool which comes in handy in the Ruby community. It also\
    \ has the benefit of being a pure functional paradigm which makes it easy to write\
    \ unit tests.\n<|/ c |>\n<| a tags=ruby,arrays |>\nI think you should use 'each'\
    \ for every iteration and return the sum of the iterations.\n<|/ a dscore=1 |>\n\
    <| c |>\nYes, this is how I would do it.  However, if you do end up with more\
    \ complex code, I would suggest you break it up into smaller methods and use 'inject'\
    \ as a more declarative solution.\n<|/ c |>\n<| c |>\nI agree. I tend to use `each`\
    \ for simple things like counting and summing (`map { |x| x+1 }.inject(0, :+)`),\
    \ and `map` more for things like transforming values (`map { |x| x.to_s }`.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  return sum((lst | take_while{|n| n < 0}\
    \ | reject {|n| n.modulo(2) != 0} | inject {|n,sum|sum + n }) * lst)\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI wanted to implement this without recursion. How\
    \ would I do that?\n<|/ c |>\n<| a tags=functional-programming,ruby |>\nUsing\
    \ Enumerable#inject:\n<code>", "  lst.each do |i|\n    if i.odd?\n      result\
    \ += i\n    end\n  end\n  result\nend", "  lst = lst.select{|x| x % 2 == 1}\n\
    \  return lst.length == 0 ? 0 :  lst.inject(:+) * lst.length\nend", "  return\
    \ lst.inject(:+).to_i\nend\n</cell>\n<cell>\ndouble_the_difference([1, 3, 2, 0])\
    \ # Should return 10\ndouble_the_difference([-1, -2, 0]) # Should return 0\ndouble_the_difference([9,\
    \ -2]) # Should return 81\ndouble_the_difference([0]) # Should return 0\n</cell>\n\
    <text>\n5 - Recursion\nA recursive algorithm can make use of divide and conquer\
    \ algorithms to solve more complicated problems. To understand recursion, you\
    \ first need to understand recursion.", "    # Write your code here\n    sum =\
    \ 0\n    count = 0\n    for i in lst:\n        if i > 0 and i % 2 == 0:\n    \
    \        sum += i\n            count += 1\n    return sum * (count - 1)\n    \n\
    </cell>\n<cell>", "  return lst.inject(0) {|sum, elem| sum + elem.is_a?(Integer)\
    \ ? sum + elem : sum + elem.to_i * elem.to_i }\nend\n</code>\n<|/ a |>\n<| c |>\n\
    The `inject` method is a great way to achieve this and I think it's the only good\
    \ answer here.\n<|/ c |>\n<| c |>\nVery nice use of `inject`. However, it's worth\
    \ noting that if you're using Rails, you should really be using `Enumerable#sum`\
    \ with a `proc` rather than `inject`. `inject` is really only appropriate in situations\
    \ where you have a `nil` terminator - `inject` will happily iterate through all\
    \ the values even though it's clearly not the case. I'd really like to see Rails\
    \ take care of this - this would have been a nice addition anyway :)\n<|/ c |>\n\
    <| c |>\n, `inject` can be very useful in situations where you want a nil terminator\
    \ but do not want to explicitly use an `if` condition that would stop the `inject`\
    \ once the condition has been satisfied. For instance if you're using the `inject`\
    \ method to calculate the sum of a collection in Ruby that is a `nil` terminated\
    \ array, `reduce` is your friend.\n<|/ c |>\n<| a |>\nYou could do this with a\
    \ simple for loop:\n<code>", '  lst.flatten!', "    sum = 0\n    sum_odd = 0\n\
    \    for n in lst\n        if n>0\n            sum += n*n;\n            sum_odd\
    \ += n%2\n    end\n    sum\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks\
    \ a lot, but I am looking for another method. Sorry, for not mentioning that in\
    \ the original post.\n<|/ c |>\n<| c |>\nNo problem. I've added some alternatives.\
    \ Hope it helps.\n<|/ c |>\n<| c |>\nI wouldn't advise using that last one. He\
    \ was trying to solve the problem on his own. He didn't want to just provide code,\
    \ but to solve the problem for him to learn how to do it.\n<|/ c |>\n<| c |>\n\
    That last one is very nice but I don't think it works. If you change it to `sum\
    \ -= n%2 << 1` it works and it's more efficient than `sum -= n%2`\n<|/ c |>\n\
    <| c |>\nWhat I meant by \"the code is not efficient\" is that it works, but in\
    \ a very inefficient manner. That's why I put it in my answer as alternatives.\
    \ I'll make an edit to add that.\n<|/ c |>\n<| a dscore=3 |>\nUse reduce to sum\
    \ up the numbers\n<code>\nrequire 'set'", "    sum = 0\n    odd_nums = filter(is_odd,\
    \ lst)\n    sum = sum + sum( map(lambda x: x ** 2, odd_nums))\n    return sum\n\
    </code>\n<|/ a |>\n<| c |>\nNice one. I like the use of list comprehension.\n\
    <|/ c |>\n<| a tags=functional-programming,ruby,python dscore=1 |>\nRuby code\n\
    <code>", "  total = 0\n  for x in lst\n    if x.is_a? Integer\n      total +=\
    \ x if x % 2 == 1\n    else\n      total += 0\n    end\n  end\n  return total\n\
    end\n</code>\n<|/ a tags=ruby,syntax |>\n<| c |>\nThe `if`/`else` statement is\
    \ not needed, it can be replaced with `x += x if x % 2 == 1`.\n<|/ c |>\n<| c\
    \ |>\n: No, that will still be a ternary operator. `x +=` will be a binary operator:\
    \ `x +`. `x =` will be an assignment operator: `=`. `x ? y : z` is an expression:\
    \ `y`. This is called the \"ternary operator\" and is part of the Ruby language,\
    \ just like `if`/`else`/`while`, so it's very useful.\n<|/ c |>\n<| c |>\n: You're\
    \ right, thanks for clarifying.  I actually have no idea how I missed that.\n\
    <|/ c |>\n<| c |>\nI like how you use \"return\" without an argument in a method.\
    \ I don't think I've ever seen that before. Was this from a book or tutorial?\n\
    <|/ c |>\n<| c |>\n, I believe it was originally from Programming Ruby by Peter\
    \ Seibert, and Steve McKinney.  I think that book has been written by Matz himself\
    \ (Matz wrote the language and used his name as a nickname).  Steve's article\
    \ is a good example of why this particular construct is useful.\n<|/ c |>\n<|\
    \ a tags=ruby,syntax |>\n<code>", "    sum = 0\n    odd_numbers = lst.select {\
    \ |x| x % 2 == 1 }\n    odd_numbers.each { |x| sum += x }\n    return sum if lst.count?\n\
    \    0\nend", "  lst.each do |i|\n    return 0 if i.nil?\n    return 0 if i.is_a?(Float)\n\
    \    return 0 if i.to_i.zero?\n    return 0 if i.to_i.odd?\n    break\n  end\n\
    \  sum = 0\n  lst.each do |i|\n    sum = sum + i.to_i*i.to_i\n  end\n  return\
    \ sum\nend\n</code>\nRuby is a great language, but if you don't know how to use\
    \ it, the code can be harder to read/understand than it might be. \nIn this case,\
    \ you can iterate through the list and add each item to a variable called sum\
    \ and then multiply that by each item. \nThis can be done in two ways. The one\
    \ above is iterating through each item of the list but is more complicated to\
    \ understand and to modify if you need a different sum. \nThe other would be to\
    \ create a for loop which iterates through the list and adds the item to a variable\
    \ called sum and then multiply that by the item. The for loop can be found below:\n\
    <code>\nsum = 0\nfor i in list\n  sum = sum + i.to_i*i.to_i\nend\n</code>\nTo\
    \ understand what happens in the for loop look at the following example:\n<code>\n\
    for i in list\n  puts i.to_i*i.to_i\nend\n</code>\nThe puts command prints to\
    \ the console and you can change the number to a variable to see what the output\
    \ is for each item. \nThe output of the above code would look like this:\n<code>\n\
    0\n1\n3\n9\n</code>\nThis means we iterate through the list and add the items\
    \ to the variable sum, which in this case is the variable i. The variable i will\
    \ output the item in the list multiplied by itself times the item. This is why\
    \ it prints out 0: 1*1 = 1. \nThe same process can be done for other list methods\
    \ such as collect, map, etc. \nRuby is a great language for manipulating complex\
    \ data types and has a great developer community which many people use and contribute\
    \ to. \nI hope this was helpful, let me know if you have any questions.\n<|/ a\
    \ tags=ruby |>\n<| c |>\n`sum = 0` can be `sum = 0` without an `if`\n<|/ c |>\n\
    <| c |>\nThank you for your answer. I tried using your solution but I still don't\
    \ get the right answer. I'm still getting the same answer that the other guy gets.\
    \ I don't think this is correct. I just want to know the proper way of doing this\
    \ because I will be using a function like this a lot so I don't want to have to\
    \ rewrite it. Also, my professor doesn't want any complex solutions, he wants\
    \ us doing it with a single line like my solution.\n<|/ c |>\n<| ", "  lst.empty?\
    \ ? 0 : (lst.reduce(:+) ** (lst.size - lst.select {|n| n % 2 == 1}.count)) \n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  sum = 0\n  lst.each\
    \ do |x|\n    sum += (x**2) if (x % 2) == 1\n  end\n  sum\nend\n</cell>\n<cell>\n\
    double_the_difference([1, 2, 3, 4, 5])\n</cell>\n<text>\nNow let's write a function\
    \ that sums up all the numbers in a list that match a given criteria. We'll first\
    \ write one such function that takes a number and sums up all the odd numbers\
    \ below it.", "  if lst.empty?\n    0\n  else\n    lst.uniq.inject {|sum, el|\
    \ sum + el} + lst.uniq.inject {|sum, el| sum + el}\n  end\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThe `inject(:+)` combination was what I was looking for, thanks!\n\
    <|/ c |>\n<| a tags=ruby,arrays,math dscore=4 |>\n<code>", "    \n  sum_of_squares\
    \ = 0\n  \n  if lst.nil? then return 0\n  \n  lst.each do |item|\n    if item\
    \ % 2 == 1\n      sum_of_squares += item ** 2\n    end\n  end\n  \n  return sum_of_squares\n\
    \  \nend\n</cell>\n<cell>\ndouble_the_difference([1,3,2,0])\n</cell>\n<cell>\n\
    double_the_difference([-1,-2,0])\n</cell>\n<cell>\ndouble_the_difference([9,-2])\n\
    </cell>\n<cell>\ndouble_the_difference([])\n</cell>\n<text>\nExercise: Write a\
    \ method called fibonacci that, given an integer, returns the sum of all previous\
    \ integers up to the given integer.", "  lst.inject(0) {|sum, v| sum + (v % 2\
    \ != 0) ? v * v : 0}\nend", "    sum = 0\n    \n    sum.even = lst.select { |i|\
    \ i % 2 == 0 }\n    sum.odd = lst.select { |i| i % 2 != 0 }", "    # Write your\
    \ code here\n    return 0\nend\n</cell>\n<text>\nTest your double_the_difference\
    \ function with the cases below:", "  sum = 0\n  for i in lst.to_a\n    sum +=\
    \ i * i\n    next if i % 2 == 1\n    sum -= i\n  end\n  sum\nend", "  lst.each\
    \ do |x|\n    next if x.is_a? Integer\n    next if x.is_a? Float\n    next if\
    \ x.is_a? Bignum\n  end\n  double = 0\n  double += lst.sum if lst.sum % 2 == 1\n\
    \  double += lst.sum * lst.sum if lst.any? {|x| x % 2 == 1}\n  double\nend", " \
    \ sum = 0\n  if lst.empty?\n    sum = 0\n  elsif lst.last.is_a?(Fixnum)\n    sum\
    \ += lst.last\n    lst.pop\n  else\n    sum = 0\n    first = lst.first\n    first.times\
    \ {sum += first.to_i}\n    lst.pop\n    sum -= lst.last\n    sum.times { sum +=\
    \ lst.first }\n  end\n  sum\nend", "  return lst.inject(:+) \nend", "  lst.each\
    \ do |num|\n    (num.is_a?(Integer) && num > 0) ? num*num : num\n  end\n  sum\
    \ = 0\n  lst.each do |num|\n    sum += num if num.is_a?(Integer) && num > 0\n\
    \  end\n  sum\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nAs a sidenote:\
    \ I learned from this that you can do `if num > 0 num*num`. It actually works\
    \ the same as `num*num if num > 0`.\n<|/ c |>\n<| c |>\nAh, nice.  And as I said\
    \ earlier, you can even do `sum += num if num > 0` -- it does the same thing.\n\
    <|/ c |>\n<| c |>\nAlso `num*num if num > 0` is an example of a [ternary operator](http://en.wikipedia.org/wiki/%3F:).\
    \ Just kidding...\n<|/ c |>\n<| c |>\n: That's a ternary operator, not a ternary\
    \ operator.  It means \"return the value of the expression `num > 0 ? num*num\
    \ : num`\" but that value is not `num*num` but rather the value `num*num`.  As\
    \ a matter of fact, the ternary operator is sometimes called \"the conditional\
    \ operator\".\n<|/ c |>\n<| c |>\n: Sure, I get your point. And the name is inspiring\
    \ :) But I still think that *conditional operator* is a bad name for that, because\
    \ it is a ternary operator *with* a conditional operator in it. In your case you\
    \ could say that the conditional operator is a ternary operator with no *conditional*\
    \ operator in it. This has nothing to do with what the operator does. You only\
    \ need to know it when you use it on a line of its own, like `<condition> ? <value1>\
    \ : <value2>`.\n<|/ c |>\n<| a dscore=2 |>\nJust for kicks, here's a version which\
    \ does everything in one line:\n<code>", "    total = 0\n    even = 0\n    total\
    \ = 0\n    for i in lst\n        if i > 0\n            total += i\n          \
    \  even += i / 2\n    return total * total\nend", "  lst.each_with_index do |x,\
    \ i|\n    if x >= 0\n      diff = x - lst[i+1]\n      if diff % 2 == 1\n     \
    \   diff *= 2\n      else\n        diff /= 2\n      end\n      lst[i+1] = diff\n\
    \    end\n  end\n  return lst.inject(0){|sum, num| sum + num}\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThank you for your answer, however I want to know\
    \ if I can use each_with_index for this.\n<|/ c |>\n<| a dscore=0 |>\nHere is\
    \ a quick way to do it with each_cons:\n<code>", "    \n  return lst.inject {\
    \ |sum,x| sum + x }\nend ", "    list = lst.to_a\n    if list.empty?\n       \
    \ return 0\n    sum_of_squares = 0\n    \n    list.each_with_index do |item, index|\n\
    \        if item % 2 == 1 && index != 0\n            sum_of_squares = sum_of_squares\
    \ + item\n        end\n    end\n    sum_of_squares = sum_of_squares + 0\n    return\
    \ sum_of_squares\nend\n</code>\nThis works with any type of number (integers,\
    \ floats, strings, decimals, etc)\n<|/ a tags=ruby |>\n<| a dscore=2 |>\n<code>",
  "  return lst.inject(0) { |sum, element| element % 2 == 0 ? sum + element : sum\
    \ }\nend", "  lst.inject(0) {|result, x| result += x*x unless x.is_a?(Integer)\
    \ }\nend\n</code>\nThe inject method was added in 1.8.7. There are other ways\
    \ to accomplish this same thing, this is just one option to solve the problem\
    \ at hand.\nThe inject method takes two parameters, the block (first parameter)\
    \ and the initial value (second parameter). As you can see, the block simply adds\
    \ the value of the block argument x to the result of the block (result + x). \n\
    The block argument x is passed to the block with each iteration of the loop. The\
    \ block returns the value of result + x. \nThe initial value is 0 by default.\
    \ You can pass 0 as your initial value to start the iteration process off with\
    \ the first value passed to the block. This initial value will be returned by\
    \ the inject method at the very end of the loop. \nSo, in our case, we can see\
    \ that we're simply looping over the original list and performing whatever math\
    \ operation is needed on each number in the list. The final value returned by\
    \ the inject method is the sum of all the values in the original list that were\
    \ odd.\n<|/ a dscore=1 |>\n<| a |>\nYou can do it with map!\n<code>\n def double_the_difference(lst)\n\
    \  lst.map!(&:+).reject(&:zero?).reduce(:+)\n end\n</code>\n<|/ a tags=ruby dscore=0\
    \ |>\n<| c |>\nI believe `reject` removes all elements where `:zero?` returns\
    \ true. Did you test this code?\n<|/ c |>\n<| c |>\nYeah, I tested it and it works.\
    \ It seems I had my logic backwards, I edited the post.\n<|/ c |>\n<| c |>\nOh\
    \ wow... I did not know `map!` would modify the original array. It seems this\
    \ is pretty cool. I never knew you could do this.\n<|/ c |>\n<| c |>\nHa! I learned\
    \ something new today. I knew this was possible because I've done it before. I\
    \ just forgot about it.\n<|/ c |>\n<| a |>\nThe simplest way is to use inject:\n\
    <code>", "  \n  # initialize sum to 0\n  sum = 0", "    double_the_difference_rec\
    \ = double_the_difference_rec\n    def double_the_difference_rec(xs, sum)\n  \
    \      if xs == []\n            sum\n        else\n            double_the_difference_rec(xs[1..-1],\
    \ sum + xs[0])\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like the\
    \ elegance of your solution. However it isn't correct. Try `double_the_difference([0,-9,9])`\
    \ which should return 19. Instead it returns 20.\n<|/ c |>\n<| c |>\nFixed (I\
    \ think). I also think the solution is more elegant than mine!\n<|/ c |>\n<| a\
    \ dscore=1 |>\nHere's another solution:\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
