name: HumanEval_74_total_match
language: rb
prompt: "# Write a function that accepts two lists of strings and returns the list\
  \ that has \n# total number of chars in the all strings of the list less than the\
  \ other list.\n# if the two lists have the same number of chars, return the first\
  \ list.\n# Examples\n# total_match([], []) \u279E []\n# total_match(['hi', 'admin'],\
  \ ['hI', 'Hi']) \u279E ['hI', 'Hi']\n# total_match(['hi', 'admin'], ['hi', 'hi',\
  \ 'admin', 'project']) \u279E ['hi', 'admin']\n# total_match(['hi', 'admin'], ['hI',\
  \ 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n# total_match(['4'], ['1', '2', '3', '4',\
  \ '5']) \u279E ['4']\ndef total_match(lst1, lst2)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_total_match\n\
  \    candidate = method(:total_match)\n    assert_equal([], candidate.call([], []))\n\
  \    assert_equal([\"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hi\"\
  , \"hi\"]))\n    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"\
  ], [\"hi\", \"hi\", \"admin\", \"project\"]))\n    assert_equal([\"4\"], candidate.call([\"\
  4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]))\n    assert_equal([\"hI\", \"Hi\"],\
  \ candidate.call([\"hi\", \"admin\"], [\"hI\", \"Hi\"]))\n    assert_equal([\"hI\"\
  , \"hi\", \"hi\"], candidate.call([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]))\n\
  \    assert_equal([\"hi\", \"admin\"], candidate.call([\"hi\", \"admin\"], [\"hI\"\
  , \"hi\", \"hii\"]))\n    assert_equal([], candidate.call([], [\"this\"]))\n   \
  \ assert_equal([], candidate.call([\"this\"], []))\n  end\nend\n"
completions: ["    lst3 = []\n    if lst1.length == lst2.length\n        lst3 = (lst1.uniq.count.min)\n\
    \    else\n        lst3.concat(lst1.uniq.count.min)\n    end\n    return lst3\n\
    end", "  \n  lst3 = lst1\n  for i in lst2\n    lst3.count(i) <= lst3.count(i)\
    \ ? lst3.append(i) : nil\n  end\n  \n  return lst3\nend\n</cell>\n<cell>\ntotal_match([],\
    \ []) # => []\ntotal_match(['hi', 'admin'], ['hI', 'Hi']) # => ['hI', 'Hi']\n\
    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) # => ['hi', 'admin']\n\
    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) # => ['hI', 'hi', 'hi']\ntotal_match(['4'],\
    \ ['1', '2', '3', '4', '5']) # => ['4']\n</cell>\n<cell>", "  count = 0\n  lst2.each\
    \ do |i|\n    count += i.length\n  end\n  return lst1 if count == lst1.length\n\
    \  return lst2\nend", "    lst1.each {|word| lst2.each {|word| puts \"#{word.length}\
    \ <= #{word}\".length < 0 } \n    if lst1 == lst2\n        lst1\n    end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  return lst1 if lst1.length\
    \ == lst2.length then lst1 else lst2\nend", "    len1 = lst1.count('\\n')\n  \
    \  len2 = lst2.count('\\n')\n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n", "  count = count\n  count = 0\n  for i in lst1\n\
    \    count += i\n  for i in lst2\n    count += i\n  if count == 0\n    return\
    \ lst1\n  else\n    return lst2\nend", "  count=0\n  len1=lst1.length\n  len2=lst2.length\n\
    \  for i in 0..len1\n    for j in 0..len2\n      count=count+1\n      if((lst1[i].length<lst2[j].length)\
    \ && (lst1[i]=~lst2[j]))\n        return lst1\n      end\n    end\n  end\n  return\
    \ lst1\nend\n</cell>\n<code language=julia-0.6>\ntotal_match([],[])\n</cell>\n\
    <code language=julia-0.6>\ntotal_match(['hi', 'admin'], ['hI', 'Hi'])\n</cell>\n\
    <code language=julia-0.6>\ntotal_match(['hi', 'admin'], ['hi', 'hi', 'admin',\
    \ 'project'])\n</cell>\n<code language=julia-0.6>\ntotal_match(['hi', 'admin'],\
    \ ['hI', 'hi', 'hi'])\n</cell>\n<code language=julia-0.6>\ntotal_match(['4'],\
    \ ['1', '2', '3', '4', '5'])\n</cell>\n<code language=julia-0.6>\ntotal_match(['4'],\
    \ ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'])\n</cell>\n<code language=julia-0.6>\n\
    total_match(['4'], ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12',\
    \ '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25',\
    \ '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38',\
    \ '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '51',\
    \ '52', '53', '54', '55', '56', '57', '58', '59', '60', '61', '62', '63', '64',\
    \ '65', '66', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '77',\
    \ '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90',\
    \ '91', '92', '93', '94', '95', '96', '97', '98', '99', '100', '101', '102'])\n\
    </cell>\n<code language=julia-0.6>\ntotal_match(['4'], ['1', '2', '3', '4', '5',\
    \ '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19',\
    \ '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32',\
    \ '33', '34', '35', '36", "  return lst1[0] if lst1.size == lst2.size || lst2.size\
    \ == lst1.size ? lst1 : lst2\nend", "    match = true\n    i = 0\n    while i\
    \ < lst1.length && i < lst2.length\n        if lst1[i] == lst2[i]\n          \
    \  match && lst1.delete_at(i)\n            lst2.delete_at(i)\n            i +=\
    \ 1 \n        else \n            match && lst1.delete_at(i)\n            lst2.delete_at(i)\n\
    \            i += 1 \n    end\n    if i == lst1.length\n        match && lst2\n\
    \    end\nend\n</code>\n<|/ a dscore=2 tags=arrays,ruby,list |>\n<| c |>\nThis\
    \ answer does not produce the desired output in the question. Try running it.\n\
    <|/ c |>\n<| c |>\nYes, you are right. I misunderstood the question. I thought\
    \ it was a general `total_match` problem, like `total_match(['hi', 'admin'], ['hI',\
    \ 'Hi']) \u279E ['hI', 'Hi']`\n<|/ c |>\n<| a dscore=1 |>\nI used your code and\
    \ added a little tweaking to fix the result. Here is the code :\n<code>", "  sum1\
    \ = lst1.inject(0) {|sum, str| sum + str.size }\n  sum2 = lst2.inject(0) {|sum,\
    \ str| sum + str.size }\n  return lst1 if sum1 < sum2 || sum2 < sum1\n  lst1\n\
    end", "  return [char for char1, char2 in\n  zip(lst1, lst2) if char1 < char2]\n\
    end", "  lst = lst1.concat(lst2)\n  l = lst.size\n  lst[l - 1].length\n  lst1.concat\
    \ lst2\nend", '    return lst1[:] if lst1.size == lst2.size else lst1[:] if lst1.size
    <= lst2.size else lst2[:] if lst1.size >= lst2.size else lst1 ', "    return lst1\
    \ + [x for x in lst2 if x not in lst1]\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\n<code>", "  # TODO: Write your code here\n  return lst2\nend\n</cell>\n\
    <text>\nSort a List", "  \nend", "  lst2.each do |x|\n    lst1.each do |y|\n \
    \     if x == y\n        return lst1\n      end\n    end\n  end\nend", "  result\
    \ = []\n  count = 0\n  for i in lst1\n    if i <=> lst2[0] \n    count += 1\n\
    \  end\n  return result\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\n\
    `<=>` is an operator in Ruby 2.2+, but it is undocumented in Ruby 2.0 and earlier,\
    \ and is not part of the 1.9 core library. Thus the OP's code will probably not\
    \ work, but it is definitely an improvement, so +1.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "\tlst3 = lst1\n\tlst4 = lst2\n\t\n\twhile lst3.count < lst4.count\
    \ and lst3.count > 0\n\t\tlst3.pop\n\t\t\n\twhile lst4.count < lst3.count and\
    \ lst4.count > 0\n\t\tlst4.pop\n\t\t\n\tlst3 += lst4\n\t\n\twhile lst3.count !=\
    \ lst4.count\n\t\tlst3.pop\n\t\tlst4.pop\n\t\n\treturn lst3\n\t", "  \n  lst1.each_with_index\
    \ { |el, i| lst2.each_with_index { |el2, j| el[i...j] } }\n  lst1.uniq.count {\
    \ |el| el <=> lst2.first } == 0 ? lst1 : lst2\nend\n</cell>\n<cell>", "  \nend\n\
    </cell>\n<code language=julia-1.5>\ntotal_match([], []) \u2261 []\ntotal_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u2261 ['hI', 'Hi']\ntotal_match(['hi', 'admin'], ['hi',\
    \ 'hi', 'admin', 'project']) \u2261 ['hi', 'admin']\ntotal_match(['hi', 'admin'],\
    \ ['hI', 'hi', 'hi']) \u2261 ['hI', 'hi', 'hi']\ntotal_match(['4'], ['1', '2',\
    \ '3', '4', '5']) \u2261 ['4']\n</cell>\n<text>\nWe now have our helper function\
    \ and now we are ready to exploit the map function.", "\tcount = 0\n\tfor i in\
    \ lst1\n\t\tcount = count + i.count(\".\")\n\tfor i in lst2\n\t\tcount = count\
    \ + i.count(\".\")\n\tif lst1 == lst2 and lst1.count == lst2.count\n\t\treturn\
    \ lst1\n\telse\n\t\treturn lst2\nend", "  total = 0\n  total1 = 0\n  total2 =\
    \ 0\n  for x in lst1\n    total += x.length \n    total1 += x.length\n    total2\
    \ += x.length\n  for x in lst2\n    total += x.length \n    total1 += x.length\n\
    \    total2 += x.length\n  if total == total1 and total == total2\n    return\
    \ lst1\n  else\n    return lst2\nend\n  ", "    lst1.each do |item1|\n       \
    \ lst2.each do |item2|\n            if item1.length < item2.length\n         \
    \       lst2.delete(item2)\n            else\n                if item1.length\
    \ == item2.length\n                    lst2.delete(item2)\n                else\n\
    \                    if item1 > item2\n                        lst2.delete(item1)\n\
    \                    else\n                        if item1 < item2\n        \
    \                    lst2.delete(item2)\n                        end\n       \
    \             end\n                end\n            end\n        end\n    end\n\
    \    lst2\nend", "    len1 = lengths(lst1)\n    len2 = lengths(lst2)\n    diff\
    \ = len1 - len2\n    diff2 = len2 - len1\n    if len1 == len2 and diff == 0 :\n\
    \        return lst1\n    if len1 == len2 and diff2 == 0 :\n        return lst2\n\
    \    if len1 > len2 :\n        return total_match(lst2, lst1)\n    else :\n  \
    \      return total_match(lst1, lst2)", "  return lst1 if len(lst1) == len(lst2)\
    \ or len(lst2) == len(lst1) \\\n    else lst1 if len(lst1) < len(lst2) \\\n  \
    \  else lst2\nend", "    lst1.each_with_index do |word, index|\n        if lst2.count(word)\
    \ <= lst2.count(\"#{word}\") \n            lst2.delete(word)\n        end\n  \
    \  end\n    lst2\nend\n    ", "  result = []\n  temp1 = \"\"\n  temp2 = \"\"\n\
    \  temp3 = \"\"", "  # your code goes here\n  return lst1\nend", "    count1 =\
    \ lst1.count\n    count2 = lst2.count\n    if count1 == count2\n        lst1\n\
    \    elsif count1 == count2\n        lst2\n    elsif count1 < count2\n       \
    \ lst1\n    else\n        lst2\n    end\nend", "  lst1.count('') <=> lst2.count('')\
    \ \nend", "  return lst1 if lst1.length == lst2.length \n  lst1[lst1.length -\
    \ lst2.length...-1]\nend", "  diff1 =  lst1- lst2\n  diff2 = lst2- lst1\n  total_diff\
    \ = diff1.length + diff2.length\n  if total_diff == 0\n    diff1.length\n    diff2.length\n\
    \  elsif total_diff > 0\n    diff1\n  elsif total_diff < 0\n    diff2\n  end\n\
    end\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nWhile this code may answer the\
    \ question, providing additional context regarding how and/or why it solves the\
    \ problem would improve the answer's long-term value.\n<|/ c |>\n<| c |>\nWhile\
    \ this code is good and may answer the question, it doesn't explain how it works\
    \ and why it should be used and how it avoids the problem.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>", "    \n    l1 = lst1.count\n    l2 = lst2.count\n    \n    if l1\
    \ == l2 and l1 > 0:\n        return lst1\n    \n    if l1 > l2:\n        return\
    \ lst2\n    \n    return lst1\n</cell>\n<cell>", "    lst3=[]\n    lst1.each do\
    \ |a|\n        lst2.each do |b|\n            if a <b\n                lst3 <<\
    \ b\n            end\n        end\n    end\n    return lst1\nend", "    return\
    \ lst1 + lst2 if lst1 == lst2 else lst2\nend", "    count = [0] * (len(lst1) +\
    \ 1)\n    count = [0] + count\n    for el1 in lst1:\n        count[el1.count('h')]\
    \ += 1\n    \n    for el2 in lst2:\n        count[el2.count('h')] += 1\n    \n\
    \    for i in range(len(count)):\n        count[i] = max(count[i:])\n    \n  \
    \  return lst1[count[0]:count[-1] + 1]", "  # Your code goes here\n  return lst1\n\
    end", "  count = -1\n  i = 0\n  while i < lst2.length do\n    if lst1[i] < lst2[i]\
    \ then\n      count = count + 1\n    else\n      lst1.pop(i)\n      count = count\
    \ - 1\n    end\n    i = i + 1\n  end\n  return lst1\nend", "  # Write your code\
    \ here.\n  count = 0\n  for string1 in lst1:\n    for string2 in lst2:\n     \
    \ if len(string1) == len(string2) and string1 < string2:\n        count += 1\n\
    \  return lst1[count:]\n</cell>\n<cell>", "    \n    total = 0\n    \n    \n \
    \   for character in lst1:\n        if character in lst2 and character < lst2[lst2.index(character)]:\n\
    \            total += 1\n            \n    return lst1[0:lst1.index(lst2[lst2.index(character)])\
    \ if character in lst2 and character < lst2[lst2.index(character)] else lst1.index(lst2[lst2.index(character)])]",
  "  return [item for item in lst1 if item < lst2[lst1.index(item)]]\nend\nputs total_match(['hI',\
    \ 'Hi'], ['hI', 'Hi'])\nputs total_match(['4'], ['1', '2', '3', '4', '5'])\n</cell>\n\
    <text>\nExercise 3\nWrite a function that accepts two lists and returns the first\
    \ list that doesn't appear in the second list. For example, the first list contains\
    \ the words 'hello', 'goodbye', and 'thank you' and second list contains the words\
    \ 'goodbye' and 'thank you' then the function should return 'hello'. The function\
    \ should work for any number of lists. For example:\nword_unavailable(['hello',\
    \ 'goodbye'], ['goodbye', 'thank you']) \u279E ['hello']\nword_unavailable(['hello',\
    \ 'goodbye'], ['goodbye']) \u279E ['hello']\nword_unavailable(['hi', 'goodbye'],\
    \ ['goodbye', 'thank you']) \u279E ['hi']\nword_unavailable(['hi', 'goodbye'],\
    \ ['goodbye']) \u279E ['hi']\nword_unavailable(['hi', 'hi', 'goodbye'], ['goodbye',\
    \ 'thank you']) \u279E ['hi']\nword_unavailable(['hi', 'hi', 'goodbye'], ['goodbye'])\
    \ \u279E ['hi']\nword_unavailable(['4'], ['1', '2', '3', '4', '5']) \u279E ['4']",
  "  \n  return lst1 if len(lst1) == len(lst2) else lst2", '  return [i for i in lst1
    if len(i) < len(lst2) and i not in lst2]', "  if lst1.length == lst2.length\n\
    \    lst3 = [lst1[0]]\n    i = 0\n    while i < lst1.length\n      tmp = lst1[i].length\n\
    \      j = i\n      while j < lst1.length\n        tmp = tmp + lst1[j].length\n\
    \        j += 1\n      lst3 << lst1[i]\n      lst3 << lst1[j]\n      i += 2\n\
    \    return lst3\n  else\n    return lst1 if lst2.length < lst1.length else lst2\n\
    \  end\nend", "    sum = 0\n    while sum < len(lst1):\n        if lst1[sum] <=\
    \ lst2[sum]:\n            sum += 1\n        else:\n            sum = 0\n    return\
    \ lst1[:sum]", "  res = []\n  if lst1.length == 0 or lst2.length == 0\n    res\
    \ = []\n  else\n    lst1.each do |l1|\n      res = l1 if lst2.find { |l2| l2.length\
    \ == l1.length }.nil?\n    end\n  end\n  return res\nend\nputs total_match(['4'],\
    \ ['1', '2', '3', '4', '5'])\nputs total_match(['4'], ['1', '2', '3', '4', '5',\
    \ '6'])\nputs total_match(['hi', 'admin'], ['hI', 'Hi'])\nputs total_match(['hi',\
    \ 'admin'], ['hi', 'hi', 'admin', 'project'])\nputs total_match(['hi', 'admin'],\
    \ ['hI', 'hi', 'hi'])\nputs total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\n\
    puts total_match(['hi', 'admin'], ['hi', 'admin', 'project', 'hi'])\nputs total_match(['hi',\
    \ 'admin'], ['hi', 'admin', 'project', 'hi'])\nputs total_match(['hi', 'admin'],\
    \ ['hi', 'admin', 'project', 'hi', 'hi', 'hi'])\nputs total_match(['hi', 'admin'],\
    \ ['hi', 'admin', 'project', 'hi', 'hi', 'hi'])\nputs total_match(['hi', 'admin'],\
    \ ['hi', 'admin', 'project', 'hi', 'hi', 'hi'])\nputs total_match(['hi', 'admin'],\
    \ ['hi', 'admin', 'project', 'hi', 'hi', 'hi', 'hi'])\nputs total_match(['hi',\
    \ 'admin'], ['hi', 'admin', 'project', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi',\
    \ 'hi'])\nputs total_match(['hi', 'admin'], ['hi', 'admin', 'project', 'hi', 'hi',\
    \ 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi',\
    \ 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi',\
    \ 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi',\
    \ 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi',\
    \ 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi',\
    \ 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi',\
    \ 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi', 'hi',\
    \ '", "  return lst1 if (lst1.length == lst2.length) \n  else lst2 if (lst1.length\
    \ < lst2.length) \n  else lst1\nend", "  result = lst1.count { |x| lst2.count\
    \ { |y| y < x } }\n  result > lst2.size ? lst1 : lst2\nend\n</cell>\n<text>\n\
    2. Sort\nThe sort method sorts the elements of a sequence in place and returns\
    \ the modified sequence. By default, sort sorts using the <=> operator <=>. The\
    \ <=> operator compares two objects, and returns -1, 0, or 1 depending on whether\
    \ the first object is less than, equal to, or greater than the second object.",
  "  lst1.each do |char|\n    if lst2.include? char\n      lst2= lst2.delete_at char.index\n\
    \    end\n  end\n  return lst1\nend\nputs total_match(['4'], ['1', '2', '3', '4',\
    \ '5'])\nputs total_match(['4'], ['4', '4', '4', '5', '5'])\nputs total_match(['4'],\
    \ ['2', '4', '4', '4', '5'])\nputs total_match(['4'], ['4', '4', '4', '4', '5'])\n\
    puts total_match(['4'], ['4', '4', '4', '4', '5'])\nputs total_match(['4'], ['4',\
    \ '4', '4', '4', '5'])\nputs total_match(['4'], ['4', '4', '4', '4', '5'])\nputs\
    \ total_match(['4'], ['4', '4', '4', '4', '5'])\nputs total_match(['4'], ['4',\
    \ '4', '4', '4', '5'])\nputs total_match(['4'], ['4', '4', '4', '4', '5'])\nputs\
    \ total_match(['4'], ['4', '4', '4', '4', '5'])\nputs total_match(['4'], ['4',\
    \ '4', '4', '4', '5'])\nputs total_match(['4'], ['4', '4', '4', '4', '5'])\nputs\
    \ total_match(['4'], ['4', '4', '4', '4', '5'])\nputs total_match(['4'], ['4',\
    \ '4', '4', '4', '5'])\nputs total_match(['4'], ['4', '4', '4', '4', '5'])\nputs\
    \ total_match(['4'], ['4', '4', '4', '4', '5'])\nputs total_match(['4'], ['4',\
    \ '4', '4', '4', '5'])\nputs total_match(['4'], ['4', '4', '4', '4', '5'])\nputs\
    \ total_match(['4'], ['4', '4', '4', '4', '5'])\nputs total_match(['4'], ['4',\
    \ '4', '4', '4', '5'])\nputs total_match(['4'], ['4', '4', '4', '4', '5'])\nputs\
    \ total_match(['4'], ['4', '4', '4', '4', '5'])\nputs total_match(['4'], ['4',\
    \ '4', '4', '4', '5'])\nputs total_match(['4'], ['4', '4', '4', '4', '5'])\nputs\
    \ total_match(['4'], ['4', '4', '4', '4', '5'])\nputs total_match(['4'], ['4',\
    \ '4', '4', '4', '5'])\nputs total_match(['4'], ['4', '4', '4', '4', '5'])\nputs\
    \ total_match(['4'], ['4', '4', '4', '4', '5'])\nputs total_match(['4'], ['4',\
    \ '4', '4', '4', '5'])\nputs total_match(['4'], ['4', '4', '4', '4', '5'])\nputs\
    \ total_match(['4'], ['4', '4', '4', '4', '5'])\nputs total_match(['4'], ['4',\
    \ '4', '4', '4', '5'])\nputs total_match(['4'], ['4', '4', '4', '4', '5'])", " \
    \ # Write your code here\n  count = 0\n  for i in range(len(lst1)):\n    if lst1[i]\
    \ < lst2[i]:\n      count += 1\n  if lst1 == lst2 and count == len(lst1):\n  \
    \  return lst1\n  else:\n    return lst2\n</cell>\n<cell>\ntotal_match(['hi',\
    \ 'admin'], ['hI', 'Hi'])\n</cell>\n<cell>\ntotal_match(['hi', 'admin'], ['hi',\
    \ 'hi', 'admin', 'project'])\n</cell>\n<cell>\ntotal_match(['hi', 'admin'], ['hI',\
    \ 'hi', 'hi'])\n</cell>\n<cell>\ntotal_match(['4'], ['1', '2', '3', '4', '5'])\n\
    </cell>\n<cell>\ntotal_match(['hi', 'admin'], ['hI', 'admin'])\n</cell>\n<cell>\n\
    total_match(['hi', 'admin'], ['hI', 'admin', 'admin'])\n</cell>\n<cell>\ntotal_match(['4'],\
    \ ['1', '2', '3', '4', '5'])\n</cell>\n<text>\nWrite a function that accepts a\
    \ list of strings and returns a list of strings that does not contain any of the\
    \ strings in the other list\nIf the two lists have the same number of strings,\
    \ return the first list.", "  \n  # code here\n  \n  result = []\n  if len(lst1)\
    \ == len(lst2):\n    return result\n  else:\n    result.append(lst1)\n    return\
    \ result\n    \nprint(total_match(['4'], ['1', '2', '3', '4', '5']))\nprint(total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']))\nprint(total_match(['hi', 'admin'], ['hi', 'hi', 'admin',\
    \ 'project']))\nprint(total_match(['hi', 'admin'], ['hI', 'hi', 'hi']))\nprint(total_match(['hi',\
    \ 'admin'], ['hi', 'admin', 'project']))\nprint(total_match(['hi', 'admin'], ['hi',\
    \ 'hi', 'admin', 'project', 'hi']))\n</cell>\n<text>\nProblem 7 - Find all possible\
    \ combinations of n x n matrix subsets\nGiven an input matrix where every row\
    \ and every column contains same number of strings, find the total number of possible\
    \ combinations of n x n matrix subsets. Each subset should contains different\
    \ strings from every row and every column.", "\t\n\ta = []\n\tb = []\n\tfor i\
    \ in range(0, len(lst1)):\n\t\ta.append(lst1[i])\n\t\tb.append(lst2[i])\n\t\t\n\
    \tlst3 = []\n\tfor i in range(len(a)):\n\t\tlst3.append(len(a[i]))\n\t\t\n\tfor\
    \ i in range(len(b)):\n\t\tlst3.append(len(b[i]))\n\t\t\n\tfor i in range(len(a)):\n\
    \t\tif lst3[i] > lst3[i + 1]:\n\t\t\tlst3.append(lst3[i + 1])\n\t\t\t\n\tfor i\
    \ in range(len(b)):\n\t\tif lst3[i] > lst3[i + 1]:\n\t\t\tlst3.append(lst3[i +\
    \ 1])\n\t\n\tlst3 = lst3[:len(lst1) + 1]\n\t\n\tfor i in lst3:\n\t\tb.append(i)\n\
    \t\t\n\tlst3.sort()\n\t\n\tif lst1 == lst3:\n\t\treturn lst1\n\telse:\n\t\treturn\
    \ b\n\t\t", "  lst1 = lst1[0]\n  lst2 = lst2[0]\n  if lst1.size == lst2.size\n\
    \    lst1\n  else\n    lst1\n  end\nend\n</cell>\n<text>\nThe total_match function\
    \ was given below.", "    # Write code here\n    len1 = len(lst1)\n    len2 =\
    \ len(lst2)\n    return lst1[:len1] if len1<=len2 else lst2[:len2]\nprint(total_match(['hi',\
    \ 'admin'], ['hI', 'Hi']))\nprint(total_match(['hi', 'admin'], ['hi', 'hi', 'admin',\
    \ 'project']))\nprint(total_match(['hi', 'admin'], ['hI', 'hi', 'hi']))\nprint(total_match(['4'],\
    \ ['1', '2', '3', '4', '5']))\n</cell>\n<cell>", "  lst_count1 = lst1.count\n\
    \  lst_count2 = lst2.count\n  if lst_count1 == lst_count2\n    return lst1\n \
    \ else\n    lst_sum1 = lst1.reduce(0, :+) \n    lst_sum2 = lst2.reduce(0, :+)\n\
    \    lst_count = lst1.count\n    lst1.select{|item| lst_count1.include? item}.map{|i|\
    \ i.chars.map(&:to_i) }.flatten.uniq.map{|i| i.count}\n  end\nend", "  \n  \n\
    \  res = []\n  \n  if lst1.size == 0 and lst2.size == 0\n    return []\n    \n\
    \  if lst1.size != 0 and lst2.size != 0\n    if lst1[0] < lst2[0]\n      res =\
    \ lst1\n    else\n      res = lst2\n  end\n  \n  \n  return res\nend", "  return\
    \ lst1 if (lst2.length == lst1.length) \n    else lst2 if (lst2.length < lst1.length)\
    \ \n    else lst1\nend\n</cell>\n<code language=julia-1.5>\ntotal_match([\"hi\"\
    , \"admin\"], [\"hI\", \"Hi\"])\n</cell>\n<code language=julia-1.5>\ntotal_match([\"\
    hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n</cell>\n<code language=julia-1.5>\n\
    total_match([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])\n</cell>\n<code language=julia-1.5>",
  "    lc = 0\n    for str1 in lst1\n        for str2 in lst2\n            if str1\
    \ < str2\n                lc += 1\n    return lst1 if lc > len(lst2) else lst2\n\
    end\n</cell>\n<code language=julia-1.5>", "  lst1.each {|i| i.gsub!(\"\\n\", \"\
    \")} \n  lst2.each {|i| i.gsub!(\"\\n\", \"\")}\n  lst1.each {|i| i.gsub!(\"\\\
    n\", \"\")}\n  lst2.each {|i| i.gsub!(\"\\n\", \"\")}\n  lst1.each {|i| i.gsub!(\"\
    \\n\", \"\")}\n  lst2.each {|i| i.gsub!(\"\\n\", \"\")}\n  lst1.each {|i| i.gsub!(\"\
    \\n\", \"\")}\n  lst2.each {|i| i.gsub!(\"\\n\", \"\")}\n  if(lst1.size == lst2.size)\n\
    \    return lst1\n  elsif(lst1.size == lst2.size && lst2.size < lst1.size)\n \
    \   return lst2\n  elsif(lst1.size > lst2.size && lst1.size < lst2.size)\n   \
    \ return lst1\n  end\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\nThis question\
    \ has been answered here before. This question is about removing duplicates, not\
    \ counting them. Here is the solution:\n<code>", "  temp = []\n  temp1 = []\n\
    \  temp2 = []\n  temp3 = []\n  if lst1.size == 0\n    lst1.each{|i| temp << i}\n\
    \  else\n    lst1.each{|i| temp1 << i}\n  end\n  if lst2.size == 0\n    lst2.each{|i|\
    \ temp2 << i}\n  else\n    lst2.each{|i| temp2 << i}\n  end\n  temp3 = temp\n\
    \  temp.each{|i| temp1.each{|i| temp3.each{|j| temp3.remove(j)}} }\n  temp1 =\
    \ temp3\n  temp3.each{|i| temp2.each{|j| temp2.remove(j)}}\n  temp2 = temp2\n\
    \  temp2 = temp2\n  temp1 = temp1\n  temp1 = temp1\n  temp2 = temp2\n  temp3 =\
    \ temp3\n  temp1.each{|i| temp2.each{|j| temp3.each{|k| temp3.remove(k)}} }\n\
    \  temp2 = temp3\n  temp3 = temp3\n  temp2.each{|i| temp3.each{|j| temp3.remove(j)}}\
    \ \n  temp3 = temp3\n  temp2.each{|i| temp3.each{|j| temp3.remove(j)}} \n  temp3\
    \ = temp3\n  temp3.each{|i| temp2.each{|j| temp2.remove(j)}} \n  temp2 = temp2\n\
    \  temp2 = temp2\n  temp1 = temp1\n  temp3 = temp3\n  temp1.each{|i| temp2.each{|j|\
    \ temp3.each{|k| temp3.remove(k)}} }\n  temp2 = temp3\n  temp3 = temp3\n  temp2.each{|i|\
    \ temp3.each{|j| temp3.remove(j)}} \n  temp3 = temp3\n  temp2.each{|i| temp3.each{|j|\
    \ temp3.remove(j)}} \n  temp3 = temp3\n  temp3.each{|i| temp2.each{|j| temp2.remove(j)}}\
    \ \n  temp2 = temp2\n  temp2 = temp2\n  temp1 = temp1\n  temp3 = temp3\n  temp1.each{|i|\
    \ temp2.each{|j| temp3.each{|k| temp3.remove(k)}} }\n  temp2 = temp3\n  temp3\
    \ = temp3\n", "    \n    return lst1\n    \n</cell>\n<cell>", "  lst = []\n  \n\
    \  lst1.each do |item1|\n    lst2 = lst2.dup\n    lst2.delete item1\n    if lst2.empty?\n\
    \      lst.push item1\n    end\n  end\n  \n  return lst\nend", "    \n    # Write\
    \ code here", "    \nend", "  sum = 0\n  lst1.each { |x| sum += x.length }\n \
    \ lst2.each { |x| sum += x.length }\n  return lst1 if sum < lst2.length\n  sum\
    \ - lst2.length\nend", "  count = 0\n  for i in lst1\n    if i[0] in lst2\n  \
    \    count += 1\n  return lst1\nend", "  return lst1 if lst1.size == lst2.size\
    \ else lst1 if lst2.size == 0 else lst1 if lst1.size > lst2.size else lst1 if\
    \ lst2.size > 0 else []\nend\n</cell>\n<code language=julia-0.5>", "  \nend\n\
    </code>\n<|/ q tags=ruby dscore=0 |>\n<| c |>\nCan you clarify what your problem\
    \ is? Does your code not work?\n<|/ c |>\n<| c |>\nHi, I believe that I'm having\
    \ trouble with my syntax for my total_match method. I'm also unsure of what I\
    \ would actually write in the \"def total_match\" part. I just started learning\
    \ ruby this week and was really struggling.\n<|/ c |>\n<| c |>\n`def total_match(lst1,\
    \ lst2)` will define the method `total_match` which takes two arguments. `lst1`\
    \ and `lst2` are the two arguments that you want to pass to the method. `lst1`\
    \ is the one that is passed and `lst2` is the other that is passed.\n<|/ c |>\n\
    <| c |>\nWhat is your question? Does your code not work? If so, what are you struggling\
    \ with?\n<|/ c |>\n<| c |>\nIt does not work. I don't think my syntax for my total_match\
    \ method is correct. I'm new to coding so I'm struggling a bit.\n<|/ c |>\n<|\
    \ a tags=ruby |>\nHere you go:\n<code>", "\treturn lst1 if lst1.length == lst2.length\
    \ ? lst1 : lst2\nend\n</cell>\n<code language=julia-1.3>\ntotal_match(['hi', 'admin'],\
    \ ['hI', 'Hi'])\n</cell>\n<code language=julia-1.3>\ntotal_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project'])\n</cell>\n<code language=julia-1.3>\ntotal_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi'])\n</cell>\n<code language=julia-1.3>\ntotal_match(['4'],\
    \ ['1', '2', '3', '4', '5'])\n</cell>\n<text>\nWrite a function that returns true\
    \ if two strings match exactly (case matters). \nExamples\nmatchexactly('Hello',\
    \ 'Hello') \u279E true\nmatchexactly('Hello', 'hELlo') \u279E false\nmatchexactly('Hello',\
    \ 'Hello!') \u279E false\nmatchexactly('Hello', 'Hell') \u279E true\nmatchexactly('Hello',\
    \ 'HeLl') \u279E false", "  # Your code here\n  \nend\n</cell>\n<cell>", "  if\
    \ lst1.size == 0 or lst2.size == 0\n    return lst1\n  if lst1.size == lst2.size\n\
    \    return lst1\n  result = []\n  for i in 0..lst1.size\n    count = 0\n    for\
    \ j in 0..lst2.size\n      if lst1[i] == lst2[j]\n        count += 1\n      end\n\
    \    end\n    \n    if count < lst2.size\n      result << lst1[i]\n    end\n \
    \ end\n  return result\nend", "  return lst1.select { |x| lst2.count(x) <= lst2.count(x)\
    \ }\nend\n</code>\n<|/ a |>\n<| c |>\nYou might want to update this with a benchmark\
    \ to show how fast this is compared to other solutions that use the built-in `String#count`\
    \ method\n<|/ c |>\n<| c |>\nThis is by far the fastest solution. Thank you!\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "    \n    # Write your code here\n    \n\
    \    return lst1\n</cell>\n<cell>", "    return lst1 if len(lst1) == len(lst2)\
    \ and len(lst1) < len(lst2) else lst2\nend\n</cell>\n<code language=julia-1.5>",
  "  count = 0\n  i = 0\n  while i < lst1.length do\n    count += lst1[i].length\n\
    \    i += 1\n  end", "  lst1.sort.sort_by {|s| s.length }\n  lst2.sort.sort_by\
    \ {|s| s.length }\n  lst1 = lst1[0..lst1.size-1]\n  lst2 = lst2[0..lst2.size-1]\n\
    \  return [lst1, lst2] if lst1.size == lst2.size && lst1.each { |s| s.size ==\
    \ lst2.size ? s : nil }.size == lst1.size\n  return lst1 if lst2.size == lst1.size\
    \ && lst2.each { |s| s.size == lst1.size ? s : nil }.size == lst2.size\n  return\
    \ lst1 if lst1.size == lst2.size && lst1.each { |s| s.size == lst2.size ? s :\
    \ nil }.size != lst2.size\n  return nil\nend", "  \n  # Write code here\n  new_lst=[]\n\
    \  if len(lst1) == 0 or len(lst2) == 0: return []\n  \n  new_lst= [x for x in\
    \ lst1 if x < lst2[0]]\n  new_lst+= [x for x in lst1 if x >= lst2[0]]\n  new_lst.extend(x\
    \ for x in lst2 if x < lst1[-1])\n  new_lst.extend(x for x in lst2 if x >= lst1[-1])\n\
    \  \n  return new_lst\n</cell>\n<cell>\ntotal_match(['4'], ['1', '2', '3', '4',\
    \ '5'])\n</cell>\n<cell>\ntotal_match(['4'], ['1', '2', '3', '4', '5'])\n</cell>\n\
    <cell>\ntotal_match(['4'], ['1', '2', '3', '4', '5'])\n</cell>\n<cell>\ntotal_match(['4'],\
    \ ['1', '2', '3', '4', '5'])\n</cell>\n<text>\n4.1 Exercise: Counting Letters\
    \ in Strings", "  l = []\n  count = 0\n  for i in lst1\n    if i.count(i) <= lst2.count(i)\n\
    \      l.push(i)\n      count += 1\n  return l if count == lst2.count else []\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\nThis was my first try at solving\
    \ this problem in Ruby, but it seemed pretty inefficient to me, and I thought\
    \ maybe I needed to see other ways of tackling this problem:\n<code>", "  # Write\
    \ your code here\nend", "  len1 = lst1.count(' ')\n  len2 = lst2.count(' ')\n\
    \  if len1 == len2\n    return lst1 if len1 < len2 \n    return lst2 if len1 >\
    \ len2\n    return lst1 if len1 == len2\n    return lst2\n  end\n  if len1 < len2\n\
    \    return lst1 if len1 < len2\n    return lst2 if len1 == len2\n    return lst1\n\
    \    return lst2\n  end\n  return lst2\nend", "  arr1 = []\n  arr2 = []\n  \n\
    \  for i in lst1\n    arr1 << i.to_i\n  end\n  \n  for i in lst2\n    arr2 <<\
    \ i.to_i\n  end\n  \n  arr2.each { |el| arr1.delete_at(arr1.index(el)) }\n  \n\
    \  return arr1.uniq\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| a dscore=0 |>\n\
    Another solution, using inject and collect:\n<code>\narr1 = ['a','b','c']\narr2\
    \ = ['a','b','c']", "    diff_count = 0\n    len1 = lst1.length\n    len2 = lst2.length\n\
    \    temp1 = lst1.to_a\n    temp2 = lst2.to_a\n    \n    \n    temp1 = temp1.each_with_index\
    \ do |val, index|\n        diff = val.length - temp2.at(index).length\n      \
    \  diff_count = diff_count + diff\n    end\n    \n    temp1.delete_at(temp1.length\
    \ - 1)\n    temp2.delete_at(temp2.length - 1)\n    \n    \n    temp1.each_with_index\
    \ do |val, index|\n        diff = val.length - temp2.at(index).length\n      \
    \  diff_count = diff_count + diff\n    end\n    \n    if diff_count == len1\n\
    \        return lst1\n    elsif diff_count == len2\n        return lst2\n    else\n\
    \        return lst1\n    end\n    \nend", "  result = []\n  i = -1\n  j = 0\n\
    \  while i < lst1.length and j < lst2.length\n    if lst1[i] < lst2[j]\n     \
    \ result[j] = lst1[i]\n      i += 1\n    else \n      result[j] = lst2[j]\n  \
    \    j += 1\n  end\n  while i < lst1.length\n    result[j] = lst1[i]\n    i +=\
    \ 1\n    j += 1\n  end\n  while j < lst2.length\n    result[j] = lst2[j]\n   \
    \ j += 1\n  end\n  return result\nend", "  # Your code here\n  return lst1 + lst2\n\
    end", "  # TODO: Write your solution here\n  return []\nend\n</cell>\n<code language=julia-1.5>",
  "  puts \"l1 = #{lst1.size}\" \n  puts \"l2 = #{lst2.size}\" \n  puts \"l1 + l2\
    \ = #{(lst1 + lst2).size}\" \n  lst1 = lst1.size if lst1.size == []\n  lst2 =\
    \ lst2.size if lst2.size == []\n  puts \"l1 + l2 = #{(lst1 + lst2).size}\" \n\
    \  puts \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\"\
    \ \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 +\
    \ lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2\
    \ = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts\
    \ \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\"\
    \ \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 +\
    \ lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2\
    \ = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts\
    \ \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\"\
    \ \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 +\
    \ lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2\
    \ = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts\
    \ \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\"\
    \ \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 +\
    \ lst2).size}\" \n  puts \"l1 + l2 = #{(lst1 + lst2).size}\" \n  puts \"l1 + l2\
    \ = #{(lst1 + lst2).size}\" \n  put", "  # your code here\n  result = []\n  for\
    \ i in lst1\n    result << i\n  end\n  for i in lst2\n    result << i\n  end\n\
    \  result = result.sort\n  result.uniq.sort\n  result\nend\nputs total_match(['hi',\
    \ 'admin'], ['hI', 'Hi'])\nputs total_match(['hi', 'admin'], ['hi', 'hi', 'admin',\
    \ 'project'])\nputs total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\n</code>\n\
    <|/ a |>\n<| a tags=arrays,ruby,string |>\nTry this out. Its a very simple and\
    \ efficient way of doing this.\n<code>", "  l1.sort.merge(sort_list(lst2).sort.uniq).uniq\n\
    end\n</code>\n<|/ a tags=ruby,arrays dscore=0 |>\n<| a dscore=0 |>\nAssuming all\
    \ strings are non-negative, here's one way using Array#select:\n<code>", "  #\
    \ Your Code Here\nend", "  lst1.map { |a| a.length }.reduce(:+).min <= lst2.map\
    \ { |a| a.length }.reduce(:+).min ? lst1 : lst2\nend", "  return [i for i in lst1\
    \ if len(i) < len(lst2) and i.count(i[0]) <= lst2.count(i[0])]\nend\n</cell>\n\
    <code language=julia-1.5>", "  # your code here\n  min_len = min(len(lst1), len(lst2))\n\
    \  if min_len == len(lst1):\n    return lst1\n  elif min_len == len(lst2):\n \
    \   return lst2\n  else:\n    lst3 = [char for char in lst1 if char not in lst2]\n\
    \    return [char for char in lst1 if char not in lst2 and char in lst3]\n  ",
  "  \n  count = lst1.reduce(:+)\n  \n  lst1.each do |word1| \n    \n    if lst2.include?\
    \ word1\n      count += 1 \n    end\n    \n  end", "  ret = []\n  lst1.each do\
    \ |str|\n    lst2.each do |str2|\n      ret << str if str.length < str2.length\n\
    \    end\n  end\n  lst2.each do |str|\n    lst1.each do |str2|\n      ret << str\
    \ if str.length < str2.length\n    end\n  end\n  ret\nend", "  result=[]\n  \n\
    \  if lst1.length == lst2.length\n    lst1.each do |x|\n      result += x.chars.count\
    \ { |y| y <=> 0 }\n    end\n    \n  else\n    lst2.each do |x|\n      result +=\
    \ x.chars.count { |y| y <=> 0 }\n    end\n  end", "\tlst1.sort\n\tlst2.sort\n\t\
    count = 0\n\twhile count < lst1.size && count < lst2.size\n\t\tel1 = lst1[count]\n\
    \t\tel2 = lst2[count]\n\t\tif el1 < el2\n\t\t\tcount = count + 1\n\t\telse\n\t\
    \t\tcount = count + 1\n\t\tend\n\tend\n\tif count < lst1.size\n\t\treturn lst1\n\
    \telse\n\t\treturn lst2\n\tend\nend", "  lst3 = []\n  l1 = lst1.count(\"?\")\n\
    \  l2 = lst2.count(\"?\")\n  if l1 == l2\n    lst3.concat lst1\n  else\n    lst3.concat\
    \ lst1[1..l1]\n  end\n  lst3.concat lst2[1..l2]\n  lst3\nend\ntotal_match(['hi',\
    \ 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\ntotal_match(['hi', 'admin'], ['hi',\
    \ 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'],\
    \ ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\ntotal_match(['4'], ['1', '2',\
    \ '3', '4', '5']) \u279E ['4']\ntotal_match(['hi', 'admin'], ['hi', 'admin', 'project'])\
    \ \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hi', 'admin', 'project'])\
    \ \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hi', 'admin', 'project'])\
    \ \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hi', 'admin', 'project'])\
    \ \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hi', 'admin', 'project'])\
    \ \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hi', 'admin', 'project'])\
    \ \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hi', 'admin', 'project'])\
    \ \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hi', 'admin', 'project'])\
    \ \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hi', 'admin', 'project'])\
    \ \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hi', 'admin', 'project'])\
    \ \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hi', 'admin', 'project'])\
    \ \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hi', 'admin', 'project'])\
    \ \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hi', 'admin', 'project'])\
    \ \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hi', 'admin', 'project'])\
    \ \u279E ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hi', 'admin', '", " \
    \ lst1 = lst1.map {|s| s.split('').length}\n  lst2 = lst2.map {|s| s.split('').length}\n\
    \  return lst1 if lst1 == lst2 || lst1<lst2 ? lst1 : lst2\nend\nprint total_match(['hi',\
    \ 'admin'], ['hI', 'Hi'])\nprint total_match(['hi', 'admin'], ['hi', 'hi', 'admin',\
    \ 'project'])\nprint total_match(['hi', 'admin'], ['hI', 'hi', 'hi'])\nprint total_match(['4'],\
    \ ['1', '2', '3', '4', '5'])\n</code>\n<|/ a dscore=0 tags=ruby,arrays,string\
    \ |>\n<| c |>\nYou should point out that you are using `map` here, which is not\
    \ idiomatic Ruby.\n<|/ c |>\n<| c |>\nWhy? Why `map` not `collect`?\n<|/ c |>\n\
    <| c |>\nUsing `map` here is pointless, since it returns the same object as the\
    \ input.\n<|/ c |>\n<| c |>\nYes you are right. I updated the answer. Thanks\n\
    <|/ c |>\n<| c |>\nNice trick with `map`, I didn't know about that.\n<|/ c |>\n\
    <| a |>\nHere is my solution in Ruby 1.9.2:\n<code>", "  n1 = lst1.length\n  n2\
    \ = lst2.length\n  return lst1.to_a - lst2.to_a.sort_by(&:length).take(n2)\nend",
  "  lst1.each { |x| return x if lst2.count(x) < lst2.count }\n  lst1\nend\n</code>\n\
    <|/ a tags=ruby,sorting |>\n<| c |>\nI think this only works if the first array\
    \ is ordered the other way around, no?\n<|/ c |>\n<| c |>\nNo, this works also\
    \ if first array is ordered the other way around, just `sorted` the other list\
    \ to get a sorted array first, then compare the length of both lists.\n<|/ c |>\n\
    <| c |>\nYes, I missed that \"if both lists have the same number of chars, return\
    \ the first list\" part.\n<|/ c |>\n<| c |>\nThe question states \"return the\
    \ first list\" if both lists have the same number of characters. `total_match(['hi',\
    \ 'admin'], ['hi', 'hi', 'admin', 'project'])` returns `['hi', 'admin']` but it\
    \ should return `['hi', 'admin', 'project']`. Am I missing something?\n<|/ c |>\n\
    <| c |>\nyou're right I missed that part, but I'm too lazy to fix it\n<|/ c |>\n\
    <| a dscore=3 |>\n<code>", "  if lst1 == [] and lst2 == []\n    []\n  elsif lst1\
    \ == [] or lst2 == []\n    lst1\n  else\n    lst1 + total_match(lst1.last, lst2.first)\n\
    \  end\nend", "    \n    length_lst1 = len(lst1)\n    length_lst2 = len(lst2)\n\
    \    \n    if (length_lst1 == length_lst2):\n        return lst1\n    \n    diff1\
    \ = lst1[:length_lst1]\n    diff2 = lst2[:length_lst2]\n    \n    if (len(diff1)\
    \ > len(diff2)):\n        diff1 = diff1[:length_lst2]\n    \n    return diff1\
    \ + total_match(diff1, diff2)", "  l1 = lst1.count\n  l2 = lst2.count\n  return\
    \ [i for i in lst1 if l1 < l2 and l1 < len(i)]\nend", "  \nend\n</cell>\n<cell>",
  "  result = lst1\n  l1.each { |x| result += lst2 if x.size < lst2.size }\n  return\
    \ result if result.size == lst1.size\nend", "    return lst1\nend", "  result\
    \ = []\n  result2 = []\n  temp = []\n  count1 = []\n  count2 = []\n  \n  # get\
    \ the counts of characters in both lists. \n  for i in lst1:\n    if i not in\
    \ temp:\n      count1.append(i.count(i))\n    temp.append(i)\n  \n  for i in lst2:\n\
    \    if i not in temp:\n      count2.append(i.count(i))\n    temp.append(i)\n\
    \  \n  # get the maximum count in both the lists.\n  max1 = max(count1)\n  max2\
    \ = max(count2)\n  \n  # loop through the lists to check what chars there are\
    \ in the same place\n  for i, j in zip(count1, count2):\n    if i == j:\n    \
    \  continue\n    if i not in count1:\n      if j not in count2:\n        result.append(i)\n\
    \        continue\n      if max1 < j:\n        result2.append(i)\n        continue\n\
    \    if j not in count2:\n      if max2 < i:\n        result2.append(i)\n    \
    \    continue\n      if max2 < j:\n        result2.append(j)\n        continue\n\
    \      \n  return result", "    lc1 = []\n    lc2 = []\n    i = 0\n    j = 0\n\
    \    for x in lst1:\n        if lst1[i] < lst2[j]:\n            i += 1\n     \
    \       lc1.append(x)\n        else:\n            j += 1\n            lc2.append(x)\n\
    \    return lc1 if len(lc1) == len(lst2) else lc2", "  match = lst1\n  match.push(*[i\
    \ for i in lst1 if i not in match])\n  match.push(*[i for i in lst2 if i not in\
    \ match])\n  match.pop\n  match\nend", "    return [] if lst1.length < lst2.length\
    \ else lst1 if lst1.length == lst2.length else lst2\nend", "    count = 0\n  \
    \  lst = lst1 + lst2\n    list3 = []\n    for i in lst:\n        count += len(i)\n\
    \        list3.append(count)\n        if count > len(lst2):\n            break\n\
    \    return list3", "    lst = []\n    lst2 = lst2[:] # Make a shallow copy\n\
    \    lst3 = [] # Make an empty list\n    i = 0\n    j = 0\n    while i < len(lst1)\
    \ and j < len(lst2):\n        if lst1[i] < lst2[j]:\n            lst3.append(lst1[i])\n\
    \            i += 1\n        elif lst1[i] > lst2[j]:\n            lst3.append(lst2[j])\n\
    \            j += 1\n        else:\n            lst3.append(lst1[i])\n       \
    \     i += 1\n            j += 1\n    return lst3", "  return lst1 + [i for i\
    \ in lst2 if len(i) < len(lst1) and i not in lst1] if len(lst1) < len(lst2) else\
    \ lst2\n</code>\n<|/ a dscore=1 |>\n<| c |>\nAwesome! The second solution worked\
    \ perfectly! I tried something similar but did not think to make the conditions\
    \ separately.\n<|/ c |>\n<| c |>\nI am glad it helped you. Happy coding!\n<|/\
    \ c |>\n<| a dscore=0 |>\nOne liner:\n<code>", "    temp = []\n    temp2 = []\n\
    \    temp.push (lst1[0])\n    temp2.push (lst2[0])\n    for i in 0..(lst1.length\
    \ - 1)\n        if lst1[i].length <  lst2[i].length\n            temp2.push (lst2[i])\n\
    \        else\n            temp.push (lst1[i])\n    end\n    temp2 = temp2[0..(temp2.length-1)]\n\
    \    temp.push (temp2)\n    temp.sort! { |a,b| a.length <=> b.length }\n    return\
    \ temp\nend\n</cell>\n<code language=julia-0.6>\ntotal_match(['4'], ['1', '2',\
    \ '3', '4', '5'])\n</cell>\n<code language=julia-0.6>\ntotal_match(['4'], ['1',\
    \ '2', '3', '4', '5', '6', '7'])\n</cell>\n<code language=julia-0.6>\ntotal_match(['4'],\
    \ ['1', '2', '3', '4', '5', '6', '7', '8'])\n</cell>\n<code language=julia-0.6>\n\
    total_match(['4'], ['1', '2', '3', '4', '5', '6', '7', '8', '9'])\n</cell>\n<code\
    \ language=julia-0.6>\ntotal_match(['4'], ['1', '2', '3', '4', '5', '6', '7',\
    \ '8', '9', '0'])\n</cell>\n<code language=julia-0.6>\ntotal_match(['4'], ['1',\
    \ '2', '3', '4', '5', '6', '7', '8', '9', '0', '1'])\n</cell>\n<code language=julia-0.6>\n\
    total_match(['4'], ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2'])\n\
    </cell>\n<code language=julia-0.6>\ntotal_match(['4'], ['1', '2', '3', '4', '5',\
    \ '6', '7', '8', '9', '0', '1', '2', '3'])\n</cell>\n<code language=julia-0.6>\n\
    total_match(['4'], ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2',\
    \ '3', '4'])\n</cell>\n<code language=julia-0.6>\ntotal_match(['4'], ['1', '2',\
    \ '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5'])\n</cell>\n\
    <code language=julia-0.6>\ntotal_match(['4'], ['1', '2', '3', '4', '5', '6', '7',\
    \ '8', '9', '0', '1', '2', '3', '4', '5', '6'])\n</cell>\n<code language=julia-0.6>\n\
    total_match(['4'], ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2',\
    \ '3', '4', '5', '6', '7'])\n</cell>\n<code language=julia-0.6>\ntotal_match(['4'],\
    \ ['1', '2', '3', '4', '5', '6', '", "    total = 0\n    length1 = lst1.count(\"\
    hI\")\n    length2 = lst2.count(\"hI\")\n    if length1 == length2:\n        return\
    \ lst1\n    elif length1 < length2:\n        lst1 = [i for i in lst1 if i != \"\
    hI\"]\n        return lst1\n    else: \n        lst2 = [i for i in lst2 if i !=\
    \ \"hI\"]\n        return lst2", "  sum = 0\n  n = lst1.length\n  m = lst2.length\n\
    \  sum1 = nil\n  sum2 = nil\n  for i in 0...n\n    sum1 += lst1[i].length\n  end\n\
    \  for i in 0...m\n    sum2 += lst2[i].length\n  end\n  sum1 == sum2 ? lst1 :\
    \ lst2\nend", "    char_count = 0\n    chars_less = 0\n    chars_more = 0", " \
    \ return lst1 if len(lst1) < len(lst2) else lst2\nend", "  return lst1 if lst1.count\
    \ <= lst2.count and lst1.any? {|s| s.size < lst2.size}\n  lst2\nend", "  count\
    \ = 0\n  for i in lst1\n    count += i.length\n  for i in lst2\n    count += i.length\n\
    \  count", "  count1 = 0\n  count2 = 0\n  for i in lst1\n    count1 += i.count\n\
    \  end\n  for i in lst2\n    count2 += i.count\n  end\n  return lst1 unless count1\
    \ == count2\n  count1\nend", "  lst2.each do |x|\n    lst1.each do |y|\n     \
    \ if y > x\n        lst1.delete(y)\n      end\n    end\n  end\n  lst1\nend", " \
    \ \n  # your code here\n  \n  \n  return lst \n  \n  ", "  a = lst1.map(&:length).min\
    \ \n  b = lst2.map(&:length).min \n  lst1.take(a..b + 1).flatten.uniq\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI like the idea of using `take` and `flatten`. I think it's\
    \ pretty readable and understandable.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\n<code>\narr1 = [\"hi\", \"admin\"]\narr2 = [\"hI\", \"Hi\"]\n</code>\nYou\
    \ can do this:\n<code>\narr1.each_cons(2).map {|a, b| a.length + b.length}", " \
    \ return [i for i in lst1 if len(i) < len(lst2) or len(i) == len(lst2) or i in\
    \ lst2]\nend", "  result = []\n  count = {}", "  puts lst1\n  puts lst2\n  return\
    \ if lst1.size == lst2.size && lst1.size == 0\n  arr = []\n  lst2.each_with_index\
    \ do |item, index|\n    arr << item if lst1.include?(item)\n  end\n  arr\nend\n\
    total_match([], [])\ntotal_match(['hi', 'admin'], ['hI', 'Hi'])\ntotal_match(['hi',\
    \ 'admin'], ['hi', 'hi', 'admin', 'project'])\ntotal_match(['hi', 'admin'], ['hI',\
    \ 'hi', 'hi'])\ntotal_match(['4'], ['1', '2', '3', '4', '5'])", "  \nend", " \
    \ count = 0\n  lst1.each do |elem1|\n    lst2.each do |elem2|\n      count +=\
    \ 1\n      break if count > lst2.length - 1\n      break if elem1 == elem2\n \
    \   end\n    break if count > lst1.length - 1\n  end\n  return lst1 if lst1.length\
    \ == lst2.length && lst1.length == count\n  return lst1 if lst1.length != lst2.length\n\
    \  return []\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| a tags=ruby |>\n<code>",
  "  lst2 = lst2.sort\n  lst1 = lst1.sort\n  lst1.each_with_index do |char, i|\n \
    \   lst2[i] = char if char < lst2[i]\n  end\n  lst1 = lst1.sort\n  lst2 = lst2.sort\n\
    \  lst1.each_with_index do |char, i|\n    lst2[i] = char if char < lst2[i]\n \
    \ end\n  lst1.count <= lst2.count ? lst1 : lst2\nend\n</cell>\n<code language=julia-1.0>\n\
    total_match(['1', '2', '3', '4', '5'], ['4', '4', '5', '6', '7']) == ['4', '4',\
    \ '5', '6', '7']\n</cell>\n<code language=julia-1.0>\ntotal_match(['1', '2', '3',\
    \ '4', '5'], ['4', '4', '5', '6', '7', '5', '6', '7', '4', '5', '6', '7']) ==\
    \ ['4', '4', '5', '6', '7']\n</cell>\n<code language=julia-1.0>\ntotal_match(['1',\
    \ '2', '3', '4', '5'], ['4', '4', '5', '6', '7', '5', '6', '7', '4', '5', '6',\
    \ '7', '4', '5', '6', '7']) == ['4', '4', '5', '6', '7']\n</cell>\n<code language=julia-1.0>",
  "  # Your code here\n  return [] if lst2.count < lst1.count else lst1 if lst1.count\
    \ == lst2.count else lst2\nend", "  \n  res=[]\n  l1=len(lst1)\n  l2=len(lst2)\n\
    \  \n  if l1>l2:\n    res=lst2\n  else:\n    res=lst1\n  \n  sum=0\n  for i in\
    \ lst1:\n    for j in lst2:\n      if i<j:\n        sum+=1\n        break\n  \
    \  \n  if sum==l1:\n    for i in res:\n      res.append(i)\n    \n  return res",
  "  lst1.each do |i| \n    lst2.each do |j| \n      if (i <=> j) == -1\n        match\
    \ = i\n        break\n      end\n    end\n    return match\n  end\nend\n</cell>\n\
    <cell>", "  \n  # initialize counter\n  total = 0\n  \n  # loop through each element\
    \ in the list\n  for i in lst1\n  \n    # if the first element in the list is\
    \ less than the second\n    if i < lst2[0]\n      \n      # increment the counter\n\
    \      total+=1\n    \n      # break the loop\n      break\n    \n    # if the\
    \ first element in the list is greater than the second\n    if i > lst2[0]\n \
    \     \n      # update the counter\n      total+=1\n    \n      # break the loop\n\
    \      break\n    \n    # if the first element in the list is equal to the second\n\
    \    if i == lst2[0]\n      \n      # break the loop\n      break\n      \n  #\
    \ return the list\n  return lst1", "  return lst1 if lst1 == lst2 else lst1 +\
    \ lst2\nend\n</cell>\n<text>\nDay 10 - Spiral Numbers\nSpiral numbers are a sequence\
    \ that can be expanded from two angles. Write a function that accepts one argument\
    \ and returns the next number in the spiral starting at the origin and expanding\
    \ from one end of the spiral to the other.", "    match_lst = []\n    \n    if\
    \ len(lst1) == 0 and len(lst2) == 0:\n        match_lst = []\n    \n    elif len(lst1)\
    \ == 0:\n        match_lst = lst2\n    \n    elif len(lst2) == 0:\n        match_lst\
    \ = lst1\n    \n    else:\n        match_lst = lst1[:len(lst1)]\n        match_lst\
    \ += lst2[:len(lst1)]", "    \n    lst1.each do |i|\n        lst2.each do |j|\n\
    \            if i == j\n            else\n                break\n            end\n\
    \        end\n    end\n    return lst1\nend\n</cell>\n<code language=julia-1.6>\n\
    total_match(['4'], ['1', '2', '3', '4', '5']) \u279E ['4']\n</cell>\n<code language=julia-1.6>\n\
    total_match(['4'], ['1', '2', '3', '4', '5']) \u279E ['4']\n</cell>\n<code language=julia-1.6>\n\
    total_match(['4'], ['1', '2', '3', '4', '5', '6']) \u279E ['4']\n</cell>\n<code\
    \ language=julia-1.6>\ntotal_match(['4'], ['1', '2', '3', '4', '5', '6']) \u279E\
    \ ['4']\n</cell>\n<code language=julia-1.6>\ntotal_match(['4'], ['1', '2', '3',\
    \ '4', '5', '6']) \u279E ['4']\n</cell>\n<code language=julia-1.6>\ntotal_match(['4'],\
    \ ['1', '2', '3', '4', '5', '6']) \u279E ['4']\n</cell>\n<code language=julia-1.6>\n\
    total_match(['4'], ['1', '2', '3', '4', '5', '6']) \u279E ['4']\n</cell>\n<code\
    \ language=julia-1.6>\ntotal_match(['4'], ['1', '2', '3', '4', '5', '6']) \u279E\
    \ ['4']\n</cell>\n<code language=julia-1.6>\ntotal_match(['4'], ['1', '2', '3',\
    \ '4', '5', '6']) \u279E ['4']\n</cell>\n<code language=julia-1.6>\ntotal_match(['4'],\
    \ ['1', '2', '3', '4', '5', '6']) \u279E ['4']\n</cell>\n<code language=julia-1.6>\n\
    total_match(['4'], ['1', '2', '3', '4', '5', '6']) \u279E ['4']\n</cell>\n<code\
    \ language=julia-1.6>\ntotal_match(['4'], ['1', '2', '3', '4', '5', '6']) \u279E\
    \ ['4']\n</cell>\n<code language=julia-1.6>\ntotal_match(['4'], ['1', '2', '3',\
    \ '4', '5', '6']) \u279E ['4']\n</cell>\n<code language=julia-1.6>\ntotal_match(['4'],\
    \ ['1', '2', '3', '4', '5', '6']) \u279E ['4']\n</cell>\n<code language=julia-1.6>\n\
    total_match(['4'], ['1', '2', '3', '4', '5', '6']) \u279E ['4']\n</cell>\n<code\
    \ language=julia-1.6>", "  return lst1 + lst2 - lst1\nend", "  \n  lst1 = lst1.sort\
    \ # make sure they are in the same order\n  lst2 = lst2.sort\n  \n  count = 0\n\
    \  \n  while count < lst1.length\n    \n    pos = lst1.index( lst1[count] )\n\
    \    \n    count += 1 #count up one to keep comparing with the next char\n   \
    \ \n    if pos < lst2.length\n      lst1[pos] = lst1[pos].upcase #upcase the string\
    \ to count the chars\n      \n      count += 1 #count up one to keep comparing\
    \ with the next char\n      \n      break #break once the whole string is found\n\
    \    end\n  end\n  \n  lst1\nend\n</cell>\n<code language=julia-1.5>", "    \n\
    \    return [] if lst1.empty? and lst2.empty? else lst1[0] + lst2[0] if lst1.empty?\
    \ and lst2.empty? else [lst1[0] + lst2[0]] if (lst1[0].to_s.length == lst2[0].to_s.length\
    \ and lst1.length == lst2.length) \n    \n    l1 = lst1.map { |s| s.to_s.chars.map(&:ord)\
    \ }\n    l2 = lst2.map { |s| s.to_s.chars.map(&:ord) }\n    \n    return l1 if\
    \ l1.empty? and l2.empty? else l2 if l1.empty? and l2.empty? else [l1[0] + l2[0]]\
    \ if l1.length == l2.length\n    \n    l1.zip(l2).reduce(:+)\nend", "  match_len\
    \ = 0\n  while not lst1.empty? and not lst2.empty?\n    if lst1.pop(0) < lst2.pop(0)\n\
    \      match_len += 1\n    end\n  end\n  return match_len < lst1.length ? lst1\
    \ : lst2\nend", "  return lst1\nend", "  lst1.uniq.map { |x| lst2.count { |y|\
    \ x == y } }.max.zip(lst2).map(&:first).flatten\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nThanks Amit for the solution. I really appreciate your time. Thanks a lot\
    \ again!\n<|/ c |>\n<| a dscore=0 |>\nThe code I wrote for my recent project is\
    \ as follows: \n<code>", "  return lst1 if lst1.size == lst2.size && lst2.include?(lst1[0])\n\
    \  lst1 + lst2[1..-1]\nend", "  lst1.each_with_index { |a,i| \n    lst2.each_with_index\
    \ { |b,j| \n      if a.length < b.length\n        lst2.delete_at(i)\n      end\n\
    \    }\n  }\n  lst1\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\ni don't think your\
    \ solution will work with `total_match(['1', '2', '3', '4', '5'], ['4', '5'])`.\
    \ this will return `['4', '5']`\n<|/ c |>\n<| c |>\nI edited my question to make\
    \ it more clear what i'm looking for. I'm looking for a solution where i don't\
    \ need to change the lists at all\n<|/ c |>\n<| a dscore=0 |>\nHere's my attempt:\n\
    <code>", "  total = 0\n  for i in 0..(lst1.size - 1)\n    total += lst1[i].bytesize\
    \ + lst2[i].bytesize\n  return lst1 if (total == lst2.bytesize) \n  [lst1, lst2]\
    \ = [lst2, lst1]\n  lst1.each_with_index { |s,i| lst2[i] = lst1[i] if s <= lst2[i]\
    \ }\n  lst2\nend", "  \n  # Write your code here\n  if lst1.empty? or lst2.empty?\
    \ \n    return lst1 if lst1.size == lst2.size \n    \n  else\n    \n    count\
    \ = 0\n    \n    lst1.each do |x|\n      if lst2.include? x\n        count +=\
    \ 1\n      end\n    end\n    \n    if count == lst1.size\n      return lst1\n\
    \    else\n      return lst2\n    end\n  end\nend\nputs total_match(['a', 'b',\
    \ 'c', 'd', 'e'], ['a', 'b', 'c', 'd', 'e'])\nputs total_match(['a', 'b', 'c',\
    \ 'd', 'e'], ['a', 'b', 'c', 'd', 'd', 'e'])\nputs total_match(['a', 'b', 'c',\
    \ 'd', 'e'], ['a', 'b', 'c', 'd', 'e', 'f', 'g'])\nputs total_match(['a', 'b',\
    \ 'c', 'd', 'e'], ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'])\nputs\
    \ total_match(['5', '10', '20', '30', '40'], ['0', '1', '2', '3', '4', '5', '6',\
    \ '7', '8', '9'])\nputs total_match(['5', '10', '20', '30', '40'], ['0', '1',\
    \ '2', '3', '4', '5', '6', '7', '8', '10'])\nputs total_match(['5', '10', '20',\
    \ '30', '40'], ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'])\nputs\
    \ total_match(['5', '10', '20', '30', '40'], ['0', '1', '2', '3', '4', '5', '6',\
    \ '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20',\
    \ '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33',\
    \ '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46',\
    \ '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59',\
    \ '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72',\
    \ '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85',\
    \ '86', '87', '88', '89', '90', '91', '92', '93', '94', '95', '96', '97', '98',\
    \ '99', '100', '101', '102', '103', '104', '105', '106', '107', '108', '109',\
    \ '110', '111', '112', '113', '114', '", "    l1 = []\n    for i in lst1:\n  \
    \      count = 0\n        for j in lst2:\n            count += 1\n           \
    \ if i == j:\n                l1.append(i)\n                if count == len(lst2):\n\
    \                    return l1\n    return lst1\n</cell>\n<cell>\nprint(total_match([],\
    \ []))\nprint(total_match(['hi', 'admin'], ['hI', 'Hi']))\nprint(total_match(['hi',\
    \ 'admin'], ['hi', 'hi', 'admin', 'project']))\nprint(total_match(['hi', 'admin'],\
    \ ['hi', 'hi', 'hi']))\nprint(total_match(['4'], ['1', '2', '3', '4', '5']))\n\
    </cell>\n<text>\nProblem 9\nImplement a function that takes a list of strings\
    \ as input and returns a list of those strings that start with a given prefix.",
  "  # Your code goes here\n  lst3=[]\n  for i in lst1:\n    cnt=0\n    for j in lst2:\n\
    \      cnt+=len(i)-len(j)\n    if cnt>0:\n      lst3.append(i)\n  return lst3\n\
    print(total_match(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi'])\nprint(total_match(['hi',\
    \ 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin'])\nprint(total_match(['hi',\
    \ 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi'])\nprint(total_match(['4'],\
    \ ['1', '2', '3', '4', '5']) == ['4'])\n</cell>\n<cell>", "  return lst1[0..(lst1.length-1)].select\
    \ {|x| lst2.index(x) < lst2.length}\nend\n</cell>\n<text>\n3. Write a function\
    \ that accepts a string and returns the substring between the second and third\
    \ occurrence of \"-\" character.", "  lst1.each do |elem|\n    total = 0\n   \
    \ lst2.each do |e|\n      if elem < e\n        total = total + 1\n      end\n\
    \    end\n    return lst1 if total < lst2.count\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,string\
    \ |>\n<| a dscore=0 |>\nThis code will work even if the length of the strings\
    \ are different. I just tried to make it a little more flexible and easy to read.\
    \ \n<code>", "  return [x for x in lst1 if len(x) < len(lst2) and x in lst2]\n\
    end\n</cell>\n<code language=julia-1.5>", "  arr1 = Array.new\n  arr2 = Array.new\n\
    \  lst1.each { |str1| arr1 << str1 }\n  lst2.each { |str2| arr2 << str2 }\n  arr1.size.times\
    \ do |i|\n    arr1[i] << arr2[i]\n    arr2[i] << arr1[i]\n  end\n  arr1.uniq\n\
    end\n</code>\n<|/ a |>\n<| a dscore=0 tags=ruby,arrays |>\n<code>\na = [1, 2,\
    \ 3, 4]\nb = [3, 4, 5, 6]\nc = [a, b, a]", "    # Write your code here\n  \n \
    \   return lst1\n    \n</cell>\n<cell>", "    return lst1 if len(lst1) == len(lst2)\
    \ else lst2\nend", "  count = 0\n  \n  for x in lst1\n    for y in lst2\n    \
    \  if x < y\n        count += 1\n  \n  if count == len(lst1)\n    return lst1\n\
    \  else\n    return lst2\nend\n</cell>\n<code language=julia-1.0>\n@time begin\n\
    \  total_match(['4'], ['1', '2', '3', '4', '5']) \u279E ['4']\nend\n</cell>\n\
    <text>\nChallenge", "  result=[]\n  lst1.each do |e|\n    if lst2.include?(e)\n\
    \      result << e\n    end\n  end\n  return result if result.length==lst1.length\n\
    \  lst2.each do |e|\n    if !lst1.include?(e)\n      result << e\n    end\n  end\n\
    \  return result\nend", "  return lst1 + lst2[lst1.size - lst2.size..]\nend\n\
    </cell>\n<code language=julia-1.3>\ntotal_match(['4'], ['1', '2', '3', '4', '5'])\n\
    </cell>\n<code language=julia-1.3>\ntotal_match(['hi', 'admin'], ['hI', 'Hi'])\n\
    </cell>\n<code language=julia-1.3>\ntotal_match(['hi', 'admin'], ['hi', 'hi',\
    \ 'admin', 'project'])\n</cell>\n<code language=julia-1.3>\ntotal_match(['hi',\
    \ 'admin'], ['hi', 'hi', 'hi'])\n</cell>\n<code language=julia-1.3>\ntotal_match(['4'],\
    \ ['1', '2', '3', '4', '5'])\n</cell>\n<code language=julia-1.3>\ntotal_match(['hi',\
    \ 'admin'], ['hi', 'hi', 'hi', 'hi'])\n</cell>\n<code language=julia-1.3>\ntotal_match(['hi',\
    \ 'admin', 'project'], ['hi', 'hi', 'hi'])\n</cell>\n<code language=julia-1.3>\n\
    total_match(['hi', 'admin', 'project'], ['hi', 'hi', 'hi', 'hi'])\n</cell>\n<code\
    \ language=julia-1.3>\ntotal_match(['hi', 'admin', 'project'], ['hi', 'hi', 'hi',\
    \ 'hi', 'hi'])\n</cell>\n<text>\nExercise 2\nLet's rewrite total_match using filter\
    \ and length.", "\t\n\treturn lst1 if len(lst1) == len(lst2) else lst2\n\t\nprint\
    \ (total_match([], []))\nprint (total_match(['hi', 'admin'], ['hI', 'Hi']))\n\
    print (total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']))\nprint\
    \ (total_match(['hi', 'admin'], ['hi', 'hi', 'hi']))\nprint (total_match(['4'],\
    \ ['1', '2', '3', '4', '5']))\n</cell>\n<cell>", "  return lst1 if lst1.size ==\
    \ lst2.size && lst1.uniq.size == lst2.uniq.size && lst1.uniq.uniq.size == lst2.uniq.uniq.size\
    \ \n    && lst1.uniq.uniq.uniq.size == lst2.uniq.uniq.uniq.size\n    && lst1.uniq.uniq.uniq.uniq.size\
    \ == lst2.uniq.uniq.uniq.uniq.size\n    && lst1.uniq.uniq.uniq.uniq.uniq.size\
    \ == lst2.uniq.uniq.uniq.uniq.uniq.size \n    && lst1.uniq.uniq.uniq.uniq.uniq.uniq.size\
    \ == lst2.uniq.uniq.uniq.uniq.uniq.uniq.size \n    && lst1.uniq.uniq.uniq.uniq.uniq.uniq.uniq.size\
    \ == lst2.uniq.uniq.uniq.uniq.uniq.uniq.uniq.size \n    && lst1.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.size\
    \ == lst2.uniq.uniq.uniq.uniq.uniq.uniq.uniq.size \n    && lst1.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.size\
    \ == lst2.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.size \n    && lst1.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.size\
    \ == lst2.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.size \n    && lst1.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.unisize\
    \ == lst2.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.size \n    && lst1.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.size\
    \ == lst2.uniq.uniq.uniq.uniq.uniq.uniq.uniq.size \n    && lst1.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uni.size\
    \ == lst2.uniq.uniq.uniq.uniq.uniq.uniq.uniq.size \n    && lst1.uniq.uniq.uniq.uniq.uniq.uniq.uniq.uni.uniq.size\
    \ == lst2.uniq.uniq.uniq.uniq.uniq.uniq.uniq.size \n    && lst1.uniq.uniq.uniq.uniq.uniq.uniq.uni.q.size\
    \ == lst2.uniq.uniq.uniq.uniq.uni.q.size \n", "    # Your code here\n    sum1\
    \ = sum([len(x) for x in lst1 if len(x) > 0])\n    sum2 = sum([len(x) for x in\
    \ lst2 if len(x) > 0])\n    if sum1 == sum2:\n        return lst1\n    else:\n\
    \        return lst2", "  if lst1.length == lst2.length\n    lst1.each do |str1|\n\
    \      lst2.each do |str2|\n        str1.each_char.inject(0) {|sum, char| sum\
    \ + char.ord } <= str2.each_char.inject(0) {|sum, char| sum + char.ord }\n   \
    \   end\n    end\n  else\n    lst1\n  end\nend", "  lst3 = []\n  \n  for str in\
    \ lst1:\n    for str2 in lst2:\n      if(str < str2):\n        lst3.append(str)\n\
    \      elif(str == str2):\n        lst3.append(str)\n        break\n      \n \
    \ return lst3\nprint(total_match(['hi', 'admin'], ['hI', 'Hi']))\nprint(total_match(['hi',\
    \ 'admin'], ['hi', 'admin', 'project']))\nprint(total_match(['hi', 'admin'], ['hi',\
    \ 'hi', 'hi']))\nprint(total_match(['4'], ['1', '2', '3', '4', '5']))\n</cell>\n\
    <cell>", "  return [] if lst1.size < lst2.size else lst1\nend\n</cell>\n<cell>",
  "\treturn [x for x in lst1 if x in lst2 if lst2.count(x) == lst1.count(x)]\nend\n\
    </cell>\n<code language=julia-1.5>", "  \n  lst1 = lst1.sort\n  lst2 = lst2.sort\n\
    \  \n  total_chars = 0\n  \n  for i in 0...lst1.count\n    total_chars = total_chars\
    \ + lst1[i].count\n  end\n  \n  for i in 0...lst2.count\n    total_chars = total_chars\
    \ + lst2[i].count\n  end\n  \n  if total_chars == lst1.count || total_chars ==\
    \ lst2.count\n    return lst1\n  else\n    return lst2\n  end\n  \nend", "  return\
    \ lst1 if lst2.count == lst1.count ? lst1 : lst2\nend\n</cell>\n<code language=julia-1.5>\n\
    total_match([\"hi\", \"admin\"], [\"hI\", \"Hi\"])\n</cell>\n<code language=julia-1.5>\n\
    total_match([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])\n</cell>\n\
    <code language=julia-1.5>\ntotal_match([\"hi\", \"admin\"], [\"hi\", \"hi\", \"\
    hi\"])\n</cell>\n<code language=julia-1.5>\ntotal_match([\"4\"], [\"1\", \"2\"\
    , \"3\", \"4\", \"5\"])\n</cell>\n<code language=julia-1.5>\ntotal_match([\"4\"\
    ], [\"1\", \"2\", \"3\", \"4\", \"5\"], ignorecase = true)\n</cell>\n<code language=julia-1.5>\n\
    total_match([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"], ignorecase = false)\n\
    </cell>\n<code language=julia-1.5>\ntotal_match([\"4\"], [\"1\", \"2\", \"3\"\
    , \"4\", \"5\"], ignorecase = true)\n</cell>\n<code language=julia-1.5>\ntotal_match([\"\
    4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"], ignorecase = false)\n</cell>\n<code\
    \ language=julia-1.5>\ntotal_match([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"\
    ], ignorecase = true)\n</cell>\n<code language=julia-1.5>\ntotal_match([\"4\"\
    ], [\"1\", \"2\", \"3\", \"4\", \"5\"], ignorecase = false)\n</cell>\n<text>\n\
    3.4.2 Matching Strings", "  total = 0\n  for i in lst1\n    total += i.length\n\
    \  for i in lst2\n    total -= i.length\n  return lst1 if total == 0 else lst2\n\
    end", "  return [x for x in lst1 if len(x) <= len(lst2) or len(x) == len(lst2)\
    \ and x == lst2[0]]\nend", "    lst3 = []\n    if lst1.size == 0\n        lst3\
    \ += lst2\n        return lst3\n    \n    if lst2.size == 0\n        lst3 += lst1\n\
    \        return lst3", "  \n  # Write your code here\n  \n  return lst1\n</cell>\n\
    <cell>", "  lst1.each_with_index do |s, i|\n    lst2.each_with_index do |t, j|\n\
    \      if (s.to_i < t.to_i)\n        break\n      else\n        lst2[j] = ''\n\
    \      end\n    end\n  end\n  lst2\nend", "  temp=[]\n  l=len(lst1)\n  k=len(lst2)\n\
    \  if l==k\n    temp=lst1\n  elsif k>l\n    temp=lst2\n  elsif l<k\n    temp=lst2\n\
    \    temp=temp+[temp[-1]]*(l-k)\n  end\n  temp\nend", "  ret = []\n  i = 0\n \
    \ j = 0\n  while i < len(lst1) and j < len(lst2)\n    if lst1[i] == lst2[j] \n\
    \      ret.append(lst1[i])\n      i += 1\n      j += 1\n    i += 1\n    j += 1\n\
    \  return ret", "  total_chars = lst1.length + lst2.length\n  \n  return lst1\
    \ if total_chars == lst2.length else lst2\nend", "    lst1.each do |str1|\n  \
    \    lst2.each do |str2|\n        if str1.length < str2.length\n          return\
    \ str1\n        end\n      end\n    end\n    return lst1\nend\n</cell>\n<cell>",
  "    lst3 = lst1\n    lst4 = lst2\n    count = 0\n    while count < lst3.count and\
    \ count < lst4.count\n        if lst3[count] <lst4[count]\n            lst3.delete_at(count)\n\
    \            lst3.insert(count, lst4[count])\n            lst4.delete_at(count)\n\
    \            lst4.insert(count, lst3[count])\n            lst3.count -= 1\n  \
    \          lst4.count -= 1\n        end\n        count += 1\n    end\n    lst3.concat(lst4[1..lst4.count])\n\
    \    return lst3\nend\n</cell>\n<cell>", "  return lst1 if lst1.length == lst2.length\
    \ else lst1[lst1.length..-1]\nend", "    lst1.each do |x|\n        lst2.each do\
    \ |y|\n            if x <=> y > 0\n                lst1\n                break\n\
    \            end\n        end\n    end\nend", "  return lst1 if lst1.size == lst2.size\
    \ && lst1.sort<lst2.sort ? lst1 : lst2\nend", "  if lst1.length==0\n    return\
    \ lst2\n  elsif lst2.length==0\n    return lst1\n  elsif lst1.length==lst2.length\n\
    \    i=0\n    while(i<lst1.length)\n      return lst1 if lst1[i] < lst2[i] else\
    \ lst2\n      i+=1\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n\
    <code>", "  return lst1 if lst1.size == lst2.size && lst1.size <= lst2.size &&\
    \ lst2.size >= lst1.size ? \n    lst1 : lst2\nend\n</code>\n<|/ a dscore=3 |>\n\
    <| a |>\n<code>", "  lst2.each_with_index do |val, index|\n    if lst1.size ==\
    \ index && lst2.size == index\n      return lst1\n    elsif lst1.size == index\n\
    \      return lst1\n    elsif lst2.size == index\n      return lst1\n    end\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nI have edited the answer. Now its working\
    \ fine :)\n<|/ c |>\n<| a |>\n<code>", "  arr1 = lst1.map{|x| x.size}.uniq\n \
    \ arr2 = lst2.map{|x| x.size}.uniq", "  l1 = lst1.size\n  l2 = lst2.size\n  if\
    \ l1 == 0\n    lst1\n  elsif l2 == 0\n    lst2\n  else\n    total = []\n    i\
    \ = 0\n    while i < l1 and i < l2\n      total << lst1[i]\n      i += 1\n   \
    \ while i < l1\n      total << lst1[i]\n      i += 1\n    while i < l2\n     \
    \ total << lst2[i]\n      i += 1\n    total\n  end\nend\n</cell>\n<cell>", " \
    \ return lst1 if  all(map(lambda str1: str, str2: str1 == str2, lst1, lst2)) else\
    \ lst2\nend\n</cell>\n<code language=julia-1.5>\nfunction check_match_exact(lst1,\
    \ lst2)\n  return total_match(lst1, lst2) if length(lst1) == length(lst2) else\
    \ false\nend\n</cell>\n<code language=julia-1.5>\ncheck_match_exact(['hi', 'admin'],\
    \ ['hI', 'Hi'])\n</cell>\n<code language=julia-1.5>\ncheck_match_exact(['hi',\
    \ 'admin'], ['hi', 'hi', 'admin', 'project'])\n</cell>\n<code language=julia-1.5>\n\
    check_match_exact(['hi', 'admin'], ['hi', 'hi', 'hi'])\n</cell>\n<code language=julia-1.5>\n\
    function check_match_substrings(lst1, lst2)\n  return total_match(lst1, lst2)\
    \ if all(map((str) -> string(str) in string(str1), lst1, lst2)) else false\nend\n\
    </cell>\n<code language=julia-1.5>\ncheck_match_substrings(['hi', 'admin'], ['hI',\
    \ 'Hi'])\n</cell>\n<code language=julia-1.5>\ncheck_match_substrings(['hi', 'admin'],\
    \ ['hi', 'hi', 'admin', 'project'])\n</cell>\n<code language=julia-1.5>\ncheck_match_substrings(['hi',\
    \ 'admin'], ['hi', 'hi', 'hi'])\n</cell>\n<code language=julia-1.5>\nfunction\
    \ check_match_substrings_case(lst1, lst2)\n  return total_match(lst1, lst2) if\
    \ all(map((str) -> string(str) in string(str1, uppercase), lst1, lst2)) else false\n\
    end\n</cell>\n<code language=julia-1.5>\ncheck_match_substrings_case(['hi', 'admin'],\
    \ ['hI', 'Hi'])\n</cell>\n<code language=julia-1.5>\ncheck_match_substrings_case(['hi',\
    \ 'admin'], ['hi', 'hi', 'admin', 'project'])\n</cell>\n<code language=julia-1.5>\n\
    check_match_substrings_case(['hi', 'admin'], ['hi', 'hi', 'hi'])\n</cell>\n<code\
    \ language=julia-1.5>", "  \nend", "  # Solution code here\n  return lst1\nend",
  "  max_length = 0\n  while lst1.length > max_length\n    max_length += 1\n  end\n\
    \  max_length += 2\n  lst3 = []\n  while lst1.length > 0\n    if lst1.last < lst2.first\n\
    \      lst3.push(lst1.pop)\n    else\n      lst3.push(lst2.pop)\n    end\n  end\n\
    \  return lst3\nend", "  if lst1.length < lst2.length\n    lst1\n  else\n    lst2\n\
    \  end\nend", "  return lst1 if lst1.size == lst2.size && lst1.all?(&lt: lst2)\
    \ && lst1.size > lst2.size ? lst1 : lst2\nend", "  \n  count = lst1.size\n  \n\
    \  for i in 0...count\n    if lst1[i] < lst2[i]\n      count += 1\n      lst1.delete_at(count-1)\n\
    \    else\n      count += 1\n      lst2.delete_at(count-1)\n    end\n  end\n \
    \ \n  if lst1.size == count\n    return lst1\n  else\n    return lst2\n  end\n\
    end\nprint(total_match(['hi', 'admin'], ['hI', 'Hi'])) ", "  l1 = lst1.length\n\
    \  l2 = lst2.length\n  if l1 == l2\n    lst1\n  elsif l1 < l2\n    lst1.sort!\
    \ #sorts the list ascending\n    l1 = lst1.length\n    lst1\n  else\n    lst2.sort!\
    \ #sorts the list ascending\n    l2 = lst2.length\n    lst2\n  end\n  \n  lst3\
    \ = []\n  for i in 0..l1-l1\n    if lst1[i] < lst2[i]\n      lst3 << lst1[i]\n\
    \    end\n  end\n  \n  for i in 0..l2-l2\n    if lst2[i] < lst1[i]\n      lst3\
    \ << lst2[i]\n    end\n  end\n  \n  lst3.uniq #removes duplicates\nend", '  return
    [i for i,v in enumerate(lst1) if v not in lst2]', "  if lst1.length == lst2.length\n\
    \    lst2.each_with_index do |char, i|\n      if lst2.length >= i\n        lst1[i]\
    \ = char\n      end\n    end\n  else\n    lst2\n  end\nend", "  lst3 = []\n  total\
    \ = 0\n  for i in lst2\n    if lst1.include?(i)\n      lst3.push(i)\n      total\
    \ += i.length\n    end\n  end\n  if lst3.length == total\n    return lst1\n  else\n\
    \    return lst2\n  end\nend", "  return lst1 if len(lst1) == len(lst2) or lst2\
    \ ==[] else lst1 + lst2[0::]\nend", "    arr1 = arr2 = []\n    i = 0\n    while\
    \ i < len(lst1)\n        arr1.push(lst1[i])\n        i += 1\n    i = 0\n    while\
    \ i < len(lst2)\n        arr2.push(lst2[i])\n        i += 1\n    i = 0\n    arr2.each_with_index\
    \ do |e, i|\n        arr1.each_with_index do |f|\n            i = 0\n        \
    \    while i < len(e)\n                if f[i] > e[i]\n                    arr1.push(f.slice!(i))\n\
    \                else\n                    break\n                end\n      \
    \          i += 1\n            end\n        end\n    end\n    return arr1\nend\n\
    </code>\n<|/ a dscore=1 tags=string,arrays,ruby |>\n<| c |>\nI understand your\
    \ answer, however, I'm looking to solve this in Ruby. I've also found this answer\
    \ on SO that does the same thing - http://stackoverflow.com/a/9458337/2437092\n\
    <|/ c |>\n<| c |>\nYou can solve it in ruby. It doesn't require any external libraries.\
    \ You basically need to iterate through the list one character at a time, for\
    \ each character iterate through the other list adding each character to the new\
    \ list until you hit the end. After you iterated through the two lists they will\
    \ be the same size, so you can return the first list. I don't know why you're\
    \ using each_with_index\n<|/ c |>\n<| c |>\nI've been trying to get the logic\
    \ into ruby but I'm having some difficulty understanding it. I've been using this\
    \ site to practice, but I'm having trouble figuring out how to write this in ruby\
    \ - http://try.ruby-lang.org/\n<|/ c |>\n<| c |>\nHere's a version that uses only\
    \ methods of Array, not loops http://ideone.com/pIh8zQ\n<|/ c |>\n<| a dscore=1\
    \ |>\nI'm still pretty new to ruby so it's possible that there's an easier way\
    \ that I'm just not seeing. I took a look at your link above and decided to write\
    \ some code:\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
