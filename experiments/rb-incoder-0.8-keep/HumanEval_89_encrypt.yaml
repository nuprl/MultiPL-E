name: HumanEval_89_encrypt
language: rb
prompt: "# Create a function encrypt that takes a string as an argument and\n# returns\
  \ a string encrypted with the alphabet being rotated. \n# The alphabet should be\
  \ rotated in a manner such that the letters \n# shift down by two multiplied to\
  \ two places.\n# For example:\n# encrypt('hi') returns 'lm'\n# encrypt('asdfghjkl')\
  \ returns 'ewhjklnop'\n# encrypt('gf') returns 'kj'\n# encrypt('et') returns 'ix'\n\
  def encrypt(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n\
  \    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"\
  ))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"\
  kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n\
  \    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"\
  lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
  , candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"\
  e\", candidate.call(\"a\"))\n  end\nend\n"
completions: ["  result = ''\n  for i in 1..s.length - 1\n    result = result.concat(ALPHABET[ALPHABET.index\
    \ { |c| (s.chars.combination(2).find { |c| (c.eql?(ALPHABET[i - 1]) and c.eql?(ALPHABET[i\
    \ + 1])) }) != nil } + 2])\n  end\n  result\nend", "  alphabet = ['a', 'b', 'c',\
    \ 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  alphabet.reverse\n  alphabet = alphabet[1..-1]",
  "  return s.gsub(/[a-zA-Z]/) {|c| c.upcase + c.downcase }\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby |>\n<| c |>\nSorry I don't understand how your solution can be modified\
    \ to work for this\n<|/ c |>\n<| c |>\nI have changed the method signature so\
    \ that it now takes the alphabet, and returns an array of letters encryted with\
    \ the alphabet shifted by one position. The code can be changed accordingly too.\n\
    <|/ c |>\n<| c |>\nThanks, that works. But I want the output to look like the\
    \ one in line 4 in the original question\n<|/ c |>\n<| c |>\nI just updated my\
    \ answer with your requirement. Hopefully it works for you now.\n<|/ c |>\n<|\
    \ a dscore=0 tags=ruby |>\nHere's how I would do it:\n<code>", "  # Initialize\
    \ a variable to store the encrypted string\n  e = ''", "  alphabet = ('a'..'z').to_a\n\
    \  alphabet.rotate(2)\n  alphabet.join('')\nend", "  s.gsub(/(.)(.?)/) { |m| m.length\
    \ == 2 ? \"#{$1.upcase + $2}#{($2.upcase + $1).rotate(2)}\" : m }\nend", "  a\
    \ = s.split(//).map { |x| x.split(//).map { |y| y.to_i * 2 } }\n  s.size.times\
    \ { |i| a[i] << 1 }\n  s.split('').join.chars.to_a.join\nend", "  result = \"\"\
    \n  \n  # Initialize a variable to represent a letter\n  l = s.downcase[0]\n \
    \ \n  # Move all the letters down in alphabetical order\n  s.downcase!\n  \n \
    \ # Iterate over the string by counting the number of times each letter occurs\n\
    \  s.each_char { |c|\n    result += c.to_s.count(l) * 2\n  }\n  \n  result.downcase!\n\
    \  \n  # Return the encrypted string\n  result\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks so much for sharing. I appreciate you not giving the exact answer as I\
    \ appreciate learning to code from the process of understanding the concept rather\
    \ than just copying someone else's code.\n<|/ c |>\n<| c |>\nYou're welcome. Don't\
    \ hesitate to ask for clarification if you need it :D\n<|/ c |>\n<| c |>\nThe\
    \ above code is not working on rot13. Can anyone help me how this can be modified\
    \ for rot13?\n<|/ c |>\n<| a dscore=4 |>\nI solved it in Ruby a while ago. \n\
    <code>", "    alphabet.each do |letter|\n        pos = alphabet.index(letter)\n\
    \        s = s.gsub(letter, alphabet[pos + 2])\n    end\n    \n    return s\n\
    end", "  s.scan(/.{1,2}|./).each { |e| s.prepend(e.rotate(2)) }\n  s.join\nend",
  "  alphabet = %w(a b c d e f g h i j k l m n o p q r s t u v w x y z)\n  new = ''\n\
    \  s.chars.each do |c|\n    new_letter = alphabet.shift\n    alphabet[-1] << new_letter\n\
    \    alphabet << new_letter\n    new << new_letter\n  end\n  new\nend", "  alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n  alphabet_length = len(alphabet)\n  new_string\
    \ = ''\n  for i in s\n    new_string += alphabet[alphabet_length - alphabet.index(i)\
    \ + alphabet_length - (alphabet_length - alphabet.index(i) + 2)]\n  return new_string\n\
    \  ", "  alph = s.split(//)\n  return alph.join(alph.rotate!)\nend\n</code>\n\
    Now you can solve your problem:\n<code>\nputs encrypt('hi')\n</code>\nor\n<code>\n\
    puts encrypt('asdfghjkl')\n</code>\nor\n<code>\nputs encrypt('gf')\n</code>\n\
    or\n<code>\nputs encrypt('et')\n</code>\n<|/ a dscore=0 tags=ruby,encryption,ruby-on-rails\
    \ |>\n<| c |>\nPlease don't use \"Thank you\", or \"Any help appreciated\", or\
    \ signatures on Stack Overflow. Either write an answer of your own, or accept\
    \ an existing one if it was helpful.\n<|/ c |>\n<| c |>\nStill working on this,\
    \ got it working now. Thx!\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  # convert\
    \ s to lower case\n  s = s.downcase\n  \n  # count the number of occurrences of\
    \ each letter\n  s = s.each_char.map { |c| c.count }", "  return encryptHelper(s,alphabet)\n\
    end", "  # your code here\n  alphabet=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \  alphabet2=['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']\n\
    \  alphabet3=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']\n\
    \  alphabet4=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \  alphabet5=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i",
  "  s = encrypt_alphabet(s)\n  result = ''\n  i = 0\n  while i < s.length\n    letter\
    \ = s.chr(i)\n    result += (letter + (letter - 'A' + 2) * 2)\n    i += 1\n  end\n\
    \  result\nend\n  ", "  \n  # Initialize your encryption variable to the empty\
    \ string. \n  encryption = ''", "    alphabet = [**'abcdefghijklmnopqrstuvwxyz']\n\
    \    shift = alphabet.count('a') + 1\n    return s.split('').map { |c| alphabet[alphabet.index(c)\
    \ + shift] }.join\nend", "    alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \    cipher = []\n    for i in alphabet\n        cipher = cipher + alphabet\n\
    \    end\nend\n    ", "  # Your code here\n  l = s.split(\"\")\n  l = [x + y for\
    \ x in l for y in alphabet]\n  return \"\".join(l)\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nCan you explain what this line does? `l = s.split(\"\")`\n<|/ c\
    \ |>\n<| c |>\nThe string `l` is split into individual characters, then each individual\
    \ character is added to `alphabet`\n<|/ c |>\n<| c |>\nSo `l` holds all of the\
    \ characters in `s` ? What is the purpose of splitting `s` before adding them\
    \ into `alphabet` ?\n<|/ c |>\n<| c |>\nYes, `l` holds all of the characters in\
    \ `s`. When you split `s` by `\"\"` you get an array of all characters in the\
    \ string. `[h, i, l]`\n<|/ c |>\n<| c |>\n`l` is an array because you are splitting\
    \ the string into characters. `[h, i, l]` is each individual character of the\
    \ string.\n<|/ c |>\n<| a tags=ruby dscore=1 |>\n<code>", "  # TODO: Write code\
    \ here\n  return s\nend", "  alphabet = ('a'..'z').to_a\n  rotation = alphabet.zip(alphabet)\n\
    \  encrypted_s = ''\n  s.split('').each { |letter| encrypted_s += alphabet[rotation.find\
    \ {|e| e == letter}.first] }\n  encrypted_s\nend", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    s = s.chars.map(&:to_i)\n    s.rotate!(-2)\n    \n    alphabet = alphabet.split('')\n\
    \    alphabet.map! do |char|\n        if s.include?(char)\n            char +\
    \ 2\n        elsif alphabet.include?(char)\n            char - 1\n        else\n\
    \            char\n        end\n    end", "  result = \"\"\n  s.chars.each do\
    \ |c|\n    result << alphabet[alphabet.index(c) - alphabet.index(s.downcase) +\
    \ 2]\n  end\n  result\nend", "    i = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    while i < s.length\n        s += alphabet[(alphabet.index(s.chars[i]) + 2)\
    \ % 26]\n        i += 1\n    end\n    return s\nend", "    cipher = s[0..1] +\
    \ s[2..3] + s[4..5] + s[6..7] + s[8..9]\n    cipher = cipher.rotate(2).rotate(2).rotate(2)\n\
    \    cipher = cipher.rotate(3).rotate(3)\n    return cipher\nend", "  alphabet\
    \ = %w{a b c d e f g h i j k l m n o p q r s t u v w x y z}\n  rotated_alphabet\
    \ = alphabet[0..-1] + alphabet[0..-2] + alphabet[0..-3] + alphabet[0..-4]\n  rotated_alphabet.each\
    \ { |e| s[0..0] = e; s[1..-1] = e }\n  s.upcase + s[1..-1]\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nNice solution - one correction is that the first line\
    \ of rotated_alphabet should be `rotated_alphabet = alphabet.rotate(2).map{|char|\
    \ char.downcase}`. Otherwise `rotated_alphabet = [ 'a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z' ]`\n<|/ c |>\n<| c |>\nYes you are right, I've fixed the\
    \ code. Thanks!\n<|/ c |>\n<| a dscore=2 |>\nAs an alternative to the accepted\
    \ answer you can implement this in Ruby using a combination of Ruby's String class\
    \ and Array's rotate method.\n<code>", "  s.gsub!(/[a-z]/i) { |c| c.ord + 2 }\n\
    \  s.gsub!(/[A-Z]/i) { |c| c.ord + 2 }\n  s.gsub!(/[^a-z]/i) { |c| c.ord + 2 }\n\
    \  s\nend\n  ", "  cipher = []\n  s.split('').each do |char|\n    char.upcase!\
    \ # make the chars uppercase\n    cipher << ALPHABET[ALPHABET.index(char)] \n\
    \  end\n  cipher.join('')\nend", "  letters = s.split('')\n  rotated_letters =\
    \ letters.map {|c| c.succ if c.to_i > 25}\n  rotated_letters.join\nend", "  alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ = alphabet.rotate(2)\n", "  # convert s to a list\n  s = s.chars.to_a", "  alphabet\
    \ = ('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z')\n\
    \  alphabet = alphabet.rotate(2)\n  result = \"\"\n  s.each do |char|\n    char\
    \ = char.downcase\n    if alphabet.index(char)\n      result += alphabet[alphabet.index(char)]\n\
    \    else\n      result += 'z'\n    end\n  end\n  result\nend", "  s.each_char\
    \ do |c|\n    s.slice!(c,2).slice!(c,1)\n  end\nend", "  s.split('').rotate(2).join\n\
    end", "end\n</code>\n<|/ q dscore=0 |>\n<| c |>\nYour `encrypt` function takes\
    \ three arguments, but the example only passes two arguments. Also, when you use\
    \ `rotate` you aren't using the return value.  And if this is an exercise, you\
    \ are expected to figure out the algorithm yourself, not just post the code with\
    \ no explanation.  Hint: you need to `rotate` each letter by two letters.\n<|/\
    \ c |>\n<| c |>\nThis was an exercise that was given to me. The rotate function\
    \ takes three arguments. I can just not figure out how to do it. How would I rotate\
    \ each letter by two letters?\n<|/ c |>\n<| c |>\nWhat is your `rotate` function?\
    \  Also, `rotate` returns a string, so you need to assign it to a variable (`x\
    \ = rotate(alphabet)`)\n<|/ c |>\n<| c |>\nSorry my bad I was looking at some\
    \ other stuff and accidentally deleted that line of code. My rotate function is\
    \ just an alias for my rotate function that is provided by Ruby. I also added\
    \ the encrypt function to my question to show my current code.\n<|/ c |>\n<| c\
    \ |>\n`rotate` takes 3 arguments, but you are only passing 2, so your code won't\
    \ run.  I suggest you delete this question and come back and edit it with the\
    \ correct information (i.e. the correct code).\n<|/ c |>\n<| a tags=ruby |>\n\
    Your encryption algorithm is wrong, you need to rotate each letter by two letters.\n\
    <code>", "  rotated_alphabet = s.chars.rotate\n  \n  alphabet = alphabet.chars.rotate\n\
    \  \n  result = ''\n  \n  s.chars.to_a.each do |char|\n    result += alphabet\
    \ unless char == char.upcase\n    result += rotated_alphabet unless char == char.downcase\n\
    \    alphabet = alphabet.chars.rotate\n  end", "  new_s = \"\"\n  s.each_byte\
    \ {|char| new_s << alphabet[char + 2]}\n  new_s\nend", "  s.chars.each_with_index\
    \ do |char, index|\n    alphabet[index].upcase!\n  end \n  s.chars.zip(0..5).map\
    \ { |a, b| b + 2 }.join # Add the index\nend", "  s.downcase!\n  result = \"\"\
    \n  alphabet = s.split('')\n  alphabet.each_with_index { |char, index| \n    if\
    \ char.eql?('z')\n      result += \"a\"\n    elsif index % 2 == 0 && char.eql?('a')\n\
    \      result += \"b\"\n    elsif index % 2 == 1 && char.eql?('b')\n      result\
    \ += \"c\"\n    elsif index % 2 == 2 && char.eql?('c')\n      result += \"d\"\n\
    \    elsif index % 2 == 3 && char.eql?('d')\n      result += \"e\"\n    elsif\
    \ index % 2 == 4 && char.eql?('e')\n      result += \"f\"\n    elsif index % 2\
    \ == 5 && char.eql?('f')\n      result += \"g\"\n    elsif index % 2 == 6 && char.eql?('g')\n\
    \      result += \"h\"\n    elsif index % 2 == 7 && char.eql?('h')\n      result\
    \ += \"i\"\n    elsif index % 2 == 8 && char.eql?('i')\n      result += \"j\"\n\
    \    elsif index % 2 == 9 && char.eql?('j')\n      result += \"k\"\n    elsif\
    \ index % 2 == 10 && char.eql?('k')\n      result += \"l\"\n    elsif index %\
    \ 2 == 11 && char.eql?('l')\n      result += \"m\"\n    elsif index % 2 == 12\
    \ && char.eql?('m')\n      result += \"n\"\n    elsif index % 2 == 13 && char.eql?('n')\n\
    \      result += \"o\"\n    elsif index % 2 == 14 && char.eql?('o')\n      result\
    \ += \"p\"\n    elsif index % 2 == 15 && char.eql?('p')\n      result += \"q\"\
    \n    elsif index % 2 == 16 && char.eql?('q')\n      result += \"r\"\n    elsif\
    \ index % 2 == 17 && char.eql?('r')\n      result += \"s\"\n    elsif index %\
    \ 2 == 18 && char.eql?('s')\n      result += \"t\"\n    elsif index % 2 == 19\
    \ && char.eql?('t')\n      result += \"u\"\n    elsif index % 2 == 20", "  alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n  rotation = alphabet.length - 1\n  return s.chars.map\
    \ do |c|\n    alphabet.chars.find { |x| alphabet.index(x) == rotation.index ?\
    \ alphabet.index(c) + 2 : alphabet.index(x) + 2 }\n  end.join\nend", "  result\
    \ = \"\"\n  \n  # Iterate over the string \n  s.split(\"\").each do |char|\n \
    \   # If the character is shifted by 2 positions, add 2 letters to the \n    #\
    \ alphabet\n    if char.upcase == \"A\"\n      result += \"B\"\n    elsif char.upcase\
    \ == \"B\"\n      result += \"C\"\n    elsif char.upcase == \"C\"\n      result\
    \ += \"D\"\n    elsif char.upcase == \"D\"\n      result += \"E\"\n    elsif char.upcase\
    \ == \"E\"\n      result += \"F\"\n    elsif char.upcase == \"F\"\n      result\
    \ += \"G\"\n    elsif char.upcase == \"G\"\n      result += \"H\"\n    elsif char.upcase\
    \ == \"H\"\n      result += \"I\"\n    elsif char.upcase == \"I\"\n      result\
    \ += \"J\"\n    elsif char.upcase == \"J\"\n      result += \"K\"\n    elsif char.upcase\
    \ == \"K\"\n      result += \"L\"\n    elsif char.upcase == \"L\"\n      result\
    \ += \"M\"\n    elsif char.upcase == \"M\"\n      result += \"N\"\n    elsif char.upcase\
    \ == \"N\"\n      result += \"O\"\n    elsif char.upcase == \"O\"\n      result\
    \ += \"P\"\n    elsif char.upcase == \"P\"\n      result += \"Q\"\n    elsif char.upcase\
    \ == \"Q\"\n      result += \"R\"\n    elsif char.upcase == \"R\"\n      result\
    \ += \"S\"\n    elsif char.upcase == \"S\"\n      result += \"T\"\n    elsif char.upcase\
    \ == \"T\"\n      result += \"U\"\n    elsif char.upcase == \"U\"\n      result\
    \ += \"V\"\n    elsif char.upcase == \"V\"\n      result += \"W\"\n    elsif char.upcase\
    \ == \"W\"\n      result += \"X\"\n    elsif char.upcase == \"X\"\n      result\
    \ += \"Y\"\n    elsif char.upcase == \"Y\"\n      result += \"Z\"\n    elsif char.upcase\
    \ == \"Z\"\n      result += \"A\"\n    elsif char.upcase == \"", "  s.chars.shuffle.inject\
    \ do |a,b| \n    b.ord > a.ord ? a : b\n  end\nend", "  s.chars.map do |c|\n \
    \   puts \"#{c.rotate(2)}\"\n  end.join(\"\")\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thank you very much for your help. I've been trying to figure out how to do this\
    \ all day, and I appreciate it so much.\n<|/ c |>\n<| c |>\nYou are very welcome.\
    \  Feel free to accept an answer if it works for you :) .\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby,string |>\nUsing Ruby's rotate method:\n<code>", "  alpha = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \  result = ''\n  for c in s \n  result = result + alpha[(alpha.index(c)+2)%26]\n\
    end", "    s = s.upcase\n    alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\
    \ 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z']\n    alphabet1 = alphabet.dup\n    alphabet2 = alphabet.dup\n    alphabet3\
    \ = alphabet.dup\n    alphabet4 = alphabet.dup\n    alphabet5 = alphabet.dup\n\
    \    alphabet6 = alphabet.dup\n    alphabet7 = alphabet.dup\n    alphabet8 = alphabet.dup\n\
    \    alphabet9 = alphabet.dup\n    alphabet10 = alphabet.dup\n    alphabet11 =\
    \ alphabet.dup\n    alphabet12 = alphabet.dup\n    alphabet13 = alphabet.dup\n\
    \    alphabet14 = alphabet.dup\n    alphabet15 = alphabet.dup\n    alphabet16\
    \ = alphabet.dup\n    alphabet17 = alphabet.dup\n    alphabet18 = alphabet.dup\n\
    \    alphabet19 = alphabet.dup\n    alphabet20 = alphabet.dup\n    alphabet21\
    \ = alphabet.dup\n    alphabet22 = alphabet.dup\n    alphabet23 = alphabet.dup\n\
    \    alphabet24 = alphabet.dup\n    alphabet25 = alphabet.dup\n    alphabet26\
    \ = alphabet.dup\n    alphabet27 = alphabet.dup\n    alphabet28 = alphabet.dup\n\
    \    alphabet29 = alphabet.dup\n    alphabet30 = alphabet.dup\n    alphabet31\
    \ = alphabet.dup\n    alphabet32 = alphabet.dup\n    alphabet33 = alphabet.dup\n\
    \    alphabet34 = alphabet.dup\n    alphabet35 = alphabet.dup\n    alphabet36\
    \ = alphabet.dup\n    alphabet37 = alphabet.dup\n    alphabet38 = alphabet.dup\n\
    \    alphabet39 = alphabet.dup\n    alphabet40 = alphabet.dup\n    alphabet41\
    \ = alphabet.dup\n    alphabet42 = alphabet.dup\n    alphabet43 = alphabet.dup\n\
    \    alphabet44 = alphabet.dup\n    alphabet45 = alphabet.dup\n    alphabet46\
    \ = alphabet.dup\n    alphabet47 = alphabet.dup\n    alphabet48 = alphabet.dup\n\
    \    alphabet49 = alphabet.dup\n    alphabet50 = alphabet.dup\n    alphabet51\
    \ = alphabet.dup\n    alphabet52 = alphabet.dup\n    alphabet53 = alphabet.dup\n\
    \    alphabet54 = alphabet.dup\n    alphabet55 = alphabet.dup\n    alphabet56\
    \ = alphabet.dup\n    alphabet57 = alphabet.dup\n    alphabet58 = alphabet.dup\n\
    \    alphabet59 = alphabet.dup\n    alphabet60 = alphabet.dup\n    ", "  # Create\
    \ an array called alpha\n  alpha = Array(0..26).to_a\n  # Set counter to 0\n \
    \ counter = 0\n  # Loop through each character in s\n  s.chars.each do |char|\n\
    \    counter += 1\n    alpha[counter] = alpha[counter] * (-1)\n    alpha[counter]\
    \ += char.ord\n    alpha[counter] = alpha[counter].chr\n  end\n  # Loop through\
    \ alpha\n  alpha.each do |char|\n    counter += 1\n    alpha[counter] = alpha[counter]\
    \ * (-1)\n    alpha[counter] += char.ord\n    alpha[counter] = alpha[counter].chr\n\
    \  end\n  # Return s + 'a' for each character in s\n  s.chars.map{|c| c + 'a'}.join\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYour code does not work as intended\
    \ for any given input.\n<|/ c |>\n<| c |>\n, thanks for letting me know.\n<|/\
    \ c |>\n<| a tags=encryption,ruby,loops dscore=0 |>\n<code>", "  new_s = \"\"\n\
    \  s.chars.each do |c|\n    idx = s.size - 1\n    new_s[idx] = c + 2\n    new_s[idx+1]\
    \ = c + 4\n    new_s[idx+2] = c + 6\n    new_s[idx+3] = c + 8\n    new_s[idx+4]\
    \ = c + 10\n    new_s[idx+5] = c + 12\n    new_s[idx+6] = c + 14\n    new_s[idx+7]\
    \ = c + 16\n    new_s[idx+8] = c + 18\n    new_s[idx+9] = c + 20\n  end\n  return\
    \ new_s\nend", "  s.each_byte { |c| return c + 2 }\nend", "  l = s.length\n  return\
    \ s.chars.map { |c|\n    if c.upcase == 'A' || c.upcase == 'B' || c.upcase ==\
    \ 'C' || c.upcase == 'D' || c.upcase == 'E' || c.upcase == 'F' || c.upcase ==\
    \ 'G' || c.upcase == 'H' || c.upcase == 'I' || c.upcase == 'J' || c.upcase ==\
    \ 'K' || c.upcase == 'L' || c.upcase == 'M' || c.upcase == 'N' || c.upcase ==\
    \ 'O' || c.upcase == 'P' || c.upcase == 'Q' || c.upcase == 'R' || c.upcase ==\
    \ 'S' || c.upcase == 'T' || c.upcase == 'U' || c.upcase == 'V' || c.upcase ==\
    \ 'W' || c.upcase == 'X' || c.upcase == 'Y' || c.upcase == 'Z'\n      c = c.upcase\n\
    \    else\n      c = c.downcase\n    end\n    c = ((c.ord - 96) * 2) + 96\n  \
    \  c = c.chr\n  }.join('')\nend", "    encrypted_string = ''\n    for letter in\
    \ s \n        encrypted_string << encrypt_letter(letter) \n    end\n    return\
    \ encrypted_string\nend", "    encrypted_string = ''\n    s.chars.each do |c|\n\
    \        \n        # get the index of the next character in the alphabet\n   \
    \     # that is the same as the current letter being worked on \n        index\
    \ = (alphabet.index(c) + 1).to_i\n        # add the letter of the alphabet (shifting\
    \ it down by two)\n        encrypted_string += alphabet[index % alphabet.size].chr\n\
    \    end \n    encrypted_string\nend", "  # Complete this function\nend", "  \
    \  l = s.split('')\n    new_l = l.reverse.map{|letter| letter == 'a' ? letter\
    \ == 'e' ? letter == 'i' ? letter == 'l' ? 'm' : letter == 'f' ? 'l' : letter\
    \ == 'g' ? 'k' : letter == 'j' ? 'g' : letter == 'h' ? 'i' : letter == 'k' ? 'm'\
    \ : letter == 'j' ? 'e' : letter == 'i' ? letter == 'k' ? 'h' : letter == 'l'\
    \ ? 'g' : letter == 'm' ? 'g' : letter == 'e' ? 'e' : letter == 'l' ? 'i' : letter\
    \ == 'f' ? 'k' : letter == 'h' ? 'i' : letter == 'l' ? 'f' : letter == 'e' ? 'g'\
    \ : letter == 'f' ? 'm' : letter == 'h' ? 'k' : letter == 'g' ? 'l' : letter ==\
    \ 'j' ? 'm' : letter == 'k' ? 'h' : letter == 'm' ? 'j' : letter == 'i' ? letter\
    \ == 'e' : letter == 'l' ? 'i' : letter == 'g' : letter == 'h' ? 'f' : letter\
    \ == 'k' ? 'i' : letter == 'l' ? 'h' : letter == 'j' ? 'g' : letter == 'g' ? 'e'\
    \ : letter == 'k' ? 'j' : letter == 'l' ? 'f' : letter == 'm' ? 'j' : letter ==\
    \ 'h' ? 'g' : letter == 'k' ? 'm' : letter == 'j' ? 'i' : letter == 'h' ? 'm'\
    \ : letter == 'f' ? 'l' : letter == 'e' ? 'j' : letter == 'k' ? 'g' : letter ==\
    \ 'e' ? 'i' : letter == 'f' ? 'l' : letter == 'h' ? 'i' : letter == 'g' : letter\
    \ == 'j' ? 'k' : letter == 'g' ? 'm' : letter == 'l' ? 'e' : letter == 'i' ? letter\
    \ == 'j' : letter == 'f' : letter == 'i' : letter == 'l' : letter == 'g' : letter\
    \ == 'e' : letter == 'm' : letter == 'g' : letter == 'j' : letter == 'l' : letter\
    \ == 'f' : letter == 'e' : letter == 'h' : letter == 'k' : letter == 'i' : letter\
    \ == 'h' : letter == 'j' : letter == 'm' : letter == 'l' : letter == 'g' : letter\
    \ == 'i' : letter == 'k' : letter == 'm' : letter == 'g' : letter == 'h' : letter\
    \ == 'i' : letter == 'g' : letter == 'j' : letter == 'k' : letter == 'l' : letter\
    \ == 'e' : letter == 'f' : letter == 'j' : letter == 'g' : letter == 'm' : letter\
    \ == 'k' : letter == 'j' : letter == 'i' : ", "  s = s + s\n  alphabet = [ \"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"\
    l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"\
    w\", \"x\", \"y\", \"z\" ]\n  s = s.to_s\n  for i in 1..s.length\n    s = s.substring\
    \ (0, i) + alphabet.join (alphabet.rotate (i - 1)) + s.substring (i + 1)\n  end\n\
    \  return s\nend\np encrypt(\"asdfghjkl\")\n</cell>\n<cell>", "  cipher = \"\"\
    \n  s.split(\"\").each do |char| \n    cipher = char + cipher[0]\n  end\n  return\
    \ cipher\nend\n  ", " \n    # Create a variable to hold the encrypted string\n\
    \    encrypted = \"\"\n \n    # Loop through each letter in string s\n    for\
    \ i in s \n \n        # Convert the letter to a number\n        num = alphabet.index(i)\n\
    \ \n        # Shift the number down by two places\n        num +=2\n \n      \
    \  # Convert number back to letter\n        letter = alphabet[num]\n \n      \
    \  # Add letter to encrypted\n        encrypted += letter\n \n    # Return the\
    \ encrypted string\n    return encrypted\nend\n</code>\nThis is the code I used\
    \ to solve the problem:\n<code>", "  letters = Array.new(26)\n  letters.fill nil\n\
    \  s.chars.each_with_index do |char, index|\n    letters[(char.ord - 97) + 2]\
    \ = (char.ord - 97).abs\n  end\n  letters.map { |l| l.to_s }.join(\"\")\nend\n\
    </code>\nOutput:\n<code>", "   alphabet = [*'abcdefghijklmnopqrstuvwxyz']\n  \
    \ rot_alphabet = []\n   for c in alphabet\n       rot_alphabet.append(alphabet[(alphabet.index(c)+2)%26])\n\
    \   return rot_alphabet[alphabet.index(s)]\nend", "  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  rot_alphabet = alphabet[alphabet.length-1..alphabet.length-2]\n  alphabet.rotate!\n\
    \  alphabet + rot_alphabet\nend", "  s.each_index { |index| s[(index-1)%26] =\
    \ s[(index-1)%26] + s[(index-1)%26].upcase }\n  s\nend", "    # Write your code\
    \ here\n    n = s.count(\"a\")\n    n += s.count(\"b\")\n    n += s.count(\"c\"\
    )\n    n += s.count(\"d\")\n    n += s.count(\"e\")\n    n += s.count(\"f\")\n\
    \    n += s.count(\"g\")\n    n += s.count(\"h\")\n    if n <= 1:\n        return\
    \ s \n    first = s[n.index(\"a\") + 1]\n    last = s[n.index(\"a\") + 2]\n  \
    \  return first + last\n</code>\n<|/ a |>\n<| c |>\nHi Sidharth, thank you for\
    \ your feedback. I see now what my issue was. I updated my code, and it's still\
    \ not working. I'm wondering if I could get some help on this.\n<|/ c |>\n<| c\
    \ |>\nHi Sidharth, thanks for your feedback. I updated my code again and it's\
    \ still not working as planned. Any help would be appreciated. I am hoping someone\
    \ will respond and I'll be happy to update my code with what I've come up with\
    \ until then.\n<|/ c |>\n<| c |>\nSure. You need to understand the problem and\
    \ how to solve it. I have given you a skeleton for this. You need to figure out\
    \ how you want to shift the letters down by two to make the decrypt function work.\
    \ I'll also give you a skeleton for that and I'll add an additional comment to\
    \ your code. Hold on\n<|/ c |>\n<| c |>\nHi Sidharth - I'm a little confused by\
    \ what you are saying. Would you mind giving me a skeleton of it? I've been working\
    \ on it for over an hour now and don't understand your solution very well. I appreciate\
    \ your help, thank you very much!\n<|/ c |>\n<| c |>\nYou just need to do something\
    \ like this: a = \"hi\"; b = \"ab\"; c = encrypt(b) Now c contains the encrypted\
    \ text. Now you just need to understand how you shift the letters down by two\
    \ so they match the encryption function.\n<|/ c |>\n<| a |>\nTry something like\
    \ this - I added comments so you can understand what's going on.\n<code>", " \
    \ # Convert the string to a list\n  letters = s.split(\"\")\n  # Rotate the letters\
    \ by 2 times\n  letters = letters[1..-1] * 2\n  # Rebuild the string\n  s = letters.join(\"\
    \")\n  return s\nend\n</cell>\n<text>\nLet's test our function!", "  result =\
    \ ''\n  s.each do |ch|\n    result += alphabet[alphabet.index(ch) - 2] + alphabet[alphabet.index(ch)\
    \ - 1]\n  end\n  \n  return result\nend", "  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  s.split('').map { |letter| alphabet.index(letter) + 2 }.join\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI am not asking you to solve this problem for me.\
    \ I am just asking for assistance in understanding the code you have written.\n\
    <|/ c |>\n<| c |>\nThe code I've written is probably the most cryptic way of doing\
    \ what you want to do in Ruby, but it shows that it isn't rocket science. Though\
    \ it does look like it could be improved by using an `inject` loop (rather than\
    \ `map` followed by `join`), but you might want to ask a more specific question\
    \ about that.\n<|/ c |>\n<| c |>\nYes, I understand that it is cryptic but I want\
    \ to understand why it is that way.\n<|/ c |>\n<| c |>\nI understand the inject\
    \ loop but how does the alphabet string be made up of characters a-z?\n<|/ c |>\n\
    <| c |>\nBy adding 2 to the index of each letter in the alphabet.\n<|/ c |>\n\
    <| a tags=ruby,function,encryption |>\nThe easiest way would be to use the rotate\
    \ method on the String class.\n<code>", "    # Write your code here.\n    shift_down\
    \ = s.chars.each_char.map do |c| c * 2 }.join \"\"\n    alphabet = shift_down.chars.each_char.map\
    \ { |c| c >= 'a' ? 'z' + c - 'a' : c + 1 }.join \"\"\n    cipher = alphabet +\
    \ shift_down\n    return cipher.upcase\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ |>\nYou can use the rotate function from String and pass it the character that\
    \ you want to rotate to:\n<code>", "    cipher = []\n    i = 0\n    while i <\
    \ s.length\n        cipher.push(s.charAt(i))\n        i += 1\n    end\n    i =\
    \ 0\n    while i < cipher.length\n        temp = cipher[i]\n        j = 0\n  \
    \      while j + 2 < cipher.length\n            temp = cipher[i + j] + cipher[i\
    \ + j + 1] + cipher[i + j + 2]\n            j += 1\n        end\n        cipher.push(temp)\n\
    \        i += 1\n    end\n    i = 0\n    while i < cipher.length\n        if cipher[i]\
    \ < 97\n            cipher[i] = cipher[i] + 2\n        else\n            cipher[i]\
    \ = cipher[i] - 26\n        end\n        i += 1\n    end\n    return cipher.join('')\n\
    end", "  # Return the string encrypted.\nend", "  s.split(//).map { |c| rotated_alphabet[c.to_s.downcase.ord\
    \ - 'a'.ord] }.join\nend\n</code>\nAs for how to actually rotate the alphabet,\
    \ you can either do it yourself, or you can use one of the existing rotating ciphers:\n\
    <code>", "  # Complete this function\nend", "end\n</code>\nSo now we have an encryption\
    \ algorithm, we just need to encrypt our string! Let's start by creating a method\
    \ that does this, and using Ruby's string interpolation operator to call our encryption\
    \ method with our string.\n<code>", "  result = ''\n  i = s.length\n  while i\
    \ >= 2\n    char = s[i - 1] + s[i - 2]\n    result << char\n    i -= 1\n  end\n\
    \  return result\nend", "  cipher = []\n  s.split('').each do |char|\n    cipher.push(alphabet[char[0]].to_i)\n\
    \    cipher.push(alphabet[char[1]].to_i)\n    cipher.push(alphabet[char[2]].to_i)\n\
    \    cipher.push(alphabet[char[3]].to_i)\n    cipher.push(alphabet[char[4]].to_i)\n\
    \    cipher.push(alphabet[char[5]].to_i)\n    cipher.push(alphabet[char[6]].to_i)\n\
    \    cipher.push(alphabet[char[7]].to_i)\n    cipher.push(alphabet[char[8]].to_i)\n\
    \    cipher.push(alphabet[char[9]].to_i)\n    cipher.push(alphabet[char[10]].to_i)\n\
    \    cipher.push(alphabet[char[11]].to_i)\n    cipher.push(alphabet[char[12]].to_i)\n\
    \    cipher.push(alphabet[char[13]].to_i)\n    cipher.push(alphabet[char[14]].to_i)\n\
    \    cipher.push(alphabet[char[15]].to_i)\n    cipher.push(alphabet[char[16]].to_i)\n\
    \    cipher.push(alphabet[char[17]].to_i)\n  end\n  cipher.to_s.gsub(/(.)/) {\
    \ |char| alphabet[char].to_i}\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays,ruby-on-rails,encryption,string\
    \ |>\nMy code will work for any size of string. \n<code>", "  s.chars.reverse\n\
    \  letters = s.chars.map.with_index.with_object({}) { |(c,i),h| h[c] = i; h }.\n\
    \    sort.\n    map(&:last).\n    map { |c| letters[c] }.\n    join\nend", " \
    \ s.split('').rotate!.map{|c| c+2}.join\nend", "  s.chars.rotate!\n  s.chars.rotate!\n\
    \  s.chars.rotate!\nend\n</code>\nNext, write a method that takes a string and\
    \ returns its encrypted value. The encrypted value should be the same length as\
    \ the string.\nFor example:\n<code>\ndecrypt('lm') returns 'hi'\n</code>\n<|/\
    \ a tags=encryption,ruby,string,algorithm |>\n<| c |>\nI suspect that the OP was\
    \ expected to solve the problem, so I won't give this a second look, but this\
    \ looks promising.\n<|/ c |>\n<| a dscore=2 |>\nOne way to solve this is to convert\
    \ the string to an array of characters, shift each character in turn 2 places\
    \ down, and then convert the array back to a string. The following is an example\
    \ of how to do this:\n<code>", "    \n    # Initialize your result variable to\
    \ the empty string\n    result = \"\"\n    \n    # Get the length of the string\n\
    \    length = s.length\n    \n    # Get the current letter being tested \n   \
    \ curr_char = s.chr\n    \n    # Iterate through the string one letter at a time\n\
    \    for i in 1..length\n    \n        # Shift the letter down by two places and\
    \ add the letter \n        # to the result\n        result += curr_char.chr.downcase.chars.rotate(2).join\n\
    \    \n        # Shift the letter down by one place and add the letter \n    \
    \    # to the result\n        result += curr_char.chr.downcase.chars.rotate(1).join\n\
    \    \n        # Shift the letter down by one place and add the letter \n    \
    \    # to the result\n        result += curr_char.chr.downcase.chars.rotate(1).join\n\
    \    \n        # Shift the letter down by one place and add the letter \n    \
    \    # to the result\n        result += curr_char.chr.downcase.chars.rotate(1).join\n\
    \    \n        # Return the result variable\n        return result\n    \n   \
    \ end\n    \n    # Return the result variable\n    return result", "  alphabet\
    \ = s.downcase \n  new_alphabet = alphabet.split(//) \n  new_alphabet.rotate(2)\
    \ \n  new_alphabet.join(//) \nend", "  a = rotate(alphabet.chars, 2)\n  c = s.chars.inject([])\
    \ { |a, e| a + [a.last.dup.insert(1, e.to_i)] }\n  c.join\nend", "  alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyz\".split(\"\").reverse\n  alphabet = alphabet.insert(1,\
    \ alphabet[1])\n  alphabet = alphabet[2..-1]\n  alphabet = alphabet.reverse\n\
    \  s.split(\"\").each do |c|\n    alphabet = alphabet.join(c)+alphabet[-c-1]\n\
    \  end\n  alphabet\nend", "  result = ''\n  s.each do |letter|\n    letter_index\
    \ = alphabet.index(letter)\n    shifted_letter_index = letter_index - 2\n    result\
    \ += alphabet[shifted_letter_index]\n  end\n  return result\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=encryption,ruby dscore=1 |>\nHere's a more Rubyish\
    \ way:\n<code>\nalphabet = \"abcdefghijklmnopqrstuvwxyz\"", end, "  # Create a\
    \ new list to hold the result\n  result = ''\n  # Loop through the string and\
    \ shift each character\n  s.each do |c|\n    # Get the current char value\n  \
    \  current = c\n    # Get the alphabet value\n    alphabet = @alphabet\n    #\
    \ Shift the character\n    current << alphabet[0]\n    # Shift the next character\n\
    \    current << alphabet[1]\n    # Shift the next character\n    current << alphabet[2]\n\
    \    # Shift the next character\n    current << alphabet[3]\n    # Shift the next\
    \ character\n    current << alphabet[4]\n    # Shift the next character\n    current\
    \ << alphabet[5]\n    # Shift the next character\n    current << alphabet[6]\n\
    \    # Shift the next character\n    current << alphabet[7]\n    # Shift the next\
    \ character\n    current << alphabet[8]\n    # Shift the next character\n    current\
    \ << alphabet[9]\n    # Shift the next character\n    current << alphabet[10]\n\
    \    # Shift the next character\n    current << alphabet[11]\n    # Shift the\
    \ next character\n    current << alphabet[12]\n    # Shift the next character\n\
    \    current << alphabet[13]\n    # Shift the next character\n    current << alphabet[14]\n\
    \    # Shift the next character\n    current << alphabet[15]\n    # Add the new\
    \ character to the result string\n    result << current\n  end\n  # Return the\
    \ result string\n  result\nend\n</code>\nNow we can test the functions:\n<code>\n\
    puts encrypt('hi')", "    # Write your code here\nend\n</cell>\n<text>\nSolution\n\
    Click for solution", "  alphabet = s.downcase.chars.map{|c| c.to_i + 2 if c >\
    \ 'z'}\n  alphabet.unshift(0)\n  alphabet = alphabet.join\n  alphabet.reverse_each\
    \ do |c|\n    s = s.gsub(c, '')\n  end\n  s.gsub!(/../){|a| alphabet[a%alphabet.length]}\n\
    \  s\nend\n</code>\n<|/ a tags=encryption,ruby |>\n<| c |>\nAhh, that helped!\n\
    But I still cant get it working, here is what I came up with:\n`\n  def encrypt(string)\n\
    \    alphabet = string.downcase.chars.map{|c| c.to_i + 2 if c > 'z'}\n    alphabet.unshift(0)\n\
    \    alphabet = alphabet.join\n    alphabet.reverse_each do |c|\n      string.gsub!(c,\
    \ '')\n    end\n    string.gsub!(/../){|a| alphabet[a%alphabet.length]}\n  end\n\
    `", "  s.split('').map.with_index { |w, i| w[i.even? ? 0 : 1] }.join \nend", " \
    \   return s.split(\"\").map { |c| c.upcase + c.downcase }.join\nend\n</cell>\n\
    <text>\nA word of caution\nYou saw that in order to avoid confusion between strings\
    \ and integers we needed to cast one or the other to the appropriate data type.\n\
    However, in this case, we had to perform this conversion in order to perform mathematical\
    \ operations.\nHow would we go about performing this math without needing to do\
    \ any conversions?\nWe couldn't, because mathematical operations between string\
    \ and integer types are not defined in the Ruby language.\nThis is something that\
    \ is very easy to do in other languages, such as Python, but is unfortunately\
    \ not something that Ruby does.\nHow would you do it?", "    \nend", " \n    alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \n    \n    key = alphabet[2::-2]\n    alphabet\
    \ = alphabet[2::-2]\n \n    key = key.join\n \n    s = s.split\n \n    l = s.length\n\
    \    \n    i = 0\n \n    # Append 'a' to the first letter of 's' and call it 'b'.\n\
    \    b = (s << 1).join\n \n    # Append 'b' to the last letter of 's' and call\
    \ it 'c'.\n    c = (s >> 1).join\n \n    # Do some bit shifting. \n    # Decrement\
    \ 'c' to remove 'a' from its original position. \n    # Decrement 'l' to remove\
    \ 'b' from its original position. \n    # Shift 'c' four bits to the right. \n\
    \    # Add 'c' to 'a' to move it to the correct position.\n    c = c.sub(/../).sub(/../).sub(/../).sub(/../).(/../)\n\
    \ \n    return a.join(c) + b.join(c) + c.join(a) + d.join(a) + e.join(a)\nend\n\
    </code>\n<|/ q dscore=1 |>\n<| c |>\nDo you know any ruby at all?\n<|/ c |>\n\
    <| c |>\nWhat do you mean \"shift\"? Do you mean rotate the letters? Shift means\
    \ move the letters to the right side of the alphabet (e.g., `A` would be shifted\
    \ to the right, `B` would be shifted to the left, etc.). Rotate means the opposite.\n\
    <|/ c |>\n<| c |>\nSorry for the confusion guys. By shift I meant move the letters\
    \ to the left side of the alphabet. I have updated my question accordingly. Thanks!\n\
    <|/ c |>\n<| c |>\nHave you considered doing it in a language that is closer to\
    \ what you want to do? For example, if you want to implement this in Ruby then\
    \ you could do it in about 15 lines of code. Ruby is not exactly your language\
    \ of choice for this type of problem (as is usually the case with most programming\
    \ problems), but it will make you a much better programmer overall.\n<|/ c |>\n\
    <| c |>\nThanks Icemanind, I realize that. I am very interested in solving these\
    \ problems in ruby. I am just exploring the possibilities for my programming skills.\
    \ I am hoping if I can solve these in ruby, I can learn how to solve them in ruby.\n\
    <|/ c |>\n<| a dscore=2 ", "  s.gsub(/[a-z]/){|c| c << 2 }\nend", "  s.chars.map\
    \ { |c| c.rotate(2) }.join\nend", "  s.upcase!\n  alphabet = s.split\n  alphabet\
    \ = alphabet.rotate\n  alphabet = alphabet.join\n  alphabet = alphabet.chars\n\
    \  alphabet = alphabet.map { |e| e.ord }\n  alphabet.join\nend", "  alphabet =\
    \ %w[a b c d e f g h i j k l m n o p q r s t u v w x y z]\n  s.each_char do |c|\n\
    \    puts \"#{c}#{alphabet[-alphabet.index(c) + 2]}\"\n  end\nend", "  # Initialize\
    \ the current alphabet to the empty string\n  alphabet = ''", "  # Return the\
    \ encrypted string\n  new_s = ''\n  alphabet = ('abcdefghijklmnopqrstuvwxyz')\n\
    \  s.downcase.each_char.with_index do |c, i| \n    new_s += alphabet[(alphabet.index(c)\
    \ + alphabet.index(alphabet[i]))]\n  end\n  return new_s\nend", "  # Replace each\
    \ character in the string with its encrypted version\n  s.gsub!(/[a-z]/) { alphabet.index(&$1.upcase)\
    \ + 2 }\n  # Replace each character in the string with its encrypted version\n\
    \  s.gsub!(/[A-Z]/) { alphabet.index(&$1.upcase) + 2 }\n  # Return the string\
    \ containing the encrypted letters\n  return s\nend", "  result = \"\"\n  for\
    \ i in s \n    result << alphabet[alphabet.index(i)+2]\n  end\n  return result\n\
    end", "  l = s.length\n  c = []\n  i = 0\n  while i < l\n    char = s[i]\n   \
    \ if char.upcase == char\n      j = i+1\n      while j < l\n        if j+1 < l\n\
    \          next_char = s[j+1]\n          if next_char.upcase == char\n       \
    \     c.push(char.downcase)\n            j += 1\n          else\n            c.push(next_char.upcase)\n\
    \          end\n        else\n          c.push(char)\n        end\n        j +=\
    \ 1\n      end\n      i += 1\n    else\n      c.push(char)\n    end\n  end\n \
    \ c = c.reverse\n  i = 0\n  while i < l\n    char = s[i]\n    if char.upcase ==\
    \ char\n      j = i+1\n      while j < l\n        if j+1 < l\n          next_char\
    \ = s[j+1]\n          if next_char.upcase == char\n            c.push(char.downcase)\n\
    \            j += 1\n          else\n            c.push(next_char.upcase)\n  \
    \        end\n        else\n          c.push(char)\n        end\n        j +=\
    \ 1\n      end\n      i += 1\n    else\n      c.push(char)\n    end\n  end\n \
    \ return c.join\nend", "  cipher = []\n  cipher = s.split(//)\n  new_cipher =\
    \ []\n  \n  while cipher.length > 0\n    new_cipher.push(rotate(cipher[0].chars.join))\n\
    \    cipher.shift\n  end\n  \n  return new_cipher.join(//)\nend", "    alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n    alpha = alphabet.split(//)\n    letters\
    \ = s.split(//)\n    new_letters = letters.map { |l|\n        l * (alpha.length\
    \ - alpha.index(l))\n    }\n    new_letters.join\nend\n</code>\n<|/ a tags=encryption,ruby\
    \ dscore=0 |>\n<| a tags=encryption,ruby dscore=0 |>\nYou could do it like this:\n\
    <code>", "  s.tr!('abcdefghijklmnopqrstuvwxyz', 'kjfdlnoprtvybim')\nend", "  #\
    \ Return the encrypted string after passing each character in the string\n  #\
    \ through the rotate function.\n  new_s = ''\n  s.split('').each do |char|\n \
    \   new_s << rotate(char)\n  end\n  return new_s\nend", "  # Create a string of\
    \ empty letters\n  result = \"\"\n  \n  # Create a variable to represent the current\
    \ alphabet\n  current_alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  \n  # Create\
    \ a variable that represents each letter of the alphabet\n  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  \n  # Iterate over the string letter by letter\n  for i in 0...s.length()-1\n\
    \    # If the character at the current index \n    # of the alphabet is the same\
    \ as the \n    # character at the next index \n    if alphabet.charAt(i) == alphabet.charAt(i+1)\n\
    \      # Shift each letter down by two \n      # multiplied to two places. \n\
    \      result += current_alphabet.charAt(alphabet.indexOf(i)+2).upcase\n    #\
    \ Else\n    else\n      # Shift each letter down by one\n      # multiplied to\
    \ one place. \n      result += current_alphabet.charAt(alphabet.indexOf(i)+1).upcase\n\
    \    end\n  end\n  \n  # Return the encrypted string\n  return result\nend", " \
    \ s = s + [s.upcase[0]] * 2\n  s.gsub!(/.(.).(.)/, '\\1\\2')\n  s\nend", "   \
    \ s = s.downcase\n    alphabet = ALPHABET.dup\n    alphabet.rotate(s.length)\n\
    \    alphabet.reverse # Because we rotated the alphabet in reverse\n    \n   \
    \ index = s.index\n    en = [0] * alphabet.length\n    \n    while index do\n\
    \        en[alphabet.index(index.next)] = s[index[0]] \n        index = index.next\n\
    \    end\n    \n    return en.join(\"\")\nend", "  s.split('').map do |letter|\n\
    \    # Rotate two letters left and right\n    l = (letter - 'a').rotated_left\n\
    \    r = ((letter - 'a').rotated_right).rotated_right\n    \n    # Shift the letters\
    \ down\n    l = (l + 'a').rotated_left\n    r = (r + 'a').rotated_right\n    \n\
    \    l << r\n  end.join\nend", "  alphabet = ('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z')\n\
    \  new_string = ''\n  \n  # Iterate through every character in the string\n  for\
    \ i in s.chars\n    \n    # Get the ASCII value of the current character in the\
    \ string\n    current = i.ord\n    \n    # If the current character is lower case\
    \ then add it to the new string with a \n    # 2 multiplied to it's ASCII value.\n\
    \    if current < 65 or current > 90\n      new_string << alphabet[(alphabet.index(current)+2)%26]\n\
    \    \n    # If the current character is upper case then add it to the new string\
    \ with a \n    # 1 multiplied to it's ASCII value.\n    elsif current > 90 or\
    \ current < 97\n      new_string << alphabet[(alphabet.index(current)+1)%26]\n\
    \    \n    # If the current character is either upper or lower case then add it\
    \ to the new string with a \n    # 0 multiplied to it's ASCII value.\n    else\n\
    \      new_string << alphabet[(alphabet.index(current)+1)%26]\n    end\n  end\n\
    \  \n  # Return the encrypted string.\n  new_string\nend", "  alpha=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \  new_alpha=[]\n  count=0\n  for letter in alpha\n    new_alpha.push(letter.to_s)\n\
    \  end\n  s.each{|letter|\n    if letter.to_s.in?(new_alpha) == true\n      alpha.push((alpha[alpha.length-1]\
    \ + alpha[alpha.length-2]).to_s)\n    end\n  }\n  new_alpha\nend", "    # Write\
    \ your answer below\n    \n    # Convert the string s into an array of characters.\n\
    \    arr = s.split(\"\")\n    \n    # Create a for loop that iterates from 0 to\
    \ length-1 and shifts the \n    # letters down by two. \n    # For each letter\
    \ in the array, add two to the shifted letter. \n    # For example:\n    # arr[0]\
    \ = h -> arr[0 + 2] = h\n    # arr[1] = h -> arr[1 + 2] = h\n    # arr[2] = i\
    \ -> arr[2 + 2] = i\n    \n    # Loop through each letter in the array\n    for\
    \ letter in arr\n        # Add the letter shifted by two to the end of our new\
    \ array\n        arr << 2 \n        \n    # Convert the array back to a string\
    \ and return\n    return arr.join(\"\")", "  s.gsub(/./){|e| e.ord - (e.ord -\
    \ key.ord)} \nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is very helpful.\
    \ I've been able to implement a similar solution to this, but I'm not certain\
    \ it's quite right - I'll take a look when I get home.\n<|/ c |>\n<| c |>\nWhat\
    \ do you mean by \"not quite right\"? Do you mean the string is not being rotated\
    \ properly?\n<|/ c |>\n<| c |>\nYes, sorry, the string is not being rotated properly.\
    \ I've made some progress, I'll post a solution when I get home. Thanks for your\
    \ help!\n<|/ c |>\n<| c |>\nUpdated my answer. Hopefully this solves your problem.\
    \ Let me know if there are any issues remaining.\n<|/ c |>\n<| a dscore=2 |>\n\
    Okay, here's what I've managed to come up with that seems to work. \n<code>",
  "    # Your code here\n    \nend\n</cell>\n<code language=julia-1.1>", "  letters.map\
    \ {|l| l}.join\nend", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    alphabet\
    \ = alphabet[1..-1]\n    return alphabet[s.chars.zip(alphabet).map { |a,b| a.succ\
    \ % 26 }.inject(0, :+)]\nend\n</code>\n<|/ a |>\n<| c |>\n`alphabet = alphabet[1..-1]`\
    \ will fail if `alphabet` is only `\"abcdef\"`\n<|/ c |>\n<| a |>\nThis was my\
    \ solution.  I needed a very fast and simple way to rotate a string. No complex\
    \ loops, no conditionals, no modulus.  \n<code>", "  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  s = s + 'z' #Add the 'z' to the end of the string\n  enc = Array.new(s.length,\
    \ 0) #Create a new array with the same size as the original string\n  \n  for\
    \ i in 0...s.length\n    temp = s.chars.to_a.sample(1)\n    char = alphabet.index(temp)\n\
    \    enc << alphabet[(char+2)%alphabet.length]\n  end\n  \n  return enc.join('')\n\
    end", "  return s.chars.map {|c| c.chr % 26 }.join\nend", "  alphabet = ['a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  new_s = \"\"\n  for i in s\n\
    \    new_s += alphabet.rotate(i) \n  return new_s\nend\n</cell>\n<code language=julia-1.5>",
  "  s = s + s[1,0] + s[0,1]\n  s = s[2,0] + s[3,1] + s[2,1] + s[3,0]\n  s = s[4,0]\
    \ + s[5,1] + s[6,1] + s[5,0] + s[4,1]\n  s = s[6,0] + s[5,1] + s[6,1] + s[5,0]\
    \ + s[6,1] + s[5,1] + s[4,0]\n  s = s[7,0] + s[6,1] + s[7,1] + s[6,0] + s[7,1]\
    \ + s[7,0] + s[6,1] + s[7,1]\n  s = s[8,0] + s[7,1] + s[8,1] + s[7,0] + s[8,1]\
    \ + s[8,0] + s[7,1] + s[8,1] + s[8,0]\n  s = s[9,0] + s[8,1] + s[9,1] + s[8,0]\
    \ + s[9,1] + s[9,0] + s[8,1] + s[9,1] + s[9,0] + s[8,1]\n  s = s[10,0] + s[9,1]\
    \ + s[10,1] + s[9,0] + s[10,1] + s[10,0] + s[9,1] + s[10,1] + s[10,0] + s[9,1]\
    \ + s[10,1]\n  s = s[11,0] + s[10,1] + s[11,1] + s[10,0] + s[11,1] + s[11,0] +\
    \ s[10,1] + s[11,1] + s[11,0] + s[10,1] + s[11,1] + s[11,0] + s[11,1]\n  s = s[12,0]\
    \ + s[11,1] + s[12,1] + s[11,0] + s[12,1] + s[12,0] + s[11,1] + s[12,1] + s[12,0]\
    \ + s[11,1] + s[12,1] + s[12,0] + s[11,1] + s[12,1] + s[12,0] + s[11,1]\n  s =\
    \ s[13,0] + s[12,1] + s[13,1] + s[12,0] + s[13,1] + s[13,0] + s[12,1] + s[13,1]\
    \ + s[13,0] + s[12,1] + s[13,1] + s[13,0] + s[12,1] + s[13,1] + s[13,0] + s[12,1]\
    \ + s[13,1] + s[13,0] + s[12,1] + s[13,1]\n  s = s[14,0] + s[13,1] + s[14,1] +\
    \ s[13,0] + s[14,1] + s[14,0] + s[13,1] + s[14,1] + s[14,0] + s[13,1] + s[14,1]\
    \ + s[14,0] + s[13,1] + s[14,1] + s[14,0] + s[13,1] + s[14,1]", "    # Write your\
    \ code here.\n    letters = ('abcdefghijklmnopqrstuvwxyz'\n               + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \               + '0123456789')\n    encrypted_string = ''\n    for i in s: \n\
    \        encrypted_string += letters[ord(i)-ord('A')]\n    return encrypted_string",
  "    s.chars.map { |c| c == \"z\" ? c + 1 : c == \"y\" ? c - 2 : c == \"x\" ? c\
    \ - 3 : c }.join\nend\n</code>\nAs you can see, the method above is very similar\
    \ to the code you gave in your original question. The only difference is that\
    \ the method uses a ternary operator instead of an if statement. I would recommend\
    \ using ternary operators whenever you find them more readable than if statements.\n\
    Now for the decrypt method:\n<code>", "  return s.chars.map do |c|\n    i = ALPHABET[c.upcase].length\n\
    \    ALPHABET[c.upcase][i % i] + ALPHABET[c.downcase][(i + i) % i]\n  end.join\n\
    end", "  (0..s.length-1).map { |n| s.slice!(n,n+2) }.join\nend\n</code>\n<|/ a\
    \ dscore=2 tags=ruby,string |>\n<| a dscore=1 tags=ruby,string |>\nFor fun and\
    \ education, this was my attempt.\n<code>", "  result = ''\n  s.chars.map do |c|\n\
    \    result << c.ord + (c.ord << 2)\n  end\n  return result\nend", "    alphabet\
    \ =['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    rotated_alphabet\
    \ = alphabet[alphabet.index(alphabet[::-1]) - 2] + alphabet[alphabet.index(alphabet[::-1])\
    \ - 1]\n    return s.translate(rotated_alphabet)\n    ", "  s.upcase!\n  rotated_alphabet\
    \ = (('A'..'Z').rotate(rand(3)).to_a).join(\" \")\n  s.chars.zip(rotated_alphabet.chars).join\n\
    end", "  s.split(\"\").each_with_index do |e,i|\n    (e[0]+2).rotate(i).join \n\
    \  end \nend", "  return s.gsub(/[a-z]/) { |letter| letter + letter[/[a-z]/] }.downcase\n\
    end", "  # initialize ciphertext as empty string\n  cipher = ''\n  \n  # use for\
    \ loop to go through each character in the string\n  # add two to every character\
    \ to get the rotated letter\n  # append the rotated letter to the ciphertext string\n\
    \  for char in s\n    cipher += (char.upcase + 2).downcase\n  end\n  \n  # return\
    \ the ciphertext string\n  return cipher\nend", "  result = ''\n  s.chars.each\
    \ do |c|\n    result += c.downcase.chars.map { |c| c.to_i + 2 }.join\n  end\n\
    \  result\nend", "    encrypted_string = \"\"\n    # Rotate s until it is all\
    \ letters \n    # or until all letters have been rotated\n    while s.downcase\
    \ != s\n        s = rotate_alphabet(s)\n    end\n    # Loop through the string\
    \ and add each letter to \n    # encrypted_string concatenated with the \n   \
    \ # string before it\n    # For example: \n    # s = 'abc'\n    # encrypted_string\
    \ = ''\n    # s.upcase + 'a' = 'ab'\n    # s.upcase + 'b' = 'ac'\n    # s.upcase\
    \ + 'c' = 'ad'\n    # s.upcase + 'd' = 'ae'\n    # s.upcase + 'e' = 'af'\n   \
    \ # s.upcase + 'f' = 'ag'\n    # s.upcase + 'g' = 'ah'\n    # s.upcase + 'h' =\
    \ 'ai'\n    # s.upcase + 'i' = 'aj'\n    # s.upcase + 'j' = 'ak'\n    # s.upcase\
    \ + 'k' = 'al'\n    # s.upcase + 'l' = 'am'\n    # s.upcase + 'm' = 'an'\n   \
    \ # s.upcase + 'n' = 'ao'\n    # s.upcase + 'o' = 'ap'\n    # s.upcase + 'p' =\
    \ 'aq'\n    # s.upcase + 'q' = 'ar'\n    # s.upcase + 'r' = 'as'\n    # s.upcase\
    \ + 's' = 'at'\n    # s.upcase + 't' = 'av'\n    # s.upcase + 'u' = 'aw'\n   \
    \ # s.upcase + 'v' = 'ax'\n    # s.upcase + 'w' = 'ay'\n    # s.upcase + 'x' =\
    \ 'az'\n    # s.upcase + 'y' = 'ay'\n    # s.upcase + 'z' = 'az'\n    s.each_byte\
    \ do |char|\n        if char.upcase == char\n            encrypted_string += char.upcase\n\
    \        else\n            encrypted_string += char.upcase\n        end\n    end\n\
    \    # Return the encrypted string\n    encrypted_string\nend", "    \n    return\
    \ s\nend", "    alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n\
    \    alphabet = alphabet[2:] + alphabet[:2]\n    \n    cipher = []\n    for i\
    \ in alphabet:\n        cipher.append([])\n        for char in s:\n          \
    \  if char.upper() in alphabet:\n                cipher[-1].append(char)\n   \
    \         else:\n                cipher[-1].append(alphabet[alphabet.index(char.upper())\
    \ + 1])\n            \n    cipher = \"\".join(cipher)\n    \n    return cipher",
  "  # Return the encrypted string.\n  result = \"\"\n  # For each character in the\
    \ original string, append the encrypted \n  # version of the character to the\
    \ result.\n  s.chars.reverse_each do |ch|\n    result << alphabet[alphabet.index(ch)\
    \ + shift].chr\n  end\n  # Return the encrypted string.\n  return result\nend",
  "  # Initialize an empty string for storing the encrypted string. \n  encrypted_string\
    \ = \"\"\n  \n  # Loop over every character in the string s\n  for character in\
    \ s\n    # Add two to every letter in the alphabet \n    encrypted_string += alphabet[(alphabet.index(character)\
    \ + 2) % 26]\n  \n  return encrypted_string\nend", "  s.each_char do |c|\n   \
    \ (alphabet.index(c.upcase) + 2).modulo alphabet.size \n  end \nend", "  alphabet_array\
    \ = alphabet\n  alphabet_array.shuffle\n  s.gsub!(\".\", alphabet[0])\n  s.gsub!(\"\
    .\", alphabet[1])\n  s.gsub!(\".\", alphabet[2])\n  s.gsub!(\".\", alphabet[3])\n\
    \  s.gsub!(\".\", alphabet[4])\n  s.gsub!(\".\", alphabet[5])\n  s.gsub!(\".\"\
    , alphabet[6])\n  s.gsub!(\".\", alphabet[7])\n  s.gsub!(\".\", alphabet[8])\n\
    \  s.gsub!(\".\", alphabet[9])\n  s.gsub!(\".\", alphabet[10])\n  s.gsub!(\".\"\
    , alphabet[11])\n  s.gsub!(\".\", alphabet[12])\n  s.gsub!(\".\", alphabet[13])\n\
    \  s.gsub!(\".\", alphabet[14])\n  s.gsub!(\".\", alphabet[15])\n  s.gsub!(\"\
    .\", alphabet[16])\n  s.gsub!(\".\", alphabet[17])\n  s.gsub!(\".\", alphabet[18])\n\
    \  s.gsub!(\".\", alphabet[19])\n  s.gsub!(\".\", alphabet[20])\n  s.gsub!(\"\
    .\", alphabet[21])\n  s.gsub!(\".\", alphabet[22])\n  s.gsub!(\".\", alphabet[23])\n\
    \  s.gsub!(\".\", alphabet[24])\n  s.gsub!(\".\", alphabet[25])\n  s.gsub!(\"\
    .\", alphabet[26])\n  s.gsub!(\".\", alphabet[27])\n  s.gsub!(\".\", alphabet[28])\n\
    \  s.gsub!(\".\", alphabet[29])\n  s.gsub!(\".\", alphabet[30])\n  s.gsub!(\"\
    .\", alphabet[31])\n  s.gsub!(\".\", alphabet[32])\n  s.gsub!(\".\", alphabet[33])\n\
    \  s.gsub!(\".\", alphabet[34])\n  s.gsub!(\".\", alphabet[35])\n  s.gsub!(\"\
    .\", alphabet[36])\n  s.gsub!(\".\", alphabet[37])\n  s.gsub!(\".\", alphabet[38])\n\
    \  s.gsub!(\".\", alphabet[39])\n  s.gsub!(\".\", alphabet[40])\n  s.gsub!(\"\
    .\", alphabet[41])\n  s.gsub!(\".\", alphabet[42])\n  s.gsub!(\".", "  # Return\
    \ the encrypted string.\n  return s.gsub(/[a-zA-Z]/,->{\n    letter = self[/./]\n\
    \    letter = letter < 'a' ? letter + 2 : 'z'\n    self[/./] = letter\n  })\n\
    end", "  s.reverse!\n  s.rotate(2, 1)\n  s.reverse!\n  s\nend\n</code>\n<|/ a\
    \ dscore=1 tags=ruby |>\n<| c |>\nWow, thanks. I'll test this out in the morning.\n\
    <|/ c |>\n<| c |>\nI haven't been able to try it yet. I don't quite understand\
    \ how this works, but I'm sure I'll be able to test it out in the morning. Thank\
    \ you very much for your help!\n<|/ c |>\n<| c |>\nI tested this out and it doesn't\
    \ quite work. Can you explain why this doesn't work? It doesn't quite do the trick.\n\
    <|/ c |>\n<| a tags=ruby |>\nI believe this is as close as you're going to get\
    \ to what you want. You'll need to find a way to wrap around the alphabet when\
    \ rotating and reverse when rotating.\n<code>", "  new_alphabet = rotate(alphabet_string,\
    \ 2)\n  encrypted_string = ''\n  s.chars.each_with_index do |letter, index|\n\
    \    encrypted_string << new_alphabet[index]\n  end\n  return encrypted_string\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you so much for your help.\n<|/ c |>\n\
    <| a tags=string,ruby dscore=1 |>\n<code>", "  \n  result = ''\n  \n  s.split('').each\
    \ do |char|\n    char == char.to_sym ? result += (char.upcase + char.downcase).rotate(2)\
    \ : result += (char + char).rotate(1)\n  end\n  \n  return result.upcase\nend",
  "    alphabet = s.dup\n    alphabet.rotate(2)\n    alphabet.each_index {|i| alphabet[i]\
    \ = alphabet[i].to_s.upcase }\n    alphabet.join\nend", "  s.chars.inject(\"\"\
    ){|s,c| s + alphabet[s.size - 1 - alphabet.index(c)].to_s}\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nI added some comments to the code and added an explanation.\n\
    <|/ c |>\n<| c |>\nThank you so much! I was able to solve this on my own, but\
    \ this was really helpful in understanding the process. I appreciate it!\n<|/\
    \ c |>\n<| a dscore=0 |>\nThis question has been asked before here and the accepted\
    \ answer was using arrays.  I understand that there are advantages to using arrays\
    \ but I was trying to learn how to do it in Ruby.  I hope this helps.\n<code>",
  "    i = 0\n    letter = s.chars.to_a\n    letter = letter.reverse\n    letter =\
    \ letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n \
    \   letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter = letter.reverse\n    letter = letter.reverse\n\
    \    letter = letter.reverse\n    letter", "  # Create an empty array to hold\
    \ the encrypted string\n  encrypted_string = []", "  alphabet.rotate(2)\n  return\
    \ alphabet[s.index(s)]\nend\n</code>\nFor a more practical example, I'll use the\
    \ string 'abcd' as a test case but I'll leave the implementation up to you.\n\
    The next thing you'll want to do is to take a look at the Ruby documentation for\
    \ Array#rotate. Since rotate rotates elements individually the index of the rotated\
    \ elements is going to be off. Ruby provides a way to swap elements by index without\
    \ knowing the size of the array.\n<code>", "  alphabet = ('A'..'Z').to_a\n  rot_alphabet\
    \ = alphabet.rotate.to_a\n  s.gsub(/[^A-Za-z]/) { |x| rot_alphabet[alphabet.index\
    \ x] }\nend", "  \n  s.downcase! #Convert all letters to lowercase\n  \n  alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\".split(\"\") #Create a string with the alphabet\n\
    \  alphabet = [alphabet[i], alphabet[i + 1]] #Create a list of every two letters\
    \ starting at the middle\n  alphabet = [alphabet[0], alphabet[1]]\n  \n  s.tr!(alphabet)\
    \ #Remove the letters being rotated", "  new_alphabet = []\n  s.chars.each do\
    \ |c|\n    new_alphabet.push( c )\n  end\n  new_alphabet.rotate!\n  new_alphabet.join(\"\
    \")\nend", "   alphabet = ('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z')\n\
    \   alphabet = [alphabet[i] for i in alphabet]\n   alphabet = [alphabet[i] for\
    \ i in alphabet]\n   alphabet = [alphabet[i] for i in alphabet]\n   \n   length\
    \ = len(s)\n   \n   for i,c in enumerate(s):\n      if not (i==0) and not (i==length-1):\n\
    \         alphabet.append(alphabet[i])\n         alphabet.append(alphabet[i+1])\n\
    \         alphabet.append(alphabet[i-1])\n         alphabet.append(alphabet[i-2])\n\
    \         alphabet.append(alphabet[i-3])\n         \n   alphabet = [alphabet[i]\
    \ for i in alphabet]\n   alphabet = ''.join(alphabet)\n   \n   \n   \n   return\
    \ alphabet", "  result = ''\n  (0...s.length).each do |index|\n    result = result\
    \ + alphabet[((index+2)%26) + 1]\n  end\n  result\nend", "  s.chars.each_with_index\
    \ do |char, index| \n    letter = alphabet.index(char)\n    letter = letter +\
    \ 2\n    letter = letter % 26\n    alphabet[index] = alphabet[letter]\n  end\n\
    \  s.chars\nend", "  # TODO: Return the encrypted version of s.\nend", "  alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n  res = []\n  s.split(\"\").each do |c|\n  \
    \  index = alphabet.index(c.upcase)\n    index += 1\n    index = ((index*2)/2)\
    \ + 1\n    index = alphabet.index(index)\n    res << alphabet[index]\n  end\n\
    \  res.join(\"\")\nend", "  s.reverse!\n  alphabet = s.split('').map(&:to_i)\n\
    \  alphabet = alphabet.rotate(2).zip(alphabet).to_h\n  alphabet.reverse!\n  s.reverse!\n\
    \  s.split('').zip(alphabet.map { |c,a| a.include?(c) ? c : nil } ).join\nend",
  "   alphabet = %w[a b c d e f g h i j k l m n o p q r s t u v w x y z]\n   result\
    \ = \"\"\n   s.split('').each do |c|\n      i = alphabet.index(c)\n      result\
    \ << alphabet[(i - 1) % alphabet.size]\n      result << alphabet[(i - 2) % alphabet.size]\n\
    \   end\n   result\nend", "  s.chars.zip(0..s.size).map {|e| e.rotate(2).join}.join\n\
    end\n</code>\n<|/ a tags=ruby,encryption |>\n<| c |>\n`s.chars.zip(0..s.size).map\
    \ {|e| e.rotate(2).join}.join` is more concise and readable, IMHO.\n<|/ c |>\n\
    <| c |>\nI guess that's true, I haven't really thought about the readability of\
    \ the code. Thanks for the comment!\n<|/ c |>\n<| c |>\nIt may also be worth mentioning\
    \ that this method would only work if all the characters are lowercase letters.\
    \ `decrypt(\"lm\")` will return `nil` because `\"a\"` is not in the alphabet.\n\
    <|/ c |>\n<| c |>\nI see, I added an edit in the original post to reflect that.\n\
    <|/ c |>\n<| c |>\nThanks for that addition. Very helpful indeed.\n<|/ c |>\n\
    <| a dscore=3 |>\n<code>", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotated\
    \ = alphabet[-s.index(alphabet[0]):][::-1] + alphabet[0:s.index(alphabet[0]):][::-1]\n\
    \    alphabet = alphabet.split().reverse()\n    alphabet = alphabet[:-1] + ['k']\n\
    \    return ''.join([alphabet[index] for index in range(0,len(s)) if s[index]\
    \ not in 'aeoy'])", "  chars.zip(chars.rotate).inject(s) { |s, (a,b)| s + a.chr\
    \ + b.chr }\nend", "    encrypted_string = ''\n    \n    # Loop through the string\
    \ and append encrypted characters\n    for i in (s.split(''))\n        encrypted_string\
    \ += alphabet[alphabet.index(i) + 2]\n        \n    # Add a new line to seperate\
    \ encrypted characters\n    encrypted_string += \"\\n\"", "  s.each_char { |c|\
    \ s.rotate(2) }\nend", "  s.each_char.map { |c|\n    c + 2\n  }.join\nend", " \
    \ # Initialize a list to contain the alphabet\n  a = [char for char in alphabet\
    \ if char != ' ']", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    s_length\
    \ = s.length\n    encrypted = ''\n    for i in alphabet\n        if i == alphabet[s_length\
    \ - 1]\n            encrypted += alphabet[alphabet.index(i) + 2]\n        else\
    \ if i != alphabet[s_length - 1]\n            encrypted += alphabet[alphabet.index(i)\
    \ + 2]\n            encrypted += alphabet[alphabet.index(i) + 1]\n        else\n\
    \            encrypted += i\n        end\n    end\n    encrypted\nend", "  alphabet\
    \ =  'abcdefghijklmnopqrstuvwxyz'\n  alph_len = len(alphabet)\n  rot_alphabet\
    \ = alphabet[alph_len-2..alph_len-1]\n  rot_alphabet.concat alphabet[alph_len..alph_len-1]\n\
    \  rot_alphabet.concat alphabet[alph_len-2..alph_len]\n  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n\
    \  rot_alphabet.concat alphabet[alph_len-2..alph_len]\n  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n\
    \  rot_alphabet.concat alphabet[alph_len-2..alph_len]\n  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n\
    \  rot_alphabet.concat alphabet[alph_len-2..alph_len]\n  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n\
    \  rot_alphabet.concat alphabet[alph_len-2..alph_len]\n  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n\
    \  rot_alphabet.concat alphabet[alph_len-2..alph_len]\n  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n\
    \  rot_alphabet.concat alphabet[alph_len-2..alph_len]\n  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n\
    \  rot_alphabet.concat alphabet[alph_len-2..alph_len]\n  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n\
    \  rot_alphabet.concat alphabet[alph_len-2..alph_len]\n  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n\
    \  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n  rot_alphabet.concat alphabet[alph_len-2..alph_len]\n\
    \  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n\
    \  rot_alphabet.concat alphabet[alph_len-2..alph_len]\n  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n\
    \  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n  rot_alphabet.concat alphabet[alph_len-2..alph_len]\n\
    \  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n  rot_alphabet.concat alphabet[alph_len..alph_len-2]\n\
    \  rot_alphabet.concat alphabet[alph_len-2..alph_len]\n  rot_alphabet.concat alphabet[alph_len",
  "  result = \"\"\n  s.each do |letter|\n    result += alphabet.index(letter) + 2\n\
    \  end\n  result << alphabet[alphabet.size - 1]\n  return result\nend", "  alphabet_size\
    \ = 26\n  letter_size = 26\n  rotated_alphabet = rot13(alphabet)\n  encrypted_string\
    \ = ''", "    rot_chars = rotate(ALPHABET,s)\n    return rot_chars\nend", "  s.each_char\
    \ do |char|\n    char.ord + 48 + char.ord + (char.ord >> 2)\n  end\nend", "  return\
    \ s.chars.rotate.map { |c| c.ord + 2 }.join\nend", "    # Your code goes here\n\
    \    #encryption = \"\"\n    #for i in range(0, (len(s)/2)):\n    #    encryption\
    \ = encryption + alphabet[(alphabet.index(s.lower())+2)%26]\n    #return encryption\n\
    \    encryption = \"\"\n    for i in range(len(s)):\n        encryption = encryption\
    \ + alphabet[(alphabet.index(s.lower())+2)%26]\n    return encryption", "  # Write\
    \ your code here.\nend", "  return s.chars.zip(s[1..-1]).map { |a,b| b+2*a.next\
    \ }.join\nend\n</code>\nThen the code should look like this (using the above helper\
    \ function and a couple of additional helpers):\n<code>\nword = 'test'\np encrypt(word)\n\
    p decrypt = encrypt(word)\np decrypt\np decrypt = decrypt(decrypt)\np decrypt\n\
    p decrypt\np decrypt\np decrypt = decrypt(decrypt)\np decrypt\np decrypt\n</code>\n\
    Output:\n<code>\ntest\ntest\ntest\ntest\ntest\ntest\ntest\ntest\ntest\ntest\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for your answer but its not exactly what I\
    \ was looking for ;) My goal is to encrypt a string, with all the letters shifted\
    \ down by 2, like I showed in the example.\n<|/ c |>\n<| a tags=ruby dscore=0\
    \ |>\nAs I understand it, you need to implement a method rotate2x that takes two\
    \ arguments: the alphabet and a string, as you've defined them in the question,\
    \ and returns a string, with the characters of the string rotated through each\
    \ of the alphabet. The alphabets are \"rotated through\" by two, so \"abc\" becomes\
    \ \"cba\", and \"abcd\" becomes \"dcba\".\n<code>", "    # Initialize a variable\
    \ called result to an empty string\n    result = ''\n    # Loop over the string\n\
    \    s.each do |c|\n        # If the current character is in the alphabet\n  \
    \      if alphabet.include? c\n            # Add two to the current character\
    \ in the alphabet\n            result += alphabet[alphabet.index(c) + 2].capitalize\n\
    \        else\n            # Add twice the current character to the alphabet\n\
    \            result += alphabet[alphabet.index(c) + 2].capitalize\n          \
    \  result += alphabet[alphabet.index(c) + 2].capitalize\n        end\n    end\n\
    \    # Return the result string\n    return result\nend", "  cipher = nil\n  s.split('').each\
    \ do |i|\n    cipher = i.ord + cipher\n  end\n  cipher.to_s(36).rjust(36, '0')\n\
    end", "    s = s.downcase\n    s = 'a'.upcase + s.to_s.split('').map { |c| c.upcase\
    \ }.join(\"\").rotate 2\n    s.downcase\nend\n</code>\nIn addition to the previous\
    \ solution, my own solution:\n<code>", "  s.chars.each { |c| c.succ * 2 }.join\n\
    end", "  s.chars.each_with_index do |c,i|\n    temp = c.chars.last\n    temp =\
    \ (temp*2 + c).chr\n    temp = (temp + c.chars.first).chr\n    temp = (temp*2\
    \ + c).chr\n    temp = (temp + c.chars.first).chr\n    temp = (temp + c.chars.first).chr\n\
    \    s.insert(i,temp)\n  end\nend", "  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  result = ''\n  s.each_char do |c|\n    result += (alphabet[(alphabet.index(c)\
    \ + 2) % alphabet.length])\n  end\n  result\nend", "    alphabet = s.chars.to_a\n\
    \    alphabet.rotate 2, 2\n    alphabet.map! do |char| alphabet.index(char) +\
    \ 1\n    alphabet.join\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nYou\
    \ could use some string manipulation with substitution to rotate the characters:\n\
    <code>", "  s.each_char do |c|\n    alpha.index(c + c.upcase) % alpha.size\n \
    \ end\nend", "  # We will need to create an array of 26 integers and initialize\
    \ each one\n  # to a random integer between 0 and 25 - this will be useful later\n\
    \  # to make sure our numbers are different than random numbers\n  array = []\n\
    \  (0..25).each { |i| array << i }\n  # Now we will need to loop through each\
    \ letter in our string\n  # and shift the letters down by two \n  (s..s.count(\"\
    z\")).each { |letter| \n    letter = s[letter] \n    array[(letter - 2) % 26]\
    \ = letter\n  }\n  # To convert the numbers back to letters, we have to add 26\
    \ back on\n  # each array's number\n  array.map { |num| num + 26 }\n  # Now we\
    \ just need to join each array by an empty string\n  array.join\nend", "    #\
    \ Create a variable called alphabet that stores \n    # the alphabet to be rotated.\
    \ \n    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    # Create a variable called\
    \ alphabet_count that stores the \n    # number of letters in alphabet\n    alphabet_count\
    \ = 26", "    cipher = \"\"\n    letters = \"abcdefghijklmnopqrstuvwxyz\"\n  \
    \  numbers = \"12345\"\n    for letter in s\n        if letter in letters\n  \
    \          cipher = cipher + letters[letters.index(letter)].upcase\n        else\n\
    \            cipher = cipher + letters[letters.index(letter)].downcase\n    \n\
    \    if letter in numbers\n        cipher = cipher + numbers[numbers.index(letter)].upcase\n\
    \    else\n        cipher = cipher + numbers[numbers.index(letter)].downcase\n\
    \        \n    return cipher\nend", "  letters = string.ascii_lowercase\n  letters_count\
    \ = letters.length\n  letters.rotate!\n  \n  s.chars.each do |char|\n    if char.upcase\
    \ >= letters_count\n      char.upcase -= letters_count\n    end\n  end\n  \n \
    \ return s\nend\n</cell>\n<cell>", "  encrypted_alphabet = s.dup\n  encrypted_alphabet.rotate(s.length)\n\
    \  encrypted_alphabet.insert(s.length - 1, 'z')\n  encrypted_alphabet.insert(0,\
    \ 'a')\n  encrypted_alphabet.join(\"\")\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=ruby-on-rails-3,ruby |>\nAs a pure Ruby solution (which may not be as elegant\
    \ as the other solutions posted), here's how I solved the problem in a Rails 3.2.14\
    \ environment:\nIn app/controllers/letters_controller.rb:\n<code>", "    alpha\
    \ = 'abcdefghijklmnopqrstuvwxyz'\n    alpha_rotated = alpha.rotate(2)\n    s_enc\
    \ = s.split(\"\")\n    s_enc_rotated = []\n    for c in s_enc:\n        if c not\
    \ in alpha:\n            s_enc_rotated.append(c)\n        else:\n            s_enc_rotated.append(alpha_rotated[alpha.index(c)+2])\n\
    \    return ''.join(s_enc_rotated)\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThis\
    \ works and avoids looping through each letter in the string twice. \n<code>",
  "    alpha = 'abcdefghijklmnopqrstuvwxyz'\n    alphabet = alpha.split(//)\n    rotations\
    \ = alpha.count('z')\n    index = alphabet.index\n    \n    cipher = []\n    i\
    \ = 0\n    while i < s.length\n        cipher.push(alpha[index(s[i] + rotations)].concat)\n\
    \        i += 1\n    return cipher\nend", "  alphabet = s.split('').sort.join\n\
    \  alphabet = alphabet.split('').rotate\n  alphabet = alphabet.join\n  return\
    \ alphabet\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nYou can use the\
    \ following code (thanks to \"John Hartman\"):\n<code>", "    s = s.gsub(/[a-z]/){|a|\
    \ a.ord.to_s * (26 - a.ord - 2)}\n    s.gsub(/[a-z]/){|a| a.ord.to_s * (26 - a.ord\
    \ - 2)}\nend\n</code>\n<|/ a tags=encryption,ruby |>\n<| a dscore=3 |>\n<code>\n\
    cipher = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"]\nplain = \"abcde\"\ncipher = cipher.zip(cipher).map(&:reverse).map(&:join).zip(plain).map(&:join)\n\
    </code>\n<|/ a tags=encryption,ruby |>\n<| c |>\nThanks, that works. But is there\
    \ a way to get this done without having to have \"plain\" in it?\n<|/ c |>\n<|\
    \ c |>\nI'm sure there is a way but I don't understand why you would want that.\
    \ If you're trying to protect your secret, you really want to store them in a\
    \ separate file and read them in from a safe location that isn't open to your\
    \ code. Otherwise you're just going to make life harder for no real gain.\n<|/\
    \ c |>\n<| c |>\nIt's an exercise from Programming Ruby 2nd by Stanley, which\
    \ wants us to use a separate file of secret information to encrypt and decrypt.\
    \ So I think you're right. Thanks.\n<|/ c |>\n<| a |>\nThe Zxcvbn encryption library\
    \ is really handy:\n<code>\nrequire \"zxcvbn\"\nrequire \"base64\"\nZxcvbn.random_password(:words,\
    \ 8).encode64\n</code>\n<|/ a tags=encryption,ruby dscore=3 |>\n<| c |>\nThis\
    \ should be the accepted answer. The zxcvbn gem is well maintained, and can do\
    \ more than the OP needs.\n<|/ c |>\n<| a |>\nHere's one way using a simple array:\n\
    <code>\nalphabet = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]",
  "    alphabet.each { |letter| s.split(//).zip(letter).map(&:join).join }\nend",
  "  alphabet = s.to_s.split('')\n  alphabet = alphabet.rotate(1).join\n  alphabet\
    \ = alphabet.rotate(-1).join\n  alphabet = alphabet.split('').join\n  return alphabet\n\
    end\n  ", "  s.split('').each do |letter|\n    alphabet.shift(letter, 2)\n  end\n\
    end", "  return s.split('').zip(s.chars.rotate(2).map{|c| c.succ}).map{|a| a.join}\n\
    end\n</code>\nThe first line splits the string into an array of characters.  The\
    \ second line zips them with the array of characters rotated two places to the\
    \ right (so \"abcdef\" becomes [[\"a\", \"b\"], [\"c\", \"d\"], [\"e\", \"f\"\
    ], [\"g\", \"h\"], [\"i\", \"j\"], [\"k\", \"l\"], [\"m\", \"n\"], [\"o\", \"\
    p\"], [\"q\", \"r\"], [\"s\", \"t\"], [\"u\", \"v\"], [\"w\", \"x\"], [\"y\",\
    \ \"z\"]]) and map them into a new array where each element is a letter shifted\
    \ two places to the right (so \"abcdef\" becomes [[\"b\", \"c\"], [\"d\", \"e\"\
    ], [\"f\", \"g\"], [\"h\", \"i\"], [\"j\", \"k\"], [\"l\", \"m\"], [\"n\", \"\
    o\"], [\"p\", \"q\"], [\"r\", \"s\"], [\"t\", \"u\"], [\"v\", \"w\"], [\"x\",\
    \ \"y\"], [\"z\"]]).  Finally we map them into a new array where each element\
    \ is a letter in it's original position plus it's new shifted position (so \"\
    abcdef\" becomes [[\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"], [\"g\", \"h\"\
    , \"i\"], [\"j\", \"k\", \"l\"], [\"m\", \"n\", \"o\"], [\"p\", \"q\", \"r\"],\
    \ [\"s\", \"t\", \"u\"], [\"v\", \"w\", \"x\"], [\"y\", \"z\"]]) and finally join\
    \ them all into one string.\n<|/ a |>\n<| a |>\nThis works:\n<code>", "end\n</code>\n\
    <|/ q tags=ruby,ruby-on-rails |>\n<| c |>\nIf you can do it in a single line,\
    \ then why are you posting it in a separate file? It will confuse people reading\
    \ your question.\n<|/ c |>\n<| c |>\nI suppose it might be easier to read and\
    \ follow if I can separate each line of code into its own file. Is that a bad\
    \ idea?\n<|/ c |>\n<| c |>\nNo, it's not a bad idea. That's what it's there for.\
    \ You should probably take a look at Ruby style guide.\n<|/ c |>\n<| c |>\nThanks\
    \ for the help everyone, I was struggling with this.\n<|/ c |>\n<| a |>\n<code>",
  "    alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    encrypted\
    \ = []\n    for char in s\n        encrypted << alphabet[alphabet.index(char)\
    \ + 2]\n    end\n    return encrypted.join\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| a tags=ruby |>\n<code>", "  rotated = ''\n  for c in s \n    if c == ?a # check\
    \ if character is alphabet \"a\"\n      rotated << ?b # append \"b\" to rotated\
    \ string\n    elsif c == ?z # check if character is alphabet \"z\"\n      rotated\
    \ << ?a # append \"a\" to rotated string\n    else\n      rotated << c\n    end\n\
    \  end\n  rotated\nend\n</cell>\n<cell>\nencrypt(\"Hi\")\n</cell>\n<cell>", " \
    \ # Get the length of the string\n  length = s.length", "  result = \"\"\n  s.each_char\
    \ do |c|\n    result+= (alphabet.index(c) + 2) * 2\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby,arrays,string |>\n<| a dscore=1 |>\nYou can use a hash to map\
    \ the letters in the alphabet to a value, and just add 2 before adding:\n<code>",
  "  result = ''\n  s.each_char { |c| result += alphabet.rotate((alphabet.index(c)\
    \ + 2) % alphabet.length) }\n  return result\nend", "    alphabet = s.split(//)\n\
    \    alphabet.each { |c| alphabet[alphabet.index(c)] = alphabet[alphabet.index(c)].upcase\
    \ }\n    alphabet.join\nend\n</code>\n<|/ a tags=ruby,encryption,functional-programming\
    \ |>\n<| c |>\nThis is really nice. Thanks for the explanation\n<|/ c |>\n<| a\
    \ dscore=3 tags=ruby,encryption,functional-programming |>\nI liked the idea of\
    \ using a rotating function but here's a more efficient way of doing it:\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
