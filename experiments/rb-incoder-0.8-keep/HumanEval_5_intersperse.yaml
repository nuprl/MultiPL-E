name: HumanEval_5_intersperse
language: rb
prompt: "# Insert a number 'delimeter' between every two consecutive elements of input\
  \ list `numbers'\n# >>> intersperse([], 4)\n# []\n# >>> intersperse([1, 2, 3], 4)\n\
  # [1, 4, 2, 4, 3]\ndef intersperse(numbers, delimeter)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersperse\n\
  \    candidate = method(:intersperse)\n    assert_equal([], candidate.call([], 7))\n\
  \    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))\n    assert_equal([2,\
  \ 2, 2, 2, 2], candidate.call([2, 2, 2], 2))\n  end\nend\n"
completions: ["  numbers.each_with_index.map { |n, i| i + 1 }.map { |i| delimeter\
    \ * i } + numbers\nend", "  numbers.each_cons(2) do |a,b|\n    numbers.insert(a,\
    \ delimeter)\n    numbers.insert(b, delimeter)\n  end\n  numbers\nend", "    numbers.reduce(:<<).unshift(delimeter)\n\
    end", "  \n  return [] if numbers.empty? || numbers.size == 0\n  \n  numbers_with_the_separator\
    \ = []\n  \n  numbers.each_with_index do |number, index|\n    \n    numbers_with_the_separator\
    \ << number if index == 0\n    \n    numbers_with_the_separator << delimeter\n\
    \    \n    numbers_with_the_separator << number if index == (numbers.size-1)\n\
    \  end\n  \n  return numbers_with_the_separator\nend", '  interspersed_numbers
    = []', "  if numbers.nil?\n    numbers\n  else\n    numbers.each_with_index do\
    \ |number, index|\n      new_list = numbers.slice(0, index + 1)\n      new_list\
    \ << number\n      new_list << delimeter\n      new_list << numbers.slice(index\
    \ + 1, numbers.length)\n      new_list\n    end\n  end\nend\n</code>\n<|/ a tags=arrays,ruby,ruby-on-rails\
    \ |>\n<| a dscore=0 |>\nThis is a variant of Benjamin's answer but it's very simple\
    \ and intuitive:\n<code>", "  numbers = numbers[0..-2]\n  numbers.each_with_index\
    \ do |number, index|\n    numbers[index] = delimeter if index + 1 < numbers.length\n\
    \    numbers[index..-1] += delimeter + number\n  end\n  numbers\nend\n</code>\n\
    <|/ a dscore=4 tags=ruby,ruby-on-rails,arrays,ruby-on-rails-3 |>\n<| c |>\n+1\
    \ for providing the code for the method. I'll take this as my answer when I can\
    \ get my test suite to pass.\n<|/ c |>\n<| c |>\nI got this working on my rails\
    \ test suite but I'll mark this as my answer because it's the most readable solution\
    \ and I can get my test suite passing.\n<|/ c |>\n<| c |>\n+1 for providing the\
    \ tests, but you didn't mention the edge cases. Do you think I should add them?\n\
    <|/ c |>\n<| c |>\nYes, I would also like to add a test for the edge cases, so\
    \ that if you're working with your colleagues code they don't have to fix it when\
    \ they call your method.\n<|/ c |>\n<| c |>\nI've added the test cases and removed\
    \ the unnecessary `map` and `join`.\n<|/ c |>\n<| a dscore=4 |>\n<code>", "  numbers.each\
    \ do |number|\n    yield number\n    yield delimeter\n  end\nend", "    numbers_length\
    \ = numbers.size\n    numbers_length = numbers_length.zero? if numbers.empty?\
    \ then 0 else numbers_length end\n    numbers_length = numbers_length + 1\n  \
    \  interspersed_number = []\n    interspersed_number.concat numbers.to_a\n   \
    \ interspersed_number.concat [delimeter] * numbers_length\n    interspersed_number.reverse!\n\
    \    return interspersed_number\nend", "  numbers = numbers.dup\n  numbers[0..-2].concat\
    \ delimeter, numbers[1..-1]\nend", "  result = numbers.dup\n  delim = delimeter\n\
    \  until result.empty?\n    result.shift delimeter\n  end\n  result\nend", " \
    \ numbers.collect! {|n| [n, delimeter]}\n  numbers.join\nend", "  numbers.each_cons(2).with_index\
    \ do |(a,b),i|\n    numbers[(i - 1) * 2] = a\n    numbers[(i - 1) * 2 + 1] = delimeter\n\
    \  end\n  numbers\nend", "  numbers.collect! do |number|\n    number.to_s + delimeter.to_s\n\
    \  end\n  number\nend\n</code>\n<|/ a tags=ruby,list,arrays |>\n<| c |>\nThe OP\
    \ said they didn't want to use `Array#collect`.  I believe `Array#collect` is\
    \ fine in their case.\n<|/ c |>\n<| c |>\nMy guess is he was just trying to avoid\
    \ `Array#collect` because they said they didn't want to use `Array#collect`. But\
    \ yes, your solution is fine.\n<|/ c |>\n<| c |>\nI added some explanation to\
    \ the OP since I noticed that he was looking for a way to avoid `Array#collect`,\
    \ which I explained above.\n<|/ c |>\n<| c |>\nI guess it would be nice to have\
    \ a better answer, because if there's a way to avoid `Array#collect` that would\
    \ be nice.\n<|/ c |>\n<| a dscore=1 |>\nAnother solution is to use 'inject'.\n\
    <code>\n[1, 2].inject([]) { |a, b| a << a[-1] + b; a << b }", "  numbers.zip(numbers[1..-1]).map\
    \ do |x, y|\n    x if delimeter == y\n  end.compact\nend", "  if numbers.empty?\
    \ or numbers.last.nil? # empty or last element of numbers is nil\n    numbers\n\
    \  else\n    numbers.first.send(:+) + delimeter.join(numbers.drop(1))\n  end\n\
    end", "  numbers.inject do |result, num|\n    result << num if result.size < numbers.size\
    \ || (result.size == numbers.size && num != numbers.last)\n    result << delimeter\n\
    \    result\n  end\nend", "  \n  # Write your code here.\n  # => numbers = numbers.each_slice(2).to_a\n\
    \  # => numbers.each {|a| a.join(delimeter)}\n  \n  numbers.each_slice(2).to_a.each\
    \ do |a|\n    a.join(delimeter)\n  end\nend\n</cell>\n<cell>", "  numbers\n  numbers.each\
    \ do |n|\n    yield(n) if block_given?\n    yield(n)\n    yield delimeter\n  end\n\
    end\n</code>\n<|/ a tags=ruby,arrays,interleave,ruby-on-rails |>\n<| a tags=ruby,arrays,interleave,ruby-on-rails\
    \ |>\nI like Kudo's answer, but I think he was overcomplicating the problem. The\
    \ problem is simple: I want to create a string like so: \"hello, john, foo, bar,\
    \ foo\", so I simply need to use string concatenation. No special methods or anything:\n\
    <code>\n[\"hello\", \"john\", \"foo\", \"bar\"].join(', ')\n=> \"hello, john,\
    \ foo, bar\"\n</code>\n<|/ a dscore=2 |>\n<| c |>\nBut it doesn't answer the original\
    \ question which is about an array\n<|/ c |>\n<| a tags=ruby,arrays,interleave,ruby-on-rails\
    \ dscore=2 |>\nI solved it by doing this in a helper function\n<code>", "\tresult\
    \ = []\n\tif numbers.any?\n\t\tnumbers.each_with_index do |number, index|\n\t\t\
    \tresult << number unless index == 0\n\t\t\tresult << delimeter\n\t\t\tresult\
    \ << number unless index == numbers.length - 1\n\t\tend\n\telse\n\t\tresult =\
    \ numbers\n\tend\n\tresult\nend", "    numbers_with_delimiter = [numbers.first,\
    \ numbers.last]\n    (numbers_with_delimiter.length >= 2) and numbers_with_delimiter\
    \ << delimeter\n    \n    # Return `numbers' after removing all elements found\
    \ in `numbers_with_delimiter'\n    numbers.delete_if { |n| numbers_with_delimiter.include?(n)\
    \ }\nend\n</cell>\n<text>\nWe now need to convert our list of numbers into its\
    \ equivalent list of words", "    numbers.each_cons(2) do |a, b|\n        a.unshift(b)\n\
    \        b.unshift(delimeter)\n    end\nend", "  # Initialize a variable `result'\
    \ to be an empty list\n  result = numbers.dup\n  # Iterate over every element\
    \ of the list `numbers'\n  numbers.each_with_index do |number, index|\n    # Insert\
    \ a number 'delimeter' between every two consecutive elements of input list `numbers'\n\
    \    result.insert(index + 1, delimeter)\n  end\n  # Return variable 'result'\n\
    \  result\nend\n</pre>", "    numbers, delimeter, out = [], delimeter, []\n  \
    \  numbers.each do |n|\n        out << n\n        out << delimeter\n    end\n\
    \    out\nend", "  if numbers.empty?\n    number\n  else\n    numbers.map { |n|\
    \ n.dup }.unshift(delimeter)\n  end\nend\n</code>\n<|/ a tags=ruby dscore=3 |>\n\
    <| c |>\nThis is the best answer I guess.\n<|/ c |>\n<| a |>\nHere is a way that\
    \ works on MRI and jRuby 1.5.0 and is pretty compact (one line):\n<code>", " \
    \ return [] if numbers == [] then [] else numbers.first.nil? ? [] : [numbers.first,\
    \ delimeter, numbers.last]\nend", "  return [...numbers[0...-1], delimeter, ...numbers[-1..-1]]\n\
    end", "  result = []\n  for x in numbers\n    result << ((numbers.size != 1) ?\
    \ x : delimeter) + x\n  result\nend", "  return [delimeter + x for x in numbers]\n\
    end", "    return numbers[0..-2].join(delimeter).concat(numbers[-2..-1])\nend",
  "  numbers.inject([], :+)\nend", "  numbers = numbers.dup\n  numbers.each do |n|\n\
    \    numbers.shift\n    numbers.push(delimeter, n)\n  end\n  numbers\nend", " \
    \ numbers.each_cons(2).with_object([]) do |(first, second), output|\n    output\
    \ << first << delimeter << second\n  end\nend", "  numbers, delimeter = numbers,\
    \ delimeter\n  numbers.each_with_index do |number, index|\n    numbers[index+1]\
    \ = number\n    numbers << delimeter\n  end\n  numbers\nend\n</code>\nHere we\
    \ are just looping through each element of an array, then appending that element\
    \ (with its index) to the numbers array, and then appending a delimeter to that\
    \ array (with index + 1). \nIf you want a shorter version (which you may find\
    \ clearer if you are just learning) you could use map, which just loops through\
    \ a collection and returns another collection:\n<code>\nnumbers = [1, 2, 3, 4]\n\
    delimer = 4", "    # Insert delimeter in between every two consecutive elements\
    \ of input list `numbers'\n    # >>> intersperse([1, 2, 3], 4)\n    # [1, 4, 2,\
    \ 4]\n    # >>> intersperse([1, 2], 4)\n    # [1, 2, 1, 2]\n    return numbers.each_cons(2).map\
    \ {|a, b| a + delimeter + b }.flatten\nend\n</code>\nIn Ruby, there is an each_cons\
    \ method which lets you iterate over an iterator in groups of n. Like you might\
    \ write it in Python:\n<code>", "  numbers.each_cons(2).with_index do |(number,\
    \ index), i|\n    numbers[i + 1] = number + delimeter + numbers[i + 1]\n  end\n\
    end", "  numbers.each_cons(2) do |a,b|\n    a.unshift(delimeter)\n    b.unshift(delimeter)\n\
    \  end\nend", "  # Initialize the output list to `numbers'\n  out = numbers",
  "  # your code here\nend\n</cell>\n<cell>", "  numbers_with_delimeter = numbers.each_cons(2).to_a\n\
    \  numbers_with_delimeter[0...-1].push(delimeter)\n  numbers_with_delimeter.join\n\
    end", "  return [numbers[0], delimeter.join(numbers[1..-1]), numbers[-1]]\nend",
  "  return numbers.each_cons(2).map {|n| n.join(delimeter)}.join(\"\")\nend\n</code>\n\
    <|/ a tags=string,arrays,ruby dscore=0 |>\n<| a tags=string,arrays,ruby |>\n<code>",
  "  numbers.inject { |result, number| result + [number] + delimeter.join number.to_s\
    \ }\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| a tags=ruby |>\nTo avoid the\
    \ nested loops you can use #inject:\n<code>\nnumbers = [1, 2, 3, 4, 5]\nresult\
    \ = numbers.inject([]) { |r,x| r << x << \",\" }\nputs result.join(\"\\n\")\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis would not produce the same output as\
    \ the question, where each element is separated by a comma.\n<|/ c |>\n<| c |>\n\
    You are right, I updated the answer accordingly. Thanks.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nHere's a solution that uses inject:\n<code>\nnumbers = [1, 2, 3, 4, 5]\n\
    result = numbers.inject([]) do |arr, number|\n  arr.concat(number).join(\",\"\
    )\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI updated my answer (now with my\
    \ first solution) to use a String instead of an array and join it at the end.\
    \ Thanks for the suggestion.\n<|/ c |>\n<| c |>\n`arr.concat(number).join(\",\"\
    )` is the same as `arr.concat [number]`, same as `arr.concat number.to_s`\n<|/\
    \ c |>\n<| c |>\nYes I saw that in your updated solution. Thanks for the suggestion.\n\
    <|/ c |>\n<| c |>\nI updated my answer with your solution and some comments. Thanks\
    \ for your suggestion.\n<|/ c |>\n<| a tags=ruby |>\n<code>\nnumbers = [1, 2,\
    \ 3, 4, 5]\nnumbers.map { |i| i.to_s }.join(\",\")\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\nUsing inject:\n<code>\nnumbers.inject([]) { |r, (i, n)| r.concat(n.to_s).join(',\
    \ ') }\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis would not produce the same\
    \ output as the question, where each element is separated by a comma.\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>\nnumbers.map { |n| n.to_s }.join(\",\")\n</code>\n<|/\
    \ a tags=ruby |>\n<| a dscore=0 |>\nYou can try something like this:\n<code>\n\
    numbers = [1, 2, 3, 4, 5]\nnumbers.each{|num| puts num + ',' } #=> 1,2,", "  numbers[0..-2].unshift(delimeter)\n\
    \  numbers.compact!\nend", "  numbers = numbers.dup\n  numbers[0, 2] = numbers[0,\
    \ 2].first\n  numbers.map {|n| n[0, delimeter]; n[delimeter, -1]}\nend", "  numbers.inject([])\
    \ do |result, number|\n    result << number if result.size == 0 || delimeter ==\
    \ result[-1]\n    result << number if delimeter != number\n    result\n  end\n\
    end\n</pre>", "  numbers.each_cons(2) do |chunk|\n    chunk << delimeter\n  end\n\
    end\n</code>\n<|/ a tags=ruby,arrays,recursion dscore=0 |>\n<| a dscore=0 |>\n\
    The other answers work great, but they require an additional loop to iterate through\
    \ the array, which is less performant. Here is an alternate implementation that\
    \ does the same thing without looping over the array twice. \n<code>", "    numbers.each_with_index\
    \ { |num, i| numbers[i + 1] = num + delimeter if numbers.size + 1 <= i }\n   \
    \ numbers\nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\nYou can create a wrapper\
    \ class with a method defined as below. \n<code>", "    numbers.each_cons(2).map(&:join)\
    \ + [delimeter]\nend\n</cell>\n<code language=julia-0.6>", "  interspersed_string\
    \ = \"\"\n  numbers.reverse!\n  numbers = numbers.map { |number| intersperse(delimeter)\
    \ + number }\n  numbers[0] + numbers[numbers.size - 1]\nend", "  numbers[0..-2].join(delimeter)\
    \ + numbers[-1..-1].join(delimeter) + numbers[0..-2].join(delimeter)\nend", " \
    \ return numbers.each_cons(2) do |numbers|\n    numbers.unshift(delimeter).join(\"\
    \")\n  end\nend", "    # Your code here\n    # To check if the input is empty\
    \ \n    # numbers.length == 0\n    # To check if the input is of size 1\n    #\
    \ numbers.length == 1", "  return [] if numbers.empty? or numbers.size == 1\n\
    \  return numbers[0...numbers.size / 2] << delimeter << numbers[numbers.size /\
    \ 2..-1]\nend", "  numbers.map!{ |i| delimeter + i }\n  numbers\nend\n</code>\n\
    The benefit of this intersperse method, rather than using the Ruby built-in Array#join,\
    \ is that the delimeter is decoupled from the separator character. For example,\
    \ the separator character could be ',' and the delimiter could be '-'; it would\
    \ be easy to change the separator to whatever you want in the first argument without\
    \ having to change the delimiter in the second.\n<|/ a tags=arrays,ruby |>\n<|\
    \ c |>\nRuby 1.9.3 introduced Enumerable#chunk. `numbers.chunk {|n| n }.map {\
    \ |a,b| a << delimeter + b }.reduce(:+)`\n<|/ c |>\n<| c |>\nThank you very much\
    \ to both of you for the solutions! I ended up implementing `intersperse` with\
    \ a method as suggested by Jonathan and Dave Newton, since my code will ultimately\
    \ need to run on 1.8, and in 1.9 the method seems very clean. I also like the\
    \ fact that it's decoupled from the delimiter. Thanks again!\n<|/ c |>\n<| a tags=arrays,ruby\
    \ |>\nI like the answer provided by jm666 but thought I'd add my own variation.\n\
    <code>", "  if numbers.empty?\n    numbers = []\n  else\n    numbers = numbers[0..-2]\
    \ + [numbers[-1]] + numbers[-2..-1]\n  end\n  numbers[0, 2] = numbers[1, 0]\n\
    \  numbers.compact!\n  numbers[1, 0] = delimeter\n  numbers\nend", "    numbers\
    \ = numbers.map { |x| x == delimeter ? nil : x }\n    result = numbers.dup.concat(numbers[1..-1]).map{\
    \ |x| x == delimeter ? nil : x }.flatten\n    \n    if numbers.empty?\n      \
    \  result\n    else\n        intersperse(numbers.drop(1), delimeter) + [result]\n\
    \    end\nend\n</code>\nThis implementation is O(n) so I don't think it is any\
    \ more efficient than the others.\n<|/ a tags=ruby |>\n<| c |>\nThis works in\
    \ Ruby 2.1.5 and probably earlier.\n<|/ c |>\n<| c |>\nIt was indeed introduced\
    \ since 2.1.5 I believe\n<|/ c |>\n<| c |>\nYes. It is introduced in 2.1.5. It's\
    \ `intersperse`.\n<|/ c |>\n<| a |>\n<code>", "  numbers.inject do |output, number|\n\
    \    output + [number] + delimeter.join unless output.empty? || number != delimeter[-1]\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,arrays dscore=3 |>\n<| a dscore=3 |>\nI\
    \ wanted to make a generic function that would produce a number that would be\
    \ unique in any given array, regardless of order, so I wrote this monkey patch\
    \ to Fixnum:\n<code>", "  # Convert numbers to an array if it's not already\n\
    \  if numbers == []\n    numbers = [numbers]\n  end", "  # initialize result to\
    \ empty string\n  result = ''", "  if numbers.length > 1\n    intersperse(numbers[0..numbers.length-2],\
    \ delimeter) + delimeter + intersperse(numbers[numbers.length..-1], delimeter)\n\
    \  else\n    numbers\n  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\nThis is\
    \ what I did to accomplish this:\n<code>", "  numbers = [numbers] if numbers.kind_of?\
    \ Array\n  numbers.each_index {|i| numbers[i + 1] = numbers[i] + delimeter}\n\
    \  return numbers\nend\n</code>\n<|/ a |>\n<| c |>\nThis is very useful. It can\
    \ be used with numbers too. `intersperse([1,2], [3,4])` gives `[1,3,4]`\n<|/ c\
    \ |>\n<| a tags=ruby,string dscore=4 |>\n<code>", "  numbers.each do |number|\n\
    \    numbers.delete(number)\n    numbers.insert(number.length, delimeter)\n  end\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nOk, thanks, but I am looking for solutions\
    \ without using a gem.\n<|/ c |>\n<| c |>\nThat is what I wrote as part of the\
    \ answer :) Although it is not that different from Gem solution, it is an alternative.\n\
    <|/ c |>\n<| a dscore=2 |>\nJust to show how this problem can be solved in O(n):\n\
    <code>", "  numbers = [numbers]\n  delimeter = delimeter\n  numbers[0..-2].zip(numbers[-1..-1]).each\
    \ do |number, next|\n    numbers.push(next)\n  end\n  numbers[0..-2].zip(numbers[-1..-1]).map\
    \ do |number, next|\n    next if number.nil?\n    next if number == delimeter\n\
    \    next unless next.nil?\n    number.to_s + delimeter + next.to_s\n  end\nend\n\
    </pre>\n</div>", "  result = []\n  numbers.each_with_index do |element, index|\n\
    \    if index == 0\n      result << element\n    else\n      result << delimeter\
    \ << element\n    end\n  end\n  result\nend", "  if numbers.empty?\n    numbers\n\
    \  else\n    intersperse(numbers[1..-1], delimeter) + numbers[0, 1] + numbers[2..-1]\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks, that's really helpful.\
    \ I'm a Ruby beginner, so I appreciate your help. Also, thanks for the code example.\
    \ I don't know Ruby, and I'm just trying to learn on my own.\n<|/ c |>\n<| c |>\n\
    Thanks, I updated my answer to include a code example of how you can do it.\n\
    <|/ c |>\n<| c |>\nThanks again. Your code was very helpful.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nAnother option, that doesn't mutate numbers:\n<code>", "  numbers[0, delimeter.to_i]\
    \ = [delimeter]\n  numbers.map { |i| i[0, delimeter.to_i].join(\"\") + i[delimeter.to_i,\
    \ i.size] }\nend", "  numbers.each_with_index.map { |number, index| index % 2\
    \ == 0 ? [number, delimeter, number] : [number, number] }\nend", "  return numbers.inject([])\
    \ { |res, x|\n    res << x unless res.empty? || res.last == x\n    res << delimeter\
    \ unless res.empty? || res.last != delimeter\n    res\n  }\nend\n</code>\n<|/\
    \ a tags=ruby,arrays |>\n<| a dscore=2 |>\nJust for fun, here's a way using a\
    \ simple inject:\n<code>\n[1,2,3].inject([]) do |a, x|\n  (a + [x]).last == x\
    \ ? a : [a].concat [x,x]\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a |>\nHere\
    \ is yet another approach:\n<code>", "  # Write your code here\n  numbers = numbers.map\
    \ {|x| x.to_s}\n  numbers.zip(numbers.drop(1).zip(delimeter)).flatten\nend", " \
    \   numbers.map { |number| number.to_s + delimeter + number.to_s }\nend", "  if\
    \ numbers.nil? || delimeter.nil? || numbers.empty? || delimeter.empty?\n    numbers\n\
    \  else\n    numbers[0...numbers.size - 1] + delimeter + numbers[numbers.size\
    \ - 1..-1]\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nYou would not use that to\
    \ insert anything in a list. You would use it to build a list. You would use it\
    \ to build an array which you could append to or replace its contents. In Ruby\
    \ you can insert into a list much more easily than you can into an array (and\
    \ vice versa).\n<|/ c |>\n<| c |>\nThat's not what he asked. He asked for a way\
    \ to insert an element in between any two elements of a list, not just insert\
    \ an element at the end of a list which is why i wrote that method.\n<|/ c |>\n\
    <| c |>\nYes that's the question I asked but this answer doesnt actually do that.\
    \ It adds the delimeter to the end of the array which is not what was asked\n\
    <|/ c |>\n<| c |>\nThis doesn't even work on an empty array\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\nTo insert an element between two elements in a list, say :\n<code>\nlist\
    \ = [1, 2, 3, 4]\n</code>\nYou can do :\n<code>\nlist.insert(2, :a)\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nI suggest `list.insert(2, :a)`, because the second\
    \ argument is an `:index` which can have two values `:first` and `:last`.\n<|/\
    \ c |>\n<| c |>\nOr simply `list.insert(1, :a)`. Or `list.insert(2, :a)`.\n<|/\
    \ c |>\n<| a |>\nIf you want to insert an element at a specific index, you need\
    \ to get the sub-list and then insert the new element at the specified index.\
    \ For example:\n<code>\na = [1, 2, 3, 4]\na.insert(1, 10)\n=> [1, 10, 2, 3, 4]\n\
    </code>\nIf you want to insert an element in a random location, you need to get\
    \ a sub-list. For example:\n<code>\na = [1, 2, 3, 4]\na[2..-1] = [10, 20]\n=>\
    \ [1, 10, 2, 20, 3, 4]\n</code>\n<|/ a tags=ruby,arrays dscore=5 |>\n<| a tags=ruby,arrays\
    \ |>\nYou can use the built-in insert to insert an element at a specific position\
    \ or at an arbitrary position. For example:\n<code>\narray = [1, 2, 3]\narray.insert(2,\
    \ 10) # [1, 2, 3, 10]\narray.insert(-1, 20) # [1, 2, 10, 3]\n</code>\n<|/ a dscore=5\
    \ |>\n<| a tags=ruby,arrays dscore=5 |>\nTo ", "    return numbers[0..-2] + [delimeter]\
    \ + numbers[-2..-1]\nend", "  numbers = numbers.dup\n  numbers.size.times do |i|\n\
    \    if i % 2 != 0\n      numbers[0, i + 1] = delimeter\n    end\n  end\n  numbers\n\
    end", "  numbers[0...-1].zip(numbers[1...-1]).map {|a,b| a + delimeter + b}\n\
    end", "  numbers = numbers.dup\n  result = []\n  numbers.each_index do |i|\n \
    \   result.unshift numbers[i]\n    if i < numbers.size - 1\n      result.push\
    \ delimeter\n    end\n  end\n  result\nend", "  numbers.each_cons(2) do |start,\
    \ stop|\n    yield start, delimeter\n    yield stop, delimeter\n  end\nend", " \
    \ numbers.inject([], :<<)\nend", "  return [numbers[0]] + (numbers.map {|x| delimeter\
    \ + x} + numbers[1..-1]).flatten\nend", "  return [delimeter * i + n for i, n\
    \ in enumerate(numbers)]\nend\n</code>\n<code>", "  numbers.size.times do |i|\n\
    \    numbers[i] << delimeter\n  end\n  numbers\nend\n</code>\nNow, we can use\
    \ this to split a list into a list of lists:\n<code>\nnumbers = [1, 4, 2, 3, 5,\
    \ 6, 7, 8, 9]\nnumbers.partition { |x| x.odd? }.map(&:to_a)", "  result = []\n\
    \  numbers.each_with_index { |number,index| result << number if index % delimeter\
    \ == 0}\n  result\nend\n</pre>\n<p>As you can see, it works well for lists, though\
    \ it won't work for strings (which is why we use <tt>inject</tt>).  It also assumes\
    \ the list is already sorted.</p>\n<p>We can make this work for any kind of object\
    \ by defining <tt>number</tt> to be <tt>object.to_s</tt>.  <tt>number</tt> could\
    \ be any kind of object, even a string.  And this example can be extended to handle\
    \ nested lists etc. as well.</p>\n<p>Finally, note that <tt>each_with_index</tt>\
    \ will give the index of the element in the array.  But since we're inserting\
    \ at the beginning of the array, we can just omit <tt>each_with_index</tt>.  <tt>inject</tt>\
    \ will insert it at the correct spot.  We could also use <tt>delete_at</tt> to\
    \ remove the element at the current index and then insert it at the correct spot.</p>\n\
    <h2 id=\"destructive-operations-in-place\">Destructive operations in place</h2>\n\
    <p>In many cases, we wish to insert or delete an element from a list.  These operations\
    \ will modify the list.  Here are some examples:</p>\n<pre class=\"code\">", " \
    \ numbers.each_with_index do |number, index|\n    numbers[index] == delimeter\
    \ and return [number]\n    numbers[index] == number and numbers[index + 1] ==\
    \ delimeter and return numbers + [number]\n  end\nend", "    numbers.inject {\
    \ |res, el| res + [el] + delimeter }[0..-2].join\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThank you, I edited my answer. I will remove my previous comment\
    \ too.\n<|/ c |>\n<| a |>\nNot exactly sure what you're asking but from reading\
    \ your other question, I think you want a Ruby function that converts an array\
    \ to an string where each element in the array is separated by a comma and an\
    \ ampersand. Something like this would work:\n<code>", "  numbers.inject([], :+)\
    \ do |acc, number|\n    acc << number if acc.last.nil? || number == delimeter\n\
    \    acc << number\n    acc\n  end\nend", "  return [numbers[0]] + numbers.zip(numbers.drop(1)).map\
    \ {|x, y| x + delimeter + y} + [numbers[-1]]\nend\n</code>\n<|/ a dscore=3 |>\n\
    <| a tags=ruby,arrays,ruby-on-rails |>\nUsing Enumerable#each_slice you can split\
    \ an array into chunks of n elements.\n<code>\nnumbers = [1,2,3,4,5,6,7,8,9]\n\
    chunks = numbers.each_slice(3)\nchunks.map(&:join) # => [\"123\", \"456\", \"\
    789\"]\n</code>\neach_slice uses Array#[] to retrieve the elements and add them\
    \ to a new array, so you cannot use it to add delimiters between. However you\
    \ can write your own method. For example\n<code>", "\tresult = []", "  return\
    \ numbers[0...-1] + delimeter.times.map{|i| numbers[i]}\nend", "  numbers[0, 0]\
    \ = delimeter\n  numbers << numbers[0, 1].dup\n  numbers\nend", "  return numbers[0..-2].inject([])\
    \ { |s,x| s << delimeter + x; s << x } + numbers[-2..-1]\nend\n</code>\n<|/ a\
    \ |>\n<| a dscore=2 tags=ruby |>\nTry to use join with a range, like so:\n<code>\n\
    array = [1,2,3,4,5]\narray.join('-')\n=> \"1-2-3-4-5\"\n</code>\nor in your case:\n\
    <code>\narray.join('-')\n</code>\n<|/ a |>\n<| c |>\nThis isn't what the OP wants.\
    \ The OP wants `\"1-2-3-4-5\"` as a string.\n<|/ c |>\n<| c |>\nThanks, I updated\
    \ my answer. Also, for those who wants a string in return\n<|/ c |>\n<| a |>\n\
    <code>", "  numbers = numbers.dup\n  numbers.each do |number|\n    return numbers\
    \ unless number == delimeter\n    numbers.shift while numbers.first == number\n\
    \    numbers << number\n  end\n  return numbers\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks, I implemented a slightly different version for Ruby 2.3\
    \ and added comments. I also added a test case and added a new version that uses\
    \ `slice` to remove the last element from input. Now the code even works for `intersperse([1,\
    \ 5, 2, 6], 2)`.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  result = []\n  numbers.each_with_index\
    \ do |number, index|\n    result << number\n    if index != numbers.size - 1\n\
    \      result << delimeter\n    end\n  end\n  result\nend\n</code>\n<|/ a |>\n\
    <| c |>\nVery compact and elegant, but I believe this answer may be misleading\
    \ for beginners who are expecting the result to be `[1, 2, 3, 4]`.\n<|/ c |>\n\
    <| c |>\nYes, the OP asked for the result to be `[1, 2, 3, 4]`, but I also think\
    \ that the answer may confuse beginners who are expecting a different result.\
    \ That's why I added the comments in the code above.\n<|/ c |>\n<| a |>\nA simple\
    \ one liner that might help you out if you prefer something simple\n<code>\n numbers\
    \ = numbers[0..-2] + numbers[-1..-1]\n</code>\n<|/ a dscore=5 tags=ruby,arrays\
    \ |>\n<| c |>\nThis does not work if the last number is not an integer.\n<|/ c\
    \ |>\n<| c |>\nWhat if `numbers = numbers[0..-2] + numbers[-1..-1]` gives `[1,\
    \ 2, 3, 4]`, then `numbers` becomes `[1, 2, 3, 4]`, then `numbers = numbers[0..-2]\
    \ + numbers[-1..-1]` gives `[1, 2, 3, 1, 2, 3, 4]`, then `numbers` becomes `[1,\
    \ 2, 3, 1, 2, 3, 4]`.\n<|/ c |>\n<| c |>\nThis only works if the last number is\
    \ always going to be an integer.\n<|/ c |>\n<| c |>\nIf you're going to use negative\
    \ indices, you can also use negative indices.\n<|/ c |>\n<| c |>\n`numbers[0..-2]\
    \ + [numbers[numbers.size-1]]` would also work.\n<|/ c |>\n<| a dscore=5 |>\n\
    A simple and effective one-liner:\n<code>\na = numbers.map { |n| n.to_s.to_i }\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis is really neat! I love it! I\
    \ prefer this because it's more readable than the other solutions posted here.\n\
    <|/ c |>\n<| c |>\nI would use `to_s` because `\"123\".to_i` will get you 123,\
    \ and `\"123\".to_s` will get you `'123'`. But this is really neat!\n<|/ c |>\n\
    <| c |>\nIt also works for decimals. `a = [1.2, \"3\"].map { |n| n.to_s.to_",
  "  # TODO: Write code here\nend\n</cell>\n<text>\nExcercise 2.\nGiven a string input\
    \ representing a sentence, return a list of every possible palindrome made from\
    \ it. In other words, \"racecar\" yields \"racecarr\", \"caarace\" yields \"caaracer\"\
    , etc. Remember to handle capitalization correctly!", "  numbers.each_cons(2)\
    \ do |left, right|\n    left.unshift(delimeter) if left.empty?\n    right.unshift(delimeter)\
    \ if right.empty?\n    left << delimeter\n    right << delimeter\n  end\nend",
  "  numbers.each_cons(2).map {|x| x.join(delimeter)}.flatten\nend", "  ret = []\n\
    \  for i in 0...(numbers.length - 1)\n    ret.push numbers[i..i + 1].join(delimeter)\n\
    \  end\n  ret\nend\n</cell>\n<code language=julia-0.5>", "    intermediate = \"\
    \"\n    i = 0\n    while i < numbers.length\n        intermediate = intermediate.concat(numbers[i])\n\
    \        if i < numbers.length-1\n            intermediate = intermediate.concat(delimeter)\n\
    \        i += 1\n    end\n    return intermediate\nend", "  i = 1\n  while i <\
    \ numbers.size do\n    numbers.insert(i, delimeter)\n    i += 1\n  end", "   \
    \ # Your code goes here\n    if numbers.length <= 0\n        return numbers\n\
    \    if numbers.length == 1\n        return [numbers[0]]\n    \n    \n    left_over\
    \ = numbers.length - 1\n    i = 0\n    result = []\n    while i < left_over:\n\
    \        result.push(numbers[i])\n        result.push(delimeter)\n        i +=\
    \ 1\n        left_over -= 1\n    result.push(numbers[left_over])\n    \n    return\
    \ result", "  numbers[0...-1].zip(numbers[1...-1]).inject([]) do |output, |\n\
    \    output << yield(numbers.pop, numbers.pop)\n    output << delimeter\n  end\n\
    end", "  numbers.map do |number|\n    interspersed_string += number + delimeter\n\
    \  end\nend", "  return numbers.map {|x| [x, delimeter * x].join('')} * delimeter\n\
    end", "  numbers.each_with_index do |n, i| \n    numbers[i] = (delimeter || '\
    \ ').to_s + n.to_s \n  end\n  numbers\nend", "  # TODO: raise exception\nend",
  "  numbers.each_with_index.map {|num, i| i ? num + delimeter : num}.compact\nend\n\
    </code></pre>\n<h5 id=\"function-intersperse-parameters\">Parameters</h5>\n<ul>\n\
    <li>numbers - a list</li>\n<li>delimeter - string</li>\n</ul>\n<h5 id=\"function-intersperse-returns\"\
    >Returns</h5>\n<p>a list</p>\n<h5 id=\"function-intersperse-examples\">Examples</h5>\n\
    <p>Basic usage of the function:</p>\n<pre><code class=\"lang-ruby\"><span class=\"\
    hljs-keyword\">def</span> <span class=\"hljs-function\"><span class=\"hljs-title\"\
    >intersperse</span>(<span class=\"hljs-params\">numbers, delimeter</span>)</span>\n\
    \  numbers.each_with_index.map {|num, i| i ? num + delimeter : num}.compact\n\
    end\n</code></pre>\n<h4 id=\"function-intersperse-string-parameters-string-delimeter\"\
    >intersperse(string, &quot;delimeter&quot;)</h4>\n<p>Returns a string with <code>delimeter</code>\
    \ inserted between every two consecutive elements of <code>string</code>.</p>\n\
    <h5 id=\"function-intersperse-string-parameters-string-delimeter-returns\">Returns</h5>\n\
    <p>string</p>\n<h5 id=\"function-intersperse-string-parameters-string-delimeter-examples\"\
    >Examples</h5>\n<p>Basic usage of the function:</p>\n<pre><code class=\"lang-ruby\"\
    ><span class=\"hljs-keyword\">def</span> <span class=\"hljs-function\"><span class=\"\
    hljs-title\">intersperse</span>(<span class=\"hljs-params\">string, &quot;delimeter&quot;</span>)</span>\n\
    \  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">unless</span>\
    \ <span class=\"hljs-keyword\">typeof</span> string == <span class=\"hljs-string\"\
    >&quot;string&quot;</span>\n  <span class=\"hljs-keyword\">return</span> <span\
    \ class=\"hljs-keyword\">unless</span> <span class=\"hljs-keyword\">typeof</span>\
    \ delimeter == <span class=\"hljs-string\">&quot;string&quot;</span>", "  return\
    \ [] if numbers.empty? || numbers.first == 0\n  result = [numbers.first]\n  numbers\
    \ << numbers.delete_prefix(1)\n  numbers.each do |number|\n    result << number\n\
    \    result << delimeter\n  end\n  result\nend", "    numbers.each_index do |i|\n\
    \        numbers[i].insert(i, delimeter)\n    end\n    numbers\nend\n</code>\n\
    <|/ a |>\n<| c |>\n+1 for being correct and providing examples. But I decided\
    \ to write up my own, because it was a fun problem, and I wanted to learn something\
    \ new.\n<|/ c |>\n<| a |>\n<code>\na = [1,2,3]\na.each_cons(2) do |x,y|\n   puts\
    \ \"#{x} #{y}\"\nend", "  if numbers.empty?\n    numbers\n  else\n    [numbers.first]\
    \ + numbers.drop(1).each_cons(2).map(&:join) + [numbers.last]\n  end\nend\n</code>\n\
    The most difficult part of this method is mapping the method each_cons to each\
    \ consecutive two elements of the list. And it turns out that this could be done\
    \ much easier, thanks to J\xF6rg W Mittag's answer:\n<code>", "  numbers.each_with_index.with_index\
    \ do |n, i|\n    if i == 0\n      n\n    else\n      n.insert(1, delimeter)\n\
    \    end\n  end\nend\n</code>\nUsing a regex with gsub to replace each number\
    \ with a regex captured number and a separator, i.e. \"#{@separator}#{i}\"\n<code>",
  "  return [delimeter if i == 0 else numbers[i] for i in range(1 + 2 * numbers.length)]\
    \ + numbers\nend", "  return numbers[0...-1] + delimeter + numbers[-1...-1] if\
    \ numbers.size > 0 \n  else \"\"\nend", "  interspersed_numbers = []\n  i = 0\n\
    \  while i < numbers.length\n    interspersed_numbers << numbers[i]\n    i +=\
    \ 1\n    interspersed_numbers << delimeter\n  end\n  return interspersed_numbers\n\
    end", "  # TODO: implement a better recursive solution\n  if numbers.nil?\n  \
    \  numbers\n  elsif numbers.empty?\n    []\n  else\n    numbers.first.nil? ? [numbers.first]\
    \ : numbers[0...-1] + [delimeter] + numbers[1...-1]\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,python,arrays |>\n<| c |>\nThat is awesome and solves my problem!\
    \ But now my next question is how do i get a list of all the numbers in the array,\
    \ instead of just returning [1,2,3] which only returns the first three.\n<|/ c\
    \ |>\n<| c |>\n: I added a method to intersperse all elements of a list into a\
    \ single element list. I also changed the function name to `intersperse_list`.\
    \ As you can see, I did not change any code, just added a new method and a new\
    \ method call. The name `intersperse` does not give away any information about\
    \ what is happening. `intersperse` is only a verbatim translation of your function's\
    \ name to the English word \"intersperse.\" It is not an instruction or a command.\
    \ `intersperse_list` gives a more useful description of the operation.\n<|/ c\
    \ |>\n<| a tags=ruby,python,arrays |>\nA more idiomatic version of Andy's answer:\n\
    <code>", "  numbers.inject do |number, next|\n    number + delimeter + next\n\
    \  end\nend", "  # Return the input list concatenated with the interspersed elements\
    \ of input list `delimeter' between every two consecutive elements of input list\
    \ `numbers'\n  # >>> intersperse([1, 2, 3, 4, 5], [4, 5, 6, 7, 8])\n  # [4, 5,\
    \ 6, 7, 8, 1, 2, 3, 4, 5]\n  return numbers +\n    (delimeter + numbers[1..-1]).join(numbers[1..-1])\n\
    end", "  numbers.inject([]){|result, number| result << number << delimeter; result}\n\
    end", "  numbers.each_cons(2) do |interspersed_number, number|\n    interspersed_number\
    \ << number\n  end\nend\n</code>\n<|/ a |>\n<| c |>\n`intersperse([1, 2, 3], 4)`\
    \ returns `[1, 4, 2, 4, 3]` but should return `[1, 4, 2, 3, 4, 1]`\n<|/ c |>\n\
    <| c |>\nYeah, I thought he was referring to the `intersperse` function, not the\
    \ `intersperse` method in the `Fixnum` class. I guess the correct answer is \"\
    the Ruby way\" :)\n<|/ c |>\n<| a |>\nRuby 1.9 has method each_cons which accepts\
    \ arguments for length and step.\n<code>", "  return [] if numbers.empty? || delimeter.zero?\n\
    \  numbers = (numbers << {:n | n != 0} + delimeter).to_a\n  result = numbers.take_while\
    \ {|n| n < 0} + numbers.take_until {|n| n >= 0}\n  result.join\nend", "  numbers\
    \ = [numbers] + numbers.map { |number| [number] }\n  numbers.flatten.map do |number|\n\
    \    break if number != delimeter\n    number\n  end.first(numbers.size).map do\
    \ |number|\n    number.intern << delimeter\n  end\nend", "  return numbers[0..-2].each_cons(2).inject(:+)\
    \ + [numbers[-2]] + numbers[0..-2].reverse.each_cons(2).inject(:+) + [delimeter]\
    \ + numbers[-2..-1]\nend", "  if numbers.nil? || delimeter.nil?\n    numbers\n\
    \  else\n    numbers.map {|n| [n, delimeter, n]}.flatten(1)\n  end\nend", "  \
    \  numbers.map!(&:to_i)\n    return numbers.map { |n| n.to_s + delimeter.to_s\
    \ * (numbers.size - n.to_i).abs }\nend\n</code>\n<|/ a |>\n<| c |>\nthis doesn't\
    \ work if `numbers` includes any element that isn't a string. for example, if\
    \ `numbers = [1, \"a\", 3]`, then `intersperse([1, 2], \"-\")` returns `\"-1--2\"\
    ` rather than `\"-1--2\"`\n<|/ c |>\n<| c |>\nthat's exactly what this does. From\
    \ the docs:", "  if numbers.empty?\n    []\n  else\n    numbers.first.zero? ?\
    \ numbers.first : numbers.first.to_s + delimeter + intersperse(numbers.drop(1),\
    \ delimeter)\n  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays,string |>\n\
    For those who are looking for an alternative for ruby's Array include?\n<code>",
  "  return numbers.first + [delimeter] + numbers.drop(1)\nend\n</cell>\n<text>\n\
    The intersperse function takes two parameters, numbers and delimeter, and returns\
    \ a new list that interleaves the elements of numbers with the first elements\
    \ of numbers.drop(1).", "  # Write your code here.\n  result = numbers.dup\n \
    \ result.insert(result.length, delimeter)\n  result\nend", "  numbers.map { |x|\
    \ [x].concat(delimeter.nil? ? [] : [delimeter, x, y]) }.\n    join\nend", "  \
    \  return numbers[0..-2].each_cons(2).map(&:join) + [delimeter + numbers[-2..-1]]\n\
    end", "  return [delimeter + number + delimeter for number in numbers]\nend\n\
    </cell>\n<code language=julia-1.5>\nintersperse([1,2,3], 2)\n</cell>\n<code language=julia-1.5>\n\
    intersperse([1,2,3], 4)\n</cell>\n<code language=julia-1.5>\nintersperse([1, 2,\
    \ 3], 4)\n</cell>\n<text>\nThe map() function\nThe map() function, like reduce()\
    \ + foldl(), applies a function to all elements of a collection and returns a\
    \ collection of the same length. It takes a collection as its first argument and\
    \ a function to apply to each element of the collection as its second argument.\
    \ The function must return a collection of the same length.", "  numbers, delimeter\
    \ = numbers, delimeter\n  return [numbers[0...-1], delimeter, numbers[-1]]\nend",
  "    return numbers[1...-1].inject(delimeter, :<<)\nend", "  numbers = [numbers]\
    \ if numbers.is_a? Integer\n  return numbers.inject([]) do |interspersed_numbers,\
    \ number|\n    interspersed_numbers + [number] + numbers[1..-1]\n  end\nend",
  "  if numbers == []\n    numbers\n  else\n    intersperse(numbers[0..-1], delimeter)\
    \ + [numbers[-1]]\nend\n</pre>", "    numbers.inject do |memo, number|\n     \
    \   if number == delimeter\n            memo << \"\"\n        else\n         \
    \   memo << number\n        end\n        memo\n    end\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 tags=ruby,arrays |>\nJust to give another alternative:\n<code>\n\
    array = [1, 2, 3]\narray.each_with_index.reject {|x,i| i / 2 != i / 2 }.uniq.map\
    \ {|x| x * 2 }", "  return [numbers].flatten.compact.inject(delimeter) { |string,\
    \ number| string + number.to_s }\nend\n</pre>\n        </div>", "  return numbers.inject([],\
    \ :+) + numbers.each_cons(2).map { |x, y| x + delimeter + y }\nend", "  return\
    \ numbers.inject([], :<<){ |interspersed_array, number|\n    interspersed_array.last.nil?\
    \ ? [number] : [number, interspersed_array.last].join(delimeter)\n  }\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work. Try intersperse([1], \"-\") with your code\
    \ and you'll see that it returns [\"1-1\"]. Instead of returning an array like\
    \ [\"1-1\"] it returns [\"1\"]. Also, your code doesn't handle negative numbers\
    \ correctly. You should use `.inject(0, :<<)` instead of `.inject([], :<<)`.\n\
    <|/ c |>\n<| c |>\nOops, I used `inject` instead of `inject!` and totally forgot\
    \ to update the answer :) Thanks for pointing out my mistake.\n<|/ c |>\n<| c\
    \ |>\nYes I missed that part, just fixed it right away.\n<|/ c |>\n<| c |>\nI\
    \ added a solution with the `inject` method that doesn't use `inject!`. Let me\
    \ know if you have any questions.\n<|/ c |>\n<| c |>\nNice! I like your last solution,\
    \ using slice, especially when there's no better way! The only downside is that\
    \ it doesn't work for negatives and zero values, but that is a minor issue in\
    \ my case.\n<|/ c |>\n<| a |>\nI would go with the map approach for efficiency,\
    \ but I would prefer a helper function like the following to make this more readable:\n\
    <code>", "  numbers  = numbers[0..-2]\n  return numbers.product(delimeter).flatten(1)\n\
    end", "  numbers\n    .each_cons(2)\n    .map(&:first)\n    .to_a + delimeter\
    \ + numbers.last.to_a\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ add an extra `delimeter` to the end of the list\n<|/ c |>\n<| c |>\nIt adds\
    \ a delimiter after the last element. Try it with `intersperse([1, 2, 3], \" \"\
    )`\n<|/ c |>\n<| c |>\nNo, you're misreading it.  It adds an additional delimiter\
    \ after the last element of the list. Try it with `intersperse([1, 2, 3], \" \"\
    )`\n<|/ c |>\n<| c |>\nYep, you're right. I'll edit the post and add a note about\
    \ it - thanks for the note!\n<|/ c |>\n<| a |>\nI came up with this code which\
    \ seems to be pretty efficient at what it does:\n<code>", "  result = []\n  numbers.each_with_index\
    \ do |element, i|\n    result << element\n    result << delimeter if i < numbers.length\
    \ - 2\n  end\n  result\nend", "  result = numbers.dup\n  numbers.reverse.each_with_index\
    \ {|n,i| result[i+1] = delimeter + n }\n  result\nend", "  # Write your code here\n\
    \  return numbers[0...-1] + numbers[1...-1] + delimeter + numbers[2...]\nend\n\
    </cell>\n<text>\nThe second method intersperse can be found in the ruby standard\
    \ library. There are many other ways of achieving the same thing.", "  numbers\n\
    \    .each_with_index\n    .map { |n, i| i == 0 ? n : delimeter + n }\n    .compact\n\
    \    .join\nend", "  # Split input list `numbers' on every occurrence of delimeter\
    \ `delimeter'\n  numbers.split(delimeter).inject([], :+)\nend", "  numbers = numbers.dup\
    \ if numbers.frozen? # avoid mutating caller's list\n  delimeter = delimeter.to_s\
    \ if delimeter.kind_of?(Numeric)\n  return numbers.map { |number| number.to_s\
    \ }.insert(0, delimeter).flatten\nend", "  numbers.inject([]) do |output, number|\n\
    \    output << number\n    output << delimeter\n    output << number\n  end\n\
    end\n</code></pre>\n        </section>", "  if numbers.empty?\n    numbers\n \
    \ else\n    (numbers.first + delimeter + numbers.last).step(1, :).to_a\n  end\n\
    end\n</code>\nNow the method intersperse can be used as follows:\n<code>", " \
    \ return numbers.inject do |result, element|\n    result + [element] + numbers[0..(numbers.size\
    \ - 2)].to_a + [delimeter + element] + numbers[(numbers.size - 1)..-1].to_a\n\
    \  end\nend", "    numbers.insert(0, delimeter)\n    return numbers\nend", " \
    \ return numbers.zip(numbers[1..-1]).inject(delimeter) {|s, (n, v)| s + n.to_s\
    \ + v.to_s}\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nI did this as an exercise\
    \ in learning Ruby, so I decided to have a crack at solving it using recursion.\
    \  It uses recursion to print the numbers one by one and uses recursion to print\
    \ the numbers in pairs.  I used the 'return' keyword to do this, but you can also\
    \ use the 'yield' keyword instead if you prefer.\n<code>", "  numbers.each_cons(2).map(&:first).join(delimeter)\n\
    end", "  return numbers.reduce(:<<, delimeter).zip(numbers).reduce(:+)\nend",
  "  return numbers.inject([]) do |output, value|\n    output << value\n    (output\
    \ << delimeter).join[value]\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=2\
    \ |>\nYou could use inject:\n<code>\n(1..5).inject([]){|arr,i| arr << i; arr <<\
    \ i; arr}\n=> [1, 4, 2, 4, 3, 5]\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYour example\
    \ does not make sense. `inject` returns the accumulated value so if you change\
    \ `arr << i` to `arr << i*2` it would return `[1, 4, 2, 8, 4, 3, 10]`. So the\
    \ array would be `[1, 4, 2, 8, 4, 3, 10, 5, 2, 6, 4, 8]`.\n<|/ c |>\n<| a dscore=2\
    \ |>\nI find it hard to believe that there are no other answers so here goes anyway.\n\
    I would do this using each_with_index which keeps track of the current index while\
    \ you iterate over it like so:\n<code>\na = [1,2,3,4]\na.each_with_index { |x,\
    \ i| a[i] = a[i].next }\n</code>\nOr, if you prefer:\n<code>\na.each_with_index\
    \ { |x, i| a[i] = a[i].next } # => [2, 3, 4, 3]\n</code>\n<|/ a tags=ruby |>\n\
    <| a dscore=1 |>\n<code>", "  result = []\n  numbers.each_with_index do |number,\
    \ index|\n    result << number\n    if index < numbers.size - 1\n      result\
    \ << delimeter\n    end\n  end\n  result\nend", "    numbers.each do |number|\n\
    \        yield(number) if yield(number)\n        yield(delimeter) if yield delimeter\n\
    \    end\nend", "  numbers = numbers.map {|n| n + delimeter} if numbers.is_a?(Array)\n\
    \  numbers.map {|n| n % delimeter}\nend", "  numbers.each_with_index do |number,\
    \ index|\n    if index == 0\n      delimited_number = number\n    else\n     \
    \ delimited_number = delimeter + number\n    end\n    yield(delimited_number)\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThe `if index == 0` part is\
    \ unnecessary since the last element will already have the delimiter added.\n\
    <|/ c |>\n<| a |>\nA more straightforward implementation is to use Array#join:\n\
    <code>\nnumbers = [1, 2, 3]\nnumbers = numbers.join(', ') # => \"1, 2, 3\"\n</code>\n\
    To ensure the delimiter appears at the end, you can reverse the array and join\
    \ it:\n<code>\nnumbers = [1, 2, 3]\nnumbers = numbers.reverse.join(',')", "  \n\
    \  return numbers.each_with_index.reduce(delimeter.to_s) {|acc, num, i| acc +\
    \ num * i} + numbers[1..-1]\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n\
    An old question, but it deserves an answer. I think this can be done much more\
    \ simply.\n<code>", "  numbers.length >= 1\n  output = []\n  numbers.each_with_index\
    \ do |element, index|\n    if index == 0\n      output << element\n    elsif index\
    \ > 0\n      output << delimeter << element\n    end\n  end\n  output\nend", " \
    \ if numbers.empty?\n    []\n  else\n    numbers.inject([], :<<)\n    numbers[0,\
    \ delimeter]\n    numbers.drop(1)\n  end\nend", '  return [num for elem in numbers
    for num in (elem or [])] + [ delimeter ]', "  return numbers[0..-2] + delimeter\
    \ + numbers[-1..-1] if numbers.size == 1 else\n    intersperse(numbers[0..-2]\
    \ + [numbers[-1..-1]], delimeter)", "  numbers[0,0] = delimeter\n  numbers = numbers.flatten(1)\n\
    \  numbers[0,0] = nil\n  numbers = numbers.map do |i|\n    i = i.to_s.to_i\n \
    \   i = i > 0 ? i : nil\n    i\n  end\n  numbers\nend", "  numbers.each_cons(2).with_index\
    \ do |numbers, index|\n    yield(numbers, delimeter * index)\n  end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nIn ruby 1.8.7 and above, you have Array#cycle:\n<code>\n\
    >> [1,2,3].cycle.to_a\n=> [[1, 2], [3], [1, 2], [3]]\n</code>\n<|/ a tags=arrays,ruby\
    \ dscore=1 |>\n<| c |>\nIn Ruby 1.9.2, cycle does not work like that, it returns\
    \ an array of arrays, not a permutation of all the elements in the original array.\n\
    <|/ c |>\n<| c |>\n: That's not true. It will give you an array that loops back\
    \ and forth between its starting values. Try it in irb.\n<|/ c |>\n<| c |>\n:\
    \ I see what you mean, it does appear to go back to its starting values in Ruby\
    \ 1.9.2. But if you want a permutation of all the elements, you can do `Array#permutation`,\
    \ which is exactly what cycle does. Check it out.\n<|/ c |>\n<| c |>\n: I've added\
    \ a note about that to my answer.\n<|/ c |>\n<| a tags=arrays,ruby |>\nHere's\
    \ a recursive solution that doesn't use an explicit loop construct.\n<code>",
  "  numbers[0..-2].concat(numbers[1..-1], numbers[2..-1])\nend", "  # Initialize\
    \ a variable named 'result' to an empty list\n  result = \"\"\n  # Iterate through\
    \ each element of list `numbers'\n  # Convert each element into a string using\
    \ `to_s' method\n  # append the string representation of current element to the\
    \ list `result'\n  numbers.each do |num|\n    result += num.to_s\n  end\n  # Insert\
    \ `delimeter' between consecutive elements of `result'\n  result.split(delimeter).map!\
    \ {|x| x.to_i }\n  result\nend", "  result = []\n  numbers.length.times do |i|\n\
    \    result << numbers[i]\n    result << delimeter\n  end\n  result\nend\n</code>\n\
    The most common use case is passing in a single number (e.g. 1) as the delimeter\
    \ parameter.\n<|/ a dscore=3 tags=ruby |>\n<| a dscore=3 |>\nJust for fun, here's\
    \ another approach:\n<code>\n(0..100).map { |n| n * 10 }.reduce(:+)\n</code>\n\
    <|/ a tags=ruby |>\n<| a dscore=2 |>\n<code>\n[1,2,3,4,5,6,7,8,9,10].inject(0)\
    \ { |sum, n| sum + n*10 }\n</code>\n<|/ a tags=ruby |>\n<| c |>\nUsing `inject`\
    \ like this is overkill, as it only does it once per iteration. Stick to the more\
    \ readable `map`.\n<|/ c |>\n<| a tags=ruby |>\nYou can do:\n<code>\n[1,2,3,4,5,6,7,8,9,10].inject(0)\
    \ { |sum, n| sum + n*10 }\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby |>\n<code>\n\
    10.times.inject(0) do |sum, num|\n    sum += num * 10\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\n<code>", "  numbers.inject([], :<<)\nend", "  numbers[0..-1].zip(numbers[1..-1]).flatten.compact.reverse.join.split(delimeter)\n\
    end", "    numbers.each do |number|\n        numbers.shift\n        numbers.unshift(number)\n\
    \    end\n    return numbers\nend\n</code>\n<|/ a tags=ruby dscore=3 |>\n<| c\
    \ |>\nIt's worth noting that this technique is similar to [the method described\
    \ in Ruby's Array#to_s documentation](http://ruby-doc.org/core-2.2.0/Array.html#method-i-to_s)\
    \ \u2014 you can override that method and insert a delimiter between every element,\
    \ but it's simpler to just write a method and call it directly.\n<|/ c |>\n<|\
    \ c |>\nThis doesn't actually insert a delimiter between every element in the\
    \ list, but only between elements that come after the first one. It will also\
    \ insert a delimiter at the end of the list if the list has one element: `intersperse([1,2,3],\
    \ 'x')`.\n<|/ c |>\n<| a dscore=3 |>\n<code>", "  numbers.inject([]) do |output,\
    \ number|\n    output << number unless output.last == delimeter\n    output <<\
    \ delimeter\n    output\n  end\nend", "  numbers.reduce(::delimeter)\nend", " \
    \ return nil if numbers.length <= 1\n  number = numbers[0]\n  numbers = numbers[1..-1]\n\
    \  number.split(delimeter).each do |n|\n    numbers << n\n  end\n  numbers\nend",
  "  numbers.inject([], :concat).each_slice(2) do |a, i, a| a[i..-1].insert(0, a[i])\n\
    end\n</code></pre>\n</td>\n</tr>\n<tr class=\"odd\">\n<td class=\"attributes\"\
    >\nStatic\n</td>\n<td class=\"name\">\n<code>intersperse</code>\n</td>\n<td class=\"\
    code\">\n<pre class=\"static-highlight language-js\"><code class=\"language-js\"\
    ># 'numbers' is required", "  result = []\n  numbers.each do |number|\n    result\
    \ << (number if result.empty?)\n    result << delimeter\n  end\n  result\nend",
  "  return numbers.reduce([]) { |inters, el| inters << el << (inters.empty? ? delimeter\
    \ : '') }\nend", "\tnumbers = numbers.to_a\n\tnumbers.length.times do |i|\n\t\t\
    numbers.insert(i, delimeter)\n\tend\n\tnumbers\nend", "  if numbers.empty?\n \
    \   numbers\n  else\n    delimeter + numbers.map { |n| n + delimeter}.drop(1).join\n\
    \  end\nend\n</code></pre>\n</div>", "  return numbers.map { |n| n.to_s + delimeter.to_s\
    \ }[0...numbers.size - 1]\nend", "  if numbers.empty?\n    []\n  else\n    intersperse(numbers[1..-1],\
    \ delimeter) + [numbers.pop]\n  end\nend", "  numbers = [numbers]\n  delimeter\
    \ = [delimeter]\n  return numbers.map { |a| a.join(delimeter) }\nend", "  return\
    \ [numbers[0]].concat numbers.drop(1).map {|n| delimeter.nil? ? n : delimeter\
    \ + n}\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThe solution for `[\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\"]` would be: `[\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\"].reverse.map { |s| s.size % 2 == 1 ? s + s.to_s.reverse : s }.compact.reverse`\n\
    <|/ c |>\n<| c |>\nThis solution is very close to mine, but I'd use `intersperse([1,\
    \ 2, 3], \" \")` instead of `intersperse([1, 2, 3], \"\")`, which I think should\
    \ be the correct one. `intersperse([1, 2, 3], \"\")` would result `[1, '1', 2,\
    \ '2', 3, '3']`, while `intersperse([1, 2, 3], \" \")` would result `[1 , \" \"\
    , 2 , \" \", 3 , \" \"]`, as required.\n<|/ c |>\n<| c |>\n, thanks for pointing\
    \ out. As far as I can tell, the order is the same as in the OP.\n<|/ c |>\n<|\
    \ c |>\n, yes, it is. Thanks for pointing out. I had no idea `intersperse` would\
    \ modify objects in place.\n<|/ c |>\n<| c |>\nI think a couple parens around\
    \ the assignment is cleaner though: ```([numbers[0]].concat numbers).drop(1).map\
    \ {|n| delimeter.nil? ? n : delimeter + n}```\n<|/ c |>\n<| a dscore=4 |>\n<code>\n\
    a = \"1234567890\"\n</code>\nIf you want to insert a character every even position\
    \ (index 0, 2, 4, 6, ...):\n<code>\n(a[0..1] + a[1..2] + a[2..3] + a[3..4] + a[4..5]\
    \ + a[5..6] + a[6..7] + a[7..8] + a[8..9] + a[9..10]).gsub(/^((.)\\2*)/, '\\1')\n\
    => \"123451234\"\n</code>\nIf you want to insert a character every odd position\
    \ (index 1, 3, 5, ...):\n<code>\n(a[0..1] + a[1..2] + a[2..3] + a[3..4] + a[4..5]\
    \ + a[5..6] + a[6..7] + a[7..8] + a[8..9] + a[9..10]).gsub(/^((.)\\2*)/, '\\1').reverse\n\
    => \"1234567889\"\n</code>\n<|/ a tags=", "  return numbers << [0] if numbers.size\
    \ == 1 || (numbers.size == 2 && (numbers[1] == 0)) \n    numbers.size % 2 == 1\
    \ ? numbers.dup : (delimeter << [0]).dup << numbers.each.with_index(1).map { |number,\
    \ index| number + delimeter + numbers[index.succ].to_s }\nend\n</code>\n<|/ a\
    \ dscore=4 tags=ruby |>\n<| a tags=ruby |>\nThe answer given by jvnill's answer\
    \ worked for me until I noticed it failed when there was more than one consecutive\
    \ delimeter. So, I modified his answer a little bit:\n<code>", "  return numbers[0..-2]\
    \ + delimeter + numbers[-1..-1]\nend", "  numbers[0..-1].insert(1, delimeter)\
    \ + numbers[1..-1]\n  numbers\nend\n</cell>\n<cell>", "  return numbers.reduce(::[].concat,\
    \ delimeter).reduce(:::<<)\nend", "  numbers, delimeter = numbers, [delimeter]\
    \ * numbers.size\n  numbers.each_with_index do |n,i|\n    numbers[i] += delimeter\n\
    \    numbers[i+1] +=\n      (n.is_a?(Array) ? intersperse(n,delimeter) : n)\n\
    \  end\n  numbers\nend", "    # Create a copy of input list\n    numbers = numbers.dup",
  "  if numbers.empty?\n    []\n  else\n    [ numbers.first.to_s + delimeter + numbers.last\
    \ ] +\n    intersperse(numbers.drop(1), delimeter)\nend", "  return numbers.each_cons(2).map\
    \ { |x, y| x.dup << delimeter << y }.reduce(:<<)\nend", "    first = true\n  \
    \  result = \"\"\n    numbers.each do |n|\n        if first\n            result\
    \ << n\n            first = false\n        else\n            result << delimeter\n\
    \            result << n\n        end\n    end\n    result\nend", "  (0...numbers.length).step(2)\
    \ { |i| numbers.insert(i+1, delimeter) }\n  numbers\nend", "  return [] unless\
    \ numbers && numbers.any?\n  numbers.reduce([]) { |result,num| result << num;\
    \ [delimeter] + result }\nend", "  numbers.reduce([]) { |a, e| a.unshift(delimeter.join(e));\
    \ a }\nend\n</code>\n<|/ a |>\n<| c |>\nThe [Ruby documentation](http://ruby-doc.org/core-2.2.2/Array.html#method-i-reduce)\
    \ also has an example of the use of `reduce` for array processing, and it also\
    \ shows the usage of `map` vs. `reduce` for collections processing\n<|/ c |>\n\
    <| a dscore=3 |>\nHere's another take on this. This version uses only one reduce:\n\
    <code>", "  if numbers.empty?\n    numbers\n  else\n    numbers[0, numbers.size...-1].zip(numbers[1..-1]).inject([])\
    \ do |result, pair|\n      result << pair\n      result << delimeter\n      result\n\
    \    end\n  end\nend", "  # Write your code here.\nend", "  numbers = numbers.map\
    \ {|n| n.to_s }\n  numbers.each_cons(2).map do |first_two|\n    first_two.inject(delimeter)\
    \ { |delim, next_number|\n      delim + next_number.to_s\n    }\n  end\nend\n\
    </code>\n<|/ a tags=ruby,string,arrays,split dscore=5 |>\n<| c |>\nThis should\
    \ be the accepted answer - it is more idiomatic Ruby code, and works on an arbitrary\
    \ number without extra overhead like `inject`\n<|/ c |>\n<| c |>\nThis is better\
    \ than the accepted answer.  It also explains why `inject` is good.\n<|/ c |>\n\
    <| a dscore=5 |>\n<code>", "  numbers[0,1] = delimeter if numbers[0] && numbers[0]\
    \ == delimeter else numbers[0]\n  numbers[1, numbers.length] = delimeter if numbers[numbers.length]\
    \ && numbers[numbers.length] == delimeter else numbers[numbers.length]\n  numbers\n\
    end", "\t\n\tnew_numbers = numbers.clone\n\tnew_numbers[0..numbers.size - 1] =\
    \ numbers[0..numbers.size - 1].collect(&:+).each_slice(2).to_a", "  numbers.inject([])\
    \ do |output, value|\n    if output.length == 0\n      output << value\n    elsif\
    \ output.length == 1\n      output << value\n      output << delimeter\n    else\n\
    \      output << delimeter\n      output << value\n    end\n    output\n  end\n\
    end", "  numbers.each_cons(2).map { |a, b| a + delimeter + b }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
