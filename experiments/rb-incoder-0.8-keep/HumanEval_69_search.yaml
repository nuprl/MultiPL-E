name: HumanEval_69_search
language: rb
prompt: "# You are given a non-empty list of positive integers. Return the greatest\
  \ integer that is greater than \n# zero, and has a frequency greater than or equal\
  \ to the value of the integer itself. \n# The frequency of an integer is the number\
  \ of times it appears in the list.\n# If no such a value exist, return -1.\n# Examples:\n\
  # search([4, 1, 2, 2, 3, 1]) == 2\n# search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n\
  # search([5, 5, 4, 4, 4]) == -1\ndef search(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_search\n\
  \    candidate = method(:search)\n    assert_equal(1, candidate.call([5, 5, 5, 5,\
  \ 1]))\n    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))\n    assert_equal(-1,\
  \ candidate.call([3, 3]))\n    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8,\
  \ 8, 8]))\n    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))\n    assert_equal(1,\
  \ candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10,\
  \ 8, 1]))\n    assert_equal(2, candidate.call([3, 2, 8, 2]))\n    assert_equal(1,\
  \ candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))\n    assert_equal(-1, candidate.call([8,\
  \ 8, 3, 6, 5, 6, 4]))\n    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7,\
  \ 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))\n    assert_equal(1,\
  \ candidate.call([1, 9, 10, 1, 3]))\n    assert_equal(5, candidate.call([6, 9, 7,\
  \ 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))\n    assert_equal(1,\
  \ candidate.call([1]))\n    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5,\
  \ 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))\n    assert_equal(2, candidate.call([2,\
  \ 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))\n    assert_equal(1, candidate.call([1,\
  \ 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))\n    assert_equal(4, candidate.call([9, 2,\
  \ 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8,\
  \ 10, 9, 4]))\n    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10,\
  \ 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))\n    assert_equal(2, candidate.call([9,\
  \ 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))\n    assert_equal(-1,\
  \ candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10,\
  \ 8]))\n    assert_equal(-1, candidate.call([10]))\n    assert_equal(2, candidate.call([9,\
  \ 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))\n    assert_equal(1, candidate.call([5,\
  \ 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))\n    assert_equal(1, candidate.call([7, 9, 9,\
  \ 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))\n    assert_equal(-1,\
  \ candidate.call([3, 10, 10, 9, 2]))\n  end\nend\n"
completions: ["  # first case\n  return 0 if(lst.empty?) -1\n  # second case\n  return\
    \ 0 if(lst.include?(lst.min) || lst.include?(lst.max.next)) -1\n  # third case\n\
    \  freq = freq(lst.count)\n  freq.each{|x| return 0 if(x > lst.max) -1}\n  freq\n\
    end", "  lst.each_with_index do |x, i|\n    if x >= 0\n      break\n    end\n\
    \    if lst.count(x) >= i \n      return x\n    end\n  end\n  -1\nend", "  \n\
    \  # Use a hash to count frequencies \n  freqs = Hash.new(-1)", "  i = lst.index(lst.max)\
    \ # finds the index of the max\n  freq = lst[i] # finds the frequency of max in\
    \ list\n  if freq >= lst.size # checks if frequency is greater than or equal to\
    \ the size of the list\n    return -1\n  else # frequency is not greater than\
    \ or equal to the size of the list\n    return freq\nend", "  lst.each_with_index\
    \ do |val,index|\n    return index if val <= 0 || val == frequency(lst, index)\
    \ ? val : -1\n  end\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| a tags=arrays,ruby\
    \ |>\nIf you're looking for the simplest method, use Enumerable#max, it returns\
    \ the first item that passes the test and stops iterating after that:\n<code>",
  "  lst.uniq.sort_by { |i| -i }.find {|i| i > 0 && lst.count(i) >= i }\nend", " \
    \ lst.sort\n  \n  lst.each {|x| return x if x >= 0}\n  return -1\nend", "  n =\
    \ lst.length\n  max = lst[0]\n  for i in 0...n\n    next if lst[i].zero?\n   \
    \ if lst[i] > max\n      max = lst[i]\n    end\n  end\n  return max\nend", " \
    \   arr.each do |x|\n        if x > 0 and arr.count > x\n            return x\n\
    \        end\n    end\n    return -1\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    That's not the right way to iterate through an array in Ruby. Please, consult\
    \ the official docs on [`each`](http://www.ruby-doc.org/core-2.1.5/Enumerable.html#method-i-each)\
    \ and [`count`](http://www.ruby-doc.org/core-2.1.5/Enumerable.html#method-i-count).\n\
    <|/ c |>\n<| c |>\nWhat do you mean by that? I see no problem with `each` here,\
    \ just that I'm not too familiar with the Ruby array enumerators.\n<|/ c |>\n\
    <| a dscore=1 tags=ruby |>\nYou can try this one:\n<code>", "  lst.each do |i|\
    \ \n    if (l.count(i) > i)\n      return i \n    end\n  end\n  return -1\nend",
  "  lst.sort!\n  freq = lst.group_by{|x| x}\n  if freq.empty?\n    return -1\n  end\n\
    \  return freq.max_by{|k,v| v}.last.last\nend\n</code>\n<|/ a |>\n<| c |>\nThat\
    \ is a beautiful implementation, and I learned a lot from it. I'm going to be\
    \ studying your solutions more carefully this week to understand them better,\
    \ thanks!\n<|/ c |>\n<| a tags=algorithm,ruby,sorting |>\nThis can be done with\
    \ a single line of code using Enumerable#each_with_object:\n<code>", "  lst.sort.reverse_order.each_with_index\
    \ do |e,i|\n    if e == 0\n      break\n    elsif e == lst.sort[i]\n      lst.delete_at(i)\n\
    \    end\n  end\n  lst.empty? ? -1 : lst.sort[0]\nend\n</code>\n<|/ a |>\n<| a\
    \ tags=ruby |>\nHere's a fairly compact solution for you:\n<code>", "  i = 0\n\
    \  n = lst.count\n  \n  if n == 0\n    return -1\n  \n  while i < n do\n    if\
    \ lst[i] < 0\n      i += 1\n      break\n    \n    if lst[i] >= n\n      break\n\
    \    \n    if lst[i] != lst[i - 1]\n      return i - 1\n    \n    i += 1\n  end\n\
    \  \n  return -1\nend", "  return nil if lst.empty?\n  freq = lst.uniq.count\n\
    \  return lst.find_index { |x| x > 0 && freq[x] >= freq[x].to_i } if freq[lst.first]\
    \ >= freq[lst.first].to_i\n  return -1\nend\n</cell>\n<cell>", "  lst.each do\
    \ |num|\n    freq = lst.count(num) - num\n    return freq if freq >= 0\n  end\n\
    \  -1\nend", "  lst.sort.each do |x|\n    if x[-1] < 0\n      return -1\n    elsif\
    \ x == 0\n      return 0\n    elsif lst[x] == x[-1] + 1\n      return x\n    end\n\
    \  end\n  -1\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis solution won't work\
    \ if the array is sorted from bigger to smaller. For example, `search([3,2,1])`\
    \ returns `nil` instead of `3`.\n<|/ c |>\n<| c |>\nIt does work as I proposed:\
    \ first it sorts the list from largest to smallest and than returns the index\
    \ of the value being searched for.\n<|/ c |>\n<| c |>\nSorry, I misread that part.\
    \ Your answer works. I was confused because of the comment in the code \"# You\
    \ are given a non-empty list of positive integers.\". :)\n<|/ c |>\n<| a tags=search,algorithm,ruby,sorting,arrays\
    \ |>\n<code>", "  lst.each_with_index { |e, i| return i if i > 0 }\n  -1\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  freq = Hash.new(0)\n\
    \  lst.each { |x| freq[x] += 1 }\n  freq.keys.each { |x| freq[x] <= 0 ? return\
    \ -1 : freq[x] }\n  lst.sort.last\nend\n</cell>\n<cell>", "    arr.inject(0) {\
    \ |m, n| m.tap { m += n if n > 0} }.max_by(&:last).last\nend\n</code>\n<|/ a dscore=3\
    \ tags=ruby,arrays |>\n<| c |>\nI came up with a very similar solution, but was\
    \ wondering if there is a more efficient one. Would love to see your version.\n\
    <|/ c |>\n<| a dscore=3 |>\nThis is not the answer to your question but might\
    \ help.\nI did this problem recently to solve a very similar problem.\n<code>",
  "  lst.sort.reverse!\n  result = -1\n  freq = Hash.new(0)\n  lst.each do |x| \n\
    \    if freq[x] > 0\n      result = x\n      break\n    elsif freq[x] == 0\n \
    \     freq[x] = 1\n    else\n      freq[x] += 1\n    end\n  end\n  result\nend",
  "\tlst.sort.reverse\n\tlst.each do |val|\n\t\tif val.zero?\n\t\t\treturn -1\n\t\t\
    elsif lst.count(val) <= val\n\t\t\treturn val\n\t\tend\n\tend\n\treturn -1\nend",
  "  lst.sort!\n  freq = 1\n  for i in 0...lst.size\n    if lst[i] < freq\n      freq\
    \ = lst[i]\n    end\n  end\n  return freq if freq > 0\n  return -1\nend", "  lst\
    \ = lst.sort\n  lst.each_with_index do |e, i|\n    return i if e > 0 && lst[i-1]\
    \ == e\n  end\n  return -1\nend", "  lst.sort.select { |x| x > 0 }.max { |a, b|\
    \ (lst.count(b) - lst.count(a)) }\nend", "  lst.uniq.select { |v| v > 0 }.max_by\
    \ { |v| lst.count(v) }\nend", "  if lst.empty?\n    return -1\n  max_val, max_count,\
    \ min_val = 0, nil, 0\n  lst.each do |x|\n    if x == max_val\n      max_count\
    \ += 1\n    else\n      if max_count >= max_val\n        max_val, max_count =\
    \ x, 1\n      elsif max_count < max_val\n        max_count, min_val = max_count,\
    \ x\n      end\n    end\n  end\n  return -1 if max_count == 0\n  return min_val\n\
    end", "  lst.each do |num|\n    if num > 0\n      f = 0\n      lst.each do |num2|\n\
    \        if num2 >= num\n          f += 1\n        end\n      end\n      return\
    \ num if f >= num\n    end\n  end\n  return -1\nend", "  max_num = lst[0]\n  freq\
    \ = 1\n  i = 0\n  while i < lst.count{|i| i > max_num}\n    if lst[i] == max_num\n\
    \      freq += 1\n    else\n      max_num = lst[i]\n      freq = 1\n    end\n\
    \    i += 1\n  end\n  if freq > lst.length\n    return -1\n  else\n    return\
    \ max_num\n  end\nend", "  i = 1\n  while i <= lst.count\n    return lst.find\
    \ { |x| x > i }\n    i += 1\n  end\n  return -1\nend\n</code>\n<|/ a tags=ruby,algorithm\
    \ |>\n<| c |>\nYour solution is O(n^2). Your code (I think) takes O(n^2) steps.\
    \ The following is the correct solution: \n`def search(lst)\n  i = 0\n  while\
    \ i < lst.count\n    j = i + lst.count\n    break if j >= lst.count\n    return\
    \ lst[i] if lst[i] > j && lst[i] >= i\n    i += 1\n  end\n  return -1\nend`\n\
    <|/ c |>\n<| c |>\nAhh good catch, you are right the O(n^2) time complexity is\
    \ due to the `count` method. I missed that detail. Thank you!\n<|/ c |>\n<| c\
    \ |>\nThe second one actually works, but it has the worst case O(n^2) since you\
    \ loop through the list twice. The first one only loops through the list once,\
    \ so it has an O(n) solution (where n = lst.count).\n<|/ c |>\n<| a tags=ruby,algorithm\
    \ |>\nHere is a solution in Ruby (not very elegant by any means) that is linear\
    \ time and O(n).\nIt does not use sort since it is not O(nlogn) and you cannot\
    \ get O(n) out of it without looping through the whole thing.\n<code>", "    maximum\
    \ = 0\n    maximum2 = 1\n    maximum3 = 1\n    for i in lst\n        if maximum\
    \ < 0 and i > maximum and i > maximum2 and i > maximum3\n            maximum =\
    \ i\n        else if i > maximum and i > maximum2 and i > maximum3\n         \
    \   maximum2 = i\n        else if i > maximum2 and i > maximum3\n            maximum3\
    \ = i\n    return maximum\nend", "  l = lst.sort\n  l.each_with_index do |e, i|\n\
    \    return e if i == l.find_index { |e| e < i }\n  end\n  -1\nend", "  lst.each_with_index\
    \ do |e, i|\n    if e <= 0 then\n      return -1\n    elsif lst[i] == e then \n\
    \      return e\n    elsif e < lst[i] then \n      return -1\n    end\n  end\n\
    end", "  sorted = lst.sort { |a, b| b - a}\n  if sorted.length < 1\n    return\
    \ -1\n  end\n  sorted.each_with_index { |i, index| return i if i > 0 }\n  sorted.first\n\
    end", "  # write your code here\n  return -1\nend\n</cell>\n<code language=julia-1.3>",
  "  freq = Hash.new(0)\n  lst.each{ |item| freq[item] += 1}\n  freq.each{ |item,\
    \ count| return item if count >= freq[item] }\n  -1\nend", "  if lst.size < 2\n\
    \    return -1\n  end\n  lst.sort\n  lst.each_with_index do |item, index|\n  \
    \  if index > 0 && lst[index-1] > item\n      return index\n    elsif index ==\
    \ lst.size - 1\n      if item > lst[index]\n        return index\n      else\n\
    \        return -1\n      end\n    end\n  end\nend", "  lst.each do |num|\n  \
    \  number = num\n    number = number.to_i\n  \n    if number > -1\n      if num[number-1]\
    \ != -1\n        if num[number-1] > num\n          num = num[number-1]\n     \
    \   end\n      else\n        num = -1\n      end\n    else\n      num = -1\n \
    \   end\n  end\n  \n  num\nend", "  lst.each do |x|\n    if x > 0 && freq > x\n\
    \      return x\n    end\n  end\n  return -1\nend\n</code>\nHope this helps! Good\
    \ luck.\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nYou could use a hash with default\
    \ value to -1. In the loop you check if the current value is not -1 (falsey),\
    \ if so you know that the current value is present and you get the frequency of\
    \ it. Otherwise you get frequency of default value (-1).\n<code>", "  l = lst.sort.reverse\n\
    \  l.each_with_index do |v,i|\n    return i if v >= 0\n  end\n  -1\nend\n</cell>\n\
    <code language=conda-root-py>", "    index = nil\n    max = nil\n    i = 0\n \
    \   while(i < lst.size)\n        if(lst[i] == 0)\n            return i\n     \
    \   elsif(lst[i] > max)\n            max = lst[i]\n            index = i\n   \
    \     elsif(lst[i] > 0 && lst[i] <= max)\n            i += 1\n        end\n  \
    \  end\n    return -1\nend", "  result = -1\n  for i in lst\n    freq = arr.assoc(i)\n\
    \    if freq \n      result = i\n    else \n      return -1\n  return result\n\
    end", "  lst.sort!\n  for i in 0..lst.size-1\n    if lst[i] >= lst[i+1]\n    \
    \  lst[i], lst[i+1] = lst[i+1], lst[i]\n    end\n  end\n  lst.find{ |x| x > 0\
    \ }.nil? ? -1 : lst.find{ |x| x > 0 }\nend", "    arr.each_with_index {|num, i|\
    \ return num if num > 0}\n    -1\nend\n</code>\n<|/ a dscore=0 tags=ruby,arrays\
    \ |>\n<| a |>\nI wanted to see if the above solution worked for you. I wrote this\
    \ program in python to find if a number is present in a list. Hope this helps.\
    \ \n<code>\nnum = int(input(\"Enter a number: \"))\narray = [1,2,3,4,5,6,7,8,9,0]\n\
    for num in array:\n    if num == num:\n        print(\"The number \" + str(num)\
    \ + \" is present in the list.\")\n        break\n    else:\n        print(\"\
    The number \" + str(num) + \" is not present in the list.\")\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>", "\ti = 0\n\twhile i < lst.count\n\t\t\
    i = i + 1\n\t\tif lst[i] >= 0\n\t\t\tbreak\n\t\tend\n\tend\n\treturn i\nend",
  "  return lst.max_by { |x| x.to_i } if lst.any?\n  -1\nend", "  freq = lst.group_by{|x|\
    \ x}\n  i = 1\n  freq.keys.inject(-1) do |max, element|\n    max = freq[element].size\
    \ > i ? freq[element][i] : max\n    i += 1\n    max\n  end\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| c |>\nI did notice that `search` returns nil when the given\
    \ list is empty - is this an issue for you?\n<|/ c |>\n<| c |>\nYes, empty list\
    \ is also a valid input\n<|/ c |>\n<| a dscore=0 |>\nHere is an answer with recursion\
    \ and a Hash lookup:\n<code>", "  lst.each do |i|\n    return i if lst.count(i)\
    \ >= i.count\n  end\n  -1\nend\n</code>\n<|/ a |>\n<| c |>\nIt's O(n), not O(n^2).\n\
    <|/ c |>\n<| c |>\nO(n^2) means every element of the array is checked for its\
    \ presence. Since it would be O(n), you have a looping over every element of the\
    \ array. Therefore, it's O(n^2).\n<|/ c |>\n<| c |>\nYeah, this algorithm is bad.\n\
    <|/ c |>\n<| c |>\nThe \"if i is present more than once\" case is O(n), not O(n^2)\n\
    <|/ c |>\n<| c |>\nThis is O(n) but the complexity is not very good because you\
    \ still do a linear number of searches (O(n)), you should avoid this when you\
    \ can as it will reduce performance.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ |>\nThe question was asking for the largest value greater than zero (no negative\
    \ values) in a list of positive integers.  It was asked that the result be the\
    \ value itself or -1 if no value was greater than zero.  \nI started with the\
    \ idea to sort the list and then find the first non-zero value, but I came up\
    \ with this solution which I think can be optimized.  It does not require any\
    \ searching.\n<code>", "  lst.sort.find {|x| x > 0 }\n  puts lst.sort.find {|x|\
    \ x > 0 }\n  return lst.sort.find {|x| x > 0 }\nend", "  lst.sort\n  arr.each_with_index\
    \ { |val, idx| return val if val == 0 and idx > lst.index(0) || val != lst.index(\
    \ val ) and val != 0 }\nend", "  lst.each do |x|\n    next x if x == 0 || x ==\
    \ -1\n    if lst.count(x) >= x\n      return x\n    end\n  end\n  return -1\n\
    end\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThis is my solution, it's very fast\
    \ and simple:\n<code>\nfunction search (array){\n    return array.sort().find(x=>{if\
    \ (array.indexOf(x) > -1) return x}).val;\n}\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThat is `O(n*log(n))` where `n = array.length`, since `Array#sort`\
    \ is `O(n log n)`. A `Array#find` with a `block` of `x == array.indexOf(x)` can\
    \ be done in linear time.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  lst.each\
    \ do |x|\n    puts \"#{x}, #{@hash[x]}\"\n  end", "  lst.sort.each do |i|\n  \
    \  puts i unless i.zero?\n    if lst.count(i) <= 1\n      return i\n    end\n\
    \  end\n  -1\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis fails for the list\
    \ [1, 0, 1, 1, 1, 1]. Should return 1.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ that out. I updated my solution.\n<|/ c |>\n<| a tags=ruby |>\nIf your list\
    \ is sorted and if your list has only positive numbers, then the binary search\
    \ has a complexity of O(log(n)), so for an array with n elements it would take\
    \ O(log(n)) time.\n<code>", "  return lst.max_by { |i| i.to_i }[1].to_i\nend",
  "  lst.each do |num|\n    count[num] += 1\n  end = count.max_by {|k, v| v}\n  puts\
    \ \"#{end[0]}\" if count.has_key? end[0]\n  \nend\n  ", "\tlst.each_with_index\
    \ do |x, i|\n\t\ti = i + 1\n\t\tj = i\n\t\twhile j < lst.size && lst[j] == x\n\
    \t\t\tj = j + 1\n\t\tend\n\t\tif j < lst.size\n\t\t\tif lst[j] != x || i == 1\n\
    \t\t\t\treturn -1\n\t\t\telse\n\t\t\t\treturn lst.index(lst[j]) + 1\n\t\t\tend\n\
    \t\telse\n\t\t\treturn -1\n\t\tend\n\tend\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ is O(n^2) time, though it could be optimized by starting with a list of length\
    \ one to speed up the looping.\n<|/ c |>\n<| c |>\nyes, good observation, thanks,\
    \ I've added the optimization\n<|/ c |>\n<| a tags=ruby,algorithm |>\nHere is\
    \ a way to do it in a single pass through the list using the ruby Enumerable#chunk_while\
    \ method:\n<code>", "    lst.sort.reverse\n    \n    val = lst.first\n    val\
    \ = -val if val < 0 \n    \n    pos = -1\n    val = -val if val < 0\n    \n  \
    \  while val != 0\n        pos += 1\n        val = -val if val < 0\n    end\n\
    \    \n    return pos\nend\n</cell>\n<code language=julia-1.1>\nsearch([4, 1,\
    \ 2, 2, 3, 1])\n</cell>\n<code language=julia-1.1>\nsearch([1, 2, 2, 3, 3, 3,\
    \ 4, 4, 4])\n</cell>\n<code language=julia-1.1>\nsearch([5, 5, 4, 4, 4])\n</cell>\n\
    <code language=julia-1.1>\nsearch([1, 3, 5])\n</cell>\n<code language=julia-1.1>\n\
    search([0, 2, 3, 2])\n</cell>\n<code language=julia-1.1>\nsearch([0, 2, 4, 0])\n\
    </cell>\n<code language=julia-1.1>\nsearch([1, 3, 7])\n</cell>\n<code language=julia-1.1>\n\
    search([-2, 3, 5])\n</cell>\n<code language=julia-1.1>\nsearch([-7, -9, -7, -7,\
    \ -7, -7, -9, -8, -8, -9, -8])\n</cell>\n<code language=julia-1.1>\nsearch([-7,\
    \ -8, -8, -9, -8])\n</cell>\n<code language=julia-1.1>\nsearch([-7, -8, -8, -9,\
    \ -8, -8, -9, -8])\n</cell>\n<code language=julia-1.1>\nsearch([-7, -8, -8, -9,\
    \ -8, -9, -8])\n</cell>\n<code language=julia-1.1>\nsearch([-7, -8, -8, -9, -8,\
    \ -9, -8])\n</cell>\n<code language=julia-1.1>\nsearch([-7, -8, -8, -9, -8, -9,\
    \ -8])\n</cell>\n<code language=julia-1.1>\nsearch([-7, -8, -8, -9, -8, -9, -8])\n\
    </cell>\n<code language=julia-1.1>\nsearch([-7, -8, -8, -9, -8, -9, -8])\n</cell>\n\
    <code language=julia-1.1>\nsearch([-7, -8, -8, -9, -8, -9, -8])\n</cell>\n<code\
    \ language=julia-1.1>\nsearch([-7, -8, -8, -9, -8, -9, -8])\n</cell>\n<code language=julia-1.1>\n\
    search([-7, -8, -8, -9, -8, -9, -8])\n</cell>\n<code language=julia-1.1>\nsearch([-7,\
    \ -8, -8, -9, -8, -9, -8])\n</cell>\n<code language=julia-1.", "  # code here\n\
    end", "  max_number = 0\n  max_index = 0\n  for x in lst\n    if x == 0\n    \
    \  max_number = max_number + 1\n      if max_number > x\n        max_index = max_index\n\
    \      end\n    end\n  end\n  puts \"#{ max_index }\"\nend", "  arr.each_with_index.map\
    \ { |num, idx| \n    if (num > 0)\n      arr.each_with_index { |x, i| return i\
    \ if num == x }\n    end\n  }\nend", "  arr.each {|x| return x if x > 0 }\n  return\
    \ -1\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=1 |>\nI believe this to be\
    \ the shortest solution but just for kicks, here it is in one line:\n<code>",
  "  arr = lst.sort.reverse\n  for i in arr\n    return i\n  return -1\nend", "  lst.sort.each\
    \ { |x| break x if x > 0 }\n  lst.delete_at(-1) if lst.empty? or lst.last == 0\n\
    \  return lst.last if lst.last > 0 and lst.last >= lst.last\n  return -1\nend\n\
    </cell>\n<text>\nWe can use the following test case to make sure it passes:",
  "  lst.sort.last\n  lst.each { |x| return x if x > 0 && x == lst.count }\n  -1\n\
    end", "  lst.sort!\n  frequency = Hash.new(0)\n  frequency.merge(lst, Hash.new(0))\
    \ {|count, i| count += 1 if i == lst[0]; count }\n  frequency.each {|k, v| return\
    \ k if v >= frequency.max && v != -1 }\n  return -1\nend", "  lst.sort.each {\
    \ |x| return x if (x == 0 || x >= lst.count && (lst.count > 0))}\n  return nil\
    \ if lst.count <= 0\n  lst.sort.each { |x| return x if (x == 0 || x >= lst.count\
    \ && (lst.count >= x))}\n  lst.sort.each { |x| return x if (x >= lst.count)}\n\
    \  -1\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby |>\n<code>", "  lst.each\
    \ do |number|\n    puts \"#{number} has #{frequencies?(number)} times\"\n  end",
  "  lst.each_with_index { |i, idx| return i if idx < lst.count and lst.count - idx\
    \ > 0 }\nend", "  lst.each do |el|\n    el = el.to_i\n    if el.nonzero? && el\
    \ >= 0\n      return el\n    end\n  end\n  -1\nend", "  arr = []\n  arr.push lst.count\n\
    \  arr.push arr.count", "  freq = Hash.new(-1)\n  n = 1\n  lst.each do |x|\n \
    \   freq[x] ||= n\n    n += 1\n  end\n  freq.default = -1\n  freq[lst[0]] >= freq[lst[0]]\
    \ ? lst[0] : -1\nend\n</cell>\n<cell>\nsearch(lista)\n</cell>\n<text>\n3.2 Longest\
    \ Common Prefix\nQuestion: What is the longest common prefix of two strings?",
  "  lst.sort\n  idx = lst.index(0)\n  return idx if idx >= lst.index(lst.last) -1\
    \ else -1\nend", "  lst=lst.sort\n  lst.each do |i|\n    return i if i > 0 &&\
    \ i.to_s.to_i == lst.first\n  end\n  return -1\nend\n</cell>\n<cell>", "  lst\
    \ = lst.sort.uniq.reverse\n  puts lst.inject(0){|t,i| t=i if t<=lst[i]; t}\nend",
  "  max_freq = 0\n  max_num = nil\n  lst.each do |num|\n    if freq(num) >= max_freq\n\
    \      max_freq = freq(num)\n      max_num = num\n    end\n  end\n  return max_num\n\
    end", "  freq = {}\n  max_val, max_idx = nil, nil\n  lst.each_index do |i|\n \
    \   if freq[i] && freq[i] >= lst[i]\n      max_val = freq[i]\n      max_idx =\
    \ i\n    end\n    freq[i] = freq.has_key?(i) ? freq[i] + 1 : 1\n  end\n  return\
    \ max_idx if max_val\n  return -1\nend\n</code>\n<|/ a |>\n<| c |>\nI like that\
    \ solution.\n<|/ c |>\n<| c |>\nNice!  But this solution is O(n^2). Sorting is\
    \ O(n log n), so in practice O(n + n log n). Plus it won't work for duplicates\
    \ in the list, which the OP seems to require (+1).\n<|/ c |>\n<| a |>\nHere is\
    \ another solution using Enumerable#each_cons:\n<code>", "    freq = {}\n    freq.each\
    \ do |key, val|\n      if val >= lst[0]\n        return lst[0] if freq[key] >=\
    \ lst[0]\n      end\n    end\n    return -1\nend", "  index = -1\n  arr.map {|i|\
    \ i = i; i + 1 }\n  if arr.map {|i| i = i; i + 1 }.max == arr.max\n    index =\
    \ arr.map {|i| i = i; i + 1 }.max\n  end\n  return index\nend\n</code>\n<|/ q\
    \ dscore=0 tags=ruby |>\n<| c |>\nWelcome to Stack Overflow. Your question should\
    \ contain a clear problem statement, including what you've tried so far, what\
    \ error messages you received, and any relevant input. Please read \"[ask]\" including\
    \ the link \"[mcve]\".\n<|/ c |>\n<| c |>\nWhat do you mean by \"no such value\
    \ exist\"? Are you saying that a particular element might not exist? If so, please\
    \ edit the question and clarify.\n<|/ c |>\n<| c |>\nPlease read \"[ask]\". Your\
    \ question isn't a clear, concise and valid question. In the process of making\
    \ a good question, we discover that your question is too broad. Please refactor\
    \ the question to focus on a single problem.\n<|/ c |>\n<| c |>\nAh ok, sorry\
    \ I thought the title was very clear. I just added the problem I have.\n<|/ c\
    \ |>\n<| c |>\n\"If no such value exist, return -1\" is not what your question\
    \ states. You asked the method to return -1 if there are no values in the list\
    \ that satisfy this condition. The fact that your current code returns nil when\
    \ there are no values that satisfy the condition is irrelevant. This question\
    \ is still unclear. For example, why do you think the code should return -1 if\
    \ there are no values in the list that satisfy the condition? What is the point\
    \ of returning -1 when the condition clearly states that there is no such value?\n\
    <|/ c |>\n<| a |>\nYou could use the max_by method of the Enumerable module, which\
    \ returns the value with the highest key, if exists, or nil if not. \n<code>\n\
    arr = [4, 1, 2, 2, 3, 1]\narr.max_by{ |e| e == arr.max && e }", "  lst.sort\n\
    \  lst.delete_if{|x| x < 0 }\n  lst.delete_if{|x| x < lst.first }\n  lst.delete_if{|x|\
    \ x < lst.last }\n  lst.delete_if{|x| x > lst.last }\n  lst.delete_if{|x| x >\
    \ lst.first }\n  lst.size == 0 ?  -1 : lst.first\nend\n</code>\n<|/ a tags=ruby,algorithm\
    \ dscore=3 |>\n<| c |>\nThis doesn't answer the question. The question is what\
    \ is the *largest* possible number that is greater than zero.\n<|/ c |>\n<| a\
    \ tags=ruby,algorithm |>\nI believe this should be the correct answer\n<code>",
  "    max = lst[0]\n    min = lst[0]\n    for i in lst\n        if i == max && lst[i]\
    \ > min\n            max = i\n            min = i\n        elsif i == min && lst[i]\
    \ < max\n            min = i\n        end\n    end\n    return -1 if max == min\n\
    \    return max\nend", "    max = -1\n    max_index = 0\n    i = 0\n    while\
    \ i < lst.count\n        if lst[i] > max\n            max = lst[i]\n         \
    \   max_index = i\n        end\n        i += 1\n    \n    if max_index == 0\n\
    \        return -1\n    end\n    return max_index\nend\n</cell>\n<code language=julia-0.6>",
  "  lst.sort\n  lst.each {|num| return num if num > 0 }\n  return -1\nend\n</code>\n\
    <|/ a dscore=2 tags=algorithm,ruby |>\n<| c |>\nThis algorithm will return the\
    \ largest number if there are duplicates (like [2, 2, 3]), but if there are no\
    \ duplicates it will return -1.\n<|/ c |>\n<| c |>\n`lst.sort` will take O(n log\
    \ n), and `lst.count` takes O(n) also.\n<|/ c |>\n<| c |>\nSorting can be done\
    \ in O(nlogn) if all elements are distinct\n<|/ c |>\n<| c |>\nThanks for the\
    \ clarification :)\n<|/ c |>\n<| c |>\nThis code will throw `RangeError` if `lst`\
    \ contains 0 because it returns `nil` instead of `0`. Try `search([0])` to see\
    \ the error.\n<|/ c |>\n<| a tags=algorithm,ruby dscore=1 |>\nMy take on the problem.\n\
    <code>", "  arr.each_with_index do |x,i|\n    arr.count(x)>i\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  # Your code here\n  lst.each\
    \ do |x|\n    freq.each {|y| return y if x == y}\n  end\n  -1\nend", "    lst.sort.reverse.each_with_index.select\
    \ { |item, index| item == 0 && index % 2 != 0 }.max_by{ |i| i }\nend", "  lst.sort.reverse\n\
    \  first = lst[0]\n  return first...\nend", "  lst.each do |x| \n    if x > 0\
    \ && arr[x] >= x\n      return x\n    end\n  end\n  return -1\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\n`lst.each` can be written more simply as `lst.find_all{|x|\
    \ x > 0}`, but more importantly is this answer wrong? Because it seems to me that\
    \ your solution will give the wrong answer in the case where no such value exists\
    \ (which I think your solution should not)? This question asks for the greatest\
    \ integer, not one that exists in the list.\n<|/ c |>\n<| c |>\nYes, it gives\
    \ the wrong answer if no such value exists, but that's a case where it would give\
    \ the right answer.\n<|/ c |>\n<| a tags=ruby dscore=2 |>\nHere is a solution\
    \ without using sort or each_char.\n<code>", "    res=-1\n    max=-1\n    found=false\n\
    \    \n    arr=lst.sort\n    arr.each{|x| if x>=max  && !found\n            found=true\n\
    \            max=x\n            res=x}\n    \n    unless found\n        arr.each{|x|\
    \ if x!=max  && !found\n                found=true\n                max=x\n  \
    \              res=x}\n    end\n    \n    res\nend\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\n<code>", "  arr.map { |x| arr.count(x) }\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis would work but is O(n^2) because it iterates over each element of\
    \ the list twice, once to count the number of times the element appears and once\
    \ to find the index of the max. Another way to do it would be to use Enumerable#max_by\
    \ and pass it a block that returns the frequency of the element and returns the\
    \ index.\n<|/ c |>\n<| c |>\nIt's not O(n^2). That's a constant factor of O(n).\n\
    <|/ c |>\n<| c |>\nThe second iteration runs O(n) times, it's just that the first\
    \ loop runs at O(n). That's the same as saying the first loop runs at O(n^2).\n\
    <|/ c |>\n<| c |>\nThe first loop runs O(n) times because arr.count is O(n). Nothing\
    \ about the first loop runs O(n^2) times. It's not like you iterate over each\
    \ element of the list once and call arr.count on it.\n<|/ c |>\n<| c |>\nAh, I\
    \ see. You're just saying that arr.count is O(n). So arr.count is O(n^2), but\
    \ you're saying the arr.count is O(n) because the arr.map that runs on it runs\
    \ O(n) times. That's like saying the first loop runs O(n^2) times because you\
    \ iterate over the list once to count the number of times the element appears\
    \ and then you iterate over the list once more to find the index of the max. I\
    \ don't think that's right. He could have used arr.uniq because he wants the max\
    \ to be the value that appears most number of times which is O(n) time.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nHere is an O(N) solution where I am counting the frequency\
    \ of each element, and then I am picking the element with the highest frequency.\n\
    <code>", "  lst.each_with_index.inject(0) do |max, (num, i)|\n    max <= num ?\
    \ max : i\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYou probably want\
    \ to use `each_with_index` instead of `inject` as it is more efficient for the\
    \ latter as it does not require building a list of all values.\n<|/ c |>\n<| c\
    \ |>\n, `each_with_index` doesn't return an index, it returns the current and\
    \ next index into the array.\n<|/ c |>\n<| c |>\n: no, `inject` returns the current\
    \ element and the next element in the list. `each_with_index` is what you'd use\
    \ to iterate over the array as you move through it, so it builds an index while\
    \ iterating, which isn't the case with `inject`.\n<|/ c |>\n<| c |>\n, you are\
    \ right about that, I hadn't thought of using `each_with_index`.\n<|/ c |>\n<|\
    \ c |>\n, I added an explanation of the `each_with_index` method, which I think\
    \ has some merit in understanding how `inject` is implemented. The `inject` method\
    \ will iterate over the array without having to build an index. In contrast, `each_with_index`\
    \ will need to build an index by comparing each item against the previous one,\
    \ which may be more expensive than `inject`.\n<|/ c |>\n<| a |>\n<code>", "  freq\
    \ = {}\n  for i in lst \n    if freq.has_key?(i)\n      freq[i] += 1\n    else\n\
    \      freq[i] = 1\n  end\n  max_freq = freq.max_by{|k,v| v}[1]\n  if freq.has_key?(max_freq)\n\
    \    max_freq\n  else\n    -1\n  end\nend", "  lst.each_with_index { |n, i| return\
    \ i if n > 0 } \n  return -1\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\n<code>",
  "  lst.sort!\n  index = 0\n  max_val = 0\n  freq = 0\n  while index < lst.size\n\
    \    freq += 1\n    val = lst[index]\n    while index != lst.size - 1 && val >\
    \ lst[index + 1]\n      index += 1\n    freq -= 1\n    if freq > max_val\n   \
    \   max_val = freq\n    end\n    index += 1\n  end\n  if max_val == 0 && index\
    \ >= lst.size\n    return -1\n  end\n  max_val\nend", "  return -1\nend", '  lst.sort!
    # Sort the array in ascending order.', "    i = 0\n    frequency = 0", "  return\
    \ lst.max_by { |n| n > 0 ? n.to_i : n }.to_i\nend\n</code>\n<|/ a dscore=1 tags=ruby\
    \ |>\n<| c |>\nWow! This is impressive.\n<|/ c |>\n<| c |>\n: Thank you. Ruby\
    \ is a great language, and this problem is just so much fun.\n<|/ c |>\n<| c |>\n\
    Why does `[5, 5, 4, 4, 4].max_by { |n| n > 0 ? n.to_i : n }.to_i` return `5` instead\
    \ of `4`?\n<|/ c |>\n<| c |>\n: Because \"the greatest integer that is greater\
    \ than zero\" means that the greatest non-negative integer that is greater than\
    \ zero. Ruby doesn't know that integers cannot have negative numbers, so it just\
    \ returns the first non-negative number. It looks like my code is intended to\
    \ return `nil` if all integers in the array are negative, which is actually a\
    \ better solution for that problem.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\nI would\
    \ use each_cons to find the indices of the array that are greater than zero, then\
    \ find the greatest index using max_by:\n<code>", "  lst = lst.sort\n  i = 0\n\
    \  \n  while i < lst.count and lst[i] >= 0\n    i += 1\n  end\n  \n  if i < lst.count\n\
    \    return lst[i]\n  else\n    return -1\n  end\nend", "  lst.each_with_index\
    \ do |val, index|\n    break if val == -1\n    freq = arr.count(val)\n    puts\
    \ \"#{val} has #{freq} times\"\n  end\nend\n</cell>\n<text>\n\U0001F4A1 Next,\
    \ write a solution for counting consecutive duplicates in a list.\nWrite a function\
    \ that takes in a list of integers and returns the number of consecutive duplicates.\
    \ \nThe consecutive duplicates occur whenever the difference between the current\
    \ index and the previous index is 1 or more. \nYou are not allowed to import any\
    \ extra modules for this exercise.", "  return nil if lst.nil?\n  freq = Hash.new(0)\n\
    \  lst.each do |i|\n    freq[i] += 1\n  end\n  freq.values.max {|a, b| a == b\
    \ ? a : -1}\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=algorithm,ruby\
    \ |>\n<code>", "  lst.sort\n  lst.shift\n  lst.min\nend", "  sorted = lst.sort\n\
    \  i = sorted.pop\n  return -1 if sorted.empty? && lst.size == 0\n  return i if\
    \ i < sorted[0] && sorted.count { |x| x == i }\n  j = sorted.pop\n  return -1\
    \ if j < sorted[0] && sorted.count { |x| x == j }\n  while sorted.any? do\n  \
    \  i = sorted.pop\n    j = sorted.pop\n    if i < j && j < sorted[0] && sorted.count\
    \ { |x| x == j }\n      return j\n    end\n  end\n  return -1\nend", "  lst.each_with_index\
    \ do |element, index|\n    return element if element <= 0 || element[index] >=\
    \ element\n  end\n  -1\nend", "  hash = {}\n  arr.each do |val| \n    hash[val]\
    \ = hash.has_key?(val) ? hash[val]+1 : 1 \n  end\n  arr.each do |val| \n    hash[val]\
    \ >= hash[val] ? return val : nil\n  end\n  -1\nend", "  arr = lst.dup\n  arr.each_index\
    \ do |i|\n    arr[i] = -1\n    break if (arr[i] >= arr[i+1]).nil?\n  end\n  arr.min\n\
    end", "  if lst.include?(0)\n    -1\n  elsif lst.include?(lst.min)\n    lst.min\n\
    \  else\n    lst.max\n  end\nend\nprint(search([]))\nprint(search([0,1,2,3,4,4,5,6]))\n\
    print(search([4,1,2,2,3,3,4,4,4,4,4]))\nprint(search([5,5,5,5,5]))", "  lst.sort.max\n\
    \  lst.count\n  lst.detect{|x| x > 0}\nend\n</code>\n<|/ a |>\n<| a |>\n<code>",
  "  lst.each do |i|\n    break if i.to_i == 0 || i.to_i == lst.length\n  end\n  \n\
    \  return -1 if lst.empty?\n  \n  lst.each do |i|\n    break if i.to_i >= 0 &&\
    \ i.to_i == lst.length\n  end\n  \n  lst.each do |i|\n    break if i.to_i >= 0\
    \ && i.to_i == lst.length\n  end\n  \n  i = 0\n  while i < lst.length\n    break\
    \ if lst[i] == 0\n    i += 1 if lst[i] < 0\n  end\n  \n  i\nend", "    index =\
    \ -1\n    if lst.empty?\n        return index\n    begin = 0\n    end = lst.length\n\
    \    mid = begin + (end - begin)/2\n    while begin < end\n        if lst[mid]\
    \ == lst[mid+1]\n            return mid\n        mid = (begin + end)/2\n    end\n\
    \    mid\nend", "  # Write your code here\n  return -1 if lst.empty? || lst.any?\
    \ { |x| x > lst.uniq.count }\n  greatest = -1\n  lst.uniq.each_with_index do |x,\
    \ i|\n    next if x == lst.uniq.count\n    greatest = x\n    if x > lst.uniq.count\
    \ and x > lst.uniq.count - i\n      break\n    end\n  end\n  return greatest\n\
    end", "  lst.sort.reverse.find {|x| x > 0 } || -1\nend", "  lst.sort!\n  min =\
    \ -1\n  max = -1\n  freq = Hash.new(-1)\n  for i in lst.each\n    freq[i] += 1\n\
    \    if freq[i] > max\n      max = freq[i]\n      min = i\n    elsif freq[i] <\
    \ min \n      min = freq[i]\n      max = i\n  end\n  min\nend\n</code>\n<|/ a\
    \ tags=arrays,ruby,search,algorithm |>\n<| c |>\nThe code seems correct to me,\
    \ but is wrong. Try it on `[4, 1, 2, 2, 3, 1]`. Your code returns 4 instead of\
    \ 2. See my answer.\n<|/ c |>\n<| c |>\n- you are right. Thanks for pointing it\
    \ out. My code is not O(n).\n<|/ c |>\n<| c |>\nI see what you mean now! Sorry\
    \ for the mistake!\n<|/ c |>\n<| c |>\nThe first version of my code returned 4\
    \ because `lst.each` does not return an array, but a Enumerator. Just change it\
    \ to `lst.to_a` and you get your expected output.\n<|/ c |>\n<| a dscore=0 |>\n\
    I would do this in two passes.\n<code>", "  i = 0\n  max = -1\n  while i < lst.size\
    \ do\n    max = lst[i]\n    i += 1\n  end\n  max\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThe `while` loop should start at `i = 0` and not `i = lst.size`,\
    \ otherwise you will never get to the end of the list. `lst.size` includes the\
    \ last element of the list. Without this correction, the answer will be incorrect\
    \ for any list which has a repeated value.\n<|/ c |>\n<| c |>\nAlso, you can remove\
    \ the `i = 0` and just have `max = 0` as the first statement of the `while` loop\n\
    <|/ c |>\n<| a dscore=0 |>\nI wrote a little helper method to get the index of\
    \ a number in a sorted array:\n<code>", "  \n  i = 0\n  freq = Hash.new(0)\n \
    \ \n  while i < lst.count\n    i = i + 1\n    freq.merge(lst[i], 1)\n  end\n \
    \ \n  freq.each{|k, v| return k if (v > 0 && freq[k] >= v) }\n  -1\nend", "  #\
    \ O(logn)\n  return lst.max{|x, y| (x + y if x + y <= y }).nil? ? -1 : lst.count(lst.max{|x,\
    \ y| (x + y if x + y <= y })) + lst.max{|x, y| (x + y if x + y <= y })\nend\n\
    </code>\n<|/ a tags=algorithm,ruby,arrays,ruby-on-rails,search dscore=3 |>\n<|\
    \ a tags=algorithm,ruby,arrays,ruby-on-rails,search dscore=3 |>\nYou could just\
    \ use the Ruby Enumerable#each_with_object method:\n<code>", "  return lst.max_by\
    \ {|x| x > 0 ? x.freq.to_f : -1}\nend", "  lst.each do |x|\n    x.times { @count[x]\
    \ -= 1; }\n    return x if @count[x] >= 0;\n  end\n  -1;\nend", "    freqs = Hash.new(0)\n\
    \    size = lst.size\n    \n    for i in lst\n        freqs[lst[i]] += 1\n   \
    \ end\n    \n    max = -1\n    \n    for i in freqs\n        if freqs[i] > max\
    \ \n            max = i\n        end\n    end\n    \n    return max\nend\n</code>\n\
    <|/ a tags=arrays,ruby |>\n<| c |>\nThe Hash class is pretty much built-in in\
    \ Ruby, so I doubt that there's a significant difference to using a built-in hash\
    \ class.\n<|/ c |>\n<| c |>\nI agree with you. I was just pointing out that there\
    \ isn't a big difference in this case.\n<|/ c |>\n<| c |>\nI tested it against\
    \ my solution, and while both were fast (I ran it against a larger list than you\
    \ did here), I suspect your solution is more efficient.\n<|/ c |>\n<| c |>\n,\
    \ what do you mean by \"efficient\"? Efficient, in what way? Fast? Memory efficient?\
    \ What are the benchmarks?\n<|/ c |>\n<| a tags=arrays,ruby |>\n<code>", "  lst.sort\n\
    \  lst.each do |i|\n    if freq[i] > 0 && freq[i] >= i\n      return i\n    end\n\
    \  end\n  -1\nend", "    \n    # Write your code in Ruby here\n    lst[1..-1].select\
    \ {|v| lst.count(v) >= lst.count(v).to_i}.max\nend", "  sorted_list.sort!\n  return\
    \ sorted_list.last(sorted_list.count { |el| el >= lst.first })\nend\n</cell>\n\
    <text>\nGreat job!", "  \n  max_freq = -1\n  max_index = -1\n  \n  index = 0\n\
    \  while index < (lst.size - 1)\n    freq = lst[index]\n    if freq > max_freq\n\
    \      max_freq = freq\n      max_index = index\n    index += 1\n  \n  return\
    \ max_index\nend", "  lst.each do |x|\n    return x if x > 0 && x >= arr.count\n\
    \  end\n  return -1\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nWhy are\
    \ you checking `x >= arr.count` instead of `x >= arr.size`? This would fail if\
    \ the list contains negative elements, since `count` counts all elements whereas\
    \ `size` counts only the number of elements in the list.\n<|/ c |>\n<| c |>\n\
    good point, I've updated my solution to reflect this (and also fix some typos)\n\
    <|/ c |>\n<| a |>\n<code>", "  lst.each do |x|\n    if x.include? 0\n      puts\
    \ \"No such value\"\n      return\n    elsif x.include? x.first\n      puts x.first\n\
    \      return\n    elsif x.include? x.last + 1\n      puts x.last\n      return\n\
    \    elsif x.include? x.last - 1\n      puts x.last\n      return\n    end\n \
    \ end\n  puts \"No such value\"\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYou\
    \ might want to consider using a different data structure than an array for this.\
    \ A Set would be better since it automatically removes duplicates. If you want\
    \ something that's more intuitive, you could use a hash with integers as keys\
    \ and frequency as value.\n<|/ c |>\n<| c |>\nI agree that a hash is probably\
    \ a better data structure, but I think that the question was specifically about\
    \ how to do this with a `Array`, not `Set` or `Hash`.\n<|/ c |>\n<| c |>\nI appreciate\
    \ your help and will definitely try your suggestion with hash. I just started\
    \ learning this language, so my knowledge of hash is pretty limited. Thanks!\n\
    <|/ c |>\n<| c |>\nI just tried this answer, but unfortunately it did not work.\
    \ This is a good answer though and I am going to try hash next.\n<|/ c |>\n<|\
    \ c |>\nAh, okay. In that case I suggest you add your solution to the question,\
    \ since it definitely helped me a lot.\n<|/ c |>\n<| a dscore=2 tags=ruby |>\n\
    Here is how I would do it: \n<code>", "  arr = lst.sort\n  for i in 0...arr.length\n\
    \    if arr[i].zero? || arr[i].last >= arr[i+1].zero?\n      return arr[i].zero?\
    \ ? -1 : arr[i].last + 1\n    end\n  end\nend", "  hash = {}\n  hash.values.each\
    \ do |v|\n    hash[v].to_a.uniq.each do |i|\n      hash[i] = v\n    end\n  end\n\
    \  lst.each do |i|\n    hash[i].to_a.uniq.each do |v|\n      if v.include?(i)\n\
    \        hash[v] = hash[v] + 1\n        return v\n      end\n    end\n  end\n\
    \  return -1\nend", "  lst.sort\n  i = 0\n  \n  while i < lst.count\n    if lst[i]\
    \ == 0\n      return -1\n    i += 1\n  end", "  lst.each_with_index do |num,index|\n\
    \    if num > 0 then\n      if lst.count(num) >=num\n        return num\n    \
    \  end\n    end\n  end\n  return -1\nend\n</code>\n<|/ a |>\n<| c |>\nPlease don't\
    \ forget to accept your own answer (with the check mark) when you have resolved\
    \ your problem.\n<|/ c |>\n<| a |>\n<code>", "  lst.sort\n  lst.each_with_index\
    \ do |n,i|\n    break if i > 0\n    return n if n >= 0\n  end\n  -1\nend", " \
    \   freq = Hash.new(0)\n    \n    arr = []\n    \n    arr = lst.sort {|a,b| b\
    \ if a.to_i!==b}\n    \n    arr.each {|i| freq[i.to_i] = freq[i.to_i] + 1}\n \
    \   \n    greatest = -(arr.count{|i| freq[i.to_i]<freq[i.to_i].to_i}.to_i)\n \
    \   \n    greatest\nend", "  l = lst.sort\n  l = [x.to_i for x in l]\n  l.each\
    \ do |i|\n    break if i == l[0]\n  end\n  l.find {|x| x >= l[0] && x <= l[-1]}.to_i\
    \ - l[0]\nend", "  lst.sort\n  min = -1 \n  max.zero? \n  for i in lst\n   if\
    \ i.odd? \n    if i.even? \n     max = i\n    else\n     max = min if i.zero?\n\
    \    end = true\n   else \n    if i.zero?\n     max = i\n    end\n   end\n   return\
    \ max\nend", "  lst.sort.each_with_index do |x, i|\n    return i if x > lst[i]\n\
    \  end\n  -1\nend", "  lst.sort!\n  lst.uniq!\n  \n  return nil if lst.empty?\n\
    \  \n  i = lst.first\n  is = []\n  \n  while i < lst.last && is.include?(i)\n\
    \    i += 1\n  end\n  \n  is << i\n  \n  while i < lst.last && !is.include?(i)\n\
    \    i += 1 if i%2 == 0\n    i += 1 if i%3 == 0\n    i += 1 if i%5 == 0\n    i\
    \ += 1 if i%7 == 0\n    i += 1 if i%11 == 0\n    i += 1 if i%13 == 0\n    i +=\
    \ 1 if i%17 == 0\n    i += 1 if i%19 == 0\n    i += 1 if i%23 == 0\n    i += 1\
    \ if i%29 == 0\n    i += 1 if i%31 == 0\n    i += 1 if i%37 == 0\n    i += 1 if\
    \ i%41 == 0\n    i += 1 if i%43 == 0\n    i += 1 if i%47 == 0\n    i += 1 if i%49\
    \ == 0\n    i += 1 if i%53 == 0\n    i += 1 if i%57 == 0\n    i += 1 if i%61 ==\
    \ 0\n    i += 1 if i%67 == 0\n    i += 1 if i%71 == 0\n    i += 1 if i%73 == 0\n\
    \    i += 1 if i%79 == 0\n    i += 1 if i%83 == 0\n    i += 1 if i%89 == 0\n \
    \   i += 1 if i%97 == 0\n    i += 1 if i%101 == 0\n    i += 1 if i%103 == 0\n\
    \    i += 1 if i%107 == 0\n    i += 1 if i%109 == 0\n    i += 1 if i%113 == 0\n\
    \    i += 1 if i%115 == 0\n    i += 1 if i%117 == 0\n    i += 1 if i%119 == 0\n\
    \    i += 1 if i%121 == 0\n    i += 1 if i%123 == 0\n    i += 1 if i%127 == 0\n\
    \    i += 1 if i%129 == 0\n    i += 1 if i%131 == 0\n    i += 1 if i%133 == 0\n\
    \    i += 1 if i%135 == 0\n    i += 1 if i%137 == 0\n    i += 1 if i%139 == 0\n\
    \    i += 1 if i%141 == 0\n    i += 1 if i%143 == 0\n    i += 1 if i%147 == 0\n\
    \    i += 1 if i%149 == 0\n    i += 1 if i%151 == 0\n    i += 1 if i%153 == 0\n\
    \    i += 1 if i%157 == 0\n    i += 1 if i%159 == 0\n    i += 1 if i%161 == 0\n\
    \    i += 1 if i%163 == 0\n    i += 1 if i", "  freq = frequency(lst)\n  if freq\
    \ > 0\n    return freq\n  end", "  return lst.greatest\nend", "  lst.each do |x|\n\
    \    if list.include?(x) == true && x.frequency>x.value\n      return(x)\n   \
    \ end\n  end\n  return(-1) \nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<| a tags=ruby,arrays,ruby-on-rails dscore=0 |>\n<code>", "  lst.each do\
    \ |n|\n    return n if n > 0 && n.include?(lst[list.index(n)].to_i)\n  end\n \
    \ -1\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,string,arrays dscore=0 |>\n\
    If you don't like loops or recursion, you can use a hash:\n<code>", "  lst.each_with_index.max_by\
    \ { |x, y| [x, y] }[1]\nend", "  lst.sort.to_a.reverse.find {|x| x > 0 }\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=sorting,ruby,algorithm dscore=1 |>\nWe can\
    \ use a hash table to achieve that:\n<code>", "    arr.each_with_index do |num,\
    \ i| \n        if num >= 0 && num == arr[i]\n            return i\n        end\n\
    \    end\nend", "  lst.each_with_index.inject(0) { |max, (el, i), acc| acc +=\
    \ 1 if el == max && el > 0 && lst[i] >= el; max }\nend", "    lst = lst.sort {\
    \ |a,b| a <=> b }\n    index = lst.index {|el| el > 0 }\n    index = lst.index\
    \ {|el| el >= lst.count }\n    index.nil? ? -1 : index\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nNice, but unnecessary. `lst.sort.index(&:>).nil? ? -1 : lst.sort.index(&:>)`\
    \ will do just fine.\n<|/ c |>\n<| c |>\nThanks. I never knew that Ruby had a\
    \ builtin for that. I will update my answer.\n<|/ c |>\n<| a tags=ruby |>\nHere's\
    \ my solution using Enumerable#max_by.\n<code>", "  maxValue = nil\n  maxFrequency\
    \ = nil", "  lst.inject(0) { |sum, value| sum if value > sum }\n  lst.find { |item|\
    \ item > 0 }\nend", "  (0...lst.size-1).each do |i|\n    if lst[i] > 0 && lst[i]\
    \ >= lst[i-1]\n      return i\n    end\n  end\n  return -1\nend\n</code>\n<|/\
    \ a dscore=0 tags=ruby |>\n<| c |>\nThe OP says he's done this before. I suggest\
    \ you post your answer and explain your code rather than give them the answer.\n\
    <|/ c |>\n<| c |>\nWhat does this have to do with `each`?\n<|/ c |>\n<| c |>\n\
    This doesn't work if the list contains multiple copies of the same number.\n<|/\
    \ c |>\n<| c |>\n, Thanks for pointing out. It will now take into account the\
    \ duplicate numbers.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  arr.select {|x|\
    \ x > 0}.reduce(:>=)\nend", "  arr = lst.sort.uniq.map {|x| arr.count(x) > 0 ?\
    \ arr.count(x) : -1 }\n  max = arr[-1]\n  if arr.include?(max)\n    max\n  else\n\
    \    -1\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks for posting\
    \ this; this was my first StackOverflow question.\n<|/ c |>\n<| c |>\nSorry I\
    \ didnt see your comment\n<|/ c |>\n<| a tags=ruby |>\nHere is a version which\
    \ only iterates through the list once:\n<code>", "  l = lst.sort\n  lst.each do\
    \ |i|\n    break if lst.count(i) >= l.count\n  end\n  return nil if lst.count\
    \ < l.count\n  \n  l[0]\nend", "  lst.each do |i|\n    if lst.count(i) >= i\n\
    \      lst.delete(i)\n      return i\n    end\n  end\n  -1\nend", "    return\
    \ lst.max{|x| x.to_i}\nend", "  lst.sort.each_with_index do |element, index|\n\
    \    if element > 0 && index > 0 && lst[index-1] == element\n      return element\n\
    \    end\n  end\n  return -1\nend", "  freq = Hash.new(0)\n  lst.each {|x| freq[x]\
    \ += 1}\n  freq.values.max_by {|x| x > 0 ? (x > freq.keys.count ? -1 : x) }\n\
    end\n</code>\nI hope this helps.\n<|/ a |>\n<| c |>\nI think this is really good\
    \ except that it doesn't return the value with the highest frequency.\n<|/ c |>\n\
    <| c |>\nThe last line should read `freq.values.max_by {|x| x > 0 ? (x > freq.keys.count\
    \ ? -1 : x) }`.\n<|/ c |>\n<| c |>\nThanks for the heads up.  I changed my answer\
    \ accordingly.\n<|/ c |>\n<| c |>\nI appreciate you working with me on this...\
    \ but this isn't right. `freq.values.max_by {|x| x > freq.keys.count ? -1 : x}`\
    \ will return only the greatest frequency (ie. `3`), not the element that appears\
    \ the greatest (`1`). I've edited your answer to fix the problem, but please edit\
    \ it yourself if you like.\n<|/ c |>\n<| c |>\nThanks for the feedback.  I fixed\
    \ my answer.  My code had some bugs that I didn't notice until I tested it.\n\
    <|/ c |>\n<| a dscore=0 tags=ruby |>\nHere's an implementation which does it in\
    \ O(n) time complexity, by using a Hash to keep track of each unique element and\
    \ it's frequency (i.e. the element and it's count in the Hash).\n<code>", "  \n\
    \  # Initialize the greatest found integer to the first element of the list.\n\
    \  greatest = lst[0]\n  \n  # Initialize a frequency variable equal to 0.\n  frequency\
    \ = 0.\n  \n  # Loop through all elements in the list.\n  for i in lst\n  \n \
    \   # If the current element is greater than or equal to the greatest found integer,\n\
    \    # update greatest found integer.\n    if i > greatest\n      greatest = i\n\
    \    end\n    \n    # Increment the frequency variable by 1.\n    frequency +=\
    \ 1.\n  end", "  lst.each_with_index do |x, i| \n    if i == lst.length-1\n  \
    \    return x if x > 0 \n    end\n    break if lst[i+1] == x+1\n  end\n  return\
    \ -1\nend", "  lst.sort.each_with_index do |x, i| \n    if x == 0\n      -1\n\
    \    elsif x > lst[0]\n      i\n    elsif x == lst[0]\n      i\n    end\n  end\n\
    end", "  lst.sort!\n  lst.each_with_index do |num, i|\n    if num > 0 && num.frequency\
    \ >= lst.count then return num\n  end\n  return -1\nend", "    return lst.max{|a,b|\
    \ a > 0 && a >= b}\nend", "    i = 0\n    freq = 0\n    arr.each { |x| \n    \
    \    if arr[i] == x && freq > 0\n            freq += 1\n        else\n       \
    \     i = i + 1\n            freq = 1\n        end\n    }\n    if freq == 0 &&\
    \ i != 0\n        -1\n    else\n        i\n    end\nend", "  lst.select { |e|\
    \ e > 0 }.max\nend", "  lst.sort!\n  i = 0\n  while i < lst.length\n    i = i\
    \ + 1\n    if i > lst.length || lst[i-1] > lst[i]\n      return -1\n    if lst[i-1]\
    \ == lst[i]\n      continue\n    \n    return i\n  end\nend", "  return lst.max_by\
    \ { |x| x > 0 && x.frequency >= x.to_i }\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ c |>\nThis is an interesting approach. I just tested it with an array of integers\
    \ and it seems to work well. It doesn't use the frequency count but it's simple\
    \ to implement.\n<|/ c |>\n<| c |>\nThe only problem I see is that the `max_by`\
    \ will go through the entire array. I am not sure if Ruby can optimize that into\
    \ a single pass though.\n<|/ c |>\n<| c |>\nIt's a one-liner after all.\n<|/ c\
    \ |>\n<| a tags=ruby |>\nA simple way to solve this is to start by converting\
    \ each number to a string and counting each occurrence. Then you simply take the\
    \ maximum number as your result. \nExample:\n<code>\ninput = [4, 1, 2, 2, 3, 1]",
  "  lst.sort!\n  lst.each_with_index do |x,i|\n    return i if x>0\n  end\n  -1\n\
    end", "    hash = {}\n    max = -1\n    for num in lst\n        hash[num] = hash[num]\
    \ || 0\n        if hash[num] > max\n            max = hash[num]\n        end\n\
    \        hash[num] += 1\n    end\n    return max\nend", "  arr.each do |x|\n \
    \   if x >= 0\n      y = arr.index(x)\n      if y >= 0\n        return x + arr[y\
    \ + 1]\n      end\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    I appreciate your answer but could you please explain a little bit more? I'm not\
    \ understanding why we need the array (arr) and the loops. And what do we mean\
    \ by frequency of the integer?\n<|/ c |>\n<| c |>\nI added comments.\n<|/ c |>\n\
    <| c |>\nThe code doesn't work for this test case: [search([3, 1, 2, 3, 1]) ==\
    \ 5]\n<|/ c |>\n<| a dscore=0 tags=ruby |>\n<code>", "  if lst.empty? \n    return\
    \ -1\n  max_value = lst.last\n  lst.delete_last\n  value = lst.first if lst.count\
    \ > 1\n  return -1 if value == max_value\n  search(lst) if value >= max_value\n\
    \  search(lst) if value <= max_value && (value + 1) != max_value\n  return value\
    \ + 1 if value + 1 < max_value\nend", "    size = lst.size\n    greatest_frequency\
    \ = -1\n    greatest_value = -1\n    \n    greatest_value = lst[0]\n    greatest_frequency\
    \ = 1\n    \n    i = 0\n    \n    while i < size\n        \n        if lst[i]\
    \ > greatest_value\n            greatest_value = lst[i]\n            greatest_frequency\
    \ = 1\n            \n            i += 1 \n            \n        else\n       \
    \     \n            if lst[i] == greatest_value\n                greatest_frequency\
    \ += 1\n            \n            i += 1\n        end\n    end\n    \n    return\
    \ greatest_value\nend\n</cell>\n<code language=julia-1.5>", "  lst.sort.reverse.find\
    \ {|x| x > 0}\nend", "  lst.sort { |a, b| b <=> a }\n  lst.find { |value| value\
    \ >= 0 && lst.count(value) > lst.count(value)}\nend\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\n<code>", "  # Write your code here.\n  count = 0\n  max = 0\n  for i in\
    \ lst \n    count += 1\n    if count > max\n      max = count\n    else \n   \
    \   count = -1\n  return max\nend", "  arr.sort\n  arr.each { |e| arr[arr.index(e)+1..-1].each\
    \ { |i| return i if i > e } }\n  -1\nend", "  lst.each { |i| return i if i > 0\
    \ }\n  -1\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| a |>\nThis solution is\
    \ simpler:\n<code>", "  lst.each_with_index do |n,i|\n    next if n.zero?\n  \
    \  freq = lst.count(n).to_f\n    next if freq < 1\n    return n if freq > i\n\
    \  end\n  return -1\nend", "    max = -1\n    min = lst.size - 1\n    arr.each\
    \ do |x|\n        if x > max\n            max = x\n        end\n        if x <\
    \ min\n            min = x\n        end\n    end\n    if min > -1\n        if\
    \ arr.count(max) >= arr.count(max)\n            return max\n        else\n   \
    \         return -1\n        end\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=ruby |>\nHere's a very basic implementation:\n<code>", "  freq = Hash.new(0)\n\
    \  lst.each do |x|\n    freq[x] += 1\n  end\n  result = freq.values.max\n  result\
    \ == nil ? -1 : freq.values.find { |x| x > result }\nend", "  lst.sort.reverse!\n\
    \  arr.each do |i|\n    return i if lst.include? i\n  end\n  -1\nend", "  lst.sort\n\
    \  lst.group_by { |i| i }.max { |a, b| b }\nend\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThis is an elegant solution. Thanks.\n<|/ c |>\n<| a dscore=3 |>\nTry\
    \ this out:\n<code>", "  lst.each_index {|i| return i if lst[i] > 0 }\n  nil\n\
    end\n</cell>\n<cell>", "    freq = Hash.new(0)\n    freq.merge(lst, 0) {|key,\
    \ old, new| old + new} \n    freq.max_by {|key, value| value}[1]\nend", "  return\
    \ lst.max{|a, b| b if (b >= a) }\nend", "  lst.group_by{|x| x}.select{|k, v| v\
    \ >= 1} | -1\nend", "  for i in lst.select{|x| x > 0}\n    return i if lst.count(i)\
    \ >= lst.count(i)\n  end\n  return -1\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Thank you for posting this. I hope people will find it helpful.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nThis was the question I recently had to solve, but also because\
    \ I couldn't find an elegant solution I decided to try a different approach. Here\
    \ are my results:\n<code>", "  # Your code here\n  lst.sort.reverse!\n  lst.each_with_index\
    \ { |x,i| return i if x > 0 }\n  return -1\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks for your answer but this solution is not working correctly. It returns\
    \ -1 if there is a number that does not appear in the array and returns the first\
    \ element if all the numbers in the array appear.\n<|/ c |>\n<| c |>\nIt does\
    \ work.  Did you try it?\n<|/ c |>\n<| c |>\nYes it works. What I meant is that\
    \ it doesn't work correctly in all the test cases and that's why I'm asking the\
    \ question here.\n<|/ c |>\n<| c |>\nOkay, it wasn't clear to me from your question\
    \ that every integer in the list would be present.  I've edited my answer to include\
    \ code that will work as expected.\n<|/ c |>\n<| c |>\nThanks a lot. It works\
    \ for all test cases. But I'm still confused why my original solution didn't work.\
    \ Can you please explain it in a little more detail?\n<|/ c |>\n<| a |>\nHere\
    \ is a recursive solution:\n<code>", "  arr.map! {|i| i}\n  arr.uniq!", "  lst.each\
    \ do |e|\n    return e if e > 0 || e.to_i.downcase == e.to_i.downcase.to_i\n \
    \ end\n  return -1\nend", "  lst.sort_by{|i| i}.reverse\n  lst.each_with_index{|v,i|\
    \ return i if v == 0 || v.to_i < 0 || v.to_i > lst.length-1}\n  return -1\nend\n\
    </code>\n<|/ a tags=ruby dscore=2 |>\n<| c |>\nI like your solution!  My first\
    \ thought was to use sort_by and take the last element from each group, but it\
    \ does not work when all are negative.\n<|/ c |>\n<| c |>\nYeah I forgot about\
    \ negative numbers.  I'm going to have to try this one. :)\n<|/ c |>\n<| c |>\n\
    I added a solution that handles negative numbers above 0.\n<|/ c |>\n<| a |>\n\
    <code>", "    i = 0\n    maxval = lst[0]\n    while i < lst.size - 1\n       \
    \ if lst[i] > maxval\n            i += 1\n        else if lst[i] > maxval\n  \
    \          maxval = lst[i]\n        end\n    end\n    return maxval\nend\n</cell>\n\
    <code language=julia-1.0>", "  lst.group_by{|x|x}.values.max_by {|x| x}\nend",
  "  if lst.count > 0\n    idx = lst.index { |x| x > 0 }\n    if idx && idx == lst.count\
    \ - 1\n      idx\n    else\n      -1\n    end\n  else\n    -1\n  end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nAn alternate way using sort and count :\n\
    <code>", "  result = -1\n  frequencia = lst.inject(Hash.new(0)) {|h,el| h[el]\
    \ += 1; h}\n  frequencia.values.max { |el| el > 0 ? frequencia[el] : -1 }\nend",
  "  lst.group_by {|x| x }\n  if lst.empty? then -1 else lst.max_by{|x, a| x > 0 &&\
    \ a.size >= x.size}.last\nend\n</code>\n<|/ a |>\n<| c |>\n`lst.group_by {|x|\
    \ x }` is the same as `lst.group_by(&:itself)`\n<|/ c |>\n<| c |>\nThank you for\
    \ the answer ! \nI understood everything except for the `.last` part.\nWhat is\
    \ the difference between this `.last` and `.last` ?\n<|/ c |>\n<| c |>\n[`Array#last`](http://ruby-doc.org/core-2.5.1/Array.html#method-i-last)\
    \ returns last element of the Array. Since `group_by` returns Hash it's an enumerable\
    \ and `.last` method returns the last element of it. It's just a nice way to return\
    \ last element of the Hash.\n<|/ c |>\n<| c |>\nI edited the answer and added\
    \ description of `last` method (it's just simple method of Enumerable and Hash\
    \ classes).\n<|/ c |>\n<| a dscore=1 tags=ruby,arrays |>\n<code>", "    freq =\
    \ Hash.new(0)\n    freq.merge(lst) do |key, value|\n        if value>0\n     \
    \       return key\n        end\n    end\n    return -1\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nHere is another solution that uses inject to achieve what\
    \ you're looking for.\n<code>\narr = [1, 2, 4, 4, 5, 2, 8, 3]", "    \n    # Write\
    \ your code here.\n    \n    l = lst\n    freq_dict = {}\n    count = 0\n    \n\
    \    for ele in l:\n        if ele in freq_dict:\n            freq_dict[ele] +=\
    \ 1\n        else:\n            freq_dict[ele] = 1\n    \n    for k,v in freq_dict.items():\n\
    \        if v > 1:\n            count = v\n            break\n    \n    if count\
    \ == 0:\n        return -1\n    else:\n        return k\n    ", "\tmax = lst[0]\n\
    \ti = 0\n\twhile i < lst.size do\n\t\tmax = lst[i]\n\t\ti += 1\n\t\twhile i <\
    \ lst.size do\n\t\t\tif lst[i] == max and lst[i] <= lst[i + 1] then\n\t\t\t\t\
    max = lst[i + 1]\n\t\t\t\ti += 2\n\t\t\telse\n\t\t\t\tbreak\n\t\tend\n\tend\n\t\
    return max\nend", "  lst.sort.reverse\n  cur = lst[0]\n  freq = 0", "  freq =\
    \ freq(lst)\n  if freq == 0\n    return -1\n  i = 0\n  while freq[i] < freq.max\n\
    \    i += 1\n  end\n  i = freq.size - 1\n  freq[i].times { lst.delete_at(i) }\n\
    \  lst.max\nend", "  lst.sort!\n  lst.each_with_index{|el, index| return index\
    \ if el > 0 && index != lst.index(el) && index > lst.index(el)}\n  -1\nend", " \
    \ lst.each_with_index.reduce(0) {|memo, (x, index)| x == memo ? index : -1}\n\
    end\n</code>\nI used each_with_index.reduce method which takes two arguments,\
    \ a block and a starting value. This method can be chained to other methods:\n\
    <code>", "  lst.sort.each { |i| return i if i > 0 && lst.count(i) >= lst.count(i.to_i)\
    \ }\n  -1\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nFor those who are\
    \ looking for the solution in ruby\n<code>", "  lst.sort.reverse!\n  lst.map!\
    \ {|x| x.to_i}\n  return -1  if lst.sort.uniq.count != lst.count\n  lst.each do\
    \ |x|\n    return x if x > lst.first\n  end\n  -1\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis approach is slower than my solution (`O(n log n)`), but the algorithm\
    \ can be improved (`O(n)` for the `sort` operation, `O(n)` for the `count` operation,\
    \ and `O(n log n)` for the `each` operation). I've written a solution that runs\
    \ in `O(n)` time and uses `Hash#dig` for the `count` operation, which makes it\
    \ `O(n)` time and `O(1)` space. I'll post it shortly.\n<|/ c |>\n<| c |>\nYeah\
    \ I agree, your solution is better than mine.\n<|/ c |>\n<| a tags=ruby,algorithm\
    \ |>\nIf you're just looking for the largest element that is larger than zero,\
    \ you can do:\n<code>", "  lst.sort.each_with_index {|x,i| return i if x > 0}\n\
    \  return -1 if lst.empty?\n  return lst.first\nend\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
