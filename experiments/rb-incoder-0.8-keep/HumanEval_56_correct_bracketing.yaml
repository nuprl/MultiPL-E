name: HumanEval_56_correct_bracketing
language: rb
prompt: "# brackets is a string of \"<\" and \">\".\n# return True if every opening\
  \ bracket has a corresponding closing bracket.\n# >>> correct_bracketing(\"<\")\n\
  # False\n# >>> correct_bracketing(\"<>\")\n# True\n# >>> correct_bracketing(\"<<><>>\"\
  )\n# True\n# >>> correct_bracketing(\"><<>\")\n# False\ndef correct_bracketing(brackets)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n\
  \    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"\
  <>\"))\n    assert_equal(true, candidate.call(\"<<><>>\"))\n    assert_equal(true,\
  \ candidate.call(\"<><><<><>><>\"))\n    assert_equal(true, candidate.call(\"<><><<<><><>><>><<><><<>>>\"\
  ))\n    assert_equal(false, candidate.call(\"<<<><>>>>\"))\n    assert_equal(false,\
  \ candidate.call(\"><<>\"))\n    assert_equal(false, candidate.call(\"<\"))\n  \
  \  assert_equal(false, candidate.call(\"<<<<\"))\n    assert_equal(false, candidate.call(\"\
  >\"))\n    assert_equal(false, candidate.call(\"<<>\"))\n    assert_equal(false,\
  \ candidate.call(\"<><><<><>><>><<>\"))\n    assert_equal(false, candidate.call(\"\
  <><><<><>><>>><>\"))\n  end\nend\n"
completions: ["    # Your code here!\n    stack = []\n    for char in brackets:\n\
    \        if char == '<':\n            if not stack or stack[-1] != '<':\n    \
    \            return False\n            stack.pop()\n        elif char == '>':\n\
    \            if not stack or stack[-1] != '>':\n                return False\n\
    \            stack.pop()\n        else:\n            stack.append(char)\n    return\
    \ not stack", "  brackets.gsub!(/\\<\\>/, '<') # \"<\" -> \"<\"\n  brackets.gsub!(/\\\
    >\\>/, '>') # \">\" -> \">\"\n  brackets.gsub!(/\\</, '>') # \"<\" -> \">\"\n\
    \  brackets.gsub!(/\\>\\</, '<') # \">\" -> \"<\"\n  brackets.gsub!(/\\<\\>/,\
    \ '>') # \"<\" -> \">\"\n  brackets.gsub!(/\\>\\</, '<') # \">\" -> \"<\"\n  brackets.gsub!(/\\\
    </, '<') # \"<\" -> \"<\"\n  brackets.gsub!(/\\>\\</, '<') # \">\" -> \"<\"\n\
    \  return brackets.to_i == brackets.length\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This is an interesting solution that uses regular expressions to replace an indeterminable\
    \ amount of characters. I wonder if there's a way to do it with just one regular\
    \ expression. Anyone who knows how to do that please chime in.\n<|/ c |>\n<| c\
    \ |>\n: I haven't done it in a while, but I believe that the only regex that can\
    \ match a specific number of characters is something like `(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(.)*(",
  "  brackets.scan(/\\(<.+>\\)|\\<.+>\\>|\\<.+\\>/) do |opening, closing|\n    opening\
    \ = opening.to_s.strip\n    closing = closing.to_s.strip\n    if opening.empty?\
    \ && closing.empty?\n      return true\n    end\n    return false if opening.empty?\n\
    \    return false if closing.empty?\n    return false if opening.include?('>')\n\
    \    return false if closing.include?('<')\n    return true if opening.include?('<')\
    \ && closing.include?('>')\n    return true if opening.include?('>') && closing.include?('<')\n\
    \    return true if opening.include?('>') && closing.include?('>')\n    return\
    \ true\n  end\n  return false\nend", "  bracket = brackets[0]\n  bracket_count\
    \ = brackets.count(\"<\")\n  bracket_count += 1\n  bracket_count = brackets.count(\"\
    >\") - bracket_count\n  bracket_count = 0 if bracket_count < 0 else bracket_count\n\
    \  bracket_count = brackets.count(\"(\") - bracket_count\n  bracket_count = brackets.count(\"\
    )\") - bracket_count\n  return bracket_count == bracket\nend\n</cell>\n<code language=julia-1.5>",
  "  brackets.scan(/^<|>$|^<|>$|^<|>$/)\n  return brackets == brackets.to_s\nend",
  "  brackets.chars.sort.each do |c|\n    return false unless brackets.chars.all?\
    \ { |b| c == b }\n  end\n  return true\nend", "    brackets = brackets.to_s\n\
    \    brackets = brackets.chomp('>')\n    brackets = brackets.chomp('<')\n    return\
    \ brackets.each_char.reduce(:==)\nend", "  brackets.count(\"<\") == 0\nend", " \
    \ brackets.gsub!(/\\<+/,\"\")\n  brackets.gsub!(/\\>+/,\"\")\n  brackets.gsub!(/\\\
    <{3,}/, \"<<\")\n  brackets.gsub!(/\\>{3,}/,\">>\")\n  brackets.gsub!(/\\<{3,}/,\
    \ \"<<\")\n  brackets.gsub!(/\\>{3,}/,\">>\")\n  brackets.gsub!(/\\<{3,}/, \"\
    <<\")\n  brackets.gsub!(/\\>{3,}/,\">>\")\n  brackets.gsub!(/\\<{3,}/, \"<<\"\
    )\n  brackets.gsub!(/\\>{3,}/,\">>\")\n  brackets.gsub!(/\\<{3,}/, \"<<\")\n \
    \ brackets.gsub!(/\\>{3,}/,\">>\")\n  brackets.gsub!(/\\<{3,}/, \"<<\")\n  brackets.gsub!(/\\\
    >{3,}/,\">>\")\n  brackets.gsub!(/\\<{3,}/, \"<<\")\n  brackets.gsub!(/\\>{3,}/,\"\
    >>\")\n  brackets.gsub!(/\\<{3,}/, \"<<\")\n  brackets.gsub!(/\\>{3,}/,\">>\"\
    )\n  brackets.gsub!(/\\<{3,}/, \"<<\")\n  brackets.gsub!(/\\>{3,}/,\">>\")\n \
    \ brackets.gsub!(/\\<{3,}/, \"<<\")\n  brackets.gsub!(/\\>{3,}/,\">>\")\n  brackets.gsub!(/\\\
    <{3,}/, \"<<\")\n  brackets.gsub!(/\\>{3,}/,\">>\")\n  brackets.gsub!(/\\<{3,}/,\
    \ \"<<\")\n  brackets.gsub!(/\\>{3,}/,\">>\")\n  brackets.gsub!(/\\<{3,}/, \"\
    <<\")\n  brackets.gsub!(/\\>{3,}/,\">>\")\n  brackets.gsub!(/\\<{3,}/, \"<<\"\
    )\n  brackets.gsub!(/\\>{3,}/,\">>\")\n  brackets.gsub!(/\\<{3,}/, \"<<\")\n \
    \ brackets.gsub!(/\\>{3,}/,\">>\")\n  brackets.gsub!(/\\<{3,}/, \"<<\")\n  brackets.gsub!(/\\\
    >{3,}/,\">>\")\n  brackets.gsub!(/\\<", "    return brackets =~ /\\(<[^>]*>\\\
    )/ and brackets =~ /\\(<([^>]*?)>\\)/ ? true : false\nend", "  opens = brackets.scan(/[<>]*/)\n\
    \  opens.each do |o|\n    if brackets.count(o) <= 1\n      return false\n    end\n\
    \  end\n  return true\nend\n</code>\nThis is still O(n^2), but much faster than\
    \ a naive regex solution.\n<|/ a |>\n<| c |>\n`s.scan(/(?<open>[\\<\\>])|(?<-open>[\\\
    <\\>])/)` - this returns array of pairs `(open,close)` which you could then check\
    \ if they are balanced like here: http://stackoverflow.com/questions/12662830/how-can-i-check-whether-a-string-s-includes-a-balanced-pair-of-characters-in-jav\n\
    <|/ c |>\n<| a |>\nYou can use a stack to keep track of which brackets are being\
    \ matched.  As you go through the string, add the opening and closing brackets\
    \ to the stack.  If it ever detects multiple matches, you've found a problem.\n\
    <|/ a tags=regex,ruby dscore=3 |>\n<| a |>\nHere's my approach\n<code>", "  #\
    \ remove whitespace and convert to lower case\n  brackets = brackets.gsub(/\\\
    s+/, \" \").downcase\n  # remove brackets and convert to lower case\n  brackets\
    \ = brackets.gsub(/[\\<\\>]+/, \" \").gsub(/[\\<\\>]+/, \" \").downcase\n  # split\
    \ the string into an array on the spaces so that every element in the array\n\
    \  # is another string with the opening and closing brackets removed\n  brackets\
    \ = brackets.split(\" \").map(&:gsub(/[\\<\\>]+/, \" \"))\n  \n  # initialize\
    \ a variable to keep track if we encounter an opening\n  # or closing bracket\n\
    \  opening = false\n  # initialize an index variable to keep track of the index\
    \ of\n  # the currently opened bracket\n  index = 0\n  \n  # loop through each\
    \ element in the array\n  brackets.each do |str|\n    # if the string is opening,\
    \ set the opening flag to true\n    opening ? opening = false : opening = true\n\
    \    # if the string is closing, set the opening flag to true\n    opening ? opening\
    \ = true : opening = false\n    # if the string is the same as the string that\
    \ was previously opened\n    # (because we reached the end of the array), then\
    \ we have found\n    # the correct number of opening brackets.\n    opening &&\
    \ index == 0 ? (index += 1, true) : false\n    # if the string is the same as\
    \ the string that was previously opened\n    # (because we reached the end of\
    \ the array), then we have found\n    # the correct number of closing brackets.\n\
    \    opening && index == 0 ? (index -= 1, false) : false\n  end\n  # if we didn't\
    \ encounter any brackets we didn't match\n  # this means there were no matching\
    \ brackets\n  opening == false ? false : true\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI agree, however, you only need to remove a pair of brackets. Your code\
    \ would work for example with `'((abc))'`.\n<|/ c |>\n<| c |>\nTrue, however I\
    \ was thinking more about what if someone had multiple pairs of brackets. I'll\
    \ modify the code so it works more generally.\n<|/ c |>\n<| c |>\nThank you for\
    \ helping out. I was able to modify it to suit my needs. I added an additional\
    \ variable and used a variable for the index to keep track of how far I was. My\
    \ code below for reference. Thank you for your help!\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\nYou could use something like the following:\n<code>", "  bracket_pairs =\
    \ []\n  bracket = nil\n  brackets.each_byte do |char|\n    break if char == \"\
    >\" # we want the first \">\"\n    bracket_pairs << char\n    bracket_pairs <<\
    \ \">\" unless char == \"<\" # we want the first \"<\"\n  end\n  bracket_pairs.each_index\
    \ do |index|\n    if bracket_pairs[index + 1] == \"<\"\n      bracket_pairs[index\
    \ + 1] = \">\"\n    end\n  end\n  bracket_pairs.inject(true) do |result, bracket_pair|\n\
    \    result && (bracket = bracket_pair, true or false)\n  end\nend", "  brackets.scan(/[<>]|\\\
    ([^\\)]*\\)/) do |m|\n    (m.empty? || m[0] == '<') ? true : false # return true\
    \ if < is found\n  end\nend", "  brackets = brackets.to_s\n  correct_bracket =\
    \ brackets =~ /[^<>]+/\n  correct_bracket = correct_bracket.to_s == \"<\" and\
    \ correct_bracket != 0\n  correct_bracket\nend\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ Michael. That was very helpful. Still don't understand why my code didn't work,\
    \ but yours did.\n<|/ c |>\n<| c |>\nIf you don't understand it, I suggest you\
    \ add some `puts`s in your code so you see what it's doing and see how it's working\
    \ at every stage. I recommend [Pry](https://github.com/pry/pry). Try setting `debugger`\
    \ at the top of your code and running your code in `pry` with `binding.pry` so\
    \ you can step through your code and see what's happening. Then you can see how\
    \ your code is running and why it's failing.\n<|/ c |>\n<| a |>\nI would go with\
    \ this solution:\n<code>", "  # Your code here\n  while brackets.length > 0\n\
    \    if brackets.slice!(\"<\").include?(brackets.slice!(\")\")) && brackets.slice!(\"\
    <\").include?(brackets.slice!(\"(\"))\n      brackets.slice!(\"<\")\n    else\n\
    \      brackets.slice!(\")\")\n    end\n  end\n  brackets == \"\" ? true : false\n\
    end\n</cell>\n<cell>", "    brackets = brackets.to_s\n    i = 0\n    while i <\
    \ brackets.length\n        left = brackets[i..i+1]\n        right = brackets[i+1..i+2]\n\
    \        if left != \">>\" and right != \"<<\"\n            i += 1\n        else\n\
    \            return false\n    end\n    return true\nend", "  # Your code here\n\
    \  s.count(\"<\") == 0\nend", "  brackets.gsub!(/^<(?!>)(.+)$/, '<\\1>') rescue\
    \ false\n  brackets.gsub!(/^(?!<)(.+)$/, '>\\1') rescue false\n  brackets.empty?\
    \ rescue false\nend", "  brackets.scan(/\\(/)\n  bracket_count = brackets.count(\"\
    (\")\n  brackets.scan(/\\)/)\n  bracket_count -= brackets.count(\")\")\n  brackets.scan(/>/)\n\
    \  bracket_count -= brackets.count(\"<\")\n  brackets.scan(/</)\n  bracket_count\
    \ -= brackets.count(\">\")\n  brackets.scan(/=/)\n  bracket_count -= brackets.count(\"\
    =\")\n  brackets.scan(/:/)\n  bracket_count -= brackets.count(\"/\")\n  brackets.scan(/#/)\n\
    \  bracket_count -= brackets.count(\"#\")\n  brackets.scan(/[<>]/)\n  bracket_count\
    \ -= brackets.count(\"<>\")\n  brackets.scan(/[^<>]/)\n  bracket_count -= brackets.count(\"\
    <\")\n  return bracket_count == 0\nend", "    return brackets =~ /\\(.*\\)/  &&\
    \ brackets =~ /\\(.*\\)/\nend", "  brackets.scan(/\\(|\\)|</) do |char|\n    next\
    \ if char == ?(\n    return false if char == ?)\n    bracket_depth = 0\n    brackets.scan(/#{char}|\\\
    (/) do |sub_char|\n      bracket_depth += 1\n      return false if bracket_depth\
    \ > 1\n      return true if sub_char == ?/\n      bracket_depth += 1\n    end\n\
    \  end\n  true\nend", "  # check for correct bracketing\n  opening = brackets.count(\"\
    <\")\n  closing = brackets.count(\">\")\n  if opening != closing \n    # print\
    \ brackets\n    # print brackets.count(\"<\")\n    # print brackets.count(\">\"\
    )\n    # print \"opening:\", opening\n    # print \"closing:\", closing\n    #\
    \ raise Exception(\"Incorrect\")\n    return false\n  # brackets are correct\n\
    \  return true\nend", "    # write your code in Ruby here\n    open_brackets =\
    \ []\n    correct_brackets = false\n    brackets.each_char do |char|\n       \
    \ if char == \"<\"\n            open_brackets << char\n        elsif char == \"\
    >\"\n            if open_brackets.length == 1\n                correct_brackets\
    \ = true\n            else\n                open_brackets.pop\n            end\n\
    \        else\n            open_brackets.pop\n        end\n    end\n    correct_brackets\n\
    end", "  return brackets.scan(/<|>|\\+|-/).all?\nend", "  brackets.count(\"<\"\
    ) > brackets.count(\">\")\nend", "  return brackets.chars.all? do |char|\n   \
    \ bracket_opening = brackets[char]\n    bracket_closing = brackets[char + 1]",
  "  brackets = brackets.split\n  opening_brackets = brackets.find{|x| x[0] == '<'}\n\
    \  closing_brackets = brackets.find{|x| x[0] == '>'}\n  return opening_brackets\
    \ == closing_brackets\nend", "  brackets.split(\"\").all? do |char|\n    closing_brackets\
    \ = closing_brackets(char)\n    opening_brackets = opening_brackets(char)\n  \
    \  !opening_brackets.nil? && !closing_brackets.nil?\n  end\nend", "  brackets.gsub!(/</,'\\\
    <')\n  brackets.gsub!(/>/,'\\>')\n  brackets.gsub!(/<=/,'\\<=') \n  brackets.gsub!(/=>/,'\\\
    >=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\\
    >=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\\
    >=') \n  brackets.gsub!(/==/,'\\==') \n  brackets.gsub!(/!=/,'\\!=') \n  brackets.gsub!(/=/,'\\\
    =') \n  brackets.gsub!(/<=/,'\\<=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\\
    >=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\\
    >=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\\
    >=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\\
    >=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\\
    >=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\\
    >=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\>=') \n  brackets.gsub!(/>=/,'\\\
    >=') \n  brackets.gsub!(/>=/", "  bracket_open = brackets.index(\"<\")\n  bracket_close\
    \ = brackets.index(\">\")\n  return (bracket_open - bracket_close) == (bracket_open\
    \ + bracket_close - 1)\nend", "  brackets.gsub(/</) do |open_bracket|\n    if\
    \ @brackets.include?(open_bracket)\n      correct_bracketing(@brackets[open_bracket]\
    \ + \">\")\n    elsif @brackets.include?(open_bracket + \">\")\n      correct_bracketing(@brackets[open_bracket\
    \ + 1] + \"<\")\n    else\n      true\n    end\n  end\nend", "    brackets = brackets.to_s\n\
    \    stack = []\n    for c in brackets\n        if c == \"<\"\n            stack\
    \ << c\n        elsif c == \">\"\n            if stack.last(2) == \"<<\"\n   \
    \             stack.pop\n            else\n                stack.pop >> stack.last(2)\
    \ << c\n            end\n        else\n            stack << c\n        end\n \
    \   end\n    stack.empty?\nend", "  brackets.scan(/[\\<\\>]/ ) { |m| break false\
    \ if m == \"<\" ; break true if m == \">\" }\n  true\nend", "    brackets_count\
    \ = brackets.count(\"<<\") # count the number of \"<<\"\n    no_of_closing_brackets\
    \ = brackets.count(\"->\")\n    \n    opening_brackets_open = brackets.count(\"\
    <\")\n    opening_brackets_close = brackets.count(\">\")\n    \n    closing_open\
    \ = brackets_count - opening_brackets_close\n    closing_close = no_of_closing_brackets\
    \ - opening_brackets_close\n    \n    \n    if closing_open > closing_close\n\
    \        return closing_open < closing_close\n    else\n        return closing_close\
    \ < closing_open\n    end \nend", '  brackets = brackets.to_s', "  brackets =\
    \ brackets.to_s\n  # Don't do anything if there are no ( or ) in brackets\n  return\
    \ brackets.index(\"<\") == brackets.index(\">\") \nend\n</cell>\n<text>\nNow let's\
    \ write a get_adjacent_characters function, which takes a string and returns the\
    \ set of characters that come immediately after it. The following test should\
    \ return \"[]\".", "  # Don't try to parse HTML with regexes.\n  if brackets =~\
    \ /^<.*>$/ then\n    # Make sure the brackets are well formatted.\n    return\
    \ brackets =~ /^(<<?[<>]?>>)$/\n  else\n    # Split the brackets string into its\
    \ elements.\n    opening_brackets = brackets[1, 1].split('<<')\n    closing_brackets\
    \ = brackets[-2, -2].split('>>')", "    return brackets =~ /^<|>$/\nend\n</cell>\n\
    <code language=julia-1.5>", "    i = 0\n    open_bracket = brackets[0]\n    correct_bracketing\
    \ = False\n    while i < len(brackets)\n        if open_bracket[-1] == brackets[i]\n\
    \            correct_bracketing = True\n            i += 1\n        else\n   \
    \         i += 1\n    end\n    correct_bracketing\nend", "  # Create an array\
    \ containing all the valid bracketing pairs.\n  pairs = []\n  \n  # Iterate over\
    \ the array and add the opening bracket to each pair.\n  brackets.each_char do\
    \ |b|\n    pairs << \"<#{b}>\"\n  end\n  \n  # Iterate over the array and add\
    \ the closing bracket to each pair.\n  pairs.reverse_each do |pair|\n    brackets.gsub(pair)\
    \ do |b|\n      b == \"<\" ? \">\" : b\n    end\n  end\nend", "    brackets =\
    \ brackets.gsub(\"[\", \"\")\n    brackets = brackets.gsub(\"]\", \"\")\n    brackets\
    \ = brackets.gsub(\"(<\", \"<\")\n    brackets = brackets.gsub(\">>\", \">\")\n\
    \    return brackets.gsub(\"</?(/?)>\", \"\") == \"\"\nend", "  return brackets.count(\"\
    <\") % 2 == 0 and brackets.count(\">\") % 2 == 0\nend", "  # Only change brackets\
    \ that are actually brackets.\n  return brackets =~ /\\(/\nend", "  brackets =\
    \ brackets.dup\n  opening = brackets.index(\"<\")\n  closing = brackets.index(\"\
    >\")\n  return opening < closing and opening != 0\nend", "  return brackets ==\
    \ \"<\" or brackets == \">\"\nend", "  brackets.chars.each_with_index do |char,\
    \ index|\n    return false unless char == \">\" && brackets.chars[index-1] ==\
    \ \">\"\n    return false unless char == \"<\" && brackets.chars[index+1] == \"\
    <\"\n    return false unless char == \"<\" && brackets.chars[index-1] == \">\"\
    \n    return false unless brackets.chars[index] == \">\" && brackets.chars[index+1]\
    \ == \"<\"\n  end\n  return true\nend", "  brackets.count(\"<\") == 0\nend", " \
    \ brackets.split('><') - brackets.split('<')\nend", "  brackets.split(//)\n  brackets.each_char\
    \ do |c|\n    return false if (c == '<' && brackets.slice!(0) == '>')\n    return\
    \ false if (c == '>' && brackets.slice!(-1) == '<')\n  end\n  true\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nHi Henrik, Thank you for your response! I understand\
    \ that I can have more efficient solutions, but I was wondering if there was a\
    \ more \"pythonic\" way of doing this. Also, I'm a little confused about your\
    \ use of \"<<<\". What does that do?\n<|/ c |>\n<| c |>\nAh, I just realized that\
    \ you're using a regular expression to split up your string. I'm assuming that's\
    \ why you used the split method. I'd be interested to know if there's a more efficient\
    \ way to do this. Also, what is the difference between splitting a string and\
    \ splitting a regex?\n<|/ c |>\n<| c |>\n`split` takes a string as input and returns\
    \ a list of strings; `split` takes a regexp as input and returns a list of strings\
    \ that match the regexp. You want to split your input string by `<` and `>` characters.\
    \ You have a single `<` and a single `>`, so you can just split by `<` and `>`.\
    \ `<<<` is a heredoc: see http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_expressions.html#s42\n\
    <|/ c |>\n<| c |>\nOh, I see. So that means `split` is a method of the String\
    \ class. I haven't seen that syntax before. Thank you for letting me know that.\
    \ I guess it didn't exist when I was looking at some older ruby code.\n<|/ c |>\n\
    <| a tags=ruby,python,regex |>\nOne way to do the same thing in Python would be:\n\
    <code>", "  brackets.each_index do |i|\n    if brackets[i] == '<'\n      next\n\
    \    end\n    if brackets[i] == '>'\n      break\n    end\n    return false if\
    \ brackets[i] != brackets[i+1]\n  end\n  true\nend", "  brackets.scan(/\\(.*\\\
    )|\\[.*\\]|{.*\\}/m) do |left|\n    right.scan(/\\(.*\\)|\\[.*\\]|{.*\\}/m) do\
    \ |right|\n      return left == right\n    end\n  end\n  false\nend", "  # implement\
    \ as described above\nend\n</pre>", "  return brackets.gsub(/<|>|&/, \"\") ==\
    \ \"\"\nend\n</code>\n<|/ a |>\n<| c |>\nI suppose the above will fail for `<<>>`\
    \ though (as that is valid) but that is a different issue\n<|/ c |>\n<| c |>\n\
    : It shouldn't, unless I'm mistaken.\n<|/ c |>\n<| c |>\n`<<>>` is not valid.\
    \ `<<><>>` is. In fact, OP needs to clarify what he meant by valid input\n<|/\
    \ c |>\n<| c |>\n: Sorry, I missed that part. OP can clarify if he's okay with\
    \ it or not.\n<|/ c |>\n<| c |>\n: I've updated my answer to include a check for\
    \ the empty string.\n<|/ c |>\n<| a dscore=0 |>\nThis may be an interesting way\
    \ to think about it, but I think that if your goal is to validate a string, then\
    \ why not just count the characters that are in each of the brackets and make\
    \ sure it's consistent with the number of opening and closing brackets?\n<code>",
  "  brackets.scan(/<|>|\\(|\\)/ do |m|\n    char = m.matched[0]\n    next unless\
    \ char == \">\" || char == \"<\" || char == \"(\" || char == \")\"\n    stack\
    \ = brackets_stack.dup\n    stack.push [char, stack.size] unless stack.empty?\n\
    \    next unless stack.size == 2\n    stack.last.last.last == \">\" || stack.last.last.last\
    \ == \"<\" or\n      (stack.last.last.last == \"(\" && stack.size > 1) or\n  \
    \    (stack.last.last.last == \")\" && stack.size == 1)\n    stack.clear\n   \
    \ stack.last.last == \"(\" ? stack.last.push(\")\") :\n      (stack.last.last\
    \ == \")\" ? stack.last.push(\"(\") :\n        (stack.last.last == \"<\" ? stack.last.push(\"\
    <\") : stack.last.push(\">\")))\n    stack.last.last == \")\" ? stack.last.last.last\
    \ == \"(\" ? stack.last.pop : :\n      (stack.last.last == \"<\" ? stack.last.last.last\
    \ == \"(\" ? stack.last.pop : :\n        (stack.last.last == \"<\" && stack.last.last.last\
    \ == \"(\" ? stack.last.pop : :\n          stack.last.last == \"<\" && stack.last.last\
    \ == \"<\" ? stack.last.pop : :\n            stack.last.last == \"<\" && stack.last.last\
    \ == \"<\" && stack.last.last.last == \"(\" ? stack.last.pop : :\n           \
    \   stack.last.last == \"<\" && stack.last.last == \"<\" && stack.last.last ==\
    \ \"<\" && stack.last.last.last == \"(\" ? stack.last.pop : :\n              \
    \  stack.last.last == \"<\" && stack.last.last == \"<\" && stack.last.last ==\
    \ \"<\" && stack.last.last == \"<\" && stack.last.last.last == \"(\" ? stack.last.pop\
    \ : :\n                  stack.last.last == \"<\" && stack.last.last == \"<\"\
    \ && stack.last.last == \"<\" && stack.last.last == \"<\" && stack.last.last.last\
    \ == \"<\" && stack.last.pop : :\n                    stack.last.last == \"<\"\
    \ && stack.last.last == \"<\" && stack.last.last == \"<\" && stack.last.last ==\
    \ \"<\" && stack.last.last.last == \"<\" && stack.last.pop : :\n             \
    \         stack.last.last == \"<\" && stack.last.last == \"<\" && stack.last.last\
    \ == \"<\" && stack.last.last == \"<\" && stack.last.last.last == \"<\" && stack.last.pop\
    \ : ", "  brackets.scan(/^<+/) {|m| return false }\n  brackets.scan(/[\\<\\>]+/)\
    \ {|m| return true }\n  false\nend", "  brackets = brackets.split(\"\")\n  brackets.each\
    \ do |b|\n    if b == \"<\"\n      brackets.delete_at(brackckets.index(b))\n \
    \     break\n    elsif b == \">\"\n      brackets.delete_at(brackckets.index(b)\
    \ + 1)\n      break\n    end\n  end\n  brackets.empty?\nend", "  brackets = brackets.chars\n\
    \  return brackets.inject(:>).all?(&:==)\nend", "  brackets = brackets.to_s\n\
    \  # If we are given an empty string then there is nothing to do so return.\n\
    \  unopened_brackets = brackets.empty?\n  return unopened_brackets == false &&\
    \ brackets.none? do |char|\n    opening = char == \"<\"\n    closing = char ==\
    \ \">\"\n    openings_count = brackets.count(opening)\n    closesing_count = brackets.count(closing)\n\
    \    unopened_brackets = openings_count == closesing_count\n  end\nend", "  brackets\
    \ = brackets.to_s\n  openings = brackets.scan(/[<>]/).to_a\n  closings = brackets.scan(/[<>]/).to_a\n\
    \  all_closings = closings.uniq.map {|x| [x, x]}\n  closings_sorted = closings.sort\
    \ {|a,b| a.first <=> b.first}\n  openings_sorted = openings.sort {|a,b| a.first\
    \ <=> b.first}\n  openings_sorted.empty? && closings_sorted.empty? ? true : openings_sorted.all?\
    \ {|o| closings_sorted.include?(o)} && openings_sorted.all? {|c| closings_sorted.include?(c)}\
    \ && openings_sorted.all? {|o,c| openings.include?(o) && closings.include?(c)}\n\
    end", "    bracket_pos = brackets.index(\"<\")\n    while bracket_pos > 0\n  \
    \      bracket_pos -= 1\n        if brackets[bracket_pos] == \"<\"\n         \
    \   brackets[bracket_pos] = \">\"\n    end\n    bracket_pos = brackets.index(\"\
    >\")\n    while bracket_pos < brackets.length - 1\n        bracket_pos += 1\n\
    \        if brackets[bracket_pos] == \">\"\n            brackets[bracket_pos]\
    \ = \"<\"\n    end\nend", "  brackets.gsub!(\"<\", \"\")\n  brackets.gsub!(\"\
    >\", \"\")\n  brackets.chars.all? do |c|\n    brackets.include?(c)\n  end\nend",
  "    stack = []\n    last = \"\"\n    opening_brackets = 0\n    closing_brackets\
    \ = 0\n    for c in brackets\n        if c == \"<\"\n            if last == \"\
    <\"\n                opening_brackets += 1\n            else\n               \
    \ opening_brackets = 1\n            stack << c\n            last = c\n       \
    \ if c == \">\"\n            if last == \">\"\n                closing_brackets\
    \ += 1\n            else\n                closing_brackets = 1\n            stack\
    \ << c\n            last = c\n        if opening brackets == closing_brackets\n\
    \            stack << c\n            stack.reject {|e| e == \"<\"}\n         \
    \   opening_brackets, closing_brackets, last, stack.empty?\n        end\n    end\n\
    \    stack.empty?\nend", "  brackets = brackets.chars\n  opening_brackets = Array.new(brackets.length,\
    \ false)\n  closing_brackets = Array.new(brackets.length, false)\n  i = 0\n  while\
    \ i < brackets.length\n    opening_brackets[i] = (brackets[i] == \"<\")\n    closing_brackets[i]\
    \ = (brackets[i] == \">\")\n    i += 1\n  return opening_brackets.product(closing_brackets)\n\
    end", "  brackets.scan(/</).inject(true){|a, e| a && e[1]}\nend", "  brackets.scan(/([^>])>\\\
    1|[^<>]>\\1|<([^>])\\1|<\\1([^>])/) do |match|\n    return false unless match[0]\
    \ == '>' || match[0] == '<'\n  end\n  true\nend", "  return brackets =~ /\\A<[<>]+\\\
    Z/\nend", "    opening_brackets, closing_brackets = brackets.split(\">\")\n  \
    \  opening_brackets = opening_brackets.split(\"<\")\n    closing_brackets = closing_brackets.split(\"\
    <\")\n    \n    # Check that every opening bracket has a corresponding closing\
    \ bracket\n    correct_bracketing = True\n    for opening_bracket in opening_brackets:\n\
    \        if opening_bracket != closing_brackets[0]:\n            correct_bracketing\
    \ = False\n            break\n    \n    # Check that every closing bracket has\
    \ a corresponding opening bracket\n    correct_bracketing = True\n    for closing_bracket\
    \ in closing_brackets:\n        if closing_bracket != opening_brackets[0]:\n \
    \           correct_bracketing = False\n            break\n    \n    return correct_bracketing\n\
    \    ", "  return brackets =~ /(\\<|\\>)/\nend", "  return brackets =~= /^<*>$/\
    \ ? brackets =~= /^<>$/ : brackets =~= /^<\\/\\/.*\\/>$/ ? brackets =~= /^<\\\
    /\\*.*\\*\\/>$/ : brackets =~= /^<\\/*.*\\/*\\/>$/ ? brackets =~= /^<.*\\/>$/\
    \ : brackets =~= /^<\\/?.*\\/>$/ ? brackets =~= /^<.*\\/*>$/ : brackets =~= /^<.*\\\
    /*\\/>$/ ? brackets =~= /^<.*>/\nend", "  # Handle empty brackets by returning\
    \ True\n  (brackets == \"\" or brackets[0] == \"<\" and brackets[-1] == \"<\"\
    ) or return True\n  \n  # Handle a bracket that begins on the first character\
    \ but ends on the last character\n  return brackets.index(\"<\") == 0 and brackets.rindex(\"\
    <\") == len(brackets)-1\nend\n</code>\n<|/ a dscore=2 tags=ruby,string |>\n<|\
    \ a tags=ruby,string |>\nHere is my solution. Hope it helps!\n<code>", '  brackets
    = brackets.to_s', "  brackets.gsub!(/\\(([^)]*)\\)/) { |s| correct_bracketing(s)\
    \ }\n  brackets.gsub!(/(\\<([^>]*)\\>)/) { |s| correct_bracketing(s) }\n  brackets\
    \ == brackets.gsub(/[\\<\\>]/, '').gsub(/[\\[\\]]/, '')\nend", "  bracket_opening\
    \ = false\n  bracket_closing = false\n  bracket_opened_count = false\n  bracket_closed_count\
    \ = false\n  brackets.each_char do |char|\n    if char == \"<\"\n      bracket_opening\
    \ = true\n    elsif char == \">\"\n      bracket_closing = true\n    end\n  end",
  "  brackets = brackets.split(\"<\").to_a #split on \"<\"\n  brackets.reverse!",
  "    brackets.chars.each do |char|\n        if open_brackets.include?(char)\n  \
    \          open_brackets.delete(char)\n        else\n            open_brackets\
    \ << char\n        end\n        if close_brackets.include?(char)\n           \
    \ close_brackets.delete(char)\n        end\n    end\n    open_brackets.blank?\
    \ == close_brackets.blank?\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>",
  "  return brackets.split('>').each_cons(2) do |(a,b)|\n    a == '<' and b == '>'\
    \ and return false or b == '<' and a == '>' and return false\n  end\nend", " \
    \ brackets.split(//).all? { |s| s.split(\"<\").all? { |e| e.split(\">\").all?\
    \ { |f| f != \"<\" || f != \">\" } } } \nend", "    brackets = brackets.strip\n\
    \    return brackets.chars.all? { |char| char == \"<\" || char == \">\" }\nend",
  "  brackets = brackets.to_s\n  (l,r) = brackets.scan(/[<>]/)\n  l == r\nend", " \
    \ brackets.scan(/[^<>]+/) { |m| m.scan(/[^<>]+/).empty? }\nend", "  return brackets\
    \ =~ /\\(.*\\)/\nend", "  brackets.gsub!(\"<\",\"\").gsub!(\">\",\"\")\n  opening\
    \ = brackets.scan(/[<>]/)\n  closing.inject(0) do |sum, open|\n    sum + 1 if\
    \ opening == open\n  end == 0\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby |>\n\
    <| c |>\nThanks for the explanation - I'm relatively new to ruby, so your help\
    \ is very appreciated.\n<|/ c |>\n<| c |>\nThe only thing that seems to me to\
    \ be missing here is the explanation of what gsub!() is doing.\n<|/ c |>\n<| c\
    \ |>\ngsub! returns the receiver. It operates on self and replaces every occurrence\
    \ of something with something else, in this case, removing all the \"<\" and \"\
    >\" characters from brackets. In this case, it is replacing every \"<\" with \"\
    \" (nothing) and every \">\" with \"\" (nothing).\n<|/ c |>\n<| a |>\nI believe\
    \ it is more efficient to use scan instead of gsub!\n<code>", "  brackets.scan(/\\\
    (.*?\\)|\\[.*?\\]|{.*?}|\\(.*?\\)|{.*?}|<.*?>|</.*?>/).all? { |m| m =~ /^<.*?>$/\
    \ }\nend", "  # replace each opening bracket with its corresponding closing bracket\n\
    \  brackets.gsub!(/<|>/) {|m| \"<#{m}>\"}\n  return brackets == \"<\"\nend", " \
    \ # Write your code here.\n  return\nend", "  if brackets == \"<\"\n    return\
    \ False\n  else\n    return brackets.gsub(\"<|>\", \"\").gsub(\"<<\", \"<\").gsub(\"\
    <>\", \">\") == brackets\nend", "  brackets = brackets.to_s\n  brackets.gsub!(/[\\\
    [\\]]/, '\\>')\n  brackets.gsub!(/[\\[\\]]/, '\\<')\n  brackets.gsub!(/[\\[\\\
    ]]/, '\\>')\n  brackets.gsub!(/[\\[\\]]/, '\\<')\n  brackets.gsub!(/[\\[\\]]/,\
    \ '\\>')\n  brackets.gsub!(/[\\[\\]]/, '\\<')\n  brackets.gsub!(/[\\[\\]]/, '\\\
    >')\n  brackets.gsub!(/[\\[\\]]/, '\\<')\n  brackets.gsub!(/[\\[\\]]/, '\\>')\n\
    \  brackets.gsub!(/[\\[\\]]/, '\\<')\n  brackets.gsub!(/[\\[\\]]/, '\\>')\n  brackets.gsub!(/[\\\
    [\\]]/, '\\<')\n  brackets.gsub!(/[\\[\\]]/, '\\>')\n  brackets.gsub!(/[\\[\\\
    ]]/, '\\<')\n  brackets.gsub!(/[\\[\\]]/, '\\>')\n  brackets.gsub!(/[\\[\\]]/,\
    \ '\\<')\n  brackets.gsub!(/[\\[\\]]/, '\\>')\n  brackets.gsub!(/[\\[\\]]/, '\\\
    <')\n  brackets.gsub!(/[\\[\\]]/, '\\>')\n  brackets.gsub!(/[\\[\\]]/, '\\<')\n\
    \  brackets.gsub!(/[\\[\\]]/, '\\>')\n  brackets.gsub!(/[\\[\\]]/, '\\<')\n  brackets.gsub!(/[\\\
    [\\]]/, '\\>')\n  brackets.gsub!(/[\\[\\]]/, '\\<')\n  brackets.gsub!(/[\\[\\\
    ]]/, '\\>')\n  brackets.gsub!(/[\\[\\]]/, '\\<')\n  brackets.gsub!(/[\\[\\]]/,\
    \ '\\>')\n  brackets.gsub!(/[\\[\\]]/, '\\<')\n  brackets.gsub!(/[\\[\\]]/, '\\\
    >')\n  brackets.gsub!(/[\\[\\]]/, '\\<')\n  brackets.gsub!(/[\\[\\]]/, '\\>')\n\
    \  brackets.gsub!(/[\\[\\]]/, '\\<')\n  brackets.gsub!(/[\\", "    brackets_length\
    \ = brackets.length\n    brackets_array = brackets.split(\"\").map {|x| x.to_i}\n\
    \    brackets_array.each do |index|\n        if index >= brackets_length\n   \
    \         return false\n        end\n        other_char = brackets_array[index\
    \ + 1]\n        if other_char\n            return false\n        end\n    end\n\
    \    return true\nend", "  brackets.split('>').each do |bracket|\n    return false\
    \ unless bracket.include?(\"<\")\n    return true if bracket.include?(\">\")\n\
    \  end\n  true\nend\n</code>\n<|/ a |>\n<| c |>\nYour `correct_bracketing` method\
    \ only works for the simplest of cases. Consider `correct_bracketing(\"<><>\"\
    )`. It returns true. Notice that it returns true for `>><<` which is not correct\
    \ for most applications. You need to split the string into its parts and return\
    \ true only if *every part* is correctly bracket.\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>", "  brackets.scan(/([<>])/) do\n    brackets = $1.to_s\n    brackets.scan(/([<>])/)\
    \ do\n      brackets = $1.to_s\n      return brackets == brackets.reverse\n  \
    \  end\n  end\n  false\nend", "    stack = brackets.scan(/(<|>)*/).flatten\n \
    \   return stack.length == 0\nend\n</pre>\n      </p>\n      <p>\n        <strong>Recursive\
    \ solution:</strong>\n      </p>\n      <pre class=\"code ruby\">", "  if brackets\
    \ == \"<\"\n    true\n  else\n    if brackets == \"<>\"\n      true\n    else\n\
    \      if brackets == \"<>\"\n        true\n      else\n        false\n      end\n\
    \    end\n  end\nend\n</pre>\n<p>Write a Ruby method <code>correct_bracketing(s)</code>\
    \ that takes a string <code>s</code>\nas input and determines whether or not the\
    \ input is valid bracketing. If it's valid,\nit should return a string that is\
    \ the same as the input. If the input is invalid, return <code>nil</code>.</p>\n\
    <p>For example, <code>correct_bracketing(\"<\")</code> should return <code>\"\
    <\"</code>. While\n<code>correct_bracketing(\"<<><>>\")</code> should return <code>\"\
    &lt;&gt;&lt;&gt;\"</code>.</p>\n<h2>Examples</h2>\n<pre>", "  brackets = brackets.gsub('>','>')\n\
    \  brackets = brackets.gsub('<','<')\n  brackets = brackets.gsub('>>','>>')\n\
    \  brackets = brackets.gsub('<<','<<')\n  brackets = brackets.gsub('>>>','>>>')\n\
    \  brackets = brackets.gsub('>>>','>>>')\n  brackets = brackets.gsub('<<<','<<<')\n\
    \  brackets = brackets.gsub('>>>>','>>>>')\n  brackets = brackets.gsub('>>>>>','>>>>>')\n\
    \  brackets = brackets.gsub('<<>>','<<>>')\n  brackets = brackets.gsub('<<<>>','<<<>>')\n\
    \  brackets = brackets.gsub('<>>','<>>')\n  brackets = brackets.gsub('<>>>','<>>>')\n\
    \  brackets = brackets.gsub('<>>>>>>','<>>>>>>')\n  brackets = brackets.gsub('>>>>>>>>>','>>>>>>>>>')\n\
    \  brackets = brackets.gsub('>>>','>>>')\n  brackets = brackets.gsub('<<','<<')\n\
    \  brackets = brackets.gsub('>>','>>')\n  brackets = brackets.gsub('>>>>','>>>>')\n\
    \  brackets = brackets.gsub('<<<','<<<')\n  brackets = brackets.gsub('>>>>>','>>>>>')\n\
    \  brackets = brackets.gsub('<<>>','<<>>')\n  brackets = brackets.gsub('<<<>>','<<<>>')\n\
    \  brackets = brackets.gsub('<>>','<>>')\n  brackets = brackets.gsub('<>>>','<>>>')\n\
    \  brackets = brackets.gsub('<>>>>>>','<>>>>>>')\n  brackets = brackets.gsub('>>>>>>>>>','>>>>>>>>>')\n\
    \  brackets = brackets.gsub('>>>','>>>')\n  brackets = brackets.gsub('<<','<<')\n\
    \  brackets = brackets.gsub('>>','>>')\n  brackets = brackets.gsub('>>>>','>>>>')\n\
    \  brackets = brackets.gsub('<<<','<<<')\n  brackets = brackets.gsub('>>>>>','>>>>>')\n\
    \  brackets = brackets.gsub('<<>>','<<>>')\n  brackets = brackets.gsub('<<<>>','<<<>>')\n\
    \  brackets = brackets.gsub('<>>','", "  return brackets =~ /\\A(<\\?|[>\\&])\\\
    Z/ && !brackets =~ /\\A(<\\?|[>\\&])\\Z/\nend", "  brackets = brackets.to_s\n\
    \  brackets.scan(/[^<]+/) do |left|\n    brackets.scan(/[^>]+/) do |right|\n \
    \     brackets == left.gsub!(left, \"<\") + right.gsub!(right,\">\")\n    end\n\
    \  end\nend\n</code>\n<|/ a tags=regex,ruby |>\n<| c |>\nNice solution! But it\
    \ does fail for input such as \"<><<\" as it will yield \"<><<\". Do you see a\
    \ way to fix this with your approach?\n<|/ c |>\n<| c |>\nI just fixed it :)\n\
    <|/ c |>\n<| c |>\n`<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><",
  "  brackets.gsub!(/>/, \">\\n<\")\n  brackets.gsub!(/</, \"\\n<\")\n  brackets.gsub!(/<>/,\
    \ \"\\n<\")\n  brackets.gsub!(/\\n<\\//, \"\\n<\")\n  brackets.gsub!(/\\//, \"\
    >\")\n  brackets.gsub!(/\\n>\\//, \"\\n>\")\n  brackets.gsub!(/\\n>/, \"\\n>\"\
    )\n  brackets.gsub!(/\\n>/>, \"\\n>\")\n  brackets.gsub!(/\\n>/>/, \"\\n>\")\n\
    \  brackets.gsub!(/\\//, \"/\")\n  brackets.gsub!(/\\n>\\//, \"\\n\")\n  brackets.gsub!(/\\\
    n>/, \"\\n\")\n  brackets.gsub!(/\\n>/>, \"\\n\")\n  brackets.gsub!(/\\n>/>/,\
    \ \"\\n\")\n  brackets.gsub!(/\\n>\\n<\\//, \"\\n\")\n  brackets.gsub!(/\\n>\\\
    n<\\n/, \"\\n\")\n  brackets.gsub!(/\\n>\\n<\\n>\\n/, \"\\n\")\n  brackets.gsub!(/\\\
    n>\\n<\\n>/, \"\\n\")\n  brackets.gsub!(/\\n>\\n<\\n>/, \"\\n\")\n  brackets.gsub!(/\\\
    n>\\n<\\n>/, \"\\n\")\n  brackets.gsub!(/\\n>\\n<\\n>\\n/, \"\\n\")\n  brackets.gsub!(/\\\
    n>\\n<\\n>/, \"\\n\")\n  brackets.gsub!(/\\n>\\n<\\n>\\n/, \"\\n\")\n  brackets.gsub!(/\\\
    n>\\n<\\n>/, \"\\n\")\n  brackets.gsub!(/\\n>\\n<\\n>/, \"\\n\")\n  brackets.gsub!(/\\\
    n>\\n<\\n>\\n/, \"\\n\")\n  brackets.gsub!(/\\n>\\n<\\n>/, \"\\n\")\n  brackets.gsub!(/\\\
    n>\\n<\\n>\\n/, \"\\n\")\n  brackets.gsub!(/\\n>\\n<\\n>/, \"\\n\")\n  brackets.gsub!(/\\\
    n>\\n<\\n>/, \"\\n\")\n  brackets.gsub!(/\\n>\\n<\\n>\\n/, \"\\n\")\n  brackets.gsub!(/\\\
    n>\\n<\\n>/, \"\\n\")\n  brackets.gsub!(/\\n>\\n<\\n>/, \"\\n\")\n  brackets.gsub",
  "  # Your code here!\n  return false # or true\nend\n</pre>", "  opening_brackets\
    \ = []\n  closing_brackets = []\n  opening_count = 0\n  closing_count = 0\n  brackets.each\
    \ do |b|\n    if b == \"<\"\n      opening_brackets << b\n      opening_count\
    \ += 1\n    elsif b == \">\"\n      closing_brackets << b\n      closing_count\
    \ += 1\n    else\n      opening_brackets << b\n      closing_brackets << b\n \
    \   end\n  end", "    return !brackets.nil? && (brackets =~ /\\A(?:<[<>])*\\Z/)\
    \ && brackets.size != brackets.size/2\nend", "  # Use a stack to check paired\
    \ brackets\n  stack = Stack.new\n  bracket_count = 0\n  # Iterate over string\n\
    \  bracket_str = brackets.split(\"\")\n  bracket_str.each_index do |i|\n    if\
    \ bracket_str[i] == \"<\"\n      stack.push(bracket_str[i - 1])\n      bracket_count\
    \ += 1\n    elsif bracket_str[i] == \">\"\n      if !stack.pop\n        # Close\
    \ bracket found without opening\n        return false\n      else\n        bracket_count\
    \ += 1\n      end\n    end\n  end\n  return bracket_count == brackets.length\n\
    end", "  return brackets =~ /\\<\\>/ ? false : true\nend", "  brackets.scan(/\\\
    <(.*?)\\>/) do |m|\n    next if m.nil?\n    next\n  end # end m.scan\n  brackets.scan(/\\\
    <(.*?)\\>/) do |m|\n    return false unless m.match(/\\<(.*?)\\>/)\n    next\n\
    \  end # end m.scan\n  return true\nend # end correct_bracketing", "    stack\
    \ = []\n    brackets = \"<\" + brackets + \">\"\n    brackets_set = brackets.chars\n\
    \    brackets.each_char do |char|\n        if char == brackets_set.first\n   \
    \         stack << char\n        else\n            popped_char = stack.pop\n \
    \           return char == popped_char if stack.empty?\n        end\n    end\n\
    \    false\nend", "  brackets = brackets.gsub(/</, '&lt;')\n  brackets = brackets.gsub(/</,\
    \ '&lt;')\n  brackets = brackets.gsub(/</, '&lt;')\n  brackets = brackets.gsub(/>/,\
    \ '&gt;')\n  brackets = brackets.gsub(/>/, '&gt;')\n  brackets = brackets.gsub(/>/,\
    \ '&gt;')\n  brackets = brackets.gsub(/[<>]/, '&gt;&lt;')\n  brackets = brackets.gsub(/[<>]/,\
    \ '&gt;&lt;')\n  brackets = brackets.gsub(/[<>]/, '&gt;&lt;')\n  brackets = brackets.gsub(/&lt;/,\
    \ '<')\n  brackets = brackets.gsub(/&lt;/, '<')\n  brackets = brackets.gsub(/&lt;/,\
    \ '<')\n  brackets = brackets.gsub(/&gt;/, '>')\n  brackets = brackets.gsub(/&gt;/,\
    \ '>')\n  brackets = brackets.gsub(/&gt;/, '>')\n  brackets = brackets.gsub(/&gt;/,\
    \ '>')\n  brackets = brackets.gsub(/&gt;/, '>')\n  brackets = brackets.gsub(/&gt;/,\
    \ '>')\n  brackets = brackets.gsub(/&gt;/, '>')\n  brackets = brackets.gsub(/&gt;/,\
    \ '>')\n  brackets = brackets.gsub(/&gt;/, '>')\n  brackets = brackets.gsub(/&gt;/,\
    \ '>')\n  brackets = brackets.gsub(/&gt;/, '>')\n  brackets = brackets.gsub(/&gt;/,\
    \ '>')\n  brackets = brackets.gsub(/&gt;/, '>')\n  brackets = brackets.gsub(/&gt;/,\
    \ '>')\n  brackets = brackets.gsub(/&gt;/, '>')\n  brackets = brackets.gsub(/&gt;/,\
    \ '>')\n  brackets = brackets.gsub(/&gt;/, '>')\n  brackets = brackets.gsub(/&gt;/,\
    \ '>')\n  brackets = brackets.gsub(/&gt;/, '>')\n  brackets = brackets.gsub(/&gt;/,\
    \ '>')\n  brackets = brackets.gsub(/&gt;/, '>')\n  brackets = brackets.gsub(/&gt;/,\
    \ '>')\n  brackets = brackets.gsub(/&gt;/, '>')\n  brackets = brackets.gsub(/&gt;/,\
    \ '>')\n  brackets = brackets.gsub(/&gt;/, '>')\n  brackets = brackets.gsub(/&gt;/,\
    \ '>')\n  brackets = brackets.g", "  brackets = brackets.dup\n  brackets.gsub!(/[<>]>/,\
    \ \"\") # get rid of \"<\" and \">\"\n  brackets.gsub!(/>/, \"\")\n  brackets.gsub!(/<>/,\
    \ \"\")\n  brackets.empty?\nend", "  brackets.gsub!(/\\<<(.*?)\\>\\>/) { |s| s.gsub(/[\\\
    <\\>](?![^<>]*\\>)/, '&lt;&gt;') }\n  brackets.gsub!(/\\<\\<(.*?)\\>\\>\\>/) \
    \  { |s| s.gsub(/[\\<\\>](?![^<>]*\\>)/, '&lt;&gt;') }\n  brackets.gsub!(/\\<\\\
    <(.*?)\\>\\>/)   { |s| s.gsub(/[\\<\\>](?![^<>]*\\>)/, '&lt;&gt;') }\n  brackets.gsub!(/<\\\
    <(.*?)\\>\\>/)   { |s| s.gsub(/[\\<\\>](?![^<>]*\\>)/, '&lt;&gt;') }\n  brackets.gsub!(/<\\\
    <(.*?)\\>\\>/)   { |s| s.gsub(/[\\<\\>](?![^<>]*\\>)/, '&lt;&gt;') }\n  brackets.gsub!(/\\\
    <\\(.*?\\)\\>/)   { |s| s.gsub(/[\\<\\>](?![^<>]*\\>)/, '&lt;&gt;') }\n  brackets.gsub!(/\\\
    <\\(.*?\\)\\>/)   { |s| s.gsub(/[\\<\\>](?![^<>]*\\>)/, '&lt;&gt;') }\n  brackets.gsub!(/<\\\
    (.*?\\)\\>/)   { |s| s.gsub(/[\\<\\>](?![^<>]*\\>)/, '&lt;&gt;') }\n  brackets.gsub!(/<\\\
    (.*?\\)\\>/)   { |s| s.gsub(/[\\<\\>](?![^<>]*\\>)/, '&lt;&gt;') }\n  brackets.gsub!(/\\\
    <.*?\\>/)      { |s| s.gsub(/[\\<\\>](?![^<>]*\\>)/, '&lt;&gt;') }\n  brackets.gsub!(/\\\
    <.*?\\>/)      { |s| s.gsub(/[\\<\\>](?![^<>]*\\>)/, '&lt;&gt;') }\n  brackets.gsub!(/[\\\
    <\\>](?![^<>]*\\>)/, '&lt;&gt;')\n  brackets.gsub!(/[\\<\\>](?![^<>]*\\>)/, '&lt;&gt;')\n\
    \  brackets.gsub!(/", "    brackets.scan(/<|>|[^<>])/) { |x| return false }\n\
    \    true\nend", "  bracket_pairs = {}\n  bracket_pairs[\">\"] = (\"><\")\n  bracket_pairs[\"\
    <\"] = (\"><\")\n  bracket_pairs[\"<<\"] = (\"><>\")\n  bracket_pairs[\">>\"]\
    \ = (\"><>\")", "  bracket_stack = []\n  result = true\n  i = 0\n  while i < brackets.length\n\
    \    if brackets[i] == \"<\"\n      bracket_stack.push brackets[i]\n    elsif\
    \ brackets[i] == \">\"\n      while bracket_stack.length > 0\n        if bracket_stack.pop\
    \ != \"<\"\n          result = false\n          break\n      end\n    end\n  \
    \  i += 1\n  end\n  result\nend", "  brackets = brackets.to_s.chomp\n  open_stack\
    \ = Stack.new\n  close_stack = Stack.new\n  open_stack.push brackets[0]\n  close_stack.push\
    \ brackets[1]\n  until open_stack.empty? || close_stack.empty?\n    open_bracket\
    \ = open_stack.pop\n    close_bracket = close_stack.pop\n    if open_bracket ==\
    \ close_bracket\n      return true\n    end\n    unless open_bracket == \"<\"\
    \ && close_bracket == \">\"\n      return false\n    end\n    unless open_bracket\
    \ == \">\" && close_bracket == \"<\"\n      return false\n    end\n    open_stack.push\
    \ open_bracket\n    close_stack.push close_bracket\n  end\n  false\nend", "  brackets.gsub!(/(<)>(?=<)/,\
    \ \"\\\\2\\\\3\") \n  brackets.gsub!(/(<)>(?=<)/, \"\\\\1\\\\3\") \n  brackets.gsub!(/(<)/,\
    \ \"\\\\1\") \n  brackets.gsub!(/(>)/, \"\\\\1\") \n  brackets.gsub!(/(<)>(?=<)/,\
    \ \"\\\\1\\\\3\") \n  brackets.gsub!(/(<)>(?=<)/, \"\\\\2\\\\3\") \n  brackets.gsub!(/(<)/,\
    \ \"\\\\1\") \n  brackets.gsub!(/(>)/, \"\\\\1\") \n  brackets.gsub!(/(<)>(?=<)/,\
    \ \"\\\\1\\\\3\") \n  brackets.gsub!(/(<)>(?=<)/, \"\\\\2\\\\3\") \n  brackets.gsub!(/(<)/,\
    \ \"\\\\1\") \n  brackets.gsub!(/(>)/, \"\\\\1\") \n  brackets.gsub!(/(<)>(?=<)/,\
    \ \"\\\\1\\\\3\") \n  brackets.gsub!(/(<)>(?=<)/, \"\\\\2\\\\3\") \n  brackets.gsub!(/(<)/,\
    \ \"\\\\1\") \n  brackets.gsub!(/(>)/, \"\\\\1\") \n  brackets.gsub!(/(<)>(?=<)/,\
    \ \"\\\\1\\\\3\") \n  brackets.gsub!(/(<)>(?=<)/, \"\\\\2\\\\3\") \n  brackets.gsub!(/(<)/,\
    \ \"\\\\1\") \n  brackets.gsub!(/(>)/, \"\\\\1\") \n  brackets.gsub!(/(<)>(?=<)/,\
    \ \"\\\\1\\\\3\") \n  brackets.gsub!(/(<)>(?=<)/, \"\\\\2\\\\3\") \n  brackets.gsub!(/(<)/,\
    \ \"\\\\1\") \n  brackets.gsub!(/(>)/, \"\\\\1\") \n  brackets.gsub!(/(<)>(?=<)/,\
    \ \"\\\\1\\\\3\") \n  brackets.gsub!(/(<)>(?=<)/, \"\\\\2\\\\3\") \n  brackets.gsub!(/(<)/,\
    \ \"\\\\1\") \n  brackets.gsub!(/(>)/, \"\\\\1\") \n  brackets.gsub!(/(<)>(?=<)/,\
    \ \"\\\\1\\\\3\") \n  brackets.gsub!(/(<)>(?=<)/, \"\\\\2", "    brackets.reverse!\n\
    \    openings = brackets.scan(/[^<]*/)\n    closings = brackets.scan(/[^>]*/)\n\
    \    if openings == closings\n        return brackets.empty?\n    end\n    if\
    \ openings.length != closings.length\n        return false\n    openings.each\
    \ do |opening|\n        closings.each do |closing|\n            return closing\
    \ == opening if closing < opening\n        end\n    end\n    false\nend", "  brackets.chars.each\
    \ do |c|\n    if (brackets[c] == \">\" && brackets[c + 1] == \"<\")\n      return\
    \ false\n    end\n  end\n  return true\nend\n  ", "  # Initialize a stack to store\
    \ seen opening brackets.\n  stack = []\n  # Traverse the given brackets.\n  brackets.each\
    \ do |char|\n    # Add char to the stack unless it is an opening bracket.\n  \
    \  if char == \"<\"\n      stack << char\n    elsif char == \">\"\n      # Remove\
    \ top element of stack if stack is empty.\n      stack.pop if stack.empty?\n \
    \   else\n      # Otherwise, if stack is not empty, then top element is not opening.\n\
    \      return false if stack.empty?\n      # Remove top element of stack if stack\
    \ is not empty.\n      stack.pop if stack.any?\n    end\n  end\n  # If stack is\
    \ empty, return true.\n  return stack.empty?\nend", "  brackets = brackets.to_s\n\
    \  brackets.sub!(/[<>]/,'')\n  brackets.gsub!(/<<<>>/,'<=>')\n  brackets.gsub!(/><<>/,'=><')\n\
    \  brackets.gsub!(/<>/,'')\n  brackets.gsub!(/=<>/,'=>')\n  brackets.gsub!(/>=<>/,'=><')\n\
    \  brackets.gsub!(/=/,'=>')\n  brackets.gsub!(/<>/,'=>')\n  brackets.gsub!(/=>/,'=>')\n\
    \  brackets.gsub!(/=></,'=><')\n  brackets.gsub!(/<=>/,'=>')\n  brackets.gsub!(/<=>/,'=>')\n\
    \  brackets.gsub!(/=>/,'=>')\n  brackets.gsub!(/=/,'=>')\n  brackets.gsub!(/<<<>>/,'<=>')\n\
    \  brackets.gsub!(/><<>/,'=><')\n  brackets.gsub!(/<<<>>/,'<=>')\n  brackets.gsub!(/=<>/,'=>')\n\
    \  brackets.gsub!(/<>/,'')\n  brackets.gsub!(/=<>/,'=>')\n  brackets.gsub!(/>=<>/,'=><')\n\
    \  brackets.gsub!(/>=<>/,'=><')\n  brackets.gsub!(/=/,'=>')\n  brackets.gsub!(/<>/,'=>')\n\
    \  brackets.gsub!(/=>/,'=>')\n  brackets.gsub!(/<=>/,'=>')\n  brackets.gsub!(/=<=>/,'=><')\n\
    \  brackets.gsub!(/=<=>/,'=><')\n  brackets.gsub!(/>=<=>/,'=><')\n  brackets.gsub!(/>=<=>/,'=><')\n\
    \  brackets.gsub!(/=<=>/,'=><')\n  brackets.gsub!(/=<=>/,'=><')\n  brackets.gsub!(/>=<=>/,'=><')\n\
    \  brackets.gsub!(/>=<=>/,'=><')\n  brackets.gsub!(/=<=>/,'=><')\n  brackets.gsub",
  "  brackets.gsub!(/(<+>)$/, '\\\\1')\n  brackets.each_char.with_index do |char,\
    \ i|\n    unless char == \">\"\n      unless char == \"<\"\n        brackets.slice!(i,\
    \ 1)\n      end\n    end\n  end\n  brackets == brackets.reverse\nend", "    #\
    \ initialize a boolean value which tells if bracketing has been\n    # done correctly\n\
    \    correct = False\n    \n    # split brackets string by \"<\" and \">\" characters\n\
    \    brackets = brackets.split(\"<\")", "  brackets = brackets.to_s\n  brackets\
    \ = brackets.chars.to_a.join\n  brackets = brackets.gsub(/[\\[\\]]/,'')\n  brackets\
    \ = brackets.gsub(/[<>]/,'')\n  brackets = brackets.gsub(/[\\{<]/,'')\n  brackets\
    \ = brackets.gsub(/[\\}>]/,'')\n  brackets = brackets.gsub(/[\\{]/,'{')\n  brackets\
    \ = brackets.gsub(/[\\}]/,'}')\n  brackets = brackets.gsub(/[\\|]/,'|')\n  brackets\
    \ = brackets.gsub(/[\\<|]/,'<')\n  brackets = brackets.gsub(/[\\>]/,'>')\n  brackets\
    \ = brackets.gsub(/[\\{]/,'{')\n  brackets = brackets.gsub(/[\\}]/,'}')\n  brackets\
    \ = brackets.gsub(/[\\|]/,'|')\n  brackets = brackets.gsub(/[\\<|]/,'<')\n  brackets\
    \ = brackets.gsub(/[\\>]/,'>')\n  brackets = brackets.gsub(/[\\{]/,'{')\n  brackets\
    \ = brackets.gsub(/[\\}]/,'}')\n  brackets = brackets.gsub(/[\\<|]/,'<')\n  brackets\
    \ = brackets.gsub(/[\\>]/,'>')\n  brackets = brackets.gsub(/[\\{]/,'{')\n  brackets\
    \ = brackets.gsub(/[\\}]/,'}')\n  brackets = brackets.gsub(/[\\|]/,'|')\n  brackets\
    \ = brackets.gsub(/[\\<|]/,'<')\n  brackets = brackets.gsub(/[\\>]/,'>')\n  brackets\
    \ = brackets.gsub(/[\\{]/,'{')\n  brackets = brackets.gsub(/[\\}]/,'}')\n  brackets\
    \ = brackets.gsub(/[\\<|]/,'<')\n  brackets = brackets.gsub(/[\\>]/,'>')\n  brackets\
    \ = brackets.gsub(/[\\{]/,'{')\n  brackets = brackets.gsub(/[\\}]/,'}')\n  brackets\
    \ = brackets.gsub(/[\\<|]/,'<')\n  brackets = brackets.gsub(/[\\>]/,'>')\n  brackets\
    \ = brackets.gsub(/[\\{]/,'{')\n  brackets = brackets.gsub(/[\\}]/,'}')\n  brackets\
    \ = brackets.gsub(", "  brackets.scan(/[^<>]+/) do |x|\n    next if x =~ /^<\\\
    /|</\n    next if x =~ /^<\\/>/\n    next if x =~ /^<</\n    next if x =~ /^>\\\
    />/\n    next\n  end\nend", "  brackets.gsub!(/</, \"&lt;\")\n  brackets.gsub!(/>/,\
    \ \"&gt;\")\n  brackets.gsub!(/(<.*?>)/m) { |str| str[1...-2] == \"<\" ? str.strip\
    \ : nil }\n  brackets.gsub!(/(<.*?>)/) { |str| str[1...-2] == \"<\" ? str.strip\
    \ : nil }\n  brackets.gsub!(/(<.*?>)/, \"&lt;\")\n  brackets.gsub!(/(<.*?>)/,\
    \ \"&gt;\")\n  brackets.gsub!(/<\\/?([^<>]*)>/m) { |str| str[1...-2] == \"<\"\
    \ ? str.strip : nil }\n  brackets.gsub!(/<\\/?([^<>]*)>/) { |str| str[1...-2]\
    \ == \"<\" ? str.strip : nil }\n  brackets.gsub!(/<([^<>]*)>/) { |str| str[1...-2]\
    \ == \"<\" ? str.strip : nil }\n  brackets.gsub!(/<([^<>]*)>/, \"&lt;\")\n  brackets.gsub!(/<([^<>]*)>/,\
    \ \"&gt;\")\n  brackets.gsub!(/>/, \"&gt;\")\n  brackets.gsub!(/</, \"&lt;\")\n\
    \  brackets.gsub!(/</, \"&lt;\")\n  brackets.gsub!(/>/, \"&gt;\")\n  brackets.gsub!(/</,\
    \ \"&lt;\")\n  brackets.gsub!(/</, \"&lt;\")\n  brackets.gsub!(/>/, \"&gt;\")\n\
    \  brackets.gsub!(/</, \"&lt;\")\n  brackets.gsub!(/</, \"&lt;\")\n  brackets.gsub!(/</,\
    \ \"&lt;\")\n  brackets.gsub!(/</, \"&lt;\")\n  brackets.gsub!(/</, \"&lt;\")\n\
    \  brackets.gsub!(/</, \"&lt;\")\n  brackets.gsub!(/</, \"&lt;\")\n  brackets.gsub!(/</,\
    \ \"&lt;\")\n  brackets.gsub!(/</, \"&lt;\")\n  brackets.gsub!(/</, \"&lt;\")\n\
    \  brackets.gsub!(/</, \"&lt;\")\n  brackets.gsub!(/</, \"&lt;\")\n  brackets.gsub!(/</,\
    \ \"&lt;\")\n  brackets.gsub!(/</, \"&lt;\")\n  brackets.gsub!(/</, \"&lt;\")\n\
    \  brackets.gsub!(/</, \"&lt;\")\n  ", "  # Your code here\n  puts \"Correcting\
    \ Brackets #{$brackets}\"\n  correct_open_bracket = brackets.gsub(/<|>|<=|>=/,\
    \ '').length == 0\n  correct_close_bracket = brackets.gsub(/<<|>|<=|>=/, '').length\
    \ == 0\n  correct_open_bracket\n  correct_close_bracket\nend\n</code>\nThe regex\
    \ /<|>|<=|>=/ is a regular expression that finds brackets. gsub is used for global\
    \ substitution. It takes a regular expression as the first parameter, and the\
    \ string to be substituted for that regular expression as the second parameter.\n\
    The | is an or. The | operator is called an alternation. If either side matches,\
    \ then the expression is true and the replacement is performed. So, |<=|>= matches\
    \ either the string <, <=, or >= because of the or operator. Once again, the replacement\
    \ is empty string, so the string is not replaced.\n<|/ a tags=ruby,string |>\n\
    <| c |>\nYou seem to have misunderstood the OP's question. He has asked if every\
    \ string in `brackets` has at least one occurrence of \"<\" and at least one occurrence\
    \ of \">\", which is not the same as if the string is equal to \"<>\". Therefore\
    \ your answer does not give the desired result.\n<|/ c |>\n<| c |>\nThanks for\
    \ the comment. I misunderstood the question. I was under the impression that he\
    \ wanted to check if the string contained \"<\" and \">\". But he edited the question\
    \ to clarify this. I guess I didn't get into the question correctly. I'll delete\
    \ my answer.\n<|/ c |>\n<| a dscore=2 tags=ruby,string |>\n<code>", "  brackets.scan(/<|>/)\
    \ { |x| return false } #empty string is valid bracketing.\n  brackets.scan(/</)\
    \ { |x| return false }\n  brackets.scan(/>/) { |x| return false }\n  return true\n\
    end", "  opening_brackets = brackets.scan(/\\</)\n  closing_brackets = brackets.scan(/\\\
    >/)\n  opening_brackets.each do |opening_bracket|\n    closing_brackets.each do\
    \ |closing_bracket|\n      next if opening_bracket == closing_bracket\n      return\
    \ false\n    end\n  end\n  return true\nend", "  return brackets =~ /\\A<\\w+>*\\\
    s*<\\w+>*\\s*<\\w+>*\\z/\nend", "  return brackets =~ /\\A<+>+\\Z/\nend\n</pre>\n\
    <p><strong>Exercise</strong></p>\n<p>What do you notice about this function? Why\
    \ do you think it might not work?</p>\n<h2>7. String methods</h2>\n<p>We've done\
    \ a lot of string processing so far. What's next? Let's take a look at some of\
    \ the more useful string methods that Ruby provides.</p>\n<p>Ruby provides a wide\
    \ range of methods, including a method called <code>gsub</code> (a global substitute).\
    \ In this exercise, you will practice using a regular expression to change all\
    \ <code>\"-\"</code> characters to <code>\"+\"</code> characters.</p>\n<p>To start,\
    \ find all of the <code>\"-\"</code> characters, and replace them with a <code>\"\
    +\"</code> character.</p>\n<pre>", "  brackets.scan(/\\((.*)\\)/)\n  return brackets.scan(/\\\
    {(.*)\\}/)\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI don't think the `<`,\
    \ `>` and `{` should be escaped, but rather they should be part of the string.\
    \ Also, I don't think it is possible to have more than one open bracket.\n<|/\
    \ c |>\n<| c |>\nYou're right, I've made that correction. I've also corrected\
    \ my answer to remove those escaping characters.\n<|/ c |>\n<| c |>\nThat is exactly\
    \ what I was looking for. I haven't yet tested it, but I shall do so in the morning.\
    \ I will tell you how it goes. Thanks a lot for the help.\n<|/ c |>\n<| c |>\n\
    , can you clarify what you mean by \"escaping characters\"?\n<|/ c |>\n<| c |>\n\
    What I was talking about was \"\\\"{\", which Ruby will evaluate to just \"{\"\
    . My point was that you shouldn't have to escape them when they are part of the\
    \ string.\n<|/ c |>\n<| a |>\n<code>", "  return brackets =~ /\\<\\</\nend\n  ",
  "  return brackets == \"<\" or brackets == \">\"\nend", "    brackets = brackets.split(//)\n\
    \    length = brackets.length()", "  brackets = brackets.split(//)\n  brackets.each\
    \ do |bracket|\n    if bracket.match(/\\A<\\/*\\>\\Z/)\n      return false\n \
    \   end\n  end\n  return true\nend", "    return brackets =~ /\\<+\\>+/\nend",
  "  return (brackets =~ /(<|>)+/) == nil\nend", "  brackets.gsub!(/^<|>$/, \"\")\n\
    \  brackets.gsub!(/<|>/, \"<>\")\n  brackets.gsub!(/<|>/, \"\")\n  brackets.gsub!(/<|>/,\
    \ \"<>\")\n  brackets.gsub!(/<|>/, \"\")\n  brackets.gsub!(/<|>/, \"<>\")\n  brackets.gsub!(/<|>/,\
    \ \"\")\n  brackets.gsub!(/<|>/, \"<>\")\n  brackets.gsub!(/<|>/, \"\")\n  brackets.gsub!(/<|>/,\
    \ \"<>\")\n  brackets.gsub!(/<|>/, \"\")\n  brackets.gsub!(/<|>/, \"<>\")\n  brackets.gsub!(/<|>/,\
    \ \"\")\n  brackets.gsub!(/<|>/, \"<>\")\n  brackets.gsub!(/<|>/, \"\")\n  brackets.gsub!(/<|>/,\
    \ \"<>\")\n  brackets.gsub!(/<|>/, \"\")\n  brackets.gsub!(/<|>/, \"<>\")\n  brackets.gsub!(/<|>/,\
    \ \"\")\n  brackets.gsub!(/<|>/, \"<>\")\n  brackets.gsub!(/<|>/, \"\")\n  brackets.gsub!(/<|>/,\
    \ \"<>\")\n  brackets.gsub!(/<|>/, \"\")\n  brackets.gsub!(/<|>/, \"<>\")\n  brackets.gsub!(/<|>/,\
    \ \"\")\n  brackets.gsub!(/<|>/, \"<>\")\n  brackets.gsub!(/<|>/, \"\")\n  brackets.gsub!(/<|>/,\
    \ \"<>\")\n  brackets.gsub!(/<|>/, \"\")\n  brackets.gsub!(/<|>/, \"<>\")\n  brackets.gsub!(/<|>/,\
    \ \"\")\n  brackets.gsub!(/<|>/, \"<>\")\n  brackets.gsub!(/<|>/, \"\")\n  brackets.gsub!(/<|>/,\
    \ \"<>\")\n  brackets.gsub!(/<|>/, \"\")\n  brackets.gsub!(/<|>/, \"<>\")\n  brackets.gsub!(/<|>/,\
    \ \"\")\n  brackets.gsub!(/<|>/, \"<>\")\n  brackets.gsub!(/<|>/, \"\")\n  brackets.gsub!(/<|>/,\
    \ \"<>\")\n  brackets.gsub!(/<|>/, \"\")", "  brackets.gsub!(/(<[^>]*>)/ do\n\
    \    $1.gsub(/[^<]+/) { |s| \"<\" + s + \">\" }\n  end)\n  brackets.gsub!(/(<\\\
    /[^>]*>)/ do\n    $1.gsub(/[^>]+/) { |s| \">\" + s }\n  end)\n  brackets.gsub!(/([^<><\\\
    />]*)<([^<><\\/>]*)>([^<><\\/>]*)<([^<><\\/>]*)>([^<><\\/>]*)<([^<><\\/>]*)>/\
    \ do\n    \"<#{$1}#><#{$3}#><#{$5}#><#{$7}#><#{$9}#>\"\n  end)\n  brackets.gsub!(/([^<><\\\
    />]*)<([^<><\\/>]*)>/ do\n    \"<#{$1}#><#{$3}#>\"\n  end)\n  brackets.gsub!(/([^<><\\\
    />]*)<([^<><\\/>]*)/>/ do\n    \"<#{$1}#><#{$3}#/>\"\n  end)\n  brackets.gsub!(/([^<><\\\
    />]*)<([^<><\\/>]*)/>/ do\n    \"<#{$1}#><#{$3}#>/>\"\n  end)\n  brackets.gsub!(/([^<><\\\
    />]*)<([^<><\\/>]*)><// do\n    \"<#{$1}#><#{$3}#></#{$5}#>\"\n  end)\n  brackets.gsub!(/([^<><\\\
    />]*)<([^<><\\/>]*)>/ do\n    \"<#{$1}#><#{$3}#>\"\n  end)\n  brackets.gsub!(/(<[^>]*>)/\
    \ do\n    $1.gsub(/[^<]+/) { |s| \"<\" + s + \">\" }\n  end)\n  brackets.gsub!(/(<\\\
    /[^>]*>)/ do\n    $1.gsub(/[^>]+/) { |s| \">\" + s }\n  end)\n  brackets.gsub!(/([^<><\\\
    />]*)<([^<><\\/>]*)>([^<><\\/>]*)<([^<><\\/>]*)>([^<><\\/>]*)<([^<><\\/>]*)>([^<><\\\
    />]*)<([^<><\\/>]*)>([^<", "  brackets = brackets.to_s.strip.downcase\n  brackets.gsub!(/[<>]/,\
    \ '') # remove \"<\" and \">\"\n  brackets.gsub!(/([<>]{2})/, '\\1') # replace\
    \ \"<<\" and \"<<\" with \"><\", etc.\n  brackets.gsub!(/([<>]{3})/, '\\1\\1\\\
    1')\n  brackets.gsub!(/\\(/, '<')\n  brackets.gsub!(/\\)/, '>')\n  brackets.gsub!(/([\\\
    )]{3})/, '\\1\\1')\n  brackets.gsub!(/([\\)]{2})/, '\\1')\n  brackets.gsub!(/\\\
    [/, '(')\n  brackets.gsub!(/\\]/, ')')\n  brackets.gsub!(/([\\[]{3})/, '\\1\\\
    1')\n  brackets.gsub!(/([\\]]{2})/, '\\1')\n  brackets.gsub!(/\\]/, ']')\n  brackets.gsub!(/\\\
    {/, '[')\n  brackets.gsub!(/\\}/, ']')\n  brackets.gsub!(/\\(/, '(')\n  brackets.gsub!(/\\\
    )/, ')')\n  brackets.gsub!(/\\[/, '[')\n  brackets.gsub!(/\\]/, ']')\n  brackets.gsub!(/\\\
    {/, '{')\n  brackets.gsub!(/\\}/, '}')\n  brackets.gsub!(/([\\[]{3})/, '\\1\\\
    1')\n  brackets.gsub!(/([\\]]{2})/, '\\1')\n  brackets.gsub!(/\\]/, ']')\n  brackets.gsub!(/([\\\
    ]]{2})/, '\\1')\n  brackets.gsub!(/\\]/, ']')\n  brackets.gsub!(/\\}/, '}')\n\
    \  brackets.gsub!(/([\\]]{2})/, '\\1')\n  brackets.gsub!(/\\]/, ']')\n  brackets.gsub!(/\\\
    {/, '{')\n  brackets.gsub!(/\\}/, '}')\n  brackets.gsub!(/([\\]]{2})/, '\\1')\n\
    \  brackets.gsub!(/\\]/, ']')\n  brackets.gsub!(/\\[/, '[')\n  brackets.gsub!(/\\\
    ]/, ']')\n  brackets.gsub!(/\\(/, '(')\n  brackets.gsub!(/\\)/", "  brackets =\
    \ brackets.to_s\n  opening_brackets_stack = brackets.scan(/\\<\\>/)\n  closing_brackets_stack\
    \ = brackets.scan(/\\>\\>/)", "  brackets.split(\"\").all? do |char|\n    if char\
    \ == \"<\" || char == \">\"\n      bracket_stack << char\n    end\n    bracket_stack.empty?\
    \ || bracket_stack.last == char\n  end\nend", "  return brackets.split('<').all(&:matches('>'))\
    \ ? true : false\nend", "  return false unless brackets\n  brackets.gsub!(\"<\"\
    , \"\").gsub!(\">\", \"\")\n  return brackets.gsub!(/(^<)|(>$)/ ) { |match| match.empty?\
    \ }\nend", "  brackets.scan(/\\(|<\\/|\\[|\\{|<\\/[\\]\\}|\\]\\}|\\|\\|/) do |char|\n\
    \    case char\n    when /\\(/ then return false\n    when /\\)/ then return true\n\
    \    end\n  end\n  return false\nend", "  # check if brackets is empty or only\
    \ has one character.\n  if brackets.length < 2\n    false\n  else\n    # find\
    \ how many opening brackets it has.\n    opening = brackets.match(/[\\[\\(\\{]/)\n\
    \    if opening == nil\n      false\n    else\n      opening.length\n    end\n\
    \  end\nend\n</code>\nAs you can see in the function above, we need to find the\
    \ number of opening brackets within the brackets string, i.e. how many of the\
    \ following characters are \"[\", \"(\", \"{\", \"<\", or \"<\". If there are\
    \ no brackets, return false. Otherwise, return true if every opening bracket has\
    \ a corresponding closing bracket.\nIn order to do this, we need to use the regular\
    \ expressions /[\\[\\(\\{]/ and /[\\]}\\)]/. These regular expressions match a\
    \ series of \"[\", \"(\", \"{\", or \"<\" followed by a \"]\". By specifying these\
    \ regular expressions within the square brackets, you can use the match method\
    \ on a string, and it will return the number of matches (in this case, 1) as a\
    \ string. For example, these two expressions match the same string, so \"[[]]\"\
    .match(/[\\[\\(\\{]/) would equal \"[[]]\".\nSo to put it all together in your\
    \ program, try the following:\n<code>", "  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/,\
    \ \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n\
    \  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/,\
    \ \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n\
    \  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/,\
    \ \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n\
    \  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/,\
    \ \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n\
    \  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/,\
    \ \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n\
    \  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/,\
    \ \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n\
    \  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/,\
    \ \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n  brackets.gsub!(/^<,|,>/, \"\")\n\
    \  bracket", "  bracket_counts = Hash.new(0)\n  brackets.split(\"\").each do |x|\n\
    \    if x == \">\"\n      bracket_counts[\">\"] += 1\n    elsif x == \"<\"\n \
    \     bracket_counts[\"<\"] += 1\n    elsif x == \"(\"\n      bracket_counts[\"\
    (\"] += 1\n    elsif x == \")\"\n      bracket_counts[\")\"] += 1\n    end\n \
    \ end\n  return bracket_counts.values.all? { |c| c == 0 }\nend", "  brackets.scan(/<|>|<|>|</).empty?\n\
    end", "  # This code assumes that brackets has exactly two characters. \n  # (Recall\
    \ that strings can be indexed.)\n  if brackets[0] == brackets[1]\n    # The string\
    \ is of the form '<' or '>'\n    return false\n  # This code assumes that brackets\
    \ has three or more characters. \n  # (Recall that strings can be indexed.)\n\
    \  index = brackets.index(brackets[0])\n  count = 1\n  while index != -1 and count\
    \ != 0\n    index = brackets.rindex(brackets[index + 1])\n    count -= 1\n  end\n\
    \  # The string is of the form '<<' or '>>'\n  return true\nend", "  brackets\
    \ = brackets.to_s\n  brackets.gsub!(/(<)+/, '<')\n  brackets.gsub!(/(>)+/, '>')\n\
    \  brackets.gsub!(/(\\<\\<)+/, '<')\n  brackets.gsub!(/(\\>\\>)+/, '>')\n  brackets.gsub!(/(\\\
    <\\>\\<)+/, '<')\n  brackets.gsub!(/(\\>\\>\\>)+/, '>')\n  return brackets ==\
    \ brackets\nend", "  return brackets.chars.all? {|char| char == '<'}\nend", " \
    \   # @param brackets A string with brackets.\n    # @return True if every opening\
    \ bracket has a corresponding closing bracket.\n    opening_brackets = brackets.scan(/[<>]/)\n\
    \    closing_brackets = brackets.scan(/[<>]/).reject { |match| match =~ /[<>]/}\n\
    \    return opening_brackets.all? { |match| closing_brackets.include?(match) }\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a |>\n<code>", "  brackets.scan(/[^<>]+/)\n\
    \  brackets.scan(/[^<>]+/)\n  brackets.scan(/[^<>]+/)\n  return brackets.length\
    \ == 3\nend\n</code>\n<|/ a tags=ruby,regex,string |>\n<| c |>\nThis only works\
    \ for brackets, not other punctuation\n<|/ c |>\n<| c |>\n- I see your point.\
    \ Can you explain what you mean by \"other punctuation\"? Do you mean punctuation\
    \ that isn't a bracket? Or punctuation that isn't surrounded by brackets?\n<|/\
    \ c |>\n<| c |>\nI mean punctuation that isn't surrounded by brackets\n<|/ c |>\n\
    <| c |>\n- What is your definition of \"punctuation\"?\n<|/ c |>\n<| c |>\nI mean\
    \ anything that isn't a bracket\n<|/ c |>\n<| a dscore=1 |>\nHere's an example\
    \ that uses Raku (Ruby version 0.6.2) to create a DFA (Deterministic Finite Automaton)\
    \ that matches brackets that aren't surrounded by other brackets (this DFA is\
    \ much larger than the OP's DFA because it's less powerful):\n<code>", "  brackets\
    \ = brackets.to_s\n  brackets.squeeze!\n  brackets.reverse!\n  brackets.gsub!(/\\\
    s*<\\s*/, \"<<\")\n  brackets.gsub!(/\\s*>\\s*/, \">>\")\n  brackets.gsub!(/\\\
    s*\\|\\s*/, \",|\")\n  brackets.gsub!(/\\s*\\|\\|\\s*/, \"|||\")\n  brackets.gsub!(/\\\
    s*\\/\\*/, \"/\\*\")\n  brackets.gsub!(/\\s*\\*\\/\\s*/, \"\\*/\")\n  brackets.gsub!(/\\\
    s*\\/\\/\\s*/, \"/\\/\")\n  brackets.gsub!(/\\s*#\\s*(?![&|])\\s*/, \"#~\")\n\
    \  brackets.gsub!(/\\s*\\^\\s*/, \"\\^\")\n  brackets.gsub!(/\\s*\\~\\s*/, \"\
    ~\")\n  brackets.gsub!(/\\s+/, \" \")\n  brackets.gsub!(/\\|\\|/, \"|||\")\n \
    \ brackets.gsub!(/\\*\\*/, \"\\*\\/\")\n  brackets.gsub!(/\"/, \"\")\n  brackets.gsub!(/\"\
    /, \"\")\n  brackets.gsub!(/\\*\\//, \"/\\/\")\n  brackets.gsub!(/\\//, \"/\"\
    )\n  brackets.gsub!(/\\//, \"/\")\n  brackets.gsub!(/\\*\\*/, \"\\*\\/\")\n  brackets.gsub!(/</,\
    \ \"\")\n  brackets.gsub!(/>/, \"\")\n  brackets.gsub!(/\\^/, \"\\^\")\n  brackets.gsub!(/\\\
    ~/, \"~\")\n  brackets.gsub!(/\\|\\|/, \"|||\")\n  brackets.gsub!(/\\*\\*/, \"\
    \\*\\/\")\n  brackets.gsub!(/~\\s*/, \"~\")\n  brackets.gsub!(/\\s*\\^\\s*/, \"\
    \\^\")\n  brackets.gsub!(/\\s*\\~\\s*/, \"~\")\n  brackets.gsub!(/\\s+/, \" \"\
    )\n  brackets.gsub!(/\\|\\|/, \"|||\")\n  brackets.gsub!(/\\*\\*/, \"\\*\\/\"\
    )\n  brackets.gsub!(/\"/, \"\")\n  brackets.gsub!(/\"/, \"\")\n  brackets.gsub!(/\\\
    *\\//, \"/\\/\")\n  brackets.gsub!(/\\//, \"/\")\n  brackets.gsub!(/\\", "  brackets.scan(/</)\
    \ do |char|\n    if brackets.scan(/</) { true }\n    elsif brackets.scan(/>/)\n\
    \      brackets.unscan(/>/)\n      true\n    else\n      brackets.unscan(/>/)\n\
    \      brackets.unscan(/</)\n    end\n  end\n  brackets.scan(/>/)\n  brackets.scan(/</)\n\
    \  brackets.unscan(/>/)\n  brackets.unscan(/</)\nend", "  brackets.split('').each_with_index\
    \ do |char, index|\n    if char == '<'\n      return false\n    elsif char ==\
    \ \">\"\n      if index == 0 || index == 3\n        return true\n      else\n\
    \        return false\n      end\n    end\n  end\n  false\nend\nputs correct_bracketing(ARGV[0])\n\
    </code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nI think you should return `false`\
    \ from `correct_bracketing` rather than `true`.\n<|/ c |>\n<| c |>\n: Thanks.\
    \ I changed it. I also added a test for the empty string.\n<|/ c |>\n<| c |>\n\
    : And now I added a test for the string `\"<<><>>\"`.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>", "  # Only change it if the brackets are already correct.\n  if\
    \ brackets.chars.all? { |c| brackets.chars.include?(c) }\n    true\n  else\n \
    \   # If the string contains any opening bracket, count how many closing brackets\n\
    \    # follow it.\n    open_count = 0\n    brackets.chars.each do |c|\n      if\
    \ c == \"<\"\n        open_count += 1\n      elsif c == \">\"\n        open_count\
    \ -= 1\n      end\n    end", "  brackets = brackets.to_s.strip\n  if brackets\
    \ == \"\"\n    true\n  else\n    correct_bracketing(brackets[1..-1]) == true &&\
    \ correct_bracketing(brackets[0..-2]) == true\n  end\nend", "  brackets.gsub(/(<|>)([<])/)\
    \ { |m| $3.downcase }.gsub(/(<|>)([>])/) { |m| $3.downcase }\nend", "  brackets\
    \ = brackets.to_s.gsub('>','&gt;').gsub('<','&lt;').gsub('&','&amp;')\n  opening_bracket\
    \ = brackets.gsub('<','&lt;').gsub('&','&amp;')\n  closing_bracket = brackets.gsub('>','&gt;').gsub('&','&amp;')\n\
    \  if opening_bracket.empty? and closing_bracket.empty?\n    true\n  else\n  \
    \  opening_bracket.gsub('&amp;','&').gsub('&lt;','<').gsub('&gt;','>')\n  end\n\
    end", "  brackets = brackets.to_s\n  i = 0\n  while i < brackets.length\n    j\
    \ = i + 1 while j < brackets.length and brackets[i + 1] == brackets[j]\n    next\
    \ if j == brackets.length\n    if brackets[i] == \"<\"\n      brackets.slice!(i,\
    \ j)\n      i = j\n    else\n      return false if brackets[i] == \">\"\n    end\n\
    \  end\n  return true\nend\n</code>\n<|/ a |>\n<| c |>\nThanks, I'll try that\n\
    <|/ c |>\n<| a tags=ruby,string,regex,ruby-on-rails |>\nThis is basically a variant\
    \ of Matt's answer: It converts the string to a regular expression and then uses\
    \ String#scan to find all the matches.\n<code>\nstring = \"<><>\"", "  brackets.split(//).each\
    \ do |opening_bracket|\n    closing_brackets = brackets[opening_bracket.size..-1]\n\
    \    # return false if we can't find an opening or closing bracket\n    return\
    \ false if !opening_bracket || !closing_brackets.present?", "  brackets.gsub!(/\\\
    <(?!/)|\\>(?!/)|\\<\\>|\\<\\>|\\<(?!/)|\\>(?!/)/, \"\")\n  brackets.each_char{\
    \ |x| x != \"<\" && x != \">\" && x != \"<<\" && x != \">>\" && x != \"<<<\" &&\
    \ x != \">>>\" && x != \"<>\"}\n  return brackets.empty?\nend", "  brackets =\
    \ brackets.dup\n  brackets.gsub! \"<\", \">\"\n  brackets.gsub! \">>\", \">>\"\
    \n  brackets.gsub! \"<<\", \">>\"\n  brackets.gsub! \"<->\", \"<->\"\n  brackets.gsub!\
    \ \"->>\", \"->>\"\n  brackets.gsub! \"-><\", \"->>\"\n  brackets.gsub! \"<->\"\
    , \"<->\"\n  brackets.gsub! \"<<<\", \">>\"\n  brackets.gsub! \"<<->\", \">>\"\
    \n  brackets.gsub! \"<-><\", \">>\"\n  brackets.gsub! \"<->->\", \">>\"\n  brackets.gsub!\
    \ \"<<-><\", \">>\"\n  brackets.gsub! \"<<->->\", \">>\"\n  brackets.gsub! \"\
    <->->\", \">>\"\n  brackets.gsub! \"<-><\", \">>\"\n  brackets.gsub! \"<->->\"\
    , \">>\"\n  brackets.gsub! \"<<-><\", \">>\"\n  brackets.gsub! \"<<->->\", \"\
    >>\"\n  brackets.gsub! \"<->->\", \">>\"\n  brackets.gsub! \"<-><\", \">>\"\n\
    \  brackets.gsub! \"<->->\", \">>\"\n  brackets.gsub! \"<<-><\", \">>\"\n  brackets.gsub!\
    \ \"<<->->\", \">>\"\n  brackets.gsub! \"<->->\", \">>\"\n  brackets.gsub! \"\
    <<-><\", \">>\"\n  brackets.gsub! \"<<->->\", \">>\"\n  brackets.gsub! \"<->->\"\
    , \">>\"\n  brackets.gsub! \"<-><\", \">>\"\n  brackets.gsub! \"<->->\", \">>\"\
    \n  brackets.gsub! \"<<-><\", \">>\"\n  brackets.gsub! \"<<->->\", \">>\"\n  brackets.gsub!\
    \ \"<->->\", \">>\"\n  brackets.gsub! \"<<-><\", \">>\"\n  brackets.gsub! \"<<->->\"\
    , \">>\"\n  brackets.gsub! \"<->->\", \">>\"\n  brackets.gsub! \"<<-><\", \">>\"\
    \n  brackets.gsub! \"<<->->\", ", "  brackets.chars.each_with_index do |char,\
    \ i|\n    return false if char == \"<\" && brackets[i] == \">\"\n    return false\
    \ if char == \">\" && brackets[i] == \"<\"\n  end\n  true\nend", "  bracket_open\
    \ = 0\n  bracket_close = 0\n  bracket_open = brackets.index(\"<\")\n  bracket_close\
    \ = brackets.index(\">\", bracket_open)\n  while bracket_open < bracket_close\n\
    \    bracket_open = brackets.index(\"<\", bracket_close)\n    bracket_close =\
    \ brackets.index(\">\", bracket_open)\n    if brackets[bracket_open+1] != brackets[bracket_close-1]\n\
    \      return False\n    bracket_open += 1\n    bracket_close += 1\n  return True\n\
    end", "    brackets = brackets.to_s\n    correct_bracket_count = 0\n    opening_counts\
    \ = Hash.new(0)\n    opening_brackets = Hash.new(0)\n    closing_brackets = Hash.new(0)",
  "    brackets = brackets.to_s\n    opening_counts = brackets.scan(/([<>])/)\n  \
    \  closing = brackets.scan(/(\\<\\<)/)\n    correct = opening == closing\n   \
    \ \n    if opening_counts.empty?\n        # no need to do anything\n        return\
    \ true\n    end\n    \n    opening_counts.any? do |open_count, close_count|\n\
    \        opening_counts.include?(open_count)\n    end\nend", "  if brackets =~\
    \ /\\<\\</ \n    return true\n  else \n    return false\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>\n  def has_brackets?(string)\n    openings = string.count('(')\n\
    \    closings = string.count(')')\n    openings > closings\n  end\n</code>\n<|/\
    \ a tags=ruby,regex |>\n<| c |>\nI like this solution. Elegant, concise, and easy\
    \ to read. I believe it is also the fastest (as compared to my solution, below).\n\
    <|/ c |>\n<| a |>\n<code>", "  brackets.count(\"<\") == brackets.count(\">\")\
    \ + 1\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks, I like your answer a\
    \ lot more than my own. I wish I could accept both.\n<|/ c |>\n<| a dscore=2 tags=ruby,algorithm\
    \ |>\nThe problem is actually a lot more interesting than it may seem.\nHere is\
    \ a recursive solution, which is also faster than the other solutions provided\
    \ here. \n<code>", "  brackets.scan(/[<>]/) do |b|\n    brackets.scan(/[<>]/)\
    \ do |c|\n      bracket_nesting << b\n      bracket_nesting << c\n    end\n  end\n\
    \  bracket_nesting.size == brackets.size / 2\nend", "    brackets_stack = []\n\
    \    brackets_stack2 = []\n    brackets_stack2.push brackets\n    \n    # Find\
    \ all the opening brackets.\n    while brackets_stack.any?\n        top = brackets_stack.last\n\
    \        if top =~ /^</\n            brackets_stack.push top\n        else\n \
    \           if brackets_stack2.any?\n                brackets_stack.push brackets_stack2.pop\n\
    \            end\n        end\n    end\n    \n    # Find all the closing brackets.\n\
    \    while brackets_stack.any?\n        top = brackets_stack.last\n        if\
    \ top =~ /^>/\n            brackets_stack.push top\n        else\n           \
    \ if brackets_stack2.any?\n                brackets_stack.push brackets_stack2.pop\n\
    \            end\n        end\n    end\n    \n    return brackets_stack.size ==\
    \ 0\nend", "  open_brackets = brackets.split(\"<\")\n  close_brackets = brackets.split(\"\
    >\")\n  open_brackets.each_with_index { |x, i| open_brackets[i] = x.gsub(/^\\\
    >/, \"\") }\n  open_brackets.each_with_index { |x, i| open_brackets[i] = x.gsub(/^</,\
    \ \"\") }\n  close_brackets.each_with_index { |x, i| close_brackets[i] = x.gsub(/^\\\
    >/, \"\") }\n  close_brackets.each_with_index { |x, i| close_brackets[i] = x.gsub(/^</,\
    \ \"\") }\n  open_brackets.each_with_index { |x, i| open_brackets[i] = x.gsub(/\\\
    A</, \"\") }\n  close_brackets.each_with_index { |x, i| close_brackets[i] = x.gsub(/\\\
    A>/, \"\") }\n  open_brackets == close_brackets\nend", "  if brackets.length <\
    \ 2\n  then return brackets == \"\"\n  else return false\n  end\nend", "  brackets\
    \ = brackets.to_s\n  result = false\n  if brackets.empty?\n    result\n  else\n\
    \    if brackets[0] == \"<\"\n      result = true\n    else\n      if brackets[1]\
    \ == \"<\"\n        result = true\n      else\n        if brackets[2] == \"<\"\
    \n          result = true\n        else\n          if brackets[3] == \"<\"\n \
    \           result = true\n          else\n            if brackets[4] == \"<\"\
    \n              result = true\n            else\n              if brackets[5]\
    \ == \"<\"\n                result = true\n              else\n              \
    \  if brackets[6] == \"<\"\n                  result = true\n                else\n\
    \                  if brackets[7] == \"<\"\n                    result = true\n\
    \                  else\n                    if brackets[8] == \"<\"\n       \
    \               result = true\n                    else\n                    \
    \  if brackets[9] == \"<\"\n                        result = true\n          \
    \            else\n                        if brackets[10] == \"<\"\n        \
    \                  result = true\n                        else\n             \
    \             if brackets[11] == \"<\"\n                            result = true\n\
    \                          else\n                            if brackets[12] ==\
    \ \"<\"\n                              result = true\n                       \
    \     else\n                              if brackets[13] == \"<\"\n         \
    \                       result = true\n                              else\n  \
    \                              if brackets[14] == \"<\"\n                    \
    \              result = true\n                                else\n         \
    \                         if brackets[15] == \"<\"\n                         \
    \           result = true\n                                  else\n          \
    \                          if brackets[16] == \"<\"\n                        \
    \              result = true\n                                    else\n     \
    \                                 if brackets[17] == \"<\"\n                 \
    \                       result = true\n                                      else\n\
    \                                        if brackets[18] == \"<\"\n          \
    \                                result = true\n                             \
    \           else\n                                          if brackets[19] ==\
    \ \"<\"\n                                            result = true\n         \
    \                                 else\n                                     \
    \       if brackets[20] == \"<\"\n                                           \
    \   result = true\n                                            else\n        \
    \                                      if brackets[21] == \"<\"\n            \
    \                                    result = true\n                         \
    \                     else\n                                                if\
    \ brackets[22] == \"<\"\n                                                  result\
    \ = true\n                                                else\n             \
    \                                     if brackets[23] == \"<\"\n             \
    \                                       result = true\n                      \
    \                            else\n                                          \
    \          if brackets[24] == \"<\"\n                                        \
    \              result = true\n                                               \
    \     else\n                                                      if brackets[25]\
    \ == \"<\"\n                                                        result = true\n\
    \                                                      else\n                \
    \                                        if brackets[26] == \"<\"\n          \
    \                                                result = true\n             \
    \                                             else\n                         \
    \                                   if brackets[27] == \"<\"\n               \
    \                                               result = true\n              \
    \                                            else\n                          \
    \                                    if brackets[28] == \"<\"\n              \
    \                                                  result = true\n           \
    \                                                   else\n                   \
    \                                             if brackets[29] == \"<\"\n     \
    \                                                             result = true\n\
    \                                                                else\n      \
    \                                                              if brackets[30]\
    \ == \"<\"", "  if brackets.include?(\"<\")\n    brackets.gsub!(/\\</, \"&lt;\"\
    )\n  elsif brackets.include?(\">\")\n    brackets.gsub!(/\\>/, \"&gt;\")\n  end\n\
    \  brackets.include?(\"<\")\nend", "  brackets.each_char.all? do |char|\n    next\
    \ unless char == \"<\" && brackets.gsub!(char, \">\") || char == \">\" && brackets.gsub!(char,\
    \ \"<\")\n    next\n  end\n  brackets == brackets.gsub(\">\", \"\")\nend", " \
    \ brackets = brackets.to_s\n  brackets.reverse\n  open_count = 0\n  closed_count\
    \ = 0\n  while brackets.any?\n    bracket_string = brackets.pop\n    if bracket_string\
    \ == \"<\"\n      open_count += 1\n      break\n    elsif bracket_string == \"\
    >\"\n      closed_count += 1\n      break\n    elsif closed_count > open_count\n\
    \      break\n    elsif open_count > closed_count\n      return false\n    end\n\
    \  end\n  return true\nend", "  brackets.gsub!(\"[<>]\", \"\")\n  brackets.gsub!(\"\
    <<>\", \"\")\n  brackets.gsub!(\"<>\", \"\")\n  brackets.gsub!(\"[\", \"\")\n\
    \  brackets.gsub!(\"<\", \"\")\n  brackets.gsub!(\">\", \"\")\n  return brackets\
    \ == \"<>\"\nend", "  brackets.split('').sort == brackets\nend", "  brackets.scan(/\\\
    (|\\)/).each do |bracket_open|\n    return false if bracket_open != \"(\" && bracket_open\
    \ != \")\"\n    return false if bracket_open != \"]\" && bracket_open != \"}\"\
    \ && bracket_open != \")\"\n  end\n  true\nend", "    brackets = brackets.to_s.split(\"\
    \")\n    brackets.each do |b|\n        if b.length == 1 and (b == \"<\" or b ==\
    \ \">\")\n            brackets.delete(b)\n        end\n    end\n    brackets.empty?\n\
    end", "  brackets = brackets.split('>')\n  brackets.each {|x| x << '<'}\n  brackets.each\
    \ {|x| x << \">\"}\n  brackets.all? {|x| x << \"<\"}\nend\n</code>\n<|/ a tags=ruby,regex\
    \ dscore=2 |>\n<| a dscore=0 |>\nYou might want to take a look at Nokogiri.  It\
    \ allows parsing XML, HTML, and XHTML in Ruby.  It's relatively easy to use, supports\
    \ XPath, etc.\n<|/ a tags=ruby,regex |>\n<| a tags=ruby,regex |>\nHere's a solution\
    \ that will work for any type of nested brackets. It's basically a depth-first\
    \ traversal of the string, allowing you to stop whenever you hit a closing bracket.\
    \ \n<code>\nstring = \"( ( a ( b ) c ) )\"\nresult = ''\nstack = [ string ]",
  "  brackets =~ /\\<([^\\<\\>]*)\\>/ && brackets.gsub(\"\\<\\>\",'') && brackets.gsub(\"\
    \\>\\<\",'') == ''\nend", "  brackets.split(\"\").sort.each_with_index do |char,\
    \ i|\n    next if (char == \">\" && i >= 0 && brackets[i+1] != \">\")\n    next\
    \ if (char == \"<\" && i >= 0 && brackets[i-1] != \"<\")\n    char == \">\"\n\
    \  end && brackets == \">\"\nend", "  bracket_count = 0\n  brackets = brackets.split(\"\
    \").map{|b| b.to_s}\n  brackets.reverse_each{|b| bracket_count += 1 if b == \"\
    <\"}\n  brackets.reverse_each{|b| bracket_count -= 1 if b == \">\"}\n  return\
    \ bracket_count == 0\nend", "  return brackets.count \"<\" == brackets.count \"\
    >\"\nend", "    brackets = brackets.chars\n    correct_bracketing = false\n  \
    \  correct_bracketing = true\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n    correct_bracketing = false\n    correct_bracketing = false\n  \
    \  correct_bracketing = false\n    correct_bracketing = false\n    correct_bracketing\
    \ = false\n", "  brackets = brackets.to_s\n  bracket_count = 0\n  result = true\n\
    \  brackets.scan(/([^>])/) do |match|\n    bracket_count += 1\n    result.update(match.to_s\
    \ == \"<\")\n  end\n  result.update(bracket_count == brackets.size)\n  result\n\
    end", "  brackets.count(\"<\") + (brackets.count(\"<\") - brackets.count(\">\"\
    ))\nend\n</code>\n<|/ a tags=loops,ruby,string |>\n<| a dscore=2 |>\nThe solutions\
    \ given so far will fail in some cases. For example, for input \"<<<\" and output\
    \ \"<<<\", the solution would return \"<<<\" rather than \"<<<>><\". Furthermore,\
    \ it is possible to reach the end of the string with input \"<<<<\" and output\
    \ \"<<<<>><\" which is clearly not correct. Also, for input \"<\" and output \"\
    ><\" the solution would return \"<>><\" which is clearly not correct. The general\
    \ problem is, that any valid solution must encounter the same number of opening\
    \ brackets as the closing brackets. If you have n opening brackets and m closing\
    \ brackets, you can always reach the end of the string with n opening brackets\
    \ and m closing brackets. Therefore, the solution should only encounter the required\
    \ number of brackets.\nTo solve the problem I made an algorithm that solves the\
    \ problem for all input cases. Here is my algorithm for the problem stated in\
    \ the question:\n<code>", "  brackets.scan(/</)\n  brackets.scan(/>/)\n  return\
    \ brackets.empty?\nend\n</code>\nSo you have the correct bracketing algorithm\
    \ in place, but now we just need to implement the actual recursion.  I've broken\
    \ it down for you:\n<code>", "  brackets.count(\"<\") + brackets.count(\">\")\
    \ < brackets.length\nend", "  brackets.scan(/^<(.*?)>/) do |m|\n    (@open <<\
    \ m[0]) == m[1]\n  end\nend", "  return brackets !~ /\\{|\\}/\nend", "  brackets.scan(/([<>]+)/)\
    \ {|match| opening_pairs.delete(match)}\n  opening_pairs.empty?\nend\n</code>\n\
    <|/ a tags=ruby,regex,string |>\n<| c |>\nI didn't downvote you but your answer\
    \ doesn't work as expected for string like `<<>><<>><<>><`\n<|/ c |>\n<| c |>\n\
    Oh, I forgot that there could be multiple pairs being matched. That would require\
    \ a change in the regex to `<(.*?)>+`. I'll update my answer accordingly.\n<|/\
    \ c |>\n<| a dscore=2 |>\nYou might use lookarounds here and use quantifier +\
    \ for the closing part.\n<code>\n(?<!<)<(.*?)>+(?!>)\n</code>\nDEMO\nTest\n<code>\n\
    re = /(?<!<)<(.*?)>+(?!>)/m\n</code>\n<|/ a tags=ruby,regex,string |>\n<| c |>\n\
    Thank you for helping me with the regex! I really appreciate it!\n<|/ c |>\n<|\
    \ c |>\n, I have added explanation for lookarounds in my answer.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nJust for the fun of it, here's one solution which uses only a\
    \ single, simple regex, but it is not very efficient.\n<code>", "  brackets =\
    \ brackets.to_s\n  return brackets =~ /^([<]+)(\\1\\1+)$/\nend", "    # Remove\
    \ any spaces that appear before or after each character.\n    brackets = brackets.gsub(/[<>]+/,\
    \ '')\n    # Return true if the bracketing appears correctly with only opening\
    \ brackets.\n    correct_opening = brackets.gsub(/[<>]/, '').empty?\n    correct_closing\
    \ = brackets.gsub(/[<>]/, '').empty?\n    return correct_opening && correct_closing\n\
    end", "  return brackets.gsub(/</, \"&lt;\").gsub(/>/, \"&gt;\").empty?\nend\n\
    </code>\n<|/ a |>\n<| a dscore=2 tags=ruby |>\nI believe that Ruby has some functionality\
    \ to help you do this: it's called a regular expression. You can find more info\
    \ on Ruby regular expressions here: http://www.ruby-doc.org/core-1.9.3/Regexp.html\n\
    What you want to do is something like this (the <> brackets being your opening\
    \ brackets):\n<code>\nstring.gsub(/[<>]+/, \"</\")\n</code>\n<|/ a |>\n<| c |>\n\
    Ruby regular expressions are not the same as Perl.  To match a set of characters,\
    \ it must be enclosed in square brackets.  (That said, your answer is correct\
    \ if the question is phrased as being about \"matching a set of characters with\
    \ regular expressions\".)\n<|/ c |>\n<| a |>\nA simple gsub! should do the trick:\n\
    <code>\n\"&lt;&gt;&lt;&gt;\".gsub!('<', '&lt;')\n=> \"&lt;&gt;&lt;&gt;\"\n</code>\n\
    <|/ a tags=ruby dscore=2 |>\n<| c |>\nThis solution assumes that you want to replace\
    \ the string '&lt;' with the string '<'. As asked, this does not seem to be the\
    \ case.\n<|/ c |>\n<| a |>\nI think you want to use 'gsub' which will replace\
    \ all instances of the given pattern with the replacement string.\n<code>", " \
    \ return brackets =~ /\\A<[^>]*>\\Z/ &&\n    (/\\A<[^>]*>\\Z/ =~ brackets || brackets\
    \ =~ /\\A<[^>]*>\\Z/)\nend", "  bracket_counts = brackets.scan(/[<>]|\\(\\<\\\
    >\\)|\\(<<\\)><><>|>>>/).count\n  (bracket_counts == brackets.length) ? false\
    \ : true\nend", "  brackets.scan(/[^>]+/).all? { |s| s.include?(\"<\") }\nend",
  "  bracket = brackets[0]\n  bracket_count = 0\n  bracket_opened = false\n  bracket_stack\
    \ = []\n  \n  # Pop an opening bracket off the stack while keeping track of what\
    \ was opened.\n  while bracket_count < brackets.length and bracket_stack.length\
    \ > 0\n    bracket_count += 1 if brackets[bracket_count] == bracket else 0\n \
    \   bracket_stack.pop\n  \n  while bracket_count >= 0 and bracket_opened == false\n\
    \    bracket_count -= 1 if brackets[bracket_count] == bracket else 0\n    \n \
    \   open_bracket = brackets[bracket_count] if bracket_count < brackets.length\
    \ else '<' + bracket\n    closed_bracket = brackets[bracket_count + 1] if bracket_count\
    \ < brackets.length else '<' + bracket\n    \n    # If the stack of opened brackets\
    \ is empty, then the opening bracket must be closed.\n    if bracket_stack.empty?\n\
    \      bracket_stack << open_bracket\n      bracket_opened = (open_bracket ==\
    \ closed_bracket)\n    else\n      # The opening bracket must be closed, and the\
    \ next bracket must be opened.\n      bracket_stack.pop\n      bracket_stack <<\
    \ closed_bracket\n      bracket_opened = (closed_bracket == open_bracket)\n  \
    \  end\n  end\n  \n  # Check whether the bracket stack is empty.\n  return bracket_stack.empty?\n\
    end", "  # initialize result to false\n  result = false\n  # for each character\
    \ in brackets\n  (0..brackets.length-1).each do |i|\n    # if brackets[i] is \"\
    <\"\n    if brackets[i] == \"<\"\n      # if not result and previous character\
    \ is \">\"\n      if not result and i > 0 and brackets[i-1] != \">\"\n       \
    \ # set result to true\n        result = true\n      end\n    end\n  end\n  #\
    \ return result\n  result\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nNice, this\
    \ is pretty slick\n<|/ c |>\n<| c |>\nThis looks very clever.  Thank you for taking\
    \ the time to write it.\n<|/ c |>\n<| c |>\nI like this approach but I don't think\
    \ it works with nested brackets.  For example, `correct_bracketing(\"<(<((<))>))>\"\
    )` returns `true`, when it should be `false`.  I tried to fix it but I'm out of\
    \ ideas.\n<|/ c |>\n<| c |>\nOops, that was my mistake.  I forgot to remove the\
    \ `<` from the beginning of my input.  I just edited my answer, but I'll leave\
    \ it to others to fix it.  Thanks!\n<|/ c |>\n<| c |>\nThank you for fixing my\
    \ mistake.  I appreciate your help.\n<|/ c |>\n<| a tags=ruby |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
