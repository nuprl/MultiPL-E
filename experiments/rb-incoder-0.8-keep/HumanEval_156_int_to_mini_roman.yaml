name: HumanEval_156_int_to_mini_roman
language: rb
prompt: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n#\
  \ >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n#\
  \ >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
  \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
  \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
  \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
  \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
  \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
  \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
  \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
  \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
completions: ["  if number == 1\n    \"x\"\n  elsif number == 5\n    \"v\"\n  elsif\
    \ number == 10\n    \"l\"\n  elsif number == 50\n    \"c\"\n  elsif number ==\
    \ 100\n    \"d\"\n  elsif number == 500\n    \"m\"\n  elsif number == 1000\n \
    \   \"b\"\n  else\n    raise ArgumentError, \"Invalid integer #{number}\"\n  end\n\
    end", "  roman_numerals = [\n    '',\n    'i',\n    'ii',\n    'iii',\n    'iv',\n\
    \    'v',\n    'vi',\n    'vii',\n    'viii',\n    'ix',\n    'x',\n    'xi',\n\
    \    'xii',\n    'xiii',\n    'xiv',\n    'xv',\n    'xvi',\n    'xvii',\n   \
    \ 'xviii',\n    'xix',\n    'xx',\n    'xxx',\n    'xxxx',\n  ]\n  roman_numerals_reverse\
    \ = [\n    '',\n    'i',\n    'ii',\n    'iii',\n    'iv',\n    'v',\n    'vi',\n\
    \    'vii',\n    'viii',\n    'ix',\n    'x',\n    'xi',\n    'xii',\n    'xiii',\n\
    \    'xiv',\n    'xv',\n    'xvi',\n    'xvii',\n    'xviii',\n    'xix',\n  \
    \  'xx',\n    'xxx',\n    'xxxx',\n  ]\n  roman_numerals_reverse.each do |roman_numeral|\n\
    \    if number >= roman_numeral\n      roman_numeral = roman_numerals_reverse[roman_numerals_reverse.index(roman_numeral)\
    \ + 1]\n      break\n    end\n  end\n  roman_numeral = roman_numerals[roman_numerals.index(roman_numeral)\
    \ + 1]\n  roman_numeral.downcase!\n  return roman_numeral\nend\n</code>\n<|/ a\
    \ dscore=2 tags=ruby,string |>\n<| c |>\nWhy are you using downcase! here?\n<|/\
    \ c |>\n<| c |>\n, I think that is what the OP was looking for. I just figured\
    \ it out myself.\n<|/ c |>\n<| c |>\nThis doesn't work when the number is below\
    \ 1, e.g. 110.\n<|/ c |>\n<| a tags=ruby,string dscore=1 |>\n<code>", "  roman\
    \ = ['',] * 9", "  roman = Array.new\n  numeral_roman = {1 => 'I', 5 => 'V', 10\
    \ => 'X', 20 => 'C', 50 => 'D', \n\t\t   100 => 'M', 1000 => 'M'} \n\t\n  # Add\
    \ hundreds\n  if number >= 100\n    (number - 100).times do |i| roman.push numeral_roman[i]\
    \ end\n    roman.push('C')\n    number = number - 100\n  elsif number < 100\n\
    \    roman.push('M')\n  end\n  \n  # Add tens\n  number -= number < 10 ? number\
    \ + 100 : number \n  number.times do |i| roman.push numeral_roman[i] end\n  roman.push('X')\n\
    \  \n  # Add ones\n  roman.push('I')\n  \n  return roman.join('').downcase\nend",
  "  if number > 1000 or number < 1\n  raise ArgumentError.new(\"Invalid value: #{number.inspect}\"\
    )\n  end\n  roman_chars = %w{\n  C D M L X\n  V I X L C M\n  G T P A Y S Z\n \
    \ M B D F K J\n  Y W V H R N\n  S C R Q D B\n  C L D F G H\n  T H D M Y S\n  P\
    \ K E Y W R\n  A I Q Z W V\n  I D C Y F T\n  Y G F C X W\n  T H M I S G\n  S J\
    \ K X W V A\n  J Q D R M Y C\n  T H D M W Z A\n  T H M C X R D\n  T H M D X C\
    \ S\n  T H X C R Q M\n  T H X D R A M\n  T H X F R G A\n  T H X M R G D\n  T H\
    \ X M R A D\n  T H X R G C M\n  T H X R G D M\n  T H X R A C G\n  T H X R A D\
    \ G\n  T H X R D C A\n  T H X R D G C\n  T H X R D G A\n  T H X R G C D\n  T H\
    \ X R G D C\n  T H X R G D A\n  T H X R A C D\n  T H X R A D D\n  T H X R D C\
    \ G\n  T H X R D G C\n  T H X R D G A\n  T H X R G C D\n  T H X R G D C\n  T H\
    \ X R G D A\n  T H X R A C D\n  T H X R A D D\n  T H X R D C G\n  T H X R D G\
    \ C\n  T H X R D G A\n  T H X R G C D\n  T H X R G D C\n  T H X R G D A\n  T H\
    \ X R A C D\n  T H X R A D D\n  T H X R D C G\n  T H X R D G C\n  T H X R D G\
    \ A\n  T H X R G ", "  roman = ''\n  int_to_roman_helper(number, roman, 1000)\n\
    \  roman.downcase!\n  roman\nend", "  roman, int_list = [], 0\n  while number\
    \ > 0\n    roman, number, integer_part = divmod number, 1000, 1\n    int_part\
    \      = number_to_roman(number)\n    roman         << int_part\n    int_list\
    \      << integer_part\n  end\n  roman, int_list.join\nend", "  roman_numerals\
    \ = []\n  roman_numerals_as_strings = roman_numerals_as_strings(number)\n  \n\
    \  if roman_numerals_as_strings.size < 1\n    return \"-\"\n  end\n  \n  # Convert\
    \ each letter to an integer and add it to the array\n  roman_numerals.each_with_index\
    \ do |letter, i|\n    roman_numerals[i] = letter_to_int(letter)\n  end\n  \n \
    \ # Iterate through the array, adding each element to roman_numerals_as_strings\n\
    \  roman_numerals_as_strings.each do |string|\n    # Add '-' if '-' is the first\
    \ entry in the array\n    roman_numerals_as_strings[0] = '-' + roman_numerals_as_strings[0]\
    \ unless roman_numerals_as_strings[0] == '-'\n    \n    # Iterate through each\
    \ letter in string, adding it to roman_numerals_as_strings[i] if it\n    # is\
    \ > 1 character\n    roman_numerals_as_strings[i + 1] = string + roman_numerals_as_strings[i\
    \ + 1] unless roman_numerals_as_strings[i + 1].blank?\n    \n    # If string contains\
    \ only one letter, remove it from the array\n    roman_numerals.delete_at(0) if\
    \ roman_numerals.size == 1 && roman_numerals.first == '-'\n  end\n  \n  # Join\
    \ array with '-'\n  roman_numerals.reverse.each do |string|\n    roman_numerals_as_strings[0]\
    \ = string if roman_numerals_as_strings[0].blank?\n    break if roman_numerals_as_strings[0]\
    \ == '-'\n  end\n  \n  # Convert array to string, returning it lowercase\n  roman_numerals_as_strings.join.downcase\n\
    end", "  roman = Array.new\n  roman = roman.push(\"m\")\n  roman = roman.push(\"\
    cm\")\n  roman = roman.push(\"d\")\n  roman = roman.push(\"cd\")\n  roman = roman.push(\"\
    c\")\n  roman = roman.push(\"xc\")\n  roman = roman.push(\"l\")\n  roman = roman.push(\"\
    xl\")\n  roman = roman.push(\"x\")\n  roman = roman.push(\"ix\")\n  roman = roman.push(\"\
    v\")\n  roman = roman.push(\"iv\")\n  roman = roman.push(\"i\")\n  roman = roman.push(\"\
    vi\")\n  roman = roman.push(\"vii\")\n  roman = roman.push(\"iv\")\n  roman =\
    \ roman.push(\"i\")\n  roman = roman.push(\"vi\")\n  roman = roman.push(\"vii\"\
    )\n  roman = roman.push(\"iv\")\n  roman = roman.push(\"i\")\n  roman = roman.push(\"\
    vi\")\n  roman = roman.push(\"vii\")\n  roman = roman.push(\"iv\")\n  roman =\
    \ roman.push(\"i\")\n  roman = roman.push(\"vi\")\n  roman = roman.push(\"vii\"\
    )\n  roman = roman.push(\"iv\")\n  roman = roman.push(\"i\")\n  roman = roman.push(\"\
    vi\")\n  roman = roman.push(\"vii\")\n  roman = roman.push(\"iv\")\n  roman =\
    \ roman.push(\"i\")\n  roman = roman.push(\"vi\")\n  roman = roman.push(\"vii\"\
    )\n  roman = roman.push(\"iv\")\n  roman = roman.push(\"i\")\n  roman = roman.push(\"\
    vi\")\n  roman = roman.push(\"vii\")\n  roman = roman.push(\"iv\")\n  roman =\
    \ roman.push(\"i\")\n  roman = roman.push", "  return roman_to_mini_roman(int_to_roman(number)[0].to_s)\n\
    end", "  roman = ''\n  int_to_roman(number, roman, 0, '')\n  return roman\nend",
  "    roman = ''", "  roman = \"\"\n  temp = \"\"\n  \n  # Convert integer to string\n\
    \  str = number.to_s\n  \n  # Initialize temporary variable\n  temp = \"\"\n \
    \ \n  # Loop through each character in string\n  for i in 0...str.count('0')\n\
    \    \n    # Add 'i' to the end of temp and prepend 'i'\n    temp += \"i\"\n \
    \   \n    # Add '0' to the end of temp\n    temp += \"0\"\n    \n    # Add 1 to\
    \ i\n    i += 1\n    \n    # Add i to temp\n    temp += i\n  end\n  \n  # Replace\
    \ all 'i's with 'm' and replace all '0's\n  # with 'i'\n  roman = temp\n  \n \
    \ # Convert roman to lowercase\n  roman = roman.downcase\n  \n  # Return roman\n\
    \  return roman\nend", "  roman = String.new\n  roman = roman.concat(number_to_roman(number)[0,\
    \ 1])\n  roman = roman.concat(number_to_roman(number)[2, 1])\n  roman = roman.concat(number_to_roman(number)[3,\
    \ 2])\n  roman = roman.concat(number_to_roman(number)[4, 1])\n  roman = roman.concat(number_to_roman(number)[5,\
    \ 2])\n  roman = roman.concat(number_to_roman(number)[6, 2])\n  roman = roman.concat(number_to_roman(number)[7,\
    \ 3])\n  roman = roman.concat(number_to_roman(number)[8, 1])\n  roman = roman.concat(number_to_roman(number)[9,\
    \ 2])\n  roman = roman.concat(number_to_roman(number)[10, 3])\n  roman = roman.concat(number_to_roman(number)[11,\
    \ 4])\n  roman = roman.concat(number_to_roman(number)[12, 5])\n  roman = roman.concat(number_to_roman(number)[13,\
    \ 6])\n  roman = roman.concat(number_to_roman(number)[14, 7])\n  roman = roman.concat(number_to_roman(number)[15,\
    \ 8])\n  roman = roman.concat(number_to_roman(number)[16, 9])\n  roman = roman.concat(number_to_roman(number)[17,\
    \ 10])\n  roman = roman.concat(number_to_roman(number)[18, 11])\n  roman = roman.concat(number_to_roman(number)[19,\
    \ 12])\n  roman = roman.concat(number_to_roman(number)[20, 13])\n  roman = roman.concat(number_to_roman(number)[21,\
    \ 14])\n  roman = roman.concat(number_to_roman(number)[22, 15])\n  roman = roman.concat(number_to_roman(number)[23,\
    \ 16])\n  roman = roman.concat(number_to_roman(number)[24, 17])\n  roman = roman.concat(number_to_roman(number)[25,\
    \ 18])\n  roman = roman.concat(number_to_roman(number)[26, 19])\n  roman = roman.concat(number_to_roman(number)[27,\
    \ 20])\n  roman = roman.concat(number_", "  roman_array = ['i', 'x', 'c', 'm']\n\
    \  roman = ''\n  last_index = 0\n  while number > 0\n    roman_array.each do |i|\n\
    \      break if number >= i\n    end\n    roman = roman_array[last_index] + roman\n\
    \    last_index = roman_array.index(i)\n    number -= i\n  end\n  return roman\n\
    end", "  int_to_roman(number, true)\nend", '  roman_number = []', "  roman = ''\n\
    \  i = 1\n  while i <= number\n    roman = (roman << 1) + roman_to_index[roman_to_index[roman.to_s[0,1]]]\n\
    \    i += 1\n  end\n  return roman\nend", "  if number > 1000 then\n    number\
    \ = number/1000\n    int_to_mini_roman(number)\n  else\n    if number < 1000 then\n\
    \      if number == 0 then\n        miniroman = 'zero'\n      else\n        miniroman\
    \ = miniroman + (str_to_mini_roman(number))\n      end\n    else\n      miniroman\
    \ = miniroman + (str_to_mini_roman(number % 1000) + (str_to_mini_roman(number\
    \ / 1000)))\n    end\n  end\n  return miniroman\nend", "  roman = ''\n  while\
    \ number > 0\n    digit, number = number % 10, number / 10\n    roman += mini_roman[digit]\n\
    \  end\n  roman.downcase!\n  return roman\nend", "    roman_numeral = int_to_roman(number)\n\
    \    roman_numeral = roman_numeral.lower()\n    return roman_numeral", "  roman\
    \ = nil\n  roman_digits = Array.new", "  if number < 100\n    roman_num = roman_to_int(number)\n\
    \  else\n    roman_num = ''\n    while number >= 100\n      roman_num += roman_to_int(number\
    \ % 100)\n      number /= 100\n    roman_num += roman_to_int(number)\n  end",
  "  roman = Array.new\n  roman.push(\"M\") if number < 3 || number == 0 ||\n    (number\
    \ > 0 && number < 21) || number % 10 == 0\n  roman.push(\"D\") if (number < 3\
    \ || number == 0) && (number % 100 != 0)\n  roman.push(\"C\") if (number < 3 ||\
    \ number == 0) && (number % 10 != 0)\n  roman.push(\"L\") if (number < 3 || number\
    \ == 0) && (number % 100 == 0)\n  roman.push(\"X\")\n  roman.push(\"V\")\n  roman.push(\"\
    I\")\n  roman.join('')\nend", "    roman = ''\n    \n    if number <= 0: return\
    \ roman", '  roman = Array.new', "  if number.nil? || number > 1000 || number\
    \ < 1\n    return \"\"\n  end\n  roman = \"\"\n  digit = number\n  while number\
    \ > 0\n    roman << mini_roman[number % 10]\n    number /= 10\n  end\n  return\
    \ roman.to_s\nend", "  roman_num = []\n  i = 0\n  roman_num.push (' ')\n  while\
    \ i < number\n    roman_num.push ('M' if number >= 1000000 else 'CM')\n    number\
    \ -= 1000000\n    roman_num.push ('D' if number >= 10000 else 'CD')\n    number\
    \ -= 10000\n    roman_num.push ('C' if number >= 100 else 'XC')\n    number -=\
    \ 100\n    roman_num.push ('L' if number >= 10 else 'XL')\n    number -= 10\n\
    \    roman_num.push ('X' if number >= 1 else 'IX')\n    i += 1\n  roman_num.push\
    \ ('V')\n  return roman_num.join\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis\
    \ answer looks pretty good to me.  I personally would have used a loop (`until`\
    \ would be a nice alternative) instead of a recursion, but either one should be\
    \ fine.\n<|/ c |>\n<| c |>\nIt is not the fastest method but it is the most elegant\
    \ and easy to understand solution.\n<|/ c |>\n<| c |>\nHi, your code is working\
    \ perfectly fine but can you help me to understand how it is working?\n<|/ c |>\n\
    <| c |>\nYou used recursion to solve this problem. Recursion will call itself\
    \ until there is no more stack frames to pop off. Once the stack gets empty it\
    \ will return to the caller, and the caller will keep calling itself until it\
    \ hits the end of the method.\n<|/ c |>\n<| c |>\nIt will help a lot to see this\
    \ written as a loop (rather than recursion)\n<|/ c |>\n<| a tags=ruby,roman-numerals,ruby-on-rails\
    \ dscore=3 |>\nHere is a solution that uses recursion.  It builds a string with\
    \ a \"prefix\" argument that can be a roman numeral or a non-roman numeral.  If\
    \ a roman numeral is added, it appends to the prefix argument.  Otherwise, it\
    \ just appends to the argument without appending the prefix.\n<code>", "  if number\
    \ < 1\n    puts \"Please enter a positive integer\"\n    return\n  end \n  roman\
    \ = \"\"\n  while number > 0\n    roman = roman.to_s + int_to_roman_num(number\
    \ % 10)\n    number = number / 10\n  end\n  roman = roman.to_s[0...-1]\n  return\
    \ roman\nend", "  roman = Array.new\n  roman[0] = nil\n  roman[1] = nil\n  roman[2]\
    \ = nil\n  roman[3] = nil\n  roman[4] = nil\n  roman[5] = nil\n  roman[6] = 'i'\n\
    \  roman[7] = 'ii'\n  roman[8] = 'iii'\n  roman[9] = 'iv'\n  roman[10] = 'v'\n\
    \  roman[11] = 'vi'\n  roman[12] = 'vii'\n  roman[13] = 'viii'\n  roman[14] =\
    \ 'ix'\n  roman[15] = 'x'\n  roman[16] = 'xi'\n  roman[17] = 'xii'\n  roman[18]\
    \ = 'xiii'\n  roman[19] = 'xiv'\n  roman[20] = 'xv'\n  roman[21] = 'xv'\n  roman[22]\
    \ = 'xv'\n  roman[23] = 'xvi'\n  roman[24] = 'xvii'\n  roman[25] = 'xviii'\n \
    \ roman[26] = 'xix'\n  roman[27] = 'xx'\n  roman[28] = 'xxi'\n  roman[29] = 'xxii'\n\
    \  roman[30] = 'xxiii'\n  roman[31] = 'xxiv'\n  roman[32] = 'xxv'\n  roman[33]\
    \ = 'xxvi'\n  roman[34] = 'xxvii'\n  roman[35] = 'xxviii'\n  roman[36] = 'xxix'\n\
    \  roman[37] = 'xxx'\n  roman[38] = 'xxxi'\n  roman[39] = 'xxxii'\n  roman[40]\
    \ = 'xxxiii'\n  roman[41] = 'xxxiv'\n  roman[42] = 'xxxv'\n  roman[43] = 'xxxvi'\n\
    \  roman[44] = 'xxxvii'\n  roman[45] = 'xxxviii'\n  roman[46] = 'xxxiv'\n  roman[47]\
    \ = 'xxxv'\n  roman[48] = 'xxxvi'\n  roman[49] = 'xxxvii'\n  roman[50] = 'xxxviii'\n\
    \  roman[51] = 'xxxix'\n  roman[52] = 'xxxiv'\n  roman[53] = 'xxxv'\n  roman[54]\
    \ = '", "  roman_num = ''\n  hundreds = number / 100\n  hundreds = trunc(hundreds,\
    \ 2)\n  tens = trunc(number - hundreds * 100, 2)\n  i = 0\n  while i < hundreds\n\
    \    roman_num << get_roman_num(hundreds)\n    i += 1 \n  end\n  i = 0\n  while\
    \ i < tens\n    roman_num << get_roman_num(tens)\n    i += 1\n  end\n  i = 0\n\
    \  while i < number_to_roman(number)\n    roman_num << get_roman_num(number)\n\
    \    i += 1\n  end\n  roman_num.downcase!\n  return roman_num\nend", "  roman\
    \ = ''\n  roman_numerals = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C',\
    \ 90: 'XC',\n                    50: 'L', 40: 'XL', 10: 'L', 9: 'X', 5: 'V', 4:\
    \ 'IV', 1: 'I'}\n  roman_numerals_reverse = roman_numerals.invert", "  roman =\
    \ []\n  roman.push(\"c\")\n  roman.push(\"l\")\n  roman.push(\"c\")\n  roman.push(\"\
    d\")\n  roman.push(\"m\")\n  roman.push(\"c\")\n  roman.push(\"l\")\n  roman.push(\"\
    x\")\n  roman.push(\"c\")\n  roman.push(\"v\")\n  roman.push(\"i\")\n  roman.push(\"\
    x\")\n  roman.push(\"i\")\n  roman.push(\"l\")\n  roman.push(\"c\")\n  roman.push(\"\
    l\")\n  roman.push(\"x\")\n  roman.push(\"c\")\n  roman.push(\"v\")\n  roman.push(\"\
    c\")\n  roman.push(\"l\")\n  roman.push(\"c\")\n  roman.push(\"m\")\n  roman.push(\"\
    c\")\n  roman.push(\"l\")\n  roman.push(\"c\")\n  roman.push(\"v\")\n  roman.push(\"\
    i\")\n  roman.push(\"x\")\n  roman.push(\"i\")\n  roman.push(\"l\")\n  roman.push(\"\
    c\")\n  roman.push(\"l\")\n  roman.push(\"x\")\n  roman.push(\"c\")\n  roman.push(\"\
    v\")\n  roman.push(\"c\")\n  roman.push(\"l\")\n  roman.push(\"c\")\n  roman.push(\"\
    m\")\n  roman.push(\"c\")\n  roman.push(\"l\")\n  roman.push(\"c\")\n  roman.push(\"\
    v\")\n  roman.push(\"i\")\n  roman.push(\"x\")\n  roman.push(\"i\")\n  roman.push(\"\
    l\")\n  roman.push(\"c\")\n  roman.push(\"l\")\n  roman.push(\"x\")\n  roman.push(\"\
    c\")\n  roman.push(\"v\")\n  roman.push(\"c\")\n  roman.push(\"l\")\n  roman.push(\"\
    c\")\n  roman.push(\"m\")\n  roman.push(\"c\")\n  roman.push(\"l", '  roman_numerals
    = []', "  int_to_roman(number, \"\")\nend", "  roman_numbers = int_to_roman(number)\n\
    \  roman_numbers[8] = 'i'\n  return roman_numbers.join('')\nend", "    if number.to_i\
    \ > 1\n        int_to_mini_roman(number.to_i).insert(0, number.to_s)\n    else\n\
    \        int_to_mini_roman(number.to_i).insert(0, number.to_s)\n    end\nend",
  "  if number < 1 || number > 1000:\n    raise 'Invalid'\n  roman = []\n  sign =\
    \ ''\n  while number != 0:\n    digit = number % 10\n    number /= 10\n    roman\
    \ << digit\n    if number == 0:\n      break\n    sign = sign if number < 10 else\
    \ ''\n  return sign + ''.join(roman)\nend", "  roman = 'MCMXCIV'[number/1000].downcase\n\
    \  number %= 1000\n  roman, number = roman.succ, number - 1000\n  roman, number\
    \ = roman.succ, number - 1000\n  roman, number = roman.succ, number - 1000\n \
    \ roman, number = roman.succ, number - 1000\n  roman, number = roman.succ, number\
    \ - 1000\n  roman, number = roman.succ, number - 1000\n  roman, number = roman.succ,\
    \ number - 1000\n  roman, number = roman.succ, number - 1000\n  roman, number\
    \ = roman.succ, number - 1000\n  roman, number = roman.succ, number - 1000\n \
    \ roman, number = roman.succ, number - 1000\n  roman, number = roman.succ, number\
    \ - 1000\n  roman, number = roman.succ, number - 1000\n  roman, number = roman.succ,\
    \ number - 1000\n  roman, number = roman.succ, number - 1000\n  roman, number\
    \ = roman.succ, number - 1000\n  roman, number = roman.succ, number - 1000\n \
    \ roman, number = roman.succ, number - 1000\n  roman, number = roman.succ, number\
    \ - 1000\n  roman, number = roman.succ, number - 1000\n  roman, number = roman.succ,\
    \ number - 1000\n  roman, number = roman.succ, number - 1000\n  roman, number\
    \ = roman.succ, number - 1000\n  roman, number = roman.succ, number - 1000\n \
    \ roman, number = roman.succ, number - 1000\n  roman, number = roman.succ, number\
    \ - 1000\n  roman, number = roman.succ, number - 1000\n  roman, number = roman.succ,\
    \ number - 1000\n  roman, number = roman.succ, number - 1000\n  roman, number\
    \ = roman.succ, number - 1000\n  roman, number = roman.succ, number - 1000\n \
    \ roman, number = roman.succ, number - 1000\n  roman, number = roman.succ, number\
    \ - 1000\n  roman, number = roman.succ, number - 1000\n  roman, number = roman.succ,\
    \ number - 1000", "  num = str(number)\n  roman_number = []\n  counter = 0\n \
    \ while counter < len(num) - 2\n    roman_number = [num[counter]] + roman_number\n\
    \    counter += 1\n  roman_number = [num[counter]] + roman_number\n  counter =\
    \ 0\n  while counter < len(num) - 2\n    roman_number.insert(0,\"#\")\n    counter\
    \ += 1\n  return roman_number.join('')\nend", "  roman = ''\n  index = 0\n  while\
    \ index < number.length\n    roman = roman + ((number.to_s(index) + index) % (10\
    \ ** number.length))\n    index += 1\n  return roman\nend\n</code>\n<|/ a dscore=5\
    \ tags=integer,string,ruby |>\n<| c |>\n`roman = roman + ((number.to_s(index)\
    \ + index) % (10 ** number.length))` -> `roman = roman + ((number.to_s(index)\
    \ + index).romanize.to_s % (10 ** number.length))`.\n<|/ c |>\n<| c |>\nIf you're\
    \ using rails, see this answer: https://stackoverflow.com/questions/2485330/how-to-convert-an-integer-to-roman-numerals-in-ruby\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>", "  roman = \"ABC\"\n  roman_val = \"\"\n\
    \  while number > 0\n    if number >= 100\n      number -= 100\n      roman +=\
    \ \"M\"\n    end\n    if number >= 50\n      number -= 50\n      roman += \"D\"\
    \n    end\n    if number >= 10\n      number -= 10\n      roman += \"C\"\n   \
    \ end\n    roman += \"L\"\n  end\n  roman_val = roman.to_s\n  roman_val = roman_val.lstrip\n\
    \  roman_val = roman_val.rstrip\n  roman_val = roman_val.downcase\n  return roman_val\n\
    end", '  return roman_to_int(int_to_roman(number))', "  roman_num = \"\"\n  while\
    \ number >= 1000\n    roman_num += \"M\"\n    number -= 1000\n  while number >=\
    \ 900\n    roman_num += \"CM\"\n    number -= 900\n  while number >= 500\n   \
    \ roman_num += \"D\"\n    number -= 500\n  while number >= 400\n    roman_num\
    \ += \"CD\"\n    number -= 400\n  while number >= 100\n    roman_num += \"C\"\n\
    \    number -= 100\n  while number >= 90\n    roman_num += \"XC\"\n    number\
    \ -= 90\n  while number >= 50\n    roman_num += \"L\"\n    number -= 50\n  while\
    \ number >= 40\n    roman_num += \"XL\"\n    number -= 40\n  while number >= 10\n\
    \    roman_num += \"X\"\n    number -= 10\n  while number >= 9\n    roman_num\
    \ += \"IX\"\n    number -= 9\n  while number >= 5\n    roman_num += \"V\"\n  \
    \  number -= 5\n  while number >= 4\n    roman_num += \"IV\"\n    number -= 4\n\
    \  while number >= 1\n    roman_num += (\"I\" if number == 1 else \"V\")\n   \
    \ number -= 1\n  return roman_num.downcase\nend", "  if number == 0\n    number\n\
    \  elsif number == 1\n    ''\n  elsif number < 1\n    \"Invalid input\"\n  elsif\
    \ number > 1000\n    \"Invalid input\"\n  else\n    roman = Array.new\n    roman\
    \ = (10**number.to_i - 1).to_s\n    roman.sub!(/i/, 'i')\n    roman.sub!(/x/,\
    \ 'v')\n    roman.sub!(/l/, 'c')\n    roman.sub!(/(.)(\\1*)$/, '\\1')\n    roman.sub!(/(.)((\\\
    1|\\2)(\\1*)$/, '\\1')\n    roman.sub!(/(\\1|\\1|\\2)(\\1*)$/, '\\1')\n    roman.sub!(/(\\\
    1|\\1|\\1|\\2)(\\1*)$/, '\\1')\n    roman.sub!(/(\\1|\\1|\\1|\\1|\\2)(\\1*)$/,\
    \ '\\1')\n    roman.sub!(/(\\1|\\1|\\1|\\1|\\1|\\2)(\\1*)$/, '\\1')\n    roman.sub!(/(\\\
    1|\\1|\\1|\\1|\\1|\\1|\\2)(\\1*)$/, '\\1')\n    roman.sub!(/(\\1|\\1|\\1|\\1|\\\
    1|\\1|\\1|\\2)(\\1*)$/, '\\1')\n    roman.sub!(/(\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\\
    1|\\2)(\\1*)$/, '\\1')\n    roman.sub!(/(\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\\
    2)(\\1*)$/, '\\1')\n    roman.sub!(/(\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\\
    2)(\\1*)$/, '\\1')\n    roman.sub!(/(\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\\
    1|\\2)(\\1*)$/, '\\1')\n    roman.sub!(/(\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\1|\\\
    1|\\1|\\1|\\2)(\\1*)$/, '\\1')\n    roman.sub!(/(\\1|\\1|\\1|\\1|\\1|\\1", " \
    \ roman = ''", "  roman = \"IVXLCDM\"\n  result = ''\n  if number < 0 or number\
    \ > 1000\n    raise ArgumentError, \"Invalid input\"\n  while number > 0\n   \
    \ result = roman[number % 10] + result\n    number /= 10\n  end\n  return result.downcase\n\
    end", "  if number.zero?\n    '0'\n  elsif number < 0 || number > ROMAN_TO_INT_LIMIT\n\
    \    raise(ArgumentError, \"invalid argument #{number} for int_to_mini_roman\"\
    )\n  elsif number.between?(1, 1000)\n    roman = roman_to_int_array(number.to_s)\n\
    \    roman.map! {|i| i.ljust(2)}.join('')\n  else\n    roman = roman_to_int_array(number)\n\
    \    roman.map! {|i| i.ljust(3)}.join('')\n  end\n  roman\nend", "  mini_roman\
    \ = \"\"\n  roman_numerals = [\"\", \"c\", \"d\", \"x\", \"l\", \"m\", \"b\",\
    \ \"z\"]\n  roman_numeral_length = roman_numerals.length", '  roman = Array.new',
  "  roman_numerals = { 'I' => 1, 'V' => 5, 'X' => 10, 'L' => 50, 'C' => 100, 'D'\
    \ => 500, 'M' => 1000, 'IV' => 4,\n                      'IX' => 10, 'XL' => 50,\
    \ 'XC' => 10, 'CD' => 500, 'CM' => 1000, 'XIV' => 4,\n                      'XIX'\
    \ => 10, 'XXL' => 50, 'XXC' => 10, 'XXX' => 1000, 'XLV' => 4,\n              \
    \        'LXXX' => 1000, 'VXL' => 50, 'CXXX' => 1000, 'CDX' => 500, 'CMX' => 1000,\n\
    \                      'MXX' => 1000, 'IVL' => 4, 'IVC' => 10, 'IXC' => 10, 'XIV'\
    \ => 4,\n                      'XIX' => 10, 'XXI' => 5, 'XXII' => 9, 'LXXX' =>\
    \ 1000, 'VXL' => 50,\n                      'CXXX' => 1000, 'CDX' => 500, 'CMX'\
    \ => 1000, 'MXX' => 1000, 'IXC' => 10,\n                      'XIV' => 4, 'XIX'\
    \ => 10, 'XXV' => 5, 'XXC' => 10 }\n  return int_to_roman(number, roman_numerals)\n\
    end", "  if number < 100\n    \"M\"\n  elsif number < 500\n    \"C\"\n  elsif\
    \ number < 1000\n    \"D\"\n  elsif number < 2000\n    \"C\"\n  elsif number <\
    \ 3000\n    \"C\"\n  elsif number < 4000\n    \"C\"\n  elsif number < 5000\n \
    \   \"XC\"\n  elsif number < 6000\n    \"CD\"\n  elsif number < 7000\n    \"CM\"\
    \n  elsif number < 8000\n    \"M\"\n  elsif number < 9000\n    \"M\"\n  elsif\
    \ number < 10000\n    \"M\"\n  elsif number < 11000\n    \"M\"\n  elsif number\
    \ < 12000\n    \"D\"\n  elsif number < 13000\n    \"CD\"\n  elsif number < 14000\n\
    \    \"CM\"\n  elsif number < 15000\n    \"M\"\n  elsif number < 16000\n    \"\
    D\"\n  elsif number < 17000\n    \"CD\"\n  elsif number < 18000\n    \"CM\"\n\
    \  elsif number < 19000\n    \"M\"\n  elsif number < 20000\n    \"M\"\n  elsif\
    \ number < 21000\n    \"D\"\n  elsif number < 22000\n    \"CD\"\n  elsif number\
    \ < 23000\n    \"CM\"\n  elsif number < 24000\n    \"M\"\n  elsif number < 25000\n\
    \    \"D\"\n  elsif number < 26000\n    \"CD\"\n  elsif number < 27000\n    \"\
    CM\"\n  elsif number < 28000\n    \"M\"\n  elsif number < 29000\n    \"D\"\n \
    \ elsif number < 30000\n    \"CD\"\n  elsif number < 31000\n    \"CM\"\n  elsif\
    \ number < 32000\n    \"M\"\n  elsif number < 33000\n    \"D\"\n  elsif number\
    \ < 34000\n    \"CD\"\n  elsif number < 35000\n    \"CM\"\n  elsif number < 36000\n\
    \    \"M\"\n  elsif number < 37000\n    \"D\"\n  elsif number < 38000\n    \"\
    CD\"\n  elsif number ", "  roman_number = ''\n  while number > 0\n    if number\
    \ % 1000 == 0\n      roman_number << convert_roman_to_mini_roman(number % 1000)\n\
    \      number /= 1000\n    else\n      roman_number << convert_roman_to_mini_roman(number\
    \ % 100) + '.'\n      number /= 100\n    end\n  end\n  roman_number << convert_roman_to_mini_roman(number)\n\
    \  return roman_number.downcase\nend", "  roman_numerals = [nil, nil]\n  roman_numerals.push\
    \ ['', 'x']\n  roman_numerals.push ['c', 'l']\n  roman_numerals.push ['d', 'm']\n\
    \  roman_numerals.push ['i', 'v']\n  roman_numerals.push ['x', 'l']\n  roman_numerals.push\
    \ ['c', 'l']\n  roman_numerals.push ['d', 'm']\n  roman_numerals.push ['i', 'v']\n\
    \  roman_numerals.push ['i', 'x']\n  roman_numerals.push ['l', 'd']\n  roman_numerals.push\
    \ ['l', 'd']\n  roman_numerals.push ['m', 'd']\n  roman_numerals.push ['l', 'd']\n\
    \  roman_numerals.push ['l', 'd']\n  roman_numerals.push ['m', 'd']\n  roman_numerals.push\
    \ ['l', 'd']\n  roman_numerals.push ['l', 'd']\n  roman_numerals.push ['m', 'd']\n\
    \  roman_numerals.push ['l', 'd']\n  roman_numerals.push ['m', 'd']\n  roman_numerals.push\
    \ ['l', 'd']\n  roman_numerals.push ['l', 'd']\n  roman_numerals.push ['m', 'd']\n\
    \  roman_numerals.push ['l', 'd']\n  roman_numerals.push ['m', 'd']\n  roman_numerals.push\
    \ ['l', 'd']\n  roman_numerals.push ['l', 'd']\n  roman_numerals.push ['m', 'd']\n\
    \  roman_numerals.push ['l', 'd']\n  roman_numerals.push ['m', 'd']\n  roman_numerals.push\
    \ ['l', 'd']\n  roman_numerals.push ['m', 'd']\n  roman_numerals.push ['l', 'd']\n\
    \  roman_numerals.push ['m', 'd']\n  roman_numerals.push ['l', 'd']\n  roman_numerals.push\
    \ ['m', 'd']\n  roman_numerals.push ['l', 'd']\n  roman_numerals.push ['m', 'd']\n\
    \  roman_numerals.push ['l', 'd']\n  roman_numerals.push ['m', 'd']\n  roman_numerals.push\
    \ ['l', 'd']\n  roman_numerals.push ['m', 'd']\n  roman_numerals.push ['l', 'd']\n\
    \  roman_numerals.push ['m', 'd']\n  roman_numerals.push ", "    roman = ''\n\
    \    numbers_to_roman = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII',\
    \ 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'L', 'X', 'L', 'L']\n    numbers_to_roman.each_with_index\
    \ { |x, i| roman += x.to_s.reverse[1..-1] if i % 2 == 0 }\n    roman += numbers_to_roman[number].to_s.reverse[1..-1]\n\
    \    roman.downcase!\n    roman\nend", "  number = number.to_i\n  return roman_to_mini_roman(roman_numerals(number))\n\
    end", "  roman = []\n  roman.concat(roman.new('M'))\n  roman.concat(roman.new('CM'))\n\
    \  roman.concat(roman.new('D'))\n  roman.concat(roman.new('CD'))\n  roman.concat(roman.new('C'))\n\
    \  roman.concat(roman.new('XC'))\n  roman.concat(roman.new('L'))\n  roman.concat(roman.new('XL'))\n\
    \  roman.concat(roman.new('X'))\n  roman.concat(roman.new('V'))\n  roman.concat(roman.new('IV'))\n\
    \  roman.concat(roman.new('I'))\n  roman.concat(roman.new('VI'))\n  roman.concat(roman.new('I'))\n\
    \  roman.concat(roman.new('II'))\n  roman.concat(roman.new('III'))\n  roman.concat(roman.new('N'))\n\
    \  roman.concat(roman.new('NN'))\n  roman.concat(roman.new('NNN'))\n  roman.concat(roman.new('III'))\n\
    \  roman.concat(roman.new('IV'))\n  roman.concat(roman.new('V'))\n  roman.concat(roman.new('VI'))\n\
    \  roman.concat(roman.new('I'))\n  roman.concat(roman.new('XI'))\n  roman.concat(roman.new('XII'))\n\
    \  roman.concat(roman.new('XIII'))\n  roman.concat(roman.new('XIV'))\n  roman.concat(roman.new('XV'))\n\
    \  roman.concat(roman.new('XVI'))\n  roman.concat(roman.new('XVII'))\n  roman.concat(roman.new('XVIII'))\n\
    \  roman.concat(roman.new('XIX'))\n  roman.concat(roman.new('XX'))\n  roman.concat(roman.new('XXX'))\n\
    \  roman.concat(roman.new('XXXX'))\n  roman.concat(roman.new('XL'))\n  roman.concat(roman",
  "  return number < 0 or number >= 1000 ? '' : int_to_roman(number)\nend", "  if\
    \ number < 1 or number > 1000\n    puts \"[ERROR] Invalid argument.\"\n  end",
  "  roman = ''\n  while number >= 1000\n    roman += mini_roman_to_int(number / 1000)\n\
    \    number %= 1000\n  end\n  roman += mini_roman_to_int(number)\n  return roman\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is not an answer, but an admission\
    \ to rewrite your homework assignment. You wrote code with multiple bugs and that\
    \ code is a good example of how to write code without bugs. This is a great example\
    \ of code that is much easier to understand, debug, and maintain.\n<|/ c |>\n\
    <| c |>\nI know what you mean. I'm just reusing someone else's work and I'm teaching\
    \ myself Ruby at the same time :p\n<|/ c |>\n<| c |>\nI wouldn't worry about learning\
    \ Ruby at the same time as learning how to write Ruby code. There are a lot of\
    \ things you could learn at the same time, but most of what you would learn would\
    \ be more valuable if you knew Ruby first. Once you know Ruby, you can get into\
    \ more advanced topics like making good Ruby code. And the admission to rewrite\
    \ your code was a good way to show you how good Ruby code looks.\n<|/ c |>\n<|\
    \ c |>\n: Good point!  I did not realize that this was an \"answer\".  I was imagining\
    \ a comment to the OP that said \"thank you\", and that I would be happy to delete\
    \ my answer.  But I see now that the OP has accepted my answer.  I guess I should\
    \ have checked back first...  Oops.\n<|/ c |>\n<| c |>\nThanks, I like your answer\
    \ a lot. I just wanted to add that \"[ruby](http://ruby.org)\" is a nice way to\
    \ say \"[Ruby](http://ruby-lang.org)\". You could also say \"[Ruby](http://ruby-lang.org)\"\
    . It's a little more \"Ruby-ish\".\n<|/ c |>\n<| a dscore=5 |>\nI tried to add\
    \ some comments on your code:\n<code>", "  roman_numeral = \"\"\n  digits = 1000000000\n\
    \  while number >= digits\n    roman_numeral = \"#{roman_numeral}#{number % digits}\"\
    .to_i\n    number = number / digits\n  end\n  roman_numeral = \"#{roman_numeral}#{number}\"\
    .to_i\n  roman_numeral.to_s.downcase.lstrip\nend", "  result = ''", "  if number\
    \ < 1 or\n    number > 1000\n  then\n    return nil\n  end\n  roman_num_table\
    \ = {\n    1000:  'm',\n    900:   'cm',\n    500:   'd',\n    400:   'cd',\n\
    \    1000:  'm',\n    900:   'cm',\n    500:   'd',\n    400:   'cd',\n    1000:\
    \  'm',\n    900:   'cm',\n    500:   'd',\n    400:   'cd',\n    1000:  'm',\n\
    \    900:   'cm',\n    500:   'd',\n    400:   'cd',\n    1000:  'm',\n    900:\
    \   'cm',\n    500:   'd',\n    400:   'cd',\n    1000:  'm',\n    900:   'cm',\n\
    \    500:   'd',\n    400:   'cd',\n    1000:  'm',\n    900:   'cm',\n    500:\
    \   'd',\n    400:   'cd',\n    1000:  'm',\n    900:   'cm',\n    500:   'd',\n\
    \    400:   'cd',\n    1000:  'm',\n    900:   'cm',\n    500:   'd',\n    400:\
    \   'cd',\n    1000:  'm',\n    900:   'cm',\n    500:   'd',\n    400:   'cd',\n\
    \    1000:  'm',\n    900:   'cm',\n    500:   'd',\n    400:   'cd',\n    1000:\
    \  'm',\n    900:   'cm',\n    500:   'd',\n    400:   'cd',\n    1000:  'm',\n\
    \    900:   'cm',\n    500:   'd',\n    400:   'cd',\n    1000:  'm',\n    900:\
    \   'cm',\n    500:   'd',\n    400:   'cd',\n    1000:  'm',\n    900:   'cm',\n\
    \    500:   'd',\n    400:   'cd',\n    1000:  'm',\n    900:   'cm',\n    500:\
    \   'd',\n    400:   'cd',\n    1000:  'm',\n    900:   'cm',\n    500:   'd',\n\
    \    400:   'cd',\n    1000:  'm',\n    900:   'cm',\n    500:   'd',\n    400:\
    \   'cd',\n    1000:  'm',\n    900:   'cm',\n    500:   'd',", "  roman = \"\"\
    \n  while number > 0\n    roman = (number/10).to_s + roman\n    number = (number%10).to_i\n\
    \  end\n  roman = (number/10).to_s + roman\n  roman = (number%10).to_s + roman\n\
    \  roman = (number%10).to_s + roman\n  roman = (number%10).to_s + roman\n  roman\
    \ = roman[0..-1]\n  return roman\nend", "  int_to_roman_roman(number)\n  int_to_roman_numeral(number)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nWhat is the role of the helper method? Why the\
    \ duplication?\n<|/ c |>\n<| a dscore=1 |>\nAnother solution:\n<code>", "  roman\
    \ = Array.new\n  roman[0] = \"I\" # V\n  roman[1] = \"X\" # I\n  roman[2] = \"\
    C\" # IV\n  roman[3] = \"D\" # VI\n  roman[4] = \"M\" # I\n  roman[5] = \"C#\"\
    \ # VII\n  roman[6] = \"B\" # III\n  roman[7] = \"D#\" # VIII\n  roman[8] = \"\
    M#\" # I\n  roman[9] = \"C##\" # VIII\n  roman[10] = \"B#\" # IV\n  roman[11]\
    \ = \"D##\" # VII\n  roman[12] = \"M##\" # I", "\tint_to_roman(number, \"\")\n\
    end", "  roman = Array.new\n  roman[0] = String.new\n  roman[1] = String.new\n\
    \  roman[2] = String.new\n  roman[3] = String.new\n  roman[4] = String.new\n \
    \ roman[5] = String.new\n  roman[6] = String.new\n  roman[7] = String.new\n  roman[8]\
    \ = String.new\n  roman[9] = String.new\n  roman[10] = String.new\n  roman[11]\
    \ = String.new\n  roman[12] = String.new\n  roman[13] = String.new\n  roman[14]\
    \ = String.new\n  roman[15] = String.new\n  roman[16] = String.new\n  roman[17]\
    \ = String.new\n  roman[18] = String.new\n  roman[19] = String.new\n  roman[20]\
    \ = String.new\n  roman[21] = String.new\n  roman[22] = String.new\n  roman[23]\
    \ = String.new\n  roman[24] = String.new\n  roman[25] = String.new\n  roman[26]\
    \ = String.new\n  roman[27] = String.new\n  roman[28] = String.new\n  roman[29]\
    \ = String.new\n  roman[30] = String.new\n  roman[31] = String.new\n  roman[32]\
    \ = String.new\n  roman[33] = String.new\n  roman[34] = String.new\n  roman[35]\
    \ = String.new\n  roman[36] = String.new\n  roman[37] = String.new\n  roman[38]\
    \ = String.new\n  roman[39] = String.new\n  roman[40] = String.new\n  roman[41]\
    \ = String.new\n  roman[42] = String.new\n  roman[43] = String.new\n  roman[44]\
    \ = String.new\n  roman[45] = String.new\n  roman[46] = String.new\n  roman[47]\
    \ = String.new\n  roman[48] = String.new\n  roman[49] = String.new\n  roman[50]\
    \ = String.new\n  roman[51] = String.new\n  roman[52] = String.new\n  roman[53]\
    \ = String.new\n  roman[54] = String.new\n  roman[55] = String.new\n  roman[56]\
    \ = String.new\n  roman[57] = String.new\n  roman[58] = ", "  if number < 1000\
    \ and number > 0 then\n    if number < 21 then\n      if number == 0 then\n  \
    \      return nil\n      else\n        return \"x\" + int_to_mini_roman(number\
    \ - 21)\n      end\n    else\n      if number == 0 then\n        return \"0\"\n\
    \      else\n        if number == 1 then\n          return \"i\"\n        else\n\
    \          roman = nil\n          temp_string = \"1\"\n          while number\
    \ >= 1000 do\n            number = number / 1000\n            temp_string = temp_string\
    \ + \"m\"\n          end\n          temp_string += \"000\"\n          while number\
    \ >= 100 do\n            number = number / 100\n            temp_string = temp_string\
    \ + \"c\"\n          end\n          temp_string += \"00\"\n          while number\
    \ >= 10 do\n            number = number / 10\n            temp_string = temp_string\
    \ + \"x\"\n          end\n          temp_string += \"$\"\n          roman = temp_string\n\
    \          while number > 0 do\n            number = number % 10\n           \
    \ roman = roman + \"i\"\n          end\n          return roman\n        end\n\
    \      end\n    end\n  else\n    return \"Invalid input\"\n  end\nend\n</code>\n\
    <|/ a tags=string,ruby,arrays dscore=0 |>\n<| a dscore=0 tags=string,ruby,arrays\
    \ |>\n<code>", "  if number < 1\n    puts \"Please enter an integer >= 1.\"\n\
    \    exit\n  elsif number > 1000\n    puts \"Please enter an integer <= 1000.\"\
    \n    exit\n  else\n    roman_number = \"\"\n    roman_number = ((number/1000).to_s).scan(/.(?=(?:.(?!\\\
    d)|$))/).join(\"\").gsub(/^.(?=\\d)/, \"\")\n    roman_number += ((number % 1000)\
    \ / 100).to_s\n    roman_number += (number % 100).to_s\n    return roman_number.downcase\n\
    \  end\nend", "  # Make number a string\n  string = \"\"\n  \n  i = 0\n  \n  #\
    \ Repeat while i < len(num) - 1\n  while i < len(number) - 1\n    # Get the next\
    \ digit\n    digit = number[i]\n    \n    # If the digit is greater than 10, skip\
    \ it\n    if digit > 9\n      i += 1\n      continue\n    \n    # Get the next\
    \ number which is the current digit - 10\n    next_number = number[i]-10\n   \
    \ \n    # If the next number is < 10, skip it\n    if next_number < 10\n     \
    \ i += 1\n      continue\n    \n    # Add the next number to the string and add\
    \ it to the current number - 10\n    string += str(next_number)\n    \n    # Add\
    \ 9 to current number - 10\n    number += 9\n    \n    # Increment the index\n\
    \    i += 1\n    \n  # Add the last digit, if it exists, to the string\n  string\
    \ += str(number[i]) if i < len(number) else \"0\"\n  \n  # Return result in a\
    \ lower case string\n  return string.lower()\nend", "  return to_mini_roman(number)\n\
    end", "  roman, num, roman_num = 0, 0, \"\"\n  romans = [1000, 900, 500, 400,\
    \ 100, 90, 50, 40, 10, 9, 5, 4, 1]\n  while number >= romans[roman]\n    roman\
    \ += 1\n    roman_num += \"i\"\n    number -= romans[roman]\n  while number >=\
    \ romans[roman]\n    roman += 1\n    roman_num += \"v\"\n    number -= romans[roman]\n\
    \  while number >= romans[roman]\n    roman += 1\n    roman_num += \"f\"\n   \
    \ number -= romans[roman]\n  while number >= romans[roman]\n    roman += 1\n \
    \   roman_num += \"c\"\n    number -= romans[roman]\n  while number >= romans[roman]\n\
    \    roman += 1\n    roman_num += \"m\"\n    number -= romans[roman]\n  while\
    \ number >= romans[roman]\n    roman += 1\n    roman_num += \"x\"\n    number\
    \ -= romans[roman]\n  roman_num += roman_num\n  while number >= romans[roman]\n\
    \    roman += 1\n    roman_num += \"l\"\n    number -= romans[roman]\n  while\
    \ number >= romans[roman]\n    roman += 1\n    roman_num += \"xl\"\n    number\
    \ -= romans[roman]\n  while number >= romans[roman]\n    roman += 1\n    roman_num\
    \ += \"i\"\n    number -= romans[roman]\n  roman_num += \"v\"\n  while number\
    \ >= romans[roman]\n    roman += 1\n    roman_num += \"f\"\n    number -= romans[roman]\n\
    \  while number >= romans[roman]\n    roman += 1\n    roman_num += \"c\"\n   \
    \ number -= romans[roman]\n  while number >= romans[roman]\n    roman += 1\n \
    \   roman_num += \"m\"\n    number -= romans[roman]\n  while number >= romans[roman]\n\
    \    roman += 1\n    roman_num += \"x\"\n    number -= romans[roman]\n  roman_num\
    \ += roman_num\n  while number >= romans[roman]\n    roman += 1\n    roman_",
  "  roman = \"\"\n  while number != 0\n    (num, integer) = divmod(number, 10)\n\
    \    roman += \"M\" * num if integer == 0 else \"CM\"[integer] + \"D\"\n    number\
    \ = integer\n  end\n  roman\nend", "  roman_numerals = [\n    \"M\", \"CM\", \"\
    D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\
    \ ]\n  roman_numerals_reverse = [\n    \"M\", \"CM\", \"D\", \"CD\", \"C\", \"\
    XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\n  roman_numerals_reverse.reverse!\n\
    \  roman_numerals.each_index do |i|\n    number = number.to_i.times { roman_numerals_reverse[i]\
    \ }\n    break if number >= 1000\n  end\n  \n  roman_numerals.zip(roman_numerals_reverse).each\
    \ do |roman | \n    roman << number.to_s\n    break if number > 999\n  end\n \
    \ roman_numerals.last\nend", "  roman_numerals = [\"m\", \"cm\", \"d\", \"cd\"\
    , \"x\", \"x\", \"l\", \"xl\", \"c\", \"c\"]\n  roman_numerals_array = Array.new(roman_numerals)\n\
    \  i = 0\n  while i < roman_numerals.length\n    if number % roman_numerals[i]\
    \ == 0 && number / roman_numerals[i] >= 1\n      roman_numerals_array[i] = roman_numerals[number\
    \ / roman_numerals[i]]\n      number %= roman_numerals[i]\n    i += 1\n  end\n\
    \  roman_numerals_array.to_s.downcase\nend", "    if number <= 0\n        return\
    \ nil\n    roman, numerals = \"\", []\n    roman_numerals = %w[C D M L X V]\n\
    \    while number\n        roman_numeral = roman_numerals[number % 100]\n    \
    \    numerals.unshift(roman_numeral)\n        number /= 100\n    end\n    roman\
    \ = numerals.join('').reverse.join\n    if roman < 'I'\n        roman = \"I\"\
    \ + roman\n    end\n    return roman.upcase\nend", "  roman_numerals = \"IVXLCDM\"\
    \n  roman_numerals.gsub!(/I|V|X|L|C/, \"m\")\n  roman_numerals.gsub!(/I|V|X|L|C/,\
    \ \"c\")\n  roman_numerals.gsub!(/I|V|X|L|C/, \"d\")\n  roman_numerals.gsub!(/I|V|X|L|C/,\
    \ \"m\")\n  roman_numerals.gsub!(/I|V|X|L|C/, \"l\")\n  roman_numerals.gsub!(/I|V|X|L|C/,\
    \ \"x\")\n  roman_numerals.gsub!(/I|V|X|L|C/, \"v\")\n  roman_numerals.gsub!(/I|V|X|L|C/,\
    \ \"i\")\n  roman_numerals.gsub!(/I|V|X|L|C/, \"n\")\n  roman_numerals.gsub!(/I|V|X|L|C/,\
    \ \"p\")\n  roman_numerals.gsub!(/I|V|X|L|C/, \"f\")\n  roman_numerals.gsub!(/I|V|X|L|C/,\
    \ \"s\")\n  roman_numerals.gsub!(/I|V|X|L|C/, \"o\")\n  roman_numerals.gsub!(/I|V|X|L|C/,\
    \ \"x\")\n  roman_numerals.gsub!(/I|V|X|L|C/, \"g\")\n  roman_numerals.gsub!(/I|V|X|L|C/,\
    \ \"h\")\n  roman_numerals.gsub!(/I|V|X|L|C/, \"b\")\n  roman_numerals.gsub!(/I|V|X|L|C/,\
    \ \"d\")\n  roman_numerals.gsub!(/I|V|X|L|C/, \"k\")\n  roman_numerals.gsub!(/I|V|X|L|C/,\
    \ \"h\")\n  roman_numerals.gsub!(/I|V|X|L|C/, \"j\")\n  ", "  roman = \"\"\n \
    \ roman_num = 1\n  roman_num_str = number_to_roman_numeral(number)\n  roman_num_arr\
    \ = roman_num_str.split(\"\").map(&:to_i)\n  \n  roman_num_arr.each do |i|\n \
    \   roman += roman_num_str[i]\n    roman += (number % roman_num_arr[i] == 0) ?\
    \ \".\" : \"\"\n    roman += (number % roman_num_arr[i] == 0) ? \"\" : number_to_roman_numeral((number\
    \ % roman_num_arr[i]).abs)\n    number = number / roman_num_arr[i]\n  end\n  \n\
    \  roman.strip!\n  roman.downcase!", "  int_to_roman(number)\n  roman_number =\
    \ ''\n  current_roman = roman_numerals.roman[num]\n  while current_roman != ''\n\
    \    roman_number += current_roman\n    current_roman = roman_numerals.roman[current_roman]\n\
    \  end\n  roman_number\nend", "  number_in_roman = numeral_roman[number]\n  int_to_mini_roman_digits(number,\
    \ 0)\n  return number_in_roman.downcase\nend", "  roman = \"\"\n  for i in range(0,\
    \ number)\n    roman = (roman + romans.roman_to_mini_roman[i]).upcase\n    roman\
    \ = (roman + \"X\" * (number - i - 1)).upcase\n  end\n  roman = roman.downcase\n\
    end", "  roman = nil\n  if number < 0 \n    return \"ERROR\"\n  elsif number ==\
    \ 0\n    roman = \"III\"\n  elsif number < 3\n    roman = \"I\" + (\"I\" * (number\
    \ - 1))\n  elsif number < 6\n    roman = (number / 3) + \"C\" + (\"C\" * (number\
    \ - 3 * number / 3))\n  elsif number < 9\n    roman = \"M\" + (\"M\" * (number\
    \ - 3 * number / 3)) + (\"M\" * number)\n  else\n    roman = (number / 3) + \"\
    D\" + (\"D\" * (number - 3 * number / 3)) + (number % 3 * \"X\")\n  end \n  roman\
    \ = roman.upcase\n  return roman\nend\n</code>\n<|/ a dscore=5 tags=ruby,string\
    \ |>\n<| c |>\nVery nice implementation with good explanation.\n<|/ c |>\n<| a\
    \ dscore=5 |>\nMy favorite way to convert any integer to Roman Numerals is using\
    \ this nice little gem:\nhttps://github.com/jonas/roman_to_int\nFor example:\n\
    <code>\nrequire 'roman_to_int'\nputs RomanToInt.to_int('XIII')\n=> 14\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\n+1 for RomanToInt. I'd add that it's important\
    \ to note that RomanToInt is case-sensitive, so you should use `'Xiii'` not `'xiii'`\n\
    <|/ c |>\n<| c |>\nGood point - thanks for bringing it up. RomanToInt is now maintained\
    \ in its github repo here: https://github.com/jonas/roman_to_int\n<|/ c |>\n<|\
    \ c |>\n`require 'roman_to_int'` doesn't work, I had to `require 'roman_to_int.rb'`\n\
    <|/ c |>\n<| c |>\nI tested it in RubyMine and it works just fine.\n<|/ c |>\n\
    <| c |>\nWorks great on Ruby 2.1.0. Thank you!\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\nFor Ruby on Rails, the following code could be useful:\n<code>", "  roman_numerals\
    \ = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII',\
    \ 'XIII', 'XIV',\n    'C', 'D', 'CC', 'CCC', 'CD', 'D', 'DCC', 'DCCC', 'CM', 'M']\n\
    \  roman_numerals.sort!", "  return number.to_s.chars.map { |char| Roman [char.to_i\
    \ % 28, char.to_i] }.join\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis has\
    \ worked, thank you very much for the help. I wonder though, is it possible to\
    \ write this in a single function?\n<|/ c |>\n<| c |>\nI've written a similar\
    \ function [here](https://stackoverflow.com/a/52407826/495518), hope it helps\
    \ :)\n<|/ c |>\n<| a dscore=0 |>\n<code>\n  def int_to_mini_roman(number)\n  \
    \  roman = Roman [number.to_s.chars.map { |char| char.to_i }].join\n  end\n</code>\n\
    <|/ a tags=ruby,string,arrays |>\n<| c |>\nWhile this code snippet may solve the\
    \ question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| c |>\nThanks for the suggestion to include an explanation,\
    \ but this is what I tried doing. I thought it was obvious enough that I didn't\
    \ think it was worth explaining. I see now that I should have included the explanation\
    \ when I tried to edit, but as I didn't think it was a good idea, I decided to\
    \ remove it from the code snippet, which I do now have.\n<|/ c |>\n<| c |>\nYeah,\
    \ I think it's obvious enough to explain why your solution works, so why not also\
    \ include some explanation on why that would be a good way to solve the problem?\n\
    <|/ c |>\n<| c |>\nThanks, I added a little explanation on how to do this in my\
    \ own answer.\n<|/ c |>\n<| a tags=ruby,string,arrays |>\nThis is my solution\
    \ for this question:\n<code>", "  roman = Array.new\n  roman[0] = (\"M\", \"D\"\
    , \"C\", \"L\", \"X\")\n  roman[1] = (\"IV\", \"II\", \"III\", \"IV\", \"V\")\n\
    \  roman[2] = (\"IX\", \"X\", \"X\", \"L\", \"C\")\n  roman[3] = (\"V\", \"IV\"\
    , \"VI\", \"III\", \"II\")\n  roman[4] = (\"VII\", \"VIII\", \"IX\", \"XII\",\
    \ \"XIII\")\n  roman[5] = (\"XIV\", \"XV\", \"L\", \"C\", \"CL\")\n  roman[6]\
    \ = (\"CIV\", \"CI\", \"CIX\", \"L\", \"DL\")\n  roman[7] = (\"CV\", \"CV\", \"\
    IV\", \"V\", \"VI\")\n  roman[8] = (\"CCL\", \"CD\", \"CC\", \"DL\", \"DC\")\n\
    \  roman[9] = (\"CL\", \"CL\", \"X\", \"XL\", \"C\")\n  roman[10] = (\"DLL\",\
    \ \"DC\", \"DCL\", \"CCL\", \"CC\")\n  roman[11] = (\"C\", \"L\", \"C\", \"XL\"\
    , \"D\")\n  roman[12] = (\"D\", \"C\", \"C\", \"C\", \"C\")\n  roman[13] = (\"\
    CL\", \"X\", \"C\", \"L\", \"XL\")\n  roman[14] = (\"L\", \"C\", \"X\", \"C\"\
    , \"C\")\n  roman[15] = (\"DL\", \"X\", \"C\", \"L\", \"XC\")\n  roman[16] = (\"\
    C\", \"D\", \"C\", \"L\", \"CL\")\n  roman[17] = (\"C\", \"C\", \"X\", \"L\",\
    \ \"DL\")\n  roman[18] = (\"C\", \"C\", \"C\", \"L\", \"DL\")\n  roman[19] = (\"\
    C\", \"C\", \"X\", \"L\", \"CL\")\n  roman[20] = (\"C\", \"L\", \"C\", \"X\",\
    \ \"DL\")\n  roman[21] = (\"CL\", \"X\", \"C\", \"L\", \"DL\")\n  roman[22] =\
    \ (\"DL\", \"C\", \"L\", \"C\", \"CL\")\n  roman[23] = (\"L\", \"C\", \"X\", \"\
    C\", \"CL\")\n  roman[24] = (\"D\", \"C\", \"C\", \"L\", \"CL\")\n  roman[25]\
    \ = (\"D\", \"C\", \"C\", \"L\", \"DL\")\n  roman[26] = (\"D\", \"C\", \"X\",\
    \ \"L\", \"CL\")\n  roman[27] = (\"D\", \"L\", \"C\", \"X\", \"CL\")\n", "  return\
    \ '' if number < 1 || (number > 1000 && !(number % 1000)) \n  \n  roman_numerals\
    \ = {\n    1 => 'i',\n    5 => 'v',\n    10 => 'l',\n    25 => 'c',\n    50 =>\
    \ 'd',\n    100 => 'c',\n    1000 => 'm'\n  }\n  \n  result = ''\n  while number\
    \ > 0\n    roman_number, numeral = number % 1000, number / 1000\n    result +=\
    \ roman_numerals[roman_number] + numeral \n    number -= roman_number\n  end\n\
    \  \n  result.upcase\nend", "  # TODO: Convert to strings\n  roman = \"\"\n  while\
    \ number > 0\n    digit = number % 10\n    roman = roman.concat(digit.to_s)\n\
    \    number = number / 10\n  end\n  roman = roman.concat(\"I\")\n  return roman.upcase\n\
    end", "  # Split number into digits.\n  roman_digits = roman_digit_split(number)",
  "  romans = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\",\
    \ \"IX\", \"V\", \"IV\", \"I\"]\n  result = ''\n  for i in 0...(number.to_s.length\
    \ - 1)\n    result << romans[(number % 100_000_000_000).to_s.chars.index { |c|\
    \ c == '0' }] << romans[(number % 10_000_000).to_s.chars.index { |c| c == '0'\
    \ }]\n    number /= 100_000_000_000\n  end\n  result << romans[(number % 100_000).to_s.chars.index\
    \ { |c| c == '0' }] << romans[(number % 10).to_s.chars.index { |c| c == '0' }]\n\
    \  result\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\nYou could use an enumerator\
    \ to loop through the numbers and add them to an array. Then, using inject you\
    \ can add them together into a roman number:\n<code>", "  rom = ''\n  while number\
    \ > 0\n    rom += mini_roman_map[number % 1000]\n    number = (number - number\
    \ % 1000)/1000\n  end\n  rom.downcase!\n  return rom\nend", "  romans = []\n \
    \ romans.concat [ (\"i\",1), (\"ii\",2), (\"iii\",3), (\"iv\",4), (\"v\",5), (\"\
    vi\",6), (\"vii\",7), (\"viii\",8), (\"ix\",9), (\"x\",10) ]\n  romans.concat\
    \ [ (\"l\",50), (\"m\",100), (\"c\",500), (\"d\",1000), (\"cd\",5000), (\"cm\"\
    ,10000), (\"xd\",100000), (\"xcm\",1000000) ]\n  romans.concat [ (\"s\",900),\
    \ (\"m\",900), (\"c\",900), (\"d\",900), (\"cd\",900), (\"cm\",900), (\"xd\",900),\
    \ (\"xcm\",900) ]\n  romans.concat [ (\"l\",5), (\"m\",5), (\"c\",5), (\"d\",5),\
    \ (\"cd\",5), (\"cm\",5), (\"xd\",5), (\"xcm\",5) ]\n  romans.concat [ (\"s\"\
    ,4), (\"m\",4), (\"c\",4), (\"d\",4), (\"cd\",4), (\"cm\",4), (\"xd\",4), (\"\
    xcm\",4) ]\n  romans.concat [ (\"l\",3), (\"m\",3), (\"c\",3), (\"d\",3), (\"\
    cd\",3), (\"cm\",3), (\"xd\",3), (\"xcm\",3) ]\n  romans.concat [ (\"s\",2), (\"\
    m\",2), (\"c\",2), (\"d\",2), (\"cd\",2), (\"cm\",2), (\"xd\",2), (\"xcm\",2)\
    \ ]\n  romans.concat [ (\"l\",1), (\"m\",1), (\"c\",1), (\"d\",1), (\"cd\",1),\
    \ (\"cm\",1), (\"xd\",1), (\"xcm\",1) ]\n  romans.concat [ (\"s\",0), (\"m\",0),\
    \ (\"c\",0), (\"d\",0), (\"cd\",0), (\"cm\",0), (\"xd\",0), (\"xcm\",0) ]\n  if\
    \ number < 0 || number > 10000\n    throw \"Invalid input\"\n  else\n    while\
    \ number > 0\n      if romans.any? { |roman, i| roman[0] == number % i }\n   \
    \     romans.delete { |roman, i| roman[0] == number % i }\n        number /= i\n\
    \      else\n        romans.concat [ (\"m\",number), (\"c\",number), (\"d\",number),\
    \ (\"cd\",number), (\"cm\",number), (\"xd\",number), (\"xcm\",number) ]\n    \
    \    break\n      end\n    end\n    romans.sort! { |a, b| a[0] <=> ", "  num =\
    \ \"0\"\n  i = 1\n  while i < number\n    roman = roman_numeral_map.has_key?(number)\
    \ ? roman_numeral_map[number] : nil\n    if roman == nil\n      num << number\n\
    \      i += 1\n      next\n    end\n    mini_roman = (roman.first * 1000 + roman.last)\n\
    \    i += roman.size + 1\n    num << (mini_roman % 100)\n  end\n  num.downcase!\n\
    \  num\nend\n</code>\n<|/ a |>\n<| c |>\n`mini_roman = (roman.first * 1000 + roman.last)`\
    \ this was the key part for me\n<|/ c |>\n<| a |>\n<code>", "  if number < 1000:\n\
    \    roman = number\n  elif number < 9000:\n    roman = (number - 9000)\n    roman,\
    \ leftover = roman_numeral_to_int(roman)\n  else:\n    roman = (number - 45000)\n\
    \    roman, leftover = roman_numeral_to_int(roman)\n    roman += 9000 \n  \n \
    \ if roman:\n    roman = roman_numeral_to_int(roman)[0]\n  \n  return roman_numeral_to_string(roman).lower()",
  "    if number == 0\n        return '0'\n    roman = ''\n    numbers = [1000, 500,\
    \ 100, 50, 10, 5, 1]\n    while number != 0:\n        remainder = number % 1000\n\
    \        number /= 1000\n        roman += romans[remainder]\n    return roman.lower()",
  "  roman_num = ''\n  while number >= 1000\n    roman_num << roman_to_int(number\
    \ / 1000)\n    number %= 1000\n  roman_num << roman_to_int(number)\n  roman_num.downcase!\n\
    \  roman_num\nend", '  roman = Array.new', "  roman = Array.new\n  roman[0] =\
    \ int_to_roman(number)\n  roman[1] = int_to_roman(number / 10)\n  roman[2] = int_to_roman((number\
    \ % 10) + 1)\n  roman.join\nend", "  return roman_to_int(int_to_roman(number))\n\
    end", "  roman_table = {\n    0 => '',\n    1 => 'I',\n    2 => 'II',\n    3 =>\
    \ 'III',\n    4 => 'IV',\n    5 => 'V',\n    6 => 'VI',\n    7 => 'VII',\n   \
    \ 8 => 'VIII',\n    9 => 'IX',\n  }", "  if number == 0 then\n    return ''\n\
    \  roman = int_to_roman(number)\n  result = roman.sub(/(.{3})/, '\\1i')\n  if\
    \ string.lower(result) ~= result then\n    return 'Error'\n  else\n    return\
    \ result\n  end\nend", "  roman = \"\"\n  n = 1\n  while number >= n\n    roman\
    \ << ROMAN_DIGITS[number % n]\n    number /= n\n    n += 2\n  end\n  return roman.downcase\n\
    end", "\troman = ''", "  num = \"0\"\n  for i in (1..999)\n    num += string_to_roman_numeral(i)\n\
    \  end\n  return num.lcase\nend", "  roman = nil\n  roman = case number\n  when\
    \ 0 then 'zero'\n  when 1 then 'one'\n  when 2 then 'two'\n  when 3 then 'three'\n\
    \  when 4 then 'four'\n  when 5 then 'five'\n  when 6 then 'six'\n  when 7 then\
    \ 'seven'\n  when 8 then 'eight'\n  when 9 then 'nine'\n  else int_to_roman(number)\n\
    \  end\n  return roman\nend", "  return roman_numeral_to_mini_roman(number)\n\
    end", "  int_to_roman(number, \"\")\nend", "  if number.is_a?(Integer)\n    if\
    \ number < 1000 # 1 less than the number itself\n      number = number.to_s\n\
    \    else\n      number = (number / 1000).to_s\n    end\n  else\n    number =\
    \ number.to_s\n  end\n  \n  if number == \"\"\n    return \"\"\n  end\n  \n  sum\
    \ = 0\n  digits = number.reverse.split('').reverse\n  \n  numbers.each do |letter|\n\
    \    sum += letter.index(digits[sum]) * numbers[letter]\n  end\n  \n  digits.reverse!\n\
    \  sum *= -1\n  sum.times do |i|\n    digits[i] >= 10 ? digits[i] += 'M' : digits[i]\
    \ -= 'M'\n  end\n  digits.reverse!\n  \n  digits.join\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby |>\n<| a tags=ruby |>\nMy answer would be to make a hash with key\
    \ as roman and value as it's number. \nFor example \n<code>\nHash.new{|k,v| k[v]=v}\n\
    </code>\nthen convert the roman to integer and add to hash\n<|/ a dscore=0 |>\n\
    <| c |>\nThis is just a hash with one value, which is *always* the original number.\n\
    <|/ c |>\n<| a |>\nHere is a more Ruby-like way of doing it.  Using hashes seems\
    \ unnecessary, as you should be able to do this more easily with simple arrays.\
    \  Using a hash (a HashWithIndifferentAccess) seems to complicate things a bit.\
    \  Also, I had to convert the roman numerals into the numerical values, as they\
    \ would be returned as strings by Ruby.\n<code>", "  roman = []\n  i = 0\n  while\
    \ i < number\n    roman.append(int_to_roman(i))\n    i += 1\n  end\n  roman.map\
    \ { |value| value.ljust(7, '0') }.join\nend\n</code>\n<|/ a dscore=5 tags=ruby,algorithm,roman\
    \ |>\n<| c |>\nThanks, your answer was very useful. Though I wouldn't recommend\
    \ doing this in Ruby, I thought it would be good to share a similar approach in\
    \ Python.\n<|/ c |>\n<| c |>\nYeah, I realized that Ruby has its own libraries\
    \ to do this but I was just doing this in Python for simplicity's sake.\n<|/ c\
    \ |>\n<| a dscore=4 |>\nI ended up doing a lot of googling and trying to make\
    \ sense of some Ruby code written by another answer here... but ended up giving\
    \ up on that idea entirely. It's much simpler if we just use an array of the Unicode\
    \ chars that represent each digit in our roman numerals. Here's how I did it:\n\
    <code>", "  number = number.to_i\n  result = ''\n  roman_numerals = {'I': 1, 'V':\
    \ 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n  numeral_equivalent =\
    \ roman_numerals.keys.sort.take_while {|key| key > number}\n  numeral_equivalent.map\
    \ {|key| result << key }\n  result.downcase!\nend", "  roman, tens = nil\n  if\
    \ number < 0 || number > 1000 || number_in_range(1, number)\n    roman = nil\n\
    \    tens = 0\n  else\n    roman = \"\"\n    tens = number / 10\n    number =\
    \ number % 10\n    roman, tens = mini_roman_digits(number, tens)\n  end\n  roman,\
    \ tens = mini_roman_digits(number, tens)\n  roman, tens = mini_roman_digits(number,\
    \ tens)\n  roman, tens = mini_roman_digits(number, tens)\n  roman, tens = mini_roman_digits(number,\
    \ tens)\n  roman, tens = mini_roman_digits(number, tens)\n  roman, tens = mini_roman_digits(number,\
    \ tens)\n  roman, tens = mini_roman_digits(number, tens)\n  roman, tens = mini_roman_digits(number,\
    \ tens)\n  roman, tens = mini_roman_digits(number, tens)\n  roman, tens = mini_roman_digits(number,\
    \ tens)\n  roman, tens = mini_roman_digits(number, tens)\n  roman, tens = mini_roman_digits(number,\
    \ tens)\n  roman, tens = mini_roman_digits(number, tens)\n  roman, tens = mini_roman_digits(number,\
    \ tens)\n  roman, tens = mini_roman_digits(number, tens)\n  roman, tens = mini_roman_digits(number,\
    \ tens)\n  roman, tens = mini_roman_digits(number, tens)\n  roman, tens = mini_roman_digits(number,\
    \ tens)\n  roman, tens = mini_roman_digits(number, tens)\n  roman, tens = mini_roman_digits(number,\
    \ tens)\n  roman, tens = mini_roman_digits(number, tens)\n  roman, tens = mini_roman_digits(number,\
    \ tens)\n  roman, tens = mini_roman_digits(number, tens)\n  roman, tens = mini_roman_digits(number,\
    \ tens)\n  roman, tens = mini_roman_digits(number, tens)\n  roman, tens = mini_roman_digits(number,\
    \ tens)\n  roman, tens = mini_roman_digits(number, tens)\n  roman, tens = mini_roman_",
  "  roman_numeral = [nil]\n  roman_numeral[0] = nil\n  roman_numeral[1] = nil\n \
    \ roman_numeral[2] = nil\n  roman_numeral[3] = nil\n  roman_numeral[4] = nil\n\
    \  roman_numeral[5] = 'i'\n  roman_numeral[6] = 'i'\n  roman_numeral[7] = 'i'\n\
    \  roman_numeral[8] = 'i'\n  roman_numeral[9] = 'i'\n  roman_numeral[10] = 'i'\n\
    \  roman_numeral[11] = 'i'\n  roman_numeral[12] = 'i'\n  roman_numeral[13] = 'i'\n\
    \  roman_numeral[14] = 'i'\n  roman_numeral[15] = 'i'\n  roman_numeral[16] = 'i'\n\
    \  roman_numeral[17] = 'i'\n  roman_numeral[18] = 'i'\n  roman_numeral[19] = 'i'\n\
    \  roman_numeral[20] = 'i'\n  roman_numeral[21] = 'i'\n  roman_numeral[22] = 'i'\n\
    \  roman_numeral[23] = 'i'\n  roman_numeral[24] = 'i'\n  roman_numeral[25] = 'i'\n\
    \  roman_numeral[26] = 'i'\n  roman_numeral[27] = 'i'\n  roman_numeral[28] = 'i'\n\
    \  roman_numeral[29] = 'i'\n  roman_numeral[30] = 'i'\n  roman_numeral[31] = 'i'\n\
    \  roman_numeral[32] = 'i'\n  roman_numeral[33] = 'i'\n  roman_numeral[34] = 'i'\n\
    \  roman_numeral[35] = 'i'\n  roman_numeral[36] = 'i'\n  roman_numeral[37] = 'i'\n\
    \  roman_numeral[38] = 'i'\n  roman_numeral[39] = 'i'\n  roman_numeral[40] = 'i'\n\
    \  roman_numeral[41] = 'i'\n  roman_numeral[42] = 'i'\n  roman_numeral[43] = 'i'\n\
    \  roman_numeral[44] = 'i'\n  roman_numeral[45] = 'i'\n  roman_numeral[46] = 'i'\n\
    \  roman_numeral[47] = 'i'\n  roman_numeral[48] = 'i'\n  roman_numeral[49] = 'i'\n\
    \  roman_numeral[50] = 'i'\n  roman_numeral[51] = 'i'", "  roman_num_string =\
    \ ''\n  roman_numeral_map = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n  roman_numeral_map.each_with_index\
    \ do |v, index|\n    if number / index != 0\n      index = number / index\n  \
    \    number -= index * index\n    else\n      break\n    end\n    roman_numeral_map.delete_at(index)\n\
    \  end\n  roman_numeral_map.each do |x|\n    roman_num_string += \"M\"\n  end\n\
    \  roman_numeral_map.reverse!\n  roman_numeral_map.each do |x|\n    roman_num_string\
    \ += x.to_s\n  end\n  roman_num_string.downcase!\n  return roman_num_string\n\
    end", "  return roman_number[number - 1]\nend", "    if number < 1:\n        raise\
    \ ValueError(\"Parameter should be positive integer\")\n    romanString = ''\n\
    \    while number > 0:\n        remainder = number % 100\n        romanString\
    \ = romanString + miniRoman[remainder]\n        number //= 100\n    return romanString.lower()",
  "  num = number.to_i\n  roman = ''\n  roman_counter = 1\n  while roman_counter <=\
    \ num\n    roman_counter = roman_counter * 10 + roman_counter\n    roman += roman_counter.to_s[0...1]\n\
    \  end\n  return roman\nend", "  return mini_roman_map[number] if number <= TEN_TO_THE_TENTH\
    \ else\n    \"#\" if (number % 10) == 0 else mini_roman_map[number % 10]\nend",
  "  roman = Array.new\n  i = 0\n  while i < number\n    if number >= (10 + (i * 10))\
    \ \n      roman[i] = (number - ((10 * i) + 1)) / 10\n    else \n      roman[i]\
    \ = 10 * (number - ((10 * i) + 1))\n    end\n    i += 1\n  end\n  roman.reverse\n\
    \  return roman.join.to_s\nend", "  return int_to_roman(number)[0, 3].downcase\n\
    end", "  int_to_roman(number).gsub(/^-/, '')\nend", "  roman =\n    case number\n\
    \    when 0, 1\n      'm'\n    when 2..100\n      'l'\n    when 101..900\n   \
    \   'c'\n    when 901..Infinity\n      'd'\n    else\n      nil\n    end\n  return\
    \ roman if roman\n  return nil if number < 1 || !((0...9) === number.to_a)\n \
    \ roman = \"\"\n  (number.to_a * 10).map do |i|\n    roman = roman + i % 10\n\
    \  end\n  return roman.downcase\nend", "  roman = MiniRoman.to_roman(number)\n\
    \  roman = roman.to_s.downcase\n  return roman\nend", "    roman = Array.new(3)\
    \ { |i| Roman[number % 1000].romanize }\n    number = number / 1000\n    while\
    \ number > 0\n        (number % 1000).romanize.zip(roman).each { |roman, digit|\
    \ roman = roman.upcase + digit }\n        roman.shift\n        roman.slice!(0,\
    \ 2)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1, 1)\n        roman.slice!(-1,\
    \ 1)", "  return number.to_s.scan(/(\\d+)|\\D/).map do |string|\n    string.empty?\
    \ ? \"#{number}\" : roman_numbers[string] || \"#{number}#{roman_numbers['i']}\"\
    \n  end.join unless number.to_s == number.to_s.to_i\nend", "  if number.to_i >\
    \ 1000\n    return \"invalid\"\n  result = ''\n  for i in 0..number.to_i\n   \
    \ if i < 1000\n      result << \"M\"\n    else\n      result += roman_numeral[i]\n\
    \  end\n  return result.downcase\nend", "  # Your code here\n  if number < 0 or\
    \ number > 1000\n    raise ArgumentError \"Invalid input\"\n  roman = \"\"\n \
    \ roman_symbols = [\"c\", \"l\", \"c\", \"x\", \"d\"]\n  roman_numbers = [1, 5,\
    \ 10, 50, 100, 500, 1000, 5000, 10000]\n  while number > 0:\n    roman_number\
    \ = number % 1000\n    number /= 1000\n    roman += roman_symbols[roman_number]\n\
    \  return roman.downcase\nend", "  number_to_roman = {\n    1: 'I',\n    2: 'II',\n\
    \    3: 'III',\n    4: 'IV',\n    5: 'V',\n    6: 'VI',\n    7: 'VII',\n    8:\
    \ 'VIII',\n    9: 'IX',\n    10: 'X',\n    11: 'XI',\n    12: 'XII'\n  }", " \
    \ roman = ''\n  while number >= 1000\n    roman = (roman + \"M\" * number)[0..-2].upcase\n\
    \    number -= 1000\n  while number >= 100\n    roman = (roman + \"C\" * number)[0..-2].upcase\n\
    \    number -= 100\n  while number >= 10\n    roman = (roman + \"D\" * number)[0..-2].upcase\n\
    \    number -= 10\n  while number >= 1\n    roman = (roman + \"L\" * number)[0..-2].upcase\n\
    \    number -= 1\n  roman\nend", "  if number == 0\n    \"0\"\n  elsif number\
    \ < 0\n    \"-#{int_to_mini_roman(-number)}\"\n  else\n    mini_romans = %w(m\
    \ d c)\n    roman_numbers = (number / 100).divmod(10)\n    roman_numbers = [roman_numbers[0]]\
    \ + roman_numbers.map { |i| roman_numbers[1] * i}\n    roman_numbers.map! do |roman_number|\n\
    \      if roman_number < 4\n        mini_romans[roman_number]\n      else\n  \
    \      \"#{roman_number}o\"\n      end\n    end\n    mini_romans.join\n  end\n\
    end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a tags=ruby |>\nHere's my solution:\n\
    <code>", "  roman_numeral = ''\n  num_string = \"\"\n  i = 2", '  roman_str =
    Array.new', "  roman = nil\n  if number > 1000\n    raise ArgumentError, 'Invalid\
    \ argument: number too large'\n  elsif number < 0\n    raise ArgumentError, 'Invalid\
    \ argument: number too small'\n  end\n  \n  roman = ''\n  \n  if number >= 100\n\
    \    roman << 'c' \n    number = number - 100\n  elsif number >= 10\n    roman\
    \ << 'l'\n    number = number - 10\n  end\n  \n  while number >= 5\n    roman\
    \ << 'i'\n    number = number - 5\n  end\n  \n  if number > 0 && number < 5\n\
    \    roman << 'm'\n    number = number - 1\n  end\n  \n  roman\nend", "  roman\
    \ = ''\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat\
    \ 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat\
    \ 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat\
    \ 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat\
    \ 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat\
    \ 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat\
    \ 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat\
    \ 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat\
    \ 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat\
    \ 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat\
    \ 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat\
    \ 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat\
    \ 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat\
    \ 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat 'i'\n  roman.concat\
    \ 'i'\n  roman", "  if number < 1\n    raise \"Invalid Input\"\n  roman = []\n\
    \  if number <= 3999\n    roman = ['i']\n    number -= 1000\n  end\n  until number\
    \ <= 999\n    roman = ['i'] + (roman * 2)\n    number -= 100\n  end\n  until number\
    \ <= 19999\n    roman = ['i'] + roman\n    number -= 10\n  end\n  until number\
    \ <= 399999\n    roman = ['i'] + roman\n    number -= 100\n  end\n  until number\
    \ <= 49999\n    roman = ['i'] + roman\n    number -= 10\n  end\n  until number\
    \ <= 9999999\n    roman = ['i'] + roman\n    number -= 100\n  end\n  until number\
    \ <= 999999999\n    roman = ['i'] + roman\n    number -= 10\n  end\n  until number\
    \ <= 99999999999\n    roman = ['i'] + roman\n    number -= 100\n  end\n  until\
    \ number <= 999999999999999\n    roman = ['i'] + roman\n    number -= 100\n  end\n\
    \  until number <= 99999999999999999\n    roman = ['i'] + roman\n    number -=\
    \ 10\n  end\n  until number <= 9999999999999\n    roman = ['i'] + roman\n    number\
    \ -= 10\n  end\n  until number <= 999999999999999999\n    roman = ['i'] + roman\n\
    \    number -= 10\n  end\n  until number <= 99999999999999999999\n    roman =\
    \ ['i'] + roman\n    number -= 10\n  end\n  until number <= 99999999999999999999\n\
    \    roman = ['i'] + roman\n    number -= 10\n  end\n  until number <= 9999999999999999999999\n\
    \    roman = ['i'] + roman\n    number -= 10\n  end\n  until number <= 99999999999999999999999\n\
    \    roman = ['i'] + roman\n    number -= 10\n  end\n  until number <= 999999999999999999999999999\n\
    \    roman = ['i'] + roman\n    number -= 10\n  end\n  until number <= 9999999999999999999999999999\n\
    \    roman = ['i'] + roman\n    number -= 10\n  end\n  until number <= 999999999999999999999999999999\n\
    \    roman = ['i'] + roman\n    number -= 10\n  end\n  until number <= 9999999999999999999999999999999\n\
    \    roman = ['i'] + roman\n    number -= 10\n  end\n  until number <= 999999999999999999999999999999999\n\
    \    roman = ['i'] + roman\n", "  roman_numeral = \"\"\n  i = 0\n  while number\
    \ > 10\n    roman_numeral += int_to_roman(number / 10)\n    number %= 10\n  end\n\
    \  roman_numeral += int_to_roman(number)\n  roman_numeral.downcase!\n  return\
    \ roman_numeral\nend", "  roman = ''\n  roman_digits = %w(i ii iii iv v vi vii\
    \ viii ix x xi xii).map { |i| i.to_s }\n  roman_digits.reverse.each do |i|\n \
    \   digit = number % 10\n    number /= 10\n    roman << i if number > 0\n    roman\
    \ += digit if roman != '' && digit > ''\n  end\n  roman.downcase\nend", "  return\
    \ int_to_roman(number)\nend", "  roman = ''\n  n = 0\n  while number >= 1000\n\
    \    n += 1\n    number = number / 1000\n  end\n  roman = (roman * n).to_s + roman.to_s[0..n]\n\
    \  roman = roman.to_s.upcase\n  roman = roman.to_s.reverse\n  roman\nend", " \
    \ roman_numeral = ''\n  while number > 0\n    roman_numeral = ((number % 100)\
    \ + roman_numeral).roman_numeral.to_s\n    number = number / 100\n  end\n  roman_numeral\
    \ = roman_numeral.upcase\n  roman_numeral.gsub!(/[IVXLCDM]+/, '')\n  roman_numeral.gsub!(/[IV]\\\
    z/, '')\n  return roman_numeral\nend", "  if number < 0 \n    puts \"Oops, negative\
    \ numbers not supported in MiniRoman.\"\n    return nil\n  end", "  return if\
    \ number < 1 || number > 1000\n  result = ''\n  romans = %w(IX X CL L M D C M)\n\
    \  i = 1\n  while i <= number\n    if number % i == 0\n      result += romans[i\
    \ % romans.length]\n      number -= i\n    end\n    i += 1\n  end\n  result.downcase!\n\
    end", '  roman = ""', "  number = Integer(number)\n  return number.to_s.gsub(/(?<=\\\
    d)(..?)(\\d)/) { |x| [x.first, $1.upcase][$1.to_i < 2].join }\nend", "  if number\
    \ < 0\n    return nil\n  end\n  roman_digits = []\n  roman_digits[0] = ''\n  roman_digits[1]\
    \ = 'I'\n  roman_digits[2] = 'V'\n  roman_digits[3] = 'X'\n  roman_digits[4] =\
    \ 'L'\n  roman_digits[5] = 'C'\n  roman_digits[6] = 'D'\n  roman_digits[7] = 'M'\n\
    \  roman_digits[8] = 'I'\n  roman_digits[9] = 'V'\n  roman_digits[10] = 'X'\n\
    \  roman_digits[11] = 'L'\n  roman_digits[12] = 'C'\n  roman_digits[13] = 'D'\n\
    \  roman_digits[14] = 'M'\n  roman_digits[15] = 'I'\n  roman_digits[16] = 'V'\n\
    \  roman_digits[17] = 'X'\n  roman_digits[18] = 'L'\n  roman_digits[19] = 'C'\n\
    \  roman_digits[20] = 'D'\n  roman_digits[21] = 'M'\n  roman_digits[22] = 'I'\n\
    \  roman_digits[23] = 'V'\n  roman_digits[24] = 'X'\n  roman_digits[25] = 'L'\n\
    \  roman_digits[26] = 'C'\n  roman_digits[27] = 'D'\n  roman_digits[28] = 'M'\n\
    \  roman_digits[29] = 'I'\n  roman_digits[30] = 'V'\n  roman_digits[31] = 'X'\n\
    \  roman_digits[32] = 'L'\n  roman_digits[33] = 'C'\n  roman_digits[34] = 'D'\n\
    \  roman_digits[35] = 'M'\n  roman_digits[36] = 'I'\n  roman_digits[37] = 'V'\n\
    \  roman_digits[38] = 'X'\n  roman_digits[39] = 'L'\n  roman_digits[40] = 'C'\n\
    \  roman_digits[41] = 'D'\n  roman_digits[42] = 'M'\n  roman_digits[43] = 'I'\n\
    \  roman_digits[44] = 'V'\n  roman_digits[45] = 'X'\n  roman_digits[46] = 'L'\n\
    \  roman_digits[47] = 'C'\n  roman_digits[48] = 'D'\n  roman_digits[49] = 'M'\n\
    \  roman_digits[", "  roman = ''\n  temp = str(number)\n  \n  if number >= 1000\n\
    \    roman = 'M'\n  \n  if number >= 900 and number < 1000\n    roman = 'D'\n\
    \  \n  if number >= 500 and number < 900\n    roman = 'C'\n  \n  if number >=\
    \ 400 and number < 500\n    roman = 'L'\n  \n  if number >= 100 and number < 400\n\
    \    roman = 'X'\n  \n  if number >= 90 and number < 100\n    roman = 'V'\n  \n\
    \  if number >= 50 and number < 90\n    roman = 'I'\n  \n  if number >= 40 and\
    \ number < 50\n    roman = 'I'\n  \n  roman = temp + roman\n  \n  roman = roman.ljust(3)\n\
    \  roman = roman.strip\n  \n  roman.upcase!\n  \n  return roman\nend\n    ", " \
    \ roman = \"\"\n  while number >= 1000\n    roman, number = number_to_mini_roman(number),\
    \ number/1000\n  end\n  roman = number_to_mini_roman(number)\n  roman, number\
    \ = number_to_mini_roman(number), number\n  roman, number = number_to_mini_roman(number),\
    \ number\n  return roman + roman.tr('X', 'x')\nend\n  ", "  roman_number = []\n\
    \  roman_number = (0..number).to_a\n  roman_number.each do |i|\n    roman_string\
    \ = roman_number[i].roman_numeral\n    roman_string << i\n    roman_string = roman_string.downcase\n\
    \    roman_number[i] = roman_string\n  end\n  roman_number.join\nend", "  roman\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  roman_index = -1\n  while number >= 1000:\n\
    \    roman_index += 1\n    number -= 1000\n  roman_roman =   roman[roman_index]",
  "  int_to_roman(number)\nend", "  roman = Array.new\n  roman.push ('C')\n  roman.push\
    \ ('D')\n  roman.push ('M')\n  roman.push ('L')\n  roman.push ('X')\n  roman.push\
    \ ('V')\n  roman.push ('I')", "  return roman_to_int(int_to_roman(number))\nend",
  "  roman = '' \n  roman.concat(int_to_roman(number).split('').map(&:capitalize).join(''))\n\
    \  roman.concat('XXVI'.split('').map(&:capitalize).join(''))\n  roman.concat('CDI'.split('').map(&:capitalize).join(''))\n\
    \  roman.concat('XXV'.split('').map(&:capitalize).join(''))\n  roman.concat('XXX'.split('').map(&:capitalize).join(''))\n\
    \  return roman.downcase\nend", "  rom = ''\n  \n  roman = ['', 'cm', 'cd', 'xc',\
    \ 'ix', 'xl', 'lx', 'cd', 'xc', 'ix', 'xl', 'lx']\n  \n  for i in 0...(number/1000).abs\n\
    \    rom << roman[i*1000]\n    number = number.remainder(1000)\n  end\n  \n  rom\
    \ << roman[(number/100)*100]\n  \n  for i in 0...(number%100).abs\n    rom <<\
    \ roman[i*100]\n  end\n  \n  rom.to_s.downcase\nend", "  # Split number into thousands\n\
    \  number_thousands, number = number_split(number)\n  # Determine minimum number\
    \ of integers\n  min_num = 1\n  # Count integers\n  integer_count = 0\n  while\
    \ number_thousands.is_integer?\n    integer_count += 1\n    number_thousands,\
    \ number = number_split(number_thousands)\n    min_num += 1\n  end\n  # If number\
    \ is less than one, return 'invalid input'\n  return 'invalid input' if number\
    \ <= 0\n  # If number is < 1000, return 'invalid input'\n  return 'invalid input'\
    \ if number < 1000 and number > min_num\n  # If there are more than 3 integers,\
    \ return 'invalid input'\n  return 'invalid input' if integer_count > 3\n  # If\
    \ there are more than 3 thousands, return 'invalid input'\n  return 'invalid input'\
    \ if number_thousands.is_integer?\n  # Initialize return value\n  return_string\
    \ = ''\n  # Loop integers\n  while integer_count > 0\n    # Determine number of\
    \ digits in the integer\n    num_digits = digit_count(number_thousands)\n    #\
    \ Convert to decimal number in thousands\n    number_thousands = to_decimal(number_thousands)\n\
    \    # Add leading zeros to the integer if applicable\n    num_zeros_to_add =\
    \ num_digits - digit_count(number_thousands)\n    if num_zeros_to_add > 0\n  \
    \    number_thousands += 10**num_zeros_to_add\n    end\n    # Add the integer\
    \ to the return string\n    return_string += number_thousands.to_s[-num_digits:]\n\
    \    # Decrement integer count and thousands\n    integer_count -= 1\n    number_thousands\
    \ = number_split(number_thousands)[1]\n  end\n  # Return lowercase and join the\
    \ return string with dashes\n  return_string.downcase\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nI wonder how you implemented this, though. It looks incredibly\
    \ elegant. Where are you getting the string \"x\" from? That seems unlikely to\
    \ me. I'm getting \"X\" instead, which is quite different from the OP's intent.\n\
    <|/ c |>\n<| c |>\nSorry, I misunderstood your intent. I've updated the answer\
    \ to include a solution that should work.\n<|/ c |>\n<| c |>\nYour code is still\
    \ incorrect, since it is outputting the string \"c\" for the input of \"12\",\
    \ where it should output \"X\".\n<|/ c |>\n<| c |>\nThanks for the catch! I missed\
    \ that when I first wrote this solution. I've updated the answer to ", "  return\
    \ int_to_roman(number, true)\nend", "  roman = ''\n  while number >= 1000\n  \
    \  number -= 1000\n    roman += ROMANS[1000]\n  end\n  while number >= 900\n \
    \   number -= 900\n    roman += ROMANS[900]\n  end\n  while number >= 500\n  \
    \  number -= 500\n    roman += ROMANS[500]\n  end\n  while number >= 400\n   \
    \ number -= 400\n    roman += ROMANS[400]\n  end\n  while number >= 100\n    number\
    \ -= 100\n    roman += ROMANS[100]\n  end\n  while number >= 90\n    number -=\
    \ 90\n    roman += ROMANS[90]\n  end\n  while number >= 50\n    number -= 50\n\
    \    roman += ROMANS[50]\n  end\n  while number >= 40\n    number -= 40\n    roman\
    \ += ROMANS[40]\n  end\n  while number >= 10\n    number -= 10\n    roman += ROMANS[10]\n\
    \  end\n  while number >= 9\n    number -= 9\n    roman += ROMANS[9]\n  end\n\
    \  while number >= 5\n    number -= 5\n    roman += ROMANS[5] + ROMANS[5]\n  end\n\
    \  while number >= 4\n    number -= 4\n    roman += ROMANS[4] + ROMANS[4]\n  end\n\
    \  while number >= 1\n    number -= 1\n    roman += ROMANS[1] + ROMANS[1]\n  end\n\
    \  return roman\nend", "  romanized = []\n  roman = { 1000: 'M', 900: 'CM', 500:\
    \ 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5:\
    \ 'L', 4: 'V', 3: 'IV', 1: 'I' }\n  tens = { 10: '', 9: 'X', 5: 'L', 3: 'X', 1:\
    \ '' }\n  hundreds = { 100: 'C', 90: 'XL', 50: 'L', 40: 'XC', 10: 'X' }\n  while\
    \ number > 0\n    romanized = [roman[number%100] + roman[number%10], roman[number%100]].concat(roman[number%10]).concat(roman[number%100])\n\
    \    number /= 100\n  end\n  romanized = romanized.concat([hundreds[number]])\n\
    \  return romanized.join(\"\")\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\nI suggest\
    \ this:\n<code>", "  roman = ''\n  while number >= 1000:\n    roman += int_to_mini_roman(number\
    \ / 1000)\n    number %= 1000\n  roman += int_to_mini_roman(number)\n  return\
    \ roman.lower()\nend", "  roman = [\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\"\
    ,\"DCC\",\"DCCC\",\"CM\",\n    \"M\",\"MM\",\"MMM\",\"MMMM\",\"MMMMM\",\"MMMMMM\"\
    ,\"MMMMMMM\",\"MMMMMMMM\",\n    \"MMMMMMMMM\",\"Y\"]\n  roman.each do |roman|\n\
    \    if number >= roman.length\n      return roman\n    end\n    if number % roman.length\
    \ == 0\n      return(roman.to_s.split(//).map{|num| num.to_s.downcase }).join(\"\
    \")\n    end\n  end\nend", "  roman = \"C\"\n  remainder = number\n  i = 0\n \
    \ while remainder >= 10:\n    remainder -= 10\n    i += 1\n    roman += \"M\"\n\
    \  roman = roman.upcase + roman.downcase[i - 1].to_s\n  \n  if number > 1000:\n\
    \    return roman\n  \n  roman = \"\"\n  while remainder != 0:\n    remainder\
    \ = number % 10\n    number /= 10\n    roman += mini_roman[remainder]\n  return\
    \ roman.upcase + roman.downcase[0].to_s\nend", "  roman_numerals = ( 'M', 'CM',\
    \ 'D', 'CD', 'C', 'XC', 'L', 'XI', 'I', 'V', 'IV', 'I' )\n  number_as_roman =\
    \ number.to_s.chars.reverse.inject([]) do |memo, digit|\n    memo << roman_numerals[digit]\n\
    \    memo\n  end\n  number_as_roman.reverse.join\nend", "  # Special cases\n \
    \ if number < 1 OR number > 1000 then\n    return nil\n  end\n  # Initialize variables\n\
    \  roman_numeral = ''\n  numeral_symbol = ''\n  # Determine how many times the\
    \ numeral should be repeated\n  times = math.floor(math.log(number, 1000))\n \
    \ # Convert to decimal and add numeral symbol repeatedly\n  decimal_number = number.to_s.split('').map(&:to_i).reduce(:+)\n\
    \  decimal_number += 1000 * (times - 1)\n  # Handle number above 1000 without\
    \ recursion\n  if decimal_number > 1001 then\n    return nil\n  end\n  while decimal_number\
    \ >= 1000 do\n    # Convert number from base 1000 (times base to times) and multiply\
    \ by 1000\n    roman_numeral = decimal_number % 1000 + (roman_numeral * 1000)\n\
    \    # Divide by base 1000\n    decimal_number = decimal_number / 1000\n    #\
    \ Add numeral symbol\n    roman_numeral += numeral_symbol\n  end\n  return roman_numeral.upcase\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThe second example doesn't work for\
    \ me. It should be `26.to_mini_roman` not `26.mini_roman`. But other than that\
    \ it works perfectly well. Thanks\n<|/ c |>\n<| c |>\n: Yes, you're right. I fixed\
    \ my post.\n<|/ c |>\n<| a dscore=2 |>\nI wrote a gem to do this in Rails. \n\
    https://github.com/jcupitt/roman_numerals\n<code>\nrequire \"roman_numerals\"\n\
    RomanNumerals.to_arabic(19)", "  roman_numeral_map = {\n    1 => 'I',\n    9 =>\
    \ 'CM',\n    10 => 'D',\n    40 => 'CD',\n    50 => 'C',\n    60 => 'XC',\n  \
    \  90 => 'XL',\n    100 => 'X',\n    400 => 'XL',\n    500 => 'L',\n    600 =>\
    \ 'X',\n    1000 => 'IX',\n  }\n  roman_numeral_array = roman_numeral_map.values\n\
    \  roman_numeral_array.concat(roman_numeral_map.keys)\n  roman_numeral_array.delete_if\
    \ {|x| x < number }\n  roman_numeral_array.delete_if {|x| x > number }\n  roman_numeral_array.delete_if\
    \ {|x| x == 0 }\n  roman_numeral_array.each_with_index do |x, index|\n    roman_numeral_array.delete_at(index)\
    \ if x == (number / index)\n  end\n  roman_numeral_array.sort!\n  roman_numeral_array.reverse!\n\
    \  roman_numeral_array.each do |x|\n    if x == 1\n      x.to_s.capitalize\n \
    \   elsif x == 9\n      x.to_s.upcase\n    else\n      x.to_s.capitalize\n   \
    \ end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nCould you clarify your\
    \ answer by explaining how your solution differs from others?\n<|/ c |>\n<| c\
    \ |>\nWhile this code snippet may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| c |>\nThanks for the comment, I have updated the\
    \ answer to explain that my solution does not require any additional gems or methods.\n\
    <|/ c |>\n<| a |>\nI created an enumerable of roman numerals and then I used map\
    \ to iterate through the array of symbols:\n<code>\nRONUMERALS = %w[I IV VI IX\
    \ XI XXI]\nRONUMERALS.map { |x| x.to_s.upcase } # => [\"I\", \"IV\", \"VI\", \"\
    IX\", \"XI\", \"XXI\"]\n", "  roman_numerals = {}\n  roman_numerals['I'] = 1000\n\
    \  roman_numerals['V'] = 500\n  roman_numerals['X'] = 400\n  roman_numerals['L']\
    \ = 100\n  roman_numerals['C'] = 90\n  roman_numerals['D'] = 80\n  roman_numerals['M']\
    \ = 50\n  roman_numerals['I'] = 1", "  return roman_to_int_map.keys.select { |k|\
    \ k >= number }.map { |k| roman_to_int_map[k] }.join\nend", "  if number.nil?\
    \ || number == 0\n    return nil\n  end\n  if number < 1 || number > 1000\n  \
    \  return nil\n  end\n  roman = Array.new\n  while number > 0\n    roman.insert(0,\
    \ %w[CC CD DC DD XC XD XX].shift)\n    number -= roman.shift\n  end\n  return\
    \ roman.join\nend\n</pre>\n            </div>\n          </div>\n          \n\
    \          \n          \n            \n            <div class=\"pilwrap \">\n\
    \              <a class=\"pilcrow\" href=\"#section-2\">&#182;</a>\n         \
    \   </div>\n            \n            <p>\n          Now, that we have all the\
    \ code we need to do the actual work, we can start writing\n  the actual application.\n\
    </p>", "  roman = []\n  roman_number = number\n  while roman_number > 0\n    roman_number\
    \ -= 10\n    roman.unshift(roman_to_int[roman_number])\n  roman.join(\" \")\n\
    end", "  # Implement your own code here.\n  roman = \"M\"\n  remainder = number\
    \ % 1000\n  if remainder < 500:\n    roman = \"C\"\n  elif remainder < 1000:\n\
    \    roman = \"D\"\n  elif remainder < 4000:\n    roman = \"Cx\"\n  else:\n  \
    \  roman = \"Cxx\"\n  return(roman)\n</cell>\n<text>\nProblem 4\nConvert the number\
    \ 1 into the corresponding roman numeral: I.\nThis function should take one parameter\
    \ -- a positive integer. \nIf the given number is 1, you should return 'I'.",
  "  # Find the largest number that fits in our current digits\n  number = number.to_i\n\
    \  digits = number.digits(10)", "  roman = \"\"\n  \n  if number > 1000\n    roman\
    \ = int_to_mini_roman(number / 1000)\n  end\n  \n  roman = roman + int_to_mini_roman_helper(number)\n\
    \  \n  return roman\nend", "  roman = {\n    1 => 'i',\n    2 => 'ii',\n    3\
    \ => 'iii',\n    4 => 'iv',\n    5 => 'v',\n    6 => 'vi',\n    7 => 'vii',\n\
    \    8 => 'viii',\n    9 => 'ix',\n    10 => 'x',\n    11 => 'xi',\n    12 =>\
    \ 'xii',\n    13 => 'xiv',\n    14 => 'xv',\n    15 => 'xvi',\n    16 => 'xvii',\n\
    \    17 => 'xviii',\n    18 => 'xix',\n  }\n  roman_number = number.to_s.split(//).map\
    \ do |i| \n    roman[i.to_i]\n  end.compact.join\n  roman_number.upcase\nend",
  "  roman = ''\n  i = 0\n  while i < 4 do\n    roman = roman + roman_to_index[number%10]\n\
    \    number = number/10\n    i += 1\n  end\n  while i < 1 do\n    roman = roman\
    \ + roman_to_index[number%10]\n    number = number/10\n    i += 1\n  end\n  roman\
    \ = roman + roman_to_index[number]\n  return roman\nend", "  roman = \"\"\n  num\
    \ = \"\"\n  while number >= 1000\n    roman += \"M\"\n    number -= 1000\n  while\
    \ number >= 900\n    roman += \"CM\"\n    number -= 900\n  while number >= 500\n\
    \    roman += \"D\"\n    number -= 500\n  while number >= 400\n    roman += \"\
    CD\"\n    number -= 400\n  while number >= 100\n    roman += \"C\"\n    number\
    \ -= 100\n  while number >= 90\n    roman += \"XC\"\n    number -= 90\n  while\
    \ number >= 50\n    roman += \"L\"\n    number -= 50\n  while number >= 40\n \
    \   roman += \"XL\"\n    number -= 40\n  while number >= 10\n    roman += \"X\"\
    \n    number -= 10\n  while number >= 9\n    roman += \"IX\"\n    number -= 9\n\
    \  while number >= 5\n    roman += \"V\"\n    number -= 5\n  while number >= 4\n\
    \    roman += \"IV\"\n    number -= 4\n  while number >= 1\n    roman += \"I\"\
    \n    number -= 1\n  num += \"9\"\n  while number >= 1\n    num += \"9\"\n   \
    \ number -= 1\n  roman += num.to_s\n  roman = roman.to_s\n  roman = roman.downcase\n\
    \  return roman\nend", "  rom = ''\n  while number > 1000\n    number /= 1000\n\
    \    rom += 'M'\n  end\n  number %= 1000\n  while number > 9\n    rom = (number%10)\
    \ + rom\n    number /= 10\n  end\n  rom = (number%10) + rom\n  return rom.downcase\n\
    end", "  roman = MiniRoman # Default value\n  roman.roman_numerals.each do |x|\n\
    \    if number >= x.from\n      roman.roman_numerals.delete(x.from)\n      roman.roman_numerals.delete(x.to)\n\
    \      roman.roman_numerals << x.to(x.from-1)\n      roman.roman_numerals << x.to(x.from-1)\n\
    \      roman.roman_numerals << x.to(x.from-1)\n      number = number-x.from-1\n\
    \      break\n    end\n  end\n  return roman.to_s\nend", "  result = ''\n  roman_numerals\
    \ = 'IVXLCDM'\n  while number > 0\n    result << roman_numerals[number % 10]\n\
    \    number /= 10\n  result.downcase!\n  result\nend", "  roman = [nil]\n  roman.push(nil)\n\
    \  roman.push(nil)\n  roman.push(nil)\n  roman.push(nil)", "  return int_to_roman(roman_to_int(int_to_mini_roman(number)))\
    \ if number > 0 and number <= 1000 else ''\nend", "  return roman_to_int(int_to_roman(number))\
    \ + int_to_roman(number).downcase\nend", "  int_to_roman(number, true)\nend",
  "    roman = String.new\n    # Iterate over all roman numerals.\n    roman_numerals\
    \ = ::MiniRoman - Roman + Roman + Roman + ::MiniRoman\n    roman_numerals.each\
    \ do |numeral|\n        roman = roman + numeral\n        if number < numeral.to_i\n\
    \            break\n        end\n    end\n    roman\nend", "  int_to_roman(number,\
    \ \"\")\nend", "  roman = MiniRoman.new(number)\n  roman.to_s.downcase\nend",
  "  return int_to_roman(number).downcase\nend", "  roman = \"i\"\n  numeral_map =\
    \ {\n    1 => \"i\",\n    9 => \"ii\",\n    4 => \"v\",\n    6 => \"vi\",\n  \
    \  5 => \"vii\",\n    3 => \"ix\",\n    2 => \"x\",\n    8 => \"xii\",\n  }\n\
    \  roman_numeral_map  = {\n    \"i\" => 1,\n    \"ii\" => 2,\n    \"v\" => 3,\n\
    \    \"vi\" => 4,\n    \"vii\" => 5,\n    \"ix\" => 6,\n    \"x\" => 7,\n    \"\
    xii\" => 8,\n  }\n  roman_numeral_map.each do |k,v|\n    roman.sub! /^#{k}/, v\n\
    \  end\n  roman\nend", "  roman_numeral = MiniRoman.to_roman(number)\n  roman_numeral.downcase!\n\
    \  roman_numeral.gsub!(/\\W/, '')\n  roman_numeral.gsub!(/^[^cm]*|cm/, '')\n \
    \ return roman_numeral\nend", "  roman = Array.new()\n  roman[0] = \"\"\n  roman[1]\
    \ = MiniRomanNumerals[number % 10]\n  number /= 10\n  roman[2] = MiniRomanNumerals[number\
    \ % 10]\n  number /= 10\n  roman[3] = MiniRomanNumerals[number % 10]\n  number\
    \ /= 10\n  roman[4] = MiniRomanNumerals[number % 10]\n  roman = roman.join('')\n\
    \  return roman.downcase\nend", "  rom = [\"\"] * 1001\n  roman = 0\n  i = 0\n\
    \  while i < number\n    roman *= 100\n    roman += number[i].to_i\n    i += 1\n\
    \  end\n  rom << roman.to_s\n  rom.reverse!\n  return rom.join('')\nend", "  mini_roman\
    \ = ''\n  roman_numeral = Array.new\n  roman_numeral = [ '', 'I', 'II', 'III',\
    \ 'IV', 'V', 'VI', 'VII', 'VIII', 'IX' ]\n  roman_numeral_reverse = Array.new\n\
    \  roman_numeral_reverse = [ '', 'X', 'XX', 'XXX', 'XL', 'L', 'XC', 'LX', 'LXX',\
    \ 'LXXX', 'XC' ]\n  roman_numeral_roman = Array.new\n  roman_numeral_roman = [\
    \ '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX' ]\n  roman_numeral_reverse\
    \ = Array.new\n  roman_numeral_reverse = [ '', 'X', 'XX', 'XXX', 'XL', 'L', 'XC',\
    \ 'LX', 'LXX', 'LXXX', 'XC' ]\n  roman_numeral_roman = Array.new\n  roman_numeral_roman\
    \ = [ '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX' ]\n  roman_numeral_reverse\
    \ = Array.new\n  roman_numeral_reverse = [ '', 'X', 'XX', 'XXX', 'XL', 'L', 'XC',\
    \ 'LX', 'LXX', 'LXXX', 'XC' ]\n  roman_numeral_roman = Array.new\n  roman_numeral_roman\
    \ = [ '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX' ]\n  roman_numeral_reverse\
    \ = Array.new\n  roman_numeral_reverse = [ '', 'X', 'XX', 'XXX', 'XL', 'L', 'XC',\
    \ 'LX', 'LXX', 'LXXX', 'XC' ]\n  roman_numeral_roman = Array.new\n  roman_numeral_roman\
    \ = [ '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX' ]\n  roman_numeral_reverse\
    \ = Array.new\n  roman_numeral_reverse = [ '', 'X', 'XX', 'XXX', 'XL', 'L', 'XC',\
    \ 'LX', 'LXX', 'LXXX', 'XC' ]\n  roman_numeral_roman = Array.new\n  roman_numeral_roman\
    \ = [ '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX' ]\n  roman_numeral_reverse\
    \ = Array.new\n  roman_numeral_reverse = [ '', 'X', 'XX', 'XXX', 'XL', 'L', 'XC',\
    \ 'LX', 'LXX', 'LXXX', 'XC' ]\n", "  roman = ''\n  number = number.to_i\n  roman_table\
    \ = {0 => '', 1 => 'I', 2 => 'II', 3 => 'III', 4 => 'IV', 5 => 'V', 6 => 'VI',\
    \ 7 => 'VII', 8 => 'VIII', 9 => 'IX'}\n  while number > 0\n    roman_table.each\
    \ do |key, value|\n      current_number = number % 1000\n      roman_number =\
    \ current_number/1000\n      roman = value + roman_table[key] + roman_number\n\
    \      number = number - current_number*1000\n    end\n  end\n  roman\nend", " \
    \ roman = Array.new\n  roman.push nil\n  roman.push 'C'\n  roman.push 'D'\n  roman.push\
    \ 'M'\n  roman.push 'L'\n  roman.push 'X'\n  roman.push 'V'\n  roman.push 'I'\n\
    \  roman.push 'X'\n  roman.push 'I'\n  roman.push 'I'\n  roman.push 'I'\n  roman.push\
    \ 'I'\n  roman.push 'II'\n  roman.push 'III'\n  roman.push 'IV'\n  roman.push\
    \ 'V'\n  roman.push 'V'\n  roman.push 'V'\n  roman.push 'V'\n  roman.push 'V'\n\
    \  roman.push 'V'\n  roman.push 'V'\n  roman.push 'V'\n  roman.push 'V'\n  roman.push\
    \ 'V'\n  roman.push 'V'\n  roman.push 'V'\n  roman.push 'X'\n  roman.push 'X'\n\
    \  roman.push 'X'\n  roman.push 'X'\n  roman.push 'X'\n  roman.push 'X'\n  roman.push\
    \ 'X'\n  roman.push 'X'\n  roman.push 'X'\n  roman.push 'X'\n  roman.push 'X'\n\
    \  roman.push 'X'\n  roman.push 'X'\n  roman.push 'X'\n  roman.push 'X'\n  roman.push\
    \ 'X'\n  roman.push 'X'\n  roman.push 'X'\n  roman.push 'X'\n  roman.push 'X'\n\
    \  roman.push 'X'\n  roman.push 'X'\n  roman.push 'X'\n  roman.push 'X'\n  roman.push\
    \ 'X'\n  roman.push 'X'\n  roman.push 'X'\n  roman.push 'X'\n  roman.push 'X'",
  "  roman = \"\"\n  roman_numerals = []\n  roman_numerals << \"x\"\n  roman_numerals\
    \ << \"i\"\n  roman_numerals << \"ii\"\n  roman_numerals << \"iii\"\n  roman_numerals\
    \ << \"iv\"\n  roman_numerals << \"v\"\n  roman_numerals << \"vi\"\n  roman_numerals\
    \ << \"vii\"\n  roman_numerals << \"viii\"\n  roman_numerals << \"ix\"\n  roman_numerals\
    \ << \"x\"\n  roman_numerals << \"xix\"\n  roman_numerals << \"xiv\"\n  roman_numerals\
    \ << \"xvi\"\n  roman_numerals << \"xvii\"\n  roman_numerals << \"xviii\"\n  roman_numerals\
    \ << \"xix\"\n  roman_numerals << \"xix\"", "  roman_number = ''\n  i = 1\n  while\
    \ number > i:\n    if number % i == 0\n      roman_number << i\n      number -=\
    \ i\n    else\n      roman_number << i\n      roman_number << 0\n    end\n   \
    \ i += 1\n  end\n  roman_number\nend", "    roman_numeral = ''\n    i = 0\n  \
    \  \n    while i < number\n        roman_numeral += roman_numeral_string[i]\n\
    \        \n        if number >= (4 * i) and number <= (4 * i + 4)\n          \
    \  roman_numeral += \"l\"\n            \n        elif number >= (4 * i) and number\
    \ <= (4 * i + 1)\n            roman_numeral += \"c\"\n            \n        elif\
    \ number >= (4 * i) and number <= (4 * i + 3)\n            roman_numeral += \"\
    v\"\n            \n        elif number >= (4 * i) and number <= (4 * i + 6)\n\
    \            roman_numeral += \"d\"\n            \n        elif number >= (4 *\
    \ i) and number <= (4 * i + 9)\n            roman_numeral += \"m\"\n         \
    \   \n        i += 1\n        \n    return roman_numeral.lower()\nend\n</cell>\n\
    <code language=julia-1.6>\nmini_roman_numbers = [\n    \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\",\n    \"XI\", \"XII\"\
    , \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\",\n    \"XIX\", \"XX\"\
    , \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\",\n    \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXI\", \"XXII\", \"XXIII\",\n    \"XXIV\", \"XXV\"\
    , \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\",\n]\n</cell>\n<code language=julia-1.6>",
  "  roman = ''\n  roman_numeral = int_to_roman_numeral(number)\n  for i in range(len(roman_numeral)):\n\
    \    roman += roman_numeral[i]\n    roman += ' '\n  return roman.downcase\nend",
  "  roman_number = ''\n  int_to_roman(number, roman_number)\n  roman_number.downcase!\n\
    \  roman_number\nend", '  roman_number = []', "  roman_numeral = ''\n  roman_numeral\
    \ = roman_numeral.concat(int_to_mini_roman_reverse(number)) \n  roman_numeral\
    \ = roman_numeral.concat(int_to_mini_roman_shift(number)) \n  roman_numeral =\
    \ roman_numeral.concat(int_to_mini_roman_shift(number)) \n  roman_numeral = roman_numeral.concat(int_to_mini_roman_reverse(number))\n\
    \  roman_numeral.downcase!\n  return roman_numeral\nend", "  if number.to_i <=\
    \ 1000\n    roman_num = ''\n    roman_num = roman_num + int_to_roman(number)\n\
    \    roman_num = roman_num.downcase\n  end\n  return roman_num\nend", "  number\
    \ = number.to_i\n  roman_numeral = ''\n  roman_numeral << RM_DICT[number] if number\
    \ in RM_DICT else ''\n  roman_numeral << RM_DICT[number - 100] if number >= 100\
    \ and number < 1000 else ''\n  roman_numeral.downcase!\n  return roman_numeral\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
