name: HumanEval_147_get_max_triples
language: rb
prompt: "# You are given a positive integer n. You have to create an integer array\
  \ a of length n.\n# For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i\
  \ - i + 1.\n# Return the number of triples (a[i], a[j], a[k]) of a where i < j <\
  \ k, \n# and a[i] + a[j] + a[k] is a multiple of 3.\n# Example :\n# Input: n = 5\n\
  # Output: 1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is\
  \ (1, 7, 13).\ndef get_max_triples(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_max_triples\n\
  \    candidate = method(:get_max_triples)\n    assert_equal(1, candidate.call(5))\n\
  \    assert_equal(4, candidate.call(6))\n    assert_equal(36, candidate.call(10))\n\
  \    assert_equal(53361, candidate.call(100))\n  end\nend\n"
completions: ["  count = 0\n  for i in 1...n\n    if i % 3 == 0\n      count += 1\n\
    \    end\n  end\n  count\nend\n</cell>\n<code language=julia-1.6>\nget_max_triples(10)\n\
    </cell>\n<text>\nProblem 18", "  a=Array.new(n)\n  for i in 0..n-1\n    a[i]=i*i-i+1\n\
    \  end\n  return a.select {|i| i%3==0}.length\nend", "  # Your code here\n  result=0\n\
    \  a=[0 for i in range(n)]\n  for i in range(n):\n    if a[i] % 3 == 0 and a[i]\
    \ > 0 and a[i] < n:\n      result+=1\n      a[i] = a[i] + a[i]\n  return result",
  "  a = []\n  for i in (1..n)\n    a.push(i * i - i + 1)\n  a.sort!\n  for i in (1..n-1)\n\
    \    for j in (i+1..n)\n      if a[i] + a[j] + a[k] == 3 \n        puts [i, j,\
    \ k]\n        break\n    end\n  end\nend", "  return 3 * (n ** 3 - 3 * (n ** 2\
    \ - 1) * (n - 1)) / 3\nend", "  nums = Array.new(n)\n  nums[0] = 1\n  for i in\
    \ 1..n\n    nums[i] = i * i - i + 1  \n  triple = 0\n  for i in 1..n\n    for\
    \ j in (i + 1 .. n)\n      k = j - 1\n      while k > 0 && a[k] == nums[i] * a[j]\
    \ * nums[k]\n        triple = triple + 1\n        k = k - 1\n      end\n    end\n\
    \  end\n  return triple\nend", "    \n    # O(1)\n    a = (1..n).to_a\n    \n\
    \    # O(n)\n    a.select{ |i| i < a.size - 1 }.each do |i|\n      j = i + 1\n\
    \      while j < a.size\n        k = j + 1\n        while k < a.size\n       \
    \   break unless a[i] < a[j] && a[i] < a[k]\n          k += 1\n        end\n \
    \       j += 1\n      end\n    end", "    max = nil\n    for i in 0...n\n    \
    \    if a[i] > max\n            max = a[i]\n        end\n    end\n    return max\n\
    end\n</code>\nI hope this helps, if you have any questions let me know.\n<|/ a\
    \ tags=ruby,algorithm |>\n<| c |>\nThank you for this solution! I have been struggling\
    \ with this for a while, and this is the first time that I've gotten so many good\
    \ answers and explanations. I have one question: what is \"nil\"? Is it the object\
    \ nil?\n<|/ c |>\n<| c |>\nNil is the ruby equivalent of the null pointer, `null`\
    \ in Java and C#\n<|/ c |>\n<| a dscore=0 tags=ruby,algorithm |>\nHere's a recursive\
    \ solution:\n<code>", "  arr = Array.new(n)\n  1.upto(n) do |i|\n    arr[i] =\
    \ i * i - i + 1\n  end\n  count = 0\n  arr.each do |i|\n    arr.each do |j|\n\
    \      arr.each do |k|\n        if i + j + k == 3 * i\n          count += 1\n\
    \        end\n      end\n    end\n  end\n  return count\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis doesn't work if there are multiple pairs that sum to 3.\n\
    <|/ c |>\n<| c |>\nIf there are multiple pairs that sum to 3, then it's not a\
    \ valid triple. Please read question carefully before answering.\n<|/ c |>\n<|\
    \ c |>\nThe code only works if there are no pairs that sum to 3. It fails in that\
    \ case and therefore is not a solution.\n<|/ c |>\n<| a tags=ruby dscore=2 |>\n\
    Here is an alternative solution using Array#combination\n<code>", "  i = 0\n \
    \ j = 0\n  k = 0\n  a.push(1) while i <= n\n  a.push(1) while j <= n\n  a.push(1)\
    \ while k <= n\n  \n  i , j , k = 0\n  while i < n\n  \n  while j < n\n  \n  while\
    \ k <= n\n  \n  while i < n\n  \n  while j < n\n  \n  while k <= n\n  \n  while\
    \ i < n\n  \n  while j < n\n  \n  while k <= n\n  \n  while i < n\n  \n  while\
    \ j < n\n  \n  while k <= n\n  \n  while i < n\n  \n  while j < n\n  \n  while\
    \ k <= n\n  \n  while i < n\n  \n  while j < n\n  \n  while k <= n\n  \n  while\
    \ i < n\n  \n  while j < n\n  \n  while k <= n\n  \n  while i < n\n  \n  while\
    \ j < n\n  \n  while k <= n\n  \n  while i < n\n  \n  while j < n\n  \n  while\
    \ k <= n\n  \n  while i < n\n  \n  while j < n\n  \n  while k <= n\n  \n  while\
    \ i < n\n  \n  while j < n\n  \n  while k <= n\n  \n  while i < n\n  \n  while\
    \ j < n\n  \n  while k <= n\n  \n  while i < n\n  \n  while j < n\n  \n  while\
    \ k <= n\n  \n  while i < n\n  \n  while j < n\n  \n  while k <= n\n  \n  while\
    \ i < n\n  \n  while j < n\n  \n  while k <= n\n  \n  while i < n\n  \n  while\
    \ j < n\n  \n  while k <= n\n  \n  while i < n\n  \n  while j < n\n  \n  while\
    \ k <= n\n  \n  while i < n\n  \n  while j < n\n  \n  while k <= n\n  \n  while\
    \ i < n\n  \n  while j < n\n  \n  while k <= n\n  \n  while i < n\n  \n  while\
    \ j < n\n  \n  while k <= n\n  \n  while i < n\n  \n  while j < n\n  \n  while\
    \ k <= n\n  \n  while i < n", "  a = (1..n).to_a\n  i = 0\n  while i < n\n   \
    \ j = i + 1\n    while j < n\n      k = j + 1\n      while k < n\n        if a[i]\
    \ < a[j] && a[i] < a[k] && a[j] < a[k]\n          return (j - k + 1)\n       \
    \ end\n        k += 1\n      end\n      j += 1\n    end\n    i += 1\n  end\n \
    \ return -1\nend", "  a.each do |i|\n    i.times do |j|\n      if j < i\n    \
    \    j += 1\n      elsif j > i\n        i += 1\n      end\n    end\n  end\nend",
  "    \n    a.push(1) \n    \n    for i in 1...n do \n       if a.pop() != nil then\
    \ \n           j = a.pop() \n           if a.pop() != nil then \n            \
    \   k = a.pop() \n               if a.pop() != nil then \n                   if\
    \ a[i] + a[j] + a[k] == 0 then \n                       a.pop_back() \n      \
    \             else \n                       a.pop_back() \n               else\
    \ \n                   a.pop_back() \n           else \n               a.pop_back()\
    \ \n       else \n           a.pop_back() \n       end \n    end \n    return\
    \ a.size \nend \n</code>\n<|/ a tags=arrays,algorithm,ruby,ruby-on-rails dscore=1\
    \ |>\n<| c |>\nThis is in fact a correct answer. There must be some mistake though.\
    \ Because it gives the following output for n = 5: `[[], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [],\
    \ [], [], [], [], ", "  array = [1 ... n]\n  array.each_with_index do |i, index|\n\
    \    if index != 0\n      next\n    end\n    array[i] = array[i] - array[i] +\
    \ array[index - 1]\n  end\n  array.each_with_index do |i, index|\n    if index\
    \ != 0\n      next\n    end\n    array[i] = array[i] % 3\n  end\nend\n</cell>\n\
    <cell>", "    arr = Array.new(n)\n    arr[0] = arr[1] = arr[2] = 1\n    arr.each_with_index\
    \ do |el, i|\n      if i <> n\n        arr[i+2] > arr[i+1] and arr[i+2] > arr[i]\
    \ and arr[i+2] > arr[i-1]\n      end\n    end\n    arr.uniq.length\n  end\n  \n\
    \  # Return the number of consecutive integers in a that are evenly divisible\
    \ by b.\n  # If b is evenly divisible by all elements of a, then return the length\
    \ of a.\n  # If b is evenly divisible by no elements of a, return 0.\n  # Explanation:\n\
    \  # Given an integer array a and a number b.\n  # Return number of elements in\
    \ a, that are evenly divisible by b.\n  # If b is evenly divisible by all elements\
    \ of a, then return the length of a.\n  # If b is evenly divisible by no elements\
    \ of a, return 0.\n  def get_consecutive(a, b)\n    if a.length == 0 then 0\n\
    \    else a.select { |e| e % b == 0 }.size\n    end\n  end\n  \n  # Return the\
    \ number of consecutive integers in a that are evenly divisible by b.\n  # If\
    \ b is evenly divisible by all elements of a, then return the length of a.\n \
    \ # If b is evenly divisible by no elements of a, return 0.\n  def get_consecutive_odd(a,\
    \ b)\n    if a.length == 0 then 0\n    else a.select { |e| e % b == 0 }.select\
    \ { |e| e % 2 == 0 }.size\n    end\n  end\n  \n  # Return the number of consecutive\
    \ integers in a that are odd.\n  # If b is odd, then return the length of a.\n\
    \  # If b is evenly divisible by no elements of a, return 0.\n  def get_consecutive_odd_even(a,\
    \ b)\n    if a.length == 0 then 0\n    else a.select { |e| e % b == 0 }.select\
    \ { |e| e % 2 == 1 }.size\n    end\n  end\n  \n  # Return the number of consecutive\
    \ integers in a that are odd.\n  # If b is odd, then return the length of a.\n\
    \  # If b is evenly divisible by no elements of a, return 0.\n  def get_consecutive_even(a,\
    \ b)\n    if a.length == 0 then 0\n    else a.select { |e| e % b == 0 }.select\
    \ { |e| e % 2 == 0 }.size\n    end\n  end\n  \n  # Return the number of elements\
    \ in a, that is a multiple of b. \n  # If b is evenly divisible by all elements\
    \ of a, then return the length of a.\n  # If b is evenly divisible by ", "  a\
    \ = Array.new(n) { |i| i * i - i + 1 }\n  (0..n-1).each do |i|\n    for j in 0..i-1\n\
    \      a[j] += a[j+1] + a[j+2]\n    end\n  end \n  a.select { |x| x <= 3*3*3 }.length\n\
    end", "    triples = 0\n    if n >= 3\n        arr = [1, 3, 7, 13, 21]\n     \
    \   for i in range(2, n)\n            if arr[i] % 3 == 0\n                triples+=1\n\
    \    return triples\nend", "  a = []\n  for i in 0..n-1\n    a[i] = i*i-1+i+1\n\
    \  max_triples = 0\n  for i in 0..n-1\n    for j in i+1..n-1\n      for k in j+1..n-1\n\
    \        if a[i] + a[j] + a[k] % 3 == 0\n          max_triples +=1\n  p p p p\
    \ p p p p p p p\n  p p p p p p p p p p p\n  p p p p p p p p p p p\n  p p p p p\
    \ p p p p p p\n  p p p p p p p p p p p\n  p p p p p p p p p p p\n  p p p p p p\
    \ p p p p p\n  p p p p p p p p p p p\n  p p p p p p p p p p p p\n  p p p p p p\
    \ p p p p p p\n  p p p p p p p p p p p p\n  p p p p p p p p p p p p\n  p p p p\
    \ p p p p p p p p\n  p p p p p p p p p p p p\n  p p p p p p p p p p p p\n  p p\
    \ p p p p p p p p p p\n  p p p p p p p p p p p p\n  p p p p p p p p p p p p\n\
    \  p p p p p p p p p p p p\n  p p p p p p p p p p p p\n  p p p p p p p p p p p\
    \ p\n  p p p p p p p p p p p p\n  p p p p p p p p p p p p\n  p p p p p p p p p\
    \ p p p\n  p p p p p p p p p p p p\n  p p p p p p p p p p p p\n  p p p p p p p\
    \ p p p p p\n  p p p p p p p p p p p p p\n  p p p p p p p p p p p p p\n  p p p\
    \ p p p p p p p p p p\n  p p p p p p p p p p p p p\n  p p p p p p p p p p p p\
    \ p\n  p ", "  a = Array.new(n)\n  for i in 1..n\n    a[i] = i*i - i + 1\n  end\n\
    \  \n  count = 0\n  for i in 0..n-1\n    for j in i+1..n\n      k = j + 1\n  \
    \    while k <= n\n        if a[i] == a[j] + a[k]\n          count += 1\n    \
    \    end\n        k += 1\n      end\n    end\n  end\n  \n  return count\nend\n\
    </cell>\n<code language=julia-1.0>\nget_max_triples(5)\n</cell>\n<code language=julia-1.0>\n\
    function get_triples(n)\n  a = Array.new(n)\n  for i in 1..n\n    a[i] = i*i -\
    \ i + 1\n  end\n  \n  count = 0\n  for i in 0..n-1\n    for j in i+1..n\n    \
    \  k = j + 1\n      while k <= n\n        if a[i] <= a[j] + a[k]\n          count\
    \ += 1\n        end\n        k += 1\n      end\n    end\n  end\n  \n  return count\n\
    end\n</cell>\n<code language=julia-1.0>\nget_triples(5)\n</cell>\n<code language=julia-1.0>\n\
    function get_triples_upto(n)\n  a = Array.new(n)\n  for i in 1..n\n    a[i] =\
    \ i*i - i + 1\n  end\n  \n  count = 0\n  for i in 0..n-1\n    for j in i+1..n\n\
    \      k = j + 1\n      while k <= n\n        if a[i] <= a[j] + a[k]\n       \
    \   count += 1\n        end\n        k += 1\n      end\n    end\n  end\n  \n \
    \ return count\nend\n</cell>\n<code language=julia-1.0>\nget_triples_upto(5)\n\
    </cell>\n<code language=julia-1.0>\nfunction get_triples_downto(n)\n  a = Array.new(n)\n\
    \  for i in 1..n\n    a[i] = i*i - i + 1\n  end\n  \n  count = 0\n  for i in n-1..1\n\
    \    for j in i+1..n\n      k = j + 1\n      while k <= n\n        if a[i] <=\
    \ a[j] + a[k]\n          count += 1\n        end\n        k += 1\n      end\n\
    \    end\n  end\n  \n  return count\nend\n</cell>\n<code language=julia-1.0>\n\
    get_triples_downto(5)\n</cell>\n<code language=julia-1.0>\nfunction get_triples_upto_downto(n)\n\
    \  a = Array.new(n)\n  for i in 1..n\n    a[i] = i*i - i + 1\n  end\n  \n  count\
    \ = 0\n  for i in n-1..1\n    for j in i+1..n\n      k = j + 1\n      ", "  a\
    \ = []\n  for i in (1..n)\n    a.push(i * i - i + 1)\n  a.sort.sort\n  count =\
    \ 0\n  for i in (1..n)\n    for j in (1..n)\n      if a[i] > a[j] and i < j\n\
    \        count += 3\n  return count\nend", "  max_triples = 0\n  a = Array.new(n){|i|\
    \ i * i - i + 1}\n  (a.length - 1).downto(0) do |i|\n    (a.length - 1).downto(i\
    \ - 1) do |j|\n      (a.length - 1).downto(i - j) do |k|\n        if a[i] && a[j]\
    \ && a[k]\n          max_triples += 1 if a[i] + a[j] + a[k] % 3 == 0\n       \
    \ end\n      end\n    end\n  end\n  max_triples\nend\n</code>\n<|/ a |>\n<| a\
    \ tags=ruby |>\nHere is a solution using Ruby's enumerable methods:\n<code>",
  "    arr.concat(1..n)\n    arr.each_cons(3){|arr| arr.each_cons(3){|arr| arr.max}}\n\
    end", "\ttriples = 0\n\ta = Array.new(n){1..n}\n\tfor i in (0..n-1)\n\t\tfor j\
    \ in (i+1..n-1)\n\t\t\tfor k in (j+1..n-1)\n\t\t\t\tif a[i] < a[j] && a[j] < a[k]\n\
    \t\t\t\t\tif a[i] < a[i] + a[j] && a[j] < a[j] + a[k]\n\t\t\t\t\t\tif a[i] < a[i]\
    \ + a[j] + a[k]\n\t\t\t\t\t\t\ttriples += 1\n\t\t\t\t\t\t\tbreak \n\t\t\t\t\t\
    end \n\t\t\t\tend \n\t\t\tend \n\t\tend \n\tend \n\tputs \"The triplet count is\
    \ #{triples}\" \n\treturn triples \nend \nget_max_triples(5)\n</cell>\n<cell>",
  "  a = [1, 3, 7, 13, 21]\n  a.size.times do |i|\n    a.each do |j|\n      a.each\
    \ do |k|\n        if i == j && j == k && j >= i && a[i] + a[j] + a[k] % 3 == 0\n\
    \          return i + 1\n        end\n      end\n    end\n  end\nend", "  a =\
    \ Array.new(n)\n  a[0] = a[1] = 1\n  result = 0\n  for i in range(1, n)\n    result\
    \ = (result * 3) % n\n    \n    if a[i] < result \n      a[i] = result\n    \n\
    \  puts \"The triples of a where i < j < k and a[i] + a[j] + a[k] is a multiple\
    \ of 3 are: #{a.map {|i| [i, i, i]}}.inspect\"\n  puts \"The number of triples\
    \ of a where i < j < k and a[i] + a[j] + a[k] is a multiple of 3 is: #{a.size}\"\
    \nend\nget_max_triples(5)", "  count = 0\n  a = []\n  for _ in 1...n\n    a.push(0)\n\
    \  end\n  a.each_with_index do |num, i|\n    if num % 3 == 0\n      count += 1\n\
    \      next\n    end\n    count = count + 1 if num + 1 == i + 1\n    count = count\
    \ + 1 if num + 2 == i + 1\n  end\n  count\nend", "  # Your code here\n  a=[]\n\
    \  i=1\n  while i<=n\n    a[i]=i*i-2\n    i+=1\n  max_j=n\n  max_k=n\n  while\
    \ 1\n    i=n\n    while 1\n      j=n\n      while 1\n        a[i]=i*i-2\n    \
    \    i+=1\n        if j>max_j\n          max_j=j\n        j+=1\n        if i>max_k\n\
    \          max_k=i\n        i+=1\n        if max_j==max_k\n          break\n \
    \     break\n    j=n\n    while 1\n      k=n\n      while 1\n        a[i]=i*i-2\n\
    \        i+=1\n        if j>max_j\n          max_j=j\n        j+=1\n        if\
    \ k>max_k\n          max_k=k\n        k+=1\n        if max_j==max_k\n        \
    \  break\n      break\n    if max_j==max_k\n      return 0\n    i+=1\n  max_j=n\n\
    \  max_k=n\n  while 1\n    i=n\n    while 1\n      j=n\n      while 1\n      \
    \  a[i]=i*i-2\n        i+=1\n        if j>max_j\n          max_j=j\n        j+=1\n\
    \        if k>max_k\n          max_k=k\n        k+=1\n        if max_j==max_k\n\
    \          break\n      break\n    k= n\n    while 1\n      k=n\n      while 1\n\
    \        a[i]=i*i-2\n        i+=1\n        if j>max_j\n          max_j=j\n   \
    \     j+=1\n        if k>max_k\n          max_k=k\n        k+=1\n        if max_j==max_k\n\
    \          break\n      break\n    if max_j==max_k\n      return 0\n    i+=1\n\
    \  end\n  return 1\nend\nprint get_max_triples(10)\nputs get_max_triples(20)\n\
    puts get_max_triples(100)\nputs get_max_triples(1000)\nputs get_max_triples(10000)\n\
    puts get_max_triples(100000)\nputs get_max_triples(1000000)\nputs get_max_triples(10000000)\n\
    puts get_max_triples(100000000)\nputs get_max_triples(1000000000)\nputs get_max_triples(10000000000)\n\
    puts get_max_triples(100000000000)\nputs get_max_triples(1000000000000)\nputs\
    \ get_max_triples(10000000000000)\nputs get_max_triples(100000000000000)\nputs\
    \ get_max_triple", "  count = 0\n  a = Array.new(n - 1)\n  (0..n-1).each do |i|\n\
    \    a[i] = i * i - i + 1\n  end\n  (0..n-2).each do |i|\n    (1..n-1).each do\
    \ |j|\n      (1..n-1).each do |k|\n        if a[i] < a[j] && a[i] < a[k] && a[j]\
    \ < a[k]\n          count += 1\n        end\n      end\n    end\n  end\n  return\
    \ count\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI believe that the solution\
    \ without using loops is possible by means of recursion.\n<code>", "  a = Array.new(n)\n\
    \  a[0] = n\n  for i in 1..n\n    a[i] = a[i-1]\n  end\n  a.sort\n  \n  count\
    \ = 0\n  for i in 0..(n-1)\n    for j in (i+1)..n\n      if a[i] + a[j] + a[k]\
    \ == 0\n        count += 1\n      end\n    end\n  end\n  \n  count\nend\n</pre>\n\
    <p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 4\n<strong>Output:</strong>\
    \ 4\n<strong>Explanation:</strong> The number of triples (a[i], a[j], a[k]) of\
    \ a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3 is: \n  a[1]\
    \ = 1 * 1 + 3 = 4 \n  a[2] = 1 * 2 + 3 = 5 \n  a[3] = 1 * 3 + 3 = 6 \n</pre>\n\
    <p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 6\n<strong>Output:</strong>\
    \ 3\n<strong>Explanation:</strong> The number of triples (a[i], a[j], a[k]) of\
    \ a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3 is: \n  a[1]\
    \ = 1 * 1 + 3 = 4 \n  a[2] = 1 * 2 + 3 = 5 \n  a[3] = 1 * 3 + 3 = 6 \n  a[4] =\
    \ 2 * 1 + 3 = 8 \n  a[5] = 2 * 2 + 3 = 10 \n  a[6] = 2 * 3 + 3 = 11 \n</pre>\n\
    <p>\_</p>\n<p><strong>Constraints:</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;=\
    \ 1000</code></li>\n</ul>\n</div></div><br><br><hr><br>*********************************<div\
    \ id=\"title\">697. Maximum Number of Jumps</div>\n*********************************<div\
    \ class=\"content__u3I1 question-content__JfgR\"><div><p>Given a binary search\
    \ tree (BST), you are required to find the maximum number of jumps to get to the\
    \ root of the tree. In the <strong>binary search tree</strong> each node has a\
    \ value between 0 and n - 1.</p>\n<ul>\n<li>A <strong>jump</strong> is when you\
    \ <strong>insert</strong> a new node into a <strong>already existing node</strong>\
    \ at the <strong>right</strong> position.</li>\n</ul>\n<p>In other words, you\
    \ can insert a new node <em>v</em> into the BST such that the left subtree (0-indexed)\
    \ of this new node contains the <em>rightmost</em> node (value less than or equal\
    \ to\_v) and the right subtree (1-indexed) contains the <em>rightmost</em> node\
    \ (value greater than or equal to\_v) of your new node <em>v</em>.</p>\n<p>Write\
    \ a function to find the <strong>maximum</strong> number of jumps.</p>\n<p>\_\
    </p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> root =\
    \ [1,4,10,null,13,3,8,null,null,null,", "  max_triples = 0\n  a = [0, 0, 0]\n\
    \  for i in (1..n-1)\n    a[i] = i * i - i + 1 \n  end\n  for i in (1..n-1)\n\
    \    for j in (1..n-1)\n      for k in (1..n-1)\n        if a[i] < a[j] && a[i]\
    \ < a[k] && a[j] < a[k]\n          max_triples += 1\n        end\n      end\n\
    \    end\n  end\n  return max_triples\nend", "  a = [1, 3, 7, 13, 21]\n  a.each_index\
    \ do |i|\n    if i + 1 < n\n      j = i + 1\n      while j < n\n        k =  j\
    \ + 1\n        while k < n\n          a.each do |x|\n            if x == a[i]\
    \ && x == a[j] && x == a[k]\n              return a\n            end\n       \
    \   end\n          k += 1\n        end\n        j += 1\n      end\n    end\n \
    \ end\n  return a\nend", "  a = Array.new(n)\n  for i in 1..n\n    a[i] = i *\
    \ i - i + 1\n  end\n  counter = 0\n  for i in 1..n\n    for j in 1..n\n      for\
    \ k in 1..n\n        if i != j && i != k && j != k\n          counter += a[i +\
    \ j + k]\n        end\n      end\n    end\n  end\n  return counter\nend", "  a\
    \ = Array.new(n){1..n}\n  a.each do |i|\n    a.delete_if {|j| j > i}\n  end\n\
    \  a.inject(0){|sum, val| sum + val}\nend", "    arr = []\n    i = 0\n    while\
    \ i < n\n        arr << i * i - i + 1\n        i += 1\n    return arr.count{|x|\
    \ x * x * x == 3}\nend\n</cell>\n<code language=julia-0.5>\nfunction main()\n\
    \    show(@time get_max_triples(5))\nend", "  count = Hash.new(0)\n  for i in\
    \ (1..n)\n    if i%3 == 0 \n      count[i] += 1\n    end\n  end\n  return count\n\
    end", "  arr = []\n  for i in 1..n\n    if i\n      arr << i * i - i + 1\n   \
    \   end\n      end\n  return arr.find { |v| v % 3 == 0 }\nend\n</code>\n<|/ a\
    \ dscore=1 tags=ruby,arrays,algorithm |>\n<| c |>\nCan you describe your algorithm?\
    \ What do you mean by \"your algorithm\"? What does the first loop do? What does\
    \ the second loop do?\n<|/ c |>\n<| c |>\nI added the explanation into the answer\n\
    <|/ c |>\n<| c |>\nThe explanation is good, but I cannot understand the first\
    \ `for` loop. It does exactly what `arr.select! {|v| v % 3 == 0} does. `select!`\
    \ modifies the array in-place and so you don't need to return it.\n<|/ c |>\n\
    <| c |>\nYou are right, the two loops can be merged into one. But the question\
    \ is about the complexity of two loops, so I didn't want to change too much of\
    \ the code :)\n<|/ c |>\n<| c |>\nAh. My bad. Didn't see you were calling `count`\
    \ on the array. Yes, that is an O(N) operation. Thanks. Sorry, but I still don't\
    \ understand why you use the `select!` method instead of `find` since `select!`\
    \ doesn't modify the array and `find` does.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\nYou can do it by iterating on array only once and then using two accumulators.\n\
    <code>", "  a = []\n  a.push(1)\n  (1..n).each do |i|\n    a.push(i.*(3-1))\n\
    \    a.push(i+1)\n  end\n  a.each do |i|\n    a.each_index do |j|\n      a.each_index\
    \ do |k|\n        if i==j and j==k and (i*i-i-i)%3==0 then \n          return\
    \ i+1\n        end\n      end\n    end\n  end\n  return -1\nend", "  a = Array.new(n)\n\
    \  \n  # For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n\
    \  for i in 1..n\n    a.push(i * i - i + 1)\n  end", "  a = []\n  for i in 1..n\n\
    \    a.push(i * i - i + 1)\n  a.each_with_index do |num, i|\n    if num == 3\n\
    \      return i\n    end\n  end\nend", "  a = Array.new(n)\n  (0...n).each {\n\
    \    a[$_] = $_ * $_ - $_ +$1\n  }\n  (1...n).each { |i| a[i] = i * a[i] - i +\
    \ 1 }\n  (0...n).each { |i|\n    j = i + 1\n    k = n\n    while j <=k\n     \
    \ if a[i] + a[j] + a[k] % 3 == 0\n        return k\n      end\n      j += 1\n\
    \      k += 1\n    }\n  }\n  0\nend", "  a = Array.new(1..n, 0).to_a\n  triple\
    \ = 0\n  for i in 1..n\n    a[i - 1] = (i * i - i + 1) / 2\n    triple = triple\
    \ + 1 if a[i] + a[j] + a[k] == (i * i - i + 1) % 3\n  end\n  return triple\nend",
  "\ta = Array.new(n)\n\ta.each_index do |i|\n\t\ta[i] = i * i - i + 1\n\tend\n\t\
    res = a.select do |x|\n\t\tx < 100\n\tend\n\tres.count\nend\n</cell>\n<cell>",
  "  a = []\n  for i in 1...n\n    a.push i * i - i + 1\n  count = 0\n  for i in a\n\
    \    count = count + (i > a[-1] and i > 0)\n  end\n  return count\nend", "  a\
    \ = []\n  for i in 1..n\n    if i >= a.length\n      a.push(i)\n      i += 1 \n\
    \    end\n  end\n  \n  triples = 0\n  for i in 0..n\n    for j in 0..n\n     \
    \ for k in 0..n\n        if i < j && j < k && i < k\n          triples += 1\n\
    \        end\n      end\n    end\n  end\n  \n  return triples\nend", "  i = 0\n\
    \  j = 0\n  k = 0\n  a = Array.new(n)\n  while i < n do\n    if a[i] < 3 then\n\
    \      i += 1\n    else \n      j += 1\n      while j < n do\n        if a[j]\
    \ < 3 then\n          j += 1\n        else\n          k += 1\n          while\
    \ k < n do\n            if a[k] < 3 then\n              k += 1\n            else\n\
    \              a[k] += a[k-1] + a[j]\n              k -= 1\n            end\n\
    \          end\n        end\n      end\n      i += 1\n    end\n  end\n  puts a.size\n\
    end", "    sum = [0]*n\n    (sum[0], sum[1], sum[2]) = (0, 0, 0)\n    (sum[0],\
    \ sum[1], sum[2]) = (0, 0, 0)\n    (sum[0], sum[1], sum[2]) = (0, 0, 0)\n    for\
    \ i in 1..n\n        for j in (i+1)..n\n            for k in (j+1)..n\n      \
    \          a = [(i*i - j + 1)..k]\n                if sum[a[0]] <= sum[a[1]] +\
    \ sum[a[2]]\n                    sum[a[0]] += sum[a[1]] + sum[a[2]]\n        \
    \        end\n            end\n        end\n    end\n    return sum[0]\nend\n\
    print get_max_triples(4)", "  return get_triples(n, 1, n).size\nend\n</cell>\n\
    <code language=julia-1.4>\n@assert get_max_triples(10) == 5\n</cell>\n<code language=julia-1.4>",
  "  a = (1..n).to_a\n  a.size.times do |i|\n    a.size.times do |j|\n      a.size.times\
    \ do |k|\n        return i if i + j < k + i && a[i] + a[j] + a[k] % 3 == 0\n \
    \     end\n    end\n  end\nend\n</cell>\n<code language=conda-root-py>\na = (1..5).to_a\n\
    </cell>\n<code language=conda-root-py>", "  a = []\n  for i = 1 ... n\n    a.push(i\
    \ * i - i + 1)\n  a.sort!\n  \n  count = 0\n  \n  for i in a \n    if i != a[i-1]\
    \ + a[j] + a[k]\n      count += 3\n    end\n  end\n  \n  count\nend\n</cell>\n\
    <code language=julia-1.6>", "    i = n\n    a.clear\n    while i > 0\n       \
    \ a[i] = i * i - i + 1\n        i = i - 1\n    return a.length\nend\n</code>\n\
    <|/ a |>\n<| a |>\n<code>", "  a = [1, 3, 7, 13, 21]\n  count = 0\n  for i in\
    \ a\n    for j in a\n      for k in a\n        if i < j < k\n          count +=\
    \ 3\n          break\n      break\n  end\n  return count\nend\n</code>\n<|/ a\
    \ tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nUsing Array#product\n<code>",
  "\ta = []\n\tfor i in 1..n\n\t\ta << i * i - i + 1\n\tend\n\treturn a.inject(:+)\n\
    end", "  a = [1, 2]\n  for i in 1...n\n    # remove a[i] + a[j] and a[j] form\
    \ the array\n    a.delete_at(a.index(i))\n    # find a[i] by binary search\n \
    \   if i > a[n]\n      return 0\n    end\n    # find a[j] by binary search\n \
    \   if j > a[n]\n      j = a[n]\n    end\n    # find a[k] by binary search\n \
    \   if k > (a[n] - 1)\n      k = a[n]\n    end\n    # add a[i] and a[j] with a[k]\n\
    \    a.insert(k, a[i] + (a[j] - a[i]))\n  end\n  # get the sum of all elements\
    \ of array a\n  sum = 0\n  for i in 0..a[n]\n    sum += a[i]\n  end\n  return\
    \ sum % 3 == 0\nend", "  a = (0..2*n).to_a\n  count = 0\n  for i in a\n    count\
    \ = count + a.sum if a[i] < 3*a[i+1] else count\n    count = count + a.sum if\
    \ a[i] > 3*a[i+1] else count\n  end\n  return count\nend", "  a = []\n  1.upto(n-1)\
    \ do |x|\n    a.push(x*x-x+1)\n  end\n  a.sort!\n  a.size.downto(0) - 2 \nend",
  "  triple = Array.new(n)\n  for i in (1..n)\n    triple[i] = i*i - i + 1 \n  \n\
    \  sum = 0\n  for i in (1..n)\n    sum += triple[i]\n    \n  sum % 3 == 0 ? triples.times\
    \ do\n    triples.each do |i|\n      sum += triple[i]\n    end\n  end\n  \n  sum\
    \ % 3 == 0 ? triple : 0\nend", "\ta = Array.new(n)\n\tfor i in 1...n\n\t\ta[i]\
    \ = i * i - i + 1\n\tend", "  a = Array.new(n)\n  a.each_index { |i| a[i] = i\
    \ * i - i + 1 }\n  count = 0\n  a.each_index do |i|\n    j = i + 1\n    k = i\
    \ + 2\n    count += 1 if a[i] > a[j] && a[i] > a[k]\n    count += 1 if a[j] >\
    \ a[i] && a[j] > a[k]\n    count += 1 if a[k] > a[i] && a[k] > a[j]\n  end\n \
    \ count\nend\n</cell>\n<cell>", "  \n  if n == 0 \n    return 0\n  \n  a = Array.new(n)\n\
    \  a[0] = 1\n  \n  for i in 1...n\n    a[i] = i * i - i + 1\n  end\n  \n  count\
    \ = 0\n  \n  for i in 1...n\n    for j in 1...i\n      count = count + a[j] *\
    \ a[j] * a[k]\n    end\n  end\n  \n  return count\nend", "  max_triples = 0\n\
    \  arr.each_with_index do |val, index|\n    arr[index] += 1 unless index % 3 ==\
    \ 0\n  end\n  \n  arr.each_with_index do |val, index|\n    arr[index] -= 1 unless\
    \ index % 3 == 0\n  end\n  \n  arr.each_with_index do |val, index|\n    arr[index]\
    \ += 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index do |val, index|\n\
    \    arr[index] -= 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index do\
    \ |val, index|\n    arr[index] += 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr[index] -= 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr[index] += 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr[index] -= 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr[index] += 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr[index] -= 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr[index] += 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr[index] -= 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr[index] += 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr[index] -= 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr[index] += 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr[index] -= 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr[index] += 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr[index] -= 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr[index] += 1 unless index % 3 == 0\n  end\n  \n  arr.each_with_index\
    \ do |val, index|\n    arr", "    count = 0\n    \n    array = Array.new(n)\n\
    \    for i in 0..n-1\n        array[i] = i\n    end", "    a.fill 0 #initialize\
    \ array\n    a.fill(0) #reset array to 0\n    for i in 1...n\n        \n     \
    \   if a[i..i..i].sum % 3 == 0 #check if a[i] is multiple of 3\n            return\
    \ a[i..i..i].size #return size of array\nend\n</cell>\n<code language=julia-1.5>\n\
    @time triples = get_max_triples(5)\n</cell>\n<code language=julia-1.5>\n@time\
    \ triples = get_max_triples(100000)\n</cell>\n<code language=julia-1.5>\n@time\
    \ triples = get_max_triples(2000000)\n</cell>\n<code language=julia-1.5>\n@time\
    \ triples = get_max_triples(20000000)\n</cell>\n<code language=julia-1.5>\n@time\
    \ triples = get_max_triples(30000000)\n</cell>\n<text>\nConsider the following\
    \ two scenarios:", "  triples = Array.new(2) { Array.new(3) { 0 } }\n  for i in\
    \ (1..n).to_a do \n    triples[i - 1][0] += i * i - i + 1\n    triples[i - 1][1]\
    \ += i * i - i + 1\n    triples[i - 1][2] += i * i - i + 1\n  end\n  return triples.find\
    \ { |i| i[0] + i[1] + i[2] == 3 }[0].size\nend", "  a = Array.new(n) { |i| i*i-1+1\
    \ }\n  a.each { |i| a.delete_at(i) }\n  a.each { |i| a.delete_at(i) }\n  a.each\
    \ { |i| a.delete_at(i) }\n  a.each { |i| a.delete_at(i) }\n  a.delete_at(0)\n\
    \  a.each { |i| a.delete_at(i) }\n  a.delete_at(0)\n  a.each { |i| a.delete_at(i)\
    \ }\n  a.delete_at(0)\n  a.each { |i| a.delete_at(i) }\n  a.delete_at(0)\n  a.each\
    \ { |i| a.delete_at(i) }\n  a.delete_at(0)\n  a.each { |i| a.delete_at(i) }\n\
    \  a.delete_at(0)\n  a.each { |i| a.delete_at(i) }\n  a.delete_at(0)\n  a.each\
    \ { |i| a.delete_at(i) }\n  a.delete_at(0)\n  a.each { |i| a.delete_at(i) }\n\
    \  a.delete_at(0)\n  a.each { |i| a.delete_at(i) }\n  a.delete_at(0)\n  a.each\
    \ { |i| a.delete_at(i) }\n  a.delete_at(0)\n  a.each { |i| a.delete_at(i) }\n\
    \  a.delete_at(0)\n  a.each { |i| a.delete_at(i) }\n  a.delete_at(0)\n  a.each\
    \ { |i| a.delete_at(i) }\n  a.delete_at(0)\n  a.each { |i| a.delete_at(i) }\n\
    \  a.delete_at(0)\n  a.each { |i| a.delete_at(i) }\n  a.delete_at(0)\n  a.each\
    \ { |i| a.delete_at(i) }\n  a.delete_at(0)\n  a.each { |i| a.delete_at(i) }\n\
    \  a.delete_at(0)\n  a.each { |i| a.delete_at(i) }\n  a.delete_at(0)\n  a.each\
    \ { |i| a.delete_at(i) }\n  a.delete_at(0)\n  a.each { |i| a.delete_at(i) }\n\
    \  a.delete_at(0)\n  a.each { |i| a.delete_at(i) }\n  a.delete_at(0)\n  a.each\
    \ { |i| a.delete_at(i) }\n", "  arr = []\n  for i in 1..n\n    arr[i] = i * i\
    \ - i + 1\n  end\n  max_triple_count = 0\n  max_triple_sum = 0\n  for i in 0..(n-1)\n\
    \    for j in 0..(n-1)\n      for k in 0..(n-1)\n        triple_sum = arr[i] +\
    \ arr[j] + arr[k]\n        if triple_sum % 3 == 0\n          triple_count = triple_sum\
    \ / 3\n          if triple_count > max_triple_count\n            max_triple_count\
    \ = triple_count\n            max_triple_sum = triple_sum\n          end\n   \
    \     end\n      end\n    end\n  end\n  max_triple_count\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| c |>\n`arr[i] = i * i - i + 1` is also the sum of `n` natural\
    \ numbers from 0 to `n-1`. Why not simply `arr.sum`?\n<|/ c |>\n<| c |>\nBecause\
    \ my professor insists on solving this problem using loops, recursion and arrays.\n\
    <|/ c |>\n<| a |>\n<code>", "    count = 0\n    a = [nil]*n\n    a.fill(0) # fill\
    \ the array with zeros\n    a.each_with_index do |value, index|\n        a[index]\
    \ = value*value - value + 1 # update the value based on index value\n        if\
    \ a[index] % 3 == 0\n            count += 1\n        end\n    end\n    return\
    \ count\nend", "  a = Array.new(n)\n  for i in 1..n\n    a[i] = i * i - i + 1\n\
    \  end\n  return a.select { |i| i < j && j + i < k && a[i] + a[j] + a[k] == i*i*i\
    \ }.length\nend", "  a = (1..n).to_a\n  count = 0\n  for i in a\n    for j in\
    \ a\n      for k in a\n        if i+j+k == a[i]+a[j]+a[k]\n          count = count\
    \ + 1\n          break\n  return count\nend\nprint(get_max_triples(5)) #should\
    \ be 1\nprint(get_max_triples(7)) #should be 0\nprint(get_max_triples(2)) #should\
    \ be 0\nprint(get_max_triples(3)) #should be 1\nprint(get_max_triples(4)) #should\
    \ be 0\nprint(get_max_triples(10)) #should be 24\nprint(get_max_triples(40000))\
    \ #should be 11302233360\nprint(get_max_triples(80000)) #should be 511302233360\n\
    print(get_max_triples(10)) #should be 24\nprint(get_max_triples(100)) #should\
    \ be 24\nprint(get_max_triples(300)) #should be 24\nprint(get_max_triples(80000))\
    \ #should be 511302233360\nprint(get_max_triples(120000)) #should be 2511302233360\n\
    print(get_max_triples(140000)) #should be 411302233360\nprint(get_max_triples(160000))\
    \ #should be 4011302233360\nprint(get_max_triples(180000)) #should be 31102233360\n\
    print(get_max_triples(200000)) #should be 2411302233360\nprint(get_max_triples(240000))\
    \ #should be 311302233360\nprint(get_max_triples(240000)) #should be 311302233360\n\
    print(get_max_triples(240000)) #should be 311302233360\nprint(get_max_triples(240000))\
    \ #should be 311302233360\nprint(get_max_triples(240000)) #should be 311302233360\n\
    print(get_max_triples(240000)) #should be 311302233360\nprint(get_max_triples(240000))\
    \ #should be 311302233360\nprint(get_max_triples(240000)) #should be 311302233360\n\
    print(get_max_triples(240000)) #should be 311302233360\nprint(get_max_triples(240000))\
    \ #should be 311302233360\nprint(get_max_triples(240000)) #should be 311302233360\n\
    print(get_max_triples(240000)) #should be 311302233360\nprint(get_max_triples(240000))\
    \ #should be 311302233360\nprint(get_max_triples(240000)) #should be 311302233360\n\
    print(get_max_triples(", "  triples = 0\n  i = 0\n  a = Array.new(n) { 0 }\n \
    \ while i < n\n    a[i] = i * i - i + 1\n    i += 1\n  end\n  i = n-1\n  while\
    \ i >= 0\n    j = i\n    while j > 0\n      k = j - 1\n      while k > 0\n   \
    \     triples = triples + a[j] + a[k] - 3\n        k -= 1\n      end\n      j\
    \ -= 1\n    end\n    i -= 1\n  end\n  return trips\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nI believe you might be able to remove a lot of the inner loops since you're\
    \ not using it for anything. The inner most `while` loop doesn't seem to be doing\
    \ much. Just a comment that I don't really understand what it's supposed to do\
    \ since it seems like it's just setting variables that are never used.\n<|/ c\
    \ |>\n<| a tags=ruby,algorithm,ruby-on-rails,performance,big-o dscore=2 |>\nThis\
    \ is my solution in Python. I believe it will perform in O(N).\n<code>", "  #\
    \ Write your code here.\n  a = []\n  a.push 1\n  a.push 3\n  a.push 7\n  a.push\
    \ 13\n  a.push 21\n  a.each do |i|\n    a.push i*i\n    a.push i+1\n    a.push\
    \ i*i + i+1\n  end\n  i = 0\n  j = 1\n  k = 2\n  while i < j and j < k\n    if\
    \ a[i] + a[j] + a[k] == 3 * 3 * 3\n      i += 1\n      j += 1\n      k += 1\n\
    \    elsif a[i] + a[j] + a[k] == 0\n      i += 1\n      j += 1\n    else\n   \
    \   k += 1\n    end\n  end\n  return i\nend", "  a = []\n  (0...n).each do |i|\n\
    \    a[i..n] = Array.new(n - i + 1) do |j|\n      j + i\n    end\n  end\n  count\
    \ = 0\n  a.each do |i|\n    a.each do |j|\n      a.each do |k|\n        if k >\
    \ i && k > j && k > j\n          if k > i * i + i + a[k - i]\n            count\
    \ = count + 1\n          end\n        end\n      end\n    end\n  end\n  return\
    \ count\nend\n</code>\n<|/ a dscore=3 tags=algorithm,ruby |>\n<| c |>\nNice solution.\
    \ +1. However `a[k - i]` should be `a[j - i]`, since `j-1` is the position of\
    \ `k`.\n<|/ c |>\n<| c |>\nI do not know about Ruby, but in `c` you would write\
    \ `for(int i = 0; i < (n-1); ++i) { for (int j = 0; j < (n-i); ++j) { for(int\
    \ k = 0; k < (n-i); ++k) { if (k > i && k > j && k > j) if (k > i * i + i + a[k\
    \ - i]) ++count; } } } return count; }` (and of course in ruby, `(0...n).each\
    \ {|i| a[i..n] = Array.new(n - i + 1) {|j| j + i }}; count = 0; a.each {|i| a.each\
    \ {|j| a.each {|k| if (k > i && k > j && k > j) if (k > i * i + i + a[k - i])\
    \ ++count;}}}}; return count;` )\n<|/ c |>\n<| c |>\n, thanks for pointing out\
    \ the typo.\n<|/ c |>\n<| c |>\nThis seems like it could work but I'm not clear\
    \ on what it means when the if statement is `k > i*i+i+a[k-i] ` . Since `i` is\
    \ the index of the triple `(i, j, k)`, shouldn't `k` be the position of `i`? Like\
    \ `k = 3` when `i` is `1` since `1+1+3 == 3`.\n<|/ c |>\n<| c |>\n, that is the\
    \ idea behind `a[j - i]`. When `i = j - i = k - i` we get the position of `i`\
    \ in the array `a[j]`.\n<|/ c |>\n<| a dscore=2 |>\nYou can use the following\
    \ code to find all triplets:\n<code>", "  arr = []\n  arr.push(1)\n  while arr.size\
    \ != n\n    arr.push(arr.last * arr.last - arr.last + 1)\n    arr.shift\n  end\n\
    \  arr.each_index { |i| arr[i] = arr[i] + arr[i] - 1 }\n  arr.reduce(0) { |sum,\
    \ val| sum + val % 3 == 0 ? val : 0 }\nend\n</code>\n<code>\nn = 5\na = %w|1 3\
    \ 7 13 21|\nb.times do\n  puts a.zip(get_max_triples(n)).map{|a, b| [a, b]}\n\
    end", "    # write your code here\n    arr = Array.new(n)\n    arr.each_index\
    \ do |i|\n        arr[i] = i * i - i + 1\n    end\n    arr.each do |i|\n     \
    \   a.each_index do |j|\n            a.each_index do |k|\n                if a[i]\
    \ < a[j] && a[j] < a[k]\n                    puts \"#{a[i]} #{a[j]} #{a[k]}\"\n\
    \                end\n            end\n        end\n    end\nend", "  a = Array.new(n)\
    \ { |i| i * i - i + 1 }\n  max_count = 0\n  (0...n).each do |i|\n    3.times do\
    \ |j|\n      max_count = i + (j + 1) * max_count if a[i + j] % 3 == 0\n    end\n\
    \  end\n  max_count\nend", "  a = []\n  for i=0 ... n\n    a.push(i*(i-1)+i+1)\n\
    \  end\n  a.sort {|a,b| b <=> a} # sort in ascending order\n  count = 0\n  (0...n).each\
    \ do |i|\n    count += 1 if a[i] < a[i] + a[i] + a[i]\n  end\n  count\nend", " \
    \ a = Array.new(n)\n  a[0] = a[1] = a[2] = 1\n  for i in 1..n\n    j = i+1\n \
    \   while j < a.length and a[j] == a[i-1]\n      j+=1\n    if j < a.length and\
    \ a[j] == a[i-1]\n      return j - i\n    i += 1\n  return 0\nend", "  a = Array.new(n)\n\
    \  a.map! { |n| n * n - 2 * n }\n  count = 0\n  for i in 1..n\n    j = n - i -\
    \ 1\n    if a[i] < a[j] && a[i] < a[j + 1]\n      count += 1\n    end\n  end\n\
    \  return count\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm,mathematical-optimization\
    \ |>\n<| c |>\nCan you explain to me what your code is doing? I understand the\
    \ first part, but I don't understand the `- 2 * n` part.\n<|/ c |>\n<| c |>\n\
    For each `i` the value of `a[i]` is calculated by `i * i - i + 1`. We want our\
    \ array to be sorted in increasing order. With this `- 2 * n` we move all negative\
    \ values to the beginning of the array. Then, for each `j` we check whether `a[i]\
    \ < a[j] && a[i] < a[j + 1]` which means that `a[i] - a[j] < a[j + 1] - a[i]`\
    \ which is `a[i] - a[j] < 0` which means that we have `a[i] = a[j] + 1` which\
    \ means that `a[i] - a[j] < 0` is satisfied for all `i` and `j`.\n<|/ c |>\n<|\
    \ c |>\nThanks, I understand now. One more thing though, why does the `- 2 * n`\
    \ part work? Shouldn't it be `- 2 * i + 1`? I mean, if we want to sort it in increasing\
    \ order, we need to move all negative numbers to the beginning of the array. And,\
    \ if `a[i] - a[j] < 0` then `a[j + 1] - a[j] < 0` which is `a[j] - a[j] < 0` which\
    \ is satisfied for all `i` and `j`.\n<|/ c |>\n<| c |>\nYes, the trick is to move\
    \ all negative numbers to the beginning of the array. Actually, I didn't see that\
    \ this is required in the original problem description. Thanks for the correction.\n\
    <|/ c |>\n<| c |>\nThank you for you time, but please see my comments to your\
    \ original answer. :)\n<|/ c |>\n<| a tags=ruby,arrays,algorithm,mathematical-optimization\
    \ |>\nHere is a straightforward solution that uses no additional data structures:\n\
    <code>", "  a = [0] * n\n  1.upto(n) do |i|\n    1.upto(n) do |j|\n      1.upto(n)\
    \ do |k|\n        a[i] = i * i - i + j + k\n      end\n    end\n  end\n  (a[0]\
    \ - a[1..-1] - a[0..-2]) % 3 == 0 ? a.length + 1 : a.length\nend", " \n  # Initialize\
    \ count triple as 1\n  count_triples = 1", "  array.new(n) { |i| i << i }.each_with_index\
    \ do |ai, i|\n    ai.each do |aj|\n      ai.each do |ak|\n        return i if\
    \ ai + aj + ak == n * 3\n      end\n    end\n  end\n  0\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby dscore=1 |>\n<code>", "\ta = Array.new(n)\n\ta.each_with_index\
    \ do |i, index|\n\t\tindex == 0 || index == 1 || index == 2 ? a[index] = i * i\
    \ - i + 1 : nil\n\t\tindex == 3 ? a[index] = i * i - i + 1 : nil\n\tend\n\tcount\
    \ = 0\n\tfor i in 0..n\n\t\tcount = 0\n\t\tfor j in 0..n\n\t\t\tfor k in 0..n\n\
    \t\t\t\tcount = count + (a[i..n].include?(a[j..n].include?(a[k..n])) ? 1 : 0)\n\
    \t\t\tend\n\t\tend\n\t\tif count == 3\n\t\t\treturn count\n\t\tend\n\tend\nend",
  "    \n    a = (1..n).to_a\n    \n    puts \"a=[#{a.inspect}]\"\n    puts \"a.each\
    \ {|i| puts i}\"\n    \n    count = 0\n    \n    a.each do |i|\n        next if\
    \ i.odd?\n        \n        a.each do |j|\n            next if j.odd?\n      \
    \      \n            a.each do |k|\n                count += 0 if i == j && j\
    \ == k && k.odd?\n            end\n        end\n    end\n    \n    puts \"count[#{count.inspect}]\"\
    \n    \n    count\nend", "  a = Array.new(n)\n  a.each_with_index do |e, i|\n\
    \    e.times do |j|\n      k = (i + j)\n      if k < n && (a[j] == 0 && a[k] ==\
    \ 0 && a[j] == a[k])\n        a[k] = a[j] + a[k]\n      end\n    end\n  end\n\
    \  n = a.uniq.size\n  return n / 3\nend", "    count = [0] * n\n    \n    # Write\
    \ your code here\n    a = [1, 2, 4, 8]\n    for i in range(n):\n        for j\
    \ in range(i+1, n):\n            for k in range(j+1, n):\n                count[i]\
    \ += count[j] * count[k]\n                \n    return count[n-1]", "  a = Array.new(n)\
    \ { |i| i * i - i + 1 }\n  count = 0\n  (0..n).each do |i|\n    count += 1 if\
    \ a.min == i*i\n  end\n  count\nend", "  a.length(n)\n  sum = a[1..n].inject(:+)\n\
    \  i = 0\n  j = n\n  k = n-1\n  while (i<j) && (k>=0)\n    if a[i] <= a[j]\n \
    \     i += 1\n    else\n      j -= 1\n    end\n    if a[i] <= a[j]\n      k +=\
    \ 1\n    end\n  end\n  return i\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>",
  "  # write your code here\n  a = []\n  for i in 1..n\n    a[i] = i * i - i + 1\n\
    \  end\n  \n  triple = 0\n  for i in 0..n-1\n    for j in 0..n-1\n      for k\
    \ in 0..n-1\n        if i != j and i != k and j != k\n          triple = a[i]\
    \ + a[j] + a[k]\n          break\n        end\n      end\n    end\n  end\n  return\
    \ triple\nend", "  counts = Array.new(n){ 0 }\n  2.upto(n) { |i|\n    counts[i]\
    \ += 1\n    2.upto(n) { |j|\n      counts[j] += 1\n      2.upto(n) { |k|\n   \
    \     counts[k] += 1\n        if counts[i] < counts[j] && counts[i] != 0 && counts[j]\
    \ > 0 && counts[k] !=0\n          count = counts[i] + counts[j] + counts[k]\n\
    \          return count\n        end\n      }\n    }\n  }\nend", "    arr = []\n\
    \    arr.push 0 # push 0 to arr\n    for i in (1..n) # iterate from 1 to n\n \
    \       arr.push i * i - i + 1\n    end\n    return arr.max_by { |x| x == 3 }\
    \ # return max element where value == 3\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ looks like a good solution, but the code is not formatted properly. I would\
    \ recommend putting code in the code block. Also a line break after the `end`\
    \ is required in Ruby, and indentation can be added as needed. The OP wants to\
    \ find how many triples are there in a **multiple** of 3. Yours finds the maximum\
    \ number of triples that have a value of 3 which is different than what the OP\
    \ wants.\n<|/ c |>\n<| c |>\nThank you! I edited my answer and added the line\
    \ break and indentation. I also added some explanation on my solution :)\n<|/\
    \ c |>\n<| a dscore=0 |>\nA solution with Enumerable#each_cons:\n<code>\n(1..n).each_cons(3).map\
    \ {|a| a.inject(0) {|i, _| i + _}}.sum\n</code>\n<|/ a tags=ruby,arrays |>\n<|\
    \ c |>\n`map` would be better here than `inject`. I would also use `each_cons`\
    \ instead of `(1..n).each_cons(3).each_cons(3).reduce(0) { |sum, arr| sum + arr.inject(0)\
    \ { |i, _| i + _ }}`\n<|/ c |>\n<| c |>\nOr even `(1..n).each_cons(3).flat_map\
    \ { |a| a.each_cons(3).map { |a| a.inject(0) { |i,_| i + _ }}.sum }`\n<|/ c |>\n\
    <| c |>\nI agree, but I did it because I don't know Ruby.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ dscore=0 |>\nIf efficiency is not an issue, I would recommend a simple loop\
    \ (which makes it easy to add conditionals):\n<code>", "  triples=1\n  for i in\
    \ 1..n\n    for j in 1..i\n      if i==j\n        triples=trips+1\n      else\n\
    \        for k=2..j\n          if i+k==j+k\n            triples=trips+1\n    \
    \      end\n        end\n      end\n    end\n  end\n  return trips\nend\n</code>\n\
    <|/ a tags=arrays,ruby,algorithm dscore=1 |>\n<| a |>\nThe array a must be sorted,\
    \ otherwise the search is impossible because the elements won't be sorted. The\
    \ following will work.\n<code>", "  sum = 0\n  a = Array.new(n)\n  a[0] = a[1]\
    \ = 1\n  for i in 1..n-1\n    a[i] = a[i] + a[i-1]\n  end\n  a.delete_if { |x|\
    \ x < 0 }\n  a.delete_if { |x| x > 0 }\n  a.delete_if { |x| x == 0 }\n  a.delete_if\
    \ { |x| x == n }\n  puts a.inspect\n  return a.size\nend", "  # TODO: Write your\
    \ code here\n  a = [1,3,7,13,21]\n  n = a.size\n  count = 0\n  for i in 0...n-1\n\
    \    for j in 0...n-1\n      for a in 0...n-1\n        if (i+j+a)%3 == 0\n   \
    \       count += 1\n        end\n      end\n    end\n  end\n  count\nend", " \
    \ a = [0 for i in range(n)]\n  a.each_index do |i|\n    a[i] += i * i - i\n  end\n\
    \  a.each_index do |i|\n    a[i] += a[j] + a[i]\n    if i % 3 == 2\n      a[i]\
    \ += a[k]\n    end\n  end\n  a.select{|x| x % 3 == 0}.length\nend", "  a = (1..n)\n\
    \  a.map! { |x| x * x - x + 1 }\n  a.select { |x| x > 0 && x < n }\n  .inject\
    \ 0 do |total, val|\n    if total + val > 3 * val\n      total += val\n    end\n\
    \    total\n  end\nend", "  a = []\n  for i in 1..n\n    a << i * i - i + 1\n\
    \  end\n  a.sort.each_with_index do |x, i|\n    i -= 2\n    while i < n && x >\
    \ a[i]\n      i -= 1\n    end\n    while i < n && x < a[i]\n      i += 1\n   \
    \ end\n    next unless i == 0 || i == n || i == n-1\n    next unless x == a[i]\
    \ + a[j] + a[k]\n    return i + 1\n  end\n  return -1\nend\n</code>\n<|/ a |>\n\
    <| c |>\nYes, you're right, it is not optimal but it's fast. Your answer is great,\
    \ thanks.\n<|/ c |>\n<| c |>\n, I have added a better solution.\n<|/ c |>\n<|\
    \ a tags=algorithm,ruby,arrays dscore=3 |>\nI did a benchmark test on it, and\
    \ here is the benchmark:\n<code>\nrequire 'benchmark'\nn = 1000000\nBenchmark.bm(7)\
    \ do |x|\n  x.report(\"my solution\")  {\n    n.times do\n      get_max_triples(n)\n\
    \    end\n  }\n  x.report(\"jimmy's solution\") {\n    n.times do\n      jimmy_solution(n)\n\
    \    end\n  }\n  x.report(\"Yehuda's solution\") {\n    n.times do\n      Yehuda_solution(n)\n\
    \    end\n  }\nend", "  # your code here\n  a = [0] * n\n  for i in (0..n-1)\n\
    \    num = i * i - i + 1\n    a[i] = num", "  max_triples = -1\n  for i in 1..n\n\
    \    if i % 3 != 0\n      continue\n    count = 1\n    for j in i + 1..n\n   \
    \   if i % 3 == 0 && i % j ~= 0\n        count += 1\n      if count > max_triples\n\
    \        max_triples = count\n      end\n    end\n  end\n  max_triples\nend",
  "  a = []\n  a.push(n * n - 1)\n  a.push(n * n)\n  a.push(n * n + 1)\n  \n  for\
    \ i in 0...n\n    a.push(n * i - i + 1)\n  end", "  arr = Array.new(n) do i\n\
    \    return i * i - i + 1\n  \n  sum_triples = 0\n  triples = []\n  \n  # For\
    \ each element, add it to the triples\n  n.times { arr[i] = arr[i] - arr[i] +\
    \ 1 }\n  \n  # For each element, add it to the sum of triples \n  n.times { arr[i]\
    \ = arr[i] + arr[i] + arr[i] }", "  count = 0\n  a = Array.new(n, nil)\n  \n \
    \ a[0] = 0\n  \n  a[0] = 3 * a[0] - 1 + 1\n  \n  for i in 1..n\n    a[i] = a[i-1]\n\
    \  \n  for i in 0..n-1\n    for j in 0..i-1\n      k = i+j\n      count += a[k]\
    \ % 3 == 0 ? 0 : 1 \n    end\n  end\n  \n  return count\nend\n</cell>\n<code language=julia-0.6>",
  "  a = []\n  for i in (1...n)\n    a.push i * i - i + 1\n  (0...n).each {|i|\n \
    \   j = ((i + 1) / 3)\n    k = ((i + 2) / 3)\n    a.push( (a[i * i - i + 1] +\
    \ a[j] + a[k])*3 )\n  }\n  a.count{|x| x > 0}\nend", "    arr = []\n    for i\
    \ in (1..n)\n        arr << i * i - i + 1\n    arr.uniq.count\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nNice! I'd also have guessed that \"The only valid\
    \ triplet is (1, 7, 13).\" meant something like \"The only valid triplets are\
    \ the triples formed by the numbers 1 and 7, and 13.\"\n<|/ c |>\n<| c |>\n\"\
    The only valid triplet is (1, 7, 13).\" meant something I didn't think of before.\
    \ Thank you!\n<|/ c |>\n<| a dscore=2 tags=arrays,ruby,algorithm |>\nThe other\
    \ answers are all great! Here's an alternate solution that may or may not suit\
    \ your particular use-case. \n<code>", "  a = [1,3,5,7,9]\n  return a.max{|e|\
    \ e * e - e + 1 }\nend", "  # write your code here\n  \nend", "  a = Array.new(n)\
    \ { |i| i * i - i + 1 }\n  triples = 0\n  for i in 1..n\n    for j in 0...i\n\
    \      if a[i] < a[j] and a[j] < a[k]\n        triples += 1\n      end\n    end\n\
    \  end\n  return triples\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\n\
    A lot of the ruby code in your answer is just syntactic sugar for the ruby language\
    \ itself (such as `Array#new`, `Array#each`, `Array#include?`, `Array#each_index`,\
    \ etc).\n<|/ c |>\n<| c |>\nYes, but I'm just answering the OP's question which\
    \ seemed to be about the code they posted. As to your other comments, I agree\
    \ they are useful, but I didn't want to over-complicate the answer with a bunch\
    \ of language details. I'll add some comments when I think of something important\
    \ to add.\n<|/ c |>\n<| c |>\nWell, it's true that most of this code is language\
    \ syntactic sugar, but it's also true that most of this code is more verbose and\
    \ less expressive than it needs to be.  It's not always easier to write Ruby code\
    \ than to write C code.\n<|/ c |>\n<| c |>\n, thanks for the heads up. I did some\
    \ reading of that and have removed that section from the answer.\n<|/ c |>\n<|\
    \ c |>\n\"it's also true that most of this code is more verbose and less expressive\
    \ than it needs to be.\" => not necessarily. Ruby has many nice things for manipulating\
    \ arrays (sorting, merging, etc.) that it does not have.\n<|/ c |>\n<| a |>\n\
    I love recursion. :)\n<code>", "  sum = 0\n  arr = Array.new(n) {|i| i*i}\n  for\
    \ i in 1..n-1\n    arr[i] = arr[i] + arr[i-1]\n  end\n  for i in 2..n\n    arr[i]\
    \ = arr[i] + arr[i-2]\n  end\n  for i in 3..n\n    if sum % 3 == 0\n      sum\
    \ += arr[i]\n    end\n  end\n  return sum\nend\n</code>\n<|/ a dscore=0 tags=ruby,algorithm\
    \ |>\n<| c |>\nThis would be an excellent answer if you added an explanation of\
    \ what you've done, and why you chose to do what you've done.\n<|/ c |>\n<| a\
    \ tags=ruby,algorithm |>\nMy answer:\n<code>", "\tn = n*2\n\ta = Array.new(n,\
    \ 0.0)\n\tfor i in 1..n\n\t\ta[i] = i*(i+1)-i*i\n\ta.reject do |a|\n\t\ta.sum\
    \ % 3 == 0\n\tend\n\ta.size\nend", "  a = Array.new(n) {|x| x*x - x + 1}\n  count\
    \ = 0\n  (0...n).each do |i|\n    (i..n).each do |j|\n      count += a.find {|x|\
    \ (i - x == 0) || (j - x == 0) || (i - j == 0)} && 1\n    end\n  end\n  count\n\
    end", "    a = []\n    a.push(n)\n    a[0] = 1\n    i = 0\n    while i < n\n \
    \     j = i + 1\n      while j < n\n        k = j + 1\n        while k < n\n \
    \         a.push(k * (k - j) * (j - i))\n          k = k + 1\n        end\n  \
    \      j = j + 1\n      end\n      i = i + 1\n    end\n    a = a.reverse\n   \
    \ count = 0\n    a.each_with_index do |triple, i|\n      count += 1 if triple.odd?\
    \ and triple.even? and triple.even?\n    end\n    return count\nend", "  a = Array.new(n)\n\
    \  for i in 0...n\n    a[i] = i * i - i + 1\n  return a.max_by { |x| x * x * x\
    \ }\nend", "  a = (1..n).to_a\n  i = a.length-1\n  \n  a.map { |e| return 0 }\
    \ # return an array with 0 in every element \n  \n  while i >= 0 do\n    j = i\
    \ - 1\n    k = i - 2\n    \n    while j >=0 && k < i do\n      a[j] = a[j] + a[k]\n\
    \      j = j - 1\n      k = k - 2\n    end\n    i = i - 1\n  end\n  \n  a\nend",
  "  a = Array.new(n)\n  (0..n).each { |i| a[i] = i * i - i + 1 }\n  counter = 0\n\
    \  (1..n).each do |i|\n    counter += 1\n    (1..i).each do |j|\n      counter\
    \ += 1\n      (2..n).each do |k|\n        if a[i] + a[j] + a[k] == 2 * i * (i\
    \ + 1) * (i + 2)\n          return counter\n        end\n      end\n    end\n\
    \  end\nend\n</cell>\n<cell>", "  a = [1] * n\n  i = 0\n  j = 1\n  k = 2\n  while\
    \ i < n and j < n and k < n\n    a[i] = i * i - i + 1\n    j = (j + k + 1) % n\n\
    \    k = (k + a[i]) % n\n    i += 1\n    j = (j + k + 1) % n\n    k += 2\n  end\n\
    \  return a.count{|x| x % 3 == 0}\nend\n</cell>\n<code language=julia-1.0>", " \
    \ max = Integer.new(31)\n  a = Array.new(n)\n  for i in 1..n\n    a[i] = i * i\
    \ - i + 1\n  end\n  max = a.max\n  count = 0\n  for j in 0..(n-1) # j - 1 since\
    \ array indexing from 1..n\n    for k in 0..(n-1)\n      if a[j] + a[k] >= max\n\
    \        break\n      else\n        count += 1\n      end\n    end\n  end\n  count\
    \ * 3\nend\n</code>\n<|/ a |>\n<| c |>\nA little bit of explanation would be nice\
    \ :)\n<|/ c |>\n<| a dscore=2 tags=arrays,ruby |>\n<code>", "    array = []\n\
    \    array[0..n] = n\n    array.each do |i|\n        next if array[i-1] != i\n\
    \        array[i] = (array[i] * i - i + 1)\n    end\n    array.sort.reverse.each_with_index\
    \ do |i,j|\n        if i < j and array[i] < array[j]\n            return j\n \
    \       end\n    end\n    0\nend", "  triples = Hash.new(0)\n  (1..n).each {|i|\
    \ triples[i] += i * i - i + 1  }\n  triples.max_by{|k,v| v}\nend\n</code>\n<|/\
    \ a tags=algorithm,ruby,dynamic-programming |>\n<| a dscore=2 |>\nYou can use\
    \ a bloom filter to efficiently check whether each of your triples are possible.\
    \ I will use Ruby as I already have it installed, so I put a test case in comments.\n\
    <code>\nrequire 'bloom_filter'", "    total = 0\n    arr = Array.new(n)\n    (0...n).each\
    \ do |i|\n        (0...n).each do |j|\n            (0...n).each do |k|\n     \
    \           if i <= j <= k\n                    arr[i] += arr[j] + arr[k]\n  \
    \                  total += ((arr[i] - arr[j]) * (arr[i] - arr[k])) / 3\n    \
    \            end\n            end\n        end\n    end\n    puts \"Total is #{total}\"\
    \n    puts \"Number of triples #{arr[0..(n-1)]} is a multiple of 3.\"\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\n`(0...n).to_a` is unnecessary.\n<|/ c |>\n\
    <| c |>\n`(0...n).each_with_object` does the same and is shorter.\n<|/ c |>\n\
    <| c |>\nThanks, I added the each_with_object to my answer.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\nThis is my solution:\n<code>", "    hash_table = {} \n    triples = 0\n\
    \    for i in 1...n\n        if !hash_table[i]\n            hash_table[i] = i\
    \ * i - i + 1\n        else\n            hash_table[i] += hash_table[i-1]\n  \
    \          if hash_table[i] % 3 == 0\n                triples += 1\n        end\n\
    \    end\n    hash_table\nend", "  a = []\n  for i in 1..n\n    a.push i * i -\
    \ i + 1\n  end\n  \n  a.uniq!\n  a.sort # Sort the array\n  a.reverse!\n  \n \
    \ a.each_with_index do |e, i|\n    return i if e % 3 == 0\n  end\nend", "    #\
    \ write your code here\n    a.map!{|i| i*i-i+1}\n    a.reduce(&:+).to_i/3\nend",
  "  a = [*1..n]\n  count = 0\n  for i in 1..n\n    if a[i] < 0 || (i == a[0] && a[1]\
    \ == a[2] && a[3] >= a[4])\n      next\n    end\n    count += 1\n  end\n  return\
    \ count\nend", "  a, count = [], 0\n  for i in 1...n\n  a[i] = a[i] * a[i] + a[i]\n\
    \  end\n  \n  for i in 1...n\n    for j in 1...n\n      if i != j\n        if\
    \ a[j] + a[i] > 3\n          count += 1\n        end\n      end\n    end\n  end\n\
    \  \n  return count\nend", "    array = []\n    array.push(n)\n    array.sort!\
    \ \n    sum = 0\n    k = array.length - 1\n    while k >= 0 do\n        if ((array[k])*(array[k]))\
    \ == (array[k+1]*(array[k+1])) then\n            sum+=1\n            array.delete(k)\n\
    \        end\n        k--\n    end\n    array.sort!\n    return sum\nend", " \
    \   arr = [0, 1, 2]\n    count = 0\n    for i in 1...n\n        i += 1\n     \
    \   if arr[i] != i\n            arr[i] = i * i - i + 1\n            count += 1\n\
    \        end\n    end\n    \n    return count\nend", "\ttriples = 0\n\tarray.map!\
    \ { |i| triples += (i * i) - i + 1 }\n\treturn triples if triples % 3 == 0\nend",
  "    sum = 0\n    a.collect!(1)\n    a.shuffle!\n    # i = 1\n    # a.each_index\
    \ do |i|\n    # i = i + 1\n    # j = a.index(i)\n    # k = a.index(j) + 1\n  \
    \  # sum = sum + i + j + k\n    # end\n    a.each do |i|\n        j = a.index(i)\n\
    \        k = a.index(j) + 1\n        sum = sum + i + j + k\n    end\n    return\
    \ sum\nend", "  a = Array.new(n)\n  i = 0\n  j = 1\n  k = 2\n  while i < n and\
    \ j < n and k < n\n    a << i*i + (j-1)*j + (k-1)*k\n    i += 1\n    j += 1\n\
    \    k += 1\n  end\n  return a.count { |x| x % 3 == 0 }\nend", "  a = [n] * n\n\
    \  for i in 1..n\n    arr[i]= i * i - i + 1\n  end", "  # TODO: Write your code\
    \ here\n  array = []\n  for i in 1..n\n    array[i] = i * i - i + 1\n  end\n \
    \ \n  max_triple_count = 0\n  for i in 0..(n-1)\n    for j in (i+1)..n\n     \
    \ for k in (i+1)..n\n        if array[j] + array[k] % 3 == 0\n          max_triple_count\
    \ += 1\n        end\n      end\n    end\n  end\n  \n  return max_triple_count\n\
    end", "  i = 0\n  a = []\n  while i < n\n    a = i * i - i + 1 \n    i += 1\n\
    \  count = 0\n  a.each do |i|\n    a.each do |j|\n      a.each do |k|\n      \
    \  if i > j && i > k && j > k\n          count += 1\n        end\n      end\n\
    \    end\n  end\n  count\nend\nprint get_max_triples(5)\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nPlease edit your answer to include an explanation of how your code\
    \ works. Don't just give the code like this.\n<|/ c |>\n<| a dscore=2 |>\nYou\
    \ could use Array#permutation to generate the triples and then count the occurrences\
    \ of a triple in the results. \n<code>\nrequire 'permutation'", "  a = []\n  for\
    \ i in 1...n\n    a << i * i - i + 1\n  p =0\n  for i in 0...n\n    p += (a[i]\
    \ + a[j] + a[k])%3 == 0\n  end\n  return p\nend", "  count = 0\n  a = Array.new(n)\
    \ \n  for i in 1..n\n    a[i] = i * i - i + 1\n  end\n  for i in 0..n\n    for\
    \ j in i..n\n      if a[i] < a[j] && a[j] < a[k]\n        count += 1\n      end\n\
    \    end\n  end\n  count\nend", "  result = 0\n  a = [1..n]\n  a.each_index do\
    \ |i|\n    a.each_index do |j|\n      a.each_index do |k|\n        if i+j+k <\
    \ n and i*i + j*j + k*k < n and i*i + j*j + k*k % 3 == 0\n          result +=\
    \ 1\n        end\n      end\n    end\n  end\n  return result\nend\nget_max_triples(10)",
  "  (0..(n-1).-1).each do |i|\n    (1..n-1).each do |j|\n      (1..n-1).each do |k|\n\
    \        if i+j+k == i*i*i + j*j*j + k*k*k\n          return i+j+k\n        end\n\
    \      end\n    end\n  end\nend\n</cell>\n<cell>", "  a = Array.new(n)\n  for\
    \ i in 1...n\n    a[i] = i * i - i + 1\n  count = 0\n  for i in 1...n\n    for\
    \ j in 1...n\n      for k in 1...n\n        if a[i] < a[j] && a[i] < a[k]\n  \
    \        count = count + 1\n        end\n      end\n    end\n  end\n  count\n\
    end", "  a = [1, 2] * n\n  i = 0\n  j = 1\n  k = 3\n  while i < n\n    while j\
    \ < n\n      while k < n\n        if i == j && j == k && k == n\n          i +=\
    \ 1\n          j += 1\n          k += 1\n        end\n        k += 1\n      end\n\
    \      k += 3\n    end\n    i += 1\n    j += 1\n  end\n  puts i\nend", "  a =\
    \ Array.new(n)\n  (1..n).each { |i| a[i] = i * i - i + 1 }\n  count = 0\n  (1..n).each\
    \ do |i|\n    (1..n).each do |j|\n      (1..n).each do |k|\n        if a[i] >\
    \ a[j] && a[i] > a[k]\n          count += 1\n        end\n      end\n    end\n\
    \  end\n  return count\nend", "  a.length.times do |i|\n    count = 0\n    arr.each\
    \ do |j|\n      if i < j and j <= i \n        count += 1\n      end\n    end\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=2 tags=ruby |>\nThe simplest\
    \ solution is as follows.\n<code>", "    sum = 0\n    array = [1, 2, 3..n]\n \
    \   array.each do |num|\n      sum = sum + num*num\n    end\n    array.each do\
    \ |num|\n      if num <= sum % 3 then\n        sum += num*num\n      end\n   \
    \ end\n  end\n</code>\n<|/ a tags=arrays,ruby,range dscore=3 |>\n<| c |>\nThank\
    \ you, this is exactly what i was looking for! One quick question, what exactly\
    \ is the purpose of \"array.each do |num|\" ? Do i need to write that for every\
    \ number? Or is it only because of the conditional statement?\n<|/ c |>\n<| c\
    \ |>\nIt's like an `if` statement where you only have to write the conditional\
    \ once. `array.each do |num|` is the same as `array.each do |num| num = num +\
    \ 1 | end`.\n<|/ c |>\n<| a tags=arrays,ruby,range dscore=3 |>\n<code>", "  arr\
    \ = (1..n).to_a\n  a.product(arr)\n  arr.sum.to_s.split(//).map(&:to_i)\nend\n\
    </code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nThe question said that the input\
    \ was an integer rather than an array.\n<|/ c |>\n<| c |>\n`arr.sum.to_s.split(//).map(&:to_i)`\
    \ could just be `arr.sum.to_s.each_char.map(&:to_i)`\n<|/ c |>\n<| c |>\nStill\
    \ too slow, even with `a = [1..n]`\n<|/ c |>\n<| c |>\n: How do you know it's\
    \ too slow? The question's title and body suggest that the input is an array (with\
    \ length `n`). In fact, it's an array of integers.\n<|/ c |>\n<| c |>\nI did run\
    \ the benchmark test. My answer was faster, but his was faster. I see what you're\
    \ saying about my answer, but I don't see how you know it's too slow. The test\
    \ just said that my answer was faster, but not that it was faster than yours.\
    \ Did I miss something?\n<|/ c |>\n<| a tags=arrays,ruby dscore=2 |>\nThis is\
    \ as fast as I can make it, but I doubt it's possible to be significantly faster\
    \ than the accepted solution. This method does assume that you only care about\
    \ the highest 3 values of a[0] to a[n]. \n<code>", "  a = []\n  a.push(n)\n  a.push(n)\n\
    \  a.push(n)\n  a.push(n)\n  a.push(n)\n  count = 0\n  while a.length != 0\n \
    \   i = a.shift\n    j = a.shift\n    k = a.shift\n    count += i+j+k\n    a.push(i+j+k)\n\
    \  end\n  return count\nend", "  result = 0\n  a = Array.new(n){0} \n  a.each_with_index\
    \ do |i,j|\n    result += (j+1<n)?j+1:0\n    result += (j+i<n)?j+i:0\n    result\
    \ += (i+1<n)?i+1:0\n  end\n  return result\nend", "  num = [1..n]\n  a = num.map\
    \ { |i| i * i - i + 1 }\n  a.each_with_index do |x, i|\n    a.each_with_index\
    \ do |y, j|\n      a.each_with_index do |z, k|\n        if (x < y < z) && (x >\
    \ y > z)\n          return i + 1\n        end\n      end\n    end\n  end\nend\n\
    </code>\n<|/ a |>\n<| a dscore=1 tags=ruby |>\nI was looking for something more\
    \ elegant, and this is my solution using ranges:\n<code>", "  a = Array.new(n){|i|\
    \ i * i - i + 1}\n  count = 0\n  1.upto(n) do |i|\n    2.upto(n) do |j|\n    \
    \  3.upto(n) do |k|\n        if k > n || j > n || i > n || i > n\n          next\n\
    \        end\n        if a[k] + a[j] + a[i] == n\n          count += 1\n     \
    \   end\n      end\n    end\n  end\n  count\nend", "  a = Array.new(n)\n  for\
    \ i in 0...n-1\n    a[i] = (i * i - i + 1)\n  end\n  a.sort!\n  n = a.length\n\
    \  num_trip = 0\n  for i in 0...n-1\n    for j in (i+1)...n\n      k = j+1\n \
    \     while k != n\n        if a[j] + a[k] == 3 * a[i]\n          num_trip +=\
    \ 1\n        end\n        k += 1\n      end\n    end\n  end\n  return num_trip\n\
    end\n</cell>\n<code language=julia-0.6>\nget_max_triples(4)\n</cell>\n<code language=julia-0.6>\n\
    get_max_triples(5)\n</cell>\n<code language=julia-0.6>\nget_max_triples(6)\n</cell>\n\
    <code language=julia-0.6>\nget_max_triples(10)\n</cell>\n<code language=julia-0.6>\n\
    get_max_triples(1000)\n</cell>\n<text>\nProblem 9", "  arr = []\n  for i in 1...n\n\
    \    arr << i*i - i + 1\n    puts arr\n  end\nend", "  a = Array.new(n)\n  a[0]\
    \ = 1\n  a[1] = 3\n  a[2] = 7\n  a[3] = 13\n  a[4] = 21\n  i = 0\n  j = 3\n  k\
    \ = 0\n  c = 0\n  while i < n and j < n and k < n\n    if a[i] < a[j] and a[i]\
    \ < a[k]\n      c+=1\n      i+=1\n    elsif a[j] < a[i] and a[j] < a[k]\n    \
    \  c+=1\n      j+=1\n    else\n      c+=1\n      k+=1\n    end\n  end\n  return\
    \ c\nend\n</code>\n<|/ a |>\n<| c |>\nThis won't solve the problem, but it's a\
    \ good idea. If I were to implement the problem, I'd do it using a recursive function.\
    \ It'd be much clearer to me, and less confusing, than what you're doing.\n<|/\
    \ c |>\n<| c |>\nI agree with you, but I still think it would be better to use\
    \ a recursive function. I believe that recursion will be more clear than a while\
    \ loop.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    a.clear\n    for i in 1..n\n\
    \        a[i] = i * i - i + 1\n    end\n    for i in 1..n\n        for j in 1..n\n\
    \            for k in 1..n\n                if ( a[i] < a[j] && a[j] < a[k] &&\
    \ a[i] < a[j] && a[j] < a[k] && a[i] < a[k])\n                    count += 2\n\
    \                end\n            end\n        end\n    end\n    return count\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| a |>\nYou can try this\n<code>", " \
    \ sum = 0\n  for i in 1..n\n    sum = sum + i ** 2 - i + 1\n  end\n  sum -= (n\
    \ + 1) * (n + 1)\n  \n  return sum % 6\nend", "  a = [1,3,5,7,9]\n  count = 0\n\
    \  i = 0\n  while i < n\n    j = i + 1\n    while j < n and a[j] % 3 == 0\n  \
    \    j += 1\n    if j < n\n      count = count + j - i + 1\n      i = j\n  end\n\
    \  return count\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't do what\
    \ was asked. It counts number of triplets whose values are multiple of 3. Not\
    \ triples that sum to an odd number.\n<|/ c |>\n<| c |>\nI think what OP wants\
    \ is `return count - get_max_triples(n - 1)`, not `count - get_max_triples(n)`.\n\
    <|/ c |>\n<| a dscore=0 tags=ruby |>\nThis is another way:\n<code>", "  a = Array.new(n)\n\
    \  for i in 1..n\n    a[i] = i * i - i + 1\n  count = 0\n  for i in 1..n\n   \
    \ for j in i..n\n      for k in j..n\n        if a[i] > a[j] + a[k]\n        \
    \  count += 1\n        end\n      end\n    end\n  end\n  count\nend", "  a = Array.new(n)\n\
    \  a.each{|x| a << x * x - x + 1}\n  a.each do |i|\n    a.each do |j|\n      a.each\
    \ do |k|\n        a.each do |i|\n          if i > j > k\n            a.each do\
    \ |i|\n              return 0 if a[i] + a[j] + a[k] == i\n            end\n  \
    \        end\n        end\n      end\n    end\n  end\nend\n</code>\nThe solution\
    \ can be found here:\nhttps://leetcode.com/problems/maximum-triple-subarray/\n\
    <|/ a dscore=1 tags=ruby |>\n<| c |>\nThis solution does not handle zero values\
    \ very well.\n<|/ c |>\n<| c |>\n, thank you for your feedback. You are right\
    \ about the zero values but it is not the problem of this solution.\n<|/ c |>\n\
    <| c |>\nI didn't downvote, but your code is O(N^5), not O(N^3).\n<|/ c |>\n<|\
    \ c |>\n, thank you for your comment. I edited my answer and added the example\
    \ with zero values too.\n<|/ c |>\n<| c |>\nStill O(N^5) - there are 6 nested\
    \ loops. I suspect the complexity was reduced to O(N^3) by some clever use of\
    \ sets in order to avoid a lot of duplicate work.\n<|/ c |>\n<| a |>\nI would\
    \ use array enumerator here to iterate through the array once:\n<code>", "  a\
    \ = []\n  for i = 0 to n-1 do\n    a.push i * (i + 1) - (i + 1)\n  end\n  a.sort!\n\
    \  count = 0\n  for i in a do\n    if i >= i and i < a[i] + a[j] and a[i] + a[j]\
    \ + a[k] == i*i*i do\n      count += 1\n    end\n  end\n  return count\nend\n\
    </pre>", "    # Your code here\n    a,b = [0]*n,[0]*n\n    sum=0\n    for i in\
    \ range(1,n+1):\n        for j in range(i,n+1):\n            sum+=a[i]*a[j]*a[k]\n\
    \            if sum%3==0:\n                a[i]=a[i]+1\n                a[j]=a[j]+1\n\
    \                a[k]=a[k]+1\n                sum=sum-3\n                break\n\
    \    return len(a)\n        ", "  triples = 0\n  for i in 0..n-1\n    for j in\
    \ 0..n-1\n      sum = 0\n      k = i+j\n      for k in 0..n-1\n        sum +=\
    \ k*k\n      triples += ((i+j) == sum)*1\n    end\n  end\n  return triples\nend",
  "  a = [1, 2, 3]\n  while n > 0\n    a.push(a.pop() * a.pop() * a.pop())\n    n\
    \ -= 1\n  end\n  return a.size\nend", "  a = Array.new(n)\n  a.each_with_index\
    \ do |i, index|\n    (i+1)*(i+2)/2 - (i+1)*(i+1)/2 - (i+2)*(i+2)/2 == i\n  end\n\
    end\n</code>\n<|/ a tags=ruby,arrays dscore=0 |>\n<| a tags=ruby,arrays |>\nThe\
    \ solution using Array#product and Array#sum should work for you:\n<code>\narray\
    \ = (1..n)\ntriples = array.each_with_index.map do |i, index|\n  [i, i, i]\nend.product(array).map\
    \ { |i| i.sum }", "  arr = Array.new(5) { 1 }\n  arr.each_index do |i|\n    arr[i]\
    \ = i * i - i + 1\n  end\n  return arr.uniq.size - arr.select {|i| arr[i] % 3\
    \ == 0}.size\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| a |>\nThis can be\
    \ accomplished in O(n) time by using two hashes, one for calculating a[i], and\
    \ the other for a[j] and a[k]:\n<code>", "  a = Array.new(n)\n  for i in 1..n\n\
    \    a[i] = i * i - i + 1\n  end\n  triples = 0\n  for i in 0...n-1\n    for j\
    \ in 0...n-1\n      if j != i\n        triples += a[i] + a[j] + a[k] > 3 * 0 ?\
    \ 1 : 0\n      end\n    end\n  end\n  puts triples\nend", "  \n  a = []\n  for\
    \ i in (1..n+1)\n    a.push i * i - i + 1\n  \n  puts \"The valid triples are:\"\
    \n  a.each do |x| \n    if (x.odd?)\n      if (x.even?)\n        if (x.even?)\n\
    \          puts x\n        end\n      else\n        puts x\n      end\n    end\n\
    \  end\nend", "  a.push(n * n - n * n + 1)\n  (0..n).each do |i|\n    (0..n).each\
    \ do |j|\n      (0..n).each do |k|\n        break unless a[j] + a[k] + a[i] <\
    \ 3 \n      end\n    end\n  end\n  a.length - 1 \nend\n</code>\n<|/ a tags=arrays,ruby,algorithm\
    \ dscore=2 |>\n<| a |>\nMy understanding is that you want the solution as close\
    \ to O(n) time complexity. \nFirst of all, sort the array in O(nlogn) time complexity,\
    \ and then loop through it until you encounter an even number n in the array and\
    \ start computing the sum of all triples (n^2 - n)/2 which is in O(n) time complexity.\
    \ \nYou have to sort a sub-array in O(n) time complexity too, so the overall complexity\
    \ will be O(nlogn). \nComplexity is O(nlogn). \nYou have to keep track of the\
    \ sum of even numbers in a sub-array which is O(2n)=O(n) time complexity. \n<code>",
  "    a.fill(0)\n    return a.count(a.max) # return n\nend\n</cell>\n<code language=julia-1.5>",
  "  a = Array.new(n)\n  for i in 0...n\n    a[i] = i*i\n  end\n  sum = a[0]\n  for\
    \ i in 1...n\n    sum -= a[i]\n  end\n  for i in 1...n\n    sum -= a[n-i-1]\n\
    \  end\n  sum\nend\n</code>\n<|/ a tags=ruby,arrays,math dscore=0 |>\n<| c |>\n\
    `Array.new(n)` \u2192 `Array.fill(n, (n**2 - n)*(n**2 - n))`.\n<|/ c |>\n<| c\
    \ |>\n: Thanks, I will try it next time I'm on Ruby\n<|/ c |>\n<| c |>\nYeah,\
    \ the same thing came up on my phone a few times too, and I couldn't find the\
    \ dupe until I researched it more closely. So yeah, if you come across a question\
    \ with the same answer, then you'll likely have a better chance of finding it.\
    \ So +1 for a Ruby-only answer. :-)\n<|/ c |>\n<| c |>\n`Array.new(n)` \u2192\
    \ `Array.new(n) { n * n - n * n }`.\n<|/ c |>\n<| c |>\n: I never said it was\
    \ an optimal solution.\n<|/ c |>\n<| a tags=ruby,arrays,math |>\nUsing Hash#each_cons\
    \ can make your job easy with the help of Array#combination.\n<code>", "  a =\
    \ []\n  for i in (1..n)\n    a.push i * i - i + 1\n  a.sort.each do |x|\n    break\
    \ if x == a[x] + a[x] + a[x]\n  end\n  return a.length - 1\nend\n</code>\n<|/\
    \ a |>\n<| a tags=ruby,arrays |>\n<code>", "  a = Array.new(n); i = 0\n  until\
    \ i == n\n  a.push(i * i - i + 1)\n  i = i + 1\n  until i == n\n  a.reverse!\n\
    \  k = 0\n  until k < n\n  k = k + 1\n  until k < n\n  j = k - 1\n  until j <\
    \ n\n  i = 0\n  until i < j\n  i = i + 1\n  until i < j\n  return a.select {|i|\
    \ (i + j) % 3 == 0}.length\nend", "  a = Array.new(n, nil)\n  for i in 1...n\n\
    \    a[i] = i * i - i + 1\n  end\n  a.sort!\n  count = 0\n  for i in 0..n-1\n\
    \    for j in i+1...n\n      count += (a[i] + a[j] + a[k]) % 3 == 0\n    end\n\
    \  end\n  return count\nend", "    a.clear\n    i = 0\n    while i < n\n     \
    \   a[i] = i * i - i + 1\n        i += 1\n    i = 1\n    while i < n\n       \
    \ if a[i] < a[i] + a[j] + a[k]\n            i += 1\n        else\n           \
    \ j = i + 1\n            while j < n\n                if a[i] < a[j] + a[k]\n\
    \                    i += 1\n                else\n                    k = j +\
    \ 1\n                    while k < n\n                        if a[i] < a[j] +\
    \ a[k]\n                            i += 1\n                        else\n   \
    \                         k = j + 1\n                        end\n           \
    \         end\n                end\n            end\n        end\n    end\n  \
    \  return i\nend", "  a = Array.new(2*n) # create an array of length 2*n\n  (a[0..(n-1)]\
    \ | (0..(n-1))).each do |i|\n    (a[i..(i+1)] | (i..(i+1))).each do |j|\n    \
    \  (a[i..(i+1)] | (i..(i+1))).each do |k|\n        if (i..(i+1)).all? { |j| j\
    \ > i && j > k }\n          a[i] = i * i - i + 1\n          return a.length\n\
    \        end\n      end\n    end\n  end\nend", "    a = []\n    a.resize(0,n)\n\
    \    for i in (0..n-1)\n        a[i] = i*i - i + 1\n    return a.count(i*i - i\
    \ + 1) if n > 0 then 0 end\nend\n</code>\n<|/ a |>\n<| c |>\nI like it, but it\
    \ would be great if it would work for an array of any length (not just `n`).\n\
    <|/ c |>\n<| c |>\nI added a version that works for any length\n<|/ c |>\n<| c\
    \ |>\n`get_max_triples(n)` should be `get_max_triples(n, a)` right? Otherwise\
    \ it is going to return `nil` for an empty array (as it is an implicit `return`).\
    \ Also `@a` should be `a`\n<|/ c |>\n<| c |>\nOh yes, sorry I changed that variable\
    \ name from inside the method and didn't change in the call. I'll fix it. Thanks.\n\
    <|/ c |>\n<| a |>\nThis code will print the number of triples for an array of\
    \ any size\n<code>", "  result = 1\n  a = (1..n).to_a\n  a.each do |i|\n    j\
    \ = n\n    until j > 1\n      j -= 1\n      if a[j] + a[j-1] + a[j-2] == a[i]\n\
    \        result += 1\n        break\n      end\n    end\n  end\n  result\nend",
  "  return 2*((n**3-n)-(n**2-n)+1).floor/3\nend\n</cell>\n<cell>", "  count = 0\n\
    \  array.unshift([])\n  array.unshift(0)\n  for i in 1...n\n    count = (count\
    \ + array[1][i] + array[2][i]) % 3\n    array[2] += array[1] * 3 - array[2][i]\n\
    \  end\n  count\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nHi Manoj, thanks for\
    \ your answer. However I can't see how this would return the correct answer for\
    \ the example given by OP. Can you please explain how this would work?\n<|/ c\
    \ |>\n<| c |>\nI just had a typo in the code that I fixed now.\n<|/ c |>\n<| c\
    \ |>\nI hope you understand my comment. I'm saying that your solution doesn't\
    \ give the correct answer for the example given by OP.\n<|/ c |>\n<| c |>\nYes\
    \ indeed. I just realized it after I posted my answer. I will correct it and post\
    \ the correct answer when I'm back from my desk.\n<|/ c |>\n<| c |>\nYeah sure,\
    \ if you find time :-)\n<|/ c |>\n<| a dscore=0 tags=math,arrays,ruby |>\nThis\
    \ can be done in O(n log n) time using dynamic programming. Let n be the size\
    \ of the array, m be the size of the triplet. There are three operations that\
    \ are important:", "  max_triples = 0\n  a = [1, 3, 7, 13, 21]", "  n = Integer(n)\n\
    \  a = Array.new(n, nil)\n  \n  (0..n).each { |i| a[i] = i * i - i + 1 }\n  \n\
    \  (0..n).each do |i|\n    (0..n).each do |j|\n      (0..n).each do |k|\n    \
    \    if i < j && j < k && a[i] < a[j] + a[k]\n          return true\n        elsif\
    \ j < i && i < k && a[j] < a[j] + a[k]\n          return true\n        elsif k\
    \ < i && a[k] < a[j] + a[k]\n          return true\n        end\n      end\n \
    \   end\n  end\n  \n  0\nend", "  trip_count = 1\n  a.clear\n  (1..n).each do\
    \ |i|\n    (1..n).each do |j|\n      (1..n).each do |k|\n        if i < j && j\
    \ < k && a[i] < a[j] && a[j] < a[k]\n          trip_count = trip_count + 1\n \
    \       end\n      end\n    end\n  end\n  puts \"Triplets with a[i] < a[j] < a[k]\"\
    \n  puts trip_count\nend", "    a, x = [] + 1, 0\n    (1..n).each do |i|\n   \
    \     (1..i).each do |j|\n            (1..j).each do |k|\n                if i\
    \ + j + k == a * 3 * i\n                    x.increment\n                end\n\
    \            end\n        end\n    end\n    x\nend\n</cell>\n<code language=julia-0.6>",
  "  arr = Array.new(n)\n  arr[0] = arr[1] = arr[2] = 1\n  for i in 1..n\n    arr[i]\
    \ = i * i - i + 1\n  end\n  max_triples = 0\n  max_triple = nil\n  for i in 0..n\n\
    \    for j in 0..n\n      for k in 0..n\n        if arr[i] < arr[j] && arr[i]\
    \ < arr[k] && arr[j] < arr[k]\n          max_triples += 1\n          if max_triple\
    \ == 0\n            max_triple = (arr[i], arr[j], arr[k])\n          elsif arr[i]\
    \ + arr[j] + arr[k] != max_triple\n            max_triple = nil\n          end\n\
    \        end\n      end\n    end\n  end\n  return max_triples\nend", "    arr\
    \ = (1..n).to_a\n    arr.each_index do |i|\n        arr[i] = i * i - i + 1\n \
    \   end\n    arr.select do |a|\n        a[0] > a[1] && a[0] > a[2]\n    end.count\n\
    end\n</code>\n<|/ a dscore=3 tags=ruby,algorithm |>\n<| c |>\nThis doesn't answer\
    \ the question at all. The question was *how can I find the largest triplet in\
    \ the array*. This answer doesn't help anybody.\n<|/ c |>\n<| c |>\nThe title\
    \ is \"Triangle with the most possible sum\", but the question states that you\
    \ found all possible triples which sum is maximal, which means you just need to\
    \ find max sum, not the triplet which sum is maximal.\n<|/ c |>\n<| c |>\nThis\
    \ question has been asked more than ten times before - please search before answering.\n\
    <|/ c |>\n<| c |>\nI didn't know that it is already asked. Thanks for the info\n\
    <|/ c |>\n<| c |>\nWhat about the second case?\n<|/ c |>\n<| a tags=ruby,algorithm\
    \ dscore=2 |>\nIn case there are 2 or more triples with same max sum\n<code>",
  "\ta = Array.new(n) \n\tfor i in 1..n\n\t\ta[i] = i * i - i + 1\n\ta.sort.each do\
    \ |i|\n\t\tif i != a.first and i != a.last && i == a[0...a.size/2].sum + a[a.size/2..-1].sum\
    \ + a[a.size-1]\n\t\t\treturn i\n\t\tend\n\tend\n\treturn -1\nend", "    # Write\
    \ your code here.\n    return 0\nend\n</cell>\n<code language=julia-0.6>", " \
    \   i = 0\n    triples = 0\n    a = []\n    while i < n\n        i += 1\n    end\n\
    \    return i\nend", "  a = Array.new(3 * n)\n  n.times do |i|\n    a[i * i -\
    \ i + 1] = 1\n  end\n  \n  max_triples = 0\n  for i in 0...(n-1) # n-1 because\
    \ of the last element \n    if a[i] > max_triples && a[i] + a[j] + a[k] == 3*i\n\
    \      max_triples = a[i] + a[j] + a[k]\n    end\n  end\n  \n  return max_triples\n\
    end", "  a = Array.new(n + 1)\n  1.upto(n) do |i|\n    a[i] = i * i - i + 1\n\
    \  end\n  a.select { |x| x.even? }.size\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ |>\nI see a lot of answers here but none that seem to return the sum of the\
    \ numbers, only the count of the numbers that are multiples of 3.\nI like doing\
    \ this with 2 loops, one to find the multiples and another to count the sum.\n\
    <code>", "  a = Array.new(n)\n  count = 0\n  for i in (0..n-1)\n    for j in (i+1..n-1)\n\
    \      for k in (j+1..n-1)\n        if a[i] + a[j] + a[k] == 3*(i+j+k)\n     \
    \     count += 1\n        end\n      end\n    end\n  end\n  return count\nend",
  "    count = 0\n    nums = [1,2,3]\n    count = 1\n    for i in (0 .. n - 1)\n \
    \       j =(nums.index(i) + 1)\n        k = nums.index(j)\n        if nums[i]\
    \ + nums[j] + nums[k]%3 == 0\n            count += 1\n        end\n    end\n \
    \   count\nend", "  tri = 0\n  for i in 1..n\n    k = n - i\n    k = k if k >=\
    \ 0 else k + i\n    tri += (a[i] * a[j] + a[j] * a[k] + a[k] * a[i]) % (1000000007)\
    \ #BigInteger Module\n  end\n  tri\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n\
    <| c |>\nThanks, i was trying to do it with loops but couldn't figure out how\
    \ to use Big integers. Thanks again.\n<|/ c |>\n<| c |>\nPlease explain how it\
    \ works. It's not obvious to me how your code works.\n<|/ c |>\n<| c |>\nThis\
    \ code is giving me error: `undefined local variable or method `a' for main:Object\
    \ (NameError)`\n<|/ c |>\n<| c |>\nI made a small change for the variable `a`\
    \ initialization\n<|/ c |>\n<| c |>\n: You are missing a `do` in `do` `end`. See\
    \ https://stackoverflow.com/a/18908634/4653463\n<|/ c |>\n<| a tags=ruby,algorithm\
    \ |>\nHere's a solution without big integers:\n<code>", "  a = [1,3,7,13,21]\n\
    \  a.sort! \n  sum = 0\n  i = 0\n  j = 1\n  k = a[0]\n  while i < n and j > 0\
    \ and k < a[n-1]\n    sum = sum + a[i] + a[j] + a[k]\n    i += 1\n    j += 1\n\
    \    k += 3\n  end\n  return sum % 3\nend", "  result = 0\n  a = []\n  for i in\
    \ 1..n\n    if a.empty?\n      a.push(i)\n    else \n      j = a.last\n      a.last\
    \ += 1\n      while j + 1 < i\n        j += 1\n      a.push i\n      result +=\
    \ (i * a[j] - i * a[j] - i)\n    end\n  end\n  return result\nend", "  arr = Array.new(n)\
    \ {|i| i*i-1+1 }\n  triples = 0\n  for i in 1..n-1 do\n    j = i\n    until arr[j]\
    \ == i do\n      j += 1\n    end\n    k = j\n    while arr[k] == i do\n      k\
    \ += 1\n    end\n    if arr[i] + arr[j] + arr[k] == i*i\n      triples += 1\n\
    \    end\n  end\n  return triples\nend", "  a.length.times do |i|\n    a[i] =\
    \ i*i - i + 1\n  end\n  a.length.times do |i|\n    a.length.times do |j|\n   \
    \   a.length.times do |k|\n        if a[i] < a[j] && a[i] < a[k]\n          return\
    \ a[i] + (a[j] + a[k])\n        end\n      end\n    end\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nThe above answers are correct, here is a\
    \ non-recursive version that works:\n<code>", "  a = [1, 3, 7, 13, 21]\n  count\
    \ = 0\n  for i in 0..(n-1)\n    for j in (i+1)..(n)\n      count = 0\n      k\
    \ = j + 1\n      while a[i] < k\n        count += 1\n        k = k + 1\n     \
    \ end\n      if count % 3 == 0\n        count += 1\n      end\n    end\n  end\n\
    \  count\nend\nend", "  a = Array.new(n+1)\n  1.upto(n) do |i|\n    a[i] = i *\
    \ i - i + 1\n  end\n  count = 0\n  1.upto(n) do |i|\n    2.upto(n) do |j|\n  \
    \    3.upto(n) do |k|\n        if i == j && j == k && (i != 0 || j != 0 || k !=\
    \ 0)\n          count += (a[i] + a[j] + a[k])\n        end\n      end\n    end\n\
    \  end\n  return count\nend\n</cell>\n<code language=julia-1.0>\n@assert get_max_triples(3)\
    \ == 6\n@assert get_max_triples(5) == 25\n</cell>\n<text>\n\u6700\u5927\u4E09\u89D2\
    \u5F62\nGiven an integer n, you need to find the largest triangle containing exactly\
    \ n 3-sided sides. The sides must be in non-decreasing order.", "    arr = []\n\
    \    arr.push(n*(n - 1)/2)\n    while arr.size < n\n        arr.push(n*(n - 1)/2)\n\
    \    return arr.size\nend", "  a = Array.new(n)\n  for i in 0 .. n-1\n    a[i]\
    \ = i * i - i + 1\n  end\n  result = 0\n  for i in 0 .. n-1\n    for j in 0 ..\
    \ n-1\n      for k in 0 .. n-1\n        if a[i] < a[j] && a[i] < a[k]\n      \
    \    result += 1\n        end\n      end\n    end\n  end\n  return result\nend",
  "  a = []\n  for i in range(n)\n    a[i] = i * i - i + 1\n  max_triples = 0\n  i\
    \ = n\n  while i > 0\n    j = i - 1\n    while j > 0\n      k = j - 1\n      while\
    \ k > 0\n        if a[i] + a[j] + a[k] % 3 == 0\n          max_triples += 1\n\
    \        k -= 1\n      j -= 1\n    i -= 1\n  return max_triples\nend", "  a =\
    \ Array.new(n + 1) # +1 because we use a[0], which is not possible\n  for i in\
    \ 0...n\n    a[i] = i * i - i + 1\n  \n  res = 0 # result value\n  for i in 0...n\n\
    \    for j in (i + 1)...n\n      res = max(res, a[i] + a[j] + a[k])\n  \n  res\n\
    end", "    arr = Array.new(n)\n    for i in 1...n\n        arr[i] = i * i - i\
    \ + 1\n    end\n    arr.select! { |i| i + i + i }\nend\n</cell>\n<cell>\nget_max_triples(5)\n\
    </cell>\n<text>\nQ2. Given a binary array arr of length n. Find the length of\
    \ longest consecutive zero-crossing in the array.", "  a = []\n  for i in 1..n\n\
    \    a.push(i*i-i+1)\n  \n  (0...n-1).each do |i|\n    j = i-1\n    k = (n-1)-i\n\
    \    while j > 0 && k > 0\n      a.push(a[j]+a[k])\n      j -= 1\n      k -= 1\n\
    \    end\n  end", "  count = 0\n  a = [1,3,5,7,9,11,13,15,17]\n  for i in a do\n\
    \    for j in a[i+1:n] do\n      for k in a[i+1:n] do\n        if i + j + k ==\
    \ i * i * i then\n          count += 1\n        end\n      end\n    end\n  end\n\
    \  return count\nend", "  a = Array.new(n)\n  for i in 1..n\n    a.push i * i\
    \ - i + 1 \n  a.sort { |x, y| x <=> y }\n  a.size - 1 \nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
