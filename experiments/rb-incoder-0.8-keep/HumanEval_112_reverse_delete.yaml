name: HumanEval_112_reverse_delete
language: rb
prompt: "# Task\n# We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n# then check if the result string is\
  \ palindrome.\n# A string is called palindrome if it reads the same backward as\
  \ forward.\n# You should return a tuple containing the result string and True/False\
  \ for the check.\n# Example\n# For s = \"abcde\", c = \"ae\", the result should\
  \ be ('bcd',False)\n# For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n\
  # For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\ndef reverse_delete(s,\
  \ c)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_reverse_delete\n\
  \    candidate = method(:reverse_delete)\n    assert_equal([\"bcd\", false], candidate.call(\"\
  abcde\", \"ae\"))\n    assert_equal([\"acdef\", false], candidate.call(\"abcdef\"\
  , \"b\"))\n    assert_equal([\"cdedc\", true], candidate.call(\"abcdedcba\", \"\
  ab\"))\n    assert_equal([\"dik\", false], candidate.call(\"dwik\", \"w\"))\n  \
  \  assert_equal([\"\", true], candidate.call(\"a\", \"a\"))\n    assert_equal([\"\
  abcdedcba\", true], candidate.call(\"abcdedcba\", \"\"))\n    assert_equal([\"abcdedcba\"\
  , true], candidate.call(\"abcdedcba\", \"v\"))\n    assert_equal([\"abba\", true],\
  \ candidate.call(\"vabba\", \"v\"))\n    assert_equal([\"\", true], candidate.call(\"\
  mamma\", \"mia\"))\n  end\nend\n"
completions: ["  # Write your code here\n  return s[:s.reverse.length-1] == c\nend\n\
    </cell>\n<code language=julia-1.6>\nfunction reverse_delete(s, c)\n  # Write your\
    \ code here\n  begin\n     return s[:s.reverse.length-1] == c\n  catch e\n   \
    \  return false\n  end\nend\n</cell>\n<code language=julia-1.6>", "    count =\
    \ 0\n    rev_s = \"\"\n    rev_c = \"\"\n    \n    i = 0\n    j = 0\n    \n  \
    \  while(i < len(s) and j < len(c)):\n        if s[i] == c[j]:\n            count\
    \ += 1\n            rev_s += s[i]\n            rev_c += c[j]\n            i +=\
    \ 1\n            j += 1\n        elif count != 0:\n            count += 1\n  \
    \          rev_s += s[i]\n            rev_c += c[j]\n            i += 1\n    \
    \    else:\n            i += 1\n        \n        \n    rev_s = rev_s[:len(s)\
    \ - count]\n    rev_c = rev_c[:len(c) - count]\n    return (rev_s, rev_c == s)",
  "  result = 0\n  l = s.length\n  for i in (0...l)\n    result = (result * 10) +\
    \ s[i].ord\n    result = result.modulo(256)\n    if result != 0\n      break\n\
    \  l = c.length\n  for i in (0...l)\n    result = (result * 10) + c[i].ord\n \
    \   result = result.modulo(256)\n    if result != 0\n      break\n  return (s.dup.reverse,\
    \ s.reverse.eql? c)\nend", "  \nend", "  new_s = \"\"\n  \n  while s.empty? ==\
    \ false do\n    new_s << s.slice!(0)\n  end\n  \n  new_c = \"\"\n  \n  c.each\
    \ do |x|\n    new_c << new_s.slice!(0)\n  end\n  \n  new_s == new_c\nend", " \
    \   string = \"\"\n    i = 0\n    while i < s.length\n        string += s[i]\n\
    \        if s[i] == c\n            string = string.gsub!(s[i], '')\n        else\n\
    \            i += 1\n        end\n    end\n    string == string.gsub!('', '')\n\
    end\n</cell>\n<code language=julia-0.4>", "  p =s.length\n  r = s.length\n  r\
    \ = r- p\n  t = s.length\n  result = \"\"\n  for i in 0..r\n    if s[i] == c\n\
    \      result.concat(s[i]) \n    end\n  end\n  for i in 0..t\n    if s[i] == c\n\
    \      result.concat(s[i]) \n    end\n  end\n  return result,true\nend\n</code>\n\
    <|/ q tags=ruby,algorithm |>\n<| c |>\nThe question is not clear. Do you want\
    \ to count the number of palindromic strings that start with the same character\
    \ and are the same length?\n<|/ c |>\n<| c |>\nCan you give an example of what\
    \ you mean by \"the character is the same\"?\n<|/ c |>\n<| c |>\nYes, I want to\
    \ count the number of palindromic strings that start with the same character and\
    \ are the same length\n<|/ c |>\n<| c |>\n\"palindromic string\" means `str[i]\
    \ == str[str.length-i-1]`\n<|/ c |>\n<| c |>\nI think he means the characters\
    \ are the same.\n<|/ c |>\n<| a tags=ruby,algorithm |>\nThe question is unclear\
    \ but here's my solution.\n<code>", "    # Write your code here\n    \n    \n\
    \    \n    # Step 1: Delete all characters in s which equals to c\n    \n    #\
    \ Step 2: check if the result string is palindrome\n    \n    return (result,result==s\n\
    \              )", "  # Your code here\n  return s,c==s[::-1]\nend\n</cell>\n\
    <code language=julia-1.5>\nreverse_delete(\"abbc\",\"ba\")\n</cell>\n<code language=julia-1.5>",
  "  return s==s.delete(s,c) == c\nend\n</cell>\n<code language=julia-1.5>", "  s.gsub!(c,\
    \ '')\n  s.each_char do |char|\n    yield(char)\n  end\n  result = s.reverse.eql?(s.reverse)\n\
    \  result\nend", "    str = s[0..-2]\n    str.each_byte do |byte|\n        str.delete_byte\
    \ byte\n    end", "    \n    chars = s.length\n    i = 0\n    count = 0\n    result\
    \ = []\n    \n    while i < chars\n        \n        if s[i] == c[i]\n       \
    \     count += 1\n            i += 1\n        else \n            if count > 0\n\
    \                result[count] = s[i]\n                count = 0\n           \
    \ i += 1\n    end\n    \n    return (\"#{result.join}#{s[0,chars-1]}\" ==  s)\
    \ ? [result.reverse, True] : [result.reverse, False]\nend\n        \n        ",
  "  s.chars.each{|e| s.delete(e) if c.include?(e)}\n  s = (s.chars.join)\n  result\
    \ = s == s.reverse\n  return result,result\nend", "  r = []\n  s.each_byte do\
    \ |char|\n    r.push( char if char == c.first)\n  end\n  r.reverse!\n  return\
    \ (r,r.join==s)\nend", "\tdeleted_chars = ''\n\tdeleted_chars = deleted_chars\
    \ << s.delete(c)\n\tdeleted_chars = deleted_chars.reverse\n\tis_palindrome = deleted_chars\
    \ == s\n\tdeleted_chars.clear\n\treturn [deleted_chars, is_palindrome]\nend",
  "  s = s.to_a\n  for i in 0...s.length-1\n    if s[i].chr == c.chr\n      s.delete_at(i)\n\
    \      s.reverse!\n      break\n    elsif s[i] == c\n      break\n    end\n  end\n\
    \  s.reverse!\n  s[s.length-1].chr == c.chr\nend", "    string = \"\"\n    i =\
    \ 0\n    flag = True\n    while i < len(s)\n        if s[i] == c\n           \
    \ string = string + s[i + 1]\n            i = i + 2\n        else if s[i] == c\n\
    \            string = string + s[i + 1]\n            i = i + 1\n        else if\
    \ s[i] <=> c\n            string = string + s[i]\n            i = i + 1\n    \
    \    else if s[i + 1] <=> c\n            string = string + s[i]\n            i\
    \ = i + 1\n        else if s[i + 1] != c\n            string = string + s[i]\n\
    \            i = i + 1\n        else\n            flag = False\n        i = i\
    \ + 1\n    \n    if flag\n        string = string + s[i + 1]\n    return string,\
    \ flag\nend", "  s.gsub! c,''\n  s.reverse!\n  return [s,s.gsub(c,'')].reverse.empty?\n\
    end", "    i = s.index(c)\n    rv = (s[i..-1], s.reverse == s)\n    return rv\n\
    end", "\treverse_string = \"\"\n\treverse_count = 0\n\t\n\tfor i in 0..s.length-1\
    \ do\n\t\treverse_string = reverse_string + s[i]\n\tend\n\t\n\tfor i in 0..c.length-1\
    \ do\n\t\tif s[i] == c[i]\n\t\t\treverse_count = reverse_count + 1\n\t\tend\n\t\
    end\n\t\n\tif reverse_count > 1\n\t\treturn (reverse_string, false)\n\telse\n\t\
    \treturn (reverse_string, true)\n\tend\nend", "    \n    #your code here\n   \
    \ \n    if s[0] == c[0]\n        reverse = s[1...-1]\n    end\n    \n    return\
    \ reverse, True\n    \nend", "  s.delete_if(&c.method(:==))\n  s.size == s.length?\
    \ [s, false] : [s.reverse, false]\nend", "\t\n\ts = s.chars.reverse.join\n\ts.gsub!(c)\n\
    \tif s[0] == s[-1] then return (s, false)\n\telse return (s, true)\nend\n</cell>\n\
    <code language=julia-1.4>", "\tnew_s=s\n\tnew_c=c\n\twhile new_c!=\"\"\n\t\tnew_s=new_s[:new_s.index(new_c)+new_c.count(\"\
    c\")]\n\t\tnew_c=new_c[new_c.rindex(\"c\")+1:]\n\tend\n\treturn (new_s,new_c==\"\
    \")\nend", "\tpalindrome = \"\"\n\tresult = \"\"\n\ts = s[0..s.length-c.length]\n\
    \ts.each_byte do |char|\n\t\tchar = char.to_s\n\t\tif char == c\n\t\t\tresult\
    \ = result + char\n\t\telse\n\t\t\tresult = result + char\n\t\tend\n\tend\n\t\
    s.each_byte do |char|\n\t\tchar = char.to_s\n\t\tif char == c\n\t\t\tresult =\
    \ result + char\n\t\telse\n\t\t\tpalindrome = char.to_s\n\t\tend\n\tend\n\tif\
    \ result == palindrome\n\t\treturn result,true\n\telse\n\t\treturn result,false\n\
    \tend\nend", "\tstr = []\n\tfor i in 0..s.length-1\n\t\tif s[i]==c\n\t\t\tstr.push\
    \ s[i]\n\t\tend\n\tend\n\tstr.reverse\n\tfor i in 0..s.length-1\n\t\tif s[i]!=str[i]\n\
    \t\t\treturn str.reverse, false\n\t\tend\n\tend\n\tstr.reverse\n\treturn str.reverse,\
    \ true\nend", "  if s.length == 0 \n    (c, True)\n  elsif s.length == 1\n   \
    \ (s.first(s.length), false)\n  else\n    (i = s.length - 1).downto(0)\n    s\
    \ = s.reverse\n    char = s.first(i)\n    deleted = false\n    if char == c\n\
    \      deleted = true\n      i = i - 1\n      while i >= 0\n        char = s.first(i)\n\
    \        if char == c\n          deleted = true\n          i = i - 1\n       \
    \ else\n          i = i - 1\n        end\n      end\n    end\n    (s.first(i),\
    \ deleted)\n  end\nend", "    # Write your code here\n    return s,false\nend\n\
    </code>\n<|/ q dscore=2 |>\n<| c |>\nPlease give an example of the test case\n\
    <|/ c |>\n<| c |>\nWhat is the output supposed to be?\n<|/ c |>\n<| c |>\nYour\
    \ code seems fine. Can you give an example of your test case?\n<|/ c |>\n<| c\
    \ |>\nThe input should be \"aba\" and \"abb\" and the output should be \"a\" and\
    \ \"b\"\n<|/ c |>\n<| c |>\n`def palindrome(s)\n  #Write your code here\n  return\
    \ s, false\nend` This is the code I have so far but i dont know how to test it\
    \ because i dont know how it works\n<|/ c |>\n<| a |>\nIn addition to what BTW\
    \ said, you should probably return False when something fails. Otherwise you'll\
    \ return nothing if the string is a palindrome and nil otherwise.\n<code>", " \
    \ result = []\n  n = s.length\n  i = 0\n  j = 0\n  while i < n\n    if s[i] ==\
    \ c[j]\n      j = j + 1\n      if j == n\n        result = result + s[i]\n   \
    \   else\n        result = result + s[i] + c[j]\n    else\n      if j != 0\n \
    \       result = result + s[i]\n      end\n    end\n    i = i + 1\n  end\n  result\
    \ = result + s[i..n]\n  return (result,s.downcase == result.downcase)\nend", " \
    \   # Write your code here.\n    if s.length == 0\n        return s, true\n  \
    \  temp = s.dup\n    temp.reverse!\n    reverse_delete!(temp, c)\n    temp.reverse!\n\
    \    s[temp.length..-1] == c ? true : false\nend", "  s = s.chars\n  c.each{|i|\
    \ s.remove?i}\n  s.empty?\nend", "  result = ''\n  i = 0\n  while i < s.length\n\
    \    if s[i] == c\n      result << s[i]\n      i += 1\n    else\n      i += 1\n\
    \  end\n  if s == result\n    return (result,true)\n  else\n    return (result,false)\n\
    \  end\nend\n</cell>\n<cell>", "  s = s.dup\n  s.slice!(-c.size..-1)\n  s.reverse!\n\
    \  result = ''\n  i = 0\n  while i < s.size\n    result += s[i]\n    i += 1\n\
    \  end\n  s.slice!(0..c.size)\n  s.reverse!\n  return [result, true]\nend", " \
    \   \n    if s.length != c.length \n        return (\"Error: Wrong number of characters\"\
    )\n    \n    deleted = []\n    \n    i = 0\n    j = 0\n    \n    while i < s.length\
    \ \n        \n        if s[i] == c[j] \n            \n            deleted.push(s[i])\n\
    \            i = i + 1\n            j = j + 1\n            \n        else\n  \
    \          i = i + 1\n        end\n        \n    end\n    \n    result = (deleted.join,\
    \ j == 0 or (j - 1) == 0 or (deleted.join == deleted.join[0..j-1]))\n    \n  \
    \  return result\nend", "\tdeleted_char = \"\"\n\treverse_string = \"\"\n\t\n\t\
    for i in (0..s.length-1)\n\t\tif (s[i] != '#')\n\t\t\tdeleted_char += s[i]\n\t\
    \tif (s[i] == c[i])\n\t\t\tdeleted_char = ''\n\t\t\treverse_string += deleted_char\n\
    \t\t\tdeleted_char = ''\n\t\t\t\n\tif (deleted_char == \"\")\n\t\treverse_string\
    \ = reverse_string + s[:s.length-1]\n\t\treverse_string[reverse_string.length-1]\
    \ = \"#\"\n\t\t\n\treturn (reverse_string,deleted_char == c)\nend", "  s.each\
    \ do |elem|\n    if elem == c\n      s = s[0...-1]\n      break\n    end\n  end\n\
    \  if s == c\n    (s, false)\n  else\n    (s, true)\n  end\nend", "  result =\
    \ \"\"\n  i = 0\n  while i < s.length\n    ch = s[i]\n    if ch == c\n      result=result+ch\n\
    \      i = i + 1\n      i = 1\n      while i < s.length\n        ch = s[i]\n \
    \       if ch != c\n          result = result + ch\n          i = i + 1\n    \
    \    end\n      end\n    end\n  end\n  if result == s\n    return result ,True\n\
    \  else\n    return result ,False\n  end\nend", "   result = 0\n   for i in range(len(s))\n\
    \      result = result * 10 + s.index(s[i])\n   return result == c.index(result)\
    \ and s == s[::-1] and True\nend\n</cell>\n<cell>", "    result = []\n    s =\
    \ s.to_s\n    c = c.to_s\n    count = 0\n    while count < s.length\n       result.push(s[count])\n\
    \       count += 1\n    end\n    count = 0\n    while count < s.length\n     \
    \  if s[count] == c[count]\n         count += 1\n       else\n         result.pop\n\
    \       end\n    end\n    result.join\n    result == s\nend\n</code>\nI wrote\
    \ this code in ruby, but you can also use python\n<|/ a |>\n<| a tags=python,ruby,algorithm\
    \ |>\n<code>", "  s.gsub!(c)\n  return s,s.chars.uniq.size ==s.size\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nIf you want a more Ruby way\
    \ of doing this, try this.\n<code>", "    arr = s.split(//)\n    len = s.length\n\
    \    reversed = arr.reverse", "\tnew_s = \"\"\n\ts = s.split(\"\").reverse\n\t\
    new_s = s.join(\"\")\n\tnew_s = new_s.split(c).reverse\n\tnew_new_s = \"\"\n\t\
    for i in new_s\n\t\tnew_new_s += i\n\treturn (new_new_s,new_new_s == new_s)\n\
    end", "\tlenS = length(s) \n\tlenC = length(c) \n\ti = 0 \n\tj = 0 \n\tresult\
    \ = ''", "  begin = 0\n  end = s.length - 1 # -1 because last position is included\n\
    \  while begin < end\n  begin+=1\n  end -= 1\n  if s[begin] != c\n  s[begin] =\
    \ s[end]\n  s[end] = nil\n  end\n  reverse_delete(s, c)\n  if s == c #or s[begin]\
    \ != nil\n  return (s, true)\n  end\n  if begin > end\n  return (s, false)\n \
    \ end\n  reverse_delete(s, c) # if s == c or begin > end then it is not a palindrome\n\
    \  return (s, true)\nend\n  ", "  s = s.downcase\n  c = c.downcase\n  c.each_char\
    \ do |char|\n    s = s.gsub(/#{char}/,\"\") if s[0...-1].include?(char).nil?\n\
    \  end\n  s.gsub!(c,\"\") if c.gsub!(c,\"\").empty?\n  return (s,c.empty?)\nend",
  "  s.chars.each do |s|\n    reversed = s.reverse\n    deleted = reversed.delete(c)\n\
    \    return (reversed, (deleted == c))\n  end\n  return ('False', False)\nend",
  "  # Your code here\nend", "\tstr = \"\"\n\tstr = \"\".join(s)\n\tresult = \"\"\n\
    \tfor i in c\n\t\tresult = result + i\n\t\tif result != str\n\t\t\tbreak;\n\t\t\
    end\n\tend\n\tif result == str\n\t\treturn (True,result)\n\tend\n\t\n\treturn\
    \ (False,result)\nend", "  # Your code here\n  new_str = ''\n  s.each_char do\
    \ |char|\n    new_str += char if char == c\n  end\n  new_str.length <= s.length\
    \ ? new_str : (s.length - new_str.length, true)\nend", "    i=0;j=s.length-1;\n\
    \    s=s.to_s.chars.join;\n    while(i<j and i<s.length and j>=0)\n        if\
    \ s[i]==c[j]\n            i,j=(i+1),j-1\n        else\n            i,j=(i+1),j-1\n\
    \    return s[i..j].join,(i==j and s[i..j]==s)\nend\n</cell>\n<code language=julia-0.6>\n\
    reverse_delete(\"abcde\",\"a\")\n</cell>\n<code language=julia-0.6>\nreverse_delete(\"\
    abcde\",\"b\")\n</cell>\n<code language=julia-0.6>\nreverse_delete(\"abacab\"\
    ,\"ab\")\n</cell>\n<code language=julia-0.6>\nreverse_delete(\"abacab\",\"ac\"\
    )\n</cell>\n<code language=julia-0.6>\nreverse_delete(\"abacab\",\"b\")\n</cell>\n\
    <code language=julia-0.6>\nreverse_delete(\"abacab\",\"c\")\n</cell>\n<code language=julia-0.6>\n\
    reverse_delete(\"abacab\",\"a\")\n</cell>\n<code language=julia-0.6>\nreverse_delete(\"\
    abacab\",\"ca\")\n</cell>\n<code language=julia-0.6>\nreverse_delete(\"abacab\"\
    ,\"ba\")\n</cell>\n<code language=julia-0.6>\nreverse_delete(\"abacab\",\"ca\"\
    )\n</cell>\n<code language=julia-0.6>\nreverse_delete(\"abacab\",\"b\")\n</cell>\n\
    <code language=julia-0.6>\nreverse_delete(\"abacab\",\"c\")\n</cell>\n<code language=julia-0.6>\n\
    reverse_delete(\"abacab\",\"a\")\n</cell>\n<code language=julia-0.6>\nreverse_delete(\"\
    abacab\",\"a\")\n</cell>\n<code language=julia-0.6>\nreverse_delete(\"abacab\"\
    ,\"a\")\n</cell>\n<code language=julia-0.6>\nreverse_delete(\"abacab\",\"a\")\n\
    </cell>\n<code language=julia-0.6>\nreverse_delete(\"abacab\",\"a\")\n</cell>\n\
    <code language=julia-0.6>\nreverse_delete(\"abacab\",\"a\")\n</cell>\n<code language=julia-0.6>\n\
    reverse_delete(\"abacab\",\"a\")\n</cell>\n<code language=julia-0.6>\nreverse_delete(\"\
    abacab\",\"a\")\n</cell>\n<code language=julia-0.6>\nreverse_delete(\"abacab\"\
    ,\"a\")\n</cell>\n<code language=julia-0.6>\nreverse_delete(\"abacab\",\"a\")\n\
    </cell>\n<code language=julia-0.6>\nreverse_delete(\"", "    # Write your code\
    \ here.\n    return s.delete(c,s.size<=0), s.delete(0,s.size<0)==s.size<0\nend",
  "    i = 0\n    string = ''\n    while (i < len(s)/2) do\n        if (s[i] == c)\
    \ then\n            string = string + s[i]\n            i = i + 1\n        else\n\
    \            string = string + s[i]\n            i = i + 1\n        end\n    end\n\
    \    string = string.reverse\n    return string, string==s\nend", "  s = s.dup\n\
    \  c = c.dup\n  c = c.split(//)\n  c.pop\n  new_s = \"\"\n  new_c = \"\"\n  while\
    \ s.size > 0\n    if s.chars[0] == c.first\n      s = s.rest\n      c = c.rest\n\
    \      new_s << c.first\n      c = c.rest\n      new_c << c.first\n    else\n\
    \      break\n    end\n  end\n  if new_s == new_c\n    return (\"palindrome\"\
    ,true)\n  else\n    return (\"palindrome\",false)\n  end\nend", "  new_s = s\n\
    \  new_c = c", "  n = s.length\n  s = c+s\n  p =  s.length\n  while (n>=0)\n \
    \   if s.chars[n-1] == c\n      s.slice!(n-1,1)\n      n--\n    else\n      n--\n\
    \    p -= 1\n  end\n  return s, s.length==0 or s.chars == c\nend", "  # Your code\
    \ here\n  return s[s.index(c)+1], True\nend", "    i = 0\n    j = len(s) - 1\n\
    \    result = \"\"\n    found = False\n    while (i >= 0) or (j >= 0):\n     \
    \   if i >= 0 and j >= 0 and s[i] == c[j]:\n            found = True\n       \
    \     i += 1\n            j -= 1\n        elif i >= 0 and j >= 0 and s[i] == c[j]:\n\
    \            found = True\n            i -= 1\n            j -= 1\n        elif\
    \ i >= 0 and j >= 0 and s[i] == c[j]:\n            found = True\n            i\
    \ -= 1\n        else:\n            result += s[i]\n            i -= 1\n    return\
    \ result, found\n</cell>\n<cell>", "  s.gsub!(c.to_s, '')\n  s.gsub!(/#{c}/, '')\n\
    \  s.reverse!\n  s == s.reverse ? true : false\nend\nputs reverse_delete('abcde',\
    \ 'ae')", "    i = 0\n    l = s.length", "  s.split(//)\n  c.split(//)\n  s.each_char\
    \ do |letter|\n    letter = letter.to_s\n    s = s.gsub(letter, '')\n  end\n \
    \ s.split(//)\n  s.each_char.inject(:+) == c.split(//).each_char.inject(:+)\n\
    end", "  s.each_index do |i|\n    puts s[i].to_s if s[i] == c\n    if s[i] ==\
    \ c\n      s.delete_at(i)\n      i += 1\n      break\n    end\n  end\n  \n  s.reverse!\n\
    \  s.each_index do |i|\n    puts s[i].to_s if s[i] == c\n    if s[i] == c\n  \
    \    s.delete_at(i)\n      i += 1\n      break\n    end\n  end\n  \n  return s,false\n\
    end", "  # write your code here\n  reverse = s.reverse\n  s.delete(c)\n  return\
    \ reverse,s == reverse\nend", "    # write your code here\n    end1 = s.index(c)\n\
    \    end2 = s.rindex(c)\n    left_str = s[end1..end]\n    right_str = s[0...end2]\n\
    \    if left_str == right_str\n        return s,true\n    end\n    return s,false\n\
    end", "    ans = \"\"\n    found = false\n    l = s.length\n    if l == 0\n  \
    \      return ans\n    for i in 0...l-1\n        if s[i] == c[0]\n           \
    \ ans += c[0]\n            found = true\n            l -= 1\n        else\n  \
    \          if found == true\n                return ans\n        end\n    end\n\
    \    return ans\nend", "  # Your code here\n  s = s.upcase\n  c = c.upcase\n \
    \ result = []\n  i = 0\n  while i < s.length\n    char = s[i]\n    if char ==\
    \ c\n      result.push s[i]\n    else\n      result.push char\n    end\n    i\
    \ += 1\n  end\n  s = result.join\n  \n  if s == result.join\n    return ('',false)\n\
    \  elsif s == result.join[0..s.length/2-1].reverse\n    return ('',true)\n  end\n\
    \  \n  begin\n    while i < s.length\n      char = s[i]\n      if char == c\n\
    \        result.push char\n      else\n        result.push char\n      end\n \
    \     i += 1\n    end\n    s = result.join\n  rescue\n    return ('',false)\n\
    \  end\n  \n  if s == result.join[0..s.length/2-1].reverse\n    return ('',true)\n\
    \  else\n    return ('',false)\n  end\n  \nend", "  s.split(//).each do |letter|\n\
    \    s.split(//).each do |letter|\n      if letter == letter\n        s << letter\n\
    \      elsif letter == c\n        s << letter\n      end\n    end\n  end\n  if\
    \ s == s.reverse\n    return s, true\n  else\n    return s, false\n  end\nend",
  "  return s if s[0] == s[0][c.length-1] else delete_rev(s,c)\nend", "    \nend",
  "  a = s.split(//)\n  a.each_index do |i|\n    if a[i] = c\n      return a.reverse.join(//),\
    \ True\n    end\n  end\n  return a.reverse.join(//), False\nend\n</code>\nThe\
    \ algorithm above works just fine but since it uses multiple loops and arrays,\
    \ it's not the most efficient algorithm. It can be done by iterating through strings\
    \ and characters in parallel. However, the easiest way is just to iterate through\
    \ the characters in each string.\n<code>", "  i = s.length\n  result = []\n  while\
    \ i>0\n    c = s.slice(i-1,i)\n    if c.include?(c.last)\n      result.pop\n \
    \     i-1\n    end\n    result << c\n    i -= 1\n  end\n  result.reverse\n  result==s\n\
    end", "\tresult = \"\"\n\ts = s.downcase\n\tc.downcase!=\"\"\n\ts.each_index do\
    \ |i|\n\t\tresult += s[i] unless s[i] == c[i]\n\tend\n\treturn [result, result.eql?(s)]\n\
    end", "  s.gsub!(c)\n  s = s.reverse\n  s.gsub!(c)\n  s = s.reverse\n  s.gsub!(c)\n\
    \  s = s.reverse\n  s.gsub!(c)\n  s.chars.all? {|i| i == s.first}\nend", "\ts\
    \ = s.reverse\n\ts.delete(c)\n\treturn (s,c==s)\nend", "  p =\"\"\n  s.gsub!(c)\n\
    \  if s == p then return (s, true) else return (s, false)\nend\n</cell>\n<code\
    \ language=julia-1.0>\nreverse_delete(\"acdef\",\"b\")\n</cell>\n<text>\n4.3 Longest\
    \ Common Prefix\nWrite a function which given two strings returns the longest\
    \ common prefix of these two strings.\nExample\nFor string1 = \"kumar\" and string2\
    \ = \"mumara\", the output should be\nlongestCommonPrefix(\"kumar\", \"mumara\"\
    ) = \"kum\"\nlongestCommonPrefix(\"kumar\", \"mumara\") = \"k\"\nlongestCommonPrefix(\"\
    mumar\", \"mumara\") = \"m\"\nlongestCommonPrefix(\"aman\", \"amanak\") = \"am\"",
  "    letters_deleted = []\n    result_string = \"\"", "  reverseString = \"\"\n\
    \  i = 0\n  while i < s.length do\n    reverseString = reverseString + s[i]\n\
    \    i += 1\n  end\n  i = 0\n  while i < s.length do\n    if s[i] == c\n     \
    \ begin = i\n      break\n    end\n    i += 1\n  end\n  begin = 0\n  i = 0\n \
    \ while i < s.length do\n    if s[i] != c\n      begin = begin\n      break\n\
    \    end\n    i += 1\n  end\n  while i < s.length do\n    if begin > i\n     \
    \ begin = begin\n      break\n    end\n    i += 1\n  end\n  return reverseString[begin..end],\
    \ begin == end\nend", "  s = s.chars\n  c.each_byte {|x| s.delete(x) }\n  s.join\
    \ == c.join ? true : false\nend", "  begin = 0\n  end = s.length-1\n  while begin\
    \ < end do\n    if s[begin] != c[end] then\n      begin+=1\n    else\n      begin+=1\n\
    \      end-=1\n    end\n  end\n  return s[begin..end].reverse, begin == end\n\
    end", "  s.split(//).map do |char|\n    if char.eql?(c)\n      return char\n \
    \   end\n  end\n  false\nend", "  # Your code here\n  result = ''\n  for i in\
    \ 0...s.length-1\n    if (s[i] == c[i])\n      result << s[i]\n      result <<\
    \ c[i]\n    else\n      result << s[i]\n      break\n  end\n  if result == s[0...s.length-1]\n\
    \    return result, true\n  else\n    return result, false\n  end\nend", "   if\
    \ s == nil or c == nil then return nil\n   if s == c then return (s, false)\n\
    \   x = reverse_delete(s[1..-1], c[c..-1])\n   if x != nil then return (s, true)\
    \ if x < (s, true) then return (x, false) else return (s, false)\n   return nil\n\
    end", "    count = 0\n    rev = ''\n    \n    while count <=(len(s)/2)\n     \
    \   if s[count] == c[count]\n            rev = rev + s[count]\n            count\
    \ = count + 1\n        else\n            rev = rev + s[count]\n            rev\
    \ = rev + c[count]\n            count = count + 1\n    end", "  reverse_str =\
    \ []\n  s.reverse!\n  s.each_char do |char|\n    char == c ? reverse_str << char\
    \ : reverse_str\n  end\n  if s.reverse.chars.eql?(reverse_str.chars)\n    return\
    \ (reverse_str, true)\n  else\n    return (reverse_str, false)\n  end\nend", " \
    \ if s.length == 0\n    return (\"\",0)\n  result = []\n  index = 0\n  while index<s.length\n\
    \    if s.index(c,index) != -1\n      while index<s.length\n        if s.index(c,index)\
    \ == index\n          result.append(s.slice(index,s.length))\n        index +=\
    \ 1\n      result.reverse\n      if s.reverse == s\n        return (result,True)\n\
    \      index += 1\n    index += 1\n  return (s,False)\nend", "    s_size = s.length\n\
    \    c_size = c.length\n    result = []\n    i = 0\n    j = 0\n    res = True\n\
    \    while(i <= s_size and j <= c_size)\n        if s[i] == c[j]\n           \
    \ result.append(s[i])\n            i += 1\n            j += 1\n        else\n\
    \            i+= 1\n            j = 0\n    i = 0\n    j = 0\n    while(i < s_size\
    \ and j < c_size)\n        if s[i] == c[j]\n            i += 1\n            j\
    \ += 1\n        else\n            i += 1\n        j = 0\n    res = result.join()\
    \ == s\n    return res, res\nend\n</cell>\n<code language=julia-1.4>\nusing BenchmarkTools\n\
    @btime reverse_delete(s_string, c_string)\n</cell>\n<code language=julia-1.4>",
  "  s = s.split(\"\")\n  c = c.split(\"\")\n  s.each do |s|\n    s.each do |c|\n\
    \      if(c == s[0])\n        return s.reverse, false\n      end\n    end\n  end\n\
    \  return s.reverse, false\nend", "\t\nend\n</cell>\n<cell>", "\ts.chars.each.with_index\
    \ do |char,i|\n\t\ts = s.sub(/#{char}/,'') if s.include?(char) == c.include?(char)\n\
    \tend\n\tcase s\n\twhen s[0...-1]\n\t\t(s,true)\n\twhen s[0...-1]\n\t\t(s,false)\n\
    \telse\n\t\t(s,false)\n\tend\nend", "  # write your code here\n  s.chars.reverse_each.with_index\
    \ do |c,i|\n    if c.eql?(c)\n      s.slice(i,i).replace(c)\n    end\n  end\n\
    \  s.chars.all? do |c|\n    if c==c\n      true\n    else\n      false\n    end\n\
    \  end\nend", "    if s == \"\"\n       return s,False\n    l = s.length\n   \
    \ for i in 0..l-1\n        if s[i] == c\n            s.delete_at(i)\n        else\n\
    \            break\n    return reverse_delete(s,c)\nend", "  result = []\n  i\
    \ = 0\n  j = 0\n  while i < s.length and j < c.length\n    if s[i] == c[j]\n \
    \     result[j] << s[i]\n      i += 1\n      j += 1\n    else\n      i += 1\n\
    \  end\n  result.length = j\n  if i >= s.length\n    result.reverse!\n    if result.reverse\n\
    \      return result\n    end\n  end\n  result\nend", "  puts \"Your code here\"\
    \nend", " \n  # check if s is empty\n  if s.length == 0 then return (\"s\",True)\n\
    \ \n  # check if c is empty\n  if c.length == 0 then return (\"s\",True)\n \n\
    \  # initialize a stack\n  stack =[]\n \n  # reverse s and c using stack\n  for\
    \ i in [0..s.length-1] do\n    stack.push(i)\n    stack.push(i)\n  for i in [0..length-1]\
    \ do\n    if s[i] == c[i] then\n      stack.pop\n      stack.pop\n    else\n \
    \     stack.push(i)\n      stack.push(i)\n \n  # check the result stack using\
    \ isEmpty\n  if stack.isEmpty then return (\"s\",True)\n  if stack.pop != s.length\
    \ then return (\"s\",False)\n \n  return (reverse_delete(s.subString(0, stack.pop),\
    \ c),False)\nend", "  rev = s.reverse\n  result = rev[c.length..0]\n  rev.reverse!\n\
    \  result == '' ? (rev, false) : (rev, true)\nend", "  s.reverse!\n  s.delete!(c)\n\
    \  s.reverse!\n  return s, s.delete?(c) != nil\nend\nend", "    if s.empty?\n\
    \        return s, true\n    end\n    result = []\n    left = s[0]\n    right\
    \ = s[s.length-1]\n    while left < right\n        if c == left\n            left,\
    \ right = left + 1, right - 1\n        else\n            left, right = left +\
    \ 1, right - 1\n        end\n    end\n    result.reverse << left\n    result.reverse\
    \ << right\n    result.join\nend", "  s.reverse!\n  s.delete(c).reverse!\n  s.to_s\
    \ == s.to_s\nend", "    count = 0\n    reversed_string = ''\n    for e in s\n\
    \        if e == c\n            count += 1\n            if count == 1\n      \
    \          reversed_string += e\n            else\n                reversed_string\
    \ += e\n            count = 0\n        else\n            reversed_string += e\n\
    \    puts reversed_string\n    puts count == 0\n    return reversed_string, count\
    \ == 0\nend\n</cell>\n<cell>\nreverse_delete(\"hello\", \"h\")\n</cell>\n<cell>\n\
    reverse_delete(\"hello\", \"e\")\n</cell>\n<cell>\nreverse_delete(\"hello\", \"\
    l\")\n</cell>\n<cell>\nreverse_delete(\"hello\", \"o\")\n</cell>\n<cell>\nreverse_delete(\"\
    hello\", \"m\")\n</cell>\n<cell>\nreverse_delete(\"hello\", \"a\")\n</cell>\n\
    <cell>", "  # Write your code here\n  \n  s = s.downcase\n  c = c.downcase\n \
    \ i = 0\n  result = ''\n  while i < s.length\n    char = s[i]\n    if char ==\
    \ c\n      result = (char,false)\n      break\n    i += 1\n  end\n  return result\n\
    end", "  \n  s = s.chars.to_a\n  c = c.chars.to_a\n  \n  s = s[0..-1] + s[0..-1].reverse\
    \ + s[0..-1]\n  \n  loop do\n    break if s.length <= 0\n    \n    i = s.index\
    \ c\n    break if i == -1\n    \n    s.delete_at i\n  end\n  \n  s.reverse!\n\
    \  \n  (s, s.chars.to_a.reverse.join == s.chars.to_a.join)\nend", '  return nil
    unless s && c', "  return s if c == s.reverse else nil\nend\nputs reverse_delete(\"\
    abcde\", \"ae\")\nputs reverse_delete(\"abcdef\", \"b\")\nputs reverse_delete(\"\
    abcdedcba\", \"ab\")\nputs reverse_delete(\"abcde\", \"a\")\nputs reverse_delete(\"\
    abcde\", \"c\")\nputs reverse_delete(\"abcde\", \"d\")\nputs reverse_delete(\"\
    abcde\", \"e\")\nputs reverse_delete(\"abcde\", \"f\")\nputs reverse_delete(\"\
    abcde\", \"g\")\nputs reverse_delete(\"abcde\", \"h\")\nputs reverse_delete(\"\
    abcde\", \"i\")\nputs reverse_delete(\"abcde\", \"j\")\nputs reverse_delete(\"\
    abcde\", \"k\")\nputs reverse_delete(\"abcde\", \"l\")\nputs reverse_delete(\"\
    abcde\", \"m\")\nputs reverse_delete(\"abcde\", \"n\")\nputs reverse_delete(\"\
    abcde\", \"o\")\nputs reverse_delete(\"abcde\", \"p\")\nputs reverse_delete(\"\
    abcde\", \"q\")\nputs reverse_delete(\"abcde\", \"r\")\nputs reverse_delete(\"\
    abcde\", \"s\")\nputs reverse_delete(\"abcde\", \"t\")\nputs reverse_delete(\"\
    abcde\", \"u\")\nputs reverse_delete(\"abcde\", \"v\")\nputs reverse_delete(\"\
    abcde\", \"w\")\nputs reverse_delete(\"abcde\", \"x\")\nputs reverse_delete(\"\
    abcde\", \"y\")\nputs reverse_delete(\"abcde\", \"z\")\nputs reverse_delete(\"\
    abcde\", \"a\")\nputs reverse_delete(\"abcde\", \"b\")\nputs reverse_delete(\"\
    abcde\", \"c\")\nputs reverse_delete(\"abcde\", \"d\")\nputs reverse_delete(\"\
    abcde\", \"e\")\nputs reverse_delete(\"abcde\", \"f\")\nputs reverse_delete(\"\
    abcde\", \"g\")\nputs reverse_delete(\"abcde\", \"h\")\nputs reverse_delete(\"\
    abcde\", \"i\")\nputs reverse_delete(\"abcde\", \"j\")\nputs reverse_delete(\"\
    abcde\", \"k\")\nputs reverse_delete(\"abcde\", \"l\")\nputs reverse_delete(\"\
    abcde\", \"m\")\nputs reverse_delete(\"abcde\", \"n\")\nputs reverse_delete(\"\
    abcde\", \"o\")\nputs reverse_delete(\"abcde\", \"p\")\nputs reverse_delete(\"\
    abcde\", \"q\")\nputs reverse_delete(\"abcde\", \"r\")\nputs reverse_delete(\"\
    abcde\", \"s\")", "  return if s == \"\"\n  reverse_s = reverse(s) if c.length\
    \ != 0\n  return (reverse_s, c) == (s,c) if reverse_s == s \n  else\n  (s,c) ==\
    \ (reverse_s,c) if (reverse_s == s)\n  else\n  (reverse_s,c) == (s,c) if reverse_s\
    \ == s \n  else\n  (reverse_s,c) == (reverse_s,c) if reverse_s == s \n  end\n\
    end", "    # Your code here\n    # your code here\n    result = \"\"\n    result.concat(s[0]);\n\
    \    result.concat(s[1]);\n    result.concat(s[2]);\n    result.concat(s[3]);\n\
    \    result.concat(s[4]);\n    result.concat(s[5]);\n    result.concat(s[6]);\n\
    \    result.concat(s[7]);\n    result.concat(s[8]);\n    result.concat(s[9]);\n\
    \    result.concat(s[10]);\n    result.concat(s[11]);\n    result.concat(s[12]);\n\
    \    result.concat(s[13]);\n    result.concat(s[14]);\n    result.concat(s[15]);\n\
    \    result.concat(s[16]);\n    result.concat(s[17]);\n    result.concat(s[18]);\n\
    \    result.concat(s[19]);\n    result.concat(s[20]);\n    result.concat(s[21]);\n\
    \    result.concat(s[22]);\n    result.concat(s[23]);\n    result.concat(s[24]);\n\
    \    result.concat(s[25]);\n    result.concat(s[26]);\n    result.concat(s[27]);\n\
    \    result.concat(s[28]);\n    result.concat(s[29]);\n    result.concat(s[30]);\n\
    \    result.concat(s[31]);\n    result.concat(s[32]);\n    result.concat(s[33]);\n\
    \    result.concat(s[34]);\n    result.concat(s[35]);\n    result.concat(s[36]);\n\
    \    result.concat(s[37]);\n    result.concat(s[38]);\n    result.concat(s[39]);\n\
    \    result.concat(s[40]);\n    result.concat(s[41]);\n    result.concat(s[42]);\n\
    \    result.concat(s[43]);\n    result.concat(s[44]);\n    result.concat(s[45]);\n\
    \    result.concat(s[46]);\n    result.concat(s[47]);\n    result.concat(s[48]);\n\
    \    result.concat(s[49]);\n    result.concat(s[50]);\n    result.concat(s[51]);\n\
    \    result.concat(s[52]);\n    result.concat(s[53]);\n    result.concat(s[54]);\n\
    \    result.concat(s[55]);\n    result.concat(s[56]);\n    result.concat(s[57]);\n\
    \    result.concat(s[58]);\n    result.concat(s[59]);\n    result.concat(s[60]);\n\
    \    result.concat(s[61]);\n    result.concat(s[62]);\n    result.concat(s[63]);\n\
    \    result.concat(s[64]);\n    result.concat(s[65]);\n    result.concat(s[66]);\n\
    \    result.concat(s[67]);\n    result.concat(s[68]);\n    result.concat(s[69]);\n\
    \    result.concat(s[", "  s.chars.each do |x|\n    if c != x\n      s = s + x\n\
    \    end\n  end\n  if s == s[0...s.length]\n    return s\n  end\n  return reverse_delete(s,c[1..-1])\n\
    end", "    \n    if s == '' or c == ''\n        return (s,True)\n    \n    if\
    \ s == c\n        return (s,True)\n    \n    reverse_s = s.reverse\n    reverse_c\
    \ = c.reverse\n    \n    if reverse_s == reverse_c\n        return (s,True)\n\
    \    \n    reverse_delete_rest = lambda s: reverse_delete(reverse_delete_rest(s[::-1]),c)\n\
    \    \n    if s == reverse_delete_rest(s)\n        return (s,True)\n    \n   \
    \ return (s,False)\n    ", "    s = []\n    i = 0\n    j = 0\n    rev = []\n \
    \   while i < len(s)\n        if s[i] == c\n            i += 1\n        else if\
    \ s[i] != c\n            j -= 1\n            rev[j] = s[i]\n            i += 1\n\
    \        if i == len(s)\n            break\n    s = rev\n    i = 0\n    j = 0\n\
    \    rev = []\n    while i < len(s)\n        if s[i] == c\n            i += 1\n\
    \        else if s[i] != c\n            j -= 1\n            rev[j] = s[i]\n  \
    \          i += 1\n        if i == len(s)\n            break\n    s = rev\n  \
    \  i = 0\n    j = 0\n    rev = []\n    while i < len(s)\n        if s[i] == c\n\
    \            i += 1\n        else if s[i] != c\n            j -= 1\n         \
    \   rev[j] = s[i]\n            i += 1\n        if i == len(s)\n            break\n\
    \    s = rev\n    i = 0\n    j = 0\n    rev = []\n    while i < len(s)\n     \
    \   if s[i] == c\n            i += 1\n        else if s[i] != c\n            j\
    \ -= 1\n            rev[j] = s[i]\n            i += 1\n        if i == len(s)\n\
    \            break\n    s = rev\n    i = 0\n    j = 0\n    rev = []\n    while\
    \ i < len(s)\n        if s[i] == c\n            i += 1\n        else if s[i] !=\
    \ c\n            j -= 1\n            rev[j] = s[i]\n            i += 1\n     \
    \   if i == len(s)\n            break\n    s = rev\n    i = 0\n    j = 0\n   \
    \ rev = []\n    while i < len(s)\n        if s[i] == c\n            i += 1\n \
    \       else if s[i] != c\n            j -= 1\n            rev[j] = s[i]\n   \
    \         i += 1\n        if i == len(s)\n            break\n    s = rev\n   \
    \ i = 0\n    j = 0\n    rev = []\n    while i < len(s)\n        if s[i] == c\n\
    \            i += 1\n        else if s[i] != c\n            j -= 1\n         \
    \   rev[j] = s[i]\n            i += 1\n        if i == len(s)\n            break\n\
    \    s = rev\n    i = 0\n    j = 0\n    rev = []\n    while i < len(s)\n     \
    \   if s[i] == c\n            i += 1\n        else if s[i] != c\n            j\
    \ -= 1\n            rev[j] = s[i]\n            i += 1\n        if i == len(s)\n\
    \            break\n    s = rev\n    i = 0\n    j = 0\n    rev = []\n    while\
    \ i < len(s)\n        if s[i] == c\n            i += 1\n        else if s[i] !=\
    \ c\n            j -= 1\n            rev[j] = s[i]\n            i += 1\n     \
    \   if i == len(s)\n            break\n    s = rev\n    i = 0\n    j = 0\n   \
    \ rev = []\n    while i < len(s)\n        if s[i] == c\n            i += 1\n \
    \       else if s[i] != c\n            j -= 1\n            rev[j] = s[i]\n   \
    \         i += 1\n        if i == len(s)\n            break\n    s = rev\n   \
    \ i = 0\n    j = 0\n    rev = []", "  chars = []\n  i = 0\n  while i < s.length\n\
    \    chars << s[i]\n    i += 1\n  end\n  i = 0\n  while i < s.length\n    if chars.include?(s[i])\n\
    \      chars.delete(s[i])\n    end\n    i += 1\n  end\n  if chars.join.to_s ==\
    \ chars.reverse\n    return chars, true\n  else\n    return chars, false\n  end\n\
    end", "  if s == \"\" then\n    return \"\"\n  end", "  result = ''\n  index =\
    \ 0\n  while index < s.length\n    if (s[index] == c)\n      result = result +\
    \ s[index]\n      index = index + 1\n      while index <= s.length - 1 && s[index]\
    \ == s[index + 1]\n        index = index + 1\n      end\n    end\n  end\n  return\
    \ (result,s[index] == s[index - 1]) ? true : false\nend", "    \n    rev_s = reverse(s)\n\
    \    rev_c = reverse(c)\n    \n    rev_s = rev_s.chars.join\n    rev_c = rev_c.chars.join\n\
    \    \n    if rev_s == rev_c\n        result =\n        true\n    else\n     \
    \   result =\n        false\n    end\n    \n    return result,true\nend", "\t\
    return s.gsub(c,'').split(//).each do |char|\n\t\treturn [char,true] if char ==\
    \ char.reverse\n\t\treturn [char,false] if char != char.reverse\n\tend\nend",
  "  # Your code here\n  s.gsub!(c,\"\") if s.index(c)==0 \n  s.reverse! if s.reverse==s\
    \ \n  [s,reverse] == [reverse,s]\nend", "    \n    return s.chars.to_h {c.chars}\
    \ == c.chars.to_h\nend", "  result = \"\"\n  s.each_index do |i|\n    if s.slice(i,1)\
    \ != c.slice(i,1)\n      result += s.slice(i,1)\n    end\n  end\n  return (result,s.eq(result))\n\
    end", "  s = s[0...s.length/2]\n  c = [c[0...c.length/2]]\n  r = s[0]\n  i = 0\n\
    \  \n  while i < s.length\n    if s[i] != c[i]\n      i += 1\n      r += s[i]\n\
    \    else\n      i += 1\n  end\n  \n  return (r, s[i] == c[i])\nend", "  if s.length\
    \ <= 0\n    return s\n  middle = (s.length/2).floor\n  for i in 0..middle-1\n\
    \    if s[i] == c\n      s = s[0..i-1] + s[middle..-1]\n      middle = middle+1\n\
    \    end\n  end\n  \n  result = s\n  if s == s[0..middle-1]\n    result = \"\"\
    \n  end\n  return [result, middle == s.length]\nend", "  begin = 0\n  end = s.length\n\
    \  mid = begin + (end-begin)/2\n  while mid <= end - 1\n    if s[mid] == c[begin]\n\
    \      begin = mid + 1\n      while begin >= 0 and s[begin] != c[end]\n      \
    \  begin--\n      end--\n      while end >= 0 and s[end] != c[begin]\n       \
    \ end--\n      if begin >= 0 and end >= 0 and begin < end\n        begin = begin\
    \ + 1\n        end = end - 1\n      else\n        return false\n    end\n  end\n\
    \  if begin >= 0 and end >= 0 and begin < end\n    begin = begin + 1\n    end\
    \ = end - 1\n  end\n  return s[begin..end]\nend", "\treturn s, s.chars.all? {\
    \ |char| s.chars.find { |a| a == char } != c }\nend", "  begin=0\n  end=s.length-1\n\
    \  while begin<end\n    if s[end]==c\n      s=s.delete(end,end+1)\n      end-1\n\
    \    else if s[end]!=c\n      begin+=1\n    end\n  end\n  begin=0\n  end=s.length-1\n\
    \  while begin<end\n    if s[begin]==c\n      s=s.delete(begin,begin+1)\n    \
    \  begin-1\n    else if s[begin]!=c\n      end+1\n    end\n  end\n  puts \"Result:\"\
    \ + s\n  puts \"Check:\" + (s==s)\nend", "    \n    return s.gsub(c.reverse!,\
    \ '').gsub(c.reverse!, '').reverse.eql?(s) ? true : false\nend", "  rev = s.reverse\n\
    \  s = rev[c.length..-1]\n  rev = rev[0..(c.length-1)]\n  res = s.reverse\n  return\
    \ res,(s == rev)\nend", "  result = ''\n  s = s.split('')\n  s = s.delete_if{|e|\
    \ e != c}\n  s = s.length\n  if s == 0 || s[s.first] == c\n    [result,true]\n\
    \  else\n    [result,false]\n  end\nend", "    puts \"Given string: #{s}\"\n \
    \   puts \"Given character: #{c}\"\n    i = 0\n    \n    while i < s.length\n\
    \        if s[i] == c\n            s.slice!(i,1)\n        end\n        i += 1\n\
    \    end\n    \n    return s, s == s.reverse\nend", "  # Your code here\n  s.chars.reverse_each{|i|\
    \ c =~ i && s.delete_at(i)}\n  result = s == s.reverse\n  return [s,result]\n\
    end\n</cell>\n<cell>", "  s.each_char do |char|\n    s.delete(char) if c.include?(char)\
    \ == false\n  end", "  n = s.length\n  i = 0\n  result = []\n  while i < n\n \
    \   if s[i] == c[i]\n      i += 1\n    else\n      result[i] = s[i]\n    end\n\
    \  end\n  result.reverse!\n  result\nend", "    deleted = s.delete(c)\n    if\
    \ deleted.size == 0\n        return (s,false)\n    deleted.reverse!\n    return\
    \ (deleted,true)\nend\n</code>\n<|/ a dscore=0 tags=ruby,string |>\n<| a dscore=0\
    \ |>\nSince your question asks for a solution in Ruby language, you can try the\
    \ following:\n<code>", "  reverse = s[0...-1].reverse\n  if s.include?(c.upcase)\
    \ == reverse\n    result.upcase\n  end\nend", "  \n  s.each do |i|\n    if c ==\
    \ i\n      s = s.gsub(i, '')\n    end\n  end\n  \n  s = s.reverse!\n  \n  puts\
    \ \"#{s} #{s.eql?(s.reverse)}\"\n  \n  s = s.reverse\n  \n  puts \"#{s} #{s.eql?(s.reverse)}\"\
    \n  \n  \n  \n  \nend", "  return \"#YOU DID IT\" unless s.empty? and c.empty?\n\
    \  \n  s.chars.each do |el|\n    if el == c.first\n      s.delete_at el\n    \
    \  c = c.drop(1)\n    end\n  end\n  [s, c].each { |el| el.unshift(el[0]) }\n \
    \ [s, c].each { |el| el.reverse! if el == s.reverse }\n  [s, c].each { |el| el.pop\
    \ if el == c.first }\n  [s, c].each { |el| el.reverse! if el == c.reverse }\n\
    \  [s, c].each { |el| el.pop if el == s.first }\n  \n  \nend\n ", "  return false\n\
    end", "  s.gsub!(c,\"\").reverse!\n  s.reverse!\n  s=s.join(\"\")\n  return s,s.empty?\n\
    end", "\t\nend", "  result = \"\"\n  for i in 0...s.length-1\n    result << s[i]\n\
    \  end\n  for i in 0...s.length-1\n    if result[i] != c\n      return result\
    \ , False\n    end\n  end\n  return result , True\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby |>\n<| a |>\nYou don't have to reverse string and then check for equality\
    \ just reverse string and check if it is equal\n<code>", "\tdeleted = []\n\tfor\
    \ i in 0..length(s)\n\t\tif s[i] == c\n\t\t\tdeleted.push(s[i])\n\t\tend\n\tend\n\
    \t\n\tif deleted\n\t\tnew_s = deleted.reverse\n\telse\n\t\tnew_s = s\n\tend\n\t\
    \n\tif new_s == s\n\t\treturn (new_s,true)\n\telse\n\t\treturn (new_s,false)\n\
    \tend\nend", "  s.gsub!(c, '')\n  s.split(//).each do |char|\n    if s[0...char.length]\
    \ == char\n      s.slice!(0, char.length)\n      break\n    end\n  end\n  case\
    \ s\n  when s[:-1, :-1] # We have done our job, check if it's a palindrome\n \
    \   true\n  when s[0, -1] == s[-1...-1] # Not a palindrome, check it later\n \
    \   false\n  else\n    delete_reverse(s)\n  end\nend", "\ts = s.chars.to_a\n\t\
    s = s.select { |i| (s[i] == c) }\n\ts = s[1..-1]\n\ts.chars.to_a == s[0..-2].chars.to_a\
    \ ? (s, true) : (s, false)\nend\n</cell>\n<cell>", "\treturn s, c == s[0..s.length]\n\
    end", "  i = 0\n  r = \"\"\n  while i < s.length\n    if s[i] == c\n      r =\
    \ r + s[i]\n    else\n      r = r + s[i]\n      i = i + 1\n  end\n  r.reverse!\n\
    \  return (r == s) ? [\"palindrome\",false] : [\"palindrome\",true]\nend", " \
    \   # Your code here\n    result = []\n    s = s.split(\"\")\n    for x in s:\n\
    \        if x == c:\n            result.append(x)\n        elif x < c:\n     \
    \       result.append(x)\n        else:\n            result.append(x)\n      \
    \  if result == s[::-1]:\n            return result[::-1]\n        else:\n   \
    \         return False\n    return result, True", "    chars = s.chars\n    result\
    \ = ''\n    s.chars.each_with_index do |c, i|\n        if c == c\n           \
    \ result += chars[i]\n        elsif c != c\n            result += c\n        end\n\
    \    end\n    return (result,s.chars.all? {|c| c == c})\nend\n</cell>\n<cell>\n\
    puts \"Testing #reverse_delete...\"\ns = %w{abcde abc bcd}\nc = %w{a e b}", "\t\
    # Write your code here\n\tresult = \"\"\n\tfor i in s\n\t\tresult+=i\n\t\tif i\
    \ == c\n\t\t\tbreak\n\tresult = result[::-1]\n\treturn (result,True)\nend", " \
    \   i = 0\n    resString = \"\"\n    while i < len(s)\n        if s[i] == c\n\
    \            if i == len(s) - 1 \n                resString += s[i]\n        \
    \    else \n                resString += s[i] + c\n        i += 1\n    return\
    \ resString, s[0: i - 1] == s[0: i - 1][::-1]", "  result=s.dup\n  result.reject!{|x|\
    \ c!=x}\n  result==s\nend", "    if s.count != c.count\n        return ('false',False)\n\
    \    end\n    i = 0\n    j = 0\n    while  i<s.length and j<c.count\n        if\
    \ s[i]==c[j]\n            i += 1\n            j += 1\n        else\n         \
    \   s = s[i..-1]\n            end\n        end\n    end\n    return (s,j==c.count)\n\
    end", "    \n    if s.length == 0\n        return s,False\n    \n    if s.length\
    \ == 1\n        return s,False\n    \n    if s[0] == c\n        s, result = s[:1]\
    \ + s[1..-1], s[:1] + s[1..-1]\n    \n    \n    if s[0] != c\n        s, result\
    \ = s[:1] + reverse(s[1..-1]), s[:1] + reverse(s[1..-1])\n    \n    return s,\
    \ result", "\ts.reverse!\n\ts.gsub!(c)\n\ts.reverse!\n\ts.eql?(s.join)\nend\n\
    </cell>\n<cell>\nreverse_delete('a', 'b')\n</cell>\n<text>\nString#length\nThe\
    \ string length is measured in characters. It returns the number of characters\
    \ in the string.\nExample:\nFor s = \"abccc\", return 3.", "  # Write your code\
    \ here\n  str1 = s.chars.to_a\n  str2 = c.chars.to_a\n  result = []\n  for i in\
    \ (0...str1.length-1)\n    result << str1[i..].to_s + str2.to_a[i..].to_s\n  end\n\
    \  if result == str1.chars.reverse\n    [result,true]\n  else\n    [result,false]\n\
    \  end\nend", "  result = ''\n  i = 0\n  while i < s.length\n    if s[i] == c[i]\n\
    \      result = result + s[i]\n      i += 1\n    else\n      i += 1\n  end\n \
    \ return (result,i == s.length)\nend", "  result = \"\"\n  is_palindrome = True\n\
    \  s.each_char do |letter|\n    if c.include?(letter)\n      result << letter\n\
    \      is_palindrome = false\n    else\n      result << letter\n    end\n  end\n\
    \  if result == s\n    (s, is_palindrome)\n  end\nend", "  chars = {}\n  result\
    \ = ''", "    s = s.chars.to_a\n    i = 0\n    j = s.length - c.length\n    if\
    \ j < 0\n        return [s,false]\n    end\n    result = [\"\",false]\n    loop\
    \ = true\n    until loop\n        if s[i] == c[i]\n            result[1] = true\n\
    \            i = i + 1\n            if i == j\n                loop = false\n\
    \            end\n        else\n            result[0] = result[0] + s[i]\n   \
    \         i = i + 1\n        end\n    end\n    return result\nend\nputs reverse_delete(\"\
    abcde\", \"ae\")\nputs reverse_delete(\"abcdef\", \"b\")\nputs reverse_delete(\"\
    abcdedcba\", \"ab\")\nputs reverse_delete(\"abc\", \"b\")\nputs reverse_delete(\"\
    a\", \"a\")\nputs reverse_delete(\"asdf\", \"s\")\nputs reverse_delete(\"asdf\"\
    , \"q\")\nputs reverse_delete(\"asdf\", \"asdf\")\nputs reverse_delete(\"asdf\"\
    , \"asdg\")\nputs reverse_delete(\"asdf\", \"asdfq\")\nputs reverse_delete(\"\
    asdf\", \"qasdf\")\nputs reverse_delete(\"asdf\", \"aasdf\")\nputs reverse_delete(\"\
    asdf\", \"asdfas\")\nputs reverse_delete(\"asdf\", \"asdfasd\")\nputs reverse_delete(\"\
    asdf\", \"asdfasdf\")\nputs reverse_delete(\"asdf\", \"asdfasdfas\")\nputs reverse_delete(\"\
    asdf\", \"asdfasdfasd\")\nputs reverse_delete(\"asdf\", \"asdfasdfasdf\")\nputs\
    \ reverse_delete(\"asdf\", \"asdfasdfasdfas\")\nputs reverse_delete(\"asdf\",\
    \ \"asdfasdfasdfasd\")\nputs reverse_delete(\"asdf\", \"asdfasdfasdfasdf\")\n\
    puts reverse_delete(\"asdf\", \"asdfasdfasdfasdfas\")\nputs reverse_delete(\"\
    asdf\", \"asdfasdfasdfasdfasd\")\nputs reverse_delete(\"asdf\", \"asdfasdfasdfasdfasdf\"\
    )\nputs reverse_delete(\"asdf\", \"asdfasdfasdfasdfasdfas\")\nputs reverse_delete(\"\
    asdf\", \"asdfasdfasdfasdfasdfasd\")\nputs reverse_delete(\"asdf\", \"asdfasdfasdfasdfasdfasdf\"\
    )\nputs reverse_delete(\"asdf\", \"asdfasdfasdfasdfasdfasdfas\")\nputs reverse_delete(\"\
    asdf\", \"", "  str = s.split(//,2)\n  str = str.join,''\n  str = str.gsub(c)\n\
    \  str = str.split(//,2)\n  str = str.join,''\n  return str,s.include?(str) ==\
    \ nil\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "    i = s.length\n\
    \    j = 0\n    \n    while i < 0\n        j = j + 1\n        \n        s[i] =\
    \ c[j-1]\n        \n        i = i - 1\n        \n        j = 0\n        \n   \
    \     while j > 0\n            j = j - 1\n        \n        if s.reverse == c\n\
    \            return ('True',True)\n        end\n    end\n    \n    return ('True',False)\n\
    end", "\trev_str = \"\"\n\trev_c = \"\"\n\tfor i in s\n\t\trev_str += i\n\t\t\
    rev_c += c", "  if c == \"\" then return s\n  local result\n  local i\n  result\
    \ = \"\"\n  for i in (#s - 1) .. 1 do\n    if s[i] == c then\n      if result\
    \ ~= \"\" then\n        result = result .. s[i]\n      else\n        result =\
    \ s[i]\n      end\n    else\n      if result ~= \"\" then\n        result = result\
    \ .. s[i]\n      end\n    end\n  end\n  if s == result and s[1] == result[1] then\n\
    \    return (\"True\",True)\n  else\n    return (\"False\",False)\n  end\nend\n\
    </code>\n<|/ q dscore=1 |>\n<| c |>\nPlease paste code as text, not screenshot.\n\
    <|/ c |>\n<| c |>\nOk, I added the code as text\n<|/ c |>\n<| c |>\n`s[#s]` will\
    \ throw an error if s is nil. Are you sure that's not what happening here?\n<|/\
    \ c |>\n<| c |>\nI am pretty sure that it's not, since s is nil when it's reached\
    \ that line\n<|/ c |>\n<| c |>\nI added the screenshot, sorry for the inconvenience\n\
    <|/ c |>\n<| a dscore=1 tags=lua |>\nYou're confused about the difference between\
    \ nil and an empty string. nil is the absence of a value. An empty string is the\
    \ string that is an empty string by definition. So this loop:\n<code>\nfor k in\
    \ 0 ... #s do\n</code>\nwill always run zero times. So when you write this:\n\
    <code>\nlocal t = reverse_delete(s,c) -- This will always return (\"\", false)\n\
    </code>\nYou just get an empty string and a boolean indicating that the string\
    \ is indeed a palindrome. Remember, the string \"a\" is a palindrome. \nThe function\
    \ reverse_delete is doing exactly what it's supposed to do: given a string and\
    \ an alphabet to delete, it will delete all the characters in the string that\
    \ are equal to the alphabet to delete. It will always return a boolean indicating\
    \ that the string is a palindrome.\nNow consider this:\n<code>\nlocal t = reverse_delete(s,c)\
    \ -- This will always return (\"\", false)\n</code>\nThat is, your loop is doing\
    \ exactly what it's supposed to do: given a string and an alphabet, it will delete\
    \ all the characters in the string that are equal to the alphabet to delete. \n\
    Now consider this:\n<code>\nlocal t = reverse_delete(s,c) -- This will always\
    \ return (\"\", false)\nprint(t[1])\n</code>\nThat is, the function is working\
    \ as it's supposed to work. The function returns a string and boolean ", "   \
    \ # Write your code here\n    chars = chars + c\n    chars = chars.split('')\n\
    \    chars.reverse\n    new_s = chars.join('')\n    return (new_s, s == new_s)",
  "    if s==[] or c==[]\n    return s, false\n    end", "  new_s = s\n  reversed_s\
    \ = s\n  new_c = c\n  reversed_c = c\n  i = 0\n  while i < s.length\n    while\
    \ i < s.length\n      new_s = new_s.delete(i)\n      i += 1\n    end\n    i =\
    \ 0\n    while i < reversed_s.length\n      reversed_s = reversed_s.delete(i)\n\
    \      i += 1\n    end\n    if new_s == reversed_s\n      new_s = new_s.insert(0,c)\n\
    \      reversed_s = reversed_s.insert(0,c)\n    end\n  end\n  if new_s == reversed_s\n\
    \    return (new_s,true)\n  else\n    return (new_s,false)\n  end\nend", "  if\
    \ s == nil then return s, false\n  if c == nil then return s, true", "  # Write\
    \ your code here.\n  return s.chars.uniq.each { |el| s.gsub(el, \"#\").gsub(el,\
    \ c).chars.uniq.size == s.chars.uniq.size }\nend", "\ts = s.dup\n\tc = c.dup\n\
    \treversed_string = \"\"\n\ti = 0\n\twhile i < s.size\n\t\treversed_string <<\
    \ s[i]\n\t\ti += 1\n\twhile i < c.size\n\t\ts[i] < c[i] ? s[i] << c : s[i]\n\t\
    \ti += 1\n\ti = 0\n\twhile i < s.size\n\t\ts[i] == c[i] ? s.delete(i) : nil\n\t\
    \ti += 1\n\ti = 0\n\twhile i < s.size\n\t\ts[i] == c[i] ? s.delete(i) : nil\n\t\
    \ti += 1\n\treturn reversed_string\nend", "  return s[:s.index(c)+c.index(c)]\
    \ == reverse_delete(s[s.index(c)+c.index(c)+1:], c)\nend", "  reversed_s = s.reverse\n\
    \  s.reverse!\n  \n  s.gsub!(c,\"\")\n  s.reverse!\n  \n  return s\nend", "  s\
    \ = s.chars\n  n = s.length\n  s = s.delete(c, n)\n  s.reverse!\n  s.join!\n \
    \ \n  s = s.chars\n  n = s.length\n  s = s.delete(c)\n  s.join!\n  \n  s.chars\
    \ == s.reverse ? true : false \nend", "  # Write your code here.\n  return [s[:i]+s[i:]+s[i+1:]\
    \ for i in s.index(c) if s[i:i+1] == c]", "    # Write your code here\n    return\
    \ s[:]+s[:s.index(c)+len(c)]+s[s.index(c)+len(c):],True\nend\n</cell>\n<code language=julia-1.0>",
  "  new_s = s.clone\n  new_c = c.clone\n  new_s.delete!(c)\n  new_c.delete!(s)\n\
    \  return (new_s, new_c == s.reverse)\nend", "  s.gsub!(c,\"\")\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  s.reverse!\n  s.reverse", "    return s.gsub(/(c)*\\\
    1/, \"\") == c\nend", "  # Write your code here.\n  rs = ''\n  for i in 0...s.length\n\
    \    rs << s.slice(i,1)\n  rc = c\n  rs = rs.reverse\n  return (rs == rc) ? ('',True)\
    \ : ('',False)\nend", "  begin = s.index(c.first)\n  end = s.index(c.last)\n \
    \ rest = s[begin..end]\n  puts \"#{begin..end}:#{rest}\" if DEBUG\n  reverse_delete(rest,\
    \ c)\nend", "  s.reverse!\n  s.delete_if {|x| x == c}\n  s.reverse!\n  return\
    \ s ==  s?\"True\":\"False\"\nend", "    return s.chars.map { |x| x != c }.inject(:+)\
    \ == 0 ? [s,False] : [s.reverse.chars.map { |x| x != c }.inject(:+) == 0 ? [s.reverse,True]\
    \ : [s.reverse.chars.map { |x| x != c }.inject(:+) == 0 ? [s.reverse.reverse,True]\
    \ : [s.reverse.chars.map { |x| x != c }.inject(:+),False]\nend", "  if s == nil\
    \ then\n    return('',false)\n  end\n  if c == nil then\n    return(s,true)\n\
    \  end\n  rev_s = reverse_delete(s[..-1],c)\n  if rev_s == nil then\n    return(s,true)\n\
    \  end\n  if rev_s[1] == c then\n    return(s,false)\n  end\n  return(rev_s,false)\n\
    end", "\trev = \"\"\n\ts.each_byte do |c|\n\t\trev.concat(c)\n\tend\n\treturn\
    \ rev,(s == rev) #Check if s is palindrome\nend", "  \n  s = s.gsub(/(^|\\s)#{c}($|\\\
    s)/, \"\")\n  return (s==s.reverse), s\nend\n</cell>\n<code language=julia-0.4>",
  "\t# Your code here\n\tresult = []\n\tfor i in 0...s.length-1\n\t\tif s[i]==c\n\t\
    \t\tresult.push s[i]\n\t\tend\n\tend\n\tresult.push s[s.length-1]\n\treturn result,true\n\
    end", "\trev = s.reverse\n\trev.each_char do |i|\n\t\tif i == c\n\t\t\trev.delete(i)\n\
    \t\t\tbreak\n\t\tend\n\tend\n\treturn rev\nend", "  result = ''\n  s.each_char\
    \ do |char|\n    result << char if char == c\n  end\n  return (result,s.chars\
    \ == s.reverse.chars)\nend", "  str = s.dup\n  str.reverse!\n  str.replace c\n\
    \  result = str == s ? \"palindrome\" : \"\"\n  rev = str.dup.reverse!\n  (rev\
    \ ==  s) ? \"palindrome\" :  result\nend", "  s.each_char do |char|\n    p char\
    \ if char == c.first\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 tags=ruby\
    \ |>\n<code>", "  # Solution here\n  s = s.reverse\n  s.delete(c)\n  \n  i=1\n\
    \  while i<s.size\n    s.insert(i,s.delete(i))\n    i+=1\n  end\n  s.reverse\n\
    \  \n  while i<s.size\n    if s[i]==s[i]\n      s.insert(i,s.delete(i))\n    \
    \  i+=1\n    end\n  end\n  return s,s[i]==s[i-1]\nend", "    # Your code here\n\
    \    if s == c\n        begin, end = 0, 0\n    else\n        begin, end = s.index(c),\
    \ s.length\n        puts s\n        while begin < end - 1\n            s[begin],\
    \ s[end - 1]  = s[end - 1], s[begin]\n            begin += 1\n            end\
    \ -= 1\n        end\n        puts s\n    return s\nend", "  s.each_index do |i|\n\
    \    s[i] == c[i] ? s.delete_at(s.size - i - 1) : nil\n  end\n  s == s.join\n\
    end\np reverse_delete(\"abcdef\", \"b\") # => [\"acdef\"]\np reverse_delete(\"\
    abcdedcba\", \"ab\") # => [\"cdedc\"]\np reverse_delete(\"acdefghij\", \"ab\"\
    ) # => nil\n</code>\n<|/ a tags=string,ruby,palindrome |>\n<| c |>\nI like the\
    \ `each_with_index` solution, and will probably use it here, but I decided that\
    \ using a loop over the array would be cleaner: `s.each_with_index.detect { |c,i|\
    \ s[i] == c; s.delete_at(i+1 unless s[i] == c }`\n<|/ c |>\n<| c |>\n: It's much\
    \ cleaner indeed. I was just trying to make it as clear as possible - it's nice\
    \ to see how a beginner can understand what's going on. :)\n<|/ c |>\n<| a dscore=0\
    \ tags=string,ruby,palindrome |>\nYou could also use Enumerable#each_char to loop\
    \ through all characters in string, something like:\n<code>", "    \n    s = s.chars\n\
    \    c = c.chars\n    \n    l = s.length\n    \n    res = \"\"\n    \n    for\
    \ i in 0..(l-1) do\n        if s[i]==c[i] then\n            res = res+s[i]\n \
    \       else\n            res = res+s[i]\n        end\n    end\n    \n    if res==res\
    \ then\n        return (res,true)\n    else\n        return (res,false)\n    end\n\
    end", "    if s.length != c.length || c is nil\n        return nil\n    end\n\
    \    temp = c\n    while temp != nil\n        if s ==temp\n            return\
    \ nil\n        else\n            temp = temp + c\n        end\n    end\n    return\
    \ s\nend", "  result = \"\"\n  for i in 0...s.length\n    if s.chars[i] == c\n\
    \      result += s.chars[i]\n    end\n  end\n  if result == s.reverse\n    return\
    \ (result,true)\n  else\n    return (result,false)\n  end\nend", "  result = ''\n\
    \  s.each_byte do |b|\n    result << c if b == c\n  end\n  result == s.reverse\n\
    end", "  s = s[0..-2]\n  c = c[0..-2]\n  i = 0\n  j = s.length-1\n  while (i <\
    \ j)\n    temp = s[i]\n    s[i] = c[j]\n    c[j] = temp\n    i += 1\n    j -=\
    \ 1\n  return c, s == c[..-1]\nend", "    if s == c\n        return (s,True)\n\
    \    else\n        left_idx = 1\n        right_idx = 1\n        deleted_chars\
    \ = []\n        for char in s\n            if char == c\n                deleted_chars.append(char)\n\
    \            if char == s[left_idx]\n                left_idx += 1\n         \
    \   if char == s[right_idx]\n                right_idx += 1\n        \n      \
    \  #print(s,c)\n        #print(left_idx, right_idx)\n        #print(deleted_chars)\n\
    \        \n        \n        if left_idx > right_idx\n            return (s,False)\n\
    \        else:\n            left_idx = 0\n            right_idx = 0\n        \
    \    \n            for char in s\n                if char == s[left_idx]\n   \
    \                 left_idx += 1\n                if char == s[right_idx]\n   \
    \                 right_idx += 1\n            \n            if left_idx < right_idx\n\
    \                left_idx += 1\n                right_idx -= 1\n            \n\
    \            if left_idx == right_idx\n                left_idx += 1\n       \
    \         right_idx -= 1\n            \n            if left_idx > right_idx\n\
    \                return (s,True)\n            else:\n                left_idx\
    \ += 1\n                right_idx -= 1\n                \n                new_left_idx\
    \ = 1\n                new_right_idx = 1\n                \n                new_s\
    \ = s[:left_idx]\n                new_s += deleted_chars\n                new_s\
    \ += s[right_idx:]\n                \n                #print(s,c)\n          \
    \      #print(left_idx, right_idx)\n                #print(deleted_chars)\n  \
    \              #print(new_s)\n                #print(new_left_idx, new_right_idx)\n\
    \                return (new_s,True)", "  srev = ''\n  crev = ''\n  for c in s\n\
    \    if c == s[s.rindex(c)-1]\n      srev += c\n    elsif c == s[s.rindex(c)+1]\n\
    \      crev += c\n    else\n      srev += c\n      crev += c\n  if s == srev\n\
    \    return (srev,True)\n  elsif c == crev\n    return (crev,True)\n  else\n \
    \   return (s,False)\nend", "  if s.size < c.size\n    return s, false\n  end\n\
    \  result = s.dup\n  i = 0\n  j = 0\n  while i < s.size && j < c.size\n    if\
    \ s[i] == c[j]\n      result.delete(i)\n      i += 1\n      j += 1\n      continue\n\
    \    end\n    if s[i] == c[j]\n      i += 1\n      j += 1\n      continue\n  \
    \  end\n    i += 1\n  end\n  result.delete(i)\n  return result, true\nend", "\t\
    begin = 0\n\tend = len(s) - 1\n\t\n\twhile begin < end\n\t\t\n\t\tif s[begin]\
    \ == c[begin]\n\t\t\tbegin = begin + 1\n\t\t\n\t\telse\n\t\t\tbegin = begin -\
    \ 1\n\t\n\twhile end >= 0\n\t\t\n\t\tif s[end] == c[end]\n\t\t\tend = end - 1\n\
    \t\t\n\t\telse\n\t\t\tend = end - 1\n\t\n\t\n\tif begin >= 0\n\t\t\n\t\tresult\
    \ = s[begin..end]\n\t\t\n\telse\n\t\t\n\t\tresult = s[0...end]\n\t\n\t\n\treturn\
    \ result\nend", "\t\n\ti = 1\n\t\n\twhile i <= s.length/2\n\t\t\n\t\tif s[i] ==\
    \ c\n\t\t\t\n\t\t\ts = s.gsub(s[i], \"\")\n\t\t\n\t\ti += 1\n\t\n\treturn s,true\n\
    end", "  \n  return nil\nend", "  s.chars.delete_if do |x|\n    c.include?(x)\n\
    \  end\n  s.chars.reverse.each_char.each_cons(2) do |x|\n    if x == x\n     \
    \ return (x, true)\n    end\n  end\n  return (s, false)\nend", "\ts=s.downcase\n\
    \tc=c.downcase\n\tlens=s.length\n\tlenc=c.length\n\trev=Array.new\n\trev[0]=s\n\
    \ti=2\n\twhile(i<lens)\n\t\trev[i]=rev[i-1]+c\n\t\ti+=1\n\trev[lens-1]\n\tcheck=true\n\
    \ti=lens-1\n\twhile(i>=0)\n\t\tif(rev[i]!=rev[lens-1])\n\t\t\tcheck=false\n\t\t\
    i-=1\n\trev,check\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
