name: HumanEval_19_sort_numbers
language: rb
prompt: "# Input is a space-delimited string of numberals from 'zero' to 'nine'.\n\
  # Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven',\
  \ 'eight' and 'nine'.\n# Return the string with numbers sorted from smallest to\
  \ largest\n# >>> sort_numbers('three one five')\n# 'one three five'\ndef sort_numbers(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_numbers\n\
  \    candidate = method(:sort_numbers)\n    assert_equal(\"\", candidate.call(\"\
  \"))\n    assert_equal(\"three\", candidate.call(\"three\"))\n    assert_equal(\"\
  three five nine\", candidate.call(\"three five nine\"))\n    assert_equal(\"zero\
  \ four five seven eight nine\", candidate.call(\"five zero four seven nine eight\"\
  ))\n    assert_equal(\"zero one two three four five six\", candidate.call(\"six\
  \ five four three two one zero\"))\n  end\nend\n"
completions: ["  # Your code here\nend", "  numbers.split(' ').sort!.reverse.join\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`numbers.split(' ').sort!.reverse.join`\
    \ is nice & short but doesn't work when passed `'one two three'`\n<|/ c |>\n<|\
    \ c |>\n: Yes, you're right, I corrected the answer. Now it works with `'one two\
    \ three'`\n<|/ c |>\n<| c |>\nThis is the best solution. I'd suggest changing\
    \ `sort!.reverse` to `sort!.reverse`\n<|/ c |>\n<| c |>\n`sort!.reverse` will\
    \ reverse the array in-place and returns the receiver (so it will sort the original\
    \ array). `sort!` returns the sorted array (so the original array is not modified).\
    \ So the second line is more efficient since it creates a temporary array and\
    \ reversing it.\n<|/ c |>\n<| c |>\nThanks for your input! That is very helpful!\n\
    <|/ c |>\n<| a tags=ruby dscore=5 |>\n<code>", "  if numbers.blank?\n    ''\n\
    \  elsif numbers.include?(' ')\n    numbers\n  else\n    numbers = numbers.split.map\
    \ {|n| n.to_i}\n    numbers.sort\n    numbers.join(' ')\n  end\nend", "  numbers\
    \ = numbers.split.sort\n  numbers = numbers.join(\" \")\n  numbers\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=ruby,arrays,sorting |>\nHere's another option that\
    \ I thought was interesting: use a hash to hold the values from the list, and\
    \ sort by the hash keys.  This has the advantage of not requiring any temporary\
    \ variables.  It also makes the method a bit shorter to write.\n<code>", "  sorted_numbers\
    \ = numbers.split\n  sorted_numbers.sort!\n  return sorted_numbers.join(' ')\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby |>\n<code>", "  numbers.to_s.scan(/\\\
    d+/).map{|x| x.to_i}.sort.join(' ')\nend", "  numbers = numbers.split(' ')\n \
    \ numbers.sort\n  numbers.join(' ')\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ dscore=0 |>\n<| c |>\nWhat about `'one two three'`?\n<|/ c |>\n<| c |>\nThat\
    \ was a trivial fix that I forgot when writing this code. Fixed it now.\n<|/ c\
    \ |>\n<| c |>\nI'm just interested why `sort` is not used in this particular case.\n\
    <|/ c |>\n<| c |>\nIt isn't used in that particular case.  It's in the general\
    \ case though.  I've updated my answer to show how it can be used in that case.\n\
    <|/ c |>\n<| a dscore=0 tags=ruby,ruby-on-rails |>\n<code>\nnumbers = \"one two\
    \ three\".split(\" \")\nnumbers.sort.join(\" \")", "  numbers = numbers.split('\
    \ ')\n  numbers.sort!\n  numbers = numbers.join(' ')\nend", "  # +++your code\
    \ here+++\n  numbers.split(\" \").sort!\n  numbers.split(\" \").join\nend\n</cell>\n\
    <text>\nHelpers\nIf you find yourself writing repetitive chunks of code, then\
    \ you should refactor your code into functions. You may want to define functions\
    \ to refactor common code so that you can call them multiple times.", "  numbers\
    \ = numbers.split(' ') \n  numbers = numbers.map{|x| x.to_i} \n  numbers.sort!\n\
    \  numbers.reverse!\n  numbers.join(' ')\nend\n</code>\n<|/ a tags=string,ruby,sorting,arrays\
    \ |>\n<| c |>\nThis seems to work fine for the above example, but would break\
    \ if the input was `\"one two three four\"`. A more robust solution would be to\
    \ convert the string into an array, sort it, and then convert the array back into\
    \ a string, but I think the solution in the accepted answer would be the best.\n\
    <|/ c |>\n<| a dscore=2 tags=string,ruby,sorting,arrays |>\nAs you say in the\
    \ comments, I agree with John Smiley's solution but will add a more robust version\
    \ as well.\n<code>", "  # Your code here\n  numbers.split(\" \").sort_by {|s|\
    \ s.to_i }.reverse.join(\" \")\nend", "  numbers = numbers.split(/\\s+/)\n  numbers.sort!\n\
    \  strings.join numbers\nend", "  # Split string in list of strings on space\n\
    \  number_list = numbers.split(\" \")\n  number_list.sort!", "  numbers.split(\"\
    \ \").sort_by { |number| number.to_i }.join\nend", "  numbers.gsub!(/[[:alpha:]]/,\
    \ '')\n  numbers.split(' ').sort!\n  numbers.join(' ')\nend\n</code>\n<|/ a tags=ruby,string,sorting\
    \ |>\n<| c |>\nVery nice `sort_numbers` implementation and use of [`String#gsub`](http://www.ruby-doc.org/core-1.9.3/String.html#method-i-gsub).\
    \ Also, for me `sort_numbers` returns `'one three five'`, but the example output\
    \ (in the question) shows it is `'one three five'`.\n<|/ c |>\n<| c |>\nYes, this\
    \ was a typo in the question (`sort_numbers` should be `sort_number`). The question\
    \ is updated.\n<|/ c |>\n<| a tags=ruby,string,sorting dscore=2 |>\nI haven't\
    \ tested this but a couple ideas come to mind:", "  numbers.split(' ').sort.join('\
    \ ')\nend", "  numbers.split(\" \").sort_by(&:to_i).join(\" \")\nend", "  sorted_numbers\
    \ = numbers.gsub(/[^a-z]/, '').downcase.split(' ')\n  sorted_numbers.sort!\n \
    \ sorted_numbers = sorted_numbers.join(' ')\nend\n</code>\n<|/ a tags=ruby,string,sorting\
    \ |>\n<| a dscore=0 tags=ruby,string,sorting |>\nYou want the Ruby Array sort_by\
    \ method.\n<|/ a |>\n<| c |>\nHow does this not answer the question? He already\
    \ has an array of strings and wants to sort them. What exactly is the problem?\n\
    <|/ c |>\n<| c |>\nI don't think this is an answer, just more of an comment. Also,\
    \ it's obvious that the OP doesn't know about `sort_by` or the array class, so\
    \ this might be a little too advanced for him.\n<|/ c |>\n<| c |>\nOh, I'm sorry.\
    \ I was thinking it was an answer since it's a solution to the problem.\n<|/ c\
    \ |>\n<| c |>\nWell, it's an answer, but I'm sorry for my \"answer\" being so\
    \ long. :) My point was that it should be posted as a comment.\n<|/ c |>\n<| c\
    \ |>\nMy bad. I was confused about which way to go. I'll edit my answer to make\
    \ it more clear now.\n<|/ c |>\n<| a |>\nThe Ruby documentation has a nice description\
    \ of how to do this sort of thing:\n<code>", "  strings.split(numbers).sort.join(\"\
    \ \")\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI think you mean `sort_numbers(numbers)`\
    \ not `sort_numbers(x)`\n<|/ c |>\n<| c |>\nYou don't need to sort twice since\
    \ Ruby has a built in sort method. `def sort_numbers(numbers)\n  strings.split(numbers).sort\n\
    end`\n<|/ c |>\n<| c |>\nJust for completeness: `numbers.split.sort { |a, b| a.to_i\
    \ <=> b.to_i }.join(' ')`\n<|/ c |>\n<| c |>\nTo sort an array in Ruby you can\
    \ just do: `numbers.sort.join(\" \")` :)\n<|/ c |>\n<| c |>\nThis is good answer\
    \ for ruby programmers, but the question was about how to sort a string in Java.\
    \ Your answer is a very general one and is not specific to any language as far\
    \ as I know.\n<|/ c |>\n<| a dscore=5 |>\nUse this method\n<code>\npublic static\
    \ String sortString(String aString) {\n    String[] arrStr = aString.split(\"\\\
    \\s\");\n    String[] arrStr1 = new String[arrStr.length];\n    for(int i=0;i<arrStr.length;i++)\n\
    \        arrStr1[i] = arrStr[i];\n    Arrays.sort(arrStr1);\n    return String.join(\"\
    \ \", arrStr1);\n}\n</code>\n<|/ a tags=java,algorithm,sorting |>\n<| c |>\nFor\
    \ those who are not familiar with split see http://www.journaldev.com/1940/java-string-split\
    \ for details.\n<|/ c |>\n<| c |>\nthis doesn't work for strings containing more\
    \ than one word\n<|/ c |>\n<| c |>\nThe question was about sorting a string. This\
    \ answer sorts a single string.\n<|/ c |>\n<| c |>\nThis does not work for strings\
    \ containing more than one word. For example: `\"one two three\".split(\" \")`\
    \ returns an array of size 3, but the correct order should be `[\"one\", \"two\"\
    , \"three\"]`\n<|/ c |>\n<| c |>\nI agree, your answer works better, but it is\
    \ better to provide an explanation, not just an answer.\n<|/ c |>\n<| a |>\n<code>\n\
    private static String sortString(String aString) {\n    String[] arrStr = aString.split(\"\
    \\\\s\");\n    String[] arrStr1 = new String[arrStr.length];\n    for(int i=0;i<arrStr.length;i++)\n\
    \        arrStr1[i] = arrStr[i];\n    Arrays.sort(arrStr", "  return numbers.split.sort_by\
    \ {|x| x.to_i}.join(\" \")\nend\n</code>\n<|/ a tags=ruby,sorting,arrays,string\
    \ |>\n<| a |>\nHere is a solution in Ruby, using Enumerable#sort_by:\n<code>",
  "  numbers = numbers.split(/\\s+/)\n  numbers.each do |n|\n    n.to_i.times do |i|\n\
    \      numbers[i] <=> n\n    end\n  end\n  numbers.join(' ')\nend\n</code>\nI\
    \ hope that helps!\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nThis is better than\
    \ my answer, but I'm wondering if there's a way to get the sorting to be done\
    \ without using a loop.  My algorithm is O(n) but I'm not sure how to achieve\
    \ it with a single expression or method.  I know it's possible to do this with\
    \ sort_by! but can't figure out how to use that method.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=1 |>\nThis is an adaptation from another answer here (not mine) on another\
    \ question (I don't have enough reputation to leave a comment there).\nThis is\
    \ what I came up with:\n<code>", "  # Initialize empty array to hold sorted numbers\n\
    \  sorted = []", "  if numbers.nil? or numbers.empty?\n    return 'nil'\n  end\n\
    \  a = numbers.split(' ')\n  a.sort! {|a,b| a.to_i < b.to_i }\n  return a.join('\
    \ ')\nend", "  result = numbers.split(' ').sort\n  result.reverse!\n  result\n\
    end", "  array = numbers.split(\" \")\n  array\n  .sort!\n  array.each { |number|\n\
    \    number = number.to_i\n    number.to_s\n  }\n  array.join(' ')\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby,sorting,arrays,string |>\n<| a tags=ruby,sorting,arrays,string\
    \ dscore=0 |>\n<code>", "    sorted = numbers.split(' ')\n    sorted.sort!\n \
    \   return sorted.join(' ')\nend", "    numbers.split(//).sort_by { |s| s.to_i\
    \ }.join ' '\nend\n</code>\n<|/ a dscore=1 tags=sorting,ruby,arrays,ruby-on-rails\
    \ |>\n<| a tags=sorting,ruby,arrays,ruby-on-rails |>\nHere's a solution using\
    \ Ruby's sort_by method\n<code>", "  numbers.gsub!(/\\d/) do |n| nums[n.to_i]\n\
    \  nums = nums.sort!.reverse\n  nums.to_s\nend\n</code>\nTo see how it works,\
    \ I added a couple puts statements into the loops to show how it's working.\n\
    The first puts statements show the values of the variables after each iteration:\n\
    <code>\nnumbers = three one five\nnums = [nil, \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\"]\ni = 0\n</code>\nThe next puts statements show the\
    \ values of the variables after the loop finishes and they are sorted:\n<code>\n\
    numbers = one three five\nnums = [nil, \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    , \"\", \"\", \"\"]\ni = 0\n</code>\n<|/ a |>\n<| c |>\nThis works perfectly.\
    \ I understand how it works but am a beginner so I am having trouble understanding\
    \ exactly how it works. I also have another question for you which I hope you\
    \ can help with. Would you be able to explain the code in the middle part `n.to_i`?\n\
    <|/ c |>\n<| c |>\nI added an explanation into the answer. Basically it's just\
    \ grabbing the number from the string and adding it to the array `nums`. If `n.to_i`\
    \ doesn't work you can replace it with `n`, but using `n` makes it easier to see\
    \ what's going on.\n<|/ c |>\n<| c |>\nI'm glad it helped. I've added a few more\
    \ comments to help with understanding.\n<|/ c |>\n<| c |>\nThanks. I did read\
    \ up on it but didn't fully understand how it worked. I didn't realize that it\
    \ could take any character. Good explanation.\n<|/ c |>\n<| c |>\nYou're welcome.\
    \ You should accept the answer by clicking on the check mark under the vote count.\n\
    <|/ c |>\n<| a tags=arrays,ruby,string dscore=0 |>\nThis should work\n<code>",
  "  numbers.split(\" \").sort!\n  numbers = numbers.join(\" \")\n  return numbers\n\
    end", "  numbers.split(\" \").sort.join(\" \")\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThank you so much for helping me out with this problem. I really appreciate\
    \ it!\n<|/ c |>\n<| c |>\nI see that you've commented on [this question](http://stackoverflow.com/questions/10772057/ruby-string-split-sort-join/10772131#comment13766933_10772131)\
    \ regarding your solution. Is this still the best solution? If so then I'll give\
    \ it a +1. I thought of this as a possibility but couldn't figure it out how to\
    \ use `sort` with arrays of strings and numbers.\n<|/ c |>\n<| a dscore=1 |>\n\
    Another approach: convert each string into a number and sort them.\n<code>", " \
    \   sorted_numbers = numbers.split(' ')\n    sorted_numbers.sort!\n    return\
    \ sorted_numbers.join(' ')\nend\n</cell>\n<code language=julia-1.5>", "  return\
    \ numbers.gsub(/[aeiou](?!\\d)/, '').split(\" \").sort.join(\" \")\nend", "  numbers\
    \ = numbers.split\n  numbers.map! { |number| number.to_i }\n  numbers.sort_by!(&:to_s)\n\
    \  numbers.join(' ')\nend", "  # Your code here\nend", "  # Your code goes here!\n\
    end", "  # Split out our numbers as an array\n  numbers_array = numbers.split(/\\\
    D/)\n  # Sort our numbers\n  numbers_array.sort!\n  # Put them back together as\
    \ a string\n  numbers = numbers.join(' ')\nend", "  numbers.split(\" \").sort.join(\"\
    \ \")\nend", "  numbers.split.map! do |number|\n    number.to_i\n  end\n  numbers.map\
    \ {|n| n.to_s}.sort.join\nend", "  numbers.split.sort_by { |num| num =~ /^(\\\
    d)/ ? $1.to_i : num.downcase }.join(\" \")\nend", "  sorted_numbers = \"\"\n \
    \ sorted_numbers = sorted_numbers.concat(numbers.split(\" \"))\n  sorted_numbers.sort!\n\
    \  return sorted_numbers.join(\" \")\nend", "  numbers = numbers.split(' ')\n\
    \  numbers = numbers.map {|num| num.to_i}\n  numbers.sort!\n  return numbers.join('\
    \ ')\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\n`sort_numbers('six\
    \ seven one four six')` returns `\"one four six seven six\"`, because `\"four\"\
    \ < \"seven\"`. What you really should do is sort the array of strings, and then\
    \ join the sorted array of strings with spaces. That would give `\"one four six\
    \ seven six\"` as the correct answer.\n<|/ c |>\n<| c |>\nI did consider that,\
    \ but OP wants the input to be sorted in lexicographical order. I didn't want\
    \ to write my own custom sort function, so I just used what Ruby already has (which\
    \ was already written, for what I was doing).\n<|/ c |>\n<| c |>\nI don't see\
    \ why lexicographical order matters here - `sort_numbers` will work just as well\
    \ with `'one five three two'` or `'two three one four'` or `'one two three four'`.\
    \ That's how `sort_by` works, in all cases. `sort_by` isn't designed to sort arbitrary\
    \ data, just things that implement `Comparable`. It's a little bit like saying\
    \ \"sort by alphabet letters first, then numbers\", just with a more general use\
    \ case.\n<|/ c |>\n<| c |>\n`sort_by` works on `Enumerable` objects, not strings.\
    \ The point is that `sort_numbers` works just as well with `'one two three'` or\
    \ `'one two three'` as `sort_by`.\n<|/ c |>\n<| c |>\nThe OP asked \"to return\
    \ an array of strings\" and I provided a solution that does exactly that. The\
    \ OP also asked for \"to return the input unchanged\", which I do, and I provided\
    \ that solution as well. `sort_by` works just as well on strings. I didn't want\
    \ to suggest to write my own `sort_numbers` method when Ruby already has one that\
    \ works, just like I didn't want to suggest to write my own `sort_by` method when\
    \ Ruby already has one that works.\n<|/ c |>\n<| a dscore=0 tags=ruby,arrays,sorting\
    \ |>\nHow about:\n<code>", "  return numbers.split(' ').sort_by(&:to_i).join('\
    \ ')\nend", "  numbers = numbers.split(' ')\n  numbers.map!{|s| s.to_i}\n  numbers.sort!",
  "  numbers = numbers.split(' ')", "  numbers.split.map(&:to_i).sort.join(\" \")\n\
    end", "  if numbers.is_a?(String) && numbers.size == 3\n    numbers = numbers.split.sort\n\
    \    return numbers.join(' ')\n  end\nend", "  return numbers.split(' ').reverse.sort.join('\
    \ ')\nend", "  return numbers[0...numbers.index('nine')].join(' ') + 'nine'\n\
    end\n</code>\nThe sort_numbers function is now available in the standard library,\
    \ and can be used from other modules like this:\n<code>", "  numbers.split(' ').sort.join('\
    \ ')\nend", "  numbers = numbers.split(' ') \n  numbers.map! do |num|\n    num\
    \ = num.strip.downcase \n    num = num[0].to_i.zero? ? 'zero' : num\n    num =\
    \ num[1].to_i.zero? ? 'nine' : num\n    num = num[0].to_i.zero? ? 'one' : num\n\
    \    num = num[0].to_i.zero? ? 'two' : num\n    num = num[0].to_i.zero? ? 'three'\
    \ : num\n    num = num[0].to_i.zero? ? 'four' : num\n    num = num[0].to_i.zero?\
    \ ? 'five' : num\n    num = num[0].to_i.zero? ? 'six' : num\n    num = num[0].to_i.zero?\
    \ ? 'seven' : num\n    num = num[0].to_i.zero? ? 'eight' : num\n    num = num[0].to_i.zero?\
    \ ? 'nine' : num\n    num\n  end\n  numbers.join\nend", "  # Split the string\
    \ on spaces.\n  numbers = numbers.split\n  # Set up an array to hold the new sorted\
    \ numbers.\n  new_numbers = []\n  \n  # Loop through the numbers array and add\
    \ them to the new numbers array.\n  numbers.each do |number|\n    # Add the number\
    \ to the new numbers array if it is less than the number before it.\n    new_numbers.push(number.to_i)\
    \ if new_numbers.include?(number) && number < new_numbers[new_numbers.length -\
    \ 1]\n    # Add the number to the new numbers array if it is greater than the\
    \ number before it.\n    new_numbers.push(number) if new_numbers.include?(number)\
    \ && number > new_numbers[new_numbers.length - 1]\n  end\n  \n  # Return a space-delimited\
    \ string of numbers from the new numbers array.\n  new_numbers.join(' ')\nend",
  "  arr = numbers.split(' ')\n  arr.sort! { |a, b| a.to_i <=> b.to_i }\n  arr.join('\
    \ ')\nend", "  numbers.gsub!(/[^a-z]/, '') #Remove anything not a lowercase a-z\n\
    \  numbers.gsub!(/[^0-9]/, '') #Remove anything not a number 0-9\n  numbers.gsub!(/[^0-9]/,\
    \ '') #Remove anything not a number 0-9\n  numbers.gsub!(/[^0-9]/, '') #Remove\
    \ anything not a number 0-9\n  numbers.gsub!(/[^a-z]/, '') #Remove anything not\
    \ a lowercase a-z\n  numbers.gsub!(/[^a-z]/, '') #Remove anything not a lowercase\
    \ a-z\n  numbers.gsub!(/[^a-z]/, '') #Remove anything not a lowercase a-z\n  numbers.gsub!(/[^0-9]/,\
    \ '') #Remove anything not a number 0-9\n  numbers.gsub!(/[^0-9]/, '') #Remove\
    \ anything not a number 0-9\n  numbers.gsub!(/[^0-9]/, '') #Remove anything not\
    \ a number 0-9\n  numbers.gsub!(/[^0-9]/, '') #Remove anything not a number 0-9\n\
    \  numbers.gsub!(/[^a-z]/, '') #Remove anything not a lowercase a-z\n  numbers.gsub!(/[^a-z]/,\
    \ '') #Remove anything not a lowercase a-z\n  numbers.gsub!(/[^a-z]/, '') #Remove\
    \ anything not a lowercase a-z\n  numbers.gsub!(/[^0-9]/, '') #Remove anything\
    \ not a number 0-9\n  numbers.gsub!(/[^0-9]/, '') #Remove anything not a number\
    \ 0-9\n  numbers.gsub!(/[^0-9]/, '') #Remove anything not a number 0-9\n  numbers.gsub!(/[^0-9]/,\
    \ '') #Remove anything not a number 0-9\n  numbers.gsub!(/[^a-z]/, '') #Remove\
    \ anything not a lowercase a-z\n  numbers.gsub!(/[^a-z]/, '') #Remove anything\
    \ not a lowercase a-z\n  numbers.gsub!(/[^a-z]/, '') #Remove anything not a lowercase\
    \ a-z\n  numbers.gsub!(/[^0-9]/, '') #Remove anything not a number 0-9\n  numbers.gsub!(/[^0-9]/,\
    \ '') #Remove anything not a number 0-9\n  numbers.gsub!(/[^0-9]/, '') #Remove\
    \ anything not a number 0-9\n  numbers.gsub!(/[^0-9]/, '') #Remove anything not\
    \ a number 0-9\n  numbers.gsub!(/[^a-z]/, '') #Remove anything not a lowercase\
    \ a-z\n  numbers.gsub!(/[^a-z]/, '') #Remove anything not a lowercase a-z\n  numbers.gsub!(/[^a-z]/,\
    \ '') #Remove anything ", "  numbers.split(\" \").sort.join(\" \")\nend", "  numbers\
    \ = numbers.to_s.split\n  numbers.sort!\n  numbers.join ' '.freeze\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nWhat a clean answer! I'm not a Ruby programmer, so\
    \ I learned a lot from this! Thanks.\n<|/ c |>\n<| c |>\nThis should be the right\
    \ answer. Ruby is the best for such kind of problem as sort numbers.\n<|/ c |>\n\
    <| c |>\nI like it too but i think it is overkill since this can be easily done\
    \ in O(1).\n<|/ c |>\n<| a dscore=5 |>\nHere's a Ruby one-liner (not tested):\n\
    <code>", "  numbers = numbers.split(' ')\n  numbers.sort!\n  return numbers.join('\
    \ ')\nend", "  return numbers.split(' ').sort{|a,b| a.to_i <=> b.to_i}.join(\"\
    \ \")\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't quite work, because it doesn't\
    \ remove any spaces.\n<|/ c |>\n<| c |>\n`sort_numbers(\" one three five\")` gives\
    \ me `\"one three five\"` -- why is that?\n<|/ c |>\n<| c |>\n`sort_numbers(\"\
    one three five\")` gives me `\"one three five\"` too... I thought you were going\
    \ to take that one out :)\n<|/ c |>\n<| c |>\nMy apologies, I didn't actually\
    \ test the code. I've updated it to fix that.\n<|/ c |>\n<| a tags=ruby |>\nIf\
    \ you want the result to be a string, you should remove the spaces\n<code>", " \
    \ numbers.split.sort.join\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWhat a great\
    \ answer!  I love recursion.  Thank you for sharing.\n<|/ c |>\n<| a dscore=2\
    \ tags=ruby,string |>\nOne possibility is this:\n<code>", "  sorted_numbers =\
    \ numbers.split.sort_by { |s| s.to_i }.reverse.join\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis is not the right way to do it.  This is just rewriting an existing\
    \ method.  There may be a better way to write that specific method in the first\
    \ place to begin with.  This should just be an exercise in rewriting existing\
    \ code.\n<|/ c |>\n<| c |>\nIf this is a good answer then you should mark it as\
    \ the answer so other people will know that it solved your problem.\n<|/ c |>\n\
    <| a tags=arrays,ruby,sorting |>\n<code>", "  numbers = numbers.split(/\\W+/)\n\
    \  numbers.sort!\n  numbers.join(' ')\nend\n</code>\n<|/ a tags=ruby dscore=3\
    \ |>\n<| c |>\nThat's a nice solution. But it would be nicer if you could make\
    \ it work for an arbitrary number of numbers, i.e. not just 9.\n<|/ c |>\n<| c\
    \ |>\nI agree it's definitely nicer than the solution I have posted. As mentioned,\
    \ it works for an arbitrary number of numbers. I haven't tested it for large numbers\
    \ (i.e. 10'000 digits long), but in any case you could easily test this by substituting\
    \ 10'000 with 10'000 and see how it behaves ;)\n<|/ c |>\n<| c |>\nThat works,\
    \ but you have to know that there are 3 possible output strings for each input\
    \ string. If the number of output strings is not fixed, you have to modify the\
    \ code a little. I don't think it's really nicer, but it does work.\n<|/ c |>\n\
    <| c |>\nOk, I see. That's true. One solution would be to have an array where\
    \ you keep track of the last number (i.e. `number_to_sort[0] = 'nine'`) since\
    \ we assume that it will always be the last one in the string and that it's always\
    \ smaller. If that's the case, then the solution by Daniel A. Miller can be modified\
    \ easily to work for an arbitrary number of numbers (see the edit).\n<|/ c |>\n\
    <| c |>\n: You need no modification at all. Just keep the last number in a variable.\
    \ Your solution works just fine, no modification is required. The point is: It\
    \ is a solution that works, no modification is required.\n<|/ c |>\n<| a dscore=2\
    \ |>\nThis may be a little too simple, but here's a solution that uses regular\
    \ expressions to remove any non-number characters, and then splits the resulting\
    \ string on spaces, sorts it, and then joins it to remove any non-numeric characters:\n\
    <code>", "  numbers = numbers.split(' ') \n  numbers.sort!\n  strings.join(' ')\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI love the simplicity of this code!  I thought\
    \ I saw something similar in a book but could not find it anywhere.  Many thanks!\n\
    <|/ c |>\n<| c |>\nThis does not work at all. It sorts numbers with leading zeros\
    \ first. Try it with this input: \"0012 0004 0005 0010\"\n<|/ c |>\n<| c |>\n\
    , The question is ambiguous, and I suspect the numbers to be strings rather than\
    \ integers. I did write an answer that sorts strings numerically, but it's not\
    \ what I'd call \"simple to understand\".\n<|/ c |>\n<| c |>\nI think you just\
    \ missed the part where he says \"Input is a space-delimited string of numberals\
    \ from 'zero' to 'nine'.\"\n<|/ c |>\n<| c |>\nNo, I actually meant that it's\
    \ ambiguous.  He never clarified that he wanted the numbers to sort *numerically*.\n\
    <|/ c |>\n<| a |>\nIf you're working in Ruby you could do:\n<code>", '  numbers
    = numbers.split', "    numbers = numbers.split(\" \").collect{|n| n.to_i}\n  \
    \  numbers.sort_by!{|n| -n }\n    return numbers.join(\" \")\nend\n</code>\nI\
    \ hope this helps you.\n<|/ a |>\n<| c |>\nI'm getting the following error when\
    \ I try to run the code from your answer: \"`test_sort_numbers` test_sort_numbers\
    \ (test.rb:9)\ntest_sort_numbers #1 passed\" What do I do to get it to pass?\n\
    <|/ c |>\n<| c |>\nI assume you mean the comment above?  It's a syntax error.\
    \  Just remove the `end` in the very end of the file\n<|/ c |>\n<| c |>\nI mean\
    \ the comment above my code. Just delete the `end`. Your code has `end` but is\
    \ commented out. Just delete the `end` and your code will run just fine.\n<|/\
    \ c |>\n<| c |>\n: I apologize.  I didn't know that I had to delete the `end`\
    \ to make it work.  I figured that I'd be able to just remove the `end` from `def\
    \ test_sort_numbers` but this doesn't work.  I guess that was my fault.  Thank\
    \ you for your help on this issue.\n<|/ c |>\n<| c |>\n: I didn't know that I\
    \ had to delete the `end` to make it work. I figured that I'd be able to just\
    \ remove the `end` from `def test_sort_numbers` but this doesn't work. I guess\
    \ that was my fault. Thank you for your help on this issue.\n<|/ c |>\n<| a |>\n\
    <code>", "  if numbers.empty?\n    numbers.to_s\n  elsif numbers.include?(' ')\n\
    \    numbers.split.sort\n  elsif numbers.include?(',')\n    numbers = numbers.gsub(/[-+,]/,\
    \ '').split(',')\n    numbers.sort\n  else\n    numbers = numbers.split(' ').sort\n\
    \  end\n  numbers.join(' ')\nend", "  numbers = numbers.to_s\n  numbers = numbers.split.to_s\n\
    \  numbers = numbers.sort\n  numbers = numbers.join(' ')\nend", "  numbers_array\
    \ = numbers.split(' ')\n  numbers_array.sort.reverse\n  numbers = numbers_array.join('\
    \ ')\nend\n</code>\n<|/ a dscore=5 |>\n<| a tags=ruby,string |>\nFor Ruby 1.9+\
    \ you can do this:\n<code>", "  # Your code here\n  numbers.split(\" \").sort!.reverse!\n\
    \  numbers\nend", "  numbers.split(\" \").sort!\n  return numbers\nend\n</code>\n\
    <|/ a tags=ruby,function,recursion,ruby-on-rails,algorithm |>\n<| c |>\nThanks\
    \ for the help. But how would I use this to sort a list with more than two elements?\n\
    <|/ c |>\n<| c |>\n- I added an edit to the question to include a solution for\
    \ sorting a list of any length. Hope this helps!\n<|/ c |>\n<| a |>\nAs others\
    \ have mentioned, it's best not to reimplement things that are already written\
    \ (sort being a good example).  Here is a quick and dirty recursive solution.\
    \  It does rely on String#<=> for sorting, which sorts strings in ASCII, so be\
    \ careful.\n<code>", "  numbers.split(\" \").sort{|a,b| a.to_i <=> b.to_i}.join(\"\
    \ \")\nend", '  numbers = numbers.split', "  return numbers.split.sort.join('\
    \ ')\nend", "  words = numbers.split(//)\n  words.map!(&:to_i)\n  words[0] = 0\n\
    \  words[-1] = 9\n  words.sort.join(\" \")\nend", "  array = numbers.split(' ')\n\
    \  array.sort! { |a,b| a.to_i <=> b.to_i }\n  array.join(' ')\nend\n</code>\n\
    Now that you have your sort function, you can easily change your example into\
    \ what you are actually working with:\n<code>", "  numbers.split(/\\s/).sort.join(\"\
    \ \")\nend", "  # Your code here\n  numbers.split.sort.join(' ')\nend", "  if\
    \ numbers.blank?\n    ''\n  elsif numbers.include?(' ')\n    numbers = numbers.split\n\
    \    numbers.sort!\n    numbers.join(' ')\n  else\n    numbers = numbers.gsub(/[\
    \ -]+/, '').gsub(/[0-9]/, '').gsub(/[-]+/, '').gsub(/-+/, '').split(//)\n    numbers.sort!\n\
    \    numbers.join('')\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n\
    <| a dscore=0 |>\nUsing a regular expression:\n<code>", "  numbers.to_s.split('\
    \ ').sort{|a, b| a.to_i <=> b.to_i}.join(' ')\nend", "  numbers.split(\" \").sort!\n\
    \  return numbers.join(\" \")\nend\n</code>\n<|/ a |>\n<| c |>\nFor my purposes,\
    \ your `sort_numbers` function works fine.  Thanks.\n<|/ c |>\n<| c |>\nAwesome,\
    \ glad I could help out!\n<|/ c |>\n<| c |>\n`sort_numbers` is not correct as\
    \ it doesn't take an input string and doesn't sort the numbers. `sort_numbers(\"\
    1 10 9 2 7 3 4 6 5\")` returns `\"1 2 3 4 5 6 7 10 9\"`.\n<|/ c |>\n<| c |>\n\
    : thanks, I'll fix that and include your comment.\n<|/ c |>\n<| c |>\nWhat does\
    \ `!` mean in `sort!`?\n<|/ c |>\n<| a tags=sorting,ruby |>\nI would avoid using\
    \ to_i. The reason is that to_i will interpret the string as numbers and return\
    \ nil if no number is found. For example, \"abc\" will parse as 1, and nil.\n\
    Here is a method that will work with strings and integers. It will first convert\
    \ the string to a string array and then sort that, and then convert the strings\
    \ to the original format. The final method will accept any number of arguments\
    \ and pass them to the sort_by_string method.\n<code>", "  numbers.split(\" \"\
    ).sort.join(\" \")\nend", "  list = numbers.split(' ') #creates an array from\
    \ the string\n  list.sort!\n  list.join(' ') #puts the string back together again\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks so much for the help. This is\
    \ exactly what I needed.\n<|/ c |>\n<| a tags=arrays,ruby,sorting dscore=0 |>\n\
    <code>\narray = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight',\
    \ 'nine', 'zero']\narray.sort { |a, b| a.to_i <=> b.to_i }", "  numbers.split.sort_by\
    \ { |s| s.to_i }\nend", "  numbers.split(' ').sort.join(' ')\nend", "  return\
    \ numbers_sorted_by_number(numbers.split)\nend\n</pre>\n</div>", "  numbers =\
    \ numbers.to_s.split\n  numbers.sort!\n  numbers.join(\" \")\nend\n</code>\n<|/\
    \ a tags=ruby,string dscore=5 |>\n<| c |>\nYes this was a great solution. I really\
    \ liked how you included a method call in the conditional statement instead of\
    \ the actual `sort` method.\n<|/ c |>\n<| c |>\nAwesome! I knew this problem was\
    \ so trivial to solve but I've spent an hour on this and couldn't figure it out.\
    \ Thanks!\n<|/ c |>\n<| c |>\nThis is fantastic. Thank you.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\nThis may work:\n<code>", "  numbers.split(\" \").sort.join(\" \")\nend",
  "  numbers.split(\" \").sort.join(\" \")\nend", "  numbers.split(\" \").sort.join(\"\
    \ \")\nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\nMy solution uses regular expressions:\n\
    <code>", "  numbers = numbers.split(' ')\n  numbers.map! do |n|\n    n.to_i\n\
    \  end\n  numbers.sort do |a, b|\n    a <=> b\n  end\n  numbers.join(' ')\nend\n\
    </code>\n<|/ a |>\n<| a tags=ruby,sorting,ruby-on-rails |>\n<code>\n  numbers.split(\"\
    \ \").sort_by{|i| i.to_i}.join(\" \")\n</code>\nThis sorts by integers and then\
    \ joins them back together again.\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't sort\
    \ the numbers in the desired order.\n<|/ c |>\n<| c |>\nWhat if the array is not\
    \ of strings but of numbers?\n<|/ c |>\n<| c |>\nHad a similar issue with the\
    \ array of [1,2,4,3,7] and expected output as [1,3,5,2,7] but instead got [1,2,3,4,7].\n\
    <|/ c |>\n<| c |>\nHad a similar issue with the array of [1,3,4,2,7] and expected\
    \ output as [1,3,2,4,7] but instead got [1,3,2,4,7]. Using sort_by { |i| i.to_i\
    \ } as above worked for me\n<|/ c |>\n<| a dscore=5 tags=ruby,sorting,ruby-on-rails\
    \ |>\n<code>", "  numbers.to_s.split(\" \").sort.join\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThank you! This should be the accepted answer!\n<|/ c |>\n<| c\
    \ |>\nGreat answer! Thank you!\n<|/ c |>\n<| c |>\nThis code is not only inefficient\
    \ but also returns nil instead of an empty string. Fixing these two issues gives\
    \ us a more correct answer. Thanks!\n<|/ c |>\n<| c |>\nThis should really be\
    \ the accepted answer. The accepted answer returns nil for an empty string. Thanks!\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer! Thank you\n<|/ c |>\n<|\
    \ a tags=ruby |>\nYou can use a regexp to pull out the numbers and sort them that\
    \ way:\n<code>\n\"One Two Three Four Five Six Seven Eight Nine\".gsub(/\\d+/).sort.join(\"\
    ,\")", "  numbers = numbers.split(' ')\n  numbers.sort!\n  numbers = numbers.join('\
    \ ')\n  return numbers\nend", "    numbers.to_s.split(//).sort.join(\" \")\nend\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=ruby,sorting,arrays dscore=2 |>\n<code>",
  "  numbers.split.sort.join\nend", "  numbers.split(' ').reverse.sort_by { |n| n.to_i\
    \ }.reverse.join(' ')\nend\n</code>\n<|/ a dscore=5 tags=ruby |>\n<| c |>\nI like\
    \ this one, very short and concise.\n<|/ c |>\n<| c |>\nHow about \"five one two\"\
    ? :)\n<|/ c |>\n<| c |>\n: Good point. I added a version that doesn't have that\
    \ problem.\n<|/ c |>\n<| c |>\nThank you for your suggestion. I added it into\
    \ my answer.\n<|/ c |>\n<| c |>\nThe `reverse.sort_by` is unnecessary; `sort_by`\
    \ will return an enumerable that starts with largest numbers first.\n<|/ c |>\n\
    <| a |>\nIn addition to all the other great answers, here's an alternate solution\
    \ that is more functional and doesn't use reverse.\n<code>", "  numbers.split.sort_by\
    \ { |word| word.to_i }.join\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    This is an elegant solution!\n<|/ c |>\n<| a |>\nFor this case, you can use String#split.\n\
    <code>\na = \"one two three four\".split\na.sort.join(\" \")\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=3 |>\n<| a dscore=2 |>\nUsing #split and #join \n<code>\n a=\"one two\
    \ three four\"\n a.split.join(\" \")\n #=> \"one two three four\"\n a=\"one two\
    \ three four\".split\n a.sort.join(\" \")\n #=> \"one two three four\"\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| a |>\nHere's another way to do it.\n<code>", " \
    \ numbers = numbers.split\n  numbers.sort\n  result = numbers.join(' ')\n  result\n\
    end\n</cell>\n<cell>", "    numbers = numbers.split(\" \")\n    numbers.sort!\
    \ { |a,b| a.to_i <=> b.to_i }\n    numbers.join(\" \")\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nAwesome thanks. I'll do some more research on what .map means and\
    \ why its used. I just want to understand what exactly it is doing\n<|/ c |>\n\
    <| c |>\n`.map` returns a new array populated with the return value of whatever\
    \ block you pass to it. In this case, the block returns the value of `self.class`\
    \ for the class that the object belongs to, and `self.id` for the instance ID.\
    \ As I mentioned in my answer, the `each` method will execute a block on each\
    \ object in the collection, and that block receives a reference to the object\
    \ as its argument, so the block can use that.\n<|/ c |>\n<| a dscore=0 tags=ruby\
    \ |>\nYou can sort your numbers by using a sort algorithm called selection sort.\
    \ Here is how it works:\n1. Pick a random element to swap\n2. Swap elements if\
    \ they are out of order\n3. Repeat until there is only one element left\n<code>\n\
    numbers = %w(one two three four five six seven eight nine)", "  numbers = numbers.split(\"\
    \ \")\n  numbers.each do |number|\n    number = number.to_i\n    numbers.delete(number)\n\
    \  end\n  numbers.sort!\n  numbers.join(\" \")\nend", "  # remove all spaces from\
    \ the string, making sure there are no double spaces\n  numbers.gsub!(/\\s+/,\
    \ '')\n  # split the string by space\n  numbers_array = (numbers.split(' ')).map\
    \ do |number|\n    number.to_i\n  end\n  # sort from smallest to largest\n  numbers_array.sort!.reverse\n\
    \  # join string together with spaces\n  number_string = numbers_array.join('\
    \ ')\n  number_string\nend", "  numbers.split(' ').sort.join(' ')\nend", "  #\
    \ Your code here\n  return numbers.split(' ').reverse.join(' ')\nend", "    numbers.split(\"\
    \ \").map {|number| number.to_i}.sort\n    \nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ dscore=5 |>\n<| a dscore=5 tags=ruby,arrays,sorting |>\nUsing Ruby 2.0+ you\
    \ can use the sort_by method:\n<code>\n[1, 2, 3, 1].sort_by { |x| x }", "  numbers.split(\"\
    \ \").sort!\n  numbers.split(\" \").join(\" \")\nend", "  numbers.split(\" \"\
    ).sort.join(\" \")\nend\n</code>\nIt doesn't handle the case where there are more\
    \ than 9 numbers or if there are not enough numbers, but I'll leave that as an\
    \ exercise for you.\n<|/ a dscore=4 |>\n<| a tags=string,ruby dscore=4 |>\nAs\
    \ a variant of nathanvda's answer, but without requiring an additional method\
    \ (no \"sorted\" method), I use the following method:\n<code>", "  numbers.split.sort.join\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a dscore=1 tags=ruby |>\n<code>\n def sort_numbers(numbers)\n\
    \   numbers = numbers.split.map(&:to_i).sort\n   numbers.join\n end\n</code>\n\
    <|/ a |>\n<| a |>\nI love the answer by Nick White (thanks). Here is a variation\
    \ that doesn't require a temporary array and allows for leading zeros:\n<code>",
  "  numbers.split(' ').sort.join(\" \")\nend", "  # TODO: implement a Ruby solution\
    \ here\nend\n</code>\n<|/ a dscore=3 |>\n<| a |>\n<code>", "  numbers.split(\"\
    \ \").sort.join(\" \")\nend", "  numbers.split(\" \").sort.join(\" \")\nend",
  "  numbers.gsub!(/\\s|\\n/, '')\n  numbers.tr!(' ', ' ')\n  numbers.gsub!(/([a-z])/)\
    \ { $1.upcase }\n  numbers.sort!\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    `tr!` is a great idea, thanks for sharing! I'd recommend removing the `gsub!`\
    \ call as it's unnecessary. Also, it might be worth mentioning that your last\
    \ call should probably be `to_s.downcase` as this is what `sort_numbers` expects\
    \ as an argument and `sort_numbers` does not expect all words to be converted\
    \ to lowercase, but rather those which are alphanumeric.\n<|/ c |>\n<| c |>\n\
    Yes, I definitely agree with you, it's unnecessary and should be removed.\n<|/\
    \ c |>\n<| a tags=ruby |>\n<code>\n\"one two three four\".split().sort { |a, b|\
    \ a.to_i - b.to_i }.join(\" \")\n=> \"four one two three\"\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThanks for that - I like the idea. I'll let you know how I get\
    \ on.\n<|/ c |>\n<| c |>\nThe solution is simple and elegant, but I'd like to\
    \ mention that you might want to include a `.downcase` in the split method, in\
    \ order to remove leading whitespace from numbers (i.e. `\"one  two three four\"\
    .split().sort { |a, b| a.to_i - b.to_i }.join(\" \").downcase` => \"four one two\
    \ three\").\n<|/ c |>\n<| c |>\nThanks for the suggestion.\n<|/ c |>\n<| a dscore=2\
    \ tags=ruby |>\nIf all the strings are of form \"one two three four\" then you\
    \ can use scan:\n<code>\n\"one two three four\".scan(/\\d+/).sort.join(' ')\n\
    => \"one two three four\"\n</code>\nOr simply with join and split:\n<code>\n\"\
    one two three four\".split.sort { |a, b| a.to_i - b.to_i }.join(' ')\n=> \"one\
    \ two three four\"\n</code>\n<|/ a |>\n<| c |>\nAh I like this one too. Thanks\
    \ for sharing your input!\n<|/ c |>\n<| a dscore=1 |>\nI recommend doing two gsub's,\
    \ one to convert spaces to newlines, and one to convert newlines to spaces.  I\
    \ recommend putting them on separate lines for readability, and it also makes\
    \ the code more read", "  numbers = numbers.to_s\n  numbers.gsub!(/\\D/, \"\"\
    )\n  numbers.split!\n  numbers.sort!\n  numbers.join(\", \")\nend", "  numbers\
    \ = numbers.to_s\n  sort_numbers_re = /#{numbers.scan(/\\d+/).map {|x| x.to_i}.sort}/\
    \ \n  numbers.gsub! sort_numbers_re, \"\"\nend\n</code>\n<|/ a tags=ruby dscore=2\
    \ |>\n<| c |>\nI appreciate your answer but I'm looking for a more general solution\
    \ that doesn't require that all numbers are in order, just that they are grouped\
    \ correctly.\n<|/ c |>\n<| c |>\n: Do you mean \"strings\" instead of \"numbers\"\
    ? And are you guaranteed that you can have non-integer parts of your input string?\n\
    <|/ c |>\n<| c |>\nYes, non-integer parts can be in input strings. Yes, I do mean\
    \ strings.\n<|/ c |>\n<| a |>\nI suggest a more general solution that uses regular\
    \ expressions to extract groups of consecutive digits, and then sorts each group.\n\
    <code>", "  numbers_array = numbers.split(' ')\n  numbers_array.map!(&:to_i)\n\
    \  numbers_array.sort!\n  numbers_array.join(' ')\nend", "  return numbers.to_s.split(/\
    \ /).sort_by(&:to_i).join(\" \")\nend", "  numbers.split(\" \").sort!\n  strings.join(\"\
    \ \")\nend", "    numbers.split\n    numbers.split.sort\nend", "  numbers = numbers.split.join(\"\
    \ \")\n  numbers.strip!\n  numbers.gsub!(/[^a-z]/,\"\")\n  numbers.squeeze!\n\
    \  numbers.split.sort_by!{|x| x.to_i}.join(\" \")\nend", "  numbers = numbers.split(\"\
    \ \").collect{|s| s.to_i}\n  numbers.sort_by{|i| i}.reverse.join(' ')\nend", " \
    \ sorted_numbers = numbers.split(' ')\n  sorted_numbers.sort! {|a, b| a.to_i <=>\
    \ b.to_i}\n  sorted_numbers.join(' ')\nend\n</code>\nNow we can try our function\
    \ in irb:\n<code>\nrequire 'test_helper'", "    # Your code here\n    return numbers\n\
    end", "  numbers = numbers.split(' ')\n  numbers.sort!\n  return numbers.join('\
    \ ')\nend", "  # Your code here\n  return numbers\nend\n</code>\nSolution 2\n\
    Here is a more elegant solution to sort a String of numbers. We can pass an optional\
    \ argument to sort!\n<code>", "  numbers = numbers.split(\" \")\n  sorted_numbers\
    \ = numbers.sort\n  puts \"Sorted numbers: #{sorted_numbers}\"\n  return\nend",
  "    numbers = numbers.split(' ')\n    numbers.sort!\n    strings.join(' ').gsub(/#{numbers[0]}/,\
    \ '').gsub(/#{numbers[1]}/, '').gsub(/#{numbers[2]}/, '')\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a |>\nAnother one liner solution:\n<code>", "  numbers.split('\
    \ ').sort.join(' ')\nend", "  numbers.gsub!('zero', '0')\n  numbers.gsub!('one',\
    \ '1')\n  numbers.gsub!('two', '2')\n  numbers.gsub!('three', '3')\n  numbers.gsub!('four',\
    \ '4')\n  numbers.gsub!('five', '5')\n  numbers.gsub!('six', '6')\n  numbers.gsub!('seven',\
    \ '7')\n  numbers.gsub!('eight', '8')\n  numbers.gsub!('nine', '9')\n  numbers.gsub!('\
    \ ', '')\n  numbers.sort!\nend\n</code>\n<|/ a tags=ruby-on-rails,sorting,ruby\
    \ dscore=1 |>\n<| a dscore=1 |>\n<code>", "  numbers.to_s.split(' ').sort.join('\
    \ ')\nend", "    numbers.split(/ /).sort.join(\" \")\nend", "  numbers = numbers.downcase.split(//).map\
    \ { |num| num.to_i }\n  numbers.sort!\n  numbers.to_sentence\nend", "  numbers\
    \ = numbers.split\n  numbers.sort.reverse!\n  numbers = numbers.join(' ')\n  numbers\n\
    end", "    numbers.split(\" \").sort.join(\" \")\nend", "  numbers = numbers.downcase\n\
    \  numbers.gsub!(/\\s+/, '')\n  numbers = numbers.split.sort\n  numbers.join('\
    \ ')\nend", "  numbers.split.sort.join(' ')\nend\n</code>\n<|/ a tags=string,ruby,arrays,sorting\
    \ dscore=1 |>\n<| c |>\nI like it, but I believe `sort_numbers('one three four')`\
    \ will return `\"one three four\"`, not `\"one four three\"`\n<|/ c |>\n<| c |>\n\
    Good point. I edited the answer to correct this issue, thanks.\n<|/ c |>\n<| a\
    \ dscore=1 tags=string,ruby,arrays,sorting |>\nThis is a variation on the theme\
    \ of Kris Cousins' answer, which uses sort_by to sort the numbers in descending\
    \ order, and reverse:\n<code>", "  numbers = numbers.strip.split(' ')\n  numbers.reverse.compact.each\
    \ do |n|\n    n.gsub(/[0-9]/,\"\").to_i unless ['one','two','three','four','five','six','seven','eight','nine','zero'].include?(n)\n\
    \  end\n  numbers.join(' ')\nend", "  numbers.split(\" \").sort.join(\" \")\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis looks elegant to me.  I\
    \ like it, but I don't think it's any better than `numbers.split.sort.join(\"\
    \ \")`, because it just sorts the array and joins it back together.  To do what\
    \ it appears you were asking, you'd have to reconstruct the original array, which\
    \ doesn't require the additional complexity that `sort` requires.\n<|/ c |>\n\
    <| c |>\nThis doesn't return the desired string in the question. It just returns\
    \ the numbers in a random order.\n<|/ c |>\n<| c |>\nI don't see a problem with\
    \ sorting it first and then joining, but you might be right that sorting the numbers\
    \ is more efficient than re-building the array\n<|/ c |>\n<| c |>\nI thought sorting\
    \ is more expensive than rebuilding the array... or are you saying sorting is\
    \ unnecessary in this case?\n<|/ c |>\n<| c |>\nIt *could* be faster, but I don't\
    \ know for sure.\n<|/ c |>\n<| a |>\nYou could use a regex and sort the matches:\n\
    <code>\nnums = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven',\
    \ 'eight', 'nine']\nnum = nums.sort { |a, b| nums.index(a) <=> nums.index(b) }\n\
    p num", "  numbers.split(\" \").sort_by(&:to_i).map(&:to_s).join(\" \")\nend\n\
    </code>\n<|/ a dscore=0 tags=ruby |>\n<| a |>\n<code>", "  numbers.split(' ')\n\
    \  numbers.split(' ').sort\n  numbers.split(' ').join(' ')\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThanks. I don't understand how I would call `sort_numbers`\
    \ with a `numbers` string. How would I call sort_numbers with the `numbers` string\
    \ in the code I provided?\n<|/ c |>\n<| c |>\nYou would call it like any other\
    \ method.\n<|/ c |>\n<| a tags=ruby,functional-programming,sorting |>\nHere's\
    \ how I might do it:\n<code>", "  numbers = numbers.split(' ') \n  numbers.sort.reverse!\n\
    \  numbers.join(' ')\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThanks for this,\
    \ it helped me solve my sorting problem :)\n<|/ c |>\n<| c |>\nWhy do you reverse\
    \ the order of the array in the second example?\n<|/ c |>\n<| c |>\n`numbers.sort.reverse!`\
    \ modifies the array in place, so that it is in reverse order in the calling context\n\
    <|/ c |>\n<| a dscore=5 |>\nHere is a Ruby method that does not use a regex:\n\
    <code>", "    numbers.split(\" \").sort!.join\nend\n</code>\nThe above is a bit\
    \ verbose, especially for someone who's unfamiliar with Ruby's sort_by method.\
    \ Here's a somewhat shorter and more readable version:\n<code>", "    numbers.split(\"\
    \ \").map{ |n| n.to_i}.sort.join(\" \")\nend\n</code>\n<|/ a |>\n<| a |>\n<code>\n\
    \ def sort_numbers(input)\n   arr = input.split\n   arr.map!{ |x| x.to_i} # convert\
    \ each string to integer\n   arr.sort!\n   arr.join(' ')\n end\n</code>\n<|/ a\
    \ dscore=2 tags=string,ruby,arrays,integer |>\n<| a tags=string,ruby,arrays,integer\
    \ |>\nOne more solution using #scan\n<code>", "  numbers.split(\" \").map { |n|\
    \ n.to_i }.sort.join(\" \")\nend", "    numbers.split.each_with_index do |num,\
    \ index|\n        numbers[index..index+1].sort_by{|x| x.to_i }.join(\" \")\n \
    \   end\nend", "    numbers = numbers.split(\" \")\n    numbers = numbers.map{|x|\
    \ x.to_i}\n    numbers.sort\n    numbers.map{|x| x.to_s}.join(\" \")\nend", " \
    \ return numbers.split.sort.join ' ' \nend", "  numbers.split(\" \").sort!\n \
    \ numbers.join(\" \")\nend", "  numbers.split.map(&:to_i).sort.join(\" \")\nend\n\
    </code>\nNow you can write the following:\n<code>", "  numbers = numbers.strip.split('\
    \ ')\n  numbers_sorted = numbers.collect do |number|\n    zero = one + two + three\
    \ + four + five + six + seven + eight + nine\n    number.to_i.step(9).select {\
    \ |i| i < zero }.join(' ')\n  end.join(' ')\n  numbers_sorted\nend", "  numbers.split(\"\
    \ \").map { |n| n.to_i }\n    .sort { |a,b| a <=> b }\n    .join\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for your quick response! When I try your solution I\
    \ get \"undefined method `split' for nil:NilClass\" on the following line: \"\
    numbers.split(\" \").map { |n| n.to_i }\".\n<|/ c |>\n<| c |>\nApologies, I had\
    \ to add a check to make sure `numbers` existed. I updated my answer.\n<|/ c |>\n\
    <| c |>\nThanks again for the update. Unfortunately this did not fix the problem.\
    \ I am still getting the error \"undefined method `split' for nil:NilClass\" on\
    \ line \"numbers.split(\" \").map { |n| n.to_i }\".\n<|/ c |>\n<| c |>\nApologies,\
    \ had to add a check to make sure `numbers` was defined before trying to call\
    \ `split`. Updated answer.\n<|/ c |>\n<| c |>\nThe updated answer doesn't seem\
    \ to work for me. I get the following error message: \"undefined method `split'\
    \ for nil:NilClass\" on line \"numbers.split(\" \").map { |n| n.to_i }\".\n<|/\
    \ c |>\n<| a dscore=1 |>\nThe way I see it, the most \"Ruby\" way of doing this\
    \ would be like this:\n<code>\nnumbers = [\"one\", \"two\", \"three\"]", "  numbers.split(/\
    \ /).sort\nend", "  sorted_numbers = \"\"\n  numbers = numbers.split(\" \")\n\
    \  numbers.each { |n| sorted_numbers += \"#{n} \" }\n  sorted_numbers\nend", " \
    \ sorted = numbers.split(/\\D/).map {|n| n.to_i}\n  sorted.sort\n  sorted.join\n\
    end", "  numbers.gsub!(/\\D/, '').squeeze!\n  result = numbers.sort.join(\" \"\
    )\n  result.gsub!(/(\\d)\\s+(?=\\1)/, '\\1 \\2')\n  result.rstrip!\n  result\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a |>\nThis one works with any number of digits:\n\
    <code>", "  numbers.split.sort.join\nend", '    numbers = numbers.split', "  numbers.split.sort.join\
    \ ' '\nend", "  return numbers.split(' ').sort { |a, b| a.to_i <=> b.to_i }.join('\
    \ ')\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nIt should be `a.to_i <=> b.to_i`\
    \ not `a.to_i <=> b.to_s` or `b.to_i <=> a.to_i`\n<|/ c |>\n<| c |>\nNo, they\
    \ should be `a.to_i <=> b.to_i`. It's a lexicographical sort, so `\"nine\" < \"\
    three\"` because `\"nine\" < \"one\"` because `\"nine\" < \"five\"`. `\"eight\"\
    \ < \"five\"` because `\"eight\" < \"one\"` because `\"eight\" < \"two\"`\n<|/\
    \ c |>\n<| c |>\n: I misunderstood your code. I thought you were sorting strings\
    \ that contained numbers, which is what you said is intended to do. In fact, that\
    \ code is sorting strings that _contain_ numbers. My mistake.\n<|/ c |>\n<| a\
    \ tags=ruby |>\nI like using regular expressions to split and sort strings.\n\
    <code>\nstring = 'zero one two three four five six seven eight nine'\nstring.split(/\\\
    s+/).sort_by(&:to_i)\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby dscore=3 |>\n\
    You can use Array#sort.\n<code>\n\"zero one two three four five six seven eight\
    \ nine\".split(\" \").sort\n</code>\n<|/ a |>\n<| a tags=ruby |>\nThe other answers\
    \ are all great. Here's another alternative.\n<code>\n string = \"zero one two\
    \ three four five six seven eight nine\"\n string.split(\" \").sort.join(\" \"\
    )\n #=> \"one three four five six seven eight nine zero one\" \n</code>\n<|/ a\
    \ dscore=3 |>\n<| c |>\nI like this one. Very clear what you're doing - and probably\
    \ the most efficient.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n'zero one two three\
    \ four five six seven eight nine'.split(' ').sort.join(' ')\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nYou don't need to use `split` if you use `Enumerable#sort`: `'zero\
    \ one two three ", "    numbers = numbers.split.map {|n| n % 10}.join ' '\n  \
    \  numbers = numbers[0..-2] + numbers[-2..-1]\n    numbers.split.map {|n| n =~\
    \ /^(\\d)/ ? $1.to_i : n}.reject {|n| n.nil?}.sort {|a,b| b <=> a}.join ' '\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis one works, but I changed it a bit, to also\
    \ support any number of digits in the input string\n<|/ c |>\n<| a tags=ruby,regex\
    \ dscore=2 |>\n<code>", "  # Your code here\n  numbers = numbers.split(' ') ",
  "    numbers.split.sort_by!(&:to_i).join\nend\n</code>\n<|/ a dscore=5 |>\n<| c\
    \ |>\nTo sort an array of strings with integers: `a.sort_by!(&:to_i)`\n<|/ c |>\n\
    <| c |>\n`sort_by!` will modify `a`, so this won't work.\n<|/ c |>\n<| c |>\n\
    To sort an array of strings with integers: `a.sort_by!(&:to_i)`\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work if you are sorting an array of strings with integers,\
    \ it throws an exception\n<|/ c |>\n<| c |>\nTo sort an array of strings with\
    \ integers: `a.sort_by!(&:to_i)`\n<|/ c |>\n<| a dscore=5 |>\nUse sort_by with\
    \ &:to_i, and to_i as a lambda argument:\n<code>\nsort_by &:to_i\n</code>\nExample:\
    \ \n<code>\n[\"a\", \"b\"].sort_by &:to_i", "  numbers = numbers.to_s.split(/\
    \ /)\n  numbers.sort!\n  numbers.join(\" \")\nend", "  numbers = numbers.split('\
    \ ')\n  numbers.sort!\n  numbers.join(\" \")\nend", "  numbers = numbers.split()\
    \ unless numbers.is_a?(Array)\n  numbers.sort! { |a,b| a.to_i <=> b.to_i }\n \
    \ numbers.join(\" \")\nend", "  numbers.split.sort!.inject(:+)\n  return numbers\
    \ if numbers.split.empty?\n  numbers.split.join(\" \")\nend\n</pre>\n</td>\n</tr>\n\
    <tr id=\"section-27\">\n<td>\n<pre>\n<span class=\"ruby-comment\"># Input is a\
    \ string.", "  numbers.split(/\\s+/).sort_by {|s| s.to_i }\nend", "  numbers.gsub!(/[^0-9]+/,\
    \ \"\") # remove all non-digit characters and spaces\n  numbers.gsub!(/\\s+/,\
    \ \" \") # convert spaces into single spaces\n  numbers.strip! # remove leading\
    \ and trailing spaces and tabs\n  numbers.split(\" \").sort_by { |number| number.to_i\
    \ } # convert to integers and sort\n  numbers.to_s.strip!\nend\n</code>\n<|/ a\
    \ tags=ruby,arrays |>\n<| c |>\nI like this idea, but you might want to replace\
    \ `if number > 0` with `if number > 0 && number < 9`, otherwise it will still\
    \ sort the negative numbers first. `numbers.split(\" \").sort_by { |number| number.to_i\
    \ }.map { |number| if number > 0 && number < 9 then number else number - 9 end`.\n\
    <|/ c |>\n<| a |>\n<code>", "  sorted_numbers = ''\n  numbers.split(\" \").each\
    \ do |number|\n    number = number.to_i\n    if number > 9\n      sorted_numbers\
    \ += number\n      sorted_numbers += ' '\n    end\n  end\n  sorted_numbers.chomp!\n\
    end\n</code>\n<|/ a dscore=3 tags=ruby,arrays,ruby-on-rails,sorting |>\n<| c |>\n\
    I like the use of the ternary operator.  It really makes it easy to understand\
    \ the `if` statement.  I wasn't aware of that feature of Ruby\n<|/ c |>\n<| a\
    \ |>\nOne liner Ruby code to sort a comma separated string with numbers in it\
    \ as:\n<code>", "  return numbers.gsub(/([a-z])/i) {$1.upcase }\nend", "  numbers\
    \ = numbers.split(' ')\n  numbers.sort!\n  numbers.join(' ')\nend", "  numbers\
    \ = numbers.split.map { |n| n.to_i }\n  numbers.sort!\n  strings.reduce(:<<).join('\
    \ ')\nend\n</code>\nI did want to mention that there are some potential issues\
    \ with the above code:", "  numbers.split(' ')\n  .map { |n| n.to_i }\n  .sort_by(&:to_s)\n\
    \  .map(&:to_s)\n  .join(' ')\nend", "    numbers = numbers.split(' ')\n    numbers\
    \ = numbers.map{|n| n.to_i}\n    numbers.sort!\n    numbers = numbers.map{|n|\
    \ 'zero'.dup if n == 0}\n    numbers << numbers.max+1\n    numbers.map!{|n| n==0\
    \ ? n.to_s.rjust(2, '0') : n.to_s}\n    return numbers.join(' ')\nend", "  return\
    \ \"#{numbers[0..-2]} #{numbers[-1]}\"\nend", "  return numbers.to_s.split(' ').sort.join('\
    \ ')\nend", "  sorted_number = numbers.scan(/\\d+/).map { |s| s.to_i }\n  sorted_number.sort!\n\
    \  sorted_number.map {|i| i.to_s}.join(\" \")\nend", "  numbers.split(\" \").reverse.map(&:to_i).sort.join(\"\
    \ \")\nend", "  numbers.split.each do |num|\n    num = num.downcase\n    num =\
    \ num.gsub(/zero/i, '')\n    num = num.gsub(/one/i, '')\n    num = num.gsub(/two/i,\
    \ '')\n    num = num.gsub(/three/i, '')\n    num = num.gsub(/four/i, '')\n   \
    \ num = num.gsub(/five/i, '')\n    num = num.gsub(/six/i, '')\n    num = num.gsub(/seven/i,\
    \ '')\n    num = num.gsub(/eight/i, '')\n    num = num.gsub(/nine/i, '')\n   \
    \ numbers.gsub! num, num\n  end\n  numbers\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays\
    \ |>\n<| a tags=ruby,arrays |>\nI prefer this way:\n<code>", "  numbers = numbers.split('\
    \ ')\n  numbers.sort!\n  result = numbers.join(' ')\n  return result\nend", " \
    \ numbers.split(' ').sort.join(' ')\nend", "    numbers.split(\" \").sort!\n \
    \   numbers.split(\" \").join(\" \")\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    This solution is a bit more elegant and also allows you to use any number of arguments\
    \ in the array that were not specified in the original question as they are added\
    \ dynamically and they will still be ordered correctly. Also, you can specify\
    \ the number of the array in the original question (by just adding another parameter\
    \ with the number you want to sort.\n<code>", "  numbers = numbers.split(/ /)\n\
    \  numbers.map! { |num| num.to_i }\n  numbers.sort!\n  numbers.join(' ')\nend",
  "  return numbers.split(' ').sort.join(' ')\nend", "  numbers = numbers.split\n\
    \  numbers.sort!\n  numbers.join(\" \")\nend", "  return numbers.split(\" \").sort.join('\
    \ ')\nend", "  numbers.split(' ')\n  numbers.to_i\n  numbers.to_a.sort_by(&:to_i)\n\
    end", "  numbers_sorted = numbers.split(' ') \n  numbers_sorted.map! do |number|\n\
    \    number.to_i\n  end\n  numbers_sorted.sort!\n  numbers_sorted.join(' ')\n\
    end", "    sorted_numbers = ''\n    sorted_numbers = numbers.split(' ') ", " \
    \ sorted = numbers.split().sort\n  sorted.join(\" \")\nend", "  numbers.split().sort\
    \ do |n1, n2|\n    n1 < n2 ? -1 : (n1 > n2 ? 1 : 0)\n  end.join(' ')\nend", " \
    \ numbers = numbers.split.map{|x| x.to_i} #converting input to array of integers\n\
    \  return numbers.sort.join(' ') #joining array with spaces to form string\nend\n\
    </code>\nTo find out what this returns:\n<code>\nsort_numbers('three one five')\n\
    </code>\nTo find out what this returns:\n<code>\nsort_numbers('one three four')\n\
    </code>\n<|/ a |>\n<| a tags=ruby |>\nThe code below sorts numbers from lowest\
    \ to highest in the given string.\n<code>\nnumbers = sort_numbers('one two three\
    \ five eight nine')\n=> [\"one\", \"eight\", \"three\", \"two\", \"five\", \"\
    nine\"]\n</code>\n<code>\nnumbers.each { |n| puts n }\none\neight\nthree\ntwo\n\
    five\nnine\n</code>\n<code>", "    numbers.split.each do |num|\n        num.chars.sort.join\
    \ ''\n    end\nend\n</cell>\n<cell>", "  numbers = numbers.strip\n  numbers.split(/\
    \ /).sort.join ' '\nend", "  numbers = numbers.split\n  sorted_numbers = numbers.sort.reverse!.join\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\nThe other answers are great\
    \ but I think there's something else to keep in mind about the Ruby way. I'd avoid\
    \ using eval if possible for security reasons. \nHere's an alternate solution\
    \ that is very similar to some of the other answers, though not necessarily the\
    \ best:\n<code>", "  number_array = numbers.split.to_a\n  number_array.sort!\n\
    \  return number_array.join(' ')\nend\n</cell>\n<text>\nNow our function sort_numbers\
    \ has been refactored, we must test it on all the possible inputs that we can\
    \ think of!", "  arr = numbers.split.map {|n| n.to_i}\n  arr.sort_by {|n| n}\n\
    \  return arr.join(\" \")\nend", "  numbers.split(\" \").sort\nend\n</code>\n\
    You might have noticed I changed your method call to a more modern style.  I prefer\
    \ using the more Ruby style, but if you prefer the more Haskell style, here are\
    \ a few other changes you can make.", "  numbers.split(' ').sort!\n  numbers\n\
    end", "  numbers.split(/\\s+/).sort_by(&:to_s).join\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=0 |>\n<| a tags=ruby |>\nI suggest you read about Ruby's Enumerable#sort_by\
    \ method.\n<code>", "  sorted_numbers = \"\"\n  numbers.split(\" \").each do |number|\n\
    \    number = \"#{number}\" unless number[0] == '#' and number[-1] == '#'\n  \
    \  sorted_numbers << number\n  end\n  sorted_numbers\nend", "  numbers.split(\"\
    \ \").sort_by { |x| x.to_i }.join\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    This is great and all, but I don't understand how it works. Could you explain\
    \ it to me?\n<|/ c |>\n<| c |>\n`sort_by` is an Enumerable method and will allow\
    \ you to easily sort an array with a block. Have a look at http://www.ruby-doc.org/core-2.1.1/Enumerable.html#method-i-sort_by\n\
    <|/ c |>\n<| c |>\nI still don't understand how this works. `sort_by` returns\
    \ a new array, so it shouldn't be used directly on the numbers array. Is that\
    \ correct? What does `sort_by` return?\n<|/ c |>\n<| c |>\nYes `sort_by` returns\
    \ a new array but also modifies your original array. `sort_by` returns a new array\
    \ because you can sort things like this: `array.sort { |x,y| x > y ? 1 : -1 }`\
    \ which would sort the original array by the values of x if the array was ordered\
    \ from smallest to largest.\n<|/ c |>\n<| c |>\nThis code can be reduced to `numbers.split.sort_by\
    \ {|x| x.to_i}.join(\" \")`\n<|/ c |>\n<| a |>\nTo find the largest number in\
    \ a string you can use split and max.\n<code>", "    # Convert input into a sorted\
    \ array\n    sorted_numbers = numbers.split(' ') \n    sorted_numbers.sort! \n\
    \    # Put it back together\n    sorted_numbers.join(' ')\nend\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\nAwesome answer, this one is easy to understand and easy\
    \ to understand.\n<|/ c |>\n<| c |>\nThis should be the right answer. `sort_numbers('three\
    \ one five')` returns `\"one three five\"` and not `\"one three five\"`\n<|/ c\
    \ |>\n<| c |>\nNice one. Thanks!\n<|/ c |>\n<| c |>\nAwesome! This worked for\
    \ me as well. Also the best explanation on how to achieve this task from Ruby\
    \ docs is very useful.\n<|/ c |>\n<| c |>\nFor those who like functional programming\
    \ style: `sort_numbers = ->(numbers) { numbers.split(' ').sort! }.call`\n<|/ c\
    \ |>\n<| a dscore=5 |>\n<code>", "  numbers.split(' ').sort.join(' ')\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
