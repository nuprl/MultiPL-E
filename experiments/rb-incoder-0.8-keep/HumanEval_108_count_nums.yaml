name: HumanEval_108_count_nums
language: rb
prompt: "# Write a function count_nums which takes an array of integers and returns\n\
  # the number of elements which has a sum of digits > 0.\n# If a number is negative,\
  \ then its first signed digit will be negative:\n# e.g. -123 has signed digits -1,\
  \ 2, and 3.\n# >>> count_nums([]) == 0\n# >>> count_nums([-1, 11, -11]) == 1\n#\
  \ >>> count_nums([1, 1, 2]) == 3\ndef count_nums(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_nums\n\
  \    candidate = method(:count_nums)\n    assert_equal(0, candidate.call([]))\n\
  \    assert_equal(0, candidate.call([-1, -2, 0]))\n    assert_equal(6, candidate.call([1,\
  \ 1, 2, -2, 3, 4, 5]))\n    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))\n\
  \    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))\n    assert_equal(5,\
  \ candidate.call([12, 23, 34, -45, -56, 0]))\n    assert_equal(1, candidate.call([0,\
  \ 1]))\n    assert_equal(1, candidate.call([1]))\n  end\nend\n"
completions: ["  arr.each_with_index do |n, i|\n    # Skip leading negative numbers\n\
    \    return 0 if n < 0\n    return 0 if n == 0", "  return arr.count(arr.select{|n|\
    \ n > 0}.reduce(0, :+))\nend", "    arr.each { |i|\n      num = i\n      if num\
    \ < 0\n        num += 10\n      end\n      if num >= 10\n        digit = num %\
    \ 10\n        sum += digit if digit > 0\n      end\n    }\nend\nputs count_nums([-15,\
    \ -10, -5, -1, 10, 15])", "  if arr.empty?\n    0\n  else\n    digits = (arr %\
    \ (10**10)).abs % 10**10\n    (arr - digits).to_s.split(//).count { |s| s !~ /^-?\\\
    d+$/ }\n  end\nend\n</code>\nThen you can do:\n<code>\narr = [123, -1, -12, -2,\
    \ 5, -3, -4, 2, -7, -6, -5, -7, -9, -10, 11, -6, -4, 1]\ncount_nums(arr)\n=> 4\n\
    </code>\n<|/ a tags=ruby,algorithm,arrays |>\n<| c |>\nI like your idea of splitting\
    \ the array into digits and counting them, which can be done more simply by `arr.to_s.split(//).count\
    \ { |s| s !~ /^-?\\d+$/ }`. The only thing I would add is that I believe that\
    \ the OP expects `count_nums([123, -1, -12, -2, 5, -3, -4, 2, -7, -6, -5, -7,\
    \ -9, -10, 11, -6, -4, 1]) == 4`, but your code returns `3`.\n<|/ c |>\n<| c |>\n\
    thank you for the comment, I updated my answer accordingly. I believe the OP expects\
    \ 4, but they were testing something else, so I did what they intended to do.\n\
    <|/ c |>\n<| c |>\nI've just updated the answer to fix a bug: I had omitted to\
    \ pass the negative numbers to the `count_nums` method. Thank you for pointing\
    \ this out.\n<|/ c |>\n<| a dscore=0 |>\nI thought I'd add an alternative approach\
    \ to my previous answer. Since I wasn't sure the OP wanted the original array\
    \ unchanged or the output modified, here are the two answers:\n<code>", "  arr.each\
    \ do |num|\n    if num > 0 then\n      count = 0\n      num.digits.each do |d|\n\
    \        if d > 0\n          count += 1\n        end\n      end\n    end\n  end\n\
    \  return count\nend", "  arr.size.times do |i|\n    if arr[i]\n      arr = arr\
    \ - i\n      break\n    end\n  end\n  arr\nend\ncount_nums([1,2,3,4,-4,3,-5,1,-8,2,-3,-6,5])\n\
    \  #=> [2, 3, 1]\n  #    ^   ^     ^     ^   ^     ^  ^\n  #    +---+-----+-----+-----+-----+----+\n\
    \  #         |            |\n  #         +            +\n  #\n  #  ^  ^   ^  \
    \   ^     ^   ^     ^  ^\n  #  +--+---+-----+-----+-----+-----+----+\n  #    \
    \  |            |\n  #      +            +\n  #\n  #  ^  ^   ^     ^     ^   ^\
    \     ^  ^\n  #  +--+---+-----+-----+-----+-----+----+\n  #      |           \
    \ |\n  #      +            +\n  #\n  #  ^  ^   ^     ^     ^   ^     ^  ^\n  #\
    \  +--+---+-----+-----+-----+-----+----+\n  #      |            |\n  #      +\
    \            +\n  #\n  #  ^  ^   ^     ^     ^   ^     ^  ^\n  #  +--+---+-----+-----+-----+-----+----+\n\
    \  #      |            |\n  #      +            +\n  #\n  #  ^  ^   ^     ^  \
    \   ^   ^     ^  ^\n  #  +--+---+-----+-----+-----+-----+----+\n  #      |   \
    \         |\n  #      +            +\n  #\n  #  ^  ^   ^     ^     ^   ^     ^\
    \  ^\n  #  +--+---+-----+-----+-----+-----+----+\n  #      |            |\n  #\
    \      +            +\n  #\n  #  ^  ^   ^     ^     ^   ^     ^  ^\n  #  +--+---+-----+-----+-----+-----+----+\n\
    \  #      |            |\n  #      +            +\n  #\n  #  ^  ^   ^     ^  \
    \   ^   ^     ^  ^\n  #  +--+---+-----+-----+-----+-----+----+\n  #      |   \
    \         |\n  #      +            +\n  #\n  #  ^  ^   ^     ^     ^   ^     ^\
    \  ^\n  #  +--+---+-----+-----", "  arr.each do |num|\n    digit_sum = (num.abs\
    \ * 10).to_i\n    if digit_sum > 0\n      digit_sum = digit_sum.abs\n      digit_sum\n\
    \    end\n  end\nend", "  count = 0\n  arr.each do |i|\n    count += 1 if i >\
    \ 0\n  end\n  count\nend", "    # Initialize sum to 0.\n    sum = 0\n    # Loop\
    \ through each number in the array.\n    arr.each do |x|\n        # Add the current\
    \ digit to the sum.\n        sum += x.abs\n    end\n    # Return the number of\
    \ elements in the array whose digits sum to 0.\n    sum == 0\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThank you for posting an answer but this doesn't answer the question.\
    \ The question asks for an answer without using modules like [`Enumerable`](http://ruby-doc.org/core/Enumerable.html).\
    \ This answer uses [`Enumerable`](http://ruby-doc.org/core/Enumerable.html), which\
    \ isn't what the question is asking for.\n<|/ c |>\n<| c |>\nI agree, but this\
    \ is what I was looking for. Just a fun question :-)\n<|/ c |>\n<| c |>\nI misread\
    \ the question as asking for an explanation of what the code is doing. I've updated\
    \ my answer.\n<|/ c |>\n<| c |>\nThis code is not correct. It can return negative\
    \ value if you give [10,-20,30,-50]\n<|/ c |>\n<| c |>\nGood point! I've updated\
    \ the code. I think it now works correctly.\n<|/ c |>\n<| a tags=ruby |>\nI see\
    \ a lot of comments saying you should use the 'count' method, which doesn't answer\
    \ the question correctly.\nThe reason I say that, in part, because I didn't think\
    \ that would be what was asked for.\nThe question asks for a method that can return\
    \ true or false depending on whether an Array of numbers can form a perfectly\
    \ balanced binary tree. For example, if the array were:\n<code>\n[10, 20, 30,\
    \ 40, 50, 60, 70, 80, 90]\n</code>\nThen the method would return true, because\
    \ we can build a perfectly balanced binary tree by making only two elements on\
    \ the left of the root have digits that add up to zero and adding two elements\
    \ on the right of the root have digits that add up to zero.\nA perfect binary\
    \ tree would have the following properties:", "  arr.each do |x|\n    sum = (x.to_s.size\
    \ - 1).abs\n    next if sum == 0 || sum == 1\n    sum += 1 if x > 0\n    return\
    \ sum\n  end\nend", "  return arr.count {|n| n < 0 ? n.to_s.chars.first(1).reverse\
    \ <=> n }\nend", "    arr.each { |n| return n if n.to_s.split('.').last.to_i >=\
    \ 0 }\n    arr.size\nend", "  arr.each do |n|\n    if n < 0\n      n += 10\n \
    \     arr << \"-#{n}\"\n    end\n  end\n  arr.count{ |n| n.to_s.chars.inject(0)\
    \ { |acc, c| acc + c[0, 1] } }\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ tags=ruby |>\nYou can use the code below\n<code>", "  arr.each { |i| return\
    \ i if i.zero? || (i > 0 && i.to_s.split(//).all? { |i| i.nonzero? }).size < 1\
    \ }\n  0\nend", "  arr.each_with_index { |n, i| return i if n.to_s.split('.').map(&:to_i).inject(:+)\
    \ > 0 }\nend", "  arr.each do |number|\n    digit = find_digits(number)[0]\n \
    \   if number > 0 && digit.positive?\n      return\n    end\n  end\n  return 0\n\
    end", "    count = 0\n    arr.each do |number|\n        if number.is_a?(Integer)\
    \ && number > 0\n            count += 1\n        else\n            number < 0\
    \ ? number.first : number.last\n        end\n    end\n    return count\nend",
  "  arr.inject(0) { |s, x| s += (x / 10 % 10).to_i }\n  return arr.select { |x| x.to_i\
    \ }.count { |x| x > 0 }\nend", "  arr.each_index do |i|\n    (arr[i] + arr[i+1]).to_s.each_char.select\
    \ {|c| c >= '0' }.count {|c| c != '-' } \n  end\nend\n</code>\nThen test the above\
    \ function on some sample cases:\n<code>\narr = []", "  if arr.empty?\n    0\n\
    \  else\n    arr.uniq.inject do |sum, num|\n      sign = num < 0 ? -num.abs**i\
    \ : num.abs**i\n      sum += sign.zero? ? 0 : 1 if sign.zero?\n      sum\n   \
    \ end\n  end\nend", "    arr.each do |n|\n        n.to_s.split('').select do |d|\n\
    \            d.to_i > 0 && !d.to_i.zero?\n        end.size\n    end\nend", " \
    \ arr.each do |num|\n    puts \"#{num}\" if num < 0\n    if num > 0\n      puts\
    \ \"#{num}\"\n    end\n  end\nend", "\tarr.each_with_index do |num, idx|\n\t\t\
    if num < 0\n\t\t\tnum *= -1\n\t\t\tsign = -1\n\t\telse\n\t\t\tsign = 1\n\t\tend\n\
    \t\tdigits = []\n\t\tnum.digits.each { |digit| digits << digit.to_i + sign}\n\t\
    \tif digits.sum == 0 then return 0 end\n\tend\n\treturn arr.length\nend", "  return\
    \ arr.count(sum)\nend", "    # Your code here\n    sum = 0\n    for i in arr\n\
    \        sum += i\n    if sum < 0\n        sum *= -1\n    return arr.count(sum)\n\
    end\n</cell>\n<code language=julia-1.3>", "  # Your code here\n  count = 0\n \
    \ arr.each do |e|\n    if e > 0 \n      count = count + 1\n    end\n  end\n  return\
    \ count\nend\ncount_nums([10, -100, 0, 10])\n  #=> 4\ncount_nums([1, 2, 2, -10,\
    \ -2, 1])\n  #=> 4\ncount_nums([-1, -10, -3, -8])\n  #=> 4\ncount_nums([-2, 1,\
    \ 4, 0, -6, 2])\n  #=> 4\ncount_nums([-3, -2, -1]) == 0\n  #=> true\ncount_nums([-3,\
    \ 0, -1, -5])\n  #=> 4\ncount_nums([-1, 2, 3, 4, -5, 1])\n  #=> 5\ncount_nums([6,\
    \ 2, 7, 4, -2, -5, 1])\n  #=> 6\ncount_nums([1, -6, -3, 1, -1, -2, -4, -6])\n\
    \  #=> 6\ncount_nums([-1, -2, 1, 0, 1, -1, 5, -6, -4, 1])\n  #=> 6\ncount_nums([-1,\
    \ -6, -2, -5, -1, -3, 2, -6, -3, -2, -4, -3, 1, -1, 5, 1, -6, 4, 2])\n  #=> 5\n\
    count_nums([-6, -4, -1, 1, -4, -3, -1, -6, -2, 5, -1, -4, -6, 1, 2, 1, -3, -3,\
    \ -3, -1])\n  #=> 1\ncount_nums([-6, -4, -1, 1, -4, -3, -1, -6, -2, 5, -1, -4,\
    \ -6, 1, 2, 1, -3, -3, -3, -1])\n  #=> 1\ncount_nums([])\n  #=> 0\ncount_nums([1,\
    \ 4, 5])\n  #=> 2\ncount_nums([-1, -5, -3])\n  #=> 0\ncount_nums([-1, -2, -3])\n\
    \  #=> 0\ncount_nums([-9, 6, -5, 1, 1])\n  #=> 3\ncount_nums([-9, 6, -5, 1, 1])\n\
    \  #=> 3\ncount_nums([-1, -2, -3])\n  #=> 0\ncount_nums([-1, -2, -3])\n  #=> 0\n\
    count_nums([-1, -2, -3])\n  #=> 0\ncount_nums([-1, -2, -3])\n  #=> 0\ncount_nums([-1,\
    \ -2, -3])\n  #=> 0\ncount_nums([-1, -2, -3])\n  #=> 0\ncount_nums([-1, -2, -3])\n\
    \  #=> 0\ncount_nums([-1, -2, -3])\n  #=> 0\ncount_nums([-1, -2, -3])\n  #=> 0\n\
    count_nums([-1, -2, -3])\n  #=> 0\ncount_nums([-1, -2, -3])\n  #=> 0\ncount_nums([-1,\
    \ -2, -3])\n  #=> 0\ncount_nums([-1, -2, -3])\n  #=> 0", "    arr.each_with_index\
    \ do |e, i|\n        if i < 0 \n            digit = e.abs\n            sign =\
    \ 1 if digit < 0 else 0\n            digit = digit - sign\n        else\n    \
    \        digit = e\n        end\n        arr[i] = digit * 10\n    end\n    arr.each_with_object(0)\
    \ do |e, count|\n        count += 1 if e > 0\n    end\nend\n</cell>\n<cell>\n\
    count_nums([-12, -9, 23, -7, -1, 5, -13, -12])\n</cell>\n<text>\n(4) Write a method\
    \ to calculate the sum of digits of an integer.", "  arr.inject do |sum, el|\n\
    \    el.is_a?(Fixnum) ? sum + el : sum\n  end\nend", "  # initialize count with\
    \ 0.\n  count = 0\n  # Use a loop to go through the array and check each number.\n\
    \  # For each number, add it to the count.\n  arr.each do |number|\n    if number\
    \ < 0\n      number *= -1\n    elsif number.to_s.split(\"\").reduce(:+) > 10\n\
    \      count +=1\n    end\n  end\n  count\nend\nputs count_nums(ARGV.map(&:to_i))\n\
    </code>\n<|/ a tags=ruby,algorithm dscore=1 |>\n<| a tags=ruby,algorithm |>\n\
    This can be done in a single pass over the array in O(n) time:\n<code>", "  arr\n\
    \    .each_with_index do |n, i|\n      n.to_s.chars.map(&:to_i).each_cons(i+1)\
    \ do |digits|\n        next if digits.all?(&:zero?)\n        digits.reduce(:+).nonzero?\
    \ # or .count\n      end.count || 0\n    end\nend", "    arr.each do |n|\n   \
    \     if n < 0\n            digit = n & 0xFFFF\n            n >>= 16\n       \
    \ else\n            digit = n\n        end", "  n = arr.size\n  sums = arr.reduce(:+)\n\
    \  (sums & 1 == 0) ? n : n-1\nend\n</cell>\n<cell>", "  arr.inject(0) do |tot,\
    \ num|\n    sign = num < 0 ? \"-\" : \"\"\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits.each_cons(2).select { |x, y| x > y }.size + 1\n  end + arr.size #\
    \ add size of array\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>",
  "  arr.inject(:+)\n  arr.select { |i| (i > 0 && !i.zero?) }.size\nend", "  arr.compact.inject(0)\
    \ { |sum, num| sum + num if num > 0 }\nend\n</code>\nThe above code uses inject\
    \ to iterate over the array, and adds up the numbers greater than zero.\n<|/ a\
    \ |>\n<| c |>\nThat is a very impressive solution with O(n). Thanks!\n<|/ c |>\n\
    <| a |>\n<code>\narr = [-12, -1, -2, -5]", "  arr.each_with_index do |v, i|\n\
    \    if v < 0\n      v += 10 ** v.abs\n      arr[i] = -v\n    end\n  end\n  arr.count{\
    \ |e| e > 0 }\nend", "    count = 0\n    arr.each_index do |i|\n        arr[i].each\
    \ {|digit| count += 1 if digit > 0}\n    end\n    count\nend", "  arr.each_with_index\
    \ do |n, i|\n    digits_sum = 0\n    while n > 0\n      digits_sum += n % 10\n\
    \      n = n / 10\n    end\n    if digits_sum > 0\n      arr[i] = digits_sum\n\
    \    else\n      arr[i] = -digits_sum\n    end\n  end", "    arr.each do |number|\n\
    \        if number == 0\n            break\n        end\n        num = number.to_i\n\
    \        if num > 0\n            num = num.to_s\n            digit_sum = num.each_char.inject(0)\
    \ {|sum, char| sum + char.to_i }\n            if digit_sum > 0\n             \
    \   return 1 + digit_sum\n            end\n        end\n    end\n    return 0\n\
    end", "  arr.each do |el|\n    return el if el > 0\n    el = el.abs\n    if el\
    \ < 0 && (el % 10) == -1\n      return 1\n    end\n  end\n  0\nend", "  return\
    \ arr.count(nums(arr))\nend", "  arr.inject(0, :+)\nend", "  sum = 0\n  arr.each\
    \ { |num| sum += num.abs**2 }\n  return sum if sum > 0\n  sum = arr.find { |num|\
    \ num.abs**2 <= 0 }\n  return -1 if sum.nil?\n  sum.abs\nend", "  return arr.map\
    \ {|n| n if n.positive? && n.to_s.split('').inject(0) {|s, x| s += x.to_i if x.to_i\
    \ >= 0 } == 0 ? 1 : 0 }.reduce(:+)\nend\n</code>\n<|/ a tags=ruby,arrays,function\
    \ dscore=2 |>\n<| c |>\nCan you explain why you have `|s, n| n if n.positive?\
    \ && s.zero? || s.empty?`? I think this might also be part of the problem I was\
    \ having.\n<|/ c |>\n<| c |>\nThe `|s, n| n` bit is the same as `n.positive? &&\
    \ s.zero? || s.empty?`. The `zero?` bit is just checking to see if the string\
    \ is empty, as in \"what does the string start with?\" For that you can call `s.empty?`\
    \ as `s` is an array.\n<|/ c |>\n<| a tags=ruby,arrays,function |>\nHere is my\
    \ take on the problem. \nIt doesn't use any loops and it outputs what it needs\
    \ to in order to make the function. It uses recursion to iterate through the array.\
    \ I think the recursive solution is quite elegant and very readable for Rubyists.\n\
    <code>", "    sum = 0\n    arr.each do |i|\n        sum += i\n    end\n    if\
    \ sum < 0\n        sum *= -1\n        sum -= arr.first\n    end\n    return sum\n\
    end", "  sum = 0\n  arr.each do |e|\n    sum += e if e > 0\n  end\n  return sum\n\
    end", "  arr.each do |el|\n    digits = (el % 10).abs\n    next if digits < 0\n\
    \    el += digits * 10 \n    sum += el\n  end\n  sum\nend\ncount_nums(arr)\nend",
  "  arr.each do |i|\n    num = i\n    i = i.to_s #converts number to string\n   \
    \ sum = 0\n    while i.length > 0 #loops to get sum of digits\n      sum += i.slice!(0)\n\
    \      i.slice!(0)\n    end\n    if num == sum\n      i+=1\n      sum = 0\n  \
    \  end\n  end\n  return arr.size\nend", "\tcount = 0\n\tfor i in arr\n\t\tcount\
    \ += 1 if i =~ /^[-]?\\d+$/ ? 1 : 0\n\tcount\nend", "  if arr.empty?\n    0\n\
    \  else\n    arr.flat_map { |el| el.digits.count { |d| d > 0 } }\n  end\nend",
  "  arr.select{|x| x > 0 }.length\nend", "  arr.inject(0, :+).nonzero? { |x| x >\
    \ 0 }.length\nend", "  arr.each { |num|\n    if num > 0\n      num1 = num\n  \
    \    num2 = num1\n      sum1 = num1\n      sum2 = num2\n      sum3 = num1 + num2\n\
    \      sum4 = num1 - num2\n      sum5 = num1 * num2\n      sum6 = num1 / num2\n\
    \      sum7 = num1 // num2\n      sum8 = num1 % num2\n      sum9 = num1 % num2\n\
    \      sum10 = num1 / num2\n      sum11 = num1 % num2\n      sum12 = num1 % num2\n\
    \      sum13 = num1 % num2\n      sum14 = num1 % num2\n      sum15 = num1 % num2\n\
    \      sum16 = num1 % num2\n      sum17 = num1 % num2\n      sum18 = num1 % num2\n\
    \      sum19 = num1 % num2\n      sum20 = num1 % num2\n      sum21 = num1 % num2\n\
    \      sum22 = num1 % num2\n      sum23 = num1 % num2\n      sum24 = num1 % num2\n\
    \      sum25 = num1 % num2\n      sum26 = num1 % num2\n      sum27 = num1 % num2\n\
    \      sum28 = num1 % num2\n      sum29 = num1 % num2\n      sum30 = num1 % num2\n\
    \      sum31 = num1 % num2\n      sum32 = num1 % num2\n      sum33 = num1 % num2\n\
    \      sum34 = num1 % num2\n      sum35 = num1 % num2\n      sum36 = num1 % num2\n\
    \      sum37 = num1 % num2\n      sum38 = num1 % num2\n      sum39 = num1 % num2\n\
    \      sum40 = num1 % num2\n      sum41 = num1 % num2\n      sum42 = num1 % num2\n\
    \      sum43 = num1 % num2\n      sum44 = num1 % num2\n      sum45 = num1 % num2\n\
    \      sum46 = num1 % num2\n      sum47 = num1 % num2\n      sum48 = num1 % num2\n\
    \      sum49 = num1 % num2\n      sum50 = num1 % num2\n      sum51 = num1 % num2\n\
    \      sum52 = num1 % num2\n      sum53 = num1 % num2\n      sum54 = num1 % num2\n\
    \      sum55 = num1 % num2\n      sum56 = num1 % num2", "    count = 0\n    arr.each\
    \ do |i|\n      next if i < 0\n      count += 1 if i.to_s.split('').select(&:digits).sum\
    \ { |v| v > 0 }\n    end\n    return count\nend\n</code>\n<|/ a |>\n<| a |>\n\
    <code>", "  return arr.inject(:+).zero? ? arr.length : arr.size\nend", "  return\
    \ arr.inject(0) { |sum, n| sum += if n < 0 then -n.to_i else n.to_i end}\nend",
  "    arr.each_with_index { |n, i| return 0 if n == 0 } # skip 0\n    (arr.inject(0)\
    \ { |n, a| n += (a.digits(9).map { |s| s > 0 ? s : -s } > 0).count() ? 1 : 0 })\
    \ % 9\nend", "    arr.sort!\n    i = 0\n    count = 0\n    while i < arr.length\n\
    \      if arr[i].nonzero? && (arr[i] + arr[i+1]).nonzero?\n        count += 1\n\
    \      end\n      i += 1\n    end\n    return count\nend", "    arr.each { |x|\
    \ x += x.to_s.chars.map(&:to_i).inject(0) { |sum, digit| sum + digit } if x.is_a?(Integer)\
    \ }\nend\n</code>\nThis is just the same implementation as you have, just refactored\
    \ a bit. The count_nums method is shorter, and much easier to understand.\nNote\
    \ that I used the || operator rather than a plain if for checking to see if the\
    \ number itself was negative or positive, because you don't want to add negative\
    \ numbers together.\n<|/ a tags=ruby |>\n<| c |>\nI didn't know that `inject`\
    \ was a method of every object in Ruby. This makes a lot of sense, thank you!\n\
    <|/ c |>\n<| a dscore=1 tags=ruby |>\nHere is another solution that I thought\
    \ of after reading comments above. I think it is more elegant than the previous\
    \ solutions because I do no manipulation with strings. \n<code>", "  n = arr.inject(0){\
    \ |sum, element| sum + element if element > 0 }\n  arr[0..arr.length-1].inject(0){\
    \ |sum, element| sum + element if element < 0 }\nend\n</code>\nThe above solution\
    \ uses inject from ruby v1.8.7 and is therefore not compatible with ruby v1.9.1\n\
    The inject method is an extension of the enumerable module which can be found\
    \ here http://www.ruby-doc.org/core/classes/Enumerable.html\nThe inject method\
    \ can be found in ruby v1.9.1's enumerable module which can be found here http://www.ruby-doc.org/core-1.9.1/Enumerable.html\n\
    The inject method works similar to each_with_object but with the difference that\
    \ it returns a value rather than an array as the return value.\n<|/ a dscore=2\
    \ tags=arrays,ruby |>\n<| a |>\nThe first thing that comes to mind is this:\n\
    <code>", "    s = 0\n    arr.each do |el|\n        s += el % 10\n    end\n   \
    \ s\nend", "  # Your code here\n  arr.inject(0) do |sum, num|\n    sum += (0 if\
    \ num < 0 then -num else num).to_s.length\n    sum\n  end\nend", "  result = 0\n\
    \  arr.each do |n|\n    result += n % 10 # get the last digit of each element\n\
    \  end\n  result\nend", "    arr.each do |x|\n        if x > 0 && x.positive?\n\
    \            arr.delete_if {|y| y > x }\n            count = arr.size - (arr.delete_if{|y|\
    \ y <= 0}).size\n            puts \"#{x} has #{count} number with sum of digits\
    \ > 0\" if count > 0 && count > 1\n        end\n    end\nend\n</code>\nThe output\
    \ from running count_nums on an array with your numbers is as follows:\n<code>\n\
    => count_nums([11, -9, -100, -100, -7, 10, 10, -5, -5, -10, -6, -9, -9, -5, -5,\
    \ -10, -7, -9, -9, -7, -9, -9, -9, -5, -5, -10, -7, -9, -9, -7, -9, -9, -9, -7,\
    \ -9, -9, -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9,\
    \ -9, -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9, -9,\
    \ -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9, -9, -9,\
    \ -9, -7, -9, -9, -9, -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9, -9, -9, -9,\
    \ -7, -9, -9, -9, -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9, -9, -9, -9, -7,\
    \ -9, -9, -9, -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9, -9, -9, -9, -7, -9,\
    \ -9, -9, -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9,\
    \ -9, -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9, -9,\
    \ -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9, -9, -9, -9, -7, -9, -9, -9, -9,\
    \ -9, -7, -9, -9, -", "\tarr.each do |num|\n\t\tnum = num.to_i\n\t\tnum = num\
    \ if num > 0\n\t\tnum = num % 10\n\t\tnum\n\tend\nend\ncount_nums(arr)\n</cell>\n\
    <cell>", "  arr.each { |x| return x.to_i if x.to_i > 0 }\n  0\nend", "    arr\
    \ = arr.clone\n    arr.compact\n    sum = 0\n    arr.each do |e|\n        sum\
    \ += e if e > 0 \n    end\n    sum\nend\n</cell>\n<text>\nArray#compact\nThe Array#compact\
    \ method removes all nil values from an array. For example:", "  arr.inject(0)\
    \ do |sum, number|\n    sum + number_to_digits(number)\n  end\nend", "  count\
    \ = arr[0]\n  for i in 1..arr.length\n    count += arr[i] if arr[i] >= 0\n   \
    \ count -= arr[i] if arr[i] < 0\n  end\n  count\nend", "  return arr.compact.inject(0)\
    \ { |m, x| x if x.zero? || m > x.to_s.length }.to_i\nend", "  arr.flatten.select\
    \ { |n| n.to_i >= 0 }.size\nend", "  result = 0\n  arr.each do |x|\n    result\
    \ += (x.to_i).to_s.length - 1 # Subtract 1 because we don't want to count first\
    \ digit.\n  end\n  result\nend", "  arr.each do |num|\n    if num < 0\n      return\
    \ (num * -1) - num / 10\n    end\n  end\n  return 0\nend", "  return arr.select\
    \ { |i| i.to_s.chars.select{|x| x > 0 }.count > 0 }.count\nend", "  n = arr.size\n\
    \  count = 0\n  arr.each { |x| return x if x.nonzero? }.each { |x| count += x.to_s.length\
    \ if x.to_s.length > 0 }\n  return count\nend", "  sum = 0\n  arr.each { |n| sum\
    \ += n if n.to_s.split(//).collect { |i| i.to_i }.inject(:+) > 0 }\n  sum\nend",
  "  arr.sort!\n  sum = 0\n  i = 0\n  while i < arr.length\n    sum = sum + arr[i]\n\
    \    i += 1\n    if sum < 0\n      sum += arr[i].abs\n      i += 1\n    end\n\
    \  end\n  sum\nend", "  if arr.empty?\n    0\n  else\n    digits = arr.map{|n|\
    \ n if n.positive?}\n    negatives = digits[1...-1].map{|n| n.negative? ? -n :\
    \ n}\n    negatives.reduce(:+)\n  end\nend\n</code>\n<|/ a |>\n<| c |>\n+1 for\
    \ the idea, but not for a Ruby programmer. Ruby is my weapon of choice. :)\n<|/\
    \ c |>\n<| c |>\nThis code is very similar to what I came up with as well.  The\
    \ only difference is that the way I did it used `map` on negative numbers instead\
    \ of `reduce`, which I believe is more idiomatic Ruby.\n<|/ c |>\n<| c |>\n, I\
    \ agree with your point about `map`/`reduce` vs. `inject`, but the difference\
    \ is not very significant.\n<|/ c |>\n<| c |>\n, that's true. I actually didn't\
    \ think about it. `reduce` is definitely more Ruby-like to me. Sure, it doesn't\
    \ feel like `inject`, but I've seen people using `inject` all the time without\
    \ fully understanding what it means and what the benefits are.\n<|/ c |>\n<| c\
    \ |>\nYep, `reduce` is more idiomatic in Ruby, so I tend to use that in preference\
    \ to `inject`. Just remember that `reduce` returns an `Array` and that `inject`\
    \ returns an `Enumerator`, but they're interchangeable. :-)\n<|/ c |>\n<| a dscore=1\
    \ |>\nAs a follow-up to Michael's answer, here's a more efficient solution in\
    \ ruby.\n<code>", "  arr.each_with_index do |x, i|\n    if x > 0 && x.to_s.split('').any?\
    \ {|y| y < 0 }\n      puts \"#{x} has signed digits: #{x.to_s.split('').map{|y|\
    \ -y }.join }\"\n    end\n  end\nend\ncount_nums([10, 9, -10, -9, 10, -10, 11])",
  "  arr.inject(0) { |acc, x| acc + count_digits(x) }\nend", "    count = 0\n    arr.each\
    \ do |n|\n        count += n.to_s.split('').count(&:odd?) ? 1 : n.to_s.split('').count(&:even?)\
    \ ? -1 : 0\n    end\n    count\nend", "  return arr.inject(0) { |res, x| res +\
    \ ((x % 10**9).zero? ? 0 : 1) }\nend\n</cell>\n<text>\nTest your function with\
    \ the cell below:", "    arr.each do |item|\n        if item > 0\n           \
    \ count = 0\n            while (item >= 10)\n                count += 1\n    \
    \            item -= 10\n            end\n            return count\n        end\n\
    \    end\n    return 0\nend\n</cell>\n<cell>", "  arr.inject { |sum, n| sum +\
    \ n if n.nonzero? }\nend", "    count = 0\n    arr.each do |num|\n        if num.is_a?(Integer)\
    \ && num > 0\n            count += num\n        end\n    end\n    return count\n\
    end", "  arr.sort!\n  count = 0\n  n = arr.length\n  for i in 0...n\n    arr[i]\
    \ < 0 ? arr[i - 1] += 9 : arr[i - 1] += arr[i] >= 10 ? 1 : 0\n    if arr[i] >\
    \ 9\n      arr[i] = arr[i].div(10)\n      count += 1\n    end\n  end\n  return\
    \ count\nend", "  # Use a stack to keep track of the sum we see so far.\n  # A\
    \ stack is a last-in-first-out (LIFO) data structure, which\n  # means that new\
    \ items are added to the end of the stack.\n  # The last item added to the stack\
    \ will be the one returned.\n  digits = []", "  arr.select do |e|\n    e = e *\
    \ (10**arr.length - 1) if e >= 0\n    e % 10 == 0\n  end.length\nend", "  arr.each\
    \ do |n|\n    n += 1 if n.to_i > 0\n  end\n  arr.count\nend\n</cell>\n<cell>",
  "    arr.each_index { |i| arr[i] = 0 if arr[i] < 0 else arr[i] }\n    arr.reverse.inject(0)\
    \ do |sum, n| return 0 if sum > 0 && n == 0; sum + arr[n] if n == arr.size - 1;\
    \ sum + arr[n-1] if n == 0 end\nend", "  return arr.inject(0) { |acc, n| acc +\
    \ n if n > 0 }\nend", "  if arr.empty?\n    0\n  else\n    arr.inject(0) { |sum,\
    \ n| sum + n if sum + n >= 10 }\n  end\nend", "\tn = 0\n\tfor i in arr\n\t\tn\
    \ += getSum(i)\n\tputStrLn(n)\nend", "  digits = arr.map { |n| n.to_s.split('').map(&:to_i)\
    \ }\n  num_digits = digits.size\n  num_negative = digits.any? { |d| d.first <\
    \ 0 }\n  digits.reduce(0) { |sum, d| sum += (d.last.nonzero? ? d.last : 1) * (d.first.nonzero?\
    \ ? d.first : -1) }\nend", "  arr.inject(0) do |sum, el|\n    return sum if el\
    \ < 0\n    digit = el % 10\n    sum + digit if digit > 0\n  end\nend", "    arr.each\
    \ do |x|\n        if x.is_a? Integer\n            if x >= 0\n                x.to_s.reverse.each_char.inject(0)\
    \ do |cnt, digit|\n                    cnt + 1 if digit.to_i ** 0 > x\n      \
    \          end\n            else\n                x.to_s.reverse.each_char.inject(0)\
    \ do |cnt, digit|\n                    cnt + 1 if digit.to_i ** 0 < x\n      \
    \          end\n            end\n        end\n    end\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby,algorithm |>\n<| c |>\nThis algorithm doesn't work for negative numbers\
    \ though: e.g. -123 has signed digits -1, 2, and 3, but this algorithm returns\
    \ 2.\n<|/ c |>\n<| a dscore=0 |>\nI came up with this algorithm:\n<code>", " \
    \   count = 0\n    arr.each do |x|\n        if x.to_s.split('').sum { |y| y >\
    \ 0 } > 0\n            count += 1\n        end\n    end\n    return count\nend",
  "  digits = arr.map {|e| abs(e) rescue nil}\n  digits.reduce(0) {|acc, digit| acc\
    \ + digit if digit}\nend", "  arr.map {|num| num.digits.reduce(0) {|sum, digit|\
    \ sum + digit} if num > 0 }.size\nend\n</code>\n<|/ a |>\n<| c |>\nI wish I could\
    \ upvote this more than once. Nice answer!\n<|/ c |>\n<| c |>\nThis answer doesn't\
    \ seem to handle negative numbers, though.\n<|/ c |>\n<| c |>\n, thanks for the\
    \ feedback! I fixed my answer.\n<|/ c |>\n<| a dscore=3 |>\nMy solution to your\
    \ problem:\n<code>", "  arr.each do |x|\n    return x if x < 0\n    x.to_s.each_char.inject(0)\
    \ do |sum, e|\n      sum + e.to_i if e >= 0 and e.to_i <= 9\n    end\n  end\n\
    end\n</code>\nNow, count_nums([1, 2, 3, 4]) will return 4.\n<|/ a dscore=2 |>\n\
    <| c |>\nIt's worth noting that the code above is very inefficient. O(n^2) is\
    \ bad - try it with [100, 1000, 10000, 100000, 1000000] :)\n<|/ c |>\n<| c |>\n\
    The OP asked about efficiency, so I provided an inefficient solution.\n<|/ c |>\n\
    <| c |>\nYes but the inefficiency is unlikely to matter in a real world program\
    \ and thus it's not a good example to show ;)\n<|/ c |>\n<| a dscore=0 |>\nIt\
    \ can be solved using regular expressions.\n<code>", "  # Your code here\n  ret=0\n\
    \  negative=0\n  positive=0\n  for i in arr:\n    if i<0:\n      negative=negative+1\n\
    \      i=-i\n    if i>0:\n      positive=positive+1\n      i=i\n  ret=negative+positive\n\
    \  return ret", "    arr.inject(0) do |tot, el|\n        tot += el if el.is_a?\
    \ Integer\n        tot -= el if el.is_a? Numeric\n        tot += 1 if el.nonzero?\n\
    \        tot -= 1\n        tot\n    end\nend\n</code>\nThen you get some more\
    \ readable code:\n<code>", "  sum = arr[0]\n  for i in 1..arr.size\n    if arr[i]\
    \ > sum\n      sum += arr[i]\n    elsif arr[i] < sum\n      return 0\n    end\n\
    \  end\n  return 1\nend\n</cell>\n<code language=julia-1.1>\ncount_nums([-4, 12,\
    \ -11])\n</cell>\n<code language=julia-1.1>\ncount_nums([-12, 0, -9, 4, -1, 1,\
    \ -6, 0])\n</cell>\n<code language=julia-1.1>\ncount_nums([1, -1, 1, -9, 4, -1,\
    \ 1, -6, 0])\n</cell>\n<code language=julia-1.1>\ncount_nums([-10, 1, 1, -9, 4,\
    \ -1, 1, -6, 0])\n</cell>\n<code language=julia-1.1>\ncount_nums([-10, 1, 1, -9,\
    \ 4, -1, 1, -6, 0, 2, -2, 1])\n</cell>\n<text>\nWrite a function count_evens which\
    \ takes an array of integers and returns\nthe number of elements which has an\
    \ even sum:\n>>> count_evens([]) == 0\n>>> count_evens([-1, 2, 3, -4, -2, 3])\
    \ == 2\n>>> count_evens([1, 2, -3]) == 0\n>>> count_evens([1, 2, -3, 2, -3, 1,\
    \ -2, -4, 3]) == 0\n>>> count_evens([-1, -1, 1, -5, -4, -5, -3, 1, -2, 4, 2, -5])\
    \ == 4\n>>> count_evens([-4, 12, -4, -2, -12, 2, -6, -1, -2, -3, 2, 4, -4, -9,\
    \ 1, -1, 5, -2, -2, -4, -5]) == 12\n>>> count_evens([-1, 11, 11, -5]) == 0\n>>>\
    \ count_evens([-1, 11, -5, -4, -4, -5, -5, -4, -9, -5, -5, -4, -5, -5, -5, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -", "    count = 0\n    arr.each do\
    \ |i|\n        if i.is_a?(Fixnum) and i >= 0\n            count += 1 if i >= 10\n\
    \        else\n            count = 1 unless i.is_a?(Fixnum)\n            count\
    \ += 1 if i.is_a?(Fixnum) and i <= 0\n        end\n    end\n    count\nend", " \
    \ arr.each { |n| return n if n < 0 } # Remove negative numbers\n  arr.select {\
    \ |n| n.digits.sum > 0 } # Count positive numbers\nend", "  return arr.inject(0)\
    \ { |sum,x| sum + digits(x) }\nend", "  arr.each_with_index.inject(0) {|sum, (n,\
    \ i)| sum + nums_digit(n, i) }\nend", "  arr.each do |num|\n    if num < 0\n \
    \     num = num - num.abs\n    end\n    if num > 9\n      count = 1\n      while\
    \ num > 0\n        num, digit = num / 10, num % 10\n        digits = (digit.to_i\
    \ + digits).abs\n        count = count + (digits > 0 ? 1 : 0)\n      end\n   \
    \ end\n  end\n  return arr.reduce(&:+) if arr.size > 0\n  return 0\nend", "  count\
    \ = 0\n  arr.each {|x| count += ((x / 10) > (x / 100.0) ? 1 : 0) }\n  count\n\
    end", "  arr.each { |x| sum += (x < 0) ? -x : x }\n  return sum if sum > 0\n \
    \ sum = 0\n  arr.each { |x| sum += (x < 0) ? -x : x }\n  return sum\nend\n</cell>\n\
    <code language=julia-0.6>\ncount_nums([-1, 11, -11])\n</cell>\n<code language=julia-0.6>\n\
    count_nums([-2, 3, 6, -1, -4, 9, 2])\n</cell>\n<text>\nPart 2\nThis exercise is\
    \ inspired by a problem we saw in the lecture.  Write a function\nfind_max_sum_of_two_sets(a,\
    \ b) that takes an array of sets where each element is\na set containing integers,\
    \ and returns the maximum sum that can be made by summing\npairs of elements from\
    \ the two sets.  For example, if a = [{1, 2}, {1, 3}, {2, 3}]\nand b = [{1, 1},\
    \ {2, 2}, {1, 2}, {2, 1}, {3, 3}, {1, 3}, {1, 2}], then find_max_sum_of_two_sets(a,\
    \ b) should return the value 9, because the pairs ({1, 3}, {2, 3}) can be summed\
    \ to make the biggest sum {3, 1, 3}, which is 9.  You don't need to write any\
    \ special code to handle duplicate elements.  You may assume that sets a and b\
    \ each contain at most 1000 elements.", "  count = Hash.new(0)\n  arr.each do\
    \ |n|\n    count[n.to_s.rjust(1, \"0\")] += 1 if n > 0\n  end\n  return count\n\
    end", "  sum = 0\n  arr.each do |x|\n    sum = sum + x.abs\n  end\n  sum >= 0\
    \ ? sum : sum.abs\nend", "    count = 0\n    if arr.empty?\n        return count\n\
    \    digits = arr.map { |i| i.to_s.split('').map(&:to_i).join.to_i }\n    digits.each\
    \ do |digit|\n        if digit > 0 && digits.count(digit-1) > 0\n            count\
    \ += 1\n        end\n    end\n    count\nend\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nI understand that, but I don't think it is the most efficient way as each\
    \ number needs to be iterated over many times. Do you know a way of doing this\
    \ using only 1 iteration per number ?\n<|/ c |>\n<| c |>\nThanks for your answer\
    \ but I think your algorithm is not correct, since it returns \"10\" instead of\
    \ \"3\" in the example you gave (when testing with count_nums([-1, 11, -11])).\
    \ Besides, it only returns one number, not the sum.\n<|/ c |>\n<| c |>\n: I added\
    \ the other test cases, for what I get in ruby 1.9.3p392 with your input.  Thanks.\n\
    <|/ c |>\n<| c |>\n: I've added a faster solution.  I think it's good enough,\
    \ though.\n<|/ c |>\n<| c |>\nThanks J\xF6rg, your code is very fast. I think\
    \ your solution is better than the one I accepted, but both are correct and very\
    \ fast.\n<|/ c |>\n<| a dscore=1 |>\nI solved the problem using this function:\n\
    <code>", "  arr.length.times do |i|\n    arr.slice!(i..i-1)\n    return arr.length\
    \ if arr.sum > 0\n  end\n  0\nend\n</code>\nHere's a solution that doesn't use\
    \ recursion.\n<code>", "  return arr.inject {|sum, el| sum += el if el > 0}\n\
    end", "  arr.inject([0, 0], :+)\n  arr.each_with_index.inject(0) do |sum, (value,\
    \ index)|\n    sum = sum if value > 0 && sum > 0\n    sum = sum + 1 if value <\
    \ 0 && (sum < 0 || index > 0)\n    sum\n  end\nend", "    arr.each do |n|\n  \
    \      if n.to_s.chars.map(&:to_i).inject(:+) > 0 then\n            count += 1\
    \ \n        end\n    end\nend\n</code>\nThe key idea of this code is the use of\
    \ inject and map. Inject will \"reduce\" the array in such a way that the element\
    \ at the specified index gets passed to each call of its block, and map will \"\
    map\" each element of the array to a result based on the return value of its block.\
    \ You can then sum up the results of the map to count the number of elements which\
    \ have at least one digit greater than zero.\n<|/ a |>\n<| c |>\nThe only part\
    \ I find unclear about the code is how we count each number.  I see that the last\
    \ line says \"count+=1\" but the count variable isn't defined anywhere so I'm\
    \ not sure how the count is actually getting counted here\n<|/ c |>\n<| c |>\n\
    : Thanks for the comment. I misread the code. I assumed the `count` variable was\
    \ defined at the top of the code (outside the function). I've edited my answer\
    \ to correct this.\n<|/ c |>\n<| c |>\nThanks for your post.  I really appreciate\
    \ your detailed explanations.  It was the inject function that I was struggling\
    \ to grasp.  I wish I could mark your post as the accepted answer but since I\
    \ only just started learning ruby today, I'm not sure if that's possible.  Thanks\
    \ again!\n<|/ c |>\n<| c |>\n: No problem, glad I could help. If you're happy\
    \ with the answer then you can click the tick mark next to it to mark it as accepted.\
    \ Alternatively, if you found the other answers useful, you can upvote them, which\
    \ will give you more rep.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nIf you're looking\
    \ for a solution where the code is simple, and concise, I would recommend using\
    \ inject:\n<code>", "  sum = 0\n  arr.each do |i|\n    sum += i if i.is_a? Integer\n\
    \  end\n  sum > 0 ? sum : -sum\nend", "  arr.each do |num|\n    if num < 0\n \
    \     num = -num\n    end\n    num = num.to_s\n    arr.each do |n|\n      n.to_s.split(\"\
    \").each do |char|\n        if char == num\n          arr.delete_at(arr.index(n))\n\
    \        end\n      end\n    end\n  end\n  arr.size\nend", "  arr.inject(0, :+).select\
    \ { |x| x > 0 }.size\nend", "  arr.each do |x|\n    if x.to_i >= 0 then break\
    \ end\n    digit_sum = x\n    x.to_s.split('').each do |digit|\n      digit_sum\
    \ -= digit if digit_sum > 0\n    end\n  end\n  arr.size - arr.select { |x| x >=\
    \ digit_sum }.length\nend", "    arr = arr.map(&:abs)\n    arr.uniq.select { |x|\
    \ x > 0 }.length\nend\n</code>\nThe above could be implemented with a reduce,\
    \ which is more concise:\n<code>", "    count = 0\n    neg_arr = []\n    nums\
    \ = []\n    arr.each do |n|\n      if n.kind_of?(Integer) or n.kind_of?(Float)\n\
    \        count += 1\n        nums << n\n      elsif n.kind_of?(String)\n     \
    \   nums.reverse!\n        nums << n.to_i.abs\n      end\n    end\n    neg_arr\
    \ << nums.pop\n    neg_arr.each do |n|\n      if n == 0\n        count += 1\n\
    \      end\n    end\n    count\nend\n  ", "  count = 0\n  arr.each {|n| count\
    \ += 1 if n >= 0 ? n.to_s.size-1 : n}\n  return count\nend", "  arr.each do |x|\n\
    \    break if x<0\n  end\n  arr.count(x)\nend", "  # Your code here\n  arr.each\
    \ do |num|\n    num %= 10\n    next if num < 0\n    sum = 0\n    while (num >\
    \ 0)\n      sum += num % 10\n      num /= 10\n    end\n    if sum > 0\n      puts\
    \ sum\n    end\n  end\nend", "  arr.map!{|x| x.abs} if arr.class == Array\n  arr.select\
    \ { |x| x.to_s.split('').map(&:to_i).sum > 0 }.length\nend\n</code>\nHere's a\
    \ test to make sure it works:\n<code>", "  arr = (arr.map { |x| x.abs } if arr.respond_to?(:map))\n\
    \  arr.each { |n| return n if n < 0 }\n  arr.map { |n| n % 10 }\n  .uniq\n  .map\
    \ { |n| n.to_s.length }\n  .inject(0) { |m, n| m += n if m > 0 && n % 10 == 0\
    \ }\nend\n</code>\n<|/ a |>\n<| c |>\nIt's only a small variation of my solution\
    \ that I posted below.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  # Hint: use a\
    \ hash table.\n  # Write your solution below:\n  return 0\nend", "  # Your code\
    \ here\n  digits = arr.map {|x| x.to_i}\n  digits.inject{|sum,x| sum + x if x\
    \ > 0}\nend\n</cell>\n<cell>", "    count = 0\n    arr.each do |n|\n        n.to_s.split('').each\
    \ do |d|\n            count += d.to_i\n        end\n    end\n    count\nend",
  "  n = arr.size\n  result = 0\n  arr.each { |x| result += (x / 10).abs }\n  result\n\
    end", "  # write your code in Ruby\n  arr.select { |n| n % 10 > 0 }.size\nend",
  "  count_hash = {}\n  arr.each do |item|\n    count_hash[item] = 1 if count_hash[item].zero?\n\
    \    count_hash[item] += 1 if item > 0 && !count_hash[item - 1].zero?\n  end\n\
    \  count_hash.values.inject(0){|sum, num| sum + num if num.nonzero? }\nend", " \
    \ return arr.inject(0) {|m, x| m + 1 if ((x % 10).zero? || m >= x) }\nend\n</cell>\n\
    <cell>", "  arr.map! do |i|\n    i = i.abs\n    (0...i).select { |j| i / (10 **\
    \ j) > 0 }.size\n  end\n  arr.sum\nend\n</cell>\n<cell>\ncount_nums([-3, 2, 3,\
    \ -2, 2])\n</cell>\n<cell>", "  arr = (arr + [0]) * (arr.count {|n| n > 0} * -1)\n\
    \  arr.map {|x| x.abs} # remove signs\n  .select {|x| x > 0}\n  .count\nend",
  "  arr.each { |e| return 0 if e < 0 }\n  arr.count(true)\nend\n</code>\nSo your\
    \ count_nums method is wrong. Look at the first example. -1 is less than 0. The\
    \ first element in the array is less than 0. So the method counts no elements\
    \ in the array. But you just need to check if there is at least one number with\
    \ a sum greater than 0.\n<code>", "  arr.inject(0) do |sum, num|\n    sum += num\
    \ if num > 0\n    sum\n  end\nend", "  if arr.empty?\n    0\n  elsif arr.all?\
    \ { |e| e > 0 }\n    arr.select { |e| e > 0 }.size\n  else\n    arr.detect { |e|\
    \ e > 0 }.size\n  end\nend", "  count = 0\n  arr.each { |e| count += 1 if e >\
    \ 0 }\n  count\nend", "    count=0\n    nums=[]\n    for x in arr\n        nums.push\
    \ x if x.is_a? Fixnum\n    end\n    nums.sort!\n    for num in nums\n        digits=num.to_s.chars.map(&:to_i)\n\
    \        if digits.sum>0\n            count=count+1\n        end\n    end\n  \
    \  count\nend", "  arr.each_with_index { |n, i|\n    if n >= 0\n      nums = (i\
    \ + 1).to_s.split(//)\n      nums.map(&:to_i).reduce(:+) - n\n    else\n     \
    \ arr[i] < 0 ? -arr[i].to_s.split(//).map(&:to_i).reduce(:+) : -arr[i]\n    end\n\
    \  }\nend", "  return arr.select { |x| x >= 0 }.count\nend\n</code>\nNote that\
    \ this doesn't work correctly for an array of negative numbers. I see no good\
    \ way around this other than adding an additional constraint.\n<|/ a |>\n<| c\
    \ |>\nThanks for the help. This code works on both positive and negative numbers.\
    \ Is there a way to make it work for negative numbers as well?\n<|/ c |>\n<| c\
    \ |>\nI added an explanation of why this doesn't work correctly for negative numbers.\n\
    <|/ c |>\n<| a tags=ruby |>\nIf you're on Ruby 2.3+, you can use Enumerable#slice_before\
    \ to achieve this very succinctly:\n<code>\narr = %w[9 9 9]", "  arr.each do |x|\n\
    \    if x < 0\n      x = -x\n    end\n    # x = x.to_i\n    total = 0\n    while\
    \ x > 0\n      total += 1\n      x -= 10\n    end\n    if total == 1\n      return\
    \ 1\n    elsif total == 2\n      return 2\n    end\n  end\n  return 0\nend", " \
    \ if arr.size == 0\n    0\n  else\n    arr = arr.sort.reverse\n    arr.each_index\
    \ do |i|\n      num = 0\n      while num < 9\n        num = arr[i] + num * 10\n\
    \        i += 1\n      end\n      if num > 0\n        arr[i] = -num\n      end\n\
    \      break\n    end\n    arr.size - 1\n  end\nend", "  arr.each do |i|\n   \
    \ sum += i.to_s\n  end\n  return sum if sum > 0\n  sum < 0 ? arr.each { |i| sum\
    \ += i.abs} : arr.each { |i| sum += -i.abs}\n  sum\nend", "  arr.each do |el|\n\
    \    return el if el >= 0\n    i = el < 0 ? el.to_s.rindex(\"-\") + 1 : el.to_s.rindex(\"\
    \")\n    return el if el < 0 && el.to_s.length-i-1 > 0\n  end\n  0\nend", "  #\
    \ Sum the numbers in arr. If number < 0 then get its first signed digit.\n  sum\
    \ = 0\n  arr.each do |i|\n    if i < 0\n      sum += i * (-1) ** i\n    else\n\
    \      sum += i\n    end\n  end\n  return sum\nend", "  # Your code here\n  sum\
    \ = 0\n  arr.each do |el|\n    if el >= 0\n      el *= 10\n      sum += el\n \
    \   end\n  end\n  return sum.to_i\nend\nassert count_nums([]) == 0\nassert count_nums([-1,\
    \ 1, -4]) == 1\nassert count_nums([1, 0, -3]) == 3", "  return arr.select { |i|\
    \ i.to_i >= 0 }.size\nend\n</code>\nAnd finally we can write our solution:\n<code>",
  "    count = 0\n    arr.each do |num|\n        if num < 0\n            digit = num\
    \ / 10\n            digit = num % 10\n            next if digit < 0\n        \
    \    digit = -digit\n            count += digit\n        else\n            count\
    \ += 1\n        end\n    end\n    return count\nend\nprint count_nums([-1, 11,\
    \ -12, -13, -14, 15]) # => 3\n</code>\n<|/ a tags=ruby,algorithm |>\n<| a dscore=0\
    \ tags=ruby,algorithm |>\nThe algorithm is simple: count the number of non-negative\
    \ numbers from 1 to N. For each non-negative number, find its first nonnegative\
    \ number. Subtract that from N and count how many numbers were subtracted from\
    \ N. \n<code>", "  arr.inject(0) do |count, el|\n    if el < 0\n      count +\
    \ 1\n    elsif el > 0\n      count += 1 if el % 10 == 0\n    end\n  end\nend\n\
    </cell>\n<cell>\ncount_nums([]) == 0\ncount_nums([-1, 11, -11]) == 1\ncount_nums([1,\
    \ 1, 2]) == 3\n</cell>\n<cell>\n%run -i 'count_nums.rb'\n</cell>\n<text>\n1.3\
    \ Exercises", "  return arr.inject(:+).to_i if arr.any? { |x| x > 0 }\n  0\nend",
  "  if arr.empty?\n    0\n  else\n    (arr.map{|e| e.is_a?(Integer) ? e : -e}.inject{|acc,v|\
    \ acc + v.abs} -\n      arr.first.is_a?(Integer) ?\n        arr.first - 1 : arr.first).abs\n\
    \  end\nend", "  arr.each { |n| n >= 0 ? n += n.signum : n -= n.signum }\n  arr.size\n\
    end", "  arr.length.times do |i|\n    if arr[i] < 0\n      arr[i] += 10\n    end\n\
    \  end\n  arr.compact.select { |e| e > 0 }.size\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby |>\n<| c |>\nI appreciate the suggestion.  Your code runs in about\
    \ 1ms and is still less than the code I wrote in about 3ms.  Thank you!\n<|/ c\
    \ |>\n<| a dscore=0 |>\n<code>", "  return arr.inject(0) { |sum, num| sum + (num.zero?\
    \ : num.abs) * Math.log10(10) - Math.log10(sum + 1) }\nend", "  arr.select! {\
    \ |i| i < 0 }\n  arr.select { |i| i % 10 != 0 }.length\nend\n</cell>\n<cell>\n\
    count_nums(arr)\n</cell>\n<cell>\narr1 = [0, 3, -3, -3, 10, -10, 10, 2, 12, -12,\
    \ 12]\narr2 = [0, 3, -3, -3, 10, -10, 10, 2, 12, -12, 12]\narr = [arr1, arr2]\n\
    count_nums(arr)\n</cell>\n<cell>\narr = [\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n\
    \  [9, 10, 11, 12],\n  [13, 14, 15, 16],\n  [17, 18, 19, 20]\n]\ncount_nums(arr)\n\
    </cell>\n<cell>", "  arr.each_with_index do |e, i|\n    # If the number is negative,\
    \ multiply its first digit by -1 to keep it\n    # positive.\n    if i < 0\n \
    \     e *= -1\n      # And remove the sign from the first element in the list.\n\
    \      arr[i] = arr[i].abs\n    end\n    break if arr[i] == 0\n  end\n  arr.sum\
    \ - arr.count(&:zero?)\nend\n</cell>\n<cell>\ncount_nums([-2, 11, -123])\n</cell>\n\
    <cell>\ncount_nums([1, 1, 2])\n</cell>\n<cell>\ncount_nums([1, 2, 2, 1])\n</cell>\n\
    <cell>\ncount_nums([])\n</cell>\n<text>\nRefactor", "  arr.each { |x|\n    if\
    \ x >= 0 then\n      digits = x.to_s.chars.map(&:to_i).sum\n      break\n    end\n\
    \  }\n  arr.count { |x| x >= 0 ? digits : -digits}\nend\n</cell>\n<cell>\ncount_nums([7,\
    \ 2, 8, 3, 5, -1, -2, -4])\n</cell>\n<cell>\ncount_nums([-10, -100, 200, 0])\n\
    </cell>\n<cell>\ncount_nums([-1, 0, 11, 12])\n</cell>\n<cell>", "    sum = 0\n\
    \    arr.each do |el|\n        if el < 0\n            sign = -el\n           \
    \ el *= sign\n        end\n        sum += el\n    end\n    return sum if sum >\
    \ 0\n    arr.size - arr.select { |el| el < 0 }.size\nend", "  if arr.empty?\n\
    \    0 # this covers the edge case where arr is an empty array ([])\n  else\n\
    \    # this assumes arr is an array of signed ints (i.e. [-4, -3, -2, 0, 2, 3])\n\
    \    # but this could be changed to support unsigned integers if needed\n    arr.each_with_index.inject(0,\
    \ :+).to_i \\\n      .tap { |sum, n| sum += n if n > 0 }\n  end\nend\n</code>\n\
    I believe this should work, but I am not 100% confident that it is correct.\n\
    <|/ a tags=ruby dscore=2 |>\n<| a |>\nI did this a long time ago with some Ruby\
    \ code I wrote years ago.  But I remember that I did it with a regular expression.\
    \  I ended up using the scan() method to look for sequences of one or more consecutive\
    \ digits that followed zero or more non-digits, followed by zero or more consecutive\
    \ non-digits.\nI then used the .length method of a returned array returned by\
    \ the regular expression, to determine how many digits were found.  I then subtracted\
    \ 1 from that number to get the number of non-zero digits found before the start\
    \ of the sequence.\nThis code is probably very inefficient.  It does it in one\
    \ pass through the string, rather than processing it two characters at a time.\n\
    <code>", "    arr.each do |i|\n      sum = 0\n      if i.negative?\n        i\
    \ = -i.abs\n      end\n      while i < 10\n        sum += i << 0\n        i <<=\
    \ 1\n      end\n      arr.reject! {|v| v == i}\n      arr << i if sum > 0\n  \
    \  end\n    arr.size\nend\n</code>\nAnd then\n<code>\ncount_nums(array1)\n</code>\n\
    output\n<code>\n9\n</code>\n<|/ a |>\n<| c |>\nI realize I should have been clearer\
    \ about what I was doing. I've updated the original post with clarification.\n\
    <|/ c |>\n<| c |>\n: Okay, that makes sense. You could use my solution with some\
    \ modification. I'll try to give it a try.\n<|/ c |>\n<| c |>\n: I've updated\
    \ my answer. It now contains code that works for the new requirements.\n<|/ c\
    \ |>\n<| a |>\nThe algorithm would be the following:\n<code>", "  num_sum = 0\n\
    \  arr.each do |x|\n    if x.kind_of?(Integer)\n      num_sum += x\n    elsif\
    \ x.is_a?(Numeric)\n      num_sum += x.abs\n    elsif x.is_a?(String)\n      num_sum\
    \ += x.to_i.abs\n    else\n      raise \"Error: unsupported type\"\n    end\n\
    \  end\n  num_sum\nend\n</cell>\n<cell>\ncount_nums(nums)\n</cell>\n<text>\nBONUS:\
    \ Write a method sum_in_place that sums the elements of a given array.\nThe sum_in_place\
    \ method will take an arbitrary number of integers and return the\nsum of their\
    \ digits.", "  arr.each do |num|\n    sign, digits = num.to_s.split('')\n    digits.each\
    \ { |d| return (num > 0) ? 1 : 0 }\n  end\n  0\nend", "  num_digits = arr.inject(0)\
    \ { |sum, n| sum + n.to_s.size }\n  arr.select { |n| n > 0 }.inject(0) { |sum,\
    \ n| sum + count_digits(n) } < num_digits?\nend", "  if arr.empty? or arr.size\
    \ < 2\n    0\n  else\n    sum_digits(arr)\n  end\nend", "    arr.each do |num|\n\
    \      i = 1\n      while i < num\n        i += 1\n      end\n      if num > 0\n\
    \        return num\n      else\n        num = num - num % i\n      end\n    end\n\
    \    0\n  end\n</code>\n<|/ q |>\n<| c |>\nYour solution does work, though it\
    \ is rather inefficient. You are doing a lot of unnecessary operations in your\
    \ while loop.\n<|/ c |>\n<| c |>\nYour code is O(n^2) complexity. Try to do it\
    \ in O(n), it will probably be faster.\n<|/ c |>\n<| c |>\n- I thought so. I was\
    \ trying to make it work using a while loop but couldn't figure out how to do\
    \ it without an additional array.\n<|/ c |>\n<| c |>\n- I am not expecting anybody\
    \ to give me an answer, but if you can point me in the right direction or show\
    \ me some code, that would be great.\n<|/ c |>\n<| c |>\nO(n) is an important\
    \ concept to understand. If you have a `while` loop, think of the number of iterations\
    \ of the loop and how long it takes to do that iteration. You'll see that the\
    \ total time is equal to the sum of all those iterations. You'll also notice that\
    \ your approach does not work because the `while` loop is doing way too many operations.\
    \ What I mean by that is that the `while` loop should be able to iterate over\
    \ each item in your array only once, and this can be achieved by storing each\
    \ item in a separate array, then iterating over the separate array. I'll try to\
    \ post an example later.\n<|/ c |>\n<| a |>\nAs mentioned in the comments, a more\
    \ efficient implementation would be this:\n<code>", "  return arr.map {|x| x >\
    \ 0 ? x : x[-1]}.uniq.length\nend", "    num = arr[0]\n    count = 0\n    while\
    \ num >= 0\n        num = num / 10\n        count += 1\n    end\n    return count\n\
    end", "  arr.each do |num|\n    sum += num\n  end\n  return sum if sum > 0\n \
    \ sum = 0\n  arr.each do |num|\n    sum += num if num > 0\n  end\n  return sum\
    \ if sum > 0\n  sum = 0\n  arr.each do |num|\n    sum += num if num > 0\n  end\n\
    \  return sum\nend\n</cell>\n<cell>\nassert count_nums([]) == 0\nassert count_nums([-1,\
    \ 11, -11]) == 1\nassert count_nums([1, 1, 2]) == 3\n</cell>\n<text>\nB. Combining\
    \ Arrays\nBe sure that arrays are not combined using + or += because that creates\
    \ a new array and changes the original array. To combine two arrays use Ruby's\
    \ built-in methods: + and <<.", "    count = 0\n    arr.each do |num|\n      \
    \  count = 1 if num.negative? || num.negative? && num.first < 0\n        count\
    \ = 1 if num.negative? && num.first > 0\n        count += 1 if num.positive? &&\
    \ num.first > 0\n    end\n    return count\nend", "  # Write your code here.\n\
    \  sum = 0\n  sums = arr.map { |n| sum+=n.to_s.split('').inject(:+) }\n  sums.select\
    \ { |i| i > 0 }.length\nend", "\tarr.each do |num|\n\t\tif num < 0\n\t\t\tfirst_num\
    \ = num.abs\n\t\t\tfirst_num = first_num.divmod(10)[0]\n\t\t\tnum = -first_num\n\
    \t\tend\n\t\tif num > 9\n\t\t\tcount = 1\n\t\t\twhile num > 0\n\t\t\t\tcount +=\
    \ num % 10\n\t\t\t\tnum /= 10\n\t\t\tend\n\t\telse\n\t\t\tcount = 1\n\t\t\twhile\
    \ num > 0\n\t\t\t\tcount += num % 10\n\t\t\t\tnum /= 10\n\t\t\tend\n\t\tend\n\t\
    \treturn count if count > 0\n\tend\n\treturn 0\nend", "  return arr.inject(0)\
    \ {|sum,x| sum + x.abs }\nend\n</cell>\n<code language=julia-0.6>\ncount_nums([-2,\
    \ -1, 1, 2, 3, 11])\n</cell>\n<text>\nThe count_nums function works correctly\
    \ for arrays of integers, but fails for arrays of floats. To make count_nums work\
    \ for arrays of floats, you could use count_nums(arr) .== length(arr.), but this\
    \ would be inaccurate for arrays of floats. In general for arrays of any type,\
    \ you should just use .==, since this will also work for subarrays of different\
    \ lengths. For arrays of Float64s, however, you will need to use count_nums(arr)\
    \ .== length(arr).", "  arr.reduce(0) {|sum, digit| sum + digit if digit.to_i\
    \ > 0 }\nend\n</cell>\n<text>\nThe above function can be called like this:", " \
    \ arr.inject(0) {|sum, el| sum + el if el >= 0 }\nend\n</cell>\n<cell>\ncount_nums(arr)\n\
    </cell>\n<text>\nQuestion 6\nWrite a function to find the maximum integer in an\
    \ array. Use the count_nums helper function you wrote earlier.", "  if arr.empty?\
    \ || arr.size == 0\n    return 0\n  else\n    arr.each_with_index do |n, i|\n\
    \      if n.is_a? Bignum\n        if n <= 0\n          n = (-(n).to_i).abs\n \
    \       end\n        digit_sum = 0\n        digits = n.to_s.split(//)\n      \
    \  digits.each_with_index do |d, j|\n          digit_sum += (d - '0').abs\n  \
    \        if j <= digits.length - 1 && !(j == digits.length - 1)\n            digit_sum\
    \ += digits[j + 1].abs\n          end\n        end\n        digit_sum > 0 && i\
    \ + 1 != arr.size ? i + 1 : i\n      else\n        i + 1 == arr.size ? i + 1 :\
    \ i\n      end\n    end\n  end\nend", "  arr.each do |num|\n    if num < 0\n \
    \     num *= -1\n      num -= (num.to_s.first[-1] < '0') ? 1 : 0\n    end\n  \
    \  nums = num.to_s.chars.map(&:to_i)\n    unless nums.all? { |i| i > 0 }\n   \
    \   nums.each { |i| i -= 1 }\n    end\n    arr.pop if nums.size < arr_size\n \
    \ end\n  arr.count\nend\n</code>\n<|/ a tags=ruby,sorting,arrays dscore=0 |>\n\
    <| c |>\nHi, thanks for the reply! I really appreciate the effort. Though I did\
    \ try this approach earlier, I failed because I wanted the elements of the array\
    \ to be sorted as such. I think I may have asked the wrong question.\n<|/ c |>\n\
    <| c |>\n, Please see my latest update, does that do what you wanted? If not,\
    \ can you give an example of an input and an expected output please.\n<|/ c |>\n\
    <| a tags=ruby,sorting,arrays |>\nThis problem can be solved by converting array\
    \ into hash which have sum of digits as its key and value as a array. So, every\
    \ time you find an element with sum > 0, you push element to its value, otherwise,\
    \ you push it to its key.\nAfter you find the sum > 0, you can sort hashes by\
    \ value, and get result.\n<code>", "  arr.inject(0) { |sum, num| sum + num if\
    \ num > 0 }\nend\n</cell>\n<code language=julia-0.5>\ncount_nums([-2, -1, 2, 2])\n\
    </cell>\n<text>\nExercise\nModify the above function to return 0 for an empty\
    \ array and 1 for an array with negative numbers.", "  count = 0\n  arr.each do\
    \ |i|\n    if i < 0\n      i = -i\n    end\n    count = count + i / 10 ** i %\
    \ 10\n  end\n  count\nend", "  digits = arr.map(&:abs).select(&:odd?).map(&:to_s).size\n\
    \  return 0 if arr.size == 0 \n  return 1 if arr.size == 1 && digits.zero?\n \
    \ return ((digits/10).ceil - digits).floor\nend", "    arr.sort!\n    count =\
    \ 0\n    i = 0\n    while i < arr.length\n        i += 1\n        if arr[i] <\
    \ 0\n            arr[i] += 10\n            count += 1 \n        elsif arr[i] >\
    \ 9\n            count += 1 \n        end\n    end\n    return count\nend\n</cell>\n\
    <text>\nNow that we have our function, we can test it on some examples:", "  arr.empty?\
    \ || arr.any? { |n| n < 0 } ? arr.first : count_nums(arr.drop(1))\nend", "   \
    \ arr.each do |num|\n        if num < 0 && (num > -num).abs\n            count_nums((num\
    \ / 10).to_a)\n        else\n            true\n        end\n    end\nend", " \
    \   count = 0\n    remain = arr.dup\n    remain = remain.reverse if remain[0]\
    \ < 0 # if first is negative\n    remain.each_with_index do |x, i|\n        count\
    \ += 1\n        if remain[i] <= 0\n            count -= 1\n        end\n    end\n\
    \    return count\nend\n</code>\n<|/ a tags=ruby,arrays dscore=1 |>\n<| c |>\n\
    Thanks this is exactly what I was looking for\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  arr.each do |n|\n    if n < 0\n      n += 10 # Add the first digit.\n      n\
    \ -= 1\n    end\n    sum = 0\n    while n >= 10\n      sum += n % 10\n      n\
    \ /= 10\n    end\n    sum += n\n    if sum > 0\n      sum += 1 if sum == 10 #\
    \ Add the last digit.\n    end\n    break if sum > 0\n  end\nend", "    arr.each_index\
    \ do |i|\n        sum = arr[i]\n        if sum < 0\n            sum += arr[i].to_s.size\n\
    \        end\n        sum += 1 if arr.count(i) > 0\n        arr[i] = sum\n   \
    \ end\n    arr.count\nend", "  # Only change code below this line\n  arr.sort\n\
    \  sum = 0\n  arr[0..-1].each do |i|\n    sum += i if i.to_s.split('').reverse.inject(0,\
    \ :+) > 0\n  end\n  sum\nend", "  sum = 0\n  arr.each do |x|\n    sum += x\n \
    \   if sum > 0\n      return sum\n    end\n  end\n  return 0\nend", "  arr.each\
    \ do |n|\n    if n.is_a? Integer\n      n = n.abs\n    else\n      n = n.to_i\n\
    \    end\n    count = 0\n    while n != 0\n      count += 1\n      n /= 10\n \
    \   end\n    return count\n  end\n  0\nend", "  arr.each_with_index.inject(0)\
    \ do |sum, (x, i)|\n    sum + x.to_s.length if x.to_s.length > ((arr[0]<0).zero?\
    \ ? 0 : arr[0].to_s.length-i)\n  end\nend", "  # Only the numbers that are not\
    \ negative are relevant.\n  arr.each do |x|\n    if x.to_i > 0\n      count =\
    \ count1(n)\n      return count\n    end\n  end\n  count = 0\n  arr.each do |x|\n\
    \    if x.is_a? Float\n      return 0\n    end\n    count = count1(n)\n    return\
    \ count\n  end\n  return 0\nend", "  arr.each_with_index do |i, idx|\n    idx\
    \ == arr.size - 1 && return i if i < 0\n    idx == 0 && return i if i < 0\n  \
    \  idx == arr.size - 1 && return i if i > 9\n    arr[idx].to_s.length > 0 && return\
    \ i if arr[idx].to_s.scan(/^[0-9]/).size > 0\n  end\n  0\nend\n  ", "  arr.each_with_index\
    \ do |x, i|\n    (arr[i] < 0).nil? && (arr[i].digit(-1) == 0) &&\n      (arr[i].digit(0)\
    \ == 0) &&\n      (arr[i].digit(1) == 0) &&\n      (arr[i].digit(2) == 0) &&\n\
    \      (arr[i].digit(3) == 0) &&\n      (arr[i].digit(4) == 0) &&\n      (arr[i].digit(5)\
    \ == 0) &&\n      (arr[i].digit(6) == 0) &&\n      (arr[i].digit(7) == 0) &&\n\
    \      (arr[i].digit(8) == 0) &&\n      (arr[i].digit(9) == 0) &&\n      (arr[i].digit(10)\
    \ == 0) &&\n      (arr[i].digit(11) == 0) &&\n      (arr[i].digit(12) == 0) &&\n\
    \      (arr[i].digit(13) == 0) &&\n      (arr[i].digit(14) == 0) &&\n      (arr[i].digit(15)\
    \ == 0) &&\n      (arr[i].digit(16) == 0) &&\n      (arr[i].digit(17) == 0) &&\n\
    \      (arr[i].digit(18) == 0) &&\n      (arr[i].digit(19) == 0) &&\n      (arr[i].digit(20)\
    \ == 0) &&\n      (arr[i].digit(21) == 0) &&\n      (arr[i].digit(22) == 0) &&\n\
    \      (arr[i].digit(23) == 0) &&\n      (arr[i].digit(24) == 0) &&\n      (arr[i].digit(25)\
    \ == 0) &&\n      (arr[i].digit(26) == 0) &&\n      (arr[i].digit(27) == 0) &&\n\
    \      (arr[i].digit(28) == 0) &&\n      (arr[i].digit(29) == 0) &&\n      (arr[i].digit(30)\
    \ == 0) &&\n      (arr[i].digit(31) == 0) &&\n      (arr[i].digit(32) == 0) &&\n\
    \      (arr[i].digit(33) == 0) &&\n      (arr[i].digit(34) == 0) &&\n      (arr[i].digit(35)\
    \ == 0) &&\n      (arr[i].digit(36) == 0) &&\n      (arr[i].digit(37) == 0) &&\n\
    \      (arr[i].digit(38) == 0) &&\n      (arr[i].digit(39) == 0) &&\n      (arr[i].digit(40)\
    \ == 0) &&\n      (arr[i].digit(41) == 0) &&\n      (arr[i].digit(42) == 0) &&\n\
    \      (arr[i].digit(43) == 0) &&\n      (arr[i].digit(44) == 0) &&\n      (arr[i].digit(45)\
    \ == 0) &&\n      (arr[i].digit(46) == 0) &&\n      (arr[i].digit(47) == 0) &&\n\
    \      (arr[i].digit(48) == 0) &&", "  arr.each_index do |i|\n    arr[i] = count_digits(arr[i])\
    \ if arr[i] != 0\n  end\n  return arr.sum if arr.sum != 0\n  return -1\nend",
  "  # Set up an empty dictionary to hold your result:\n  result = {}\n  # Loop through\
    \ the array:\n  arr.each do |num|\n    # If this number is negative, flip the\
    \ sign of the first digit:\n    if num.negative?\n      num = -num\n    end\n\
    \    # Loop through the digits:\n    num.digits.each do |digit|\n      # If the\
    \ current digit key does not exist in result, add it:\n      result[[digit]] =\
    \ result[[digit]].to_i + 1\n    end\n  end\n  # Return the result:\n  result\n\
    end", "  sum = nil\n  arr.each do |el|\n    if el >= 0\n      el = el.abs\n  \
    \    el = el / 10 while el > 0\n      sum += el\n    else\n      sum += -el\n\
    \    end\n  end\n  sum\nend\n</cell>\n<cell>\n%timeit count_nums(arr)\n</cell>\n\
    <cell>\n%timeit count_nums(arr_long)\n</cell>\n<text>\nUsing map and count is\
    \ slower, even for small arrays:", "  # Your code here\n  return count\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
