name: HumanEval_146_specialFilter
language: rb
prompt: "# Write a function that takes an array of numbers as input and returns \n\
  # the number of elements in the array that are greater than 10 and both \n# first\
  \ and last digits of a number are odd (1, 3, 5, 7, 9).\n# For example:\n# specialFilter([15,\
  \ -73, 14, -15]) => 1 \n# specialFilter([33, -2, -3, 45, 21, 109]) => 2\ndef specialFilter(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_specialFilter\n\
  \    candidate = method(:specialFilter)\n    assert_equal(0, candidate.call([5,\
  \ -2, 1, -5]))\n    assert_equal(1, candidate.call([15, -73, 14, -15]))\n    assert_equal(2,\
  \ candidate.call([33, -2, -3, 45, 21, 109]))\n    assert_equal(4, candidate.call([43,\
  \ -12, 93, 125, 121, 109]))\n    assert_equal(3, candidate.call([71, -2, -33, 75,\
  \ 21, 19]))\n    assert_equal(0, candidate.call([1]))\n    assert_equal(0, candidate.call([]))\n\
  \  end\nend\n"
completions: ["  # Hint: You can use the method .length on an array and use the \n\
    \  # method .each to do something with each element in a \n  # loop.\n  # Hint:\
    \ You can use the method .modulo on the elements of the array \n  # to see whether\
    \ the first or last element is an odd number.\n  # If you need to use modulo,\
    \ make sure to convert it to an \n  # integer (using .to_i).\n  \n  # Your code\
    \ here!\n  nums.length.times do |i|\n    if nums[i] > 10\n      if nums[i].modulo(2)\
    \ == 1\n        nums.delete(i)\n      end\n    end\n  end\n  nums.length\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nI added the comment at the end in hopes\
    \ of improving performance but I am getting an error when I run that. I will post\
    \ the code here and edit my original post. Do you see any errors?\n<|/ c |>\n\
    <| c |>\nI got it to work! Thanks so much! I spent a good amount of time trying\
    \ to figure out how to delete an item from a array and your post has helped me\
    \ out a ton!\n<|/ c |>\n<| c |>\nNo problem! Glad to help. If this answers your\
    \ question please accept it so other people who stumble across it may see it as\
    \ the accepted answer when they search for it in the future.\n<|/ c |>\n<| c |>\n\
    It certainly does, and I will definitely accept it. One more question: When I\
    \ run this for large arrays, like `[33, -2, -3, 45, 21, -4, 90]`, my program gets\
    \ hung up and sometimes crashes. Is there a way I can modify the algorithm to\
    \ stop this from happening?\n<|/ c |>\n<| c |>\nI'm glad it helped! As for the\
    \ crashing problem, I have no idea why it would happen. Could you edit your post\
    \ to include the code that's causing the problem?\n<|/ c |>\n<| a |>\nThis should\
    \ do it\n<code>", "  i = 0\n  count = 0\n  while i < nums.length\n    if nums[i]\
    \ > 10 && nums[i].to_s.length % 2 == 1 && nums[i].to_s.length <= 3 && nums[i].to_s.length\
    \ >= 4\n      count += 1\n    i += 1\n  end\n  count\nend", "  # Fill in the code\
    \ below to pass the test\n  return nil unless nums.size > 0\n  odd_nums = nums.grep(&:odd?).size\n\
    \  even_nums = nums.size - odd_nums\n  return even_nums if even_nums > 0 && odd_nums\
    \ > 0\n  return odd_nums\nend", "    return nums.count { |n| n > 10 && n.odd?\
    \ && (n =~ /[1|3|5|7|9]/).nil? }\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays\
    \ dscore=0 |>\n<code>", "    count = 0\n    array = nums\n    array.each do |num|\n\
    \        count = count + 1 if num > 10 and num.to_i**1 % 2 != 0 and num.to_i**1\
    \ % 2 != 0\n    end\n    count\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nTry this one:\n<code>", "    nums.each do |num|\n        if num > 10 and\
    \ num.first % 2 == 1 and num.last % 2 == 1\n            puts nums.size\n     \
    \   end\n    end\nend", "  count = 0\n  i = 0\n  while i < nums.length\n    if\
    \ nums[i] > 10\n      if i % 2 == 1\n        count += 1\n      end\n    end\n\
    \    i += 1\n  end\n  return count\nend", "  nums.each do |num|\n    if num >\
    \ 10 && num.odd? && num.first % 2 != 0 && num.last % 2 != 0 \n      return nums.size\n\
    \    end\n  end\nend", "  nums.inject(0) do |s, x|\n    if x > 10\n      s +=\
    \ 1\n    elsif x % 2 != 0\n      s += 1\n    elsif nums[nums.length - 1] % 2 !=\
    \ 0\n      s += 1\n    end\n  end\nend", "    count = 0\n    numbers.each do |x|\n\
    \        if x > 10\n            if x.to_i > 10 and x.to_i.to_i.odd?\n        \
    \        count += 1\n            end\n        end\n    end\n    return count\n\
    end", "  nums.count{|n| n > 10 && n % 2 == 1 && n % 2 == 1}\nend", "  count =\
    \ 0\n  for i in nums\n    if i > 10 && i%2 != 0 && i.modulo(10).modulo(2) == 0\n\
    \      count += 1\n    end\n  end\n  return count\nend", "  count = 0\n  for i\
    \ in nums\n    if i.is_a? Integer\n      count += 1 if i.odd? && i.first % 2 ==\
    \ 1 && i.last % 2 == 1\n    end\n  end\n  return count\nend", "  count = 0\n \
    \ for num in nums\n    if num > 10 and num > 0 and num % 1 == 0 && num % 2 ==\
    \ 1 && num % 3 == 1 && num % 4 == 1\n      count = count + 1\n    end\n  end\n\
    \  return count\nend", "  nums.inject(0) { |counter, num| \n    if num > 10 &&\
    \ num > nums.first && num > nums.last\n      counter + 1\n    end\n  }\nend\n\
    </code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nI see that my question was very\
    \ close to yours. I appreciate you taking the time to do so. Thank you\n<|/ c\
    \ |>\n<| c |>\nYou're welcome. You're right to ask a question but make sure it's\
    \ phrased properly and include what you've tried so others don't think you're\
    \ just looking for a straight up solution to the problem.\n<|/ c |>\n<| c |>\n\
    I wasn't trying to be rude. I appreciate you taking the time to help me. Thank\
    \ you so much.\n<|/ c |>\n<| c |>\n: Don't worry. As I stated before, your question\
    \ was very close to mine so I thought I'd point you in the right direction instead\
    \ of getting you an entire solution. Also, I'm glad I could help. Good luck!\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  count = 0\n  for num in nums\n    if\
    \ num > 10 and num.odd? and num.odd?\n      count += 1\n    end\n  end\n  return\
    \ count\nend", "  i = 0\n  while i < nums.length\n    i += 1\n    if nums[i] >\
    \ 10 and nums[i] % 2 == 1 and nums[i] % 2 != nums[i-1] % 2\n      return true\n\
    \    end\n  end\n  return false\nend", "  count = 0\n  for i in nums \n    if\
    \ i > 10 and i%2 == 0 and i%2 == 1 \n      count += 1\n    end\n  end\n  return\
    \ count\nend", "  count = 0\n  \n  nums.each do |num|\n    if num > 10 && num.odd?\
    \ && num.modulo(10) == 1 && num.modulo(10).odd? \n      count += 1\n    end\n\
    \  end\n  \n  return count\nend\n</cell>\n<cell>", "  count=0\n  for i in nums\n\
    \    if i>10 && nums.first.odd? && nums.last.odd?\n      count+=1\n    end\n \
    \ end\n  count\nend", "  count = nums.length\n  for i in (0...count-1)\n    val\
    \ = nums[i]\n    if val > 10 and val % 2 != 0 and\n       nums[i+1]%2 != 0 &&\
    \ nums[i-1]%2 != 0\n      return count\n    end\n  end\n  0\nend", "    nums.count{|i|\
    \ i % 2 == 0 && i.to_i > 10 && i.to_i.to_i%2 == 1}\nend", "  count = 0\n  nums.each\
    \ do |n|\n    count += 1 if n > 10 && n % 2 == 1 && n % 5 == 1 && n % 7 == 1 \n\
    \  end\n  count\nend", "  # Write your code below this line\n  return 0", "  \
    \  nums.each do |num|\n        if num > 10 && num % 1 == 0 && num % 2 == 1\n \
    \           nums.size\n        end\n    end\nend", "  n = 0\n  n.odd? \n  n.odd?\
    \ \n  n.odd? \n  nums.each do \n    n += 1 if nums[$].odd? && nums[$].odd? &&\
    \ nums[$].odd? \n  end \n  return n \nend \n</code>\n<|/ a tags=ruby,count,ruby-on-rails,conditional-statements\
    \ |>\n<| c |>\nThe question says \"Write a function that takes an array of numbers\
    \ as input and returns \nthe number of elements in the array that are greater\
    \ than 10 and both \nfirst and last digits of a number are odd (1, 3, 5, 7, 9).\"\
    \n<|/ c |>\n<| c |>\nThe question says \"Write a function that takes an array\
    \ of numbers as input and returns \nthe number of elements in the array that are\
    \ greater than 10 and both \nfirst and last digits of a number are odd (1, 3,\
    \ 5, 7, 9).\" Please see edit\n<|/ c |>\n<| c |>\nYes, but that doesn't help anyone\
    \ understand what they were looking for. Your answer was good but doesn't seem\
    \ to help the OP anymore. Though it does help future visitors.\n<|/ c |>\n<| c\
    \ |>\nThe question said \"Write a function that takes an array of numbers as input\
    \ and returns \nthe number of elements in the array that are greater than 10 and\
    \ both \nfirst and last digits of a number are odd (1, 3, 5, 7, 9).\" I thought\
    \ that made sense. I don't see how my answer doesn't help.\n<|/ c |>\n<| c |>\n\
    It's just that I didn't think that the question was clear enough. Now that you\
    \ mention it it's obvious why it didn't help.\n<|/ c |>\n<| a dscore=0 tags=ruby,count,ruby-on-rails,conditional-statements\
    \ |>\n<code>", "    i = 0\n    odds = 0\n    while i < nums.length\n        j\
    \ = i + 1\n        while j < nums.length\n            if nums[j] >= 10 and (nums[j]\
    \ % 2 != 0 or nums[j - 1] % 2 != 0)\n                odds += 1\n            j\
    \ += 1\n        i += 1\n    return odds\nend", "    nums.count { |i| i > 10 }\
    \ + nums.count { |i| i.odd? && i.first % 2 == 1 }\nend\n</code>\n<|/ a |>\n<|\
    \ a tags=ruby |>\nHere's another way:\n<code>", "  nums.inject(0) { |count, element|\
    \ count += 1 if element > 10 and (element%2 == 1 and (element/2 != 1)) }\nend\n\
    </code>\nIf this is your first time using inject in Ruby, then read this article\
    \ on inject.\nIf you're not already familiar with it, you should read this article\
    \ on Ruby loops and array functionality.\n<|/ a dscore=1 |>\n<| a tags=arrays,ruby\
    \ |>\nI guess you mean something like this\n<code>", "  nums.map do |num|\n  \
    \  return 0 if num > 10\n    num % 10 == 0\n  end.reduce(:+) == nums.length\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails dscore=0 |>\n<| a dscore=0 tags=ruby,ruby-on-rails\
    \ |>\nI feel like this is cheating, but I wanted to post this anyway:\n<code>",
  "    nums.count { |n| n % 2 != 0 && n % 10 == 1 && n % 100 != 11 }\nend\n</code>\n\
    We can see that it's easy to find the number of elements in an array\nthat satisfy\
    \ a condition.  It just needs to look at the count of \nelements for which the\
    \ block is true.\n<code>\n[15, -73, 14, -15].count { |n| n % 2 != 0 && n % 10\
    \ == 1 && n % 100 != 11 }\n</code>\nThe next logical step would be to find the\
    \ number of elements in the array \nthat satisfy the condition.  We only need\
    \ to count the ones for which \nthe block is true.  \n<code>\n[15, -73, 14, -15].count\
    \ { |n| n % 2 != 0 && n % 10 == 1 && n % 100 != 11 } \n=> 1\n</code>\nThis isn't\
    \ very useful but we can use the count method as an alternative \nto using the\
    \ select method to select only the elements that satisfy the \ncondition.\n<code>\n\
    [15, -73, 14, -15].count(&:odd?)\n=> 1\n</code>\nWe can make this a little more\
    \ useful using Ruby enumerators\n<code>\n[15, -73, 14, -15].count { |n| n % 2\
    \ != 0 && n % 10 == 1 && n % 100 != 11 } \n=> 1", "  count = 0\n  nums.each do\
    \ |n|\n    if n > 10 && n.first % 2 == 1 && n.last % 2 == 1\n      count += 1\n\
    \    end\n  end\n  count\nend", "  sum = 0\n  for i in nums\n    sum += (i>10\
    \ && i%(10*2+1)==1 && i%(10*2+3)==1)\n  end\n  return sum\nend", "  nums.inject(0)\
    \ { |acc, el| acc + (el > 10 && el % 1 == 0 && (el % 2 == 1 || el % 2 == 0)) }\n\
    end", "  return 0 if nums.nil? || nums.length == 0\n  nums.each do |num|\n   \
    \ digits = num.to_s.split('')\n    if (digits.length > 1 && digits[0] % 2 != 0\
    \ && digits[digits.length - 1] % 2 != 0) \n      return 1\n    end\n  end\n  0\n\
    end", "    nums.count{ |x| x > 10 and x.odd? and x.to_s.chars.first.to_i.odd?\
    \ }\nend", "  nums.count{ |x| x > 10 and (nums.first % 2) == 1 and (nums.last\
    \ % 2) == 1 }\nend", "  return nums.select { |n| n > 10 && n % 2 == 1 && n % 1\
    \ != 0 }.size \nend", "    nums.each do |num|\n        if num > 10 and num.odd?\n\
    \            if num.first % 2 == 1 and num.last % 2 == 1\n                puts\
    \ num\n            end\n        end\n    end\nend", "  count = nums.length\n \
    \ for i in 0..count-1\n    if (nums[i] > 10 && nums[i].even? && nums[i].odd?)\n\
    \      count -= 1\n    end\n  end\n  count\nend", "  count = 0\n  even = 0\n \
    \ odd = 1\n  while nums.any? do\n    count += 1\n    if nums[count].odd? and nums[count].even?\n\
    \      even += 2\n    elsif nums[count].odd?\n      odd += 1\n    end\n    break\
    \ if nums[count] > 10\n    break if nums[count].odd? and nums[count].even?\n \
    \ end\n  return odd * 2 + even\nend", "  nums.count { |n| n > 10 && n % 2 == 0\
    \ && n % 1 == 0 }\nend", "  nums.count{ |n| n > 10 } + nums.select { |n| n % 2\
    \ == 1 }.count{ |n| n % 2 == 1 }\nend", "  \nend", "  count = 0\n  nums.each do\
    \ |n|\n    count += 1 if n % 10 > 0 && n.first % 2 == 1 && n.last % 2 == 1\n \
    \ end\n  return count\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| a tags=ruby\
    \ dscore=1 |>\nHere is an alternative:\n<code>", "  count = 0\n  \n  for i in\
    \ 0..(nums.length - 1)\n    count = count + 1\n    if ((nums[i] > 10) & (nums[i].odd?\
    \ & nums[i].odd?)) \n      count = count + 1\n      \n  return count\nend", " \
    \ nums.count(nums.grep(/[1-9][0-9]|\\//).count&(1&nums.length) == 2)\nend", " \
    \   nums.count { |num| num > 10 and (num.odd? == true && num.odd? == true) }\n\
    end", "    count = 0\n    odd_count = 0\n    even_count = 0\n    even_odd_count\
    \ = 0", "    i = 0\n    nums.each do |x|\n        if x > 10 and (nums[i]%2 ==\
    \ 1 and nums[i-1]%2 == 1)\n            i+=1\n        else\n            i=0\n \
    \       end\n    end\n    return i+1\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\nThis has O(n\xB2) complexity instead of O(n).\n<|/ c |>\n<| c |>\nYou're\
    \ right. But O(n\xB2) does not mean that it's bad. It's the same for O(n log(n))\
    \ and O(nlogn). O(n\xB2) means linear (with n being the number of elements). Of\
    \ course you can always use other methods than O(n\xB2) to achieve the same.\n\
    <|/ c |>\n<| c |>\nThank you so much for your answer. While this works perfectly\
    \ for this particular problem, I didn't really understand how I could use it in\
    \ other situations. I guess I can try to rewrite my problem to see how I could\
    \ use the solution you provided. Thank you again.\n<|/ c |>\n<| a dscore=0 |>\n\
    Here is how I would do it:\n<code>\nnums = [15, -73, 14, -15]", "\tcount = 0\n\
    \tfor i in nums\n\t\tcount += 1\n\t\tif i.to_i() > 10\n\t\t\tbreak\n\t\tend\n\t\
    \tif i.to_i%2 == 1 and i.to_i%2 == 0\n\t\t\tcount += 1\n\t\tend\n\tend\n\treturn\
    \ count\nend", "    count = 0\n    i = 0\n    while (i < nums.length)\n      \
    \  currNum = nums[i]\n        digits = currNum.to_s.split(\"\")\n        if (digits.length\
    \ > 0 && digits[0] == \"1\" && digits[-1] == \"1\")\n            count += 1\n\
    \        i += 1\n    return count\n    ", "  i = 0\n  while i < nums.length\n\
    \    if nums[i] > 10 \n      i += 1 \n      next \n    elsif nums[i] % 2 != 0\
    \ && nums[i-1] % 2 == 0 && nums[i+1] % 2 == 0\n      i += 1\n    else\n      i\
    \ += 1\n    end\n  end\n  return i\nend", "    nums.count { |x| x > 10 && x.odd?\
    \ && x.modulo(10).odd? } \nend", "  count = 0\n  nums.each do |n|\n    break count\
    \ += 1 if ((n.to_i.to_s == n.to_s).to_i & n.to_i.odd? &\n      ((n.to_i.to_s.rjust(len(n),\
    \ 1).to_i == n.to_s.rjust(len(n), 1).to_i)).to_i)\n  end\n  return count\nend",
  "  nums.inject(0) { |sum, num| sum + 1 if num % 2 != 0 && num % 4 != 0 && num %\
    \ 8 != 0 }\nend\n</cell>\n<cell>\nspecialFilter([15, -73, 14, -15]) #=> 1\nspecialFilter([33,\
    \ -2, -3, 45, 21, 109]) #=> 2\n</cell>\n<text>\nTo use this function, first you\
    \ must define the function and pass to it the argument to be filtered. Then, call\
    \ specialFilter with that argument:", "  sum = 0\n  for i in nums\n    if i >\
    \ 10\n      sum++\n    if i[0]%2 != i[-1]%2\n      sum++\n  return sum\nend",
  "  nums.each do |n|\n    if (n >= 10) && (n % 2 == 0) && ((n / 10) % 2 == 0)\n \
    \     puts n\n    end\n  end\nend", "  count = 0\n  while nums.length > 0\n  \
    \  if nums.last % 2 != 0 && nums.first % 2 != 0\n      count += 1\n    end\n \
    \   nums.pop\n  end\n  count\nend", "  nums.inject(0){|s,n| s += 1 if n >= 10\
    \ && n.even? && n.odd? && (n.to_s[0..-2].to_i(10) % 2 == 1)}\nend", "\tspecialFilterCount\
    \ = 0\n\tfor i in nums\n\t\tif i > 10 \n\t\t\tspecialFilterCount = specialFilterCount\
    \ + 1\n\t\tend\n\tend\n\tspecialFilterCount = specialFilterCount - 1\n\tif specialFilterCount\
    \ < 1\n\t\tspecialFilterCount = 0\n\tend\n\tif nums[0] % 2 == 0 and nums[-1] %\
    \ 2 == 0\n\t\tspecialFilterCount = 0\n\tend\n\treturn specialFilterCount\nend",
  "\tnums.count{ |n| n > 10 && nums.all? { |n| n.odd? || n % 2 == 1 } }\nend", "\t\
    count = 0\n\tnums.each do |num|\n\t\tcount += 1 if num > 10 and num[0] % 2 and\
    \ num[-1] % 2\n\tend\n\treturn count\nend", "\tnums.each do |num|\n\t\tif num\
    \ > 10 and (num mod 2 == 0 or num mod 4 == 0)\n\t\t\tcount += 1\n\t\tend\n\tend\n\
    \tcount\nend", "\tn = length(nums)\n\tcounter = 0\n\t\n\tfor i in 0..n-1\n\t\t\
    if (nums[i] >= 10 && nums[i+1] % 2 == 1 && nums[i-1] % 2 == 1)\n\t\t\tcounter\
    \ += 1\n\t\n\treturn counter\nend\n</cell>\n<code language=julia-1.4>", "    nums.each\
    \ do |num|\n        if num > 10\n            if (num % 2 == 0 && num.even? &&\
    \ num.first % 2 == 1) || (num % 2 == 1 && num.even? && num.last % 2 == 1)\n  \
    \              puts \"#{num}\"\n            end\n        end\n    end\nend\n</code>\n\
    Outputs:\n<code>\n15\n14\n33\n2\n45\n21\n109\n</code>\n<|/ a tags=arrays,ruby\
    \ |>\n<| c |>\nPlease don't post only code as an answer, but also provide an explanation\
    \ of what your code does and how it solves the problem of the question. Answers\
    \ with an explanation are usually more helpful and of better quality, and are\
    \ more likely to attract upvotes.\n<|/ c |>\n<| c |>\nThanks for your suggestion.\
    \ I'll keep it in mind.\n<|/ c |>\n<| c |>\nI have edited my answer, but i think\
    \ it is better to learn from his answer. I tried to do my own answer but it didn't\
    \ work and i couldn't find the mistake. Also, i think that his answer is much\
    \ more elegant and efficient.\n<|/ c |>\n<| c |>\nYes your solution will work,\
    \ but it\u2019s inefficient. Instead of iterating over your array and checking\
    \ each item, you could use `each_cons` or something similar.\n<|/ c |>\n<| c |>\n\
    Okay, thank you for your effort, i really appreciate that.\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is another way with Enumerable#slice_when:\n<code>", "    # initialize\
    \ number of elements \n    nElems = 0\n    # loop through all the numbers in the\
    \ array\n    nums.each do |num|\n        # if the number is greater than 10\n\
    \        if num > 10\n            # and if it has a first and last digit that\
    \ are odd\n            if num % 2 != 0 && num % 3 != 0\n                numElems\
    \ = numElems + 1\n            end\n        end\n    end\n    return numElems\n\
    end\n</cell>\n<text>\nQ5\nWrite a function that takes a positive number and returns\
    \ the sum of all digits. \nFor example, 5258 and 5302 have summands 5, 2, and\
    \ 3. If you add the number to the sum and then divide it by 10, you would get\
    \ 52.5 / 10 = 5.2.\nWrite a function that takes a positive number and returns\
    \ whether its sum is a palindrome.", "\tnums.count{ |n| n > 10 && n % 1 == 0 &&\
    \ n % 2 == 1 }\nend\nprint specialFilter([15, -73, 14, -15])\nprint specialFilter([33,\
    \ -2, -3, 45, 21, 109])\n</cell>\n<text>\nChallenge 3\nWrite a function to determine\
    \ if a number is prime (a prime number is a number that is only evenly divisible\
    \ by 1 and itself ). A prime number is a natural number greater than 1 that has\
    \ no positive divisors other than 1 and itself. For instance, the number 3 has\
    \ no divisors other than 1 and itself, as is evident from the above-mentioned\
    \ facts:", "  nums.inject(0) do |sum, number|\n    sum + (number > 10 && number.odd?\
    \ && number.to_s.rsplit('', 2)[0].odd?)\n  end\nend", "    numbers = 0\n    nums.each\
    \ do |n|\n      if(n.to_s.split(\"\").each {|x| x.odd?})\n        numbers +=1\n\
    \      end\n    end\n    numbers\n  end", "  result = nums.count{|x| x > 10 &&\
    \ x.first % 2 == 1 && x.last % 2 == 1}\n  \n  if result == nums.size\n    \"no\
    \ numbers are above 10 and first and last digits are odd\"\n  else\n    result\n\
    \  end\nend", "    count = 0\n    \n    for n in nums\n        if n.to_i >= 10\
    \ && n.to_i%2 == 0 && n.to_i%2 != 0 && n.to_i%2 != 1\n            count += 1\n\
    \        end\n    end\n    \n    return count\nend\n</cell>\n<cell>", "  nums.each\
    \ { |num| return num if num > 10 && num.odd? && num.first % 2 == num.last % 2\
    \ }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI don't think so, but I've added\
    \ some examples and a link to the Ruby documentation.\n<|/ c |>\n<| c |>\nMy apologies,\
    \ you're absolutely right. I must have misread that part of the docs. I appreciate\
    \ your help.\n<|/ c |>\n<| c |>\nNo problem! Glad to help!\n<|/ c |>\n<| a tags=ruby\
    \ dscore=2 |>\nUse Array#select:\n<code>\nnumbers = [2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\nodd_digits\
    \ = numbers.select { |n| n % 10 == 0 }", "  n = nums.length\n  i = 0\n  s = 0\n\
    \  while i < n\n    if nums[i] > 10\n      s = s + 1\n    i = i + 1\n  end\n \
    \ return s\nend", "  nums.select { |x| x > 10 }.length.to_s + \" elements\\n\"\
    \ + nums.select {|x| x > 10 && x[0,1]%2 == 1 }.length.to_s + \" elements\\n\"\
    \ + nums.select {|x| x > 10 && x[0,1]%2 == 1 && (x.last.to_i%2 == 1) }.length.to_s\
    \ + \" elements\"\nend\n</cell>\n<cell>", "  # Loop through each number in the\
    \ array\n  count = 0\n  for i in 0...nums.length\n    # if the number is greater\
    \ than 10, then add it to the count\n    if nums[i] > 10\n      count += 1 \n\
    \      # if the first and last digits are odd then add it to the count\n     \
    \ if nums[i] % 2 != 0 && nums[0...i].last % 2 != 0\n        count += 1\n     \
    \ end\n    end\n  end\n  \n  # return the number of elements in the array that\
    \ are greater than 10 and both \n  # first and last digits are odd\n  return count\n\
    end\n</cell>\n<cell>", "    nums.each do |num|\n        if num > 10 && num % 2\
    \ == 1 && num % 2 != 0\n            counter += 1\n        end\n    end\n    counter\n\
    end", "    nums.reduce(0) { |acc, n| acc + (n == -10 && n % 2 == 1) }\nend", " \
    \ return nums.select do |n| \n    n.to_i < 10 && n.to_i.even? && n.to_i.odd? \n\
    \  end.length\nend", "  odds = nums.map {|x| x % 2 == 1}.inject(:+)\n  (nums.count(&:odd)\
    \ == 1 && nums.count(&:odd) == odds) ? nums.length : 0\nend\n</cell>\n<cell>",
  "  nums.count { |x| x > 10 && x.odd? && x.even? && (x.first.odd? && x.last.odd?)\
    \ }\nend\n</cell>\n<cell>", "    nums.each do |n|\n        if n > 10 and (n %\
    \ 1 == 0 or n % 5 == 0)\n            count += 1\n        end\n    end\n    count\n\
    end\n</code>\n<|/ a |>\n<| a dscore=0 tags=ruby |>\nI guess your assignment is\
    \ something like the following:\n\"Write a program which checks if an array of\
    \ numbers contains all prime numbers and prints them. Your program should take\
    \ a list of numbers and a number. If both numbers are equal, the program should\
    \ output the number itself.\"\nFor this assignment you can use Sieve of Eratosthenes\
    \ algorithm. Here is a link to a good article about it.\n<|/ a |>\n<| a dscore=0\
    \ |>\nAs other have already pointed out, the sieve of Eratosthenes is exactly\
    \ what you need here. However if you are interested in how you could implement\
    \ it, here's an example. First of all, we'll need a method that determines whether\
    \ a number is prime, whether it is divisible by another number or not, etc...\n\
    <code>", "  nums.map! { |n| n % 10 }\n  nums.uniq.sort.each do |n|\n    return\
    \ 0 if n % 2 == 0\n  end\n  nums.length\nend\nputs specialFilter([15, -73, 14,\
    \ -15])\nputs specialFilter([33, -2, -3, 45, 21, 109])", "  count=0\n  nums.each\
    \ {|a| if (a>10 && a.to_s.reverse.chars.grep(/[13579]/).all?(&:odd?)) count+=1}\n\
    \  return count\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays |>\n<| c |>\n\
    Thanks for the answer. Can you please explain the line- `a.reverse.chars.grep(/[13579]/).all?(&:odd?)`\
    \ ? It seems to be doing some magic to me.\n<|/ c |>\n<| c |>\n`grep` will return\
    \ an array that contains the matched element if any one of the array elements\
    \ that match the pattern is true, otherwise it will return nil.", "  counter =\
    \ 0\n  nums.each do |n|\n    if n < 10 and n % 2 != 0\n      counter += 1\n  \
    \  end\n  end\n  counter\nend", "    nums.each do |num|\n        if num.to_s ==\
    \ \"-10\"\n            return 1\n        end\n        if num.to_s == \"-11\"\n\
    \            return 1\n        end\n        if num.to_s == \"-12\"\n         \
    \   return 1\n        end\n        if num.to_s == \"-13\"\n            return\
    \ 1\n        end\n        if num.to_s == \"-14\"\n            return 1\n     \
    \   end\n        if num.to_s == \"-15\"\n            return 1\n        end\n \
    \       if num.to_s == \"-16\"\n            return 1\n        end\n        if\
    \ num.to_s == \"-17\"\n            return 1\n        end\n        if num.to_s\
    \ == \"-18\"\n            return 1\n        end\n        if num.to_s == \"-19\"\
    \n            return 1\n        end\n        if num.to_s == \"-20\"\n        \
    \    return 1\n        end\n        if num.to_s == \"-21\"\n            return\
    \ 1\n        end\n        if num.to_s == \"-22\"\n            return 1\n     \
    \   end\n        if num.to_s == \"-23\"\n            return 1\n        end\n \
    \       if num.to_s == \"-24\"\n            return 1\n        end\n        if\
    \ num.to_s == \"-25\"\n            return 1\n        end\n        if num.to_s\
    \ == \"-26\"\n            return 1\n        end\n        if num.to_s == \"-27\"\
    \n            return 1\n        end\n        if num.to_s == \"-28\"\n        \
    \    return 1\n        end\n        if num.to_s == \"-29\"\n            return\
    \ 1\n        end\n        if num.to_s == \"-30\"\n            return 1\n     \
    \   end\n        if num.to_s == \"-31\"\n            return 1\n        end\n \
    \       if num.to_s == \"-32\"\n            return 1\n        end\n        if\
    \ num.to_s == \"-33\"\n            return 1\n        end\n        if num.to_s\
    \ == \"-34\"\n            return 1\n        end\n        if num.to_s == \"-35\"\
    \n            return 1\n        end\n        if num.to_s == \"-36\"\n        \
    \    return 1\n        end\n        if num.to_s == \"-37\"\n            return\
    \ 1\n        end\n        if num.to_s == \"-38\"\n            return 1\n     \
    \   end\n        if num.to_s == \"-39\"\n            return 1\n        end\n \
    \       if num.to_s == \"-40\"\n            return 1\n        end\n        if\
    \ num.to_s == \"-41\"\n            return 1\n        end\n        if num.to_s\
    \ == \"-42\"\n            return 1\n        end\n        if num.to_s == \"-43\"\
    \n            return 1\n        end\n        if num.to_s == \"-44\"\n        \
    \    return 1\n        end\n        if num.to_s == \"-45\"\n            return\
    \ 1\n        end\n        if num.to_s == \"-46\"\n            return 1\n     \
    \   end\n        if num.to_", "    # Your code here\n    # Hint: nums.count is\
    \ the function you need\n    nums.count { |num| num > 10 && num.to_a.first[0]\
    \ & num.to_a.last[0] & num.to_a.last == 1 }\nend\nprint specialFilter([15, -73,\
    \ 14, -15])\nprint specialFilter([33, -2, -3, 45, 21, 109])\n</code>\n<|/ a dscore=2\
    \ tags=arrays,ruby |>\n<| c |>\nI tried to convert it into something Ruby like,\
    \ but I keep getting an error message I haven't seen before: undefined method\
    \ `to_a' for nil:NilClass. Can you help me to figure out why this is? Thanks in\
    \ advance!\n<|/ c |>\n<| c |>\nYes, that worked thanks! I'm now wondering if I\
    \ can add a more sophisticated filter condition. For example, if I wanted to include\
    \ all numbers that have a first digit of even number and either all first digits\
    \ are odd OR last digits are odd. Do you know how I could go about doing that?\
    \ Thanks again!\n<|/ c |>\n<| a |>\nThis should help you get started:\n<code>",
  "  result = nums.reduce( 0, lambda x,y| x + y if (y > 10) and (y % 2 == 0) and (x\
    \ % 2 == 1) else 0 )\nend", "  # Your code goes here\n  \nend", "    nums.select\
    \ {|num| num > 10 && num.odd? && num.first % 2 == 1 && num.last % 2 == 1}.size\n\
    end\n</cell>\n<code language=conda-env-tests-py>", "    count = 0\n    nums.each\
    \ do |n|\n        if n > 10 and n.first % 2 == 1 and n.last % 2 == 1\n       \
    \     count += 1\n        end\n    end\n    count\nend\n</code>\nThe above is\
    \ more elegant but this does it in a simple way.\n<|/ a |>\n<| a dscore=2 |>\n\
    One of the simplest way to achieve your goal is\n<code>", "  count = 0\n  nums.each\
    \ do |num|\n    count += 1 if num > 10 && num.odd? && num.first % 2 == 1 && num.last\
    \ % 2 == 1\n  end\n  count\nend", "  nums.count{ |i| i % 10 == 1 && i % 5 == 1\
    \ }\nend", "  count = 0\n  for i in nums\n    if i > 10 && nums[0,1] % 2 != 0\
    \ && nums[-1,0] % 2 != 0\n      count = count + 1\n    end\n  end\n  return count\n\
    end", "  counter = 1\n  for i in nums\n    if (i > 10) and (i % 2 == 1) and (i\
    \ % 2 == 0)\n      counter += 1\n    end\n  end\n  counter\nend", "    count =\
    \ 0\n    nums.each do |num|\n        num % (10..99) \n        first == 1 && last\
    \ == 1 \n        count = count + 1\n    end\nend\nprint specialFilter([15, -73,\
    \ 14, -15])\nprint specialFilter([33, -2, -3, 45, 21, 109])\n</code>\n<|/ q dscore=0\
    \ tags=ruby |>\n<| c |>\n`arr` is an integer, not a array\n<|/ c |>\n<| c |>\n\
    What is the question?\n<|/ c |>\n<| c |>\n`arr` is the number. How does it become\
    \ an array in the code?\n<|/ c |>\n<| c |>\n`arr.each do |i|` should work just\
    \ fine, isn't it?\n<|/ c |>\n<| c |>\n`arr.each` should iterate over each element\
    \ in `arr`. `arr` is just a number `1`.\n<|/ c |>\n<| a |>\nYou're really close.\
    \ You're just missing some very basic Ruby principles. Let's walk through what\
    \ you're trying to do:\n<code>", "    count = 0\n    odd_count = 0\n    odd_count\
    \ = 0\n    odd_count = 0\n    odd_count = 0\n    for i in nums\n        digit\
    \ = i % 10\n        if (digit == 10) or (odd_count == 1)\n            count +=\
    \ 1\n            odd_count = 0\n        else\n            if odd_count == 0\n\
    \                odd_count += 1\n            if odd_count == 1\n             \
    \   if digit % 2 == 1\n                    odd_count = 0\n                else\n\
    \                    odd_count += 1\n        end \n    end\n    count\nend\n</cell>\n\
    <code language=julia-1.0>\nspecialFilter([15,-73,14,-15])\n</cell>\n<text>\nWrite\
    \ a function that takes a string as input and returns the number of words that\
    \ are longer than three characters in the string.\nFor example, \n    stringFilter(\"\
    The quick brown fox jumps over the lazy dog\") => 4\n    stringFilter(\"The quickest\
    \ brown fox jumps over the worst dog\") => 1", "    nums.count {|x| x > 10 &&\
    \ x % 2 == 0 && x.to_s.chars.first.to_i%2 != 0}\nend", "  nums.sort!\n  count\
    \ = 0\n  for i in nums\n    if i > 10\n      count += 1\n      break if i%2 ==\
    \ 1 and i != 0\n    end\n  end\n  return count\nend", "    nums.count { |n| n\
    \ > 10 && nums[n.to_i-1] % 2 == 1 && nums[n.to_i-1] % 2 == 0 }\nend\n</cell>\n\
    <cell>", "    nums.select { |num| num > 10 and num.odd? and num.odd? }.size\n\
    end", "    nums.count { |x| x > 10 && nums.first % 2 != 0 && nums.last % 2 !=\
    \ 0 }\nend", "  return nums.count{|x| (x % 10 > 10 && x % 10 % 2 == 1)} + nums.count{|x|\
    \ (x % 10 > 10 && x % 10 % 2 == 0)}\nend", "  count = 0\n  nums.each do |num|\n\
    \    count += 1 if num > 10 && ((num % 10) == 1 && num % 100 != 11)\n    count\
    \ += 1 if num > 10 && ((num % 10) == 0 && num % 100 != 10)\n  end\n  count\nend",
  "  i = 0\n  while i < nums.length\n    unless nums[i] > 10 and (nums[i] % 2 == 0\
    \ or nums[i] % 10 == 0)\n      return i + 1\n    end\n    i += 1\n  end\n  return\
    \ nums.length\nend", "    count = 0\n    big10s = nums.select {|n| n % 10 == 0\
    \ and n % 2 == 1}\n    odd = big10s.select {|n| n % 2 != 1}\n    even = big10s.select\
    \ {|n| n % 2 == 1}\n    big10s.each do |num|\n        if num % 10 == 1 and num\
    \ % 2 == 1\n            count += 1\n        elsif num % 10 == 1 and num % 2 !=\
    \ 1\n            count += 1\n        end\n    end\n    return count\nend", " \
    \   count = 0\n    \n    # Write your code here.\n    \n    return count\n</cell>\n\
    <text>\nProblem 5\nThe Fibonacci sequence is defined by the formula:", "  nums.each\
    \ do |num|\n    if num > 10 and num % 2 == 1 and num / 2 % 2 == 1\n      puts\
    \ num\n    end\n  end\nend", "    nums.inject(0) {|sum, n| sum + n if n > 10 &&\
    \ n.first % 2 == 1 && n.last % 2 == 1}\nend", "    count = 0\n    nums.each do\
    \ |num|\n        if num > 10 && num.to_s.split('').first.to_i % 2 != 0 && num.to_s.split('').last.to_i\
    \ % 2 != 0\n            count += 1\n        end\n    end\n    return count\nend\n\
    </cell>\n<cell>\nspecialFilter([15, -73, 14, -15])\n</cell>\n<cell>\nspecialFilter([33,\
    \ -2, -3, 45, 21, 109])\n</cell>\n<text>\nSum All Numbers In An Array\nWrite a\
    \ function that takes a positive integer as input and returns the sum of the even\
    \ numbers from 1 to that number.", "    nums.to_a.each do |num|\n        unless\
    \ num > 10\n            if num % 2 != 0 && num % 2 != 1\n                nums.delete(num)\n\
    \            end\n        end\n    end\n    nums.length\nend", "    nums.count{\
    \ |x| (x > 10 and (nums.first&1 == 1 and nums.last&1 == 1))}\nend\n</cell>\n<cell>\n\
    specialFilter([15, -73, 14, -15])\n</cell>\n<cell>\nspecialFilter([33, -2, -3,\
    \ 45, 21, 109])\n</cell>\n<text>\nThe .count method works in two ways, one which\
    \ returns a scalar number and the other which returns an Enumerator which can\
    \ be used for iteration. The second method can be invoked like so:", "  # TODO:\
    \ Write your solution below:\n  nums.select{ |x| x > 10 }.count{ |x| x > 10 }.count{\
    \ |x| x > 10 }\nend\n</cell>\n<cell>", "  count = 0\n  for i in 0..(nums.length-1)\n\
    \    # Check if the number is odd and if both the first and last \n    # digits\
    \ are odd.\n    if nums[i] % 2 == 0 && (nums[i-1] % 2 == 0 || (nums[i-1] % 2 !=\
    \ 0 && nums[i+1] % 2 == 0))\n      count += 1\n    end\n  end\n  return count\n\
    end\n</code>\nHope that helps!\n<|/ a tags=ruby,arrays dscore=0 |>\n<| c |>\n\
    Hi, thank you for your help, unfortunately I only know a little bit of Ruby, could\
    \ you please explain to me what I'm doing? Thank you!\n<|/ c |>\n<| c |>\nThis\
    \ code is not \"ruby\" but it is understandable by someone with little ruby knowledge\
    \ ;) Please see my answer for a more ruby way\n<|/ c |>\n<| a |>\n<code>", " \
    \ i = 0\n  j = 0\n  num_count = 0\n  while (i < nums.length)\n    if (nums[i]\
    \ >= 10 and (nums[i].odd_first == true and nums[i].odd_last == true))\n      num_count\
    \ += 1\n    end\n    i += 1\n  end\n  return num_count\nend", "    count = 0\n\
    \    odd = false\n    first = nums[0] % 10\n    last = nums[-1] % 10\n    odd\
    \ = odd or first % 2\n    odd = odd or last % 2\n    \n    nums.each do |n|\n\
    \        if n % 2 == 0 and n != 0 && n % 10 == 0 && n % 2 != 0\n            count\
    \ += 1\n        end\n    end\n    count\nend", "    nums.each do |num|\n     \
    \   if num > 10 && num.to_a.first % 2 == 1 && num.to_a.last % 2 == 1\n       \
    \     puts num\n        end\n    end\nend", "    # Solution\n    nums.count {\
    \ |num| num > 10 && (num.odd?) && (num.first(2).odd?) }\nend\n</cell>\n<code language=julia-0.6>",
  "    count = 0\n    for num in nums\n        if num > 10 and num > nums.first and\
    \ num > nums.last\n            count += 1\n        end\n    end\n    return count\n\
    end", "  count = 0\n  for i in nums\n    if i > 10 and i.odd? and i.odd?\n   \
    \   count += 1\n    end\n  end\n  count\nend", "    count = 0\n    nums.each do\
    \ |num|\n        count = count + 1 if num > 10 and num % 2 == 0 and num.first\
    \ % 2 == 1 and num.last % 2 == 1\n    end\n    return count\nend", "  count =\
    \ 0\n  for num in nums\n    if (num > 10 && num.to_s[1, 1] % 2 == 1 && num.to_s[-1,\
    \ 1] % 2 == 1)\n      count += 1\n    end\n  end\n  return count\nend\n</cell>\n\
    <cell>", "    count = 0\n    nums.each do |num|\n        if num > 10 && num %\
    \ 2 != 0 && num % 4 != 0 && num % 8 != 0\n            count += 1\n        end\n\
    \    end\n    return count\nend", "  return nums.count { |x| x > 10 && x.odd?\
    \ && (x.first % 2).odd? && (x.last % 2).odd? }\nend", "  i = 0\n  sum = 0\n  while\
    \ i < nums.length\n    sum = sum + nums[i]\n    if nums[i] > 10 and nums[i] %\
    \ 2 == 1 and nums[i-1] % 2 == 1 and nums[i+1] % 2 == 1 then\n      return sum\n\
    \    end\n    i = i + 1\n  end\n  return sum\nend", "  odd = nums.find {|n| n\
    \ % 2 == 1}\n  even = nums.find {|n| n % 2 == 0}\n  \n  if even && odd\n    even.succ\n\
    \  elsif even && !odd\n    even\n  elsif odd && odd\n    odd.succ\n  elsif odd\
    \ && !odd\n    odd\n  else\n    0\n  end\nend", "    nums.each {|x| puts x+1 if\
    \ (x > 10 && x.odd? && x.odd? && x.odd?)}\nend", "  count = 0\n  for i in nums\n\
    \    if i > 10 && i.odd? && i.odd?\n      count += 1\n    end\n  end\n  count\n\
    end", "    num = nums.count{|num| num > 10 && num.odd? && num.first.odd? && num.last.odd?}\n\
    end\n</cell>\n<code language=xeus-cling-cpp14>", "    nums.map {|n| n.odd? }.inject(:&)\n\
    end ", "  nums.count{|x| x > 10 and nums.first[/\\d/] == nums.last[/\\d/] && nums.first[/\\\
    d/] % 2 == 1 && nums.last[/\\d/] % 2 == 1} \nend\n</cell>\n<code language=julia-0.4>",
  "  special=0\n  count=0\n  for i in nums\n    if i>10 \n      count=count+1\n  \
    \    if i%2==1 and i%4==1\n        special=special+1\n    end\n  end\n  return\
    \ count\nend\n</code>\nNow I rewrote the code as follows.\n<code>", "  nums.inject\
    \ { |sum, element| sum + element if element > 10 && element % 2 == 0 && element\
    \ % 100 != 0}\nend", "    i = 0\n    odd = false\n    even = false\n    odd =\
    \ false\n    even = false\n    while i < nums.length\n        if nums[i] > 10\
    \ \n            even = !even\n            odd = odd && even\n            i = i\
    \ + 1\n        end\n    end\n    return i\nend\n</cell>\n<code language=julia-1.0>",
  "  return nums.count{ |x| x > 10 and x.first % 2 == 1 }\nend", "  count = 0\n  \n\
    \  nums.each do |num|\n    if num > 10 && num.first % 2 != 0 && num.last % 2 !=\
    \ 0\n      count += 1\n    end\n  end\n  \n  count\nend", "    nums.each do |num|\n\
    \        if num > 10\n            if num % 2 == 0 && num % 100 % 2 != 0\n    \
    \            puts num\n            end\n        end\n    end\nend", "  # Your\
    \ code here\nend", "  nums.inject(0) {|result, num|\n    result = result + (num\
    \ > 10 && num.to_s.gsub(/\\d/, '').to_i[1..-1].odd?)\n  }\nend", "    return nums.count\
    \ {|num| num > 10 and (num[0] % 2).even? and (num[-1] % 2).odd? } \nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\n`nums[-1]` should be `nums[nums.size - 1]`\n<|/ c\
    \ |>\n<| c |>\n`nums[-1]` should be `nums[nums.size-1]`\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>\nnums = [1, -2, 3, 45, 21, -109]\nnums.count { |x| x.to_i > 10 }\n\
    \ => 3\nnums.select { |x| x.to_i > 10 && (x[x.to_i-1] % 2).odd? }.count { |x|\
    \ x.to_i > 10 && (x[x.to_i-1] % 2).even? }\n => 2\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\n`nums[-1]` should be `nums[nums.size-1]`\n<|/ c |>\n<| c |>\n`nums.select\
    \ { |x| x.to_i > 10 && (x[x.to_i-1] % 2).odd? }.count { |x| x.to_i > 10 && (x[x.to_i-1]\
    \ % 2).even? }` could also be written as `nums.select { |x| x.to_i > 10 }.count\
    \ { |x| x[x.to_i-1] % 2 == 0 }`.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nspecialFilter(nums)\n\
    \  # => nil\n</code>\nLet's begin by writing down a simple method that takes a\
    \ single integer and outputs true/false based on some conditions.  I'll use my\
    \ favorite condition, that is, \"is this number odd?\" and that it is greater\
    \ than 10.  I'll write it down first:\n<code>", "  count = 0\n  for i in nums\
    \ do\n    if i > 10 then \n      count+=1\n      if i % 2 != 1 then \n       \
    \ if i mod 10 ~= 0 then \n          if i mod 10 ~= 0 then \n            count\
    \ += 1\n        end\n      end\n    end\n  end\n  return count\nend", "  nums.each\
    \ do |n|\n    if n % 10 > 0 and (n % 100 % 10 == 0 and n % 100 % 100 == 0)\n \
    \     return nums.count(n)\n    end \n  end\n  0\nend", "    return nums.count\
    \ { |x| (x > 10) && (x.modulo(10).odd?) && (x.modulo(10).even?) }\nend", "   \
    \ count = 0\n    nums.each do |num|\n        if num > 10 && num % 1 == 0 && num\
    \ % 2 == 1\n            count += 1\n        end\n    end\n    return count\nend\n\
    </cell>\n<cell>", "  count = 0\n  for i in nums\n    count += 0 if i > 10 && i.to_s[0...1].to_i%2\
    \ != 0 && (i.to_s[0...-1].to_i%2 != 0) \n  end\n  count\nend\n</cell>\n<code language=julia-1.5>\n\
    @time begin\n  filter(x -> x > 10, [-7, -3, 4, 3, 8, 2, -7, -7, -4, 3, -1, 5,\
    \ -3]) == 3\nend\n</cell>\n<code language=julia-1.5>\n@time begin\n  filter(x\
    \ -> x > 10, specialFilter([-7, -3, 4, 3, 8, 2, -7, -7, -4, 3, -1, 5, -3])) ==\
    \ 3\nend\n</cell>\n<text>\nPractice time for map functions\nFor each of the following\
    \ problems, write a solution that uses the map function. You may reuse the following\
    \ helper functions: range, inexact, abs.", "  count = 0\n  \n  nums.each do |num|\n\
    \    if num > 10\n      if num % 2 == 1 && num % 3 == 1\n        count += 1\n\
    \      end\n    end\n  end\n  \n  count\nend", "    nums.each do |num|\n     \
    \   if num > 10\n            if num % 2 == 0 && num % 3 != 0 && num % 5 != 0\n\
    \                return nums.count\n            end\n        end\n    end\n  \
    \  return 0\nend", "    count = 0\n    nums.each do |n|\n        count += 1 if\
    \ n % 2 == 1 && n % 3 != 0 && n % 5 != 0\n        count += 1 if n % 2 == 1 &&\
    \ n % 3 == 0 && n % 5 != 0\n        count += 1 if n % 2 == 1 && n % 3 != 0 &&\
    \ n % 5 == 0\n        count += 1 if n % 2 == 0 && n % 3 != 0 && n % 5 != 0\n \
    \       count += 1 if n % 2 == 0 && n % 3 == 0 && n % 5 != 0\n        count +=\
    \ 1 if n % 2 == 0 && n % 3 != 0 && n % 5 == 0\n        count += 1 if n % 2 ==\
    \ 0 && n % 3 == 0 && n % 5 == 0\n    end\n    return count\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails,arrays |>\n<| c |>\nGood answer but you should replace\
    \ `nums` with something else like `num`. And you just need to check `n % 2 !=\
    \ 0 && n % 3 != 0` instead of all those `&&`s.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  result = 0\n  for num in nums\n    if num > 10 and num.odd? == true and num.first.odd?\
    \ == true and num.last.odd? == true\n      result += 1\n    end\n  end\n  return\
    \ result\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nYou don't need `==\
    \ true`. `odd?` is already a boolean.\n<|/ c |>\n<| a tags=ruby |>\n<code>", " \
    \ nums.each do |num|\n    if num.to_s.include?('10') && num.to_s.include?('9')\
    \ && num.to_s.include?('0') && num.to_s.include?('1')\n      return 1\n    end\n\
    \  end\n  0\nend", "    nums.count{ |x| x > 10 && x % 2 == 0 && x % 3 == 0 &&\
    \ x % 5 == 0 }\nend\n</cell>\n<text>\nWe can then rewrite the function to take\
    \ an array of numbers as input. \nThis will allow us to use the filter() method\
    \ as a way to filter the array \nand use the count() method which we can use to\
    \ count the number of elements.", "  nums.each_index do |i|\n    if nums[i] >=\
    \ 10 && nums[i].odd? && nums[i].even? && (nums[i] % 2 == 0)\n      return i\n\
    \    end\n  end\nend", "    return nums.count(nums > 10 and nums.first(2).odd?\
    \ and nums.last(2).odd?)\nend", "  nums.count{ |x| x > 10 && x.odd? && ((x % 11).odd?\
    \ || (x % 10).odd?) }\nend\n</code>\nIt works with multiple conditions very easily,\
    \ just add them to the block and separate them with &&:\n<code>", "  count = 0\n\
    \  for i in nums\n    if i > 10 && nums.first % 2 == 1 && nums.last % 2 == 1\n\
    \      count += 1\n    end\n  end\n  return count\nend", "  nums.each do |num|\n\
    \    if num > 10 and num.to_s.split(\"\").map{|x| x.to_i}.reduce(:+) % 2 == 1\
    \ and num.to_s.split(\"\").map{|x| x.to_i}.reduce(:+) % 2 == 0\n      return num\n\
    \    end\n  end\n  0\nend", "    nums.count{ |x| (x > 10 && x.odd? && x.even?\
    \ && x.first%2 == 0) }\nend\n</code>\nAnd here are some tests to show you that\
    \ these two approaches behave the way you expect:\n<code>\nrequire 'minitest/autorun'",
  "  nums.count.select { |x| x > 10 and (x % 2 == 0) and (x % 1 == 1) }\nend\n</cell>\n\
    <text>\nMore Exercises\nWrite a function using select that takes two input parameters\
    \ and returns true if any element in the array meets the conditions described\
    \ above. Hint: use select on enumerable objects.", "  return nums.count { |num|\
    \ num > 10 and num.odd? && num.first % 2 == 1 && num.last % 2 == 1 }\nend", " \
    \ count = 0\n  for i in nums \n    if i > 10 && i.first % 2 == 1 && i.last % 2\
    \ == 1 \n      count += 1\n      \n  return count\nend", "    nums.each {|n| \n\
    \        n.odd?\n        n.odd? && n.odd? && n.odd?\n    }.count\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI got this error after trying your code. ``` NoMethodError:\
    \ undefined method `odd?' for nil:NilClass\n        from filtering_exercises.rb:5:in\
    \ `block (2 levels) in <main>'\n        from filtering_exercises.rb:5:in `each'\n\
    \        from filtering_exercises.rb:5:in `block in <main>'```\n<|/ c |>\n<| c\
    \ |>\nThat's because you're calling `odd?` on a `nil` object. `odd?` only makes\
    \ sense on `Integer` objects.\n<|/ c |>\n<| a |>\n<code>", "  nums.select{|num|\
    \ num > 10 }.size\nend", "    nums.count{ |num| num > 10 && num.odd? && num.odd?\
    \ }\nend\n</code>\nIf you only want to return an array with those numbers, you\
    \ can do this:\n<code>", "    nums.count{ |n| n < 10 && n % 2 == 0 && n % 1 ==\
    \ 0 }\nend\n</code>\nAnd now we're ready to get into ruby's array methods.  Recall\
    \ that ruby is an object orientated language and as such has its own set of functions\
    \ to manipulate arrays.  In this case we will be using #count which counts the\
    \ number of elements that match a block.\nThere are several ways to do this, one\
    \ way is to use the method #select which returns a new array containing only the\
    \ elements that match your block:\n<code>\narr = [15, -73, 14, -15]\narr.select\
    \ { |n| n < 10 && n % 2 == 0 && n % 1 == 0 } # => [1, 3, 5, 7, 9]\n</code>\nYou\
    \ can use this same method in other scenarios where you want to return a list\
    \ of values that match a block:\n<code>\narr = [15, -73, 14, -15]\narr.select\
    \ { |n| n < 10 && n % 2 == 0 && n % 1 == 0 }.reduce :+ => 1\narr.select { |n|\
    \ n < 10 && n % 2 == 0 && n % 1 == 0 }.reduce :+ => 2\n</code>\nYou can also use\
    \ the method #reject, which returns a new array containing only the elements that\
    \ do not match your block:\n<code>\narr = [15, -73, 14, -15]\narr.reject { |n|\
    \ n < 10 && n % 2 == 0 && n % 1 == 0 }", "    count = 0\n    \n    if nums.size\
    \ > 0\n        \n        nums.each do |num|\n            if num > 10\n       \
    \         count += 1\n                \n                if nums.size - 1 != count\n\
    \                    count += 1\n                end\n            end\n      \
    \  end\n    end\n    \n    count\nend\n</cell>\n<cell>", "  count = 0\n  odd_count\
    \ = 0\n  first_odd_count = 0\n  last_odd_count = 0\n  \n  for n in nums\n    if\
    \ (n<10) then \n      count = count + 1\n      next \n    end \n    \n    if (n>10\
    \ && odd_count != 0) then\n      if (n%2==1) then\n        if (n>1 && first_odd_count!=0)\
    \ then\n          odd_count = odd_count + 1\n          first_odd_count = first_odd_count\
    \ + 1\n        else\n          odd_count = odd_count + 1\n        end \n     \
    \ else\n        if (n>1 && last_odd_count!=0) then\n          odd_count = odd_count\
    \ + 1\n          last_odd_count = last_odd_count + 1\n        else\n         \
    \ odd_count = odd_count + 1\n        end \n      end \n    else\n      odd_count\
    \ = 0\n      first_odd_count = 0\n      last_odd_count = 0\n    end \n  end \n\
    \  return count\nend ", "  # TODO: Write code here\nend", "  count = 0\n  for\
    \ i in nums\n    if i > 10 && i.odd? && i.first % 2 == 1 && i.last % 2 == 1\n\
    \      count += 1\n    end\n  end\n  count\nend", "  return nums.select{|x| x\
    \ > 10}.select{|x| x.odd? && (x.first&x.last.odd?)}.size\nend\n</code>\n<|/ a\
    \ |>\n<| a dscore=0 tags=ruby |>\n<code>", "    nums.map do |n|\n        n % 2\
    \ != 0\n        n % 2 != 0 && n / 2 % 1 == 1\n    end.count {|x| x > 10 }.times\n\
    end\n</code>\n<|/ a |>\n<| c |>\nGood answer. Could you explain how this works?\n\
    <|/ c |>\n<| c |>\n`if n % 2 != 0 && n / 2 % 1 == 1` means:", "    i = 0\n   \
    \ odd = 0\n    even = 0", "    nums.count{|i| i > 10 && i.odd? && i.first & i.last.odd?}\n\
    end\n</cell>\n<cell>", "    even = nums.select{|num| num % 2 == 0}\n    odd =\
    \ nums.select{|num| num % 2 != 0}\n    return even.size + odd.size if even &&\
    \ odd\n    even.size + odd.size if even\nend", "  count = 0\n  nums.each do |num|\n\
    \    if num > 10 && num % 2 != 0 && num % 1 != 0 && num % 3 == 0\n      count\
    \ += 1\n    end\n  end\n  return count\nend", "  # TODO: Your code here!\nend",
  "  result = 0\n  for num in nums\n    if num > 10 and num % 1 == 0 and num % 2 ==\
    \ 1\n      result += 1\n    end\n  end\n  result\nend\nprint(specialFilter([15,\
    \ -73, 14, -15]))", "  count = 0\n  nums.each do |number|\n    if number > 10\
    \ and (number % 2).odd? and (number % 100).odd? \n      count += 1\n    end\n\
    \  end\n  count\nend", "    count = 0\n    i = 0\n    while i < nums.length\n\
    \        if nums[i] > 10\n            count += 1\n            i += 2\n       \
    \ else\n            i += 1\n    end\nend", "    count = 0\n    nums.each do |num|\n\
    \        if (num > 10) && (num.odd?) && (num.odd?)\n            count += 1\n \
    \       end\n    end\n    return count\nend\n</cell>\n<code language=julia-1.0>",
  "    count=0\n    i=0\n    while i < nums.length\n       if (nums[i] > 10 && nums[i]\
    \ % 2 == 1 && nums[i] % 2 == 1)\n            count += 1\n       i += 1\n    end\n\
    end", "    nums.each do |n|\n        if n > 10 and (n % 2 == 1 and (n % 10 % 2\
    \ == 0 or n % 10 % 2 == 1)) \n            puts n\n        end\n    end\nend\n\
    </code>\nI hope you find this helpful and that it is of some help. If you have\
    \ any questions about what I've done or how it works, feel free to ask.\n<|/ a\
    \ tags=ruby |>\n<| a dscore=0 |>\nThe Ruby way to do this is not to iterate over\
    \ the array, to find the answer. You should use Enumerable#find or Enumerable#find_all.\
    \ This is really a perfect example of when you can use the power of Ruby's Enumerable.\n\
    First let's define a method that tells us whether a number is odd; we'll need\
    \ this later.\n<code>", "    nums.each do |num|\n        num > 10 && num.odd?\
    \ && num.odd? && num.odd?\n        count = num.count { |x| x > 10 && x.odd? }\n\
    \        count > 1 ? count : nil\n    end\nend", "    count = 0\n    nums.each\
    \ do |num|\n        oddNum = num.odd? \n        firstOddNum = num.odd?\n     \
    \   firstOddNum = true if num.odd? and num.first % 2 == 1\n        lastOddNum\
    \ = num.odd?\n        lastOddNum = true if num.odd? and num.last % 2 == 1\n  \
    \      \n        count += 1 if oddNum and firstOddNum and lastOddNum\n    end\n\
    \    \n    return count\nend\n</cell>\n<cell>\nspecialFilter([15, -73, 14, -15])\
    \ # => 1\nspecialFilter([33, -2, -3, 45, 21, 109]) # => 2\n</cell>\n<cell>", " \
    \   nums.count.select { |n| n >= 10 && (n%2 == 0 || n%2 == 1) && (n%2==1 && !n%10)\
    \ }\nend", "  count = 0\n  odd_nums = []\n  even_nums = []\n  for num in nums\n\
    \    even = num % 2 == 0\n    odd = num % 2 != 0\n    if (even && odd) \n    \
    \  even_nums << num\n    elsif (even && !odd)\n      odd_nums << num\n    elsif\
    \ (!even && odd)\n      odd_nums << num\n    elsif (!even && !odd)\n      even_nums\
    \ << num\n    end\n  end\n  even_nums.uniq.size\nend\n</cell>\n<cell>", "  counter\
    \ = 1\n  for i in nums\n    if i > 10 && i.first % 2 == 1 && i.last % 2 == 1\n\
    \      counter += 1\n    end\n  end\n  counter\nend", "  return sum(nums.select\
    \ { |n| n >= 10 && ((n % 2).zero? || (n % 2 == 1 && (n % 4 == 0))) })\nend", " \
    \   count = 0\n    \n    evens = nums.select{|x| x.even?}\n    odds = nums.select{|x|\
    \ x.odd?}\n    \n    count = 0 if evens.empty?\n    count = count + 1 if odds.length\
    \ == 1 && odds[0].odd?\n    \n    count = 0 if evens.length == 0 && odds.length\
    \ == 0\n    \n    count\nend", "  nums.count{|n| n > 10} \nend\n</cell>\n<cell>\n\
    specialFilter([15, -73, 14, -15])\n</cell>\n<cell>\nspecialFilter([33, -2, -3,\
    \ 45, 21, 109])\n</cell>\n<cell>", "  return nums.count {|i| i > 10 && nums.first\
    \ % 2 == 0 && nums.last % 2 == 1} \nend", "    even = 0\n    odd = 1\n    num_odd\
    \ = nums.select {|num| num % 2 == 0 }\n    num_even = nums.select {|num| num %\
    \ 2 == 1 }\n    num_odd.each {|num| even += 1 }\n    num_even.each {|num| odd\
    \ += 1 }\n    if even > 1 && odd > 1\n        return even\n    else if even >\
    \ 1 && odd < 1\n        return odd\n    else if even < 1 && odd > 1\n        return\
    \ even\n    else if even < 1 && odd < 1\n        return odd\n    else\n      \
    \  return even\n    end\nend", "    nums.each do |num|\n        if num > 10 &&\
    \ num.to_s.last.odd? && num.to_s.first.odd?\n            return nums.size\n  \
    \      end\n    end\nend\n</cell>\n<text>\nIn the cell above, we wrote a function\
    \ that takes a single argument that is a number. This function looks at that number\
    \ and checks if it is greater than 10. If it is, it returns its size. If the number\
    \ is less than 10, the function does not return anything. How do we know that\
    \ this function works correctly? We could just run it and see what happens, but\
    \ we could also run it on different numbers and see what happens:", "  nums.count\
    \ {|num| num > 10 and (num.odd? and num.even?)}\nend", "  i=0\n  while i < nums.length\n\
    \     if nums[i] > 10\n         if nums[i+1]%2 == 1 && nums[i-1]%2 == 1\n    \
    \           return i+1\n         end\n     end\n     i += 1\n  end\n  return 0\n\
    end", "  sum = 0\n  even = 0\n  odd = 0\n  for i in nums\n    if i < 0\n     \
    \ break\n    if i > 0\n      sum += i\n      if i % 2 == 0\n        even = even\
    \ + 1\n      else \n        odd = odd + 1\n    end\n  end\n  sum > 10 and even\
    \ % 2 == 1 and odd % 2 == 1\nend\n</cell>\n<cell>", "    nums.map { |n| n % 2\
    \ == 1 && n % 5 == 1 && n % 7 == 1 }.length\nend", "  count = 0\n  \n  nums.each\
    \ do |num|\n    if num > 10 and (num % 2 != 0 or num / 2 == 1)\n      count +=\
    \ 1\n    end\n  end", "  nums.each do |num|\n    if num > 10 and num > num[0].odd?\
    \ and num > num[-1].odd?\n      return nums.length\n    end\n  end\n  return 0\n\
    end", "  nums.count { |x| x > 10 && nums.first(2).last.odd? }\nend", "    return\
    \ nums.select {|num| num > 10 && num.odd? && num.first%2==1 && num.last%2==1}.length\n\
    end\n</code>\nIn your case it will be:\n<code>\nspecialFilter([15, -73, 14, -15])\
    \ # => 1\nspecialFilter([33, -2, -3, 45, 21, 109]) # => 2\n</code>\nAnd so on...\n\
    <|/ a dscore=1 tags=ruby,ruby-on-rails |>\n<| a |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
