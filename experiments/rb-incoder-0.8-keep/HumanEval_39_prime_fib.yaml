name: HumanEval_39_prime_fib
language: rb
prompt: "# prime_fib returns n-th number that is a Fibonacci number and it's also\
  \ prime.\n# >>> prime_fib(1)\n# 2\n# >>> prime_fib(2)\n# 3\n# >>> prime_fib(3)\n\
  # 5\n# >>> prime_fib(4)\n# 13\n# >>> prime_fib(5)\n# 89\ndef prime_fib(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prime_fib\n\
  \    candidate = method(:prime_fib)\n    assert_equal(2, candidate.call(1))\n  \
  \  assert_equal(3, candidate.call(2))\n    assert_equal(5, candidate.call(3))\n\
  \    assert_equal(13, candidate.call(4))\n    assert_equal(89, candidate.call(5))\n\
  \    assert_equal(233, candidate.call(6))\n    assert_equal(1597, candidate.call(7))\n\
  \    assert_equal(28657, candidate.call(8))\n    assert_equal(514229, candidate.call(9))\n\
  \    assert_equal(433494437, candidate.call(10))\n  end\nend\n"
completions: ["\tif n == 0\n\t\tprime\n\telse\n\t\tif n == 1\n\t\t\t2\n\t\telse\n\t\
    \t\tif n % 2 == 0\n\t\t\t\tprime_fib(n / 2)\n\t\t\telse\n\t\t\t\tprime_fib(n /\
    \ 2 + 1)\n\t\t\tend\n\t\tend\n\tend\nend", "  i = 2\n  while i <= n and prime?(i)\
    \ << i\n  prime_fib_nth_number = i\nend", "    if n < 2\n        return n\n  \
    \  return prime_fib(n-1) + prime_fib(n-2)\n</code>\nA prime number is a natural\
    \ number greater than 1 that has no positive divisors other than 1 and itself.\
    \ It is known as an irreducible number because it has no divisors.\nA prime number\
    \ is not defined as a natural number greater than 1 that has no positive divisors\
    \ other than 1 and itself. For example, 6 is a prime number because the sum of\
    \ its positive divisors excluding 1 is 6.\n<code>", "  return prime_fib_iter(n)[1]\n\
    end", "  if n <= 2\n    next\n  else\n    (prime_fib(n - 1) + prime_fib(n - 2))\
    \ % n\nend\nprime_fib(n) # returns n-th number that is a Fibonacci number and\
    \ it's also prime.", "    if n<2: return 1\n    return prime_fib(int(n/2)) + prime_fib(int(n%2))\n\
    </code>\nThis is not exactly correct, because it returns fibonacci sequence for\
    \ numbers that are not even numbers. To fix it you can add an elif statement to\
    \ check if the number is even:\n<code>", "  return prime_factors(n).each_cons(2).map(&:first).max\n\
    end", "  return n if n < 2 else prime_fib(n - 1) + prime_fib(n - 2)\nend", "\t\
    if n == 0 or n == 1 or n == 2 or n == 3\n\t\tn\n\telse\n\t\tprime_fib(n-1) + prime_fib(n-2)\n\
    end", "  if n < 2\n    prime_fib(1)\n  else\n    prime_fib(n / 2) + prime_fib(n\
    \ / 2 - 1)\n  end\nend", "  prime_fibs = [1,2]\n  prime_fibs_append = prime_fibs.append\n\
    \  (1..n).each do |x|\n    prime_fibs_append(prime_fibs[x-1] + prime_fibs[x-2])\n\
    \  end\n  prime_fibs.last\nend", "    num = n\n    \n    if n == 1 or n == 2:\n\
    \        return 2\n    elif n % 2 == 0 or n == 3:\n        return 1\n    else:\n\
    \        numbers = 3\n        while numbers < n:\n            numbers += 2\n \
    \       \n        while numbers > n:\n            numbers = numbers - 2\n    \
    \    \n        return numbers + 1", "  prime_fibs = []\n  fibs = prime_fibs #\
    \ fibonacci numbers array\n  fibs.push(prime_fib(n))\n  i = 1\n  while fibs.any?\n\
    \    next_fib = fibs.last\n    if next_fib > n\n      break\n    elsif n != next_fib\n\
    \      fibs.push(next_fib + next_fib)\n    elsif next_fib == n\n      return fibs.last\n\
    \    end\n    prime_fibs.push(next_fib)\n    i += 1\n  end\n  puts \"Out of loop.\"\
    \nend\n</code>\n<code>\nprime_fib(13) # 13th fibonacci number\nprime_fib(14) #\
    \ Out of loop\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nCan you explain\
    \ this line \"fibs = prime_fibs\" in your code ?\n<|/ c |>\n<| c |>\nI think you\
    \ misunderstood my code snippet. `prime_fibs` contains all Fibonacci numbers,\
    \ while `fibs` contains just the one number whose Fibonacci number was given.\n\
    <|/ c |>\n<| c |>\nYes I understood that. But can you explain what exactly happens\
    \ in that line. Thanks!\n<|/ c |>\n<| c |>\n`fibs.push(next_fib + next_fib)` -\
    \ here you add two Fibonacci numbers and push to the array `fibs`. So `fibs` is\
    \ a list of numbers including `next_fib`.\n<|/ c |>\n<| c |>\nBut `fibs.push(next_fib\
    \ + next_fib)` will add those two fibonacci numbers into fibonacci numbers array\
    \ and then push these numbers into the `i` variable. Which doesn't make sense.\
    \ Did you get that part ?\n<|/ c |>\n<| a dscore=0 tags=ruby |>\n<code>", "  a,\
    \ b = 0, 1\n  while a < n\n    a, b = b, a + b\n  end\n  a >= n\nend", "  prime_fib_list\
    \ = []\n  prime_fib_list = [2,1]\n  prime_fib_list << prime_fib_list.last+1\n\
    \  prime_fib_list << prime_fib_list.last+2\n  i = prime_fib_list.index(n)\n  if\
    \ i-1 == -1 then return false else return prime_fib_list[i-1] end\nend", "  prime_fibs\
    \ = []\n  i = 2\n  \n  while i < n\n    prime_fibs << i\n    i +=1", "  prime\
    \ = nil\n  i = 2\n  while i < n\n    prime = i\n    i += 1\n  end\n  prime\nend",
  "    if n < 2\n        return nil\n    end\n    \n    if n == 1\n        return\
    \ 2\n    end\n    \n    if n == 2\n        return 3\n    end\n    \n    # Fibonacci\
    \ numbers\n    if n % 2 == 0\n        return prime_fib(n - 1) + prime_fib(n -\
    \ 2)\n    end\n    \n    return prime_fib(n - 1) + prime_fib(n - 3)\nend", " \
    \ i, p, q = 0, 1, n\n  while i < p\n    q = p + q\n    if q > n\n      break\n\
    \    p, q = i, q\n    i += 1\n  return i\nend", "    primes = []\n    if n<2:\n\
    \        return primes\n    primes.append(2)\n    i = 2\n    while i <= n:\n \
    \       if primes.include?(i)\n            break\n        primes.push(i)\n   \
    \     i+=1\n    return primes\nend", "  return 2 if n < 2 else prime_fib(n - 2)\
    \ + prime_fib(n - 3)\nend", "    i = 2\n    prime = 0\n    while i <= n\n    \
    \    if isprime(i)\n            prime += 1\n        i += 1\n    return prime\n\
    \    ", "  # Write your code here\n  result = 0\n  for i in range(2,n):\n    temp\
    \ = i+i\n    if temp > n:\n      temp = n\n    if temp == 2:\n      result = i+1\n\
    \      break\n  return result\n</cell>\n<cell>", "  a = b = nil\n  while n > 0\n\
    \    if n % 2 == 0\n      b = n\n    else\n      a = n\n      n = a + b\n    end\n\
    \  end\n  return n\nend\n</cell>\n<cell>\nprime_fib(6)\n</cell>\n<cell>\nprime_fib(5)\n\
    </cell>\n<cell>", "\tif n == 1 or n == 2: return n\n\tif n % 2 == 0: return prime_fib(n\
    \ / 2)\n\telse: return prime_fib(n / 2) + prime_fib(n / 2 - 1)\n    \n</cell>\n\
    <cell>", "    a,b = 0,1\n    while a<n:\n        if n%a==0 or n%b==0:\n      \
    \      print(\"Prime number not possible!\")\n            return False\n     \
    \   b,a = a+b,a\n    return a", "  if n == 0\n    return 0\n  a = prime_fib(n-1)\n\
    \  b = 1\n  while a < n\n    a, b = b + 1, a+b\n  end\n  b\nend", '    return
    (n<=1 or n%2==1) and 2 or prime_fib(3*n+1-2) or prime_fib(3*n+2)', "    if n <\
    \ 2\n        return n\n    return prime_fib(n - 1) + prime_fib(n - 2)\nend\n</cell>\n\
    <cell>", "  # check if n is a prime number\n  if n <= 2\n    return n\n  elsif\
    \ n == 3\n    return 5\n  else\n    return prime_fib(n - 2) + prime_fib(n - 3)\n\
    end", "  return prime(n) if n <= 1 else\n    prime_fib(n - 1) + prime_fib(n -\
    \ 2)", "    a,b=1,2\n    while b<n do\n        if (a+b)%n==0 then\n          \
    \  return b\n        end\n        a,b=b,a+b\n    end\n    return nil\nend", " \
    \ (2..n).each do |n|\n    if n % 2 == 0\n      next\n    end\n    if n % 3 ==\
    \ 0\n      return n\n    end\n    return 3*n+1 if n % 5 == 0\n  end\nend", " \
    \ primes = [2, 3, 5, 7, 11, 13, 17, 19]\n  fibs = [0, 1, 1, 2, 3, 5, 8, 13, 21]\n\
    \  while n > 0\n    a,b = fibs.find { |fib| fib <= n }\n    fibs[a] = fibs[a]\
    \ + fibs[b]\n    if fibs[a] > n\n      fibs[a] = n\n      primes.delete fibs[a]\n\
    \      break\n    end\n    fibs[b] = fibs[b] + fibs[a]\n    n -= 1\n  end\n  primes.each\
    \ { |i| return i }\n  return nil\nend\nputs prime_fib", "  f = [0, 1].product([1]+[n]).map\
    \ { |p| p.last+p.first }\n  f.find { |i| i % n == 0 && i != n }\nend\n</cell>\n\
    <cell>\nprime_fib(25)\n</cell>\n<text>\nA lot of operations in Julia have their\
    \ own ways of doing things.", "  if n == 0\n    puts \"0\"\n  elsif n == 1\n \
    \   puts \"1\"\n  elsif n % 2\n    prime_fib(n / 2) \n  else \n    prime_fib(3\
    \ * n + 1) / 2 \n  end\nend\nprime_fib(10)", "  if n==1 or n==2:\n    return 2\n\
    \  while (n<15):\n    next=(n*2)+1\n    \n    if next <= n: #not prime number\n\
    \      next\n      return next\n    elif n%next ==0:\n      n += next\n      \n\
    \  \n  \n  ", "  return n if n <= 2 else prime_fib(n - 1) + prime_fib(n - 2)\n\
    end", "  if n < 2 then return 2 # not prime number\n  if n <= 3 then return 3\
    \ # prime\n  i = 2\n  while i <= n do\n    if prime? i then return i\n    i +=\
    \ 2\n  end\n  return nil\nend", "  fib = [1, 1]\n  (2..n).each do |i|\n    fib.each\
    \ {|j| fib[j] = fib[j-1]+fib[j-2]}\n    return fib[n] if fib[n] % i == 0\n  end\n\
    \  fib[n]\nend", "  primes = []\n  a,b = 1,1\n  while b < n\n    primes.push(b)\n\
    \    a,b = b,a+b\n  end\n  primes.last\nend\n</cell>\n<code language=julia-0.5>\n\
    prime_fib(10)\n</cell>\n<code language=julia-0.5>", "  return 2 if n < 2 else\
    \ prime_fib(n - 1) + prime_fib(n - 2)\nend", "  if n < 2\n    n\n  else\n    prime_fib(n-1)+prime_fib(n-2)\n\
    \  end\nend", "    fib = [1,1]\n    for r in xrange(2, n+1)\n        fib[r] =\
    \ fib[r-1] + fib[r-2]\n    prime_fibs = [2]\n    for p in xrange(3, n+1, 2)\n\
    \        if fib[p] % p != 0 and p*p != fib[p]: \n            prime_fibs.append(p)\n\
    \    return prime_fibs[-1]", "\tif n <= 0\n\t\traise ArgumentError, \"n must be\
    \ positive\"\n\tif n < 5\n\t\treturn n\n\tp =1\n\tq =1\n\tfor i in 1..n\n\t\t\
    p += q\n\t\tq *= 3\n\treturn p\nend", "  primes = [2]\n  fibos = [0, 1]\n  while\
    \ primes.any? && primes.size < n\n    primes.concat([primes.last] + primes.first)\n\
    \    fibos.concat([fibos.last] + fibos.first)\n  end\n  return fibos[n-1]\nend",
  "  if n <= 2 \n  then\n    n\n  else\n    prime_fib(n-1) + prime_fib(n-2)\n  end\n\
    end", '  return ( n > 1 and prime_fib(n-2) + prime_fib(n-1) )', '  return prime_fib_impl(n)',
  "\tprime_fib_nums = [0,1]\n\tprime_fib_nums.each do |num|\n\t\tif num > n \n\t\t\
    \tnext\n\t\tend\n\t\tif num == prime_fib_nums[1]\n\t\t\tprime_fib_nums.last\n\t\
    \telse\n\t\t\tprime_fib_nums.last + prime_fib_nums.last \n\t\tend\n\tend\nend",
  "    if n < 2\n        n\n    else\n        prime_fib(n-2) + prime_fib(n-3)\nend\n\
    \    ", "  if n < 2\n    1\n  else\n    prime_fib(n-1)+prime_fib(n-2)\n  end\n\
    end", "  return primes_array[n] if n > 0 and primes_array[n]\n  ", "    numbers\
    \ = []\n    number = 0\n    count = 0\n    while count < n\n        number +=\
    \ 1\n        count += 1\n        numbers.append(number)\n    while numbers[count-1]\
    \ == 2\n        count += 1\n        numbers[count-1] += 1\n        numbers[count]\
    \ -= 1\n    return numbers[count-1]", "\ta = [1,1]\n\twhile (a[0] <= n):\n\t\t\
    m = a[0]\n\t\tfor i in range(1,a[0]+1):\n\t\t\tif (n % i == 0):\n\t\t\t\tm = m+1\n\
    \t\ta[0] = a[0]+1\n\t\tif (m == a[0]):\n\t\t\ta[1] = m\n\tif (n < a[0]):\n\t\t\
    return 2\n\tif (a[0] == n):\n\t\treturn a[1]\n\telse:\n\t\treturn a[1]+a[0]",
  "\ta = nil\n\tb = nil\n\tn = n.to_i\n\tn = 0 if n == 1\n\tn = (n+1).to_i\n\ta =\
    \ 2 \n\tb = 3\n\twhile a < n \n\t\tb = b + a\n\t\ta = b if b % n == 0\n\tend\n\
    \ta \nend", "  if n == 1 or n == 2 then return n\n  return prime_fib(n-1) + prime_fib(n-2)\
    \ unless prime_fib(n-2)\n  return prime_fib(n-2) unless prime_fib(n-2)\n  return\
    \ prime_fib(n-3) unless prime_fib(n-2)\n  return prime_fib(n-4) unless prime_fib(n-2)\n\
    end\n</cell>\n<code language=julia-0.4>\nprime_fib(10)\n</cell>\n<code language=julia-0.4>",
  "  f = [1,2]\n  for i in 2..n\n    f.each { |i| f.push(f[i] + f[i-1]) }\n    f.uniq!\n\
    \  end\n  f.length\nend", "    if n < 2\n        return n\n    fibonacci = (1\
    \ + Math.sqrt(5)) ** n\n    prime = fibonacci.floor / fibonacci.ceil\n    return\
    \ prime\n</code>\nThis is how you can do it in Ruby 1.8.7:\n<code>", "    a, b\
    \ = 0, 1\n    while b <= n\n        a, b = b, a + b\n    end\n    a\nend", " \
    \   if n == 0 or n == 2\n        return n\n    return prime_fib(n-1) + prime_fib(n-2)\n\
    </code>\nNow we see how each function works. Let us start with the recursive call\
    \ of prime_fib(n-1) and prime_fib(n-2).\nFirst if n == 0 or n == 2 then this will\
    \ be returned. Now we have two cases when we need to use prime_fib(n-1) and prime_fib(n-2).\n\
    In first case n == 0 then n-1 is returned and recursion stops. In second case\
    \ n == 2 then n-2 is returned and recursion stops. In all other cases n-1 and\
    \ n-2 are returned.\nNow we have two recursive calls. So let's check what happens\
    \ when we have recursive calls.\nFirst call prime_fib(1). It returns 2 so we have\
    \ two recursive calls, one for prime_fib(0), another for prime_fib(2).\n<code>\n\
    prime_fib(0)\n ==>\n prime_fib(2)\n  ==>\n  prime_fib(1)\n   ==>\n   2\n</code>\n\
    Second call prime_fib(2). It returns 3 so we have two recursive calls, one for\
    \ prime_fib(0), another for prime_fib(3).\n<code>\nprime_fib(0)\n ==>\n prime_fib(3)\n\
    \  ==>\n  prime_fib(1)\n   ==>\n   2\n</code>\nSo we have four recursive calls.\
    \ And so we see how the function works.\nTo check it we can use trace function\
    \ and see how recursion works:\n<code>", "  i = 2\n  while i <= n do\n    if prime?(i)\
    \ then\n      return i\n    end\n    i += 1\n  end\nend", "  a,b=2,3\n  while\
    \ (b <= n)\n    a,b=b,a+b\n  end\n  return a\nend", "    count = 0\n    i = 1\n\
    \    prime = True\n    while prime == True:\n        if count == n:\n        \
    \    prime = False\n        else:\n            count += 1\n            i += 1\n\
    \    return i\n</cell>\n<cell>", "    primes = [1,2]\n    while primes[-1] <=\
    \ n:\n        primes.append(primes[-1] + primes[-2])\n    return primes[-1]\n\
    </cell>\n<cell>\nprime_fib(100)\n</cell>\n<cell>", "    a,b = 0,1\n    while b\
    \ < n\n        a,b = b,a+b\n    end\n    return b\nend", "  return prime_fib_memo[n]\
    \ if prime_fib_memo.has_key?(n) \n  prime_fib_memo[n] = prime_fib_cache[n] if\
    \ prime_fib_cache.has_key?(n)\n  if prime_fib_memo[n] == nil\n    prime_fib_memo[n]\
    \ = prime_fib_cache[n] = 2 * prime_fib_cache[n-1] + 1 if n > 2\n  end\n  prime_fib(n)\n\
    end", "  if n < 2\n    2\n  else\n    prime_fib(n - 1) + prime_fib(n - 2)\n  end\n\
    end", "  return prime_fib_helper(n, nil)\nend", '  return 1 if n < 2 else prime_fib(n
    // 2)+1 if n % 2 == 0 else prime_fib(n-2) + prime_fib(n-3)', "  if n == 1 then\n\
    \    return 2\n  else\n    if n == 2 then\n      return 3\n    else\n      if\
    \ n % 2 == 0 then\n        return prime_fib(n - 1) + prime_fib(n - 2)\n      else\
    \ \n        return prime_fib(n - 1)\n      end\n    end\n  end\nend", "  return\
    \ prime_fib_iter(n).next\nend", "  if n == 1 then\n    return 2\n  else \n   \
    \ return prime_fib(n - 1) + prime_fib(n - 2)\n  end\nend", "  if n == 1 or n ==\
    \ 2:\n    return n\n  return prime_fib(n-1) + prime_fib(n-2)", "\ta = b = nil\n\
    \twhile n > 1 do\n\t\tif n % 2 == 0\n\t\t\tb = b + 1\n\t\telse\n\t\t\ta = a +\
    \ 1\n\t\tend\n\t\tn = n / 2\n\tend\n\tprime_fib(b)\nend", "  if n < 2\n    puts\
    \ n\n  elsif n == 2\n    puts 3\n  elsif n % 2 == 0\n    puts n\n  else\n    puts\
    \ prime_fib(n - 2) + prime_fib(n - 3)\n  end\nend", "  if n<2\n    return n\n\
    \  elsif n<3\n    return 2\n  else\n    prime_fib_list = []\n    prime_fib_list.append(2)\n\
    \    prime_fib_list.append(3)\n    for i in range(4, n+1, 2)\n      prime_fib_list.append(i)\n\
    \    return prime_fib_list[n-1]", "  prime_n = 2\n  while prime_n < n\n    prime_n\
    \ = prime_n + 2\n  end\n  prime_n % n == 0\nend", "  if n == 0\n    0\n  elsif\
    \ n == 1\n    1\n  else\n    prime_fib(n - 1) + prime_fib(n - 2)\n  end\nend",
  "    prime_fib_number = nil\n    prime_fib_number = prime_fib_number if prime_fib_number.nil?\n\
    \    if n == 0\n        return prime_fib_number\n    end\n    if n == 1\n    \
    \    return 2\n    end\n    fib = 1\n    prime_fib_number = prime_fib_number +\
    \ fib\n    prime_fib_number = prime_fib_number if prime_fib_number % 2 == 0\n\
    \    prime_fib_number = prime_fib_number if prime_fib_number % 3 == 0\n    prime_fib_number\
    \ = prime_fib_number if prime_fib_number % 5 == 0\n    prime_fib_number = prime_fib_number\
    \ if prime_fib_number % 7 == 0\n    prime_fib_number = prime_fib_number if prime_fib_number\
    \ % 11 == 0\n    prime_fib_number = prime_fib_number if prime_fib_number % 13\
    \ == 0\n    prime_fib_number = prime_fib_number if prime_fib_number % 17 == 0\n\
    \    prime_fib_number = prime_fib_number if prime_fib_number % 19 == 0\n    prime_fib_number\
    \ = prime_fib_number if prime_fib_number % 23 == 0\n    prime_fib_number = prime_fib_number\
    \ if prime_fib_number % 25 == 0\n    prime_fib_number = prime_fib_number if prime_fib_number\
    \ % 29 == 0\n    prime_fib_number = prime_fib_number if prime_fib_number % 31\
    \ == 0\n    prime_fib_number = prime_fib_number if prime_fib_number % 37 == 0\n\
    \    prime_fib_number = prime_fib_number if prime_fib_number % 41 == 0\n    prime_fib_number\
    \ = prime_fib_number if prime_fib_number % 43 == 0\n    prime_fib_number = prime_fib_number\
    \ if prime_fib_number % 47 == 0\n    prime_fib_number = prime_fib_number if prime_fib_number\
    \ % 53 == 0\n    prime_fib_number = prime_fib_number if prime_fib_number % 59\
    \ == 0\n    prime_fib_number = prime_fib_number if prime_fib_number % 61 == 0\n\
    \    prime_fib_number = prime_fib_number if prime_fib_number % 67 == 0\n    prime_fib_number\
    \ = prime_fib_number if prime_fib_number % 71 == 0\n    prime", "  # Write your\
    \ code here\n  a = n\n  b = n-1\n  while b<2:\n      c = a+1\n      a = b\n  \
    \    b = c\n      yield a\n  c = a+1\n  yield c\n  while b<n:\n      c = a+1\n\
    \      yield c\n      a = b\n      b = c\n  c = a+1\n  yield c\n  while b<n:\n\
    \      c = a+1\n      a = b\n      b = c\n      yield a\n      yield c", "  fib_n_list\
    \ = [1,1]\n  if n <= 2\n    puts \"The number is prime\"\n    return n\n  else\n\
    \    3.times do |i|\n      fib_n_list << fib_n_list[i-1] + fib_n_list[i-2]\n \
    \   end\n    return fib_n_list[n-2]\n  end\nend", "  if n <= 1 then\n    return\
    \ 2\n  else\n    local fib1 = prime_fib(n - 1)\n    local fib2 = prime_fib(n -\
    \ 2)\n    local fib3 = fib1 + fib2\n    if fib3 % n == 0 then\n      return fib3\n\
    \    else\n      return prime_fib(fib3)\n    end\n  end\nend", "  prime_fib =\
    \ [1,2]\n  fib = 3\n  while fib < n\n    prime_fib << fib\n    fib += 2\n    prime_fib.delete(0)\n\
    \  end\n  prime_fib.last\nend", "    a, b = 0, 1\n    while a < n\n        a,\
    \ b = b, a+b\n    end\n    return a\nend\n</cell>\n<code language=julia-1.5>\n\
    prime_fib(1)\n</cell>\n<code language=julia-1.5>\nprime_fib(2)\n</cell>\n<code\
    \ language=julia-1.5>\nprime_fib(3)\n</cell>\n<code language=julia-1.5>\nprime_fib(4)\n\
    </cell>\n<code language=julia-1.5>\nprime_fib(5)\n</cell>\n<text>\nProblem 1\n\
    Write a function to find the sum of all the prime numbers less than or equal to\
    \ a given number.", "  return prime_fib_memo[n] if prime_fib_memo.has_key?(n)\
    \ \n  prime_fib_memo[n] = prime_fib_memo[n-1] + prime_fib_memo[n-2]\n  prime_fib_memo[n]\n\
    end", "  return 0 if n < 3 else 1 if n & 1 == 0 else prime_fib(n-1) + prime_fib(n-2)\n\
    end", "  a = 0\n  b = 1\n  primes = [2]\n  (2..n-1).step(2).each do |i|\n    if\
    \ b > i\n      a += i\n      b += 1\n      primes << a\n    end\n  end\n  primes\n\
    end", "  a, b = 0, 1\n  while b < n\n    yield b\n    a, b = b, a + b\n  end\n\
    end\n</code></pre>\n<p>And here's a quick benchmark which shows that we gain some\
    \ speed by precalculating prime numbers up to the limit and simply accessing them\
    \ from there:</p>\n<pre><code>$ time ruby fibonacci.rb \nreal    0m0.032s\nuser\
    \    0m0.030s\nsys     0m0.009s\n</code></pre>\n<p>The prime fibonacci function\
    \ can now be written in Ruby as such:</p>\n<pre><code>def fibonacci(n)\n  return\
    \ n if n == 0", "  return fibonacci_prime[n] if n <= fibonacci_prime.length\n\
    \  prime_fib.length = (n+1)\n  result = prime_fib.slice!(1..n).inject(0, :+).prime!\n\
    \  return result\nend", "\treturn fibonacci_fib(n,prime_check)\nend", "    prev,\
    \ curr = 1, 1\n    while curr < n\n        prev, curr = curr, prev + curr\n  \
    \  end\n    return curr\nend", "  if n <= 2\n    puts \"n cannot be less than\
    \ or equal to 2\"\n  else\n    puts \"The #{\"%05d\" % n} is Fib#{n}\"\n    puts\
    \ \"The Fibonacci number is #{(1 + n).to_s.rjust(4, '0')}\"\n    puts \"#{(n -\
    \ 2).to_s.rjust(4, '0')} is prime.\" if n % 2 == 0\n  end\nend\n</code>\n<|/ a\
    \ |>\n<| a |>\nI know this question is pretty old, but here is another way to\
    \ approach it using recursion and memoization.\n<code>", "  if n<2:\n    return\
    \ n\n  return prime_fib(n-1)+prime_fib(n-2)", "  return 0 if n < 3 else 1 if n\
    \ % 2 == 0 then 2 else prime_fib(n - 1) + prime_fib(n - 2)\nend", "  return n\
    \ if n < 2 then return n else prime_fib(n - 1) + prime_fib(n - 2)\nend\n</cell>\n\
    <text>\nPractice Problem 3\nA number is defined as $n \\equiv n^2 \\times n^3\
    \ \\times n^5 \\times n^7$ (with repetition of term).", "  a, b = 0, 1\n  while\
    \ n > 0\n    a, b = b, a+b\n    n -= 1\n  end\n  return a\nend", "  a, b = 0,\
    \ 1\n  while a < n\n    a, b = b, a+b\n  end\n  a\nend", "  i = 2\n  while i <=\
    \ n / 2\n    if n % i == 0\n      return false\n    i += 1\n  return true\nend",
  "  if n < 2\n  then\n    return\n  else\n    prime_fib(n - 1) + prime_fib(n - 2)\n\
    \  end\nend\n</cell>\n<code language=julia-1.5>", "  a = b = 1\n  (1..n).each\
    \ do |i|\n    if i % 2 == 0\n      b += i\n    else\n      a += i\n    end\n \
    \ end\n  (a - b).prime? ? a : nil\nend", '    return n if n < 2 # otherwise n
    = fib(n-1) + fib(n-2), therefore n must be >= 2.', "\treturn prime_fib(n-1)+prime_fib(n-2)\n\
    end", "    num = 1 while num < n\n    prime = 2 while prime < num\n    prime =\
    \ prime + 1 while prime < num\n    prime = prime + 1 while prime < num\n    prime\
    \ = prime + 1 while prime < num\n    prime = prime + 1 while prime < num\n   \
    \ return prime\n</cell>\n<cell>\nprime_fib(5)\n</cell>\n<text>\nSum all the numbers\
    \ from 1 to 100, and find the sum of all the even numbers from 0 to 100.", " \
    \ if n <= 2\n    n\n  else\n    prime_fib(n - 1) + prime_fib(n - 2)\nend", " \
    \ if n < 2 then return 2\n  return prime_fib(n-1) + prime_fib(n-2)\nend", "  a\
    \ = 2\n  b = 5\n  result = [2]\n  while a < n do\n    while b < n do\n      result[a]\
    \ ||= 0\n      result[a] += 1\n      b += 1\n    end\n    a += 1\n    b += 1\n\
    \  end\n  result\nend", "  if n < 2\n    puts \"Not a prime number!\"\n  else\n\
    \    puts \"#{prime_fib_prime(n)}th prime Fibonacci number is #{prime_fib_prime(n-1)}\"\
    \n  end\nend", "    if n == 0 or n == 1 then\n        return n\n    end\n    i\
    \ = 2\n    while i <= n do\n        if n % i == 0 then\n            return i\n\
    \        else\n            i = i + 1\n        end\n    end\n    return n\nend",
  "  primes = [0, 1]\n  if n < 2\n    prime\n  else\n    prime_fib(n - 2) == prime_fib(n\
    \ - 1)\n    if n % 2 == 1\n      primes[primes.index(true)] += 1\n    else\n \
    \     primes[primes.index(true)] += 1\n      prime_fib(n - 3)\n    end\n  end\n\
    \  primes\nend", "  return prime_fib_helper(n) if prime_fib_helper(n) end\nend",
  "  primes = Set.new # primes will contain prime numbers, starting from 2\n  fibonacci\
    \ = Set.new # fibonacci numbers, starting from 1\n  n = 0 if n <= 0 else n\n \
    \ n = 1 + n # Fibonacci numbers are calculated using Fibonacci sequence\n  while\
    \ fibonacci.size < n # until n Fibonacci numbers are calculated, store them in\
    \ fibonacci\n    f =  fibonacci.add(1) # add fibonacci number\n    primes << f\
    \ # add prime number to primes\n  end\n  fibonacci.delete(n) # delete fibonacci\
    \ number which is not necessary for calculating Fibonacci numbers\n  return primes.find\
    \ { |n| n % n == 0}\nend", "  if n == 0\n    0\n  elsif n == 1\n    1\n  else\n\
    \    prime_fib(n - 1) + prime_fib(n - 2)\n  end\nend", "  if n == 1 then return\
    \ 2\n  if n == 2 then return 3\n  if n == 3 then return 5\n  if n % 2==0 then\
    \ return prime_fib(3*n-1) or prime_fib(3*n-2) or prime_fib(3*n-1)\n  return prime_fib(n-1)+prime_fib(n-2)",
  "  return if n < 2\n  return prime_fib(n - 1) + prime_fib(n - 2)\nend", "  n <=\
    \ 2 ? 1 : prime_fib(n - 1) + prime_fib(n - 2)\nend\n</cell>\n<code language=julia-1.3>\n\
    prime_fib(10)\n</cell>\n<text>\nHow many times is the function prime_fib called?\n\
    How many times is the function prime_fib called?\nHow many times is the function\
    \ prime_fib called?\nHow many times is the function prime_fib called?", "    if\
    \ n <= 1\n        n = 1\n        return n\n    return prime_fib(n - 1) + prime_fib(n\
    \ - 2)\n</cell>\n<cell>\nprime_fib(10)\n</cell>\n<cell>", "    a, b = 0, 1\n \
    \   while a < n\n        a, b = b, a + b\n    end\n    return b\nend", "\tprime_fib_arr\
    \ = Array.new(n+1) \n\tprime_fib_arr[0] = 0\n\tprime_fib_arr[1] = 1\n\tprime_fib_arr[2]\
    \ = 2\n\tprime_fib_arr[3] = 1", '    return Fib(n).fib_seq[-1] if n > 0 else None',
  "  (1..n).inject(:+).prime? and n if n > 0\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nYeah, I've been looking for this for a while and haven't seen anyone\
    \ else use the inject method.  Very cool!  Thanks for the suggestion.\n<|/ c |>\n\
    <| c |>\n: Don't beat yourself up on inject :-) It's actually pretty nice. Straightforward,\
    \ readable, powerful, fast, etc.\n<|/ c |>\n<| a |>\nA recursive solution is also\
    \ possible, but it's not very efficient (O(n)).\n<code>", "  prime = 1\n  previous\
    \ = 2\n  i = 2\n  while i <= n\n    prime = prime + previous\n    previous = i\n\
    \    i += 2\n    if prime > n\n      break\n  end\n  prime\nend", "  primes =\
    \ [2]\n  a = primes[1]\n  while primes.count < n\n    primes.concat([prime_fib(primes.last)\
    \ + primes.first])\n    a = primes[primes.count - 1]\n  end\n  return a\nend",
  "\tif n < 2\n\t\treturn n\n\tif n == 2\n\t\treturn 1\n\tif n % 2 == 0\n\t\treturn\
    \ prime_fib(n - 1) + prime_fib(n - 2)\n\telse\n\t\treturn prime_fib(n / 2) + prime_fib(n\
    \ / 3)\n\t# return prime_fib(n / 2) + ((n / 3) if n % 3 == 0 else prime_fib(n\
    \ / 3)\n\t# return prime_fib(n / 2) + ((n / 3) if n % 3 == 0 else prime_fib(n\
    \ / 3)", "  return n if n < 2 else prime_fib(n - 1) + prime_fib(n - 2)\nend",
  "  return n if n < 2 else prime_fib(n - 1) + prime_fib(n - 2)\nend\n</cell>\n<code\
    \ language=julia-1.6>", "  (2..Math.sqrt(n)).each {|i|\n    next i  if (n%i).zero?\n\
    \  }\n  n\nend", "  if n == 1 then\n    return 2\n  else if n == 2 then\n    return\
    \ 3\n  else\n    return prime_fib(n - 1) + prime_fib(n - 2)\n  end\nend", "  \
    \  prime = [0, 1]\n    if n==1 or n==2:\n        return 1\n    while len(prime)<n:\n\
    \        prime.append(prime[-1]+prime[-2])\n    return prime[n-1]\n</cell>\n<cell>",
  "  return n if n < 2 else prime_fib(n - 2) + prime_fib(n - 1)\nend", "\treturn (n\
    \ % 2) == 0 and (n > 1) or prime_fib(n-1) + prime_fib(n-2)", "  if n<=2\n    1\n\
    \  else\n    prime_fib(n-1)+prime_fib(n-2)\n  end\nend", "    return Fib::fibonacci_prime(n)\n\
    end\n</cell>\n<code language=julia-0.6>\nprime_fib(1)\n</cell>\n<code language=julia-0.6>\n\
    prime_fib(2)\n</cell>\n<code language=julia-0.6>\nprime_fib(3)\n</cell>\n<code\
    \ language=julia-0.6>\nprime_fib(4)\n</cell>\n<code language=julia-0.6>\nprime_fib(5)\n\
    </cell>\n<text>\nTask 6: Generate Fibonacci numbers up to $N$", "\tprime_fib_list\
    \ = [1,2]\n\twhile prime_fib_list[-1] < n\n\t\tprime_fib_list.append(prime_fib_list[-1]\
    \ + prime_fib_list[-2])\n\treturn prime_fib_list[n]\n</cell>\n<text>\nWe used\
    \ list comprehension to implement prime fibonacci number function. In list comprehension\
    \ we use the while loop and append function as a list comprehension process. We\
    \ also use the list index -1 (n-1 to exclude the number itself from calculation)\
    \ to exclude the number itself. When we finish calculation, we get the last value\
    \ of the list as our result.", "  if n <= 2\n    return 2\n  a = 1\n  b = 1\n\
    \  c = 1\n  while b < n\n    (a, b) = (b, a+b)\n  end\n  c\nend", "    prime_fib_nums\
    \ = prime_fib_memo[n]\n    if prime_fib_nums # if the n is already prime, just\
    \ return that number itself\n        prime_fib_nums\n    else\n        prime_fib_nums\
    \ = n if n % 2 == 0 else prime_fib(n-1)+prime_fib(n-2)\n        prime_fib_memo[n]\
    \ = prime_fib_nums\n        prime_fib_nums\n    end\nend", "  a = b = 2\n  (1..n).each\
    \ do |i|\n    a += b\n    (b = a).next!\n  end\n  a\nend", "  i = 2\n  while i\
    \ <= n \n    return i\n    i += 1\n  end\n  return n\nend", "  f1 = 1\n  f2 =\
    \ 1\n  f3 = 1\n  while f1 <= n\n    f1 = f1 + f2\n    f2 = f3 + f2\n    f3 = f1\
    \ + f3\n  end\n  print f3\nend\nprime_fib(10000)\n</cell>\n<text>\nThe last thing\
    \ you learned\nFunctions in Julia\nHow to pass or return variables\nBuilt-in functions\
    \ in Julia\nHow to work with arrays and matrices\nHow to work with strings and\
    \ other types", "  if n == 1 or n == 2\n    return 2\n  a = 1\n  b = 1\n  while\
    \ a < n and b < n\n    a, b = b, a + b\n  end\n  a\nend\n</cell>\n<cell>\nprime_fib(1)\n\
    prime_fib(2)\nprime_fib(3)\nprime_fib(4)\nprime_fib(5)\n</cell>\n<cell>", "  \n\
    \  # base case\n  return n if n < 2 else prime_fib(n - 1) + prime_fib(n - 2)\n\
    end\n</cell>\n<code language=julia-1.5>\nprime_fib(5)\n</cell>\n<code language=julia-1.5>",
  "  # F(1) = 2 F(2) = 4 F(3) = 6 F(4) = 8 F(8) = 10 \n  return ((n-1) * n) % n\n\
    end", "\tprime_fib = []\n\tfibonacci = [1,1]\n\tfibonacci_prime = [0,1]\n\tfor\
    \ fiber in fibonacci\n\t\tif fiber > n\n\t\t\tbreak\n\t\tprime_fib << fiber\n\t\
    prime_fib.delete(fibonacci.last)\n\tfibonacci.delete(fibonacci.last)\n\tfibonacci_prime\
    \ << 0\n\tprime_fib.each do |value|\n\t\tvalue = value+1\n\t\tfibonacci_prime\
    \ << value\n\tend\n\treturn fibonacci_prime[n]\nend", "  if n < 2 then\n    return\
    \ 2\n  else\n    return prime_fib(n - 1) + prime_fib(n - 2)\n  end\nend\n</cell>\n\
    <cell>", "  n = n || 1\n  a, b = 0, 1\n  while a < n\n    a, b = b, a+b\n  end\n\
    \  a\nend", "  if n == 1 or n == 2:\n    return 2\n  elif n > 2:\n    return prime_fib(n\
    \ - 2) + prime_fib(n - 1)\n  else:\n    return 0\n</cell>\n<cell>", '    return
    primes_fib_1(n)', "    if n == 1 or n == 2:\n        return 1\n    elif n < 2:\n\
    \        return None\n    elif n%2 == 0:\n        return prime_fib(int(n/2)) +\
    \ prime_fib(int(n/3)) \n    else:\n        return prime_fib(int(n/2)) + prime_fib(int(n/3)\
    \ + 1) + 1", "  if n < 2\n    n\n  else\n    prime_fib(n - 1) + prime_fib(n -\
    \ 2)\n  end\nend", "  # Write your code here!\n  prime_number = 0\n  last_two_numbers\
    \ = 0\n  last_three_numbers = 0\n  prime_numbers = 2\n  while prime_numbers <\
    \ n:\n    last_two_numbers = last_two_numbers + prime_numbers\n    last_three_numbers\
    \ = last_three_numbers + prime_numbers\n    prime_numbers = prime_numbers + 1\n\
    \  if last_two_numbers < last_three_numbers:\n    prime_number = last_two_numbers\n\
    \  else:\n    prime_number = last_three_numbers\n  return(prime_number)\n</cell>\n\
    <cell>", "  fibs = Array.new(n)\n  fibs[0] = 1\n  fibs[1] = 1\n  for i in 2..n\n\
    \    fibs[i] = fibs[i-1] + fibs[i-2]\n  end\n  return fibs[n]\nend", "    primes\
    \ = [1,1]\n    a = [0,1]\n    if n<2:\n        return 1\n    elif n==2:\n    \
    \    return 2\n    elif n>2:\n        for i in range(2,n):\n            primes.append(primes[-2]\
    \ + primes[-1])\n            a.append(primes[-2])\n        primes.append(primes[-2]\
    \ + primes[-1])\n        a.append(primes[-2])\n        return a[n-2]\n        ",
  "  begin\n    prime_fib_prime = 0\n    prime_fib_composite = 1\n    prime_fib_number\
    \ = n\n    while prime_fib_number != 0\n      prime_fib_composite = (prime_fib_prime\
    \ + prime_fib_composite) % prime_fib_number\n      prime_fib_prime = prime_fib_composite\n\
    \      prime_fib_number = prime_fib_number - 1\n    end\n    prime_fib\n  end\n\
    end", "  n = fix_prime(n)\n  if n<2\n    puts \"n must be greater than 2\"\n \
    \   return nil\n  end\n  a,b = 1,1\n  while b<=n\n    a,b = b,a+b\n  end\n  puts\
    \ \"Fibonacci number: #{b}\"\n  return b\nend", "  fib, prime = 1, 0\n  while\
    \ prime < n do\n    prime, fib = fib + prime, fib\n  end\n  return prime\nend",
  "  f = fib(n)\n  return f if f <= n && prime?(f) end\nend", "  if n < 2\n    return\
    \ nil\n  elsif n == 2\n    return 1\n  elsif n == 3\n    return 2\n  else\n  \
    \  return prime_fib(n-1) + prime_fib(n-2)\n  end\nend", "  prime = 0\n  if n ==\
    \ 0\n    prime = 1\n  else\n    if n == 1\n      prime = 2\n    else\n      result\
    \ = prime_fib(n - 1)\n      prime = prime + result\n      prime = prime + prime_fib(n\
    \ - 2)\n      end\n    end\n  end\n  return prime\nend", "    # Initialize your\
    \ data structure here.\n    if n < 2 then\n        return n\n    elif n==2 then\n\
    \        return 1\n    end\n    \n    i = 2\n    while i <= n do\n        if prime_fib(2*i)\
    \ == n then\n            return n\n        end\n        i = i + 1\n    end\n \
    \   return n\nend\n</cell>\n<text>\nQ9. Write a function to check if a number\
    \ is perfect square or not.\nA perfect square is a number that is equal to the\
    \ sum of its positive divisors, excluding the number itself.", "  return n if\
    \ n <= 1 or n % 2 == 0 || (n % 3 == 0 and n % 5 == 0) else prime_fib(n - 2) +\
    \ prime_fib(n - 3)\nend", "  if n < 2\n    return n\n  a = 1\n  b = 1\n  while\
    \ a < n\n    a, b = b, a + b\n  end\n  puts \"#{n} is Fibonacci number with prime\
    \ factors: #{b}\"\n  return b\nend\n</cell>\n<code language=julia-0.4>\nprime_fib(2)\n\
    </cell>\n<text>\nLet's rewrite our Fibonacci implementation using our new version\
    \ of prime_fib()", "  a, b = 0, 1\n  while b < n\n    a, b = b, a+b\n  end\n \
    \ b\nend", "  # return n if n < 2 # base case\n  return 1 if n < 2 # recursive\
    \ case\n  return prime_fib(n - 1) + prime_fib(n - 2)\nend", "  return 2 if n <=\
    \ 1 else prime_fib(n - 2) + prime_fib(n - 1)\nend", "  if n == 1 or n == 2 then\n\
    \    puts \"2\"\n    return\n  end\n  prime_fib(n - 2)\n  puts n\nend\n</code>\n\
    <|/ a |>\n<| c |>\n`prime_fib(5)` returns 89, should be the 3rd from the top\n\
    <|/ c |>\n<| c |>\n, Thanks. I fixed the bug. :)\n<|/ c |>\n<| c |>\nI believe\
    \ the question was about how to do it recursively, which your code doesn't do\
    \ (unless I'm missing something).\n<|/ c |>\n<| c |>\n: I believe your question\
    \ is about how to implement Fibonacci recursively, not about Fibonacci iteratively.\n\
    <|/ c |>\n<| c |>\n, you're right. I've just read it again and my original idea\
    \ was to implement it in iterative way and I thought that my code is wrong. Now\
    \ it's fixed\n<|/ c |>\n<| a |>\nThe accepted answer is a good one, but doesn't\
    \ use recursion. To use recursion, you need to pass the previous result to the\
    \ next invocation of prime_fib(), and have the function return this value when\
    \ it has found the right answer. Something like this:\n<code>", "\tif n < 2\n\t\
    \treturn 2\n\tfib = 2\n\twhile fib < n\n\t\tfib += 2\n\treturn fib", "    primes_array\
    \ = [1,2]\n    primes_array[0] = primes_array[1] = 1\n    count = 0\n    while\
    \ count < n:\n        if primes_array[count] == 2:\n            count += 1\n \
    \           primes_array[count] = primes_array[count-1] + primes_array[count-2]\n\
    \        else:\n            primes_array[count] = primes_array[count-1] + primes_array[count-2]\n\
    \            count = count + 1\n    return primes_array[n]", "  if n < 4\n   \
    \ return n\n  else\n    prime_fib(n - 1) + prime_fib(n - 2)\n  end\nend", "  \
    \  a, b = 0, 1\n    while a < n\n        a, b = b, a + b\n    return b\n</cell>\n\
    <cell>", "  if n < 3 then return n\n  if n == 2 then return 1\n  local i = 1\n\
    \  while i < n do\n    if n % i == 0 then return n\n    i = i + 1\n  end\n  return\
    \ n\nend", "    if n<2:\n        return n\n    return prime_fib(n-1) + prime_fib(n-2)",
  "  primes = [1]\n  \n  for i in 2..n do\n    primes += primes[0..0]\n    primes.last[i]\n\
    \  \n  primes.find {|x| x == n}\nend", "    if n <= 1 \n        n <= 0\n    else\
    \ \n        if n == 2 \n            2\n        else \n            if n % 2 ==\
    \ 0 \n                prime_fib(n - 2)\n            else \n                if\
    \ n % 3 == 0 \n                    prime_fib(n - 3)\n                else \n \
    \                   if n % 5 == 0 \n                        prime_fib(n - 5)\n\
    \                    else \n                        if n % 7 == 0 \n         \
    \                   prime_fib(n - 7)\n                        else \n        \
    \                    if n % 11 == 0 \n                                prime_fib(n\
    \ - 11)\n                            else \n                                if\
    \ n % 13 == 0 \n                                    prime_fib(n - 13)\n      \
    \                          else \n                                    if n % 17\
    \ == 0 \n                                        prime_fib(n - 17)\n         \
    \                           else \n                                        if\
    \ n % 19 == 0 \n                                            prime_fib(n - 19)\n\
    \                                        else \n                             \
    \               if n % 23 == 0 \n                                            \
    \    prime_fib(n - 23)\n                                            else \n  \
    \                                              if n % 29 == 0 \n             \
    \                                       prime_fib(n - 29)\n                  \
    \              else \n                                    if n % 31 == 0 \n  \
    \                                      prime_fib(n - 31)\n                   \
    \                 else \n                                        if n % 37 ==\
    \ 0 \n                                            prime_fib(n - 37)\n        \
    \                                else \n                                     \
    \       if n % 41 == 0 \n                                                prime_fib(n\
    \ - 41)\n                                            else \n                 \
    \                               if n % 47 == 0 \n                            \
    \                        prime_fib(n - 47)\n                                 \
    \               else \n                                                    if\
    \ n % 51 == 0 \n                                                        prime_fib(n\
    \ - 51)\n                                                    else \n         \
    \                                               if n % 57 == 0 \n            \
    \                                                prime_fib(n - 57)\n         \
    \                                               else \n                      \
    \                                      if n % 61 == 0 \n                     \
    \                                           prime_fib(n - 61)\n              \
    \                                              else \n                       \
    \                         if n % 67 == 0 \n                                  \
    \                  prime_fib(n - 67)\n                                       \
    \         else \n                                                    if n % 71\
    \ == 0 \n                                                        prime_fib(n -\
    \ 71)\n                                                    else \n           \
    \                                             if n % 73 == 0 \n              \
    \                                              prime_fib(n - 73)\n           \
    \                                             else \n                        \
    \                                    prime_fib(n - 1)", "  a, b = 2, 1\n  while\
    \ (b <= n) do\n    if prime?(b)\n      a, b, c = b, a + b, c\n    end\n  end\n\
    \  c\nend", "  begin\n    prime_fib_cache[n] ||= n >= 2\n    return prime_fib_cache[n]\n\
    \  end until prime_fib_cache[n]\n  if n == 0\n    1\n  elsif n == 1\n    2\n \
    \ else\n    prime_fib_cache[n] = prime_fib_cache[n-1] + prime_fib_cache[n-2]\n\
    \  end\nend\n</cell>\n<cell>\nprime_fib(2)\n</cell>\n<text>\nProblem 3.10", '    return
    n % 2 == 0 and n if n <= 3 else prime_fib(n - 3) + prime_fib(n - 2)', "    \n\
    \    # Check if n is prime\n    if n == 1\n        return 1\n    if n == 2\n \
    \       return 2\n    \n    # Check if n is divisible by 3\n    if n % 3 == 0\n\
    \        return prime_fib(3*n+1)\n    \n    # Check if n is divisible by 5\n \
    \   if n % 5 == 0\n        return prime_fib(5*n+1)\n    \n    # Since n is not\
    \ divisible by any number that would divide it\n    # and it's not divisible by\
    \ any other numbers, it's prime.\n    return n\n</cell>\n<cell>\nprime_fib(1)\n\
    </cell>\n<cell>\nprime_fib(2)\n</cell>\n<cell>\nprime_fib(3)\n</cell>\n<cell>\n\
    prime_fib(4)\n</cell>\n<cell>\nprime_fib(5)\n</cell>\n<text>\nExercise 5\nWrite\
    \ a function that takes as input a two-digit octal number and returns the corresponding\
    \ decimal number. For example, if the octal number is represented by the string\
    \ '011', the function should return the decimal number 11.", "  case n <= 1\n\
    \  then return n\n  else return prime_fib(n - 1) + prime_fib(n - 2)\nend\n</cell>\n\
    <code language=julia-1.0>\nprime_fib(10)\n</cell>\n<code language=julia-1.0>\n\
    function sieve(n)\n  primes = []\n  2\n  while n > 0\n    push!(primes, n)\n \
    \   n = 3 * n - 1\n  end\n  primes\nend\n</cell>\n<code language=julia-1.0>\n\
    sieve(10)\n</cell>\n<code language=julia-1.0>\nprime_fib(10)\n</cell>\n<code language=julia-1.0>\n\
    function prime_sieve(n)\n  sieve(prime_fib(n))\nend\n</cell>\n<code language=julia-1.0>\n\
    prime_sieve(10)\n</cell>\n<code language=julia-1.0>\nfunction factorial(n)\n \
    \ 1\nend", "  # base case\n  if n < 2\n    return n\n  # else \n  a = 2\n  b =\
    \ 2\n  while b <= n\n    b = a + b\n    a, _ = b, b - a\n  end\n  a\nend", " \
    \ return prime_fib_iterative(n)\nend", "    a, b = 0, 1\n    while b < n\n   \
    \     a, b = b, a+b\n    end\n    return a\nend\n</cell>\n<code language=julia-0.4>",
  "    if n<=1\n        return 2\n    if n%2==0\n        return prime_fib(n-1)+prime_fib(n-2)\n\
    \    return prime_fib(n-2)+prime_fib(n-3)", "    if n == 0 or n == 1 or n % 2\
    \ == 0 or n % 3 == 0\n        return n\n    x, y = 0, 1\n    while y < n\n   \
    \     x, y = y, x + y\n    return y", "  prime_number = 2\n  fibonacci_number\
    \ = 1\n  while prime_number <= n\n    prime_number = prime_number + fibonacci_number\n\
    \    fibonacci_number = prime_number * (prime_number - 1)\n  end\n  return fibonacci_number\n\
    end\nprime_fib(6)\n</cell>\n<cell>", "  # if n < 2 then returns 0 which is considered\
    \ a prime number for our case.\n  return 2 if n == 0 or n == 1 else n % 10 + prime_fib(n\
    \ // 10 + 1) if n > 2 \\\n    else 0", "  primes_array = []\n  primes_array[0]\
    \ = prime_fib(2) - 1\n  primes_array[1] = prime_fib(1)\n  primes_array[2] = prime_fib(0)\
    \ + 1\n  primes = 0\n  i = 3\n  primes = 0\n  while i < n do\n    while primes_array[i]\
    \ < n do\n      primes_array[i] += 1\n    end\n    if primes_array[i] == n then\n\
    \      primes += 1\n    end\n    i += 1\n  end\n  return primes\nend", "  if n\
    \ <= 2\n    1\n  elsif n <= 4\n    3\n  elsif n <= 9\n    prime_fib(n - 1) + prime_fib(n\
    \ - 2)\n  else\n    prime_fib(n - 3) + prime_fib(n - 2)\n  end\nend", "    current\
    \ = 1\n    next_prime = 2\n    while current <= n:\n        next_prime += 2\n\
    \        while next_prime <= current:\n            current = next_prime\n    \
    \        next_prime += 2\n        if next_prime > n:\n            next_prime =\
    \ n\n        current = next_prime\n    return next_prime\n</code>\n<|/ a tags=python\
    \ dscore=1 |>\n<| c |>\nI think you missed something.\n<|/ c |>\n<| c |>\nI believe\
    \ I do. `prime_fib(10)` returns `89`, which is the correct output. See my edit\
    \ to see why I believe this is correct.\n<|/ c |>\n<| c |>\nHe missed \"The first\
    \ 10 Fibonacci numbers are 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, and so on\"\
    . Just run your code.\n<|/ c |>\n<| c |>\nYes, I missed that. I guess I am too\
    \ used to the number sequence where `prime_fib(x)` is `fibonacci(x - 1)`. Updated\
    \ my answer.\n<|/ c |>\n<| c |>\nActually i did not understand the first fibonacci\
    \ number which i thought was 1 ,but after running the code i came to know that\
    \ fibonacci(10) is 89 .\n<|/ c |>\n<| a tags=python |>\n<code>", "  if n<2\n \
    \ then\n    puts n\n  elsif n==1\n  then\n    puts 2\n  elsif prime? n\n  then\n\
    \    puts n\n  else\n    puts prime_fib(n-1)+prime_fib(n-2)\n  end\nend", "  fib,\
    \ prime = 1,0\n  while prime < n\n    prime,fib = fib + 2, prime + fib\n  end\n\
    \  prime\nend", "  prime = 1\n  fib = 1\n  i = 2\n  while i < n\n    prime *=\
    \ i\n    fib += i\n    i += 1\n    if fib > n\n      fib = 1\n  end\n  prime_fib\
    \ = prime\nend", "    a, b = 0, 1\n    while a < n:\n        yield a\n       \
    \ a, b = b, a + b\n    yield n", '    return n if n <= 1 or not (n > 1 and n %
    2) else prime_fib(n - 1) + prime_fib(n - 2)', "  return prime_fib_index(n) if\
    \ prime_fib_index(n) <= n else n\nend", "  fibs = [1, 2]\n  while n > 0\n    fib\
    \ = fibs.last + fibs.last\n    fibs.last == fib && fibs.delete_at(-1)\n    n -=\
    \ 1\n  end\n  fibs.last\nend", "    prime_fib_sum = 1\n    prime_fib_sum2 = 2\n\
    \    prime_fib_sum_is_prime = False\n    while prime_fib_sum_is_prime == False:\n\
    \        prime_fib_sum = prime_fib_sum + prime_fib_sum2\n        prime_fib_sum2\
    \ = prime_fib_sum*2\n        if prime_fib_sum > n:\n            prime_fib_sum_is_prime\
    \ = True\n    return prime_fib_sum", "  return prime_fib_aux(n,1,n) if n<n else\
    \ prime_fib_aux(n-1,2,n)\nend", "  result = 0\n  is_prime = true", "  a, b = 0,\
    \ 1\n  while b < n\n    a, b = b, a+b\n  end\n  return a\nend", "  if n <= 1\n\
    \    []\n  else\n    # n should be integer\n    # so if n is bigger than 2 it\
    \ can return only 1 number\n    # so i use while to loop\n    prime = []\n   \
    \ i = 2\n    while i <= n\n      prime << i\n      i = i + 2\n    end\n    prime\n\
    \  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
