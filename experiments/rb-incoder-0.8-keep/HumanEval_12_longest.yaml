name: HumanEval_12_longest
language: rb
prompt: "# Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n# strings of the same length. Return None in case the input\
  \ list is empty.\n# >>> longest([])\n# >>> longest(['a', 'b', 'c'])\n# 'a'\n# >>>\
  \ longest(['a', 'bb', 'ccc'])\n# 'ccc'\ndef longest(strings)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_longest\n\
  \    candidate = method(:longest)\n    assert_equal(nil, candidate.call([]))\n \
  \   assert_equal(\"x\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"\
  zzzz\", candidate.call([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]))\n\
  \  end\nend\n"
completions: ["  # Return the longest string from the input list.\n  # Return the\
    \ first string in case of multiple strings of the same length.\n  # Return None\
    \ in case the input list is empty.\n  return strings.reduce do |s, slist|\n  \
    \  s = slist.first || s\n    s.length < s.length ? s : s\n  end\nend\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nthis solution does not work when given `[\"bb\",\"\
    ccc\"]` which should return `ccc` but returns `bb` instead.\n<|/ c |>\n<| c |>\n\
    Thanks for the comment. I've updated my answer to use `first` instead. Now it\
    \ should work.\n<|/ c |>\n<| c |>\nI've just updated my answer with a shorter\
    \ solution. Can you try it now?\n<|/ c |>\n<| c |>\nI have found a shorter solution.\
    \ I will post it in my answer.\n<|/ c |>\n<| a |>\nHere is a shorter solution\
    \ using Enumerable#max_by\n<code>\nstrings = [\"a\", \"bb\", \"ccc\"]\nstrings.max_by(&:length)",
  "  strings.inject([]) do |res, str|\n    if res.empty?\n      res.push(str)\n  \
    \  elsif res[-1].size < str.size\n      res << str\n    else\n      res[-1]\n\
    \    end\n  end\nend", "  return strings.sort.last.try(:length).try(:to_str)\n\
    end", "  return strings.max_by(&:length).first\nend", "  strings.reduce(::longest)\n\
    end", "  return strings.flatten.reduce(:>) if strings.any?\nend\n</cell>\n<text>\n\
    Now let's use our longest method to get the longest string of a list. We'll also\
    \ print out the length of the string as well.", "  return strings.sort().inject(:<<).last\n\
    end", "  strings.reduce(:max)\nend", "  return strings.sort.reduce(:<<).last unless\
    \ strings.empty?\n  nil\nend", "  return strings.max if strings.size else nil\n\
    end", "  return strings.reduce(&:length) if strings else nil\nend", "  maxlen\
    \ = -1\n  string.find(strings, maxlen) + 1\nend", "  strings.sort\n  longest_string,\
    \ longest_length = nil, nil\n  strings.each do |string|\n    if longest_string\
    \ == nil || longest_string.length < string.length\n      longest_string, longest_length\
    \ = string, string.length\n    end\n  end\n  return longest_string\nend", "  longest\
    \ = strings[0].downcase\n  strings[1..-1].each do |string|\n    longest = (longest\
    \ rescue longest || string).downcase\n  end\n  longest\nend", "  maxlen = -1\n\
    \  maxstr = ''", "  strings.each do |s|\n    length = s.length\n    if longest.length\
    \ <= length\n      longest = s\n    end\n  end\n  longest\nend", "  strings.sort.reverse\n\
    \  lengths = strings.map(&:length).uniq\n  lengths.compact.max\n  strings.find\
    \ { |s| lengths.include?(s.length) } || strings.first\nend", "  return strings.detect\
    \ { |s| s.length >= longest.length } if strings.any?\n  longest.length\nend\n\
    </code>\n<|/ a tags=ruby,arrays,string |>\n<| c |>\nIt appears that `Enumerable#detect`\
    \ has been [removed from Ruby 2.3](https://github.com/ruby/ruby/pull/32351). If\
    \ you are running on Ruby 2.3, you'll have to use `Enumerable#find` instead, or\
    \ just write the loop yourself.\n<|/ c |>\n<| c |>\n, thank you! Updated the answer.\n\
    <|/ c |>\n<| a tags=ruby,arrays,string |>\nYou want the longest string in the\
    \ array. If you are using Ruby >= 2.3 then you can use Enumerable#max with a block:\n\
    <code>", "  return strings[0..-2].max_by(&:length)\nend", "  return strings.sort\
    \ { |a, b| (a.length <=> b.length).zero? ? -1 : 1  }.first\nend\n</code>\n<|/\
    \ a dscore=3 tags=string,ruby |>\n<| c |>\n`longest` is also useful in cases where\
    \ you have a set of numbers and want to find the longest one\n<|/ c |>\n<| c |>\n\
    This solution doesn't seem to be correct. `longest` will return any string that\
    \ has more characters, not the most common string.\n<|/ c |>\n<| c |>\n`longest`\
    \ returns only one string. `longest_string` returns a `String` object.\n<|/ c\
    \ |>\n<| a |>\nI like's answer, but if you also want the count of the most common\
    \ string you could do this:\n<code>", "  return strings.map { |s| s.length }.max\n\
    end", "  if strings.size == 0\n    puts nil\n  else\n    first = strings.first\n\
    \    rest = strings.drop(1)\n    max = first if first.size >= rest.size\n    rest\
    \ = rest.size > max ? rest : rest.first\n    puts rest if rest.size > 0\n  end\n\
    end\n</code>\n<|/ a tags=ruby,sorting,arrays,string |>\n<| c |>\nNice. That's\
    \ basically how I solved it but your method is the best way to learn more about\
    \ Ruby. Thank you.\n<|/ c |>\n<| a |>\nI think this may help:\n<code>", "  return\
    \ strings.max { |a, b| a.length <=> b.length } unless strings.empty?\n  strings.first\n\
    end", "  strings.each do |string|\n    next if string.empty?\n    break if string.length\
    \ == string.length\n  end\n  return nil if strings.empty?\n  strings.max &:length\n\
    end", "  strings.each do |string| \n    if string.length > longest_string then\n\
    \      longest_string = string.length\n    end\n  end\n  longest_string\nend\n\
    </cell>\n<text>\nLet's now apply these tools to the real world to see the results\
    \ :)", "  strings.each_index { |index| strings[index] }\n  strings.max_by(&:length)\n\
    end\n</code>\n<|/ a |>\n<| a dscore=4 tags=ruby |>\nI wanted to share my solution\
    \ for counting array elements which has a more \"elegant\" syntax:\n<code>\nnumbers\
    \ = [1,2,3]\nnumbers.count { |n| n % 3 == 0 || n % 5 == 0 }\n</code>\nThe same\
    \ can be done with inject:\n<code>\nnumbers.inject(0) { |sum, n| sum + (n % 3\
    \ == 0 || n % 5 == 0) }\n</code>\n<|/ a |>\n<| a tags=ruby |>\nTo get a total\
    \ of a certain kind, you can just do numbers + [99] #=> [1, 4, 7, 99, 8] and then\
    \ use .count (or the Enumerable's version). For example:\n<code>\nnumbers = [1,2,3,4,5,6,7,8,9]\n\
    numbers # => [1, 2, 3, 4, 5, 6, 7, 8, 9]\nnumbers + [99] # => [1, 4, 7, 99, 8,\
    \ 9]\nnumbers.count(99) # => 3\n</code>\nIf you want the number of times a certain\
    \ item appears, you can use this:\n<code>\nnumbers.count(99) #=> 3\nnumbers.count(100)\
    \ #=> 0\n</code>\nIf you want to know the total occurrences of a certain kind\
    \ of thing without including it, you can do this:\n<code>\nnumbers = [1,2,3,4,5,6,7,8,9,99,100,200]\n\
    numbers.count(99) + numbers.count(100) # => 3\n</code>\n<|/ a dscore=4 |>\n<|\
    \ a |>\nFor counting how many times one element is in a collection or array, I\
    \ like using inject and map like this:\n<code>\n[1,2,3,4].inject(0) { |sum, i|\
    \ sum + i.even? }", "  return strings.reduce(lambda x,y: (x.length > y.length)\
    \ ? x : y)\nend", "  return strings.max_by { |s| s.length }\nend\n</code>\nAs\
    \ you can see, the above code is pretty much identical to what the code you posted\
    \ above does. Only the implementation is different, and that's because you were\
    \ able to get it working with your code.\n<|/ a tags=ruby,arrays |>\n<| a |>\n\
    <code>", "  if strings.empty?\n    false\n  else\n    length = strings.map { |s|\
    \ s.length }.max\n    strings.find { |s| s.size == length }\n  end\nend", "  return\
    \ strings[0] if strings.size > 1 || (strings.size == 1 && strings[0].length ==\
    \ 0)\nend", "  return strings.sort.reverse.first\nend\n</pre>\n</section>\n<section\
    \ id=\"id12\">\n<pre class=\"code-highlight\">", "  strings.to_a.max_by do |s|\n\
    \    s.length\n  end\nend", "  return strings.max_by(&:length)\nend", "  return\
    \ strings.reduce(lambda a,b|a,b) unless strings.length == 1\n  string.length,\
    \ strings.reduce(lambda a,b|a,b).length\nend", "  lengths = [string.length for\
    \ string in strings]\n  if lengths.empty?\n    nil\n  else\n    strings.max_by(&:length).first\n\
    \  end\nend", "  return strings.max_by(&:length).first if strings.length \n  nil\n\
    end\n</code>\n<|/ a tags=ruby,string dscore=1 |>\n<| c |>\nI find it a bit unlikely\
    \ that a question like this has an accepted answer; it might very well be the\
    \ most useful answer in the year to come. Surely it's good enough to mark it as\
    \ the accepted answer?\n<|/ c |>\n<| c |>\nAgreed, but I was hoping someone would\
    \ come up with a more elegant solution. Perhaps one that uses `Enumerable`? Not\
    \ sure how that would look.\n<|/ c |>\n<| c |>\nThanks guys, I appreciate your\
    \ help and suggestions.\n<|/ c |>\n<| c |>\nA different approach: how about `longest_strings_in_array\
    \ = longest_strings_in_array.max_by(&:length)` (or maybe `longest_strings_in_array.max_by(&length`)?\
    \ It does require an intermediate array, though.\n<|/ c |>\n<| c |>\nGood point,\
    \ I didn't think about it, but it is an alternate approach. Thanks.\n<|/ c |>\n\
    <| a tags=ruby,string dscore=1 |>\nHere's one more way to do it:\n<code>", " \
    \ # Your code here\n  \n  result = strings.map {|s| s.length }.max\n  result =\
    \ strings.select { |s| s.length == result }[0] || nil\n  \n  if result.nil?\n\
    \    return nil\n  else\n    result\n  end\nend", "  strings.each do |string|\n\
    \    length = string.length\n    return string if strings.length == 1\n    return\
    \ string if (length - strings[strings.length-1].length).abs == length\n  end\n\
    \  nil\nend", "  return strings.sort {|a, b| b.length <=> a.length }.first\nend",
  "  max_length = strings[0].length\n  longest_strings = []", "  if strings.empty?\n\
    \    nil\n  else\n    strings.max_by(&:length)\n  end\nend", "  longest = nil\n\
    \  strings.each do |string|\n    if string && longest.length < string.length\n\
    \      longest = string\n    end\n  end\n  longest\nend", "  strings.sort.reverse\n\
    \  longest_strings = nil\n  longest_length = nil", "  strings.max_by { |s| s.length\
    \ }.first\nend\n</code>\nThis solution is much more elegant than the one by Tin\
    \ Man.\n<|/ a dscore=5 |>\n<| c |>\nI think this is much more elegant than the\
    \ `longest` implementation I wrote, which uses the `Enumerable` module's `max_by`\
    \ method. +1 for using `max_by`.\n<|/ c |>\n<| c |>\nI agree. Enumerable's `max_by`\
    \ method is much cleaner and concise than the `longest` method I wrote as well.\n\
    <|/ c |>\n<| c |>\nThis also handles nil values gracefully, whereas `longest`\
    \ would raise an error in that case: `longest(['aaa','bbb','ccc']) # => 'ccc'`\n\
    <|/ c |>\n<| c |>\nThis is more elegant than using max on an array.\n<|/ c |>\n\
    <| a dscore=5 |>\nYou can use max_by to sort by the length descending. Then select\
    \ the first one. \n<code>\nstrings.max_by(&:length).first\n</code>\n<|/ a tags=ruby,string,arrays\
    \ |>\n<| c |>\nThis doesn't work for multi-character strings. What if strings\
    \ had numbers in them? `[ 'a', 123, nil ].max_by(&:length).first # => nil`\n<|/\
    \ c |>\n<| c |>\nThis is why you should use `max_by` and not just `max` when dealing\
    \ with strings. It would handle your example perfectly: `[ 'a', 123, nil ].max_by(&:length).first\
    \ # => 123`\n<|/ c |>\n<| a tags=ruby,string,arrays |>\nYou could use Enumerable#max_by.\n\
    <code>\nstrings.max_by{ |s| s.length }\n</code>\n<|/ a dscore=5 |>\n<| a dscore=4\
    \ tags=ruby,string,arrays |>\nA simple and concise way to do it with Ruby 2.1\
    \ and above is to use Array#min\n<code>\nstrings.min\n</code>\n<|/ a |>\n<| a\
    \ dscore=4 |>\n<code>\nstrings.sort!.first\n</code>\n<|/ a tags=ruby,string,arrays\
    \ |>\n<| c |>\nThis is one of the most elegant solutions I've seen so far. The\
    \ idea of the sort method is to have it sort based on a property, in our case\
    \ a string's length.\n<|/ c |>\n<| c |>\nThis is one of the most elegant solutions\
    \ I've seen so far", "  return strings.sort[-1].last if strings.size > 0 else\
    \ None\nend\n</cell>\n<code language=julia-0.5>", "  strings.inject(nil) do |max,\
    \ s|\n    max || s.length\n  end\nend", "  strings.sort.map { |s| s.length }.max\
    \ || strings.first\nend", "  if strings.empty?\n    return nil\n  else\n    longest\
    \ = strings.sort.last\n    longest.empty? ? first : longest\n  end\nend", "  return\
    \ strings[0] if strings.size >= 1 else None\nend", "    lengths = strings.map\
    \ { |s| s.length }\n    return lengths.max if lengths.any? ", "  strings.sort!\n\
    \  strings[0] == strings[-1] ? (strings[0], strings[length(strings) - 1]) : nil\n\
    end", "  return strings[0] if strings.size == 1 || (strings.size > 1 && (strings[-2].length\
    \ <=> strings[-1].length) == 0) end\nend", "  result = strings[0]\n  max_len =\
    \ -1\n  while !empty? strings\n    if strings.length > 1\n      len = strings.map\
    \ {|s| s.length}.max\n    else\n      len = strings[0].length\n    end\n    if\
    \ len > max_len\n      max_len = len\n      result = strings.shift\n    end\n\
    \  end\n  result\nend", "  longest_string = None\n  longest_length = 0\n  if strings.empty?\n\
    \    return longest_string\n  else\n    strings.each do |string|\n      if string.size\
    \ > longest_length\n        longest_length = string.length\n        longest_string\
    \ = string\n      end\n    end\n    return longest_string\n  end\nend", "  # If\
    \ the list is empty, return none\n  return strings[0] if strings.size == 1 else\
    \ None", "  return strings.max() || strings.min() || strings.first\nend", "  if\
    \ strings.empty?\n    raise(ArgumentError, \"list of strings can't be empty\"\
    )\n  else\n    longest_length = strings.first.size\n    return strings.first.last\
    \ if longest_length > strings.last.size || longest_length == strings.last.size\n\
    \  end \nend", "    strings.each do |string|\n        length = string.length\n\
    \        if length > strings_length\n            strings_length = length\n   \
    \         longest_string = string\n        end\n    end\n    longest_string\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby dscore=0 |>\n<code>", "  longest_strings\
    \ = []\n  longest_length = 0", "  strings.compact.max_by(&strings.length)\nend\n\
    \  ", "  strings.each_with_index.max_by { |s, i| s.length }\nend", "  strings.sort.each\
    \ {|s| return s if (s.size > strings.length); strings.length = s.size if strings.length\
    \ == 0}\n  strings.length\nend", "  strings.each_with_index do |s, i|\n    return\
    \ s if i == strings.size - 1\n    return s if s.length < strings[i].length\n \
    \ end\n  nil\nend", "  return strings.compact.max_by(&:length) || strings.first\n\
    end", "  strings.sort.last\n  strings.length.times { |i| break if strings[i] ==\
    \ strings[0] }\n  strings[0,i-1]\nend", "  strings.each_with_index.max_by { |string,\
    \ i| string.length }\nend", "  longest = strings[0]\n  strings.size.times do |i|\n\
    \    longest = strings[i] if strings[i].length >= longest.length\n  end\n  longest\n\
    end", "  strings.sort.find { |string| string.length } || strings.first\nend",
  "  max = 0\n  result = nil\n  strings.each { |s|\n    max = [max].max\n    if max\
    \ != 0\n      if max == s.length\n        result = s\n      else\n        result\
    \ = None\n      end\n    end\n  }\n  result\nend", "  strings.reduce(&:length)\
    \ if strings.length >= 1 end\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ dscore=1 |>\n<code>", "  return strings.sort { |a, b| a.length <=> b.length\
    \ }[1..-1] || 'None'\nend", "  return strings.sort.last.first if strings.length\
    \ > 0 else None\nend", "  strings.map!(&:length)\n  return strings.max_by(&:length)\
    \ rescue nil\nend", "  return strings.sort.last rescue nil\nend", "  return strings.sort.last.nil?\
    \ ? None : strings.sort.last\nend", "  strings.reduce(:max)\nend", "  lengths\
    \ = strings.map { |s| s.length }\n  strings.max { |s1, s2| lengths.include? s2.length\
    \ }\nend", "  result = strings[0]\n  lens = []\n  \n  strings.each do |s|\n  \
    \  lens << s.length\n    \n    if result.length < s.length\n      result = s\n\
    \    end\n  end\n  \n  result = nil if lens.empty?\n  result = lens.max unless\
    \ lens.include? result.length\n  result\nend", "  return strings.length > 0 ?\n\
    \    strings.max_by(&:length).first :\n    strings\nend", "  result = nil\n  if\
    \ strings.size == 0\n    result\n  else\n    strings.each_with_index do |str,\
    \ i|\n      if strings[i].length < strings.length\n        result =  str\n   \
    \     break\n      end\n    end\n    result\n  end\nend", "  if strings.empty?\n\
    \    false\n  else\n    l = strings.length\n    strings.max\n  end\nend", "  strings.sort.last\n\
    end", "  max_len = nil\n  strings.each do |string|\n    max_length = string if\
    \ string && string.length > max_len && string.length > 0\n  end\n  return max_length\
    \ if max_length\nend\n</code>\n<|/ a |>\n<| c |>\nThe OP wants the longest string,\
    \ not all strings.\n<|/ c |>\n<| c |>\nThanks for reminding me of that point,\
    \ I missed that in my first look. It was a good addition for my answer. I'll add\
    \ it to the code now!\n<|/ c |>\n<| c |>\nYes, sorry, I realized the problem now.\
    \ Thanks for reminding me again though.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "\tlongest = []\n\tlongest_length = 0\n\tfor i in strings\n\t\tif i.length > longest_length\n\
    \t\t\tlongest, longest_length = i, i.length\n\t\n\treturn longest[0] if longest\
    \ && longest_length > 0 else None\nend", "  strings.reduce(:<<)\nend", "  return\
    \ strings.find { |s| s.length >= longest(s.split) } || strings.first\nend", " \
    \ strings.each do |string|\n    next_longest_string = string if string.length\
    \ > next_longest_string.length\n  end", "  strings = strings.sort # Sort the strings\
    \ first, to keep track of how long the longest one is\n  if strings.length ==\
    \ 1\n    return strings[0]\n  longest_string = strings[0]\n  longest_string_length\
    \ = strings.length\n  for i in 1..strings.length\n    string = strings[i]\n  \
    \  string_length = strings.length\n    if string_length > longest_string_length\n\
    \      longest_string = string\n      longest_string_length = string_length\n\
    \    end\n  end\n  return longest_string\nend", "  strings.sort { |s1, s2| s2.length\
    \ <=> s1.length } && strings[0] || nil\nend", "  strings.map!{ |s| s.length }\
    \ # Make sure strings have the same length\n  return strings.max_by(&:length)\n\
    end", "  if strings.empty?\n    return nil\n  elsif strings.size == 1\n    return\
    \ strings.first\n  end", "  strings.sort!\n  return strings.last if strings.any?\
    \ and strings.all? { |s| s.length == strings[0].length } and !strings.empty? and\
    \ strings.first.length == strings[0].length else nil\nend", "  strings.flatten.compact.max_by(&:length).first\n\
    end", "  return strings[0] if strings.count > 1 then strings.max[1] else strings[0]\
    \ if strings.count > 0 else None\nend", "  longest = strings.max_by(&:length)\n\
    \  return longest.first if longest\nend", "  return strings.max {|a, b| a.length\
    \ < b.length ? a : b}\nend", "  strings.reduce(0) { |max_size, str| max_size if\
    \ str.length == max_size.length then str else nil }\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nI love this solution, and I have it running on my machine, but\
    \ I always wonder if this can be made more efficient. Perhaps someone else can\
    \ come up with a more efficient solution...\n<|/ c |>\n<| c |>\nI took me a while\
    \ to understand it as well. I'd love to know what part of this is more efficient.\n\
    <|/ c |>\n<| c |>\nThis should be the selected answer! It's clear, concise, and\
    \ quite efficient.\n<|/ c |>\n<| c |>\nThis should be the selected answer! It's\
    \ clear, concise, and quite efficient.\n<|/ c |>\n<| a |>\nYou can use the Enumerable\
    \ library (http://ruby-doc.org/core/classes/Enumerable.html) to do this:\n<code>",
  "  strings.sort { |a, b| b.length <=> a.length }\n  strings.last || strings.first\n\
    end", "  if strings.empty?\n    None\n  else\n    strings = strings.to_a\n   \
    \ strings = strings.select { |string| string if string.size > 0 }\n    strings.max_by(&:size).first\n\
    end", "  if strings.empty?\n    nil\n  else\n    strings.to_s.sort.last\n  end\n\
    end\n</code>\nThe only thing left to do is implement this into a recursive function.\
    \  I'll leave that to you. Good luck!\n<|/ a tags=ruby |>\n<| c |>\nJust a small\
    \ comment, when writing `longest([])`, there is no need to write `nil`, because\
    \ `nil` is the return value of a method if it wasn't able to find a value.\n<|/\
    \ c |>\n<| a dscore=1 |>\nHere's another way of doing it using map and join:\n\
    <code>", "  strings.each do |s|\n    if s.length > max_length\n      max_length\
    \ = s.length\n    end\n  end\n  return max_length if strings.length > 0\n  nil\n\
    end", "  longest = strings.first.to_s.size\n  strings.each do |string|\n    if\
    \ string.to_s.size>longest\n      longest = string.to_s.size\n    end\n  end\n\
    \  return nil if longest == 0\n  return strings.first.to_s if longest == strings.first.to_s.size\n\
    \  longest.downcase\nend", "  return strings.sort.last.nil? ? None : strings.sort.last\n\
    end", "  return strings.max_by(&:length)\nend", "  strings.sort!\n  return strings.last\
    \ if strings.length > 0 else None\nend", "  strings.sort.with_index { |element,\
    \ index|\n    length =\n      if index == 0\n        element.size\n      else\n\
    \        element.size <=> strings[index-1].size\n      end\n    [length, index]\n\
    \  }.last.last\nend", "  strings = strings ? strings : []\n  lengths = strings.map\
    \ { |s| s.length }\n  max_length = lengths.max\n  max_length == 0 ? nil : strings[lengths.index(max_length)]\n\
    end", "  maxlen = -1\n  maxstr = ''\n  strings.each do |str|\n    if str.size\
    \ > maxlen\n      maxlen = str.size\n      maxstr = str\n    end\n  end\n  maxstr\n\
    end", "  return strings.sort.last.try(:length) || strings.first.try(:length)\n\
    end", "  strings.each do |string|\n    return string if string.length < length\n\
    \  end", "  return strings.max_by(&:length)\nend", "  strings.reduce(:min).to_s\n\
    end", "  # Sort the input list, so that longer strings are at the end of the list\n\
    \  strings.sort\n  # Keep track of the longest string seen so far\n  max_len =\
    \ strings[0].length", "  longest = strings.reduce([], :[]).reduce(:[], :max)\n\
    \  strings.find { |string| longest == string.length } if strings.any?\nend", " \
    \ result = nil\n  strings.each do |string|\n    if result.nil?\n      result =\
    \ string\n    else\n      if string.length >= result.length\n        result =\
    \ string\n      end\n    end\n  end\n  result\nend", "  strings.reduce(:max) unless\
    \ strings.empty?\nend", "  strings.sort.map { |s| s.length }.max if strings.any?\n\
    end", "  longest = strings[0]\n  strings.each { |s| longest = s.length if s.length\
    \ > longest }\n  longest\nend", "  return strings.ma(:length).min.first if strings.any?\
    \ && strings.length <= 1\n  nil\nend\n</code>\n<|/ a |>\n<| c |>\nThis solution\
    \ is actually the best for me. I've modified it to accept a default value if the\
    \ strings array is empty (return nil instead of nil on the last line). Thanks\
    \ for sharing.\n<|/ c |>\n<| c |>\nYes, this works, but it is incorrect: it will\
    \ return `nil` on an empty array (and it will return `nil` on any array which\
    \ has no strings). It also doesn't work on empty strings (it returns an empty\
    \ string instead of a string), which would make it more correct: `return strings.ma(:length).min.first\
    \ || nil`\n<|/ c |>\n<| a dscore=2 |>\nHere is my own solution, which doesn't\
    \ require enumerators, strings or regexes.\n<code>", "  if strings.empty?\n  \
    \  true\n  else\n    strings.map { |s| s.length }.max || strings.first\n  end\n\
    end", "  longest = strings.first\n  strings.each_index do |i|\n    longest = strings[i]\
    \ if strings[i].length > longest.length\n  end\n  longest\nend", "  # The \"if\"\
    \ statement ensures there is at least one string in the list\n  if strings.empty?\n\
    \    # Return None in case the input list is empty\n    return nil\n  else\n \
    \   # Get the longest string from the input\n    longest_string = strings.max_by(&:length)\n\
    \    # If there are multiple strings of the same length (the longest string),\
    \ return the first\n    longest_string.size > 1 ? longest_string : nil\n  end\n\
    end", "  if strings.empty?\n    None\n  else\n    strings.max\n  end\nend", " \
    \ return strings[0] if strings.size == 1 || (strings.size > 1 && strings.sizes.max\
    \ == strings.sizes.sizes.size) else None\nend", "  strings.each_with_index.max\
    \ {|x, i| x.length }\nend", "\tl = strings.length\n\tmax = nil\n\tfor i in 0...l\n\
    \t\tstr = strings[i]\n\t\tbreak if i > l-1\n\t\tmax = str if str.length > max\n\
    \tend\n\treturn max\nend", "    strings.sort { |x, y| x.length <=> y.length }\n\
    \    strings.first\nend", "  return strings.max_by(&:length)\nend", "  if strings.empty?\n\
    \    false\n  else\n    longest = strings.max\n    strings.each do |s|\n     \
    \ if longest.length < s.length\n        longest = s\n      end\n    end\n    longest\n\
    \  end\nend", "  strings.sort.with_index { |_, i| [strings[i], i].max_by { |s|\
    \ s.length } }\nend", "  return strings.first(length: -1).to_s if !strings.length?\
    \ # Empty list\n  longest = strings.first(length: -1).to_s\n  strings.each do\
    \ |string|\n    longest = (string if longest.length < string.length).to_s\n  end\n\
    \  longest\nend", "  strings.sort.with_index { |s, i| s[i] = s[i] = 0 }\n  longest\
    \ = strings.sort.last\n  strings.sort.with_index { |s, i| s[i] = 0 if s[i] > longest.length\
    \ } if strings\n  longest\nend", "  return strings[0] if strings.count > 0 else\
    \ strings.max\nend", "  # Your code here\n  longest = nil\n  strings.each do |string|\n\
    \    next if string.empty?\n    length = string.length\n    longest = string if\
    \ length > longest.length\n  end\n  longest\nend", "  strings.sort.last\nend",
  "  return strings.sort.last.try(:first) || nil\nend", "  strings.each { |string|\n\
    \    longest = string if string.length <= longest.length\n  }\n  longest unless\
    \ strings.empty?\nend", "  strings.sort\n  strings.each do |string|\n    return\
    \ string if string.length <= strings[0].length\n  end\n  nil\nend\n</pre>", " \
    \ return strings.map(&:length).sort.last\nend", "  longest_length = strings[0].length\n\
    \  longest_string = strings[0]", "  strings.flatten.max_by { |s| s.length }\n\
    end", "  return strings.reduce(\n    lambda prev, curr: prev.length if prev.length\
    \ > curr.length else curr.length, \n    strings.first\n  )\nend\n</cell>\n<text>\n\
    String::upcase\nSee String#upcase", "  case strings.empty?\n  when true\n    return\
    \ nil\n  when false\n    return strings.first\n  end\n  \n  longest_length = strings.length\n\
    \  longest_string   = nil\n  \n  strings.each do |string|\n    if string.length\
    \ > longest_length\n      longest_string = string\n      longest_length = string.length\n\
    \    end\n  end\n  \n  longest_string\nend", "  strings.each_with_index.max_by{|s,i|\
    \ s.length}\nend", "  lengths = strings.map { |s| s.length }.uniq.sort\n  strings.find\
    \ { |s| lengths.include? s.length } || None\nend", "  # Return None in case the\
    \ input list is empty.\n  result = nil\n  strings.each do |string|\n    unless\
    \ result || (string.length >= result.length)\n      result = string\n    end\n\
    \  end\n  result\nend", "  strings.sort.map(&:length).max || strings.first\nend",
  "  # Find the length of each string in the list.\n  lengths = strings.map(&:length)\n\
    \  # Return the index of the longest string, if any.\n  i = lengths.index(max_length(&lengths))\n\
    \  i ? strings[i] : nil\nend", "  return strings.sort { |x, y| y.length <=> x.length}.first\n\
    end", "  return strings.inject([]) do |list, (item, count)|\n    list.unshift(item)\
    \ if list.size < count\n    list.last\n  end\nend", "  strings.map { |s| s.length\
    \ }.max || strings.first\nend", "  strings.inject([]) {|list, e| list << e if\
    \ list.empty? || list.map{|str| str.length}.max > str.length}\n  strings.first\
    \ unless strings.empty?\nend", "  return strings.max_by { |s| s.length }\nend",
  "  max = 0\n  current_length = 0\n  current_string = \"\"\n  strings.each do |string|\n\
    \    current_length += 1\n    if current_length > max\n      max = current_length\n\
    \      current_string = string\n    end\n  end\n  return current_string if max\
    \ > 0\n  return nil\nend", "  return strings.map { |s| s.size }.max if strings.any?\n\
    \  nil\nend", "  return strings.first if strings.count > 1 && (strings.first.length\
    \ ||\n    strings.any? { |s| s.length == strings.count }\n  else\n    strings.first\n\
    \  end\nend", "  strings = strings if strings.length > 0 else ['']\n  \n  return\
    \ strings.reduce( (max, str) -> max if str.length == max else str.length, nil)\n\
    end\n</code></pre>", "  strings.max_by(&:length).first\nend", "\tlongest_length\
    \ = strings[0].length\n\tlongest_string = strings[0]", "  strings.reduce(:length).max\
    \ || strings.first || nil\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI think this\
    \ should be the accepted answer - it is concise and does a nice job of avoiding\
    \ multiple loops. As an added bonus, this works for strings as well as arrays\
    \ (which would otherwise require a slightly different definition of `longest`)\n\
    <|/ c |>\n<| c |>\nIn addition to your answer, if you use the `Enumerable` module\
    \ like so: `require 'enumerator'; Enumerable#max{|a,b| a <=> b}; #=> nil` you\
    \ can also do this with Ruby 2.2+ or any version of Ruby >= 2.2: `Enumerable.max{|a,b|\
    \ a <=> b}; #=> nil`\n<|/ c |>\n<| c |>\nGreat answer! This should be the accepted\
    \ answer (the others use loops and are less efficient).\n<|/ c |>\n<| c |>\nI\
    \ like this answer the most. I'd personally rename `longest` to `longest!`, but\
    \ that may not be a bad idea either.\n<|/ c |>\n<| c |>\n\"The longest string\"\
    \ doesn't mean the longest element - it's meant more as a default value if all\
    \ elements have the same length.\n<|/ c |>\n<| a |>\nAs many have pointed out,\
    \ there are several ways to do this in Ruby. However, I personally like the ternary\
    \ operator because it is more concise:\n<code>\n strings.reduce(:<=>).max\n</code>\n\
    That said, I find that ternary operators are often considered bad practice. The\
    \ Ruby Programming Language has a few recommendations:", "  max_len = strings[0].size\n\
    \  max_string = strings[0]\n  strings.each do |string|\n    if string.size > max_len\n\
    \      max_len = string.size\n      max_string = string\n    end\n  end\n  max_string\n\
    end", "  strings.each { |str| return str if str.size > string_size }\n  strings.first\n\
    end", "    longest_length = nil\n    longest_string = nil\n    strings.each do\
    \ |string|\n        if longest_length == nil || string.length < longest_length\n\
    \            longest_length = string.length\n            longest_string = string\n\
    \        end\n    end\n    return longest_string\nend", "  result = strings[0]\n\
    \  \n  if strings.length > 1\n    \n    longest_string = strings[0]\n    longest_string_length\
    \ = 0\n    \n    strings.each do |s|\n      if s.length >= longest_string_length\n\
    \        longest_string = s\n        longest_string_length = s.length\n      end\n\
    \    end\n    \n    result = longest_string\n  end\n  \n  return result\nend",
  "  return strings.reduce(:<=>)[1] if strings.length else None\nend", "  strings.compact.sort.last\n\
    end", "  strings.sort!\n  strings.length.times do |i|\n    return strings[0] if\
    \ strings[i].length == strings.length\n  end\n  nil\nend", "  result = nil\n \
    \ strings.each do |string|\n    result ||= string.dup\n    break if string.length\
    \ >= result.length\n    result = string\n  end\n  result\nend", "  longest_length\
    \ = 0\n  longest_string = None\n  strings.each do |string|\n    length = string.length\n\
    \    if length > longest_length then\n      longest_string = string\n      longest_length\
    \ = length\n    end\n  end\n  longest_string\nend", "  strings.sort.reverse\n\
    \  strings.compact.first\nend", "  strings.each.with_index do |s, i|\n    return\
    \ s if s.length == i.length\n  end\n  strings.first\nend", "  strings.sort! #\
    \ Sort strings in ascending order\n  return strings[0] if strings.size > 1 else\
    \ None\nend\n</code>\n<|/ a tags=arrays,ruby,sorting,string dscore=1 |>\n<| a\
    \ dscore=1 |>\nAs I understood, you need to find longest string in an array of\
    \ strings, so here is my solution:\n<code>", "  return strings.reduce(&:length)\
    \ rescue nil\nend", "  return strings.sort.last.nil? ? strings.first : longest(strings[1..-1])\
    \ if strings.length > 1\n  nil\nend", "  strings.sort\n  last_size = nil\n  last_string\
    \ = nil\n  strings.each do |string|\n    size = string.length\n    if last_size\
    \ && last_size != size\n      return last_string\n    end\n    last_size = size\n\
    \    last_string = string\n  end\n  nil\nend", "  if strings.length == 0\n   \
    \ puts \"Nothing to compare\"\n    return\n  result = nil\n  strings.each { |string|\n\
    \    if !result || string.length >= result.length\n      result = string\n   \
    \ end\n  }\n  result\nend", "  strings.sort!\n  max_length = 0\n  longest_string\
    \ = strings[0]\n  if strings.length == 1\n    return longest_string\n  else\n\
    \    strings.each do |s|\n      max_length = s.length if s.length <= max_length\n\
    \    end\n    longest_string\n  end\nend", "  strings.map {|s| s.chars.max}\n\
    \  strings.reduce(&:max)\nend", "  return strings.max_by { |str| str.size }\n\
    end", "  return strings.to_a ? strings.max_by { |string| string.size } : strings.first\n\
    end", "  return strings.sort.last if strings.sort.count > 1 \n  strings.sort.first.last\
    \ if strings.sort.count > 1\n  strings.sort.first\nend", "  if strings.length\
    \ == 0\n    puts \"Nothing found\"\n    return\n  else\n    puts strings.sort.last.dup\n\
    \  end\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", "  return strings.inject { |m,\
    \ s| m.length < s.length ? m : s }\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    Thanks for the answer. My goal was to have a function without using inject :)\
    \ And I guess your solution is more robust than mine.\n<|/ c |>\n<| a tags=ruby,arrays,sorting,max\
    \ |>\nI like answer\n<code>", "  return strings.reduce(:<<, :<<) if strings.any?\
    \ && strings.size > 1\n  strings.reduce(:<<, :<<).first if strings.any? && strings.size\
    \ >= 1\n  nil\nend", "  strings.each { |str| return str } if strings.size > 0\n\
    \  strings.size > 0 ? strings[0] : nil\nend", "  strings.compact.map { |str| str.size\
    \ }.max rescue nil\nend", "  return strings.reduce(:<=>).max_by {|a| a.length\
    \ }[0] if strings\nend", "  case strings.empty?\n    when true\n      return nil\n\
    \    when false\n      return strings.first\n  end\n  \n  case strings.size\n\
    \    when 0\n      return nil\n    when 1\n      return strings.first\n    when\
    \ 2\n      return strings.first\n  else\n    longest = nil\n    strings.each_with_index\
    \ do |s, i|\n      if longest == nil || s.length < longest.length\n        longest\
    \ = s\n      end\n    end\n    return longest\n  end\nend\n</cell>\n<text>\nThe\
    \ longest() function works on a list of strings. Try it out to see what it does:",
  "  return strings.reduce(:max) if strings.any? else nil\nend", "  longest = strings[0]\n\
    \  longestLength = longest.bytesize", "  # return strings[0] if strings.size >\
    \ 0 else \"None\"\n  # If we're not dealing with a list, just return the longest\
    \ string\n  case strings\n  when Array\n    longest = nil\n    strings.size.times\
    \ do |i|\n      longest = strings[i] if longest.length < strings[i].length\n \
    \   end\n    return longest\n  when String\n    longest = nil\n    strings.size.times\
    \ do |i|\n      longest = strings[i] if longest.length < strings.length\n    end\n\
    \    return longest\n  end\nend", "  return strings.sort!.reverse.reduce(:<<).to_s\
    \ if strings.count > 1\n  strings.sort!.reduce(:<<).to_s if strings.count == 1\n\
    end", "  strings.each do |string|\n    return string if string.length >= longest_string.length\n\
    \    longest_string = string\n  end\n  return longest_string if longest_string\n\
    \  return strings[0] if strings.length == 1\nend", "  return strings.length ?\
    \ strings.reduce(:<<) : strings.first\nend", "  return strings.first(2).max\n\
    end", "    longest = nil\n    longest_length = -1\n    strings.each do |string|\n\
    \        string = string.dup\n        string.gsub!(/\\s+/, ' ') unless string.empty?\n\
    \        if string.gsub(/\\s+/, ' ').length >= longest_length\n            longest_length\
    \ = string.gsub(/\\s+/, ' ').length\n            longest = string\n        end\n\
    \    end\n    return longest if longest_length > 0\n    longest\nend", "  return\
    \ strings[strings.max_by { |s| s.length }] if strings.size > 0 &&\n    strings.size\
    \ >= 2 &&\n    strings.uniq.size == strings.size\n  strings[0] if strings.size\
    \ == 1\nend", "  if strings.empty?\n    strings = strings[0..-2]\n  else\n   \
    \ strings = strings.sort_by { |s| s.length }\n  end\n  longest = strings.last\n\
    \  longest.nil? ? strings[0] : longest\nend", "  return strings.size == 0 ? nil\
    \ : strs.max_by { |s| s.length } rescue nil\nend", "  strings.sort! # We sort\
    \ the strings to get the longest one\n  return strings[0,1] if strings.length\
    \ > 1 else None\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
