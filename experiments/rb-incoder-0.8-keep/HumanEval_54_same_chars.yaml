name: HumanEval_54_same_chars
language: rb
prompt: "# Check if two words have the same characters.\n# >>> same_chars('eabcdzzzz',\
  \ 'dddzzzzzzzddeddabc')\n# True\n# >>> same_chars('abcd', 'dddddddabc')\n# True\n\
  # >>> same_chars('dddddddabc', 'abcd')\n# True\n# >>> same_chars('eabcd', 'dddddddabc')\n\
  # False\n# >>> same_chars('abcd', 'dddddddabce')\n# False\n# >>> same_chars('eabcdzzzz',\
  \ 'dddzzzzzzzddddabc')\n# False\ndef same_chars(s0, s1)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_same_chars\n\
  \    candidate = method(:same_chars)\n    assert_equal(true, candidate.call(\"eabcdzzzz\"\
  , \"dddzzzzzzzddeddabc\"))\n    assert_equal(true, candidate.call(\"abcd\", \"dddddddabc\"\
  ))\n    assert_equal(true, candidate.call(\"dddddddabc\", \"abcd\"))\n    assert_equal(false,\
  \ candidate.call(\"eabcd\", \"dddddddabc\"))\n    assert_equal(false, candidate.call(\"\
  abcd\", \"dddddddabcf\"))\n    assert_equal(false, candidate.call(\"eabcdzzzz\"\
  , \"dddzzzzzzzddddabc\"))\n    assert_equal(false, candidate.call(\"aabb\", \"aaccc\"\
  ))\n  end\nend\n"
completions: ["  i = 0\n  j = 0\n  while (i < s0.length) and ( j < s1.length)\n  \
    \  if s0[i] == s1[j]\n      i += 1\n      j += 1\n    else\n      i += 1\n  return\
    \ i == s0.length and j == s1.length\nend", "  if len(s0) == 0 or len(s1) == 0\n\
    \    false\n  else\n    s0_chars = s0.downcase\n    s1_chars = s1.downcase\n \
    \   s1_chars = s1_chars.gsub('\\000', '')\n    s1_chars = s1_chars.gsub('\\000',\
    \ '')\n    s1_chars = s1_chars.gsub('\\000', '')\n    s1_chars = s1_chars.gsub('\\\
    000', '')\n    s1_chars = s1_chars.gsub('\\000', '')\n    if s0_chars.size !=\
    \ s1_chars.size\n      false\n    else\n      s1_chars.each do |s2_char|\n   \
    \     if s0_chars.include?(s2_char)\n          true\n        else\n          false\n\
    \        end\n      end\n    end\n  end\nend\n</code>\n<|/ a tags=string,ruby\
    \ |>\n<| c |>\nWhy not use String#include? instead of gsub?\n<|/ c |>\n<| c |>\n\
    Yes, this would be much nicer, but I was under the impression that the OP wants\
    \ to ignore capitalization when comparing.\n<|/ c |>\n<| a |>\nA variation on's\
    \ answer. \n<code>", "\t\n\t# Make sure the strings don't have empty strings.\n\
    \tif s0 == '' or s1 == '' or s0 ^ s1 == '' then return false", "  return ((s0\
    \ == s1) or (len(s0) == 1 and len(s1) == 1 and s0[0] == s1[0]))\nend", "  return\
    \ all(c0 ^ c1 for c0, c1 in zip(s0, s1))\nend", "  s0.split(\"\").sort.uniq.size\
    \ <= s1.split(\"\").sort.uniq.size\nend", "  s1 = s1.chars.to_a\n  s0 = s0.chars.to_a\n\
    \  if s0.length != s1.length\n    return false\n  for i in 0..(s0.length - 1)\n\
    \    if s0[i] != s1[i]\n      return false\n  return true\nend", "  s0_c = s0.chars\n\
    \  s1_c = s1.chars\n  return (s0_c.size == 0 and s1_c.size > 0) or s0_c == s1_c\n\
    end", "  s0, s1, = s0, s1 # unpack argument list\n  return all( s0[i] == s1[i]\
    \ for i in range(len(s0)) ) # all characters are the same?\nend", "  return (\
    \ len(s0) == len(s1) and\n           all(a == b for a, b in zip(s0, s1)) and\n\
    \           not any(a == b for a, b in zip(s0, s1))\n         )", "  i0 = 0\n\
    \  i1 = 0\n  if s0.length < s1.length\n    i0 = s0.length\n    i1 = s1.length\n\
    \    s0, s1 = s1, s0\n  while i0 < i1\n    if s0.chars.eql?(s1.chars)\n      return\
    \ true\n    i0 += 1\n    i1 += 1\n    s0, s1 = s1, s0\n  false\nend", "  (s0.length\
    \ != s1.length) ? false : true\n  (0..s0.length).find { |i| s0[i] != s1[i] }\n\
    end", "  if len(s0) != len(s1) then\n    return false\n  for i = 0, #s0 do\n \
    \   if s0[i] ~= s1[i] then\n      return false\n    end\n  end\n  return true\n\
    end", "\treturn (type(s0) == String and type(s1) == String) and s0 == s1\nend",
  "  return s0.chars == s1.chars\nend", "  i = s1 = ''\n  while i < s0.length\n  \
    \  s1 = s1 + s0.charAt(i)\n    i += 1\n  return i == s0.length\nend\n</code>\n\
    <|/ a tags=ruby,string dscore=4 |>\n<| c |>\nNot only does this solution work\
    \ in both Ruby 1.9 and 2.1, but it also works in Ruby 1.8.  It also works in Ruby\
    \ 2.0 and Ruby 2.1.  That said, I like this answer the best because it works across\
    \ all versions of Ruby.  Also, this is a great example of how functional programming\
    \ can really help here.  In Ruby, you should be able to write a method that does\
    \ this logic using map/collect and no looping at all.\n<|/ c |>\n<| c |>\nI used\
    \ this solution in combination with the answers above and here is a simple solution\
    \ that checks whether a string is palindrome or not:\n`def palindrome?(string)\n\
    \  string.reverse.eql?(string)\nend`\n<|/ c |>\n<| a dscore=4 tags=ruby,string\
    \ |>\nIf you're looking for a Ruby 1.9-only solution, here's a solution that works\
    \ for both Ruby 1.8 and Ruby 1.9:\n<code>", "  # Python sets aren't hashable.\n\
    \  return s0.chars == s1.chars\nend", "  return (s0==s1) or (s0==\"\" and s1==\"\
    \") or (s1==\"\" and s0==\"\")\nend", "\ts0_size = size_s0(s0)\n\ts1_size = size_s1(s1)",
  "  if s0.length != s1.length\n    return false\n  (0..length-1).each do |i|\n  \
    \  return false if (s0[i] != s1[i])\n  end\n  return true\nend", "  chars = char_list(s0)\n\
    \  chars = chars.sort\n  chars = chars.reverse\n  chars = chars.join\n  return\
    \ chars(s1)==chars(s0)\nend", "  # Split each string into its characters and then\
    \ use sets to\n  # compare them.\n  s0, s1 = s0.chars, s1.chars\n  return set(s0)\
    \ == set(s1)", "    chars1 = chars(s1)\n    chars0 = chars(s0)\n    return chars0\
    \ == chars1\nend\n</cell>\n<code language=julia-1.0>\nfunction chars(s)\n    chars\
    \ = \"\"\n    for i in eachindex(s)\n        chars = chars.*s(i)\n    end\n  \
    \  return chars\nend\n</cell>\n<code language=julia-1.0>", "    s0 = s0.to_s\n\
    \    s1 = s1.to_s\n    s0_len = s0.length\n    s1_len = s1.length\n    return\
    \ s0_len == s1_len and s0_len > 0 and s0.chars == s1.chars\nend", "    return\
    \ s0 == s1 or (s0 and s1 and ord(s0[0]) == ord(s1[0]) and same_chars(s1[1:], s0[1:]))\n\
    end", "  s0, s1 = s0.chars.sort, s1.chars.sort\n  ((s0.last, s1.last),\n   (s0.first-1,\
    \ s1.first-1)) if ((s0.first, s1.first) <\n                                  \
    \      (s0.last, s1.last))\n  else ((s0.first-1, s1.first-1),\n       (s0.last,\
    \ s1.last))\nend # same_chars", "  s0 = s0.upcase.to_s\n  s1 = s1.upcase.to_s\n\
    \  return s0.each_char.to_a.sort == s1.each_char.to_a.sort\nend", "    # Write\
    \ your code here\n    if len(s0) > len(s1)\n        return same_chars(s1, s0)\n\
    \    else \n        return s1[-len(s0)] == s0[-len(s0)]", "    sz = size(s0)\n\
    \    sc = size(s1)\n    if sc == sz\n        return true\n    if sc > sz\n   \
    \     return s0.chars(sc) == s1.chars(sz)\n    end\n    for c in s0:\n       \
    \ if c != s1\n            return false\n    end\n    return true\nend", '    return
    not (len(s0) - len(s1)) ^ not (len(s1) - len(s0))', "  return (s0 =~ /\\w/) &&\
    \ s1 =~ /\\w/\nend", "  return s0 == s1 and all(len(s0) == len(s1) or s1[idx]\
    \ == s0[idx] for idx in range(len(s0)))\nend", "  # Create two hashes\n  h0 =\
    \ s0.each_char.inject(Hash.new{|h,c| h[c]=0}) { |h, (k, v)| h[k] += v }\n  h1\
    \ = s1.each_char.inject(Hash.new{|h,c| h[c]=0}) { |h, (k, v)| h[k] += v }\n  #\
    \ Scan through them, counting up how many characters they both have\n  h0.each\
    \ { |k,v| h1[k] += v }\n  h1.each { |k,v| h0[k] += v }\n  (h0 == h1).all?\nend",
  "  return s0.length == s1.length and \\\n  all(s0[i] <= s1[i] for i in range(len(s0)))\n\
    end", "  s0, s1 = s0.chars, s1.chars\n  n_0 = s0.size\n  n_1 = s1.size\n  return\
    \ n_0 == n_1 && (n_0 == 0 || s0.all?\n    s0[0..n_0/2] === s1[0..n_1/2] &&\n \
    \   same_chars(s1[n_0/2..-1], s1[(0..n_1-1).succ])\n  )\nend", '    return s0
    == s1 or s0.endswith(s1)', "  if s0.length != s1.length\n    then return false\n\
    \  if s0 != s1\n    then return false\n  for i in 0..length(s0)\n    then if s0.charAt(i)\
    \ != s1.charAt(i)\n      then return false\n    else if i == length(s0) - 1\n\
    \      then return true\n    else return same_chars(s0.substring(i, i + 1), s1.substring(i\
    \ + 1, i + 2))\n  else return true\nend\n\"\"\"\n</cell>\n<cell>", "  if s0.empty?\
    \ or s1.empty?\n    false\n  else\n    s0 === s1 && (s0.size > s1.size ? s0 <\
    \ s1 : s0 > s1)\n  end\nend\n</code>\n<|/ a dscore=0 tags=arrays,ruby |>\n<| c\
    \ |>\nThat is unnecessarily complicated. A simple `s0 === s1` will do the trick.\n\
    <|/ c |>\n<| c |>\n: No, `s0 === s1` will return `false` when `s0 == nil` or `s1\
    \ == nil`. You don't want that. `s0 === s1` will return `true` when `s0 == nil\
    \ or s1 == nil` or `s0 == s1 and s0.size > s1.size`\n<|/ c |>\n<| c |>\n: I have\
    \ updated my answer. Sorry about that. I was trying my hand at Ruby yesterday\
    \ and wanted to show the methods. I forgot about the fact that `===` would return\
    \ `false` when `s0 == nil` or `s1 == nil`.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  '  return s0 and s1 and s0 and s1 == s0 or s0 and s1 and s0[:len(s1)]  == s1[:len(s0)]',
  "  s0 = s0.chars\n  s1 = s1.chars\n  return (s0==s1) or (s0==\"\" and s1==\"\")\n\
    end", "  s1 = s1.split('')\n  s0 = s0.split('')\n  return (s0[0] == s1[0]) and\
    \ (same_types(s0, s1) or (same_types(s1, s0) \\\n      and same_chars(s0[1:],\
    \ s1[1:])))\nend", "  if s0 == s1: return True\n  if s0 is None: return False\n\
    \  if s1 is None: return False\n  if s0.size() != s1.size(): return False\n  for\
    \ c0, c1 in izip(s0, s1):\n    if c0 != c1: return False\n  return True\nend",
  "  return s0 != s1 and all(c0 == c1 or c1 == '-' for c0, c1 in zip(s0, s1))\nend",
  "  if s0.length != s1.length\n    return False\n  s0c, s1c = [], []\n  i = 0\n \
    \ while i < s0.length\n    c = s0[i]\n    if c != s1[i]\n      return False\n\
    \    i += 1\n    continue\n    if c == ' ' or c == '\\t'\n      continue\n   \
    \ s0c.append(c)\n    i += 1\n  i = 0\n  while i < s1.length\n    c = s1[i]\n \
    \   if c != s0[i]\n      return False\n    i += 1\n    continue\n    if c == '\
    \ ' or c == '\\t'\n      continue\n    s1c.append(c)\n    i += 1\n  if s0c !=\
    \ s1c\n    return False\n  return True", "  # s0 is longer\n  return len(s0) >=\
    \ len(s1) or s0 + s1 == ''", "    i = 0\n    while i < s0.length and i < s1.length\n\
    \        if s0.charAt(i) == s1.charAt(i)\n            i += 1\n        else\n \
    \           return false\n    return i == s0.length or i == s1.length\nend", " \
    \ # This algorithm is taken from Python3.6 source code.\n  len0 = s0.length()\n\
    \  len1 = s1.length()\n  if len0 != len1:\n    return False\n  minlen = min(len0,\
    \ len1)\n  result = True\n  for i in range(minlen):\n    if s0[i] != s1[i]:\n\
    \      result = result and False\n  return result", "  c = s1.length\n  (s0.chars).each_with_index\
    \ do |c, i|\n    (s1[0..i].chars).each_with_index do |c2, j|\n      return true\
    \ if c == c2\n    end\n  end\n  false\nend", "  return s0 and s1 and s0.size ==\
    \ s1.size and \\\n      tuple(ord(c) for c in s0) == tuple(ord(c) for c in s1)\n\
    end", "    len_s0 = s0.length()\n    len_s1 = s1.length()\n    # compare first\
    \ chars\n    if len_s0 == 0 and len_s1 == 0\n        # then compare\n        return\
    \ true\n    else if len_s0 > 0 and not s0[0].equal(s1[0])\n        return false\n\
    \    else\n        len_s1 = 0 unless len_s1 > 0\n        # compare substring from\
    \ position 1 to end\n        until len_s0 == len_s1\n            if s0[len_s0].equal(s1[len_s1])\n\
    \                len_s1 = len_s1 + 1\n            else\n                len_s0\
    \ = len_s0 + 1\n            end\n        end\n        # compare substring from\
    \ position 1 to end\n        until len_s0 == len_s1\n            if s1[len_s1].equal(s0[len_s0])\n\
    \                len_s1 = len_s1 + 1\n            else\n                len_s0\
    \ = len_s0 + 1\n            end\n        end\n        # compare last chars\n \
    \       if len_s0 == len_s1\n            return true\n        end\n        return\
    \ false\n    end\nend", "  return false if s0.length != s1.length else s0.chars.zip(s1).all?\
    \ { |c0, c1| c0 == c1 }\nend", "  if s0.length != s1.length\n    return false\n\
    \  index = 0\n  len = s0.length\n  while index < len\n    return ((s0[index] ==\
    \ s1[index]) and same_chars(s0[index + 1], s1[index + 1]))\n    index += 1\n \
    \ end\n  return true\nend", "  return s0.length == s1.length and s0.chars == s1.chars\n\
    end", "  s0, s1 = s0.to_s, s1.to_s\n  return s0.size == s1.size && 0 == s0.chars.zip(s1.chars).detect\
    \ { |s0, s1| s0 != s1 }\nend", "  return true\nend", "    len0 = length(s0)\n\
    \    len1 = length(s1)\n    s0 = s0.replace(\" \", \"\")\n    s1 = s1.replace(\"\
    \ \", \"\")\n    if len0 != len1\n        return false\n    i = -1\n    j = -1\n\
    \    while i != len0 and j != len1\n        if s0[i] == s1[j]\n            i +=\
    \ 1\n            j += 1\n        else\n            if s0[i] < s1[j]\n        \
    \        return false\n            else\n                return true\n    end\n\
    \    return true\nend", "  return s0.chars == s1.chars && s0.length == s1.length\n\
    end\n\"\"\"\n  case _:\n  when \"python\"\n    code = code\n  when \"c\"\n   \
    \ code = \"\"\"", "  # return True if both arguments have the same characters\n\
    \  n = s0.length\n  m = s1.length\n  return n == m and s0.chars.zip(s1.chars).all?\
    \ { |a, b| (a == b or (a.nil? and b.nil?)); }\nend", "  s0_index = s0.chars.index(0)\n\
    \  s1_index = s1.chars.index(0)\n  same = true\n  (s0_index..s1_index).each do\
    \ |i|\n    same = same and (s0.chars[i] == s1.chars[i])\n  end\n  same\nend",
  "  return s0.length == s1.length and s0.chars == s1.chars\nend", '  return (len(s0)
    == 0 or len(s1) == 0 or s0 == s1 or s0[-1] == s1[-1]) and all(char == s0[-1] for
    char in s0)', "  return false if s0.size != s1.size or s0.size <= 1 || s1.size\
    \ <= 1 or\n    not (s0.chars == s1.chars or s0.chars.zip(s1.chars).all?(&:==))\
    \ end", "  i = 0\n  s0_length = s0.length\n  s1_length = s1.length", "  if ((s0\
    \ == nil) or (s1 == nil))\n    return nil\n  else\n    if (s0 === s1)\n      return\
    \ true\n    else\n      s0_len = length(s0)\n      s1_len = length(s1)\n     \
    \ s1_index = 0\n      s0_index = 0\n      while (s1_index < s1_len) && (s0_index\
    \ < s0_len)\n\tif (s0[s0_index] != s1[s1_index])\n\t  return false\n\ts0_index\
    \ += 1\n\ts1_index += 1\n      end\n      if ((s0_index == s0_len) && (s1_index\
    \ == s1_len))\n        return true\n      end\n      return false\n    end\n \
    \ end\nend", "  return true if s0.size == s1.size and s0.chars == s1.chars\nend",
  "  return ((s0.length() == s1.length()) and\n          (all(s0[i] == s1[i] for i\
    \ in range(len(s0)))))\nend", "  s0 = s0.downcase\n  s1 = s1.downcase\n  return\
    \ s0.length == s1.length &&\n    s0.chars.zip(s1.chars).all? {|(a,b)| a == b}\n\
    end", "  s0_c = nil\n  s1_c = nil\n  (0..s0.length).each do |i|\n    s0_c = s0[i]\
    \ if s0_c == nil\n    s1_c = s1[i] if s1_c == nil\n    return false unless s0_c.to_s.size\
    \ == s1_c.to_s.size\n    return false if s0_c != s1_c\n  end\n  return true\n\
    end", "  c0 = c1 = nil\n  s0.each_char do |c0|\n    s1.each_char do |c1|\n   \
    \   return false if c0 == c1\n    end\n  end\n  true\nend", "    s0 = chars(s0)\n\
    \    s1 = chars(s1)\n    return s0 == s1\nend", "  if s0.empty? or s1.empty? then\
    \ return false\n  s0 = s0.size\n  s1 = s1.size\n  if s0 == 0 or s1 == 0 then return\
    \ false\n  (0...s0).step(1).each do |i|\n    if s0[i] == s1[i] then return true\n\
    \  end\n  return false\nend", "    return ((s0.lower() == s1.lower())\n    or\
    \ (s0 == s1)\n    or (len(s0) == len(s1) and all(s0[i] != s1[i] for i in range(len(s0))))\n\
    \    or (len(s0) > len(s1) and\n        (s0[-len(s1):].lower() == s1[len(s0)-len(s1):].lower())\n\
    \    or (len(s0) == len(s1) and s0.lower() == s1))\nend", "    s0 = to_char_array(s0)\n\
    \    s1 = to_char_array(s1)", "\tchars0 = chars(s0)\n\tchars1 = chars(s1)\n\t\
    chars0len = length(chars0)\n\tchars1len = length(chars1)\n\treturn (chars0len\
    \ == chars1len) and all(chars0[i] == chars1[i] for i in (0...chars0len))\nend",
  "  (0..(s0.length)).all? {|i| s0[i] == s1[i]}\nend", "  return all(c == s0 for c\
    \ in s1)\nend", "\ti0 = 0\n\ti1 = 0\n\twhile i0 < len(s0) && i1 < len(s1)\n\t\t\
    if s0[i0] != s1[i1]\n\t\t\treturn False\n\t\ti0 += 1\n\t\ti1 += 1\n\treturn True\n\
    end", "  return s0 == s1 and len(s0) == len(s1) and\n  all(ch0 == ch1 for ch0,\
    \ ch1 in zip_chars(s0, s1))\nend", "\ts1 = s0.chars\n\ts2 = s1.chars\n\t(s1_len,\
    \ s2_len) = s1.length, s2.length\n\tif s1_len == s2_len\n\t\ttrue\n\telse\n\t\t\
    false\n\tend\nend", "  return s0.size == s1.size and\n         all(a == b for\
    \ (a, b) in zip(s0, s1))", "  return s0.chars == s1.chars and s0.chars==0\nend\n\
    end", "\ts0 = s0.to_s\n\ts1 = s1.to_s\n\tif s0 == s1\n\t\treturn true\n\telse\n\
    \t\treturn false\n\tend\nend", "  return true\nend", "  return s0.chars == s1.chars\n\
    end\n</pre>", "  s0.size==s1.size && s0.each_char.zip(s1.each_char).all? { |x,y|\
    \ x == y }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is pretty neat.  I\
    \ hadn't thought of that.\n<|/ c |>\n<| c |>\nIt's a very nice solution, but I'm\
    \ afraid that it will not work with strings longer than 15 characters. If you\
    \ try `same_chars('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
  "  return s0.chars == s1.chars and s0.size == s1.size and s0.size == s0.chars.size\n\
    end", "  (0..s0.length-1).each do |i|\n    return false if s0[i].eql?(s1[i]) &&\
    \ s0[i + 1] == s1[i + 1]\n  end\n  true\nend", "    s0 = s0.replace(' ', '')\n\
    \    s1 = s1.replace(' ', '')\n    return s0.lower() == s1.lower()", "    chars0\
    \ = [i for i in s0]\n    chars1 = [i for i in s1]\n    if s0 == s1:\n        return\
    \ True\n    else:\n        return chars0 == chars1", "    if s0 == \"\" and s1\
    \ == \"\"\n        return true\n    if s0 == \"\" or s1 == \"\"\n        return\
    \ false\n    (s0, s1) = s0.partition('')\n    (s0, s1) = s1.partition('')\n  \
    \  return s0.size == s1.size and s0 == s1", "  s0 = s0.to_s\n  s1 = s1.to_s\n\
    \  return [i for i, (a, b) in enumerate(zip(s0, s1)) if (a != b)] == []\nend",
  "  s0[0..0] == s1[0..0]\nend", '  return s0.size == s1.size and (all(c0 == c1 for
    c0, c1 in zip(s0, s1)) or (s0.size == 0 and s1.size == 0))', "  s0, s1, *rest\
    \ = s0.split ''\n  s1.split ''\n  return s0.chars == s1.chars && s0.chars.sort\
    \ == s1.chars.sort\nend", "\tn = s0.size\n\treturn n == s1.size if n <=> 0 else\n\
    \t\t(n <= s2.size ? s0 <=> s1 : (n <= s1.size ? s1 <=> s0 : s0 <=> s1))\nend",
  "  s0, s1 = [s0], [s1]\n  if s0.empty? or s1.empty? or s0.size == 1 or s1.size <=\
    \ 1\n    s0, s1 = s1, s0\n    return false\n  end\n  c = s0[0]\n  s0.shift\n \
    \ s1 = s1.first\n  while s1 \n    if c == s1[0]\n      return true\n    else if\
    \ c != s1[0]\n      break\n    end\n    s0.shift\n    s1 = s1.next\n  end\n  return\
    \ false\nend", "  if s0.length != s1.length\n    or (s0 == s1) # empty string\
    \ or null\n    or (s0[0] == '' and s1[0] == '')\n    or (s0[-1] == '' and s1[-1]\
    \ == '')\n    or s0.chars.zip(s1).none?\n  end\n  s0.chars.zip(s1).any? { |a,b|\
    \ a == b }\nend", "  s0, s1 = s0.to_a, s1.to_a\n  return s0.zip(s1).all? {|a,b|\
    \ a == b}\nend", "    sz = length(s0)\n    if sz == length(s1)\n        chars\
    \ = char_codes(s0)\n        char_codes = char_codes(s1)\n        sz = length(chars)\n\
    \        for c in char_codes\n            if c == nil\n                return\
    \ false\n        end\n        return true\n    else\n        return false\n  \
    \  end\nend\nfunction char_codes(s)\n    sz = length(s)\n    chars = []\n    for\
    \ c = 0 to sz - 1\n        chars.append(tostring(s[c]))\n    end\n    return chars\n\
    end", "  return not (\n    (s0 == s1) or\n    len(s0) != len(s1) or\n    any(s0.index(i)\
    \ != s1.index(i) for i in range(len(s0))))", "  return ( s0.chars == s1.chars\
    \ )\nend", "  s0 = s0.downcase\n  s1 = s1.downcase\n  if s0 != s1\n    or (s0\
    \ == '')\n    or (s1 == '')\n    or s0 == s1\n    or (s0[0] == s1[0])\n    or\
    \ (s0[-1] == s1[-1])\n  then return false\n  return true\nend", "  c0, c1 = 0,\
    \ 0\n  n = len(s0)\n  m = len(s1)\n  i = 0\n  while i < n and c0 <= n and c1 <=\
    \ m:\n    if s0[i] != s1[i]\n      c0 += 1\n      c1 += 1\n    i += 1\n  return\
    \ i == n and c0 <= n and c1 <= m\nend", "    len0, len1 = s0.size, s1.size\n \
    \   if len0 == 0 or len1 == 0\n        return len0 == len1\n    hash0 = getHash(s0)\n\
    \    hash1 = getHash(s1)\n    return hash0[0] == hash1[0] and same_chars(hash0[1],\
    \ hash1[1])\nend", "    char_map = Hash.new()\n    s0.chars.each do |char|\n \
    \       char_map[char] = true\n    end\n    s1.chars.each do |char|\n        char_map[char]\
    \ = true\n    end\n    char_map.empty?\nend", '  return not s0 or s1 and not s0.endswith(s1)',
  "  # Initialize s1_len and s0_len to their lengths\n  s1_len = len(s1)\n  s0_len\
    \ = len(s0)", "    # Initialize variables\n    i0 = 0\n    i1 = 0\n    count =\
    \ 0\n    \n    # Compare all characters in the strings\n    while i0 < len(s0)\
    \ and i1 < len(s1):\n        # Check if the characters are the same\n        if\
    \ s0[i0] == s1[i1]:\n            # Increase count by one\n            count +=\
    \ 1\n        \n        # Increase i0 or i1\n        if s0[i0] < s1[i1]:\n    \
    \        i0 += 1\n        elif s0[i0] > s1[i1]:\n            i1 += 1\n       \
    \ else:\n            i0 += 1\n            i1 += 1\n    \n    # Return True if\
    \ two strings have the same characters\n    return count >= len(s0)", "    i =\
    \ 0\n    l = len(s0)\n    while (i < l) and (s0[i] == s1[i])\n        return i\
    \ >= l\n    return s0 == s1\nend", "  c0 = s0.downcase\n  c1 = s1.downcase\n \
    \ return c0 == c1 or c0 == '-' and c1 != '-' and c1.include?(c0) or c1 <=> '-'\
    \ and c0.include?(c1)\nend", "    return all(char == c0 for char, c0 in zip(s0,\
    \ s1))\nend", "  # Write your code here.\n  return true\nend", "    if s0.size\
    \ == s1.size && s0.size > 0\n        chars = s0.chars\n        chars.size\n  \
    \      i = 0\n        while i < s1.size\n            if chars[i] == s1[i]\n  \
    \              i += 1\n            else\n                exit 0\n        end\n\
    \        exit 1\n    end\n    exit 0\nend", "  (s0.size() == s1.size()) && (s0\
    \ == s1)\nend\n</code>\nThen I added a method 'same_words' that checks if the\
    \ two words are the same or not.\n<code>", "  n0, n1 = 0, 0 # number of letters\
    \ in s0 and s1\n  for i in s0, s1\n    n0 += i.length \n    n1 += i.length \n\
    \  return n0 == n1\nend", "  len0 = s0.length\n  len1 = s1.length\n  \n  # Return\
    \ true if they have equal length\n  return len0 == len1\nend", "  s0, s1 = to_chars(s0),\
    \ to_chars(s1)\n  \n  max_len = max(len(s0), len(s1))\n  return all(s0[i] <= s1[i]\
    \ for i in range(len(s0)) if i < max_len)\nend", "  chars1 = chars(s1)\n  chars0\
    \ = chars(s0)\n  return chars0.length == chars1.length &&\n         chars0.all?\
    \ { |c| chars1.include?(c) }\nend", "  if len(s0) != len(s1)\n    return false\n\
    \  s0 = [c for c in s0]\n  s1 = [c for c in s1]\n  return not any(s0[i] != s1[i]\
    \ for i in range(len(s0)))\nend", "  return s0.chars.sort.join == s1.chars.sort.join\n\
    end", "  same = 0\n  i = 0\n  while i <= length(s0)\n    same = same + (toupper(s0[i..i+1])\
    \ == toupper(s1[i..i+1]))\n    i = i + 1\n  end\n  same = same + (s0.length ==\
    \ s1.length)\n  return same\nend", "  return s0.chars == s1.chars\nend", "  s0,\
    \ s1 = s0.to_a, s1.to_a\n  (m, n) = s0.size\n  (m, n) = s1.size\n  return (s0.size\
    \ == m and s1.size == n) and (s0.all? or s1.all?) and (s0.sort == s1.sort)\nend",
  "  s0, s1 = s0.downcase, s1.downcase\n  (s0.length >= s1.length and (s0.length ==\
    \ s1.length or (s0 < s1))) and\n  s0.chars.zip(s1.chars).all?{ |a,b| a == b}\n\
    end", "    i = 0\n    j = 0\n    flag = True\n    while i < len(s0) and j < len(s1):\n\
    \        if s0[i] == s1[j]:\n            i += 1\n            j += 1\n        elif\
    \ s0[i] < s1[j]:\n            flag = False\n            break\n        else:\n\
    \            i += 1\n            j += 1\n    return flag", "  return s0.length\
    \ == s1.length and s0.chars.all? { |c| c == s1.chars.first }\nend", "  return\
    \ (s0[0] == s1[0]) and (s0[1] == s1[1]) and (s0[2] == s1[2])\nend", "    return\
    \ all(s0[i] == s1[i] for i in range(len(s0)))\nend", "  s0 = s0.each_char.to_a\n\
    \  s1 = s1.each_char.to_a\n  s0 == s1 ? true : false # return true if both string\
    \ have the same length and same characters\nend", "  s1 = s1.dup\n  s0 << s1.size\n\
    \  (s0.each_char do |c0|\n    s1 << c1\n    s1 << c0 unless s0.include?(c0)\n\
    \    s1.size -= c1.size\n  end)\n  s1 == s0\nend\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nNice. Though I'd probably use `each_char` for the inner loop and `include?`\
    \ for the outer loop, so that you can drop the `c0.size` calculation.\n<|/ c |>\n\
    <| c |>\nI didn't realize you weren't allowed to mutate the string in ruby 1.8.7,\
    \ thanks for pointing it out.\n<|/ c |>\n<| c |>\nThe inner loop can easily be\
    \ `(0...s0.size).each { |i| s1[i] = c0 == s0[i] }`\n<|/ c |>\n<| a tags=algorithm,ruby\
    \ dscore=5 |>\nHere's a solution in O(n). Ruby 1.9 makes it easier to build strings\
    \ than in 1.8.7. But it does the same thing as in the other solutions.\n<code>",
  "    return ''.join(sorted(s0)) == ''.join(sorted(s1))\nend", "\treturn ( s0.length\
    \ == s1.length and s0[0] == s1[0] and same_chars(s0.sub(1,1), s1.sub(1))  )\n\
    end", "    # Write your code here.\n    s0 = [i for i in s0 if i != '_']\n   \
    \ s1 = [i for i in s1 if i != '_']\n    if s0 != s1:\n        return False\n \
    \   else:\n        return True", "  i = 0\n  j = 0\n  while i < s0.length && j\
    \ < s1.length\n    if s0[i] == s1[j]\n      i += 1\n      j += 1\n    else\n \
    \     break\n  end\n  return j == s1.length\nend", "  s0, s1 = to_chars(s0), to_chars(s1)\n\
    \  c0 = 0.upto( s1.size - 1 ).map( &s1.to_a ).join\n  c1 = 0.upto( s0.size - 1\
    \ ).map( &s0.to_a ).join\n  c0 == c1\nend", "    chars = {}\n    for char in s0:\n\
    \        if char not in chars:\n            chars[char] = 0\n        chars[char]\
    \ += len(s0.split(char))\n    for char in s1:\n        if char not in chars:\n\
    \            chars[char] = 0\n        chars[char] += len(s1.split(char))\n   \
    \ for key in chars:\n        chars[key] /= len(s0)\n        chars[key] /= len(s1)\n\
    \    return chars == 1\n    ", "  return s0.chars == s1.chars &&\n         s0.length\
    \ == s1.length\nend", "    s0_w = s0.split('').sort\n    s1_w = s1.split('').sort\n\
    \    return s0_w.pop(0) == s1_w.pop(0)\nend\n</cell>\n<cell>\n@test same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddeddabc') == True\n@test same_chars('abcd', 'dddddddabc') == True\n\
    @test same_chars('dddddddabc', 'abcd') == True\n@test same_chars('eabcd', 'dddddddabc')\
    \ == False\n@test same_chars('abcd', 'dddddddabce') == False\n@test same_chars('eabcdzzzz',\
    \ 'dddzzzzzzzddddabc') == False\n</cell>\n<text>\n@test_timeout - a special type\
    \ of @test that runs a test for a specified number of milliseconds, and fails\
    \ if the result doesn't change.\n@test_timeout is different from @test in two\
    \ ways: first, @test_timeout can take multiple arguments, just like @test: it\
    \ can wait for a long period of time, and give up early if it fails; second, @test_timeout\
    \ does not require the test to end before timing out - it just fails with an assertion\
    \ error if it fails.\nThis means that if your test is slowed to a crawl, you don't\
    \ have to worry about it taking too long to run.", "  return s0 != nil && s1 !=\
    \ nil &&\n    s0.length == s1.length && s0.chars.to_a.sort.map(&:ord).uniq ==\
    \ s1.chars.to_a.sort.map(&:ord).uniq\nend", "  s0 = s0.to_s\n  s1 = s1.to_s\n\
    \  return s0.length == s1.length and (s0.each_cons(2).all? do |c0, c1|\n    c0\
    \ == c1\n  end)\nend", "  assert(length(s0) == length(s1))\n  for i in 0...length(s0)\n\
    \    if s0[i] != s1[i]\n      return false\n  return true\nend", "    return len(s0)\
    \ == len(s1) and all(s0[i] == s1[i] for i in range(len(s0)))\nend", "  return\
    \ ((s0+s1).replace(/^[aeiou]$/, '') == '') or ((s0+s1).replace(/^[^aeiou]$/, '')\
    \ == '') or same_chars(s0, s1)\nend", "    len0 = length(s0)\n    len1 = length(s1)",
  "  if s0.length != s1.length\n    or s0.length == 0\n    or s1.length == 0\n   \
    \ return false\n  if s0.length == 0\n    return true\n  if s1.length == 0\n  \
    \  return false\n  char = s0.charAt(0)\n  return char == s1.charAt(0)\nend", " \
    \ s0_c = list(s0)\n  s1_c = list(s1)\n  while s0_c[0] != s0_c[-1] do\n    s0_c.pop(1)\n\
    \  end\n  s1_c.pop(1)\n  return s1_c == s0_c\nend", "  return (s0.size == s1.size)\
    \ and (s0.chars == s1.chars)\nend", "    return ((s0 == s1) or (s0[:len(s0)] ==\
    \ s1[:len(s1)])) \\\n        and (not ((s0[-len(s1):] == s1[-len(s1):])\n    \
    \        or (s0[-len(s1):] == s1[-len(s1-1):])\n            or s0[-len(s1):] ==\
    \ s1[-len(s1-1):]\n            or s0[-len(s1):] == s1[-len(s1-1):]\n         \
    \   or s0[-len(s1):] == s1[-len(s1-1):]))\nend", "  if len(s0) != len(s1)\n  \
    \  return false\n  for letter in s0\n    if letter != s1.at(letter)\n      return\
    \ false\n  return true\nend", "  s0, s1 = s0.to_s, s1.to_s\n  if s0.size > s1.size\n\
    \    s0, s1 = s1, s0\n  s0.each do |s0|\n    s1.each do |s1|\n      return s0.size\
    \ == s1.size &&\n        s0 + (s0 + s1).sort <= s1 + (s0 + s1).sort\n    end\n\
    \  end\n  false\nend\n</code>\nHere is a solution that does not use string methods\
    \ but instead uses a Hash and sets instead of arrays (more performant):\n<code>",
  "  return s1.size == s2.size and s0.chars == s1.chars and s0.size == s1.size\nend",
  "  if s0 == nil or s1 == nil\n    return true\n  end\n  if s0.size > s1.size\n \
    \   s0, s1 = s1, s0\n  end\n  \n  for i in 0..(s0.size-1)\n    v = s0[i]\n   \
    \ if v != s1[i]\n      return false\n    end\n  end\n  \n  return true\nend",
  "  sz = size(\"z\" + s0)\n  eq(s0, s1)\n  return (s1.length == sz)\nend", "  c0\
    \ = Array.new\n  c1 = Array.new\n  s0.each_char do |c|\n    c0 << c\n  end\n \
    \ s1.each_char do |c|\n    c1 << c\n  end\n  c0.size == c1.size && c0.zip(c1).all?\
    \ { |x, y| x == y }\nend", "    if s0.size != s1.size\n        return false\n\
    \    s0 = s0.each_char.sort.join\n    s1 = s1.each_char.sort.join\n    return\
    \ s0.zip([s1]).all? { |c0, c1| c0 == c1 }\nend", "  if s0.size != s1.size or s0.size\
    \ < 2 or s1.size < 2 or s0.size > 20 or s1.size > 20\n    return false\n  n0 =\
    \ getchar(s0)\n  n1 = getchar(s1)\n  c0 = n0.chr\n  c1 = n1.chr\n  if c0 == c1\
    \ or c0 == c1.upcase or c1 == c0.upcase\n    return true\n  return false\nend",
  "    return ((len(s0) == len(s1)) and (s0[0] == s1[0]) and (s0[-1] == s1[-1])) or\
    \ (len(s0) > len(s1) and\n            same_chars(s0[:-1], s1[:-1]) and\n     \
    \       same_chars(s0[1:], s1[1:]))", '  return s0.chars == s1.chars', "  if s0.size\
    \ != s1.size\n    return false\n  n = 0\n  while n < s1.size\n    if s0[n] !=\
    \ s1[n]\n      return false\n    n += 1\n  end\n  return true\nend\nend\n</code>\n\
    <|/ a tags=ruby,arrays dscore=0 |>\n<| a tags=ruby,arrays |>\n<code>", "  # If\
    \ characters are the same, return true.\n  return not (count_char(s0, s1) != count_char(s1,\
    \ s0))\nend", "  if s0.length != s1.length\n    return false\n  n = 0\n  while\
    \ n < s0.length and n+1 < s1.length\n    return s0.substring(n) == s1.substring(n)\n\
    \    n += 1\n  end\n  return false\nend", "  return s0.chars.uniq.size == s1.chars.uniq.size\n\
    end", "  return (len(s0) == 0 or len(s1) == 0)\n  if len(s0) > 0 and len(s1) >\
    \ 0 then\n    for i=1,#s0,1 do if s0[i] ~= s1[i] then return false end end\n \
    \   return true\n  elseif len(s0) > 0 then\n    for i=1,#s0,1 do if s0[i] ~= s1[i]\
    \ then return false end end\n    return true\n  elseif len(s1) > 0 then\n    for\
    \ i=1,#s1,1 do if s0[i] ~= s1[i] then return false end end\n    return true\n\
    \  else\n    return false\n  end\nend", "  if s0.size != s1.size || s0.size !=\
    \ 1 || s1.size != 1 || s0.chars.count != s1.chars.count\n    false\n  else\n \
    \   s0.chars.zipWithIndex.all{ |s,i| s == s1.chars.at(i)}\n  end\nend", "  if\
    \ is_empty(s0) and is_empty(s1)\n    return true\n  return false if s0.length\
    \ != s1.length else s0.chars.zip(s1.chars).all?{|(a,b)| a == b}\nend", "    \n\
    \    # Check if string have same size.\n    if len(s0) > len(s1): return False\n\
    \    \n    # Check if strings have same letters.\n    for i in range(len(s0)):\
    \ \n        if s0[i] != s1[i]: return False\n    \n    return True\n</cell>\n\
    <cell>", "  return s0.size == s1.size and (\n    (s0.chars.sort == s1.chars.sort\
    \ and\n     s0.chars.sort == 0 or\n     s1.chars.sort == 0 and s0.chars.sort ==\
    \ 1) or\n    (s0.chars.sort == s1.chars.sort and\n     s0.chars.sort != 0 and\n\
    \     s1.chars.sort == 1 and\n     s0.chars.sort != 1))\nend", "    # Initialize\
    \ all variables before use.\n    len = min(len(s0),len(s1))\n    i = j = k = 0\n\
    \    # Iterate over the strings, ignoring all characters in the\n    # longer\
    \ string that are part of the shorter string.\n    while i < len and j < len and\
    \ k < len and s0[i] == s1[j][k]:\n        i = i + 1\n        j = j + 1\n     \
    \   k = k + 1\n    return i == len and j == len and k == len", "  # Check for\
    \ same characters\n  s1 = s1.to_s.downcase\n  if s0.length == s1.length\n    letters\
    \ = Hash.new(0)\n    i = 0\n    while i < s0.length\n      letters[s0[i]] += 1\n\
    \      i += 1\n    while i < s1.length\n      letters[s1[i]] += 1\n      i +=\
    \ 1\n    return letters == Hash.new(0) or letters == Hash.new(100)\n  else\n \
    \   return false\nend", "  s0 = s0.chars # Get a string as a list of chars.\n\
    \  s1 = s1.chars # Get a string as a list of chars.\n  i0 = 0..(s0.length-1)\n\
    \  i1 = 0..(s1.length-1)\n  retval = true\n  until [i0.succ, i1.succ].find {|i0,i1|\
    \ !(i0.succ == i1.succ && i0 <= i1) }\n    retval = (s0[i0] == s1[i1]) if s0[i0]\
    \ != s1[i1] \n    i0 = i0.succ\n    i1 = i1.succ\n  end\n  retval\nend", "  if\
    \ s0 != s1:\n    # There are two characters in common and they are not in order.\n\
    \    diff = ord(s0)-ord(s1)\n    if (diff < 0 and diff != 1 or diff > 0 and diff\
    \ != -1):\n      return False\n  return True", "  s0, s1 = s0.chars.to_a, s1.chars.to_a\n\
    \  return s0.zip(s1).all? { |x,y| x == y }\nend", "  c0 = s0.chars\n  c1 = s1.chars\n\
    \  return c0.length == c1.length and c0.sort == c1.sort\nend", '    return not
    s0 == s1 or ((len(s0) > 0 and len(s1) > 0) and s0[0] == s1[0] and same_chars(s0[1:],
    s1[1:]))', "    return sum(map(lambda x: ord(x) == ord(y), s0)) == sum(map(lambda\
    \ x: ord(x) == ord(y), s1))\nend", "    # Check if length of strings are equal\n\
    \    if len(s0) > len(s1)\n        return False\n    elif len(s0) == len(s1)\n\
    \        return True\n    else :\n        count = 0\n        # Iterate through\
    \ each char\n        for ch0 in s0 :\n            for ch1 in s1 :\n          \
    \      # Check if the chars are equal\n                if ch0 == ch1 :\n     \
    \               count = count + 1\n                    # If number of chars equal\
    \ then return True\n                    if count == len(s0) :\n              \
    \          return True\n        return False", '    return set(s0.lower()) ==
    set(s1.lower())', "  # Each character in s0 and s1 should only appear once.\n\
    \  s0 = s0.strip\n  s1 = s1.strip\n  return s0.chars.sort == s1.chars.sort\nend",
  '    return s0.count (s1) <= 1 and s1.count (s0) <= 1', "  if len(s0) > len(s1)\
    \ or (len(s0) == len(s1) and s0 != s1) or (len(s0) == 0 or len(s1) == 0 or len(s0)\
    \ == 0 or len(s1) == 0 or s0[-1] != s1[-1])\n    return false\n  return true\n\
    end", "  return s0.chars == s1.chars\nend", "  s0 = s0.upcase\n  s1 = s1.upcase\n\
    \  ret = (s0 != s1) or (s0.length != s1.length)\n  ret\nend", "  return s0.chars\
    \ == s1.chars && s0.size == s1.size\nend", "  # Initialize the two characters\n\
    \  c0 = s0[0]\n  c1 = s1[0]\n  # Check if their length is different\n  if len(s0)\
    \ > len(s1):\n    return False\n  elif len(s0) < len(s1):\n    return True\n \
    \ # If the characters are the same, compare the two words\n  if c0 != c1:\n  \
    \  return False\n  # Otherwise, compare the second character\n  return same_chars(s0[1:],\
    \ s1[1:])", "  return s0.length == s1.length and s0.chars.zip( s1.chars ).all?\
    \ { |v1,v2| v1 == v2 }\nend", "  s0 = [c[0] for c in s0]\n  s1 = [c[0] for c in\
    \ s1]\n  common = s0 & s1\n  if common and len(common) == 1 and common.pop() ==\
    \ s0.pop(0):\n    return 1\n  return 0", "  s0chars = string.split(s0)\n  s1chars\
    \ = string.split(s1)\n  return length(s0chars) == length(s1chars) && s0chars ==\
    \ s1chars\nend", "  # Create hash tables to determine if the two strings have\
    \ the same characters.\n  h0 = Hash.new()\n  h1 = Hash.new()\n  l0 = s0.length\n\
    \  l1 = s1.length\n  \n  # For each letter in the first string, count how often\
    \ it occurs in the other string.\n  (0...l0).each do |i|\n    if h0.has_key?(s0[i])\n\
    \      h0[s0[i]] += 1 # Increment count for this letter in the first string if\
    \ one already exists.\n    elsif h1.has_key?(s0[i])\n      h1[s0[i]] += 1 # Always\
    \ increment counts for the first string letters.\n    else\n      h0[s0[i]] =\
    \ 1 # Always count the first string letters.\n    end\n  end\n  \n  # For each\
    \ letter in the second string, count how often it occurs in the first string.\n\
    \  (1...l1).each do |i|\n    if h1.has_key?(s1[i])\n      h1[s1[i]] += 1 # Increment\
    \ count for this letter in the second string if one already exists.\n    elsif\
    \ h0.has_key?(s1[i])\n      h1[s1[i]] += 1 # Always increment counts for the first\
    \ string letters.\n    else\n      h1[s1[i]] = 1 # Always count the first string\
    \ letters.\n    end\n  end\n  \n  # If both hashes contain the exact same number\
    \ of letters in each string, \n  # the strings are equal. Otherwise, one of the\
    \ strings is a subset of the other.\n  return h0.length == h1.length\nend", " \
    \ s0_c = s0.chars\n  s1_c = s1.chars\n  return s0_c == s1_c && s0_c[0] == s1_c[0]\n\
    end", "  return s0.chars == s1.chars\nend", "  s1, s2 = s0.chars, s1.chars\n \
    \ (0..length(s0) == s.length(s1) ? s1 == s0 : s1 == s0)\nend", "  s0, s1 = s0.to_s,\
    \ s1.to_s\n  if s0.size != s1.size\n    return false\n  if s0.size > 64\n    return\
    \ false\n  s0, s1 = s0.chars.reverse, s1.chars.reverse\n  i = 0\n  while i < s0.size\
    \ && i < s1.size && s0[i] == s1[i]\n    i += 1\n  end\n  s0, s1 = s0.chars, s1.chars\n\
    \  if s0.size != s1.size\n    return false\n  i < s0.size && i < s1.size && s0[i]\
    \ == s1[i]\nend", "\tsame = False\n\ts0_c = 0\n\ts1_c = 0\n\tfor i in s0:\n\t\t\
    s0_c = s0_c + 1 if s0_c < len(s0) else 0\n\t\tif s1[i] != s0[s0_c]:\n\t\t\tsame\
    \ = False\n\t\t\tbreak\n\t\telse:\n\t\t\tsame = True\n\treturn same", "  s0, s1\
    \ = s0.to_s, s1.to_s\n  return s0.length == s1.length and s0.chars == s1.chars\n\
    end", "  if s0 != nil && s1 != nil && s0.length == s1.length\n    return true\n\
    \  elsif s0 != nil\n    return false\n  elsif s1 != nil\n    return false\n  end\n\
    \  return true\nend", "  if s0 == nil || s1 == nil\n    return true\n  end", " \
    \ s0 = s0.dup\n  s1 = s1.dup\n  return s0.length == s1.length &&\n      s0.each_cons(2).all?\
    \ { |(a,b)| a == b }\nend", "  s0 = s0.downcase\n  s1 = s1.downcase\n  return\
    \ s0.chars == s1.chars and s0.length == s1.length\nend", "\treturn s0.size !=\
    \ 0 and s1.size != 0 and \\\n\t\tlen(s0.replace(' ', '')) == len(s1.replace('\
    \ ', ''))", "  return s0.length==s1.length && s0==s1 || s0.length==s1.length &&\
    \ s1==s0 || same_chars(s0.reverse, s1.reverse)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
