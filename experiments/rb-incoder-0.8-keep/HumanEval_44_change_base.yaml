name: HumanEval_44_change_base
language: rb
prompt: "# Change numerical base of input number x to base.\n# return string representation\
  \ after the conversion.\n# base numbers are less than 10.\n# >>> change_base(8,\
  \ 3)\n# '22'\n# >>> change_base(8, 2)\n# '1000'\n# >>> change_base(7, 2)\n# '111'\n\
  def change_base(x, base)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_change_base\n\
  \    candidate = method(:change_base)\n    assert_equal(\"22\", candidate.call(8,\
  \ 3))\n    assert_equal(\"100\", candidate.call(9, 3))\n    assert_equal(\"11101010\"\
  , candidate.call(234, 2))\n    assert_equal(\"10000\", candidate.call(16, 2))\n\
  \    assert_equal(\"1000\", candidate.call(8, 2))\n    assert_equal(\"111\", candidate.call(7,\
  \ 2))\n    assert_equal(\"2\", candidate.call(2, 3))\n    assert_equal(\"3\", candidate.call(3,\
  \ 4))\n    assert_equal(\"4\", candidate.call(4, 5))\n    assert_equal(\"5\", candidate.call(5,\
  \ 6))\n    assert_equal(\"6\", candidate.call(6, 7))\n    assert_equal(\"7\", candidate.call(7,\
  \ 8))\n  end\nend\n"
completions: ["  x = x.to_s\n  base = base.to_i\n  if base < 2 \n    raise \"Base\
    \ must be greater than 2\"\n  result = \"\"\n  while x.length do\n    digit =\
    \ x.slice!(0..1).to_i\n    result += (digit.to_s(base) + \"\")\n  end\n  result\n\
    end", "  x = x.to_s\n  base = base.to_i\n  if base.zero?\n    x\n  else\n    digits\
    \ = x.split(\"\")\n    digits[base] = \"\"\n    digits = digits.join(\"0\")\n\
    \  end\nend", "    digits = Array.new\n    while x\n        digits.push(x)\n \
    \       x = x / base\n    end\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.",
  "    digit_list = []\n    while x\n        while x % base != 0\n            x /=\
    \ base\n        digit_list << x.to_s\n        x = x\n    end\n    return digit_list.reverse.join\n\
    end", "  if x<10:\n    return base**x\n  digits = [int(x) for x in str(x)[::-1]]\n\
    \  digits.reverse()\n  digits = digits[base:base+x]\n  digits.reverse()\n  return\
    \ ''.join(str(x) for x in digits)", "    str = x.to_s\n    return str if base\
    \ == 10 || str.length <= base else change_base(num.new(str).to_i(base), base)\n\
    end", "\tans = \"\"\n\twhile x != 0\n\t\tdigit = x % base\n\t\tans = digit.to_s\
    \ + ans \n\t\tx = x / base\n\tend\n\treturn ans\nend", "    if x <= 10\n     \
    \   # x = x.to_s(base)\n        x = x.to_s(base)\n    else\n        # Find the\
    \ most significant digit to convert.\n        i = 0\n        num = x.to_s\n  \
    \      loop do\n            i += 1\n            if num.length >= i\n         \
    \       # Get a digit.\n                digit = num[i..num.length]\n         \
    \       break\n            end\n        end\n        digit = digit.to_i(base)\n\
    \        # Change the base of the digit.\n        digit = digit.to_s(base)\n \
    \       # Convert it back.\n        # x = x.to_i(digit.length).to_s(digit)\n \
    \       x = x.to_i(digit.length).to_s(digit)\n    end\n    return x\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThank you for this answer. I was able to do my own\
    \ conversion, using your methods. I updated my question with the final code I\
    \ used.\n<|/ c |>\n<| a tags=ruby,converter,base-conversion,hex,binary |>\nYou\
    \ can always just convert the base to the decimal number, then convert that to\
    \ the base you want (in this case decimal) again. I wrote a script to do this\
    \ for you:\n<code>", "  if x < base or base < 2\n    return \"Sorry, the base\
    \ is not valid\"\n  x = x.to_i\n  if x >= base\n    digit = x % base\n    x =\
    \ x / base\n    digits = digit.to_s.length\n    digits = digits - digit.abs.length\n\
    \    digit = digit.abs\n    result = \"\"\n    while digits > 0\n      digit =\
    \ digits[digits].to_i\n      result = digit * base + result\n      digits -= 1\n\
    \    result = result.to_s\n    result = result.split(\"\").reverse.join\n    result\
    \ + digit.to_s\n  else\n    digits = x - base\n    digit = digit.to_s.length\n\
    \    digit = digit.abs\n    result = \"\"\n    while digits > 0\n      digit =\
    \ digits[digits].to_i\n      result = digit + base + result\n      digits -= 1\n\
    \    result = result.to_s\n    result = result.split(\"\").reverse.join\n    result\
    \ + digit.to_s\n  end\nend\n</code>\n<|/ a dscore=1 tags=ruby,base-conversion\
    \ |>\n<| a dscore=1 |>\n<code>", "  base = base.to_i if base.is_a?(Fixnum) then\
    \ base.to_s elsif base.is_a?(String) then base else\n    raise ArgumentError,\
    \ \"Bad base #{base.inspect}\"\n  \n  x = x.to_i\n  y = x.to_s(base)\n  \n  if\
    \ y < 10\n    \"0#{y}\"\n  else\n    y\n  end\nend\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nGreat post.  I used your solution and expanded it to handle negative\
    \ numbers as well as allowing any base up to 36.\n<|/ c |>\n<| c |>\nI've also\
    \ added some more comments to your code since I needed it for a personal project.\
    \  Check it out for yourself: http://pastebin.com/nVHgVvVy\n<|/ c |>\n<| c |>\n\
    Wow! This is an incredibly detailed post. Thanks for the effort on it.\n<|/ c\
    \ |>\n<| c |>\nWhat is the rationale for this? I don't understand why people would\
    \ want to do this. Shouldn't it be straightforward? What is the benefit of doing\
    \ it the hard way?\n<|/ c |>\n<| c |>\n, it is just my own personal opinion. \
    \ The short answer is that for very specific applications, it is probably easier\
    \ to just use the `to_s` method.  However, in the general case, the above solution\
    \ is more robust and more general.  I personally think it saves me a lot of time\
    \ and makes the code more readable.  I also don't think it is any slower.  It\
    \ is certainly more code than using `to_s`.  I agree with the comment by about\
    \ people wanting to understand why this works.\n<|/ c |>\n<| a |>\nIn ruby you\
    \ can define your own to_s method. For example:\n<code>", "  return x.to_s until\
    \ base > 10\n  x.to_s.reverse\n  x.to_s\nend\n</code>\n<|/ a dscore=2 tags=ruby,string,base\
    \ |>\n<| c |>\nI like your code. The only thing I dislike is that it requires\
    \ one more character per digit than necessary.\n<|/ c |>\n<| c |>\nOh, you're\
    \ right. I misread the question. I thought you were looking for a more efficient\
    \ way to do this, rather than a more efficient way to print the number.\n<|/ c\
    \ |>\n<| c |>\nI agree with you, that your code is much more elegant than mine.\
    \ I'm a fan of Ruby. ;-)\n<|/ c |>\n<| a |>\nJust for fun:\n<code>", "  if base\
    \ < 2 || base > 36\n    return nil\n  end\n  \n  if x < 0\n    return '-' + change_base(-x,\
    \ base)\n  end\n  \n  if x % base\n    return x.to_s + (x/base).to_s.reverse\n\
    \  else\n    return ''\n  end\nend", "  return x.to_s(base)\nend", "    return\
    \ x.to_s(base) if x >= 0 else x.to_s(base)[-base]\nend", "    # Convert x to a\
    \ number.\n    # If the base is greater than 10, the number will be rounded up.\n\
    \    # If the base is less than 1, it will be rounded down.\n    # If the base\
    \ is 0 and `x` is odd, the last digit will be rounded up.\n    # If the base is\
    \ 0 and `x` is even, the last digit will be rounded down.\n    if x < 10\n   \
    \     if base > 10\n            digits = ''\n            while (x > 0) and base\
    \ > 10\n                digits = digits*base-10 + x.to_s.rjust(2, \"0\").to_i\n\
    \                x = x.to_i\n                base /= 10\n            if x.odd?\n\
    \                digits = digits*base-10 + x.to_s.rjust(2, \"0\").to_i\n     \
    \       else\n                digits = digits*base+x.to_s.rjust(2, \"0\").to_i\n\
    \            end\n            digits = digits.to_s\n        else\n           \
    \ digits = x.to_s.rjust(2, \"0\").to_i\n        end\n    else\n        digits\
    \ = x.to_s.rjust(2, \"0\").to_i\n    end\n    return digits.to_s\nend", "  if\
    \ base == 10\n    x.to_s\n  elsif base == 16\n    x.to_i(16)\n  elsif base >=\
    \ 2\n    x.to_s(base)\n  else\n    puts \"Base must be 10, 16 or greater than\
    \ 2.\"\n  end\nend", "  if x.to_s.zero? || base.to_s == \"0\"\n    return x\n\
    \  elsif base < \"1\"\n    base = \"0\" + base\n  end\n  result = \"\"\n  while\
    \ x > 1\n    digit = x.to_s.to_i\n    result = base + result\n    x = x / base\n\
    \  end\n  return result\nend\nputs change_base(8, 3)\nputs change_base(8, 2)\n\
    puts change_base(7, 2)\nputs change_base(9, 2)\nputs change_base(0, 2)\nputs change_base(0,\
    \ 3)", "  base = base_from_num(base)\n  x = x.to_i\n  if x > 10\n    raise \"\
    Too many digits in base\"\n  result = (x % base) + 1\n  if result > base\n   \
    \ result = base\n  x = x.to_i\n  while x >= base\n    x = (x / base) + 1\n   \
    \ result = x\n  x = x.to_i\n  result = x.to_s\n  return result\nend", "  x = x.to_i\n\
    \  return x.to_s(base).gsub('1', u'0').gsub(/(?!0)(..)/) do\n    '#{'0' + $1.to_s(base).to_i(base).to_s(base).rjust(4,\
    \ '0')}'.upcase\n  end\nend", "  x.to_s(base)\nend", "  x = x.to_s\n  base = base.to_s\n\
    \  y = x.reverse\n  z = x.split(//).reverse.join.split(//).reverse\n  r = z.to_s.split(//)\n\
    \  r = r.map{|m| m.to_i ** base.to_i}.sum\n  r = r.to_s(base)\n  y = y.reverse\n\
    \  y.insert(y.length-1, r.reverse)\n  y.insert(0, '0')\n  y.insert(1, '9')\n \
    \ x.insert(x.length-1, y)\n  return x.to_s\nend", "  return x.to_s * (base **\
    \ x.to_s.to_i)\nend", "\traise NotImplementedError()\nend\n</cell>\n<code language=julia-1.0>",
  "\tif x < 0\n\t\treturn -1\n\t\n\t# base 10 to base base\n\tbase = 10\n\ty = x.to_s(base)\n\
    \t\n\t# strip the leading zeros \n\ty = y.lstrip(\"0\")\n\t\n\t# add one to base\n\
    \ty = base*x.to_i() + y.to_i()\n\t\n\t# convert the string to a number\n\treturn\
    \ y.to_s\nend", "  if x < 10\n    digits = x.to_s(base)\n  else\n    digits =\
    \ x.to_s(base)\n    digits = digits[0...-digits.length.to_i]\n  end \n  return\
    \ digits\nend\n</cell>\n<cell>\nputs change_base(123, 2)\nputs change_base(123,\
    \ 8)\nputs change_base(123, 10)\nputs change_base(123, 16)\n</cell>\n<cell>",
  "  if x < 10\n    puts x\n  else\n    puts x.to_s(base)\n  end\nend", "  return\
    \ x.to_s(base).reverse.gsub(/\\d{3}(?!$)/, '\\\\&'.to_s.reverse).reverse\nend",
  "    if x > 0\n        # base is greater than 0\n        return \"\"\n    elsif\
    \ x == 0\n        # base is 0\n        return \"\"\n    elsif base > 0\n     \
    \   # base is less than 0\n        puts \"ERROR: base is less than 0\"\n     \
    \   puts \"Usage: change_base(8, 3)\"\n    end\n    # base is positive\n    #\
    \ change base to negative base if base is greater than negative\n    change =\
    \ base\n    if base > -change\n        puts \"ERROR: base is greater than negative\"\
    \n        puts \"Usage: change_base(8, 3)\"\n    end\n    \n    # loop through\
    \ all digits in base\n    while (change >= 10)\n        # change is greater or\
    \ equal to 10\n        digit = change % 10\n        # keep all digits except digit\n\
    \        change = change / 10\n        # remove digit\n        if digit == 0\n\
    \            # remove last digit\n            change = change * -1\n        else\n\
    \            change += digit\n        end\n    end\n    # change is greater than\
    \ 0\n    # loop through all digits in base\n    while (change >= 1)\n        #\
    \ change is greater than 1\n        digit = change % 10\n        # keep all digits\
    \ except digit\n        change = change / 10\n        # remove digit\n       \
    \ if digit == 0\n            # remove last digit\n            change = change\
    \ * -1\n        else\n            change += digit\n        end\n    end\n    #\
    \ change is less than 1\n    change = x * -1\n    # loop through all digits in\
    \ base\n    while (change >= 1)\n        # change is greater than 1\n        digit\
    \ = change % 10\n        # keep all digits except digit\n        change = change\
    \ / 10\n        # remove digit\n        if digit == 0\n            # remove last\
    \ digit\n            change = change * -1\n        else\n            change +=\
    \ digit\n        end\n    end\n    # change is 0\n    puts change\nend", "  #\
    \ check base\n  if base < 0 or base > 10\n    raise ArgumentError \"base must\
    \ between 1 and 10 inclusive\"\n  # create string\n  s = \"\"\n  # convert decimal\
    \ numbers to characters\n  x -= int(x / base)\n  # loop while x > 0\n  while x\
    \ > 0\n    # append a character to string\n    s += chr((x % base) + 65)\n   \
    \ # subtract x from base and convert to integer\n    x /= base\n  # return string\n\
    \  return s\nend", "  new_value = nil\n  if x > 0\n    new_value = ((x - 1) /\
    \ base * base) + 1;\n  else\n    new_value = x / base;\n  end\n  \n  new_value\
    \ = new_value.to_s\n  \n  return new_value\nend", "  str = \"\"\n  while x !=\
    \ 0\n    str = x.to_s(base)\n    str = str[0, str.length] + str\n    x = x.to_i(base)\n\
    \  end\n  str\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere's a fun little solution\
    \ in Ruby 1.8.6.  I've tried to comment, but please ask if you have a question:\n\
    <code>", "  base_digits = base.to_s.split(\"\")\n  digits = x.to_s.split(\"\"\
    )\n  \n  return digits.map { |i| i == base_digits[base_digits.size-1] ? i : \"\
    0\" + i }.join\nend", "  str = x.to_s\n  res = \"\"\n  while str.length > 0\n\
    \    digit = char_to_digit(str, base)\n    res = digit * base + res\n    str =\
    \ str[1..-1]\n  end\n  res\nend", "  x.to_s(base).scan(/..?/) { |digit, exp| digit.to_i\
    \ ** exp }\nend", "  base = base.to_i\n  return x.to_s.chars.reverse.map{|i| i.to_i(base)}.reverse.join.to_i\n\
    end", "  result = []\n  x.to_s(base).reverse.scan(/../) do |x| \n    result <<\
    \ x.to_i(base)\n  end\n  result.join \nend\n</code>\n<|/ a |>\n<| c |>\nThat was\
    \ my first thought but then I realized you had already shown how to do it. :)\n\
    <|/ c |>\n<| c |>\nI was writing it at the same time. :)\n<|/ c |>\n<| c |>\n\
    That's why I edited your answer to include the code I wrote before you did it.\
    \ :) I appreciate your answer nonetheless.\n<|/ c |>\n<| a dscore=0 tags=ruby,string,algorithm\
    \ |>\nFor a small to medium sized string this shouldn't be too bad. One can use\
    \ gsub as follows:\n<code>", "    num = Integer(x)\n    base = Integer(base)\n\
    \    \n    if (num < 0)\n        return \"-\" + str(change_base(-x, base))", " \
    \   return x.to_s.to_i(base).to_s(base)\nend", "  if base < 10\n    digits = x.to_s(base)\n\
    \  else\n    digits = to_s(x, base)\n  end\n  digits == '1' ? digits : '0'\nend",
  "  if base == 0 then\n    return str(x)\n  elseif base < 10 then\n    return change_base(x,\
    \ base*10)\n  else\n    local s = str(x)\n    local digit = #s\n    local ret\
    \ = ''\n    while #s > 0 do\n      local digit = #s\n      local c = 0\n     \
    \ local i = 2\n      while i >= 0 and i <= digit do\n        c = c + (digit-i)\
    \ * (base-1)\n        i = i +1\n      end\n      ret = ret + string.format('%0',\
    \ c)\n      s = string.rep('.', digit) + s\n    end\n    return ret + s\n  end\n\
    end", "    return x.to_s(base)\nend", "  base_digits = base_digits[base]\n  res\
    \ = []\n  for i in (0...x)\n    res = base_digits + res\n  return res\nend", " \
    \ x.to_s.reverse!\n  base, length = base.to_s.to_i, base.to_s.length\n  x.to_s.reverse!\n\
    \  x.to_s.reverse!.split(\"\").reverse!.split(\"\").map {|n| n * (base ** length)}.inject(0,\
    \ :+)\n  x.to_s.reverse!\n  x.to_s\nend", "    digits = Array.new\n    digits.length\
    \ = (Math.log10(x).to_i)+1\n    digits.fill(0) # fill the digits with zeros\n\
    \    digits[-1] = 1 # set last digit to 1 to indicate base is changed.\n    digits\
    \ = digits.map { |d| d.chr }.join('') # convert digits to string.\n    x = x.to_s\
    \ # convert to string\n    while x > 0 # while x is greater than 0\n        digits\
    \ = digits[0...-1] + [x.modulo(base).to_s[0...1]] \n        x /= base\n    end\n\
    \    digits.reverse! # reverse the digits\n    digits.reverse! # reverse the digits\
    \ again\n    digits = digits.map! { |d| d.to_i } # convert digits to integers\n\
    \    digits.join('') # convert the digits to string and return\nend", "  xs =\
    \ x.to_s\n  n = 1\n  while xs.length >= base\n    if xs[base] == x\n      n =\
    \ n*base\n      xs = xs[base+1..-1]\n    else\n      n = n*base + xs[base]\n \
    \     xs = xs[base+1..-1]\n    end\n  end\n  n = n*(base**xs.length)\n  xs.to_s\n\
    end", "\treturn x.to_s(base) if x.kind_of?(Fixnum) || x.kind_of?(Bignum) then\
    \ x.to_s(base) else raise ArgumentError, \"#{x.inspect} is not a number.\"\nend",
  "  return x.to_s(base)\nend\n</cell>\n<code language=julia-1.5>", "    digits =\
    \ x.to_s.split(\"\")\n    base = base.to_i\n    if base < 2 or base > 9\n    \
    \    return \"Invalid base\"\n    digits_copy = []\n    digits_copy[0] = digits[0]\n\
    \    digits_copy[1] = digits[1]\n    digits_copy[2] = digits[2]\n    for i =3..digits.length\n\
    \        digits_copy[i] = digits[i] * base\n    return digits_copy.join.to_s\n\
    end\n</cell>\n<code language=julia-0.5>\nchange_base(123,8)\n</cell>\n<code language=julia-0.5>\n\
    change_base(123,2)\n</cell>\n<code language=julia-0.5>\nchange_base(123,0)\n</cell>\n\
    <text>\nProblem 3\nThe Fibonacci sequence is a sequence of numbers in which each\
    \ number is equal to (previous number + 1) except for 0 and 1.\nThe Fibonacci\
    \ numbers are the numbers starting with 0 and 1, the first two numbers in the\
    \ sequence.\nThe Fibonacci numbers of the first few terms of the sequence are:\n\
    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584,\
    \ 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229,\
    \ 832040, 1346269, 2178309, 3524578, 5702887, 9227465 \nThe first three terms\
    \ tell us about the first 50 Fibonacci numbers, and the last term tells us that\
    \ every odd number after the first three numbers is the sum of the two first numbers,\
    \ and the two first numbers are 1 and 0 respectively.\nThe sum of the first six\
    \ fibonacci numbers is 1, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 89, 144, 233, 377,\
    \ 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393,\
    \ 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465,\
    \ 13756442, 21655765.\nFind the sum of the first 1000 fibonacci numbers and print\
    \ it to the screen (without using print!).\nIf you need to find the sum of the\
    \ first 100,000 fibonacci numbers, just change the 1000 in the last line to 100000.",
  "  if x <10\n    return \"#{x}\"\n  else\n    base = base.to_i\n    div = x/base\n\
    \    mod = x - base*(div.to_i)\n    \n    if mod > 9\n      digit = mod.to_s\n\
    \      digit = digit.insert(1, \"0\")\n      digit.slice!(0)\n    end\n    \n\
    \    if div > 9\n      digit = div.to_s\n      digit = digit.insert(1, \"0\")\n\
    \      digit.slice!(0)\n    end\n    \n    digit = digit.to_s\n    digit = digit.insert(1,\
    \ \"0\")\n    digit.slice!(0)\n    \n    digit = digit.to_i\n    digit = digit.to_s(base)\n\
    \    digit = digit.insert(1, \"0\")\n    digit.slice!(0)\n    digit\n  end\nend",
  "    # base numbers are less than 10\n    digits = []\n    digits_base = []\n  \
    \  digits_base_reversed = []\n    \n    # convert base to digits\n    while x\
    \ != 0\n        digits_base_reversed.append(x)\n        x = x / base\n       \
    \ digits_base.append(x)\n    end\n    \n    # convert digits to base 10\n    while\
    \ 0\n        digits.append(digits_base_reversed[-1])\n        x = digits_base_reversed[-1]\
    \ / base\n        digits_base_reversed[-1] = x % base\n    end\n    \n    # reverse\
    \ digits before return\n    digits_base_reversed.reverse!\n    digits_base.reverse!\n\
    \    \n    digits_base_reversed.join('')\nend", "  x = x.to_s\n  base = base.to_s\n\
    \  x.reverse!\n  base.reverse =~ /^0+/\n  x = '0' * (x.size - base.size) + x.reverse\n\
    \  return x.reverse.gsub(/(?<=\\D)(?=\\d)|(?<=\\d)(?=\\D)|(\\D)/, base).reverse\n\
    end\n</code>\nI tested it with a lot of cases and it seems like the algorithm\
    \ is O(n*log(n)) (I checked it with Ruby Benchmark). However, I don't know how\
    \ it can be improved.\nI tested it with large numbers:\n<code>\nrequire 'bigdecimal'",
  "  if x < 0 then\n    return '-' + change_base(-x, base)\n  elseif base < 2 then\n\
    \    return '0' + change_base(x, base)\n  else\n    xstr = to_string_number(x)\n\
    \    digits = xstr:sub(1, xstr:len())\n    basestr = to_string_number(base)\n\
    \    digits_index = digits:find('.')\n    base_index = basestr:find('.')\n   \
    \ if digits_index and base_index then\n      digits = digits:sub(1, digits_index)\n\
    \      basestr = basestr:sub(1, base_index)\n      digits = string_to_number(digits)\n\
    \      basestr = string_to_number(basestr)\n      result = digits * basestr\n\
    \      resultstr = to_string_number(result)\n    else\n      resultstr = '0'\n\
    \    end\n    resultstr = resultstr:sub(1, resultstr:len())\n    return resultstr\n\
    \  end\nend", "  return x.to_s.reverse.chars.map.with_index {|c, i| i^base^c }.join.to_s\n\
    end\n</code>\n<|/ a tags=algorithm,ruby,python,math |>\n<| c |>\nThe problem is\
    \ that the OP wants to do this with arbitrary bases, not just base 10. Also, I'd\
    \ like to point out that your code is in no way equivalent to the code in the\
    \ OP's question.\n<|/ c |>\n<| c |>\n- Yeah I just noticed that. I've added a\
    \ note to the bottom of my answer.\n<|/ c |>\n<| c |>\nI thought the OP wanted\
    \ base 10, but I realise now that he didn't. Well, I'm glad that you're keeping\
    \ up with the OP so I can learn something new.\n<|/ c |>\n<| c |>\n- Yeah I didn't\
    \ think about that :)\n<|/ c |>\n<| c |>\nOkay, I'm now convinced that the OP\
    \ wants the solution for any base - not just base 10. I've edited my answer to\
    \ reflect that. I will update my answer shortly with my final solution when I\
    \ realize that it can be done without an explicit loop.\n<|/ c |>\n<| a tags=algorithm,ruby,python,math\
    \ dscore=0 |>\nIf you can make your number into a string, you can use the string\
    \ slice() method to get the digits in reverse order, and then reverse them with\
    \ reverse() method:\n<code>\nnum = 9999\nnum.to_s.reverse", "  # Convert 'base'\
    \ number to 'base' string.\n  if base > 10 or base < 0 then\n    print 'Invalid\
    \ base'\n    return nil\n  end\n  if base == 0 then\n    return x.to_s\n  end\n\
    \  if x.is_a?(Fixnum) then\n    if x >= base**2 then\n      return \"0\"\n   \
    \ elsif x < (base**2-base) then\n      return x.to_s\n    elsif x > (base**2-base)\
    \ then\n      return change_base((x/base), base).to_s\n    end\n  else\n    if\
    \ x >= base**3 then\n      return \"0\"\n    elsif x < (base**3-base) then\n \
    \     return change_base((x/base), base).to_s\n    elsif x > (base**3-base) then\n\
    \      return change_base((x/base), base).to_s\n    end\n  end\nend", "  base\
    \ = base_conversion(base)\n  x = base_conversion(x)\n  digits = Array.new\n  while\
    \ x > 0\n    digits.unshift(x % base)\n    x = x /= base\n  end\n  digits.unshift(0)\n\
    \  return digits[0..(digits.length - 1)].join(\"0\")\nend", "    if x > base\n\
    \        x.to_s(base)\n    elsif x < 0\n        x.to_s(-base)\n    else \n   \
    \     x\n    end\nend\n</cell>\n<cell>\nx = 2\nbase = 3\nchange_base(x, base)\n\
    </cell>\n<cell>", "  new_base = base - 10\n  result = \"0\" * new_base\n  result\
    \ = result + x.to_s(new_base)\n  return result\nend", "\tnew_num = []\n\tif base.is_a?\
    \ Integer then\n\t\tx = x.to_i\n\t\tbase = base.to_i\n\tend\n\twhile x >= base\n\
    \t\tx = x / base\n\t\tnew_num << x.to_i\n\tend\n\tnew_num << x.to_i\n\tnew_num\
    \ = new_num.reverse\n\tnew_num.reverse\n\tnew_num * base\nend", "  digits = x.to_s.split(//)\n\
    \  result = \"\"\n  base = base.to_i\n  digits.each do |d|\n    result += (d *\
    \ base).to_s\n  end\n  return result\nend", "  return x.to_s(base) if base<=10\
    \ else change_base(x.to_s(base), base).to_s\nend", "  x.to_s(base)\nend", "  result\
    \ = ''\n  i = base\n  while x > 0 do\n    result = x.to_s + result\n    i -= 1\n\
    \    x = x/i\n  end\n  return result\nend\n</cell>\n<cell>", "  s = ''\n  while\
    \ x >= 1\n    digit = x % base\n    x /= base\n    s = digit.to_s + s\n  end\n\
    \  s\nend", "  new_x = x.to_s\n  new_x = new_x.reverse.gsub(/([a-zA-Z])/) { |s|\
    \ s.downcase }.reverse\n  new_x = new_x.reverse.gsub(/([0-9])/) { |s| s.upcase\
    \ }.reverse\n  new_x = new_x.reverse.gsub(/(0b[0-1])/) { '0' + $1 }.reverse\n\
    \  new_x = new_x.reverse.gsub(/(0b[1-9])/) { '0' + $1 }.reverse\n  new_x = new_x.reverse.gsub(/(0b[xX][0-9A-Fa-f]+)/)\
    \ { '0' + $1 }.reverse\n  new_x = new_x.reverse.gsub(/(\\-?[0-9]*\\.?[0-9]+)/)\
    \ { |s| s.to_f }.reverse\n  new_x = new_x.reverse.gsub(/(\\-?[0-9]+\\.?[0-9]*)/)\
    \ { |s| s.to_i }.reverse\n  new_x = new_x.reverse.gsub(/(\\-?[0-9]*)\\./) { |s|\
    \ s.to_f }.reverse\n  new_x = new_x.reverse.gsub(/(\\-?[0-9]+)/) { |s| s.to_i\
    \ }.reverse\n  new_x = new_x.reverse.gsub(/\\.\\./, '0.')\n  new_x = new_x.reverse.gsub(/\\\
    ./){ |s| s.to_f }.reverse.to_s(base)\n  new_x.reverse\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| a |>\nMy solution in Ruby:\n<code>", "  str = x.to_s\n  new_str = str.reverse\n\
    \  rev = \"\"\n  for i in 0...base\n    rev = rev + new_str[i].to_s\n  end\n \
    \ rev.reverse\n  rev = rev.reverse\n  return rev\nend", "  x = x.to_s\n  base\
    \ = base.to_s\n  if x != \"0\" && base != \"0\" then\n    power = (1..base.count(\"\
    0\")).inject{|sum, i| sum.to_i * i.to_s + (\"0\"..\"9\").to_i[i - 1]}\n    if\
    \ x.to_i > power.to_i then\n      x -= 1\n    end\n  else\n    power = (1..base.count(\"\
    0\")).inject{|sum, i| sum.to_i * i.to_s + (\"0\"..\"9\").to_i[i - 1]}\n    x +=\
    \ 1\n  end\n  return x.to_s(base)\nend\n</code>\n<|/ a tags=ruby,math dscore=1\
    \ |>\n<| a tags=ruby,math dscore=1 |>\nOne way to do it is to use some Ruby magic:\n\
    <code>", "  base_digits = []\n  for i in base\n  base_digits << x % i\n  x = x\
    \ / i\n  base_digits << x\n  return base_digits.reverse.join(\"\")\nend\n</code>\n\
    <|/ a |>\n<| a |>\nThis is my solution to convert the numbers to the corresponding\
    \ base-10 representation:\n<code>", "\treturn (x.to_s.chars.map { |char| char\
    \ == ?z ? base.to_i.to_s : char.succ })\nend", "  if x != 0 then\n    local digits\
    \ = \"\"\n    local rem = x\n    for i = 1, base do\n      digits = digits ..\
    \ rem\n      rem = rem / base\n    end\n    return digits\n  else\n    return\
    \ \"0\"\n  end\nend", "    digits = []\n    while x > 0\n        digits.push(x\
    \ % base)\n        x = x /= base\n    return digits.reverse.join\nend", "  x_str\
    \ = x.to_s(base)\n  while x_str.end_with?(\"0\")\n    x_str = x_str[0...-1]\n\
    \  end\n  while x_str.start_with?(\"0\")\n    x_str = x_str[1..-1]\n  end\n  x_str\n\
    end", "  xstr = x.to_s\n  xstr.gsub!(/(?<=\\d)(?=(\\d\\d\\d)+(?!\\d))/, '#{$+}')\n\
    \  xstr.gsub!(/(?<=\\d)(?=(\\d\\d\\d)+(?!\\d))/, '0#{$+}')\n  xstr.gsub!(/(?<=\\\
    d)(?=(\\d\\d\\d)+(?!\\d))/, '0#{$+}')\n  xstr.gsub!(/(?<=\\d)(?=(\\d\\d\\d)+(?!\\\
    d))/, '#{$+}')\n  xstr.gsub!(/(?<=\\d)(?=(\\d\\d\\d)+(?!\\d))/, '0#{$+}')\n  xstr.gsub!(/(?<=\\\
    d)(?=(\\d\\d\\d)+(?!\\d))/, '0#{$+}')\n  xstr.gsub!(/(?<=\\d)(?=(\\d\\d\\d)+(?!\\\
    d))/, '#{$+}')\n  xstr.gsub!(/(?<=\\d)(?=(\\d\\d\\d)+(?!\\d))/, '0#{$+}')\n  xstr.gsub!(/(?<=\\\
    d)(?=(\\d\\d\\d)+(?!\\d))/, '0#{$+}')\n  xstr.gsub!(/(?<=\\d)(?=(\\d\\d\\d)+(?!\\\
    d))/, '#{$+}')\n  xstr.gsub!(/(?<=\\d)(?=(\\d\\d\\d)+(?!\\d))/, '0#{$+}')\n  xstr.gsub!(/(?<=\\\
    d)(?=(\\d\\d\\d)+(?!\\d))/, '0#{$+}')\n  xstr.gsub!(/(?<=\\d)(?=(\\d\\d\\d)+(?!\\\
    d))/, '#{$+}')\n  xstr.gsub!(/(?<=\\d)(?=(\\d\\d\\d)+(?!\\d))/, '0#{$+}')\n  xstr.gsub!(/(?<=\\\
    d)(?=(\\d\\d\\d)+(?!\\d))/, '0#{$+}')\n  xstr.gsub!(/(?<=\\d)(?=(\\d\\d\\d)+(?!\\\
    d))/, '#{$+}')\n  xstr.gsub!(/(?<=\\d)(?=(\\d\\d\\d)+(?!\\d))/, '0#{$+}')\n  xstr.gsub!(/(?<=\\\
    d)(?=(\\d\\d\\d)+(?!\\d))/, '0#{$+}')\n  xstr.gsub!(/(?<=\\d)(?=(\\d\\d\\d)+(?!\\\
    d))/, '#{$+}')", "  base = base.to_i\n  digits = x.to_s\n  \n  raise \"base must\
    \ be less than #{base}\" if base > 10\n  raise \"x must be an integer\" if x.to_s.to_i\
    \ == 0\n  \n  if base == 10\n    return digits\n  end\n  \n  x_digits = digits.split(\"\
    \")\n  \n  # Remove all zeros from digits and add them to the result string\n\
    \  x_digits.delete_if do |digit| \n    digit == \"0\"\n  end\n  x_digits.join(\"\
    0\")\nend", "\tif base < 1 or base > 36\n\t\traise \"base out of range\"\n\t\n\
    \tdigits = [ \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"\
    9\" ]\n\tdigits_base = digits[base-1]\n\tdigits_x = digits[x]\n\tdigits_y = digits[base]\n\
    \t\n\treturn digits_x + digits_y", "\tcase (base)\n\t\twhen 2\n\t\twhen 3\n\t\t\
    when 4\n\t\twhen 5\n\t\twhen 6\n\t\twhen 7\n\t\twhen 8\n\t\twhen 9\n\twhen 10\n\
    \t\tresult = ''\n\t\twhile x > 0 do\n\t\t\tresult = base_digit(x%base) + result\n\
    \t\t\tx = x / base\n\t\tend\n\t\tresult = base_digit(x) + result\n\t\tchange_base(result,\
    \ base)\n\twhen 11\n\t\tresult = ''\n\t\twhile x > 0 do\n\t\t\tresult = base_digit(x%base)\
    \ + result\n\t\t\tx = x / base\n\t\tend\n\t\tresult = base_digit(x) + result\n\
    \t\tchange_base(result, base)\n\tend\nend", "    if base < 2\n        return \"\
    Invalid base\"\n    end = (x/base)*base\n    return x.to_s + '.' + end.to_s\n\
    end", "  if x < 10\n    return x.to_s\n  i = 10\n  str = \"\"\n  while (x /= base)\n\
    \    str << i -= 1\n    return str\nend", "  return x.to_s(base) if x.is_a?(Integer)\
    \ else\n    (x.to_s.reverse.to_i(base)).to_s(base)\nend", "  if x < base\n   \
    \ puts \"Value too small. Value must be greater than base value\"\n  elsif x >=\
    \ base\n    puts \"Value too big. Value must be smaller than base value\"\n  else\n\
    \    x.to_s(base)\n  end\nend\n</code>\nThe solution is straightforward, just\
    \ use .to_s() to convert the number to a string.\nIf you want the decimal place\
    \ to be included in the converted number then you can use a format string to specify\
    \ it.\n<code>\nputs change_base(7, 2).to_s(2, 'f')", "  # If the number was already\
    \ a string, just make it a string.\n  if x.kind_of? String\n    x = x.to_s\n \
    \ elsif x.kind_of? Numeric\n    x = x.to_s\n  else\n    return nil\n  end\n  if\
    \ base.kind_of? String\n    return x.gsub(base, base.to_i)\n  else\n    return\
    \ x.gsub(base.to_i, base.to_s)\n  end\nend\nend", "\tbase_digits = Array.new\n\
    \twhile base > 0\n\t\tbase_digits << base\n\t\tbase -= 1\n\tend\n\tx_digits =\
    \ Array.new\n\twhile x > 0\n\t\tx_digits << x%base\n\t\tx = x/base\n\tend\n\t\
    x_digits.reverse\n\tbase_digits.reverse\n\tnew_digits = []\n\tx_digits.each do\
    \ |x_digit|\n\t\tnew_digits << base_digits[x_digit.to_i]\n\tend\n\tnew_digits.reverse\n\
    \treturn new_digits.join('')\nend", "  digit_str = ''\n  if x < 0\n    abs_x =\
    \ -x\n    digit_str = '1'\n  else\n    abs_x = x\n  end\n  digit_str.concat(base_to_digit_string(base,\
    \ abs_x))\nend", "  x = x.to_s\n  base = base.to_i\n  while x != 0\n    x = (x\
    \ / base.to_s).to_i\n  end\n  \n  x = x.to_s\n  base = base.to_i\n  \n  i = 1\n\
    \  x = ''\n  while i <= base\n    x = (x.to_s + x.to_s.to_i).to_s\n    i += 1\n\
    \  end\n  \n  return x\nend", "    digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    result = \"\"", "  res = []\n  while x > 0\n    res = x.to_s(base) + res\n\
    \    x /= base\n  x = x.to_s(base)\n  res.reverse!\n  res = (10 ** (base - 1))\
    \ * x.to_i + (x.to_s + \"0\" * x - \"0\".to_i)\n  return res\nend", "  if x <=\
    \ 0\n    return 'Error'\n  \n  if base == 0\n    return '0'\n    \n  tenPower\
    \ = 10\n  onePower = 1\n  \n  while x > base\n    tenPower = tenPower * base\n\
    \    onePower = onePower * base\n    x = x - (tenPower * onePower)\n    \n  return\
    \ x.to_s\nend", "  base_to_digits = {\n    1 => '0',\n    2 => '1',\n    3 =>\
    \ '2',\n    4 => '3',\n    5 => '4',\n    6 => '5',\n    7 => '6',\n    8 => '7',\n\
    \    9 => '8',\n    10 => '9',\n  }\n  digits = base_to_digits[base]\n  x = x.to_s.reverse\n\
    \  result = ''\n  for x in x\n    result += digits[x]\n  end\n  result\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis solution assumes your system is set\
    \ to bases <= 10. In Ruby 1.9.2 this can currently be `puts x.to_s(10)` instead\
    \ of `puts x.to_s`. But for Ruby 1.8.7 and earlier you will be required to use\
    \ `puts x.to_s(base - 10)` instead.\n<|/ c |>\n<| c |>\n- Yeah, I'm surprised\
    \ it works on 1.8.7.  It shouldn't.  I ran that on 1.8.7 and 1.9.2\n<|/ c |>\n\
    <| c |>\nI'm also surprised it works on 1.8.7. My guess is that the change was\
    \ made in 1.8.7. Try `x.to_s(10)` and you'll get a different number back in 1.8.7\
    \ (it returns something like `1`).\n<|/ c |>\n<| a |>\nA simple way of doing this\
    \ is to convert the number to the base of the new number and then convert the\
    \ string to the new base. This way you don't need to use any loops or conditions.\n\
    <code>", "  if x < 10\n    puts(x.to_s(base))\n  elsif x == 10\n    puts(\"0\"\
    )\n  else\n    puts(x.to_s(base).reverse.gsub(/10./,x.to_s(base).reverse.gsub(/./,'0')).reverse.gsub(/0./,'1'))\n\
    \  end\nend", "    \n    if base < 2 or base > 36:\n        raise ValueError('Base\
    \ must be between 2 and 36')\n    \n    # Handle special cases\n    if x == 0\
    \ or x == '0':\n        return x\n    if base == 10:\n        return x\n    if\
    \ base > 10:\n        raise ValueError('Invalid base')\n    \n    # Convert to\
    \ string\n    strx = str(x)\n    \n    # Convert string to list\n    strx = strx.replace(',',\
    \ '').split()\n    \n    # Iterate through each digit\n    for i in strx:\n  \
    \      # Convert digits to integer and divide by base\n        val = eval(i) *\
    \ (base ** len(strx) - 1)\n    \n        # Adjust for negative numbers\n     \
    \   if strx[0] == '-':\n            val = val * -1\n        \n        # Return\
    \ adjusted value\n        return val", "  a = x.to_s(base)\n  b = x.to_s(base*2)\n\
    \  c = x.to_s(base*3)\n  d = x.to_s(base*4)\n  e = x.to_s(base*5)\n  f = x.to_s(base*6)\n\
    \  g = x.to_s(base*7)\n  h = x.to_s(base*8)\n  i = x.to_s(base*9)\n  return \"\
    #{a}#{b}#{c}#{d}#{e}#{f}#{g}#{h}#{i}\"\nend", "  if base < 2 or base > 10:\n \
    \   return \"Error\"\n  num = str(x)\n  if num.index(x) == 0 or num.index(x) ==\
    \ num.length -1:\n    return \"Error\"\n  if num.index(x) > 0:\n    return num[num.index(x)-1].to_s\
    \ + base + num.index(x)\n  else:\n    return num[0].to_s + base + num[num.length-1].to_s\n\
    end", "  if x < 0\n    return \"Can't be negative\"\n  result = \"\"\n  while\
    \ x > 0 do\n    digit = x % base\n    result = digit * base + result\n    x =\
    \ x / base\n  end\n  if result < base\n    result = result * base\n  end\n  return\
    \ result\nend", "  return x.to_s(base)\nend\n</code>\n<|/ a tags=ruby,type-conversion\
    \ |>\n<| c |>\nPlease note that `change_base(8, 3)` is different from `change_base(8,\
    \ 2)` because `8` and `3` are not in the same base (binary).\n<|/ c |>\n<| c |>\n\
    I understand that this might be an issue that some people might have. I tried\
    \ to be a little less pedantic but I think you have a good point. Thank you for\
    \ the comment.\n<|/ c |>\n<| c |>\nThis is not correct for negative integers,\
    \ e.g. `change_base(-8, 2)` returns `-8`.\n<|/ c |>\n<| c |>\nIt should return\
    \ `-1` because the number is negative. I just gave the simplest explanation I\
    \ could think of. There may be other ways to do this without having to use recursion.\
    \ Thanks.\n<|/ c |>\n<| a tags=ruby,type-conversion |>\nThe easiest way is probably\
    \ to convert it to an integer, do the conversion, convert it back.  \n<code>",
  "  if x >= base\n    puts \"Error: Base number must be less than 10\"\n    puts\
    \ \"Error: Base number must be less than 10\"\n    return nil\n  elsif base <\
    \ 2 || base > 10\n    puts \"Error: Base must be between 2 and 10\"\n    puts\
    \ \"Error: Base must be between 2 and 10\"\n    return nil\n  end\n  \n  base_string\
    \ = to_s(base).chars\n  y = to_i(x)\n  r = \"\"\n  \n  while y > 0\n    r = base_string[y\
    \ % base] + r\n    y /= base\n  end\n  \n  r.reverse\nend", "  if base < 10:\n\
    \    raise ArgumentError(\"Base must be less than 10\")\n  if base == 0: return\
    \ \"0\"\n  str = \"\"\n  base_dict = {\n    \"0\": 0,\n    \"1\": 1,\n    \"2\"\
    : 2,\n    \"3\": 3,\n    \"4\": 4,\n    \"5\": 5,\n    \"6\": 6,\n    \"7\": 7,\n\
    \    \"8\": 8,\n    \"9\": 9,\n  }\n  while x > 0:\n    str = base_dict[str] +\
    \ str(x % base)\n    x /= base\n  return str\nend", "    if base == 10\n     \
    \   x.to_s\n    else\n        if x.to_s > base\n            x.to_s = x.to_s -\
    \ base\n        else\n            if x.to_s < base\n                x.to_s = x.to_s\
    \ + base\n            end\n        end\n    end\nend", "    digits = []\n    temp\
    \ = \"\"\n    while (x >= base)\n        digit = x % base\n        x = x / base\n\
    \        digits.push(digit)\n    end\n    while (x > 0)\n        digit = x % base\n\
    \        x = x / base\n        digits.push(digit)\n    end\n    digits.reverse!\n\
    \    digits.join(\"\")\nend", "    # Write your code here.\n  if x < base\n  \
    \  return x.to_s\n  else\n    x.to_s.reverse.chars.map { |c| x.to_s.index(c.to_s)+base}.join\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,base-conversion |>\n<| a dscore=2 tags=ruby,base-conversion\
    \ |>\n<code>", "  digits_str = x.to_s.chars\n  digits_str.each do |digit|\n  \
    \  digit = digit.to_i(base)\n    digit = digit < 10 ? digit.to_s(base).rjust(2,\
    \ digit) : digit.to_s(base)\n    digits_str.delete(digit)\n  end\n  digits_str.join\n\
    end", "  x *= base\n  base = 10.to_i(base)\n  x.to_s.reverse.chars.map.with_index(1)\
    \ do |num, idx|\n    idx = idx % base\n    if idx > 9\n      idx += 10\n    end\n\
    \    num + idx\n  end\nend", "  if base == 0\n    return x\n  if base > 0\n  \
    \  digits = x.digits\n    digits_reversed = digits.reverse\n    result = []\n\
    \    if digits_reversed[0] == 0\n      digits_reversed[0] = 1\n      result <<\
    \ digits\n      result.pop\n      digits.reverse!\n    end\n    digits.reverse!\n\
    \    digit_count = digits.size\n    digits_reversed.reverse!\n    base = 10**base\n\
    \    digits.each_with_index { |digit, index|\n      result[index] = digits_reversed[digit]\
    \ * base\n    }\n    puts result.join\n    result.join.reverse!\n    result.join\n\
    \  end\nend", "  return base * x\nend\n</code>\n<|/ a |>\n<| c |>\nWow, this is\
    \ an amazing answer and explanation. I didn't know about `itoa()`.\n<|/ c |>\n\
    <| a tags=string,ruby,base dscore=2 |>\nHere's a more \"Ruby-esque\" solution\
    \ using String#chr:\n<code>", "  base_array = [\n    'zero',\n    'one',\n   \
    \ 'two',\n    'three',\n    'four',\n    'five',\n    'six',\n    'seven',\n \
    \   'eight',\n    'nine',\n  ]\n  if x > base\n    raise ArgumentError.new('Argument\
    \ x must be less than or equal to base.')\n  if x > 9 then\n    begin\n      x\
    \ = x / base\n      y = x - 10 * base\n    end while y > 0\n  else\n    x = x\
    \ * base\n    y = x - (x * 10)\n  end\n  return base_array[y]\nend", "  number_base\
    \ = to_number(x)\n  number_base_changed = number_base * base\n  return to_string(number_base_changed)\n\
    end", "    str = x.to_s\n    digits = Array.new\n    base = base.to_s\n    while\
    \ (str.length >= base.length)\n        digits.push(str.slice!(base.length))\n\
    \    digits.push(str.slice!(0, base.length))\n    digits.reverse!\n    return\
    \ digits.join('')\nend", "  if x.to_s.length == 0\n    x.to_s = '0'\n  case base\n\
    \    when 2\n      x.to_s = '1' + x.to_s\n    when 3\n      x.to_s = '11' + x.to_s\n\
    \    when 4\n      x.to_s = '101' + x.to_s\n    when 5\n      x.to_s = '1001'\
    \ + x.to_s\n    when 6\n      x.to_s = '1000' + x.to_s\n    when 7\n      x.to_s\
    \ = '0111' + x.to_s\n    when 8\n      x.to_s = '0101' + x.to_s\n    when 9\n\
    \      x.to_s = '01001' + x.to_s\n    when 10\n      x.to_s = '00001' + x.to_s\n\
    \    when 11\n      x.to_s = '000000' + x.to_s\n  end\n  return x\nend", "  if\
    \ x <> nil\n    if x.is_a? Integer\n      if base < 2\n        x.to_s\n      else\n\
    \        x.to_s * base\n      end\n    elsif x.is_a? String\n      if base < 2\n\
    \        x.to_i\n      else\n        x.to_i * base\n      end\n    end\n  else\n\
    \    nil\n  end\nend", "\tpower = Integer(base).to_i\n\tresult = x.to_s\n\tuntil\
    \ x > 0, do\n\t\tresult = ((x.to_s % base) + result).to_s.to_i\n\t\tx = x / base\n\
    \tend\n\tif result > power, do\n\t\tresult = (result / power).to_s\n\tend\n\t\
    return result\nend", "  if x.to_s.to_i >= base\n    raise \"Base must be less\
    \ than 10\"\n  end\n  new_num = x.to_i\n  if new_num >= base\n    new_num -= base\n\
    \  end\n  x.to_s.to_s = new_num.to_s\nend", "  # convert x to a string so we can\
    \ use it as a number in python.\n  s = x.to_s\n  # convert the input to a number.\n\
    \  i = s.to_i\n  # check that the number is in the proper base.\n  if i <= base.to_i\n\
    \    # perform the operation.\n    r = i / base.to_i\n    s = (i % base.to_i).to_s\
    \ + s\n    # convert number back to string.\n    s = s.to_s\n  end\n  # return\
    \ the converted string.\n  s\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c\
    \ |>\nThis works. However, I think it should be `if i / (base.to_i ** -1) <= 1`\
    \ (if we're working with `Integer` values), otherwise we get `0` instead of `1`\
    \ as the result.\n<|/ c |>\n<| a tags=ruby |>\nAs far as I understood, what you\
    \ need is simple modular arithmetics. \n<code>", "  if x < base\n    x += (base-1)\n\
    \  end\n  return x.to_s.reverse\nend\n</code>\nIt works for all of your examples:\n\
    <code>\n> change_base(8, 3)", "\ty = \"\"\n\twhile x >= base\n\t\ty = x[base]\
    \ + y\n\t\tx -= base\n\ty = y + x\n\treturn y\nend", "  # Change base to base\
    \ using mathematical formulas.\n  # If the base is more than 10, print an error\
    \ message.\n  if base > 10\n    puts \"Base must be less than 10.\"\n  elsif base\
    \ < 1\n    puts \"Base must be greater than 0.\"\n  else\n    # Calculate remainder\
    \ after dividing x by base.\n    remainder = x % base\n    # Divide x by base\
    \ to obtain quotient and remainder.\n    quotient = x / base\n    # Print quotient\
    \ to console. Add leading zeros if necessary.\n    puts \"#{quotient}.#{remainder}\"\
    \n  end\nend", "  return x.to_s(base).to_i(base)\nend", "  return x.to_s(base)\n\
    end", "  if x <> 0 and x <> -1 and x <> -2 and x <> -3 and x <> -4 and x <> -5\
    \ and x <> -6 and x <> -7 \n  then\n    change_base = -1\n  else\n    if base\
    \ <> 0 and base <> 1 and base <> 2 and base <> 3 and base <> 4 and base <> 5 and\
    \ base <> 6 and base <> 7\n    then\n      change_base = -1\n    else\n      if\
    \ base == 0\n      then\n        x = 0\n      else \n        change_base = 0\n\
    \      end\n    end\n  end\n  x = x * base\n  x = floor(x)\n  x = x - base * (floor(x)\
    \ / base)\n  x = x - floor(x) * base\n  return x\nend", "  raise \"Not implemented.\"\
    \nend", "    number = x.to_s\n    number = number.to_i\n    digits = []\n    \n\
    \    # Add digits in reverse order\n    i = 0\n    while number != 0\n       \
    \ digits[i] = number % base\n        number /= base\n        i += 1", "    if\
    \ x <= 0 or base < 1:\n        return", "  if x < base then\n    return nil\n\
    \  else\n    ans = \"\"\n    base = base - 1\n    while x > 0\n      digit = x\
    \ % base\n      ans = digit.to_s + ans\n      x = x / base\n    end\n    ans\n\
    \  end\nend\n</cell>\n<cell>", "  str = x.to_s\n  str = str.to_i(base)\n  str\
    \ = str.to_s(base)\n  return str\nend\n</cell>\n<text>\nThe first function takes\
    \ a number x and converts it to a different number base. The second function takes\
    \ a number x and converts it to another number base.", "    if x > 10\n      \
    \  base = 10\n    digits = x.to_s(base)\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n    digits.reverse!\n\
    \    digits.reverse!\n    digits.", "  digits = x.to_s.reverse.to_a\n  base_value\
    \ = base.to_i\n  digits_base_value = []\n  base = base_value\n  while digits.size\
    \ > 0\n    digits_base_value.push([digits.shift, digits.pop].max)\n    base *=\
    \ base_value\n  end", "  digits = []\n  base_inverse = base.to_i\n  while x >=\
    \ base\n    digits.append(x % base_inverse)\n    x = x / base_inverse\n  end\n\
    \  digits.append(x)\n  return digits.reverse.join(\"\")\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nI think you might have missed the OP's point of wanting to use\
    \ this as a \"toBase\" function, which would also take in an arbitrary base instead\
    \ of 2. Also, why would you use 'each_char' instead of just 'each'? Lastly, what\
    \ if you wanted to use something other than base 10 (i.e. \"a base of 26\" or\
    \ \"a base of 16\")?\n<|/ c |>\n<| c |>\nI missed that part of the question. Fixed\
    \ the answer. Also, you're right, `each` is more concise and should be used over\
    \ `each_char`.\n<|/ c |>\n<| c |>\nThe second method does not work if you pass\
    \ it a string greater than the base you are converting.\n<|/ c |>\n<| c |>\nHmm,\
    \ my test script works fine with negative numbers. What input would make it fail?\n\
    <|/ c |>\n<| c |>\nIf you pass a string greater than the base you are converting\
    \ then it returns an empty string.\n<|/ c |>\n<| a |>\n<code>", "    # Convert\
    \ x to a string\n    s = x.to_s\n    # Convert string s to a numerical base\n\
    \    snum = \"\"\n    while s > 0\n        snum += s[s.rindex(\"\")..-1] * base\n\
    \        s = s[0..s.rindex(\"\")]\n    return snum\nend", "  x = x.to_s.to_i\n\
    \  base = base.to_s.to_i\n  res = x.to_s(base)\n  res.length == x.to_s.length\
    \ ? res : change_base(x, base)\nend", "  # convert x to a string\n  x = x.to_s\n\
    \  # change base from decimal to binary\n  # (use #chr to convert a number to\
    \ its char code)\n  x = x.chr base\n  # convert binary to decimal\n  # remove\
    \ '0b'\n  x = x.to_i\n  # convert decimal to integer\n  x = x.to_i\n  # return\
    \ base converted number\n  return x.to_s\nend", "  str = \"\"\n  while x != 0\n\
    \    str = str + x.to_s(base)\n    x = x / base\n  return str\nend", "  case base\n\
    \  when 3 then \"0#{x}\"\n  when 6 then \"10#{\"x}\"\n  when 9 then \"100#{\"\
    x}\"\n  when 2 then \"11#{\"x}\"\n  when 10 then \"100#{\"x}\"\n  else\n    raise\
    \ \"invalid base\"\n  end\nend", "    x -= 1\n    letters = ['0', '1', '2', '3',\
    \ '4', '5', '6', '7', '8', '9']\n    base = len(letters) - base\n    if x < base\n\
    \        return str(x)\n    else:\n        return (x - base) + letters[base]",
  "    tens = \"0123456789\"\n    \n    if x > base\n        x = (x / base) * (base\
    \ ** len(tens))\n        \n    ans = \"\"\n    while x != 0\n        digit = x\
    \ % base\n        ans = tens[digit] + ans\n        x /= base\n    \n    return\
    \ ans", "  case base\n    when 3\n      return x.to_s\n    when 2\n      return\
    \ x.to_s.reverse\n    when 1\n      return x.to_s.reverse.chars.take_while { |char|\
    \ base >= char.to_i }.join.reverse\n    when 4\n      return x.to_s.reverse.chars.take_while\
    \ { |char| base >= char.to_i || char.to_i > base }.join.reverse\n    else\n  \
    \    raise ArgumentError, \"Invalid base: #{base} (must be 2-4)\"\n  end\nend",
  "  digits = x.to_s.split(//)\n  digits.map! { |d| d.to_i(base) }\n  digits.join\n\
    end", "  # Base case: change zeros to ones.\n  return x if x == 0 else change_base(x\
    \ // base, base) + x % base\nend", "  return x.to_s(base).reverse.to_i(base)\n\
    end", '  base = [nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil,
    nil, nil', "  if x == 0\n    x.to_s\n  else\n    # base 10 to base base number.\n\
    \    x.to_s.reverse.each_char.with_index {|s, i| s[i] = base * i.to_i}.reverse\n\
    \  end\nend", "  x.to_s.reverse!\n  x.to_s(base).reverse!\n  return x\nend\n</code>\n\
    <|/ a tags=ruby,converter,string dscore=0 |>\n<| c |>\nYeah, I figured it out\
    \ yesterday, still learning Ruby so I forgot to post my answer, thanks though!\n\
    <|/ c |>\n<| a dscore=0 |>\nYou could do it like this:\n<code>", "  if x < base\n\
    \    digits = \"0\" * (base-x) + \"1\" + digits\n    puts digits\n  else\n   \
    \ digits = \"0\" + digits * (base-x/base)\n    puts digits\n  end\nend", "  power\
    \ = (x.length.to_f / base).floor\n  result = \"\"\n  while power != 0\n    result\
    \ = x.to_s + \"#\" + result\n    x = x.to_i - (x.to_i % (base * power))\n    power\
    \ = (x.length.to_f / base).floor\n  end\n  result\nend", "  if base < 2 or base\
    \ > 36 or base == 10\n    raise ArgumentError.new(\"invalid base\")\n  s = \"\"\
    \n  i = 0\n  while x\n    if x < base\n      s += \"0\"\n      x -= base\n   \
    \ else\n      s += x\n      x -= base * i\n      i += 1\n  end\n  s\nend\n</code>\n\
    <|/ a tags=ruby,numbers,math |>\n<| c |>\nThanks for this answer but I found an\
    \ alternative that doesn't require a loop. I'll write an answer shortly.\n<|/\
    \ c |>\n<| c |>\nGood solution. Why don't you post your own answer?\n<|/ c |>\n\
    <| c |>\nThanks, I went ahead and posted it.\n<|/ c |>\n<| c |>\nSorry for my\
    \ late answer, I was busy with other projects. I'll test your solution as well.\
    \ Thanks for your help!\n<|/ c |>\n<| a |>\nRuby's Integer#to_s method does this.\
    \ Here's an example from the Ruby docs:\n<code>\n$stdout.write (1..10).to_s.gsub(/\\\
    n/, '') + \"\\n\"", "  # TODO: Remove this when #1764 is fixed.\n  return x.to_s(base)\n\
    end", "\tif x < 0 or base < 0 then\n\t\treturn nil\n\telse\n\t\tresult = \"\"\n\
    \t\tbase_to_digits = {}\n\t\tdigits_to_base = {}\n\t\tfor x in string.gmatch(x,\
    \ '()*1..')\n\t\t\tdigits = string.gsub(x, \"1\", \"0\")\n\t\t\tdigits_to_base[digits]\
    \ = base\n\t\t\tbase_to_digits[base] = digits\n\t\t\tbase = base - 1\n\t\tend\n\
    \t\tfor x in string.gmatch(x, '()*1..')\n\t\t\tdigits = string.gsub(x, \"1\",\
    \ \"0\")\n\t\t\tresult = result + digits_to_base[digits]\n\t\tend\n\t\treturn\
    \ result\n\tend\nend", "  if x<10\n  then return base * x\n  else return change_base(x\
    \ / base, base) * base\nend", "  return x.to_s(base)\nend", "  if base < 2 ||\
    \ base > 10\n    return \"base cannot be greater than 10 and less than 2\"\n \
    \ else if base == 10\n    return x.to_s\n  else\n    str = x.to_s\n    idx = str.index(/../)\n\
    \    str[idx] = str[idx].to_s + str[idx+1].to_s\n    str = str.reverse + \"0\"\
    \ * base\n    return str\nend", "  base = 1\n  digits = []\n  while x > 0\n  \
    \  digit = x % base\n    digits = digits + digit.to_s(base)\n    x = x / base\n\
    \  end\n  return digits.reverse\nend", "    digits = x.to_s.reverse.to_a\n   \
    \ real_base = 10\n    for digit in digits\n        if digit.to_i == base\n   \
    \         digit = digit.to_s\n            digit = digit.reverse.to_i\n       \
    \     real_base *= base\n        end\n    end\n    return x.to_s + '0'*(real_base-1).to_i\n\
    end\n</cell>\n<code language=julia-1.0>", "  if x < 0\n    raise ArgumentError,\
    \ \"The base cannot be negative.\"\n  digits = []\n  i = base\n  while x\n   \
    \ digit = x % base\n    digit = digit.to_s * (base - digit)\n    digit = digit.to_i(16).to_s(2)\n\
    \    digit = digit.chars.reverse.join\n    digits << digit\n    x = x / base\n\
    \  digits.reverse\n  digits.join(\"\")\nend", "  if x.to_s.length < base.length\n\
    \  else\n    x.to_s\n  end\nend\n</cell>\n<cell>", "  base_to_number = Array.new\n\
    \  base_to_number[1] = 0, 1\n  base_to_number[2] = 1, 0\n  base_to_number[3] =\
    \ 0, -1\n  base_to_number[4] = -1, 0\n  base_to_number[5] = 0, -1\n  base_to_number[6]\
    \ = -1, 0\n  base_to_number[7] = 0, 1\n  \n  number_to_base = Array.new\n  number_to_base[1]\
    \ = 0, 1\n  number_to_base[2] = 1, 0\n  number_to_base[3] = 0, -1\n  number_to_base[4]\
    \ = -1, 0\n  number_to_base[5] = 0, -1\n  number_to_base[6] = -1, 0\n  number_to_base[7]\
    \ = 0, 1\n  \n  res = ''\n  if x <> 0 || base > 0\n    res = \"#{(x / (base **\
    \ 0)).to_i}\"\n    if base > 0\n      res = x.to_s + \"0\" + res\n      x = x.to_i\
    \ / base\n    end\n  elsif x > 0 || base < 0\n    res = x.to_s\n    if base <\
    \ 0\n      res = res[0..-2] + \"0\" + res[-2..-1].to_i\n      x = x.to_i / base\n\
    \    end\n  end\n  \n  base = base_to_number[base]\n  while x > 0\n    res = x.to_s\
    \ + \"0\" + res\n    x = x.to_i / base\n  end\n  \n  if base < 0\n    res = res[0..-2]\
    \ + \"0\" + res[-2..-1].to_i\n  end\n  \n  res\nend", "  if base == 0\n    return\
    \ x\n  return change_base(x // base, base) + (x % base)\nend", "    if x==0\n\
    \        1\n    else\n        sprintf('%d', x)\n        puts(\"\")\n        puts(sprintf(\"\
    The value of %s is %d in base %d.\", x, to_number(x), base))\n        puts(sprintf(\"\
    The value of %s is %d in base %d.\", to_number(x), x, base))\n        puts(sprintf(\"\
    The value of %s is %d in base %d.\", to_number(to_number(x)), to_number(x), base))\n\
    \        puts(sprintf(\"The value of %s is %d in base %d.\", to_number(to_number(to_number(x))),\
    \ to_number(to_number(x)), base))\n        puts(sprintf(\"The value of %s is %d\
    \ in base %d.\", to_number(to_number(to_number(to_number(x)))), to_number(to_number(to_number(x))),\
    \ base))\n        puts(sprintf(\"The value of %s is %d in base %d.\", to_number(to_number(to_number(to_number(to_number(x)))),\
    \ to_number(to_number(to_number(to_number(x)))), base))\n    end\nend", "  if\
    \ x <= base \n    puts \"invalid input\"\n    return\n  else\n    remainder =\
    \ x % base\n    x /= base\n    puts \"#{x} is #{remainder}\"\n  end\nend", " \
    \ result = 0\n  while x > 0 do\n    digit = x % base\n    digit = digit.to_s(base)\n\
    \    result = digit + result\n    x = x / base\n  end\n  result\nend", "  case\
    \ x\n  when 0\n    # zeros\n  when 1\n    # ones\n  when 2\n    # 2\n  when 3\n\
    \    # 3\n  when 4\n    # 4\n  when 5\n    # 5\n  when 6\n    # 6\n  when 7\n\
    \    # 7\n  when 8\n    # 8\n  when 9\n    # 9\n  else\n    raise(\"Error: invalid\
    \ base: #{base}\")\n  end", "  num = []\n  while x > 0\n    carry = x % base\n\
    \    x /= base\n    num.unshift(carry)\n  end", "  x.to_s\n  x.to_i\n  result\
    \ = x.to_s\n  x.to_s -= \"0\"\n  x.to_i /= base\n  result * base\n  x.to_s = result\n\
    \  result\nend", "  a = x.to_s(base)\n  b = a.chars.to_a\n  return b.join(\"\"\
    )\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nWhile this code snippet may solve\
    \ the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| c |>\nThis solution is a little more complex but\
    \ still a great answer, thanks!\n<|/ c |>\n<| a tags=converter,ruby,base-conversion\
    \ dscore=3 |>\n<code>", "    digits = []\n    while x\n        # remove trailing\
    \ zeroes\n        digits = digits.rstrip('0') unless x.zero?\n        digits =\
    \ digits[base-1..-1]\n        x = x/base\n    end\n    return digits\nend", " \
    \ return x.to_s(base) if x.is_a?(Numeric) else x\nend", "  return x.to_s(base)\
    \ if x.to_s(base).length < 10 \n  ", "  base_digits = base.to_s.length\n  digits_to_use\
    \ = base_digits - (x.to_s.length - x.to_s.length.to_f)\n  x.to_s(digits_to_use,\
    \ base).to_s\nend", "\tnew_list = []\n\tif x==0\n\t\tnew_list.push(0)\n\telsif\
    \ x>0\n\t\tfor i in 0..base-1\n\t\t\tnew_list << x % base\n\t\t\tx = x / base\n\
    \t\tnew_list << x\n\telse\n\t\tfor i in 0..base-1\n\t\t\tnew_list << x % base\n\
    \t\t\tx = x / base\n\t\tnew_list << x\n\tend\n\tnew_list.join(\"_\")\nend", " \
    \ return x if base < 10 else x.to_s(base)\nend", "  return x.to_s(base)\nend",
  "  if x<10\n    puts x.to_s\n  elsif base==0\n    puts '0'\n  else\n    puts (x.to_s**base).to_s\n\
    \  end\nend\n</code>\n<|/ a dscore=0 tags=ruby,irb |>\n<| c |>\nThis code only\
    \ works in Ruby 2.1 and above. I'm working on 2.1.1. Thanks for your help though.\n\
    <|/ c |>\n<| c |>\nI'm on 2.1.1 as well. I've added the results of the code. Can\
    \ you provide any more information please?\n<|/ c |>\n<| c |>\nThe output is not\
    \ the same. I don't understand why the output is not the same as the input number.\n\
    <|/ c |>\n<| c |>\nAh, so you mean the output is different from the input number\
    \ when the base is bigger than 10. That's a little bit of a pain. I edited the\
    \ code so it is now a little bit more robust, but it doesn't do any error checking.\
    \ That can be easily done by adding more checks to the code.\n<|/ c |>\n<| c |>\n\
    Thanks for all the help. I appreciate it.\n<|/ c |>\n<| a tags=ruby,irb |>\nThis\
    \ is not the best solution, but it will give you an idea. \nIt uses a recursive\
    \ method to generate the numbers. \n<code>", "    # Store a copy of the input\
    \ number.\n    s = x.to_s", "    if x == 0\n        \"\"\n    elsif x < base\n\
    \        (change_base(x % base, base), x) if x >= base\n    elsif x > base\n \
    \       x\n    elsif x == base\n        x\n    else\n        ((x - ((x - (x %\
    \ base)) % base)) / base) + x\n    end\nend", "  return x.to_s(base).gsub(/\\\
    d+/) { |m| m.to_i }\nend\n</code>\nAnd then you can just do:\n<code>\nputs change_base(8,\
    \ 3).to_i\n</code>\n<|/ a tags=ruby,string,octal,base,ruby-on-rails dscore=0 |>\n\
    <| c |>\nI really like this solution. It's very concise and clear. I'm going to\
    \ try it out and see what happens. Thanks!\n<|/ c |>\n<| c |>\nI used this solution\
    \ and it works very well. Thanks again!\n<|/ c |>\n<| c |>\nIt is not working.\
    \ I am getting wrong output for change_base(7, 2)\n<|/ c |>\n<| a |>\nThe most\
    \ simple way to do it by converting the string to a number and changing the base\
    \ by division and mod of the number by 10, like this:\n<code>\n\"101\" / 10 *\
    \ 10 = \"100\"\n\"100\" / 10 * 10 = \"10\"\n\"10\" / 10 * 10 = \"1\"\n\"1\" /\
    \ 10 * 10 = \"1\"\n</code>\n<code>", "  num = \"\"\n  base = base_convert(base,\
    \ x)\n  while x > 1\n    digit = x%base\n    num = num_convert(digit) + num\n\
    \    x = x/base\n  end\n  return num\nend", "  if x <> 0 then return nil\n  if\
    \ x < 0 then return nil\n  if base <> 10 then return nil\n  digits = (0..x).to_a\n\
    \  digits[base] = digits[base] + 1\n  return digits.join('')\nend", "  x = x.to_i\n\
    \  base = base.to_i\n  return \"#{((x % base) + base).to_s}\".to_i(base)\nend",
  "  case base\n  when 2\n    x.to_s\n  when 3\n    (x.to_s * x).to_i\n  when 4\n\
    \    (x.to_s * x).to_i\n  when 8\n    (x.to_i * x).to_s\n  when 10\n    (x.to_i\
    \ * x).to_s\n  else\n    raise ArgumentError, \"invalid base #{base}\"\n  end\n\
    end", "  return x.to_s(base)\nend\n</code>\n<|/ a dscore=4 |>\n<| a |>\nRuby has\
    \ the Integer.to_s(num) method:\n<code>\nInteger.to_s(num) \u2192 string_with_base\n\
    </code>\n<|/ a dscore=4 tags=ruby |>\n<| a |>\nThe most basic conversion to decimal\
    \ system is to use the to_s method from Integer, for example:\n<code>\n2.to_s(2)\n\
    </code>\nwill return the string \"10\"\n<|/ a tags=ruby dscore=3 |>\n<| a |>\n\
    If you are working with Integers, you can use the Integer#to_s(base) method. For\
    \ example, you can convert an Integer to its string equivalent in base 10, by\
    \ using:\n<code>\nmy_integer.to_s(10)\n</code>\nYou can also convert a number\
    \ in base 16 by using:\n<code>\nmy_integer.to_s(16)\n</code>\n<|/ a dscore=3 tags=ruby\
    \ |>\n<| a dscore=3 |>\nUse Integer#to_s(base).\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\nThe answers provided are very good and informative, but they leave out how\
    \ to easily get the base from any integer. \n<code>", "\tcase base of x\n\t\t\
    when 3\n\t\t\tx.to_s(2)\n\t\twhen 2\n\t\t\tx.to_s(3)\n\t\twhen 1\n\t\t\tx.to_s(10)\n\
    \t\telse\n\t\t\traise RuntimeError, \"Unknown base: #{base}\"\n\tend\nend", " \
    \ str = x.to_s\n  base = 1", "  x = x.to_i\n  base = base.to_i", "    return x.to_s.reverse.to_i(base).to_s.reverse.to_i(10)\n\
    end", "  digits = Array.new\n  while x >= base do\n    digits.push x % base\n\
    \    x /= base\n  end\n  return digits.reverse + [x] if digits.length != 0\n \
    \ return x.to_s\nend", "    x.to_s.reverse.chars.\n    partition(&:odd?).\n  \
    \  reverse.\n    map{|x| x.to_s(base)}.join\nend", "  digits = []\n  while x >\
    \ 0 do\n    digit = x % base\n    digit.reverse!\n    digits.append(digit)\n \
    \   x = x / base\n  end\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  return digits.reverse.join.to_s.reverse\nend", "  b = 10.to_s(base)\n  x =\
    \ x.to_s\n  x.to_s.reverse!\n  x.reverse!\n  x = x.to_s + b.to_s\n  x\nend\nend",
  "  case x\n  when 1\n    return x\n  when 0\n    return 0\n  else # x > 0\n    #\
    \ Using base 10 logarithms.\n    while x > 0\n      x = x / base\n      if x >\
    \ 0\n        base = base * 10\n      else # x < 0\n        base = base * -10\n\
    \    end\n    return base * x\n  end\nend", "  x.to_s.reverse! if x.is_a?(BigDecimal)\n\
    \  x.to_s.split(//).map {|s| s.to_i(base) }.join('')\nend", '  digits = Array.new',
  "  # Write your code here.\nend\n</cell>\n<code language=julia-1.3>", "    return\
    \ x.to_s.reverse.gsub(/./) { |a| a.to_i(base) }.reverse\nend\n</code>\n<|/ a dscore=5\
    \ tags=ruby,math,python |>\n<| c |>\nNice. Slight improvement: change `base` to\
    \ an `Integer`, otherwise `change_base(8, 2)` returns `\"10010\"`.\n<|/ c |>\n\
    <| c |>\n: indeed, changed to `Integer`. Thanks.\n<|/ c |>\n<| c |>\nNice! I only\
    \ needed to add the `reverse` part at the end of `x` because in Ruby `x` would\
    \ be a string, but in Python it's an integer. So the final code would be:", " \
    \ digits = x.digits.clone\n  power = digits.length - 1\n  digits[power] = digits[power].abs\
    \ * base\n  digits[power] = digits[power].div(base).to_i\n  digits.unshift(digits[power].div(base))\n\
    \  x.digits = digits\n  x\nend", "    if base < 2 or base > 36:\n        print(\"\
    Invalid Base Number.\")\n        return\n    if x == 0:\n        return str(0)\n\
    \    result = \"\"\n    while x != 0:\n        rem = x % base\n        result\
    \ = str(rem) + result\n        x = int(x / base)\n    return result\n</cell>\n\
    <cell>", "  base, num = x.to_s.split(/(\\d+)/)\n  base = int(base) rescue raise\
    \ ArgumentError.new(\"Non-base #{base.to_s} digits in #{x.to_s}\")\n  num.to_i(base)\
    \ rescue raise ArgumentError.new(\"Non-numeric digits in #{x.to_s}\")\nend\n</code>\n\
    <|/ a tags=ruby,algorithm |>\n<| a |>\nHere's another solution to take advantage\
    \ of regular expressions to parse the number:\n<code>", "  x.to_s.reverse.gsub!(/../)\
    \ { |s| s.divmod(base)[1] }\n  return x.to_s\nend", "    digits = []\n    digits_base\
    \ = []\n    if base < 2 or base > 36:\n        raise InvalidArgument('The base\
    \ argument must be between 2 and 36.')\n    if x == 0:\n        return '0'\n \
    \   if x < base:\n        return x\n    while x > 0:\n        digits.append(x\
    \ % base)\n        x = x / base\n    digits.reverse()\n    while len(digits_base)\
    \ < len(digits):\n        digits_base.append(0)\n    for i in range(len(digits)):\n\
    \        digits_base[digits_base.index(digits[i]) + 1] += 1\n    return str(digits_base)\n\
    </cell>\n<cell>\nchange_base(8, 2)\n</cell>\n<cell>\nchange_base(7, 2)\n</cell>\n\
    <cell>\nchange_base(8, 36)\n</cell>\n<cell>\nchange_base(8, 3)\n</cell>\n<cell>",
  "  if base == 2\n    x.to_s(base)\n  else\n    x.to_s(base).gsub(/..?0*/, \"\")\n\
    \  end\nend", "  x.to_s.reverse!\n  x.to_s.gsub!(/^0/, \"1\")\n  x.to_s.reverse!\n\
    \  x.to_s.gsub!(/^0/, \"0\")\n  x.to_s.gsub!(/#{base}/) { |s| s.to_s[0...base]\
    \ }\n  x.to_s\nend", "  return x.to_s(base) if base<=10 && x<=10 else x.to_s(0)\n\
    end", "    if x < 0 or base < 2 or base > 36\n        return ''\n    digits =\
    \ ''\n    while x != 0:\n        digits = digits*base + digits[base-1] % base\n\
    \        x /= base\n    return digits", "  result = ''\n  while x > 0\n    digit\
    \ = x % base\n    x = x / base\n    digit = digit.to_i\n    result << (digit *\
    \ base).to_s\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,integer |>\n<| a\
    \ tags=ruby,integer |>\n<code>", "  if x<10\n    return x.to_s base\n  else\n\
    \    (x % base).to_s(base).concat((change_base((x/base)*base,base)).to_s)\n  end\n\
    end", "  if base < 2\n  \treturn ''\n  end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
