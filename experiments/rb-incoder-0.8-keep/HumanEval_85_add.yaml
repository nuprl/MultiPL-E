name: HumanEval_85_add
language: rb
prompt: "# Given a non-empty list of integers lst. add the even elements that are\
  \ at odd indices..\n# Examples:\n# add([4, 2, 6, 7]) ==> 2\ndef add(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n\
  \    candidate = method(:add)\n    assert_equal(88, candidate.call([4, 88]))\n \
  \   assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))\n    assert_equal(0,\
  \ candidate.call([4, 0, 6, 7]))\n    assert_equal(12, candidate.call([4, 4, 6, 8]))\n\
  \  end\nend\n"
completions: ["  i = 0\n  even = 0\n  while i < lst.length\n    if lst[i].odd?\n \
    \     lst[even] = lst[i]\n      even += 2\n    else\n      lst[even] = lst[i]\n\
    \      even += i\n    i += 1\n  end\nend", "    even = lst.find_all{ |x| x%2 ==\
    \ 0 }\n    odd = lst.find_all{ |x| x%2 != 0 }\n    even.zip(odd).reduce(:+)\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYeah but this is using functional programming,\
    \ so I'd rather not use this method\n<|/ c |>\n<| c |>\nI updated my answer to\
    \ use the Enumerable#zip method.  But you really should check out what [Tony Hoare](http://stackoverflow.com/a/16870474/205770)\
    \ suggested!\n<|/ c |>\n<| c |>\nThanks I realized I was trying to do the same\
    \ thing using zip\n<|/ c |>\n<| a |>\n<code>\nlst = [4, 2, 6, 7]\nlst.select {\
    \ |e| e % 2 == 0 }.zip(lst.select { |e| e % 2 != 0 }).reduce(:+)", "  even = 0\n\
    \  odd = 1\n  for i in 0 .. lst.size-1\n    if lst[i] % 2 == 1\n      lst[i] =\
    \ even\n      even = even + 1\n    else\n      lst[i] = odd\n      odd = odd +\
    \ 1 # add 1 to odd elements to increase odd\n    end\n  end\n  return even\nend",
  '    even_numbers = []', "  return lst.sum { |i| i % 2 == 0 } # Returns sum of all\
    \ the even numbers\nend", "  return lst.inject do |sum, e|\n    sum + e if lst.index\
    \ % 2 == 1\n    sum\n  end\nend", "  even_index = 0\n  for i in 0..(lst.size-1)\
    \ # from 0 to end-1\n    if lst[i] % 2 != 0 then\n      lst[even_index + lst[i]]\
    \ += lst[i]\n    end\n  end\n  even_index\nend", "  lst.each {|x| lst[x] +=2}\n\
    end", "  lst.each_with_index do |n,i| # i gets even elements\n    lst[i] = lst[i].even?\
    \ ? n : n + lst[i].to_i\n  end\n  lst.sum\nend", "    lst.each_with_index { |el,\
    \ i| puts \"adding #{el} at #{i + 1}\" if el % 2 == 1 }.\n     reduce(:+)\nend",
  "  even = []\n  odd = []\n  for i in 0...lst.size\n    if i % 2 == 0\n      even.push(lst[i])\n\
    \    else\n      odd.push(lst[i])\n  even.each { |x| lst.push(x+even.last) }\n\
    \  odd += even.take(odd.size)\n  return odd.join\nend\nprint add([4, 2, 6, 7])\n\
    </code>\n<|/ a |>\n<| c |>\nThe answer doesn't show why this would work and the\
    \ original code doesn't.\n<|/ c |>\n<| a tags=arrays,ruby,list |>\n<code>", " \
    \ lst.each do |x|\n    if x.is_even? and lst[x.even_index].is_even?\n      lst[x.even_index]\
    \ += x.odd\n    end\n  end\n  \n  return lst\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nThe `if x.is_even? and lst[x.even_index].is_even?` should be `if x.is_even?\
    \ and lst[x.odd_index].is_even?`\n<|/ c |>\n<| c |>\nThanks, yes I saw that as\
    \ well.\n<|/ c |>\n<| a dscore=0 tags=ruby |>\nThis is my implementation:\n<code>",
  "  even = lst[1..(lst.length/2)]\n  odd =  lst[1..(lst.length-1)]\n  even.zip(odd).inject(0)\
    \ { |a,b| a + b }\nend\n</cell>\n<cell>", "  sum = 0\n  i = 0\n  while i < lst.length\n\
    \    if i % 2 == 0\n      sum += lst[i]\n    i += 1\n  end\n  return sum\nend",
  "  # get an iterator from lst\n  itr = lst.to_enum\n  # initialize even\n  even\
    \ = 0\n  # initialize odd\n  odd = 0\n  # While there is an element in itr\n \
    \ while itr.next\n    # If the current element is even\n    if itr.current.even?\n\
    \      # Add 2 to the even\n      even = even + 2\n    else\n      # Add 2 to\
    \ the odd\n      odd = odd + 2\n    end\n  end\n  # Return the result\n  return\
    \ even+odd\nend", "  evens = 0\n  odds = 1\n  for i in 0...lst.size - 1\n    if\
    \ (lst[i] % 2 != 0) # or if (lst[i] % 2 == 0)\n      evens += lst[i]\n    else\n\
    \      odds += lst[i]\n    end\n  end\n  evens + odds\nend\n</cell>\n<code language=julia-1.0>",
  "  even = []\n  odd = []", "  result = lst.shift\n  (0...lst.size).each do |i|\n\
    \    if lst.include?(i % 2 == 0)\n      result += i\n    end\n  end\n  result\n\
    end", "  even = []\n  odd  = []\n  index = 0\n  while index < lst.length\n   \
    \ if index % 2 == 0\n      even = even + lst[index]\n    else\n      odd = odd\
    \ + lst[index]\n    end\n    index = index + 1\n  end\n  return even.concat(odd)\n\
    end", "  if lst.size == 0 then return 0\n  result = 0\n  (0..(lst.size-1)).each{|i|\
    \ result = result + lst[i]}\n  return result if result % 2 == 0\nend", "  return\
    \ lst[0] + lst[3] if lst.size > 3 else lst[0]\nend\n</cell>\n<text>\nNext we define\
    \ a function which returns a list of the odd integers in a list of integers.",
  "  even_sum = 0\n  even_index = 0\n  odd_index = 0\n  odd_sum = 0\n  \n  even_sum\
    \ = even_sum + lst[even_index]\n  odd_sum = odd_sum + lst[odd_index]\n  \n  even_index\
    \ += 1\n  odd_index += 1\n  \n  \n  while even_index < lst.size\n    even_sum\
    \ = even_sum + lst[even_index]\n    even_index += 1\n  \n    while odd_index <\
    \ lst.size && lst[odd_index] % 2 == 1\n      odd_sum = odd_sum + lst[odd_index]\n\
    \      odd_index += 1\n      \n  end\n  \n  \n  return even_sum + odd_sum\nend",
  "  # write your code here\nend", "    even = []\n    odd = []\n    \n    even.push(*lst.take_while\
    \ { |x| x % 2 == 0 })\n    odd.push(*lst.take_while { |x| x % 2 != 0 })\n    \n\
    \    even.inject(:+)\n    odd.inject(:+)\nend\n</cell>\n<text>\nExercise: Write\
    \ the function below that will take a list of integers and find the median from\
    \ that list. The median is the number in the middle of the list which contains\
    \ all the numbers in the list. The list can contain duplicates.", "  # Your code\
    \ here\nend", "  even = lst[0...-1].select { |i| i.odd? }\n  odd =  lst[0...-1].select\
    \ { |i| i.even? }\n  even.inject(0) {|sum, i| sum + i }\nend", "  sum = 0\n  for\
    \ i in 0...lst.size\n    sum += i%2 != 0\n  end\n  sum + lst[1..lst.size].reduce(:+)\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| a |>\nThe simplest solution:\n<code>",
  "  even = lst.select { |x| (x % 2) == 0 }\n  odd = lst.select { |x| (x % 2) == 1\
    \ }\n  even.zip(odd).reduce(:+)\nend\n</cell>\n<code language=conda-env-adventofcode-py>\n\
    add(list3)\n</cell>\n<code language=conda-env-adventofcode-py>", "  evens = lst.select\
    \ { |num| num.even? }\n  odds = lst.select { |num| num.odd? }\n  evens.zip(odds).inject\
    \ { |sum, pair| sum + pair[0].to_i + pair[1].to_i }\nend", "  sum = 0\n  for i\
    \ in lst\n    if (i.even?)\n      sum += i\n  end\n  sum\nend", "  return lst.inject(:+)\n\
    end", "  sum = 0\n  i = 0\n  while i < lst.length\n    if lst[i] % 2 == 1\n  \
    \    sum += lst[i]\n    end\n    i += 1\n  end\n  return sum\nend", "  sum = 0\n\
    \  for i in 0..lst.length-1\n    if lst[i]%2 == 1\n      sum += lst[i]\n    end\n\
    \  end\n  return sum\nend", "    even = []\n    odd = []\n    i = 0\n    while\
    \ i < lst.size\n        even.push lst[i]  if i % 2 == 0  \n        odd.push lst[i]\
    \  if i % 2 != 0  \n        i += 1\n    end\n    return even.zip(odd).inject{|sum,\
    \ pair| sum + pair[0]+pair[1]}\nend\n</cell>\n<cell>\nadd(lst)\n</cell>\n<text>\n\
    Problem 8: Remove Duplicates in an Array\nGiven an array of integers nums. Remove\
    \ the duplicates from this array and return a new array of unique elements. Your\
    \ function should do the following:", "  even = lst.select { |i| i.odd? }\n  return\
    \ even.inject(:+)\nend", "  lst.each_with_index do |n,i|\n    if i%2 == 1\n  \
    \    lst.delete_at(i) # remove at index\n      lst[i] +=n\n    end\n  end\n  return\
    \ lst\nend\n</cell>\n<code language=julia-1.0>\nadd([1,2,3,4,5,6])\n</cell>\n\
    <code language=julia-1.0>\nfunction add1(lst)\n  lst.each_with_index do |n,i|\n\
    \    if i%2 == 1\n      lst.delete_at(i) # remove at index\n      lst[i] +=n\n\
    \    end\n  end\n  return lst\nend\n</cell>\n<code language=julia-1.0>\nadd1([1,2,3,4,5,6])\n\
    </cell>\n<code language=julia-1.0>\nfunction add2(lst)\n  lst.each_with_index\
    \ do |n,i|\n    if i%2 == 1\n      lst.delete_at(i) # remove at index\n      lst[i]\
    \ +=n\n    end\n  end\n  return lst\nend\n</cell>\n<code language=julia-1.0>\n\
    add2([1,2,3,4,5,6])\n</cell>\n<code language=julia-1.0>\nfunction add3(lst)\n\
    \  lst.each_with_index do |n,i|\n    if i%2 != 0\n      lst.delete_at(i) # remove\
    \ at index\n      lst[i] +=n\n    end\n  end\n  return lst\nend\n</cell>\n<code\
    \ language=julia-1.0>\nadd3([1,2,3,4,5,6])\n</cell>\n<code language=julia-1.0>\n\
    function add4(lst)\n  lst.each_with_index do |n,i|\n    if i%2 == 0\n      lst.delete_at(i)\
    \ # remove at index\n      lst[i] +=n\n    end\n  end\n  return lst\nend\n</cell>\n\
    <code language=julia-1.0>\nadd4([1,2,3,4,5,6])\n</cell>\n<code language=julia-1.0>\n\
    function add5(lst)\n  lst.each_with_index do |n,i|\n    if i%2 == 0\n      lst.delete_at(i)\
    \ # remove at index\n      lst[i] +=n\n    end\n  end\n  return lst\nend\n</cell>\n\
    <code language=julia-1.0>\nadd5([1,2,3,4,5,6])\n</cell>\n<code language=julia-1.0>\n\
    function add6(lst)\n  lst.each_with_index do |n,i|\n    if i%2 == 0\n      lst.delete_at(i)\
    \ # remove at index\n      lst[i] +=n\n    end\n  end\n  return lst\nend", " \
    \ evens = []\n  odds = []\n  for i in (0..(lst.length-1))\n    if i.even?\n  \
    \    evens << i\n    else \n      odds << i\n    end\n  end\n  evens.zip(odds).map\
    \ { |i,j| i+j}\nend", "  even = lst.each_with_index { |x, i| i % 2 == 0 }\n  even.inject(0)\
    \ { |sum, e| sum + e }\nend", "  lst.each { |i| puts i if i.odd? }\nend", "  lst.each_with_index\
    \ do |e, i| \n    return 0 if i % 2 == 1 \n    lst[i] = e + lst[i + 1] \n  end\
    \ \n  lst.inject(:+)\nend", "  return lst.inject(:+)\nend", "  evens, odds = lst.partition{|x|\
    \ x % 2 == 0}\n  return evens.reduce(:+) if evens.length == odds.length\n  evens.reduce(:+)\n\
    end", "  even_indices = []\n  odd_indices = []\n  lst.each do |el|\n    if el\
    \ % 2 == 0\n      even_indices << el\n    else\n      odd_indices << el\n    end\n\
    \  end\n  even_indices.reduce(:+) + odd_indices.reduce(:+)\nend\n</cell>\n<cell>",
  "    evens = lst.find {|x| x % 2 == 0}\n    evens ? (evens + lst.length) : nil\n\
    end", "  return lst.inject{|sum, e| sum + e if e % 2 == 1}\nend\n</cell>\n<code\
    \ language=ruby-1.9.3-p448>\nadd([4,2,6,7])\n</cell>\n<code language=ruby-1.9.3-p448>",
  "  sum = 0\n  for i in lst\n    sum += i%2\n  end\n  sum\nend", "  return lst.inject(0)\
    \ { |sum, el| sum + el if el % 2 == 1 }\nend", "  sum = 0\n  lst[0..-1].each do\
    \ |i|\n    sum += i if i % 2 == 1\n  end\n  sum\nend", "  result = 0\n  for i\
    \ in 0...lst.length\n    if (lst.index % 2 == 0)\n      result = result + lst.index\n\
    \    end\n  end\n  puts result\nend", "  return lst.inject(:+)\nend", "  even\
    \ = lst[2..-1].inject(:+)\n  odd =  lst[0..-2].inject(:+)\n  (even + odd).to_i\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`inject` and `each_cons` are great\
    \ for problems where you are expecting lots of matches, like finding all the primes\
    \ in a large list. Here though, you are just looking for `even`.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nHere you have a solution which doesn't use inject but uses each:\n\
    <code>", "  even = []\n  odd = []\n  for i in lst.each_index do \n    if i%2 ==\
    \ 0\n      even << lst[i]\n    else\n      odd << lst[i]\n    end\n  end\n  even.zip(odd).inject(:+)\n\
    end\n</code>\nAs you can see you can also do cool stuff, like even and odd lists\
    \ in Ruby.\n<|/ a dscore=1 |>\n<| c |>\nI didn't downvote you for this, I upvoted\
    \ it since I didn't see anything wrong with it. By the way, you can use `even.zip(odd).reduce(:+)`\
    \ instead of `even.zip(odd).inject(:+)`\n<|/ c |>\n<| c |>\nYeah, `reduce` has\
    \ one advantage over `inject`, which I missed in my initial answer. It lets you\
    \ pass in an initial value for the accumulator so you don't have to call `inject`\
    \ with a block that always returns `0`. `reduce(:+)` would give you `0`.  It also\
    \ comes with some nice features of [Enumerable#inject](http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-inject),\
    \ such as passing in a starting value, and using an accumulator for multiple things,\
    \ not just one thing. Anyways, thanks for the feedback, I've corrected my code.\n\
    <|/ c |>\n<| a tags=ruby |>\nJust use an if statement:\n<code>", "  lst.each_with_index\
    \ do |elem, i|\n    if i.odd?\n      lst[i] += elem\n    end\n  end\n  lst\nend",
  "  even_positions = []\n  \n  for i in 0...lst.size\n    if (lst[i] % 2 == 0)\n\
    \      even_positions << i\n  end\n  \n  for i in 0...lst.size\n    if (even_positions.include?(i))\n\
    \      lst[i] += 2\n    end\n  end\n  \n  lst\nend", "    even = []\n    odd =\
    \ []\n    i = 0\n    j = lst.length - 1\n    while (i < j)\n        if (lst[i]\
    \ % 2 != 0)\n            even.push(lst[i])\n        else\n            odd.push(lst[i])\n\
    \        i += 1\n        j -= 1\n    return (even.inject(:+) + odd).to_a\nend",
  "  evens = 0\n  odd_elements = []\n  for i, num in enumerate(lst)\n    if i % 2\
    \ == 1\n      odd_elements << num\n    else\n      evens << num\n    end\n  end\n\
    \  evens << odd_elements.reduce(:+)\n  evens\nend", "  count = 0\n  for i in lst\n\
    \    if (i % 2 == 1)\n      count = count + i\n    end\n  end\n  return count\n\
    end", "  even = nil\n  odd = nil\n  if lst.empty?\n    even = nil\n    odd = nil\n\
    \  elsif lst.size < 2\n    even = nil\n    odd = nil\n  else\n    even = lst.find\
    \ { |x| x.even? }\n    odd = lst.find { |x| x.odd? }\n  end\n  if even\n    odd.even?\
    \ ? lst.delete_at(odd.index) : add(odd)\n  elsif odd\n    even.odd? ? lst.delete_at(even.index)\
    \ : add(even)\n  else\n    add(lst)\n  end\nend", "  even_index = []\n  odd_index\
    \ = []\n  odd_even_index = []", "  res = nil\n  lst.each { |x| res += x if x %\
    \ 2 == 1 }\n  res\nend", "  return lst.inject(0) do |sum, v| sum + v unless v.odd?;\
    \ sum end\nend", "    even_positions = []\n    odd_positions = []\n    even_positions\
    \ << lst.index(2..-1)\n    odd_positions << lst.index(1..-1)\n    even_positions\
    \ << lst.index(2..-1)\n    even_positions << lst.index(3..-1)\n    odd_positions\
    \ << lst.index(1..-1)\n    odd_positions << lst.index(3..-1)\n    even_positions\
    \ << lst.index(2..-1)\n    even_positions << lst.index(4..-1)\n    even_positions\
    \ << lst.index(5..-1)\n    even_positions << lst.index(6..-1)\n    even_positions\
    \ << lst.index(7..-1)", "  even = lst[1..-1].select { |x| x % 2 == 0 }\n  even.inject(0)\
    \ do |total, even|\n    total += even\n    total\n  end\nend\n</code>\nAs you\
    \ noticed, this is really more complicated than you probably intended, so let's\
    \ rewrite it.\n<code>", "    even = 0\n    for i in 0...lst.size\n        if lst[i]\
    \ % 2 == 0\n            even = even + lst[i]\n    end\n    even\nend", "    lst.select\
    \ { |x| x.odd? }.inject(:+)\nend", "  evens, odds = [], []\n  even_indices = []\n\
    \  odd_indices = []\n  evens_count = 0\n  for i in lst\n    if i.even?\n     \
    \ evens.push(i)\n      even_indices.push(i)\n      evens_count += 1\n    else\n\
    \      odds.push(i)\n      odd_indices.push(i)\n    end\n  end\n  if evens_count\
    \ > 0\n    evens.concat(even_indices.map { |index| lst[index] })\n  end\n  odd_indices.each\
    \ do |index|\n    evens.delete(lst[index])\n  end\n  evens.reduce(:+)\nend", " \
    \ evens = 0...lst.count\n  evens.inject(0) {|acc, i| acc += lst[i] if i % 2 ==\
    \ 1}\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\nHere's a version that's a little\
    \ easier to read, and less verbose. Also I used the splat operator to remove the\
    \ need to pass in an explicit array argument.\n<code>", "  even_indexes = lst.select\
    \ {|x| x % 2 == 0}\n  even_indexes.inject {|sum, v| sum + v}\nend", "  return\
    \ lst.inject(0){|sum, element| sum + element % 2 }\nend\n</code>\nNow to explain\
    \ the inject method on arrays and hashes. Inject is a method available on all\
    \ ruby objects that loops through an array or hash and passes the element and\
    \ the index to your block. Here is an example of how it works:\n<code>\n>> arr\
    \ = [1, 2, 3, 4]\n>> arr.inject(0){|sum, element| sum + element }\n=> 10\n</code>\n\
    The inject method takes the array and passes the element and the index into the\
    \ block. It then returns the final value of the block. In the case above the block\
    \ simply sums the elements. The inject method takes in two arguments. The first\
    \ argument is what will be returned from the block. In the case above the returned\
    \ value is the sum. In the second argument the index of the element will be passed\
    \ into the block. So the block would look like this:\n<code>\n{|sum, index| sum\
    \ + arr[index] }\n</code>\nNotice that in this example the sum variable does not\
    \ have an argument in the block but we are able to retrieve it from the block.\n\
    Now to the last method you asked about, the delete_if method. This method is used\
    \ to remove all elements of a given array that meet a certain condition. The syntax\
    \ for this method is delete_if(condition). Let's say the user gives the program\
    \ an argument that checks to see if the number is even. Let's assume that we are\
    \ able to check that argument like so:\n<code>", "  return lst.inject(:+)\nend",
  "  lst.each_with_index do |e, i|\n    next if i == 0\n    lst[i + 1] += e if i %\
    \ 2 == 0\n  end\n  \n  lst\nend", "    i = 0\n    sum = 0\n    until i == lst.length\n\
    \        sum +=lst[i]\n        i = i + 1\n        sum += lst[i]\n    return sum\n\
    end", "  lst.each_with_index { |num, index|\n    if index % 2 == 1 then\n    \
    \  num + lst[index ^ 1]\n    end\n  }\nend\n</cell>\n<cell>\nlst = [4, 2, 6, 7]\n\
    add(lst)\n</cell>\n<cell>", "  lst.each_with_index do |value, index|\n    if index\
    \ % 2 == 0\n      lst.insert(index + 1, value)\n    end\n  end\n  lst\nend", " \
    \ lst.each_with_index do |el, index| \n    next if index < 2\n    lst[index] +=\
    \ el\n  end\n  lst\nend\n</code>\nNote that in Ruby you can \"reduce\" a list\
    \ with just one line as you do in your add function:\n<code>\nlst.each_with_index.reduce(0)\
    \ { |memo, el| memo += el } \n</code>\nYou can, for example, use the Enumerable#map\
    \ method as well to change the elements while iterating over a list:\n<code>\n\
    lst = [1, 4, 3, 7, 5, 8, 2]\nlst.map.with_index { |el, index| index + el }\n=>\
    \ [1, 5, 8, 6, 4, 2, 7]\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| a |>\nMy understanding\
    \ of this problem is that you are looking to find out the sum of all even numbers\
    \ in a given list.\n<code>", "  even_indexes = lst.select { |x| x % 2 == 0 }\n\
    \  even_indexes.reduce(0) { |sum, x| sum + x }\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\n`even_indexes = lst.select { |x| x % 2 == 0 }`\n<|/ c |>\n<| c |>\nWhat\
    \ is this notation called? `{ |sum, x| sum + x }`. Where can I find this documented?\n\
    <|/ c |>\n<| c |>\n, it is called a block. Here is a link to the documentation\
    \ on `Enumerable#reduce`: http://ruby-doc.org/core-2.1.1/Enumerable.html#method-i-reduce\n\
    <|/ c |>\n<| c |>\nYes, but it's not a block literal, but a Hash literal, so this\
    \ syntax is very unusual and not very clear.\n<|/ c |>\n<| c |>\n, how is that\
    \ unusual ?\n<|/ c |>\n<| a dscore=2 |>\nA more functional solution\n<code>",
  "  evens = 0.each_index do |i|\n    if (lst[i] % 2 == 0)\n      lst[i] += 2\n  \
    \  end\n  end\n  lst\nend", "  even = lst[0..-2]\n  odd = lst[1..-1]\n  even.inject(0)\
    \ do |sum, e|\n    sum + e\n  end\nend\n</cell>\n<code language=ruby-1.6>\nadd(lst)\n\
    </cell>\n<text>\nProblem 10\nA list has duplicates. Find the duplicated number\
    \ or all duplicated numbers in a list.", "  # Your code here\n  even = []\n  odd\
    \ = []\n  for el in lst\n    if el % 2 == 0\n      even.push el\n    el % 2 ==\
    \ 1\n      odd.push el\n  end\n  even.concat(odd)\n  return even\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a |>\nMy first solution:\n<code>", "  even = []\n  odd\
    \ = []\n  lst.each do |num|\n    if num % 2 == 0\n      even << num\n    else\n\
    \      odd << num\n    end\n  end\n  even.zip(odd).reduce(&:+)\nend", "  return\
    \ lst.inject(0) { |result, num| result + num % 2 }\nend", "  evens = lst.select\
    \ { |x| x % 2 == 0 }\n  evens.inject { |sum, e| sum + e }\nend", "  even = lst.take_while\
    \ { |x| x % 2 == 0 }.take_while { |x| x % 2 != 0 }\n  even.reduce(:+)\nend", " \
    \   evens = []\n    odd = []\n    lst.each do |num|\n        if num % 2 == 0\n\
    \            evens << num\n        else\n            odd << num\n        end\n\
    \    end\n    evens.reduce(:+) + odd.reduce(:+)\nend\n</code>\n<|/ a tags=ruby,algorithm\
    \ dscore=1 |>\n<| c |>\nThis is a nice answer, but you should provide an explanation\
    \ of your solution.\n<|/ c |>\n<| a tags=ruby,algorithm |>\nIf you don't want\
    \ to use any library function then here is the solution:\n<code>\narray = [4,5,3,6,1]",
  "  even = []\n  odd = []\n  n = 0\n  while n < lst.length\n    n += 2\n    if n%2\
    \ == 0\n      even << lst[n]\n    else\n      odd << lst[n]\n    end\n  end\n\
    \  even.each do |e|\n    lst.insert(lst.index(e), e)\n  end\nend", "  if lst.is_a?\
    \ Integer\n    lst = [] if lst == []\n    lst = [lst] unless lst.is_a? Array\n\
    \    lst = [lst] unless lst.is_a? Array\n    lst.each_with_index do |item, index|\n\
    \      lst[index] += item if index % 2 == 1\n    end\n    lst = lst.flatten\n\
    \  elsif lst.is_a? Array\n    lst.each_with_index do |item, index|\n      lst[index]\
    \ += item if index % 2 == 1\n    end\n  end\n  lst\nend", "  return lst.inject(0)\
    \ { |sum, el| sum + (el % 2 ? el : 0) }\nend", "  if lst.empty?\n    []\n  else\n\
    \    lst.each_with_index { |e, i| e + lst.drop(i).reduce(:+) }\n  end\nend", " \
    \   i = 0\n    evens = []", "  even = lst.select { |x| x % 2 == 0 }\n  odd = lst.select\
    \ { |x| x % 2 != 0 }\n  even + odd\nend\n</code>\n<|/ a |>\n<| c |>\nYour last\
    \ line is incorrect. `[2,4] + [3]` is `[2,3,4]`, not `[2,4]`\n<|/ c |>\n<| c |>\n\
    Your last line is incorrect. `[2,4] + [3]` is `[2,3,4]`, not `[2,4]`. Also, your\
    \ second line is incorrect: `[2,4,6] is [2,6,4]`\n<|/ c |>\n<| c |>\n, you're\
    \ correct. I've updated my answer, thanks.\n<|/ c |>\n<| c |>\n, also fixed the\
    \ second line. Thanks.\n<|/ c |>\n<| c |>\n`[2,4,6] is [2,6,4]` -- This is wrong.\
    \ Try it in your console, `[2,4,6].is_a?(Array)` returns `false`.\n<|/ c |>\n\
    <| a tags=ruby dscore=3 |>\n<code>", "  lst.inject(0) { |sum, el| sum + el if\
    \ el % 2 == 1 }\nend", "  evens = 0\n  odds = 0\n  for i in 0...lst.size - 1\n\
    \    if i % 2 == 0\n      evens += lst[i]\n    else\n      odds += lst[i]\n  end\n\
    \  evens\nend", "  evens_at_odd = lst.select{|x| (x % 2).zero?}\n  evens_at_odd.reduce(&:+)\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,list,sum |>\n<code>", "  evens\
    \ = lst.select {|x| x % 2 == 0} # evens is a list of even integers.\n  odds  =\
    \ lst.select {|x| x % 2 == 1}  # odds is also a list of the odd integers.\n  evens.reduce(0)\
    \ +  odds.reduce(0)\nend", "  even = []\n  odd = []", "  even = lst[lst.index(lst[1],\
    \ even = true)]\nend\nprint(add(lst))", "  return lst.select { |e| e % 2 == 1\
    \ }.inject(0, :+)\nend", "  lst.each_with_index do |x, i|\n    lst[i] = x + lst[i\
    \ % lst.size] if i % 2 == 0\n  end\nend\n</code>\n<|/ a tags=ruby,enumerable |>\n\
    <| c |>\nPlease see the update to my question. I've added an example of where\
    \ I am having a problem. Thanks for your help!\n<|/ c |>\n<| c |>\nI've updated\
    \ my answer, but you're trying to use each_with_index with a block that returns\
    \ a value (ie. a method) and you're passing a block to each.\n<|/ c |>\n<| c |>\n\
    Thanks for your help! I appreciate it.\n<|/ c |>\n<| a |>\nYou don't need to pass\
    \ any blocks to each. Just use the index method on the Enumerable class (which\
    \ each, in turn, calls) to get the current index of the Enumerable object, then\
    \ use that index to get the item at the current index from the array:\n<code>",
  "  sum = 0\n  i = 0\n  while i < lst.length\n    if lst[i] % 2 == 0\n      sum +=\
    \ lst[i]\n    end\n    i += 1\n  end\n  return sum\nend", "  return nil if lst.empty?\
    \ || lst.all?{ |i| i % 2 == 0}\n  return lst.map { |i| i + lst.index(i) }.sum\
    \ if lst.all?{ |i| i % 2 == 0 }\n  lst[0] + lst[1..-1].inject(:+) if lst.all?{\
    \ |i| i % 2 == 0 }\nend", "  even = []\n  odd = []", "  result = 0\n  lst.each\
    \ do |n|\n    if n % 2 == 0\n      result = result + n\n    end\n  end\n  result\n\
    end", "    return lst[1..-1].inject(0, :+)\nend", "  return lst.inject(:+)\nend",
  "    evens = lst[1 .. end-2]\n    odds = lst[2..end]\n    result = 0\n    result\
    \ + evens.reduce(:+) if evens.any?\n    result + odds.reduce(:+) if odds.any?\n\
    \    result\nend", "  even = []\n  odd = []\n  lst.each do |i|\n    if (i % 2\
    \ == 0)\n      even << i\n    else\n      odd << i\n    end\n  end\n  even.zip(odd).inject(0,\
    \ :+)\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\nHere's my take: \n\
    <code>", "    even = lst[0..(lst.size/2)]\n    odd = lst[(lst.size/2)..(lst.length-1)]\n\
    \    return even.inject(:+) + odd.inject(:+)\nend\n</cell>\n<code language=julia-1.6>\n\
    add(collect(0:3))\n</cell>\n<text>\nExercise\nLet's implement the sum function\
    \ from the tutorial, but instead of returning the result directly, add it to an\
    \ accumulator that you will keep in the variable sum. Then return the final value\
    \ of sum.", "  even = []\n  odd = []\n  even.concat(lst[1..-1])\n  odd.concat(lst[2..-1])\n\
    \  even.concat(lst[2..-1])\n  even.concat(lst[1..-1])\n  even.concat(lst[1..-1])\n\
    \  even.concat(lst[2..-1])\n  odd.concat(lst[2..-1])\n  odd.concat(lst[2..-1])\n\
    \  odd.concat(lst[1..-1])\n  odd.concat(lst[1..-1])\n  odd.concat(lst[1..-1])\n\
    \  even.concat(lst[2..-1])\n  even.concat(lst[1..-1])\n  even.concat(lst[2..-1])\n\
    \  even.concat(lst[1..-1])\n  even.concat(lst[2..-1])\n  even.concat(lst[1..-1])\n\
    \  even.concat(lst[2..-1])\n  odd.concat(lst[2..-1])\n  odd.concat(lst[1..-1])\n\
    \  odd.concat(lst[2..-1])\n  odd.concat(lst[1..-1])\n  odd.concat(lst[1..-1])\n\
    \  odd.concat(lst[1..-1])\n  odd.concat(lst[2..-1])\n  even.concat(lst[1..-1])\n\
    \  even.concat(lst[2..-1])\n  odd.concat(lst[2..-1])\n  even.concat(lst[1..-1])\n\
    \  even.concat(lst[2..-1])\n  even.concat(lst[1..-1])\n  even.concat(lst[2..-1])\n\
    \  even.concat(lst[1..-1])\n  even.concat(lst[2..-1])\n  even.concat(lst[1..-1])\n\
    \  even.concat(lst[2..-1])\n  even.concat(lst[1..-1])\n  even.concat(lst[2..-1])\n\
    \  even.concat(lst[1..-1])\n  even.concat(lst[2..-1])\n  even.concat(lst[1..-1])\n\
    \  even.concat(lst[2..-1])\n  even.concat(lst[1..-1])\n  even.concat(lst[2..-1])\n\
    \  even.concat(lst[1..-1])\n  odd.concat(lst[1..-1])\n  odd.concat(lst[2..-1])\n\
    \  odd.concat(lst[2..-1])\n  odd.concat(lst[1..-1])\n  odd.concat(lst[2..-1])\n\
    \  odd.concat(lst[1..-1])\n  odd.concat(lst[1..-1])\n  odd.concat(lst[2..-1])\n",
  "  lst.each do |el|\n    if el % 2 == 1\n      lst.delete_at(lst.index(el))\n  \
    \  end\n  end\n  lst\nend\n</code>\nSo we basically just delete the element at\
    \ that index and add it to the end of the list. As it is, it's O(n^2). We can\
    \ make it more efficient by deleting just one element at a time instead of all\
    \ of them.\n<code>", "  even = []\n  odd = []\n  even.concat(lst[1..-1])\n  odd.concat(lst[2..-1])\n\
    \  even.each_with_index { |e, i| odd << e if (i % 2) == 1}\n  odd.each_with_index\
    \ { |e, i| odd << e if (i % 2) == 0}\n  even.concat(odd)\n  even\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby |>\n<| a tags=ruby |>\n<code>", "  lst.inject(0, :+)\n\
    end", "  evens = lst.select{|i| i % 2 == 0}\n  evens.inject{|sum, i| sum + i}\
    \ \nend", "    even = 0\n    odd = 0\n    even_index = 0\n    odd_index = 0\n\
    \    while even_index < lst.length\n        even += lst[even_index] if odd_index\
    \ < lst.length else 0\n        odd += lst[odd_index] if even_index < lst.length\
    \ else 0\n        even_index += 1\n        odd_index += 1\n    end\n    even\n\
    end\n</code>\n<|/ a tags=algorithm,ruby,arrays,ruby-on-rails dscore=2 |>\n<| c\
    \ |>\nI think you've misunderstood the question. OP said the desired output is\
    \ `2` when given `[4, 2, 6, 7]`. It should be `2`, not `4`.\n<|/ c |>\n<| c |>\n\
    Thanks, missed that part. Fixed now.\n<|/ c |>\n<| a tags=algorithm,ruby,arrays,ruby-on-rails\
    \ dscore=2 |>\nYou could use Enumerable#each_cons which would let you process\
    \ two elements per iteration:\n<code>", "    # Write your code here.\n    even\
    \ = []\n    odds = []\n    count = 0\n    temp = lst[0]\n    for i in lst\n  \
    \      if i % 2 == 0\n            even.push i\n        else\n            odds.push\
    \ i\n    end\n    even.each do |i|\n        count = count + i\n    end\n    odds.each\
    \ do |i|\n        count = count - i\n    end\n    return count\nend", "  even\
    \ = lst.select { |x| x % 2 == 0 }\n  even.inject(0) { |sum, elem| sum + elem }\n\
    end", "    even_indices = []\n    i = 0\n    while i < lst.size\n        if i\
    \ % 2 == 0\n            even_indices.push(i)\n        end\n        i += 1\n  \
    \  \n    even_indices.each do |index|\n        lst[index] = lst[index] + lst[index\
    \ + 1]\n    end\nend", "  result = lst[0]\n  for i in (1..lst.length - 1)\n  \
    \  result += (lst[i] % 2 == 0) ? lst[i] : 0\n  result\nend", "  even = lst.select\
    \ { |x| x % 2 == 0 }\n  odd = lst.select { |x| x % 2 != 0 }\n  even.inject(0)\
    \ { |acc, x| acc + x }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your\
    \ help but im a total noob at ruby so im finding it hard to understand your code\n\
    <|/ c |>\n<| c |>\nI've added comments to help you.\n<|/ c |>\n<| c |>\nthanks\
    \ so much for your help and taking the time to explain it\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>\na = [4,2,6,7]\na.zip(a.each_index.drop_while{|i| a[i]%2 == 0}).inject{|x,\
    \ y| x + y}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=ruby |>\nThis is a\
    \ little tricky since inject is called twice.  To avoid the double call, the code\
    \ can be written to only call inject once.  For example:\n<code>", "  lst.inject(0)\
    \ {|s, e| (s << 1) + e if (e % 2) }\nend", "    odd_indexes = []\n    even_elements\
    \ = []\n    odd_elements.each_index do |index|\n        if index % 2 == 1\n  \
    \          even_elements << lst[index]\n            odd_indexes << index\n   \
    \     end\n    end\n    even_elements.each_with_index do |element, index|\n  \
    \      lst[index] = element + lst[odd_indexes[index]]\n    end\nend\n</cell>\n\
    <code language=conda-env-adventofcode-py>\nlst = [4,2,6,7]\nadd(lst)\nlst\n</cell>\n\
    <code language=conda-env-adventofcode-py>", "  sum = 0\n  for i in 0..(lst.length-1)\n\
    \    sum += lst[i]\n  end\n  for i in 0..(lst.length-1)\n    if lst[i] % 2 ==\
    \ 0\n      sum += lst[i]\n    end\n  end\n  return sum\nend", "  even = []\n \
    \ odd = []\n  lst.each_with_index do |element, index|\n    if index % 2 == 0\n\
    \      even << element\n    else\n      odd << element\n    end\n  end\n  even.inject\
    \ {|sum, val| sum + val} + odd.inject {|sum, val| sum + val}\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nHaha, very nice answer\n<|/ c |>\n<| c |>\nNo need for the `if`:\
    \ `lst.each_with_index.map { |e, i| i % 2 ? e : nil }.compact.inject(:+)`\n<|/\
    \ c |>\n<| c |>\nWhy would you need the map and compact here?\n<|/ c |>\n<| c\
    \ |>\nNo reason - I personally think it's a little cleaner with a compact (I assume\
    \ it's faster) - but I'm interested in the reason for compact :)\n<|/ c |>\n<|\
    \ c |>\nI like compact better too. More readable. I would have upvoted twice if\
    \ I could. :)\n<|/ c |>\n<| a tags=arrays,ruby,sum |>\nThis could also be done,\
    \ but Im not sure why you would want to do this.\n<code>", "  lst.each_with_index\
    \ do |number, index|\n    if index.odd? && number.even?\n      number + 2\n  \
    \  end\n  end\nend\n</code>\nYou could also use map and reduce:\n<code>", "  lst.inject(0)\
    \ {|sum, a| sum += a if (a % 2) != 0} + lst.length\nend", "  lst.each_with_index\
    \ do |item, i|\n    return if i % 2 == 1\n    lst[i] = item\n  end\n  lst.sum\n\
    end", "  even = lst.select { |x| x % 2 == 0 }\n  odd = lst.select { |x| x % 2\
    \ == 1 }\n  even.inject(:+) + odd.inject(:+)\nend\nputs add([4,2,6,7])", "  return\
    \ lst.inject(:+)\nend", "    evens, odds = lst.partition{|e| e%2 == 1}\n    evens.reduce(0,\
    \ &:+) + odds.length*2\nend", "  even = 0\n  odd = 1\n  even, odd = even, odd\
    \ + 1\n  even, odd = odd, even + 1\n  even, odd = odd, even + 1\n  even, odd =\
    \ odd, even + 1\n  even, odd = odd, even + 1\n  even, odd = odd, even + 1\n  even,\
    \ odd = odd, even + 1\n  even, odd = odd, even + 1\n  even, odd = odd, even +\
    \ 1\n  even, odd = odd, even + 1\n  even, odd = odd, even + 1\n  even, odd = odd,\
    \ even + 1\n  even, odd = odd, even + 1\n  even, odd = odd, even + 1\n  even,\
    \ odd = odd, even + 1\n  even, odd = odd, even + 1\n  even, odd = odd, even +\
    \ 1\n  even, odd = odd, even + 1\n  even, odd = odd, even + 1\n  even, odd = odd,\
    \ even + 1\n  even, odd = odd, even + 1\n  even, odd = odd, even + 1\n  even,\
    \ odd = odd, even + 1\n  even, odd = odd, even + 1\n  even, odd = odd, even +\
    \ 1\n  even, odd = odd, even + 1\n  even, odd = odd, even + 1\n  even, odd = odd,\
    \ even + 1\n  even, odd = odd, even + 1\n  even, odd = odd, even + 1\n  even,\
    \ odd = odd, even + 1\n  even, odd = odd, even + 1\n  even, odd = odd, even +\
    \ 1\n  even, odd = odd, even + 1\n  even, odd = odd, even + 1\n  even, odd = odd,\
    \ even + 1\n  even, odd = odd, even + 1\n  even, odd = odd, even + 1\n  even,\
    \ odd = odd, even + 1\n  even, odd = odd, even + 1\n  even, odd = odd, even +\
    \ 1\n  even, odd = odd, even + 1\n  even, odd = odd, even + 1\n  even, odd = odd,\
    \ even + 1\n  even, odd = odd, even + 1\n  even, odd = odd, even + 1\n  even,\
    \ odd = odd, even + 1\n  even, odd = odd, even + 1\n  even, odd = odd, even +\
    \ 1\n  even, odd = odd, even + 1\n  even, ", "  even, odd = lst.partition { |x|\
    \ x % 2 == 1 }\n  even.zip(odd).reduce(:+) # or even.inject(:+), but reduce is\
    \ more efficient\nend", "  lst.map{|e| e if e % 2 == 1}.inject(:+)\nend\n</code>\n\
    This works because in Ruby, arrays are enumerators. A method is \"called\" on\
    \ an enumerator object when it is called on the object. So lst.map{|e| e if e\
    \ % 2 == 1} is an enumerator that will map over the list lst, adding every element\
    \ to an array, if the element is even. Then, that array is injected into the sum\
    \ method on the enumerator, and that sum is returned.\n<|/ a |>\n<| c |>\nThis\
    \ answer is wrong and misleading. `lst.map{|e| e if e % 2 == 1}.inject(:+)` is\
    \ an enumerator that produces a sum, but the result is never used. Instead, `lst.map{|e|\
    \ e if e % 2 == 1}.inject(0, :+) would produce the same result.\n<|/ c |>\n<|\
    \ c |>\nThank you for correcting the answer. It does seem to work the way I describe\
    \ it in this answer, though I admit I did misunderstand how this worked when I\
    \ posted it.\n<|/ c |>\n<| a dscore=3 |>\nYou can use a combination of map and\
    \ inject methods:\n<code>", "  sum = 0\n  for i in lst[0...-1]\n    if i % 2 !=\
    \ 0\n      sum += i\n  sum + lst[-1]\nend", "    even = []\n    odd = []\n   \
    \ even.push lst[0]\n    odd.push lst[1]", "  even = []\n  odd = []\n  even.concat(lst[1..-1])\
    \ if lst.size > 0 else even.concat(lst)\n  even.each_with_index do |e, i|\n  \
    \  if i % 2 != 0\n      even.push(e)\n    else\n      odd.push(e)\n    end\n \
    \ end\n  even + odd # or even - odd\nend\n</code>\nThe trick is to use the modulo\
    \ operator (%) to see if the element is an odd or even index before adding it.\n\
    <|/ a dscore=1 tags=ruby,arrays,function,add |>\n<| a tags=ruby,arrays,function,add\
    \ |>\n<code>", "  lst.inject {|s, e| s + e if s % 2 != 0 && e % 2 != 0}\nend",
  "  even = 0\n  odd = 1", "  return lst.inject(0) do |sum, e|\n    sum + e if e.even?\n\
    \  end\nend", "  return lst.select{ |i| i.odd? }.inject(:+) end\nend", "  evens\
    \ = 0\n  odds = 0\n  for i in lst\n    if (i % 2) == 0\n      evens += i\n   \
    \   odds += 1\n    end\n  end\n  evens << odds * 2\n  evens.join\nend", "  even_index\
    \ = lst.each_with_index.select { |el, i| i % 2 == 0 }\n  result = even_index.map\
    \ { |i| lst[i] }.reduce(:+)\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays,ruby-on-rails,function\
    \ |>\nAnother way to do it:\n<code>", "  i = 0\n  evens = 0\n  while i < lst.size\n\
    \    if i % 2 == 1\n      evens << lst[i]\n    end\n    i += 1\n  end\n  evens\n\
    end", "    even = nil\n    odd = nil\n    even = lst[0]\n    odd = lst[1]\n  \
    \  lst[2] + lst[3]\n    return even, odd\nend", "  return 0 unless lst\n  even\
    \ = nil\n  odd  = nil\n  for i in lst.each_index { |index| even += lst[index]\
    \ if index.odd? } \n  for i in lst.each_index { |index| odd  += lst[index] if\
    \ index.even? }\n  even + odd\nend\n</cell>\n<code language=conda-env-CourseraMLAndrewNgmyNoteEnv-py>",
  "  lst.each_with_index do |e, i|\n    if i % 2 == 0\n      lst.delete_at(i)\n  \
    \  else\n      lst.insert i, e\n    end\n  end\n  lst\nend", "  return lst.inject(0)\
    \ { |sum, e| sum + e if e % 2 == 1 }\nend", "  even_index = lst.each.with_index(1)\
    \ { |e, i| i % 2 == 0 }\n  even_index.inject(0, :+)\nend\n</code></pre>", "  if\
    \ lst.size == 0\n    return 0\n  end", "    even_indexes = []\n    \n    even_indexes\
    \ << lst.each_with_index.select { |_, i| i % 2 == 0 }.map{ |_, i| i }\n    \n\
    \    even_indexes.flatten!", "  lst.each_index { |i| lst[i] += lst[i % 2]}\n \
    \ lst\nend", "  sum = 0\n  for i in (0..(lst.size - 1))\n    if lst[i] % 2 ==\
    \ 0\n      sum += lst[i]\n    end\n  end\n  return sum\nend", "  lst.each_with_index\
    \ do |num, index|\n    even = num % 2 == 0\n    odd =  index % 2 == 1\n    if\
    \ even && odd\n      lst.delete_at(index) # removes both evens and odds\n    end\n\
    \  end\n  lst.size\nend", "  even = []\n  odd = []\n  for i in 0..(lst.length-1)\n\
    \    if lst[i] % 2 == 0\n      even.push lst[i]\n    else\n      odd.push lst[i]\n\
    \    end\n  end\n  return even.sum odd.sum\nend", "  result = 0\n  index = 1\n\
    \  for i in lst\n    if index % 2 == 1\n      result += i\n    index += 1\n  return\
    \ result\nend", "  even = lst.select {|i| i%2 == 0}\n  even.inject(0) {|sum, e|\
    \ sum + e}\nend", "    even = lst.map { |x| x % 2 }\n    odd = lst.map { |x| x\
    \ % 2 != 0 }\n    even + odd\nend\n</code>\nNow let's get back to your original\
    \ question about how to improve the time complexity.\nYour current solution is\
    \ O(N^2) because you're iterating over every element in the list N times. A better\
    \ solution would be to iterate over the list only once, collecting all odds or\
    \ even items and then iterating over this collection only once. Here's how it\
    \ works.\nLet's rewrite the add method a little bit to get rid of extra variables:\n\
    <code>", "  even = []\n  odd = []\n  for num in lst\n    if num % 2 == 0\n   \
    \   even << num\n    else\n      odd << num\n    end\n  end\n  even.merge(odd).inject(:+)\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a dscore=0 tags=ruby |>\n<code>",
  "    evens = lst.select { |x| x % 2 == 0 }\n    evens.inject(0) do |sum, elem|\n\
    \        sum + elem\n    end\nend", "  return sum((lst[2..-1] % 2) == 0 ? lst\
    \ : add(lst[1..-1]))\nend", "  lst.each do |x|\n    if x % 2 == 0\n      x +=\
    \ lst[x % lst.length]\n    end\n  end\n  lst\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nYour code does not return the same results as the question asked.\n<|/\
    \ c |>\n<| c |>\nYou are correct, fixed it now\n<|/ c |>\n<| a dscore=0 tags=ruby,algorithm\
    \ |>\n<code>", "  return lst.select{|x| x % 2 == 0}.inject(:+)\nend", "  sum =\
    \ 0\n  for i in lst.each_index do sum += lst[i]; end\n  sum\nend", "  lst.each_with_index\
    \ do |n,i| \n    if (i % 2 == 0)\n      lst[i] = n\n    end \n  end\n  lst.find\
    \ {|x| x > 0 }\nend", "  even_indexes = lst.select{|x| x % 2 == 0} # find elements\
    \ at even indexes\n  even_indexes.inject(0) { |sum, el| sum + el} # sum them\n\
    end", "  i = 0\n  sum = 0\n  while (i < lst.size)\n    if (lst[i] % 2 == 0)\n\
    \      sum += lst[i]\n    i += 1\n  end\n  sum\nend", "  even = []\n  odd = []",
  "    even = []\n    odd  = []\n    even.concat lst.select{|x| x % 2 == 0}\n    odd.concat\
    \ lst.select{|x| x % 2 == 1}\n    even.inject(0){|x,y| x+y}\n    odd.inject(0){|x,y|\
    \ x+y}\nend\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| a tags=ruby |>\nJust another\
    \ variation of how to find the even and odd elements of a list:\n<code>", "  even_odd=\
    \ []\n  even_even= []\n  for i in lst\n    if i.odd?\n      even_odd.push(i)\n\
    \    else \n      even_even.push(i)\n  end\n  even_odd.reduce(:+)\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby |>\n<| c |>\nIt's not good practice to just dump a bunch\
    \ of code on us. Explain what is going on, or at least include comments within\
    \ the code\n<|/ c |>\n<| a tags=ruby dscore=0 |>\nHere is my solution to finding\
    \ the sum of even numbers in an array:\n<code>", "  return lst.inject(0) { |sum,\
    \ el| sum + el if el % 2 == 1 }\nend\n</code>\nNow we can write our own version\
    \ of each which takes two integers and returns a list containing both of them:\n\
    <code>", "    even = []\n    for i in 0..(lst.size % 2)\n        even << lst[i]\n\
    \    lst.reject! {|x| even % x == 0}\nend\n</cell>\n<cell>", "  lst.map { |x|\
    \ x + x[1..-1].to_i }.reduce(:+)\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n`lst.map\
    \ {|x| x + x[1..-1].to_i}.reduce(:+)`\n<|/ c |>\n<| c |>\nThat's a very clever\
    \ solution, thank you! I used the other solution because I thought that would\
    \ be easier to understand than the map and reduce approach.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ dscore=1 |>\n<code>", "  lst.each_with_index do |e, i|\n    next if i % 2 ==\
    \ 0\n    lst[i] = e + lst[i - 1]\n  end\n  lst\nend", "  even_indices = lst.each_with_index\
    \ { |i, x| x % 2 == 0 }\n  even_indices.reduce(0) { |a, b| a + b}\nend", "  sum\
    \ = 0\n  index = 0\n  while index < lst.size\n    sum = sum + lst[index]\n   \
    \ index = index + 1\n  end\n  return sum\nend", "  evens = lst.take_while { |x|\
    \ x % 2 == 0 }\n  odds = lst.drop(evens.count)\n  evens + odds\nend", "  even\
    \ = 0\n  odd = 1\n  even = even.concat(lst[even])\n  odd = odd.concat(lst[odd])\n\
    \  even.concat(even)\n  odd.concat(odd)\nend", "  lst.each do |x|\n    lst.index(x)\
    \ % 2 == 0 ?\n    lst.pop + x : lst.pop\n  end\nend\n</code>\n<|/ a dscore=0 tags=ruby\
    \ |>\n<| c |>\n`lst.index(x) % 2 == 0` is an anti-pattern. The index method can\
    \ take a block, which is preferable. `lst.find { |x| x % 2 == 0 }` is the way\
    \ to go.\n<|/ c |>\n<| c |>\n`lst.find { |x| x % 2 == 0 }` is not equivalent to\
    \ the original code where `x` is mutated.\n<|/ c |>\n<| a tags=ruby |>\n<code>",
  "  lst.select { |i| i%2 == 0 }.inject(:+)\nend", "    even, odd = 0, 0\n    list.each\
    \ do |i|\n        if i % 2 == 0\n            even = even+i\n        else\n   \
    \         odd = odd+i\n        end\n    end\n    even\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis answer has a very interesting way of finding the sum of even\
    \ and odd numbers without having to loop through all the elements. This is much\
    \ more efficient than looping through the whole array. Thank you for the answer.\
    \ Also thanks to everyone who responded.\n<|/ c |>\n<| a tags=ruby dscore=1 |>\n\
    <code>\narr = [2, 3, 4, 5]", "  if lst.empty?\n    []\n  elsif lst.size == 1\n\
    \    [lst[0]].flatten\n  else\n    even = lst.select { |i| i.odd? }\n    odd =\
    \ lst.select { |i| i.even? }\n    (even.flatten + odd.flatten).uniq\n  end\nend",
  "  lst.inject{ |sum, value| sum + value }\nend", "  even = (0...lst.size-2).select\
    \ { |i| i % 2 == 0 }\n  lst.zip(even).inject(0) {|sum, a| sum + a[0] }\nend\n\
    </code>\n<|/ a |>\n<| c |>\nI like the use of inject here.\n<|/ c |>\n<| a tags=arrays,ruby\
    \ |>\nRuby 2.7.0 introduced zip method on Enumerable class, so you can do:\n<code>\n\
    arr.zip.with_index.select {|x, i| i.odd?}\n</code>\n<|/ a dscore=5 |>\n<| a tags=arrays,ruby\
    \ dscore=4 |>\n<code>\narr = [1,2,3,4,5]\neven = arr.select {|x| x % 2 == 0}\n\
    odd = arr.select {|x| x % 2 != 0}\n</code>\n<|/ a |>\n<| a tags=arrays,ruby dscore=3\
    \ |>\nUsing Enumerable#zip:\n<code>\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", " \
    \   evens=[]\n    odds=[]\n    for e in lst\n        if e.odd?\n            odds\
    \ << e\n        else\n            evens << e\n        end\n    end\n    evens.concat(odds)\n\
    \    return evens\nend\n</code>\nOr you can use the map method:\n<code>", "  \
    \  even = []\n    odd= []\n    i=0\n    while i < lst.length\n        if lst[i]\
    \ % 2 == 0\n            even << lst[i]\n        else\n            odd << lst[i]\n\
    \        end\n        i += 1\n    end\n    even.length == odd.length\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nOh man! You guys are very smart! Thanks so much for\
    \ taking your time and helping me. Your answers are so much appreciated!\n<|/\
    \ c |>\n<| c |>\nI added an answer, can you please check if it works for you?\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails |>\nI think this will help you - \n<code>",
  "  odd_index = lst.index(lst[odd_index])\n  even_index = lst.index(lst[even_index])\n\
    \  \n  even = lst[even_index]\n  odd = lst[odd_index]\n  \n  lst[even_index] =\
    \ even + odd\n  \n  lst[odd_index] = even - odd\n  \n  return lst\nend", "  evens\
    \ = lst.select { |e| e % 2 == 0 }\n  evens.reduce(:+).to_i\nend\n</cell>\n<text>\n\
    Problem 5\nWhat is the sum of the numbers in the array below?", "  return lst.inject(:+)\
    \ unless lst.empty?\n  0\nend", "  lst.reduce(:+)\nend\n</cell>\n<code language=julia-0.5>",
  "    even = []\n    odd = []\n    for i in lst\n        if i % 2 == 0\n        \
    \    even += [i]\n        else\n            odd += [i]\n    return even + odd\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI like the `map` and `reduce` approach, but I\
    \ don't like using list comprehension when the method name `add` indicates they\
    \ are working with lists -- especially when they have side-effects (`+=`).\n<|/\
    \ c |>\n<| c |>\nGood point, although I'm not familiar with map or reduce and\
    \ my first thought was map & reduce. I'll try them out to see how they work (if\
    \ they work at all)\n<|/ c |>\n<| c |>\n, `map` and `reduce` are great tools.\
    \ When you come across one of them, you're going to be happy you knew how to use\
    \ it (they don't *have* to be, but they should be!). Here's a [good example](http://stackoverflow.com/q/3277367/1269503).\n\
    <|/ c |>\n<| c |>\nThanks Kirk. I thought map & reduce would be better here, but\
    \ I couldn't wrap my head around it.\n<|/ c |>\n<| a dscore=2 |>\nHere is another\
    \ one, using inject:\n<code>", "  even = lst.find{ |x| x % 2 == 0 }\n  odd = lst.find_index{\
    \ |x| x % 2 == 1 }\n  even.nil? ? 0 : even.last + 1 + odd.last\nend", "  lst.each_with_index\
    \ do |x, i|\n    if i % 2 == 0 then\n      lst.push(x)\n    end\n  end\n  lst\n\
    end", "    sum = 0\n    i = 0\n    while i < lst.size\n        if i % 2 == 0\n\
    \            sum += lst[i]\n            i += 1\n        end\n    end\n    return\
    \ sum\nend", "    evens = 0..(lst.length - 1).select { |i| lst[i] % 2 == 0 }\n\
    \    return evens.reduce(:+)\nend", "  even = [lst[0], lst[1..-1].sum]\n  return\
    \ even\nend", "  even = 1\n  odd = 1\n  lst.each_with_index do |e, i|\n    odd\
    \ += e if i & 1 == 1\n    even += e if i & 1 == 0\n  end\n  even + odd\nend",
  "  # TODO: Write your code here.\nend", "  return lst.inject(0) { |result, e| result\
    \ + (e % 2 == 0 ? e : 0) }\nend", "    count = 0\n    even = 0\n    odd = 0\n\
    \    if lst.length == 0 or lst.length < 2\n        return lst\n    \n    even\
    \ = lst.pop\n    odd = lst.pop", "  if lst.count > 0 \n    sum = 0\n    i = lst.index(0)\n\
    \    while (i < lst.count).even?\n      sum+=lst[i]\n      i+=1\n    return sum\n\
    \  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`lst.index(0) ` returns `nil`\
    \ if the given list has no `0` in the first position.\n<|/ c |>\n<| c |>\nThank\
    \ you, I've updated my answer with something that actually works!\n<|/ c |>\n\
    <| a |>\nI think this will do it:\n<code>", "  even = lst.select { |x| x % 2 ==\
    \ 0 }\n  odd = lst.select { |x| x % 2 == 1 }\n  even.inject(0) { |t, x| t + x\
    \ }\nend", "    sum = 0\n    i = 0\n    while i < lst.length\n        sum += lst[i]\n\
    \        if i % 2 == 0\n            sum += 1\n        i += 1\n    \n    return\
    \ sum\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
