name: HumanEval_17_parse_music
language: rb
prompt: "# Input to this function is a string representing musical notes in a special\
  \ ASCII format.\n# Your task is to parse this string and return list of integers\
  \ corresponding to how many beats does each\n# not last.\n# Here is a legend:\n\
  # 'o' - whole note, lasts four beats\n# 'o|' - half note, lasts two beats\n# '.|'\
  \ - quater note, lasts one beat\n# >>> parse_music('o o| .| o| o| .| .| .| .| o\
  \ o')\n# [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\ndef parse_music(music_string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_music\n\
  \    candidate = method(:parse_music)\n    assert_equal([], candidate.call(\"\"\
  ))\n    assert_equal([4, 4, 4, 4], candidate.call(\"o o o o\"))\n    assert_equal([1,\
  \ 1, 1, 1], candidate.call(\".| .| .| .|\"))\n    assert_equal([2, 2, 1, 1, 4, 4,\
  \ 4, 4], candidate.call(\"o| o| .| .| o o o o\"))\n    assert_equal([2, 1, 2, 1,\
  \ 4, 2, 4, 2], candidate.call(\"o| .| o| .| o o| o o|\"))\n  end\nend\n"
completions: ["  music_string = music_string.split(' ')\n  notes = []\n  current_note\
    \ = 'O'\n  current_beat = 1\n  last_note = 'O'\n  last_beat = 1\n  while music_string.length\
    \ > 0\n    if music_string[0] == 'o'\n      notes.push(current_beat)\n      music_string\
    \ = music_string[1..-1]\n      last_note = 'O'\n      last_beat = 1\n      current_note\
    \ = 'O'\n      current_beat = 1\n    elsif music_string[0] == 'o|'\n      notes.push(current_beat)\n\
    \      music_string = music_string[1..-1]\n      last_note = 'O'\n      last_beat\
    \ = 1\n      current_note = 'O'\n      current_beat = 2\n    elsif music_string[0]\
    \ == '.|'\n      notes.push(current_beat)\n      music_string = music_string[1..-1]\n\
    \      last_note = 'O'\n      last_beat = 1\n      current_note = 'O'\n      current_beat\
    \ = 1\n    else\n      music_string = music_string[1..-1]\n    end\n  end\n  notes.push(current_beat)\n\
    \  notes.push(last_beat)\n  return notes\nend", "  # TODO: implement this function\n\
    end\n</code>\n<|/ a tags=string,arrays,ruby,loops |>\n<| c |>\nI tested the code\
    \ on ideone.com, however it seems that it does not split the input string into\
    \ its different notes. I think something is missing in that code? Did you test\
    \ it?\n<|/ c |>\n<| c |>\nI tested it on ideone and it is working.\n<|/ c |>\n\
    <| c |>\nOh ok, i must have made a mistake earlier when i tried running it on\
    \ ideone. Thanks!\n<|/ c |>\n<| a |>\nYou can implement this using the Array#find\
    \ method. This method will return the location of the first element which matches\
    \ the given block, or nil if no match is found.\n<code>\nnotes = [\"C\", \"C#\"\
    , \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]",
  "  # Your code here!\n  music_list = music_string.split(' ')\n  music_list.each{|note|\
    \ note = note.gsub('|', 'o')}\n  music_list.each{|note| note = note.gsub('o',\
    \ 'o|')}\n  music_list.each{|note| note = note.gsub('.', '|')}\n  music_list.each{|note|\
    \ note = note.gsub('o|', 'o')}\n  music_list.each{|note| note = note.gsub('o|',\
    \ 'o|')}\n  music_list.each{|note| note = note.gsub('|', 'o')}\n  music_list.each{|note|\
    \ note = note.gsub('o|', 'o|')}\n  music_list.each{|note| note = note.gsub('.',\
    \ '|')}\n  music_list.each{|note| note = note.gsub('|', 'o')}\n  music_list.each{|note|\
    \ note = note.gsub('.', '|')}\n  music_list.each{|note| note = note.gsub('o|',\
    \ 'o')}\n  music_list.each{|note| note = note.gsub('o', 'o|')}\n  music_list.each{|note|\
    \ note = note.gsub('o|', 'o|')}\n  music_list.each{|note| note = note.gsub('|',\
    \ 'o')}\n  music_list.each{|note| note = note.gsub('o|', 'o|')}\n  music_list.each{|note|\
    \ note = note.gsub('.', '|')}\n  music_list.each{|note| note = note.gsub('|',\
    \ 'o')}\n  music_list.each{|note| note = note.gsub('.', '|')}\n  music_list.each{|note|\
    \ note = note.gsub('o|', 'o')}\n  music_list.each{|note| note = note.gsub('o',\
    \ 'o|')}\n  music_list.each{|note| note = note.gsub('o|', 'o|')}\n  music_list.each{|note|\
    \ note = note.gsub('|', 'o')}\n  music_list.each{|note| note = note.gsub('.',\
    \ '|')}\n  music_list.", "    notes = music_string.split(\" \")\n    beats = []\n\
    \    \n    beats_per_note = 4\n    \n    for note in notes:\n        if \"o|\"\
    \ in note:\n            note = note.split(\"|\")[0]\n            beats_per_note\
    \ = 2\n        elif \".|\" in note:\n            note = note.split(\"|\")[0]\n\
    \            beats_per_note = 1\n        else:\n            beats_per_note = 4\n\
    \            \n        note = note.lower()\n        \n        if note == 'o':\n\
    \            beats.append(4)\n        elif note == 'b':\n            beats.append(2)\n\
    \        elif note == 'g':\n            beats.append(1)\n        else:\n     \
    \       beats.append(4)\n    \n    return beats", "  return music_string.scan(/o|\\\
    .\\|o|o|\\.\\|o|\\.\\|o|\\.\\|o|\\.\\|o|o/).map { |note| note.split('|').map(&:to_i)\
    \ }\nend\n</cell>\n<cell>\nmusic_string = \"o o| .| o| o| .| .| .| .| .| o o\"\
    \nmusic_string.scan(/o|\\.\\|o|o|\\.\\|o|\\.\\|o|\\.\\|o|\\.\\|o|\\.\\|o/)\n</cell>\n\
    <cell>\nmusic_string.scan(/o|\\.\\|o|o|\\.\\|o|\\.\\|o|\\.\\|o|\\.\\|o|\\.\\|o/).map\
    \ { |note| note.split('|').map(&:to_i) }\n</cell>\n<text>\nGiven music string,\
    \ count how many pieces of each length exist.", "  music_array = music_string.split(\"\
    \ | \")\n  music_array.each do |note|\n    # Add 'o' for whole note\n    music_array[0]\
    \ << note\n    music_array[0] << note\n    # Add 'o|' for half note\n    music_array[1]\
    \ << note\n    music_array[1] << note\n    # Add '.|' for quater note\n    music_array[2]\
    \ << note\n    music_array[2] << note\n  end\n  music_array.reduce(0) { |acc,\
    \ note| acc + note_len(note) }\nend", "  notes = music_string.split(' ')\n  beats\
    \ = []\n  last_beat = 0", "  music_string.gsub(/[^0-9A-Za-z_]/, '') # remove all\
    \ non-alphanumeric characters\n  music_string.gsub(/[^\\.]/, '') # remove all\
    \ non-periods\n  music_string.gsub(/[\\.]{2,}/, '|') # remove any consecutive\
    \ periods\n  music_string.gsub(/[\\|]{2,}/, '|') # remove any consecutive bars\n\
    \  music_string.gsub(/[^|]/, '') # remove any non-bars\n  music_string.gsub(/[\\\
    |]/, '|') # replace any | with bar\n  music_string.split('|') # split the bars\
    \ into separate elements\n  music_string.split('|').map { |bar| bar =~ /^(.{1})$/\
    \ ? bar.size : 0}\nend\n</code>\n<|/ a tags=ruby,regex dscore=2 |>\n<| c |>\n\
    Thanks, this is what I was looking for.\n<|/ c |>\n<| c |>\nI like that you showed\
    \ me the method `split`. Thanks for that too.\n<|/ c |>\n<| c |>\n, you're welcome!\
    \ But if your goal is to learn regular expressions, I suggest you go through a\
    \ book like [Mastering Regular Expressions](http://shop.oreilly.com/product/9780596529260.do).\
    \ It's a great resource.\n<|/ c |>\n<| c |>\n: I just realized that your original\
    \ solution, `music_string.gsub(/[^0-9A-Za-z_]/, '')`, doesn't actually work. If\
    \ you try it with `music_string = 'o.o.o|.|o.o|o.o.o|.|.|.|.|o.o'` you'll see\
    \ that it returns `[7, 4, 4, 5, 5, 6, 7, 7, 7, 7, 7]`, which doesn't match your\
    \ output.\n<|/ c |>\n<| c |>\nYes, I see that, I think the OP's original code\
    \ was incomplete and wasn't quite doing what he thought it was. Thanks for the\
    \ correction.\n<|/ c |>\n<| a |>\nThe key to writing a regexp that will match\
    \ this string is understanding what that string is.\nThe string consists of characters\
    \ followed by a dash.  A dash indicates a repeating element.  An element in this\
    \ string is a single character that can repeat any number of times.  So the string\
    \ \"o\" is a single character, and that character can be repeated.  \nThe dash\
    \ can be escaped by placing it inside a character class (square brackets).  So\
    \ the string \"o.o\" is a ", "    music_string.strip!\n    music_notes = music_string.split(//).map\
    \ { |s| s.downcase }", "  music_array = music_string.split(//)\n  music_array.each\
    \ do |item|\n    note, beats = item.split(//)\n    if note == 'o'\n      music_array.pop\n\
    \    elsif note == 'o|'\n      music_array.pop\n      music_array.push beat_count(note)\
    \ * 4\n    elsif note == '.|'\n      music_array.pop\n      music_array.push beat_count(note)\n\
    \    end\n  end\n  music_array\nend", "  music_string = music_string.strip\n \
    \ music_string = music_string.sub(/[\\.\\|o]$/, '')\n  music_string = (music_string\
    \ + '|').sub(/[\\.\\|o]\\|$/, '') \n  music_string = (music_string + '|').sub(/[\\\
    |\\.\\|o]$/, '')\n  music_string = (music_string + '|').sub(/[\\.\\|o]\\|$/, '')\n\
    \  music_string = (music_string + '|').sub(/[\\|\\.\\|o]\\|$/, '')\n  music_string\
    \ = (music_string + '|').sub(/[\\|\\.\\|o]\\|$/, '')\n  music_string = (music_string\
    \ + '|').sub(/[\\.\\|o]\\|$/, '')\n  music_string = (music_string + '|').sub(/[\\\
    .\\|o]\\|$/, '')\n  music_string = (music_string + '|').sub(/[\\.\\|o]\\|$/, '')\n\
    \  music_string = (music_string + '|').sub(/[\\.\\|o]\\|$/, '')\n  music_string\
    \ = (music_string + '|').sub(/[\\.\\|o]\\|$/, '')\n  music_string = (music_string\
    \ + '|').sub(/[\\.\\|o]\\|$/, '')\n  music_string = (music_string + '|').sub(/[\\\
    .\\|o]\\|$/, '')\n  music_string = (music_string + '|').sub(/[\\.\\|o]\\|$/, '')\n\
    \  music_string = (music_string + '|').sub(/[\\.\\|o]\\|$/, '')\n  music_string\
    \ = (music_string + '|').sub(/[\\.\\|o]\\|$/, '')\n  music_string = (music_string\
    \ + '|').sub(/[\\.\\|o]\\|$/, '')\n  music_string = (music_string + '|').sub(/[\\\
    .\\|o]\\|$/, '')\n  music_string = (music_string + '|').sub(/[\\.\\|o]\\|$/, '')\n\
    \  music_string = (music_string + '|').sub(/[\\.\\|o]\\|$/, '')\n  music_string\
    \ = (music_string + '|').sub(/[\\.\\|o]\\|$/, '')\n  music_", "  music_string\
    \ = music_string.split(' ')\n  beats_array = [0]*12\n  current_beat = 0\n  current_key\
    \ = None\n  for note in music_string:\n    if note[0] == '.':\n      beats_array[current_beat\
    \ + 1] = beats_array[current_beat] + 1 if current_key != 'o' else '0'\n      current_key\
    \ = note\n      current_beat += 1\n    elif note[0] == 'o':\n      if current_key\
    \ != 'o':\n        beats_array[current_beat + 1] = beats_array[current_beat] +\
    \ 1 if current_key != 'o' else '0'\n        current_key = note\n      else:\n\
    \        current_key = note\n    elif note[0] == '|':\n      if current_key !=\
    \ 'o':\n        beats_array[current_beat + 1] = beats_array[current_beat] + 1\
    \ if current_key != 'o' else '0'\n        current_key = note\n      else:\n  \
    \      current_key = note\n    else:\n      beats_array[current_beat + 1] = beats_array[current_beat]\
    \ + 1 if current_key != 'o' else '0'\n      current_key = note\n      current_beat\
    \ += 1\n  beats_array.append(beats_array[current_beat])\n  beats_array.reverse()\n\
    \  return beats_array", "  music_string.scan(/[\\.\\|]/).each do |n|\n    n.count(\"\
    |\") + n.count(\"o\")\n  end\nend", "  music_string = music_string.split(//).map\
    \ do |note|\n    note.gsub(/[\\[\\(]|\\[)(\\]\\)]/, '')\n  end", "  music_array\
    \ = music_string.split(//)\n  music_array.reject { |elem| elem == \"\" }", " \
    \ music_list = music_string.split(//)\n  beats = []\n  i = 0\n  while i < music_list.length\n\
    \    if i % 4 == 0\n      if music_list[i] != 'o' and music_list[i] != 'o|' and\
    \ music_list[i] != '.|'\n        beats << 4\n      else\n        beats << 2\n\
    \      end\n    elsif i % 4 == 2\n      if music_list[i] != '.|' and music_list[i]\
    \ != 'o|' and music_list[i] != '.|'\n        beats << 1\n      else\n        beats\
    \ << 1\n      end\n    elsif music_list[i] == 'o' or music_list[i] == 'o|' or\
    \ music_list[i] == '.|'\n      beats << 1\n    else\n      beats << 0\n    end\n\
    \    i += 1\n  end\n  beats.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nYep, that was exactly what I needed. Thanks!\n<|/ c |>\n<| c |>\n\
    Good answer. But the question is still unanswered. How does one determine when\
    \ to stop parsing? How does one parse the note and rest? How does one determine\
    \ that it's the last note?\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>",
  "  music_string.split(//).each do |note|\n    if note.index('o')\n      note.rindex('|')\n\
    \    elsif note.index('o|')\n      note.rindex('o|')\n    elsif note.index('.|')\n\
    \      note.rindex('.|')\n    end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nThanks for the response! I'm pretty new to programming, could you please\
    \ explain your answer? I'm pretty confused as to what each line is doing.\n<|/\
    \ c |>\n<| c |>\nSure, line by line. `music_string.split(//)` makes string into\
    \ array by splitting it on every character (spaces, newlines, etc).\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails |>\nI find that using regular expressions makes for\
    \ readable code. \nI came up with a function that will parse an ASCII string into\
    \ an integer array:\n<code>", "    # your code here\n    result = []\n    last_note\
    \ = music_string[0]\n    for note in music_string[1..-1]:\n        if note.eql?(last_note):\n\
    \            result[-1] += 1\n        else:\n            result.append(1)\n  \
    \      last_note = note\n    return result\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks for the answer, but it's not what I need. The first one works fine, but\
    \ not the second one. I'm trying to figure out why.\n<|/ c |>\n<| c |>\nI'm sorry\
    \ I did not get it right at first. Now I updated the answer, please take a look.\n\
    <|/ c |>\n<| c |>\nThanks, it works now. I will review and compare it to my code,\
    \ maybe it will help someone. I'll mark it as an answer after the timer lets me.\n\
    <|/ c |>\n<| c |>\nI checked your code, and now it's really similar to mine. Thanks\
    \ for that.\n<|/ c |>\n<| c |>\nI appreciate that and I hope it can help you :)\n\
    <|/ c |>\n<| a tags=string,ruby,arrays |>\nHere is another one. \nIt looks at\
    \ the first char as the note and the rest as the number of beats.\n<code>", " \
    \ music_string.split(//).inject({}) { |m, c| m[c] = m.fetch(c, 0) + 1 }\nend",
  "  # BEGIN Question 3\n  # Create a string variable called music_notes. In this\
    \ variable you will accumulate all notes that are \n  # not yet parsed. Add spaces\
    \ between notes, otherwise they are recognized as one note.\n  # The notes are\
    \ separated by spaces.\n  # For example: 'o o' is a musical note consisting of\
    \ two octaves and therefore should \n  # be represented as 'o o'.\n  music_notes\
    \ = ''\n  # BEGIN Question 4\n  # This music_notes variable will keep track of\
    \ the notes that are not yet parsed. \n  # Loop over music_string variable and\
    \ add an index for each space to music_notes.\n  # When you reach a space, you\
    \ know you found a musical note and can parse it.\n  # When you reach a non-space,\
    \ you know you found a musical note and can not parse it.\n  # If music_notes\
    \ variable has more than one element you can assume that there is a non-space\
    \ \n  # between a note and another note, thus the note can not be parsed as a\
    \ regular note.\n  music_notes = ''\n  # BEGIN Question 5\n  # Loop over music_string\
    \ variable and add an index for each space to music_notes.\n  # When you reach\
    \ a space, you know you found a musical note and can parse it.\n  # When you reach\
    \ a non-space, you know you found a musical note and can not parse it.\n  # If\
    \ music_notes variable has more than one element you can assume that there is\
    \ a non-space \n  # between a note and another note, thus the note can not be\
    \ parsed as a regular note.\n  music_notes = ''\n  for i in music_string:\n  \
    \  if i is ' ':\n      music_notes = music_notes + music_notes\n    else:\n  \
    \    music_notes = music_notes + music_notes\n  return music_notes\n  # END Question\
    \ 3\n</cell>\n<cell>", "  # Your code here\nend\n</cell>\n<cell>", "    # Write\
    \ your code here\n    music_string[Music.MUSIC_STRING_SIZE-1] = ''\n    music_string\
    \ = music_string.split(Music.MUSIC_STRING_SEPARATOR)\n    music_string.reverse()\n\
    \    notes_int = []\n    for i in music_string:\n        if i == Music.BLANK:\n\
    \            notes_int.append(0)\n        else:\n            notes_int.append(1)\n\
    \    notes_int.reverse()\n    return notes_int\n</cell>\n<cell>", "  music_string.each_char.with_index\
    \ do |char, index|\n    if char == ' ' then\n      music_string[index] = '|'\n\
    \    else\n      music_string[index] = 'o'\n    end\n  end\n  music_string.each_char.with_index\
    \ do |char, index|\n    if char == '|' then\n      music_string[index] = 'o'\n\
    \    end\n  end\n  music_string.each_char.with_index do |char, index|\n    if\
    \ char == ' ' then\n      music_string[index] = ' '\n    end\n  end\n  music_string.each_char.with_index\
    \ do |char, index|\n    if char == 'o' then\n      music_string[index] = '|o'\n\
    \    end\n  end\n  music_string.each_char.with_index do |char, index|\n    if\
    \ char == '|' then\n      music_string[index] = '|o'\n    end\n  end\n  music_string.each_char.with_index\
    \ do |char, index|\n    if char == ' ' then\n      music_string[index] = ' '\n\
    \    end\n  end\n  music_string.each_char.with_index do |char, index|\n    if\
    \ char == '|' then\n      music_string[index] = 'o|'\n    end\n  end\n  music_string.each_char.with_index\
    \ do |char, index|\n    if char == ' ' then\n      music_string[index] = ' '\n\
    \    end\n  end\n  music_string.each_char.with_index do |char, index|\n    if\
    \ char == 'o|' then\n      music_string[index] = 'o'\n    end\n  end\n  music_string.each_char.with_index\
    \ do |char, index|\n    if char == ' ' then\n      music_string[index] = ' '\n\
    \    end\n  end\n  music_string.each_char.with_index do |char, index|\n    if\
    \ char == 'o' then\n      music_string[index] = 'o|o'\n    end\n  end\n  music_string.each_char.with_index\
    \ do |char, index|\n    if char == ' ' then\n      music_string[index] = ' '\n\
    \    end\n  end\n  music_string.each_char.with_index do |char, index|\n    if\
    \ char == '|' then\n      music_string[index] = '|o|o'\n    end\n  end\n  music_string.each_char.with_index\
    \ do |char, index|\n    if char == ' ' then\n      music_string[index] = ' '\n\
    \    end\n  end\n  music_string.each_char.with_index", '    notes_hash = {}',
  "  music_string = music_string.downcase\n  music_string.gsub!('|', 'o')\n  music_string.gsub!('o|',\
    \ 'o')\n  music_string.gsub!('\\.\\|', 'o')\n  music_string.gsub!('o\\.', 'o')\n\
    \  music_string.gsub!('\\.', '|')\n  music_string.gsub!('o', 'o|')\n  music_string.gsub!('|',\
    \ '.')\n  music_string.gsub!('o|', 'o|')\n  music_string.gsub!('\\.', '\\.|')\n\
    \  music_string.gsub!('o\\.', 'o\\.')\n  music_string.gsub!('\\.', '\\.')\n  music_string.gsub!('o',\
    \ 'o|')\n  music_string.gsub!('|', '|')\n  music_string.gsub!('o|', 'o|')\n  music_string.gsub!('\\\
    .', '\\.|')\n  music_string.gsub!('o\\.', 'o\\.')\n  music_string.gsub!('\\.',\
    \ '\\.')\n  music_string.gsub!('o', 'o|')\n  music_string.gsub!('|', '|')\n  music_string.gsub!('o|',\
    \ 'o|')\n  music_string.gsub!('\\.', '\\.|')\n  music_string.gsub!('o\\.', 'o\\\
    .')\n  music_string.gsub!('\\.', '\\.')\n  music_string.gsub!('o', 'o|')\n  music_string.gsub!('|',\
    \ '|')\n  music_string.gsub!('o|', 'o|')\n  music_string.gsub!('\\.', '\\.|')\n\
    \  music_string.gsub!('o\\.', 'o\\.')\n  music_string.gsub!('\\.', '\\.')\n  music_string.gsub!('o',\
    \ 'o|')\n  music_string.gsub!('|', '|')\n  music_string.gsub!('o|', 'o|')\n  music_string.gsub!('\\\
    .', '\\.|')\n  music_string.gsub!('o\\.', 'o\\.')\n  music_string.gsub!('\\.',\
    \ '\\.')\n  music_string.gsub!('o', 'o|')\n", "  music_string = music_string.gsub(/o|o\\\
    |/, '').gsub(/\\./, '')", "  # TODO: your code here\nend", "  music_string.split(\"\
    \ \").map do |note|\n    note = note.strip\n    case note\n    when \".|\" then\
    \ 1\n    when \"o|\" then 2\n    when \"o\" then 4\n    else 0\n    end\n  end\n\
    end\n</code>\n<|/ a dscore=3 tags=regex,ruby |>\n<| a tags=regex,ruby |>\nYou\
    \ can try this one:\n<code>\nmusic_string = \"o o| .| o| o| .| .| .| .| o o\"\n\
    music_string.gsub(/(?![.|o])([o|.])(?![.|o])/, '\\1')\n</code>\nOutput:\n<code>\n\
    \"4.2.0 2.1.0 1.1.0 1.1.0 1.1.0 1.1.0 4.4.0\"\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nVery nice solution. I was going to suggest the use of split but your look-ahead\
    \ is much more elegant.\n<|/ c |>\n<| a tags=regex,ruby dscore=3 |>\nHow about\
    \ this?\n<code>\nmusic_string.gsub(/(([\\.\\|\\s]|\\s)+)/) { |m| m.gsub(/(.)\\\
    1*/, '\\\\1') }\n</code>\nI tried to explain it in a comment, but it is too hard\
    \ to explain in the comment box.\n<|/ a |>\n<| c |>\nThis is a great solution.\
    \ I ended up using this: `music_string.gsub(/([\\.\\|\\s]|\\s)/) { |m| m.gsub(/(.)\\\
    1*/, '\\\\1') }`\n<|/ c |>\n<| c |>\nI'm glad you figured it out!  I made an edit\
    \ to your answer with the final expression you ended up using.\n<|/ c |>\n<| a\
    \ dscore=2 tags=regex,ruby |>\n<code>\nmusic_string.gsub(/[\\|\\.](?=.*\\1)/,\
    \ '').gsub(/[.\\s]{2,}/, ' ').split(' ').map{ |x| x.to_i }\n</code>\n<|/ a |>\n\
    <| c |>\nThanks for the post. I tried the solution and it does work, although\
    \ it seems a bit long-winded. Would you mind explaining what's going on here a\
    \ bit? I'm a little confused by the \"\\1\" part.\n<|/ c |>\n<| c |>\nFirst part\
    \ is to remove double spaces in between notes. Second part is to remove ", " \
    \   music=music_string.split(' ')\n    beats_per_note={}\n    for note in music:\n\
    \        note=note.strip()\n        if note in ['o','.','|']:\n            if\
    \ note == 'o':\n                note_name = 'whole note'\n                beats_per_note[note_name]\
    \ = 4\n            else:\n                note_name = 'half note'\n          \
    \      beats_per_note[note_name] = 2\n        else:\n            note_name = 'quater\
    \ note'\n            beats_per_note[note_name] = 1\n    note_sequence=[]\n   \
    \ for i in range(int(music.count('o'))):\n        note_sequence.append(i+1)\n\
    \    for i in range(int(music.count('.'))):\n        note_sequence.append(i+4)\n\
    \    for i in range(int(music.count('|'))):\n        note_sequence.append(i+2)\n\
    \    return note_sequence\n</cell>\n<cell>\nprint(parse_music('o o| .| o| o| .|\
    \ .| .| .| o o'))\n</cell>\n<text>\nHere is an example of how you can use this\
    \ function to solve an exercise:", "  parsed_music = music_string.split(\" \"\
    ).map(&:to_i).uniq\n  parsed_music = parsed_music.group_by { |element| element\
    \ }.values.map { |notes| notes.size }\n  parsed_music = parsed_music.sort_by(&:last).reverse\n\
    \  return parsed_music\nend", "    # Your code here\n    return []\n</cell>\n\
    <cell>", "  music_notes = []\n  last_note = nil", "    music_list = music_string.split(\"\
    \ \") # separates notes from rests\n    # returns list of ints\n    return map(lambda\
    \ m: (m[0] == 'o' ? 4 : m[0] == 'o|' ? 2 : m[0] == '.|' ? 1 : 0), music_list)\n\
    end", '  notes = music_string.split(" ")', "  notes = music_string.split(//)\n\
    \  notes.map {|note| note.split(//).map{|c| c.to_i}}.map(&:flatten).reduce(:+)\n\
    end\n</code>\n<|/ a dscore=3 tags=ruby,string |>\n<| c |>\nThis is excellent.\
    \ However it gives me a syntax error on the \"map{|c| c.to_i}}\" line. I've also\
    \ noticed it only returns one \"4\" when I pass in a string with more than one\
    \ \".|\"\n<|/ c |>\n<| c |>\nI've fixed the syntax error and changed it so that\
    \ it now works for more than one \".|\"\n<|/ c |>\n<| c |>\nThis is great. Thank\
    \ you. Do you know how I could modify it so that it returns an array of arrays\
    \ that I can iterate through? I'm a bit confused on how map and reduce work. I've\
    \ added what I currently have as my code above. Thanks again.\n<|/ c |>\n<| c\
    \ |>\nI have edited my answer to include a working example using your code.\n\
    <|/ c |>\n<| c |>\nThank you so much. This is exactly what I was looking for.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's a non-regex solution that is pretty fast:\n\
    <code>", "  music_string.split(\"|\")\nend\n</cell>\n<text>\nTest your function\
    \ on some musical notes:", "  music_string.scan(/[\\.\\|\\-]+/).map { |note| note[0].to_i\
    \ }\nend", "  music_string = \"o\" * music_string.count(\"o\") + \"o\" * music_string.count(\"\
    o\") + \\\n                \"o\" * music_string.count(\"o\") + \"o\" * music_string.count(\"\
    o\") + \\\n                \".\" + \"|\" * music_string.count(\"|\") + \\\n  \
    \              \".\" * music_string.count(\"|\") + \"o\" * music_string.count(\"\
    o\") + \\\n                \"o\" * music_string.count(\"o\") + \"o\" * music_string.count(\"\
    o\") + \\\n                \".\" + \"|\" * music_string.count(\"|\") + \\\n  \
    \              \".\" * music_string.count(\"|\") + \"o\" * music_string.count(\"\
    o\") + \\\n                \"o\" * music_string.count(\"o\") + \"o\" * music_string.count(\"\
    o\") + \\\n                \".\" + \"|\" * music_string.count(\"|\") + \\\n  \
    \              \".\" * music_string.count(\"|\") + \"o\" * music_string.count(\"\
    o\") + \\\n                \"o\" * music_string.count(\"o\") + \"o\" * music_string.count(\"\
    o\") + \\\n                \".\" + \"|\" * music_string.count(\"|\") + \\\n  \
    \              \".\" * music_string.count(\"|\") + \"o\" * music_string.count(\"\
    o\") + \\\n                \"o\" * music_string.count(\"o\") + \"o\" * music_string.count(\"\
    o\") + \\\n                \".\" * music_string.count(\"|\")\n  music_string =\
    \ \"o\" * (music_string.count(\"o\") / 4) + \"o\" * (music_string.count(\"o\"\
    ) / 4) + \\\n                \"o\" * (music_string.count(\"o\") / 4) + \"o\" *\
    \ (music_string.count(\"o\") / 4) + \\\n                \".\" + \"|\" * (music_string.count(\"\
    |\") / 2) + \\\n                \".\" * (music_string.count(\"|\") / 2) + \"o\"\
    \ * (music_string.count(\"o\") / 4) + \\\n                \"o\" * (music_string.count(\"\
    o\") / 4) + \"o\" * (music_string.count(\"o\") / 4) + \\\n                \".\"\
    \ + \"|\" * (music_string.count(\"|\") / 1) + \\\n                \".\" * (music_string.count(\"\
    |\") / 1) + \"o\" * (music_string.count(\"o\") / 4) + \\\n                \"o\"\
    \ * (music_string.count(\"o\") / 4) + \"o\" * (music_string.count(\"o\") / ",
  "    music_string = music_string.strip() # remove spaces at beginning and end\n\
    \    music_string = ''.join(music_string.split()) # convert list of spaces to\
    \ single string\n    music_string = music_string.upper() # uppercase letters\n\
    \    music_notes = music_string.split(' ') # split into note sequence\n    music_notes\
    \ = music_notes[:len(music_notes)-1] # remove last note\n    music_notes = [music_note.lstrip('0')\
    \ # remove leading zeros from notes\n                   for music_note in music_notes]\
    \ # remove leading zeros from notes\n    music_notes = [note.rstrip(' ') for note\
    \ in music_notes] # remove trailing spaces\n    music_notes = [int(note) for note\
    \ in music_notes] # convert notes to integers\n    music_notes = music_notes[::-1]\
    \ # reverse sequence\n    music_notes.insert(4, music_notes.pop()) # add last\
    \ note to beginning of sequence\n    return music_notes", '    music_notes = []',
  "  notes = music_string.split(' ')\n  notes.map! {|note| note.tr('0123456789abcdef',\
    \ '0')}\n  notes.map! {|note| note.scan(/./).map {|char| char.to_i}.flatten}\n\
    \  notes.map! {|note| note.inject(:+)} # inject sum\n  notes.map! {|note| note.uniq!}\
    \ # remove duplicates\n  notes.map! {|note| note.sort!}\n  notes.map! {|note|\
    \ note.each_index {|idx| note[idx] -= 1}}\n  notes.map! {|note| note.uniq.map\
    \ {|note| note.to_i}}\nend\n</code>\n<|/ a dscore=0 tags=ruby,algorithm,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| a tags=ruby,algorithm,ruby-on-rails,ruby-on-rails-3 dscore=0 |>\nOkay,\
    \ I solved it:\n<code>", "  music_list = music_string.split(' ')", "  # Your code\
    \ here\nend\n</cell>\n<text>\nSolution\nUsing the code from the previous exercise\
    \ and your parse_music function, fill in the blanks in this exercise.", "    music_notes\
    \ = music_string.split('|')\n    beat_numbers = []\n    notes = ['.', 'o']\n \
    \   beat_index = 0", "    music_string = 'o o| .| o| o| .| .| .| .| o o' if music_string\
    \ == '' else music_string\n    note_number = []\n    notes = []\n    octave =\
    \ 0\n    count = 0\n    for symbol in music_string:\n        octave = octave %\
    \ 12\n        if symbol == '|':\n            notes.append([octave, count])\n \
    \           notes.append([octave + 1, count])\n            octave += 2\n     \
    \       count += 1\n        elif symbol == 'o':\n            notes.append([octave,\
    \ count])\n            octave += 1\n            count += 1\n        else:\n  \
    \          notes.append([octave, count])\n            octave += 12\n         \
    \   count += 1\n    return notes\n</cell>\n<cell>", "  music_string = music_string.split(//)\n\
    \  notes = []\n  last_notes = []\n  current_note = []\n  last_note = []\n  last_time\
    \ = 0\n  last_time_index = 0\n  last_time_value = 0\n  music_length = len(music_string)\n\
    \  for i in 0...music_length\n    if music_string[i].downcase == \"o\"\n     \
    \ notes << current_note\n      current_note = []\n      last_note << music_string[i+1]\n\
    \      last_time_index += 1\n      last_time = 0\n      last_time_value = 0\n\
    \      last_time_index += 1\n      last_time_value = 0\n      last_time_index\
    \ += 1\n      last_time_value = 0\n      last_time_index += 1\n      last_time_value\
    \ = 0\n      last_time_index += 1\n    elsif music_string[i].downcase == \"o|\"\
    \n      notes << current_note\n      current_note = []\n      last_note << music_string[i+1]\n\
    \      last_time_index += 1\n      last_time = 0\n      last_time_value = 0\n\
    \      last_time_index += 1\n      last_time_value = 0\n      last_time_index\
    \ += 1\n      last_time_value = 0\n      last_time_index += 1\n      last_time_value\
    \ = 0\n      last_time_index += 1\n      last_time_value = 0\n      last_time_index\
    \ += 1\n    elsif music_string[i].downcase == \".|\"\n      notes << current_note\n\
    \      current_note = []\n      last_note << music_string[i+1]\n      last_time_index\
    \ += 1\n      last_time = 0\n      last_time_value = 0\n      last_time_index\
    \ += 1\n      last_time_value = 0\n      last_time_index += 1\n      last_time_value\
    \ = 0\n      last_time_index += 1\n      last_time_value = 0\n      last_time_index\
    \ += 1\n      last_time_value = 0\n      last_time_index += 1\n    elsif music_string[i].downcase\
    \ == \"b\"\n      current_note << music_string[i+1]\n      last_note << music_string[i+1]\n\
    \      last_time_index += 1\n      last_time = 0\n      last_time_value = 0\n\
    \      last_time_index += 1\n      last_time_value = 0\n      last_time_index\
    \ += 1\n      last_time_value = 0\n      last_time_index += 1\n      last_time_value\
    \ = 0\n      last_time_index += 1\n      last_time_value = 0\n      last_time_index\
    \ += 1\n      last_time_value = 0\n      last_time_index += 1\n      last_time_index\
    \ += 1\n      last_time_value = 0\n    elsif music_string[i].downcase == \"#\"\
    \n      current_note << music_", "  notes = music_string.scan(/[\\.\\|o]|\\|{2,}/).flatten.map\
    \ { |note| note.include?('|') ? note.split('|').map(&:to_i).map(&:round) : note.to_i}.flatten\n\
    \  notes.group_by { |note| note.to_i}.map { |note, note_count| note_count.inject(0){\
    \ |sum, note_number| sum + note_number if note % 5 == note_number % 5 } }.compact\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby,regex |>\n<| c |>\nThis looks nice but\
    \ I'm struggling to understand what the code is doing. For example what does the\
    \ scan method do?\n<|/ c |>\n<| c |>\nscan is [Enumerable#scan](http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-scan),\
    \ it scans array for patterns\n<|/ c |>\n<| c |>\nYeah but what is it doing?\n\
    <|/ c |>\n<| c |>\nScan is just doing a regex match on each note in music. Since\
    \ there are a total of 6 notes, each of which can be split into two beats (so\
    \ `o` is 4 beats) or one beat (so `|` is one beat), then you can group them by\
    \ note number. Then sum all the note numbers, grouped by note number, and filter\
    \ out the note numbers ending in `|` - a quarter note.\n<|/ c |>\n<| c |>\nSure,\
    \ it is probably not the best solution, but it is fairly easy to understand.\n\
    <|/ c |>\n<| a tags=ruby,regex |>\n<code>\n[4,2,1,2,2,1,1,1,1,4,4].\n  each_with_object(Hash.new(0))\
    \ do |number,hash|\n    hash.update(number) { |key,old,new| old + new } if number\
    \ % 5 == number % 5\n  end.\n  select { |note,count| count > 1 }.\n  map { |note,count|\
    \ [note, count] }\n  # => [[\"o\", 4], [\"o|\", 2], [\".|\", 1], [\"o|\", 2],\
    \ [\"o|\", 2], [\".|\", 1], [\".|\", 1], [\"o\", 4], [\".|\", 1], [\"o|\", 2],\
    \ [\"o|\", 2]]\n</code>\nThe steps:\n<code>\n[4,2,1,2,2,1,1,1,1,4,4].\n  each_with_object(Hash.new(0)",
  '  music_notes = []', "  music_chars = music_string.split(//)\n  beats = []\n  current_beat\
    \ = 0\n  notes = {0 => 'o', 1 => '|', 2 => '.'}\n  note_positions = {}\n  note_count\
    \ = 0\n  while note_count < music_chars.length\n    char = music_chars[note_count]\n\
    \    if notes.has_key?(char)\n      note_count += 1\n      if note_count == music_chars.length\n\
    \        beats << current_beat\n        current_beat = 0\n        note_positions[char]\
    \ = notes[char]\n        note_count += 1\n      else\n        note_count += note_positions[char].length\n\
    \      end\n    else\n      current_beat += 1\n      note_count += 1\n    end\n\
    \  end\n  beats << current_beat\n  return beats\nend", "    notes = []\n    notes_count\
    \ = music_string.count('|')\n    music_string += '|' * notes_count\n    \n   \
    \ for note in music_string.split(\" \"):\n        if note[-1] == '|':\n      \
    \      notes.append(note[:-1])\n        else:\n            notes.append(note)\n\
    \    return notes\n</cell>\n<cell>", "    note_positions = []\n    note_strings\
    \ = music_string.split(' ')\n    \n    # iterate through notes, add beats to note_positions\
    \ list\n    for note in note_strings:\n        if note == \"o\":\n           \
    \ note_positions.append(4)\n        elif note == \"o|\":\n            note_positions.append(2)\n\
    \        elif note == \".|\":\n            note_positions.append(1)\n    \n  \
    \  # return the sum of all note_positions\n    return sum(note_positions)\n</cell>\n\
    <cell>", "  # Your code here\nend", "    music_string = music_string.upcase\n\
    \    music_string = music_string[0..-1]  # remove leading and trailing spaces\n\
    \    \n    # split music string by |\n    note_parts = music_string.split(\"|\"\
    )\n    \n    notes = []\n    \n    # iterate over all note parts \n    note =\
    \ nil\n    \n    note_parts.each do |note_part|\n        # split note by o\n \
    \       note_parts = note_part.split(\"o\")\n        \n        # check if note\
    \ has only one part\n        # if not - add last beat to note\n        last_beat\
    \ = 1\n        \n        note_parts.each do |note_part|\n            # split note\
    \ by |\n            note_parts = note_part.split(\"|\")\n            \n      \
    \      # check if note is a whole note\n            # if not - add last beat to\
    \ note\n            if note_parts[0] != \"o\"\n                last_beat = 1\n\
    \            else\n                # check if note is a full note\n          \
    \      # if not - add last beat to note\n                if note_parts[1] != \"\
    |\"\n                    last_beat = 1\n                else\n               \
    \     # check if note is an octave\n                    # if not - add last beat\
    \ to note\n                    octave = note_parts[2].to_i\n                 \
    \   if octave < 1 || octave > 8\n                        last_beat = 1\n     \
    \               else\n                        # check if note is a whole note\
    \ with specific octave\n                        # if not - add last beat to note\n\
    \                        octave = note_parts[2].to_i\n                       \
    \ note = parse_music_note(note_parts[1], octave)\n                        note\
    \ = note.first unless note.nil?\n                        \n                  \
    \      # check if note is a whole note with specific octave\n                \
    \        # if not - add last beat to note\n                        if note ==\
    \ nil\n                            last_beat = 1\n                        else\n\
    \                            # check if note is a half note with specific octave\n\
    \                            # if not - add last beat to note\n              \
    \              if note_parts[0] == \"o\"\n                                note\
    \ = parse_music_note(note_parts[1], octave / 2)\n                            \
    \    note = note.first unless note.nil?\n                                last_beat\
    \ = 1\n                            else\n                                # check\
    \ if note is a quarter note with specific octave\n                           \
    \     # if not - add last beat to note\n                                if note_parts[0]\
    \ == \"o\"\n                                    note = parse_music_note(note_parts[1],\
    \ octave / 4)\n                                    note = note.first unless note.nil?\n\
    \                                    last_beat = 1\n                         \
    \       else\n                                    # check if note is a full note\
    \ with specific octave\n                                    # if not - add last\
    \ beat to note\n                                    note = parse_music_", "  \
    \  music_list = music_string.split(' ') #split music string on spaces\n    music_list.pop()\
    \ # remove the last element which is not needed.\n    music_list = []\n    for\
    \ string in music_list:\n        if string == 'o' or string == 'o|' or string\
    \ == '.|'  :\n            music_list.append(4)\n        else:\n            music_list.append(1)\n\
    \    music_list.extend([1] * (len(music_list) - len(music_list) % 4))\n    return\
    \ music_list", "  music_string = music_string.strip\n  if music_string == '.'\
    \ then return [4]\n  if music_string == 'o' then return [1]\n  if music_string\
    \ == 'o|' then return [2, 1]\n  if music_string == '|' then return [1]\n  if music_string.count('|')\
    \ == 1 then\n    notes = music_string.split('|')\n    notes = notes[1..-1]\n \
    \   note = notes[0..-2]\n    note = note.split(', ')\n    note = note[1..-2]\n\
    \    return note\n  else\n    notes = music_string.split('o')\n    notes = notes[1..-1]\n\
    \    note = notes[0..-2]\n    note = note.split(', ')\n    note = note[1..-2]\n\
    \    return note\n  end\nend", "  music_string.downcase!\n  music_string.gsub!('|',\
    \ '.')\n  music_string.gsub!('o', 'o o')\n  music_string.gsub!('|', '.')\n  music_string.gsub!('.|',\
    \ 'o|')\n  music_string.gsub!('o', 'o o')\n  music_string.gsub!('|', '.')\n  music_string.gsub!('.|',\
    \ 'o|')\n  music_string.gsub!('o', 'o o')\n  music_string.gsub!('|', '.')\n  music_string.gsub!('.|',\
    \ 'o|')\n  music_string.gsub!('o', 'o o')\n  music_string.gsub!('|', '.')\n  music_string.gsub!('.|',\
    \ 'o|')\n  music_string.gsub!('o', 'o o')\n  music_string.gsub!('|', '.')\n  music_string.gsub!('.|',\
    \ 'o|')\n  music_string.gsub!('o', 'o o')\n  music_string.gsub!('|', '.')\n  music_string.gsub!('.|',\
    \ 'o|')\n  music_string.gsub!('o', 'o o')\n  music_string.gsub!('|', '.')\n  music_string.gsub!('.|',\
    \ 'o|')\n  music_string.gsub!('o', 'o o')\n  music_string.gsub!('|', '.')\n  music_string.gsub!('.|',\
    \ 'o|')\n  music_string.gsub!('o', 'o o')\n  music_string.gsub!('|', '.')\n  music_string.gsub!('.|',\
    \ 'o|')\n  music_string.gsub!('o', 'o o')\n  music_string.gsub!('|', '.')\n  music_string.gsub!('.|',\
    \ 'o|')\n  music_string.gsub!('o', 'o o')\n  music_string.gsub!('|', '.')\n  music_string.gsub!('.|',\
    \ 'o|')\n  music_string.gsub!('o', 'o o')\n  music_string.gsub!('|', '.')\n  music_string.gsub!('.|',\
    \ 'o|')\n  music_string.gsub!('o', 'o o", "  music_array = music_string.split('\
    \ ') # convert string to array of words\n  music_array.pop() # remove last element\
    \ that is a single space\n  music_array.pop() # remove last element that is a\
    \ single space\n  music_array.pop() # remove last element that is a single space\n\
    \  music_array.pop() # remove last element that is a single space\n  music_array.pop()\
    \ # remove last element that is a single space\n  music_array.pop() # remove last\
    \ element that is a single space\n  music_array.pop() # remove last element that\
    \ is a single space\n  music_array.pop() # remove last element that is a single\
    \ space\n  music_array.pop() # remove last element that is a single space\n  music_array.pop()\
    \ # remove last element that is a single space\n  music_array.pop() # remove last\
    \ element that is a single space\n  music_array.pop() # remove last element that\
    \ is a single space\n  music_array.pop() # remove last element that is a single\
    \ space\n  music_array.pop() # remove last element that is a single space\n  music_array.pop()\
    \ # remove last element that is a single space\n  music_array.pop() # remove last\
    \ element that is a single space\n  music_array.pop() # remove last element that\
    \ is a single space\n  music_array.pop() # remove last element that is a single\
    \ space\n  music_array.pop() # remove last element that is a single space\n  music_array.pop()\
    \ # remove last element that is a single space\n  music_array.pop() # remove last\
    \ element that is a single space\n  music_array.pop() # remove last element that\
    \ is a single space\n  music_array.pop() # remove last element that is a single\
    \ space\n  music_array.pop() # remove last element that is a single space\n  music_array.pop()\
    \ # remove last element that is a single space\n  music_array.pop() # remove last\
    \ element that is a single space\n  music_array.pop() # remove last element that\
    \ is a single space\n  music_array.pop() # remove last element that is a single\
    \ space\n  music_array.pop() # remove last element that is a single space\n  music_array.pop()\
    \ # remove last element that is a single space\n  music_array.pop() # remove last\
    \ element that is a single space\n  music_array.pop() # remove last element that\
    \ is a single space\n  music_array.pop() # remove last element that is a single\
    \ space\n  music_array.pop() # remove last element that is a single space\n  music_array.pop()\
    \ # remove last element that is a single space\n  music_array.pop() # remove ",
  "    music_string = \"o\" + music_string.strip() + \"|\"\n    notes = [[] for _\
    \ in range(7)]\n    chords = []\n    index = 0\n    while index < len(music_string):\n\
    \        char = music_string[index]\n        if char == \"o\":\n            notes[int(music_string[index+1])].append(index)\n\
    \        elif char == \"|\":\n            notes[int(music_string[index+1])].append(index)\n\
    \            chords.append(notes)\n            notes = [[] for _ in range(7)]\n\
    \            index += 1\n        else:\n            index += 1\n    chords.append(notes)\n\
    \    return chords\n</cell>\n<cell>", "  result = []\n  offset = 0\n  current_beat\
    \ = 0\n  music_string.scan(/./) do |note|\n    if note == 'o' || note == 'o|'\n\
    \      current_beat = 0\n      result.append(offset)\n    elsif note == '.'\n\
    \      current_beat+=1\n      result.append(offset)\n    end\n    offset += 1\n\
    \  end\n  result\nend", "  music_string.scan(/\\d/).map do |m|\n    m.to_i\n \
    \ end\nend", "  music_string = music_string.rstrip\n  music_string[0]\n  music_string.lstrip\n\
    \  music_string.split(//)\n  music_string.length\n  music_string.length?\n  music_string.each_char.map(&:to_i)\n\
    end", "  music_string = music_string.split('|')\n  music_string.map! do |note|\n\
    \    note.split('o')\n  end\n  music_string = music_string.map do |note|\n   \
    \ note.flatten\n  end\n  music_string.map! do |note|\n    note[0].to_i + note[1]\n\
    \  end\n  music_string.sort!\n  music_string\nend", "  music_notes = []\n  music_notes_length\
    \ = 0\n  music_notes_index = 0\n  music_note_chars = []\n  music_note_char_index\
    \ = 0\n  music_note_chars_index = 0\n  music_note_chars_length = 0\n  music_note_char_indexes\
    \ = []", "  music_string.split(\" \").map do |note_string|\n    note_string.split(\"\
    |\").map do |note|\n      note.count(\"o\")\n    end\n  end.reduce(:+)\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nI like how you thought of the problem and\
    \ gave an example, but I suspect the OP does not know how to split a string (which\
    \ may be an exercise for them).\n<|/ c |>\n<| a tags=ruby |>\nHere's a fun one:\n\
    <code>", "  music_string = music_string.strip\n  music_string = music_string.gsub('o',\
    \ 'o o|')\n  music_string = music_string.gsub('|', 'o|')\n  music_array = music_string.split('|')\n\
    \  music_array.map!(&:strip)\n  return music_array\nend", "  music_string\nend",
  "  # Your code here\n  return music_string.scan(/o|\\.\\|/).map(&:to_i).sort.first(12).map(&:to_a)\n\
    end", "    beats = 0\n    result = []\n    music_string = music_string.strip.split('\
    \ ')\n    music_string.each do |note|\n        if note == '.'\n            beats\
    \ += 1\n        else\n            if note == 'o'\n                beats += 4\n\
    \            elsif note == 'o|'\n                beats += 2\n            elsif\
    \ note == '|'\n                beats += 1\n            end\n        end\n    \
    \    result.append(beats)\n    end\n    return result\nend\n</code>\nAnd now,\
    \ to sum this up into a single function:\n<code>", '  notes = []', "  notes =\
    \ music_string.split(\"|\")\n  \n  last_note = 0\n  last_beat = 0\n  \n  # We\
    \ keep track of what beats are last in the music string\n  # We use it to know\
    \ how long a note lasts.\n  last_beats = [0 for _ in notes]\n  \n  # We keep track\
    \ of how many notes are in a given \"beat\".\n  # If a note is in a given \"beat\"\
    , we add one to the number of notes in that \"beat\".\n  # If a note is not in\
    \ a given \"beat\", we set that \"beat\" to zero.\n  beats = [0 for _ in notes]\n\
    \  \n  # We keep track of what notes are on a given \"beat\".\n  # If a note is\
    \ on a given \"beat\", we add one to the number of notes on that \"beat\".\n \
    \ # If a note is not on a given \"beat\", we set that \"beat\" to zero.\n  notes_on_beats\
    \ = [0 for _ in notes]", "  music_string = music_string.to_s\n  music_string =\
    \ music_string[1..-2].to_s\n  music_string.split(' ').map do |note|\n    case\
    \ note\n    when 'o'\n      0\n    when 'o|'\n      2\n    when '.|'\n      1\n\
    \    else\n      raise \"Unrecognized note #{note} at #{music_string.index('o')}\"\
    \n    end\n  end.flatten\nend\n</code>\n<|/ a |>\n<| a |>\nI wrote a function\
    \ using Ruby 1.9.3's Regexp class to parse a string of musical notes.\n<code>",
  "  music_string = music_string.split('o')\n  music_string = [music_string[0][:music_string[0][0].index('.')]\
    \ + music_string[0].split('.')[1:]] + music_string\n  music_string.map!(&:lstrip!)\n\
    \  music_string = music_string.map { |note| note.index('|') ? note.index('.')\
    \ + 1 : note.index('|') ? 4 : 1 }\n  music_string = music_string.sum { |note|\
    \ note }\n  music_string.map!(&:to_i)\nend", "  music_string.chars.each_with_index\
    \ do |char, index|\n    beat_length = music[index + 1] - music[index - 1]\n  \
    \  music_length = music[index + 3] - music[index + 2]\n    if char == 'o'\n  \
    \    return [beat_length / music_length.to_i]\n    elsif char == 'o|'\n      return\
    \ [beat_length / music_length.to_i, 2]\n    elsif char == '.|'\n      return [beat_length\
    \ / music_length.to_i, 1]\n    end\n  end\nend", "    notes = [0, 0, 0, 0]\n \
    \   last_beat = music_string[0].count('.')\n    if last_beat % 4 == 0\n      \
    \  notes = [music_string[0].count('o'), music_string[0].count('o|'), music_string[0].count('.|')]\n\
    \    notes = [notes[0] if notes[1] == 0 else notes[1], notes[1] / 4, notes[2],\
    \ notes[3] / 4]\n    music_string = music_string[music_string[0].count('.|'):]\n\
    \    music_string = music_string.replace(\" \", \"\").replace(\"|\", \"o\")\n\
    \    music_string = music_string.replace(\"o\", \"0\").replace(\"|\", \"o\")\n\
    \    music_string = music_string.replace(\"o\", \"0\").replace(\" \", \"\")\n\
    \    music_string = music_string.replace(\"o\", \"0\").replace(\"|\", \"o\")\n\
    \    music_string = music_string.replace(\"o\", \"0\").replace(\" \", \"\")\n\
    \    music_string = music_string.replace(\"o\", \"0\").replace(\" \", \"\")\n\
    \    music_string = music_string.replace(\" \", \"\")\n    music_string = music_string.replace(\"\
    o\", \"0\").replace(\" \", \"\")\n    music_string = music_string.replace(\" \"\
    , \"\")\n    music_string = music_string.replace(\"o\", \"0\").replace(\" \",\
    \ \"\")\n    music_string = music_string.replace(\" \", \"\")\n    music_string\
    \ = music_string.replace(\"o\", \"0\").replace(\" \", \"\")\n    music_string\
    \ = music_string.replace(\" \", \"\")\n    music_string = music_string.replace(\"\
    o\", \"0\").replace(\" \", \"\")\n    music_string = music_string.replace(\" \"\
    , \"\")\n    music_string = music_string.replace(\"o\", \"0\").replace(\" \",\
    \ \"\")\n    music_string = music_string.replace(\" \", \"\")\n    music_string\
    \ = music_string.replace(\"o\", \"0\").replace(\" \", \"\")\n    music_string\
    \ = music_string.replace(\" \", \"\")\n    music_string = music_string.replace(\"\
    o\", \"0\").replace(\" \", \"\")\n    music_string = music_string.replace(\" \"\
    , \"\")\n    music_string = music_string.replace(\"o\", \"0\").replace(\" \",\
    \ \"\")\n    music_string = music_string.replace(\" \", \"\")\n    music_string\
    \ = music_string.replace(\"o\", \"0\").replace(\" \", \"\")\n    music_string\
    \ = music_string.replace(\" \", \"\")\n    music_string = music_string.replace(\"\
    o\", \"0\").replace(\" \", \"\")\n    music_string = music_string.replace(\" \"\
    , \"\")\n    music_string = music_string.replace(\"o\", \"0\").replace(\" \",\
    \ \"\")\n    music_string = music_string.replace(\" \", \"\")\n    music_string\
    \ = music_string.replace(\"o\", \"0\").replace(\" \", \"\")\n    music_string\
    \ = music_string.replace(\" \", \"\")", "  # TODO\nend\n</cell>\n<text>\nSolution\n\
    Let's test your implementation. You need to pass a music string to your function\
    \ and get a list of integers as an output. Test it using examples from the tests.",
  "  music_string = music_string.split('o|')\n  music_string.pop", "    music_notes\
    \ = music_string.split\n    result = music_notes.map do |note|\n        note =\
    \ note.strip\n        case note\n        when 'o'\n            4\n        when\
    \ 'o|'\n            2\n        when '.|'\n            1\n        end\n    end.inject(&:+)\n\
    \    result > 0 ? result : nil\nend\n</cell>\n<text>\nExercise 4\nImplement function\
    \ count_intervals(intervals) which takes a list of intervals and returns the number\
    \ of non-overlapping intervals.", "  music_array.push(music_string)\n  music_note_list.push(music_string)\n\
    \  music_note_beat = 0\n  music_note_number = music_string.length\n  music_note_duration\
    \ = 0\n  music_note_notes = []\n  music_note_note = music_string[0]\n  music_note_notes.unshift(music_note_note)\n\
    \  music_notes.append(music_note_notes)\n  music_notes_length = 1\n  music_notes_beat\
    \ = 0\n  music_notes_note = music_note_notes[0]\n  music_notes_notes.unshift(music_notes_note)\n\
    \  music_notes_length = 1\n  music_notes_number = music_note_notes.length\n  music_notes_duration\
    \ = 0\n  music_notes_dur = music_notes_length\n  music_notes_note = music_notes_notes[0]\n\
    \  music_notes_notes.unshift(music_notes_note)\n  music_notes_length = 1\n  music_notes_number\
    \ = music_notes_notes.length\n  music_notes_duration = 0\n  music_notes_dur =\
    \ music_notes_length\n  music_notes_note = music_notes_notes[0]\n  music_notes_notes.unshift(music_notes_note)\n\
    \  music_notes_length = 1\n  music_notes_number = music_notes_notes.length\n \
    \ music_notes_duration = 0\n  music_notes_dur = music_notes_length\n  music_notes_note\
    \ = music_notes_notes[0]\n  music_notes_notes.unshift(music_notes_note)\n  music_notes_length\
    \ = 1\n  music_notes_number = music_notes_notes.length\n  music_notes_duration\
    \ = 0\n  music_notes_dur = music_notes_length\n  music_notes_note = music_notes_notes[0]\n\
    \  music_notes_notes.unshift(music_notes_note)\n  music_notes_length = 1\n  music_notes_number\
    \ = music_notes_notes.length\n  music_notes_duration = 0\n  music_notes_dur =\
    \ music_notes_length\n  music_notes_note = music_notes_notes[0]\n  music_notes_notes.unshift(music_notes_note)\n\
    \  music_notes_length = 1\n  music_notes_number = music_notes_notes.length\n \
    \ music_notes_duration = 0\n", "  music_string = 'o o| .| o| o| .| .| .| .| o\
    \ o'\n  \n  beats = []\n  beat = 0\n  last_note = 0\n  \n  for note in music_string:\n\
    \    if (note == '.'):\n      beats.append(beat)\n      beat = 0\n    else:\n\
    \      beat += 1\n      last_note = note\n  \n  beats.append(beat)\n  \n  return\
    \ beats", "    notes = []\n    note_index = 0\n    current_note = ''\n    current_note_length\
    \ = 0\n    for c in music_string:\n        if c == '.':\n            note_index\
    \ += 1\n            note_index %= len(notes)\n            notes[note_index] +=\
    \ 1\n        elif c == ',':\n            note_index += 1\n            current_note\
    \ = notes[note_index // len(notes)]\n            current_note_length = notes[note_index\
    \ % len(notes)]\n        elif c == '|':\n            note_index += 1\n       \
    \     note_index %= len(notes)\n            notes[note_index] += current_note_length\n\
    \        else:\n            current_note += c\n            current_note_length\
    \ = 1\n    note_index += 1\n    note_index %= len(notes)\n    notes[note_index]\
    \ += current_note_length\n    return notes", "  return music_string.scan(/o|\\\
    .\\|/).flatten.map(&:to_i).sort\nend", "  music_notes = music_string.split(//)\n\
    \  music_notes.map! do |note|\n    note = note.downcase\n    case note\n    when\
    \ '.', 'o'\n      0\n    when 'o|', '|o'\n      2\n    else\n      raise \"Unrecognized\
    \ note: \" + note\n    end\n  end\n  music_notes.inject(0) do |sum, note|\n  \
    \  (sum + music_notes[note + 1] - music_notes[note]).round\n  end\nend\n</code>\n\
    EDIT: I forgot some details in the question description, so the correct result\
    \ for this example should be [8, 4, 4].\n<|/ a dscore=1 tags=ruby,string,arrays\
    \ |>\n<| c |>\nHow does the '|' become a quater note? Also, how would you change\
    \ your code so that if the input is \"o o| .| o| o| .| .| .| .| o o\", you still\
    \ get [8, 4, 4]?\n<|/ c |>\n<| c |>\n`|` will be mapped to `2`, so if you have\
    \ `o o| .| o| o|`, then `o|` will become `2` and `.|` will become `1`.\n<|/ c\
    \ |>\n<| c |>\nOkay, so I added '.' to the list of notes, but when I ran your\
    \ script on the input I provided, I got `[8, 4, 4]`, instead of `[8, 4, 4]` as\
    \ your result shows.\n<|/ c |>\n<| c |>\nYeah, sorry, I thought that was a mistake\
    \ from my side. I corrected it, it should work now.\n<|/ c |>\n<| c |>\nI'm sorry\
    \ I missed the details in the question. I edited the code now, please check it\
    \ again.\n<|/ c |>\n<| a tags=ruby,string,arrays dscore=1 |>\n<code>", "  result\
    \ = []\n  current_beat = 0\n  current_beat_note = ''\n  current_note = ''\n  current_note_length\
    \ = 0\n  \n  # We expect first character to be a note to parse\n  music_string.chars.first.to_s\n\
    \  \n  # We go through the music string one character at a time\n  music_string.chars.each\
    \ do |c|\n    if c == \" \" # Space is end of note\n      current_beat += 1 \n\
    \      \n      # If current note is not yet finished, we parse it\n      unless\
    \ current_beat_note == current_note\n        \n        # In case current note\
    \ is quarter note and current note is longer than quarter note,\n        # we\
    \ go back to first beat\n        if current_note == 'o' and current_note_length\
    \ >= 4\n          current_beat = 0\n        end\n        \n        # Parse current\
    \ note\n        result += parse_note(current_beat, current_beat_note, current_note,\
    \ current_note_length)\n        current_beat_note = ''\n        current_beat =\
    \ 0\n        current_note = ''\n        current_note_length = 0\n      end\n \
    \   elsif c != \"o\" and c != \".\" # Other characters are other notes to parse\n\
    \      current_beat_note << c unless current_beat_note.empty?\n    end\n    \n\
    \    # Increment note length\n    current_note_length += 1\n  end\n  \n  # After\
    \ last note, add last note and set new beat\n  if current_beat_note != current_note\
    \ or current_note_length == 0\n    result += parse_note(current_beat, current_beat_note,\
    \ current_note, current_note_length)\n  end\n  \n  # Return result list\n  result\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you for your answer. I appreciate your\
    \ comments about the code. I am going to give it a shot after dinner. I will update\
    \ after I try it. Thanks again!\n<|/ c |>\n<| c |>\nI updated the function based\
    \ on your feedback. Thank you for all the help!\n<|/ c |>\n<| a tags=ruby,regex\
    \ dscore=0 |>\n<code>", "  # TODO: your code here\nend", "  music_string.split(\"\
    \ \").each_with_index do |element, i|\n    if element == 'o'\n      last_beats\
    \ = 4\n    elsif element == 'o|'\n      last_beats = 2\n    elsif element == '.|'\n\
    \      last_beats = 1\n    end\n    music_string[i] = element\n  end\n  music_string.split.map\
    \ {|element| element.split(\"|\").map(&:to_i).reduce(:+)} + [last_beats]\nend\n\
    </code>\n<|/ a |>\n<| a dscore=0 tags=algorithm,ruby,hash,arrays |>\nThis can\
    \ be done in O(N*log(N)) time. Here is an example:\n<code>", "  return music_string.scan(/[\\\
    .|o]{2}|o|\\.|\\|/).map(&:to_i)\nend", "  music_string.gsub(/\\s+/, ' ').strip!\n\
    \  music_string.split(' ').each do |note|\n    if note == '.'\n      music_string\
    \ << \" .\"\n    elsif note == 'o'\n      music_string << \" o\"\n    elsif note\
    \ == 'o|'\n      music_string << \" o|\"\n    elsif note == '|'\n      music_string\
    \ << ' '\n    elsif note == '|o'\n      music_string << \" |o\"\n    else\n  \
    \    raise ArgumentError, \"Unknown note! #{note}.\"\n    end\n  end\n  music_string.split('\
    \ ').map do |note|\n    if note.index('.') && note.index('|')\n      note.split('|')[1].to_i\n\
    \    elsif note.index('|')\n      note.split('|')[0].to_i\n    else\n      note.to_i\n\
    \    end\n  end\nend\n</code>\n<|/ a tags=ruby,split,arrays |>\n<| c |>\nNice!\
    \ This is much more concise than mine. I'm very grateful for your help - and thank\
    \ you for the explanations. I will need to study your code later - but I have\
    \ a lot of experience in coding, and I think it's very valuable to me to understand\
    \ the logic that you're using. Thanks again - very much appreciated.\n<|/ c |>\n\
    <| a dscore=0 |>\nI believe that there are many ways to do this - here is one\
    \ way of doing it using regex:\n<code>\nmusic = <<EOF\no o| .| o| o| .| .| .|\
    \ .| o o\nEOF\nmusic_notes = music.split(/(?<=\\s)(?=[o|\\.])|(?<=\\s)(?=[o|\\\
    .]|(?<=\\s)[\\.\\|])/)\nmusic_notes", "  music_string.split(//).inject([]) do\
    \ |beats, current_note|\n    notes = current_note.split('|')\n    if notes.length\
    \ == 2\n      beats << [4, 1] if notes.include?('o')\n      beats << [2, 2, 1]\
    \ if notes.include?('o|')\n      beats << [1, 2, 1] if notes.include?('.|')\n\
    \    elsif notes.length == 1\n      beats << [1, 2, 1] if notes.include?('.|')\n\
    \    else\n      raise \"unknown note symbols: #{current_note}\"\n    end\n  \
    \  beats\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nNice answer, but you\
    \ missed a couple of key points: 1) It doesn't matter whether you use `map` or\
    \ `inject` here; 2) It would be better if the notes were represented as an array\
    \ rather than as a string. 3) A more efficient implementation would be to just\
    \ `notes.each { |note| beats << note == 'o' ? [4, 1] : note == 'o|' ? [2, 2, 1]\
    \ : [1,2,1] } if notes.length == 1`. 4) Even better, instead of `map` you could\
    \ use `each_with_object` which would avoid constructing the empty array and would\
    \ avoid having to check if the array is empty before appending to it.\n<|/ c |>\n\
    <| a |>\nI would take a look at Regexps. It's not too hard to build a pattern\
    \ that matches the patterns you are looking for. For example:\n<code>\n/(o|o|o|\\\
    |\\.|\\.|\\.|\\|o|\\|o|o|\\.|\\.|\\.|\\.|o|o|o|\\.|\\.|\\.|\\.|o|\\|\\.|\\.|\\\
    .|\\.|\\|\\.|\\.|\\.|\\.|o|\\|\\.|\\.|\\.|\\.|\\.|\\|\\.|\\.|\\.|\\|\\.|\\.|\\\
    .|\\.|o|o|\\.|\\.|\\.|\\.|\\|\\.|\\.|\\.|\\.|\\.|o|\\|\\.|\\.|\\.|\\.|\\.|\\.|\\\
    .|\\.|o|\\|\\.|\\.|\\.|\\.|\\.|\\.|\\.|\\.|o|o|\\.|\\.|\\.|\\.|\\|\\.|\\.|\\.|\\\
    .|\\.|\\.|o|\\|\\.|\\.|\\.|\\.|\\.|\\.|\\.|\\.|o|o|\\.|\\.|\\.|\\.|\\.|\\.|\\|",
  "  music_list = music_string.split(/\\|/)\n  music_array = []\n  current_beat =\
    \ 1\n  current_note = ''\n  while music_list[0] != '':\n    if len(music_list)\
    \ == 1: # 'o' case\n      if current_note != '':\n        music_array.append(current_beat)\n\
    \        current_beat = 1\n        current_note = ''\n    else:\n      if current_note\
    \ != '':\n        if music_list[0] == 'o':\n          current_note = 'o'\n   \
    \     elif music_list[0] == 'o|':\n          current_note = 'o|'\n        elif\
    \ music_list[0] == '.|':\n          current_note = '.|'\n        else:\n     \
    \     raise Exception\n      else:\n        if music_list[0] == 'o':\n       \
    \   current_note = 'o'\n        elif music_list[0] == 'o|':\n          current_note\
    \ = 'o|'\n        elif music_list[0] == '.|':\n          current_note = '.|'\n\
    \        else:\n          raise Exception\n      music_list.pop(0)\n    current_beat+=1\n\
    \  return music_array\n</cell>\n<cell>", "    # your code here\n    return []\n\
    end", "  music_string_list = music_string.split(' ')\n  music_list = [music_string_list[0]]\n\
    \  for element in music_string_list\n    if element == '.'\n      music_list <<\
    \ music_list[-1][-1]\n    else\n      music_list << parse_element(element)\n \
    \ end\n  music_list.compact!\n  music_list.uniq!\n  music_list.sort!\n  music_list.map\
    \ {|note| note_to_beats(note)}\nend", "  music_array.push(music_string)\n  music_array.shift\n\
    end", "  music_string.chars.each_with_index do |letter, index|\n    letter =~\
    \ /o|.|/ ? next if index == 0 || index == 2\n    letter =~ /o/ ? index += 3 :\
    \ index += 2\n  end\n  return music_string.chars.each_with_index.map { |letter,\
    \ index| index == 4 ? 4 : index }.uniq\nend", "  notes = []\n  current_beat =\
    \ 0\n  current_note = 0\n  for i in music_string.split(//)\n    if i.length ==\
    \ 1\n      notes.push current_beat\n      current_note = i.to_sym\n      current_beat\
    \ = 0\n    else\n      current_beat = current_beat + i.length\n    end\n  end\n\
    \  notes.push current_beat\n  return notes\nend\n</code>\n<|/ a dscore=0 tags=parsing,ruby,arrays,algorithm\
    \ |>\n<| c |>\nThank you for the answer. I'm relatively new to programming so\
    \ I didn't understand what you were saying about `current_beat`. But after trying\
    \ your solution, I've noticed that some strings are still being pushed into the\
    \ `notes` array because they have lengths greater than four.\n<|/ c |>\n<| a tags=parsing,ruby,arrays,algorithm\
    \ |>\nI like the solution from but wanted to show a slightly different way of\
    \ doing it\n<code>", "  music_notes = music_string.split\n  # notes = music_notes[0..-2]\n\
    \  notes = music_notes[0..music_notes.length-2]\n  beats = []\n  count = 1\n \
    \ note_count = 0\n  last_note = False\n  notes_done = []\n  while notes.length\
    \ != 0\n    note = notes[0]\n    if note == '.'\n      note = notes[1]\n     \
    \ if note == '.'\n        note = notes[2]\n        if note == '.'\n          note\
    \ = notes[3]\n          if note == '.'\n            note = notes[4]\n        \
    \    if note == '.'\n              note = notes[5]\n              if note == '.'\n\
    \                note = notes[6]\n                if note == '.'\n           \
    \       note = notes[7]\n                  if note == '.'\n                  \
    \  note = notes[8]\n                    if note == '.'\n                     \
    \ note = notes[9]\n                      if note == '.'\n                    \
    \    note = notes[10]\n                        if note == '.'\n              \
    \            note = notes[11]\n                          if note == '.'\n    \
    \                        note = notes[12]\n                            notes_done\
    \ = [notes_done.length-1]\n                            if note == 'o'\n      \
    \                        notes_done = [notes_done.length-1]\n                \
    \              note_count = note_count-1\n                              last_note\
    \ = notes_done\n                            else\n                           \
    \   notes_done = [notes_done.length-1]\n                              note_count\
    \ = note_count-1\n                              last_note = notes_done\n     \
    \                       end\n                          end\n                 \
    \       end\n                      end\n                    end\n            \
    \      end\n                end\n              end\n            end\n        \
    \  end\n        end\n      end\n    end\n    if note == 'o'\n      notes_done\
    \ = [notes_done.length-1]\n      note_count = note_count-1\n      last_note =\
    \ notes_done\n    else\n      notes_done = [notes_done.length-1]\n      note_count\
    \ = note_count-1\n      last_note = notes_done\n    end\n    notes.pop\n  end\n\
    \  beats = music_notes[0..notes_done.length]\n  beats = beats.map {|b| b.to_i}\n\
    \  beats.sort!\n  return beats\nend", '  music_string_array = music_string.split(/(\.|o|o\|)/)',
  "  music_string.scan(/./).collect { |note| note.to_i() }.sort\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nPlease avoid \"Code dump\" answers. Please explain what\
    \ the code is doing. People might want to learn from it.\n<|/ c |>\n<| a tags=ruby,regex\
    \ |>\nThe below code will get the correct answer :\n<code>", "  music_string =\
    \ \"o|\" + music_string.split(\"|\").join(\"|o\") + \"|o\"\n  music_string.downcase!\n\
    \  music_string.gsub!(/o+/, 'o|')\n  music_string.gsub!(/o\\|/, 'o|')\n  music_string.gsub!(/\\\
    .\\|/, '.|')\n  music_string.gsub!(/\\|o\\|/, 'o|')\n  music_string.gsub!(/\\\
    |\\.\\|/, '.|')\n  music_string.gsub!(/\\|o\\|o\\|/, 'o|')\n  music_string.gsub!(/\\\
    |\\.\\|\\.\\|/, '.|')\n  music_string.gsub!(/\\|o\\|o\\|\\.\\|/, 'o|')\n  music_string.gsub!(/\\\
    |\\.\\|o\\|\\.\\|/, '.|')\n  music_string.gsub!(/\\|\\.\\|o\\|\\.\\|\\.\\|/, '.|')\n\
    \  music_string.gsub!(/\\|o\\|o\\|\\.\\|\\.\\|/, 'o|')\n  music_string.gsub!(/\\\
    |\\.\\|o\\|\\.\\|\\.\\|\\.\\|/, '.|')\n  music_string.gsub!(/\\|\\.\\|o\\|\\.\\\
    |\\.\\|\\.\\|\\.\\|/, '.|')\n  music_string.gsub!(/\\|\\.\\|\\.\\|\\.\\|\\.\\\
    |\\.\\|/, '.|')\n  music_string.gsub!(/\\|\\.\\|\\.\\|\\.\\|\\.\\|\\.\\|\\.\\\
    |/, '.|')\n  music_string.gsub!(/\\|\\.\\|\\.\\|\\.\\|\\.\\|\\.\\|\\.\\|\\.\\\
    |/, '.|')\n  music_string.gsub!(/\\|\\.\\|\\.\\|\\.\\|\\.\\|\\.\\|\\.\\|\\.\\\
    |\\.\\|/, '.|')\n  music_string.gsub!(/\\|\\.\\|\\.\\|\\.\\|\\.\\|\\.\\|\\.\\\
    |\\.\\|\\.\\|\\.\\|/, '.|')\n  music_string.gsub!(/\\|\\.\\|\\.\\|\\.\\|\\.\\|",
  "  music_string.split(' ').map do |note|\n    case note\n    when 'o'\n      4\n\
    \    when 'o|'\n      2\n    when '.|'\n      1\n    else\n      0\n    end\n\
    \  end\nend\n</cell>\n<cell>", "  music_string.split(' ').map { |note| parse_note(note)\
    \ }\nend", "  music_string.downcase!\n  music_string = music_string.tr(\",.?|!\"\
    , \"\").chomp\n  music_string.gsub(/[\\[\\].]|([a-z])\\1|\\1/) { |char| char }\n\
    \  music_string.split(\" \").map { |note| note.split(\"\").map { |char| char.to_i\
    \ } }.transpose.flatten.uniq\nend", "  result = []\n  beat = 0\n  note = music_string[0]\n\
    \  rest = music_string[1:]\n  while note != \".\"\n    beat += 1\n    if note\
    \ == \"o\"\n      result << beat\n    elsif note == \"|\"\n      result << beat\
    \ * 2\n    else\n      raise \"unknown note\"\n    note = rest[0]\n    rest =\
    \ rest[1:]\n  end\n  result << beat if rest\n  result\nend\n</cell>\n<cell>",
  "    music_list = music_string.split()\n    music_list_with_beats = music_list +\
    \ ['o'] * len(music_list)\n    return music_list_with_beats\n</cell>\n<cell>",
  "  music_string.scan(/o|\\|\\||\\.\\|/) do |note|\n    note.scan(/o|\\.\\|/) do\
    \ |beats|\n      return beats.size if beats.size <= 4\n      return beats.size\
    \ if beats.size >= 5\n    end\n  end\nend", "  music_notes = music_string.scan(/\\\
    A(\\|?\\S*)\\z/m).flatten\n  notes_without_rest = music_notes.reject { |note|\
    \ note =~ /\\A[^|]|$/ }\n  notes_with_last_rest = notes_without_rest.map { |note|\
    \ note =~ /\\A[^\\|]+\\z/ ? note.size : 1 }\n  notes_with_last_rest.reduce(:+)\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,regex |>\nHere's a fairly simple\
    \ pure regex solution:\n<code>", "  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  music_string\n\
    \  music_string\n  music_string\n  music_string\n  music_string\n  musi", "  \
    \  music_string = music_string.downcase\n    music_string = ''.join(x for x in\
    \ music_string if x not in ['o', 'o|', '.|'])\n    \n    notes = []\n    for note\
    \ in music_string.split():\n        if note == 'o':\n            notes.append(4)\n\
    \        elif note == 'o|':\n            notes.append(2)\n        elif note ==\
    \ '.|':\n            notes.append(1)\n    return notes\n</cell>\n<cell>", "  music_array\
    \ = music_string.split\n  returned_array = []\n  i = 0\n  current_note = ''\n\
    \  current_note_length = 1", "  music_string = music_string.strip\n  note_list\
    \ = music_string.split(\" \") # split the string into list of notes\n  note_list.shift\n\
    \  note_list.shift if note_list.length > 4 # remove last empty string element\n\
    \  note_list.map {|n| n.to_i} # convert each string note to integer value\nend",
  "  music_notes = music_string.scan(/[\\.\\|o]+/)\n  \n  last_note_count = music_notes.inject(0){|sum,\
    \ note| sum + parse_note(note).length}\n  \n  music_notes.inject([]){|notes, note|\
    \ notes.push(parse_note(note)); notes}\nend\n</code>\n<|/ a dscore=0 tags=ruby,regex\
    \ |>\n<| c |>\nThanks for the detailed description!\n<|/ c |>\n<| c |>\nYou're\
    \ welcome. Feel free to upvote and accept if it was helpful.\n<|/ c |>\n<| a |>\n\
    Your regexp matches all patterns containing one of o|.|, while you probably want\
    \ this instead:\n<code>\nmusic_notes = music_string.scan(/[o\\.|]+/)\n</code>\n\
    Note the + instead of *. Also note the square brackets around the |, to match\
    \ a single o|.|.| and omit the o|.| completely. \nFurther, you probably want to\
    \ map this array into an array of arrays, where each subarray is a note with its\
    \ length. So a very simple solution:\n<code>\nmusic_notes = music_string.scan(/[o\\\
    .|]+/).map {|note| note.length }\n</code>\n<|/ a dscore=0 tags=ruby,regex |>\n\
    <| c |>\nThanks for the detailed description!\n<|/ c |>\n<| a dscore=0 |>\nYou\
    \ want your regex to match \"o\" or \"|\" and \".\" but not \".\" at the end.\
    \ Why not just use [o|.] instead of [o|.|]?\nAlso, you only want to scan for one\
    \ character at a time. So, you should use \\. instead of \\.\\.\n<|/ a tags=ruby,regex\
    \ |>\n<| c |>\nThanks for the detailed description!\n<|/ c |>\n<| a dscore=0 tags=ruby,regex\
    \ |>\nAs others have stated, your regex needs to contain one or more occurrences\
    \ of o|.|. not only one.\nYour code would become like this \n<code>\nmusic_notes\
    \ = music_string.scan(/[o\\.|]+/)\n</code>\n<|/ a |>\n<| c |>\nThanks for the\
    \ detailed description!\n<|/ c |>\n<| a |>\nThis is my regex pattern:\n<code>\n\
    /[\\.\\|o]+/\n</code>\nIt matches any character (except a newline character) between\
    \ o|. and .| - which ", "    music_string = music_string.strip() # Remove leading\
    \ and trailing whitespace characters\n    music_notes = music_string.split() #\
    \ Split music note sequence into array\n    music_notes.shift # Remove first element\
    \ from array\n    music_notes.shift # Remove last element from array", "  music_array\
    \ = music_string.split\n  # TODO: Write your solution\nend", "  music_array =\
    \ music_string.split(//).map { |note| note.chars.to_i(16) }\n  return music_array.map\
    \ { |note| note.to_i }.count\nend\n</cell>\n<text>\nTask 2: Count number of notes\
    \ in each row of a music array\nWrite a function that counts number of notes in\
    \ each row of a music array\nHere's an example:\n>>> music = ['.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o",
  "  music_string.scan(/o|\\.|[^|]|[^o](?!\\|)|[^o]$/)\nend\n</code>\n<|/ a tags=algorithm,ruby,string\
    \ |>\n<| c |>\nThis doesn't work if the music string is \"o.o o.o.o\" which should\
    \ return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4], but instead returns [5, 5, 4, 4, 4,\
    \ 3, 2, 2, 2, 2, 4, 4]\n<|/ c |>\n<| c |>\n.Hall I edited the answer to include\
    \ the case when notes are longer than 2 beats.\n<|/ c |>\n<| c |>\nIt's nice that\
    \ you made it work for single notes, but the solution should be more general.\
    \ You're making it work for a single note, but also for the case where there are\
    \ two or more notes.\n<|/ c |>\n<| c |>\n.Hall I agree with you and I edited the\
    \ answer to make it more general. Thanks.\n<|/ c |>\n<| a tags=algorithm,ruby,string\
    \ |>\n<code>", "  music_string.split(' ').map { |m| m.split('|') }.flatten.map\
    \ { |m| m.split('o') }.flatten.count\nend", "  music_string = music_string.split('|')\n\
    \  result = []\n  music_string.each do |note_string|\n    note_string.strip.chars.each\
    \ do |char|\n      if char == '.'\n        result << 4\n      elsif char == 'o'\n\
    \        result << 4\n      elsif char == '|'\n        result << 2\n      else\n\
    \        result << 0\n      end\n    end\n  end\n  result\nend", "    music_string\
    \ = music_string.gsub(\" \", \"\") # remove white spaces \n    music_string =\
    \ music_string.gsub(\"|\", \"\")\n    music_string = music_string.gsub(\"|\",\
    \ \"\")\n    music_string = music_string.gsub(\"o\", \"0 \").gsub(\"o\", \"1 \"\
    ).gsub(\"o\", \"2 \").gsub(\"o\", \"3 \").gsub(\"o\", \"4 \")\n    music_string\
    \ = music_string.gsub(\"o|\", \"0 \").gsub(\"o|\", \"1 \").gsub(\"o|\", \"2 \"\
    ).gsub(\"o|\", \"3 \").gsub(\"o|\", \"4 \")\n    music_string = music_string.gsub(\"\
    .|\", \"0 \").gsub(\".|\", \"1 \").gsub(\".|\", \"2 \").gsub(\".|\", \"3 \")\n\
    \    music_string = music_string.gsub(\"o|\", \"0 \").gsub(\"o|\", \"1 \").gsub(\"\
    o|\", \"2 \").gsub(\"o|\", \"3 \").gsub(\"o|\", \"4 \")\n    music_string = music_string.gsub(\"\
    .|\", \"0 \").gsub(\".|\", \"1 \").gsub(\".|\", \"2 \").gsub(\".|\", \"3 \")\n\
    \    music_string = music_string.gsub(\".|\", \"0 \").gsub(\".|\", \"1 \").gsub(\"\
    .|\", \"2 \").gsub(\".|\", \"3 \")\n    music_string = music_string.gsub(\".|\"\
    , \"0 \").gsub(\".|\", \"1 \").gsub(\".|\", \"2 \").gsub(\".|\", \"3 \")\n   \
    \ music_string = music_string.gsub(\".|\", \"0 \").gsub(\".|\", \"1 \").gsub(\"\
    .|\", \"2 \").gsub(\".|\", \"3 \")\n    music_string = music_string.gsub(\".|\"\
    , \"0 \").gsub(\".|\", \"1 \").gsub(\".|\", \"2 \").gsub(\".|\", \"3 \")\n   \
    \ music_string = music_string.gsub(\".|\", \"0 \").gsub(\".|\", \"1 \").gsub(\"\
    .|\", \"2 \").gsub(\".|\", \"3 \")\n    music_string = music_string.gsub(\".|\"\
    , \"0 \").gsub(\".|\", \"1 \").gsub(\".|\", \"2 \").gsub(\".|\", \"3 \")\n   \
    \ music_string = music_string.gsub(\".|\", \"0 \").gsub(\".|\", \"1 \").gsub(\"\
    .|\", \"2 \").gsub(\".|\", \"3 \")\n    music_string = music_", '  music_string
    = music_string.strip', "    # Your code here\n    result = music_string.split(\"\
    |\")\n    music_list = []\n    for i in result:\n        music_list.extend(i.split('o'))\n\
    \    music_list.remove('o|')\n    music_list.remove('|o')\n    music_list = list(set(music_list))\n\
    \    music_list.sort()\n    return music_list\n    ", "  music_string.scan(/[a-z\\\
    -]+|\\d+/).map { |note| note =~ /[a-z\\-]+|\\d+/ ? Note.new(note) : nil }.compact.flatten.group_by\
    \ { |note| note.note }.map do |note|\n    note.last.beats - note.first.beats\n\
    \  end.sort\nend", "  # TODO: your code goes here\nend", "  music_notes = [note[0]=='o'\
    \ for note in music_string.split('|')]\n  last_note_beats = [note.count('o') for\
    \ note in music_string.split('|')]\n  return sum(last_note_beats) % 4\nend", " \
    \ # 'notes' is an array of integers\n  notes = music_string.split('|')\n  # 'counter'\
    \ is a global variable that counts how many beats each note is played in\n  counter\
    \ = 0\n  # 'note_length' is a global variable that holds length of each note (in\
    \ beats)\n  note_length = 0\n  # 'new_notes' is array that stores how many beats\
    \ each note lasts\n  new_notes = []\n  # 'new_notes_len' is a temporary variable\
    \ that holds length of last note\n  new_notes_len = 0\n  # 'new_counter' is temporary\
    \ variable that holds length of last note\n  new_counter = 0\n  # 'new_note_length'\
    \ is temporary variable that holds length of last note\n  new_note_length = 0\n\
    \  # 'new_counter' is temporary variable that holds length of last note\n  new_counter\
    \ = 0\n  # 'new_note_length' is temporary variable that holds length of last note\n\
    \  new_note_length = 0\n  \n  # Now we iterate through all notes (in 'notes' variable)\n\
    \  for note in notes:\n    # Each note is broken down into its individual parts\
    \ (i.e. note, length in beats and number of beats)\n    note_pieces = note.split('\
    \ ')\n    # Each note is broken down into its individual parts (i.e. note, length\
    \ in beats and number of beats)\n    note_pieces_len = len(note_pieces)\n    #\
    \ Counter is a global variable that holds how many beats each note is played in\n\
    \    counter += 1\n    # Note length is number of beats played in each note\n\
    \    note_length += note_pieces_len\n    # Now we iterate through all the beats\
    \ in each note\n    for beat in range(note_pieces_len):\n      # If note last\
    \ beat, add note length to 'new_notes_len'\n      if (beat == note_pieces_len-1):\n\
    \        new_notes_len += note_length\n      # If note last beat, add note length\
    \ to 'new_counter'\n      if (beat == note_pieces_len-1):\n        new_counter\
    \ += counter\n      # If note last beat, add note length to 'new_note_length'\n\
    \      if (beat == note_pieces_len-1):\n        new_note_length += note_length\n\
    \      # If note last beat, add note length to 'new_notes'\n      if (beat ==\
    \ note_pieces_len-1):\n        new_notes.append(note_length)\n      # If not last\
    \ beat, add note length to 'new_note_length'\n      else:\n        new_note_length\
    \ += note_length\n      \n      # Now we iterate through all the beats in each\
    \ note\n      for be", "  music_string.each_char.with_object([]).inject([]) do\
    \ |array, (char, array2)|\n    if char == '.'\n      array2 << 4\n    elsif char\
    \ == 'o'\n      array2 << 4\n    elsif char == '|'\n      array2 << 2\n    else\n\
    \      array2 << 1\n    end\n    array << array2.last\n  end\nend", "  notes =\
    \ music_string.split(' ') # Split string by space\n  notes.map!{|note| note.strip}\
    \ # Remove trailing whitespaces\n  notes.map!{|note| note.downcase.to_sym} # Convert\
    \ string to symbols", "  # Your code goes here\n  result = []\n  note = 'o'\n\
    \  count = 0\n  for c in music_string:\n    count += 1\n    if c == '|':\n   \
    \   result.push((note,count))\n      note = 'o'\n      count = 1\n    elif c ==\
    \ '.':\n      result.push((note,count))\n      note = 'o'\n      count = 1\n \
    \   else:\n      note += c\n  return result\nend", "  music_list = music_string.split('\
    \ ')\n  music_list.reject!{|el| el == 'o'}", "  return music_string.split(\" \"\
    ).map { |s| s.chars.to_a[0].to_i }\nend", "  music_string.each_char.inject([])\
    \ do |acc, letter|\n    case letter\n    when 'o' then acc << 4\n    when 'o|'\
    \ then acc << 2\n    when '.|' then acc << 1\n    else raise \"Unknown musical\
    \ note #{letter}\"\n    end\n  end\nend\n</code>\nIn general, if you need more\
    \ advanced parsing like this, you should write your own parser.\n<|/ a dscore=2\
    \ tags=ruby,algorithm,data-structures |>\n<| c |>\nI should add that this is one\
    \ thing I haven't seen done before, so I have no idea if it is possible or how\
    \ to do it, but I feel like it would be fun enough to write it up.\n<|/ c |>\n\
    <| a dscore=1 |>\nIf you're interested in parsing musical notation, then I suggest\
    \ reading through the Wikipedia article on musical notation. Specifically the\
    \ section on \"A Grammar\"\nhttp://en.wikipedia.org/wiki/Musical_notation#A_grammar\n\
    It's not particularly difficult to construct a grammar that can parse musical\
    \ notation, so you can construct a parser for it. The grammar will probably be\
    \ too complex to read and maintain so you can use a parser generator to generate\
    \ it for you. \nThe Wikipedia page even has a link to an online tool called \"\
    ANTLR\" which can be used to generate the grammar.\n<|/ a tags=ruby,algorithm,data-structures\
    \ |>\n<| a dscore=1 |>\nTo expand on what says, here is another parser generator\
    \ which will parse your input string. It's not really a parser, but rather an\
    \ automated generator.\n<code>\nrequire 'strscan'", "  music_string.scan(/./)\
    \ do |note|\n    if note[-1] == '|'\n      note += '|'\n    else\n      note +=\
    \ ' '\n    end\n    note.scan(/./) do |note_string|\n      if note_string[-1]\
    \ == '|'\n        note_string = note_string.chomp + '|' + note_string.chomp\n\
    \      end\n      if note_string[-1] == 'o'\n        note_string = note_string.chomp\
    \ + '|' + note_string.chomp\n      end\n      if note_string[0] == 'o'\n     \
    \   note_string = note_string.chomp\n      end\n      if note_string[-1] == '\
    \ ' && note_string[0] != ' '\n        note_string = note_string.chomp + ' '\n\
    \      end\n      if note_string[-1] == ' ' && note_string[0] != ' '\n       \
    \ note_string = note_string.chomp\n      end\n      note_string.scan(/../) do\
    \ |beat_count|\n        if beat_count.to_i.even?\n          beat_count.to_i.times\
    \ { |i| beat_count.times { |j| music.push j } }\n        else\n          beat_count.to_i.times\
    \ { |i| music.push i }\n        end\n      end\n    end\n  end\nend\nmusic = []\n\
    parse_music(music_string)\nmusic += [0] * (music_length - music.count)\nmusic\
    \ += [0] * (music_length - music.count)\nmusic += [0] * (music_length - music.count)\n\
    music += [0] * (music_length - music.count)\nmusic += [0] * (music_length - music.count)\n\
    music += [0] * (music_length - music.count)\nmusic += [0] * (music_length - music.count)\n\
    music += [0] * (music_length - music.count)\nmusic += [0] * (music_length - music.count)\n\
    music += [0] * (music_length - music.count)\nmusic += [0] * (music_length - music.count)\n\
    music += [0] * (music_length - music.count)\nmusic += [0] * (music_length - music.count)\n\
    music += [0] * (music_length - music.count)\nmusic += [0] * (music_length - music.count)\n\
    music += [0] * (music_length - music.count)\nmusic += [0] * (music_length - music.count)\n\
    music += [0] * (music_length - music.count)\nmusic += [0] * (music_length - music.count)\n\
    music += [0] * (music_length - music.count)\nmusic += [0] * (music_length - music.count)\n\
    music += [0] * (music_length - music.count)\nmusic += [0] * (music_", "    music_string\
    \ = music_string.strip.split('|')\n    notes = []", "  music_string.scan(/(?:o|.\\\
    |)*/)\nend\n</cell>\n<code language=julia-1.5>", "  note_hashes = music_string.scan(/([a-z])+/)\n\
    \  note_hashes.map! { |note| note.downcase }", '  notes = []', "  music_list =\
    \ music_string.split(' ')\n  music_list = music_list.map { |m| m[0].to_sym }\n\
    \  music_list.shift # remove first item", "    note_symbols = music_string.split('|')\n\
    \    note_ints = []\n    for symbol in note_symbols:\n        if symbol == '.':\n\
    \            note_ints.append(1)\n        elif symbol == 'o':\n            note_ints.append(4)\n\
    \        elif symbol == '|':\n            note_ints.append(2)\n        else:\n\
    \            print('Error! Unknown note symbol: ' + symbol)\n    return note_ints\n\
    \    ", "  music_list = music_string.split(//)\n  \n  beats = []\n  temp = []\n\
    \  temp2 = []\n  \n  for symbol in music_list\n    symbol = symbol.to_s\n    \n\
    \    if symbol == 'o' or symbol == '|'\n      temp2 = temp\n      temp = []\n\
    \      beats.concat(temp2)\n    \n    elsif symbol == '.'\n      temp << 1\n \
    \   else\n      temp << 0\n    end\n  end\n  \n  beats.concat(temp)\nend", '  notes
    = []', "  # TODO: your code goes here\nend", "    music_notes = []\n    i = 0\n\
    \    while i < music_string.length\n        char = music_string[i]\n        if\
    \ char == 'o'\n            music_notes << 4\n            i += 1\n        else\n\
    \            if char == '|'\n                music_notes << 2\n              \
    \  i += 1\n            else\n                music_notes << 1\n              \
    \  i += 1\n            end\n        end\n    end\n    music_notes.reverse\nend\n\
    </cell>\n<text>\nNow let's try to run your implementation", "  # Your code here\n\
    \  music_array.delete_if{|x| x == 'o'}\n  music_array.delete_if{|x| x == 'o|'}\n\
    \  music_array.delete_if{|x| x == '.|'}\n  music_array.delete_if{|x| x == '.'}\n\
    \  music_array.delete_if{|x| x == '-'}\n  music_array.delete_if{|x| x == '?'}\n\
    \  music_array.delete_if{|x| x == '|'}\n  music_array.delete_if{|x| x == '+'}\n\
    \  music_array.delete_if{|x| x == '|'}\n  music_array.delete_if{|x| x == '#'}\n\
    \  music_array.delete_if{|x| x == '/'}\n  music_array.delete_if{|x| x == '&'}\n\
    \  music_array.delete_if{|x| x == ' '}\n  music_array.delete_if{|x| x == '#'}\n\
    \  music_array.delete_if{|x| x == '0'}\n  music_array.delete_if{|x| x == '1'}\n\
    \  music_array.delete_if{|x| x == '2'}\n  music_array.delete_if{|x| x == '3'}\n\
    \  music_array.delete_if{|x| x == '4'}\n  music_array.delete_if{|x| x == '5'}\n\
    \  music_array.delete_if{|x| x == '6'}\n  music_array.delete_if{|x| x == '7'}\n\
    \  music_array.delete_if{|x| x == '8'}\n  music_array.delete_if{|x| x == '9'}\n\
    \  music_array.delete_if{|x| x == '#'}\n  music_array.delete_if{|x| x == '%'}\n\
    \  music_array.delete_if{|x| x == '$'}\n  music_array.delete_if{|x| x == '%'}\n\
    \  music_array.delete_if{|x| x == '^'}\n  music_array.delete_if{|x| x == '&'}\n\
    \  music_array.delete_if{|x| x == ','}\n  music_array.delete_if{|x| x == '@'}\n\
    \  music_array.delete_if{|x| x == '\"'}\n  music_array.delete_if{|x| x == '('",
  "    music_notes = music_string.split(' ')\n    beats = []\n    # Go through the\
    \ music string and collect the number of beats corresponding to each note.\n \
    \   music_notes.each do |note|\n        note = note.chomp\n        if note[0]\
    \ != 'o'\n            # This note is an empty note\n            beats << 0\n \
    \       elsif note[0] == 'o'\n            # This note is a whole note\n      \
    \      beats << 4\n        elsif note[0] == '.' and note[2] == '|' or note[0]\
    \ == '.' and note[1] == '|'\n            # This note is half note, lasts two beats\n\
    \            beats << 2\n        elsif note[0] == 'o' and note[1] == '|' and note[3]\
    \ == '|'\n            # This note is quarter note, lasts one beat\n          \
    \  beats << 1\n        end\n    end\n    music_notes.each do |note|\n        note\
    \ = note.chomp\n        if note[0] != 'o'\n            # This note is an empty\
    \ note\n            beats << 0\n        end\n    end\n    return beats\nend",
  '    music_lines = music_string.split("\n")', "  # your code here\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nWhat is \"music note\"? I do not see \"note\" mentioned\
    \ anywhere in Wikipedia article for ASCII codes. I do not see any character for\
    \ notes. So what does \"music note\" mean? And how does one compute how many beats\
    \ does each note last?\n<|/ c |>\n<| c |>\nYour example has '|' and 'o' on different\
    \ positions in the string, thus this solution will not work. Also, in your solution\
    \ the beats are computed incorrectly. Your code computes how many beats the note\
    \ lasts from the previous note, but in your example it actually computes how many\
    \ beats each note lasts from *two* notes. I do not know what to do with this inaccuracy.\n\
    <|/ c |>\n<| c |>\n, I've added a description of what is music note.\n<|/ c |>\n\
    <| c |>\n, I've added a solution that computes what beats each note lasts. I assume\
    \ that your solution would be more or less the same, but it computes it more efficiently.\n\
    <|/ c |>\n<| a dscore=1 tags=string,parsing,ruby |>\nThe other answers correctly\
    \ use String#rindex and String#slice, which is a good way of doing this, but if\
    \ you just want to see how you might use String#scan, how about:\n<code>\nmusic_string\
    \ = \"o o| .| o| o| .| .| .| .| o o\"", "  music_list = music_string.split('|')\n\
    \  music_list.pop() # get rid of last empty string\n  music_list.pop() # get rid\
    \ of last empty string\n  music_list.map! do |x|\n    if x[0] == 'o'\n      4\n\
    \    elsif x[0] == 'o|'\n      2\n    elsif x[0] == '.|'\n      1\n    else\n\
    \      raise \"Cannot parse #{music_string}\"\n    end\n  end\n  music_list\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=ruby |>\nA regex might help.\
    \ The below will match a string which either starts with 'o' followed by any number\
    \ of spaces and 'o' or an '|' followed by any number of spaces and 'o'. Then it\
    \ will match any number of spaces followed by any number of spaces followed by\
    \ any number of spaces followed by any number of spaces followed by any number\
    \ of spaces followed by any number of spaces followed by any number of spaces\
    \ followed by any number of spaces followed by any number of spaces followed by\
    \ any number of spaces followed by any number of spaces followed by any number\
    \ of spaces followed by any number of spaces followed by any number of spaces\
    \ followed by any number of spaces followed by any number of spaces followed by\
    \ any number of spaces followed by any number of spaces followed by any number\
    \ of spaces followed by any number of spaces followed by any number of spaces\
    \ followed by any number of spaces followed by any number of spaces followed by\
    \ any number of spaces followed by any number of spaces followed by any number\
    \ of spaces followed by any number of spaces followed by any number of spaces\
    \ followed by any number of spaces followed by any number of spaces followed by\
    \ any number of spaces followed by any number of spaces followed by any number\
    \ of spaces followed by any number of spaces followed by any number of spaces\
    \ followed by any number of spaces followed by any number of spaces followed by\
    \ any number of spaces followed by any number of spaces followed by any number\
    \ of spaces followed by any number of spaces followed by any number of spaces\
    \ followed by any number of spaces followed by any number of spaces followed by\
    \ any number of spaces followed by any number of spaces followed by any number\
    \ of spaces followed by any number of spaces followed by any number of spaces\
    \ followed by any number of spaces followed by any number of spaces followed by\
    \ any number of spaces followed by any number of spaces followed by any number\
    \ of spaces followed by any number of spaces followed by any number of spaces\
    \ followed by any number of spaces followed by any number of spaces followed by\
    \ any number of spaces followed by any number of spaces followed by any number\
    \ of spaces followed by any number of spaces followed by any number of spaces\
    \ followed by any number of spaces followed by any number of spaces followed by\
    \ any number of spaces followed by any number of spaces followed by any number\
    \ of spaces followed by any number of spaces followed by any number of space",
  "  notes = music_string.split('|')\n  notes.delete('')\n  notes.each do |note|\n\
    \    if note[-1] == note[-2]\n      note[-1] = note[-2]\n      note[-2] = ''\n\
    \    end\n  end\n  notes.each do |note|\n    note.each_char.with_index do |char,\
    \ index|\n      if char == 'o'\n        notes[index] += 1\n      end\n    end\n\
    \  end\n  notes\nend\n</cell>\n<cell>\nmusic_string = 'o o| .| o| o| .| .| .|\
    \ .| o o'\nmusic = parse_music(music_string)\nmusic\n</cell>\n<text>\nYour task\
    \ is to implement a music player which will play a music from a music_string.\n\
    The music player will play the music in following way:\n- play music in normal\
    \ music order: A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U,\
    \ V, W, X, Y, Z\n- play music in chord order: A, A, A, A, C, B, C, C, C, C, C,\
    \ D, D, D, D, D, D, D, D, D, D, D, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E,\
    \ F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, G, G, G, G, G, G,\
    \ G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G,\
    \ G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G,\
    \ G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G,\
    \ G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G,\
    \ G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G,\
    \ G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G,\
    \ G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G,\
    \ G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G,\
    \ G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, ", "    music_string\
    \ = music_string.lstrip(\"o|\")\n    music_string = music_string.lstrip(\".\"\
    )\n    music_string = music_string.rstrip(\"|\")\n    music_string = music_string.rstrip(\"\
    .\")\n    music_string = music_string.strip(\"o|\")\n    music_string = music_string.strip(\"\
    .\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    .\")\n    music_string = music_string.strip(\"o\")\n    music_string = music_string.strip(\"\
    .\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\".\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|\")\n    music_string = music_string.strip(\"\
    o\")\n    music_string = music_string.strip(\"|", "  notes = []\n  note = \"\"\
    \n  beat = 0\n  for i in range(music_string.size)\n    # Skip whitespace\n   \
    \ while i != 0 and music_string[i] != \" \" do\n      i += 1\n    end\n    # Check\
    \ if this is a note or a chord\n    if music_string[i] == \"o\"\n      note <<\
    \ music_string[i]\n      beat += 4\n    elsif music_string[i] == \"o|\"\n    \
    \  note << music_string[i]\n      beat += 2\n    elsif music_string[i] == \".|\"\
    \n      note << music_string[i]\n      beat += 1\n    else\n      raise \"Unknown\
    \ musical symbol!\"\n    end\n    # Skip whitespace\n    while i != 0 and music_string[i]\
    \ != \" \" do\n      i += 1\n    end\n    # Check if this is the end of note\n\
    \    if i == music_string.size - 1\n      notes << parse_note(note, beat)\n  \
    \    note = \"\"\n      beat = 0\n    end\n  end\n  notes << parse_note(note,\
    \ beat)\n  return notes\nend", "  music_string.scan(/./).map {|n| n.to_i}.reduce(:+).to_a\n\
    end\n</cell>\n<cell>", "    music_notes = []\n    i = 0\n    note = ''\n    while\
    \ i < music_string.length\n        char = music_string[i]\n        if char ==\
    \ 'o'\n            # whole note, lasts 4 beats\n            i += 4\n         \
    \   music_notes << 4\n        elsif char == 'o|'\n            # half note, lasts\
    \ 2 beats\n            i += 2\n            music_notes << 2\n        elsif char\
    \ == '.'\n            # quater note, lasts 1 beat\n            i += 1\n      \
    \      music_notes << 1\n        else\n            # any other note\n        \
    \    note += char\n        end\n    end\n    return music_notes\nend", "  # TODO:\
    \ implement me\nend", "    # your code goes here\n    music_array = []\n    beat_time\
    \ = 0\n    for note in music_string:\n        if note == '.':\n            music_array.append(beat_time)\n\
    \            beat_time = 0\n        else:\n            if note == 'o':\n     \
    \           beat_time += 4\n            elif note == 'o|':\n                beat_time\
    \ += 2\n            else:\n                beat_time += 1\n    music_array.append(beat_time)\n\
    \    return music_array", "  music_list = music_string.split(\" \")\n  music_count\
    \ = []\n  \n  for music in music_list:\n    beat = 0\n    \n    if (music[0] ==\
    \ 'o'):\n      beat_count = 4\n    elif (music[0] == 'o|'):\n      beat_count\
    \ = 2\n    elif (music[0] == '|'):\n      beat_count = 1\n    elif (music[0] ==\
    \ '.|'):\n      beat_count = 1\n    else:\n      beat_count = 0\n      \n    while\
    \ (music_count[beat] != 0):\n      beat += 1\n    \n    music_count.append(beat_count)\n\
    \  return music_count", "  music_string.split(' ').each do |part|\n    if part\
    \ == 'o'\n      beats_per_bar = 4\n    elsif part == 'o|'\n      beats_per_bar\
    \ = 2\n    elsif part == '.|'\n      beats_per_bar = 1\n    else\n      raise\
    \ ArgumentError, \"Invalid music note format: #{part}\"\n    end", "  music_string\
    \ = music_string.split(//).join(' ')\n  music_string = music_string[1..-1]\n \
    \ music_string = music_string.gsub(/\\s+/, ' ')\n  music_array = music_string.split('\
    \ ')\n  music_array.map!(&:to_i)\n  music_array = music_array.select{|note| note\
    \ >= 0 && note <= 127}\n  music_array.sort!\nend", "    music_string = music_string.strip()\
    \ # remove whitespace at beginning and end of the string\n    music_array = []\n\
    \    # for each character in the string\n    for note in music_string:\n     \
    \   # check if the note is a valid note - if it is, append the count to the array\n\
    \        if note == 'o' or note == 'o|' or note == '|':\n            music_array.append(4)\n\
    \        # if the note is '.|' then increment the count\n        elif note ==\
    \ '.|':\n            music_array.append(1)\n        # if the note is not '.|'\
    \ and is not 'o' then append the count to the array\n        else:\n         \
    \   music_array.append(music_string.count(note))\n    return music_array\n</cell>\n\
    <cell>", "  music_array = music_string.split('|')", "    notes = music_string.split('\
    \ ')\n    notes = [note for note in notes if note != '']\n    notes.sort()\n \
    \   \n    beats = [0]\n    \n    for note in notes:\n        if note == 'o':\n\
    \            beats += [0]\n        if note == 'o|':\n            beats += [0,\
    \ 1]\n        if note == '.|':\n            beats += [0, 1, 2]\n        \n   \
    \ return beats\n</cell>\n<cell>\ntest_parse_music()\n</cell>\n<text>\nTask 2:\
    \ Write a function that takes note duration in beats and returns number of octaves\n\
    Example: 4 beat note duration returns 4\nExample: 8 beat note duration returns\
    \ 3\nExample: 9 beat note duration returns 3", '    music_string.replace(" ",
    "") # remove white space', "  music_string = music_string.strip\n  music_array\
    \ = music_string.split(' ')\n  music_array = (music_array + music_array).sort\n\
    \  music_array.reverse", "  music_string.scan(/[\\.\\|\\-](?=[o|o]{1}|$)/).map\
    \ do |note|\n    if note[1] == 'o'\n      4\n    elsif note[1] == 'o|'\n     \
    \ 2\n    else\n      1\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ |>\n<code>", "  # YOUR CODE HERE\n  music_list = music_string.split(\" \")\n\
    \  music_beats = [0, 0, 0, 0]\n  music_nums = []\n  for music_note in music_list:\n\
    \    if music_note == \"o\":\n      music_beats[0] += 1\n      music_nums.append(music_beats[0])\n\
    \    elif music_note == \"o|\":\n      music_beats[1] += 1\n      music_nums.append(music_beats[1])\n\
    \    elif music_note == \".|\":\n      music_beats[2] += 1\n      music_nums.append(music_beats[2])\n\
    \    elif music_note == \"|o\":\n      music_beats[3] += 1\n      music_nums.append(music_beats[3])\n\
    \    elif music_note == \".|o\":\n      music_beats[3] += 1\n      music_nums.append(music_beats[3])\n\
    \    elif music_note == \"|.\":\n      music_beats[3] += 1\n      music_nums.append(music_beats[3])\n\
    \    elif music_note == \"|.o\":\n      music_beats[3] += 1\n      music_nums.append(music_beats[3])\n\
    \    elif music_note == \"|.|\":\n      music_beats[3] += 1\n      music_nums.append(music_beats[3])\n\
    \    elif music_note == \".|.|\":\n      music_beats[3] += 1\n      music_nums.append(music_beats[3])\n\
    \  return music_nums\n</cell>\n<cell>", "  # Your code here\n  return []\nend",
  "  music_chars = music_string.split('|')\n  parsed_music_chars = []", "  music_string\
    \ = music_string.rstrip\n  music_string = music_string.lstrip\n  music_string\
    \ = music_string.strip\n  music_string = music_string[0..-2]", "  music_notes\
    \ = ['o']\n  music_notes.extend(music_string.split('|'))\n  music_notes.extend(['o']\
    \ * 6)\n  music_notes.extend(['.'] * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend(['.']\
    \ * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend('.' * 7)\n  music_notes.extend('o'\
    \ * 6)\n  music_notes.extend(['.'] * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend(['.']\
    \ * 7)\n  music_notes.extend('.' * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend(['.']\
    \ * 7)\n  music_notes.extend('.' * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend(['.']\
    \ * 7)\n  music_notes.extend('.' * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend(['.']\
    \ * 7)\n  music_notes.extend('.' * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend(['.']\
    \ * 7)\n  music_notes.extend('.' * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend(['.']\
    \ * 7)\n  music_notes.extend('.' * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend(['.']\
    \ * 7)\n  music_notes.extend('.' * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend(['.']\
    \ * 7)\n  music_notes.extend('.' * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend(['.']\
    \ * 7)\n  music_notes.extend('.' * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend(['.']\
    \ * 7)\n  music_notes.extend('.' * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend(['.']\
    \ * 7)\n  music_notes.extend('.' * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend(['.']\
    \ * 7)\n  music_notes.extend('.' * 7)\n  music_notes.extend('o' * 6)\n  music_notes.extend(['.']\
    \ * 7)\n  music_notes.extend('.' * 7)\n  music_notes.extend", "  # Your code here\n\
    end", "  music_string.scan(/(.)(\\|)(.)/).collect { |n| n.to_i(16) }\nend", " \
    \ notes = []\n  music_string.split(\" \").each do |m|\n    note, beat_count =\
    \ m.split(\"|\").map(&:to_i)\n    notes << note.zero? ? beat_count : note.to_i\
    \ + beat_count\n  end\n  notes\nend\n</code>\n<|/ a |>\n<| a |>\nThis is my take\
    \ on it. It basically converts the string to an array and then finds the largest\
    \ integer and divides by the count of that note. \n<code>", "  # Your code here\n\
    \  return music_string.count(\"o\") * 4\nend", "  music_string = music_string.chomp\n\
    \  music_list = music_string.split(' ').map do |note|\n    if note.empty?\n  \
    \    0\n    else\n      case note[0]\n      when 'o'\n        if note.length <=\
    \ 4\n          note.length.to_i\n        elsif note.length <= 5\n          5\n\
    \        else\n          6\n        end\n      when 'o|'\n        if note.length\
    \ <= 3\n          note.length.to_i\n        elsif note.length <= 4\n         \
    \ 5\n        else\n          6\n        end\n      when '.|'\n        if note.length\
    \ <= 1\n          1\n        else\n          2\n        end\n      else\n    \
    \    0\n      end\n    end\n  end\n  music_list.compact\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks a lot for answering. I tried to run your code but it's not\
    \ working properly. As I have mentioned above, if the first note is not 'o', it\
    \ must ignore all the remaining notes. For example, for the string 'o|o o|o|',\
    \ the output should be [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4], but it is giving the\
    \ output [4, 2, 1, 1, 1, 1, 4, 4].\n<|/ c |>\n<| a tags=ruby,ruby-on-rails dscore=1\
    \ |>\nI believe this problem can be reduced to finding the correct count of beats\
    \ to any given length. The code below does this by taking the first note on the\
    \ string and calculating the correct number if beats to it.\n<code>", "  music_string.scan(/\\\
    d/) do |note|\n    note = note.to_i\n    note_length = note.modulo(2) == 0 ? 4:\
    \ 1\n    note_length = note_length * note\n    note_length\n  end\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails dscore=1 |>\n<| c |>\nWhat if I had more notes?\
    \ The example I gave was just an example to demonstrate my goal\n<|/ c |>\n<|\
    \ c |>\nThe regex `/\\d/` matches any single digit. You can use `/[\\d+]/.` to\
    \ match one or more digits.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\nHere is\
    \ another approach:\n<code>\nmusic = MusicParser.new.parse('o o o')", "  # Your\
    \ code here\nend\n</cell>\n<text>\nAfter you implemented this function, running\
    \ the following cell should print [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].", "  music_string\
    \ = music_string.split(//).join('')", "    music_string = music_string.strip()\
    \ # remove leading and trailing spaces and newlines\n    music_string = ''.join(music_string.split('\
    \ ')) # get rid of multiple spaces, get one string\n    music_string = music_string.replace('|',\
    \ '') # remove pipes\n    music_string = music_string.split('o') # split by o\n\
    \    music_string = [x.strip() for x in music_string] # get rid of leading and\
    \ trailing spaces\n    music_string = [int(x) if x != 'o' else 'o' for x in music_string]\
    \ # convert string to integers and remove o's\n    music_string = music_string[::2]\
    \ # split list into odd and even parts\n    music_string = [x * 4 for x in music_string]\
    \ # take number of beats per note and multiply by 4\n    return music_string\n\
    </cell>\n<cell>\nassert parse_music('o o| .| o| o| .| .| .| .| o o') == [4, 2,\
    \ 1, 2, 2, 1, 1, 1, 1, 4, 4]\n</cell>\n<cell>", "  music_string.split('|').each\
    \ do |note|\n    note = note.split(' ')\n    note[0] = [note[0][0], note[0][2],\
    \ note[0][4]]\n    note[1] = [note[1][0], note[1][2], note[1][4]]\n    note[2]\
    \ = [note[2][0], note[2][2], note[2][4]]\n    note = [note[0], note[1], note[2]]\n\
    \    note.each do |i|\n      note.each do |i|\n        note.each do |i|\n    \
    \      note.each do |i|\n            note.each do |i|\n              note.each\
    \ do |i|\n                note.each do |i|\n                  note.each do |i|\n\
    \                    note.each do |i|\n                      note.each do |i|\n\
    \                        note.each do |i|\n                          note.each\
    \ do |i|\n                            note.each do |i|\n                     \
    \         note.each do |i|\n                                note.each do |i|\n\
    \                                  note.each do |i|\n                        \
    \            note.each do |i|\n                                      note.each\
    \ do |i|\n                                        note.each do |i|\n         \
    \                                 note.each do |i|\n                         \
    \                   note.each do |i|\n                                       \
    \       note.each do |i|\n                                                note.each\
    \ do |i|\n                                                  note.each do |i|\n\
    \                                                    note.each do |i|\n      \
    \                                                note.each do |i|\n          \
    \                                              note.each do |i|\n            \
    \                                              note.each do |i|\n            \
    \                                                note.each do |i|\n          \
    \                                                    note.each do |i|\n      \
    \                                                          note.each do |i|\n\
    \                                                                  note.each do\
    \ |i|\n                                                                    note.each\
    \ do |i|\n                                                                   \
    \ note.each do |i|\n                                                         \
    \           note.each do |i|\n                                               \
    \                     note.each do |i|\n                                     \
    \                               note.each do |i|\n                           \
    \                                         note.each do |i|\n                 \
    \                                                   note.each do |i|\n       \
    \                                                             note.each do |i|\n\
    \                                                                    note.each\
    \ do |i|\n                                                                   \
    \ note.each do |i|\n                                                         \
    \           note.each do |i|\n                                               \
    \                     note.each do |i|\n                                     \
    \                               note.each do |i|\n                           \
    \                                         note.each do |i|\n                 \
    \                                                   note.each do |i|\n       \
    \                                                             note.each do |i|\n\
    \                                                                    note.each\
    \ do |i|\n                                                                   \
    \ note.each do |i|\n                                                         \
    \           note.each do |i|\n                                               \
    \                     note.each do |i|\n                                ", " \
    \ # Your code here\n  return []\nend", "  music_string.scan(/([a-z])/).flatten.map\
    \ do |note|\n    note.match('o').nil? ? 4 : note.match('o|') ? 2 : note.match('.|')\
    \ ? 1 : 0\n  end\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nThe regex\
    \ is wrong. `\"o o| .| o| o| .| .| .| .| o o\".scan(/([a-z])/).flatten.map { |note|\
    \ note.match('o').nil? ? 4 : note.match('o|') ? 2 : note.match('.|') ? 1 : 0 }`\
    \ is `[4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]`\n<|/ c |>\n<| c |>\nAgreed, but it's\
    \ not the only bug in the code. There are other bugs besides that.\n<|/ c |>\n\
    <| c |>\nI agree. But it took me a while to figure out what OP is trying to do.\
    \ I'm leaving my comment as is.\n<|/ c |>\n<| c |>\nYes, I agree. I've commented\
    \ my own answer with my understanding of the problem.\n<|/ c |>\n<| c |>\nI understand\
    \ your comment, I just thought that the OP might find this helpful.\n<|/ c |>\n\
    <| a |>\nI believe that this is the most succinct and maintainable way to write\
    \ the code:\n<code>", "  music_string.reverse!\n  music_string[0, 2] = 'o|'.b\n\
    \  music_string.slice!(2..-1)\n  music_string.chars.map { |c| c.ord.to_i }\nend",
  "  music_string.upcase!\n  music_string.gsub!(/\\s+/, ' ')\n  music_string.gsub!(/./){|c|\
    \ BEAT_STATEMENTS[:BEATS].has_key?(c) ? BEAT_STATEMENTS[:BEATS][c] : BEAT_STATEMENTS[:OTHER_CHARS][c]}\n\
    \  music_string.gsub!(/o|/){|c| BEAT_STATEMENTS[:HALF_NOTES].has_key?(c) ? BEAT_STATEMENTS[:HALF_NOTES][c]\
    \ : BEAT_STATEMENTS[:OTHER_CHARS][c]}\n  music_string.gsub!(/\\.\\|/){|c| BEAT_STATEMENTS[:QUARTER_NOTES].has_key?(c)\
    \ ? BEAT_STATEMENTS[:QUARTER_NOTES][c] : BEAT_STATEMENTS[:OTHER_CHARS][c]}\n \
    \ music_string.split(\" \").inject([]){|acc,e| e == \".\" ? (acc << BEAT_STATEMENTS[:OTHER_CHARS][acc[-1]],\
    \ acc << BEAT_STATEMENTS[:OTHER_CHARS][acc[-1]]) : acc << BEAT_STATEMENTS[:BEATS][e]}.inject(:+)\n\
    end\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails dscore=1 |>\n<| a tags=ruby,algorithm,ruby-on-rails\
    \ |>\nHere's my solution using only a regex (no loops, no conditionals, and no\
    \ hash-access):\n<code>\nmusic = \" o o| .| o| o| .| .| .| .| .| o o \"", "  music_list\
    \ = music_string.split('|')\n  beats = []\n  beat = 0\n  music_list.each do |music|\n\
    \    if music.include? 'o'\n      beat += 1\n    end\n    if music.include? 'o|'\n\
    \      beat += 2\n    end\n    if music.include? '.|'\n      beat += 1\n    end\n\
    \    beats.push(beat)\n  end\n  beats\nend", "  music_string.split(\" \").map(&:strip).map(&:chars).map\
    \ do |chars|\n    if chars.include?(\"|\")\n      chars.split(\"|\").map(&:to_i).inject(0)\
    \ {|sum, note| sum + note}\n    else\n      chars.to_i\n    end\n  end\nend",
  "    notes = []\n    notes_array = []\n    notes_array.push(music_string)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n    notes_array.pop(0)\n\
    \    notes_array.pop(0)\n    notes_", "  music_string.scan(/./) do |letter|\n\
    \    case letter\n    when '.', 'o'\n      return 4\n    when '|', 'o'\n     \
    \ return 2\n    else\n      return 1\n    end\n  end\n  0\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| c |>\nThanks! This is very helpful.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "    # Your code here\n    music_array = music_string.split(' ')\
    \ # Split music string on white space\n    music_array = [music_array[i] for i\
    \ in range(len(music_array)) if not music_array[i] == ''] # Remove empty strings\n\
    \    music_array = [int(music_array[i]) for i in range(len(music_array)) if music_array[i]\
    \ == 'o']\n    music_array = [music_array[i] for i in range(len(music_array))\
    \ if music_array[i] == 'o|']\n    music_array = [music_array[i] for i in range(len(music_array))\
    \ if music_array[i] == '.|']\n    return music_array\n</cell>\n<cell>", "  parsed_music\
    \ = music.parse(music_string)\n  parsed_music.flat_map {|tuple| tuple[1].split(//)}\n\
    end", "  # Your code here\n  music_string.downcase!\n  notes = music_string.split(//)\n\
    \  \n  note_counter = 0\n  music_list = []", "    # remove white spaces, split\n\
    \    notes = music_string.strip().split(\" \")\n    notes_ints = []\n    # process\
    \ notes\n    for i in notes:\n        if i == \"o\":\n            notes_ints.append(4)\n\
    \        elif i == \"o|\":\n            notes_ints.append(2)\n        elif i ==\
    \ \".|\":\n            notes_ints.append(1)\n        else:\n            raise\
    \ Exception(\"Incorrect note name: \" + i)\n    return notes_ints\n</cell>\n<cell>",
  "    music_string.strip.each_char do |char|\n        note, beats = char\n      \
    \  note = note.upcase == 'O'\n        beats = char == '.'\n        return beats\
    \ if note\n    end\n    raise InvalidNoteError\nend", "    note_list = []\n  \
    \  beat_counter = 0\n    music_string = music_string.replace(' ', '')\n    music_string\
    \ = music_string.replace('o', '  ')\n    music_string = music_string.replace('|',\
    \ '  ')\n    music_string = music_string.replace('.', '  ')\n    music_string\
    \ = music_string.split('  ')\n    for note in music_string:\n        beat_counter\
    \ += 1\n        if note == '':\n            note_list.append(beat_counter)\n \
    \       else: \n            note_list.append(int(note))\n    return note_list",
  "    music = []\n    current_note = None\n    current_beat = 0\n    for note in\
    \ music_string.split(' ')\n        if note == 'o'\n            music.push current_beat\n\
    \            current_beat = 0\n            current_note = 'o'\n        elsif note\
    \ == 'o|'\n            current_beat = 2\n            current_note = 'o|'\n   \
    \     elsif note == '.'\n            current_beat = 1\n            current_note\
    \ = '.'\n        end\n    end\n    music.push current_beat\n    return music\n\
    end", "  music_string = ''.join(music_string)\n  music_list = re.findall(r'o|\\\
    .\\|', music_string)\n  music_list = [] + re.findall(r'o\\|', music_string) +\
    \ re.findall(r'\\.\\|', music_string)\n  music_list = [int(x) for x in music_list]\n\
    \  music_list.reverse()\n  return music_list\nend", "  music_list = music_string.split('\
    \ ')\n  beats_per_note = [4 / len(music_list)] * 4\n  notes = music_list\n  notes.each\
    \ do |note|\n    if note == 'o'\n      notes.push('o')\n      notes.each { |n|\
    \ beats_per_note.push(n) }\n    elsif note == 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      notes.unshift 'o|'\n\
    \      notes.unshift 'o|'\n      notes.unshift 'o|'\n      note", "  music_array\
    \ = []\n  notes = []\n  music_string = music_string.split(' ')\n  music_array.concat(music_string)\n\
    \  music_array.uniq!\n  music_array.each_index do |i|\n    notes.concat((music_array[i].split('|').last.to_i))\n\
    \  end\n  return notes\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays\
    \ |>\nI took the liberty of making your code more ruby-like and using a regex\
    \ to capture the beat count from the string. This regex looks for anything that\
    \ starts with a letter and a dot, then any number of digits then ends with an\
    \ o. I'm capturing the numbers in an array which is returned at the end of the\
    \ method.\n<code>", '  music_string.strip!', "  music_string = music_string.to_s.lstrip\n\
    \  music_string[music_string.index('|')].reverse if music_string.index('|')\n\
    \  parts = music_string.scan(/(?=\\.|\\|)/)\n  total_notes = parts.count\n  rest\
    \ = music_string.scan(/\\|/).last || []\n  beat_periods = rest.count / total_notes\n\
    \  beat_periods.times do |i|\n    notes = parts.slice(i * total_notes, (i + 1)\
    \ * total_notes)\n    notes.map! {|note| note.to_i}\n    notes\n  end\nend\n</cell>\n\
    <cell>\n%q[\n Part 1: \n  Given a musical string, you need to write code that\
    \ will return the number of beats \n  each note lasts. For example:\n  \n  Input:\
    \ \u2018o o| .| o| o| .| .| .| .| o o\u2019 \n  Output: [4, 2, 1, 2, 2, 1, 1,\
    \ 1, 1, 4, 4]\n Part 2: \n  Given a musical string, you need to write code that\
    \ will return the number of beats \n  each note lasts. For example:\n  \n  Input:\
    \ \u2018o o| .| o| o| .| .| .| .| o o\u2019 \n  Output: [4, 2, 1, 2, 2, 1, 1,\
    \ 1, 1, 4, 4]\n]\n</cell>\n<cell>\n%q[\n Part 1: \n  Given a musical string, you\
    \ need to write code that will return the number of beats \n  each note lasts.\
    \ For example:\n  \n  Input: \u2018o o| .| o| o| .| .| .| .| o o\u2019 \n  Output:\
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n Part 2: \n  Given a musical string, you\
    \ need to write code that will return the number of beats \n  each note lasts.\
    \ For example:\n  \n  Input: \u2018o o| .| o| o| .| .| .| .| o o\u2019 \n  Output:\
    \ [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n]\n</cell>\n<cell>\n%q[\n Part 1: \n  Given\
    \ a musical string, you need to write code that will return the number of beats\
    \ \n  each note lasts. For example:\n  \n  Input: \u2018o o| .| o| o| .| .| .|\
    \ .| o o\u2019 \n  Output: [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n Part 2: \n  Given\
    \ a musical ", "  music_string.scan(/[\\.\\|]/).map(&:downcase).\n    select {\
    \ |char| char != 'o' && char != 'O' }.\n    map { |char| note_to_freq[char] }\n\
    end", "  music_string = music_string.gsub(/\\s*\\|\\s*/, '|')\n  music_string\
    \ = music_string.gsub(/\\s*o\\s*/, '|o')\n  music_string = music_string.gsub(/\\\
    s*\\|o\\s*/, '||o')\n  music_string = music_string.gsub(/\\s*\\.\\|\\s*/, '|.|')\n\
    \  music_string = music_string.gsub(/\\s*\\|\\.\\|\\s*/, '||.|')\n  music_string\
    \ = music_string.gsub(/\\s*\\|o\\|\\s*/, '|o|')\n  music_string = music_string.gsub(/\\\
    s*\\|o\\|o\\s*/, '|o|o')\n  music_string = music_string.gsub(/\\s*o\\|o\\s*/,\
    \ 'o|o')\n  music_string = music_string.gsub(/\\s*o\\|\\s*/, 'o|')\n  music_string\
    \ = music_string.gsub(/\\s*\\.\\|o\\s*/, '.|o')\n  music_string = music_string.gsub(/\\\
    s*\\.\\|o\\|\\s*/, '.|o|')\n  music_string = music_string.gsub(/\\s*\\.\\|o\\\
    |o\\s*/, '.|o|o')\n  music_string = music_string.gsub(/\\s*\\.\\|.\\|\\s*/, '.|.')\n\
    \  music_string = music_string.gsub(/\\s*\\.\\|.\\|o\\s*/, '.|o')\n  music_string\
    \ = music_string.gsub(/\\s*\\.\\|.\\|o\\|\\s*/, '.|o|')\n  music_string = music_string.gsub(/\\\
    s*\\.\\|.\\|o\\|o\\s*/, '.|o|o')\n  music_string = music_string.gsub(/\\s*\\.\\\
    |.\\|\\.\\|\\s*/, '.|.|')\n  music_string = music_string.gsub(/\\s*\\.\\|.\\|\\\
    .\\|o\\s*/, '.|o|')\n  music_string = music_string.gsub(/\\s*\\.\\|.\\|\\.\\|o\\\
    |\\s*/, '.|o|o')\n  music_string = music_string.gsub(/\\s*\\.\\|.\\|\\.\\|\\.\\\
    |\\s*/, '.|.|.')\n  music_string = music_string.gsub(/\\s*\\.\\|.\\|\\.\\|\\.\\\
    |o\\s*/, '.|o|')", "  music_string[0..6] =~ /^[0-4]$/\n  music_string[6..12] =~\
    \ /^[0-4]$/", "  music_string.chomp!\n  music_string.downcase!\n  \n  # Initialize\
    \ result with 0s\n  result = [0,0,0,0,0,0,0,0]\n  \n  # Iterate over notes and\
    \ update result with beat number if note is valid\n  music_string.each_char do\
    \ |char|\n    note, beats = parse_note(char)\n    result[note] += beats\n  end\n\
    \  \n  # Return result\n  result\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
