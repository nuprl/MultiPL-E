name: HumanEval_59_largest_prime_factor
language: rb
prompt: "# Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  # >>> largest_prime_factor(13195)\n# 29\n# >>> largest_prime_factor(2048)\n# 2\n\
  def largest_prime_factor(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_prime_factor\n\
  \    candidate = method(:largest_prime_factor)\n    assert_equal(5, candidate.call(15))\n\
  \    assert_equal(3, candidate.call(27))\n    assert_equal(7, candidate.call(63))\n\
  \    assert_equal(11, candidate.call(330))\n    assert_equal(29, candidate.call(13195))\n\
  \  end\nend\n"
completions: ["  n = n.to_i\n  factors = []\n  i = 1\n  while i < n do\n    while\
    \ (n % i == 0) do \n      i += 1\n    end\n    if i == n\n      return factors\
    \ << i\n    end\n    i += 1\n  end\nend", "  return n if n <= 1 \n  \n  # Sieve\
    \ of Eratosthenes\n  limit = (n.to_i**0.5).round\n  (2..limit).to_a.each do |i|\n\
    \    candidate = n.i**((i-1)/2).round\n    if candidate % n == 0\n      candidate\
    \ = candidate.to_i**(i/2).round\n      break candidate if (candidate <= limit)\n\
    \    end\n  end\nend", "  largest_factor = 1\n  factor = 2\n  while n != 1\n \
    \   factor += 1\n    if n % factor == 0\n      while n % (factor * 2) == 0 \n\
    \        factor += 1\n      n = n / factor\n    else\n      n = n\n    end\n \
    \   largest_factor = factor\n  end\n  largest_factor\nend", "  factors = []\n\
    \  i = 3\n  while i < n do\n    if n % i == 0 then\n      factors.push(i)\n  \
    \    n = n / i\n    else\n      i += 1\n    end\n  end\n  factors\nend", "  factors,\
    \ primes = factor(n), []\n  n.times do\n    primes << factors.shift\n  end\n \
    \ primes.compact.max\nend", "  if n<2\n    puts \"*** Error: No prime factor of\
    \ #{n}!\"\n  else\n    factor=0\n    for k in 2..n\n      if n%k==0\n        break\n\
    \      else\n        factor+=1\n      end\n    end\n    puts \"#{n}'s largest\
    \ prime factor is #{factor}\"\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Ah, I see... the problem is with the second for loop. I think I fixed it with\
    \ a different method but this works. Thank you!\n<|/ c |>\n<| a |>\n<code>", " \
    \ i = 1\n  factor = 1\n  while i * i <= n\n    i += 1\n    while n % i == 0\n\
    \      factor += 1\n      n /= i\n  factor\nend", "  sieve = Array.new\n  prime_numbers\
    \ = Array.new\n  2\n  until n > 1 do\n    break if sieve.length == n\n    if sieve.include?\
    \ n then\n      prime_numbers << n\n      break\n    end\n    i = 2\n    while\
    \ i * i <= n do\n      sieve[i * i::i*2] = false\n      i += 1\n    end\n  end\n\
    \  prime_numbers[0..(prime_numbers.length - 1)].max\nend", "  primes = [2]\n \
    \ i = 2\n  while i < n do\n    if (n % primes.last) != 0 then\n      primes <<\
    \ i\n      n /= primes.last\n    end\n    i += 1\n  end\n  primes << n\n  primes.reverse!\n\
    \  primes.last\nend", "  a = 2\n  while true\n    if n % a == 0\n      return\
    \ a\n    a += 1\n    n /= a\n  end\nend\n</cell>\n<code language=julia-0.5>",
  "  i = 1\n  while i * i <= n\n    i += 1\n  i = 1\n  while i * i <= n and n % i\
    \ == 0\n    i += 1\n  i = 1\n  while i * i <= n and n % i == 0\n    i += 1\n \
    \ return i\nend", "  return factor(n).inject(:*)\nend", "  primes = factor(n)\n\
    \  return primes[primes.length - 1]\nend", "  factor = 1\n  while n % factor >\
    \ 0\n    factor += 1\n    n /= factor\n  return factor\nend", "  if n <= 1\n \
    \   then return n\n  end", "  prime_found = false\n  largest_factor = 1\n  (2..n\
    \ / 2).each do |factor|\n    break if prime_found\n    prime_found = true if n\
    \ % factor == 0\n    if prime_found\n      largest_factor = factor\n    end\n\
    \  end\n  largest_factor\nend", "    factors = []\n    if n == 1 then\n      \
    \  factors = [1]\n        return factors[0]\n    factor = 1\n    while n > 1 do\n\
    \        if n % factor == 0 then\n            factors << factor\n            n\
    \ /= factor\n        else\n            factor += 1\n        end\n    end\n   \
    \ if n > 1 then\n        factors << n\n    end\n    return factors[-1]\nend",
  "  primes = primes(n)\n  return primes.size if primes.size == 0 else primes.max.first\n\
    end", "    return n if n < 2 else 3 * largest_prime_factor(n / 3) if n > 2 else\
    \ n\nend", "    # Factor the prime factors of n.\n    # Each prime factor of n\
    \ is represented by a tuple (i, e), where i and e\n    # are the prime factors\
    \ of n and e is the exponent.\n    # In total, the prime factors of n are (2k**2,\
    \ 3k**2, 4k**2, 5k**2,\n    # 6k**2, 7k**2, 8k**2, 9k**2, 10k**2+1**2, 11k**2,\
    \ 12k**2, 13k**2+1**2,\n    # 14k**2, 15k**2, 16k**2, 17k**2, 18k**2+1**2, 19k**2,\
    \ 20k**2+1**2, 21k**2,\n    # 22k**2, 23k**2, 24k**2, 25k**2, 26k**2, 27k**2,\
    \ 28k**2, 29k**2, 30k**2+1**2,\n    # 31k**2, 32k**2, 33k**2, 34k**2, 35k**2,\
    \ 36k**2, 37k**2, 38k**2, 39k**2+1**2,\n    # 40k**2, 41k**2, 42k**2, 43k**2,\
    \ 44k**2, 45k**2, 46k**2, 47k**2, 48k**2, 49k**2+1**2,\n    # 50k**2, 51k**2,\
    \ 52k**2, 53k**2, 54k**2, 55k**2, 56k**2, 57k**2, 58k**2, 59k**2+1**2,\n    #\
    \ 60k**2, 61k**2, 62k**2, 63k**2, 64k**2, 65k**2, 66k**2, 67k**2, 68k**2, 69k**2+1**2,\n\
    \    # 70k**2, 71k**2, 72k**2, 73k**2, 74k**2, 75k**2, 76k**2, 77k**2, 78k**2,\
    \ 79k**2+1**2,\n    # 80k**2, 81k**2, 82k**2, 83k**2, 84k**2, 85k**2, 86k**2,\
    \ 87k**2, 88k**2, 89k**2+1**2,\n    # 90k**2, 91k**2, 92k**2, 93k**2, 94k**2,\
    \ 95k**2, 96k**2, 97k**2, 98k**2, 99k**2+1**2)\n    # Find the prime factors of\
    \ n.\n    # These must be greater than one and less than n.\n    # They are represented\
    \ by a tuple (i, e), where i is the prime factor\n    # of n and e is the exponent.\n\
    \    # In total, the prime factors of n are (2k**2, 3k**2, 4k**2, 5k**2,\n   \
    \ # 6k**2, 7k**2, 8k**2, 9k**2, 10k**2+1**2, 11k**2, 12k**2, 13k**2+1**2,\n  \
    \  # 14k**2, ", "  factor = 1\n  i = 1\n  while i * i <= n\n    if n % i == 0\n\
    \      factor = i\n      break\n    i += 1\n  return factor\nend", "  if n ==\
    \ 0\n    puts \"The smallest prime factor is 2.\"\n  else\n    largest = 0\n \
    \   (2..n/2).each do |i|\n      if n % i == 0\n        largest = i\n        break\n\
    \      end\n    end\n    puts largest if largest != 0\n  end\nend\n</code>\n<|/\
    \ a tags=ruby dscore=2 |>\n<| a |>\nA simple solution with no loops and no conditional\
    \ statements:\n<code>", "  i = 1\n  factor = 2", "  return n if n <= 1 else largest_prime_factor(n\
    \ / 2)\nend", "  i = 1\n  factor = 1\n  while i <= n and factor < n\n    i +=\
    \ 1\n    factor *= i\n  end\n  factor\nend", "  factors = []\n  loop do\n    prime\
    \ =\n      2\n    until n /= prime\n    factors << prime\n  end\n  factors.max\n\
    end", "  factor = 1\n  while n > 1\n    factor += 1\n    if n % factor == 0\n\
    \      n /= factor\n    else\n      n = 1\n    end\n  end\n  factor\nend", " \
    \   return factorization(n)[1]\nend", "  return prime_list_factor(n).max\nend",
  "  return p | 1 << (n & -p).ceil\nend", "  if n < 2\n    1\n  else\n    d = 2\n\
    \    while d < n\n      if n % d == 0\n        return d\n      else\n        d\
    \ = d + 2\n  end\nend", '  factors = []', "  a = 1\n  b = 2\n  while b <= n /\
    \ 2\n    if n % b == 0\n      break\n    a = b\n    b = b * 2 + 1\n  end\n  return\
    \ a\nend", "  return prime_table_lookup(n).max\nend", "  largest_prime = 1\n \
    \ i = 2\n  while i * i <= n\n    # keep incrementing i until there is no more\
    \ i that divides n.\n    while n % i == 0\n      i += 1 \n      # n is not a factor\
    \ of i. \n      # increment i until it divides n.\n      while n % i == 0\n  \
    \      i += 1\n        n /= i \n    largest_prime = i \n    i += 1\n  end\n  \n\
    \  largest_prime\nend", "  prime_array = []\n  while true\n    if n % 2 == 0\n\
    \      prime_array << 2\n      n /= 2\n    else\n      prime_array << 1\n    \
    \  n /= 2\n    end\n    if n == 1\n      return prime_array\n    end\n    i =\
    \ 0\n    break if prime_array.each do |prime|\n      break if n%i\n      i +=\
    \ 1\n      n /= prime\n    end\n  end\nend\n</code>\n<|/ a tags=primes,ruby |>\n\
    <| c |>\nThis code worked like a charm! Thank you so much!\n<|/ c |>\n<| c |>\n\
    Nice algorithm! It takes O(sqrt(n)) time to calculate the factors and doesn't\
    \ require any libraries. And it makes sense to use `prime_array` since `i` will\
    \ never exceed `prime_array.length`\n<|/ c |>\n<| a tags=primes,ruby |>\nHere\
    \ is the code snippet I wrote to solve a similar problem\n<code>\n  def prime_factors(n)\n\
    \    factors = []\n    (2..(n/2)-1).each do |i|\n      break if n % i == 0\n \
    \     factors.push(i)\n    end\n    factors\n  end", "  return find_largest_prime_factor(n)\
    \ if n != 1 else n\nend", "  factors = 1\n  while n > 1\n    (factors << 1) if\
    \ n % factors == 0\n      factors = factors + 1\n      n /= factors\n  factors\n\
    end", "  factors = []\n  i = 1\n  while i * i <= n\n    i += 1\n    while n %\
    \ i == 0\n      factors << i\n      n /= i\n    factors << n\n  end\n  factors.max\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| c |>\nJust in case you're unfamiliar, \"<<\"\
    \ means \"push\". \"<<=\" means \"push and assign at the same time\".\n<|/ c |>\n\
    <| c |>\nThanks, it's been a while since I've done Ruby, but I do appreciate the\
    \ example.\n<|/ c |>\n<| c |>\nWhat is the point of factors in your example? I\
    \ don't get it.\n<|/ c |>\n<| c |>\n`factors` just holds the factors of `n` from\
    \ 1 to the largest prime factor of `n`.  It could be written more simply as `i\
    \ = 2 ; factors = [] ; while i * i <= n ; i += 1; while n % i == 0 ; factors <<\
    \ i ; n /= i ; factors << n; end`.\n<|/ c |>\n<| c |>\nThe key point of this is\
    \ the `while i` and related `while` statements are the outer loops.  The inner\
    \ loops just iterate through all of the factors of `n` starting at `1` and stopping\
    \ when the next factor is larger than `n`.\n<|/ c |>\n<| a dscore=3 tags=ruby,algorithm,prime\
    \ |>\n<code>\nrequire 'prime'", "  largest_divisor = 1\n  while n > 1\n    if\
    \ n % largest_divisor\n      largest_divisor += 1\n      n /= largest_divisor\n\
    \    else\n      n /= largest_divisor\n      largest_divisor -= 1\n    end\n \
    \ end\n  largest_divisor\nend\n</pre>", "  if n.factors == []\n    n.factors =\
    \ getfactors(n)\n  end\n  return n.factors.max\nend", "  factor = 1\n  while n\
    \ > 1\n    factor = factor * n % 2\n    n = n / 2\n  end\n  factor\nend", "  primes\
    \ = Primes.prime_division(n)\n  largest = 0\n  largest = primes.largest\n  while\
    \ largest != 1\n    next largest = primes.next\n  end\n  largest\nend", "    factor\
    \ = 1\n    while n != 1:\n        while n % factor == 0:\n            n /= factor\n\
    \        factor += 1\n    return n\nend", "  i = 2\n  factors = 2\n  while i <=\
    \ n\n    i = i * 2\n    factors += 1\n  end\n  return i\nend", "  i = 1\n  factor\
    \ = 1\n  while i * factor < n\n    factor *= i\n    i += 1\n  i\nend", "  largest_prime\
    \ = 1\n  i = 1\n  while i * i <= n\n    i += 1\n    if n % i == 0\n      i +=\
    \ 1\n      while n % i == 0\n        n /= i\n        largest_prime += 1\n    \
    \  i += 1\n    end\n  end\n  return largest_prime\nend", "  factor = 1\n  while\
    \ n >= 2\n    factor = 2 ** factor\n    n /= factor\n    factor\n  end\n  factor\n\
    end", "  return factors(n).max.first\nend", "  largest_divisor = 1\n  largest_factor\
    \ = 1", "    # Step 1\n    while n % 2 == 0: n /= 2\n    # Step 2\n    while n\
    \ % 3 == 0: n /= 3\n    # Step 3\n    if n == 1: return 3\n    # Step 4\n    if\
    \ n == 2: return 2\n    # Step 5\n    i = 5\n    while i*i <= n: # Find sqrt(n)\n\
    \        while n % i == 0: n /= i\n        i += 2\n    # Step 6\n    if n > 1:\
    \ return n\n    # Step 7\n    return 0\nend", "  # Return the largest prime factor\
    \ of n. Assume n > 1 and is not a prime.\n  # >>> largest_prime_factor(13195)\n\
    \  # 29\n  # >>> largest_prime_factor(2048)\n  # 2\n  if n % 2 == 0\n    p = \
    \ 2\n  else\n    p =  3\n    while n % p == 0 and p < n do\n      p += 1\n   \
    \ end\n  end\n  p - 1\nend\n</cell>\n<cell>", "  factor = 1\n  while true\n  \
    \  factor += 1\n    if n % factor\n      break\n    n /= factor\n  return factor\n\
    end", "  factors = []\n  i = 1\n  while n != 1\n    factors.push i\n    i*=i\n\
    \    n /= i\n  end\n  factors.push 1 while n % 2 == 0\n  factors.last\nend\n</pre>\n\
    \    <p>\n      One might wonder, where did the loop terminate. Let's look back\
    \ at the\n      first line of the loop:\n    </p>\n<pre>\n  while n != 1\n   \
    \ factors.push i\n    i*=i\n    n /= i\n  end\n</pre>\n    <p>\n      This loop\
    \ will stop when <code>n</code> is 1. The first iteration, then,\n      will push\
    \ a new <code>1</code> onto <code>factors</code> before exiting the\n      loop.\
    \ On the next iteration, this <code>n</code> will be <code>2</code>.\n    </p>\n\
    \    <p>\n      If <code>n</code> is <code>0</code>, the loop will never be entered.\
    \ This\n      will cause the code to crash and burn.\n    </p>\n    <h4>Exercise</h4>\n\
    \    <p>\n      Write an algorithm that finds the largest prime factor for a number\
    \ n > 1 and\n      output it. If your algorithm passes all the tests, it should\
    \ print out the\n      largest prime factor of <code>n</code>.\n    </p>\n   \
    \ <p>\n      Implement the algorithm <strong>efficiently and quickly</strong>.\n\
    \    </p>\n    <h4>Difficulty</h4>\n    <p>\n      Easy, just <code>push</code>\
    \ onto the <code>factors</code> array.\n    </p>\n    <h4>See also</h4>\n    <p>\n\
    \      <a href=\"./solutions/problem_04.html\">Problem 04</a>: Prime factors.\n\
    \    </p>\n  </div>\n  <!-- ADD YOUR CODE BELOW -->\n</div>\n<script>\n  // More\
    \ info about config & dependencies:\n  // - https://github.com/hakimel/reveal.js#configuration\n\
    \  // - https://github.com/hakimel/reveal.js#dependencies\n  Reveal.initialize({\n\
    \    dependencies: [\n      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.8.0/plugin/markdown/marked.js'\
    \ },\n      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.8.0/plugin/markdown/markdown.min.js'\
    \ },\n      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.8.0/plugin/notes/notes.min.js',\
    \ async: true },\n      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.8.0/plugin/highlight/highlight.min.js',\
    \ async: true, callback: function() { hljs.initHighlightingOnLoad(); } },\n  \
    \    { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.8.0/plugin/math/math.min.js',\
    \ async: true },\n", "  return prime_division(n.to_s, 1).first\nend", "    i =\
    \ 2\n    factors = []", "  m = 2\n  while m <= n\n    factor = m \n    while factor\
    \ * m <= n\n      m += 1\n      factor = factor * m\n    m -= 1\n  end\n  factor\n\
    end", "  i = 2\n  while i <= n\n    if n % i == 0\n      i += 1\n    else \n \
    \     n = n / i\n    end\n  end\n  return n\nend", "  i = 2\n  factors = []\n\
    \  while i * i <= n\n    i += 1\n    while n % i == 0\n      n /= i\n      factors\
    \ << i\n    end\n  end\n  factors << n if n > 1\n  factors.max\nend", "  return\
    \ n if n.odd? || (n > 1 && prime?(n)) || (n < 2 && prime?(2::Integer)) || (n <\
    \ 3 && prime?(3::Integer)) || (n < 5 && prime?(5::Integer)) || (n < 7 && prime?(7::Integer))\
    \ || (n < 11 && prime?(11::Integer)) || (n < 13 && prime?(13::Integer)) || (n\
    \ < 17 && prime?(17::Integer)) || (n < 19 && prime?(19::Integer)) || (n < 23 &&\
    \ prime?(23::Integer)) || (n < 29 && prime?(29::Integer)) else 2\nend", "  return\
    \ 2 if n <= 2 \n  factor = 1\n  while n > 1 do\n    while n % factor == 0 do\n\
    \      n /= factor\n      factor = factor * 2\n    end\n    factor = factor +\
    \ 1\n  end\n  n\nend", "  factors = []\n  i = 2\n  while i * i <= n\n  i += 1\n\
    \  while i <= n\n  i += 1\n    if n % i == 0\n    factors << i\n    end\n    end\n\
    \    end\n  factors.max_by {|f| n % f}\nend\n</code>\n<|/ a dscore=4 tags=ruby\
    \ |>\n<| c |>\nThis is a bit slow for large numbers. You could make this more\
    \ efficient by first checking whether n is prime. Also this algorithm fails when\
    \ n is not an even number.\n<|/ c |>\n<| c |>\nThanks for your contribution. I've\
    \ edited the code so that it now correctly handles even numbers.\n<|/ c |>\n<|\
    \ c |>\nYou could also add a check for prime factors (if n % i == 0)\n<|/ c |>\n\
    <| c |>\n: What does that mean for a number? What would you do with those factors?\n\
    <|/ c |>\n<| c |>\nFor a number `n`, if the factors of `n` are prime, then `n`\
    \ is also prime.\n<|/ c |>\n<| a tags=ruby |>\nThe solution below was originally\
    \ written by Daniel E. G. and I recommend you check it out. The author has a great\
    \ tutorial on how to find the greatest prime factor of a number here.\n<code>",
  "  prime_fac = 2\n  while(n > 1)\n    prime_factor = n % prime_fac\n    n = n /\
    \ prime_fac\n    prime_fac = prime_factor\n  end\n  prime_fac\nend", "  # Initialize\
    \ i to 2\n  i = 2\n  # While i ** 2 < n\n  while (i ** 2) < n\n    # Increment\
    \ i by 1\n    i += 1\n  # If i ** 2 > n\n  if i ** 2 > n\n    # Return the square\
    \ root of n\n    i ** 2\n  # Else\n  # Return the maximum prime factor of n\n\
    \  else\n    # Return the maximum prime factor of n\n    i\n  end\nend", "  i\
    \ = 1\n  while i * i <= n && n % i == 0\n    i += 1\n  while i\n    prime, i =\
    \ [n / i, i].min\n    if prime != 1\n      break\n    i += 1\n  end\n  return\
    \ prime\nend", "    i = 2\n    factor = 1\n    while i*i <= n\n        if n %\
    \ i == 0\n            i += 1\n        else\n            n /= i\n            factor\
    \ *= i\n        end\n    end\n    factor\nend", "  sieve = Array.new(25, n)\n\
    \  sieve.fill(false)\n  n = 3\n  while n <= n\n    if sieve[n]\n      n = 3*n\n\
    \      next\n    else\n      i = 2\n      while i*i <= n\n        sieve[i*i] =\
    \ true\n        i = i + 2\n      end\n    end\n  end\n  prime_factors = sieve.select.with_index\
    \ { |prime, i| prime }\n  if prime_factors.length == 1\n    return prime_factors[0]\n\
    \  else\n    prime_factors = prime_factors.map { |i| i }.max\n    return prime_factors\n\
    \  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=primes,algorithm |>\nThis is\
    \ an optimization problem which can be solved with Dynamic Programming (DP). First\
    \ we define a function isPrime(integer), which tells if an integer is a prime\
    \ number or not:\n<code>\nfunction isPrime(integer)\n  if integer == 1 then return\
    \ false\n  if integer == 2 then return true\n  if integer % 2 == 0 then return\
    \ false\n  if integer <= 1 then return false\n  if integer % 3 == 0 then return\
    \ false\n  if integer % 5 == 0 then return false", "  primes = [2, 3]\n  n = n.to_i\n\
    \  while n > 2\n    prime = primes.detect { |i| (n % i) == 0 }\n    return prime\
    \ if prime != n\n    prime_candidate = 3\n    while prime_candidate <= n/prime\n\
    \      prime_candidate += prime\n    end\n    primes << prime_candidate\n    n\
    \ = n / prime_candidate\n  end\n  n\nend\n</code>\n<|/ a |>\n<| c |>\nThis fails\
    \ to detect factors of a prime number. For example `largest_prime_factor(1700)`\
    \ returns `17`, when it should be `7`\n<|/ c |>\n<| c |>\n: You are right, thanks!\
    \ I changed my answer.\n<|/ c |>\n<| c |>\nAhh I see! Thanks! Works great!\n<|/\
    \ c |>\n<| a dscore=2 |>\nFor Python 3, you can use the following code to get\
    \ prime factors.\n<code>", "  # The prime factors of n are : 2,3,5,7,11,13,17,19\n\
    \  # So let's find the largest prime factor of n to find its least factor\n  #\
    \ i.e number of divisors.\n  prime_factors = []\n  i = 2\n  while i * i <= n\n\
    \    prime_factors.push(i)\n    i += 1", "  primes = primes_up_to_n(n)\n  factors\
    \ = []\n  for i in primes\n    factors += i\n    factors.uniq.each do |f|\n  \
    \    return f if f > n\n    end\n  end\n  factors\nend", '    return n if n <
    2 else n % 2', "  return prime_factors(n).max_by { |s| s.abs }\nend", "  return\
    \ n if n < 2 else largest_prime_factor(n % 2) and largest_prime_factor(n / 2)\n\
    end", "  return n if n.odd? || n > 2 else largest_prime_factor(n / 2)\nend", " \
    \ sieve = [1] * (n/2)\n  (2..n).each do |i|\n    sieve[i] = 0\n    (3..i).each\
    \ do |j|\n      sieve[i] += sieve[j] * i\n    end\n  end\n  i = n\n  while i >\
    \ 2\n    if (sieve[i])\n      i = (i/2)\n    else\n      return i\n    end\n \
    \ end\nend", "    factors = []\n    if n > 1\n        factor = 2\n        while\
    \ factor * factor <= n\n            factor += 1\n        end\n        factors.push\
    \ factor\n        n /= factor\n    end\n    factors.push 1 if n == 1\n    factors.max\
    \ { |a, b| a < b ? a : b }\nend\n</cell>\n<cell>", "  i = 2\n  while i * i <=\
    \ n\n    i += 1\n  i\nend", "  i = 2\n  factors = []\n  while i * i <= n\n   \
    \ factors.push(i)\n    i += 2\n    n /= i\n  factors.reverse\n  factors.each {\
    \ |f| return f if n % f == 0 }\n  raise \"n must be > 1 and is not a prime\"\n\
    end\n</code>\n<|/ a |>\n<| c |>\nYes but he asked for the prime factors only\n\
    <|/ c |>\n<| c |>\nThanks but i need to do it in ruby.\n<|/ c |>\n<| c |>\n: It\
    \ does not matter - just use `grep` for it and use the method from above...\n\
    <|/ c |>\n<| c |>\nYour code is working great...but can you help me to know how\
    \ can i find this solution using recursion..?\n<|/ c |>\n<| c |>\n: Please see\
    \ the updated answer. Recursion is quite a complex subject - you should read a\
    \ good book about it... :-)\n<|/ c |>\n<| a dscore=1 tags=ruby,recursion |>\n\
    A recursive approach would be\n<code>", "  prime = 1\n  for i in 2...n do\n  \
    \  if (n % i == 0) then\n      prime = i\n      break\n  end", "  return prime_number(n)\
    \ * prime_factors(n).reduce(:*)\nend", "  n.to_i\n  n = n.round\n  factor = 1\n\
    \  while n != 1\n    n, next_value = div(n, factor) # n /= factor\n    factor\
    \ = next_value\n  end\n  factor\nend", "  largest_prime = 1\n  i = 1\n  while\
    \ i <= n do\n    if n % i == 0 then\n      if i > largest_prime then\n       \
    \ largest_prime = i\n      end\n    end\n    i += 1\n  end\n  return largest_prime\n\
    end", "  factors = []\n  i = 1\n  while i * i <= n\n    factors = factors + [i\
    \ * i]\n    i += 1\n  i = 2\n  while i * i <= n\n    if n % i == 0\n      i +=\
    \ 1\n      factors << i\n    else \n      n /= i\n      factors << i\n    end\n\
    \  end\n  factors.max\nend", "  n = n.to_i\n  if n <= 1\n    1\n  else\n    largest_prime_factor(n\
    \ % 2) == 1 ? n : n + largest_prime_factor(n % 2)\n  end\nend", "  prime = 2\n\
    \  while true\n    if n%prime == 0 then return prime\n    prime = 2*prime + 1\n\
    \  end\nend\n</cell>\n<text>\nThe factors of 13195 are 5, 7, 13 and 29.\nLet's\
    \ find all the prime factors of 13195:", "  primes = nil\n  while n > 2\n    primes\
    \ = primes + [n/2, n/2 +1 ]\n    n /= 2\n  end\n  primes.find { |x| x != n }\n\
    end", "    \n    prime_factors = []\n    for i in range(2, n / 2 + 1):\n     \
    \   if n % i == 0:\n            prime_factors.append(i)\n    return prime_factors[-1]\n\
    </code>\nNow lets see how it works and what we get:\n<code>\nIn [11]: largest_prime_factor(13195)\n\
    Out[11]: 29", "  factor = 1\n  i = 1\n  while (n % i == 0)\n    i += 1\n  n =\
    \ n / i\n  factor = i\n  while n != 1\n    if (n % i == 0)\n      n = n / i\n\
    \      factor = 1\n      i = factor\n    end\n    i += 1\n  end\n  factor\nend",
  "  prime = 2\n  factors = []\n  while n > prime\n    factors.push(prime)\n    prime\
    \ += 2\n  factors.push(prime)\n  factors.reverse.each do |i|\n    while n % i\
    \ == 0\n      n /= i\n    end\n  end\n  factors.inject(n) {|sum, i| sum}\nend",
  "    prime_divisors = [2, 3]\n    while n > 2\n        prime_divisors.each do |divisor|\n\
    \            if n % divisor == 0\n                prime_divisors = divisors.delete(divisor)\n\
    \                break\n            end\n        end\n        if prime_divisors.length\
    \ == 0\n            return n\n        end\n        n = prime_divisors.inject(n)\
    \ do |m, d|\n            next m if d == 1\n            d / m\n        end\n  \
    \  end\nend", "  n = n.to_i\n  return 2 if n < 2 else n % 2 == 0 and n >= 4 and\
    \ n != 4 \\\n    ? largest_prime_factor(n / 2) : n % 2 != 0 ? n : 3\nend", " \
    \ if n > 2 \n    if n % 2 == 0\n      return n\n    else \n      i = 3\n     \
    \ factor = 2\n      while i * factor < n\n        factor += 1\n        i += 1\n\
    \      while n > 1\n        while n % factor > 0\n          n /= factor\n    \
    \    factor += 1\n      n += 1\n      return factor\n  else\n    return 2\nend\n\
    </cell>\n<text>\nTask 3\nImplement a function is_prime(n) that, given a natural\
    \ number $n$, returns true if $n$ is prime, and false otherwise.", "\tn.upto(2,\
    \ inclusive) do |num|\n\t\treturn num if !num.prime? && num.to_f >= n\n\tend\n\
    end", "  # Limit n to improve speed of sieve\n  if n < 1 or (n % 2) == 0\n   \
    \ n\n  else\n    # Sieve of Eratosthenes by Eratosthenes Sieve\n    largest_prime\
    \ = 2 # start with 2 since 2 will also be a factor\n    (2..n / 2).step(2) do\
    \ |prime|\n      next if prime > largest_prime and prime % prime\n      largest_prime\
    \ = prime\n    end\n    largest_prime\n  end\nend", "  a = 2\n  while a <= n\n\
    \    if n % a == 0\n      a = a * 2 \n    else\n      a\n    end\n  end\n  a\n\
    end", "  max_factor = 0\n  max_factor = 0", "  largest_prime_factor = 0\n  (2..n).each\
    \ do |i|\n    if n%i==0 && n!=1 && i**2 > n\n      largest_prime_factor = i\n\
    \    end\n  end\n  largest_prime_factor\nend\n</code>\n<|/ a tags=ruby,primes\
    \ |>\n<| c |>\n`n.odd? == true` is redundant and equivalent to `n%2` which returns\
    \ either 0 or 1.\n<|/ c |>\n<| c |>\n`if n.odd?` implies that `n` is an even number,\
    \ which is not what `n.odd? == true` tests for. `n.odd? == true` is redundant.\n\
    <|/ c |>\n<| c |>\nOh, you're right. `n % 2 == 1` would have worked as well.\n\
    <|/ c |>\n<| c |>\n`n % 2 == 1` implies that `n` is even, which is redundant.\n\
    <|/ c |>\n<| c |>\nThe two expressions `n%2 == 0` and `n%2 == 1` evaluate to the\
    \ same thing. `n % 2 == 0` is preferable because it expresses intent more clearly\
    \ than `n % 2 == 1`.\n<|/ c |>\n<| a dscore=4 |>\n<code>", "    i = 2\n    factor\
    \ = 2\n    while i * factor <= n\n      i += 1\n      factor = i * 2\n    i ==\
    \ n\n    return factor\nend", "  factor = 1\n  while n > 1\n    if n % factor\
    \ == 0\n      break\n    factor++\n    n/= factor\n  return factor\nend", "  factors\
    \ = prime_divisors(n)\n  factors.each_index do |i|\n    if factors[i] > n\n  \
    \    factors = factors.delete_at(i)\n    end\n  end\n  factors.min\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby,prime-factoring,factoring dscore=1 |>\nYou could make\
    \ use of ruby prime factorizing function and do something like this\n<code>\n\
    require \"prime\"", "  i = 1\n  factors = []\n  while i * i <= n\n    if n % i\
    \ == 0\n      i += 1\n      factors << i\n    end\n  end\n  i = 2\n  while i *\
    \ i <= n\n    if n % i == 0\n      i += 1\n    else\n      factors << i\n    end\n\
    \  end\n  factors.max\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  return\
    \ n if n < 2 else n if n < 10 else n.prime_divisions do |prime_factor|\n    prime_factor.prime?\n\
    \  end\nend", "    factors = []\n    i = 2\n    while\n        factors.length\
    \ < i\n        and i <= n\n        do\n            i += 1\n            factors.push(n\
    \ % i)\n            n = (n / i).floor\n        end\n    return factors.length\
    \ ? factors.last : 1\nend\n</code>\nThe first part loops through all the prime\
    \ factors and returns the biggest one.\nThe second part returns the floor of the\
    \ result of the division.\n<|/ a tags=ruby,primes |>\n<| c |>\nThat's not how\
    \ prime factorization works. You don't need to check each number to see whether\
    \ it's divisible by any number less than or equal to it.\n<|/ c |>\n<| a tags=ruby,primes\
    \ dscore=5 |>\nRuby has a built-in function to determine if a number is a prime.\
    \ \n<code>", "  if n == 1 \n    1\n  else\n    largest_prime_factor(n % 10).should\
    \ == largest_prime_factor(n / 10)\n  end\nend", "  # If n is greater than 2, return\
    \ n and assume n is prime.\n  return n if n <= 2 else n % 2 # return n if n >\
    \ 2 else n % 2\nend", "  return n if n.odd? || n.even? || (n==1) else prime_factors(n)[-1]\n\
    end", "  sieve = n.prime_array\n  return sieve[1] if sieve.length <= 2 else n%sieve[2]\n\
    end", "  if n == 1\n    puts \"1\"\n    return\n  i = 2\n  while i * i <= n\n\
    \    if n % i == 0\n      puts \"#{i}\"\n      return\n    i += 1\n  end\n  puts\
    \ n\nend", "    primes = [i for i in range(2, n) if n % i == 0]\n    factor =\
    \ 1\n    for prime in primes\n        if n % prime == 0\n            factor *=\
    \ prime\n    return factor\n</code>\nI hope it helps\n<|/ a |>\n<| a |>\nIn case\
    \ anyone is still looking for an efficient method to find a prime factor of a\
    \ number in Python:\n<code>", "  # Write your code here.\n  factors = []\n  i\
    \ = 2\n  while i * i <= n do\n    while n % i == 0 do\n      n /= i\n      factors.push\
    \ i\n    end\n    i ++\n  end\n  factors.push n\n  return factors\nend", "  result\
    \ = 1\n  factor = 2\n  while factor < n do\n    if n % factor == 0 then\n    \
    \  result = factor\n    end\n    factor = factor + 1\n  end\n  return result\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis is just great and very clear, thank you.\
    \  But if you're interested in algorithms in general check out [this link](https://www.cs.uic.edu/~liub/Fall09/notes/algorithms1.html)\
    \ I wrote.  It goes through many examples, and then provides additional information.\n\
    <|/ c |>\n<| c |>\nThis algorithm is O(n^2) but in practice is very efficient\n\
    <|/ c |>\n<| c |>\nYes, that is O(n^2), but the algorithm does not require that\
    \ `n` is greater than 1.  All `n` must be prime factors of some larger `a` factor.\
    \  It also requires `n` be the product of two primes.  It also requires that `a`\
    \ be a factor of `n`, but the code does not test this.  It also requires that\
    \ the result be less than or equal to `a`, but the code does not test this.  And\
    \ so on.  At the end, all `n` must be less than or equal to `a^k`, where `k` may\
    \ be greater than `n` by 2's or 3's and must be less than or equal to `n`.\n<|/\
    \ c |>\n<| c |>\nThanks I appreciate the response. I have implemented your algorithm\
    \ and it is extremely fast. However it has a flaw: it does not account for prime\
    \ factors greater than the square root of the number.\n<|/ c |>\n<| a dscore=4\
    \ |>\nFirst of all I recommend to check whether the number is prime or not. The\
    \ prime number problem has many algorithms, just search it on google.\nIf my number\
    \ is N:\n<code>\nfor i=2 to N do\n   if N%i is 0 then\n      N=N/i\n   else\n\
    \      exit loop\n   end\nend \n</code>\nIf my number is P:\n<code>\nfor i=2 to\
    \ P-1 do\n   if P%i is 0 then\n      P=P/i\n   else\n      exit loop\n   end\n\
    end \n</code>\n<|/ a tags=lua,primes,sieve-of-eratosthenes |>\n<| c |>\nYou don't\
    \ need to loop from 2 to N to check whether N is prime. You only need to loop\
    \ from 2 to sqrt(N).\n<|/ c |>\n<| c |>\nThe algorithm for sieve of Eratosthenes\
    \ is very good and very clear", "  return n if n < 2 else prime_factors(n)[-1].max\
    \ # O(n log n)\nend", "  primes = prime_factors(n)\n  primes.each do |prime|\n\
    \    break if prime > n\n  end\n  largest_prime = primes.max\n  largest_prime\
    \ < n ? largest_prime : n\nend", "  return n if n < 2 else prime_factors(n).max\n\
    end", "  # https://en.wikipedia.org/wiki/Primality_test#Naive_methods\n  if n\
    \ <= 1 then return nil; end\n  if n <= 3 then return n; end\n  i = 2\n  while\
    \ i <= n do\n    factor = (n%i)\n    if factor == 0 then return i; end\n    i\
    \ = i+1\n  end\n  return nil\nend", "    factors = factor(n)\n    largest = factors.max\n\
    \    factors.delete_if{|f| f != largest}\n    return largest if factors.empty?\
    \ \n    largest_prime_factor(largest*factors.max)\nend\n</code>\nThis is more\
    \ of a mathematical question than a ruby question.  If you look at the code above\
    \ you can see that I have done the same thing that you have done.  A prime factor\
    \ decomposition is basically the decomposition of the number into its prime factors.\
    \  Once you have that decomposition you just need to get the largest prime factor\
    \ and repeat it until you get an odd number.\n<|/ a tags=primes,ruby,math,algorithm\
    \ dscore=3 |>\n<| a dscore=3 |>\nTo me this sounds like a homework problem, so\
    \ I'm going to give you a hint instead of an exact solution.\nLet's think about\
    \ a number like 23 (well, let's not go into details of how big a prime is). If\
    \ we take a look at what that number looks like as a fraction, we have:\n<code>\n\
    5/2 = 2.5\n2/2 = 0.5\n3/2 = 1.5\n1/2 = 1.0\n</code>\nAnd that's it. This is the\
    \ smallest fraction with a whole number part. Now consider the number 24:\n<code>\n\
    24 = 5/2 + 2/2 + 3/2 + 1/2\n24 = 3/2 + 1/2 + 1/2\n24 = 5/2 + 2/2 + 1/2\n24 = 5/2\n\
    </code>\nSo the number 24 is one fifth of the number 23. We can see this more\
    \ easily if we start with a very large number, like 2^64 or something. Then we\
    \ get a very large fraction:\n<code>\n2^64 = 12166566400000000000\n12166566400000000000/5\
    \ = 12166566400000000000/256 = 121665664000000\n121665664000000/256 = 121665664000000/625\
    \ = 121665664000000/49152 = 121665664000000/15625 = 121665664000000\n121665664000000/625\
    \ = 121665664000000/625 = 121665664000000\n</code>\nSo we see that we can find\
    \ the smallest fraction with a whole number part by looking at the number itself.\
    \ Now let's see what happens when we take the number 24, divide it by 5 and get\
    \ the remainder. Since we start with the number 24, we get the remainder of 1,\
    \ a fifth of the number 24. So if we repeat this process for every number between\
    \ 5 and 2^64 and check whether we get a remainder of 1, we get the smallest fraction\
    \ with a whole number part by looking at the number itself.\n<|/ a tags=primes,ruby,",
  "  factors = n.to_s.chars.map(&:to_i)\n  factors.reduce(:<<) while factors.any?\
    \ { |i| n % i == 0 }\n  return n if factors.size == 1\n  max_divisor = factors.max\n\
    \  n.to_s.chars.map { |i| i * max_divisor / i }.max\nend\n</code>\n<|/ a tags=ruby,algorithm\
    \ |>\n<| c |>\nI suggest you add some explanation of how this works, and how it\
    \ compares to the accepted answer. Code dumps without any explanation are not\
    \ as useful for future readers.\n<|/ c |>\n<| c |>\nThanks. Added some explanation.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's the most concise way to do this in Ruby:\n\
    <code>", "  i, p = 1, 2\n  while i * p <= n\n    i += 1\n    p += 1\n  return\
    \ p if n / p > i else i\nend", "    n = abs(n)\n    if n<2:\n        return 1\n\
    \    max_divisor = n / 2\n    max_i = 2\n    while max_i<n and max_divisor*max_i\
    \ <= n:\n        max_divisor *= max_i\n        max_i += 1\n    if max_i**2 < n:\n\
    \        max_divisor *= max_i\n        max_i += 1\n    return max_i", "  primes\
    \ = []\n  i = 1\n  while (n % 2 == 0 && i < n) do\n    i = i + 1\n    primes <<\
    \ 2\n  end\n  i = 1\n  while (n % 3 == 0 && i < n) do\n    i = i + 1\n    primes\
    \ << 3\n  end\n  i = 1\n  while (n % 5 == 0 && i < n) do\n    i = i + 1\n    primes\
    \ << 5\n  end\n  i = 1\n  while (n % 7 == 0 && i < n) do\n    i = i + 1\n    primes\
    \ << 7\n  end\n  i = 1\n  while (n % 10 == 0 && i < n) do\n    i = i + 1\n   \
    \ primes << 10\n  end\n  i = 1\n  while (n % 11 == 0 && i < n) do\n    i = i +\
    \ 1\n    primes << 11\n  end\n  i = 1\n  while (n % 13 == 0 && i < n) do\n   \
    \ i = i + 1\n    primes << 13\n  end\n  i = 1\n  while (n % 14 == 0 && i < n)\
    \ do\n    i = i + 1\n    primes << 14\n  end\n  i = 1\n  while (n % 15 == 0 &&\
    \ i < n) do\n    i = i + 1\n    primes << 15\n  end\n  i = 1\n  while (n % 16\
    \ == 0 && i < n) do\n    i = i + 1\n    primes << 16\n  end\n  i = 1\n  while\
    \ (n % 17 == 0 && i < n) do\n    i = i + 1\n    primes << 17\n  end\n  i = 1\n\
    \  while (n % 18 == 0 && i < n) do\n    i = i + 1\n    primes << 18\n  end\n \
    \ i = 1\n  while (n % 19 == 0 && i < n) do\n    i = i + 1\n    primes << 19\n\
    \  end\n  i = 1\n  while (n % 20 == 0 && i < n) do\n    i = i + 1\n    primes\
    \ << 20\n  end\n  i = 1\n  while (n % 21 == 0 && i < n) do\n    i = i + 1\n  \
    \  primes << 21\n  end\n  i = 1\n  while (n % 22 == 0 && i < n) do\n    i = i\
    \ + 1\n    primes << 22\n  end\n  i = 1\n  while (n % 23 == 0 && i < n) do\n \
    \   i = i + 1\n    primes << 23\n  end\n  i = 1\n  while (n % 24 == 0 && i < n)\
    \ do\n    i = i + 1\n    primes << 24\n  end\n  i = 1\n  while (n % 25 == 0 &&\
    \ i < n) do\n    i = i + 1\n    primes << 25\n  end\n  i = 1\n  while (n % 26\
    \ == 0 && i < n) do\n    i = ", "    return prime_factors(n)[n]\nend", "  i =\
    \ 2\n  while i * i <= n\n    i += 2\n  i\nend", "  if n == 0\n    1\n  else\n\
    \    largest_prime_factor(n / 2) if n % 2 == 0\n  end\nend\n</code>\n<|/ a tags=algorithm,ruby,python\
    \ dscore=3 |>\n<| a tags=algorithm,ruby,python |>\n<code>", "  factor = 1\n  while\
    \ n % factor == 0\n    factor = factor*(n/factor)\n  end\n  factor\nend", "  i\
    \ = 1\n  f = 2\n  while i <= n\n    i += 1\n    if n % i == 0\n      f = i\n \
    \     break\n    elsif f i > n\n      break\n    end\n  end\n  return f\nend",
  "  return 2 if n < 2 else 3 if n % 2 == 0 or n % 3 == 0 \n    or n % 5 != 0 and\
    \ n % 7 != 0 else largest_prime_factor(n / 2)\nend", "  prime, exponent = 2, 2\n\
    \  while prime < n\n    if n % prime == 0 && prime > exponent\n      exponent\
    \ = exponent*prime # new exponent\n      prime = prime*2        # new prime\n\
    \    elsif n % prime > 0\n      break             # no more factors possible\n\
    \    end\n  end\n  exponent\nend\n</cell>\n<text>\nWe can use this to find primes\
    \ up to a certain limit.", "  prime 1,3\n  for i in 2..n\n    if n % i == 0\n\
    \      prime i i\n  largest_prime = prime[0]\n  factors = prime[1]\n  factors.each\
    \ do |factor|\n    if n % factor == 0\n      largest_prime = factor\n      break\n\
    \    end\n  end\n  largest_prime\nend", "  factors = []\n  # Set a limit on how\
    \ large a prime factor to return\n  limit = n / 4 if n / 4 > 300 else 300\n  #\
    \ If n is prime then there cannot be any factor higher than n\n  if prime?(n)\n\
    \    1\n  else\n    i = 2\n    until n ** i > limit\n      i <<= 1\n      if n\
    \ % i == 0\n        factors << i\n        n /= i\n      end\n    end\n    if n\
    \ != 1\n      factors << n\n    end\n  end\n  factors.max\nend\n</cell>\n<text>\n\
    The first function we had defined returns the smallest prime factor of our numbers.\
    \ Now let's try to return the largest prime factor of a number! Remember this\
    \ time we know that our numbers are relatively prime to each other and we can\
    \ use this fact to solve the problem.", "  if n == 1 \n    return 1\n  factors\
    \ = []\n  i = 1\n  while i <= n \n    factor = (i**.5)/(2*i)\n    factors.push([i,\
    \ factor])\n    i = i + 2\n  factors.sort!{|a,b| a[1] <=> b[1]}\n  factors = factors.reverse\n\
    \  return factors[0][1]\nend\n</code>\n<|/ a dscore=1 tags=primes,ruby |>\n<|\
    \ a tags=primes,ruby |>\n<code>", "  primes = []\n  i = 2\n  loop do\n    loop\
    \ do\n      i += 2\n      break if (!i.mod n).zero?\n      primes << i\n    end\n\
    \    break if (primes.size > n).nonzero?\n  end\n  primes.last\nend", "  largest_prime\
    \ = 1\n  i = 1\n  while i * i <= n\n    if n % i == 0\n      largest_prime = i\n\
    \      i += 2\n    else\n      i += 1\n    end\n  end\n  i\nend\n</cell>\n<code\
    \ language=julia-1.4>\nlargest_prime_factor(13195)\n</cell>\n<code language=julia-1.4>\n\
    largest_prime_factor(2048)\n</cell>\n<code language=julia-1.4>\nlargest_prime_factor(9921)\n\
    </cell>\n<text>\nSolve for n\nSolve for n by using the equation (7 + 7n - 2) %\
    \ 7. Start with n = 2. Repeat until you have n \u2264 100.", "  prime_divisors\
    \ = (2..n).to_a\n  largest_prime_factor = nil", "  sieve_set = Array.new(81, false)\n\
    \  primes = Array.new(81, false)\n  n = [n] - [0] if n.is_a?(Array)\n  1.upto(Math.sqrt(n))\
    \ { |i| primes[i] = false }\n  n.times { |i| sieve_set[i] = i if (primes[i] ==\
    \ false && i % primes.sum == 0) }\n  primes.each do |prime|\n    if sieve_set[prime]\n\
    \      for i in 2..prime\n        if sieve_set[prime * i] == true\n          sieve_set[prime*i]\
    \ -= 1\n        end\n      end\n      return prime * (prime > n ? 1 : -1)\n  \
    \  end\n  end\n  raise \"n must be > 1.\"\nend", "  prime_factors = prime_factorization(n)\n\
    \  prime_factors.find { |factor| factor.to_s != \"1\"}\nend", "  # Primes are\
    \ less than the square root of n.\n  return n if n < 2 else n % primes.prime(n\
    \ - 2)\nend\n</cell>\n<code language=julia-1.0>", "  return n if n % 1 == 0 or\
    \ n % 2 == 0 or n % 3 == 0 or n % 5 == 0 # n must be odd\n  x = 1\n  i = 3\n \
    \ while i <= n/2\n    if n % i == 0\n      x *= i\n      n /= i\n      i += 2\n\
    \    else\n      i += 1\n  end\n  x\nend", "    prime_found = 1\n    while prime_found\
    \ == 1 and n != 1 do\n        n = n / 2 # remove all even factors\n        prime_found\
    \ = n % 2 != 0\n    end\n    largest = n # start with n = 2\n    while n > 1 do\n\
    \        largest = largest / 2 # remove all even factors\n        prime = n %\
    \ largest != 0\n        if prime == 1 then\n            break\n        end\n \
    \   end\n    return largest\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that returns the multiplicative inverse of a number. You may assume that the\
    \ given number is a perfect square. We'll call such a number $n$ the square root\
    \ of $n$.", "  factors(n)\n  largest = 0\n  largest = factors.max\nend", "  i\
    \ = 2\n  factor = 2\n  while i <= n do\n    while n % i == 0 do\n      i = i +\
    \ 1\n    end\n    factor = max(factor, i)\n    i = i + 1\n  end\n  return factor\n\
    end", "    i = 2\n    while i <= sqrt(n)\n        if n % i == 0\n            return\
    \ i\n        i += 1\n    return n\n</cell>\n<text>\nQuestion: Which primes are\
    \ greater than five million? What is the largest\nprime factor?", "  return n.prime?\
    \ factor(n) : n.factors.max\nend", "  return 2 if n < 2 else n % (2..sqrt(n))\
    \ if (n > 1) && n % 2 == 0\n  1.upto(sqrt(n) - 2, 2) do |factor|\n    break if\
    \ n % factor == 0\n    n /= factor\n  end\n  n\nend", "  i = 2\n  factor = 1\n\
    \  while i <= n/2\n    if n % i == 0\n      factor = i\n      break\n    i +=\
    \ 1\n  return factor\nend", "  if n == 0\n    0\n  else\n    largest_prime_factor(n\
    \ / 2) > n / 2 ? largest_prime_factor(n / 2) : n\n  end\nend\n</cell>\n<text>\n\
    Next let's write an Erlang program that takes a list of integers and a number\
    \ as input and returns the sum of the squares of the even numbers. We will define\
    \ a higher-order function that takes an integer-list as input and an integer,\
    \ and returns a function that takes an integer as input and returns a sum of squares\
    \ of even numbers. Note that the output of the function should match the result\
    \ we get by applying the function we defined, so our input should match our (inputs)\
    \ to the output, and our output should match the (outputs) given by the function\
    \ we defined.", "  largest_prime = 1\n  (2..n).each do |i|\n    if n % i == 0\n\
    \      if i >  largest_prime\n        largest_prime = i\n      end\n    end\n\
    \  end\n  largest_prime\nend", "  n <= 1 ? 1 : largest_prime_factor(n/2).to_s\
    \ + 1\nend", "  # Initialize largest prime factor.\n  factor = nil\n  # Check\
    \ for factors of 2, 3, and 5.\n  if n % 2 == 0 and n % 3 == 0 and n % 5 == 0\n\
    \    return n\n  elsif n % 2 == 0 and n % 3 == 0\n    factor = 2 if n % 5 == 0\
    \ else 3\n  elsif n % 5 == 0\n    factor = 5\n  else\n    factor = n / 2\n  end\n\
    \  # Test the smaller factors.\n  for i in 2..factor\n    if n % i == 0\n    \
    \  return n\n    end\n  end\n  return factor\nend\n</pre>", "  i = 2\n  factor\
    \ = 2\n  while i * i <= n do\n    while n % i == 0 do\n      n /= i\n      factor++\n\
    \    end\n    i += 1\n  end\n  factor\nend", "  n <= 1 and return nil\n  factors\
    \ = []\n  while n > 1\n    factors.push(n % prime)\n    n /= prime\n  end\n  factors.size\
    \ == 1 and return factors[0]\n  factors.size > 1 and return factors[-1]\nend\n\
    </code>\n<|/ a tags=primes,ruby |>\n<| a |>\n<code>", "  loop do\n    break if\
    \ (n % 2) == 0\n    break if (n % 3) == 0\n    break if (n % 5) == 0\n    break\
    \ if (n % 7) == 0\n    break if (n % 11) == 0\n    break if (n % 13) == 1\n  \
    \  break if (n % 17) == 1\n    break if (n % 19) == 1\n    break if (n % 23) ==\
    \ 1\n    break if (n % 29) == 1\n    break if (n % 31) == 1\n    break if (n %\
    \ 37) == 1\n    break if (n % 41) == 1\n    break if (n % 43) == 1\n    break\
    \ if (n % 47) == 1\n    break if (n % 53) == 1\n    break if (n % 59) == 1\n \
    \   break if (n % 61) == 1\n    break if (n % 67) == 1\n    break if (n % 71)\
    \ == 1\n    break if (n % 73) == 1\n    break if (n % 79) == 1\n    break if (n\
    \ % 83) == 1\n    break if (n % 89) == 1\n    break if (n % 97) == 1\n  end\n\
    \  n / 2 # return n / 2\nend\n</code>\n<|/ a tags=ruby,primes |>\n<| c |>\nThis\
    \ doesn't work, at least not on Ruby 1.8.7 (which I use). On ruby 1.9.2p180, I\
    \ get: `largest_prime_factor(1395) => 2`\n<|/ c |>\n<| c |>\nOh boy, why does\
    \ it break the program on Ruby 1.9.0?\n<|/ c |>\n<| c |>\nIt breaks on Ruby 1.9.0\n\
    <|/ c |>\n<| c |>\nThis method is much more complicated than the other one. Can\
    \ you please explain the rationale behind this? Thanks\n<|/ c |>\n<| c |>\nHow\
    \ do you know it is the largest prime factor?\n<|/ c |>\n<| a dscore=5 |>\nHere\
    \ is my solution:\n<code>", "  prime = 1\n  factors = []\n  while n > 1\n    prime,\
    \ n = next_prime(prime, n)\n    factors.push(prime)\n  factors.push(2)\n  factors.reverse\n\
    \  factors.each do |prime|\n    return prime if n % prime == 0\n  end\n  nil\n\
    end\n</code>\n<|/ a dscore=3 tags=primes,ruby |>\n<| a dscore=2 |>\nSieve of Eratosthenes\n\
    Here is an algorithm that can be used to eliminate all multiples of 2, 3, 5, 7,\
    \ 11, and 13 that are less than or equal to n.  It is not the most efficient implementation,\
    \ and it is probably not the most efficient use of memory.  I only implemented\
    \ it for n < 1000000.  But it is easy to understand.\n<code>", "  i = 2\n  factor\
    \ = nil\n  while i < n do\n    if n % i == 0\n      factor = i\n      break\n\
    \    i += 1\n  end\n  if factor\n    factor\n  else\n    n\n  end\nend", "  primes\
    \ = []\n  num = 2\n  while num < n\n    num += 2\n    primes.push num\n  end",
  "  factors = []\n  i = 2\n  while i * i <= n and n % i == 0\n    i += 1\n  while\
    \ n != 1\n    factors << i\n    n /= i\n    i += 1\n  factors << i\n  if n !=\
    \ 1\n    factors << n\n  end\n  factors.max\nend", "  largest_prime = 1\n  i =\
    \ 1\n  while i <= n\n    i += 1\n    if n % i == 0\n      while n % i == 0\n \
    \       n /= i\n      largest_prime = i\n    end\n  end\n  return largest_prime\n\
    end", "  p =2\n  while (p * p * p) <= n do\n  p += 1\n  end \n  return (p-1)\n\
    end", "  factors = []\n  i = 2\n  while i <= n\n    factors = factors + [i for\
    \ i in  (n.to_f-1..1).step(1) do |i|\n      if i % i == 0 \n        return false\n\
    \      end\n    end if i % i > 0]\n    i = i + 2\n  end\n  return factors[-1]\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is great. I was looking for a solution\
    \ with no loops, that's why I came up with my own. Thank you very much!\n<|/ c\
    \ |>\n<| c |>\n`(1..n).inject(0) do |m, i| m += (i.to_f - 1..1).step(1).all? {\
    \ |i| (i % i == 0); end ? m : 0; end` This is quite inefficient. Just `n.to_f`\
    \ will do. And `each_cons(2)` can do better.\n<|/ c |>\n<| c |>\n, that's a beautiful\
    \ solution, but it's quite inefficient since it will first enumerate the whole\
    \ range and then filter it out. It's just `n.to_f`, no extra effort needed.\n\
    <|/ c |>\n<| c |>\nYes. But it can do better.\n<|/ c |>\n<| a tags=ruby,primes\
    \ dscore=1 |>\nHere's a naive algorithm using Ruby #each_cons and #all?. As other\
    \ answers have pointed out, this could cause exponential time if the input number\
    \ is very large. Here we assume n <= 10^100, and that n will only be 1 or 2 digits.\n\
    <code>", "  i = 2\n  while i * i <= n\n    i += 1\n  i\nend\n</code>\nNow we need\
    \ to find a way to determine prime factors. \n<code>", "  # TODO: Use Sieve of\
    \ Eratosthenes or similar algorithm\n  raise NotImplementedError\nend", "  factors\
    \ = []\n  prime_one = prime_one ? prime_one : primes(n)[0]\n  (2..n).each do |i|\n\
    \    while n % i == 0 do\n      factors << i\n      n /= i\n    end\n  end\n \
    \ factors << n\n  factors.uniq!\n  factors.reverse_each{|x| return x if x == prime_one}\n\
    \  factors.first\nend", "  return prime_factors(n)[0]\nend", "  a = 2\n  while\
    \ a < n\n    begin\n      next if n % (a * a)\n      a += 1\n    end\n  a\nend",
  "  factor = 0\n  while (n % 2 == 0)\n    n /= 2\n  while (n != 1)\n    n /= 2\n\
    \  while (n > 1)\n    if (n % 2 == 0)\n      n /= 2\n    factor = 2\n    while\
    \ (n % factor == 0)\n      n /= factor\n    factor++\n  end\n  factor\nend", " \
    \ # This algorithm is modified from Rosetta Code's Sieve of Eratosthenes\n  #\
    \ http://rosettacode.org/wiki/Sieve_of_Eratosthenes#Python\n  factors = []\n \
    \ p = 2\n  while p <= n:\n    factors.append(p)\n    for f in factors[(p*p):]:\n\
    \      while n % f == 0:\n        factors.remove(f)\n        n /= f\n    if n\
    \ == 1:\n      break\n    p += 1\n  factors.append(n)\n  return factors", '    return
    p | factors(n)[-1]', "  return prime_number(n) if prime_number(n) > n && n > 2\
    \ else n\nend", "  n.is_a?(Fixnum) ? n : largest_prime_factor(n.abs)\n  # return\
    \ n if n.is_a?(Integer) ? n : largest_prime_factor(n.abs)\n  n.prime? ? n : n.ceil.next_factor\
    \ * n.prime\nend", "  factors = []\n  i = 2\n  while i <= n do\n    while n %\
    \ i == 0 do\n      factors << i\n      n /= i\n    end\n    i += 1\n  end\n  return\
    \ n if n > 1\n  factors << n\n  return factors\nend", '    return n != 1 and 3
    * largest_prime_factor(n-1) or n', "  if n % 2\n    n / 2\n  else\n    3\n  end\
    \ = n\n  while n % 2\n    n = n / 2\n  end\n  n = 3\n  while n > 1\n    if n %\
    \ 2\n      n = n / 2\n    end\n    3\n  end\n  n\nend", "    prime_divisors =\
    \ []\n    divisor = 2\n    while divisor <= n\n        prime_divisors << divisor\n\
    \        divisor = 2\n        while divisor <= n / divisor\n            divisor\
    \ += 1\n    end\n    prime_divisors.min\nend", "  i = 2\n  factors = []\n  while\
    \ i * i <= n\n    factors.push(i)\n    i += 2\n  factors.each do |factor|\n  \
    \  return factor if n % factor == 0\n  end\n  prime_factors = []\n  i = 2\n  while\
    \ i * i <= n\n    prime_factors.push(i)\n    i += 2\n  end\n  prime_factors.each\
    \ do |factor|\n    factors = factors.delete(factor)\n  end\n  return n if factors.empty?\n\
    \  factors.reverse\nend\n  ", "  largest_prime_factor = nil\n  n.downto(1) do\
    \ |i|\n    if i > largest_prime_factor\n      largest_prime_factor = i\n    end\n\
    \    if n%i == 0 && !n%i == 0\n      break\n    end\n  end\n  largest_prime_factor\n\
    end", "  i = 1\n  while i * i <= n\n    i += 1\n  end\n  while n % i == 0\n  \
    \  n /= i\n    i = 1\n    while i * i <= n\n      i += 1\n    end\n  end\n  n\n\
    end", "  loop do\n    if n % i == 0 then\n      return i\n    elsif i % i == 0\
    \ then\n      return n / i\n    end\n    n = n / i\n  end\nend", "  i = 2\n  factor\
    \ = 1\n  while i <= n do\n    if n % i == 0 then\n      factor = max(factor,i)\n\
    \      break\n    i = i + 1\n  end\n  factor\nend", '  factors = []', "  factors\
    \ = []\n  if n <= 1\n    return n\n  i = 2\n  while i * i <= n\n    i += 1\n \
    \   factors.push i\n  i = 3\n  while i * i <= n\n    i = i * i\n    factors.push\
    \ i\n  i = 3\n  while i * i <= n\n    i = i * i\n    factors.push i\n  i = 2\n\
    \  while i * i <= n\n    i = i * i\n    factors.push i\n  return factors.max do\
    \ |f|\n    n % f\n  end\nend", "  factors = 2\n  factor = 2\n  while factors <\
    \ n do\n    while n % factor == 0 do\n      n /= factor\n      factor += 1\n \
    \   end\n    factors += factor\n  end\n  factor\nend", "  prime = nil\n  prime_candidate\
    \ = 2 # Prime candidates are 2 and 3, others start at 2\n  max_factor = 1", " \
    \ n.to_i\n  return n if n < 2 else n / 2\n  n.to_i\n  return n if n < 2 else n\
    \ / 2\n  n.to_i\nend\n</cell>\n<cell>\nlargest_prime_factor(n1)\nlargest_prime_factor(n2)\n\
    largest_prime_factor(n3)\nlargest_prime_factor(n4)\n</cell>\n<cell>", "  for i\
    \ in 2...n\n    return i * i if n % i == 0\n  end\nend", "  primes = prime_factors(n)\n\
    \  return primes.inject(:+) if primes.any?\n  end\nend", "  sieve = Array.new(81)\n\
    \  sieve[0] = n\n  i = 2\n  while sieve[i] * sieve[i-1] < n\n    i <<= 1\n  i\n\
    end", "  n = n.to_i\n  result = 1\n  i = 3\n  while i * i <= n\n    i += 1\n \
    \   result *= i\n  i = 3\n  while i < n\n    i += 2\n    result *= i\n  i = 3\n\
    \  while i < n\n    i += 4\n    result *= i\n  i = 3\n  while i < n\n    i +=\
    \ 8\n    result *= i\n  i = 3\n  while i < n\n    i += 16\n    result *= i\n \
    \ result\nend", "  primes = []\n  i = 2\n  while i <= n/i\n    if n % i == 0\n\
    \      primes << i\n      n /= i\n      while n % i == 0\n        n /= i\n   \
    \   i += 1\n    end\n  end\n  if n > 2\n    primes << n\n  end\n  primes.inject(:*)\n\
    end\n</cell>\n<text>\nPractice using the largest_prime_factor() function\n5. What\
    \ is the largest prime factor of the number 600851475143 ?", "  return n > 1 ?\
    \ (factors = 2, prime_factors(factors)[1] || 1, factors) : (factors = n, prime_factors(factors)[1],\
    \ factors)\nend", '  primes = []', "  factors = []\n  if n % 1 == 0\n    return\
    \ n\n  if n == 2\n    return 2\n  if n % 2 == 0\n    return n / 2\n  if n % 3\
    \ == 0\n    return n / 3\n  i = 3\n  while i*i <= n\n    return i / i\n  i = 5\n\
    \  while i*i <= n\n    factors << i\n    i += 2\n  i = 3\n  while i*i <= n\n \
    \   factors << i\n    i += 3\n  factors.max\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thank you very much for taking the time to explain it like this. It was helpful\
    \ to me, and I appreciate all the hard work you put into it too.\n<|/ c |>\n<|\
    \ a tags=ruby,factors dscore=1 |>\nRuby has a built-in method to factor numbers.\
    \ Just call it on the number you want to factor.\n<code>", '    return 2**(n-1).bit_length()
    if n else 1', "  i, j = 2, n / 2\n  while i * j <= n\n    i, j = i + 1, j + i\n\
    \  return j\nend", "  i = 1\n  factors = []\n  while i * i <= n\n    if n % i\
    \ == 0\n      i += 1\n    else\n      factors << i\n    end\n  end\n  factors.max\n\
    end", "  n = n / 2 # Ensure that n is a positive integer\n  if n <= 1 \n    1\n\
    \  else\n    largest_prime_factor_iterative(n)\n  end\nend", "  # Sieve of Eratosthenes\n\
    \  i = 2\n  sieve = []\n  while i * i <= n\n    sieve.push(i)\n    i += 2\n  end\n\
    \  \n  i = 2\n  while i < sieve.length\n    if sieve[i] <= n\n      return sieve[i]\n\
    \    end\n    i += 1\n  end\n  \n  return nil\nend", "  i = 2\n  while i <= n\
    \ / 2\n    if n % i == 0\n      i += 1\n    else\n      if i >= n / 2\n      \
    \  return i\n      end\n    end\n  end\n  return n\nend", "  i = 1\n  factors\
    \ = []\n  while i * i <= n\n    i += 1\n    factors << i\n  end\n  factors.uniq!\n\
    \  return factors.max.inject(1){|a,b| a * b }\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This solution would only work if the numbers being tested are positive (which\
    \ can be proven from the code). Negative numbers will break the code (because\
    \ `prime? - n` will give you a negative number, which will break your `i * i <=\
    \ n` condition).\n<|/ c |>\n<| c |>\n- you are correct, I did not consider negative\
    \ numbers, updated the answer to include checking for negative numbers\n<|/ c\
    \ |>\n<| a dscore=0 |>\nUsing recursive method we can find the largest prime factor\
    \ of a number. \n<code>", "  divisor = 2\n  while n > divisor\n    divisor = 3*divisor\
    \ + 1\n    n /= divisor\n  end\n  return divisor\nend", "  if n == 1 then return\
    \ n\n  i, p = 2, n / 2\n  while i <= p\n    i += 2\n    if n % i == 0 then return\
    \ i\n  end\n  return n\nend", "  i = 2\n  largest_prime = 1\n  while i * i <=\
    \ n\n    while n % i == 0\n      i = i + 1\n      if i == n # n is composite\n\
    \        largest_prime = i\n        break\n      end\n    end\n    i = i + 1\n\
    \  end\n  largest_prime\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
