name: HumanEval_60_sum_to_n
language: rb
prompt: "# sum_to_n is a function that sums numbers from 1 to n.\n# >>> sum_to_n(30)\n\
  # 465\n# >>> sum_to_n(100)\n# 5050\n# >>> sum_to_n(5)\n# 15\n# >>> sum_to_n(10)\n\
  # 55\n# >>> sum_to_n(1)\n# 1\ndef sum_to_n(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_to_n\n\
  \    candidate = method(:sum_to_n)\n    assert_equal(1, candidate.call(1))\n   \
  \ assert_equal(21, candidate.call(6))\n    assert_equal(66, candidate.call(11))\n\
  \    assert_equal(465, candidate.call(30))\n    assert_equal(5050, candidate.call(100))\n\
  \  end\nend\n"
completions: ["  sum = 1\n  for i in 1..n\n    sum *= i\n    sum += sum / n\n  sum\n\
    end\n</cell>\n<cell>\nsum_to_n(501)\n</cell>\n<cell>\nsum_to_n(20000)\n</cell>\n\
    <cell>\nsum_to_n(-4)\n</cell>\n<cell>\nsum_to_n(0)\n</cell>\n<text>\nThe sum of\
    \ the first n perfect square numbers is given by the formula,", "  # Return a\
    \ function that sums numbers from 0 to n.\n  # We are passing n to the function\
    \ and returning a function\n  # that sums 1 to n.\n  return lambda i: sum(range(i+1))",
  "  result = 1\n  for i in (1..n)\n    result *= i\n  result\nend", "    sum_to_n_helper(0,\
    \ n)\nend", "  sum = 0\n  for i in 1..n\n    sum += i\n  end\n  sum\nend\n</code>\n\
    Notice that sum_to_n(n) doesn't change value of n after it's assigned, so I can\
    \ use it with any other variable or expression, like sum_to_n(n+1)\n<code>", " \
    \ sum = n \n  i = 1\n  while i <= n\n    sum = sum + i\n    i += 1\n  sum\nend\n\
    </cell>\n<cell>\nsum_to_n(10)\n</cell>\n<text>\nProblem 7\nWrite a function print_to_n_using_while()\
    \ that prints numbers 1 to n using a while-loop.", "  sum = n\n  while n > 1\n\
    \    sum *= n\n    n -= 1\n  end\n  sum\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nWhy are you using the `i` variable in the recursive definition of the function?\n\
    <|/ c |>\n<| c |>\nBecause I was looking for a way to get rid of the loop. Forgot\
    \ to delete that line. Fixed. Thanks!\n<|/ c |>\n<| a dscore=0 |>\nThe code for\
    \ the recursive function would be:\n<code>", "  # initialize sum and count\n \
    \ sum = 0\n  count = 0\n  \n  # use for loop to sum numbers 1 to n\n  for num\
    \ in 1..n\n    # add number to sum\n    sum += num\n    # increment count\n  \
    \  count += 1\n  end\n  \n  # return sum\n  sum\nend\n</cell>\n<code language=julia-1.1>\n\
    sum_to_n(5)\n</cell>\n<text>\nFor loops in Julia are different than those in other\
    \ languages. The for loop goes through each element of the iterable. For instance,\
    \ for an array or an enumerable such as an array, you can use for to iterate through\
    \ the elements.", "  result = 0\n  for i in 1..n\n    result *= i\n    result\
    \ += i\n  end\n  result\nend", "  return sum_to_n_aux(n)\nend", "  n.times do\
    \ |i|\n    i += 1\n  end\n  n\nend", "  i = 1\n  s = 0\n  while i < n\n    s +=\
    \ i\n    i += 1\n  s\nend", "  ((1..n).inject :+) rescue n\nend\n</code>\n<|/\
    \ a tags=ruby dscore=5 |>\n<| c |>\nIt's interesting that this returns 0 for n=0\
    \ when OP asked for it. Also interesting that this returns 0 for n=1 when OP asked\
    \ for it. +1.\n<|/ c |>\n<| c |>\nIt returns 0 for n=0 when OP asked for it because\
    \ 0 is falsey (null or falsey), so it returns 0 by default. The same applies for\
    \ n=1. Check [this](http://stackoverflow.com/questions/7052413/ruby-equivalent-of-phps-ternary-operator)\n\
    <|/ c |>\n<| c |>\nI actually like this method better than the accepted one because\
    \ it doesn't require any additional method calls.\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>", "  n = n.to_i\n  return if n < 2\n  sum_to_n(n/2)+n%2==1 ? n : sum_to_n(n-2)\n\
    end", "  n.times do |i|\n    n += 1 if n == i\n  end\n  n\nend", "  result = 0\n\
    \  for i in 1..n\n    result += i\n  end\n  result\nend\n</cell>\n<cell>\nsum_to_n(10)\n\
    </cell>\n<cell>\nsum_to_n(100)\n</cell>\n<cell>\nsum_to_n(5)\n</cell>\n<cell>\n\
    sum_to_n(3)\n</cell>\n<text>\nRecall that in Ruby when we are not using the variable\
    \ \"sum\" we must use the special variable \"@sum\" instead.", "  n.times.map\
    \ {|i| i}.reduce(:+)\nend", "  sum = 0\n  while n != 0\n    sum += n\n    n -=\
    \ 1\n  sum\nend", "  n.zero? ? n : n + sum_to_n (n - 1)\nend", "  n.downto(1).inject(:+).to_f\n\
    end", "  ((n>1)? n*(n-1)/2: n)\nend", "    sum = 0\n    (1..n).each do |i|\n \
    \       sum += i\n    end\n    sum\nend\n</cell>\n<cell>", "  n.times do |i|\n\
    \    sum+=i\n  end\n  sum\nend", "  result = 1\n  for i in 1..n\n    result *=\
    \ i\n  end\n  result\nend", "  sum = 1\n  n.times do\n    sum += rand\n  end\n\
    \  sum\nend\n</cell>\n<cell>", "    if n == 0\n        1\n    else\n        ((n%4==0\
    \ and n!=0 and n%100!=0 and n%400!=0) ? n+sum_to_n(n-1) : n)*sum_to_n(n-1)\n \
    \   end\nend", "  result = 1\n  for i in (1..n)\n    result *= i\n    result %=\
    \ 10**10\n  end\n  return result\nend\n</cell>\n<code language=julia-0.6>\nsum_to_n(30)\n\
    </cell>\n<code language=julia-0.6>\nsum_to_n(100)\n</cell>\n<code language=julia-0.6>\n\
    sum_to_n(5)\n</cell>\n<code language=julia-0.6>\nsum_to_n(10)\n</cell>\n<code\
    \ language=julia-0.6>\nsum_to_n(1)\n</cell>\n<text>\nTask 1: Implement the function\
    \ to_n_in_words_with_symbols(n) that converts integer to words and also shows\
    \ some symbols such as \u23EC, \u2308, \u2329, etc.", "  one = 1\n  two = 1\n\
    \  three = 1\n  four = 1\n  five = 1\n  six = 0\n  nine = 1\n  ten = 1\n  twenty_one\
    \ = 1", "  1.upto(n) do |i|\n    sum += i\n  end\n  sum\nend", "    sum = nil\n\
    \    1.upto(n) do |i|\n        sum += i\n    end\n    return sum\nend", "  sum_to_n_count\
    \ = 0\n  sum_to_n_count += 1 if (n % 6) == 0 else 0\n  sum_to_n_count += 2 if\
    \ (n % 18) == 0 else 0\n  sum_to_n_count += 3 if (n % 7) == 0 else 0\n  sum_to_n_count\
    \ += 4 if (n % 15) == 0 else 0\n  sum_to_n_count += 5 if ((n + 1) % 10) == 0 else\
    \ 0\n  sum_to_n_count += 6 if ((n + 1) % 30) == 0 else 0\n  sum_to_n_count +=\
    \ 7 if ((n + 1) % 35) == 0 else 0\n  sum_to_n_count += 8 if ((n + 1) % 40) ==\
    \ 0 else 0\n  sum_to_n_count += 9 if ((n + 1) % 45) == 0 else 0\n  sum_to_n_count\
    \ += 10 if ((n + 1) % 50) == 0 else 0\n  sum_to_n_count += 11 if ((n + 1) % 55)\
    \ == 0 else 0\n  sum_to_n_count += 12 if ((n + 1) % 60) == 0 else 0\n  sum_to_n_count\
    \ += 13 if ((n + 1) % 70) == 0 else 0\n  sum_to_n_count += 14 if ((n + 1) % 80)\
    \ == 0 else 0\n  sum_to_n_count += 15 if ((n + 1) % 90) == 0 else 0\n  sum_to_n_count\
    \ += 16 if ((n + 1) % 105) == 0 else 0\n  sum_to_n_count += 17 if ((n + 1) % 110)\
    \ == 0 else 0\n  sum_to_n_count += 18 if ((n + 1) % 115) == 0 else 0\n  sum_to_n_count\
    \ += 19 if ((n + 1) % 120) == 0 else 0\n  sum_to_n_count += 20 if ((n + 1) % 135)\
    \ == 0 else 0\n  sum_to_n_count += 21 if ((n + 1) % 140) == 0 else 0\n  sum_to_n_count\
    \ += 22 if ((n + 1) % 145) == 0 else 0\n  sum_to_n_count += 23 if ((n + 1) % 150)\
    \ == 0 else 0\n  sum_to_n_count += 24 if ((n + 1) % 155) == 0 else 0\n  sum_to_n_count\
    \ += 25 if ((n + 1) % 160) == 0 else 0\n  sum_to_n_count += 26 if ((n + 1) % 165)\
    \ == 0 else 0\n  sum_to_n_count += 27 if ((n + 1) % 170) == 0 else 0\n  sum_to_n_count\
    \ += 28 if ((n + 1) % 175) == 0 else 0\n  sum_to_n_count += 29 if ((n + 1) % 180)\
    \ == 0 else 0\n  sum_to_n_count += 30 if ((n + 1) % 185) == 0 else 0\n  sum_to_n_count\
    \ += 31 if ((n + 1) % ", "  sum = 0\n  while n > 0\n    sum += n\n    n -= 1\n\
    \  end\n  sum\nend\n</cell>\n<text>\nLet's see it in action!", "    number_sum\
    \ = 0\n    i = n\n    until i <= 1 do\n        number_sum = number_sum + i\n \
    \       i = i - 1\n    end\n    return number_sum\nend\n</cell>\n<code language=julia-1.5>\n\
    sum_to_n(10)\n</cell>\n<text>\nAs an exercise: Write a function that takes a number\
    \ and returns the sum of all the numbers from 1 to that number, inclusive.", " \
    \ if n <= 0\n    puts \"n must be greater than 0.\"\n    return\n  end\n  n.times\
    \ do |i|\n    print \"#{i}. \"\n  end\n  print \"#{n}.\"\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a |>\nTry this - \n<code>", "  return 1 if n<2 else n*(n+1)/2\n\
    end", "  return 1 if n <= 0 end\n  sum_to_n(n - 1) + sum_to_n(n - 2)\nend\n  \n\
    \  ", "    n.times do\n        sum_to_n n\n    end\nend", "  return n if n.zero?\
    \ or n <= 0 \n  ((n.succ + ((n.pred * n) / 2)) % n).to_s\nend", "  # The sum is\
    \ calculated by adding the first n numbers (1..n) to the\n  # first n numbers\
    \ (1..n-1), then adding 2n-1 to 2n, and so on \n  ((1..n).inject(:+) + (1..n-1).inject(:+)\
    \ + (2n-1).inject(:+) ... (n-1).inject(:+))\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| a tags=ruby |>\nAn elegant solution using inject. Ruby 2.4 (with ruby23-dev)\
    \ can do this elegantly with Enumerable#each_cons:\n<code>\n(1..5).each_cons(2).sum\
    \ { |a, b| a + b }", "  sum = 0\n  i = 1\n  while i <= n\n    sum = sum + i\n\
    \    i = i + 1\n  end\n  sum\nend\n</cell>\n<cell>\nsum_to_n\n</cell>\n<cell>\n\
    %load solutions/sum_to_n.rb\n</cell>\n<cell>", "  # Create a string containing\
    \ numbers from 0 to n.\n  numbers = 0.upto(n).collect {|i| i+1}\n  # Return the\
    \ sum of the numbers in the string.\n  numbers.reduce(:+)\nend", "  sum = nil\n\
    \  2.times do |i|\n    sum += i\n  end\n  return sum if n > 0\n  return sum if\
    \ n <= 0\n  raise \"n too small\" if n <= 1\n  raise \"n too large\" if n > 100\n\
    \  raise \"n not positive\" if n < 0\n  raise \"n not zero\" if n == 0\n  raise\
    \ \"n not negative\" if n < 0\n  raise \"n not zero\" if n == 0\nend", '  return
    1 if n==0 else n*(n+1)/2', "  sum = 1\n  while n > 0 do\n    sum = sum + n % 10\n\
    \    n = n / 10\n  end\n  sum\nend\n</cell>\n<text>\nNow let's find the sum of\
    \ the first 1000 prime numbers:", "  sum = 0\n  n.times do |i|\n    sum += i\n\
    \  end\n  sum\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThe `map` function does\
    \ not work in Ruby 2.1.1 (`map { |i| i + 2 }` works fine though)\n<|/ c |>\n<|\
    \ c |>\nRuby 2.1.1 had a bug which had affected map as well as the lambda form\
    \ in earlier versions. I'm sure they've fixed it now. :)\n<|/ c |>\n<| a tags=ruby,lambda\
    \ |>\nI know it's been a while since you asked, but:\n<code>\nlambda { |n| n *\
    \ (lambda { |n| n * 2 }).call(n + 1) }.call(1)\n</code>\nis quite readable, and\
    \ probably faster than the other proposed solutions.\n<|/ a dscore=4 |>\n<| c\
    \ |>\nThis also works if the outer lambda is defined in the same scope as the\
    \ inner lambda. Many Ruby programmers prefer this over the solution above since\
    \ it makes it clear what inner lambda you are referring to.\n<|/ c |>\n<| c |>\n\
    I prefer the use of lambda's for readability over other solutions.\n<|/ c |>\n\
    <| a dscore=4 |>\nAnother one\n<code>", "    total = 1\n    while n > 1 do\n \
    \       total = total + n\n        n = n - 1\n    end\n    total\nend", "  sum\
    \ = 0\n  while n > 0\n    sum += n\n    n -= 1\n  sum\nend\n</code></pre>\n  \
    \          </div>\n            \n        </div>\n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n", "  return 0 + (n.to_s.size==0) ? 1 : n.to_s.reduce(0,:+) \nend", "   \
    \ sum = 1\n    until n == 0 do\n        sum = sum + n\n        n = n - 1\n   \
    \ end\n    return sum\nend\n</cell>\n<code language=julia-0.6>\nsum_to_n(30)\n\
    </cell>\n<text>\nHow do you know when your algorithm is working correctly?", " \
    \ # return None if n is less than 1\n  return n if n >= 1 else None\nend", " \
    \   sum = n.to_i\n    until n > 0 do\n        sum += n\n        n -= 1\n    end\n\
    \    sum\nend", "  if n < 0\n    raise ArgumentError, \"n must be positive\"\n\
    \  n -= 1\n  return n and (n+1) * sum_to_n(n-1) or 1\nend", "  return if n <=\
    \ 0\n  (1..n).reduce(&:+)\nend\n</cell>\n<text>\nExercise 3: Find a fibonacci\
    \ number between 0 and $n$", "  if n <= 0\n    puts \"Invalid input: #{n}\"\n\
    \    exit\n  end\n  n.times do\n    puts n\n    n += 1\n  end\n  puts n\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nNice solution. One suggestion: instead of\
    \ using `puts` and `exit` inside the function, you could use `return`. This will\
    \ return the value from the function directly and you can check it directly in\
    \ the main program.\n<|/ c |>\n<| c |>\n`return` works only when the method contains\
    \ one statement, and this is clearly not the case here.\n<|/ c |>\n<| c |>\nI\
    \ didn't say it wouldn't work, I said it wouldn't be a good solution since it\
    \ does an extra function call and a return, when there's another way to do it\
    \ without having to do any of that :)\n<|/ c |>\n<| c |>\nBut as you can see,\
    \ `return` does indeed work. I tested it with `def f()  return 3; end; puts f();\
    \ puts f()`. It outputs `3` and then `nil`.\n<|/ c |>\n<| a tags=ruby |>\nThe\
    \ most natural way to do this is with a loop. Ruby has a looping construct, each,\
    \ that iterates over the contents of a collection and yields the items to blocks.\
    \ We can use that to create an infinite loop by repeating the block until the\
    \ collection is empty. We can use Array#sum to add the elements in each iteration\
    \ to total the elements up to that point. \n<code>\n(1..Float::INFINITY).each\
    \ do |n|\n  print n.to_s, ' ', n.to_s.sum\nend\n</code>\n<|/ a dscore=4 |>\n<|\
    \ c |>\nThat's a neat trick, but only works in Ruby versions >= 2.0. `(1..Float::INFINITY).each\
    \ do |n| print n.to_s, ' ', n.to_s.sum; end` outputs `1 1` for me.\n<|/ c |>\n\
    <| c |>\n: This is because your range starts at `1`, so you get `1 1 1` rather\
    \ than `1 2 3`. The first iteration sums up to `3` and the second iteration sums\
    \ up to `4`, hence the result. To get `1 2 3`, you'd have to start at `0`.\n<|/\
    \ c |>\n<| c |>\nYes it does work, I just tried it out. But I'm still curious\
    \ as to why it doesn't work with `(1...Float::INFINITY)` as you say.\n<|/ ", " \
    \ sum = 0\n  for i in 1..n\n    sum += i\n  end\n  sum\nend\n</code>\nThe next\
    \ problem is that you're trying to create a recursive function with a loop. That\
    \ is not possible in Ruby, so you need to use a while loop instead.\nThe code\
    \ would be:\n<code>", "  sum = 0\n  n = 1\n  while n <= n\n    sum += n\n    n\
    \ += 1\n  return sum\nend\n</code>\nSo now you have sum_to_n ready to use. Let\u2019\
    s put it into Ruby syntax:\n<code>\nsum_to_n = ->(number) { number.to_s.scan(/\\\
    d+/).inject(0) { |sum, number| sum + number.to_i } }\n</code>\nAnd test it out:\n\
    <code>\n> sum_to_n(10)\n=> 55\n</code>\nThat\u2019s so cool! I mean, I think it\
    \ is cool! And I think it\u2019s pretty cool! But I don\u2019t think it reads\
    \ well. That\u2019s why I\u2019d rather use a loop instead.\n<code>\nsum_to_n\
    \ = ->(number) { number.to_s.scan(/\\d+/).inject(0) { |sum, number| sum + number.to_i\
    \ } }", "  sum_to_n = 1 + n\n  while n != 0\n    sum_to_n = sum_to_n + (n - 1)\n\
    \    n -= 1\n  sum_to_n\nend", "  sum = 0\n  for num in (1..n).to_a\n    sum +=\
    \ num\n  end\n  sum\nend", "  s = 0\n  for i in 1..n\n    s += i\n  end\n  s\n\
    end", "  sum_to_n.val = sum_to_n.val + (n-sum_to_n.val) if sum_to_n.val < n else\
    \ 0\n  sum_to_n.val\nend", "  return 1 if n <= 2 else n*(n-1) + sum_to_n(n-1)\n\
    end", "  return n.times.reduce(:+)\nend", "  sum = 1\n  1.upto(n){|i| sum = sum\
    \ + i }\n  sum\nend", "  # return 0 if n is less than 1\n  return 0 if n < 1 else\
    \ n*(n+1)/2", "  sum = 1\n  n.times do\n    sum += rand\n  end\n  sum\nend", " \
    \ i = 1\n  total = 0\n  while i <= n\n    total = total + i\n    i = i + 1\n \
    \ end\n  return total\nend", "  total = 1\n  1.upto(n) { |x| total += x }\n  total\n\
    end\n</code>\n<|/ a dscore=4 tags=ruby |>\n<| c |>\nAhh, that's a better way to\
    \ do it.\n<|/ c |>\n<| c |>\nThat's just plain ruby.  It's a good answer.  I wish\
    \ I could vote it up more.\n<|/ c |>\n<| c |>\nI guess this would be a good answer\
    \ if you made `total` a local variable so as to improve performance.  Ruby is\
    \ quite fast and compilers can optimize local variables better than a global.\n\
    <|/ c |>\n<| a dscore=4 tags=ruby |>\nThe simplest way:\n<code>", "  sum = 0\n\
    \  for i in (1..n)\n    sum += i\n  return sum\nend", "    # Initialize an accumulator\n\
    \    total = 0", "  sum = 0\n  for i in 1..n\n    sum += i\n  end\n  sum\nend\n\
    </code>\n<|/ a |>\n<| a dscore=0 tags=ruby |>\n<code>", "  (0..n).reduce(:+).to_i\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThe first solution is much faster.\
    \ Thanks much!\n<|/ c |>\n<| c |>\nYour solution has a memory leak. You've got\
    \ memory allocated to the result array, then you allocate memory to hold the intermediate\
    \ results. The second solution should be much faster since it doesn't keep a bunch\
    \ of ruby objects in memory.\n<|/ c |>\n<| c |>\n`def sum_to_n(n)\n  1.upto(n){|i|\
    \ i + i}.to_i\nend`\n<|/ c |>\n<| c |>\n`sum_to_n` has a bug: `sum_to_n(10)` returns\
    \ `55`, when it should be `60`.\n<|/ c |>\n<| c |>\n, Thanks, fixed it.\n<|/ c\
    \ |>\n<| a dscore=5 |>\n<code>", "  sum = 0\n  1.upto(n){|i| sum += i}\n  sum\n\
    end", "{\n  return n * (n + 1) / 2\n}", "  total = 0\n  x = 1\n  while x <= n\n\
    \    total += x\n    x += 1\n  total\nend", "  if n < 0 then\n    error(\"n must\
    \ be positive\")\n  else\n    local result = 1\n    while n ~= 0 do\n      result\
    \ = result + n\n      n = n - 1\n    end\n  end\n  return result\nend", "  # Only\
    \ change code below this line\n  total = 0\n  i = 0\n  while i < n\n    total\
    \ += i\n    i += 1\n  return total\nend", "  sum = 0\n  while n > 0\n    sum +=\
    \ n\n    n -= 1\n  end\n  sum\nend", "  sum = 0\n  n.times do |i|\n    sum = sum\
    \ + i\n  end\n  sum\nend", "  sum_of_factorials = nil # initialize to nil\n  factorial\
    \ = 1\n  \n  while n > 0\n    # add factorial to the running total\n    sum_of_factorials\
    \ += factorial\n    # increment the factorial\n    factorial *= n\n    # subtract\
    \ 1 from the number\n    n -= 1\n  end\n  \n  # return the result\n  sum_of_factorials\n\
    end\n</cell>\n<text>\nPart 3: Recursive Solutions\nThe sum_to_n function above\
    \ uses loops and an accumulator, but a recursive function has less code and fewer\
    \ bugs. We'll make sum_to_n recursive so that it doesn't use loops and accumulators.",
  "  if n <= 0\n    throw ArgumentError.new(\"n must be positive\")\n  elsif n ==\
    \ 1\n    1\n  else\n    n * (1 + sum_to_n(n-1))\n  end\nend", "  n.zero? ? 1 :\
    \ n.succ * sum_to_n(n.succ)\nend", "  n.times do\n    return sum_to_n_aux(1) +\
    \ sum_to_n_aux(2)\n  end\n  return n\nend", "  result = 0\n  (1..n).each do |i|\n\
    \    result += (n / i)\n  end\n  result\nend\n</cell>\n<cell>", "  sum = 0\n \
    \ 1.upto(n) { |i| sum += i }\n  sum\nend", "  if n==0\n    1\n  else\n    n+sum_to_n(n-1)\n\
    \  end\nend", "    sum = 1\n    n.times do |i|\n      sum += i\n    end\n    sum\n\
    end\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "  sum = 0\n  for i in 1..n\n\
    \    sum = sum + i\n  end\n  return sum\nend\n</cell>\n<text>\nA problem that\
    \ looks like a good candidate for recursion, is a simple problem. But, actually,\
    \ we have one more condition than the other problems:", "  sum = 1\n  (1..n).each\
    \ do |i|\n    sum = sum + i\n  end\n  sum\nend", "  return 1 if n < 5 else n*(n+1)/2\n\
    end\n</cell>\n<text>\nNow sum_to_n(5) should return 15, sum_to_n(30) should return\
    \ 45, and sum_to_n(100) should return 5050.", "  # Write your code here.\n  return\
    \ n*(n+1)/2\nend\n</cell>\n<code language=julia-1.5>\nsum_to_n(10)\n</cell>\n\
    <code language=julia-1.5>\nsum_to_n(30)\n</cell>\n<code language=julia-1.5>\n\
    sum_to_n(100)\n</cell>\n<text>\nFunctions in Julia", "  if n == 0\n    1\n  else\n\
    \    sum_to_n(n - 1) + n\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nHmm, what happens\
    \ if you run this with `sum_to_n(4)`? Do you get the correct result?\n<|/ c |>\n\
    <| c |>\n, yes, it gives correct result. 4 is first number in `1, 2, 3, 4` sequence.\n\
    <|/ c |>\n<| c |>\nThe `if/else` statement is pointless when you can just use\
    \ `return sum_to_n(n-1) + n`.\n<|/ c |>\n<| c |>\n, thanks! I forgot about `sum_to_n(n-1)\
    \ + n`. That's why I wrote this comment. Thanks again!\n<|/ c |>\n<| c |>\nThanks\
    \ for explaining recursive functions, it helped a lot! I've upvoted your answer,\
    \ but because I'm a newbie, I'm getting this message now: \"Vote Up requires 15\
    \ reputation\", so I'll come back tomorrow and vote you up once I reach 15 rep.\n\
    <|/ c |>\n<| a |>\nThe code you posted does not seem to work the way you think\
    \ it does.  If your code is wrong, then the code you posted is wrong.\nI suggest\
    \ that you just copy and paste the code you have into an IRB console and play\
    \ with it until you understand the concepts.  Once you understand the concepts,\
    \ you'll see that your code is wrong.  Then fix the code.\n<|/ a tags=ruby,recursion,ruby-on-rails\
    \ dscore=1 |>\n<| a |>\nIf I had to write such a method, the way I'd do it would\
    \ be:\n<code>", "    sum = 0\n    while n > 0\n        sum += n\n        n -=\
    \ 1\n    return sum\n</code>\n<|/ a tags=recursion,python |>\n<| c |>\nI understand\
    \ the concept of the sum_to_n function, but I don't understand why the sum_to_n\
    \ function is called recursively in the last line of your code.\n<|/ c |>\n<|\
    \ c |>\nThe recursive call is needed to get the sum of numbers up to a certain\
    \ point. By passing in a positive number, it stops calling the function again\
    \ and returns the sum. By passing in a negative number, it continues calling the\
    \ function and adds all the numbers above it.\n<|/ c |>\n<| c |>\nI still don't\
    \ understand why it has to be called recursively. What does it mean to sum numbers\
    \ up to the point where you get to a certain point (i.e. the value you pass in)?\n\
    <|/ c |>\n<| c |>\nThe code I wrote gives you the sum of the numbers up to a certain\
    \ point passed in. It does this recursively. The function sum_to_n does this for\
    \ you.\n<|/ c |>\n<| c |>\nBut it does the same thing without calling the function\
    \ recursively, and I understand that your function sum_to_n is doing this recursively.\
    \ Why are we calling the function recursively? What is the difference between\
    \ calling it recursively and calling it normally?\n<|/ c |>\n<| a tags=recursion,python\
    \ |>\nThe other answers here are correct, I just want to give a more indepth explanation.\
    \ \nLet's say you have a list of numbers that you want to sum, what is a better\
    \ approach than a simple for loop?\nThe first thing that comes to mind is recursion.\
    \ The other answers here gave the example of sum_to_n(n), which is a function\
    \ that will return a value. \nLet's say you have a function which takes a list\
    \ and returns a value:\n<code>", "  return n*(n+1)/2\nend\n</cell>\n<text>\nRecursion\n\
    Recursion allows us to define a function to be invoked with another function as\
    \ input. Recall, a recursive function is a function that invokes the function\
    \ itself as part of its computation. For example, we can calculate the factorial\
    \ of a number as follows:", "  sum = 0\n  (1..n).each { |x| sum += x }\n  sum\n\
    end", "  total = 0\n  i = 0\n  while i < n\n    total += i\n    i += 1\n  puts\
    \ total\nend\n</code>\n<|/ a dscore=3 tags=ruby |>\n<| c |>\nThanks. I am also\
    \ looking to improve my skills with ruby.\n<|/ c |>\n<| a |>\n<code>", "  sum_to_n_aux(n,\
    \ 1, 1, [], 0)\nend", "  return n * n # multiply n by n and then add up all numbers\n\
    end\n  ", "  if n < 0\n    raise \"n must be nonnegative\"\n  if n == 0\n    return\
    \ 1\n  sum = 0\n  while n != 0\n    sum += n\n    n -= 1\n  sum\nend", "  if n\
    \ < 0\n    return -1\n  sum = 0\n  for i in 1..n\n    sum += i\n  return sum\n\
    </cell>\n<cell>\nsum_to_n(10)\n</cell>\n<text>\nProblem 8 (1.5 points)", "  total\
    \ = 0\n  for number in 1..n\n    total += number\n  end\n  total\nend", "  (n\
    \ + 1).even?\n    sum_to_n((n + 1).modulo(2))\n  else\n    n\nend\n        </pre>\n\
    \      </div>\n      <div data-region=\"highlight\"></div>\n    </div>\n    <div\
    \ data-region=\"source\">\n      <div id=\"toggle-code\" class=\"toggle-button\"\
    >\n        <pre>", "  total = 0\n  for i in 1..n\n    total += i\n  end\n  total\n\
    end\n</cell>\n<cell>\nsum_to_n?\n</cell>\n<cell>\nsum_to_n(10)\n</cell>\n<cell>",
  "  n.times do\n    sum = sum + rand(-100,100)\n  end\n  return sum\nend", "  # TODO:\
    \ Your code here!\n  return n\nend\n</cell>\n<text>\nAfter implementing the above\
    \ function, we can test our sum_to_n function.", "  return 0 if n < 0 else n +\
    \ sum_to_n(n - 1)\nend\n</cell>\n<code language=julia-1.5>\nsum_to_n(10)\n</cell>\n\
    <code language=julia-1.5>", "  (n == 0) ? 1 : n * (sum_to_n(n-1) + 1)\nend\n</cell>\n\
    <text>\nRecursive functions may look similar to the ones we encountered in the\
    \ previous chapter, but they have the following differences:", "  n.times do |i|\
    \ sum += i end\n  sum\nend\n</cell>\n<text>\nWe then define sum_to_n_recursive.\
    \ Again, we use the sum_to_n function as its base, but recurse down to a single\
    \ value. The function below is written to accommodate summing up values from 0\
    \ to 100. We'll see an example of a recursive function and how to use it more\
    \ below.", "  # Declare sum and n\n  sum = 0\n  # While there are still numbers\
    \ to sum\n  while n > 0\n    # Add one to the sum\n    sum = sum + n\n    # Decrement\
    \ n\n    n = n - 1\n  # Return the sum\n  sum\nend", "  return n if n < 10 else\
    \ (sum_to_n(n - 1) + n)\nend\n</cell>\n<text>\nNotice how the recursion is pushed\
    \ down into the function body! This is very important, as Python functions are\
    \ first class objects which means you can pass them around and use them in other\
    \ functions.", "  return n*(1..n).reduce(:+)\nend", "  sum = 1\n  for i in (1..n).to_a\n\
    \    sum += i\n  end\n  sum\nend\n</cell>\n<text>\nWe can also do this in one\
    \ line.", "  # Only change code below this line\n  return (n * (n + 1)) / 2\n\
    end\n</cell>\n<text>\nEven though the formula is simple and clean, implementing\
    \ it in a program is still a challenge. Fortunately, Julia has a built-in function\
    \ nsum for computing sum over a range of numbers:", "  sum = 0\n  for i in 1...n\n\
    \    sum += i\n  end\n  sum\nend", "  sum = 0\n  for i in 1...n\n    sum = sum\
    \ + i\n  end\n  sum\nend", "  if n < 1\n    0\n  else\n    n * (n-1) + sum_to_n\
    \ (n-2) \n  end\nend", "  (0...n).inject(:+).to_s\nend\n</cell>\n<code language=ruby-1.9.3-p448>",
  "  sum = 0\n  while n != 0\n    sum += n\n    n -= 1\n  end\n  sum\nend\n</code></pre>\n\
    </div>\n</div>\n<p>In Python, indentation means that we start a new level of nesting.\
    \ A code block can therefore contain other code blocks. For example:</p>\n<div\
    \ class=\"sourceCode\" id=\"cb42\"><pre class=\"sourceCode ruby\"><code class=\"\
    sourceCode ruby\"><a class=\"sourceLine\" id=\"cb42-1\" data-line-number=\"1\"\
    >def factorial(n) </a>\n<a class=\"sourceLine\" id=\"cb42-2\" data-line-number=\"\
    2\">  result = 1</a>\n<a class=\"sourceLine\" id=\"cb42-3\" data-line-number=\"\
    3\">  <span class=\"co\"># if n is 0 or 1, result is 1</span></a>\n<a class=\"\
    sourceLine\" id=\"cb42-4\" data-line-number=\"4\">  <span class=\"kw\">if</span>\
    \ n == 0 </a>\n<a class=\"sourceLine\" id=\"cb42-5\" data-line-number=\"5\"> \
    \   result </a>\n<a class=\"sourceLine\" id=\"cb42-6\" data-line-number=\"6\"\
    >  <span class=\"kw\">elsif</span> n == 1 </a>\n<a class=\"sourceLine\" id=\"\
    cb42-7\" data-line-number=\"7\">    result </a>\n<a class=\"sourceLine\" id=\"\
    cb42-8\" data-line-number=\"8\">  <span class=\"kw\">else</span> <span class=\"\
    co\"># n &gt; 1, multiply result by n</span></a>\n<a class=\"sourceLine\" id=\"\
    cb42-9\" data-line-number=\"9\">    result </a>\n<a class=\"sourceLine\" id=\"\
    cb42-10\" data-line-number=\"10\">    result <span class=\"op\">*=</span> n</a>\n\
    <a class=\"sourceLine\" id=\"cb42-11\" data-line-number=\"11\">  <span class=\"\
    kw\">end</span>\n<a class=\"sourceLine\" id=\"cb42-12\" data-line-number=\"12\"\
    >  result</a>\n<a class=\"sourceLine\" id=\"cb42-13\" data-line-number=\"13\"\
    >end</a></code></pre></div>\n<p>Here, we have two code blocks: the first one is\
    \ the function definition and the second one is the if/else statement. We also\
    \ have a keyword <span class=\"co\">#</span> that denotes a comment in Ruby. Ruby\
    \ also supports multiline comments. A multiline comment starts with a forward\
    \ slash and ends at the end of the line. This code block starts with the slash\
    \ on the line above and is indented by four spaces. Other lines are indented by\
    \ four spaces. As the comment starts on the line above, we have to indent the\
    \ code block by four spaces. This is what we write in the above example as <code\
    \ class=\"language-\"><a class=\"sourceLine\" id=\"cb42-2\" data-line-number=\"\
    2\">result </a></code>. On the line below, we have used the keyword <span class=\"\
    kw\">end</span> to terminate the code block. As there is no other code block in\
    \ this code block, we do not indent this one. The program ", "  if n<=0\n    return\
    \ n\n  sum=0\n  for i in 1...n\n    sum+=i\n  end\n  sum\nend", "  sum = 0\n \
    \ loop do\n    sum += rand\n    break if sum >= n\n  end\n  sum\nend\n</code>\n\
    The loop keyword is a looping construct that allows you to loop through an enumerable\
    \ collection of items.  In this case loop is a method that returns a block of\
    \ Ruby code that runs until a break is encountered.  The loop will execute the\
    \ block until a break is encountered.  In this case, the block is executed until\
    \ sum meets the condition sum >= n.\nThe first parameter to loop can be any number\
    \ of parameters.  In this case, loop is expecting one parameter, and we are passing\
    \ in another parameter sum.  As long as sum is less than or equal to n, then the\
    \ loop will execute until sum is equal to or greater than n, and the method returns\
    \ the value of sum.  The first parameter can be any number of parameters, but\
    \ in this case we are passing only one parameter to the method called n.\n<|/\
    \ a dscore=5 |>\n<| c |>\nThis is very well thought out and helpful! Just what\
    \ I was looking for. Thanks!\n<|/ c |>\n<| c |>\nThis is a great answer, I wish\
    \ I could upvote it more than once. I've used this construct in other places in\
    \ my code and it has come in handy.\n<|/ c |>\n<| c |>\nThis is also a great answer,\
    \ but I'd like to add that I really enjoyed the way the variable sum is handled.\n\
    <|/ c |>\n<| c |>\nThis answer deserves more up votes. Great explanation.\n<|/\
    \ c |>\n<| c |>\nThanks for sharing this.  It helped me to understand looping\
    \ a bit better.\n<|/ c |>\n<| a tags=ruby |>\nThe general pattern I use is this:\n\
    <code>", "  sum = 0\n  i = 0\n  while i < n\n    sum = sum + i\n    i += 1\n \
    \ return sum\nend\n</cell>\n<code language=julia-1.1>\nsum_to_n(30)\n</cell>\n\
    <text>\nExercise: Write a function to return the square root of a number. Hint:\
    \ the function Math.sqrt(n) will do it.", "  n.times do\n    n += rand(10) + rand(10)\
    \ + rand(10)\n  end\n  n\nend", "  n += 1\n  sum = 0\n  while n != 0\n    sum\
    \ += n\n    n -= 1\n  end\n  sum\nend\n</cell>\n<cell>\nsum_to_n(1)\n</cell>\n\
    <text>\nThe second function sum_to_n_r is a recursive function that does exactly\
    \ the same as the previous one, except that it does not create a variable.", " \
    \ return 0 if n < 0 else (n * 10) + sum_to_n(n-1)\nend", "  return 0 if n == 0\
    \ else n + sum_to_n(n - 1)\nend", "  result = 1\n  while n > 0 do\n    result\
    \ = result + n\n    n -= 1\n  end\n  result\nend", "  sum = sum_to_n_1(n)\n  sum\
    \ = sum_to_n_2(sum, n)\n  return sum\nend", "  sum = 0\n  for i in 1...n\n   \
    \ sum += i\n  end\n  sum\nend", "  sum = 0\n  for i in 1...n\n    sum += i\n \
    \ end\n  sum\nend", "  n\nend", "  return n if n == 0 \n  return 1 + sum_to_n(n\
    \ - 1)\nend", "  sum = 0\n  for i in 1..n\n    sum += i\n  end\n  sum\nend\n</cell>\n\
    <code language=julia-0.6>\nsum_to_n(10)\n</cell>\n<code language=julia-0.6>\n\
    sum_to_n(30)\n</cell>\n<text>\nNow let's do what we did with the sum of squares.\
    \ That is, the sum of the numbers from 1 to n squared.", "  return n > 0 ? n *\
    \ sum_to_n(n - 1) : n\nend\n ", "  # Create a range with 1 to n and initialize\
    \ sum\n  sum = 0\n  for i in (1..n)\n    sum += i\n  return sum\nend\n</cell>\n\
    <text>\nProblem 4.20: sum_to_n_with_memo is a function which takes an integer\
    \ n and returns a list of integers, one for each number from 1 to n. \nThe function\
    \ memoize will store the results of calls to the memoized function, and will return\
    \ those results if they are called again. \nFor example, calling memoize(sum_to_n_with_memo,\
    \ 5) in this cell will result in [1,1,1,1].", "  sum = n\n  while n > 1\n    sum\
    \ = sum_to_n(n - 1) + sum\n    n -= 1\n  end\n  sum\nend", "  # Create a sum_to_n\
    \ function that can sum up numbers from 1 to n\n  sum_to_n = lambda i: 1 if i\
    \ <= n else i + sum_to_n(i + 1)\n  return sum_to_n", "  return n.times.reduce(:+)\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere's a solution without using recursion:\n\
    <code>", "  sum = 0\n  while n > 0\n    sum += n\n    n -= 1\n  sum\nend", " \
    \ (0..n).reduce(&:+)\nend", "    total = 1\n    for i in 1..n\n        total *=\
    \ i\n    end\n    total\nend\n</cell>\n<cell>", "  n\nend", "  total = 0\n  n.times\
    \ do\n    total += rand(10**n)\n  end\n  total\nend\n</cell>\n<text>\nThe sum_of_digits(100)\
    \ function has three returns, because we sum the digits of each number and multiply\
    \ it by its index, so 100 is 0 + 1 + 5 + 0.", "  x = 1\n  while x <= n\n    x\
    \ += x\n  end\n  x\nend", "  sum = 0\n  for i in 1..n\n    sum += i\n  end\n \
    \ sum\nend\n</cell>\n<code language=julia-1.5>\nsum_to_n(50)\n</cell>\n<text>\n\
    Task 2\nWrite a function find_largest_n that finds the largest n that is divisible\
    \ by any number between 1 and 100.", "  return n.times.reduce(&:+)\nend", "  n.times\
    \ do\n    n += 1 if n > 0 else 0\n  end\n  n\nend\n</cell>\n<text>\nWe are going\
    \ to call sum_to_n a lot so we will refactor it into a reusable method:", "  i\
    \ = 1\n  sum = 0\n  while i < n\n    sum = sum + i\n    i += 1\n  end\n  sum\n\
    end\n</code></pre>\n<p>Although this code is simple, it is also possible to write\
    \ a more compact and readable version:</p>\n<pre><code class=\"lang-erlang\">sum_to_n([H|T])\
    \ when H&lt;=T[1] ->\n  sum_to_n(T,H)\nsum_to_n(_,0) ->\n  0\nsum_to_n([H|T],Acc)\
    \ when H&lt;=T[1] ->\n  sum_to_n(T,Acc+H)\nsum_to_n(_,Acc) ->\n  Acc\n</code></pre>\n\
    <p>The pattern matching in Erlang has two main benefits. First, it allows for\
    \ some really powerful expressions that you normally cannot do with plain pattern\
    \ matching. Second, it allows you to specify what to return when you have an invalid\
    \ case. In the previous example, the function could have been written without\
    \ specifying what to return when H&lt;=T[1] returns <code>false</code>. With a\
    \ pattern matching function, you can tell Erlang to return the sum of <code>0</code>\
    \ or <code>H</code> when <code>H&lt;=T[1]</code> returns <code>false</code>. In\
    \ the last example, we return <code>Acc</code> when <code>H&lt;=T[1]</code> returns\
    \ <code>false</code> and <code>Acc+H</code> when <code>H&lt;=T[1]</code> returns\
    \ <code>true</code>.</p>\n<p>As you can see, pattern matching can result in some\
    \ really powerful code, which can make code much more readable. The syntax for\
    \ pattern matching is different from those for <code>if</code> statements in other\
    \ languages.</p>\n<h3 id=\"guards-and-the-ternary-operator\">Guards and the Ternary\
    \ Operator</h3>\n<p>Okay, so far we have seen two ways to write if-statements.\
    \ One is with the <code>if</code> statement and the other is with <code>case</code>:</p>\n\
    <pre><code class=\"lang-erlang\">if A&lt;B->\n  A+B;\n  A*B;\n  A&gt;B\nend\n\
    </code></pre>\n<pre><code class=\"lang-erlang\">case A of\n  B->\n    A+B;\n \
    \   A*B;\n    A&gt;B\nend\n</code></pre>\n<p>The above code does the same thing\
    \ as if statements. We can also write pattern matching code using <code>case</code>:</p>\n\
    <pre><code class=\"lang-erlang\">case A of\n  X+Y when X&lt;Y -> A+Y;\n    X+Y\
    \ when X&gt;Y -> A*Y;\n    X&gt;Y -> A&gt;Y\n", "  sum = 0\n  1.upto(n) { |i|\
    \ sum += i }\n  sum\nend", "  n.zero? ? 1 : n.succ + (n.succ.zero? ? sum_to_n(n.succ)\
    \ : 0)\nend\n</cell>\n<text>\nWe have a sum to n function. We can now use it to\
    \ create another function to get an n sum starting from 1:", "  result = 0\n \
    \ for i = 1 to n\n    result += i\n  end\n  result\nend\n</cell>\n<code language=julia-0.4>",
  "  sum = 1\n  for i in 1..n\n    sum *= i\n  end\n  sum\nend", "  result = 0\n \
    \ for i in 1..n\n    result += 1\n    result\n  end\nend", "  result = 1\n  n.times\
    \ do |i|\n    result *= i + 1\n  end\n  result\nend", "    sum = 1\n    while\
    \ n > 0\n        sum += n\n        n -= 1\n    return sum\n    ", "  if n <= 0\n\
    \    return 0\n  sum_to_n_aux(n, sum_to_integer_array)\nend", "  ((1..n).inject(:+))\n\
    end", "  # The magic number 2.\n  # This makes sure we never accidentally pass\
    \ too big a number.\n  # It makes the smallest value possible by adding 1.\n \
    \ # So we never add too much - by accident - and that makes sure we stay below\
    \ 10.\n  # So instead of having 10 be our max number we add 1.\n  n += 1 if n\
    \ < 10 else 1\n  sum_to_n_recursive n, 0\nend", "  return n.downto(1).inject(:+)\n\
    end\n</cell>\n<cell>\nsum_to_n(6)\n</cell>\n<text>\nExercise 10\nWrite a function\
    \ that takes a list of n numbers and returns a list containing only odd numbers.\
    \ Hint: use #collect! and a block conditional that returns odd numbers. You'll\
    \ need to use #each.", "  sum_ = 0\n  (0..n).each do |i|\n    sum_ += i \n  end\n\
    \  return sum_\nend", "  sum = 1\n  for i in 1...n do\n    sum = sum + i\n  end\n\
    \  sum\nend", "  sum = 0\n  for i in 1..n\n    sum += i\n  sum\nend", "  sum =\
    \ 0\n  for i in 1..n\n    sum += i\n  end\n  return sum\nend", "  total = 0\n\
    \  for i =..n\n    total += i\n  end\n  return total\nend\n</cell>\n<cell>\nsum_to_n(10)\n\
    </cell>\n<text>\nThe first thing you'll notice is that we are passing the number\
    \ 10 into the method rather than the variable n. This can be fixed using the @\
    \ to define the method as a variable within the scope of the variable. An example\
    \ of this would be", "  sum = 1\n  for i in 1..n\n    sum *= i\n  end\n  sum\n\
    end\n</cell>\n<code language=julia-1.6>\nsum_to_n(30)\n</cell>\n<text>\nSumming\
    \ prime numbers\nThe function is_prime returns true if the given number is a prime\
    \ number.", "  sum = 0\n  for i in 1..n\n    sum += i\n  end\n  sum\nend", " \
    \ if n == 0\n    1\n  else\n    sum_to_n(n - 1) + n\n  end\nend", "  return sum_to_n_aux(n)\n\
    end", "  return n.times.reduce(:+)\nend", "  sum = 0\n  for i in 1...n\n    sum\
    \ = sum + i\n  end\n  return sum\nend\n</cell>\n<text>\nExercise 2\nWrite a function\
    \ that takes in a list containing only integers, and sums all the even numbers\
    \ in the list, and returns the sum.", "  sum = 0\n  for i in 1..n\n    sum +=\
    \ i\n  end\n  sum\nend", "    sum = 0\n    for i in 1..n\n        sum += i\n \
    \   return sum\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby,functional-programming\
    \ |>\nYet another way to do it:\n<code>\n(1..n).inject(0){|sum,num| sum + num}\n\
    </code>\n<|/ a dscore=3 |>\n<| a dscore=3 tags=ruby,functional-programming |>\n\
    I like to do this for simple cases:\n<code>", "  result = 0\n  for i in 1...n\n\
    \    result << 1 + i\n  end\n  result\nend", "  n.to_i\nend", "{\n    sum = 0",
  "    num = nil\n    loop do\n        num = num + rand\n        break unless num\
    \ > n\n    end\n    num\nend\n</code>\nNow, if you look closely, you'll notice\
    \ that my first implementation is pretty similar to yours. However, the problem\
    \ is that I didn't check the value of n inside the loop. This means, that the\
    \ code will run for as long as n is greater than zero. That's why, the number\
    \ generated will never be greater than the value of n. This means that, if you\
    \ execute this program a few times, the results will not be reproducible, since\
    \ the values of n are different each time you run it.\nI hope this helped.\n<|/\
    \ a dscore=2 |>\n<| c |>\nWow! this is really nice implementation ! thanks alot\
    \ man.\n<|/ c |>\n<| c |>\nNo problem :) Feel free to ask if you have any questions.\n\
    <|/ c |>\n<| a |>\nThe problem is that the number generator is returning nil each\
    \ time it loops through the loop.  You need to use break to exit the loop after\
    \ a random number is generated.\n<code>", "  result = 0\n  for i in 1..n\n   \
    \ result += i\n  end\n  result\nend\n</cell>\n<cell>", "  return n * n + sum_to_n(n-1)\n\
    end", "  sum = 0\n  for i in 1..n\n    sum+=i\n  end\n  sum\nend", "  return 1\
    \ if n == 0 then 0 else n + sum_to_n(n-1)\nend", "  sum=0\n  1.upto(n){|x| sum+=x}\n\
    \  sum\nend", "  sum = 1\n  loop do\n    sum += sum_to_n(n-1) + 1\n  end\n  sum\n\
    end", "  1.upto(n - 1).inject(:+) + n\nend", "  sum_ = 1\n  for i in 1..n\n  \
    \  sum_ = sum_ * i\n  end\n  sum_\nend", "  sum = 1.upto(n){|i| sum += i}\n  sum\n\
    end", "    sum = 0\n    sum_to_n_rec(sum, n)\n    return sum\nend", "  (0..n-1).reduce(:+).to_s\n\
    end", "  1.upto(n) { |i| puts i + \",\" }\n  puts \".\"\nend", "  # initialize\
    \ sum to zero.\n  sum = 0\n  # initialize running total\n  running_total = 0\n\
    \  # while the sum is less than or equal to n.\n  while sum < n\n    running_total\
    \ += 1 # add one to the sum\n    sum += 1 # update the running total\n  end\n\
    \  return running_total\nend\n</cell>\n<code language=julia-1.6>", "  # Write\
    \ your code here.\n  sum = 0\n  i = 1\n  while i < n\n    sum += i\n    i += 1\n\
    \  puts(sum)\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  return 0 if\
    \ n == 0 else n + sum_to_n(n - 1)\nend", "  result = 0\n  for i in 1..n\n    result\
    \ += 1\n  end\n  result\nend", "    sum = 0\n    (1..n).each do |i|\n        sum\
    \ += i\n    end\n    return sum\nend\n</cell>\n<code language=julia-0.6>\nsum_to_n(30)\n\
    </cell>\n<code language=julia-0.6>\nsum_to_n(100)\n</cell>\n<code language=julia-0.6>\n\
    sum_to_n(5)\n</cell>\n<code language=julia-0.6>\nsum_to_n(10)\n</cell>\n<code\
    \ language=julia-0.6>\nsum_to_n(1)\n</cell>\n<code language=julia-0.6>\nsum_to_n(2)\n\
    </cell>\n<text>\nIn Julia, a comprehension is often more compact than a loop.",
  "  return 1 if n == 0 else n * sum_to_n(n-1)\nend", "    sum = Integer(0)\n    (1..n).each\
    \ do |i|\n        sum += i\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.0>\n\
    sum_to_n\n</cell>\n<code language=julia-1.0>\nsum_to_n(4)\n</cell>\n<code language=julia-1.0>\n\
    sum_to_n(3)\n</cell>\n<code language=julia-1.0>\nsum_to_n(30)\n</cell>\n<code\
    \ language=julia-1.0>\nsum_to_n(100)\n</cell>\n<code language=julia-1.0>\nsum_to_n(5)\n\
    </cell>\n<code language=julia-1.0>\nsum_to_n(10)\n</cell>\n<code language=julia-1.0>\n\
    sum_to_n(1)\n</cell>\n<code language=julia-1.0>", "  return (n * (n + 1)) / 2\n\
    end", "  sum = 0\n  for i in 1..n\n    sum += i\n  end\n  sum\nend", "  return\
    \ n * (n + 1) / 2\nend", "    sum = n.to_i\n    sum_to_n_recurse(sum, n)\n   \
    \ return sum\nend", "  sum_to = 0\n  1.upto(n) do |x|\n    sum_to += x\n  end\n\
    \  sum_to\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is a nice solution,\
    \ but it relies on the `Enumerable` extension module. It is not part of the core\
    \ Ruby.\n<|/ c |>\n<| c |>\n, you are correct, I have added it to my answer.\n\
    <|/ c |>\n<| a tags=ruby dscore=2 |>\n<code>\n1.upto(10).inject(:+)\n</code>\n\
    <|/ a |>\n<| c |>\nThis would give a different result from `1 + 2 + 3 + 4 + 5\
    \ + 6 + 7 + 8 + 9 + 10`. To be fair, Ruby will try to optimize this by reusing\
    \ already computed values, but this could happen only on very rare occasions.\n\
    <|/ c |>\n<| a dscore=2 tags=ruby |>\nI love the other answers, but this one should\
    \ be the fastest:\n<code>", "    # Write your solution here.\n    (1..n).reduce(&:+).to_s\n\
    end\n</cell>\n<text>\nThe last part of this puzzle is pretty simple: you just\
    \ need to put an endl at the end of the print. Another thing to notice is that\
    \ we are calling a method on the Range object, not a method on the Integer class.\
    \ That is what this syntax means:", "  n\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
