name: HumanEval_153_Strongest_Extension
language: rb
prompt: "# You will be given the name of a class (a string) and a list of extensions.\n\
  # The extensions are to be used to load additional classes to the class. The\n#\
  \ strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  # letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n# in the extension's name, the strength is given by the fraction CAP - SM. \n\
  # You should find the strongest extension and return a string in this \n# format:\
  \ ClassName.StrongestExtensionName.\n# If there are two or more extensions with\
  \ the same strength, you should\n# choose the one that comes first in the list.\n\
  # For example, if you are given \"Slices\" as the class and a list of the\n# extensions:\
  \ ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n# return 'Slices.SErviNGSliCes'\
  \ since 'SErviNGSliCes' is the strongest extension \n# (its strength is -1).\n#\
  \ Example:\n# for Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n\
  def Strongest_Extension(class_name, extensions)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_Strongest_Extension\n\
  \    candidate = method(:Strongest_Extension)\n    assert_equal(\"Watashi.eIGHt8OKe\"\
  , candidate.call(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]))\n    assert_equal(\"\
  Boku123.YEs.WeCaNe\", candidate.call(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\"\
  , \"32145tggg\"]))\n    assert_equal(\"__YESIMHERE.NuLl__\", candidate.call(\"__YESIMHERE\"\
  , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]))\n\
  \    assert_equal(\"K.TAR\", candidate.call(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
  , \"cosSo\"]))\n    assert_equal(\"__HAHA.123\", candidate.call(\"__HAHA\", [\"\
  Tab\", \"123\", \"781345\", \"-_-\"]))\n    assert_equal(\"YameRore.okIWILL123\"\
  , candidate.call(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
  , \"-_-\"]))\n    assert_equal(\"finNNalLLly.WoW\", candidate.call(\"finNNalLLly\"\
  , [\"Die\", \"NowW\", \"Wow\", \"WoW\"]))\n    assert_equal(\"_.Bb\", candidate.call(\"\
  _\", [\"Bb\", \"91245\"]))\n    assert_equal(\"Sp.671235\", candidate.call(\"Sp\"\
  , [\"671235\", \"Bb\"]))\n  end\nend\n"
completions: ["  name_lengths = Hash.new(0)\n  extensions.each do |extension|\n  \
    \  name_lengths[extension.upcase] += 1\n    name_lengths[extension.downcase] +=\
    \ 1\n  end\n  extensions_sorted = extensions.sort_by{|extension| name_lengths[extension.upcase]}\n\
    \  extensions_sorted.reverse!\n  extensions_sorted.first\nend", "  extensions.each\
    \ do |extension|\n    if CAP - extension.upcase.count > SM\n      puts \"#{class_name}.#{extension}\"\
    \n      return \"#{class_name}.#{extension}\"\n    end\n  end\n  raise 'No extensions\
    \ meet the required strength'\nend", "  max_strength = -1 # You do not need to\
    \ initialize max_strength, but you \n                   # should do so if you\
    \ expect to use it later\n  max_extension = ''\n  extensions.each do |extension|\n\
    \    strength = extension.downcase.count - extension.downcase.scan(/[a-z]/).count\n\
    \    if strength > max_strength\n      max_extension = extension\n      max_strength\
    \ = strength\n    end\n  end\n  class_name + max_extension.downcase\nend\n</code>\n\
    Apart from the functions we defined above the only other thing you need is \n\
    a list of the classes in the directory. Since we do not know if the directory\
    \ contains \na special character (like space) that could confuse our programs,\
    \ we are \ngoing to use a Ruby class to store the information we need. Using our\
    \ previous\nfunctions we already know that we can easily retrieve a list of files\
    \ and directories\nwithin a directory. Let's create an object of the class Dir\
    \ to get the information. \nYou can read more about the class Dir in the API documentation.\
    \ \nThe dir method will return a object of type Array<String> that stores all\
    \ files and\ndirectories within a directory. You can think of this method as a\
    \ wrapper for\nthe find method in Linux or Windows systems. \n<code>\nrequire\
    \ 'fileutils'\nDir.new(PathToClassDirectory).each do |extension|\n  p \"#{extension}\
    \ is the strongest extension\" if Strongest_Extension(extension, extensions_array).include?(extension)\n\
    end\n</code>\nThe Strongest_Extension function takes two arguments. One is the\
    \ name of the class \nand the other is a list of all extensions in the directory.\n\
    <|/ a dscore=0 |>\n<| c |>\nThank you for your detailed answer. I appreciate it.\n\
    <|/ c |>\n<| c |>\nI tested the code on my system and found out that when I run\
    \ the code it returns two values when it should return one value.\n<|/ c |>\n\
    <| c |>\nI think I may have misunderstood your question then, do you mean that\
    \ you run this code and it returns  two values when it should return one?\n<|/\
    \ c |>\n<| c |>\nI tested the code on 2 machines and got this result \"RubyClass.SlicesExtenstions.SErviNGSliCes\"\
    \n<|/ c |>\n<| c |>\nHi there! When I run the code it returns two values when\
    \ it should return one value.\n<|/ c |>\n<| a dscore=0 tags=ruby,ruby-on-rails\
    \ |>\nI am not sure why you need the file extension, since this is mostly used\
    \ to load a class, and most of the time you want to load the class without knowing ",
  "  class_name.split.map do |s|\n    s.capitalize.chars.sort - s.split.map(&:downcase).sort.join\n\
    \  end.sort.last\nend", "  extensions_strength = [Extension_Strength(e) for e\
    \ in extensions]\n  first_index = extensions.index {|x| extensions_strength.index(x)\
    \ > -1}\n  extensions.delete_at(first_index)\n  extensions.sort.inject(class_name,\
    \ &:+)\nend", "  sorted_extensions = extensions.sort\n  max_index = sorted_extensions.length\
    \ - 1\n  strength = -Infinity\n  class_name_length = class_name.length\n  \n \
    \ for i in 0...max_index\n    letter = class_name[class_name_length - i - 1]\n\
    \    \n    if letter == sorted_extensions[i]\n      strength = i\n    end\n  end\n\
    \  \n  return class_name[0...class_name_length - strength]\nend", "    \n    \n\
    \    \n    # Declare result variable\n    result = ''\n    \n    # Declare variables\
    \ to hold cap and sm\n    cap_letters = 0\n    sm_letters = 0\n    \n    # Loop\
    \ through all extensions\n    for extension in extensions do\n        \n     \
    \   # Count number of upper case letters in extension\n        cap_letters = cap_letters\
    \ + length(extension) \n        \n        # Count number of lower case letters\
    \ in extension\n        sm_letters = sm_letters + length(extension) - cap_letters\n\
    \        \n    end\n    \n    # Calculate total caps and sms\n    total_caps =\
    \ cap_letters * length(class_name)\n    total_sms = sm_letters * length(class_name)\n\
    \    \n    # Calculate final score using formula from lecture notes\n    final_score\
    \ = total_caps - total_sms\n    \n    # Check if final score is negative and return\
    \ appropriate class name as string\n    if final_score < 0 then\n        return\
    \ class_name\n    else\n        return class_name .. '.' .. extensions[final_score]\n\
    \    end\nend\n</cell>\n<text>\nPart 3: Making a class from a list of variables\n\
    The variable names and values stored in our system are actually just lists of\
    \ strings. In this part, you will convert a class into a list of values, and then\
    \ convert a list into a class.", "    extension_count = 0\n    extension_count_list\
    \ = Array.new\n    extension_count_list.push(extension_count)\n    extension_count_list\
    \ = extension_count_list.sort_by{|x| x}.reverse\n    extension_count_list.each\
    \ do |e|\n        if class_name.include?(e[1].upcase)\n            extension_count\
    \ = e[0]\n            extension_count_list = Array.new\n            extension_count_list.push(extension_count)\n\
    \            extension_count_list = extension_count_list.sort_by{|x| x}.reverse\n\
    \            extension_count_list.each do |e|\n                if e[1] == e[1].downcase\n\
    \                    extension_count = e[0]\n                    extension_count_list.push(extension_count)\n\
    \                    extension_count_list = extension_count_list.sort_by{|x| x}.reverse\n\
    \                end\n            end\n        end\n    end\n    extension_count_list.each\
    \ do |e|\n        if e[1] == e[1].downcase\n            extension_count = e[0]\n\
    \            extension_count_list = Array.new\n            extension_count_list.push(extension_count)\n\
    \            extension_count_list = extension_count_list.sort_by{|x| x}.reverse\n\
    \        end\n    end\n    extension_count_list.each do |e|\n        if e[1] ==\
    \ e[1].downcase\n            extension_count = e[0]\n            extension_count_list\
    \ = Array.new\n            extension_count_list.push(extension_count)\n      \
    \      extension_count_list = extension_count_list.sort_by{|x| x}.reverse\n  \
    \      end\n    end\n    return class_name + \".\" + extension_count_list[0].to_s\n\
    end", "  max_extension = nil\n  \n  extensions.each do |extension|\n    count\
    \ = extension.count(class_name.upcase) - extension.count(class_name.downcase)\n\
    \    \n    if count == 0\n      max_extension = extension\n    end\n    \n   \
    \ if count > 0 && (max_extension == nil || count > max_extension.count(class_name.upcase))\n\
    \      max_extension = extension\n    end\n  end\n  \n  if max_extension != nil\n\
    \    return max_extension\n  end\n  \n  return nil\nend\n</code>\n<|/ q tags=ruby,string\
    \ |>\n<| c |>\nHow do you expect that Ruby can know that you want `'my_class.AA'`\
    \ and not `'my_class.ABC'`? They are different.\n<|/ c |>\n<| c |>\nSo how do\
    \ you define strongest extension? The one that occurs the most times (number of\
    \ occurences of substring 'AAA' in the given example)? How about 'ABB' and 'BBB'?\
    \ What about 'AAA' and 'CCC'?\n<|/ c |>\n<| c |>\nThe string 'my_class.AAA' has\
    \ only one instance of the substring 'AAA', so I'd consider that strongest. However,\
    \ 'my_class.ABC' also has only a single instance of the substring 'AAA', but the\
    \ extension name has a different number of characters, so I'd consider that to\
    \ be the strongest.\n<|/ c |>\n<| c |>\nIf you could give a working code example\
    \ that would be great.\n<|/ c |>\n<| c |>\nWell, that's a complicated requirement.\
    \ I suggest you split the task into smaller steps. First, you need to find the\
    \ most common extension. Second, you only need to know the count and what is the\
    \ first extension that matches.\n<|/ c |>\n<| a dscore=2 |>\nIt is not possible\
    \ to solve this problem with regular expressions in Ruby, because there is no\
    \ way to know which extension should be chosen if there are several with the same\
    \ count. \nYou have to solve the problem in two steps. \nFirst, you have to get\
    \ the extension with the highest count:\n<code>\n[extension,count] = extensions_with_max_counts.max_by{|e|\
    \ -e[1]}\n</code>\nThen, you have to check the count of each extension:\n<code>\n\
    extensions_with_max_counts.select{|e| -e[1]==count}.first\n</code>\nIf you have\
    \ two or more extensions with the same count, only the first one is checked, because\
    \ that extension will always have the highest count.\n<code>\n[extension,count]\
    \ = extensions_with_max_counts.max_by{|e| -e[1]}\n</code>\nis equivalent to\n\
    <code>", "  extensions.sort {|a,b|a.to_i <=> b.to_i }\n  extensions.reverse.detect\
    \ {|e| class_name.include?(e.downcase) }\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=3 |>\n<| c |>\nAh, you forgot an `s` on your `include?` line.\n<|/ c\
    \ |>\n<| a tags=ruby,arrays dscore=2 |>\nI would do something like this:\n<code>",
  end, "    sorted_extensions = extensions.sort {|a, b| b.to_f.abs <=> a.to_f}\n \
    \   sorted_extensions.reverse!\n    sorted_extensions.each_index { |i| sorted_extensions[i]\
    \ = sorted_extensions[i].to_s }\n    \n    first = sorted_extensions[0]\n    last\
    \ = sorted_extensions[-1]\n    \n    cap = first.length\n    sm = last.length\n\
    \    \n    return class_name.to_s + '.' + sorted_extensions.find {|e| e.length\
    \ == cap - sm }\nend", "  # Handle edge case\n  if extensions.empty?\n    return\
    \ class_name\n  end", "    classname = class_name.split('::')[-1].split('.')[0]\n\
    \    extension_set = Set.new\n    extensions.each { |e| extension_set << e.downcase\
    \ }\n    extension_set.each_with_object({}) { |e, d| d[e] = e.size }\n    extension_set.sort.reverse.each_with_object({})\
    \ { |e, d| d[e] = e.size }.\n        each { |e, s| s[e] = extension_set.count(e)\
    \ / extensions.size }\n    extension_set.sort.reverse.each_with_object({}) { |e,\
    \ s| s[e] = e.size }.\n        each { |e, s| s[e] = s.values.max }\n    extension_set.sort.reverse.each_with_object({})\
    \ { |e, s| s[e] = e.size }.\n        each { |e, s| s[e] = s[e].values.min }\n\
    \    extension_set.sort.reverse.each_with_object({}) { |e, s| s[e] = e.size }.\n\
    \        each { |e, s| s[e] = s[e].values.max }\n    extension_set.sort.reverse.each_with_object({})\
    \ { |e, s| s[e] = e.size }.\n        each { |e, s| s[e] = s[e].values.min }\n\
    \    extension_set.sort.reverse.each_with_object({}) { |e, s| s[e] = e.size }.\n\
    \        each { |e, s| s[e] = s[e].values.max }\n    extension_set.sort.reverse.each_with_object({})\
    \ { |e, s| s[e] = e.size }.\n        each { |e, s| s[e] = s[e].values.min }\n\
    \    extension_set.sort.reverse.each_with_object({}) { |e, s| s[e] = e.size }.\n\
    \        each { |e, s| s[e] = s[e].values.max }\n    extension_set.sort.reverse.each_with_object({})\
    \ { |e, s| s[e] = e.size }.\n        each { |e, s| s[e] = s[e].values.min }\n\
    \    extension_set.sort.reverse.each_with_object({}) { |e, s| s[e] = e.size }.\n\
    \        each { |e, s| s[e] = s[e].values.max }\n    extension_set.sort.reverse.each_with_object({})\
    \ { |e, s| s[e] = e.size }.\n        each { |e, s| s[e] = s[e].values.min }\n\
    \    extension_set.", "  # Your code here\n  max_value = 0\n  max_index = 0\n\
    \  \n  # loop through each extension\n  for extension in extensions\n    # convert\
    \ each extension to lower case\n    extension = extension.downcase\n    # get\
    \ the number of uppercase letters\n    nU = extension.count('U')\n    # get the\
    \ number of lowercase letters\n    nL = extension.count('L')\n    # get the number\
    \ of capitals\n    nC = extension.count('C')\n    # get the number of spaces\n\
    \    nS = extension.count('S')\n    # get the number of digits\n    nD = extension.count('D')\n\
    \    # get the number of vowels\n    nV = extension.count('V')\n    \n    # get\
    \ the total count\n    totalCount = nU + nL + nC + nS + nD + nV\n    \n    # if\
    \ the total is greater than the current max value \n    if (totalCount > max_value)\n\
    \      max_value = totalCount\n      max_index = extension\n  end\n  \n  return\
    \ class_name.concat(max_index)\nend\n</code>\n<|/ q tags=string,ruby |>\n<| c\
    \ |>\nIt's a lot of work, but you can do it by finding the longest prefix for\
    \ each character and taking the longest of those.\n<|/ c |>\n<| c |>\nYour question\
    \ isn't very clear. What is the purpose of the exercise? What have you tried?\
    \ Please read \"[ask]\" and \"[mcve]\". We need the information in order to help\
    \ you. What is your problem?\n<|/ c |>\n<| c |>\nYou might want to look at [Enumerable#chunk](http://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-chunk)\
    \ or [Enumerable#chunk_while](http://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-chunk_while)\n\
    <|/ c |>\n<| c |>\n, `chunk` gives you chunks of the array that match the condition.\
    \ OP wants the longest prefix for each character separately, so `chunk_while`\
    \ won't work here.\n<|/ c |>\n<| a tags=string,ruby |>\nUsing a combination of\
    \ Enumerable#slice_while and Enumerable#max_by:\n<code>\ns = 'asdfg'", "  strongest\
    \ = -1\n  extension = nil\n  \n  extensions.each do |extension|\n    if extension.include?(class_name.downcase)\n\
    \      if strongest < 0 || (strongest == 0 && !extension.include?(class_name.downcase))\n\
    \        strongest = extension.index(class_name.downcase) - extension.index(class_name.downcase.upcase)\n\
    \        extension = extension.downcase.delete_at(strongest)\n      end\n    end\n\
    \  end", "    l = extensions.sort\n    Strongest = 0\n    Strength = 0\n    for\
    \ e in extensions\n        if e[0..2] == class_name[0..2]\n            Strongest\
    \ = e[0..2]\n            break\n        end\n    end\n    Strength = l.index(Strongest)\
    \ + 1\n    Str = class_name.sub(Strongest, extensions[Strength])\nend", "  extension_count\
    \ = {}\n  extension_count.each do |e| \n    extension_count[e] = 0 \n  end \n\
    \  extensions.each do |ext|\n    extension_count.each do |k,v|\n      e_cnt =\
    \ (extension_count[ext].to_f / k.to_f).round\n      if e_cnt < extension_count[k]\n\
    \        extension_count[k] = e_cnt\n      end \n    end \n  end \n  extension_count.keys.sort.reverse.each\
    \ do |k|\n    return class_name.send(k.to_s + \".\" + Strongest_Extension(class_name,\
    \ extension_count[k]) )\n  end \nend", "    \n    # Your code here\n    \n   \
    \ return \"\"", "  strongest_extension = nil\n  extensions.each { |extension|\n\
    \    beginning_of_extension = extension.index(class_name)\n    beginning_of_extension\
    \ -= class_name.length\n    strength = (extension.size - extension.count(\"'.\"\
    ) - 1).to_f\n    strongest_extension = class_name + extension[beginning_of_extension,\n\
    \          strength.to_i].gsub(/['\"]/, '')\n    return strongest_extension if\
    \ strength.to_i == 0\n  }\n  raise ArgumentError, \"The class #{class_name} is\
    \ not found among #{extensions.inspect}\"\nend", "  my_class = class_name.downcase\n\
    \  extensions_as_strings = extensions.map(&:to_s).sort\n  extensions_as_strings.each\
    \ do |e|\n    e = e.upcase\n    if e =~ /#{my_class.gsub(my_class.chars.map(&:downcase).join(''),\
    \ '')}[A-Z]/\n      return class_name.gsub(my_class.gsub(my_class.chars.map(&:downcase).join(''),\
    \ ''), '') + '_' + e\n    end\n  end\nend", "  n = class_name.count('.')\n  extension_count\
    \ = 0\n  extension_scores = []\n  \n  extension_count = class_name.count('.')\n\
    \  extension_scores = Array.new(extension_count)\n  \n  extensions.each do |extension|\n\
    \    parts = extension.split('.')\n    \n    extensions.each do |other_extension|\n\
    \      parts = other_extension.split('.')\n    \n      parts.each do |part|\n\
    \        extension_scores[extension_count] += (part.upcase - part.downcase).abs()\n\
    \      end\n    end\n  end", "  extension_array.each { |e| e.each { |e| e.split('').map\
    \ { |x| x.upcase }.join.size == e.split('').map { |x| x.upcase }.join.size+1 };\
    \ extension_array.map { |e| e.sort { |a, b| a.split('').map { |x| x.upcase }.join.size\
    \ <=> b.split('').map { |x| x.upcase }.join.size }.first }\n  extension_array.each\
    \ { |e| e.each { |e| e.split('').map { |x| x.upcase }.join.size == e.split('').map\
    \ { |x| x.upcase }.join.size+1 }; extension_array.map { |e| e.sort { |a, b| a.split('').map\
    \ { |x| x.upcase }.join.size <=> b.split('').map { |x| x.upcase }.join.size }.first\
    \ }\nend", "\tstrongest_extension = ''\n\tstrongest_extensions = []\n\tstrongest_extensions_strength\
    \ = nil\n\t\n\textensions.each do |extension|\n\t\textension = extension.to_s\n\
    \t\textension = extension.downcase \n\t\textension = extension.gsub('.','_')\n\
    \t\textension_strength = (extension.count(\"A\") - extension.count(\"a\")) / (extension.count(\"\
    a\") + extension.count(\"A\"))\n\t\tif (strongest_extensions_strength == nil)\n\
    \t\t\tstrongest_extensions_strength = extension_strength\n\t\t\tstrongest_extension\
    \ = extension\n\t\telsif (strongest_extensions_strength > extension_strength)\n\
    \t\t\tstrongest_extensions_strength = extension_strength\n\t\t\tstrongest_extension\
    \ = extension\n\t\tend\n\tend\n\treturn class_name.to_s + '.' + strongest_extension\n\
    end", "  extensions_sorted = extensions.sort_by { |x| x.length }\n  strongest_extension\
    \ = extensions_sorted.first\n  extensions_sorted.each do |extension|\n    strongest_extension\
    \ = extension if extension.capitalize.size == strongest_extension.capitalize.size\n\
    \  end\n  return class_name + strongest_extension\nend", "  # Your code here\n\
    \  max_strength = -1\n  result = ''\n  extension_count = extensions.length\n \
    \ \n  extension_hash.each do |key, value|\n    if key.length == class_name.length\n\
    \      strength = extension_hash[key].length - key.length\n      if strength >\
    \ max_strength\n        max_strength = strength\n        result = key.to_s + extension_hash[key].last.to_s\n\
    \      end\n    end\n  end\n  \n  if extension_count > 1\n    extension_hash.each\
    \ do |key, value|\n      if key.length == class_name.length\n        strength\
    \ = extension_hash[key].length - key.length\n        if strength > max_strength\n\
    \          max_strength = strength\n          result = key.to_s + extension_hash[key].first.to_s\n\
    \        end\n      end\n    end\n  end\n  return result\nend\n</code>\nI apologize\
    \ in advance if I have not explained my question correctly or if the formatting\
    \ of this answer is not correct. I am new to programming.\n<|/ q tags=ruby |>\n\
    <| c |>\nCould you please explain what your code currently does. I don't really\
    \ understand what it is supposed to do. Also, where is `extension_hash` defined?\n\
    <|/ c |>\n<| c |>\n`'SErviNGSliCes'.length` is `8`. It should be `9`. Your code\
    \ says `'SErviNGSliCes'.length - 8 == 3` but should be `'SErviNGSliCes'.length\
    \ - 9 == 2`. Please explain in words what is your logic. Maybe you could also\
    \ provide a sample input and the expected output.\n<|/ c |>\n<| c |>\nApologies\
    \ for the confusion. I added an example to the original post. I apologize for\
    \ my ignorance in how I should word this and I appreciate the help.\n<|/ c |>\n\
    <| c |>\nMy apologies. I must have typed it wrong. I am still getting the same\
    \ output when I run the program\n<|/ c |>\n<| c |>\nI edited my answer to reflect\
    \ the new input you added\n<|/ c |>\n<| a tags=ruby |>\nThis is what I came up\
    \ with:\n<code>", "    extension_sum = extensions.inject(0) do |sum, extension|\n\
    \        sum += extension.upcase.length - extension.downcase.length\n    end\n\
    \    return class_name + \".\" + extensions[extension_sum]\nend", "\textension_strengths\
    \ = []\n\tclass_name = class_name.upcase\n\textensions = extensions.collect {\
    \ |e| e.upcase }\n\textensions.each do |ext|\n\t\tstrength = class_name.count(ext)\
    \ - ext.count('a')\n\t\textension_strengths << [ext, strength]\n\tend\n\textension_strengths.sort!\n\
    \treturn extension_strengths.first[0]\nend\n</code>\n<|/ q dscore=0 |>\n<| c |>\n\
    If your problem isn't about coding, then your question is probably better suited\
    \ for [programmers.se].\n<|/ c |>\n<| c |>\nPlease don't vandalise your own posts.\
    \ This is only to keep the site clean for future readers. The [FAQ](http://stackoverflow.com/faq#promotion)\
    \ explicitly says _\"Don\u2019t post an answer unless you plan on actually answering\
    \ the question\"_. Even if you don't, please don't vandalise your own posts.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails |>\nI would suggest using the select method\
    \ with some simple regex:\n<code>", "  strongest = ''\n  \n  # TODO: Your code\
    \ here\n  strongest = extensions[0]\n  \n  return strongest\nend\n</cell>\n<code\
    \ language=julia-1.0>\n@time begin\n  print(\"The strongest extension for \" +\
    \ \n        Strongest_Extension('my_class', ['AA', 'Be', 'CC']) + \" = \" + \n\
    \        Strongest_Extension('my_class', ['AA', 'Be', 'CC']))\nend\n</cell>\n\
    <text>\nSolution", "  str = \"\"\n  n = extensions.length\n  s = extensions.length.to_f\n\
    \  extension_strengths = [0,0]\n  for i in 0..n\n    index = ((i+s)%n).to_i\n\
    \    extension = extensions[index]\n    extension_strengths[index] = Extension_Strength(extension)\n\
    \  end\n  extension_strengths.sort!\n  strength_index = extension_strengths.index(0)\n\
    \  extension_strengths.each{|strength,index|\n    str += class_name +\".\"+ extensions[index]\
    \ \n    if strength_index != index\n      str += (strength != extension_strengths[index-1]\
    \ ? \".\" : \"\")\n    end\n  }\n  str\nend\n</code>\n<|/ a tags=string,algorithm,ruby,regex\
    \ |>\n<| c |>\nThanks, your solution works fine for most of the cases but fails\
    \ for one: `Slices`, `Slices`, `Slices.SErviNGSliCes`. The output should be `Slices.SErviNGSliCes`\
    \ but your solution returns `Slices.Slices`.\n<|/ c |>\n<| c |>\nI have modified\
    \ the answer so now it returns Slices.SErviNGSliCes for input Slices, Slices,\
    \ Slices.SErviNGSliCes.\n<|/ c |>\n<| a |>\n<code>", "  extensions.sort!\n  strongest_ext\
    \ = extensions[0]\n  extensions.each do |ext|\n    next_ext = extensions[extensions.index(ext)\
    \ + 1]\n    cap = ext.to_s.upcase.length\n    sm = next_ext.to_s.downcase.length\n\
    \    if cap - sm == 0\n      strongest_ext = ext\n    end\n  end\n  \"#{class_name}.#{strongest_ext}\"\
    \nend\n</code>\n<|/ a tags=string,ruby,algorithm dscore=1 |>\n<| c |>\nYour `Capitalize`\
    \ function doesn't appear to do what you describe. `\"MyClass\".capitalize  #=>\
    \ \"MyClass\"`.\n<|/ c |>\n<| c |>\n, you're right. I didn't have much time to\
    \ fix it so I fixed it now (it's basically the same as the OP function).\n<|/\
    \ c |>\n<| c |>\n`capitalize` capitalizes **ALL** letters. `\"MyClass\".capitalize\
    \  #=> \"MyClass\"` `\"MyClass\".capitalize!  #=> \"Myclass\"`.\n<|/ c |>\n<|\
    \ c |>\n, thanks for pointing this out. I fixed it now.\n<|/ c |>\n<| a |>\nRuby\
    \ has a built-in method String#tr for transliteration. \n<code>\n>> \"Hello World\"\
    .tr(\"h\",\"m\")\n=> \"Hello Moon\"\n</code>\n<|/ a dscore=0 tags=string,ruby,algorithm\
    \ |>\n<| a tags=string,ruby,algorithm |>\nHere is a solution using Ruby's enumerable\
    \ methods. First I used Ruby's gsub to remove the capital letters, and then I\
    \ used .downcase to convert the strings to all lowercase letters and then I used\
    \ .sort and .map to find the first letter of each word. \n<code>", "  result =\
    \ 'None'\n  first_extension = extensions[0]\n  first_extension_strength = first_extension.capitalize.length\n\
    \  second_extension_strength = extensions[1].capitalize.length\n  result = (first_extension_strength\
    \ - second_extension_strength).to_s + '.' + first_extension\n  if extensions.length\
    \ > 1\n    third_extension_strength = extensions[2].capitalize.length\n    if\
    \ third_extension_strength > second_extension_strength\n      result = first_extension_strength.to_s\
    \ + '.' + first_extension\n    elsif second_extension_strength > first_extension_strength\n\
    \      result = first_extension_strength.to_s + '.' + second_extension\n    elsif\
    \ third_extension_strength == first_extension_strength\n      result = first_extension_strength.to_s\n\
    \    end\n  end\n  return result\nend", "  strength = -1\n  \n  # Compute the\
    \ strength using the following formula:\n  # strength = number of uppercase letters\
    \ in the class name\n  #         - number of lowercase letters in the class name\n\
    \  #         - number of uppercase letters in the extensions \n  #           -\
    \ number of lowercase letters in the extensions\n  # Examples:\n  # for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\n  # for Strongest_Extension('my_class',\
    \ ['aa', 'be', 'cc']) == 'my_class.aa'\n  # for Strongest_Extension('my_class',\
    \ ['AAA', 'Bee', 'CCC']) == 'my_class.AAA'\n  # for Strongest_Extension('my_class',\
    \ ['aaaa', 'bee', 'cccc']) == 'my_class.aaaa'\n  \n  uppercase_letters = class_name.count('A-Z')\n\
    \  lowercase_letters = class_name.count('a-z')\n  uppercase_letters_extensions\
    \ = extensions.count('A-Z')\n  lowercase_letters_extensions = extensions.count('a-z')\n\
    \  \n  # Compute strength\n  strength = uppercase_letters - lowercase_letters\n\
    \  strength += uppercase_letters_extensions - lowercase_letters_extensions\n \
    \ \n  # Return class name with the strongest extension\n  return class_name.gsub(/[a-z]/)\
    \ { |c| c.upcase }.concat('.', extensions.first)\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis is a good attempt, but doesn't account for the case where\
    \ `A` and `a` are equally good. Your code would return `AB` if the array was `['A',\
    \ 'B', 'C']` instead of `['A', 'a', 'B']`. A good solution is to return `'A.B'`\
    \ if the array has `'A'` and `'B'` in the same place. You could modify your method\
    \ slightly to handle that case. I think it would be best to modify the method\
    \ that returns the strongest extension to accept a comparison function.\n<|/ c\
    \ |>\n<| c |>\nThe comparison function will be passed as a parameter to the `Strongest_Extension`\
    \ method. I'll add an implementation to my answer.\n<|/ c |>\n<| a dscore=0 tags=ruby,string\
    \ |>\nHere's my solution.\n<code>", "  # Your code here\nend", "  # Write your\
    \ code here.\n  strength = extension_count = 0\n  extension_array.each do |ext|\n\
    \    strength += 1\n    extension_count += ext.to_s.scan(/[A-Z]/).length\n  end\n\
    \  \n  max_index = -1\n  strength.downto(0) do |i|\n    if i >= strength && extension_array[i]\
    \ == class_name\n      max_index = i\n      break\n    end\n  end\n  \n  return\
    \ class_name + extension_array[max_index].to_s\nend", "    extension_str = class_name.gsub(\"\
    [^a-zA-Z]\", \"\")\n    count = 0\n    sum = 0\n    arr.each do |ext|\n      \
    \  ext =~ /[A-Z]/\n        count += $&.length\n        sum += $&.length.to_i\n\
    \    end\n    fraction = count / extension_str.length\n    sum = extension_str.length.to_i\
    \ + fraction.to_i\n    return class_name + extension_str[sum > 0 ? sum : 0]\n\
    end", "  extensions_count = extensions.size\n  min_strength = extensions_count\n\
    \  strongest_extension = nil\n  extensions.each do |extension|\n    extension_uppercase\
    \ =~ /[A-Z]/\n    extension_lowercase =~ /[a-z]/\n    strength = (extension_uppercase.length.to_f\
    \ - extension_lowercase.length.to_f)/2\n    if min_strength > strength\n     \
    \ min_strength = strength\n      strongest_extension = extension\n    end\n  end\n\
    \  return \"#{class_name}.#{strongest_extension}\"\nend\n</cell>\n<text>\nPart\
    \ 4: Testing\nNow it's your turn to test your solution by creating an instance\
    \ of the class with the parameters you used above. Create an instance of the class\
    \ called my_class and then use print to display the value of the my_class's attribute\
    \ my_attribute.", "  extension =  []\n  strength = []\n  strongest = []\n  \n\
    \  for x in extension\n    if x.index(class_name) - x.index(extension) > 0 \n\
    \     strength.push(x.index(class_name) - x.index(extension))\n     extension.push(x)\n\
    \     x.pop\n    elsif x.index(class_name) - x.index(extension) < 0 \n     strength.push(x.index(class_name)\
    \ - x.index(extension))\n     extension.push(x)\n     x.push\n    end\n  end\n\
    \  \n  extension.each_index do |i|\n   if strength[i] == 0\n    strongest.push(extension[i])\n\
    \    extension.delete(i)\n   else\n    strongest.push(extension[i])\n    extension.delete(i)\n\
    \    extension.push(i)\n   end\n  end\n  strongest.join(\".\") + \".\" + extension.join(\"\
    .\") \nend\n  ", end, "  # Write your code here\n  strongest = nil\n  extensions.each\
    \ do |ext|\n    if ext.include?(class_name.capitalize)\n      strongest = class_name+\"\
    .\"+ext\n      break\n    end\n  end\n  return strongest\nend\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nThis does not work for `Strongest_Extension('ABC', ['AAB',\
    \ 'ABC', 'AB'])`, which should be `'ABC.AAB'` instead of `'ABC.ABC'`.\n<|/ c |>\n\
    <| c |>\nI forgot to mention that the extension classes should have capital letters,\
    \ I edited my question with the code for the extensions. Thank you for your answer!\n\
    <|/ c |>\n<| c |>\nOk I changed my answer\n<|/ c |>\n<| a tags=ruby,algorithm,string,ruby-on-rails\
    \ dscore=2 |>\nHere's an answer for Ruby 1.8.7 & Rails 3.2:\n<code>", "  highest_strength\
    \ = -1\n  highest_extension = \"\"\n  \n  extensions.each do |ext|\n    if ext.include?(class_name.downcase)\n\
    \      strength = ext.gsub(class_name.downcase, '').length\n      if strength\
    \ > highest_strength\n        highest_strength = strength\n        highest_extension\
    \ = ext\n      end\n    end\n  end\n  \n  return class_name + \".\" + highest_extension\n\
    end", "    strength_of_extensions = extension_strength(extensions)\n    strongest_extension\
    \ = extension_of_strength(strength_of_extensions, class_name).first\n    return\
    \ strongest_extension.to_s\nend", "  extension_numbers = extensions.collect {|e|\
    \ e.to_s.downcase.length}\n  strength = extension_numbers.max - extension_numbers.min\n\
    \  sorted_extensions = extensions.sort {|a,b| b.to_s.downcase <=> a.to_s.downcase}\n\
    \  if strength == 0\n    class_name.to_s\n  else\n    sorted_extensions.first.name.to_s\
    \ + '.' + sorted_extensions.last.name.to_s\n  end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 tags=ruby |>\nI would use a sort, to sort them alphabetically,\
    \ then use to_s to get the string value\n<code>", "  extension_strengths = {}\n\
    \  extensions.each do |extension|\n    extension_strengths[extension.downcase]\
    \ = extension.count('A') - extension.count('a')\n  end", "    extension_str =\
    \ ''\n    extension_num = -1\n    extension_str_len = len(extension_str)\n   \
    \ class_name_len = len(class_name)\n    extension_strength = -1\n    for extension\
    \ in extensions\n        if extension_strength > 0\n            extension_strength\
    \ /= (extension_str_len - extension_num)\n            if extension_strength >\
    \ extension_num\n                extension_strength = extension_num\n        \
    \        extension_str = extension\n        else\n            extension_strength\
    \ = extension_num\n            extension_str = extension\n    end\n    class_name\
    \ += '.' + extension_str\n    return class_name\nend", "  (0..extensions.length).sort\
    \ {|a, b| (extensions.index(b) - extensions.index(a)) }.first\nend", "  s = 0.\n\
    \  i = 0\n  while i < extensions.length\n    s += (extensions[i].split('').length\
    \ - 1) / (extensions[i].split('').length - 1)\n    i += 1\n  end\n  return class_name[0...i]\
    \ + s[0...i] * class_name[i..-1]\nend", "  cap = extensions.length\n  sm = extensions.length\n\
    \  \n  extensions.each { |ext|\n    cap = cap.succ\n    sm = sm.succ\n  }\n  \n\
    \  extension_strength = cap - sm\n  \n  extensions.sort.each { |ext|\n    ext\
    \ = \"#{class_name}.#{ext}\"\n    if ext.split('.').last == extension_strength.to_s\n\
    \      return ext\n    end\n  }\n  \nend", "  # Initialize our return variable\
    \ to the empty string\n  return_value = ''\n  # We will use the helper method\
    \ 'count' to keep track of the number of letters in \n  # the extension name and\
    \ the letter CAP in the helper method 'CAP', where \n  # CAP is the number of\
    \ capitals in the class name. Let's assume CAP is 4 for \n  # this example. The\
    \ first letter of the extension name is 'S', the number of \n  # letters in 'S'\
    \ is 1, the number of capitals in 'S' is 2. We will use the \n  # helper method\
    \ 'count' to keep track of the number of letters in \n  # the extension name and\
    \ the letter SM in the helper method 'SM', where SM is \n  # the number of small\
    \ letters in the class name. Let's assume SM is 1 for \n  # this example. The\
    \ first letter in the extension name is 'A', the number of \n  # letters in 'A'\
    \ is 1, the number of small letters in 'A' is 2. We will \n  # use the helper\
    \ method 'count' to keep track of the number of letters in \n  # the extension\
    \ name and the letter SM in the helper method 'SM', where SM is \n  # the number\
    \ of small letters in the class name. Let's assume SM is 1 for \n  # this example.\
    \ The first letter in the extension name is 'E', the number of \n  # letters in\
    \ 'E' is 2, the number of small letters in 'E' is 1. We will \n  # use the helper\
    \ method 'count' to keep track of the number of letters in \n  # the extension\
    \ name and the letter SM in the helper method 'SM', where SM is \n  # the number\
    \ of small letters in the class name. Let's assume SM is 1 for \n  # this example.\
    \ The first letter in the extension name is 'R', the number of \n  # letters in\
    \ 'R' is 1, the number of small letters in 'R' is 2. We will \n  # use the helper\
    \ method 'count' to keep track of the number of letters in \n  # the extension\
    \ name and the letter SM in the helper method 'SM', where SM is \n  # the number\
    \ of small letters in the class name. Let's assume SM is 1 for \n  # this example.\
    \ The first letter in the extension name is 'V', the number of \n  # letters in\
    \ 'V' is 1, the number of small letters in 'V' is 2. We will \n  # use the helper\
    \ method 'count' to keep track of the number of letters in \n  # the extension\
    \ name and the letter SM in the helper method 'SM', where SM is \n  # the number\
    \ of small letters in the class name. Let's assume SM is 1 for \n  # this example.\
    \ The first letter in the extension name is 'I', the number of \n  # letters in\
    \ 'I' is 2, the number of small letters in 'I' is 1. We will \n  # use the helper\
    \ method 'count' to keep track of the number of letters in \n  # the extension\
    \ name and the letter SM in the helper method 'SM', where SM is \n  # the number\
    \ of small letters in the class name. Let's assume ", "  extension_length = extensions.length\n\
    \  if extension_length < 1 then return nil\n  \n  extensions.sort.reverse!\n \
    \ extension_sum = 0\n  \n  i = 0\n  while i < extension_length\n    extension_sum\
    \ += extensions[i].to_i\n    i += 1\n  end", "\t\n\t\n\textension_strengths =\
    \ []\n\textension_strongest_extension = ''\n\t\n\t\n\t\n\tfor i in range(len(extensions)):\n\
    \t\textension_strengths.append(len(extensions[i])-len(extensions[i].upper()))\n\
    \t\n\t\n\textension_strengths.sort()\n\t\n\t\n\tfor i in range(len(extension_strengths)):\n\
    \t\tif extension_strengths[i] == len(extension_strengths)-1:\n\t\t\textension_strongest_extension\
    \ += class_name+\".\"+extensions[i]\n\t\t\tbreak\n\t\telse:\n\t\t\textension_strongest_extension\
    \ += class_name+\".\"+extensions[i]", "  \n  # The code you write here will be\
    \ evaluated in the \"else\" part of the if statement.\n  # It will return the\
    \ string that has the highest extension strength among \n  # the extensions passed\
    \ in the arguments.\n  \n  # Return a string that has the highest extension strength\
    \ among the\n  # extensions passed in the arguments. Return '' if the list of\n\
    \  # extensions is empty.\n  \n  # Declare a variable named \"strength\" as an\
    \ integer.\n  strength = 0\n  \n  # Declare a variable named \"extension_strength\"\
    \ as an integer.\n  extension_strength = 0\n  \n  # Declare a variable named \"\
    extension\" as an integer.\n  extension = 0\n  \n  # Declare a variable named\
    \ \"extension_name\" as a string.\n  extension_name = ''\n  \n  # Declare a variable\
    \ named \"class_name\" as a string.\n  class_name = ''\n  \n  # Initialize \"\
    extension_name\" as an empty string.\n  extension_name = ''\n  \n  # For each\
    \ of the extensions passed in the arguments:\n  for extension in extensions\n\
    \  \n    # Get the extension name by removing everything after the first uppercase\
    \ letter.\n    extension_name = extension_name[1:] unless extension_name.include?(extension[0])\n\
    \  \n    # Increment \"extension_strength\" by 1.\n    extension_strength += 1\n\
    \  \n    # Get the extension name by removing everything after the last lowercase\
    \ letter.\n    extension_name = extension_name[:-1] unless extension_name.include?(extension[-1])\n\
    \  \n    # Increment \"strength\" by 1.\n    strength += 1\n    \n    # If the\
    \ extension's name contains any uppercase letters \n    # (except the first) and\
    \ no lowercase letters, increase \"strength\" by 1.\n    # Otherwise, increase\
    \ \"extension_strength\" by 1.\n    \n    strength = strength + extension_strength\
    \ if extension_name.include?(extension[0]) && !extension_name.include?(extension[-1])\
    \ \n    extension_strength = extension_strength + 1 if extension_name.include?(extension[-1])\
    \ && !extension_name.include?(extension[0])\n  end\n  \n  # Return the extension\
    \ that has the strongest extension strength.\n  return extension_name if strength\
    \ == extension_strength\n  \n  # Return '' if the list of extensions is empty.\n\
    end\n</cell>\n<cell>", "    # Your code here\n    \n    return class_name", " \
    \ # TODO: write code here\n  raise \"Not implemented\"\nend\n</cell>\n<code language=julia-1.3>",
  "    strength = -2\n    \n    extension_counter = 0\n    for extension in extensions\n\
    \        extension_counter = extension_counter + 1 if extension_counter < extension.length\n\
    \        \n        frac = extension_counter / extension.length.to_f\n        \n\
    \        strength = strength + frac\n    end\n    \n    if strength > -1\n   \
    \     return class_name.gsub(\".\", \".\") + extensions[strength].to_s\n    else\n\
    \        return class_name.gsub(\".\", \".\") + \".\" + \"NONE\"\n    end\nend",
  "    \n    ext = []\n    \n    \n    # Compute the strength of each extension.\n\
    \    for i in 0..(extensions.length-1)\n        ext = ext + [ (extensions[i]-extensions[i+1]).to_s\
    \ ]\n    \n    \n    \n    # Find the strongest extension.\n    ext1 = extensions[0..(ext.length-1)]\n\
    \    ext2 = extensions[0..(ext.length-1)]\n    \n    \n    # Calculate the strength\
    \ of the two extensions.\n    for i in 0..(ext1.length-1)\n        ext1[i] = ext1[i].to_i\n\
    \        ext2[i] = ext2[i].to_i\n    \n    \n    ext1_strength = ext1.inject(0){|s,e|\
    \ s+e }\n    ext2_strength = ext2.inject(0){|s,e| s+e }\n    \n    \n    # Return\
    \ only extensions with the highest strength.\n    if (ext1_strength > ext2_strength)\n\
    \        return class_name.to_s + '.' + ext1.last\n    elsif (ext1_strength ==\
    \ ext2_strength)\n        return class_name.to_s + '.' + ext1.first\n    end\n\
    \    \nend", "  extensions_sorted = extensions.sort_by { |e| e.to_s.size }\n \
    \ extensions_sorted.each do |extension|\n    if extension.to_s.size == class_name.length\n\
    \      return \"#{class_name}.#{extension}\"\n    end\n  end\n  raise \"No extension\
    \ with given length\"\nend", "\tstrongest_extension = ''\n\tstrongest_extension_strength\
    \ = -1\n\t\n\t# your code here\n\t\n\treturn strongest_extension\nend", "  extensions.map!\
    \ {|e| e.downcase}\n  extensions.sort!\n  strength = extensions.length\n  \n \
    \ extension_index = 0\n  while extension_index < extensions.length\n    if extensions[extension_index]\
    \ == extensions[extension_index].upcase\n      extension_index += 1\n    else\n\
    \      break\n    end\n  end\n  \n  extensions.delete_at(extension_index)\n  \n\
    \  if extensions.length == 0\n    class_name.split('.')\n    class_name = class_name[0].downcase\
    \ + class_name[1..-1]\n  else\n    extensions.reverse!\n  end\n  extensions.map!\
    \ {|e| e.downcase}\n  extensions.sort!\n  extensions.reverse!\n  \n  extension_index\
    \ = 0\n  while extension_index < extensions.length\n    if extensions[extension_index]\
    \ == extensions[extension_index].upcase\n      extension_index += 1\n    else\n\
    \      break\n    end\n  end\n  extensions.delete_at(extension_index)\n  \n  new_class_name\
    \ = class_name[0].downcase + extensions[0...extension_index].join.upcase\n  new_class_name.split('.').map\
    \ {|c| c.capitalize}\nend", "  extensions.sort\n  last_extension = extensions[-1]\n\
    \  first_extension = extensions[0]\n  strength = last_extension.size - first_extension.size\n\
    \  \n  return class_name+\".\"+(first_extension.slice(0,strength))\nend", "  #TODO:\
    \ Write code to find the strongest extension\nend\n</cell>\n<cell>", "  extension\
    \ = extensions.sort.last\n  extension = extension.capitalize\n  extensions.each\
    \ do |e|\n    if e.index(extension) == 0\n      break\n    end\n  end\n  return\
    \ \"#{class_name}.#{extension}\"\nend\n</cell>\n<cell>", "  # Your code here\n\
    end", "  extensions_count = extensions.map { |ext| ext.size }.max\n  extensions_count.zero?\
    \ ? '' : class_name.split('').zip(extensions_count.to_a).\n      map { |(char,\
    \ count)| char+count.to_s.upcase }.join('.').\n      chomp('.')\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI feel like the `choose` method is a bit too overcomplicated\
    \ here. It's pretty easy to just sort the extensions by length descending and\
    \ then just find the first item in the result list that has at least one element\
    \ and it's length is greater than zero.\n<|/ c |>\n<| c |>\nThe problem is I did\
    \ not understand the logic behind the `choose` method and I do not have any knowledge\
    \ of Ruby so I tried to make my own solution. Although it is true that the sort\
    \ is unnecessary and I agree that `select` is the better method (I am new to ruby\
    \ so I did not know about this method).\n<|/ c |>\n<| c |>\nI thought I understood\
    \ `choose`... I looked at the docs and didn't realize it could take a block. Well,\
    \ here's [another article](http://www.ruby-doc.org/core-1.9.3/Enumerable.html#method-i-choose)\
    \ on it, and [an explanation](http://www.rubycentral.com/articles/ruby-enumerable-extensions)\
    \ of its usefulness.\n<|/ c |>\n<| a |>\nI love the chosen method, but I think\
    \ it might be simpler to sort alphabetically and take the first item that has\
    \ at least one character:\n<code>", "  extension_set = {}\n  extensions.each do\
    \ |ext|\n    extension_set[ext.downcase] = true\n  end\n  \n  extension_set.each\
    \ do |ext_name, flag|\n    ext_len = ext_name.length\n    ext_cap = ext_len.upcase\
    \ - ext_len.downcase\n    ext_sm = ext_cap.downcase - ext_cap.upcase\n    if flag\
    \ && extension_set[ext_name]\n      extension_set[ext_name].each do |e|\n    \
    \    if e == ext_name\n          extension_set[ext_name] = false\n          break\n\
    \        end\n      end\n    end\n  end\n  \n  if extension_set.empty?\n    return\
    \ nil\n  end\n  \n  extension_set.each do |ext_name, flag|\n    ext_len = ext_name.length\n\
    \    ext_cap = ext_len.upcase - ext_len.downcase\n    ext_sm = ext_cap.downcase\
    \ - ext_cap.upcase\n    if flag\n      break\n    end\n  end\n  \n  extension_set.sort.reverse.first.to_s\
    \ + '.' +\n    extension_set.sort.reverse.last\nend\n</cell>\n<cell>", "  extensions.sort!\n\
    \  strongest = nil\n  index = -1\n  extensions.each do |ext|\n    index = index\
    \ + 1\n    if index != 0\n      ext1 = ext.downcase\n      ext2 = extensions[index-1].downcase\n\
    \      strength = (ext1.size + ext2.size) - ext1.size - ext2.size\n    else\n\
    \      strength = 0\n    end\n    if strength > strongest.size or strength ==\
    \ 0\n      strongest = ext\n    end\n  end\n  strongest\nend", "  extensions_count\
    \ = extensions.count\n  extensions_count.times do |i|\n    if extensions[i].downcase\
    \ == extensions[i].downcase.capitalize\n      return class_name + '.' + extensions[i].downcase\n\
    \    end\n  end\nend\n</code>\n<|/ q |>\n<| a |>\nHow about this simple one? :\n\
    <code>", "  best_strength = -1 \n  best_extension = \"\"\n  for extension in extensions\n\
    \    if extension_strongest(extension, class_name)\n      best_extension = extension\n\
    \      best_strength = extension_strength(extension, class_name)\n    end\n  end\n\
    \  return best_extension\nend", "  strength = extensions.length\n  extensions.each\
    \ do |ext|\n    ext_length = ext.length\n    ext_name = ext.split('')\n    ext_count.each\
    \ do |letter|\n      ext_count = ext_count.select { |n| n != letter }\n      if\
    \ ext_count.length < ext_length\n        strength -= ext_count.length\n      end\n\
    \    end\n  end\n  if strength < 0\n    extensions.each do |ext|\n      ext_length\
    \ = ext.length\n      ext_name = ext.split('')\n      ext_count.each do |letter|\n\
    \        ext_count = ext_count.select { |n| n != letter }\n        strength -=\
    \ ext_count.length\n      end\n    end\n  end\n  print class_name\n  print \"\
    .\"\n  print extensions\n  print \".\"\n  if strength == 0\n    return class_name\
    \ \n  end\n  strength.to_s.rjust(class_name.size).downcase\nend", "  cap_extensions\
    \ = extensions.collect { |e| e.capitalize }\n  sm_extensions = extensions.collect\
    \ { |e| e.downcase }\n  strength_of_extensions = cap_extensions - sm_extensions\n\
    \  \n  max_strength = strength_of_extensions.max\n  \n  extension_of_max_strength\
    \ = cap_extensions.find { |e| e.capitalize == max_strength }\n  \n  return class_name\
    \ + extension_of_max_strength\nend", "  return extensions[Strongest(extensions)]\n\
    end", "  max_extension_value = -1\n  max_extension_name = nil", "    \n    count=0\n\
    \    extension_array=[]\n    \n    extension_array.push(class_name)\n    \n  \
    \  i=0\n    while i<=extensions.length-1\n        count+=extensions[i].length-1\n\
    \        \n        extension_array.push(extensions[i])\n        i+=1\n       \
    \ \n    end\n    \n    \n    if count>0\n        \n        extension_array.sort!\n\
    \        \n        extension_array.pop\n        \n        \n        i=extension_array.length-1\n\
    \        while i>=0\n            \n            if extension_array[i]==extension_array[i-1]\n\
    \                \n                extension_array.pop\n                \n   \
    \             i-=1\n            else\n                break\n            end\n\
    \        end\n        \n        extension_array.pop\n        \n        \n    \
    \    i=extension_array.length-2\n        while i>=0\n            if extension_array[i]==extension_array[i-1]\n\
    \                \n                extension_array.pop\n                \n   \
    \             i-=1\n            else\n                break\n            end\n\
    \        end\n        \n        extension_array.pop\n        \n        \n    \
    \    extension_array.push(\"(\" + class_name + \".\" +  extension_array[1] + \"\
    )\")\n        \n    end\n    \n    return extension_array.join(\".\") + \".\"\n\
    end", "    \n    # Write your code here\n    \nend\n</cell>\n<text>\nTest Your\
    \ Solution", "  extensions_hash = Hash.new(0)\n  extensions.each do |extension_name|\n\
    \    extensions_hash[extension_name.downcase.count('a'..'z')]+=1\n  end\n  \n\
    \  max_extension_value = extensions_hash.max_by{|k,v| -v}[1]\n  \n  class_name.constantize.const_get(max_extension_value).to_s\n\
    end", "    extension_strength = []\n    for extension in extensions\n        if\
    \ extension.include?(class_name)\n            extension_strength.push(extension.split(class_name)[1].split('').reduce(:+))\n\
    \        end\n    end\n    extension_strength.sort\n    return class_name.split(\"\
    .\").last.split(//).first.gsub(/\\d/, extension_strength.pop).join(\".\") if extension_strength.size\
    \ >= 1\n    return nil\nend\n</cell>\n<text>\nYour first task is to write a function\
    \ called \"Test\", that will return a boolean value depending on whether the first\
    \ argument is a class name and the second argument is a list containing strings\
    \ that represent class names. For example:", "  \n  # initialize two variables\
    \ to hold the strongest extension found and the \n  # number of letters in the\
    \ extension name\n  extension_found = ''\n  extension_letters = ''\n  \n  # iterate\
    \ over the list of extensions in the parameter\n  extensions.each do |ext|\n \
    \   \n    # if the extension name begins with a capital (capitals start counting\n\
    \    # from 1) increment the capital counter\n    if ext[0].upcase == ext[0]\n\
    \      extension_letters << ext[0].upcase\n      \n    # if the extension name\
    \ begins with a lowercase letter (lowercase start\n    # counting from 0) decrement\
    \ the lowercase counter\n    elsif ext[0].downcase == ext[0]\n      extension_letters\
    \ << ext[0].downcase\n      \n    # if the extension name has more than one letter\
    \ and it starts with a\n    # lowercase letter (lowercase start counting from\
    \ 0) decrement the\n    # lowercase counter\n    elsif ext[0] == ext[0].downcase\n\
    \      extension_letters << ext[0].downcase\n      \n    # if the extension name\
    \ has more than one letter and it starts with a\n    # capital letter (capitals\
    \ start counting from 1) increment the\n    # capital counter\n    elsif ext[0]\
    \ == ext[0].upcase\n      extension_letters << ext[0].upcase\n    end\n    \n\
    \    # if the extension_letters string is longer than the current extension_found\n\
    \    # string then set extension_found to the extension_letters string and \n\
    \    # increment the extension counter\n    if extension_letters.length > extension_found.length\n\
    \      extension_found = extension_letters\n      extension_letters = ''\n   \
    \   \n    # if the extension_letters string is the same as current extension_found\n\
    \    # string then increment the extension counter\n    elsif extension_letters\
    \ == extension_found\n      extension_letters = ''\n    end\n  end\n  \n  # if\
    \ the extension_letters string is empty (no letters in it) then set \n  # extension_found\
    \ to the class name as there is only one extension\n  if extension_letters.length\
    \ == ''\n    extension_found = class_name\n    extension_letters = ''\n  end\n\
    \  \n  # return the strongest extension\n  extension_found\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThanks for help, please check my update. The only issue with\
    \ your solution is it fails on this string: \"AClass BB DD EE EF GH IJ\", because\
    \ it has 2 capitals and 1 lowercase for the first extension.\n<|/ c |>\n<|", " \
    \ # Get the number of capital letters in the extensions name\n  num_capitals =\
    \ class_name.scan(/[A-Z]/).size\n  \n  # Get the number of lowercase letters in\
    \ the extensions name\n  num_lowercases = class_name.scan(/[a-z]/).size\n  \n\
    \  # Calculate the extensions strength\n  strength = num_capitals - num_lowercases\n\
    \  \n  # Find the strongest extension\n  max_extension = extensions[0]\n  for\
    \ i in extensions[1..-1]\n    if max_extension.include?(i)\n      if i == max_extension\n\
    \        max_extension = i\n      end\n    else\n      if i < max_extension\n\
    \        max_extension = i\n      end\n    end\n  end\n  \n  # Return the name\
    \ with the strongest extension\n  strongest_extension = \"#{class_name}.#{max_extension}\"\
    \nend\n</code>\n<|/ a |>\n<| c |>\nHow can you get these functions to work with\
    \ the sample code I gave?\n<|/ c |>\n<| c |>\nI added a line at the bottom which\
    \ should do it\n<|/ c |>\n<| a tags=ruby dscore=0 |>\nThe most simple method I\
    \ can think of is to just use regex to match the extension letters:\n<code>",
  "  \n  extensions_cap = Array.new\n  extensions_sm = Array.new\n  \n  extensions.each\
    \ do |ext|\n    ext.downcase.split(\"\").each do |c|\n      extensions_cap <<\
    \ c.to_i.chr\n    end\n    ext.downcase.split(\"\").each do |c|\n      extensions_sm\
    \ << c.to_i.chr\n    end\n  end\n  \n  extensions_cap.sort!\n  extensions_sm.sort!\n\
    \  \n  c = extensions_cap.count - extensions_sm.count\n  \n  if c < 0\n    p c\n\
    \  end\n  \n  extensions_cap.uniq.each do |c|\n    extensions_sm.each do |x|\n\
    \      break if x == c\n    end\n    break if c == extensions_cap.count - extensions_sm.count\n\
    \  end\n  \n  p class_name + extensions_cap.join + \".\" + extensions_sm.join\n\
    end", "  extension_strengths = Hash.new{|h, k| h[k] = -1}\n  extensions.each do\
    \ |extension|\n    extension = extension.downcase\n    extension_strengths[extension]\
    \ = 0 if extension_strengths[extension] < 0\n    extension_strengths[extension]\
    \ += 1\n  end\n  sorted_strengths = extension_strengths.sort_by{|k, v| v}\n  return\
    \ class_name + \".\" + sorted_strengths.first\nend", "  extensions_count = extensions.length\n\
    \  extensions_sum = extensions_count.times.map { |i| extensions[i].length }\n\
    \  extensions_average = extensions_sum / extensions_count\n  extensions_average.times\
    \ do |i|\n    if extensions_count > 1\n      best_extension = extensions[0]\n\
    \    else\n      best_extension = extensions[i]\n    end\n    break if best_extension.length\
    \ > class_name.length\n    break if best_extension.length < class_name.length\n\
    \    break if best_extension.length > class_name.length and best_extension.length\
    \ < class_name.length\n  end\n  class_name + \".\" + best_extension\nend", "\t\
    extension_count = extensions.inject(0) do |count, extension|\n\t\tcount.times\
    \ {\n\t\t\tif extension == extension_name \n\t\t\t\treturn count\n\t\t\tend\n\t\
    \t}\n\tend\n\tif extension_count > 0 \n\t\treturn class_name + extensions[0..(extension_count\
    \ - 1)].collect{|s| s.capitalize}.join('.') + \"#{extensions[extension_count].capitalize}\"\
    \n\telse\n\t\treturn nil\n\tend\nend", "  # Get the number of uppercase letters\n\
    \  capital_letters = class_name.count('A')\n  # Get the number of lowercase letters\n\
    \  lowercase_letters = class_name.count('a')\n  # Find the fraction of the capital\
    \ letters in the lowercase\n  frac = capital_letters / lowercase_letters\n  #\
    \ Find the strength of the extension\n  strength = frac.floor\n  # Sort the extensions\
    \ by strength\n  extensions.sort!\n  # Return the extension that has the maximum\
    \ strength\n  return extensions.first if strength == frac.max else class_name\n\
    end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a |>\nHere are some ways of doing\
    \ this, using Array#sort_by and Array#last to sort an array of strings by the\
    \ number of letters in a given string, and then Array#slice to get the last element\
    \ in the array, then Array#join to join that array into a string:\n<code>", " \
    \ return extensions.find { |e| e[/[A-Z](?!.*[A-Z])(?=[a-z])/].size <=> \n    \
    \                           e[/[a-z](?!.*[A-Z])(?=[A-Z])/].size }.\n  split('_').map(&:capitalize).join('')\n\
    end\n</code>\nAnd now for the method you asked about.\n<code>", "  extensions\
    \ = extensions.map(&:downcase)\n  extensions.map!{ |ext| ext.gsub(/[^\\da-z]/,\
    \ '') }\n  extensions.sort!\n  extensions.map!{ |ext| ext.capitalize }\n  extensions.map!{\
    \ |ext| ext[0] if ext.length > 0 }\n  extensions.map!{ |ext| ext[0..1] if ext.length\
    \ > 1 }\n  extensions.map!{ |ext| ext[1..] if ext.length > 2 }\n  extensions.map!{\
    \ |ext| ext[0..2] if ext.length > 3 }\n  extensions.map!{ |ext| ext[3..] if ext.length\
    \ > 4 }\n  extensions.map!{ |ext| ext[0..4] if ext.length > 5 }\n  extensions.map!{\
    \ |ext| ext[5..] if ext.length > 6 }\n  extensions.map!{ |ext| ext[0..6] if ext.length\
    \ > 7 }\n  extensions.map!{ |ext| ext[6..] if ext.length > 8 }\n  extensions.map!{\
    \ |ext| ext[0..7] if ext.length > 9 }\n  extensions.map!{ |ext| ext[7..] if ext.length\
    \ > 10 }\n  extensions.map!{ |ext| ext[0..8] if ext.length > 11 }\n  extensions.map!{\
    \ |ext| ext[8..] if ext.length > 12 }\n  extensions.map!{ |ext| ext[0..9] if ext.length\
    \ > 13 }\n  extensions.map!{ |ext| ext[9..] if ext.length > 14 }\n  extensions.map!{\
    \ |ext| ext[0..10] if ext.length > 15 }\n  extensions.map!{ |ext| ext[10..] if\
    \ ext.length > 16 }\n  extensions.map!{ |ext| ext[0..11] if ext.length > 17 }\n\
    \  extensions.map!{ |ext| ext[11..] if ext.length > 18 }\n  extensions.map!{ |ext|\
    \ ext[0..12] if ext.length > 19 }\n  extensions.map!{ |ext| ext[12..] if ext.length\
    \ > 20 }\n  extensions.map!{ |ext| ext[0..13] if ext.length > 21 }\n  extensions.map!{\
    \ |ext| ext[13..] if ext.length > 22 }\n  extensions.map!{ |ext| ext[0..14] if\
    \ ext.length > 23 }\n  extensions.map!{ |ext| ext[14..] if ext.length > 24 }\n\
    \  extensions.map!{ |ext| ext[0..15] if ext.length > 25 }\n  extensions.map!{\
    \ |ext| ", "  extensions.each_with_index do |e, index|\n    puts index\n    if\
    \ e.to_s.include?(class_name.to_s.upcase)\n      if index != 0\n        if e.to_s.include?(class_name.to_s.upcase)\
    \ && index == extensions.size - 1\n          puts extensions[index - 1]\n    \
    \      extensions.delete(index - 1)\n        end\n      end\n      if e.to_s.include?(class_name.to_s.downcase)\
    \ && index != 0\n        if e.to_s.include?(class_name.to_s.downcase) && index\
    \ == extensions.size - 1\n          puts extensions[index - 1]\n          extensions.delete(index\
    \ - 1)\n        end\n      end\n    end\n  end\n  \n  # print extensions array\n\
    \  puts extensions\n  \n  # return strongest extension\n  extensions.sort{|a,b|\
    \ b.to_s.size - a.to_s.size}.first\nend", "\textensions.each { |ext| \n\t\text_counts\
    \ = Hash.new(0)\n\t\text_counts[ext.upcase.count('a')] += 1\n\t\text_counts[ext.downcase.count('a')]\
    \ += 1\n\t\text_counts[ext.upcase.count('A')] += 1\n\t\text_counts[ext.downcase.count('A')]\
    \ += 1\n\t\text_counts[ext.upcase.count('0')] += 1\n\t\text_counts[ext.downcase.count('0')]\
    \ += 1\n\t\text_counts[ext.upcase.count('9')] += 1\n\t\text_counts[ext.downcase.count('9')]\
    \ += 1\n\t\text_counts.each { |k,v| v if k == 0 || k > 0 }\n\t\tsorted_exts =\
    \ ext_counts.sort_by { |k, v| -v }\n\t\tsorted_exts.last == ext ? sorted_exts.last\
    \ : sorted_exts.reverse.first\n\t}\nend", "  strongest = nil\n  extensions.each\
    \ do |extension|\n    index = class_name.index(extension)\n    extension_length\
    \ = extension.length\n    if index > 0 && index + extension_length > class_name.size\n\
    \      index = class_name.rindex(extension)\n    end\n    next_index = index +\
    \ extension_length\n    if index < 0 || next_index < 0 || next_index > class_name.size\n\
    \      return extension\n    end\n    if strongest.nil? or strength(extension)\
    \ < strength(strongest)\n      strongest = extension\n    end\n  end\n  return\
    \ strongest\nend\n</code>\n<|/ a |>\n<| a |>\nI implemented the code in JavaScript\
    \ and it works fine in every test case. Try it.", "  #Your code here\nend", " \
    \ sorted = extensions.sort_by{|x| x.split('').map(&:upcase).inject(0){|sum, letter|\
    \ sum + letter; sum}}\n  max_strength = -1 \n  max_extension = ''\n  sorted.each\
    \ do |e|\n    if e.split('').map(&:downcase).inject(0){|sum, letter| sum + letter}\
    \ > max_strength \n      max_extension = e\n      max_strength = e.split('').map(&:downcase).inject(0){|sum,\
    \ letter| sum + letter}\n    end \n  end\n  return \"#{class_name}.#{max_extension}\"\
    \ \nend", "  cap = class_name.count('A-Z')\n  sm = class_name.count('a-z')\n \
    \ total = cap - sm\n  if cap == 0 || sm == 0\n    raise \"Class name not recognized\"\
    \n  puts \"#{class_name}.#{extensions[total].split('').sort.join}\"\nend\n</code>\n\
    <|/ a tags=ruby dscore=1 |>\n<| c |>\nThank you very much! I thought i had to\
    \ put my code in but i forgot to add it. Now it is much clearer :D\n<|/ c |>\n\
    <| c |>\nWhat do you think of my approach? Should I keep it or should you go for\
    \ something else?\n<|/ c |>\n<| c |>\nI do not know Ruby, but I am quite sure\
    \ that my solution is not optimal, because you are actually doing a lot of string\
    \ manipulations. Maybe there is a more elegant solution in Ruby, but my approach\
    \ is more \"idiomatic\" Ruby.\n<|/ c |>\n<| c |>\nNo problem. Thank you very much\
    \ again :D\n<|/ c |>\n<| c |>\nI updated my answer and added a couple of tests.\
    \ I hope that it will help you to understand why my solution is \"better\" :).\n\
    <|/ c |>\n<| a tags=ruby |>\nYou can try with following code, \n<code>", "  extension_hash\
    \ = {}\n  extensions.each do |extension|\n    extension_hash[extension] = extension.count(\"\
    A\") - extension.count(\"a\")\n  end\n  extensions.sort.last.split.join('').downcase\
    \ + '-' + extensions.sort.last.split.join('').downcase.to_s.split.join('').downcase.gsub(/[^A-Z]/,\
    \ '').downcase\nend", "  max_strength = -1\n  max_strongest = ''\n  extensions.each_index\
    \ do |i|\n    if extensions[i].length >= max_strength\n      max_strongest = extensions[i]\n\
    \      max_strength = extensions[i].length\n    end\n  end\n  return class_name+max_strongest\n\
    end\n</code>\n<|/ a tags=ruby,class dscore=0 |>\n<| c |>\nThank you, but I guess\
    \ my question is still unsolved. It doesn't work for class names like \"Animal\"\
    \ and \"Pet\".  I posted a solution below if that helps anyone\n<|/ c |>\n<| a\
    \ dscore=0 tags=ruby,class |>\nHere is a solution that works for both classes\
    \ and modules defined in an array. It also returns nil if no extensions match\
    \ or there are multiple extensions with the same strength. \n<code>", "  extensions_count\
    \ = extensions.length\n  extensions.each { |extension| \n    extension_count =\
    \ extension.count\n    \n    # find and return the extension with strongest name\n\
    \    if (extension_count == extensions_count) && (extension.chars.map { |c| c.upcase\
    \ }.reduce(:+) == extension.count).zero?\n      p \"extension_count: #{extension_count}\"\
    \n      p \"extensions_count: #{extensions_count}\"\n      p \"extension: #{extension}\"\
    \n      p \"extension.chars: #{extension.chars}\"\n      p \"extension.chars.map(&:upcase):\
    \ #{extension.chars.map(&:upcase)}\"\n      p \"extension.chars.reduce(:+): #{extension.chars.reduce(:+)}\"\
    \n      p \"extension.count: #{extension.count}\"\n      p \"extension: #{extension.upcase}\"\
    \n      return class_name.upcase + extension.upcase\n    end\n  }\n  raise \"\
    No extension with equal number of letters in name\"\nend\n</code>\nThe code below\
    \ should work:\n<code>", end, "  #Write your code here.\n  \n  extensions_count\
    \ = extensions.length\n  extension_count = extensions.count{|e| e.length}\n  \n\
    \  if extensions_count > 0 && extension_count > 0\n    sorted_extensions = extensions.sort\n\
    \    \n    if sorted_extensions.length == extensions_count\n      strength = sorted_extensions.length\
    \ - extension_count\n    else\n      strength = extension_count / sorted_extensions.length\n\
    \    end\n    \n    if strength > 0\n      sorted_extensions.each do |e|\n   \
    \     return class_name + e.downcase + Strongest_Extension(class_name, extensions[1..-1])\n\
    \      end\n    end\n  end\n  return class_name\nend\n</code>\n<|/ a tags=ruby,algorithm\
    \ dscore=2 |>\n<| a |>\n<code>", "  strongest_extension = nil\n  extensions.sort.each\
    \ do |ext|\n    unless strongest_extension\n      strongest_extension = class_name\n\
    \    elsif strongest_extension.capitalize.include?(ext.capitalize)\n      break\
    \ if strongest_extension.capitalize > ext.capitalize\n      strongest_extension\
    \ = class_name\n    end\n  end\n  strongest_extension.capitalize + extensions.last.capitalize\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThe OP is asking about how to determine\
    \ the extension in lexicographical order based on the capitalization of the class\
    \ name. This will give them the extension in lexicographical order based on the\
    \ string length in descending order, which is not what is required by the OP.\n\
    <|/ c |>\n<| a dscore=1 |>\nYou can try using something like this:\n<code>", " \
    \ extensions_count = extensions.reduce(:+)\n  extensions_count = extensions_count\
    \ > 0 ? extensions_count : 1\n  extensions_count.times do |i|\n    name_length\
    \ = class_name.length\n    name_length.times do |j|\n      if i != 0 && j != 0\
    \ && (j % name_length) == 0 && class_name[j] == class_name[j-1]\n        name_length\
    \ -= 1\n      else\n        break\n      end\n    end\n    if class_name.slice(name_length\
    \ - extensions_count.to_s, name_length).downcase == extensions[i]\n      return\
    \ class_name.slice(name_length - extensions_count.to_s, name_length).downcase\
    \ + \".\" + extensions[i]\n    end\n  end\nend", "  best_extension, best_strength\
    \ = extensions[0], -1\n  extension_strengths = Hash.new(0)\n  extensions.each\
    \ do |ext|\n    extension_strengths[ext] += 1\n  end\n  extension_strengths.sort.each\
    \ do |ext, strength|\n    if strength > best_strength\n      best_extension =\
    \ ext\n      best_strength = strength\n    end\n  end\n  \"#{class_name}.#{best_extension}\"\
    \nend\n</cell>\n<cell>", "  result = nil\n  extensions.each do |ext|\n    ext_cap_len\
    \ = ext.size\n    ext_sm_len = ext.downcase.size\n    \n    if ext_cap_len - ext_sm_len\
    \ > 0\n      strength = (ext_cap_len - ext_sm_len) / ext_cap_len\n      \n   \
    \   break if strength == 0\n      \n      if strength <= 0\n        strength =\
    \ -1 \n      else\n        strength *= -1\n      end\n      \n      result = class_name\
    \ + '.' + ext if strength > 0\n      result = class_name + '.' + ext.upcase if\
    \ strength > 0\n    end\n  end\n  \n  result\nend", "  strength = -1 \n  extension_name\
    \ =nil\n  index = 0\n  while index < extensions.count\n    extension = extensions[index]\n\
    \    begin = extension.index('C')\n    end = extension.index('E')\n    extension_name\
    \ = extension[0..begin-1].to_s + extension[end..-1]\n    begin = extension_name.index('C')\n\
    \    end = extension_name.index('E')\n    extension_name[begin..end]\n    if strength\
    \ == -1\n      strength = extension_name[0].ord.to_i\n    else\n      strength\
    \ = strcmp(extension_name, extension_name[0].ord.to_i)\n      if strength > strength\n\
    \        strength = extension_name[0].ord.to_i\n      end\n    end\n    index\
    \ = index + 1\n  end\n  return class_name.to_s + '.' + extension_name.to_s # 'my_class.AA'\n\
    end", "  # Your code here\nend", "  class_name.gsub!(/([A-Z]+)([A-Z][a-z])/, '\\\
    1.\\2')\n  class_name.gsub!(/([a-z]+)([A-Z])/, '\\1.\\2')\n  strongest_extension\
    \ = extensions.max_by(&:length)\n  class_name.gsub!(/([A-Z][a-z])/, strongest_extension)\n\
    end", "  strongest = ''\n  strongest_count = 0\n  extension_count = extensions.count\n\
    \  for i in 1...extension_count\n    extension = extensions[(i - 1)]\n    letters\
    \ = extension.downcase\n    count = letters.count\n    strength = (count - letters.count)\
    \ / letter_count(letters)\n    strongest = extension if strongest_count < strength\
    \ \n    strongest_count = strength\n  end\n  strongest += '.' + class_name\n \
    \ return strongest\nend", "    # Write your code here.\n    array = extensions.map\
    \ {|e| e.downcase}\n    array.sort.reverse!\n    strongest_extension = array[array.index\
    \ { |e| e.include?(class_name.upcase) }]\n    return class_name + '.' + strongest_extension\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\"you should return 'Slices.SErviNGSliCes'\
    \ since 'SErviNGSliCes' is the strongest extension (its strength is -1).\" I guess\
    \ this would be more of a \"it must return 'Slices' since it is the strongest\
    \ extension (its strength is 1)\"\n<|/ c |>\n<| c |>\nYes, you're right. I edited\
    \ my answer. Thank you!\n<|/ c |>\n<| c |>\nYou can simplify the solution by replacing\
    \ `extensions.map {|e| e.downcase}` with `extensions.map(&:downcase)`\n<|/ c |>\n\
    <| c |>\nThat's not valid syntax\n<|/ c |>\n<| c |>\nIt works perfectly fine for\
    \ me in Ruby 2.1.1 . Which version are you using?\n<|/ c |>\n<| a dscore=3 |>\n\
    The accepted answer is very useful and complete.\nI have written the following\
    \ code to achieve the result with minimum code changes:\n<code>", "\tresult =\
    \ ''\n\t\n\textension_count = extensions.size\n\t\n\tsorted_extensions = extensions.sort{|a,b|\
    \ b.to_i.abs<=>a.to_i}\n\t\n\tstrongest_extensions = sorted_extensions[0..extension_count-1]\n\
    \t\n\tstrongest_extensions.each do |strongest|\n\t\tresult = result + \"#{class_name}#{strongest.to_s.upcase}#{'\
    \ ' if result.present?}, \"\n\tend\n\t\n\tresult = result[0..-3]\n\t\n\treturn\
    \ result\nend", "  extensions.sort_by{|x| -x.count}\n  extensions.reverse.shift\n\
    \  extensions.count{|x| x.upcase.to_s.size > x.downcase.to_s.size}\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThank you so much! I really appreciate it\n<|/ c |>\n<| c |>\n\
    This is brilliant!\n<|/ c |>\n<| a |>\nI have taken this problem as an exercise,\
    \ to help me learn ruby.\nI have tried to implement the solution in the most efficient\
    \ way possible, and also have commented the solution so that you won't miss it.\n\
    <code>", "    \n    extension_strengths = []\n    class_strength = class_name.count(\"\
    !\")\n    class_strength += class_name.count(\"?\") \n    class_strength += class_name.count(\"\
    ,\")\n    class_strength += class_name.count(\":\")\n    class_strength += class_name.count(\"\
    ;\")\n    class_strength += class_name.count(\".\")\n    class_strength += class_name.count(\"\
    !\")\n    class_strength += class_name.count(\"?\")\n    class_strength += class_name.count(\"\
    ,\")\n    class_strength += class_name.count(\":\")\n    class_strength += class_name.count(\"\
    ;\")\n    class_strength += class_name.count(\".\")\n    class_strength += class_name.count(\"\
    !\")\n    class_strength += class_name.count(\"?\")\n    class_strength += class_name.count(\"\
    ,\")\n    class_strength += class_name.count(\":\")\n    class_strength += class_name.count(\"\
    ;\")\n    class_strength += class_name.count(\".\")\n    class_strength += class_name.count(\"\
    !\")\n    class_strength += class_name.count(\"?\")\n    class_strength += class_name.count(\"\
    ,\")\n    class_strength += class_name.count(\":\")\n    class_strength += class_name.count(\"\
    ;\")\n    class_strength += class_name.count(\".\")\n    class_strength += class_name.count(\"\
    !\")\n    class_strength += class_name.count(\"?\")\n    class_strength += class_name.count(\"\
    ,\")\n    class_strength += class_name.count(\":\")\n    class_strength += class_name.count(\"\
    ;\")\n    class_strength += class_name.count(\".\")\n    class_strength += class_name.count(\"\
    !\")\n    class_strength += class_name.count(\"?\")\n    class_strength += class_name.count(\"\
    ,\")\n    class_strength += class_name.count(\":\")\n    class_strength += class_name.count(\"\
    ;\")\n    class_strength += class_name.count(\".\")\n    class_strength += class_name.count(\"\
    !\")\n    class_strength += class_name.count(\"?\")", "  extensions.sort!\n  extension_number\
    \ = 1\n  while extension_number <= extensions.count\n    if extensions[extension_number]\
    \ == extension_number - 1\n      return class_name.sub('(.)') { |s| s << '.';\
    \ s << extensions[extension_number].to_s }\n    end\n    extension_number += 1\n\
    \  end\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThat's pretty clever.  One thing\
    \ to note is that this returns `\"Slices\"` for \"Slices\" class with extensions\
    \ `['SErviNGSliCes', 'Cheese', 'StuFfed']`.\n<|/ c |>\n<| c |>\nyep, forgot about\
    \ that case. I added a note to that effect. Thanks.\n<|/ c |>\n<| a tags=ruby,string,regex\
    \ |>\nHere's a slightly more concise version of the answer from Chris:\n<code>",
  "  strength = extensions.size\n  strongest_extension = nil\n  extensions.each do\
    \ |ext|\n    if ext.downcase == class_name.downcase\n      strength = strength\
    \ - 1\n      if strength <= 0\n        strongest_extension = ext\n      end\n\
    \    end\n  end\n  return strongest_extension\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,oop\
    \ |>\n<| a dscore=0 |>\n<code>", "  strongest_extension = ''\n  extensions.each\
    \ do |extension|\n    length = extension.size \n    uppercase_letters = length\
    \ / 2 \n    lowercase_letters = length - uppercase_letters\n    strongest_extension\
    \ = extension[(uppercase_letters - lowercase_letters).downcase]\n  end \n  return\
    \ class_name + strongest_extension\nend \n</code>\n<|/ a dscore=1 tags=ruby |>\n\
    <| c |>\nThanks for the help. Can you please explain the code with comments? I'm\
    \ still not understanding it. Thank you.\n<|/ c |>\n<| c |>\nI have added comments\
    \ to the code. If it still doesn't make sense, I would suggest looking up Ruby\
    \ methods and classes at http://ruby-doc.org/core-2.0.0/index.html\n<|/ c |>\n\
    <| a dscore=0 |>\nTry this (without using any methods):\n<code>", "  extension_class\
    \ = String.downcase(class_name)\n  extension_strengths = Array.new\n  extensions.each\
    \ do |extension|\n    extension_strengths[extension.to_s.downcase.count(\"_\"\
    )-1] += 1\n  end\n  extension_strengths.sort_by! {|k, v| -v}\n  extension_strengths.uniq.first\n\
    end\n</cell>\n<cell>", "\t\n\tstrongest = extensions[0]\n\tstrongest_ext = extensions[0]\n\
    \t\n\tfor i in range(len(extensions))\n\t\tif (extensions[i].include?(strongest.downcase))\n\
    \t\t\tstrongest = extensions[i]\n\t\tend\n\t\n\tfor i in range(len(extensions))\n\
    \t\tif (extensions[i].include?(strongest_ext.downcase))\n\t\t\tstrongest_ext =\
    \ extensions[i]\n\t\tend\n\t\n\tif (strongest_ext.include?(strongest.downcase))\n\
    \t\tstrongest\n\telse\n\t\tclass_name\n\tend\nend", "    extension_strengths =\
    \ {}\n    extensions.each do |ext|\n        ext.split.each do |name|\n       \
    \     strength = name.scan(/[A-Z]/ ).size\n            extension_strengths[name]\
    \ = strength unless extension_strengths[name].nil?\n        end\n    end\n   \
    \ return class_name if extension_strengths.values.uniq.size == extension_strengths.size\n\
    \    most_common = []\n    extension_strengths.values.uniq.each do |strength|\n\
    \        most_common << [extension_strengths[most_common[0]], most_common].compact.first\n\
    \    end\n    most_common.inject(:+)\nend", "\t\n\tresult = ''\n\tcount = 0\n\t\
    \n\tfor i in extensions\n\t\tcount += 1\n\t\tif count == 1\n\t\t\tresult = class_name+'.'+i\n\
    \t\t\tbreak\n\t\t\n\t\tif class_name+'.'+i == result\n\t\t\tresult = class_name+'.'+i\n\
    \t\t\tbreak\n\t\t\n\t\tif class_name+'.'+i > result\n\t\t\tresult = class_name+'.'+i\n\
    \t\n\treturn result\n</cell>\n<text>\nPart 2 - Design a Slicing Method\nNow implement\
    \ the slicing method to split a string. You may use str.split \nand a list comprehension.",
  "  # TODO: Write your code here.\nend\n</cell>\n<cell>", "  # Your code here\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nthanks so much. your solution is really\
    \ helpful for me as I tried to practice ruby on rails :)\n<|/ c |>\n<| a tags=ruby\
    \ |>\nYou could use the following code:\n<code>", "  result = ''\n  strength =\
    \ -1 # default to the strongest extension strength\n  extension_hash = Hash.new()\n\
    \  extension_hash.update(extensions.collect{|x| x.capitalize})\n  extension_hash.update(extensions.collect{|x|\
    \ x.downcase})\n  extension_hash.each do |key, value|\n    puts \"#{key} = #{value}\"\
    \n    if value != ''\n      if strength == -1 || value.index(key.capitalize) ==\
    \ 0 || value.index(key.downcase) == 0\n        strength = key.index(key.capitalize)\
    \ == 0 ? key.index(key.downcase) : key.index(key.capitalize).length\n        result\
    \ = class_name\n      end\n    end\n  end\n  puts \"#{class_name}.#{result}\"\n\
    \  return result \nend\n</code>\n<|/ a |>\n<| c |>\nThanks for taking the time\
    \ to write this answer :) The problem is that the OP's example is oversimplified\
    \ for brevity, but his actual problem could be much more complicated.\n<|/ c |>\n\
    <| c |>\nThanks, I agree with you. Your answer would work well for most simple\
    \ problems, but the OP's actual problem is even more complicated. :-)\n<|/ c |>\n\
    <| c |>\nIt is not simple at all, if you take that into account. :-)\n<|/ c |>\n\
    <| a dscore=0 tags=ruby |>\nThis is just an attempt to come up with a solution\
    \ that uses some regex and some array-manipulation techniques. I'm sure this could\
    \ be improved upon.\n<code>", "  new_extensions = extensions.map{|e| e.downcase}\n\
    \  new_extensions.uniq!\n  new_extensions.sort!\n  new_extensions.first.to_sym\
    \ \nend", "\textension_array = extensions.sort\n\tstrongest_extension_index =\
    \ -1\n\tnumber_of_upper_letters = class_name.count('A')\n\tnumber_of_lower_letters\
    \ = class_name.count('a')\n\tnumber_of_upper_letters_in_extension = extension_array.count('A')\n\
    \tnumber_of_lower_letters_in_extension = extension_array.count('a')\n\tif number_of_upper_letters\
    \ < number_of_lower_letters\n\tstrongest_extension_index = number_of_upper_letters\
    \ - number_of_lower_letters\n\telsif number_of_upper_letters > number_of_lower_letters\n\
    \tstrongest_extension_index = number_of_upper_letters - number_of_lower_letters\n\
    \telsif number_of_upper_letters == number_of_lower_letters\n\tstrongest_extension_index\
    \ = number_of_upper_letters - number_of_lower_letters\n\telsif number_of_upper_letters\
    \ == number_of_lower_letters and number_of_upper_letters_in_extension < number_of_lower_letters_in_extension\n\
    \tstrongest_extension_index = number_of_upper_letters - number_of_lower_letters\n\
    \telsif number_of_upper_letters == number_of_lower_letters and number_of_upper_letters_in_extension\
    \ > number_of_lower_letters_in_extension\n\tstrongest_extension_index = number_of_upper_letters\
    \ - number_of_lower_letters\n\telsif number_of_upper_letters == number_of_lower_letters\
    \ and number_of_upper_letters_in_extension == number_of_lower_letters_in_extension\n\
    \tstrongest_extension_index = 0\n\telsif number_of_upper_letters == number_of_lower_letters\
    \ and number_of_upper_letters_in_extension != number_of_lower_letters_in_extension\n\
    \tstrongest_extension_index = number_of_upper_letters - number_of_lower_letters\n\
    \telsif number_of_upper_letters > number_of_lower_letters and number_of_upper_letters_in_extension\
    \ > number_of_lower_letters_in_extension\n\tstrongest_extension_index = number_of_upper_letters\
    \ - number_of_lower_letters\n\telsif number_of_upper_letters > number_of_lower_letters\
    \ and number_of_upper_letters_in_extension != number_of_lower_letters_in_extension\n\
    \tstrongest_extension_index = number_of_upper_letters - number_of_lower_letters\n\
    \telsif number_of_upper_letters > number_of_lower_letters and number_of_upper_letters_in_extension\
    \ == number_of_lower_letters_in_extension\n\tstrongest_extension_index = number_of_upper_letters\
    \ - number_of_lower_letters\n\telsif number_of_upper_letters == number_of_lower_letters\
    \ and number_of_upper_letters_in_extension != number_of_lower_letters_in_extension\n\
    \tstrongest_extension_index = number_of_upper_letters - number_of_lower_letters\n\
    \tend\n\treturn class_name + '.' + extension_array[strongest_extension_index]\n\
    end\n</cell>\n<code language=julia-1.5>", "  sorted_extensions = extensions.sort_by\
    \ { |extension| extension.length }\n  if sorted_extensions.any?\n    sorted_extensions.first.to_s\n\
    \  else\n    \"#{class_name.to_s}.NONE\"\n  end\nend", "  first_extension = extensions[0]\n\
    \  second_extension = extensions[1]\n  first_class_name = class_name.split('::')[0]\n\
    \  second_class_name = second_extension.split('::')[0]\n  first_class_name_length\
    \ = first_class_name.length\n  second_class_name_length = second_class_name.length\n\
    \  first_class_name_strength = 0\n  second_class_name_strength = 0\n  for letter\
    \ in first_class_name\n    first_class_name_strength += letter.toUpperCase().length\
    \ - letter.toLowerCase().length\n  end\n  for letter in second_class_name\n  \
    \  second_class_name_strength += letter.toUpperCase().length - letter.toLowerCase().length\n\
    \  end\n  return \"#{class_name}.#{second_extension.sub(/[\\sA-Z]/.,\"\")[first_class_name_strength..second_class_name_strength]}\"\
    \nend\n</code>\nHere are some tests I put together:\n<code>\nrequire 'test/unit'",
  "  max_count = 0\n  max_extension = nil\n  extensions.each do |ext|\n    count =\
    \ class_name.count(ext)\n    if count == max_count and ext != max_extension\n\
    \      max_extension = ext\n      max_count = count\n    end\n  end\n  return\
    \ class_name.gsub(max_count, max_count-max_extension)\nend", "  # Add your code\
    \ here\n  extensions.sort.reverse.find { |ext| ext.size == class_name.size }.to_s.split(\"\
    .\")\nend", "  best_extension = nil\n  best_strength = -1\n  extensions.each do\
    \ |extension|\n    extension_class = class_name + extension\n    extension_class.constantize.constants.each\
    \ do |const|\n      strength = const.split('_').map(&:upcase).inject(0) do |strength,\
    \ c| strength + (c.to_s.downcase == extension_class.downcase? ? 1 : 0)\n     \
    \ break if strength > best_strength\n      best_strength = strength\n      best_extension\
    \ = extension\n    end\n  end\n  return class_name + best_extension\nend", " \
    \ extension_strengths = Hash.new(0)\n  extensions.each { |ext| extension_strengths[ext]\
    \ += 1 }\n  extension_strengths.sort.reverse.first.to_s + '.' + \n  extension_strengths.sort.reverse.last.to_s\n\
    end", "  class_name_letters = class_name.to_s.split(//).map(&:to_upper)\n  extensions_letters\
    \ = extensions.map(&:to_s).map(&:to_upper)\n  \n  class_name_letters.zip(extensions_letters).max_by\
    \ { |(a,b)| b.to_i(:erfc) - a.to_i(:erfc) }\nend", "  candidates = extensions.collect\
    \ do |extension| \n    [extension.split(//).map(&:capitalize).join, extension.split(//).map(&:downcase).join]\n\
    \  end\n  candidates.sort.reverse.detect { |candidate| class_name.include? candidate\
    \ }\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  # your code here\n\
    end", "  (0...(extensions.count)).each do |i|\n    break extensions[0...i] if\
    \ (extensions[0...i].downcase == class_name.downcase)\n  end\n  extensions.last\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYou still need to define \"Strongest\
    \ extension\".  You just haven't done that.\n<|/ c |>\n<| c |>\nThanks, but I\
    \ don't want to have to define it. I was hoping to find a way to make `Strongest_Extension`\
    \ return the name of the \"strongest\" extension (as opposed to the extensions\
    \ list).\n<|/ c |>\n<| c |>\nI didn't think of using `Enumerable#max_by`. That\
    \ would work perfectly in most situations.\n<|/ c |>\n<| c |>\nAh, I see what\
    \ you're saying. That would actually be the perfect solution. However, that would\
    \ be a bit hard to implement, as I am not too familiar with the Ruby programming\
    \ language. Would you mind showing me how to do it in my situation?\n<|/ c |>\n\
    <| c |>\nAlso, how would you implement `Strongest_Extension` in my situation?\n\
    <|/ c |>\n<| a tags=ruby |>\nIf you don't want a library method, you can create\
    \ a class that implements Enumerable.  In this case, it looks for all the extensions\
    \ with that class name and returns the first one:\n<code>", "  strongest = extensions[0]\n\
    \  i = 1\n  while i <= extensions.length\n    if StrongestExtension(class_name,\
    \ extensions[i]) < strongest\n      strongest = StrongestExtension(class_name,\
    \ extensions[i])\n    end\n    i += 1\n  end\n  strongest\nend", "  cap = extensions.size\n\
    \  sm = extensions.size\n  ext1 = extensions.first\n  ext2 = extensions.last\n\
    \  ext1_idx = 0.upto(cap-1) { |i| ext1.chars.to_s.downcase.index(i.chars.to_s.downcase)\
    \ }\n  ext2_idx = 0.upto(sm-1) { |i| ext2.chars.to_s.downcase.index(i.chars.to_s.downcase)\
    \ }\n  extensions[(ext1_idx+ext2_idx)/2 -1]\nend", "  min_len = 100000000\n  max_len\
    \ = -1\n  class_name = class_name.to_s\n  extensions.each do |extension|\n   \
    \ len = extension.count('!')\n    if len == 0\n      len = extension.count('?')\n\
    \    end\n    len = len.to_f / 2.0\n    if len < min_len\n      min_len = len\n\
    \    end\n    if len > max_len\n      max_len = len\n    end\n  end\n  \n  len\
    \ = (max_len - min_len).abs\n  len if len > 0\nend", "\tmax_strength = -1\n\t\
    extension_str = ''\n\t\n\textensions.each do |e|\n\t\tif e.include?(class_name)\n\
    \t\t\textension_str = e\n\t\t\tmax_strength = e[e.length - 1]\n\t\t\tbreak\n\t\
    \tend\n\tend\n\t\n\textension_str\nend", "  # Your code here\nend", "\tstrongest_extension\
    \ = extensions[0]\n\tstrongest_extension_strength = -1\n\t\n\textensions.each\
    \ do |extension|\n\t\tif extension.split(//).reduce(:+).to_f < strongest_extension_strength\n\
    \t\t\tstrongest_extension_strength = extension.split(//).reduce(:+).to_f\n\t\t\
    \tstrongest_extension = extension\n\t\tend\n\tend\n\treturn class_name + \".\"\
    \ + strongest_extension\nend", "  best_extension = ''\n  best_strength = -1\n\
    \  best_count = -1\n  extensions.each do |e|\n    extension = e.split(/(.)/)\n\
    \    count = extension.count(' ')\n    strength = extension.count(/[Aa][Bb][Cc]/)\
    \ - extension.count(/[Aa][Cc]/)\n    strength = if count == 0\n              \
    \  -1\n              else\n                -count\n              end\n    \n \
    \   if strength > best_strength\n      best_strength = strength\n      best_extension\
    \ = e\n      best_count = count\n    end\n  end\n  \n  return class_name + \"\
    .\" + best_extension\nend", "  # Your code here\n  return \nend", "  \n  # Return\
    \ the Strongest Extension \n  strongest_extension = nil\n  extensions.each do\
    \ |ext|\n    break if ext.downcase == class_name.downcase\n  end\n  \n  strongest_extension\
    \ = ext if !strongest_extension.nil? and strongest_extension.length > 0\n  \n\
    \  return strongest_extension\nend\n</cell>\n<cell>", "  class_name = class_name.dup\n\
    \  extensions = extensions.collect {|e| e.dup}\n  extensions.reject! {|e| !e.include?(\"\
    .\") }\n  extensions.sort! {|a,b| a.size <=> b.size }\n  extensions.reverse!\n\
    \  return class_name+extensions.first.sub(\"(.)([A-Z][a-z]+)\",\".\\\\2\\\\1\"\
    )\nend", "  strongest_extension = nil\n  extension_class_names.each do |extension_class_name|\n\
    \    extension = extension(extension_class_name, extensions)\n    if strongest_extension\
    \ == nil\n      strongest_extension = extension\n    end\n    if extension.strength\
    \ > strongest_extension.strength\n      strongest_extension = extension\n    end\n\
    \  end\n  return strongest_extension.class_name if strongest_extension != nil\n\
    \  return class_name\nend", "  extensions.sort.reverse!\n  ext1 = extensions.sort.find\
    \ {|x| x.to_s.upcase.size == class_name.size}\n  if ext1\n    ext1.to_s.split(\"\
    \").each do |x| \n      if x.to_s.downcase.size == class_name.size\n        return\
    \ class_name + \".\" + x\n      end\n    end\n  end\n  ext2 = extensions.sort.find\
    \ {|x| x.to_s.downcase.size == class_name.size}\n  if ext2\n    ext2.to_s.split(\"\
    \").each do |x| \n      if x.to_s.upcase.size == class_name.size\n        return\
    \ class_name + \".\" + x\n      end\n    end\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nOkay great, thanks! But if I were to extend this to a hash with\
    \ multiple keys, how would I go about doing that? Like in the example above, how\
    \ would I extend this to hash {'A' => 1, 'B' => 2, 'C' => 3}?\n<|/ c |>\n<| c\
    \ |>\nThat should work fine, you just need one additional line to handle it.\n\
    <|/ c |>\n<| a tags=ruby,arrays dscore=0 |>\nI suppose this is what you want:\n\
    <code>", "  max_count = 0\n  max_extension = \"\"\n  extension_count = extensions.count",
  "  extension_strength = extension_score(extensions)\n  class_strongest = class_name\
    \ \n  class_count = extension_strength.count\n  \n  # Sort extensions by strength\n\
    \  sorted_extensions = extension_strength.sort_by {|k, v| -v}\n  \n  # Find top\
    \ extension\n  while sorted_extensions.any? { |k, v| k.last == class_strongest\
    \ }\n    extension = sorted_extensions.find { |k, v| k.last == class_strongest\
    \ }\n    top_extension = extension[0]\n    class_strongest = top_extension.first\n\
    \    class_count = extension_strength[class_strongest].count\n  end\n  \n  return\
    \ \"#{class_strongest}.#{class_strongest + class_count}\"\nend", "\tstrongest\
    \ = ''\n\textension_count = {}", "  my_class = class_name.upcase\n  extensions.sort!\n\
    \  extension_strengths = extensions.map { |ext|\n    ext.length - ext.gsub(my_class,\
    \ \"\").length\n  }\n  return \"#{my_class}.#{extension_strengths.min - 1}\"\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThe `sort_by &:length` should be `sort_by(&:length)`\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails |>\nYou can use the ruby string split method\
    \ \n<code>\n\"Slices\".split('').reverse.join.join('.')\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThe method \"split\" is not in Ruby 1.9.\n<|/ c |>\n<| c |>\nThis\
    \ solution is good, but you only need to reverse the string once. `string[::-1]`\
    \ works as well.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  extensions_set = Array.new(extensions,\
    \ 0)\n  extensions_set.sort! do |a, b| \n    (b.to_i.to_s + \"#\" + a.to_i).to_i\n\
    \  end \n  return class_name + extensions_set.last\nend", "    extensions_count\
    \ = extensions.size\n    extensions_count.times do |n|\n      if n < extensions_count\n\
    \        extensions_count += 1\n        break\n      end\n    end\n    \n    extensions_count.times\
    \ do |n|\n      extensions_name =  class_name.to_s.gsub(/[A-Z]/, extensions[n\
    \ % extensions_count].upcase).gsub(/[a-z]/, extensions[n % extensions_count].downcase)\n\
    \      extension_class = Object.const_get(extensions_name)\n      extension =\
    \ extension_class.new\n      return extensions_name.gsub(extensions_name.to_s[0,\
    \ extensions_name.to_s.index(extensions_name)], '').to_s + '.' + extension.StrongestExtensionName()\n\
    \    end\n    \n    ''\n  end", "\tCAP, SM = CAPITAL_LETTERS_AND_NUMBERS.split('-')\n\
    \t\n\textensions.sort!\n\t\n\treturn class_name+extensions[CAP-SM-1]\nend", " \
    \ \n  strongest_extension = extensions[0]\n  \n  for extension in extensions[1..-1]\n\
    \    if extension.include?(strongest_extension)\n      strongest_extension = extension\n\
    \    end\n  end", "  # Your code here\nend\n</cell>\n<code language=julia-1.0>",
  "  best_extension = extensions[0]\n  best_extension_strength = -1", "  best_extensions\
    \ = []\n  best_strength = -1\n  \n  extensions.each do |ext|\n    ext = ext.upcase\n\
    \    strength = ext_strength(ext)\n    if strength > best_strength\n      best_strength\
    \ = strength\n      best_extensions = [ext]\n    else\n      best_extensions <<\
    \ ext if best_extensions.count > 0 && strength == best_strength\n    end\n  end\n\
    \  \n  return class_name.concat(best_extensions.sort).join('.')\nend", "  extensions_sorted\
    \ = extensions.sort\n  extensions_sorted.reverse!\n  i = 0\n  while i < extensions_sorted.length\n\
    \    i += 1\n    if extensions_sorted[i] == class_name\n      return class_name.to_s\
    \ + '.' + extensions_sorted[i]\n    end\n  end\n  return nil\nend", "  # Your\
    \ code goes here\nend", "  \n  strongest = nil\n  extension_strength = nil\n \
    \ \n  extensions = extensions.sort.uniq.map { |e| e.split('') }\n  \n  # For each\
    \ extension, find the shortest extension with the same\n  # strength.\n  extensions.each\
    \ do |e|\n    \n    # If there exists a shorter extension that has the same strength.\n\
    \    # Then set it to the shortest extension.\n    unless strongest and extension_strength\n\
    \      if e.length >= strongest.length\n        strongest = e\n      elsif e.length\
    \ <= strongest.length\n        extension_strength = e.length - strongest.length\n\
    \      end\n    end\n  end\n  \n  # Return the classname.\n  class_name.to_s +\
    \ \".\" + strongest.join\nend", "    \n    extension_str = nil\n    \n    extensions_count\
    \ = extensions.length\n    extension_count = class_name.split(' ').length\n  \
    \  \n    extension_class_name = class_name.split(' ').join('')\n    \n    extension_str\
    \ = class_name + '.'\n    \n    extension_count -= extensions_count.to_i\n   \
    \ \n    if (extension_count != 0)\n    \n        for ext_index = 0\n        \n\
    \            extension_name = extensions[ext_index]\n            \n          \
    \  ext_class_name = extension_class_name + extension_name\n            \n    \
    \        if (ext_class_name.split(' ').length <= extension_count)\n          \
    \  \n                extension_str += ext_class_name.split(' ').join('')\n   \
    \         \n            end\n        end\n    end\n    \n    return extension_str\n\
    end", "    ext = Strongest(extensions)\n    return class_name + '.' + ext\nend",
  "  extension_hash = {}\n  extensions.each do |extension_name|\n    extension_hash[extension_name.downcase]\
    \ = extension_name\n  end\n  \n  class_name.split('.').each do |class_name|\n\
    \    \n    # Iterate over all possible extensions in this class\n    previous_index\
    \ = -1\n    extension_hash.each do |extension_name, extension_name_string|\n \
    \     \n      # If the extension is present in the current class\n      if extension_name.start_with?(extension_name_string)\n\
    \        \n        # increment the previous index\n        previous_index = extension_name.index(extension_name_string)\n\
    \        break\n      end\n    end\n    \n    # If we did not find the extension\
    \ \n    # in the class, then set it as -1 and break\n    if previous_index !=\
    \ -1\n      previous_index = -1\n      break\n    end\n  end\n  \n  # Get the\
    \ extension with a negative strength\n  previous_extension = extension_hash.values.find\
    \ {|extension_name| extension_name.start_with?(extension_hash.keys.last) }\n \
    \ \n  # Return the class and the extension with negative strength\n  return class_name.split('.').last,\
    \ previous_extension if previous_extension\nend", "  strength = extensions.map\
    \ { |e| e.length }.max + 1\n  extension_str = extensions[strength.to_i - 1]\n\
    \  class_name.replace extension_str\n  class_name.gsub!(/[^A-Za-z]/, '.')\n  class_name\n\
    end", "\thighest_strength = -1\n\t\n\textensions.each_with_index do |ext, index|\n\
    \t\tstrength = ext.to_s.downcase.count(ext.upcase)/ext.to_s.length\n\t\t\n\t\t\
    if strength > highest_strength\n\t\t\thighest_strength = strength\n\t\telsif strength\
    \ == highest_strength\n\t\t\thighest_strength = highest_strength if index == 0\n\
    \t\tend\n\tend\n\t\n\treturn class_name+\".\"+highest_strength.to_s.downcase\n\
    end", "  extensions.sort_by {|e| e.split('').reduce(0) {|acc, e| acc + e.upcasecase}}.first\n\
    end\n</code>\n<|/ a tags=ruby,string,algorithm |>\n<| c |>\nI like this solution.\
    \ But why are you splitting on `''` and not on `.` since your extensions have\
    \ periods?\n<|/ c |>\n<| c |>\nBecause I thought extensions could contain periods.\
    \ And a dot is always part of the extension's name. This was my assumption from\
    \ the way the question was phrased. I'm not going to go into details because that's\
    \ a rather vague question.\n<|/ c |>\n<| c |>\nIt's a good answer, but the complexity\
    \ is O(n^2). You would be better off with O(n).\n<|/ c |>\n<| a dscore=2 tags=ruby,string,algorithm\
    \ |>\nI suggest you use an external library like Faker gem for generating random\
    \ names and then to create your custom names. In your case you could use:\n<code>\n\
    Faker::Name.first_name\n</code>\nFaker is a gem providing you with random generators,\
    \ such as:\n<code>\nFaker::Name.first_name\nFaker::Name.last_name\nFaker::Name.name\n\
    Faker::Name.nickname\nFaker::Name.first_name\nFaker::Name.first_name\n</code>\n\
    <|/ a |>\n<| c |>\nFaker is a gem, but only provides names. He wants to generate\
    \ names.\n<|/ c |>\n<| c |>\n, i updated my answer, sorry for that\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>", "  extension_strength = extensions.length\n  max_extension_strength\
    \ = 0\n  best_extension = ''\n  best_extension_strength = -1", "  \n  extension_strengths\
    \ = {}\n  extensions.each do |extension|\n    extension.split(\"\").each do |x|\n\
    \      uppercase_letters = (x.length - x.upcase.length).abs\n      lowercase_letters\
    \ = x.length - uppercase_letters\n      extension_strengths[x] = (uppercase_letters\
    \ + lowercase_letters).to_f\n    end\n  end\n  \n  strongest_extension = nil\n\
    \  \n  extension_strengths.each do |k, v|\n    if v.max == v.min\n      strongest_extension\
    \ = k\n    end\n  end\n  \n  return [class_name, strongest_extension].join(\"\
    .\")\nend", "  extension_strengths = []\n  extensions.each do |e|\n    extension_strength\
    \ = e.length - e.downcase.count('a')\n    extension_strengths << extension_strength\n\
    \  end\n  \n  extension_strengths.sort!\n  \n  s = extension_strengths.first\n\
    \  extensions.each do |e|\n    if e.length != e.downcase.count('a') + 1 || (e.length\
    \ > e.downcase.count('a') + 1 && e.count('a') == e.downcase.count('a') && extension_strengths.index(e.length\
    \ - e.downcase.count('a') - 1) < extension_strengths.index(e.length - e.downcase.count('a')\
    \ - 2))\n      break\n    else\n      s += extension_strengths.index(e.length\
    \ - e.downcase.count('a') - 1)\n    end\n  end\n  \n  puts class_name.to_s + \"\
    #{class_name.downcase}.\" + extensions[s.to_i]\nend", "  extensions = extensions.to_a\n\
    \  extension_count = extensions.count\n  extensions.delete_if{|e| e == ''}\n \
    \ strength = extension_count.inject(0) {|sum, e| sum + e.count(e.upcase) - e.count(e.downcase)}\n\
    \  extension_count.delete_if{|e| e == ''}\n  return class_name.downcase + extensions.sort_by{|e|\
    \ e == extension_count.join}.join\nend\n</code>\n<|/ a tags=ruby,arrays,string\
    \ dscore=1 |>\n<| a tags=ruby,arrays,string dscore=1 |>\nHere are two solutions.\
    \ One is more generic and probably faster, the other is more concise and probably\
    \ easier for you to understand. The first method takes advantage of the fact that\
    \ strings are just arrays of characters, and counts how many times each letter\
    \ appears in another string. The second method assumes the word is one word and\
    \ checks the letters individually to find the \"strongest\" one.\n<code>", "\t\
    str = class_name \n\textensions = extensions.sort\n\ti = 0\n\twhile i < extensions.count\
    \ and i < 1\n\t\textensions[i].gsub(/[[:upper:]]/,'_').gsub(/[[:lower:]]/,'_')\n\
    \t\tif class_name.gsub('.','_') == extensions[i].gsub('.','_') \n\t\t\tstr = class_name\
    \ \n\t\tend\n\t\ti += 1\n\tend\n\treturn str\nend", "  sorted = extensions.sort\n\
    \  strengths = sorted.map { |x| x.include?(class_name.upcase) ? x.length - class_name.upcase.length\
    \ : -1 }\n  strengths.inject(:+)\n  sorted.find { |x| x.include?(class_name.upcase)\
    \ }\nend", "  str.downcase(class_name)\n  strongest_extension = nil\n  extensions.each\
    \ do |extension|\n    str.upcase(extension)\n    strength = extension.size - class_name.size\n\
    \    if strength == 0 \n      strongest_extension = extension\n      break\n \
    \   elsif strength > 0\n      strongest_extension = extension\n      break\n \
    \   end\n  end\n  strongest_extension\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    This is perfect!  Thank you! I wish I could vote you up more than once, I'm new\
    \ and I don't have enough reputation.\n<|/ c |>\n<| c |>\nGlad to help. Welcome\
    \ to the community. Welcome to StackOverflow.\n<|/ c |>\n<| c |>\nSorry to trouble\
    \ you, but is there a way to do this without using extensions? I'm still a beginner\
    \ and have never learned about them yet, so I'm asking you if I could write this\
    \ without them.  I appreciate it if you can help me!\n<|/ c |>\n<| c |>\n: Sure,\
    \ I'll post an alternative implementation. But first, what do you mean by _without\
    \ using extensions_? Extensions are a common way to extend classes. Are you trying\
    \ to avoid using them?\n<|/ c |>\n<| c |>\nYes I'm trying to avoid using them.\
    \ Just to clarify, I'm attempting to do this without using any built in Ruby methods\
    \ that don't involve extensions (unless that's a whole other question). Your code\
    \ doesn't work for my own code though. I'm attempting to modify the original code\
    \ I posted here with my own code as well.\n<|/ c |>\n<| a tags=ruby,string |>\n\
    You could try something like this:\n<code>", "  # Get the number of uppercase\
    \ letters in class_name.\n  upcase_letters = class_name.count(\"A-Z\")", "  strongest_extension\
    \ = nil\n  extensions.each do |extension|\n    extension = extension.upcase\n\
    \    uppercase_letters = extension.count('X')\n    lowercase_letters = extension.count('x')\n\
    \    strength = uppercase_letters - lowercase_letters\n    unless strongest_extension.nil?\n\
    \      if strength > strongest_extension.strength\n        strongest_extension\
    \ = extension\n      end\n    else\n      strongest_extension = extension\n  \
    \  end\n  end\n  strongest_extension.capitalize\nend", "  extensions.sort.reverse.each_with_index\
    \ do |e, i| \n    if class_name == e.gsub(' ', '').downcase.gsub('-', '').capitalize\n\
    \      return e[0...i]\n    end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a\
    \ |>\n<code>", "  candidates = extensions.group_by(&:capitalize).sort_by {|k,\
    \ v| -v.size}\n  best_candidate = nil\n  best_candidate.size = -1\n  best_candidate.name\
    \ = class_name\n  best_candidate.extension = nil\n  best_candidate.extensions\
    \ = []\n  extensions.each do |extension|\n    candidate = candidates[extension.capitalize]\n\
    \    candidate.size += 1 if candidate.size != -1 || best_candidate.size == -1\n\
    \    candidate.size -= 1 if best_candidate.size == -1 && candidate.size != -1\n\
    \    if candidate.size != -1\n      if best_candidate.size == -1 || best_candidate.size\
    \ < candidate.size\n        best_candidate = candidate\n      end\n      candidate.extensions\
    \ << extension\n    end\n  end\n  return best_candidate.extension\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\nHow does this work? Can you please explain\
    \ more?\n<|/ c |>\n<| c |>\nHi Rudi, can you please give some explanation on what\
    \ your code does? How does it return the best candidate?\n<|/ c |>\n<| a tags=ruby,string\
    \ dscore=2 |>\nHere's an alternative that doesn't use a loop. As others said,\
    \ it requires at least one loop, and it doesn't depend on any specific character\
    \ in the string to be the 'best' candidate.\n<code>", "  # Your code here\n  return\
    \ class_name\nend", "  strength = extensions.inject(0) do |strength, extension|\n\
    \    extension.upcase.count(extension) - extension.downcase.count(extension)\n\
    \  end\n  \n  strength.to_s + \"#{class_name.downcase}#{extensions.first.upcase}\"\
    \nend", "  strongest_extension = nil\n  extensions.each do |extension|\n    strength\
    \ = extension.downcase.count(\"a\")\n    strongest_extension = extension if strength\
    \ > strongest_extension.downcase.count(\"a\") and strength > 0\n  end\n  strongest_extension.gsub!(/[^A-Z]+/,\
    \ \"\")\n  strongest_extension.sub(/^([A-Z])/, '\\1'.uppercase )\nend\n</code>\n\
    And that is how I did it:\n<code>", "  extension_strongest = 0\n  extension_strength\
    \ = 0\n  \n  # Your code here!\n  \n  return class_name\nend\n</cell>\n<cell>\n\
    puts Strongest_Extension('my_class', ['AA', 'Be', 'CC'])\n</cell>\n<cell>", " \
    \ # Your code here\n  \nend", "  sorted_extensions = extensions.sort\n  strongest\
    \ = \"\"\n  index = -1\n  while index != -1\n    strongest = class_name + sorted_extensions[index]\n\
    \    if sorted_extensions.last == sorted_extensions[index]\n      index = sorted_extensions.size\
    \ - 1\n    else\n      index = sorted_extensions.index\n    end\n  end\n  return\
    \ strongest\nend", "  first_extension = extensions.shift\n  class_name_length\
    \ = len(class_name)\n  strength = class_name_length - first_extension.downcase.length\
    \ - 1\n  strength -= class_name_length - first_extension.upcase.length\n  strength\
    \ = strength.to_f\n  extensions.each do |extension|\n    strength -= extension.downcase.length\n\
    \    strength -= extension.upcase.length\n  end\n  if extensions.empty?\n    \"\
    #{class_name}.#{first_extension}\"\n  else\n    if first_extension.downcase ==\
    \ first_extension.upcase\n      \"#{class_name}.#{first_extension}\"\n    else\n\
    \      \"#{class_name}.#{first_extension.downcase}#{first_extension.upcase}#{Strongest_Extension(class_name,\
    \ extensions)}\"\n    end\n  end\nend", "  str_extensions = extensions.map { |e|\
    \ e.gsub(/[A-Z]/, '0').to_s }\n  str_extensions.sort!\n  return class_name + \"\
    .\" + str_extensions[0]\nend", "  \n  # Write your code here\n  extensions.sort.each_with_index.with_index\
    \ do |e,i|\n    upper, lower = e.downcase, e.upcase\n    strongest = lower if\
    \ i==0 || (upper.index(lower)>upper.index(upper))\n    return class_name if strongest.index(class_name)==0\n\
    \  end\n  \n  return class_name\nend", '  extensions.sort!', "  max_strength =\
    \ -1\n  max_name = ''\n  extensions.each do |ext|\n    if ext.downcase == class_name.downcase\n\
    \      strength = class_name.count(' ')\n    else\n      strength = ext.downcase.count('\
    \ ')\n    end\n    if strength > max_strength\n      max_strength = strength\n\
    \      max_name = ext\n    end\n  end\n  return max_name\nend", "  extension =\
    \  extensions[extensions.map{|x| x.gsub(/[\\dA-Z]/,\"\")}.uniq.sort.map{|x| x.to_s.upcase}.min]\n\
    \  return class_name + extension\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI\
    \ think you misunderstood what the problem was. Thanks for the answer though.\n\
    <|/ c |>\n<| c |>\nI did, I thought you wanted to know how to solve the problem\
    \ in Ruby rather than the problem itself :)\n<|/ c |>\n<| c |>\nYeah, I didn't\
    \ think Ruby had any built in sorting capabilities so I was kind of struggling\
    \ to find any sort of solution.\n<|/ c |>\n<| a tags=algorithm,ruby |>\nThis solution\
    \ works only for words with only one lowercase letter except the first letter.\
    \ Other solutions using sort or sort_by won't work\n<code>", "  best_extension_index\
    \ = 0\n  best_extension_strength = -1\n  best_extension_class_name = class_name\n\
    \  extensions.each_index do |i|\n    extension_class_name = extensions[i].downcase\n\
    \    extension_class_name = extension_class_name.gsub(/[^A-Z]/, \"\")\n    extension_class_name\
    \ = extension_class_name.gsub(/[A-Z]/, \"\")\n    extension_class_name = extension_class_name.gsub(/[A-Z]/,\
    \ \"\")\n    extension_class_name = extension_class_name.gsub(/[A-Z]/, \"\")\n\
    \    extension_class_name = extension_class_name.gsub(/[A-Z]/, \"\")\n    extension_class_name\
    \ = extension_class_name.gsub(/[A-Z]/, \"\")\n    extension_class_name = extension_class_name.gsub(/[A-Z]/,\
    \ \"\")\n    extension_class_name = extension_class_name.gsub(/[A-Z]/, \"\")\n\
    \    extension_class_name = extension_class_name.gsub(/[A-Z]/, \"\")\n    extension_class_name\
    \ = extension_class_name.gsub(/[A-Z]/, \"\")\n    extension_class_name = extension_class_name.gsub(/[A-Z]/,\
    \ \"\")\n    extension_class_name = extension_class_name.gsub(/[A-Z]/, \"\")\n\
    \    extension_class_name = extension_class_name.gsub(/[A-Z]/, \"\")\n    extension_class_name\
    \ = extension_class_name.gsub(/[A-Z]/, \"\")\n    extension_class_name = extension_class_name.gsub(/[A-Z]/,\
    \ \"\")\n    extension_class_name = extension_class_name.gsub(/[A-Z]/, \"\")\n\
    \    extension_class_name = extension_class_name.gsub(/[A-Z]/, \"\")\n    extension_class_name\
    \ = extension_class_name.gsub(/[A-Z]/, \"\")\n    extension_class_name = extension_class_name.gsub(/[A-Z]/,\
    \ \"\")\n    extension_class_name = extension_class_name.gsub(/[A-Z]/, \"\")\n\
    \    extension_class_name = extension_class_name.gsub(/[A-Z]/, \"\")\n    extension_class_name\
    \ = extension_class_name.gsub(/[A-Z]/, \"\")\n    extension_class_name = extension_class_name.gsub(/[A-Z]/,\
    \ \"\")\n    extension_class_name = extension_class_name.gsub(/[A-Z]/, \"\")\n\
    \    extension_class_name = extension_class_name.gsub(/[A-Z]/, \"\")\n    extension_class_name\
    \ = extension_class_name.gsub(/[A-Z]/, \"\")\n    extension_class_name = extension_class_name.gsub(/[A-Z]/,\
    \ \"\")\n    extension_class_name = extension_class_name.gsub(/", "  strength\
    \ = -1 \n  extension_array = extensions.to_a.sort\n  max_number = extension_array.max\n\
    \  extension = extension_array.first \n  max_number = extension_array.max\n  while\
    \ extension_array != max_number\n    extension_array.reject! do |value|\n    \
    \  value = extension_array.first\n      value = value.to_s.upcase\n      value\
    \ = value.to_s.downcase\n      value = value.to_s.split\n      value[0] = value[0].to_s.upcase\n\
    \      value[1] = value[1].to_s.downcase\n      value[1] = value[1].to_s.split\n\
    \      value[1].join\n      value[1] == extension.join \n    end\n    extension\
    \ = extension_array.first\n    max_number = extension_array.max\n  end\n  return\
    \ class_name + (extension.first).to_s\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    The idea is to keep looping till the highest number of the array is the same.\
    \ Once that happens, return that value, otherwise, return the last value in the\
    \ array.\n<|/ c |>\n<| c |>\nI added a test for the code above with your example.\
    \ Can you please tell me if that's what you were looking for?\n<|/ c |>\n<| c\
    \ |>\nThank you so much, this is exactly what i was looking for.\n<|/ c |>\n<|\
    \ c |>\nGlad I was able to help!\n<|/ c |>\n<| a dscore=0 |>\nYou need this\n\
    <code>", "  extensions = extensions.sort\n  extensions = extensions.map{|s| s.capitalize}\n\
    \  num_cap, num_ins = 0, 0\n  extensions.each do |extension|\n    if extension.index(class_name)\n\
    \      num_cap += 1\n    else\n      num_ins += 1\n    end\n  end\n  return class_name.to_s.capitalize\
    \ + \"#{class_name}.\" + extensions.first\nend\n</code>\n<|/ a dscore=0 tags=ruby\
    \ |>\n<| c |>\nNicely done, and a very good exercise.\n<|/ c |>\n<| c |>\nOne\
    \ thing to note is that the code fails because `extensions` is a list of strings\
    \ and not a list of classes.\n<|/ c |>\n<| c |>\nThank you. I'm actually glad\
    \ I got this far! \nI've never really written any Ruby code before so this was\
    \ super helpful!\n<|/ c |>\n<| c |>\nGreat. Good luck. Let me know if you have\
    \ any questions.\n<|/ c |>\n<| c |>\nThanks for the help. I was able to get it\
    \ working with some slight modifications. I was wondering, what if I don't know\
    \ how many classes are in the list? What if the list was ['AA', 'Be', 'CC', 'CDE',\
    \ 'EE']\n<|/ c |>\n<| a tags=ruby |>\nHere is something I wrote for this a while\
    \ ago:\n<code>", "    # Your code goes here\n    return class_name.gsub(/[A-Z][a-z]+/,\
    \ \"\").downcase.gsub(/[A-Z]/, \"\").to_sym\nend\n</code>\nYou can test your program\
    \ by changing \"Slices\" in the Strongest_Extension method with the class you\
    \ want.\n<|/ a tags=ruby |>\n<| c |>\nThis returns \"Slices\" rather than the\
    \ extension. I've edited my question with my updated code.\n<|/ c |>\n<| c |>\n\
    : I've updated my answer. Thanks for pointing out my mistake.\n<|/ c |>\n<| c\
    \ |>\nThanks so much for your help! I really appreciate it!\n<|/ c |>\n<| c |>\n\
    : You're welcome. I am glad that my answer helped you. :)\n<|/ c |>\n<| c |>\n\
    : No problem. :)\n<|/ c |>\n<| a tags=ruby |>\n<code>", "    my_class = class_name.split\
    \ # split class_name into an array with three elements\n    my_class.shift # Remove\
    \ the first element\n    my_class.map!(&:downcase) # Make all elements lower case\n\
    \    extensions_sorted = extensions.sort # Sort the extensions by decreasing order\
    \ of their length\n    extensions_sorted.delete_if do |e|\n        # Remove the\
    \ element if it is a single uppercase letter\n        e.gsub!(/[A-Z]/, '')\n \
    \       # Remove the element if it is a single lowercase letter\n        e.gsub!(/[a-z]/,\
    \ '')\n        if e == ''\n            true\n        else\n            e.split(//).inject(-1)\
    \ { |x, e| x.to_i + e.to_i.abs }\n        end\n    end\n    extensions_sorted.delete_if\
    \ {|x| x == ''}\n    extensions_sorted.sort_by { |x| x.length }.reverse.first\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis is an excellent solution! Thank you!\n<|/\
    \ c |>\n<| c |>\nI added a line to remove empty strings and to sort the extensions\
    \ by length. Does it need any editing?\n<|/ c |>\n<| c |>\nYes, it does. I added\
    \ it.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  extensions_strength = {}\n  extensions.each\
    \ do |extension|\n    if extension.downcase == extension\n      extensions_strength[extension]\
    \ = -1\n    else\n      extensions_strength[extension] = extension.count('a')\
    \ - extension.count('e') - extension.count('i') - extension.count('o') - extension.count('u')\n\
    \    end\n  end\n  \n  sorted_extensions_strength = extensions_strength.sort_by\
    \ { |k, v| v }\n  sorted_extensions_strength.last\nend\n</code>\nThis code will\
    \ first find all the extensions that each class in the argument has and then for\
    \ each class it loops over all the extensions and calculates the strongest extension\
    \ from those.\nThen it uses Ruby's sort_by method to sort the extensions based\
    \ on their strength and it returns the last extension from the array.\n<|/ a tags=ruby\
    \ dscore=2 |>\n<| a dscore=1 |>\nTry this simple solution with regex:\n<code>",
  "\textensions.sort.reverse.find { |e| e.include?(class_name) }\nend", "  extension_count\
    \ = {}\n  \n  max_strength = -1\n  max_extension = ''\n  \n  for extension in\
    \ extensions \n    i = extension.index(class_name)\n    \n    if (i < 0) \n  \
    \    next\n    \n    extension_name = extension.sub!('', '')\n    \n    strength\
    \ = (class_name[1..i].count(' ') - class_name[1..i].count(''))/2.0\n    \n   \
    \ extension_count[extension_name] = strength\n    \n    if (strength > max_strength)\
    \ \n      max_strength = strength\n      max_extension = extension_name\n  end\n\
    \  \n  strongest_extension = max_extension\n  \n  if (extension_count.has_key?(strongest_extension))\
    \ \n    extension_count.each do |key, value|\n      if (value > 0) \n        extension_count[key]\
    \ = max_strength\n      end\n    end\n  end\n  \n  return strongest_extension\n\
    end", "  extensions.each {|e| return e unless e.include? class_name}\n  extensions.reverse.each\
    \ {|e| return e unless e.include? class_name.downcase}\nend", "  # BEGIN PSEUDOCODE\
    \ HERE\n  # Write your code here.\n  # END PSEUDOCODE\nend", "    \nend\n</cell>\n\
    <text>\nSolution\nHere are some examples of implementing your solution:", "\t\
    max_strength = -1\n\tmax_extension_name = ''\n\textensions.each do |x|\n\t\tx_strength\
    \ = x.split('').map(&:upcase).count(\"A\") - x.split('').map(&:upcase).count(\"\
    B\")\n\t\tif x_strength > max_strength\n\t\t\tmax_strength = x_strength\n\t\t\t\
    max_extension_name = x\n\t\tend\n\tend\n\treturn \"#{class_name}.#{max_extension_name}\"\
    \nend", "  max_score = -1\n  max_extension = ''", '  extension_strengths = []',
  "  extensions = extensions.sort\n  strongest_extension = nil\n  extensions.each\
    \ do |extension|\n    next_upper = extension.slice(0,1).toUpperCase\n    next_lower\
    \ = extension.slice(0,1).toLowerCase\n    if next_upper.eql?(class_name.slice(0,next_upper.length).downcase)\
    \ \n      strongest_extension = extension\n      break\n    elsif next_lower.eql?(class_name.slice(0,next_lower.length).downcase)\n\
    \      strongest_extension = extension\n      break\n    end\n  end\n  strongest_extension\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
