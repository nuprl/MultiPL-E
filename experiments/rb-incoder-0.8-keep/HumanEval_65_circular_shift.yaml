name: HumanEval_65_circular_shift
language: rb
prompt: "# Circular shift the digits of the integer x, shift the digits right by shift\n\
  # and return the result as a string.\n# If shift > number of digits, return digits\
  \ reversed.\n# >>> circular_shift(12, 1)\n# \"21\"\n# >>> circular_shift(12, 2)\n\
  # \"12\"\ndef circular_shift(x, shift)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n\
  \    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100,\
  \ 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\"\
  , candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"\
  11\", candidate.call(11, 101))\n  end\nend\n"
completions: ["  n = x.to_s.length\n  s = \"0\" * (shift + 1) # Preserve leading zeros\n\
    \  s.reverse! # Reverse order\n  while n > shift do\n    s = s.insert(0, x.to_s[shift])\n\
    \    shift -= 1\n    n -= 1\n  end\n  s\nend", "  # return x if shift <= 0 else\
    \ circular_shift(x % 10, shift - 1) * 10 + x % 10\n  x = x % 10\n  if shift >\
    \ x\n    shift = shift - x\n    x = 10\n  end\n  shift = shift - x\n  x = 10\n\
    \  return x if shift <= 0 else circular_shift(x % 10, shift - 1) * 10 + x % 10\n\
    end", "  if shift < 0\n    shift = (-shift).abs\n  end\n  \n  digits = x.to_s.split(\"\
    \")\n  \n  shift = shift % digits.length\n  \n  digits.reverse!\n  \n  digits.concat(digits.shift(shift).reverse)\n\
    \  \n  return digits.join(\"\")\nend\n</code>\n<|/ a dscore=1 tags=ruby,modulo,math,algorithm\
    \ |>\n<| c |>\nIt should be pointed out that this method does suffer from the\
    \ same problems that Oscar's solutions do - it will sometimes return a large number\
    \ of digits than are required. For example, when `x.to_s == 100` it returns `\"\
    11\"` rather than `\"1000\"`.\n<|/ c |>\n<| c |>\nTrue, and that's why I said\
    \ that Oscar's method would \"suffer\" from the same problems. I see your point\
    \ though; I added a method which doesn't suffer from that problem.\n<|/ c |>\n\
    <| c |>\nThanks for your help guys. I appreciate your time :) My first questions\
    \ was really bad, I'm new to the site so I didn't know this was a thing.\n<|/\
    \ c |>\n<| c |>\n: No worries! It's a common problem when you don't know your\
    \ way around Stack Overflow or even basic programming terminology. It's important\
    \ to make sure that you research problems before you start solving them :)\n<|/\
    \ c |>\n<| a |>\n<code>", "  return x.modulo(10 ** shift)\nend", "  x = x.to_s\n\
    \  shift = shift || 0\n  digits = x.reverse[shift.to_i]\n  digits[0...shift.to_i].concat\
    \ digits[shift.to_i..-1].reverse\nend", "    digits = x.to_s(10).reverse\n   \
    \ if shift > digits.length\n        shift -= digits.length\n        digits.reverse!\n\
    \    end\n    digits.reverse!\n    digits.reverse! shift\n    return digits.reverse\n\
    end", "  if shift > length(x) then\n    return x\n  end", "  result = \"\"\n \
    \ digit_length = x.to_s.length\n  digits = x.to_s\n  \n  while digits.size > shift\n\
    \    digits = digits.substring (0, digits.size - 1)\n    result += digits\n  end",
  "  x.to_s.split(\"\").reverse.zip(x.to_s.split(\"\")).map { |i, j| i.to_i + j.to_i\
    \ }.rotate(shift).map(&:to_s).join\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Please don't post only code as answer, but also provide an explanation what your\
    \ code does and how it solves the problem of the question. Answers with an explanation\
    \ are usually more helpful and of better quality, and are more likely to attract\
    \ upvotes.\n<|/ c |>\n<| c |>\nThanks for the suggestion.\n<|/ c |>\n<| a dscore=1\
    \ |>\nIn rails you can get it this way:\n<code>", "  num = \"\"\n  while x > 0\n\
    \    digit = x % 10\n    x = x / 10\n    if x >= shift\n      digit += 1\n   \
    \   x = x - (digit * shift)\n    num = num.to_s + digit.to_s\n  end\n  return\
    \ num\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby dscore=2 |>\n<code>",
  "  return x.digits.reverse.shift(shift).reverse\nend", "  result = \"\"\n  if shift\
    \ < 0\n    raise ArgumentError, \"shift must be non-negative\"\n  elsif shift\
    \ > Float::INFINITY\n    shift = -shift\n  elsif shift < x.length\n    result\
    \ = x.slice(-shift)\n  elsif x.length > shift\n    x = x.slice(x.length - shift)\n\
    \    result = \"0\" + x.to_s\n  end\n  return result\nend", "  if x >= (10**shift)\n\
    \    shift = -(10**shift)\n  x = x.to_s\n  digits = x.to_s.split(//)\n  if shift\
    \ > digits.length\n    digits = digits.reverse\n  new_digits = digits.reverse.concat(digits.reverse).reverse\n\
    \  new_digits = digits.reverse.concat(new_digits)\n  x = new_digits.join(\"\"\
    )\n  x = x.to_i\n  x = x.to_s\n  return x.to_i\nend", "  return x if shift < 0\
    \ \n  result = x.to_s.gsub(/.(?=\\d)/, '#').gsub(/(?<=\\d)(?=#)/, '').to_i\n \
    \ result = (result >> shift) | (result << (32 - shift))\n  return result.to_s(10)\n\
    end\n</code>\n<|/ a tags=ruby-on-rails,ruby,activeadmin dscore=3 |>\n<| a |>\n\
    A shorter variant of's answer:\n<code>", "  x = x.to_s\n  digits = x.reverse\n\
    \  digits = digits[shift...-1] + digits.slice(0, shift)\n  digits = digits.reverse\n\
    \  x = x.dup\n  x += digits\n  x = x.to_s\nend", "    l = x.to_s.length\n    str\
    \ = x.to_s\n    (str << shift).slice!(0, l)\n    str = str.to_s\n    return str\n\
    end", "  digits = x.to_s.chars\n  shifted_digits = \"\"\n  shift_digits = shift\
    \ - 1\n  while shift_digits >= 0\n    digits[shift_digits] = \"1\"\n    shift_digits\
    \ -= 1\n    shifted_digits << shift_digits\n  end\n  digits[shift_digits] = \"\
    0\"\n  shifted_digits.reverse!\n  digits.join(\"\")\nend\n</code>\n<|/ a tags=ruby,string,algorithm\
    \ |>\n<| a |>\nHere is a recursive solution which converts binary to decimal.\n\
    <code>", "  shifted = x.abs\n  shifted.times { |i| shifted.rotate!(-shift) }\n\
    \  shifted.to_s(10)\nend", "  x = x.to_s\n  if shift > x.length\n    shift -=\
    \ x.length\n    x.slice!(end)\n  elsif shift < 0\n    shift += x.length\n    x.slice!(0...-shift)\n\
    \  else\n    x.slice!(0...shift)\n  end\n  x\nend", "  digits = x.to_s.chars.reverse\n\
    \  n = (digits * shift).to_i\n  n % 10 == 0 ? n : circular_shift(n % 10, shift\
    \ + 1)\nend", "  n = x.to_s.length - shift\n  return x.to_s.chars.reverse[n, shift,\
    \ n].join\nend\n</code>\nCircular shift in Ruby\n<|/ a dscore=3 tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThis works for me with a little modification. ", "  x = x.to_i\n\
    \  shift = shift.to_i\n  if x > shift.abs then\n    raise \"shift must be <= #{x.abs}\"\
    \n  end", "    if shift > log10(x.to_s).ceil\n        shift %= log10(x.to_s).ceil\n\
    \    else\n        shift %= log10(x.to_s)\n    end\n    x_digits = x.to_s.reverse\n\
    \    shift = x_digits.length - shift\n    x.to_s.reverse!\n    x.to_s.insert(0,\
    \ x_digits[shift..-1].join)\nend", "  shift %= x.length\n  digits = x.to_s.reverse\n\
    \  digits.reverse! if shift > 0\n  digits.reverse! while shift > digits.length\n\
    \  digits.reverse! if shift < digits.length\n  digits.reverse!\n  digits.reverse!\
    \ if shift > 0\n  digits.reverse! while shift < digits.length\n  digits.reverse!\
    \ if shift < digits.length\n  digits.reverse!\n  return digits.join\nend", " \
    \ return x.to_s.reverse.slice!(0, shift)\nend", "  return x.divmod(10**shift)[1][0].insert(0,\
    \ x.divmod(10**shift)[0][0])\nend", "    digits = x.digits.reverse\n    shift\
    \ %= digits.count\n    if shift > 0\n        digits.reverse! { |i| i >= shift\
    \ }\n    else \n        digits.reverse! { |i| i < shift }\n    end\n    digits.join\n\
    end\n</code>\n<|/ a dscore=4 tags=ruby,algorithm |>\n<| c |>\nYou don't need the\
    \ array at all here, you can just do `x.digits.reverse!(&:succ)` since `reverse!`\
    \ returns the receiver.\n<|/ c |>\n<| c |>\nAh, I thought that `reverse!` returned\
    \ the object itself. Good catch.\n<|/ c |>\n<| a tags=ruby,algorithm |>\nHere's\
    \ one way to do it using Array#inject:\n<code>", "  digits = \"\"\n  digits_length\
    \ = x.length\n  shift_length = digits_length - shift\n  \n  digits = x.to_s.reverse[shift_length..-1]\n\
    \  return digits\nend", "  if shift > x.to_s.length\n    shift.times { x << 1\
    \ }\n    x.to_s\n  else\n    x.to_s.chars.reverse.chars.take(shift).join\n  end\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI'm guessing that the OP wanted something\
    \ along the lines of `puts \"#{circular_shift(11, 5)}\"`\n<|/ c |>\n<| c |>\n\
    You're right, thanks. I just updated the answer.\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>", "  x = x.to_s\n  return x.slice!(-shift, x.length) + x.slice!(x.length\
    \ - shift)\nend", "  if shift > log10(x)\n    # Shift too large\n    shift_digits\
    \    = log10(x)\n    shift_remainder = x % shift_digits\n  else\n    # Shift too\
    \ small\n    shift_digits = shift\n    shift_remainder = x - (x % shift_digits)\n\
    \  end\n  \n  if shift_digits == 0\n    return x.to_s\n  else\n    return ((shift_digits\
    \ + shift_remainder).to_s.reverse).insert(0, shift_digits)\n  end\nend", "   \
    \ digits = \"\"\n    shift = shift % x.length\n    lenx = x.length\n    while\
    \ shift > 0\n        digits = digits[0..lenx - shift] + '0'\n        shift -=\
    \ 1\n    return digits[0..lenx - shift]\nend", "  if x < 0\n    raise(ArgumentError,\
    \ \"shift must be positive\")\n  else\n    if shift == 0\n      x\n    else\n\
    \      digits = x.to_s.reverse[shift..0]\n      x.to_s.reverse[0..shift] = digits\n\
    \      x.to_s\n    end\n  end\nend\n</cell>\n<code language=julia-0.5>", "  shifts\
    \ = (x.to_s.size - shift)...\n  return x.to_s(10, shifts)\nend", "  x = x.to_s\
    \ # cast to string for circular_shift\n  \n  if shift == 0\n    return x\n  \n\
    \  digits, base = (0...x.size).map { |i| (x.chars[i] * shift).to_i }\n  \n  result\
    \ = \"\"\n  \n  digits.reverse.each_with_index do |d, i|\n    result << (d >=\
    \ base ? x.chars[digits[i]] : x.chars[digits[i] + base])\n  end\n  \n  return\
    \ result\nend\n</code>\nExample usage:\n<code>\nputs circular_shift(12, 1)", " \
    \ x\n  if x != 0\n    result = ''\n    n = shift + 1\n    digits = x.to_s.length\
    \ - 1\n    while (digits = n - (n % digits), digits.zero?)\n      result << (x.to_s[digits])\n\
    \      x = x / 10\n    end\n    result\n  end\nend", "  string = \"\"\n  remainder\
    \ = x % shift\n  while (remainder != 0)\n    string = (x * 10) + remainder\n \
    \   remainder = (string % 10) % shift\n    string = (string * 10) % shift\n  return\
    \ string\nend", "  if x > 10\n    puts \"Please enter an integer\"\n    return\
    \ nil\n  elsif shift > length(x)\n    puts \"Please enter an integer greater than\
    \ 1\"\n    return nil\n  end\n  digits = reverse(x)\n  result = \"\"\n  i = 0\n\
    \  while i <= shift\n    result << digits[i]\n    i += 1\n  end\n  result << digits[shift]\n\
    \  result\nend", "  return x.zero? ? 0 : (x + x.modulo(shift)).to_s\nend", " \
    \   if shift == 0\n        return x\n    digits = tostr(x)\n    digits = digits[0\
    \ ... -(digits.size % shift)]\n    return digits * shift\nend", "  if shift >\
    \ x.to_s.length\n    x.to_s\n  elsif shift <= x.to_s.length\n    x.to_s[0...(shift...-1)]\
    \ + x.to_s[shift...-1]\n  else\n    x.to_s[0...(shift...-1)]\n  end\nend", " \
    \ digits = x.digits.reverse\n  digits.each_index do |i|\n    digits[i] = digits[i]\
    \ - digits[i - shift]\n  end\n  digits.join\nend", "  digits = x.digits.reverse\n\
    \  shift < 0 ? digits(0).reverse + digits(shift) : digits(shift).reverse + digits(0).reverse\n\
    end", "  len = Integer(x).length\n  shifted_len = Integer(shift).length\n  return\
    \ Integer(x).to_s.chars.chars.reverse.insert(shifted_len, len).join\nend", " \
    \ return x.slice(-shift)\nend", "  if shift > x.length\n    x.split(\"\")\n  \
    \  shift -= 1\n  x.reverse!\n  x.split(\"\").each_with_index do |digit, i|\n \
    \   x[i] = digit[shift..-1] + digit[0..shift]\n  end\n  x.join(\"\")\nend", " \
    \ return x.to_s.reverse.gsub(/(.)(\\d*?\\d)(?=\\d)(?!\\d)|.(?<=\\d)(.)\\d+(?=\\\
    d)|.(\\d+?)(?=\\d)|(\\d+)(?=\\d$)/, '\\1\\2\\3'.ljust(shift, '0')).reverse\nend",
  "  return x.modulo(10**shift).div(10**shift)\nend\n</cell>\n<cell>\nputs circular_shift(123,3)\n\
    </cell>\n<text>\nModular arithmetic\nA modular arithmetic algorithm (MODULAR ARITHMETIC)\
    \ is used to perform a circular shift on integers that represent rational numbers.\
    \  For a given modulus, d, there exists a number n such that n\xD7d divides n\xD7\
    m if m divides n\xD7d exactly.  The MODULAR ARITHMETIC algorithm shifts integers\
    \ a right until they reach m and then the result is returned.  That is why it\
    \ is important to use modulo instead of integer division.", "  len = (x.length\
    \ / 2).ceil\n  str = \"\"\n  for i in 0...len\n    str = str + x[len-i-1]\n  end\n\
    \  str = str + x[len]\n  return str\nend", "  if x < 0\n    \"Invalid shift.\"\
    \n  elsif shift == 0\n    return 0\n  elsif shift == 1\n    return x\n  elsif\
    \ x < 10\n    return \"%i\" % x\n  elsif x < 100\n    return \"%02i\" % x\n  elsif\
    \ x < 1000\n    return \"%.4i\" % x\n  elsif x < 10000\n    return \"%3.3i\" %\
    \ x\n  elsif x < 100000\n    return \"%4.4i\" % x\n  elsif x < 1000000\n    return\
    \ \"%5.5i\" % x\n  elsif x < 10000000 \n    return \"%6.6i\" % x\n  elsif x <\
    \ 100000000\n    return \"%7.7i\" % x\n  elsif x < 1000000000\n    return \"%8.8i\"\
    \ % x\n  elsif x < 10000000000\n    return \"%9.9i\" % x\n  elsif x < 100000000000\n\
    \    return \"%10.10i\" % x\n  elsif x < 1000000000000\n    return \"%11.11i\"\
    \ % x\n  elsif x < 10000000000000\n    return \"%12.12i\" % x\n  elsif x < 100000000000000\n\
    \    return \"%13.13i\" % x\n  elsif x < 1000000000000000\n    return \"%14.14i\"\
    \ % x\n  elsif x < 10000000000000000\n    return \"%15.15i\" % x\n  elsif x <\
    \ 100000000000000000\n    return \"%16.16i\" % x\n  elsif x < 1000000000000000000\n\
    \    return \"%17.17i\" % x\n  else\n    \"Invalid shift.\"\n  end\nend\n</code>\n\
    <|/ a dscore=4 tags=ruby,python,perl,algorithm,math |>\n<| c |>\nWhat do you mean\
    \ by \"circular shift\"?\n<|/ c |>\n<| c |>\nIn other words, `123456` becomes\
    \ `654321`.\n<|/ c |>\n<| c |>\nThat is what I understood of the term, too. But,\
    \ it is not what the OP asked for.\n<|/ c |>\n<| c |>\n: It would be nice if the\
    \ OP would confirm this.\n<|/ c |>\n<| c |>\nI have no idea what OP means by \"\
    circular shift\" but I suspect OP wants to get the largest string that has as\
    \ many digits as `x`, with the least digits starting from the first digit.\n<|/\
    \ c |>\n<| a tags=ruby,python,perl,algorithm,math |>\nIn Perl, ", "  x = x.to_s(2)\n\
    \  shift = shift.to_s(2)\n  if x.size < shift\n    x = x.reverse\n  end\n  return\
    \ x.slice(-shift)\nend\n</pre>", "  return x.to_s.reverse.slice(shift, x.to_s.length\
    \ - shift)\nend", "  return x.modulo(10**shift).to_s.reverse\nend", "  if shift\
    \ == 0\n    return x\n  else\n    # Circular shift algorithm for shifting digits\
    \ left and right.\n    # Shift digits right until right most digit\n    # is less\
    \ than shift. Shift digits left until left\n    # most digit is greater than or\
    \ equal to shift.\n    # If left most digit is greater than or equal to\n    #\
    \ shift, do nothing. Else shift left and right digit\n    # to left most digit.\n\
    \    while x > 0\n      x = (x % 10) + x % 10\n      x /= 10\n      x += 1\n \
    \   end\n    while x < 0\n      x = (x % 10) - x % 10\n      x /= 10\n      x\
    \ -= 1\n    end\n    x\n  end\nend", "  result = ''\n  remaining = x\n  while\
    \ remaining > 0 do\n    result << (remaining % 10 + shift)\n    remaining = remaining\
    \ / 10\n  end\n  result.reverse\nend", "  n = x.length\n  if n >= shift\n    return\
    \ x.sub(1, 1)\n  else\n    return x.sub(n, shift)\nend", "  # Circularly shift\
    \ a number x a fixed number of places to the right (>=0).\n  # x must be an integer.\n\
    \  # shift must be an integer.\n  # >>> circular_shift(12, 0)\n  # 12\n  # >>>\
    \ circular_shift(12, 1)\n  # \"21\"\n  # >>> circular_shift(12, 2)\n  # \"12\"\
    \n  return x.to_s(10).reverse.gsub(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/,'\\1'.rjust(shift,'0'))\n\
    end", "  x = x.to_s\n  shift = shift.to_i\n  return x.reverse * shift % x.size\n\
    end", "  if shift > x.digits.length()\n    digits = x.digits.reverse\n  else\n\
    \    digits = x.digits\n  end\n  shifted_digits = digits[0..(digits.length - shift)-1]\n\
    \  x.digits = digits[0..(digits.length - shift)-1]\n  x.digits.concat shifted_digits\n\
    \  return x\nend", "  x = x.to_s # convert to string for string methods\n  if\
    \ shift > x.length\n    shift.downto(0) do |i|\n      x.insert(i, x[i])\n    end\n\
    \  else\n    x.slice!(0, shift) rescue x # slice string\n    x.slice!(0, x.length\
    \ - shift) rescue x # slice string\n  end\n  return x\nend", "  xstr = \"\" +\
    \ x\n  shift = shift % x.length\n  if shift > 0\n    xstr = xstr.reverse\n  end\n\
    \  return xstr[0, shift]\nend", "  # We need to \"reverse\" the shift.\n  if shift\
    \ > x.length\n    shift = x.length - shift\n  end", "    if shift > 32 or shift\
    \ < 0\n        return -1\n    digits = \"0123456789\"\n    return digits[((digits.index(digits.charAt(x\
    \ % 10)) + shift) % len(digits))]\nend", "  # >>> circular_shift(12, 0)\n  # 12\n\
    \  # >>> circular_shift(12, 1)\n  # 11\n  # >>> circular_shift(12, 2)\n  # 10\n\
    \  # >>> circular_shift(12, 3)\n  # 9\n  # >>> circular_shift(12, 4)\n  # 8\n\
    \  # >>> circular_shift(12, 5)\n  # 7\n  # >>> circular_shift(12, 6)\n  # 6\n\
    \  # >>> circular_shift(12, 7)\n  # 5\n  # >>> circular_shift(12, 8)\n  # 4\n\
    \  # >>> circular_shift(12, 9)\n  # 3\n  lenx = length(x)\n  shiftstr = to_s(shift)\n\
    \  digits = to_s(lenx)\n  if shiftstr.length <= digits.length\n    # digits.length\
    \ < shiftstr.length\n    # return digits reversed\n    digits = digits.reverse\n\
    \  end\n  start = digits.index(x)\n  digits[start, ...] = digits[start - 1, ...]\n\
    \  digits[start - 1, ...] = digits[start, ...]\n  digits[start, 0] = 0\n  digits[start,\
    \ ...] = digits[start - 1, ...]\n  digits[start - 1, ...] = digits[start, ...]\n\
    \  digits[start, 0] = lenx - 1\n  digits[start, ...] = digits[start - 1, ...]\n\
    \  digits[start - 1, ...] = digits[start, ...]\n  digits[start, 0] = lenx - 2\n\
    \  digits[start, ...] = digits[start - 1, ...]\n  digits[start - 1, ...] = digits[start,\
    \ ...]\n  digits[start, 0] = lenx - 3\n  digits[start, ...] = digits[start - 1,\
    \ ...]\n  digits[start - 1, ...] = digits[start, ...]\n  digits[start, 0] = lenx\
    \ - 4\n  digits[start, ...] = digits[start - 1, ...]\n  digits[start - 1, ...]\
    \ = digits[start, ...]\n  digits[start, 0] = lenx - 5\n  digits[start, ...] =\
    \ digits[start - 1, ...]\n  digits[start - 1, ...] = digits[start, ...]\n  digits[start,\
    \ 0] = lenx - 6\n  digits[start, ...] = digits[start - 1, ...]\n  digits[start\
    \ - 1, ...] = digits[start, ...]\n  digits[start, 0] = lenx - 7\n  digits[start,\
    \ ...] = digits[start - 1, ...]\n  digits[start - 1, ...] = digits[start, ...]\n\
    \  digits[start, 0] = lenx - 8\n  digits[start, ...] = digits[start - 1, ...]\n\
    \  digits[start - 1, ...] = digits[start, ...]\n  digits[start, 0] = ", "  result\
    \ = ''\n  while x > 0\n    if shift > 0\n      result = result << shift\n    \
    \  shift -= 1\n    end\n    x = x >> 1\n    result = result + (x & 1)\n  end\n\
    \  if shift > 0 then\n    result << (shift - 1)\n  end\n  return result\nend",
  "  x = x.to_s(10)\n  shift = shift % x.length\n  \n  if x.length <= shift\n    x\n\
    \  else\n    x.slice!(0, shift)\n    x.reverse!\n    x << x\n  end\nend", "  x.slice!(0,\
    \ shift)\n  x[-shift] = x[-shift].to_i\n  x.reverse! if shift < x.length\n  x\n\
    end", "  x.slice!(0, shift)\n  x.slice!(-shift, x.length)\n  return x.reverse\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby,algorithm,ruby-on-rails,arrays,sorting\
    \ |>\n<| a tags=ruby,algorithm,ruby-on-rails,arrays,sorting |>\n<code>", "  result\
    \ = \"\"\n  \n  if shift > x.length\n    shift = x.length\n    \n    result.concat(x.slice(-shift))\n\
    \    \n    result.concat(x.slice(0, shift))\n  else\n    result.concat(x.slice(0,\
    \ shift))\n    \n    result.concat(x.slice(shift))\n    \n  return result\nend",
  "  if shift > log(x, 10)\n    return x * circular_shift(shift(x), shift)\n  end\n\
    \  return x.to_s.chars.reverse.gsub(\"(#{shift})\", &:reverse).reverse\nend",
  "  return x.to_s.length <= shift ? x.to_s[0...shift-1] + x.to_s[shift...-1] : x.to_s[0...shift]\
    \ + x.to_s[shift+1..-1].reverse\nend", "  x = x.to_s\n  shift = shift % x.length\n\
    \  x.chars.zip(x.chars.drop(shift)).map { |a,b| a.succ << shift | b }.join(\"\"\
    )\nend", "  return x.modulo(10**shift).to_s + x.modulo(10**shift + 1).to_s\nend",
  "  return x.to_s.reverse.rjust(shift).reverse\nend", "  str = x.to_s.reverse\n \
    \ n.times{str = str.slice(1) + str.slice(0,1)}\n  return x.to_i(36) % 36 + str\n\
    end", "  if shift < 0\n    raise \"shift must be a non-negative integer\"\n  str\
    \ = \"\"\n  while x > 0\n    x = x >> 1\n    str = str << 1\n  end\n  str = str\
    \ + str\n  while str.length < shift\n    str = str + str\n  end\n  return str\n\
    end", "  x.slice!(0, shift)\n  x.slice!(-shift, shift)\n  x\nend", "  if shift\
    \ > x.length\n    x.reverse!\n  else\n    digits = Array.new\n    digits = digits[0...shift-1]\
    \ + x.to_a.reverse[shift..-1] + digits[0...shift]\n  end\n  return digits.join('')\n\
    end", "  result = \"\"\n  digits = x.to_s.length\n  while shift > digits do\n\
    \    digits = digits - 1\n    shift = shift - 1\n  end\n  digits = digits.to_s\n\
    \  shift = shift.to_s\n  for i in 0...digits do\n    if i.to_s == shift then\n\
    \      result = result + i\n    else\n      result = result + i.to_s\n    end\n\
    \  end\n  return result\nend", "  x = x.to_s unless x.is_a?(Integer)\n  if shift\
    \ > x.length\n    x.length - shift\n  else\n    \"\" + x.slice(-shift)\n  end\n\
    end", "    digits =  Integer(x)\n    digits = digits.digits(0)\n    digits = digits[shift..-shift]\n\
    \    return digits.reverse.join\nend", "\tdigits = x.to_s.reverse\n\tif shift\
    \ > digits.length\n\t\tshift = digits.length\n\tdigits = digits[0..(shift..digits.length-1)].join\n\
    \tdigits\nend", "  x.to_s.split(//).reverse.inject(\"\") do |result, digit|\n\
    \    digit.blank? ? result : (result << shift, result << digit)\n  end\nend",
  "  str = x.to_s\n  digits = str.each_char.to_a\n  digits.reverse!\n  digits.reverse_each\n\
    \  \n  if shift > 0\n    digits.shift(shift)\n    digits.reverse!\n  end\n  \n\
    \  return digits.join('')\nend", "  n = x.to_s.length\n  \n  if shift > n\n  \
    \  x.to_s.reverse!\n    x.to_s << shift\n  else\n    x.to_s << shift\n    x.to_s.reverse!\n\
    \  end\n  \n  x\nend", "    sign = (x < 0)\n    x = abs(x)\n    digits = []\n\
    \    shift = shift % len(x)\n    # for i in range(0, len(x)):\n    while x !=\
    \ 0:\n        digits.append(int(x / 10))\n        x %= 10\n    digits.reverse()\n\
    \    for i in range(shift, len(digits)):\n        digits[i] = 0\n    digits[shift]\
    \ = sign\n    return ''.join(map(str, digits))", "  # Shift by 0 should return\
    \ the original input if x==0, and return a\n  # string of length 1 if the shift\
    \ is a negative integer.\n  x + (shift<0)\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThis works just fine, but I feel like this is a much more straight\
    \ forward way of doing this with just built-in ruby methods (and no additional\
    \ gems). I'm new to ruby and thought it would be great to have a simple solution\
    \ for this. Thanks!\n<|/ c |>\n<| c |>\nIt can be solved without the `circular_shift`\
    \ method in just one line, but I will include it.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nYou can achieve that with a simple String#gsub:\n<code>\n'123'.gsub(/\\\
    d+/) { |n| n[1..-1] }", "  digits = x.digits.reverse\n  digits.unshift(*digits.take(shift))\n\
    \  digits.join\nend", "  return x.to_s.length + (shift.to_s - x.to_s.length +\
    \ shift.to_s % x.to_s).to_s.reverse\nend", "  return x.to_s.reverse if shift >\
    \ x.to_s.length \n  x.to_s.insert(shift, x.to_s[-shift])\nend\n</code>\nFor a\
    \ demonstration, see Circular shifting numbers, i.e. shifting numbers by a power\
    \ of 10\n<|/ a |>\n<| a tags=math,ruby,ruby-on-rails,algorithm |>\nThis seems\
    \ like it could be done with a simple regex:\n<code>\n/(\\d)(?=(\\d{3})+(?!\\\
    d))/\n</code>\nAnd then some string manipulation to do the math.  It would work\
    \ by putting the first digit from the string on both sides of the string being\
    \ replaced, and then splitting the string into two parts separated by commas.\
    \  Then it would be a simple matter of adding all the digits in one part, subtracting\
    \ the other part.\n<|/ a dscore=2 |>\n<| c |>\n`(\\d)(?=(\\d{3})+(?!\\d))` doesn't\
    \ work for `12` it gives `21` instead of `12`\n<|/ c |>\n<| c |>\nI think this\
    \ would work: `/(\\d)(?=(\\d{3})(?!\\d))/` But it would be a pain to have to do\
    \ the math for each digit. Also I would have to reformat the final answer if it\
    \ was a repeating pattern.\n<|/ c |>\n<| a tags=math,ruby,ruby-on-rails,algorithm\
    \ |>\nHere's a function that will work with arbitrary bases:\n<code>", "  shift\
    \ = shift % x.length\n  return x[x.length - shift * -1]\nend", "  if shift ==\
    \ 0 then return x\n  return circular_shift(x % 10 + 10 * floor(x / 10), shift\
    \ - 1) \nend", "  shift %= length(x)\n  digits = x.to_s.reverse[1..-1].split('')\n\
    \  digits.rotate!(-shift)\n  digits.reverse!\n  return digits.join('')\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThank you for the answer. I don't think this is what\
    \ OP wanted but it is a good alternative to what I had in mind when I wrote my\
    \ answer.\n<|/ c |>\n<| c |>\nThat's perfect! I like that it's just one line and\
    \ not a bunch of nested loops or anything like that.\n<|/ c |>\n<| c |>\nYou're\
    \ welcome. I added an alternative which doesn't use `reverse!` because I don't\
    \ think it's really necessary (but please let me know if I'm wrong).\n<|/ c |>\n\
    <| a |>\nThis could be a one-line method if you wanted to do it with recursion:\n\
    <code>", "  x.divmod(shift)[1]\nend", "  n = 0\n  digits = to_s(x)\n  \n  digits.each_index\
    \ do |i|\n    n = n * 10 + digits[i]\n  end\n  \n  digits.length.times { digits.rotate!(shift)\
    \ }\n  \n  digits.join\nend", "  return x.to_s.reverse.substr(0, shift) + x.to_s.reverse.substr(shift)\n\
    end", "  digits = x.to_s.reverse\n  digits = digits[0...shift]\n  digits = digits[1...(digits.length\
    \ - 1)]\n  digits.reverse!\n  return digits\nend", "  \n  x.gsub!(/(\\d)(\\d{#{shift}})/)\
    \ do\n    mc = Regexp.last_match\n    str = mc.pre_match.to_i + shift\n    shift\n\
    \  end\nend\n</code></pre>\n  </article>\n</div>", "  x = ''\n  if shift == 0\n\
    \    return x\n  i = shift\n  while i > 0 do\n    x = '%s%s' % (x, x[i])\n   \
    \ i -= 1\n  end\n  return x\nend", "  shift %= x.length\n  digits = []\n  loop\
    \ do\n    digit = x.slice!(-shift, shift)\n    digits << digit\n    shift += 1\
    \ unless shift == x.length\n  end\n  digits.reverse\nend\n</code>\n<|/ a tags=ruby,algorithm\
    \ |>\n<| c |>\nI'm pretty sure that your solution is the right one. `slice!` is\
    \ not a method, it is an operator and can be chained like this: `x.slice!(..).slice!(-shift,\
    \ shift)`.\n<|/ c |>\n<| c |>\nThat is true, however I think it might be better\
    \ to do `x.slice!(-shift, shift)` because in that way you are working in a copy\
    \ of the array, making the operation `O(1)` instead of `O(n)`.\n<|/ c |>\n<| c\
    \ |>\n: Thanks for your answer. I tried your code, however it won't work. Could\
    \ you please try my code and see what's wrong with it?\n<|/ c |>\n<| c |>\n`slice!`\
    \ doesn't work as a method because it's an operator and should be chained\n<|/\
    \ c |>\n<| c |>\n: Yes but I don't think it does what it's intended to do. slice!(-shift,\
    \ shift) removes the rightmost shift (the last digit) and shifts the entire array\
    \ to the left by shift.\n<|/ c |>\n<| a tags=ruby,algorithm dscore=1 |>\nHere's\
    \ an alternate approach which does not mutate the original string:\n<code>", " \
    \   digits = Array(x)\n    reverse_digits = Array(x)", "    if shift > length(x)\n\
    \        return reverse(x)\n    if shift == 0\n        return x\n    digits =\
    \ String(x)\n    digits = digits[0..length(x)-shift].chars\n    digits[0..length(x)-shift]\
    \ = reverse(digits[0..length(x)-shift])\n    digits[0..length(x)-shift] = digits[0..length(x)-shift].chars\n\
    \    if shift > length(x)\n        return digits[0..length(x)-shift]\n    digits[0..length(x)-shift-1]\
    \ = digits[0..length(x)-shift-1].chars\n    digits[0..length(x)-shift] = reverse(digits[0..length(x)-shift])\n\
    \    digits[0..length(x)-shift-1] = digits[0..length(x)-shift-1].chars\n    return\
    \ String.new(digits.join)\nend", "    x = x.to_s\n    len = x.length\n    if shift\
    \ >= len\n        x\n    else\n        x.split(\"\").reverse.map {|y| x.rjust(len,\
    \ y) }.join\n    end\nend", "  s = x.to_s\n  shifted_digits = s[0...shift].chars.reverse\n\
    \  digits = s[shift..-1]\n  return digits.reverse + shifted_digits\nend", "  x.to_s.split(\"\
    \").reverse[shift.to_i]\nend", "  x.to_s.reverse.split(\"\").collect{|digit| (digit=digit.to_i+shift).to_s(10)}.reverse.join\n\
    end\n</code>\n<|/ a dscore=3 tags=ruby,sorting,arrays |>\n<| c |>\nNice answer!\
    \ I made a slight change to your code `x.to_s.reverse.split(\"\").collect{|digit|\
    \ digit.to_i + shift}.to_s.reverse`, which allows us to avoid creating a string\
    \ that isn't actually required. Thanks!\n<|/ c |>\n<| c |>\nThis breaks down when\
    \ shifting past a power of 10 (e.g. `circular_shift(13, -1)`).\n<|/ c |>\n<| c\
    \ |>\n`circular_shift(x, shift)` returns `nil` when `x` is `0`\n<|/ c |>\n<| a\
    \ dscore=3 |>\nHere's a more optimized version with memoization.\n<code>", " \
    \ return x.to_s.reverse.gsub(/(.)(\\d*)/,'\\1\\2').to_i(16).to_s(16)\nend", " \
    \ # if shift > length then reverse and return\n  return x.reverse[x.reverse.length\
    \ + shift - x.length]\nend", "  s = (\"%0\" + str(len(x.to_s) % 2) + x.to_s).to_s.reverse\n\
    \  s.slice!(0, shift)\n  s.slice!(-shift)\n  s\nend", "  x = '' + x\n  shift =\
    \ '' + shift\n  result = \"\"\n  while shift >= 0\n    digit = x.slice!(i, i+1).to_i\n\
    \    result << digit\n    shift -= 1\n  end\n  result.reverse\nend\n</code>\n\
    <|/ a tags=ruby,algorithm,math,string |>\n<| c |>\nYou don't need to reverse the\
    \ result if shift<0. If shift < 0, then you get a negative string as result. `\"\
    \" << n #=> \"\"`\n<|/ c |>\n<| c |>\nI thought about that but decided that I'd\
    \ rather have a non-negative result if the shift was negative. Thanks for the\
    \ comment. I'll edit the answer accordingly.\n<|/ c |>\n<| a tags=ruby,algorithm,math,string\
    \ |>\n<code>", '    shifted_digits = ""', "  xs = x.to_s.chars\n  rev = false\n\
    \  shift.times do |i|\n    rev = true if xs[(i + shift.to_i)..-1] == \"\"\n  \
    \  xs[(i + shift.to_i)..-1].rotate(1)\n  end\n  rev ? xs.reverse.join.to_s : x.to_s\n\
    end", "  s = \"\"\n  while shift > 0\n    s << x\n    x >>= shift\n    shift -=\
    \ 1\n  s\nend\n  ", "  digits = x.digits.reverse\n  shift = 0 - shift\n  while\
    \ digits.length >= shift\n    digits = digits.reverse\n    digits = digits.shift.apply(digits,\
    \ shift)\n  end\n  digits.reverse\n  digits.join\nend", "  return x.modulo(10**shift).to_s\n\
    end", "  return x.gsub(/./){|d| (shift > 0 ? shift - (d.length % shift) : shift)\
    \ + (d.length % shift)}\nend\n</cell>\n<cell>", "  s = x.to_s(10)\n  s.reverse!\
    \ if shift > s.length\n  s[0...shift].insert(0, s[shift])\n  s.reverse!\n  s\n\
    end", "  result = ''\n  while shift > 0 do\n    digit = x % 10\n    x = x / 10\n\
    \    result = digit.to_s + result\n    shift = shift - 1\n  end\n  while shift\
    \ > 0 do\n    digit = x % 10\n    x = x / 10\n    result = digit.to_s + result\n\
    \    shift = shift - 1\n  end\n  if result == '' then\n    result = '0' #no digits\
    \ was left\n  end\n  return result\nend", "  return x.to_s.reverse.gsub(/(.)(.)/){|s|\
    \ s[0, shift]}.concat(\"0\")\nend", "  string = \"\"\n  if x > 0\n    while shift\
    \ > x.length\n      shift = shift - x.length\n      string = x.to_s + string\n\
    \      x = x.abs\n    end\n    x.to_s\n    while shift > 0\n      string = x.to_s\
    \ + string\n      x = x.abs\n      shift = shift - 1\n    end\n    string\n  else\n\
    \    x.to_s\n  end\nend\n</cell>\n<code language=julia-1.0>\ncircular_shift(1,1)\n\
    </cell>\n<text>\nFunction to calculate fibonacci number up to $n$", "\ts = x.to_s\n\
    \trev = s.length < shift\n\ts[rev] = s[rev].succ\n\t\n\ts.reverse! if rev\n\t\n\
    \treturn s\nend", "    # check if shift > length\n    if shift > x.length\n  \
    \      return \"\" + x[x.length..(-1 * shift)].to_s\n    \n    # Circularly shift\
    \ digits of x right by shift \n    # (x >> (x.length << shift)) is equal to x\
    \ >> shift.\n    \n    # 1. Circular shift the digits of the integer x, shift\
    \ the digits right by shift\n    # and return the result as a string.\n    # If\
    \ shift > number of digits, return digits reversed.\n    # >>> circular_shift(12,\
    \ 1)\n    # \"21\"\n    # >>> circular_shift(12, 2)\n    # \"12\"\n    return\
    \ x[0...x.length].to_s + x[x.length...(-1 * shift)].to_s \nend", "  if shift ==\
    \ 0\n    return x\n  shift_digits = x.digits.reverse\n  new_digits = x.digits.reverse\n\
    \  \n  shift.times do\n    new_digits = shift_digits(new_digits)\n  end\n  \n\
    \  return new_digits.join('')\nend", "  return x.to_s.reverse.sub(/(.)(.)(.*)/,\
    \ '\\\\2\\\\1\\\\2\\\\3').to_s\nend", "  digits = x.to_s\n  \n  return digits.reverse\
    \ if shift > digits.length else digits.reverse.chars.first(shift).reverse\nend",
  "  return ((x << shift) >> shift)\nend", "  shifted = x + shift - 1\n  digits =\
    \ shifted.digits.reverse\n  shifted.digits = digits\n  return shifted\nend", " \
    \ return x.to_s.reverse.chars.take(shift).join('')\nend\n</code>\nThen use the\
    \ function you defined above to find the sum of the digits of an integer, and\
    \ convert it to base 10\n<code>", "  digits = x.to_s.split(//)\n  shifted_digits\
    \ = digits.reverse.each_cons(shift).map { |x| x.reverse.join('') }\n  \"#{shifted_digits[0...shift].join('')}#{digits[shift].join('')}\"\
    \nend\n</code>\n<|/ a tags=ruby,string,ruby-on-rails |>\n<| c |>\n`x.to_s.split(//)`\
    \ should be `x.to_s.split(//)`\n<|/ c |>\n<| a |>\nHere's a recursive solution:\n\
    <code>", "  return \"#{'0' * (shift - Math.log10(x.abs)) + x.to_s.reverse}\"\n\
    end", "  n = shift.to_i\n  return x.to_s.rjust(shift.to_i * 2, \"0\") + x.to_s[shift.to_i\
    \ * 2 .. -1] if shift > n and x.to_s.length > n then circular_shift(x.to_s[1 ..\
    \ -n], shift - n) else x.to_s\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere's\
    \ a function that will do that:\n<code>", "  if shift == 0\n    return x\n  shift_digits\
    \ = shift.abs()\n  digits = x.to_s(10)\n  if shift_digits == 0\n    return digits\n\
    \  if shift_digits > digits.length\n    return digits.reverse\n  digits_reversed\
    \ = digits[shift_digits.length...].split(\"\").reverse.join\n  digits_shifted\
    \ = digits[0...shift_digits] + digits_reversed\n  result = digits_shifted\n  return\
    \ result\nend\n</cell>\n<text>\nExercise: Circular shift\nWrite a function that\
    \ takes a string and shifts each digit circularly by a given amount, for instance\
    \ circular_shift_by(\"12\", 3) should return \"21\".", "  \n  return x.to_s.reverse.gsub(/./)\
    \ { |n| n.to_s.reverse[shift.to_i] }\nend\n</cell>\n<code language=julia-1.5>\n\
    julia_shift = CircularShift(:digits)\n@code_warntype circular_shift(123, 1)\n\
    @code_warntype circular_shift(123, 2)\n</cell>\n<text>\nJulia also comes with\
    \ some handy tools for processing strings and vectors.", "  x.to_s.reverse.rjust(shift).chars.join(\"\
    \")\nend\n</cell>\n<cell>\nputs \"Shift right by one digit: '#{circular_shift(12,\
    \ 1)}'\"\n</cell>\n<cell>\nputs \"Shift right by two digits: '#{circular_shift(12,\
    \ 2)}'\"\n</cell>\n<cell>\nputs \"Shift right by three digits: '#{circular_shift(12,\
    \ 3)}'\"\n</cell>\n<cell>\nputs \"Shift right by four digits: '#{circular_shift(12,\
    \ 4)}'\"\n</cell>\n<cell>\nputs \"Shift right by five digits: '#{circular_shift(12,\
    \ 5)}'\"\n</cell>\n<cell>\nputs \"Shift right by six digits: '#{circular_shift(12,\
    \ 6)}'\"\n</cell>\n<cell>\nputs \"Shift right by seven digits: '#{circular_shift(12,\
    \ 7)}'\"\n</cell>\n<cell>\nputs \"Shift right by eight digits: '#{circular_shift(12,\
    \ 8)}'\"\n</cell>\n<cell>\nputs \"Shift right by nine digits: '#{circular_shift(12,\
    \ 9)}'\"\n</cell>\n<cell>\nputs \"Shift right by ten digits: '#{circular_shift(12,\
    \ 10)}'\"\n</cell>\n<cell>\nputs \"Shift right by eleven digits: '#{circular_shift(12,\
    \ 11)}'\"\n</cell>\n<cell>\nputs \"Shift right by twelve digits: '#{circular_shift(12,\
    \ 12)}'\"\n</cell>\n<cell>\nputs \"Shift right by thirteen digits: '#{circular_shift(12,\
    \ 13)}'\"\n</cell>\n<cell>\nputs \"Shift right by fourteen digits: '#{circular_shift(12,\
    \ 14)}'\"\n</cell>\n<cell>\nputs \"Shift right by fifteen digits: '#{circular_shift(12,\
    \ 15)}'\"\n</cell>\n<cell>\nputs \"Shift right by sixteen digits: '#{circular_shift(12,\
    \ 16)}'\"\n</cell>\n<cell>\nputs \"Shift right by seventeen digits: '#{circular_shift(12,\
    \ 17)}'\"\n</cell>\n<cell>\nputs \"Shift right by eighteen digits: '#{circular_shift(12,\
    \ 18)}'\"\n</cell>\n", "  x = x.to_i\n  result = x.to_s # result string will contain\
    \ the integer part\n  # shift right\n  if shift > 0\n    # shift left until a\
    \ digit is reached\n    shift_left = shift - 1\n    while result and (result[shift_left]\
    \ >= 10)\n      shift_left -= 1\n      # shift the digits to the left\n      result\
    \ = result[0, shift_left] + result[shift_left + 1, shift_left + 2].to_s + result[0,\
    \ shift_left + 1].to_s\n    end\n    # Shift the digits left as much as possible\
    \ to complete the shift\n    shift_right = shift_left\n    while shift_right >=\
    \ 0\n      # get the highest digit to shift\n      highest_digit = result[shift_right,\
    \ 1].to_i\n      # shift the digits\n      result = result[0, shift_right] + highest_digit.to_s\
    \ + result[0, shift_right].to_s\n      shift_right -= 1\n    end\n  end\n  # return\
    \ the result\n  result\nend\n</code>\nHere is an implementation of an algorithmic\
    \ solution:\n<code>", "  if x < 0\n    return -circular_shift(-x, shift)\n  digits\
    \ = x.to_s.reverse.to_i\n  digits[digits.size + 1 - shift] %= 10\n  digits = digits.digits.reverse\n\
    \  return x.new(digits)\nend", "  return x.to_s(10).reverse.split(//).rotate(shift).join\n\
    end", "  digits = x.to_s.reverse.split(\"\").to_a\n  digits[0..(digits.length\
    \ - shift)].join\nend", "  return x.to_s.reverse.chars.to_a.rotate(shift).join.to_s.reverse\n\
    end", "  shifted = x.to_s.length\n  digits.reverse!\n  digits << shift\n  digits.reverse!\n\
    \  return x.to_s + (digits[shifted.to_s.size..-1])\nend", "  result = ''\n  x\
    \ = x.to_i\n  shift = shift % x.digits", "  x -= x.modulo(10**shift).to_i\n  x.to_s(10)[shift..].to_i(10)\n\
    end", "  shift = shift < 0 ? -shift : shift\n  digits = x.digits.reverse\n  digits[0,\
    \ shift].concat(digits[shift, 1])\n  digits.join\nend", "  x.to_s.chars.zip(shift).map\
    \ { |a| a.reverse.join }.join\nend", "  str = x.to_s.reverse\n  if shift > str.length\n\
    \    str.reverse\n  end\n  str.slice!(0, shift)\n  return str\nend", "  if shift\
    \ > log10(x) + 1\n    x = (x % 10 + 10) % 10 * 10 + x % 10\n  else\n    x = x\
    \ % 10 * 10 + x % 10\n  end\n  x = x.floor\n  x += (shift - log10(x)).abs\n  x\
    \ = x % 10\n  x = x.floor\n  return x.to_s\nend", "  if shift == 0\n    return\
    \ x\n  ret = x\n  while shift > 0\n    ret = (\"%0\" + str(shift) + \"d\" % ret).rjust(len(str(x)))\n\
    \    shift -= 1\n  end\n  return ret\nend", "  shift -= 1\n  string = \"\"", " \
    \ if x == 0\n    puts \"0\"\n  elsif shift == 0\n    puts x\n  elsif shift > -x.to_s.length\n\
    \    puts x.to_s\n  elsif shift < -x.to_s.length\n    puts x.to_s[0...-shift]\n\
    \  else\n    digits = x.to_s\n    digits[0...shift] = digits[shift]\n    digits[-shift..-1]\
    \ = \"0\"\n    puts digits.to_s\n  end\nend", "  x =~ /\\d+/ if x.class == Fixnum\n\
    \  x = x.to_s\n  result = ''\n  len = x.length\n  shift %= len\n  digits = x.chars.to_a\n\
    \  digits.each_index do |i|\n    digits[i] << shift if shift > 0\n    digits[i]\
    \ >>= shift if shift < 0\n  end\n  digits = digits.join\n  if digits.size < len\n\
    \    digits.reverse[len..-1]\n  else\n    digits\n  end\nend", "    if shift <=\
    \ 0\n        x.reverse!\n        return\n    \n    digits = x.to_s\n    digits[0..shift-1]\
    \ = digits[shift..-1]\n    digits.reverse!\n    \n    return digits.to_s\nend",
  "    digits =\n        x.digits.map { |i| (i + shift) % 10 }\n    digits[0...shift].join\n\
    end\n</code>\nNow the main part of your program will look like this\n<code>",
  "  digits = x.to_s(16).reverse.to_i(16).times\n  digits = (digits >> shift) | ((digits\
    \ << (64-shift)) & 0xffffffffffffffff)\n  digits = digits(64).times\n  digits\
    \ = digits.reverse.to_s(16).reverse\n  puts \"#{digits(64)}\"\nend", "  return\
    \ x.to_s.reverse.slice(shift.to_i, x.length).reverse\nend", "    digits = []\n\
    \    shift = abs(shift)\n    for d in x.to_s.reverse\n        digits.push(d >>\
    \ shift)\n        digits.push(d & MASK)\n    end\n    return digits.reverse.join\n\
    end", "  if shift > x.length\n    x.reverse!\n    shift-=x.length\n  end\n  x.slice!(shift)\n\
    \  x.reverse!\n  x\nend", "  x = x.to_s\n  result = []\n  while x.length > shift\n\
    \    result << x.slice!(0, shift)\n    shift -= 1\n  result << x.slice!(0, shift)\n\
    \  return result.join(\"\")\nend", "    digits = ''\n    if shift > 0\n      \
    \  digits = x.to_s.reverse[shift].to_s\n    else\n        digits = x.to_s.reverse[shift].to_s\n\
    \    end\n    digits\nend", "  n = ((x // 10**shift) * 10**shift).to_i\n  x -=\
    \ n*10**shift\n  x = x.floor.to_s\n  return x.reverse\nend", "  return x.to_s.reverse.gsub(/((\\\
    d)\\1*)/) { |m| m[$2.to_i + shift].to_s }\nend", "  x = x.to_s\n  shift = shift\
    \ % x.size\n  x.slice!(..shift)\n  x.slice!(..x.size)\n  x.reverse!\n  return\
    \ x.to_s\nend", "\tdigits = x.to_s\n\tshift_digits = digits.reverse\n\tdigits.slice!(0,\
    \ shift_digits.length+shift)\n\tdigits[shift_digits.length..-1].reverse!\n\treturn\
    \ digits.reverse\nend\n\t", "    digits = x.digits.reverse\n    if shift > x.digits.length\n\
    \        shift  = x.digits.length - shift\n    x.digits.each do |digit, index|\n\
    \        digits[(index + shift) % x.digits.length] = digit\n    end\n    x.digits.reverse!\n\
    \    return x.digits.join\nend\n</code>\n<|/ a dscore=4 tags=ruby,algorithm,time-complexity\
    \ |>\n<| c |>\nWhat is this doing exactly?\n<|/ c |>\n<| c |>\n, it's converting\
    \ a number to an array, rotating the array and converting the array back to a\
    \ number. Also it's using a hash table to save on O(n) lookups.\n<|/ c |>\n<|\
    \ c |>\nI'm having trouble understanding how this would work when shifting to\
    \ the left like `circular_shift(123, 3)` but I'm assuming this is because the\
    \ `digits` array is a reversed representation of the input number? If so, would\
    \ this be an acceptable implementation? `digits[(index - shift) % x.digits.length]\
    \ = digit`\n<|/ c |>\n<| c |>\n, that's right, I reversed the digits because I\
    \ thought it would be more readable if the array was \"backwards\". Without reversing\
    \ the array, I end up with `circular_shift(123, 3)` returning `1230` which doesn't\
    \ work. `circular_shift(123, 0)` would return `123`.\n<|/ c |>\n<| c |>\n, I'm\
    \ getting a wrong answer. `circular_shift(111, 2)` returns `1112`. `1112` should\
    \ be `111`.\n<|/ c |>\n<| a dscore=3 |>\nThe best way would be to use BigDecimal.\
    \ BigDecimals have a rotate method which allows one to rotate them by n places.\
    \ In ruby this would look like this:\n<code>", "  ret = ''\n  if shift <= 0\n\
    \    return x\n  while shift > 0 do\n    if x > 0\n      x = x >> 1\n      ret\
    \ = String(ret) << 1\n    else\n      x = x << 1\n      ret = String(ret) >> 1\n\
    \    end\n    shift = shift - 1\n  end\n  return ret\nend", "    digits = x.to_s(2)\n\
    \    digits.reverse!\n    digits.slice!(0, shift)\n    digits.reverse!\n    return\
    \ digits\nend", "  if x > 9 or shift > x.length\n  then return \"\"\n  end\n \
    \ new_x = x.to_s\n  x.slice!(0, shift)\n  x.slice!(0, shift)\n  return new_x\n\
    end\n</cell>\n<code language=julia-1.5>", "    return x.to_s.scan(/(.)/).join.reverse.scan(/.{1,shift}$/).join.tr('0',\
    \ x.to_s).to_s\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\n<code>\n\"12345\".reverse.scan(/(.{2})/).join.reverse.scan(/(.{2})$/).join.tr(\"\
    0\", '').reverse\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=ruby |>\n<code>\n\
    \"1234\".reverse.scan(/(.{2})/).join.reverse.scan(/(.{2})$/).join.reverse\n</code>\n\
    <|/ a |>\n<| a tags=ruby |>\n<code>\n\"1234\".reverse.scan(/(.{2})/).join.reverse.scan(/(.{2})$/).join.tr(\"\
    0\", \"'\").reverse", "  x.to_s.reverse.chars.take(shift).join\nend", "  s = shift\
    \ % x.length\n  return x.reverse[s] + x.reverse[0...s]\nend", "  return x.reverse.chars.slice(0,shift).reverse.chars.join\n\
    end", "  digits = x.to_s(10)\n  digits = digits.reverse.gsub(/(.)\\1*/) { $1.reverse\
    \ }\n  return digits.reverse.gsub(/^(\\d*)/) { $1+shift.to_s(10) }\nend", "  x\
    \ = x.to_s\n  shift = shift % x.size\n  x <<= shift\n  x &= (2**x.size-1).to_s(2).reverse\n\
    \  x = x.reverse\n  return x\nend", "  str = \"\"\n  while x < 0\n    x = x +\
    \ 2**32\n    str = str + x.to_s\n  end\n  while x > 2**32\n    str = str + \"\
    0\"\n    x = x - 2**32\n  end\n  str = '0' * (shift - str.size) + str\n  str.reverse!\n\
    \  return str\nend", "    digits = x.to_s.reverse\n    digits = digits[0...shift]\
    \ + digits[shift...-1]\n    return digits.to_s.reverse\nend\n</code>\nThe above\
    \ code is in Ruby; for Ruby it would be something like:\n<code>", "  xstr = x.to_s\n\
    \  xstr.slice!(0, -shift)\n  xstr.reverse!\n  xstr.slice!(0, -shift)\n  return\
    \ xstr\nend", "  digits = []\n  digit, i = x.divmod(shift)\n  digits.push(digit)\n\
    \  x = x - digit*shift\n  while x > shift\n    digit, i = x.divmod(shift)\n  \
    \  digits.push(digit)\n    x = i - digit*shift\n  end\n  digits.reverse!\n  digits.reverse!\n\
    \  return digits_to_string(digits)\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays,recursion\
    \ |>\nI wrote this function in PHP, but I believe it'll work in Ruby too:\n<code>\n\
    <?php\nfunction myFunction($n)\n{\n    $x = pow(10, $n);\n    $digits = \"\";\n\
    \    while(true)\n    {\n        if($x >= 1)\n        {\n            $x = ($x\
    \ % 10) + 1;\n        }\n        else\n        {\n            break;\n       \
    \ }\n        $digits = $x.$digits;\n    }\n    return $digits;\n}", "  if shift\
    \ < 0\n    digits, _ = divmod x, 10\n    digits = digits.reverse\n  else\n   \
    \ digits = (x % (10**shift)).divmod(10**shift)\n    digits = digits + ((digits[-1],\
    \ digits.pop()),)\n  end", "  ret = x.to_s\n  l = ret.length\n  shift += l\n \
    \ if shift>=l then\n    ret = ret.slice(-shift, -1)\n  else\n    ret = ret.slice(-shift)\n\
    \  end\n  ret\nend", "    if shift > log10(x)\n        shift = (log10(x) + 1)\
    \ % log10(x)\n    digits = int(x)\n    while digits > shift\n        digits =\
    \ digits - 10\n    digits = digits + shift\n    digits = digits and str(digits)\
    \ or \"0\"\n    if digits[8] == \"0\"\n        digits = digits[7:9] + digits[0:7]\n\
    \    else\n        digits = digits[0:8] + digits[7:10]\n    return digits[::-1]\n\
    end", "  result = ''\n  while shift > x.length\n    shift = shift - x.length\n\
    \    x = x.to_s\n  end\n  shift += x.length\n  x.gsub(/(.)(.)/) { |v| result =\
    \ result + v.to_s << shift }\n  result\nend", "  return x.to_s.reverse.gsub(/(..)..(..)/,'\\\
    1\\2')\nend\n</code>\nSo what are they doing here? \n<code>\n$ ruby -e 'p CircularShift.new.circular_shift(12,\
    \ 1)'\n\"21\"\n$ ruby -e 'p CircularShift.new.circular_shift(12, 2)'\n\"12\"\n\
    </code>\nThey are turning the number into a string, chopping off the end (slice),\
    \ then reversing the string (slice).\n<|/ a tags=ruby |>\n<| c |>\nThanks for\
    \ the explanation. `to_s` is exactly what I was looking for.\n<|/ c |>\n<| c |>\n\
    `to_s` is just an alias for `inspect`. `inspect` outputs the string in human-readable\
    \ way. `to_s` returns the string in Ruby internal format.\n<|/ c |>\n<| a dscore=3\
    \ |>\n<code>", "  str = \"\"\n  while x >= 2**(shift*10) and str.length <= 10\n\
    \    shift -= 1\n    str = str + x.to_s.chars.reverse[shift..-shift-1]\n    x\
    \ >>= shift\n  end\n  str = str + x.to_s.chars[0..shift]\n  str\nend\n</code>\n\
    <|/ a tags=bit-shift,ruby |>\n<| c |>\nHi, you have a problem with shift > length.\
    \ Do you have an idea how to fix that?\n<|/ c |>\n<| c |>\nI don't understand\
    \ what you mean.\n<|/ c |>\n<| c |>\nThe string length can be more than 10 digits.\
    \ After the first digit, there are less then ten digits. So the shift should be\
    \ <= the string length. Your code only works if the length is less than 10. Does\
    \ this make sense to you?\n<|/ c |>\n<| c |>\nI edited the answer to use `String.length`\
    \ instead of hardcoded `10`. I also made it clearer that the algorithm is circular,\
    \ by reversing the digits. `circular_shift` should probably be renamed to `circular_shift!`,\
    \ because it will modify the original number.\n<|/ c |>\n<| c |>\nI added a comment\
    \ about that.\n<|/ c |>\n<| a dscore=3 |>\nYou could use the to_i method. Like\
    \ this:\n<code>\n>> \"9223372036854775808\".to_i\n=> 9223372036854775808\n>> \"\
    9223372036854775809\".to_i\n=> -9223372036854775808\n</code>\n<|/ a tags=bit-shift,ruby\
    \ |>\n<| a tags=bit-shift,ruby |>\nAs mentioned by others, there is to_i available,\
    \ but if you need something more \"clever\", you can build an enumerator that\
    \ gives you the next number in a circular fashion. This can be used with Enumerable#cycle\
    \ or Iterator#next.\n<code>", "  ret = \"\"\n  digits = x.to_s\n  len = digits.count(\"\
    0\") - shift\n  ret.concat(digits.slice!(len..-1))\n  if len == 0\n    ret.concat(digits.reverse)\n\
    \  end\n  ret\nend", "  return x.to_s.length >= shift ? x.to_s.insert(0, x.to_s.slice(-shift))\
    \ : x.to_s\nend", "  x.slice!(1..shift)\n  x.reverse! if shift > x.length\n  x.join\n\
    end", "    if x < 0\n        x, shift = -x, 1\n    end\n    digits = x.to_s.reverse.to_i(10)\n\
    \    (shift > digits.length and digits) or (digits[0...shift].concat(digits[shift+1...digits.length]))\n\
    end", "    digits = x.to_s\n    (shift > 0 ?\n      digits.reverse! : digits.reverse).slice!(0,\
    \ shift)\n    return digits.to_s\nend", "  return x.to_s.rjust(shift, x.digits[-shift])\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays dscore=0 |>\nHere\
    \ is yet another solution that follows the same logic as the others, but is more\
    \ readable and more idiomatic in Ruby:\n<code>", "  return x.to_s.reverse.slice(shift)\n\
    end", "  return x.slice(-shift)+x.slice(shift)\nend", "  str = \"\"\n  if x >\
    \ 0\n    str = x.to_s\n    str.slice!(0, shift)\n    str.slice!(0, x.to_s.length\
    \ - shift)\n    str += circular_shift(x.to_s.reverse, shift)\n  else\n    if shift\
    \ > 0\n      str += circular_shift(x.to_s.reverse, shift)\n    end\n  end\n  return\
    \ str\nend", "  if shift > x.length\n    x.slice!(-1*(x.length-shift))\n  else\n\
    \    x.slice!(-shift, x.length)\n  end\nend", "  return x.to_s.reverse.ljust(shift,\
    \ x)\nend", "  if x > 9\n    shift -= 1\n    x = x >> shift\n    shift = shift\
    \ % 10\n    return circular_shift(x, shift)\n  else\n    return x\n  end\nend",
  "  str = x.to_s\n  shift = shift % str.length\n  result = \"\"\n  i = 0\n  while\
    \ i < shift do\n    result = str + (result ? \" \" + result : \"\")\n    i +=\
    \ 1\n  end\n  istr = \"\"\n  i = str.length\n  while i >= 0 do\n    istr = istr\
    \ + (istr ? \" \" + istr : \"\")\n    i -= 1\n  end\n  return result.chop + istr.chop\n\
    end", "    # Circular shift the digits of the integer x, shift the digits right\
    \ by shift\n    # and return the result as a string.\n    # If shift > number\
    \ of digits, return digits reversed.\n    # >>> circular_shift(12, 1)\n    # \"\
    21\"\n    # >>> circular_shift(12, 2)\n    # \"12\"\n    digit = x.to_s\n    digit\
    \ = (digit[0,shift.to_s] + digit[shift.to_s+1,digit.size - 1 - shift.to_s]).to_s\n\
    \    return digit\nend\n</pre>\n                    </div>\n                 \
    \   \n                    <div id=\"footer\">\n                        <span class=\"\
    right\">Created with <a href=\"http://www.spigotmc.org/\">SpigotMC</a></span>\n\
    \                    </div>\n                    \n                </div>\n  \
    \          </div>\n        </div>\n    </div>\n</div> ", "  return x.to_s.reverse[x.to_s.size\
    \ - shift.to_s.size + shift.to_s.size - x.to_s.size - 1]\nend", "  x.to_s.reverse\
    \ * shift\nend", "  x[end - shift, end - shift] = x[end - shift, end - 1]\n  x\
    \ = x.reverse\n  x[end - shift, end - shift] = x[end - shift, end - 1]\n  x =\
    \ x.reverse\n  x[0, end - shift] = x[0, end - shift] % 10 + circular_shift(x,\
    \ 1)\n  x = x.reverse\n  return x.to_s\nend", "    digits = x.to_s.reverse[1...shift]\n\
    \    digits.reverse!\n    x + (digits.reverse)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
