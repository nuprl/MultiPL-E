name: HumanEval_61_correct_bracketing
language: rb
prompt: "# brackets is a string of \"(\" and \")\".\n# return True if every opening\
  \ bracket has a corresponding closing bracket.\n# >>> correct_bracketing(\"(\")\n\
  # False\n# >>> correct_bracketing(\"()\")\n# True\n# >>> correct_bracketing(\"(()())\"\
  )\n# True\n# >>> correct_bracketing(\")(()\")\n# False\ndef correct_bracketing(brackets)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_correct_bracketing\n\
  \    candidate = method(:correct_bracketing)\n    assert_equal(true, candidate.call(\"\
  ()\"))\n    assert_equal(true, candidate.call(\"(()())\"))\n    assert_equal(true,\
  \ candidate.call(\"()()(()())()\"))\n    assert_equal(true, candidate.call(\"()()((()()())())(()()(()))\"\
  ))\n    assert_equal(false, candidate.call(\"((()())))\"))\n    assert_equal(false,\
  \ candidate.call(\")(()\"))\n    assert_equal(false, candidate.call(\"(\"))\n  \
  \  assert_equal(false, candidate.call(\"((((\"))\n    assert_equal(false, candidate.call(\"\
  )\"))\n    assert_equal(false, candidate.call(\"(()\"))\n    assert_equal(false,\
  \ candidate.call(\"()()(()())())(()\"))\n    assert_equal(false, candidate.call(\"\
  ()()(()())()))()\"))\n  end\nend\n"
completions: ["    brackets.scan(/[()]/) do |x|\n        if brackets.peek(x) != \"\
    )\"\n            # not opening\n            true\n        else\n            #\
    \ closing\n            brackets.next\n            false\n        end\n    end\n\
    end", "  brackets = brackets.to_s\n  bracket_stack = []\n  bracket_level = 0\n\
    \  brackets.reverse!", "  bracket_stack = bracket_stack\n  opening_stack = bracket_stack\n\
    \  stack = []\n  while brackets do\n    if brackets == \"()\" then\n      stack.pop\
    \ until stack.length == 0\n      brackets = stack.pop\n      opening_stack = opening_stack\n\
    \      bracket_stack = bracket_stack\n      break\n    elsif brackets =~ (/[()]+/)\
    \ then\n      brackets = brackets[1..-2].gsub(\"\\\\\", \"\") unless brackets\
    \ =~ (/[()]/)\n      if opening_stack.last == \"(\" and brackets =~ /[()]+/ then\n\
    \        brackets = brackets[1..-2]\n        opening_stack = opening_stack.push(brackets)\n\
    \      else\n        opening_stack = opening_stack.push(brackets)\n      end\n\
    \    elsif brackets =~ (/[()]/) then\n      brackets = brackets[1..-2].gsub(\"\
    \\\\\", \"\") unless brackets =~ (/[()]+/)\n      opening_stack = opening_stack.push(brackets)\n\
    \    elsif brackets =~ (/\\)/) then\n      brackets = brackets[1..-2].gsub(\"\\\
    \\\", \"\") unless brackets =~ (/\\)/)\n      opening_stack = opening_stack.push(brackets)\n\
    \      opening_stack = opening_stack.pop until opening_stack.length == 0\n   \
    \   bracket_stack = bracket_stack\n      brackets = stack.pop\n    else\n    \
    \  brackets = brackets[1..-2].gsub(\"\\\\\", \"\")\n      opening_stack = opening_stack.push(brackets)\n\
    \    end\n  end\n  opening_stack.length == 0\nend", "    opening_brackets = brackets.count(\"\
    (\")\n    closing_brackets = brackets.count(\")\")", "  if brackets == \"\"\n\
    \    return false\n  brackets = brackets.to_s.chars\n  # Create a stack of pairs\
    \ of brackets\n  stack = []\n  stack << [brackets[0]]\n  \n  # Iterate through\
    \ the rest of the brackets\n  for i in 1..brackets.length\n    if brackets[i]\
    \ == \"(\"\n      # If the stack is empty or a matching closing bracket is found,\n\
    \      # add the opening bracket to the stack\n      unless stack.length == 0\
    \ or stack.pop.pop == \"(\"\n        stack.push(\"(\")\n      end\n    elsif brackets[i]\
    \ == \")\"\n      # If the stack is empty or a matching opening bracket is found,\n\
    \      # add the closing bracket to the stack\n      unless stack.length == 0\
    \ or stack.pop.pop == \")\"\n        stack.push(\")\")\n      end\n    else\n\
    \      stack.push(brackets[i])\n    end\n  end\n  \n  # If there are no more brackets\
    \ left, we have a matching pair of brackets\n  stack.size == 0 and return true\n\
    \  false\nend\n</cell>\n<cell>", "  brackets.gsub!(/^ *\\([^()]*\\)$/,'')\n  brackets.gsub!(/\\\
    ( *\\([^()]*\\)$/,'(')\n  brackets.gsub!(/\\( *\\([^()]*\\)$/,'')\n  brackets.gsub!(/\\\
    ) *\\([^()]*\\)$/,')')\n  brackets.gsub!(/\\) *\\([^()]*\\)$/,'')\n  brackets.gsub!(/^\
    \ *\\([^()]*\\)/,'(')\n  brackets.gsub!(/^ *\\([^()]*\\)/,'')\n  brackets.gsub!(/^\
    \ *\\([^()]*\\)$/,'')\n  brackets.gsub!(/\\) *\\([^()]*\\)$/,')')\n  brackets.gsub!(/\\\
    ) *\\([^()]*\\)$/,'')\n  brackets.gsub!(/\\) *\\([^()]*\\)$/,'')\n  brackets.gsub!(/\\\
    ) *\\([^()]*\\)/,')')\n  brackets.gsub!(/\\) *\\([^()]*\\)/,'')\n  brackets.gsub!(/\\\
    ) *\\([^()]*\\)/,'')\n  brackets.gsub!(/^ *\\([^()]*\\)/,'')\n  brackets.gsub!(/^\
    \ *\\([^()]*\\)$/,'')\n  return brackets == \"\"\nend", "  return brackets.gsub(/\\\
    (/, '').gsub(/\\)/, '') =~ /[\\(\\)]/\nend", "  brackets.scan(/([()]+)/).all?{|x|\
    \ x.is_a?(String) && x.scan(/([()]+)/).all?{|y| y.is_a?(String) && y == \"()\"\
    } }\nend", "    bracket_count = brackets.count(\"(\")\n    brackets.gsub!(\"(\"\
    , \"(\" * bracket_count)\n    brackets.gsub!(\")\", \")\" * bracket_count)\n \
    \   return brackets.gsub!(/\\(\\)/, \"(\") == brackets.gsub!(/\\(\\)/, \")\")\n\
    end", "  brackets.scan(/[\\(\\)]/) do |opening_bracket|\n    brackets.scan(/\\\
    (/) { |closing_bracket| return false }\n    return false if opening_bracket.nil?\n\
    \    next false if opening_bracket.empty?\n    brackets.scan(opening_bracket,\
    \ closing_bracket) do |opening_bracket, closing_bracket|\n      opening_bracket.empty?\
    \ && closing_bracket.empty? ||\n      opening_bracket.empty? && opening_bracket\
    \ == closing_bracket\n    end\n    false\n  end\n  true\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\nIn Ruby 1.8.7, you can use String#match to find a regex match within\
    \ a string.\nFor example:\n<code>", "  stack = []\n  brackets = brackets.to_s\n\
    \  brackets.chars.each do |char|\n    if char == \"(\"\n      stack.push(char)\n\
    \    elsif char == \")\"\n      return false unless stack.pop == char\n    end\n\
    \  end\n  true\nend\n</code>\nAnd here is how you would implement it:\n<code>",
  "  return brackets.chars.all? { |c| c == ')' || c == '(' }\nend", "  # Your code\
    \ here!\n  return true\nend", "  bracket_counts = brackets.count(\"(\") - brackets.count(\"\
    )\")\n  return bracket_counts == 0", "    stack = []\n    brackets = brackets.split(\"\
    \")\n    opening_brackets = 0\n    closing_brackets = 0\n    # Iterate through\
    \ all brackets\n    for bracket in brackets\n        # Append the bracket to our\
    \ stack\n        stack << bracket\n        # When we see a bracket, increment\
    \ its opening brackets counter\n        if bracket == '('\n            opening_brackets\
    \ += 1\n        # When we see a bracket, decrement its closing brackets counter\n\
    \        if bracket == ')'\n            closing_brackets -= 1\n        # When\
    \ (both) brackets counters reach 0, then we can be sure that\n        # every\
    \ brackets has a corresponding closing bracket\n        if opening_brackets ==\
    \ 0 and closing_brackets == 0\n            return opening_brackets == closing_brackets\n\
    \    end\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>", "  brackets = brackets.to_s\n\
    \  brackets.scan(/^\\((.+?)\\)$/) {|m| yield(m[1].length == m[0].length)}\nend\n\
    </code>\n<|/ a tags=ruby,regex,ruby-on-rails dscore=1 |>\n<| c |>\nThis worked\
    \ great, but now it won't accept any brackets next to each other. Example: ",
  "    brackets.scan(/[()]/)\n    return brackets.empty?\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks for this answer! I will try it out and get back to you as\
    \ soon as possible.\n<|/ c |>\n<| c |>\nOkay so I implemented this solution and\
    \ it is working perfectly! I understand how the code works, thanks again! I am\
    \ now trying to solve the question where you are given a string of parentheses.\
    \ Return a string consisting only of opening brackets.\n<|/ c |>\n<| c |>\n: Good\
    \ to hear! Happy coding :)\n<|/ c |>\n<| c |>\nHey I've just updated my code with\
    \ my full code (which I forgot to add before submitting this) and I keep getting\
    \ this error when trying to run my solution: `wrong number of arguments (0 for\
    \ 1..2)` Any idea why I'm getting this error? It worked fine before I added my\
    \ solution. I added my full solution after submitting my question. Thanks again!\n\
    <|/ c |>\n<| c |>\nHmm, strange. Which line is it complaining about? Can you share\
    \ the error with me? It should be on line 15. Also which version of ruby are you\
    \ running?\n<|/ c |>\n<| a dscore=1 |>\nYou can simply iterate over each character\
    \ in the string and check if the character is \"(\" or \")\", and if not then\
    \ you can append the character to an array, like so:\n<code>", "  brackets = brackets.dup\n\
    \  brackets.sub!(/[]/, '')\n  brackets.sub!(/\\)/, '')\n  return brackets.empty?\n\
    end", "  brackets.scan(/(([^\\s()]*\\([^\\s()]*\\))*[^\\s()]*)/) do |m|\n    return\
    \ false unless m.last.nil?\n    # m is a MatchData object containing all captured\
    \ groups from the regex.\n    # The last group in this match is the entire match\
    \ (i.e., everything up to and including the last\n    # closing bracket)\n   \
    \ # m.last returns the entire match without the first group (i.e., the entire\
    \ match).\n    return true if m.last.slice!(0)\n    # m.last.nil? indicates that\
    \ the last closing bracket was the first\n    # one in the string.\n    # Therefore,\
    \ this string has one closing bracket at the beginning\n    # and no more.\n \
    \   # Therefore, we need to correct the bracketing.\n    m.replace(m[1..-1]) unless\
    \ m[1..-1] == ''\n  end\n  false\nend", "  brackets = brackets.to_s\n  opening\
    \ = brackets[0...-1]\n  closing = brackets[1...-1]\n  opening = opening.to_s\n\
    \  closing = closing.to_s\n  if opening.length != closing.length\n    false\n\
    \  else\n    true\n  end\nend\n</pre>\n</div>", "  brackets = brackets.to_s\n\
    \  brackets.each_char { |char|\n    next if (char == ?(\n      true\n    elsif\
    \ char == ?(\n      false\n    elsif char == ?{\n      true\n    elsif char ==\
    \ ?}\n      false\n    elsif char == ?;\n      true\n    elsif char == ?,\n  \
    \    true\n    elsif char == ?\\n\n      true\n    else\n      false\n    end\n\
    \  }\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\nThis doesn't match the\
    \ example given in the OP's question. For example, it should return true for `'()'`,\
    \ `'(())'` and `'(()())'` but false for `'()()'`.\n<|/ c |>\n<| c |>\nSorry I\
    \ fixed the code. Now it should match all the examples provided by the OP.\n<|/\
    \ c |>\n<| c |>\nSorry, I've read the question once again. I think you misread\
    \ it, because you said it was working for the OP but now you've fixed it.\n<|/\
    \ c |>\n<| c |>\nI fixed my code again. I checked it with `'()()'`, `'(())'` and\
    \ `'(()())'` and it now works for all of them.\n<|/ c |>\n<| c |>\nOh, sorry,\
    \ my bad. You're right, it works for all now. Sorry about that.\n<|/ c |>\n<|\
    \ a dscore=1 |>\n<code>", "  bracketing = brackets.count(\"(\") == brackets.count(\"\
    )\")\n  brackets = brackets.count(\"(\") - brackets.count(\")\")\n  bracketing\
    \ = (bracketing == brackets) and (\n    brackets.to_i > 0 and brackets.to_i <=\
    \ brackets.to_i + 2)\n  return bracketing\nend", "  brackets.split('(').map{|open_bracket|\
    \ correct_bracketing(open_bracket)}\n  brackets.split(')').map{|close_bracket|\
    \ correct_bracketing(close_bracket)}\n  brackets == brackets.gsub(/[][]/, '').gsub(/[^()]+/,\
    \ '').gsub(/[\\[\\]]/, '').gsub(/[\\(\\)]/, '')\nend", "  brackets = brackets.strip\n\
    \  brackets = brackets.sub(/[\\(\\)]/, '')\n  brackets.empty? && (brackets = brackets)\n\
    \  brackets.count == '()' && return false\n  brackets.count == '[]' && return\
    \ true\n  brackets.count == '{}' && return true\n  brackets.count == '<>' && return\
    \ true\n  brackets.count == '<>}' && return true\n  brackets.count == '<>}[]{}'\
    \ && return true\n  brackets.count == '<>[]{}' && return true\n  brackets.count\
    \ == '<>{}[]' && return true\n  brackets.count == '<>{}[][]{}{}' and return true\n\
    \  brackets.count == '<>{}[]{}[]{}{}' and return true\n  brackets.count == '<>{}[]{}[]{}{}[]{}'\
    \ and return true\n  brackets.count == '<>{}[]{}[]{}{}[]{}{}' and return true\n\
    \  brackets.count == '<>{}[]{}[]{}{}[]{}{}[]{}' and return true\n  brackets.count\
    \ == '<>{}[]{}[]{}{}[]{}{}[]{}{}' and return true\n  brackets.count == '<>{}[]{}[]{}{}[]{}{}[]{}{}'\
    \ and return true\n  brackets.count == '<>{}[]{}[]{}{}[]{}{}[]{}{}[]{}' and return\
    \ true\n  brackets.count == '<>{}[]{}[]{}{}[]{}{}[]{}{}[]{}{}' and return true\n\
    \  brackets.count == '<>{}[]{}[]{}{}[]{}{}[]{}{}[]{}{}[]{}' and return true\n\
    \  brackets.count == '<>{}[]{}[]{}{}[]{}{}[]{}{}[]{}{}[]{}' and return true\n\
    \  brackets.count == '<>{}[]{}[]{}{}[]{}{}[]{}{}[]{}{}[]{}{}' and return true\n\
    \  brackets.count == '<>{}[]{}[]{}{}[]{}{}[]{}{}[]{}{}[]{}{}[]{}' and return true\n\
    \  brackets.count == '<>{}[]{}[]{}{}[]{}{}[]{}{}[]{}{}[]{}{}[]{}{}' and return\
    \ true\n  brackets.count == '<>{}[]{}[]{}{}[]{}{}[]{}{}[]{}{}[]{}{}[]{}{}[]' and\
    \ return true\n  brackets.count == '<>{}[]{}[]{}{}[]{}{}[]{}{}[]{}{}[]{}{}[]{}{}[]{}'\
    \ and return true\n  brackets.", "  brackets.chars.each do |char|\n    case char\n\
    \    when '('\n      stack << char\n    when ')'\n      if stack.empty?\n    \
    \    return false\n      elsif stack.pop != char\n        return false\n     \
    \ end\n    end\n  end\n  true\nend", "    brackets.scan(/\\(/)\n    brackets.scan(/\\\
    )/)\n    return brackets.empty?\nend", "  brackets = brackets.gsub(\"[()]\", \"\
    \")\n  return brackets.gsub(\"^[()]$\", \"\") == \"\"\nend", "  opening_brackets\
    \ = brackets.match('\\(')\n  closing_brackets = brackets.match('\\)')\n  opening_brackets.each\
    \ do |bracket|\n    return false unless closing_brackets.include?(bracket)\n \
    \ end\n  true\nend\n</code>\nThis isn't the most efficient way to solve this problem,\
    \ but I think it's easy to understand.\n<|/ a tags=ruby,regex dscore=1 |>\n<|\
    \ c |>\nThis doesn't check for nested brackets in the right order.\n<|/ c |>\n\
    <| c |>\nThanks for the catch! I edited it now to fix the issue.\n<|/ c |>\n<|\
    \ a |>\n<code>", "  brackets.each_char do |char|\n    bracket_counts[char] +=\
    \ 1\n    opening_brackets << bracket_counts[char] > 1\n  end\nend\n</code>\nThe\
    \ array brackets is just a list of characters. In Ruby, you can treat strings\
    \ as arrays of characters; the string \"(\" is just an array with the single character\
    \ '(' in it.\nThe each_char method iterates over every character in brackets,\
    \ one at a time. Since brackets is a string, each character is passed in as a\
    \ character variable.\nWe can then increment bracket_counts[char] by 1 every time\
    \ we see a character in brackets. Each time we see a character in brackets, bracket_counts[char]\
    \ will be greater than 1, so we'll add 1 to the count for that character, and\
    \ if it already has that value, add 1.\nThen, we'll check if the count for that\
    \ character is greater than 1, in which case we know we have a matching bracket.\
    \ If it's greater than 1, then the counts are different, so it's an error. Since\
    \ we're already checking each character, we know that no brackets will match with\
    \ each other.\nAt the end, the opening_brackets array will contain all the brackets\
    \ that are not paired with a closing bracket.\n<|/ a tags=ruby,regex |>\n<| c\
    \ |>\n\"Brackets have a corresponding closing bracket.\" Do you know that every\
    \ opening bracket has a corresponding closing bracket? Or is that an assumption?\n\
    <|/ c |>\n<| c |>\nThat's why I put that assumption at the top. It's a little\
    \ unclear what the OP wants, since I interpreted it as \"every opening bracket\
    \ has a corresponding closing bracket.\" But if that's what they want, then yes\
    \ - that's exactly what I put at the top of my answer.\n<|/ c |>\n<| c |>\n\"\
    Brackets have a corresponding closing bracket.\" Do you know that every opening\
    \ bracket has a corresponding closing bracket? Or is that an assumption?", " \
    \ brackets = brackets.split(\"\")\n  result = true\n  brackets.each_with_index\
    \ do |char, i|\n    if char == \"(\" && brackets[i + 1] == \")\"\n      brackets[i]\
    \ = \")\"\n      result = false\n    end\n  end\n  result\nend", "  brackets.gsub!(/\\\
    (/, '')\n  brackets.gsub!(/\\)/, '')\n  brackets.gsub!(/\\[/, '')\n  brackets.gsub!(/\\\
    ]/, '')\n  brackets.gsub!(/\\{/, '')\n  brackets.gsub!(/\\}/, '')\n  brackets.gsub!(/\\\
    |/, '')\n  brackets.gsub!(/\\+/, '')\n  brackets.gsub!(/\\-/, '')\n  brackets.gsub!(/\\\
    \\/, '')\n  brackets.gsub!(/[^\\w\\s]/, '')\n  brackets.gsub!(/[\\.\\,\\?\\!\\\
    :\\;\\(\\)\\-]/, '')\n  brackets.gsub!(/[\\.\\,\\?\\!\\:\\;\\(\\)\\-]/, '')\n\
    \  brackets.gsub!(/[\\.\\,\\?\\!\\:\\;\\(\\)\\-]/, '')\n  brackets.gsub!(/[\\\
    .\\,\\?\\!\\:\\;\\(\\)\\-]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\\
    s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\\
    s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\\
    s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\\
    s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\\
    s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\\
    s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\\
    s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\\
    s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\\
    s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\s]/, '')\n  brackets.gsub!(/[^a-zA-Z0-9\\\
    s]/, '')\n", "  bracket = brackets[0]\n  if bracket == \"(\" then return correct_bracketing(brackets[1:])\n\
    \  else if bracket == \")\" then return correct_bracketing(brackets[1:])\n  else\
    \ return brackets[0] == brackets[brackets.size - 1]\nend\n</cell>\n<code language=julia-1.2>",
  "    brackets.each do |b|\n        return false unless brackets.gsub(b,\"\").length\
    \ == 0\n    end\n    return true\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>",
  "    brackets = brackets.to_s\n    opening_brackets = brackets.scan(/[a-z\\(]/).count\n\
    \    closing_brackets = brackets.scan(/[a-z\\)])/).count\n    (opening_brackets\
    \ == closing_brackets)\nend", "  brackets = brackets.split(\"\")\n  brackets.each\
    \ do |char|\n    bracket_pos = brackets.index(char)\n    next_bracket = brackets[bracket_pos+1]\n\
    \    if next_bracket == \"(\"\n      brackets[bracket_pos] = \"}\"\n    elsif\
    \ next_bracket == \")\"\n      brackets[bracket_pos] = \"(\"\n    end\n  end\n\
    \  brackets.join(\"\") == brackets\nend\n</code>\n<|/ a tags=recursion,ruby,string\
    \ |>\n<| c |>\nThis is an excellent demonstration of recursion in Ruby. I would\
    \ add one more thing to your answer: your recursive function always returns `true`\
    \ for a \"valid\" input. Add an `else` clause to your `if` statement and you'll\
    \ get an \"invalid\" result back. (And then I'll upvote you.)\n<|/ c |>\n<| c\
    \ |>\nHa. That's a good point, thanks. The only reason I added the else clause\
    \ is because I wasn't sure how I should handle the case when \"()\" was a valid\
    \ input. I added that because that was the only input in the original problem\
    \ description. The recursive function would return false for other inputs. I didn't\
    \ want my answer to get too long.\n<|/ c |>\n<| c |>\nThanks for the explanation\
    \ and solution!\n<|/ c |>\n<| c |>\nI added a second solution as an alternative\
    \ to the second part of the answer if you would like to see a second way to solve\
    \ this problem. :)\n<|/ c |>\n<| a tags=recursion,ruby,string dscore=2 |>\nThe\
    \ solution I suggest is not the fastest, but it is easy to understand, and you\
    \ get the benefit of having seen the recursive case before.\n<code>", "  brackets\
    \ = brackets.to_s\n  stack = []\n  open_count = 0\n  closed_count = 0\n  while\
    \ brackets.length > 0\n    bracket = brackets[0,1]\n    if bracket == \")\"\n\
    \      if open_count == 0\n        close_count += 1\n      open_count -= 1\n \
    \     brackets = brackets[2,1]\n      next if open_count <= 0\n    elsif bracket\
    \ == \"(\"\n      if closed_count == 0\n        open_count += 1\n      closed_count\
    \ += 1\n      brackets = brackets[2,1]\n      next if closed_count <= 0\n    elsif\
    \ bracket == \"[\"\n      brackets = brackets[2,1]\n    elsif bracket == \"]\"\
    \n      brackets = brackets[2,1]\n    else\n      return false\n  end\n  brackets.to_s.length\
    \ == 0 or brackets == \")\"\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for your\
    \ answer. I don't fully understand how to apply it to my code though. Sorry.\n\
    <|/ c |>\n<| a |>\nI came up with the following solution:\n<code>", "  brackets.gsub!(/[\\\
    (\\)]/, '')\n  brackets.gsub!(/\\(/, '(').gsub!(/\\)/, ')')\n  brackets.gsub!(/\\\
    (/, '(').gsub!(/\\)/, ')')\n  brackets.gsub!(/[()]/, '')\n  brackets.gsub!(/\\\
    (/, '(').gsub!(/\\)/, ')')\n  brackets.gsub!(/\\(/, '(').gsub!(/\\)/, ')')\n \
    \ brackets.gsub!(/\\(/, '(').gsub!(/\\)/, ')')\n  brackets.gsub!(/\\(/, '(').gsub!(/\\\
    )/, ')')\n  brackets.gsub!(/\\(/, '(').gsub!(/\\)/, ')')\n  brackets.gsub!(/\\\
    (/, '(').gsub!(/\\)/, ')')\n  brackets.gsub!(/\\(/, '(').gsub!(/\\)/, ')')\n \
    \ brackets.gsub!(/\\(/, '(').gsub!(/\\)/, ')')\n  brackets.gsub!(/\\(/, '(').gsub!(/\\\
    )/, ')')\n  brackets.gsub!(/\\(/, '(').gsub!(/\\)/, ')')\n  brackets.gsub!(/\\\
    (/, '(').gsub!(/\\)/, ')')\n  brackets.gsub!(/\\(/, '(').gsub!(/\\)/, ')')\n \
    \ brackets.gsub!(/\\(/, '(').gsub!(/\\)/, ')')\n  brackets.gsub!(/\\(/, '(').gsub!(/\\\
    )/, ')')\n  brackets.gsub!(/\\(/, '(').gsub!(/\\)/, ')')\n  brackets.gsub!(/\\\
    (/, '(').gsub!(/\\)/, ')')\n  brackets.gsub!(/\\(/, '(').gsub!(/\\)/, ')')\n \
    \ brackets.gsub!(/\\(/, '(').gsub!(/\\)/, ')')\n  brackets.gsub!(/\\(/, '(').gsub!(/\\\
    )/, ')')\n  brackets.gsub!(/\\(/, '(').gsub!(/\\)/, ')')\n  brackets.gsub!(/\\\
    (/, '(').gsub!(/\\)/, ')')\n  brackets.g", "    brackets = brackets.to_s.strip\n\
    \    brackets.gsub!(\"[\", \"(\")\n    brackets.gsub!(\"]\", \")\")\n    brackets.gsub!(\"\
    {\", \"{\")\n    brackets.gsub!(\"}\", \"}\")\n    return brackets.to_s.include?('(')\
    \ && brackets.to_s.include?(')')\nend\n</code>\nAnd here's a ruby version that\
    \ checks for \"(\" and \")\", but not nested brackets:\n<code>", "  brackets.gsub!(\"\
    ()\", \"\")\n  return brackets =~ /\\(/\nend\n</cell>\n<cell>", "  brackets =\
    \ brackets.to_s\n  brackets.gsub!(/\\(/, '')\n  brackets.gsub!(/\\)/, '')\n  brackets.empty?\
    \ && return true\n  bracket_stack = brackets.reverse.chars.map.with_index {|x,\
    \ i| [x, i]}\n  previous_bracket = nil\n  (brackets.gsub(/\\(/, '') != brackets.gsub(/\\\
    )/, '')) && return false\n  brackets.each_char.with_index do |char, index|\n \
    \   next if index >= brackets.size\n    stack = bracket_stack[index - brackets.size\
    \ - 1]\n    return false if stack.last == char\n    previous_bracket = stack.last\
    \ if stack[0] == previous_bracket\n    return false unless stack[0] == char\n\
    \    bracket_stack[index] = stack + [char]\n    stack = bracket_stack[index -\
    \ brackets.size - 1]\n  end\n  bracket_stack[0][-1] == previous_bracket\nend",
  "  bracket_openers = brackets.scan(/\\(/)\n  bracket_closers = brackets.scan(/\\\
    )/)\n  correct_bracket_matching = true\n  for opener, closer in zip(bracket_openers,\
    \ bracket_closers)\n    if closer - opener != 1\n      correct_bracket_matching\
    \ = false\n    end\n  end\n  correct_bracketing\nend", "    return brackets =~\
    \ /\\(.*\\)/ || brackets =~ /\\(.*\\)/\nend", "  brackets.count(\"(\") == 0\n\
    end", "  brackets = brackets.to_s.gsub(/\\(/, '').gsub(/\\)/, '')\n  brackets.reverse!\n\
    \  brackets.each_char.with_index do |char, i|\n    if char !~ /\\(/\n      brackets.replace\
    \ i, 1, char\n    end\n  end\n  brackets.reverse!\n  brackets.empty?\nend", " \
    \ brackets.scan(/\\(/)\n  brackets.scan(/\\)/)\n  brackets.scan(/\\{/)\n  brackets.scan(/\\\
    }/)\n  brackets.scan(/\\[/)\n  brackets.scan(/\\]/)\n  brackets.scan(/\\(/)\n\
    \  brackets.scan(/\\)/)\n  brackets.scan(/\\{/)\n  brackets.scan(/\\}/)\n  brackets.scan(/\\\
    [/)\n  brackets.scan(/\\]/)\n  brackets.scan(/\\(/)\n  brackets.scan(/\\)/)\n\
    \  brackets.scan(/\\{/)\n  brackets.scan(/\\}/)\n  brackets.scan(/\\[/)\n  brackets.scan(/\\\
    ]/)\n  brackets.scan(/\\(/)\n  brackets.scan(/\\)/)\n  return brackets.scan(/\\\
    )/) == brackets.scan(/\\)/)\nend", "  brackets = brackets.chars\n  brackets.reverse\n\
    \  brackets.each_index do |i|\n    if brackets[i] == '('\n      brackets.delete_at\
    \ i\n      break\n    end\n  end\n  brackets.reverse!\n  brackets.all? { |b| b\
    \ == ')' }\nend", "  brackets_set = brackets.to_set\n  brackets_set.add(')')\n\
    \  brackets_set.add(')')\n  brackets_set.add(')')\n  return brackets_set.size\
    \ == 2\nend\n</code>\n<|/ a tags=string,ruby |>\n<| c |>\nThe OP asked for a Ruby\
    \ solution. Why should this one be any good?\n<|/ c |>\n<| c |>\nHis own solution\
    \ is in Ruby. It is a very simple one. I think my code is Ruby too. It is not\
    \ an elegant solution, but is certainly simple and works.\n<|/ c |>\n<| c |>\n\
    I agree with you, but the OP asked for a Ruby solution. No need to down vote me\
    \ for that.\n<|/ c |>\n<| c |>\nI didn't down-vote you. But your solution does\
    \ not solve the problem at all, since `correct_bracketing(\"()())\")` is true\
    \ and should be false. Also it is not a Ruby solution, but a pure Ruby one. That\
    \ is why I down-voted your answer. Sorry.\n<|/ c |>\n<| c |>\nThe OP asked for\
    \ a Ruby solution. Why should this one be any good? I provided a Ruby solution.\
    \ I am not voting you down. Your solution does not solve the problem at all, since\
    \ `correct_bracketing(\"()())\")` is true and should be false. Also it is not\
    \ a Ruby solution, but a pure Ruby one. That is why I down-voted your answer.\
    \ Sorry.\n<|/ c |>\n<| a tags=string,ruby |>\nAnother approach:\n<code>", "  \
    \  stack = []\n    bracket = brackets[0]\n    \n    if brackets.size <= 1\n  \
    \      return True\n    ends_right = brackets[2..-1].include? bracket\n    starts_right\
    \ = brackets[1] == bracket\n    \n    stack.push bracket\n    \n    for i in 1..brackets.size\n\
    \        bracket = brackets[i]\n        \n        if brackets.size <= i\n    \
    \        continue\n            \n        stack.pop\n        \n        stack.push(bracket)\n\
    \        \n        if ends_right && starts_right\n            return false\n \
    \       elsif ends_right && !starts_right\n            return false\n        ends_right\
    \ = brackets[2..-1].include? bracket\n        starts_right = brackets[1] == bracket\n\
    \    end\n    \n    return stack.empty?\nend\n</code>\n<|/ a |>\n<| c |>\nHow\
    \ is this different from the accepted solution? Seems to do the same thing in\
    \ a much more readable way. Did you actually test this?\n<|/ c |>\n<| c |>\nI\
    \ did, but it doesn't really work on the \"(())\" case, which the accepted solution\
    \ does.\n<|/ c |>\n<| c |>\nActually, it does work. I didn't notice you had used\
    \ a different variable name. I just ran your test case in IRB and it works. Try\
    \ it out yourself and you'll see that it works on all cases.\n<|/ c |>\n<| c |>\n\
    Ok, I see what you mean. Didn't read the question carefully enough. The original\
    \ answer had a bug, that allowed it to pass the test case on its own but not in\
    \ IRB. Updated my answer to remove the bug.\n<|/ c |>\n<| c |>\nHm, I still don't\
    \ get it. It's not an issue of whether it works in IRB or not, but rather a problem\
    \ of how to read the test cases. I thought it was obvious that the function should\
    \ return False if `(()` is passed as input, but in fact it returns True on IRB.\
    \ What's wrong here?\n<|/ c |>\n<| a |>\nUsing stacks is inefficient, but this\
    \ solution will work if the brackets are always valid:\n<code>", "  stack = []\n\
    \  opening_brackets = [\")\", \"]\", \"}\"]\n  closing_brackets = [\"(\", \"[\"\
    , \"{\"]\n  stack.push(brackets)\n  while stack.size > 0\n    brackets = stack.pop\n\
    \    closing_brackets.each do |char|\n      if brackets.include?(char)\n     \
    \   if stack.size > 0\n          stack.last << char\n        else\n          return\
    \ false\n        end\n      else\n        stack.last << char\n      end\n    end\n\
    \    opening_brackets.each do |char|\n      if brackets.include?(char)\n     \
    \   if stack.size > 0\n          stack.last << char\n        else\n          return\
    \ false\n        end\n      end\n    end\n  end\n  true\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nA variant of this answer is that of Rob Waldman, using an explicit\
    \ stack. As long as it's fairly small, it won't blow the stack for long strings.\
    \ You still have the issue of nested brackets, but that's pretty easy to solve.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  brackets.split(\"\").all? { |x| x == \"\
    (\" || x == \"[\" || x == \"{\" || x == \"}\" }\nend", "  brackets.gsub!(/[\\\
    (|\\)]/, \"\")\n  brackets.gsub!(/([^\\(\\)])/, '\\1')\n  brackets.gsub!(/([^\\\
    (]\\))/, '\\1')\n  brackets.gsub!(/\\(([^\\(\\)])/, '\\1')\n  brackets.gsub!(/\\\
    (([^\\)]\\))/, '\\1')\n  brackets.gsub!(/([^\\(]\\))/, '\\1')\n  brackets.gsub!(/\\\
    (([^\\(\\)]\\))/, '\\1')\n  brackets.gsub!(/([^\\(]\\))/, '\\1')\n  brackets.gsub!(/\\\
    (([^\\(\\)]\\))/, '\\1')\n  brackets.gsub!(/\\(([^\\)]\\))/, '\\1')\n  brackets.gsub!(/([^\\\
    (\\)]\\))/, '\\1')\n  brackets.gsub!(/([^\\(]\\))/, '\\1')\n  brackets.gsub!(/\\\
    (([^\\(\\)]\\))/, '\\1')\n  brackets.gsub!(/([^\\(]\\))/, '\\1')\n  brackets.gsub!(/\\\
    (([^\\(\\)]\\))/, '\\1')\n  brackets.gsub!(/([^\\(]\\))/, '\\1')\n  brackets.gsub!(/\\\
    (([^\\(\\)]\\))/, '\\1')\n  brackets.gsub!(/\\(([^\\)]\\))/, '\\1')\n  brackets.gsub!(/\\\
    (([^\\)]\\))/, '\\1')\n  brackets.gsub!(/([^\\(\\)]\\))/, '\\1')\n  brackets.gsub!(/\\\
    (([^\\(\\)]\\))/, '\\1')\n  brackets.gsub!(/\\(([^\\)]\\))/, '\\1')\n  brackets.gsub!(/\\\
    (([^\\)]\\))/, '\\1')\n  brackets.gsub!(/([^\\(\\)]\\))/, '\\1')\n  brackets.gsub!(/\\\
    (([^\\(\\)]\\))/, '\\1')\n  brackets.gsub!(/\\(([^\\)]\\))/, '\\1')\n  brackets.gsub!(/([^\\\
    (\\)]\\))/, '\\1')\n  brackets.gsub!(/\\(([^\\(\\)]\\))/, '\\1')\n  brackets.gsub!(/([^\\\
    (\\)]\\))/, '\\1')\n  brackets.gsub!(/\\(([^\\(\\", "  brackets.chars.each_with_index\
    \ do |bracket,i|\n    if bracket == '('\n      next\n    elsif bracket == ')'\n\
    \      if.chars.last() != bracket\n        bracket_matcher = bracket\n       \
    \ break\n      end\n    end\n  end\n  bracket_matcher == brackets\nend", "  bracket_depth\
    \ = 0\n  bracket_string = brackets\n  bracket_stack = []\n  bracket_depth = 0\n\
    \  while bracket_string.length > 0\n    if bracket_string == \"(\"\n      bracket_depth\
    \ += 1\n      bracket_string += \"(\"\n      bracket_stack << bracket_string\n\
    \    elsif bracket_string == \")\"\n      bracket_depth -= 1\n      if bracket_depth\
    \ == 0\n        bracket_string += \")\"\n      elsif bracket_depth < 0\n     \
    \   return false\n      else\n        bracket_string = bracket_stack.pop\n   \
    \   end\n    end\n  end\n  return true\nend", "  return brackets =~ /\\(.*\\)/\
    \ && brackets =~ /\\(.*\\)/\nend\n</code>\n<|/ a dscore=3 tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nIt would be better if you explained the `/` after the `match` and\
    \ why it works. I understand that `/` means a regular expression but I don't see\
    \ what it means here.\n<|/ c |>\n<| a dscore=2 tags=ruby,ruby-on-rails |>\nTo\
    \ be complete I wanted to add an extra answer, to check if there is an odd number\
    \ of parentheses inside parenthesis, as in ((())). I just wanted to add this answer\
    \ in case someone is looking for an answer. I added this answer to my comment\
    \ below, so that there aren't too many comments.\nI came up with this one: \n\
    <code>", "  return brackets =~ /\\(\\)/\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ a |>\nYou can use scan:\n<code>\n\"(()()())\".scan(/\\(|\\)/).length == 2\n\
    </code>\n<|/ a dscore=1 tags=ruby |>\n<| a tags=ruby |>\n<code>", "  brackets\
    \ = brackets.split(\"\")\n  correct_brackets = 0\n  \n  for i in 0...brackets.length\n\
    \    if brackets[i] == \"(\"\n      correct_brackets = correct_brackets + 1\n\
    \      correct_brackets = correct_brackets % 2\n    else\n      correct_brackets\
    \ = correct_brackets - 1\n    end\n    \n    if correct_brackets != 0 and correct_brackets\
    \ != 2\n      return false\n    end\n  end\n  \n  return true\nend", "  bracket_counts\
    \ = brackets.count(\"(\")\n  brackets.gsub!(/[()]/, \"\")\n  return bracket_counts\
    \ != brackets.count(\"(\")\nend", "    brackets.scan(/^[^()]+/)\n    brackets.scan(/\\\
    (/)\n    brackets.scan(/\\)/) \n    brackets.scan(/\\)[^()]+/) \n    brackets.scan(/\\\
    (/) unless brackets.scan(/\\(/)\n    brackets.scan(/\\)/) unless brackets.scan(/\\\
    (/)\n    brackets.scan(/\\)[^()]+/) unless brackets.scan(/\\(/)\n    brackets.scan(/\\\
    (/) unless brackets.scan(/\\(/)\n    brackets.scan(/\\)/) unless brackets.scan(/\\\
    (/)\n    brackets.scan(/\\)[^()]+/) unless brackets.scan(/\\(/)\n    brackets.scan(/\\\
    (/) unless brackets.scan(/\\(/)\n    brackets.scan(/\\)/) unless brackets.scan(/\\\
    (/)\n    return brackets.scan(/\\)/) != nil\nend", "  bracket_count = brackets.count(\"\
    (\")\n  if bracket_count > 0 and bracket_count != brackets.count(\")\")\n    brackets\
    \ = brackets.gsub(\"(()\", \"(\").gsub(\")(\", \")\").gsub(\")()\", \")(\")\n\
    \    bracket_count = brackets.count(\"(\")\n    if bracket_count > 0 and bracket_count\
    \ != brackets.count(\")\")\n      brackets = brackets.gsub(\"()(\", \"(\").gsub(\"\
    )(\", \")\").gsub(\"()()\", \")(\")\n      bracket_count = brackets.count(\"(\"\
    )\n  end\n  bracket_count = brackets.count(\")\")\n  if bracket_count > 0 and\
    \ bracket_count != brackets.count(\"(\")\n    brackets = brackets.gsub(\"(()\"\
    , \"(\").gsub(\")(\", \")\").gsub(\"()(\", \")(\")\n    bracket_count = brackets.count(\"\
    (\")\n  end\n  bracket_count = brackets.count(\"(\")\n  brackets = brackets.gsub(\"\
    )(\", \")(\")\n  return bracket_count == brackets.count(\")\")\nend\n</code>\n\
    <|/ a tags=ruby,regex |>\n<| c |>\nThat's quite nice. Although I believe it's\
    \ `(bracketed string which is not a close paren)*(close paren)` :P Also you might\
    \ want to check your `correct_bracketing` method, there's a `return bracket_count\
    \ == brackets.count(\")\")` which should read `return bracket_count != brackets.count(\"\
    )\")`\n<|/ c |>\n<| a tags=ruby,regex |>\nTry this regex\n<code>\n(?<!\\()(?:\\\
    (|(?<!\\))\\()|(?:\\(|(?!\\))\\))\n</code>\nRuby regex demo\nRuby code:\n<code>\n\
    regex = /(?<!\\()(?:\\(|(?<!\\))\\()|(?:\\(|(?!\\))\\))/\nstr = '(()())()'", " \
    \ # Don't do anything if brackets is an empty string.\n  return brackets.empty?\
    \ or not brackets.length\nend", "  # Write your code here.\n  return false\nend\n\
    </cell>\n<cell>", "  brackets =~ (/(\\()|(\\))/)\n  return brackets.nil?\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\n`brackets =~ (/(\\()|(\\))/)` should work\
    \ as well as `brackets =~ /\\(|\\)/` since `[]` already defines a character class.\n\
    <|/ c |>\n<| c |>\nYou mean `brackets =~ /\\(|\\)/ #=> true`. Or did you mean\
    \ `brackets =~ /(\\()|(\\))/ #=> false`?\n<|/ c |>\n<| c |>\nHmmm, yeah, I realised\
    \ that `[]` defines a character class. I've been wondering what happens when the\
    \ regexp doesn't contain any characters. And I think it does what I had intended\
    \ it to: `/\\(|\\)/.nil? #=> false` - \"an empty string\" is matched against `nil`.\
    \ :-) Now if only I hadn't been so lucky that `nil` didn't have a special meaning\
    \ in my code!\n<|/ c |>\n<| c |>\nNo, `/\\(|\\)/.nil? #=> true`, as expected.\n\
    <|/ c |>\n<| c |>\nThanks for the comments and for all the other responses. I\
    \ appreciate your help!\n<|/ c |>\n<| a |>\nTo detect whether a string is balanced,\
    \ you only need to worry about opening brackets. If a closing bracket is missing,\
    \ the string is unbalanced. \n<code>", "    open_brackets_count = 0\n    close_brackets_count\
    \ = 0\n    if brackets == \"(\"\n        open_brackets_count += 1\n    elsif brackets\
    \ == \")\"\n        close_brackets_count += 1\n    return open_brackets_count\
    \ - close_brackets_count == 0\nend\n</code>\nThe next function will read a file,\
    \ line by line, and split it into tokens. This function will also strip any spaces,\
    \ newlines, and tabs, and convert newlines to \\n.\n<code>", "    stack = []\n\
    \    # Add a new opening bracket if the first character is a new bracket\n   \
    \ # otherwise just continue with the current bracket.\n    if brackets.empty?\
    \ or brackets.first[0] != brackets.first[1]\n      stack << brackets.first\n \
    \   end\n    \n    # Keep going through the string and adding new brackets until\
    \ no more\n    # new brackets are found.\n    until stack.empty?\n      brackets\
    \ = stack.shift\n      # If the current bracket doesn't have a corresponding closing\
    \ bracket,\n      # then add the current bracket to the stack and move to the\
    \ next one\n      # otherwise add the closing bracket.\n      if brackets.empty?\
    \ or brackets.first[0] != brackets.first[1]\n        stack << brackets.first\n\
    \      else\n        stack << brackets.last\n      end\n    end\n    # Return\
    \ false if no brackets were added to the stack.\n    stack.empty?\n  end\n  \n\
    \  # Return a new string where all spaces in the original string are replaced\
    \ \n  # with underscores. \n  # >>> space_string = \"hi      how     are     you\"\
    \n  # >>> space_string.splat_words_to_underscores\n  # \"hi_how_are_you\"\n  #\
    \ \n  # See also: underscores_to_words\n  def splat_words_to_underscores\n   \
    \ self.gsub(\" \", \"_\").gsub(/\\W+/, \"_\").downcase\n  end\n  \n  # Return\
    \ a new string where all dashes in the original string are replaced \n  # with\
    \ underscores. \n  # >>> dashed_string = \"hi--how---are--you\"\n  # >>> dashed_string.splat_words_to_underscores\n\
    \  # \"hi_how_are_you\"\n  # \n  # See also: underscores_to_words\n  def splat_dashes_to_underscores\n\
    \    self.gsub(\"-\", \"_\").gsub(/\\W+/, \"_\").downcase\n  end", "  brackets.chars.inject(0)\
    \ { |sum, char| sum + 1 if char == brackets[0] } == 0\nend", '    return brackets
    =~ /^\(.*\)$/ and brackets =~ /^\(\(.*\)\)$/', "  brackets.scan(/^(.*[^ ])(.*)/).each\
    \ {\n    first, second = $1, $2\n    first = first.scan(/^(.*[^ ])/).join('')\n\
    \    second = second.scan(/^(.*[^ ])/).join('')\n    first =~ /^[({\\[])/ && second\
    \ =~ /^[)}\\]]/ ? false : true\n  }\nend\n</code>\n<|/ a dscore=3 tags=string,ruby,regex\
    \ |>\n<| c |>\nNice answer. Although it may look like a hack to solve this problem,\
    \ the real problem is that regex is NOT designed for such problems and regex is\
    \ the wrong tool for this job.\n<|/ c |>\n<| c |>\nI realized that a similar problem\
    \ was asked here: http://stackoverflow.com/questions/252459/regular-expression-to-match-outer-brackets/252510#252510",
  "  brackets = brackets.to_s\n  brackets.reverse\n  brackets.each_char.with_index\
    \ do |char, index|\n    if char == \"(\" && brackets[index-1] != \"\\\\\"\n  \
    \    return false\n    elsif char == \")\" && brackets[index+1] != \"\\\\\"\n\
    \      return false\n    end\n  end\n  return true\nend\n</code>\n<|/ a |>\n<|\
    \ a |>\nFor this one, I think regex is overkill. Here's a very simple approach\
    \ to solve the problem. \nI used an Array of strings and then used a combination\
    \ of map() and reduce() to get the desired result. \n<code>", "    bracket_count\
    \ = {}\n    open_count = 1\n    close_count = 1", "  # initialize a variable to\
    \ be the boolean value False\n  correct_bracketing = False\n  # initialize the\
    \ index variable to be 0\n  index = 0\n  # initialize an empty array that will\
    \ hold all the brackets\n  brackets = []\n  # initialize a boolean value that\
    \ will be True if the brackets\n  # array is empty.\n  empty_brackets_array =\
    \ False", "  bracket_count = 0\n  opening_brackets = brackets.count('(')\n  closing_brackets\
    \ = brackets.count(')')\n  while bracket_count < opening_brackets\n    bracket_count\
    \ = bracket_count + 1\n    brackets = brackets.gsub('(', '(bracket_#{') \n   \
    \ brackets = brackets.gsub(')', '})')\n  while bracket_count < closing_brackets\n\
    \    bracket_count = bracket_count + 1\n    brackets = brackets.gsub('{', '(open_#{')\
    \ \n    brackets = brackets.gsub('}', ')}open_#{') \n    brackets = brackets.gsub('(open_#{'',\
    \ '((') \n    brackets = brackets.gsub(')open_#{'', ')((') \n    brackets = brackets.gsub(')',\
    \ '))')\n  bracket_count = bracket_count - 1\n  brackets = brackets.gsub('(',\
    \ '(') \n  brackets = brackets.gsub(')', ')')\n  return brackets == ''\nend #correct_bracketing",
  "  return brackets =~ /\\(.*\\)/m\nend\n</pre>", "  # Your code here\n  return true",
  "  return brackets =~ /\\(/g && brackets =~ /\\)/g\nend", "  brackets.gsub!(/(\\\
    (|\\))/, '')\n  brackets.gsub!('()', '')\n  brackets.gsub!('[]', '')\n  brackets.gsub!('{}',\
    \ '')\n  brackets.gsub!('{}', '')\n  brackets.gsub!('}', '')\n  brackets.gsub!('[]',\
    \ '')\n  brackets.gsub!('()', '')\n  brackets.gsub!('{}', '')\n  brackets.gsub!('[]',\
    \ '')\n  brackets.gsub!('}', '')\n  brackets.gsub!('()', '')\n  brackets.gsub!('()',\
    \ '')\n  brackets.gsub!('[]', '')\n  brackets.gsub!('{}', '')\n  brackets.gsub!('{}',\
    \ '')\n  brackets.gsub!('}', '')\n  brackets.gsub!('{}', '')\n  brackets.gsub!('[]',\
    \ '')\n  brackets.gsub!('{}', '')\n  brackets.gsub!('{}', '')\n  brackets.gsub!('}',\
    \ '')\n  brackets.gsub!('[]', '')\n  brackets.gsub!('{}', '')\n  brackets.gsub!('{}',\
    \ '')\n  brackets.gsub!('[]', '')\n  brackets.gsub!('}', '')\n  brackets.gsub!('()',\
    \ '')\n  brackets.gsub!('[]', '')\n  brackets.gsub!('{}', '')\n  brackets.gsub!('{}',\
    \ '')\n  brackets.gsub!('[]', '')\n  brackets.gsub!('()', '')\n  brackets.gsub!('[]',\
    \ '')\n  brackets.gsub!('{}', '')\n  brackets.gsub!('{}', '')\n  brackets.gsub!('[]',\
    \ '')\n  brackets.gsub!('()', '')\n  brackets.gsub!('{}', '')\n  brackets.gsub!('[]',\
    \ '')\n  brackets.gsub!('}', '')\n  brackets.gsub!('{}', '')\n  brackets.gsub!('[]',\
    \ '')\n  brackets.gsub!('()', '')\n  brackets.gsub!('{}', '')\n  brackets.gsub!('[]',\
    \ '')\n  brackets.gsub!('()', '')\n  brackets.gsub!('[]', '')\n  brackets.gsub!('{}',\
    \ '')\n  brackets.gsub!('{}', '')\n  brackets.gsub!('[]', '')", "  brackets =\
    \ brackets.to_s\n  opening_counts = brackets.scan(/\\(/).to_h\n  closing_counts\
    \ = brackets.scan(/\\)/).to_h\n  correct_counts = opening_counts - closing_counts\n\
    \  correct_brackets = brackets.scan(/\\(+/).inject(0) { |sum, string| sum + 1\
    \ } == 0\n  correct_brackets = correct_brackets && brackets.scan(/\\(+/).inject(0)\
    \ { |sum, string| sum + 1 } == 0\n  correct_brackets = correct_brackets && brackets.scan(/\\\
    (/).inject(0) { |sum, string| sum + 1 } == 0\n  correct_brackets = correct_brackets\
    \ && brackets.scan(/\\(/).inject(0) { |sum, string| sum + 1 } == 0\n  correct_brackets\
    \ = correct_brackets && brackets.scan(/\\(+/).inject(0) { |sum, string| sum +\
    \ 1 } == 0\n  correct_brackets = correct_brackets && brackets.scan(/\\(/).inject(0)\
    \ { |sum, string| sum + 1 } == 0\n  correct_brackets = correct_brackets && brackets.scan(/\\\
    (+/).inject(0) { |sum, string| sum + 1 } == 0\n  correct_brackets = correct_brackets\
    \ && brackets.scan(/\\(+/).inject(0) { |sum, string| sum + 1 } == 0\n  correct_brackets\
    \ = correct_brackets && brackets.scan(/\\(/).inject(0) { |sum, string| sum + 1\
    \ } == 0\n  correct_brackets = correct_brackets && brackets.scan(/\\(+/).inject(0)\
    \ { |sum, string| sum + 1 } == 0\n  correct_brackets = correct_brackets && brackets.scan(/\\\
    (+/).inject(0) { |sum, string| sum + 1 } == 0\n  correct_brackets = correct_brackets\
    \ && brackets.scan(/\\(/).inject(0) { |sum, string| sum + 1 } == 0\n  correct_brackets\
    \ = correct_brackets && brackets.scan(/\\(+/).inject(0) { |sum, string| sum +\
    \ 1 } == 0\n  correct_brackets = correct_brackets && brackets.scan(/\\(/).inject(0)\
    \ { |sum, string| sum + 1 } == 0\n  correct_brackets = correct_brackets && brackets.scan(/\\\
    (+/).inject(0) { |sum, string| sum + 1 } == 0\n  correct_brackets = correct_brackets\
    \ && brackets.scan(/\\(+/).inject(0) { |sum, string| sum + 1 } == 0", "  return\
    \ !brackets.scan(/[\\(\\)]/).empty?\nend\n</code>\n<|/ a tags=ruby,regex dscore=5\
    \ |>\n<| c |>\n`scan(/[\\(\\)]/)` should be `scan(/[\\(\\)]+/)` if you need to\
    \ match empty brackets. However, you might want to change it to `scan(/\\((?!\\\
    ))/)` as this lookahead is non-greedy and will prevent it from matching too much\
    \ or too little brackets.\n<|/ c |>\n<| c |>\nGreat answer! One addition is that\
    \ if you need to check brackets in arbitrary positions, you can just do `brackets.scan(/\\\
    ((?!\\))/).none?`\n<|/ c |>\n<| c |>\nIt would be better if you add `+?` after\
    \ each `(\\)`: `brackets.scan(/\\(\\+?(?!\\))/).none?`\n<|/ c |>\n<| c |>\nWhat\
    \ about `correct_bracketing(\"()\") #=> true`? I think your solution should return\
    \ `false`\n<|/ c |>\n<| c |>\nThanks for asking. I edited my answer to cover that\
    \ case, and I added some additional comments to the code (at the bottom) to explain\
    \ what each part of it is doing.\n<|/ c |>\n<| a tags=ruby,regex dscore=5 |>\n\
    Just in case somebody is using Ruby 2.2+, you can do this: \n<code>\n'(test)(test)'.gsub(/\\\
    ((.*?)\\)/) { |x| x.count('(') - x.count(')') }\n</code>\n<|/ a |>\n<| c |>\n\
    That's a nice one-liner. Just in case: `'(test)(test)'.gsub(/\\(/, \"\").gsub(/)/,\
    \ \"\").count('(')`\n<|/ c |>\n<| c |>\nThe question is not tagged with a Ruby\
    \ version, so I posted this as a one-liner :)\n<|/ c |>\n<| c |>\nI like this\
    \ solution. I'm wondering if the regex could be written more elegantly but this\
    \ works really well.\n<|/ c |>\n<| c |>\nHow would you add support for nested\
    \ brackets? e.g. `'((test)(test))'`.\n<|/ c |>\n<| c |>\n: I suppose you would\
    \ be able to use nested brackets as well by simply using a non-greedy quantifier\
    \ instead of `*`. `/(\\((.*?\\", "  brackets.chars.each_with_index.all? { |bs,\
    \ i| bs != brackets[i] }\nend", "  return brackets.empty? and brackets =~ /\\\
    (/ or brackets =~ /\\)/\nend", "  brackets = brackets.chomp\n  brackets = brackets.gsub(\"\
    ()\", \"\")\n  brackets = brackets.gsub(\"[]\", \"\")\n  brackets = brackets.gsub(\"\
    {}\", \"\")\n  brackets = brackets.gsub(\"[]\", \"\")\n  brackets = brackets.gsub(\"\
    ()\", \"\")\n  brackets = brackets.gsub(\"(\", \"\")\n  brackets = brackets.gsub(\"\
    )\", \"\")\n  brackets = brackets.gsub(\"{}\", \"\")\n  brackets = brackets.gsub(\"\
    []\", \"\")\n  brackets = brackets.gsub(\"{}\", \"\")\n  brackets = brackets.gsub(\"\
    ()\", \"\")\n  brackets = brackets.gsub(\"(\", \"\")\n  brackets = brackets.gsub(\"\
    )\", \"\")\n  brackets = brackets.gsub(\"{\", \"\")\n  brackets = brackets.gsub(\"\
    }\", \"\")\n  brackets = brackets.gsub(\"[]\", \"\")\n  brackets = brackets.gsub(\"\
    []\", \"\")\n  brackets = brackets.gsub(\"()\", \"\")\n  brackets = brackets.gsub(\"\
    )\", \"\")\n  brackets = brackets.gsub(\"(\", \"\")\n  brackets = brackets.gsub(\"\
    )\", \"\")\n  brackets = brackets.gsub(\"{\", \"\")\n  brackets = brackets.gsub(\"\
    }\", \"\").strip\n  brackets = brackets.gsub(\"{\", \"\")\n  brackets = brackets.gsub(\"\
    }\", \"\").strip\n  brackets = brackets.gsub(\"[]\", \"\")\n  brackets = brackets.gsub(\"\
    []\", \"\")\n  brackets = brackets.gsub(\"()\", \"\")\n  brackets = brackets.gsub(\"\
    )\", \"\")\n  brackets = brackets.gsub(\"(\", \"\")\n  brackets = brackets.gsub(\"\
    )\", \"\")\n  brackets = brackets.gsub(\"{\", \"\")\n  brackets = brackets.gsub(\"\
    }\", \"\").strip\n  brackets = brackets.gsub(\"]\", \"\")\n  brackets = brackets.gsub(\"\
    [\", \"\")\n  brackets = brackets.gsub(\"]\", \"\")\n  brackets = brackets.gsub(\"\
    ()\", \"\")\n  brackets = brackets.gsub(\")\", \"\")\n  brackets = brackets.gsub(\"\
    (\", \"\")\n  brackets = brackets.gsub(\")\", \"\")\n  brackets = brackets.gsub(\"\
    {\", \"\")\n  brackets = brackets.gsub(\"}\", \"\").strip\n  brackets = brackets.gsub(\"\
    ]\", \"\")\n  brackets = brackets.gsub(\"[\", \"\")\n  brackets = brackets.gsub(\"",
  "  brackets.gsub!(/(\\(([^()]*)\\))/) {|m| m.gsub(/\\(([^()]*)\\)/, '\\1')}\n  brackets.gsub!(/(\\\
    ([^()]*\\))/) {|m| m.gsub(/\\([^()]*\\)/, '\\1')}\n  brackets.gsub!(/(\\[[^\\\
    [\\]]*\\])/) {|m| m.gsub(/\\[[^\\[\\]]*\\]/, '\\1')}\n  brackets.gsub!(/[\\[\\\
    ]\\(\\)]/, '')\n  brackets.gsub!(/^[^\\(]*\\(([^\\)]*)\\)[^\\)]*/, '\\1')\n  brackets.gsub!(/^[^\\\
    (]*\\([^\\)]*\\)[^\\)]*/, '\\1')\n  brackets.gsub!(/[^\\(\\)]*$/, '')\n  brackets.gsub!(/\\\
    (/, '[')\n  brackets.gsub!(/\\)/, ']')\n  brackets.gsub!(/\\[[^\\[\\]]*\\]/, '[]')\n\
    \  brackets.gsub!(/\\(.*\\)/, '[]')\n  brackets.gsub!(/[^\\(\\)]*$/, '[]')\n \
    \ brackets.gsub!(/\\[([^\\[\\]]*)\\]/, '[]')\n  brackets.gsub!(/\\[[^\\[\\]]*\\\
    ]/, '[]')\n  brackets.gsub!(/(\\[|\\])/, '')\n  brackets.gsub!(/(\\(|\\))/, '')\n\
    \  brackets.gsub!(/(\\[|\\]\\))/, '')\n  brackets.gsub!(/(\\(|\\)|\\[|\\])/, '')\n\
    \  brackets.gsub!(/(\\[|\\])/, '[]')\n  brackets.gsub!(/(\\)|\\[|\\]\\)/, '[]')\n\
    \  brackets.gsub!(/(\\[|\\])/, '[]')\n  brackets.gsub!(/(\\)|\\[|\\]\\)/, '[]')\n\
    \  brackets.gsub!(/(\\[|\\])/, '[]')\n  brackets.gsub!(/(\\)|\\[|\\]\\)/, '[]')\n\
    \  brackets.gsub!(/]/, '[]')\n  brackets.gsub!(/]/, '[]')\n  brackets.gsub!(/]$/,\
    \ '')\n  brackets.gsub!(/]$/, '')\n  brackets.gsub!(/\\[/, '(')\n  brackets.gsub!(/\\",
  "  brackets.scan(/[()]/) {|match| return false }\n  brackets.scan(/[(]/) {|match|\
    \ return false }\n  brackets.scan(/[)]/) {|match| return false }\n  brackets.scan(/[)]/)\
    \ {|match| return false }\n  true\nend", "  brackets.to_s.each_char.any? do |char|\n\
    \    char =~ /\\(/ || char =~ /\\)/ || char == '(' || char == ')'\n  end\nend\n\
    </code>\n<|/ a tags=string,ruby,boolean |>\n<| a dscore=2 |>\n<code>", "  brackets.each_char{|c|\n\
    \    return false unless c == \")\"\n    return false unless next_bracket?(c)\
    \ == false\n  }\n  true\nend", "  brackets.chars.each_with_index do |char, index|\n\
    \    if char == \"(\"\n      return true if index == 0\n      next true if index\
    \ == 1\n      return true if index == 2\n      next true if index == 3\n     \
    \ return true if index == 4\n      next true if index == 5\n      return true\
    \ if index == 6\n    end\n  end\n  return false\nend", "  brackets.gsub!(\"()\"\
    , \"\") # remove paired brackets\n  brackets.gsub!(\"[]\", \"\") # remove unpaired\
    \ brackets\n  brackets.gsub!(\"{}\", \"\") # remove unpaired brackets\n  brackets.gsub!(\"\
    []{\", \"\") # remove unpaired brackets\n  brackets.gsub!(\"{}]\", \"\") # remove\
    \ unpaired brackets\n  return brackets !~ /\\(.*\\)/\nend\n</code>\n<|/ a tags=ruby,string,brackets\
    \ |>\n<| a tags=ruby,string,brackets |>\n<code>", "  # Only change brackets if\
    \ they're inside parentheses.\n  return brackets.count \"(\" == brackets.count\
    \ \")\"\nend\n</code>\n<|/ a tags=parsing,ruby,regex |>\n<| c |>\nWhat does it\
    \ do if I have nested brackets?\n<|/ c |>\n<| c |>\nIt handles nested parentheses.\
    \ Try `correct_bracketing(\"(foo(bar(foo())))\")`.\n<|/ c |>\n<| a dscore=0 |>\n\
    If your brackets are balanced, you can simply use regular expression:\n<code>\n\
    /\\(.*?\\)/\n</code>\n<|/ a tags=parsing,ruby,regex |>\n<| c |>\nThis doesn't\
    \ solve the problem of nested parens.\n<|/ c |>\n<| c |>\n: how do you interpret\
    \ `nested parens`?\n<|/ c |>\n<| c |>\nNested parens as in nested parentheses,\
    \ not nested parentheses as in nested brackets.\n<|/ c |>\n<| c |>\n: sorry, I\
    \ don't know ruby... in python you could use `re.match(r'\\(.*?\\)', str)`, but\
    \ this would not be efficient...\n<|/ c |>\n<| a |>\nA little late but here it\
    \ is:\n<code>", "    stack = bracket_stack\n    stack.length = 0\n    stack.push(brackets)\n\
    \    open_bracket = brackets\n    while (open_bracket && stack.count > 0)\n  \
    \      open_bracket = stack.pop()\n        if open_bracket != \")\"\n        \
    \    # We're not at the first closing bracket, so we\n            # must have\
    \ found at least one matching opening bracket.\n            # All brackets must\
    \ be in the same column.\n            if stack.count > 0\n                # The\
    \ opening bracket must match the last\n                # non-matching closing\
    \ bracket.\n                matching_bracket = stack.pop\n                open_bracket\
    \ = matching_bracket\n            else\n                # There were no matching\
    \ brackets, since we are\n                # not at the first closing bracket.\n\
    \                # If the brackets are in the same column, then\n            \
    \    # the closing bracket must also be in the same column.\n                #\
    \ For example, if the closing bracket is \"(\", and the\n                # opening\
    \ brackets are \"[\", \"[\", and \"(\" in the same column,\n                #\
    \ then \"[\" must be the matching bracket.\n                return false\n   \
    \     end\n    end\n    return true\nend\n</cell>\n<code language=julia-1.4>",
  "  brackets.gsub!(/^\\((.+)\\)\\$/,\"\")\n  brackets.gsub!(/^\\((.+)\\)$/,\"\")\n\
    \  brackets.gsub!(/^\\((.+)\\)\\(/,\"\")\n  brackets.gsub!(/^\\((.+)\\)\\)/,\"\
    \")\n  brackets.gsub!(/^\\((.+)\\)/,\"(\" + brackets + \")\")\n  brackets.gsub!(/^\\\
    ((.+)\\)\\[/,\")(\"+brackets+\")(\")\n  brackets.gsub!(/^\\((.+)\\)\\]/,\"(\"\
    +brackets+\")\"+\")\")\n  brackets.gsub!(/^\\((.+)\\)\\{/,\")(\"+brackets+\"){\"\
    )\n  brackets.gsub!(/^\\((.+)\\)\\}/,\"(\"+brackets+\")\"+\"}\")\n  return brackets\
    \ =~ /^\\((.+)\\)/\nend", "  brackets.each do |b|\n    if b == \"(\"\n      if\
    \ not (stack[stack.length-1] == \"(\")\n        stack.push \"(\"\n      end\n\
    \    elsif b == \")\"\n      if not (stack[stack.length-1] == \")\")\n       \
    \ stack.pop\n      end\n    end\n  end\nend\n</code>\n<|/ a tags=arrays,ruby,stack\
    \ |>\n<| c |>\nI like it, but it gives me an error: NoMethodError: undefined method\
    \ `each' for \"()()\":String\n<|/ c |>\n<| c |>\nYeah, that's what I get for trying\
    \ to be quick.  I'll fix it up.  It was a little too quick when I did it :)\n\
    <|/ c |>\n<| a tags=arrays,ruby,stack dscore=0 |>\nThis question was asked in\
    \ an interview.  I solved it in a different way using the following approach.",
  "  brackets.split('').reverse.map {|x| x == ')' && x != '(' ? false : x == '(' ?\
    \ true : false}.all?\nend", "  return brackets.split(/\\(|\\)|\\[|\\]/).all? {\
    \ |x| x.match(/\\(|\\)|\\[|\\]|\\?/) }\nend", "  opening_count = 1\n  i = 0\n\
    \  while i < brackets.length\n    if brackets[i] == '('\n      opening_count +=\
    \ 1\n    elsif brackets[i] == ')'\n      if opening_count > 0\n        opening_count\
    \ -= 1\n      elsif opening_count == 0\n        return false\n      end\n    end\n\
    \    i += 1\n  end\n  false\nend", "  opening = brackets.count(\"(\")\n  closing\
    \ = brackets.count(\")\")\n  return opening+closing == brackets.length\nend\n\
    </pre>", "    brackets.scan(/\\(/) do |char|\n        if char == \")\"\n     \
    \       return true\n        else\n            return false\n        end\n   \
    \ end\n    false\nend\n</code>\n<|/ a dscore=0 tags=ruby,regex |>\n<| a |>\n<code>",
  "  brackets.gsub!(/^\\((.+?)\\)$/) {|m| m[1][1..-1] == m[1][-1..-1] }\n  brackets.gsub!(/^\\\
    ((.+?)\\)$/) {|m| m[1][1..-1] == m[1][-1..-1] }\n  brackets.gsub!(/^\\((.+?)\\\
    )$/) {|m| m[1][1..-1] == m[1][-1..-1] }\n  brackets.gsub!(/^\\((.+?)\\)$/) {|m|\
    \ m[1][1..-1] == m[1][-1..-1] }\n  brackets.gsub!(/^\\((.+?)\\)$/) {|m| m[1][1..-1]\
    \ == m[1][-1..-1] }\n  brackets.gsub!(/^\\((.+?)\\)$/) {|m| m[1][1..-1] == m[1][-1..-1]\
    \ }\n  brackets.gsub!(/^\\((.+?)\\)$/) {|m| m[1][1..-1] == m[1][-1..-1] }\n  brackets.gsub!(/^\\\
    ((.+?)\\)$/) {|m| m[1][1..-1] == m[1][-1..-1] }\n  brackets.gsub!(/^\\((.+?)\\\
    )$/) {|m| m[1][1..-1] == m[1][-1..-1] }\n  brackets.gsub!(/^\\((.+?)\\)$/) {|m|\
    \ m[1][1..-1] == m[1][-1..-1] }\n  brackets.gsub!(/^\\((.+?)\\)$/) {|m| m[1][1..-1]\
    \ == m[1][-1..-1] }\n  brackets.gsub!(/^\\((.+?)\\)$/) {|m| m[1][1..-1] == m[1][-1..-1]\
    \ }\n  brackets.gsub!(/^\\((.+?)\\)$/) {|m| m[1][1..-1] == m[1][-1..-1] }\n  brackets.gsub!(/^\\\
    ((.+?)\\)$/) {|m| m[1][1..-1] == m[1][-1..-1] }\n  brackets.gsub!(/^\\((.+?)\\\
    )$/) {|m| m[1][1..-1] == m[1][-1..-1] }\n  brackets.gsub!(/^\\((.+?)\\)$/) {|m",
  "  brackets = brackets.chars.to_a\n  brackets.each do |c|\n    next if c.nil? or\
    \ c == ?(\n    return false if c != ?(\n    stack.push c\n  end\n  true\nend\n\
    </code>\nThis also gives you access to the number of opening brackets, and their\
    \ position in the string. These two things are often useful.\n<code>", "  brackets\
    \ = brackets.to_s\n  \n  brackets.reverse\n  bracket_string = brackets.reverse.chars.to_s\n\
    \  \n  brackets.reverse\n  open_brackets = brackets.reverse.chars.chars.to_s\n\
    \  \n  bracket_count = 0\n  open_brackets.reverse\n  \n  open_brackets.each do\
    \ |c|\n    bracket_count += 1\n    bracket_count -= 1 if c == open_brackets[bracket_count]\n\
    \  end\n  \n  bracket_count == 0\nend", "  brackets_count = 0\n  if brackets.empty?\n\
    \    brackets_count <= 1\n  else\n    brackets.each do |char|\n      case char\n\
    \      when \"(\" then brackets_count += 1\n      when \")\" then brackets_count\
    \ -= 1\n      end\n    end\n    brackets_count == 0\n  end\nend", "  bracket_open\
    \ = brackets.count(\"(\")\n  bracket_close = brackets.count(\")\")\n  brackets_checked\
    \ = 0\n  \n  while brackets_checked < bracket_open\n    if brackets[brackets_checked]\
    \ == \")\"\n      brackets_checked += 1\n      while brackets_checked < bracket_open\
    \ and brackets[brackets_checked] == \")\"\n        brackets_checked += 1\n   \
    \   return bracket_close != brackets_checked\n    end\n    brackets_checked +=\
    \ 1\n  end\n  \n  return false\nend", "  opening_brackets = brackets[0..0]\n \
    \ closing_brackets = brackets[1..-1]\n  opening_brackets.each_char.with_object([]).with_index.with_object([]).with_index\
    \ do |char, open_parentheses, index, open_paren_stack|\n    if open_paren_stack.include?(char)\n\
    \      return false\n    else\n      open_paren_stack.push(char)\n    end\n  end\
    \ == closing_brackets\nend\n</code>\n<|/ a |>\n<| a tags=ruby dscore=0 |>\n<code>",
  "  brackets.scan(/\\(|\\)/ do |x|\n    return !(brackets.index(x) == brackets.rindex(x))\
    \ if brackets.index(x) < brackets.rindex(x)\n    true\n  end).empty?\nend", " \
    \ brackets.each_char {|b|\n    next if b == '(' or b == '['\n    return false\
    \ if b == '['\n    return false if b == ')'\n    return true unless b == ']'\n\
    \  }\n  false\nend\n</code>\nThis uses the each_char method of strings which returns\
    \ an enumerator. each_char works like map but yields the character instead of\
    \ changing the original string value. In this case I chose to return the character\
    \ itself and the block will continue to operate on the string until it comes across\
    \ the next character.\nThe next method skips the remainder of the block, so if\
    \ b doesn't match the first or last character of the string, we return false.\
    \ Otherwise we return true.\n<|/ a tags=ruby,string-matching,regex |>\n<| c |>\n\
    Whoa, I never knew about `Enumerator` - that's awesome. I'll have to remember\
    \ that!\n<|/ c |>\n<| c |>\nWhoa, awesome use of Enumerators! I actually used\
    \ this code in another function I was writing but this was very elegant. Thanks.\n\
    <|/ c |>\n<| a |>\nYou could use recursion and a regex:\n<code>", "    brackets\
    \ = brackets.split(\"\")\n    return brackets.all? { |x| x.equal? \")\" } && brackets.all?\
    \ { |x| x.equal? \"(\" }\nend\n</code>\n<|/ a tags=ruby dscore=3 |>\n<| c |>\n\
    Thank you. I didn't know about `all?`.\n<|/ c |>\n<| a |>\nHere is my solution:\n\
    <code>", "    bracket_stack = []\n    opening_brackets = 0\n    for c in brackets\n\
    \        opening_brackets += c if c == \"(\" else -1\n        closing_brackets\
    \ = -1 if c == \"(\" else c if c == \"(\" else 1\n        if opening_brackets\
    \ <= closing_brackets\n            if c == \"(\" and opening_brackets == 0\n \
    \               bracket_stack.pop\n            elsif c == \")\" and closing_brackets\
    \ == 0\n                bracket_stack.push c\n            elsif opening_brackets\
    \ == 0\n                bracket_stack.push c\n            else bracket_stack.push\
    \ c\n        end\n    end\n    return bracket_stack.size == 0\nend", "    stack\
    \ = []\n    bracket = brackets[0]\n    opening_brackets = 0\n    closing_brackets\
    \ = 0\n    index = 0\n    while index < brackets.length\n        if brackets[index]\
    \ == bracket\n            opening_brackets += 1\n        else\n            closing_brackets\
    \ += 1\n            stack << bracket\n        end\n        index += 1\n    end\n\
    \    closing_brackets == opening_brackets and return true\n    stack.size == 0\
    \ and return false\n    return stack.size == closing_brackets and return true\n\
    end", "  brackets.scan(/\\(/)\n  brackets.scan(/\\)/)\n  brackets.scan(/\\(\\\
    (/)\n  brackets.scan(/\\)\\)/)\n  return brackets.empty?\nend", "  brackets.split(\"\
    \").each_with_index do |char, i|\n    return false if char == \")\" && (i != 0\
    \ || brackets.include?(\"(\"))\n    return false if char == \"(\" && brackets.include?(\"\
    )\")\n  end\n  true\nend", "  bracketing = false\n  bracketing ||= brackets =~\
    \ /\\(/ ? true : false\n  bracketing ||= brackets =~ /\\)/  ? true : false\n \
    \ bracketing\nend", "    brackets = brackets.split(//).join\n    brackets = brackets.gsub(')',')(').gsub('(','(')\n\
    \    return brackets =~ /\\(/\nend", "  brackets.gsub!( /[()]/ ) { \"(\" + $&\
    \ + \")\" }\n  brackets.gsub!( /([)]/) { $& + \")\" }\n  brackets.gsub!( /([()])/\
    \ ) { \"(\" + $& + \"())\" }\n  brackets.gsub!( /([)(])/ ) { \"(\" + $& + \"())\"\
    \ }\n  brackets.gsub!( /(()()/) ) { $& }\n  brackets.gsub!( /([)(])/) { $& }\n\
    \  brackets.gsub!( /([{}])/ ) { \"(\" + $& + \")\" }\n  brackets.gsub!( /([(){}])/\
    \ ) { \"(\" + $& + \")\" }\n  brackets.gsub!( /([()(){}])/ ) { \"(\" + $& + \"\
    )\" }\n  brackets.gsub!( /([{}()])/ ) { \"(\" + $& + \"())\" }\n  brackets.gsub!(\
    \ /([{}])/) { $& + \")\" }\n  brackets.gsub!( /([{}])/) { $& + \")\" }\n  brackets.gsub!(\
    \ /([{])/ ) { \"(\" + $& + \"())\" }\n  brackets.gsub!( /([)])/ ) { $& + \"())\"\
    \ }\n  brackets.gsub!( /([)])/ ) { $& + \"())\" }\n  brackets.gsub!( /(()()/)\
    \ ) { $& }\n  brackets.gsub!( /(()())/ ) { $& }\n  brackets.gsub!( /([)])/) {\
    \ $& }\n  brackets.gsub!( /([)])/) { $& }\n  brackets.gsub!( /([{])/) { $& }\n\
    \  brackets.gsub!( /([{])/) { $& }\n  brackets.gsub!( /([()])/ ) { $& + \"())\"\
    \ }\n  brackets.gsub!( /([(])/ ) { $& + \"())\" }\n  brackets.gsub!( /([(])/ )\
    \ { $& + \"())\" }\n  brackets.gsub!( /([{}])/ ) { $& + \"())\" }\n  brackets.gsub!(\
    \ /([{}])/ ) { $& + \"())\" }\n  brackets.gsub!( /([{])/) { $& }", "  brackets.scan(/[^()]+/).all?\
    \ { |char| char == \")\" } && brackets.scan(/[^()]+/).all? { |char| char == \"\
    (\" } ? true : false\nend", "    brackets = brackets.strip\n    \n    opening_brackets\
    \ = {')', '}', ']'}\n    closing_brackets = {'(', '}', '['}\n    \n    return\
    \ brackets == brackets[0, -1] and\n            brackets in closing_brackets and\n\
    \            brackets[0, -1] not in opening_brackets\nend", "  # implement here\n\
    end", "  return brackets == \"()\" or brackets == \"[]\" or brackets == \"{}\"\
    \ or brackets == \"<>\" or brackets == \"<>[]\" or brackets == \"{}[]\"\nend",
  "  brackets.scan(/[()]/)\n  brackets.scan(/[)]/)\n  brackets.scan(/[)(]/)\n  brackets.scan(/[)]/)\n\
    \  return brackets == brackets\nend", "  brackets.scan(/[(]/)\n  brackets.scan(/[)]/)\n\
    \  return brackets.last.nil?\nend", "  brackets = brackets.to_s\n  bracket_pairs\
    \ = []\n  \n  # Iterate over every character in brackets.\n  brackets.each_char\
    \ do |char|\n    if char == \")\"\n      bracket_pairs << char\n    else\n   \
    \   break if bracket_pairs.size < 1\n      if bracket_pairs.last == char\n   \
    \     bracket_pairs.pop\n      else\n        bracket_pairs << char\n      end\n\
    \    end\n  end\n  \n  # If brackets are balanced, then bracketing is correct.\n\
    \  brackets = bracket_pairs.join(\"\")\n  return brackets.size < 1\nend", "  brackets.split(\"\
    \").all? {|x| x.include?(\"(\") }\nend", "  bracket_stack = []\n  bracket_stack.push(brackets)\n\
    \  bracket_stack_string = \"\"", "  brackets.scan(/[()]/)\n  brackets.each { |x|\n\
    \    open_bracket = brackets.index(x)\n    open_bracket > brackets.size - 1 and\
    \ brackets[open_bracket] = \"()\"\n  }\n  return brackets == \"()\"\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis is almost the right answer. You need to use `brackets.size\
    \ - 1` because the last element in `brackets` is `\"()\"` (or `\"())\"` or `\"\
    (()())\"`). The code I have posted will handle all these cases.\n<|/ c |>\n<|\
    \ c |>\nYes, good catch. Thanks. I did that fix when posting my first answer.\
    \ I will update my answer in a minute to reflect that change. Thanks for the heads\
    \ up on the `\"()\"` case.\n<|/ c |>\n<| a dscore=0 tags=string,ruby,regex |>\n\
    Here is an alternative to Tim Pietzcker's answer. It uses a regular expression\
    \ to find all the \"proper\" brackets in the string, then replaces each with its\
    \ opposite.\n<code>", "    brackets = brackets.to_s\n    brackets.reverse\n  \
    \  brackets.each_index do |i|\n        if brackets[i] == \"(\"\n            if\
    \ brackets[i+1] != \")\"\n                brackets.slice!(i+1, 2)\n          \
    \      return false\n            end\n        end\n    end\n    true\nend", " \
    \ brackets = brackets.to_s\n  # Check whether the parentheses are balanced.\n\
    \  opening = brackets.count(\"(\")\n  closing = brackets.count(\")\")\n  if opening\
    \ > closing \n    true\n  else\n    false\n  end\nend\n</code>\n<|/ a tags=ruby,string\
    \ dscore=2 |>\n<| c |>\nWhile this code snippet may solve the question, [including\
    \ an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| c |>\nGood point. I've edited\
    \ to give some more detail and explain why this approach may be preferable.\n\
    <|/ c |>\n<| a |>\nFor fun, here's a solution that uses a little bit of regex:\n\
    <code>", "    stack = brackets.to_a\n    stack.last.nil?\nend", "  brackets.scan(/[()]/)\n\
    \  brackets.scan(/[^()]/)\n  brackets.scan(/[)]/)\n  brackets.scan(/[^)]/)\n \
    \ return brackets.size == 0\nend", "  brackets = brackets.to_s\n  brackets.scan(/\\\
    (/) { add_brackets(@i) }\n  brackets.scan(/\\)/) { add_brackets(@i) }\n  brackets.scan(/\\\
    {/) { add_brackets(@i) }\n  brackets.scan(/\\}/) { add_brackets(@i) }\n  brackets.scan(/\\\
    [/) { add_brackets(@i) }\n  brackets.scan(/\\]/) { add_brackets(@i) }\n  brackets.scan(/\\\
    (/) { add_brackets(@i) }\n  brackets.scan(/\\)/) { add_brackets(@i) }\n  brackets.scan(/\\\
    {/) { add_brackets(@i) }\n  brackets.scan(/\\}/) { add_brackets(@i) }\n  brackets.scan(/\\\
    [/) { add_brackets(@i) }\n  brackets.scan(/\\]/) { add_brackets(@i) }\n  brackets.scan(/\\\
    (/) { add_brackets(@i) }\n  brackets.scan(/\\)/) { add_brackets(@i) }\n  brackets.scan(/\\\
    {/) { add_brackets(@i) }\n  brackets.scan(/\\}/) { add_brackets(@i) }\n  brackets.scan(/\\\
    [/) { add_brackets(@i) }\n  brackets.scan(/\\]/) { add_brackets(@i) }\n  brackets.scan(/\\\
    (/) { add_brackets(@i) }\n  brackets.scan(/\\)/) { add_brackets(@i) }\n  brackets.scan(/\\\
    {/) { add_brackets(@i) }\n  brackets.scan(/\\}/) { add_brackets(@i) }\n  brackets.scan(/\\\
    [/) { add_brackets(@i) }\n  brackets.scan(/\\]/) { add_brackets(@i) }\n  brackets.scan(/\\\
    (/) { add_brackets(@i) }\n  brackets.scan(/\\)/) { add_brackets(@i) }\n  brackets.scan(/\\\
    {/) { add_brackets(@i) }\n  brackets.scan(/\\}/) { add_brackets(@i) }\n  brackets.scan(/\\\
    [/) { add_brackets(@i) }\n  brackets.scan(/\\]/) { add_brackets(@i) }\n  brackets.scan(/\\\
    (/) { add_brackets(@i) }\n  brackets.scan(/\\)/) { add_brackets(@i) }\n  brackets.scan(/\\\
    {/", "  opening_brackets = brackets.count(\"(\")\n  closing_brackets = brackets.count(\"\
    )\")\n  return opening_brackets == closing_brackets\nend\n</code>\n<|/ a tags=ruby,arrays,enumerable\
    \ |>\n<| a tags=ruby,arrays,enumerable |>\nI believe this to be the most concise\
    \ way:\n<code>", "  # implement this function\n  \n  return true\nend\n</cell>\n\
    <text>\nAccording to the algorithm, the function should return True if the given\
    \ bracketing is correct and false otherwise. Fill in the code below (if you get\
    \ stuck, there is an example in the video).", "  # Remove one opening bracket\
    \ at a time from brackets and repeat until\n  # no more brackets are left.\n \
    \ return brackets == \"()\" or brackets == \"(()\" or brackets == \"(())\" or\
    \ brackets == \"(()()\"\nend", "  bracket = brackets.to_s.gsub(/\\(|\\)/,\"\"\
    )\n  bracket_open = bracket.gsub(/\\(/,\"\").to_f\n  bracket_closed = bracket.gsub(/\\\
    )/,\"\").to_f\n  (bracket_open - bracket_closed).zero?\nend", "  # your code here\n\
    end", "  return brackets.count(\"(\") == brackets.count(\")\")\nend\n</cell>\n\
    <text>\nPart III - Part II\nNow that you're done with Chapter 3, you can move\
    \ on to the exercises under Part III. You'll have to modify the code so that it\
    \ passes all the test cases. You will also have to modify the code to run faster.",
  "  brackets = brackets.to_s\n  brackets.scan(/\\(/) do |x|\n    brackets.slice!(x)\n\
    \    brackets.slice!(1) while brackets.slice!(/\\(/)\n    break if brackets.slice!(/\\\
    )/)\n    false\n  end.empty?\nend", "  bracket_depth = brackets.scan(/\\(|\\)/).size\n\
    \  return bracket_depth == brackets.scan(/\\(|\\)/).size - 1 \nend", "  return\
    \ brackets =~ (/(\\()/).to_s + /\\)/.to_s + /\\}/.to_s\nend", "  brackets = brackets.gsub(/([()])/,\
    \ '\\1')\n  opening = brackets.scan(/[(]/)\n  closing = brackets.scan(/[)]/)\n\
    \  (opening.empty? || closing.empty?) && return false\n  opening.any? && closing.any?\
    \ && opening.any? <= closing && return true\n  true\nend\n</code>\n<|/ a tags=ruby,regex,brackets\
    \ |>\n<| a tags=ruby,regex,brackets |>\nFor those who need this in Python:\n<code>\n\
    import re", "  brackets = brackets.to_s\n  brackets.gsub!(/[()]+/, \"\")\n  brackets.gsub!(/^\\\
    (/, \"(\")\n  brackets.gsub!(/\\)/, \")\")\n  brackets.gsub!(/^\\)/, \")\")\n\
    \  brackets.gsub!(/([^\\(])(\\(|\\)(?!\\))/, '\\2 \\3')\n  brackets.gsub!(/\\\
    ([^\\)]*\\)/, '\\1')\n  return brackets == \"()\"\nend", "    bracket_counts =\
    \ {} # Maps opening brackets to their corresponding closing brackets, counting\
    \ how many brackets there are.\n    correct_brackets = [] # List of brackets in\
    \ the form (open,close) where open and close are each of the brackets in brackets.",
  "  brackets.chars.each do |c|\n    next if c == \"(\"\n    return false if c ==\
    \ \")\"\n  end\n  true\nend", "    brackets.gsub!(/[()]/) { |x| x == ')' ? '('\
    \ : x }\n    brackets.gsub!(/[)]/) { |x| x == ')' ? '(' : x }\n    brackets.gsub!(/[]/)\
    \ { |x| x == ']' ? '[' : x }\n    brackets.gsub!(/[]/) { |x| x == ']' ? '[' :\
    \ x }\n    brackets.gsub!(/[^()|[]{}]/) { |x| x == ')' ? '(' : x }\n    brackets.gsub!(/[^()|[]{}]/)\
    \ { |x| x == ')' ? '(' : x }\n    brackets.gsub!(/[^()|[]{}]/) { |x| x == ']'\
    \ ? '[' : x }\n    brackets.gsub!(/[^()|[]{}]/) { |x| x == ']' ? '[' : x }\nend",
  "  if brackets.empty?\n    true\n  elsif brackets.chars.count == '('\n    correct_bracketing(bracktors{brackets.chars[0]})\
    \ && correct_bracketing(bracktors{brackets.chars[1]})\n  elsif brackets.chars.count\
    \ == '['\n    correct_bracketing(bracktors{brackets.chars[0]}) && correct_bracketing(bracktors{brackets.chars[1]})\
    \ && correct_bracketing(bracktors{brackets.chars[2]})\n  elsif brackets.chars.count\
    \ == '{'\n    correct_bracketing(bracktors{brackets.chars[0]}) && correct_bracketing(bracktors{brackets.chars[1]})\
    \ && correct_bracketing(bracktors{brackets.chars[2]}) && correct_bracketing(bracktors{brackets.chars[3]})\n\
    \  elsif brackets.chars.count == '}'\n    correct_bracketing(bracktors{brackets.chars[0]})\
    \ && correct_bracketing(bracktors{brackets.chars[1]})\n  else\n    true\n  end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThanks for taking the time to write this answer.\
    \ It will help me a lot when I revisit the problem next time I encounter it.\n\
    <|/ c |>\n<| c |>\nI wrote a recursive version of the code with memoization in\
    \ mind.  Check it out if it looks good to you.  Let me know if you have any questions\
    \ about how it works.  I haven't tested it much.\n<|/ c |>\n<| c |>\nHey, it seems\
    \ to work for me in most test cases, but there are some edge cases I'm not able\
    \ to figure out. Could you give an example where it fails?\n<|/ c |>\n<| c |>\n\
    It fails because I'm missing some cases I need to test for. I tried a couple other\
    \ cases and it only works some of the time. That's why I added the test cases\
    \ in the comments.\n<|/ c |>\n<| a tags=ruby,algorithm,recursion dscore=2 |>\n\
    I have seen a few solutions posted here but none that have actually been tested.\
    \ The accepted solution seems to have some issues when the input string is empty\
    \ (which makes it a little pointless I admit). The solution below tests that a\
    \ string has at least two closing brackets before the next opening bracket, if\
    \ that condition is met then the algorithm returns false (as it should), if that\
    \ condition is not met it recursively searches for a matching opening bracket\
    \ until it finds one that has 2 or more closing ", "  if brackets.empty?\n   \
    \ true\n  else\n    brackets.include?(opening_brackets.first) && brackets.include?(closing_brackets.first)\n\
    \  end\nend", "  bracket_open = brackets.scan(/\\(+/).to_a\n  bracket_close =\
    \ brackets.scan(/\\)+/).to_a\n  bracket_open.zip(bracket_close).all? {|a,b| a\
    \ == b }\nend", "  brackets.gsub!(/[^()]/, \"(\")\n  brackets.gsub!(/[()]/, \"\
    (\")\n  brackets.gsub!(/[)]/, \")\")\n  brackets.gsub!(/[()]/, \")\")\n  brackets.gsub!(/[)]/,\
    \ \")\")\n  brackets.gsub!(/\\)/, \"(\")\n  brackets.gsub!(/\\)/, \")\")\n  return\
    \ brackets == brackets\nend", "  brackets.scan(/[^()]+/)\n  brackets.scan(/[\\\
    (\\)]/)\n  brackets == brackets.to_s\nend\n</code>\n<|/ a dscore=5 |>\n<| a dscore=5\
    \ tags=ruby |>\nHere's a solution that works with Ruby 1.9 and a regex (thanks\
    \ to Chris for his regexp comment). \n<code>", "  # Replace each opening bracket\
    \ with the first closing bracket it encounters.\n  brackets.gsub!(/[()]/) {|char|\
    \ correct_bracketing(brackets[$1..-1])}\n  brackets == brackets.reverse\nend",
  "  brackets.gsub!(/^\\(/, \"(\"); brackets.gsub!(/\\)/, \")\")\n  brackets.gsub!(/\\\
    )/, \"(\"); brackets.gsub!(/^\\)/, \")\")\n  return brackets == \"(()())\"\nend\n\
    </code>\n<|/ a |>\n<| a tags=ruby,regex |>\n<code>", "    brackets.count(\"(\"\
    )\n    brackets.count(\")\")\n    brackets.count(\"(\") - brackets.count(\")\"\
    )\nend", "  return brackets.scan(/\\(|\\)/).all? {|x| x =~ /\\(/} and brackets.scan(/\\\
    )/).all? {|x| x =~ /\\)/}\nend", "    brackets = brackets.to_s\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\(]+/, '(')\n    brackets.gsub!(/[\\)]+/, ')')\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\(]+/, '(')\n    brackets.gsub!(/[\\)]+/, ')')\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\(]+/, '(')\n    brackets.gsub!(/[\\)]+/, ')')\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\(]+/, '(')\n    brackets.gsub!(/[\\)]+/, ')')\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\(]+/, '(')\n    brackets.gsub!(/[\\)]+/, ')')\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\(]+/, '(')\n    brackets.gsub!(/[\\)]+/, ')')\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\(]+/, '(')\n    brackets.gsub!(/[\\)]+/, ')')\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\(]+/, '(')\n    brackets.gsub!(/[\\)]+/, ')')\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\(]+/, '(')\n    brackets.gsub!(/[\\)]+/, ')')\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\(]+/, '(')\n    brackets.gsub!(/[\\)]+/, ')')\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\(]+/, '(')\n    brackets.gsub!(/[\\)]+/, ')')\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\(]+/, '(')\n    brackets.gsub!(/[\\)]+/, ')')\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\(]+/, '(')\n    brackets.gsub!(/[\\)]+/, ')')\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\(]+/, '(')\n    brackets.gsub!(/[\\)]+/, ')')\n    brackets.reverse!\n\
    \    brackets.gsub!(/[\\", "  stack = []\n  open_bracket = \"\"\n  close_bracket\
    \ = \"\"", "  brackets = brackets.to_s\n  open_paren_stack = Stack.new\n  close_paren_stack\
    \ = Stack.new", "  brackets = brackets.to_s\n  brackets.gsub!(/\\(/, \"[\")\n\
    \  brackets.gsub!(/\\)/, \"]\")\n  brackets.gsub!(/[\\[\\]]/, \"\") # remove empty\
    \ brackets\n  brackets.gsub!(/[()]/, \"(\")\n  brackets.gsub!(/([)]/, \")\")\n\
    \  brackets.gsub!(/[[]/, \"[\")\n  brackets.gsub!(/[]]/, \"]\")\n  return brackets\
    \ != brackets.to_s\nend\n</code>\n<|/ a dscore=5 |>\n<| a dscore=4 tags=ruby,string,regex\
    \ |>\nHow about this:\n<code>\nstr = \"(()())\"\nstr.length.times.reduce(:&)\n\
    \  #=> 0\n</code>\nThe method String#times calls to_s on the argument, which returns\
    \ self, and passes the result as a block to Enumerable#reduce. #to_s returns self\
    \ if it is an array, and returns self.to_s if it's an Enumerable object. :& takes\
    \ the bitwise AND of all the bits, and so :(&) returns 0 when self is 0.\n<code>\n\
    enum = str.times\n  #=> #<Enumerator: \"(()())\":times>\nenum.next\n  #=> 0\n\
    enum.next\n  #=> 0\nenum.next\n  #=> 0\nenum.next\n  #=> 0\nenum.next\n  #=> 0\n\
    </code>\nSince self is 0, String#length returns 0.\n<code>\nenum = str.times.reduce(:&)\n\
    \  #=> 0\n</code>\nThe method String#times calls to_s on the argument, which returns\
    \ self, and passes the result as a block to Enumerable#reduce. #to_s returns self\
    \ if it is an array, and returns self.to_s if it's an Enumerable object. :& takes\
    \ the bitwise AND of all the bits, and so :(&) returns 0 when self is 0.\n<code>\n\
    enum = str.times\n  #=> #<Enumerator: \"(()())\":times>\nenum.next\n  #=> 0\n\
    enum.next\n  #=> 0\nenum.next\n  #=> 0\nenum.next\n  #=> 0\nenum.next\n  #=> 0\n\
    </code>\nSince self is 0, String#length returns 0.\n<code>\nenum = str.times.reduce(:&)\n\
    \  #=> 0\n</code>\n<|/ a |>\n<| c |>\nI appreciate this explanation. I thought\
    \ of using .times.reduce but didn't know how to implement it.\n<|/ c |>\n<| c\
    \ |>", "  bracket_stack = []\n  brackets_correct = true\n  brackets_open = brackets.count(\"\
    (\")\n  brackets_closed = brackets.count(\")\")\n  brackets_total =  brackets_open\
    \ + brackets_closed + 1\n  opening_chars = []\n  closing_chars = []\n  open_count\
    \ = 0\n  close_count = 0\n  while brackets_total > 0\n    opening_char = brackets[open_count].to_s.chr\n\
    \    closing_char = brackets[close_count + 1].to_s.chr\n    if opening_char ==\
    \ \"(\" and closing_char == \")\"\n      open_count += 2\n      close_count +=\
    \ 2\n      brackets_total -= 2\n      brackets_correct &= (open_count - close_count\
    \ == 1)\n      opening_chars.unshift opening_char\n      closing_chars.unshift\
    \ closing_char\n    else\n      if opening_char == \"(\" and closing_char != \"\
    )\"\n        open_count += 1\n        brackets_total -= 1\n      elsif opening_char\
    \ != \"(\" and closing_char == \"(\"\n        close_count += 1\n        brackets_total\
    \ -= 1\n      else\n        open_count -= 1\n        close_count -= 1\n      \
    \  brackets_total -= 1\n  end\n  opening_chars.reverse!\n  closing_chars.reverse!\n\
    \  if opening_chars == closing_chars\n    brackets_correct = false\n  end\n  return\
    \ brackets_correct\nend", "  brackets = brackets.to_s\n  brackets = brackets.gsub(')',\
    \ '')\n  brackets = brackets.gsub(')', '')\n  brackets = brackets.gsub('(', '')\n\
    \  brackets = brackets.gsub('(', '')\n  brackets = brackets.gsub('\\\\)', '')\n\
    \  brackets = brackets.gsub('\\\\(', '')\n  brackets = brackets.gsub('\\\\(',\
    \ '')\n  return brackets == brackets\nend", '    return brackets.count("(") ==
    brackets.count(")")', "  brackets.chars.each_cons(2).all? { |a,b| a == b }\nend\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nWow, `each_cons` is a new one for me, I didn't\
    \ know about it.\n<|/ c |>\n<| c |>\nIt's a great way to flatten the nested array\
    \ (without creating a new array).\n<|/ c |>\n<| c |>\nGreat answer. Although I'd\
    \ suggest changing the first line to `def correct_bracketing(brackets)` to make\
    \ it more clear what you are doing (a method called correct_bracketing).\n<|/\
    \ c |>\n<| c |>\nHow about `brackets.chars.each_cons(2).all?(&:==)`? I think it\u2019\
    s more readable than `brackets.chars.each_cons(2).all?{ |a,b| a == b }`\n<|/ c\
    \ |>\n<| c |>\nThe method \"each_cons\" has been around since Ruby 1.8.7: http://www.ruby-doc.org/core/classes/Enumerable.html#M001721\n\
    <|/ c |>\n<| a |>\nIf you don't like each_cons, you can always use each_slice:\n\
    <code>", "  brackets = brackets.chars\n  i = 0\n  open_brackets = 0\n  while i\
    \ < brackets.length\n    # If the next character is the beginning of a bracket,\n\
    \    # increment the counter.\n    if brackets[i] == \"(\"\n      open_brackets\
    \ += 1\n    # If the next character is the end of a bracket,\n    # decrement\
    \ the counter.\n    if brackets[i] == \")\"\n      open_brackets -= 1\n    # If\
    \ the counter is zero,\n    # then we have encountered an opening bracket,\n \
    \   # and we need to close the corresponding closing bracket.\n    if open_brackets\
    \ == 0\n      return false\n    # Increment the counter one more time.\n    i\
    \ += 1\n  # If we made it this far,\n  # then we have not encountered any brackets.\n\
    \  return true\nend\n</code>\nThe code above checks for parentheses in an input\
    \ string, but of course you can change that as needed.\n<|/ a dscore=1 |>\n<|\
    \ c |>\nI wonder if the second line should be `return false` instead of `return\
    \ true`?\n<|/ c |>\n<| c |>\n: I made a mistake there, thanks for pointing it\
    \ out. I've corrected that now.\n<|/ c |>\n<| a |>\nThis is an alternative solution\n\
    <code>", "  return brackets =~ /\\(.*\\)/\nend", "  # +++your code here+++\n \
    \ result = (brackets == ')') or (brackets == '(')\n  return result\nend", "  bracket_map\
    \ = {\n    '(': ')',\n    '[': ']',\n    '{': '}',\n  }\n  correct_bracketing\
    \ = []\n  brackets.each do |bracket_char|\n    correct_bracketing << !bracket_map.has_key?(bracket_char)\
    \ == bracket_char\n  end\n  correct_bracketing\nend", "  brackets =~ /\\(/\n \
    \ brackets =~ /\\)/\n  bracket_stack = [brackets]\n  bracket_stack.each do |bracket|\n\
    \    if bracket =~ /\\(/\n      bracket_stack[-1] << bracket\n      bracket_stack.push\
    \ []\n    end\n    if bracket =~ /\\)/\n      bracket_stack.pop\n    end\n  end\n\
    \  bracket_stack.pop.empty?\nend", "  return brackets =~ /\\(.*\\)/m && brackets\
    \ =~ /\\(.*\\)/m\nend", "    stack = []\n    bracket_stack = []\n    brackets_map\
    \ = {}\n    bracket_map[brackets] = True\n    # Keep going until we run out of\
    \ brackets\n    while brackets != \"()\" do\n      # If brackets is an opening\
    \ bracket, we push it onto the stack.\n      if brackets_map[brackets] == nil\
    \ then\n        stack = [brackets]\n      else\n        stack = stack + [brackets]\n\
    \      end", "    bracket_stack = []\n    open_brackets = 0\n    for character\
    \ in brackets\n        if character == '('\n            open_brackets += 1\n \
    \           bracket_stack.push((open_brackets, character))\n        if character\
    \ == ')'\n            open_brackets -= 1\n            bracket_stack.pop() while\
    \ open_brackets >= 0\n    end = 0\n    while bracket_stack.length > 0\n      \
    \  if bracket_stack.pop().last.last == ')'\n            end += 1\n        end\n\
    \    end\n    true_bracketing = brackets.sub(\"()\", \"\")\n    return true_bracketing\
    \ == brackets.sub(\"()\", \"\")[end..-1]\nend", "    bracket_count = 0\n    stack\
    \ = []\n    if brackets == \"(\" # parentheses only\n        return true\n   \
    \ brackets.each do |x|\n        if x == \"(\" # opening bracket\n            stack\
    \ << x\n            bracket_count += 1\n        elsif x == \")\" # closing bracket\n\
    \            if bracket_count == 1\n                stack.pop\n              \
    \  bracket_count -= 1\n            else\n                return false # unbalanced\
    \ brackets\n            end\n        else\n            false # other characters\
    \ are invalid\n        end\n    end\n    stack.empty? # stack is empty\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=ruby,regex |>\n<code>\n def validate_brackets?(input)\n\
    \    input = input.downcase\n    stack = []\n    bracket_count = 0\n    input.gsub(/\\\
    (\\?\\)/) do |x|\n      if x == '('\n        stack.push(x)\n        bracket_count\
    \ += 1\n      elsif x == ')'\n        if bracket_count == 1\n          stack.pop\n\
    \          bracket_count -= 1\n        else\n          return false\n        end\n\
    \      else\n        false\n      end\n    end\n    stack.empty?\n  end\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nWhile this code snippet may solve the question, [including\
    \ an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, as this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a |>\n<code>", "    stack = []\n    brackets_map\
    \ = {\"(\": \"{\", \")\": \"}\", \"{\": \"(\", \"}\": \")\"}\n    stack = [brackets_map.get(brackets,\
    \ brackets)]\n    opening = false\n    while !stack.empty?\n        current =\
    \ stack.pop\n        if current == \"(\"\n            opening = !opening\n   \
    \     elsif current == \")\"\n            stack << current unless opening\n  \
    \      else\n            stack << current\n        end\n    end\n    stack.empty?\n\
    end", "  brackets = brackets.to_s\n  return brackets.chars.reduce(:==).to_s !=\
    \ brackets.chars.reduce(:<=>).to_s\nend", "  brackets.scan(/[()]+/).all? do |x|\n\
    \    brackets.scan(/[^()]+/).all? do |y|\n      x == y ? false : true\n    end\n\
    \  end\nend", "    i = 0\n    while i < brackets.length\n        j = i\n     \
    \   while j < brackets.length\n            if brackets[j] == brackets[i]\n   \
    \             brackets = brackets.substring (0, j) + \" \" + brackets.substring\
    \ (j + 1)\n            end\n            j = j + 1\n        end\n        i += 1\n\
    \    end\n    return brackets\nend\n</cell>\n<code language=julia-0.6>", "   \
    \ # your code goes here\n    return false\nend", "  brackets.scan(/\\(/) do |match|\n\
    \    brackets.scan(/\\)/) do |closing_match|\n      next if closing_match != match",
  "    stack = []\n    open_brackets = 0\n    open_brackets_positions = []\n    closed_brackets\
    \ = 0\n    closed_brackets_positions = []\n    last_position = 0\n    while last_position\
    \ < brackets.length\n        if brackets[last_position] == \"(\"\n           \
    \ open_brackets_positions << last_position\n            open_brackets += 1\n \
    \       elsif brackets[last_position] == \")\"\n            open_brackets_positions.delete(brackets_positions[last_position])\n\
    \            closed_brackets += 1\n        elsif brackets[last_position] == \"\
    [\"\n            closed_brackets_positions << last_position\n            closed_brackets\
    \ += 1\n        elsif brackets[last_position] == \"]\"\n            closed_brackets_positions.delete(brackets_positions[last_position])\n\
    \            open_brackets -= 1\n        last_position += 1\n    if open_brackets\
    \ < closed_brackets\n        return false\n    return true\nend", "  # remove\
    \ spaces, so that we can use indexOf to find where brackets are.\n  brackets =\
    \ brackets.gsub(\" \", \"\").upcase", "    # Your code here\n    if brackets.count\
    \ == \"(\"\n        return false\n    if brackets.count == \"[\"\n        return\
    \ true\n    if brackets.count == \"{\"\n        return false\n    if brackets.count\
    \ == \"<\"\n        return true\n    if brackets.count == \">\"\n        return\
    \ false\n    return false\n    ", "  brackets.split('').each do |b|\n    b.to?(/[()]/)\
    \ != nil ? !(b == '(' || b == '[') : false\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=string,ruby dscore=0 |>\n<code>", "    brackets = brackets.to_s\n\
    \    opening_bracket = brackets.match(/[^()]+/)\n    closing_bracket = brackets.match(/[^()]+/)\n\
    \    opening_bracket.size != closing_bracket.size || opening_bracket.size <= 1\n\
    end", "  brackets.gsub!( /(\\()/, '\\1\\2')\n  brackets.gsub!( /(\\))/, '\\1\\\
    2')\n  brackets.gsub!( /([^)(])/, '\\1\\1')\n  brackets.gsub!( /(\\))/, '\\1\\\
    1')\n  brackets.gsub!( /(\\()/, '\\1\\1')\n  brackets.gsub!( /([^)(])/, '\\1\\\
    1')\n  return brackets == \"()\"\nend", "    # Check for correct bracketing\n\
    \    if brackets == '()'\n        true\n    elsif brackets == '[]'\n        true\n\
    \    else\n        false\n    end\nend\n</code>\n<|/ a |>\n<| a |>\nThere are\
    \ a couple issues here.\nFirst, you're returning true on one branch, but not on\
    \ all the possible branches. You need to return true for the first condition,\
    \ and false for the other two conditions.\n<code>", "  brackets.each_char { |char|\
    \ return false if char != \"(\" && char != \")\" }\n  true\nend", "  return bracketed_brackets.all?\
    \ { |x| brackets.include? x }\nend", "  # Get the number of opening brackets\n\
    \  opening_count = brackets.count(\"(\")\n  # Get the number of closing brackets\n\
    \  closing_count = brackets.count(\")\")", "  brackets.scan(/\\(|\\)/) do |x|\n\
    \    brackets.gsub! x, \"\"\n  end\n  brackets.empty?\nend", "  brackets.scan(/\\\
    (/) do |x|\n    brackets.scan(/\\)/) { |y| break false if y == x }\n    break\
    \ false\n  end\n  true\nend\n</code>\nI used scan instead of scan because it's\
    \ more efficient when searching for a regexp multiple times, and scan can search\
    \ for the same regexp multiple times.\n<|/ a tags=ruby,string dscore=1 |>\n<|\
    \ a dscore=1 |>\nRuby's String#match works well for this sort of thing:\n<code>",
  "  brackets.chars.each_with_index do |x, i|\n    if x == \"(\" && brackets.chars[i\
    \ - 1] != \"(\" ||\n        brackets.chars[i + 1] != \")\" ||\n        x == \"\
    )\" && brackets.chars[i - 2] != \"(\" ||\n        brackets.chars[i - 1] == \"\
    )\" && brackets.chars[i + 1] != \"(\"\n      return false\n    end\n  end\n  true\n\
    end", "  # Use a set to keep track of the brackets we have seen\n  seen_brackets\
    \ = Set.new", "  brackets = brackets.gsub(\"\\\\(|\\\\)\", \"\")\n  brackets.chars.each_byte\
    \ do |char|\n    if char == \"(\"\n      brackets += \")\"\n      return true\
    \ if brackets.chars.count > 1\n    end\n  end\n  false\nend", "  brackets.each_char\
    \ do |char|\n    if char == \"(\" || char == \")\"\n      return char == brackets.next\n\
    \    end\n  end\n  false\nend", "  # Your code here\n  result=False\n  opening_count=0\n\
    \  closing_count=0\n  openings=brackets.split(\"(\")\n  closings=brackets.split(\"\
    )\")\n  for i in openings:\n    if i!='' and i!='()':\n      opening_count+=1\n\
    \  if opening_count==openings.length:\n    result=True\n  for j in closings:\n\
    \    if j!='' and j!='()':\n      closing_count+=1\n  if closing_count==closings.length:\n\
    \    result=True\n  if result==True:\n    for i in openings:\n      if i!='' and\
    \ i!='()':\n        result=False\n        break\n    for j in closings:\n    \
    \  if j!='' and j!='()':\n        result=False\n        break\n  if result==True:\n\
    \    return i\n  else:\n    return result", "  return brackets !~ /[()]/\nend",
  "  # TODO: Implement Function\nend", "  brackets.chars.reduce(0) {|s,c|\n    s +=\
    \ c == ')' ? 1 : -1 if s == '('\n    s\n  } == 0 && brackets.size != 0\nend",
  "  # The string bracket_opens_string describes the characters that can appear\n\
    \  # before the brackets, bracket_closes_string describes the characters that\
    \ can\n  # appear after the brackets. Thus bracket_opens_string is a string of\
    \ \"{\" and\n  # bracket_closes_string is a string of \"}\".\n  bracket_opens_string\
    \ = \"{(}[]\"\n  bracket_closes_string = \"{}[]}\"\n  return brackets.index(bracket_opens_string)\
    \ == brackets.index(bracket_closes_string)\nend", "  brackets = brackets.to_s\n\
    \  brackets.slice!(-1) if brackets.slice!(-1) == \")\"\n  brackets.slice!(-1)\
    \ if brackets.slice!(-1) == \"]\"\n  brackets.slice!(-1) if brackets.slice!(-1)\
    \ == \"}\"\n  brackets.slice!(-1) if brackets.slice!(-1) == \"[\"\n  brackets.slice!(-1)\
    \ if brackets.slice!(-1) == \")(\"\n  brackets.slice!(-1) if brackets.slice!(-1)\
    \ == \"()[\"\n  brackets.slice!(-1) if brackets.slice!(-1) == \"[]\"\n  brackets.slice!(-1)\
    \ if brackets.slice!(-1) == \"](\"\n  brackets.slice!(-1) if brackets.slice!(-1)\
    \ == \"{}(\"\n  brackets.slice!(-1) if brackets.slice!(-1) == \"}[]\"\n  brackets.slice!(-1)\
    \ if brackets.slice!(-1) == \"{[]\"\n  brackets.slice!(-1) if brackets.slice!(-1)\
    \ == \"[{]\"\n  brackets.slice!(-1) if brackets.slice!(-1) == \"([]\"\n  brackets.slice!(-1)\
    \ if brackets.slice!(-1) == \"[](\"\n  brackets.slice!(-1) if brackets.slice!(-1)\
    \ == \"){}(\"\n  brackets.slice!(-1) if brackets.slice!(-1) == \")[](\"\n  brackets.slice!(-1)\
    \ if brackets.slice!(-1) == \"(){}\"\n  brackets.slice!(-1) if brackets.slice!(-1)\
    \ == \"{}[]\"\n  brackets.slice!(-1) if brackets.slice!(-1) == \")()\"\n  brackets.slice!(-1)\
    \ if brackets.slice!(-1) == \"()()\"\n  brackets.slice!(-1) if brackets.slice!(-1)\
    \ == \"(())\"\n  brackets.slice!(-1) if brackets.slice!(-1) == \"()()()\"\n  brackets.slice!(-1)\
    \ if brackets.slice!(-1) == \"()[]\"\n  brackets.slice!(-1) if brackets.slice!(-1)\
    \ == \")()[]\"\n  brackets.slice!(-1) if brackets.slice!(-1) == \"){}[]\"\n  brackets.slice!(-1)\
    \ if brackets.slice!(-1) == \"{([])\"\n  brackets.slice!(-1) if brackets.slice!(-1)\
    \ == \")({([])\"\n  brackets.slice!(-1) if brackets.slice!(-1) == \"[({([])\"\n\
    \  brackets.slice!(-1) if brackets.slice!(-1) == \"]({})\"\n  brackets.slice!(-1)\
    \ if brackets.slice!(-1) == \"[[](", "  bracket_map={}\n  bracket_map['(']=')'\n\
    \  bracket_map['{']=']'\n  bracket_map['[']=']'\n  bracket_map['<']=','\n  bracket_map['>']='}'\n\
    \  bracket_map['.']=','\n  bracket_map['-']=','\n  bracket_map[';']=','\n  bracket_map[':']=','\n\
    \  bracket_map['=']='='\n  bracket_map['~']=','", "  brackets.chars.all? do |b|\n\
    \    (b == '(' || b == ')') && brackets.index(bracks)+1==brackets.rindex(b)\n\
    \  end\nend", "    return brackets.gsub(/[()]/, '') == ''\nend", "  bracket_counts\
    \ = brackets.count(\"(\")\n  bracket_counts -= brackets.count(\")\")\n  return\
    \ (bracket_counts == 0)\nend", "  # check if brackets is a string with two or\
    \ more chars\n  if type(brackets) is String\n    # split string by opening brackets\n\
    \    parts = brackets.split(/\\(|\\)/)\n    # return true if every opening bracket\
    \ has a corresponding closing bracket\n    return parts.length >= 2 &&\n     \
    \ parts.length <= parts.length.to_s.length\n  else\n    # brackets is not a string,\
    \ return false\n    return false\nend", "  if brackets == nil then\n    return\
    \ true\n  end\n  local stack = {}\n  for i = 1, #brackets do\n    local opening\
    \ = brackets[i]\n    local closing = brackets[i - 1]\n    if opening == \"(\"\
    \ then\n      stack[#stack + 1] = closing\n    else\n      if opening == stack[#stack]\
    \ then\n        return false\n      end\n      stack[#stack + 1] = opening\n \
    \   end\n  end\n  return true\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
