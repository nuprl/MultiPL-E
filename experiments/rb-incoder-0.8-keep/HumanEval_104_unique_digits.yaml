name: HumanEval_104_unique_digits
language: rb
prompt: "# Given a list of positive integers x. return a sorted list of all \n# elements\
  \ that hasn't any even digit.\n# Note: Returned list should be sorted in increasing\
  \ order.\n# For example:\n# >>> unique_digits([15, 33, 1422, 1])\n# [1, 15, 33]\n\
  # >>> unique_digits([152, 323, 1422, 10])\n# []\ndef unique_digits(x)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique_digits\n\
  \    candidate = method(:unique_digits)\n    assert_equal([1, 15, 33], candidate.call([15,\
  \ 33, 1422, 1]))\n    assert_equal([], candidate.call([152, 323, 1422, 10]))\n \
  \   assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))\n    assert_equal([31,\
  \ 135], candidate.call([135, 103, 31]))\n  end\nend\n"
completions: ["    return x.select { |i| (x & i).zero? }\nend", "  result = []\n \
    \ x.each do |x| \n    digit = x.to_s.split('')\n    digit.uniq.each do |x|\n \
    \     result << x\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nYour method fails for `unique_digits([10, 9, 4, 7])`. See my answer for\
    \ how it should behave.\n<|/ c |>\n<| c |>\nI added an explanation of why the\
    \ method fails. Hope that helps.\n<|/ c |>\n<| c |>\nI believe OP was trying to\
    \ implement a method that, given a list, returns all elements that are _not_ part\
    \ of another element in the list. For example, `unique_digits([15, 33, 1422, 1])`\
    \ should return `[1, 15, 33]`, because `1` has no digits.\n<|/ c |>\n<| c |>\n\
    - I guess that's what OP wants, but the OP also says _\" ...in increasing order\"\
    _ which I take to mean the list should be sorted in ascending order (like what\
    \ you've posted). I think the OP wants it sorted in ascending order because that's\
    \ what their code does, but I think that's a mistake and they actually want to\
    \ be sorted (without considering the duplicates), which means that `unique_digits([15,\
    \ 33, 1422, 1]).sort == [1, 15, 33]`. But I may be wrong and if OP clarifies they\
    \ can change it accordingly.\n<|/ c |>\n<| c |>\nI think `[15, 33, 1422, 1]` should\
    \ return `[1, 15, 33]` because it has no digits in the first position. Your code\
    \ returns `[1, 10, 15, 33]`. I don't believe this is what OP wants. And I believe\
    \ `unique_digits([10, 9, 4, 7])` should return `[4, 7] because `7` has digits\
    \ in all positions. I believe OP does not want to consider duplicates.\n<|/ c\
    \ |>\n<| a |>\n<code>\n def unique_digits(x)\n      x.uniq.select{ |x| x.split(\
    \ /\\d/).length != x.split( /\\d/).uniq.size }\n    end\n</code>\n<|/ a tags=ruby\
    \ dscore=0 |>\n<| a dscore=0 |>\nI believe this is what you're trying to do:\n\
    <code>", "  x.each { |item| puts item if item.to_s.scan(/\\d/).size == 1 }\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis is actually a really clever solution. Unfortunately\
    \ it doesn't work for my example above. `unique_digits([15, 33, 1422, 1])` gives\
    \ `=> [1, 15, 33]` whereas I expect `=> [15, 33]` because `33` has no digit at\
    \ all.\n<|/ c |>\n<| c |>\nI've updated the answer to show how to get the expected\
    \ result. Also note that your function didn't actually work. It wouldn't even\
    \ give the expected result. Just fixed it for you.\n<|/ c |>\n<| c |>\nWow, it\
    \ works. This is really clever solution to my problem. However I wonder why I\
    \ can't understand why `unique_digits([15, 33, 1422, 1])` returns `[1, 15, 33]`\
    \ instead of `=> [15, 33]` like other people suggest. Since `33` has no digit\
    \ at all. Isn't `x.each` going through `[15, 33, 1422, 1]` all at once?\n<|/ c\
    \ |>\n<| c |>\nI believe that `x.each` iterates through the array sequentially.\
    \ `[15, 33, 1422, 1]` is an array, and `1` is also an array. So the `.each` method\
    \ doesn't take two arrays as arguments but instead takes each individual item\
    \ in the array as the argument. This means it iterates through the items in the\
    \ array, one at a time. And since `1` is an array, it iterates through each item\
    \ in the array.\n<|/ c |>\n<| c |>\nI think I figured it out. `x.each` iterates\
    \ through array item by item. But it also passes argument to block which is item\
    \ itself, so `1` becomes `1`. Because `1` was passed as an argument to block,\
    \ `1` becomes `item` in `block`. And this behavior is also consistent with `map`,\
    \ `reduce` and `inject`.\n<|/ c |>\n<| a |>\n<code>", "\tx.sort!\n\ta = []\n\t\
    a.push(x[0])\n\tb = x[0..1]\n\tfor x in b\n\t\ta.push x\n\ta\nend", "    x.sort!\n\
    \    res = []\n    (1..x.size).each do |i|\n        if x[i] % 2 == 0 then\n  \
    \          res << x[i]\n        end\n    end\n    res\nend\n</cell>\n<cell>\n\
    unique_digits([152, 323, 1422, 10])\n</cell>\n<cell>", "  x.map!{|i| i.to_s}.uniq!.sort\n\
    end\n</pre>\n</div>", "  x.sort.each do |y|\n    break if y % 2 == 0\n  end\n\
    \  x\nend", "  x.sort!\n  result = []\n  x.each do |n|\n    result << n if n.to_s.chars.uniq.size\
    \ != 1\n  end\n  result\nend", "    digits = []\n    for i in x\n        digits.push(i.to_s)\n\
    \    end\n    \n    unique = []\n    i = 0\n    while i < x.size\n        begin\n\
    \            if digits[i].to_s.length % 2 == 0\n                unique.push(digits[i])\n\
    \            else\n                i += 1\n            end\n        end\n    end\n\
    \    unique.sort!\n    return unique\nend", "  x.sort\n  result = []\n  x.each_with_index\
    \ do |item, index|\n    if item % 2 == 0\n      result << item\n    end\n  end\n\
    \  result\nend", "  s = x.sort.to_a\n  result = []\n  while s.any?\n    d =  s.detect{|e|\
    \ e % 2 == 0}\n    result << d\n    s.delete(d) if s.count(d) == 0 # delete an\
    \ element that has only even digit\n  end\n  result\nend\n</code>\n<|/ a |>\n\
    <| a dscore=2 tags=sorting,ruby,algorithm,list |>\n<code>", "  x.each { |y| y.digits.uniq.sort\
    \ }\nend", "  x.sort!\n  result = []\n  x.each_with_index do |y, i|\n    if y\
    \ % 2 == 0 && i != 0\n      result << y\n      x.delete_at(i)\n    end\n  end\n\
    \  result\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI love this solution. My\
    \ approach was to delete all elements from array which has even number as a digit\
    \ (since a sorted array is given by definition). But the problem is, if I delete\
    \ all the even numbers, then the sorted array will also contain even numbers and\
    \ that is the reason why I wanted to check if an element was even and I deleted\
    \ the element if it was even.\n<|/ c |>\n<| c |>\nThe reason why I didn't want\
    \ to sort the array is that it's an assignment. I'm afraid that sorting could\
    \ be an easy solution.\n<|/ c |>\n<| c |>\nHmm, after thinking about it for a\
    \ while, I agree with you. I'll be more careful next time.\n<|/ c |>\n<| a dscore=1\
    \ |>\nUsing Array#delete_at\n<code>", "    digits = Set.new\n    x.each do |x|\n\
    \        if x % 10 == 0\n            digits.add x\n        end\n    end\n    digits.to_a\n\
    end", "  x.sort!\n  result = []\n  for i in x\n    result << i unless i.to_s.chars.uniq.count\
    \ % 2 == 0\n  result\nend\n</cell>\n<code language=julia-1.0>\nunique_digits([1,\
    \ 3, 7, 15, 2])\n</cell>\n<text>\nWrite a function that finds and prints all integers\
    \ divisible by 7 from a given \nrange.", "    x.each do |e|\n        if e =~ /\\\
    d/\n            x.delete_at(x-1)\n        end\n    end\n    return x\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nWhat about this input `unique_digits([152,323,1422,10],\
    \ :remove_zero)` ?\n<|/ c |>\n<| c |>\nThanks for pointing that out, I missed\
    \ that. I've updated my answer\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\nA\
    \ bit simpler solution using Array#uniq:\n<code>\n[1, 1, 2, 2, 3, 3, 4, 5].uniq.sort.map(&:to_i)",
  "  return x.inject([], :<<) do |result, item| \n    if (item & 1) == 0\n      result\
    \ << item\n    end\n    result\n  end\nend\n</code>\nHere we using inject to get\
    \ the unique elements out of the list. Using inject is a bit tricky because inject\
    \ returns the value that is returned in the block.\nThen we using << method to\
    \ append the element to the result.\nAnother solution is to using uniq:\n<code>",
  "  result = []\n  x.each do |i|\n    result.delete(i) if i.to_s.chars.map(&:to_i).uniq.empty?\n\
    \  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  x.sort!\n\
    \  x.map!{|i| i if i.to_s.size % 2 == 0}\n  x\nend\n</cell>\n<text>\nGiven a list\
    \ of numbers, returns the sum of all numbers \nwhich are divisible by 7.", " \
    \ result = []\n  for i in x\n    if i.to_s.length % 2 == 0\n      result << i\n\
    \  result.sort!\n  result\nend", "  return x.select{ |n| n % 2 == 0 }.sort\nend",
  "  x.sort!\n  result=[]\n  x.each do |y|\n    y=y.to_s.reverse\n    y=y.each_char.find_all\
    \ {|z| z.to_i.even?}\n    y=y.collect{|z| z.to_s}\n    if y.empty?\n      result<<y\n\
    \    else\n      y.each {|z| result<<y}\n    end\n  end\n  result\nend", "  x.sort!\n\
    \  result = x.select {|e| e % 10 == 0}\n  result.sort!\n  result\nend\n</code>\n\
    For your second function use Hash like below:\n<code>", "  x.sort! # sort the\
    \ array in ascending order\n  result = []\n  x.each_with_index do |y, i|\n   \
    \ if y % 2 == 0 && y != 0\n      result << y\n    end\n  end\n  result.sort!\n\
    \  result\nend", "  result = x.to_a\n  result.each_index do |i|\n    result.delete_if{|i|\
    \ i % 2 != 0}\n  end\n  result\nend\n</code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThis is a good answer but it is inefficient because it does a linear\
    \ scan of all elements each time. Also note that `sort` can be combined with `uniq`\
    \ instead of `delete_if`: `a.sort{|a,b| a.to_s.reverse <=> b.to_s.reverse }.reduce(:uniq).reverse`\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails dscore=0 |>\n<code>", "    put = []\n \
    \   put.push(x)\n    put.each do |i|\n        if i.odd?\n            put = put.select\
    \ { |i| i.odd? }\n        end\n    end\n    put.sort!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,algorithm\
    \ |>\n<| c |>\nOh! this is interesting. Thanks for sharing!\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,algorithm\
    \ |>\nHere is a solution that only uses one pass over the input array:\n<code>",
  "  result = []\n  x.each do |i|\n    temp = i\n    result.each do |j|\n      break\
    \ if i != j && temp % 10 == 0 \n    end\n  end\n  result\nend", "  return x.sort.uniq.compact\n\
    end", "  x.sort!\n  ret = []\n  x.each do |i|\n    ret[i] ||= 0\n    ret.push(1)\
    \ if ret[i] % 2 != 0\n    ret[i] += 1 \n  end\n  ret.uniq.sort\nend\n</code>\n\
    And now we know how we can get the answer, just put it all together and write\
    \ a method for it.\n<code>", "    seen = {}\n    unique_digits = []\n    for i\
    \ in x do\n        if seen[to_int(i)] then\n            unique_digits << i\n \
    \       else\n            seen[to_int(i)] = true\n        end\n    end\n    return\
    \ unique_digits\nend", "  x.sort { |a,b| a <=> b }\n  x.delete_if { |x| (x % 10).zero?\
    \ }\nend", "  x.sort!\n  result = []\n  x.each do |i|\n    result.push(i) if i.to_s.scan(/\\\
    d/).length != 0\n  end\n  result\nend", "    x.sort!\n    res = x.find { |x| x.to_s.split('').uniq.size\
    \ < x.to_s.size}\n    x.delete_at(res ||= 0)\n    x\nend", "  sorted = x.sort\
    \ { |a,b| a[0] <=> b[0] }\n  sorted = sorted.select { |i| i[0] % 2 == 0 }\n  sorted.sort!\n\
    end", "  result = Hash.new(0)\n  x.each do |i|\n    result << i if i%2 == 0\n\
    \  end\n  result.sort.reverse\nend", "    digits=[]\n    digit_count={} # a hash\
    \ of digits to count\n    x.each do |i|\n        digit = i\n        if digit_count.has_key?(digit)\n\
    \            digit_count[digit] += 1\n        else\n            digit_count[digit]\
    \ = 1\n        end\n    end\n    digit_count.sort.each do |digit,count|\n    \
    \    if count == 1\n            digits << digit\n        end\n    end\n    return\
    \ digits\nend", "  x.sort!\n  result = []\n  seen = {}\n  x.each do |x|\n    seen[x]\
    \ ? result.push(x) : seen[x] = true\n  end\n  result\nend\n</cell>\n<cell>\nunique_digits([15,\
    \ 33, 1422, 1])\n</cell>\n<cell>\nunique_digits([152, 323, 1422, 10])\n</cell>\n\
    <text>\nCome to think of it, this approach is still a little slower than the one\
    \ presented in the previous notebook. Let's see if we can make an improvement.",
  "    x.sort!\n    \n    x.collect!{|x| (x%10).zero? ? x : x%10}\n    \n    x.flatten!\n\
    \    \n    x.each do |n|\n        x.delete_if { |y| y.zero? }\n        \n    \
    \    x.delete_if { |y| y.odd? }\n    end\n    \n    return x\nend\n</cell>\n<code\
    \ language=julia-1.4>\nfunction unique_digits(x)\n    x.sort!\n    \n    x.collect!{|x|\
    \ (x%10).zero? ? x : x%10}\n    \n    x.flatten!\n    \n    x.each do |n|\n  \
    \      x.delete_if { |y| y.zero? }\n        \n        x.delete_if { |y| y.odd?\
    \ }\n    end\n    \n    return x\nend\n</cell>\n<code language=julia-1.4>", " \
    \ x.sort! # in-place\n  result = x.delete_if do |x|\n    (x.to_s.reverse.chars.map(&:to_i).uniq.count\
    \ {|x|x}) == x.to_s.length\n  end\n  result.sort!\n  result\nend", "    x.sort\n\
    \    result = []\n    i = 0\n    while i < x.length\n        current = x[i]\n\
    \        j = 0\n        while j < i && x[j] % current == 0\n            j += 1\n\
    \        if j <= i\n            result.push(current)\n            i += j\n   \
    \     end\n    end\n    return result\nend", "  x.uniq = Set.new\n  \n  x.each\
    \ do |item|\n    if item % 2 == 0\n      x.uniq << item\n    end\n  end\n  \n\
    \  x.uniq\nend", "  x.sort\n  unique_x = []\n  x.each do |i|\n    if i.to_s.chars.uniq.size\
    \ < 2\n      unique_x << i\n    end\n  end\n  unique_x\nend", "  x.uniq!\n  x.select\
    \ {|i| !i.zero? and i.odd? }.sort\nend", "  return x.sort_by{|x| x.to_s.reverse.to_i}\n\
    end", "  x.sort!\n  x.uniq!\n  x\nend\n</code>\n<|/ a |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>\narr = [5, 1, 2, 8, 3, 9, 4, 3, 5, 4, 1, 2, 8]\narr.sort.uniq.each_with_object([])\
    \ do |e, a|\n  a.include?(e) ? a.unshift(e) : a << e\nend", "  x.sort!\n  x.map!{|e|\
    \ e.to_i}\n  x = x.select{|e| e % 2 == 0}\n  x = x.map{|e| [e, 10*e].join}\n \
    \ x.select!{|e| e.split('').sort.uniq.size == 1}\n  x.to_a.sort\nend", "  return\
    \ x.sort { |x, y| x < y ? -1 : x > y ? 1 : 0 }\nend", "  \n  # O(n) time\n  x_hash\
    \ = Hash.new\n  \n  # O(n) time\n  x.each do |num|\n    digit = num.to_s[/\\d/]\n\
    \    x_hash[digit] ? x_hash[digit] << num : x_hash[digit] = [num]\n  end\n  \n\
    \  # O(2) time\n  x.sort.select {|num| x_hash.has_key?(num.to_s[/\\d/]) }\nend",
  "  if x.is_a?(Array)\n    x.sort.uniq\n  elsif x.is_a?(Numeric)\n    x.to_s.chars.sort.uniq.map\
    \ {|i| i.to_i}\n  else\n    raise ArgumentError, \"Expected x to be a list or\
    \ numeric value, got #{x.class}\"\n  end\nend", "    \n    numbers = []\n    \n\
    \    for i in x\n        if i.to_s(0).index('1').nil?\n            numbers <<\
    \ i\n        else\n            numbers = []\n        end\n    end\n    \n    numbers\n\
    end", "  x.each_index do |i|\n    if x[i] % 2 == 0\n      x[i] = x[i] / 2\n  \
    \    x.delete_at(i)\n    end\n  end\n  x\nend", "  result = []\n  x.each do |i|\n\
    \    result << i if i.to_s.chars.map(&:to_i).uniq.size == 1\n  end\n  result.sort\n\
    end", "  \n  result = []\n  \n  x.each do |x| \n    if (x % 10 == 0)\n      result\
    \ = result + x\n    else \n      break\n    end\n  end", "  x.each do |el|\n \
    \   return el if el % 10 == 0\n  end\n  x\nend\nputs unique_digits([15, 33, 1422,\
    \ 1])\nputs unique_digits([152, 323, 1422, 10])", "  x.sort!\n  result = []\n\
    \  for i in x\n    if i.to_s.length < 2\n      break\n    if i.to_s.length % 2\
    \ == 0\n      result << i\n    end\n  end\n  return result\nend", "  sorted =\
    \ x.sort\n  \n  while sorted.any?\n    current = sorted.shift\n    next == nil\
    \ ? sorted << current : sorted.each do |elem|\n      if elem.to_s.split(//).uniq.size\
    \ == 1\n        sorted.delete(elem)\n        next\n      end\n    end\n  end\n\
    \  \n  sorted\nend", "  x.sort # Sort first for easy check\n  new_list = []\n\
    \  x.each do |num|\n    if num.even?\n      new_list << num\n    end\n  end\n\
    \  new_list\nend", "  x.each_with_index.with_object([]) { |n, i| n if n.to_s.chars.all?\
    \ { |i| i.to_i % 2 == 0 } }\nend", "  x.sort!\n  i = 0\n  result = []\n  while\
    \ i < x.length\n    el = x[i]\n    break if x[i] == 0\n    i += 1\n    el = el\
    \ % 10\n    result << el\n  end\n  return result\nend", "  x.sort\n  result =\
    \ []\n  \n  for i in x\n    \n    while (result[-2, -1].to_i > i.to_i) && (i..to_i\
    \ < result[0, -2])\n      result << i\n    end\n    \n    if i..to_i < result[0,\
    \ -2]\n      result << i\n    end\n  end\n  \n  result\nend\n</cell>\n<code language=julia-0.4>\n\
    unique_digits([15, 33, 1422, 1])\n</cell>\n<code language=julia-0.4>\nunique_digits([152,\
    \ 323, 1422, 10])\n</cell>\n<text>\nProblem 3", "    x.each do |x|\n        if\
    \ x.to_s.gsub!(/[\\d]/,'') then\n        x.to_s.gsub!(/\\d/,'') \n        if x.to_s.gsub(/\\\
    d/,'').empty? then\n        x.to_s\n        else\n        end\n        else \n\
    \        end\n    end \nend\n</code>\n<|/ a tags=ruby-on-rails,ruby |>\n<| a |>\n\
    Here's a way that doesn't use regular expressions:\n<code>", "  x.sort!\n  x.map!\
    \ { |a| a.to_i }\n  x.uniq!\n  x\nend", "  x.uniq!\n  x.sort!\n  x.reject!{|e|\
    \ e.to_s.chars.map(&:to_i).reject {|i| i.even?}.any? }\n  x\nend\n</code>\n<|/\
    \ a |>\n<| a |>\nIf your input array is not too big, you can sort it, then take\
    \ all numbers divisible by 4 or 5, and sort them again by taking only the last\
    \ digit of each number and sorting them in reverse order.\n<|/ a dscore=0 tags=ruby\
    \ |>\n<| c |>\nWhat if the input array is too big?  Also, can you give any sample\
    \ code?  I will be testing this out tonight.\n<|/ c |>\n<| c |>\n: What do you\
    \ think this algorithm is doing? How does it compare to the other solutions given?\
    \ It's a good candidate for reject and uniq, because of the ability to reorder\
    \ and reject elements in the list, but that doesn't make it any more or less efficient\
    \ than a solution that's O(n).\n<|/ c |>\n<| c |>\n: I suggest you write out the\
    \ algorithm and try to convince yourself that it's better than the current solution.\n\
    <|/ c |>\n<| c |>\n: How can you say it's O(n)? It looks like O(n log n). And\
    \ how do you compare O(n) with O(n log n), for example?\n<|/ c |>\n<| c |>\n:\
    \ I said that it's O(n log n) because if you sort an array first, you can't know\
    \ where the first element ends and where the last one begins. You have to do n\
    \ log n operations.\n<|/ c |>\n<| a |>\nHere's a more Rubyish approach:\n<code>",
  "  x.sort!\n  r = []\n  i = 0\n  while i < x.size\n    while i < x.size and x[i].to_s.size\
    \ % 2 == 0\n      i += 1\n    end\n    if i > x.size\n      r += x[i..x.size]\n\
    \      break\n    else\n      r += x[i..i]\n    end\n    i += 1\n  end\n  return\
    \ r\nend", "  x.sort!\n  x.each do |i|\n    next if i =~ /^0$/\n    x[i.to_s.index('').to_i]\n\
    \  end\nend", "  return x.select{|i| i.to_s.chars.uniq.size != i.to_s.size}.sort\n\
    end", "  \n  x.map!{ |num| num.to_s.split(//).map(&:to_i).sort.uniq.size }\n \
    \ x.sort.uniq\nend", "  x.sort\n  result = []\n  while x.size > 0\n    x = x.dup\n\
    \    x.delete_if { |y| y % 10 != 0 }\n    result << x.first\n  end\n  result\n\
    end", "    digit_set = Set.new\n    x.each { |i| digit_set.add i if i.to_s.chars.uniq.size\
    \ > 1 }\n    return digit_set\nend", "  # Write your code here\n  return []\n\
    end", "  x.sort!\n  result = []\n  x.each do |x|\n    i = x.to_s.split('').map(&:to_i).each_cons(2).find\
    \ { |y, z| y % 2 == 0 && !result.include?(z) }\n    result << i ? i.to_i : nil\n\
    \  end\n  return result\nend", "    digits = []\n    digit = 1\n    while x.include?(digit)\n\
    \        digit += 1\n    end\n    while x.include?(digit)\n        digits << x.pop(digit)\n\
    \    end\n    digits.sort!\n    return digits\nend", "  x.sort!\n  unique = []\n\
    \  \n  x.each do |e|\n    if e < 10\n      unique << e\n    end\n  end\n  unique\n\
    end", "  x.sort!\n  x.uniq!\n  x\nend", "  x.uniq!\n  x.uniq.sort\nend\n</code>\n\
    <|/ a tags=ruby,hashmap dscore=0 |>\n<| c |>\nNot sure I understand what you mean\
    \ by \"a map doesn't have any key twice\". It does, and it's not a duplicate key.\n\
    <|/ c |>\n<| c |>\nI agree, the question was a bit unclear on that, but I suspect\
    \ OP had a point about a map with duplicate keys.\n<|/ c |>\n<| c |>\nOh yeah.\
    \ That's true.\n<|/ c |>\n<| c |>\nYes, I have misunderstood the question.\n<|/\
    \ c |>\n<| a |>\nI wrote a solution that does not use any built-in functions.\
    \ It uses Hash.", "  x.sort.uniq\nend", "  x.each do |e|\n    if e % 2 == 0\n\
    \      puts \"#{e} is even\"\n    end\n  end\nend", "\tx.map!{ |y| y % 10 }\n\t\
    x.select { |y| y % 2 != 0}\n\tx.sort\nend", "  x.sort!\n  ret = []\n  i = 0\n\
    \  while i < x.length\n    if x[i].to_s.length != 0\n      j = i + 1\n      while\
    \ j < x.length\n        if x[j].to_s.length == 0\n          ret << x[j]\n    \
    \      j += 1\n        end\n      end\n    end\n    i += 1\n  end\n  ret\nend",
  "    x.sort!\n    y = []\n    for i in x\n        y << i if i.to_s.match(/\\A\\\
    d*\\z/).nil? \n    end\n    y\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\nTo find all elements of arr which do not have any even digits:\n<code>\n\
    arr.select { |x| x.to_s.chars.map(&:to_i).none?(&:odd?) }\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nHere's another solution:\n<code>\narr = %w{33 1 6 2 15 33 1422}\n\
    arr.group_by { |x| x.to_s.chars.map(&:to_i) }.values.select { |x| x.map(&:size).all?\
    \ { |y| y.odd? } }", "    x.sort\n    x.uniq.sort\nend", "    x.each_with_index.select\
    \ { |e,i| i % 2 == 0 }\nend", "  x.each do |x|\n    x.to_s.chars.uniq.each do\
    \ |y|\n      y.to_s.chars.uniq.each do |z|\n        if z != \"0\"\n          return\
    \ x if y == z\n        end\n      end\n    end\n  end\n  nil\nend", "  x.sort!\n\
    \  ret = []\n  x.each do |i|\n    ret << i if i.to_s.chars.uniq.size == 1\n  end\n\
    \  ret\nend", "  x.sort!\n  ret = []\n  ret.reject! {|n| n.to_s.scan(/[\\d]/).all?\
    \ {|d| d.odd?}}\n  ret\nend", "    x.sort.each do |y|\n        if y % 2 != 0\n\
    \            x.delete(y)\n        end\n    end\n    x\nend\n</cell>\n<code language=conda-env-Anaconda3-py>\n\
    unique_digits([15, 33, 1422, 1])\n</cell>\n<text>\nNow let's apply our functions\
    \ to calculate what we need.", "  x.sort.reduce(:<<)\n  x.reject{|i| i.reverse.to_i.odd?}.sort.reduce(:<<)\n\
    end\n</cell>\n<cell>\nunique_digits([22, 345, 345, 454, 245])\n</cell>\n<cell>",
  "  x.uniq!\n  x.uniq!.select { |i| i.to_s.length % 2 == 0 }\nend", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.split(\"\").uniq.size\
    \ == 1\n  end\n  result.sort\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c\
    \ |>\nThis is a very concise solution. Thank you for sharing it.\n<|/ c |>\n<|\
    \ c |>\nHi I wanted to upvote this but I am unable due to my reputation. Sorry\
    \ about that but could you tell me why you used `x.sort!` and not just `x.sort`?\n\
    <|/ c |>\n<| c |>\nIt's just for sorting (I prefer `sort!` to be explicit), but\
    \ also, to give a hint for the optimization of Ruby to avoid the sorting of the\
    \ original array.\n<|/ c |>\n<| c |>\nAh okay, I didn't know that. Thanks!\n<|/\
    \ c |>\n<| a tags=ruby |>\nHere is an example of how to do it in Ruby using the\
    \ each_cons method.\n<code>", "  x.sort!\n  even = true\n  x.each_with_index do\
    \ |y,i|\n    if y % 2 == 0 && !even\n      even = false\n      x.delete_at(i)\n\
    \    else\n      even = true\n    end\n  end\n  return x\nend", "  x.uniq!\n \
    \ x.delete_if { |x| x.to_s.length == 0 }\n  x.sort_by { |x| x.to_i }\n  x\nend",
  "  x.uniq!\n  x.select { |e| e =~ /^\\d+$/ }.sort\nend", "    seen = {}\n    odd\
    \ = {}\n    unique_digits_x = [x for x in x if not odd[x] and str(x).count('1')\
    \ < 1]\n    unique_digits_x.sort(key=int)\n    unique_digits_x.extend(x for x\
    \ in unique_digits_x if str(x).count('1') < 1)\n    return unique_digits_x\n</code>\n\
    <|/ a tags=python-3.x,algorithm,sorting |>\n<| a tags=python-3.x,algorithm,sorting\
    \ |>\nThis might be a bit overkill but this also sorts by length of digits.  It\
    \ does this by converting to a string then counting the digits.  I haven't checked\
    \ this on large lists.\n<code>", "  result = []\n  x.each do |num|\n    result.concat(num.to_s.split('').map\
    \ { |i| i.to_i if i.to_i.odd? }.sort)\n  end\n  result.uniq\nend", "    return\
    \ x.map {|i| i if i % 10 == 0 }\n      .sort_by {|i| i }\n      .uniq\nend\n</code>\n\
    In your second question you asked how to use each item in a collection, so you\
    \ might want to take a look at map, collect and reduce. \nmap allows you to transform\
    \ each item in a collection. collect allows you to transform the items in a collection\
    \ and merge it into a new collection. reduce allows you to reduce the items in\
    \ a collection or a collection of collections. You will want to use these functions\
    \ on collections, rather than the items in the collection. \nmap is used to transform\
    \ each item in a collection. collect is similar to map but will merge each item\
    \ in the collections into a new collection. reduce is used to reduce the items\
    \ in a collection or a collection of collections. You will want to use these functions\
    \ on collections, rather than the items in the collection. \nA good resource for\
    \ learning more about using these functions is Ruby's Core API's and Objects.\
    \ \nRuby's documentation is pretty good too.\n<|/ a dscore=5 tags=ruby |>\n<|\
    \ c |>\nNice! That was a long answer for a short question. Thank you!\n<|/ c |>\n\
    <| c |>\nVery good explanation, but if my input is 152 323 1422 10, the result\
    \ should be [152, 323, 1422] instead of [1, 15, 33, 1422]\n<|/ c |>\n<| c |>\n\
    He added `[152, 323, 1422, 10]` to his question, so I assumed he wanted to filter\
    \ out numbers containing more than one digit.\n<|/ c |>\n<| c |>\nYes, thats correct,\
    \ your answer helps me in solving the first part of the problem (filter out elements\
    \ that has more than one digit)! Thanks!\n<|/ c |>\n<| c |>\nHi, just want to\
    \ share the link to ruby core API and objects link: https://ruby-doc.org/core/index.html\n\
    <|/ c |>\n<| a dscore=3 tags=ruby |>\nFor a more general solution I suggest a\
    \ recursive approach:\n<code>", "    x.sort!\n    x.reverse!\n    even = []\n\
    \    odd = []\n    x.each do |n|\n        return odd if n % 2 == 0\n        even.push(n)\n\
    \    end\n    even.each do |n|\n        odd << n\n    end\n    even.reverse!\n\
    \    even.each do |n|\n        x.delete(n)\n    end\n    odd\nend\n</cell>\n<code\
    \ language=julia-1.5>", "  y = x.clone\n  y.reject! { |e| e % 10 == 0 }\n  y.sort!\n\
    \  y\nend\n</cell>\n<cell>", "  x.sort!\n  result = []\n  for i in x\n    if i\
    \ % 2 == 0\n      result << i\n    end\n  end\n  result\nend\n</cell>\n<cell>\n\
    unique_digits([15, 33, 1422, 1])\n</cell>\n<cell>\nunique_digits([152, 323, 1422,\
    \ 10])\n</cell>\n<cell>", "    x.sort\n    \n    seen = {}\n    \n    return x.select\
    \ { |i| !seen[i] && !seen[i % 10] }\nend", "    digits = {}\n    for i in x\n\
    \        digits[i] = digits[i] if i in digits else 0\n    end\n    unique_digits\
    \ = []\n    digits_count = 0\n    for i in digits.keys()\n        digits_count\
    \ += 1\n        if digits[i] != 0\n            unique_digits[i] = i\n        \
    \    digits[i] = 0\n            digits_count += 1\n            if digits_count\
    \ > 1\n                break\n        end\n    end\n    return unique_digits\n\
    end", "    return x.select{|i| x.count(i) % 2 == 0}\nend", "    x.sort!\n    return\
    \ x if x.count == 0 \n    \n    even = x.select {|i| i.to_i.to_s % 2 != 0}\n \
    \   even.sort!\n    \n    (even.size + 1).times do |i|\n        if even[i]\n \
    \           even.delete_at(even.index(even[i]))\n            even.delete_at(i)\n\
    \        end\n    end\n    \n    even\nend", "  x.each do |y|\n    x.delete_if\
    \ {|z| y % z == 0 && z.odd?}\n  end\nend", "  x.sort!\n  ret = []\n  x.each do\
    \ |x|\n    ret.push(x) if x.to_s.chars.map(&:to_i).reject {|e| e % 2 == 0 }.size\
    \ < 1\n  end\n  ret\nend", "    x.sort!\n    res = []\n    odd_idx = nil\n   \
    \ x.each_with_index do |el,idx|\n        if el % 2 == 0\n            odd_idx =\
    \ idx\n        else\n            if el > 0\n                res << el\n      \
    \      end\n        end\n    end\n    res << x[odd_idx]\n    res\nend", "  x.sort!\n\
    \  n = []\n  x.each do |x|\n    if x.modulo(10).zero?\n      n << x\n    end\n\
    \  end\n  n.sort!\n  n\nend\n</cell>\n<cell>", "    x.sort\n    unique_digits\
    \ = []\n    for i in x\n        digit = Integer(i).digit\n        if digit.even?\n\
    \            unique_digits << digit\n        end\n    end\n    unique_digits.sort\n\
    end\n</cell>\n<code language=julia-0.4>", "    x.uniq!\n    x.compact.uniq!\n\
    \    x.sort_by!(&:to_i).uniq!\nend\n</code>\nTest\n<code>\nunique_digits([15,\
    \ 33, 1422, 1])", "    x.sort!\n    res=nil\n    x.each do |i|\n        if res!=nil\
    \ and res[-1].even?\n            break\n        else\n            res||=[]\n \
    \           res<<i\n        end\n    end\n    res\nend", "  x.sort!\n  result\
    \ = []\n  last = 0\n  x.each do |i|\n    if i.to_s.scan(/\\d/).length == 0\n \
    \     result << i\n    end\n  end\n  result\nend", "  if x.nil? then return x\
    \ else unique_digits([x[0]] + x[1:])\n  \n  \n  # Create a hash table for O(1)\
    \ lookup\n  h = {}\n  \n  # Create a helper function to add each element of x\
    \ to a \n  # hash table and to remove each element of x that has \n  # a digit\
    \ as a prefix \n  def digits_add(n)\n    unless h.has_key?(n)\n      h[n] = true\n\
    \      x.each{|i| digits_add(i)}\n    end\n  end\n  \n  digits_add(0)\n  \n  #\
    \ Filter out elements with even digits and sort them in\n  # increasing order\n\
    \  x.select{|i| i[0] & 1 != 0 }.sort{|a,b| a <=> b}\nend\n</cell>\n<cell>\nunique_digits([15,\
    \ 33, 1422, 1])\n</cell>\n<cell>\nunique_digits([152, 323, 1422, 10])\n</cell>\n\
    <text>\nQuestion 15\nGiven a list, return a list of all lists containing only\
    \ \neven digits, sorted from largest to smallest number.", "  return x.uniq.compact\n\
    end", "  sorted = x.sort\n  result = []\n  while sorted.length > 0\n    index\
    \ = sorted.find{|x|x.to_i < 10}\n    result.append(sorted.delete_at(0))\n  end\n\
    \  result\nend", "  unique = []\n  x.sort.each do |y|\n    unique.delete(y.to_s.chars.uniq.sort.join)\n\
    \  end\n  unique\nend", "  x.sort!\n  result = []\n  while x\n    result << x.pop\
    \ if x.select { |y| y % 2 == 0 }.size == 0\n  end\n  result\nend", "  return x.select{|x|\
    \ x.to_s.split(\"\").uniq.size != x.to_s.size}.sort\nend", "  x.sort!\n  evens\
    \ = x.select { |i| i.to_s.split(//).uniq.size % 2 == 0 }\n  evens.empty? ? x :\
    \ evens\nend", "    digits = x.digits.map(&:to_s)\n    unique_digits = x.select\
    \ { |d| !digits.include?(d) }\n    unique_digits.sort\nend", "  x.sort!\n  result\
    \ = []\n  for x in x\n    x % 10 == 0 ? true : false \n    result.push x\n  end\n\
    \  return result\nend", "  return x.select { |i| x.all? { |j| j % i == 0 } }\n\
    end", "    x.sort\n    \n    even = []\n    odd  = []\n    \n    x.each do |e|\n\
    \        (e%2).zero? ? odd << e : even << e\n    end\n    \n    (even+odd).uniq\n\
    end", "  x.sort!\n  digits = []\n  x.each do |x| \n    x.to_s.reverse.split(\"\
    \").each do |y| \n      if y != \"0\"\n        y != \"9\" && digits << y \n  \
    \    end\n    end\n  end\n  digits.sort!\n  return digits\nend\n</cell>\n<cell>\n\
    unique_digits([15, 33, 1422, 1])\n</cell>\n<cell>\nunique_digits([152, 323, 1422,\
    \ 10])\n</cell>\n<cell>", "    ans = []\n    seen = {}\n    \n    for v in x\n\
    \        seen[v] = true\n        \n    x.each_index { |i|\n        if x[i] % 2\
    \ != 0\n            ans << x[i]\n        end\n    }\n    \n    return ans\nend",
  "  x.sort\n  x\n  result = []\n  x.each_with_index do |i, idx|\n    while idx >\
    \ 0 && x[idx] % 10 == 0 && result.include? i\n      result.delete(i)\n      idx\
    \ -= 1\n    end\n    result << i if i.to_s.chars.uniq.size == 1\n  end\n  result.sort\n\
    end", "  x.sort!\n  ret = []\n  x.each do |i|\n    flag = true\n    x.each do\
    \ |j|\n      if i % j == 0\n        flag = false\n      end\n    end\n    if flag\n\
    \      ret << i\n    end\n  end\n  ret\nend", "    digits = []\n    seen = {}\n\
    \    for i in x\n        if seen[i / 10] != 0\n            digits.push(i / 10)\n\
    \            seen[i / 10] = seen[i / 10] + 1\n        end\n    end\n    digits.sort\n\
    \    return digits\nend", "  return x.uniq.sort_by(&:to_s)\nend\n</cell>\n<text>\n\
    Q3. Given a list of integers x. return a sorted list of all elements that hasn't\
    \ any odd digit.\nNote: Returned list should be sorted in increasing order.\n\
    For example:\n>>> unique_digits([15, 33, 1422, 1])\n[1, 33, 15]\n>>> unique_digits([152,\
    \ 323, 1422, 10])\n[]\n</text>\n<code language=julia-1.0>\nfunction unique_digits(x)\n\
    \  return x.uniq.sort_by(&:to_s)\nend\n</cell>\n<text>\nQ4. Given a list of integers\
    \ x. return a sorted list of all elements that hasn't any non repeating digit.\n\
    Note: Returned list should be sorted in increasing order.\nFor example:\n>>> unique_digits([15,\
    \ 33, 1422, 1])\n[1, 33, 15]\n>>> unique_digits([152, 323, 1422, 10])\n[1, 10]\n\
    </text>\n<code language=julia-1.0>\nfunction unique_digits(x)\n  return x.uniq.sort_by(&:to_s)\n\
    end\n</cell>\n<text>\nQ5. Given a list of integers x. return a sorted list of\
    \ all elements that hasn't any digit that is repeated more than twice in the list.\n\
    Note: Returned list should be sorted in increasing order.\nFor example:\n>>> unique_digits([15,\
    \ 33, 1422, 1])\n[1, 33, 15]\n>>> unique_digits([152, 323, 1422, 10])\n[1, 10]\n\
    </text>\n<code language=julia-1.0>\nfunction unique_digits(x)\n  return x.uniq.sort_by(&:to_s)\n\
    end\n</cell>\n<text>\nQ6. Given a list of integers x. return a sorted list of\
    \ all elements that hasn't any digit that is repeated more than three times in\
    \ the list.\nNote: Returned list should be sorted in increasing order.\nFor example:\n\
    >>> unique_digits([15, 33, 1422, 1])\n[1, 33, 15]\n>>> unique_digits([152, 323,\
    \ 1422, 10])\n[1, 10]\n</text>\n<code language=julia-1.0>\nfunction unique_digits(x)\n\
    \  return x.uniq.sort_by(&:to_s)\nend\n</cell>\n<text>\nQ7. Given a list of integers\
    \ x. return a sorted list of all elements that hasn't any digit that is repeated\
    \ more than five times in the list.\nNote: Returned list should be sorted in increasing\
    \ order.\nFor example:\n>>> unique_digits([15, 33, 1422, 1])\n[1, 33, 15]\n>>>\
    \ unique_digits([152, 323, 1422, 10])\n[1, 10]\n</text>\n<code language=julia-1.0>\n\
    function unique_digits(x)\n  return x.uniq.sort_by(&:to_s)\nend\n", "  x.uniq!\n\
    \  x.group_by{|x| x.to_s}.map{|k, v| v unless v.empty? }.sort{|a,b| a.to_i <=>\
    \ b.to_i}\nend", "  x.sort\n  result = []\n  for i in x\n    if i =/= 0\n    \
    \  result << i\n    end\n  end\n  result.sort\nend\n</cell>\n<code language=julia-0.6>\n\
    @time unique_digits([152, 323, 1422, 10])\n</cell>\n<code language=julia-0.6>\n\
    @time unique_digits([1, 2, 3, 4, 5, 6])\n</cell>\n<code language=julia-0.6>",
  "    x.sort!\n    y = x.uniq\n    y.empty? ? nil : y\nend", "  x.sort.each do |i|\n\
    \    i = i.to_s\n    i = i.split(\"\")\n    i.each_with_index do |j, index|\n\
    \      if j % 2 != 0\n        x.delete(i[index])\n      end\n    end\n  end\n\
    end", "    unique_digits = []\n    x.each do |i|\n        if i.to_s.include? \"\
    .\"\n            digit = i.to_s.split(\".\")[0]\n            unique_digits <<\
    \ digit\n        else\n            unique_digits << i\n        end\n    end\n\
    \    unique_digits.sort!\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 tags=arrays,ruby\
    \ |>\nMy take:\n<code>", "  x.sort!\n  result = []\n  x.each do |e|\n    next\
    \ if e.to_s.chars.uniq.empty?\n    if e % 2 == 0\n      result.push(e)\n    end\n\
    \  end\n  result\nend", "  x.sort!\n  ret = []\n  for i in x\n    if (x.count(i)\
    \ % 2 == 0)\n      ret << i\n  end\n  ret.sort!\n  ret\nend", "    x.sort!\n \
    \   x.reverse!\n    x.delete_if{ |x| x.to_i.even? }\n    x\nend", "  x.sort!\n\
    \  return x if x.size <= 1 \n  x.delete_if{|n| n % 2 == 0} \nend", "  x.select\
    \ { |x| x.to_i.even? }.sort\nend", "  x.sort!\n  x.each_with_index do |n,i|\n\
    \    next if n % 2 == 0\n    x.delete_at(i)\n  end\n  x\nend\n</cell>\n<text>\n\
    3.4", "  x.sort!\n  seen = Set.new\n  result = []\n  for x in x\n    seen.add(x)\n\
    \    result << x if x =~ /^\\D/ \n  end\n  result\nend", "  x.sort!\n  x.reverse!\n\
    \  x.each do |i|\n    while i =~ /\\d/ && i > 0\n      i -= 1 \n    end\n    x.delete_if\
    \ {|i| i == 0}\n  end\n  x.sort!\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>", "  result = []\n  x.each do |n|\n    if n.to_s.chars.uniq.size\
    \ <= 1\n      result << n\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a dscore=0 |>\n<code>", "  x.uniq!\n  x.sort!\n  x.reject{|v|\n    (v.to_s.to_i(10).to_s(1)\
    \ == \"\")\n  }\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays,algorithm,sorting,unique\
    \ |>\n<| c |>\nThis approach doesn't take into account negative numbers. In Ruby\
    \ you can do `x.uniq.sort`.\n<|/ c |>\n<| c |>\n: You're right. I should have\
    \ read more carefully before posting. Fixed.\n<|/ c |>\n<| c |>\nYour implementation\
    \ does return the negative numbers, though.\n<|/ c |>\n<| c |>\n: `(x.to_s.to_i(10).to_s(1)\
    \ != \"\")` is equivalent to `(x.to_s.to_i(10) != \"\")`. Therefore, only positive\
    \ numbers are returned. Could you please explain what you mean?\n<|/ c |>\n<|\
    \ c |>\nMy mistake. My apologies.\n<|/ c |>\n<| a dscore=0 |>\nHere is another\
    \ solution in Ruby\n<code>", "  result = []\n  x.each do |x|\n    i = 0\n    while\
    \ (x/10).to_i > 0\n      result += [x%10]\n      x /= 10\n    end\n    result\
    \ += [x/10]\n  end\n  result\nend", "  return x.uniq.sort_by(&:to_s).take_while{|x|\
    \ x % 2 == 0}\nend", "  x.sort!\n  result = []\n  x.each do |n|\n    next if n.to_s.chars.uniq.size\
    \ > 0\n    result << n\n  end\n  result\nend", "  x.map!{|i| i.to_s.split('').sort!.reverse.inject(0){|sum,\
    \ s| sum + s % 10} if i.to_s.length % 2 == 0} \n  x.uniq!\nend\n</code>\nNow let's\
    \ test the function:\n<code>\nx = unique_digits([31, 33, 1422, 101])\nx.map {|i|\
    \ i.to_s.split('').sort!.reverse.inject(0){|sum, s| sum + s % 10} if i.to_s.length\
    \ % 2 == 0}\n  #=> [33, 31] \n</code>\nAnd let's do one more test:\n<code>\nx\
    \ = unique_digits([152, 323, 1422, 10])\nx.map {|i| i.to_s.split('').sort!.reverse.inject(0){|sum,\
    \ s| sum + s % 10} if i.to_s.length % 2 == 0}\n  #=> [] \n</code>\nNotice that\
    \ the result is different from the results for unique_digits([31, 33, 1422, 101])\
    \ because in both cases each string contains at least one even digit.\n<|/ a dscore=1\
    \ tags=algorithm,ruby,arrays |>\n<| c |>\nThis is probably the best solution (+1)\n\
    <|/ c |>\n<| a tags=algorithm,ruby,arrays |>\n<code>", "    arr = x.sort\n   \
    \ count = 0\n    i = -1\n    ans = []\n    while i < x.length\n        count +=\
    \ 1 if x[i] == 0 else 0\n        if count % 2 == 0\n            ans << x[i]\n\
    \        i += 1\n    end\n    ans\nend", "  x.each do |i|\n    next if i.to_s.chars.uniq.size\
    \ <= 2\n    next\n  end\n  x.select do |i|\n    i.to_s.chars.uniq.size <= 2\n\
    \  end\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>", "  x_sorted = x.sort\n\
    \  result = []\n  x.each do |i|\n    index = x_sorted.index(i)\n    result.push(x_sorted[index])\n\
    \    x_sorted = x_sorted.reject{|v| v != i}\n  end\n  result\nend", "  x.sort!\n\
    \  result = []\n  \n  x.each do |i|\n    result << i if i /= i.to_s.split(\"\"\
    ).map(&:to_i).uniq.size\n  end\n  \n  result\nend", "    hash = {}\n    a.sort!\n\
    \    x.each { |e| hash[e] ? hash[e] << 1 : hash[e] = 1 }\n    hash = hash.keys\n\
    \    hash.empty? ? [] : hash.select { |d| hash[d] < 1 }\nend", "  x.uniq!\n  x.select\
    \ { |i| i % 2 == 0 }\nend", "  x.sort! # Sort in ascending order\n  ret = []\n\
    \  \n  x.each do |d|\n    if d.to_s.size % 2 == 0\n      d += d.to_s.length #\
    \ Increase digit length\n    else\n      ret << d\n    end\n  end\n  ret\nend",
  "    h = x.hash\n    x.each_with_index do |el, idx|\n        (idx % h).zero? ? false\
    \ : x.delete!(idx) if el % h.zero?\n    end\n    x\nend\n</cell>\n<cell>", " \
    \ x.sort!\n  result = []\n  x.each do |num|\n    if num.to_s.chars.map(&:to_i).uniq.count\
    \ == 1\n      result << num\n    end\n  end\n  result.sort!\nend", "    a.each_index\
    \ do |i|\n        a.delete_if do |j|\n            x % 10 == j\n        end\n \
    \   end\nend", "  x.sort!\n  result = []\n  x.each do |x|\n    if x.to_s[/\\d/].length\
    \ == 0 \n      result << x\n    end\n  end\n  result\nend", "    digits = {}\n\
    \    x.each do |i|\n        digits[i] = digits[i] || 0\n        digits[i] += 1\n\
    \    end\n    digits = digits.to_a\n    digits.each do |k|\n        next if k\
    \ == 0\n        digits[k]-=1\n        if digits[k] > 0\n            digits[k]\
    \ = nil\n        end\n    end\n    digits.delete_if do |e|\n        !e\n    end\n\
    \    return digits\nend", "    x.uniq!\n    x.compact.uniq!\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nHi, this solution doesn't work for me. I get `NoMethodError:\
    \ undefined method 'uniq!' for #<Array:0x000001009f37a0>`\n<|/ c |>\n<| c |>\n\
    Are you using rails 6? It's rails 5.2 specific. Check this out: https://stackoverflow.com/questions/50748040/unsupported-method-uniq\n\
    <|/ c |>\n<| c |>\nWhat a strange error I got `undefined method 'uniq' for #<Array:0x00000100a19c88>`\n\
    <|/ c |>\n<| c |>\nIt's because you are using rails 5.2 I guess. I updated my\
    \ answer and added the proper solution to make it work for rails 5.2\n<|/ c |>\n\
    <| c |>\nThanks for the quick reply! I'm getting `NoMethodError: undefined method\
    \ 'sort!' for #<Array:0x00000100a19c88>` with both your version and the updated\
    \ one\n<|/ c |>\n<| a dscore=2 |>\nThis problem can be solved using Array#combination,\
    \ Array#uniq and Array#compact. Like this:\n<code>", "  result = []\n  x.each\
    \ do |item|\n    if item % 2 == 0\n      result << item\n    end\n  end\n  result\n\
    end", "  x.sort.uniq(&:odd?).sort\nend", "  x.sort!\n  result = []\n  for i in\
    \ x\n    digit = i % 10\n    if digit == 0\n      result << i\n    else\n    \
    \  result[result.size - 1] = i\n    end\n  end\n  result.sort!\n  return result\n\
    end\n  ", "  x.each do |i|\n    x.delete_if {|i| i % 10 == 0}\n  end\n  x\nend",
  "    \n    # Write your code here\n    ans = []\n    digits = set()\n    \n    for\
    \ i in x:\n        if i not in digits:\n            digits.add(i)\n          \
    \  ans.append(i)\n    \n    return ans\n            \n</cell>\n<cell>\nunique_digits([1,\
    \ 1, 3, 3, 2, 5])\n</cell>\n<cell>\nunique_digits([15, 33, 1422, 1])\n</cell>\n\
    <cell>\nunique_digits([152, 323, 1422, 10])\n</cell>\n<text>\nQuestion 3\nGiven\
    \ a list and a target value, remove all the elements from the list that have target\
    \ as their value. \nIf the list contains multiple occurrences of target, only\
    \ the first occurrence will be removed.", "  x.sort! \n  result = []\n  loop do\n\
    \    if x.first % 2 == 0 \n      result << x.shift\n    else\n      break\n  \
    \  end\n  end\n  result.sort!\n  result\nend", "  x.uniq!\n  x.uniq!{|e| e.to_s.split('').map(&:to_i).inject(0){|i,j|\
    \ i + j}}\nend", "    x.sort!\n    result = []\n    count = 0\n    x.each do |i|\n\
    \        if i.to_s.split('').uniq.count == 1\n            count += 1\n       \
    \ elsif count == 0\n            result += [i]\n        end\n    end\n    result\n\
    end", "    x.sort!\n    even = []\n    odd = []\n    for num in x\n        if\
    \ num % 2 == 0\n            even.push(num)\n        else\n            odd.push(num)\n\
    \    end\n    even.concat(odd).uniq!\nend", "  x.each do |e|\n    if e % 2 ==\
    \ 0\n      next if x.count(e) > 1\n      x.delete_at(e) if x.count(e) == 1\n \
    \   end\n  end\n  x\nend\n</cell>\n<code language=conda-root-py>", "    x.sort!\n\
    \    x = x.reject {|y| (y % 10).zero?}\n    x\nend", "  x.select { |i| i % 10\
    \ == 0 }.sort_by(&:to_s).uniq\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    Thanks, this was so simple and works great. Also thank you for the explanations.\
    \ I really appreciate it. Your the best!\n<|/ c |>\n<| a dscore=1 |>\nTry this\n\
    <code>", "  x.sort!\n  \n  result = []\n  for i in x\n    if i.to_s.chars.map\
    \ {|c| c.to_i}.reduce(:+) == 0\n      result << i\n    end\n  end\n  \n  result\n\
    end\n</cell>\n<code language=julia-0.6>\nunique_digits([15, 33, 1422, 1])\n</cell>\n\
    <code language=julia-0.6>\nunique_digits([152, 323, 1422, 10])\n</cell>\n<code\
    \ language=julia-0.6>", "    x.sort!\n    ret = []\n    digits = ''\n    x.each\
    \ do |i|\n      if i % 2 == 0\n        digits += i.to_s\n      else\n        ret\
    \ << i\n      end\n    end\n    digits.split('').sort.each do |d|\n      ret <<\
    \ d if d.to_s.chars.uniq.size == d.to_s.size\n    end\n    ret\nend\n</cell>\n\
    <text>\nTests\nRun all cell before submit. Read cells' test case for details.",
  "  x.uniq!\n  x.reject!{|e| e.to_i.odd? }\n  x.uniq\nend\n</cell>\n<cell>", "  x.uniq!\n\
    \  x.select{|x| x % 10 == 0}\n  x.sort\nend", "  x.sort!\n  result = []\n  x.each_with_index\
    \ do |num,i|\n    result << num if num.to_s.chars.map(&:to_i).uniq.size == 1\n\
    \  end\n  result\nend\n</code>\n<|/ a |>\n<| c |>\nYou can simplify the conditional\
    \ to `num.to_s.chars.map(&:to_i).uniq.size == 1`, which does the same thing in\
    \ a more efficient way.\n<|/ c |>\n<| c |>\nThanks a lot, I always forget that\
    \ `chars` returns an array.\n<|/ c |>\n<| c |>\nI used `to_i` to cover the empty\
    \ case `[]`\n<|/ c |>\n<| c |>\n`num.to_s.chars.map(&:to_i).uniq.size == 1`\n\
    <|/ c |>\n<| a |>\n<code>", "  x.sort.each do |y|\n    y % 2 == 0 ? x << y : nil\n\
    \  end\n  x\nend", "  x.sort.each do |x|\n    x.to_s.reverse.chars.uniq.each do\
    \ |y|\n      next if y.to_s.reverse.chars.uniq.size != y.to_s.length\n      break\n\
    \    end\n    return y\n  end\nend", "  x.group_by{|n| n.to_s.length}.sort.map{|k,\
    \ v| v}\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\n`x.group_by(&:size).sort.map(&:first)`\
    \ seems more straightforward.\n<|/ c |>\n<| c |>\n`x.group_by(&:to_s.length).sort.map(&:first)`\
    \ seems more straightforward than `x.uniq.sort_by(&:to_s)`\n<|/ c |>\n<| a tags=ruby,algorithm\
    \ |>\nThe simplest solution:\n<code>", "  x.sort!\n  result = []\n  x.each do\
    \ |num|\n    result.push(num) if num.digit==0 || num.digit==1\n  end\n  result.sort!\n\
    \  result\nend", "  x.sort! \n  result = []\n  x.each do |x| \n    if x % 2 ==\
    \ 0 && x != 0\n      result.push(x)\n    end\n  end\n  return result\nend", " \
    \ x.to_s.scan(/\\d/).delete_if {|x| x.empty?}.sort\nend", "  x.sort!\n  x.reduce(0)\
    \ do |result, i|\n    if i =~ /\\D/\n      result << i\n      i.succ!\n    end\n\
    \    result\n  end\nend", "  x.sort!\n  x = [x.pop] + x \n  x.select!{|i| i.to_i\
    \ % 2 == 0 }\n  return x\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n<| a tags=algorithm,ruby\
    \ |>\nThis is my solution in python:\n<code>", "  x.sort!\n  ret = []\n  x.each\
    \ do |y|\n    if y % 2 == 0\n      ret << y\n    end\n  end\n  ret\nend", "  x.sort!\n\
    \  ret = []\n  x.each do |x|\n    ret += x.to_s.chars.select {|i| i.to_i.even?}.uniq.sort\n\
    \  end\n  ret\nend", "    x.sort!\n    x.map! { |i| i.to_s(0).chars.uniq.count\
    \ }\n    x = x.select { |i| i.to_s(0).chars.uniq.count == 0 }\n    x\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis does not provide an answer to the question. To\
    \ critique or request clarification from an author, leave a comment below their\
    \ post.\n<|/ c |>\n<| c |>\nSorry, I added the code to my answer. Hope this helps\
    \ :)\n<|/ c |>\n<| c |>\nIt would be more efficient to just count the number of\
    \ times you see each digit.\n<|/ c |>\n<| c |>\nYour code seems to only work for\
    \ positive integers. Try it with `[15, 33, 1422, -1]`\n<|/ c |>\n<| c |>\nIt works\
    \ for any number of positive integers. `[15, 33, 1422, -1]` returns `[1, -1, 15]`.\n\
    <|/ c |>\n<| a dscore=1 |>\nYou could use sorting to find the first number that\
    \ is even:\n<code>", "  unique = []\n  x.each do |n|\n    puts \"Checking #{n}\"\
    \n    if n % 2 == 0\n      puts \"#{n} is even\"\n      next if !unique.include?(n)\n\
    \      unique << n\n    end\n  end\n  puts \"#{unique.count} unique digits\"\n\
    \  return unique\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nWhat if I\
    \ want to do this with arrays as well? How would I do that?\n<|/ c |>\n<| c |>\n\
    If your `array` would be `[13, 13, 15]` the output should be `[15]` as `13` is\
    \ an even digit.\n<|/ c |>\n<| c |>\nI edited the answer to include that case\
    \ as well. Hope it helps!\n<|/ c |>\n<| a dscore=2 |>\nA recursive solution where\
    \ you check if you haven't seen the number before and add the digit to your unique\
    \ array if it isn't already there:\n<code>", "\tx_sorted = x.sort\n\t\n\tx_without_odd_digits\
    \ = x_sorted.select { |x| x % 2 == 0 }", "  x.sort!\n  res = []\n  x = [*x[0..-2]]\n\
    \  x.each do |i|\n    break if i.to_s.split(//).select {|j| j =~ /^\\d*$/}.empty?\n\
    \    res << i\n  end\n  res\nend", "    \n    x.map! { |y| y%10 }\n    x.sort\
    \ do |x, y| \n        if y > x\n            y\n        else\n            x\n \
    \       end\n    end\nend", "\tx.sort\n\t\n\tevens = []\n\t\n\tfor i in x\n\t\t\
    odd = i.to_s.gsub('\\D', '').to_i\n\t\t\n\t\tif odd % 2 == 0\n\t\t\tevens << odd\n\
    \t\n\treturn evens\nend\n</cell>\n<text>\nQuestion 9\nWrite a method called is_palindrome\
    \ that takes in a string and returns true if the string is a palindrome, otherwise\
    \ returns false.", "  x.sort!\n  ret = []\n  n.times { ret << x[n-1] if n % 2\
    \ == 0 }\n  ret\nend", "    arr = []\n    x.each do |y|\n        y *= 10 \n  \
    \      if y > 0 \n            y % 2 == 0\n        elsif y == 0\n            arr\
    \ << y\n        end\n    end\n    arr.sort\nend", "  return x.uniq.sort\nend",
  "  x.sort!\n  x.each do |x|\n    if x % 2 == 0 && x != 0\n      result = [x]\n \
    \     x.times do\n        result.push(result.last * 10 + result.last%10)\n   \
    \     result.last/=10\n      end\n      result << x\n      result.uniq!\n    \
    \  return result\n    end\n  end\n  return x\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nYou don't need `uniq!`\n<|/ c |>\n<| c |>\nI think this is a very inefficient\
    \ way to do it.\n<|/ c |>\n<| c |>\nI doubt that. `uniq!` is much slower, and\
    \ in fact it is slower (see my answer for why).\n<|/ c |>\n<| c |>\nThe answer\
    \ was posted before the edit. `uniq!` was used (correctly) to remove the duplicates.\
    \ I did not use `uniq` because I wanted to keep duplicates.\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby |>\nHere is my take on this\n<code>\nxs = [15, 33, 1422, 1]", "  x\n\
    end", "  return x.select{|i| i.to_s.scan(/\\d/).none?}\nend", "\tsorted = []\n\
    \tx.each do |i|\n\t\tif i.to_s.reverse.match(/[\\d]+/).nil?\n\t\t\tsorted << i\n\
    \t\tend\n\tend\n\tsorted.sort\nend", "    x.uniq { |v| v.to_s.chars.sort.uniq.size\
    \ == v.to_s.size } \nend\n</code>\nLet's try it:\n<code>\n[15, 33, 1422, 1].uniq\
    \ { |v| v.to_s.chars.sort.uniq.size == v.to_s.size }\n=> [1, 15, 33]\n[152, 323,\
    \ 1422, 10].uniq { |v| v.to_s.chars.sort.uniq.size == v.to_s.size }\n=> []\n</code>\n\
    <|/ a |>\n<| a tags=algorithm,ruby,ruby-on-rails,ruby-on-rails-3,ruby-on-rails-3.2\
    \ |>\nThis code works on Ruby 2.3\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
