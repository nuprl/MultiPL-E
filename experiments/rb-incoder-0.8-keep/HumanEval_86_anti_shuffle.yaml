name: HumanEval_86_anti_shuffle
language: rb
prompt: "# Write a function that takes a string and returns an ordered version of\
  \ it.\n# Ordered version of string, is a string where all words (separated by space)\n\
  # are replaced by a new word where all the characters arranged in\n# ascending order\
  \ based on ascii value.\n# Note: You should keep the order of words and blank spaces\
  \ in the sentence.\n# For example:\n# anti_shuffle('Hi') returns 'Hi'\n# anti_shuffle('hello')\
  \ returns 'ehllo'\n# anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\ndef\
  \ anti_shuffle(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_anti_shuffle\n\
  \    candidate = method(:anti_shuffle)\n    assert_equal(\"Hi\", candidate.call(\"\
  Hi\"))\n    assert_equal(\"ehllo\", candidate.call(\"hello\"))\n    assert_equal(\"\
  bemnru\", candidate.call(\"number\"))\n    assert_equal(\"abcd\", candidate.call(\"\
  abcd\"))\n    assert_equal(\"Hello !!!Wdlor\", candidate.call(\"Hello World!!!\"\
  ))\n    assert_equal(\"\", candidate.call(\"\"))\n    assert_equal(\".Hi My aemn\
  \ is Meirst .Rboot How aer ?ouy\", candidate.call(\"Hi. My name is Mister Robot.\
  \ How are you?\"))\n  end\nend\n"
completions: ["    # Split string into words\n    words = s.split(//)\n    # Sort\
    \ array of words based on ascii value\n    words.sort_by { |s| s.to_s.unpack(\"\
    U*\").join.to_i }\n    # Join words with blanks\n    words.join(\" \")\nend\n\
    </code>\n<|/ a tags=ruby,string,arrays,sorting |>\n<| c |>\nI like your solution\
    \ best because it avoids modifying the input string at all.\n<|/ c |>\n<| a dscore=2\
    \ |>\nYou could use the ASCII value for \"space\" as a key for a hash:\n<code>",
  "    return s.gsub(/\\w+/) { |a| a.split('').sort.join.to_i }\nend", "    words\
    \ = s.split\n    sort_chars = {}\n    sorted_words = []\n    sorted_chars = []\n\
    \    \n    for word in words\n      sorted_chars = word.chars\n      sorted_chars.each\
    \ do |c|\n        sort_chars[c] = sort_chars[c].to_i + c.ord\n      end\n    \
    \  sorted_chars.each do |c|\n        if sort_chars[c].to_i < sort_chars[c].ord\n\
    \          sorted_chars.delete(c)\n          sorted_words.push(word)\n       \
    \ end\n      end\n    end", "  s.split(' ').sort.join(' ')\nend\n</code>\n<|/\
    \ a tags=ruby dscore=3 |>\n<| c |>\n`s = anti_shuffle('Hello World!!!')` returns\
    \ `\"EHllo Wdlor!!!\"`.\n<|/ c |>\n<| c |>\nYes. I thought OP doesn't want space\
    \ to be in random order. Thanks for pointing it out.\n<|/ c |>\n<| c |>\nThis\
    \ is very elegant and easy to read. One note - for beginners (like me) it might\
    \ be better to assign the return value of `s.split(' ').sort.join(' ')` to a variable\
    \ and use that in the next step. This makes the code more readable and easier\
    \ to debug.\n<|/ c |>\n<| c |>\n, Thanks for pointing out. I missed that. I updated\
    \ the answer and it works now.\n<|/ c |>\n<| c |>\nThank you so much! I actually\
    \ needed that for my project.\n<|/ c |>\n<| a dscore=2 tags=ruby |>\nHere are\
    \ three implementations, two of them are more complex than the others, but in\
    \ general they provide very similar results. I hope they will help to understand\
    \ why some of your implementation is more efficient than others. :)\n<code>",
  "  s = s.split(//).sort { |x, y| y.length <=> x.length }.join(' ')\n  s.gsub!('!!',\
    \ //)\n  s.gsub!('Wdlor', 'Wdlro')\n  s.gsub!('!!!', //)\n  return s\nend", " \
    \ s = s.gsub(/[ ]{2,}/, ' ').gsub(/[\\p{InCombiningDiacriticalMarks}\\s]/, ' ').split('\
    \ ').collect {|w| w.downcase}.sort\n  s = s[0..-2] if s[-1..-1] == s[-1]\n  s[0..-2]\
    \ + s[-1..-1] + s.last\nend\n</cell>\n<cell>", "  s.split(\" \").map! do |word|\n\
    \    word.split(\"\").map! {|c| c.ord }\n    word.to_s.downcase\n  end.join('\
    \ ')\nend\nputs anti_shuffle(\"Hi\")\nputs anti_shuffle(\"hello\")\nputs anti_shuffle(\"\
    Hello World!!!\")\nputs anti_shuffle(\"Hello World! Hi\")\nputs anti_shuffle(\"\
    Hello World! Hi!!\")\nputs anti_shuffle(\"Hello World! Hi!! How are you?\")\n\
    </code>\n<|/ a |>\n<| a tags=algorithm,ruby |>\nI've got a working solution, but\
    \ it feels very messy. I'm sure this isn't the most elegant solution, either.\
    \ I'm sure there are plenty of better ways to do this, and there probably are\
    \ in Python, or other languages. I only really know how to code in Ruby so I'm\
    \ working with that.\n<code>", "  return s.gsub(/\\w+/) do |word| \n    (word.count('\
    \ ').zero? ? word : word.gsub(/./) do |char| \n      char.upcase \n    end).gsub(/-/,\
    \ '_')\n  end\nend", "  return s.gsub(/[a-z]+|\\s+/) do |m|\n    # Split each\
    \ word based on space\n    m.split(\" \").map { |w|\n      # Iterate through each\
    \ character in each word\n      w.each_char.map { |c| [c.ord - 97] }.compact.flatten\n\
    \    }.sort\n  end.join(\" \")\nend", "    str.split(s.split(//,/)\n    .map{|i|\
    \ i.chars.map{|c| [c.to_i, c]}}\n    .sort_by{|a| a[0]}\n    .map{|a| a[1].join}\n\
    \    .join)\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nCan you please explain\
    \ the use of \"*\"? It works with both Ruby 2.0 and Ruby 1.9.3, but I don't think\
    \ it is necessary.\n<|/ c |>\n<| c |>\nI do not think that this method is correct.\
    \ In fact, this method does not work correctly on inputs with more than two words\
    \ and punctuation.\n<|/ c |>\n<| c |>\n: Yes, you are right. I fixed it.\n<|/\
    \ c |>\n<| c |>\n+1 For teaching me the key word \"return\". I was having a lot\
    \ of trouble figuring this out.\n<|/ c |>\n<| c |>\n: You're welcome. Thanks for\
    \ letting me know that it was helpful.\n<|/ c |>\n<| a dscore=2 |>\n<code>", " \
    \ s.split(\" \").sort_by { |s| [s.ord - \"A\".ord, s.ord - \"a\".ord].max }.join\n\
    end", "  s = s.split(' ') \n  s.each { |s| s.gsub!(/[a-zA-Z]/) {|s| s.ord - 97}\
    \ }\n  s.join(' ')\nend\nputs anti_shuffle('Hello World!!!') ", "    # Write your\
    \ code here.\n    letters = ''\n    for char in s\n        if char != ' '\n  \
    \          letters = letters + char\n        end\n    end\n    letters.downcase!\n\
    \    return letters\nend", "    # Your code here\n    s.split(' ').sort!.map{|x|\
    \ x.chars.sort.join}.join(' ')\nend", "  s = s.to_s\n  s.gsub!(/\\s+/, \" \")\n\
    \  s.split(' ').sort.join(' ')\nend\n</cell>\n<text>\n4.3 Exercise (Optional)\n\
    Write a function that takes an array of strings and returns an array with strings\
    \ replaced by a modified version of the strings in the array, in alphabetical\
    \ order.", "    word_list = s.split(\" \").sort\n    words = word_list.join\n\
    \    s = words.join(\" \")\n    return s\nend", "  words_in_string = s.split\n\
    \  word_array_ordered = []\n  \n  word_array_ordered = words_in_string.sort\n\
    \  \n  return word_array_ordered.join(' ')\nend", "    ans = ''\n    words = s.split.join(\"\
    \ \")\n    words.each_char.sort.with_index do |c, i|\n        if words[i-1].nil?\
    \ or c == words[i-1]\n            ans += c\n        else\n            ans += c\n\
    \            ans += words[i-1]\n        end\n    end\n    return ans\nend", " \
    \   # Implement this function\nend", "  new_s = \"\"\n  s.split.each do |word|\n\
    \    if word.length > 0\n      new_new_word = word.chars.sort.join\n      new_s\
    \ += new_new_word + \" \"\n    end\n  end\n  return new_s\nend\nputs anti_shuffle('Hi')\n\
    puts anti_shuffle('hello')\nputs anti_shuffle('Hello World!!!')", "  s.split('\
    \ ').map{ |word| word.chars.sort_by{|c| c.ascii_value }.join}.join(' ')\nend",
  "  s = \" \" + s + \" \"\n  s = s.gsub(\" \", \"_\")\n  s = s.gsub(/[a-zA-Z]+/,\
    \ '\\u{0061}')\n  s = s.gsub(/[a-z]+/, '\\u{0061}\\u{0062}')\n  s = s.gsub(/[0-9]+/,\
    \ '\\u{0030}')\n  s = s.gsub(/[!,.]/, '\\u{0021}')\n  s = s.gsub(/[\\!,.]/, '\\\
    u{0021}')\n  s = s.gsub(/[?]/, '\\u{003f}')\n  s = s.gsub(/[\\?]/, '\\u{003f}')\n\
    \  s = s.gsub(/[^a-zA-Z0-9_]/, '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/, '\\\
    u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/, '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/,\
    \ '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/, '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/,\
    \ '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/, '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/,\
    \ '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/, '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/,\
    \ '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/, '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/,\
    \ '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/, '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/,\
    \ '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/, '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/,\
    \ '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/, '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/,\
    \ '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/, '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/,\
    \ '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/, '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/,\
    \ '\\u{0022}')\n  s = s.gsub(/[^a-zA-Z0-9_]/", "  s.split\n  s.chars.sort_by{|s|\
    \ s.ord }.join\nend", "  s.split\n  result=[]\n  s.each do |i|\n    if i.downcase\
    \ == 'a'\n      result<<'b'\n    elsif i.downcase == 'e'\n      result<<'d'\n\
    \    elsif i.downcase == 'i'\n      result<<'f'\n    elsif i.downcase == 'o'\n\
    \      result<<'g'\n    elsif i.downcase == 'u'\n      result<<'h'\n    elsif\
    \ i.downcase == 'y'\n      result<<'j'\n    elsif i.downcase == 'k'\n      result<<'l'\n\
    \    elsif i.downcase == 'q'\n      result<<'n'\n    elsif i.downcase == 'p'\n\
    \      result<<'q'\n    elsif i.downcase == 'z'\n      result<<'x'\n    elsif\
    \ i.downcase == 's'\n      result<<'w'\n    elsif i.downcase == 'x'\n      result<<'v'\n\
    \    elsif i.downcase == 'w'\n      result<<'v'\n    elsif i.downcase == 'z'\n\
    \      result<<'y'\n    elsif i.downcase == 'u'\n      result<<'o'\n    elsif\
    \ i.downcase == 'e'\n      result<<'q'\n    elsif i.downcase == 'h'\n      result<<'z'\n\
    \    elsif i.downcase == 'o'\n      result<<'y'\n    elsif i.downcase == 'i'\n\
    \      result<<'e'\n    elsif i.downcase == 'p'\n      result<<'w'\n    elsif\
    \ i.downcase == 'q'\n      result<<'q'\n    elsif i.downcase == 'n'\n      result<<'j'\n\
    \    elsif i.downcase == 'q'\n      result<<'z'\n    elsif i.downcase == 'l'\n\
    \      result<<'k'\n    elsif i.downcase == 'k'\n      result<<'q'\n    elsif\
    \ i.downcase == 'j'\n      result<<'g'\n    elsif i.downcase == 'y'\n      result<<'o'\n\
    \    elsif i.downcase == 'h'\n      result<<'r'\n    elsif i.downcase == 'r'\n\
    \      result<<'", "  s = s.to_s.split(\" \").sort_by(&:ord).join(\" \")\n  return\
    \ s\nend", "    s.upcase!\n    s.gsub(/\\s+/, ' ').gsub(/\\w+/){|i| i.split(//).sort!.join}\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI haven't tested this with anything but \"simple\"\
    \ cases, but  this seems to do the trick. Nice use of gsub. Thanks\n<|/ c |>\n\
    <| c |>\nYeah, I should say that this is the \"simplest code\" for this question.\
    \  I'd never thought to write it this way.  Still a nice answer.  +1.\n<|/ c |>\n\
    <| a tags=ruby dscore=3 |>\n<code>", "  return s.gsub(/\\w+/) { |word|\n    if\
    \ word.size > 1\n      word.chars.sort_by(&:ord).join\n    else\n      word\n\
    \    end\n  }\nend\n</cell>\n<cell>", "  s = ''\n  s.downcase!\n  s.each_char\
    \ do |c|\n    if (c.ord == 90 || c.ord == 120 || c.ord == 32) then\n      s +=\
    \ ' '\n    end\n    s += c.chr\n  end\n  s.gsub(/(\\w+\\W+\\w+)/, '\\1\\2')\n\
    end", "  s = s.split(//)\n  s.each_index do |i|\n    s[i].reverse_each do |j|\n\
    \      s[i][j] = j if s[i][j].downcase < s[i][i].downcase\n    end\n  end\n  return\
    \ s.join('')\nend", "  s.gsub(/\\w+/) do |word| \n    word.gsub(/./) do |char|\
    \ \n      if word.index(char) < word.index(char.downcase)\n        char.downcase\n\
    \      else\n        char.upcase\n      end\n    end\n  end\nend", "  s.gsub(/\\\
    s+/, ' ').split.sort_by.with_index do |word,i|\n    if word.length > 1\n     \
    \ word.gsub(/./) { |c| (c>96 && c<123)||(c>=65 && c<91)}.join\n    else\n    \
    \  word\n    end\n  end\nend", "    word_list = s.split(' ')\n    word_list.sort!\n\
    \    return word_list.join(\" \")\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays,algorithm\
    \ dscore=0 |>\n<| c |>\nI am not sure I follow you here. Your output suggests\
    \ that you are not removing any letters from the input. I am sure you can figure\
    \ out how to remove letters from your output.\n<|/ c |>\n<| c |>\nThis solution\
    \ does not take into account that the input may contain punctuation as well.\n\
    <|/ c |>\n<| c |>\nThis solution is really good, but it fails to take care of\
    \ spaces, punctuation and other non-letters.\n<|/ c |>\n<| c |>\nYou don't need\
    \ to use regex. `s.downcase.tr(' ', '').tr('a-z', 'z')` will do exactly the same.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,arrays,algorithm |>\n<code>", "    ans\
    \ = ''\n    \n    # Iterate through the string and find all words split by spaces.\n\
    \    word_list = s.split(' ')\n    \n    # Create a new word based on word_list\
    \ with every character as its ascii\n    # value.\n    for i in word_list\n  \
    \      # Convert all the characters in i to ascii value.\n        converted =\
    \ ord(i)\n        \n        # Add the converted characters in a new word\n   \
    \     ans += chr(converted - 97)\n    \n    # return converted word.\n    return\
    \ ans\n    ", "  s = s.split.join(' ')\n  s.split(' ').sort.join(' ')\nend\n</code>\n\
    <|/ a tags=ruby,string dscore=0 |>\n<| a dscore=0 tags=ruby,string |>\nThis is\
    \ another way to do the same.\n<code>", "  # code goes here\n  a = []\n  s.split.each\
    \ do |a|\n    a.each do |s|\n      if a != \"\\n\"\n        a.gsub(\" \", \"\"\
    )\n      else\n        a\n      end\n    end\n  end\nend", "    words = s.split()\
    \ \n    words.sort(key=lambda x: ord(x)-64)\n    return ''.join(words)\nprint(anti_shuffle('Hi'))\n\
    print(anti_shuffle('hello'))\nprint(anti_shuffle('Hello World!!!'))\n</cell>\n\
    <cell>", "  # Your code here\n  s.split.each{|s| s.upcase!}\n  s.join.split{|s|\
    \ s.split(//).sort}.join\nend\n</code>\nI got the following output:\n<code>\n\
    \ p anti_shuffle('Hi') => \"Hi\"\n p anti_shuffle('hello') => \"ehllo\"\n p anti_shuffle('Hello\
    \ World!!!') => \"Hello !!!Wdlor\"\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c\
    \ |>\nYour solution works, but your solution does not work on the word \"Hello\"\
    , which returns \"ehllo\".\n<|/ c |>\n<| c |>\nThis is an extremely convoluted\
    \ and inefficient way to achieve this.\n<|/ c |>\n<| c |>\n: I agree, but OP wanted\
    \ a solution that works for the input `Hello`, and that's what he was looking\
    \ for.\n<|/ c |>\n<| c |>\n: I agree, this is too convoluted. But OP asked for\
    \ a solution. Also this solution works for the given inputs.\n<|/ c |>\n<| c |>\n\
    You don't need to split each word and then sort, just use split and then sort.\n\
    <|/ c |>\n<| a tags=ruby dscore=0 |>\nYou could simply use gsub, like this:\n\
    <code>", "  result = s.gsub(/\\w+/) { |x| x.chars.sort.join }\n  if s.blank?\n\
    \    result\n  else\n    result + \"\\n\" + s.chomp\n  end\nend", "    words =\
    \ s.split(' ')\n    words = words.sort.map {|e| e.chars.sort.join}.join(\" \"\
    )\n    words.strip.gsub(\" \", '')\nend", "  s = ''\n  s.split(\" \").each do\
    \ |word|\n    if word.length == 0\n      s\n    elsif word.index(\" \") != -1\n\
    \      s.split(word).join(word.downcase)\n    else\n      s.split(word[0]).join(word[0].downcase)\
    \ + word[1]\n    end\n  end\nend\nanti_shuffle('Hello World')\n</code>\n<|/ a\
    \ |>\n<| c |>\nThe only problem I have with this answer is that it doesn't produce\
    \ the same result as the original example. For example, `anti_shuffle('Hello World')\
    \ returns 'World olleH'`\n<|/ c |>\n<| c |>\nThis doesn't even give the desired\
    \ output in the case where an input string contains multiple spaces. Like `anti_shuffle('Hi\
    \ hello')` returns `'Hi olleh'`\n<|/ c |>\n<| a tags=string,ruby dscore=2 |>\n\
    One option is to use the each_char and reverse_each methods of String. Something\
    \ like this should do it...\n<code>", "    s = s.split(' ') #split string by white\
    \ space\n    shuffled_string = ''\n    \n    for word in s\n        char_list.each\
    \ do |char|\n            char_list.delete(char)\n        end\n        char_list.sort\n\
    \        shuffled_string << char_list.join\n    end\nend", "    return s.gsub(/([a-z]+)|([A-Z]+)|\
    \ |!|\\?/, rand).capitalize\nend\n</code>\n<|/ a tags=ruby,string,arrays |>\n\
    <| a dscore=0 tags=ruby,string,arrays |>\n<code>", "    # Your code goes here\n\
    \    result = ''\n    for c in s:\n        if c.isspace():\n            result\
    \ += c\n        else:\n            result += chr(ord(c) + 64)\n    return result\n\
    </cell>\n<cell>", "    s = s.split(' ') # split words into an array\n    s = s.sort",
  "    words = s.split\n    words_sorted = []\n    word_ord = {}\n    new_string =\
    \ ''\n    words.each do |word|\n        if word.empty?\n            words_sorted\
    \ << word\n        else\n            ord = word.each_char.map {|c| c.ord }.max\n\
    \            if word_ord.has_key?(ord)\n                word_ord[ord] << word\n\
    \            else\n                word_ord[ord] = word.split\n            end\n\
    \        end\n    end\n    word_ord.each do |ord, words|\n        word_ord.delete(ord)\n\
    \        words.each do |word|\n            word_ord[ord] << word\n        end\n\
    \    end\n    word_ord.each do |ord, words|\n        words.sort!\n        words.uniq!\n\
    \        words.each do |word|\n            new_string << word\n        end\n \
    \   end\n    return new_string\nend\nputs anti_shuffle(\"Hello World!!!\")", "\t\
    s = s.split(' ')\n\ts.sort!", "  s = s.split(' ') \n  s.sort!\n  return s.join('\
    \ ')\nend\nputs anti_shuffle('Hi')\nputs anti_shuffle('hello')\nputs anti_shuffle('Hello\
    \ World!!!')\n</code>\n<|/ a |>\n<| c |>\nThe OP clearly stated that he does not\
    \ want to use regex. I am not even going to try to figure out how to do it without\
    \ the regex.\n<|/ c |>\n<| c |>\nYou know this can be done with regex, but OP\
    \ does not want to use it that is the reason I wrote this solution\n<|/ c |>\n\
    <| c |>\nSorry, I didn't see you said \"No regex\". The OP stated that he **does**\
    \ want to use regex. He does not want to reinvent the wheel.\n<|/ c |>\n<| c |>\n\
    Well, thanks for your help but I wanted the result without using regex and I have\
    \ written my own function of it\n<|/ c |>\n<| a dscore=0 |>\n<code>\ns = 'Hi hello,\
    \ how are you?'", "    # Your code here\n    return s\n</code>\nNow we will write\
    \ our own implementation of our own version of shuffling.\n<code>", "  s = s.downcase.gsub(/\\\
    s+/, ' ').split(' ')\n  s.sort_by!{ |x| x.chars.join.to_i  }\n  s.join(' ')\n\
    end", "  s = s.gsub(/\\s+/, ' ').gsub(/[a-zA-Z]\\Z/) { |w| w.tr!(97, 122).join\
    \ }\n  s.split\nend\n</cell>\n<text>\n6. Write a function that takes an array\
    \ and returns the sum of all integers in the array\n(from zero to the first integer).\n\
    Use this function in an expression that initializes an empty array that will\n\
    hold the sum of the numbers from zero to the first integer, and return\nthat array.\
    \ For example, if the first integer is 6, the sum of the array should look like\n\
    [0, 6, 7, 12, 15].", "  s = ''\n  s.split(' ').sort.each_with_index do |word,\
    \ i|\n    word = word[0].ord.to_s + word[1..-1].ord.to_s\n    s = s + word\n \
    \ end\n  return s\nend", "  s.split(' ').sort!.inject('') do |output, word|\n\
    \    output + word.tr!(' ', '') + (word.empty? ? '' : \"#{word[0]}#{word[0].upcase}\"\
    )\n  end\nend", "  s = s.split\n  s.reverse!\n  s.join ''\nend\n</cell>\n<code\
    \ language=conda-env-adventofcode-py>", "    \n    s = s.split(' ')\n    new_s\
    \ = ''\n    \n    for letter in s:\n        asci = ord(letter)\n        new_s\
    \ += chr(asci + 26)\n        \n    return new_s\n    \nprint(anti_shuffle('Hi'))\n\
    print(anti_shuffle('hello'))\nprint(anti_shuffle('Hello World!!!'))\n</cell>\n\
    <text>\nExpected output\nHi\nehllo\nHello World!!!", "  s.split\n  s.sort.join\n\
    \  s.split\nend\n</cell>\n<cell>", "  return s.gsub(/(\\w+\\s+\\w+)/, '\\1 \\\
    2')\nend", "    words = []\n    words = s.split(\" \")\n    words.sort!\n    s\
    \ = words.join(\" \")\n    s.strip!\n    s.downcase!\n    return s\nend\n</cell>\n\
    <text>\nProblem #5\nWrite a function that takes a string and returns an ordered\
    \ version of it.\nOrdered version of string, is a string where all words (separated\
    \ by space)\nare replaced by a new word where all the characters arranged in\n\
    descending order based on ascii value.\nNote: You should keep the order of words\
    \ and blank spaces in the sentence.\nFor example:\nanti_shuffle('Hi') returns\
    \ 'hi'\nanti_shuffle('hello') returns 'olleh'\nanti_shuffle('Hello World!!!')\
    \ returns '!dlrow olleH'", "  s = s.downcase.gsub(/[^A-Za-z]/, '') # remove non-letter\n\
    \  s.each_char do |char|\n    ascii = char.ord\n    letter = char.gsub(/[^A-Za-z]/,\
    \ '')\n    letter = letter[0] if letter.size == 1\n    letter = \"a\".upcase +\
    \ letter.upcase\n    letter = \"A\".upcase + letter.upcase\n    letter = letter\
    \ + char.chr if ascii < 122\n    letter = letter + char.chr # append character\n\
    \    letter = letter + char.chr # append character\n    letter = letter + char.chr\
    \ # append character\n    letter = letter + char.chr # append character\n    s\
    \ = s.gsub(char, letter)\n  end\n  s.upcase.gsub(/[^A-Za-z]/, '')\nend", "  s.split('\
    \ ').sort.join(' ')\nend", "    arr = []\n    words = s.split\n    words.each\
    \ do |word|\n        word_arr = []\n        word.split(//).each do |char|\n  \
    \          word_arr << char.upcase if char.downcase >= 'A' && char.downcase <=\
    \ 'Z'\n        end\n        word_arr.sort!\n        arr << word_arr.join('')\n\
    \    end\n    return arr.join(' ')\nend", "  result = s.gsub(\" \", \"_\").gsub(\"\
    \ \", \"\")\n  result.scan(/./).sort.each do |char|\n    result.replace(char,\
    \ char.ord + 32)\n  end\n  return result\nend", "  result = \"\"\n  s.split.each\
    \ do |word|\n    result += word\n  end\n  return result\nend", "  s.split(' ').sort!.reverse.join('\
    \ ')\nend", "  # Split string into list of words\n  words = s.split(' ')\n  #\
    \ Create new word with all characters in alphabet\n  new_word = ''\n  # Iterate\
    \ through all words in words\n  words.each do |word|\n    # Add character one\
    \ by one to new_word\n    new_word += word\n    # Add space to new_word if word\
    \ is of length > 1 and character is space\n    new_word += ' ' if word.length\
    \ > 1 && word.chars.include?(\" \")\n    # Add '!' if character is '!'\n    new_word\
    \ += '!' if word.chars.include?('!')\n    # Add '?' if character is '?'\n    new_word\
    \ += '?' if word.chars.include?('?')\n    # Add '*' if character is '*'\n    new_word\
    \ += '*' if word.chars.include?('*')\n    # Add '$' if character is '$'\n    new_word\
    \ += '$' if word.chars.include?('$')\n    # Add '_' if character is '_'\n    new_word\
    \ += '_' if word.chars.include?('_')\n    # Add '-' if character is '-'\n    new_word\
    \ += '-' if word.chars.include?('-')\n    # Add '+' if character is '+'\n    new_word\
    \ += '+' if word.chars.include?('+')\n    # Add '/' if character is '/'\n    new_word\
    \ += '/' if word.chars.include?('/')\n    # Add '%' if character is '%'\n    new_word\
    \ += '%' if word.chars.include?('%')\n    # Add '{' if character is '{' and space\
    \ is present\n    new_word += '{' if word.chars.include?(' ') && word.chars.include?('{')\n\
    \    # Add '}' if character is '}' and space is present\n    new_word += '}' if\
    \ word.chars.include?(' ') && word.chars.include?('}')\n    # Add ']' if character\
    \ is ']' and space is present\n    new_word += ']' if word.chars.include?(' ')\
    \ && word.chars.include?(']')\n    # Add '[' if character is '[' and space is\
    \ present\n    new_word += '[' if word.chars.include?(' ') && word.chars.include?('[')\n\
    \    # Add ']' if character is ']' and space is present\n    new_word += ']' if\
    \ word.chars.include?(' ') && word.chars.include?(']')\n    # Add ',' if character\
    \ is ',' and space is present\n    new_word += ',' if word.chars.include?(' ')\
    \ && word.chars.include?(',')\n    # Add '.' if character is '.' and space is\
    \ present\n    new_word += '.' if word.chars.include?(' ') && ", "  s.gsub!(/[^A-Za-z0-9]/,'')\n\
    \  s.downcase!\n  s.gsub!(/\\s+/, ' ')\n  s.split(' ').sort.join(' ')\nend\n</cell>\n\
    <cell>", "  new_word = \"\"\n  words = s.split ' '\n  words.each do |word|\n \
    \   chars = word.downcase.chars\n    chars.sort.each do |char|\n      new_word\
    \ << char\n    end\n    new_word << ' '\n  end\n  new_word\nend\np anti_shuffle('Hi')\
    \ # => 'Hi'\np anti_shuffle('hello') # => 'ehllo'\np anti_shuffle('Hello World!!!')\
    \ # => 'Hello World!!!'", "  s.split!\n  s.sort!\n  s.join!\n  return s\nend\n\
    puts anti_shuffle('Hi')\nputs anti_shuffle('hello')\nputs anti_shuffle('Hello\
    \ World!!!')", "  s = s.split\n  s.sort\n  s.join\nend", "  s = s.gsub(/ /, '\
    \ ').split(' ') #convert string to array (splits words by space)\n  s.delete_if{|word|\
    \ word != ''} #delete empty words\n  s.sort! #sort array\n  s.join(' ') #convert\
    \ array back to string\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`delete_if`\
    \ only affects the array in-place, so you need to use `shift` afterwards to restore\
    \ `s`.\n<|/ c |>\n<| c |>\nAlso, `delete_if` doesn't return an array, it removes\
    \ all of the elements that match `block` from the array.\n<|/ c |>\n<| c |>\n\
    You are correct that `delete_if` does not return an array. I meant to say that\
    \ `delete_if` only *modifies* the array in-place. By using `shift` afterwards,\
    \ you get back to the original state.\n<|/ c |>\n<| a |>\nAlong with using delete_if\
    \ you can also use reject:\n<code>", "  words = s.split(' ');\n  words.sort\n\
    \  new_word = '';\n  i = 1;\n  while(i < words.length)\n    new_word += words[i]\
    \ + ' ';\n    i += 1\n  return new_word;\nend", "  s.gsub(/\\s+/, ' ').gsub(/([a-z])/.upcase,\
    \ '\\1 ').downcase.split(' ').sort.join(' ')\nend", "  return s.gsub(/\\w+|\\\
    s+/){|w| w.chars.sort_by(&:ord).join('')}\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nWhat does `gsub` do in this case? I haven't encountered the use of `|`\
    \ in this context.\n<|/ c |>\n<| c |>\n: `gsub` is a method of the String class\
    \ (see [String#gsub](http://www.ruby-doc.org/core-2.1.3/String.html#method-i-gsub)).\
    \ [`|` is an alternative block](http://ruby-doc.org/core-2.1.3/doc/syntax/methods_rdoc.html#label-Block%20Arguments).\n\
    <|/ c |>\n<| c |>\nThe `|` syntax is new to me. Thanks for the info!\n<|/ c |>\n\
    <| a dscore=2 tags=sorting,ruby |>\nYou have a lot of ways to do it, but the one\
    \ I've used most often is to use a Hash instead of a string. That way, you can\
    \ just call hash[:word] and it will return the value of the hash.\n<code>", " \
    \ s.split(\" \").sort.join(\" \")\nend\n</cell>\n<code language=julia-1.5>", " \
    \   # return s.shuffle\n    return s.gsub(/[[:space:]]+/, ' ').tr(' ', '') \n\
    end", "  s.split(\" \").sort!.inject(\"\", :+).capitalize\nend", "  return\nend",
  "  s = s.split(' ') # Split sentence to words\n  i = s.length - 1 # index for last\
    \ word\n  \n  # Replace all letters by their index in ascending order\n  while(i\
    \ >= 0)\n    s[i] = s[i].to_s.tr(\"a-z\", \"0-9\").to_i\n    i = i - 1\n  \n \
    \ # Reverse the order of words and blanks\n  s = s[1..-1].reverse\n  \n  return\
    \ s.join(' ')\nend", "    word_list = s.split\n    word_list.sort!\n    word_list.map!{|w|\
    \ w.gsub(/./, \"\").downcase}\n    word_list.join(\"   \").gsub(/^\\s+|\\s+$/,\
    \ \"\").gsub(/\\s+/, \"   \")\nend", "  s.split(' ').collect do |x| \n    char_list\
    \ = x.split('')\n    char_list.sort { |x,y| x.ord<=>y.ord }.join \n  end + \n\
    \  s.split(' ').collect do |x| \n    char_list = x.split('')\n    char_list.sort\
    \ { |x,y| y.ord<=>x.ord }.join \n  end\nend", "  # Split string into array and\
    \ sort it\n  s.split(\" \").sort!\n  # return string with blank space and words\
    \ in reverse order \n  s.gsub(/(\\S+)/) { $1.split(\"\").reverse.join(\"\\n\"\
    ) }\nend", "  s = s.downcase.split(/ /).join(' ')\n  s.scan(/(\\w+)(\\W|$)/){|x|\
    \ x[1]=x[1].downcase}\n  s.scan(/\\s*(\\w+)$/){|x| x[2]=x[2].downcase}\n  s.scan(/(\\\
    w+)\\s*(\\w)/){|x| x[1]=x[1].downcase + x[2].downcase }\n  s.scan(/\\s*(\\w+)\\\
    s*(\\w)/){|x| x[1]=x[1].downcase + x[2].downcase }\n  s.scan(/(\\w+)\\s*(\\w)(\\\
    W|$)/){|x| x[1]=x[1].downcase + x[2].downcase }\n  s.scan(/\\s*(\\w+)\\s*(\\w)(\\\
    W|$)/){|x| x[1]=x[1].downcase + x[2].downcase }\n  s.scan(/(\\w+)\\s*(\\w)(\\\
    W|$)/){|x| x[1]=x[1].downcase + x[2].downcase }\n  s.scan(/\\s*(\\w+)\\s*(\\w)(\\\
    W|$)/){|x| x[1]=x[1].downcase + x[2].downcase }\n  s.scan(/(\\w+)\\s*(\\w)(\\\
    W|$)/){|x| x[1]=x[1].downcase + x[2].downcase }\n  s.scan(/(\\w+)\\s*(\\w)(\\\
    W|$)/){|x| x[1]=x[1].downcase + x[2].downcase }\n  s.scan(/(\\w+)\\s*(\\w)(\\\
    W|$)/){|x| x[1]=x[1].downcase + x[2].downcase }\n  s.scan(/(\\w+)\\s*(\\w)(\\\
    W|$)/){|x| x[1]=x[1].downcase + x[2].downcase }\n  s.scan(/(\\w+)\\s*(\\w)(\\\
    W|$)/){|x| x[1]=x[1].downcase + x[2].downcase }\n  s.scan(/(\\w+)\\s*(\\w)(\\\
    W|$)/){|x| x[1]=x[1].downcase + x[2].downcase }\n  s.scan(/(\\w+)\\s*(\\w)(\\\
    W|$)/){|x| x[1]=x[1].downcase + x[2].downcase }\n  s.scan(/(\\w+)\\s*(\\w)(\\\
    W|$)/){|x| x[1]=x[1].downcase + x[2].downcase }\n  s.scan(/(\\w+)\\s*(\\w)(\\\
    W|$", "  \n  s = s\n  s_new = s\n  \n  while s_new != ''\n    s_new = s_new.split.each\
    \ { |word|\n      word.each_byte { |c| \n        if c.to_i > c.to_i.downcase\n\
    \          s_new = s_new + word.downcase\n        end\n      }\n    }\n    s_new\
    \ = s_new.split\n  end\n  return s_new\nend", "  s = s.downcase\n  s = s.gsub(/[!,.?]\\\
    s/, '') # Replace all punctuations at end of word\n  words = s.split\n  words.map\
    \ do |word|\n    word.split(//).sort.join\n  end.join ' ' #Rebuild the string\
    \ using space between words\nend", "  result = \"\"\n  s.split(\" \").each do\
    \ |word|\n    word.split(\"\").each do |char|\n      if char !~ /[A-Za-z0-9]/\n\
    \        result << char.upcase\n      else\n        result << char.downcase\n\
    \      end\n    end\n    result << \" \"\n  end\n  return result\nend", "  s.split(\"\
    \ \").sort.join\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=string,ruby\
    \ |>\nYou could do some string manipulation using regular expressions, for example,\
    \ split the input on space, and sort them on ascii value.  Then combine them back\
    \ together.\n<|/ a |>\n<| a |>\nHere is what I came up with:\n<code>", "  puts\
    \ s\n  new_str = ''\n  s.split.each do |word|\n    word.chars.sort.each do |char|\n\
    \      new_str += char\n    end\n    new_str += ' '\n  end\n  puts new_str\nend",
  "  ans = ''\n  word_array = s.split(' ') # split input string into array of words\n\
    \  for i in 0...word_array.length\n    if word_array[i].to_s.size > 0\n      chars\
    \ = word_array[i].to_s\n      chars.reverse! # reverse the char array\n      chars.gsub!\
    \ /\\w/, '' # remove all non-word characters\n      chars.gsub! /[!,\\.]/, ''\
    \ # remove punctuation\n      chars.gsub! /[?]/, '' # remove question mark\n \
    \     chars.gsub! /[\\(\\)]/, '' # remove paranthesis\n      chars.gsub! /[\\\
    s\\?]/, '' # remove spaces and question marks\n      ans += chars # concat the\
    \ new word onto the string\n    end\n  end\n  ans\nend", "    sorted_string=''\n\
    \    words = s.split(\" \") # split string into words based on space\n    letters\
    \ = {}\n    for word in words\n        word.downcase! # convert all letters to\
    \ lowercase\n        letters[word] = letters[word].to_i + 1 # create hashmap of\
    \ words to ascii value\n    end\n    words.each { |word|\n        sorted_string\
    \ += letters[word].to_s + (letters[word].to_i==26? \"\" : \" \")\n    }\n    sorted_string\n\
    end", "  s.split(\" \").sort!.inject([\"\"], &:concat).join\nend", "    # replace\
    \ each word with its ascii value\n    words = s.split(' ') #[\"Hello\", \"World\"\
    , \"!!!\"]\n    words_with_ascii = [word.encode('ascii').strip() for word in words]\
    \ #[\"ehllo\", \"wdlor\", \"!!!\"]\n    # sort words\n    sorted_words = sorted(words_with_ascii)\n\
    \    # join sorted words\n    return ''.join(sorted_words)", "    w = s.split('\
    \ ')\n    w.sort.with_index{ |a,b| b.to_i-a.to_i }\n    w.join(' ')\nend\n</code>\n\
    And here's the recursive solution:\n<code>", "  s.gsub(\" \", \"_\").tr(\"a-zA-Z\"\
    , \"Z-A\")\nend", "\ts = \"\"\n\tletters = (\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"\
    ,\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\"\
    ,\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"\
    ,\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\"\
    ,\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\")\n\tspaces = \" \"\n\twords = s.split\
    \ (\" \")\n\tnewword = \"\"\n\tlenword = words.length\n\tfor letter in letters\n\
    \t\tfor x in range(0,lenword)\n\t\t\tif letter == words[x]\n\t\t\t\tnewword =\
    \ newword + letter + \" \"\n\t\t\t\tbreak\n\t\t\telse \n\t\t\t\tif spaces.include?\
    \ words[x]\n\t\t\t\t\tnewword = newword + letter + \" \"\n\t\t\t\t\tbreak\n\t\t\
    \t\telse\n\t\t\t\t\tnewword = newword + letter + words[x] + \" \"\n\t\t\t\t\t\
    break\n\t\tnewword = newword + \" \"\n\tend\n\tnewword = newword.strip\n\tnewword\
    \ = newword.gsub (/[ ]+/, \" \")\n\treturn newword\nend", "    # Write your solution\
    \ here\n    words = s.split(' ')\n    sorted_words = []\n    for i in words:\n\
    \        sorted_words.append(i.encode('ascii', 'ignore').decode())\n    return\
    \ ' '.join(sorted_words)\n</cell>\n<cell>\nanti_shuffle('Hi')\n</cell>\n<cell>\n\
    anti_shuffle('hello')\n</cell>\n<cell>\nanti_shuffle('Hello World!!!')\n</cell>\n\
    <text>\nReversed words (Reverse the order of the words in a sentence while keeping\
    \ the blank spaces)", "  # Write your solution here\n  wordlist = s.split(\" \"\
    ).map {|s| s.upcase}\n  wordlist.sort!\n  return wordlist.join(\"  \")\nend",
  "  result = s.split(' ').sort { |a, b| a.chars.to_a.sort_by { |x| x.ord - b.ord\
    \ }.join.to_i }\n  result.join(' ')\nend", "  return s.gsub(/\\w+/){|w| w.chars.sort_by(&:ord).join}\n\
    end\n</cell>\n<code language=julia-0.6>\nanti_shuffle('Hi')\n</cell>\n<code language=julia-0.6>\n\
    anti_shuffle('hello')\n</cell>\n<code language=julia-0.6>\nanti_shuffle('Hello\
    \ World!!!')\n</cell>\n<code language=julia-0.6>", "  s.split(//).sort.join('\
    \ ')\nend\n</cell>\n<cell>\nanti_shuffle('Hi')\n</cell>\n<cell>\nanti_shuffle('hello')\n\
    </cell>\n<cell>\nanti_shuffle('Hello World!!!')\n</cell>\n<cell>", "  s.gsub!(/\\\
    s+/, ' ')\n  s.gsub!(/\\w+/, { |w| w.reverse.to_a }.flatten.compact.sort.join)\n\
    \  s.gsub!(/\\s+/, ' ')\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\nI used the\
    \ code from above but realized that it only worked for some letters and numbers.\
    \ Here is my solution that works for both lowercase and uppercase letters and\
    \ numbers:\n<code>", "  s.scan(/\\w+/)\n  s.each_char.with_index.with_object([])\
    \ { |e, i|\n    next if e.nil?\n    ord = e.ord >= 97 ? e.ord - 97 : e.ord + 1\n\
    \    i.push([e.dup, ord])\n  }.sort_by { |e| -e[1] }.reverse.map { |e| e[0] }.join(\"\
    \ \")\nend\n</cell>\n<code language=conda-env-course-env-py>", "    words,_ =\
    \ [s.split(\" \").sort{ |a,b| a.downcase <=> b.downcase }] \n    words.join(\"\
    \ \")\nend", "  s = ''\n  s.split(\" \").each do |word|\n    word += ''\n    word.tr!('a',\
    \ 'Z') + word.tr!('Z', 'a')\n    word.tr!('0', 'Z') + word.tr!('Z', '0')\n   \
    \ word.tr!(' ', '') + word.tr!('', '')\n  end\n  s\nend\n</code>\n<|/ a tags=string,ruby\
    \ |>\n<| a dscore=2 tags=string,ruby |>\nHere's an example that works with Rails.\n\
    <code>", "\ts = s.split(\" \").map { |x| x.each_char.sort_by { |y| y.ord }.join\
    \ }.join(\" \")\n\treturn s\nend\n</cell>\n<code language=julia-0.5>", "  # Solution\
    \ code here\nend", "  return s.gsub(/\\w+/){|w| w.split(//).sort_by(&:ord).join}\n\
    end", "  s = s.split(\"#\")[0]\n  s = s.split(\"&\")[0]\n  s = s.split(\" \")\n\
    \  s = s[1..-1]\n  s.each do |word|\n    word.each_char do |c|\n      c.upcase!\n\
    \    end\n  end\n  return s\nend", "  s.split(' ').sort.join\nend\n</cell>\n<code\
    \ language=julia-1.6>", "  result = \"\"\n  s.split(' ').sort.each do |word|\n\
    \    result << word.split('').reverse.join\n  end\n  return result\nend", "  #\
    \ Your code here\n  \nend", "  s = s.split(\" \").map{ |word| word.tr(\" \",\"\
    \") }.join\n  s.split(\"\").sort!.map{|c| c.chr}.join(\" \")\nend", "  s = s.split()\
    \ # Split string into an array\n  s.map! do |s| # Map the array to convert characters\
    \ to ascii values\n    ord = s.ord # Get the ascii value of the character\n  \
    \  ord.to_s.rjust(2, '0') # Convert to 2 digit string with leading 0\n  end\n\
    \  s.sort { |a, b| a.to_s <=> b.to_s } # Sort the array in ascending order\n \
    \ s.join.tr(\" \",\"_\") # Join all elements of the array into a string\nend",
  "  s = s.gsub(/\\s+/, ' ')\n  s.gsub!(/([a-z])/) { $1.downcase }\n  s.gsub!(/[^a-z]/)\
    \ { |x| x.tr('abcdefghijklmnopqrstuvwxyz', 'klmnopqrstuvwxyzabcdefghij') }\n \
    \ s.gsub!(/\\s+/, ' ')\n  s.downcase!\n  s\nend", "  # TODO: Write your solution\
    \ here\n  s.split(' ').sort { |a,b| a.to_i <=> b.to_i }.join\nend\n</cell>\n<cell>",
  "  s = s.split(' ') \n  s.each do |str| \n    str.gsub!(' ', '') \n  end\n  s.join!('\
    \ ').downcase \n  s.map! { |str| str.each_char.inject(:+).to_s.split(//).sort_by\
    \ { |s| s.to_i }.join }\n  s.join!(' ').upcase\n  s.join(' ')\nend", "  s = s.split(//).sort{|a,b|\
    \ a.ord <=> b.ord}.join\n  while s.gsub!(/(\\s)/, \"\")\n    s = s.gsub(/(\\s)/,\
    \ \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n   \
    \ s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\\
    s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n\
    \    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\\
    s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n\
    \    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\\
    s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n\
    \    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\\
    s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n\
    \    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\\
    s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n\
    \    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\\
    s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n\
    \    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\\
    s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n\
    \    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\\
    s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n    s = s.gsub(/(\\s)/, \"!\")\n\
    \    s = s.gsub(/(", "    words = s.split.to_a\n    words.sort { |x, y| x.ord\
    \ <=> y.ord }\n    return words.join(' ')\nend", "  sorted_string = ''\n  split_words\
    \ = s.split(\" \").sort\n  s.split(\" \").sort.each do |word|\n    sorted_string\
    \ << word.to_s.reverse\n  end\n  split_words.each do |word|\n    sorted_string\
    \ << word.to_s.reverse\n  end\n  sorted_string\nend", "\twords = s.split(' ')\n\
    \twords.map! { |x| x.tr(\" \",\"_\") }\n\twords = words.join.split(//)\n\twords.map!\
    \ { |x| x.downcase }\n\twords.sort!\n\treturn words.join(' ')\nend", "  s = s.split('\
    \ ') \n  n = s.length\n  result = []\n  for i in 0...n-1\n    j = rand(0...n-1)\n\
    \    result[i] = s[j] unless s[i].include? s[j]\n    result[j] = s[i] unless s[i].include?\
    \ s[i]\n    result[n-1] = s[i] unless s[i].include? s[n-1]\n  end\n  return result.join('\
    \ ')\nend\n</cell>\n<code language=julia-1.5>", "  return s.gsub(/\\w+/) { |x|\
    \ x.each_char.sort_by{|y| y.ord }.join.tr(' ','') }\nend\n</code>\nTests:\n<code>\n\
    anti_shuffle('hello')  #=> \"elloh\"  \nanti_shuffle('Hello World!!!')  #=> \"\
    Hello World!!!\"\nanti_shuffle('Hi John') #=> \"Hi John\"\n</code>\n<|/ a tags=ruby,ruby-on-rails,string,ruby-on-rails-4\
    \ dscore=2 |>\n<| c |>\nThe method does not work correctly with special characters\
    \ like \u24C6, \u3142, etc\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,string,ruby-on-rails-4\
    \ |>\n<code>", "    # Your code here\n    new_s = ''\n    s = s.to_s\n    words\
    \ = s.split\n    words.each do |word|\n      if word.empty?\n        new_s +=\
    \ word\n      else\n        a = word[0].ord\n        b = word[1].ord\n       \
    \ c = word[2].ord\n        d = word[3].ord\n        e = word[4].ord\n        f\
    \ = word[5].ord\n        g = word[6].ord\n        h = word[7].ord\n        i =\
    \ word[8].ord\n        j = word[9].ord\n        k = word[10].ord\n        l =\
    \ word[11].ord\n        m = word[12].ord\n        n = word[13].ord\n        o\
    \ = word[14].ord\n        p = word[15].ord\n        q = word[16].ord\n       \
    \ r = word[17].ord\n        s = word[18].ord\n        u = word[19].ord\n     \
    \   words = new_s << word\n      end\n    end\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 tags=ruby |>\nA better way would be to use Ruby 1.9.2 Array#rotate.\n\
    <code>", "  # TODO: Write your code here\n  s = s.split(\" \").map { |x| x.chars.sort.join.chars.reverse\
    \ }.join\n  s = s[0..-s.size]\n  s\nend\n</cell>\n<code language=julia-1.5>",
  "  return s\nend", "    words = s.split(\" \")\n    words.sort!\n    new_s = words.join(\"\
    \ \")\n    return new_s\nend ", "  s = s.split(\"  \").to_sentence\n  s = s.gsub(/./,\
    \ &:ord)\n  return s\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThank you very\
    \ much for your answer! It did solve my problem, but I would like to know why\
    \ this happened. I did not have to use your \"anti_shuffle\" function at all in\
    \ my code.\n<|/ c |>\n<| c |>\nBecause you were using `String#gsub!`, which modifies\
    \ the string in place, and you didn't specify a block. The string gets modified\
    \ in-place and `gsub` returns the original string, so `s` isn't altered. Using\
    \ `gsub!` with a block explicitly tells Ruby to create a copy of the string and\
    \ modify that instead. `gsub!` is very useful if you're dealing with a long string\
    \ of text and want to make changes in place without having to create a new string.\n\
    <|/ c |>\n<| c |>\nThank you, that makes perfect sense!\n<|/ c |>\n<| a dscore=1\
    \ |>\nThe problem is this line:\n<code>\nputs s.gsub(/./, &:ord)\n</code>\nIt\
    \ should be:\n<code>\nputs s.gsub(/./) do |c|\n    puts c.ord\nend\n</code>\n\
    But this also doesn't do what you expect:\n<code>", "  word_list = s.split(' ')\n\
    \  final_list = []\n  word_list.each do |word|\n    if word.empty?\n      final_list\
    \ << ''\n    else\n      new_word = word_list.map do |w|\n        if w.empty?\
    \ || w == ' ' then\n          w\n        else\n          w.downcase\n        \
    \  w.gsub(/[!,@,#,$,%,^,&,*,(,),-,_,+,=,{,[,],},.,?]/, '')\n        end\n    \
    \  end.join('').split('')\n      final_list << new_word.sort.join('')\n    end\n\
    \  end\n  final_list\nend", "  # Write your code here\n  return s.split(' ').map\
    \ {|a| a.gsub(/[ -]/, \"a\").downcase }.join(' ')\nend\n</cell>\n<cell>", "  s\
    \ = s.split(\" \").map(&:downcase).join(\" \")\n  s.each_char do |c|\n    i =\
    \ c.ord - 32\n    s = s.sub(/./) { |s| s.chr(i) }\n  end\n  s\nend", "  s.split('\
    \ ').sort_by{|x| x.each_char.sort_by{|y| y.ord}.join}.join\nend", "  s.split('\
    \ ').sort.join(' ')\nend", "    return s.split().sort{|x, y| x.to_i <=> y.to_i}.join\n\
    end", "    # Your code goes here\n    return s\n</cell>\n<cell>\nassert anti_shuffle('Hi')\
    \ == 'Hi'\nassert anti_shuffle('hello') == 'ehllo'\nassert anti_shuffle('Hello\
    \ World!!!') == 'Hello World!!!'\nassert anti_shuffle(' ') == ' '\n</cell>\n<text>\n\
    Question 10 (3 points)\nWrite a function that takes a string as input and returns\
    \ a new string\nthat contains only the unique characters in that string separated\
    \ by spaces\nthat you can sort.", "    i = 0\n    temp = s\n    new_string = ''\n\
    \    while i < len(s)\n        i += 1\n        if s[i] == ' ' then\n         \
    \   temp = temp + s[i + 1]\n        else\n            if s[i] != temp[-1] then\n\
    \                new_string += temp[-1] + s[i]\n            else\n           \
    \     new_string += s[i]\n            end\n        end\n    end\n    return new_string\n\
    end", "    arr = []\n    str = s.split\n    str.each do |str|\n        str.chars.sort_by{|x|\
    \ x.ord}.each do |x|\n            arr << x.chr\n        end\n    end\n    return\
    \ arr.join(' ')\nend", "  s = s.split(//)\n  s.reverse!\n  s.join ''\nend", " \
    \   # Your code here\n    arr = s.split(//).sort_by { |word| word.upcase.to_i(16).to_s\
    \ }.join //\n    arr << '!' if s.count != arr.length\n    return arr\nend\n</code>\n\
    Test cases\n<code>\nanti_shuffle('Hi') # => Hi\nanti_shuffle('hello') # => ehllo\n\
    anti_shuffle('Hello World!!!') # => Hello !!!Wdlor\n</code>\n<|/ a tags=ruby,sorting,string\
    \ |>\n<| c |>\nThanks for the answer. I know this question was asked long ago.\
    \ But could you please explain the code?\n<|/ c |>\n<| c |>\n, sure let me edit\
    \ my answer and explain it\n<|/ c |>\n<| c |>\nThe method `#sort_by` returns an\
    \ `Enumerable` of key-value pairs. After sorting each key-value pair is joined\
    \ with space and a new `!` if the count of keys and values do not match. For more\
    \ details, you can refer to [Array#sort_by](http://ruby-doc.org/core-2.4.0/Array.html#method-i-sort_by)\
    \ and [Enumerable#join](http://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-join)\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "    arr = s.split(\" \")\n    arr1 = []\n\
    \    arr2 = []\n    arr3 = []\n    for i in arr\n        arr1 = arr1 + i.split(\"\
    \")\n        arr2 = arr2 + i.split(\"\")\n        arr3 = arr3 + i.split(\"\")\n\
    \    arr3.sort\n    arr1.sort\n    arr2.sort\n    new_str = \"\"\n    i = 0\n\
    \    while i < len(arr3):\n        new_str = new_str + arr3[i]\n        i += 1\n\
    \    while i < len(arr2):\n        new_str = new_str + arr2[i]\n        i += 1\n\
    \    while i < len(arr1):\n        new_str = new_str + arr1[i]\n        i += 1\n\
    \    return new_str", "  return s.gsub(/./){|w| w.gsub(/ /,'_').gsub(/[a-z]/){|c|\
    \ c.ord - 'a'.ord}}\nend\n</code>\n<|/ a tags=string,ruby,sorting dscore=4 |>\n\
    <| c |>\nThis is great - thank you! I'll use it and study it, as it seems very\
    \ elegant.\n<|/ c |>\n<| a dscore=4 tags=string,ruby,sorting |>\nThis is another\
    \ way using sort_by and gsub!:\n<code>\n\"This Is A Test\".sort_by {|x| x.gsub(/\
    \ /, ' ')}.reverse\n</code>\n<|/ a |>\n<| c |>\nThis also works in Rails console,\
    \ but I find this more readable.\n<|/ c |>\n<| c |>\nThis is not only working\
    \ in Rails console, but also working in irb and ruby 2.3.0. :)\n<|/ c |>\n<| a\
    \ tags=string,ruby,sorting |>\nHere's another one using Enumerable#inject\n<code>\n\
    \"This Is A Test\".split(' ').inject([]) {|a, c| a << c unless a.empty? || !c.empty?;\
    \ a}.join(' ')\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI didn't know inject was\
    \ part of Ruby.  Thanks.\n<|/ c |>\n<| c |>\nJust a note: Your regex splits on\
    \ spaces only. Hence \"This\" will become [\"This\"]. You need to add `/\\s+/`\
    \ regexp to split on one or more spaces.\n<|/ c |>\n<| a dscore=3 |>\n<code>",
  "  new_s = ''\n  words = s.split\n  words.each do |w|\n    w = w.gsub(/./, ' ')\n\
    \    w.split('').sort.each do |c|\n      new_s << c\n    end\n    new_s << ' '\n\
    \  end\n  return new_s.strip\nend", "  s = s.downcase\n  s.gsub!(/[ \\t]+/, '\
    \ ')\n  s.gsub!(/([a-z])(\\w*)\\1/, '\\2 \\1')\n  s.split\nend\n</cell>\n<cell>",
  "  s.split(' ').map{|word| word.chars.sort_by{|c| c.ascii_value.to_i}.join}.join('\
    \ ')\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,ruby,string |>\nYou could\
    \ use regex to find all spaces and replace them with another character (let's\
    \ say _):\n<code>", "  s.split.sort.join(\" \")\nend\n</code>\n<|/ a tags=string,ruby\
    \ |>\n<| a dscore=2 |>\n<code>", "    # Split sentence into array of words\n \
    \   arr = s.split(\" \")\n    # Create a new empty string\n    new_str = \"\"\n\
    \    # Iterate over array of words\n    for word in arr\n        # Add the next\
    \ character to new string\n        new_str += word[-1]\n        # Iterate over\
    \ each character of word\n        for char in word\n            # Replace the\
    \ character with its ascii value\n            new_str += word[word.index(char)+1]\n\
    \            # Delete the character from word\n            word = word.replace(char,\
    \ \"\")\n    # Return the new string\n    return new_str", "  s.gsub(/\\w+/) {\
    \ |word| word.split('').sort.join }\nend", "    # Write your code here\n    words\
    \ = s.split(\" \").sort\n    words.reverse!\n    s = words.join\n    s\nend\n\
    </cell>\n<code language=julia-1.6>", "  s = s.gsub(/\\s+/, '').downcase\n  s.gsub!(/(([\\\
    p{L}\\p{N}])|(\\W))/) do |match|\n    \"#{$1}#{$2}#{match[2]}\"\n  end\n  s.scan(/[\\\
    w'-]+/).sort.join\nend", "  s = s.split \" \"\n  s.sort!\n  s.reverse!\n  s.join(\"\
    \ \")\nend", "  s.split.each {|w| w.gsub!(/\\s+/, ' '*w.size*' ')}\n  s.split.each\
    \ {|w| w.tr!(' ', ' ')}\n  s.split.each {|w| w.split.sort.each {|a| a.insert(0,\
    \ \" \")}}\n  s.join\nend", "  return s.gsub(/(\\w+|\\s+)/) do |m|\n    m.downcase\n\
    \  end\nend", "  s = s.downcase\n  s.gsub!(/\\s+/, ' ')\n  a = s.split(' ').sort_by\
    \ {|word| word.count(' ')}.reverse\n  s = ''\n  a.each { |word| s += word }\n\
    \  s\nend", "    words = s.split(\" \")\n    new_word = \"\"\n    word_count =\
    \ 1\n    word_list = []\n    while word_count != words.count\n        word_count\
    \ += 1\n        word_list << words[word_count-1]\n        word_list << words[word_count]\n\
    \    word_list.sort!\n    for index in word_list.index\n        new_word += words[index]\n\
    \    end\n    new_word += words[word_list.index]\n    return new_word\nend", " \
    \ \n  s = s.split\n  \n  s.each do |w|\n    w.each_char do |c|\n      letter =\
    \ String.new(c)\n      letter = letter[0].ord + letter[1].ord \n    end\n  end\n\
    \  \n  s.join\nend", "  return s.split(\" \").map{|x| x.chars.sort.join}.join\
    \ \" \"\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\nHere's another way\
    \ that doesn't involve regular expressions nor sorting the characters. It's just\
    \ about breaking up the string into single words, sorting each word, and joining\
    \ back together again:\n<code>", "  s.gsub(/\\s+/, ' ').gsub(/\\w+/) { |word|\n\
    \    word.each_char.sort.join\n  }\nend", "  s.split.each do |word|\n    word.chars.sort_by\
    \ do |char|\n      char.to_i\n    end.join\n  end\nend", "    words = []\n   \
    \ words = s.split.split(' ')\n    new_word = ''\n    \n    sorted_word = ''\n\
    \    \n    i = 0\n    for word in words\n        if word.to_s.size > 0 \n    \
    \        new_word << word\n            \n        else \n            sorted_word\
    \ << new_word\n            new_word = ''\n            \n        end\n        \n\
    \        i += 1\n        \n        if i == words.size\n            sorted_word\
    \ << new_word\n        end\n    \n    end\n    \n    sorted_word << new_word\n\
    \    \n    return sorted_word\nend", "  return s.gsub(/\\w+|\\s+/){|w| w.scan(/./).sort.join}\n\
    end", "  s = s.to_s\n  s.split(' ').sort.join(' ')\nend", "  sorted_s = s.split.sort_by\
    \ { |x| x.unpack('c').to_i }.join\n  sorted_s.empty? ? s : sorted_s\nend", " \
    \ s = ''\n  s.split(//).sort! do |a, b|\n    if a.length < b.length then a <=>\
    \ b else\n      a <=> b unless a.length == b.length\n    end\n  end\n  return\
    \ s\nend", "  new_s = s.split(\" \").sort_by { |s| s.unpack(\"U\").chars.sort.join.to_i\
    \ }.join(' ')\n  return new_s.downcase\nend", "    chars = s.gsub(\" \", \"\\\
    0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\").reverse\n    chars.reverse.insert(0,\
    \ \" \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n    s.gsub!(\" \", \"\\0\").split(\"\").sort_by { |e| e.ord.to_s }.join(\"\
    \")\n", "  s = s.split(' ').sort\n  s.join(' ')\nend", "    str = s.split(\" \"\
    )\n    \n    str.each {|item|\n        word.each_char do |i|\n            if \
    \ i == item\n                item = \"\"\n            else\n                item\
    \ += i\n            end\n        end\n    }\n    str = item.join(\" \")\nend",
  "  s.split.each_with_index.sort_by(&:last).join(\" \")\nend", "  return s.split\n\
    \    .map { |x|\n      x.chars.sort.join\n    }.join\nend\n</cell>\n<code language=conda-root-py>",
  "  s.split(' ').sort.join\nend", "    i = 0\n    while i < s.length\n        j =\
    \ i + 1\n        while j < s.length\n            if s[i].ord <= s[j].ord\n   \
    \             s[j], s[i] = s[i], s[j]\n            j = j + 1\n        i = i +\
    \ 1\n    end\n    return s\nend", "  s.split(' ').sort.join.gsub(/./){|c| c.to_i\
    \ }.gsub(/\\s/){|c| c.to_i }.to_s\nend", "  s.split.each do |word|\n    word.split.each\
    \ do |letter|\n      if letter.upcase < letter.downcase then\n        word.delete(letter)\n\
    \      else\n        word.insert(letter, letter)\n      end\n    end\n  end\n\
    \  s.split.join(\" \")\nend", "  s = s.to_s\n  s = s.gsub(/\\w+/) do |word|\n\
    \    word.chars.sort_by{|c| c.ord - 32}.join\n  end\n  return s\nend", "  # @return\
    \ a string where all words (separated by space) are replaced by a new word\n \
    \ #        where all the characters arranged in ascending order based on ascii\
    \ value.\n  s = s.split(\" \").sort_by{|x| x.ord}.join(\" \")\n  s = s[0,s.size-2]\
    \ + s[s.size-2,s.size]\n  s = s.gsub(/([a-z])/){|x| [x.ord].pack(\"U\")}\n  s.gsub!(\"\
    !\", \"!!\")\n  s.gsub!(\"?\", \"??\")\n  s.gsub!(\"!?\", \"!!!\")\n  s.gsub!(\"\
    ??\", \"???\")\n  s.gsub!(\"???\", \"????\")\n  s\nend", "  s.split(//).sort.join(\"\
    \")\nend\n</cell>\n<cell>", "  s.split\n  s.chars.sort_by{|x| x.ord}\n  s.join\n\
    end", "  s.scan(/\\w+/){|w| w.split('').sort!.map{|s| s.ord - 97}}.join\nend",
  "  s = s.downcase\n  s.gsub(/\\w+/){|w| w.split(//).sort!}\nend", "  s.split\n \
    \ result = \"\"\n  word = \"\"\n  i = 0\n  j = 1\n  while i < s.length do\n  \
    \  if s[i] == \" \" then\n      if word.length > 0 then\n        result += word\n\
    \      end\n      word = s[i]\n      i += 1\n      j += 1\n    else\n      if\
    \ j > s.length then\n        word += s[i]\n      else\n        word = word + s[j]\n\
    \        j += 1\n      end\n      i += 1\n    end\n  end\n  if word.length > 0\
    \ then\n    result += word\n  end\n  return result\nend", "  # Your code here\n\
    \  return s\nend", "\ts.split(' ').sort.join.tr(' ', '') \nend\n</cell>\n<cell>",
  "  new_str = \"\"\n  s.split(\" \").each_with_index do |word, index|\n    new_str\
    \ += word[0..index] + word[index+1..-1] + \" \"\n  end\n  new_str\nend", "  #\
    \ TODO: Write your solution here\n  s.scan(/\\w+/).inject(s) {|word, new_word|\n\
    \    new_word.scan(/./).sort.reduce(:+).to_s.gsub(/\\w+/, word)\n  }\nend", " \
    \   s.split(' ').map{|word| word.chars.map(&:ord).sort.join}.join(' ')\nend",
  "  s.gsub!(/\\s+/, '')\n  s.split.sort.join(' ')\nend", "  s.scan(/\\w+/) do |word|\n\
    \    word.split(\" \").sort.join(\" \")\n  end\nend", "  s = s.split\n  s.sort!\n\
    \  return s.join(' ')\nend\n</cell>\n<code language=julia-1.0>", "  result = s\n\
    \  s.gsub(/./){|c| result.insert(0, c.chr) }\n  result\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI wouldn't do this in Ruby. I'd use Perl or Python. It can do this\
    \ with a one-liner - not that I'd recommend this in any way.\n<|/ c |>\n<| c |>\n\
    Why would this be bad in Ruby?\n<|/ c |>\n<| c |>\nIt isn't - you do it in Ruby\
    \ but you don't do it in Perl or Python.\n<|/ c |>\n<| c |>\n- I've had to do\
    \ this in multiple languages over the years - not just Ruby, but Ruby, Python,\
    \ Perl, Python, C++, VB6, etc.  In Perl or Python you do it with a one-liner.\
    \  However, in Ruby, it's a little more involved (involving `collect`).  But I\
    \ agree that Ruby is much more readable than Perl and Python - it really is a\
    \ better programming language.  I haven't done this in Perl and Python because\
    \ Perl and Python are very different languages and don't tend to follow the same\
    \ style.  So I haven't done this in Ruby.  But I didn't say you wouldn't do this\
    \ in Perl or Python.  I said I wouldn't do it *this way*.  I'd do it a different\
    \ way.\n<|/ c |>\n<| a |>\nThe Ruby way:\n<code>", "  s.split(\" \").sort.join.upcase\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "    s = s.split('\
    \ ')\n    s.map! { |i| i.tr('a-z', 'n-z').tr('A-Z', 'Nz') }\n    s.join(' ')\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nI have tried this and it is\
    \ working perfectly.\n<code>", "  # implement anti-shuffle here\nend\n</pre>\n\
    </div>", "    words = s.split(' ')\n    new_s = ''\n    \n    new_s = words.join('')\n\
    \    \n    \n    return new_s\n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    ", "  s = s.split(' ')\n  new_s = ''\n  (0..s.count('')).each do |x|\n\
    \    new_s += s[x]\n  end\n  (0..s.count('')).each do |x|\n    puts new_s[x] +\
    \ ' '\n  end\nend", "  s = s.split(\" \").map{|a| a.chars.sort.join}.join(\" \"\
    )\n  s = s.split(\" \").map{|a| a.chars.sort.join}.join \" \"\nend\n</cell>\n\
    <cell>", "  s = s.downcase\n  s.gsub!(/([a-z])/) { |x| x.ord + 32 }\n  s.gsub!(/([A-Z])/)\
    \ { |x| x.ord - 32 }\n  s.gsub!(/\\s+/, ' ')\n  s\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nHow does this work without `join`? `s.gsub(/\\s+/, ' ').split('\
    \ ').sort.join(' ')`\n<|/ c |>\n<| c |>\nThis also doesn't work, for example anti_shuffle('Hello\
    \ World!!!') returns 'H!ello W!orld!!!'\n<|/ c |>\n<| c |>\nI guess you meant\
    \ to say `anti_shuffle('HellOoo WoRlDd!!')` returns 'HelLO WrlDd!!', and I guess\
    \ you didn't bother to check that. Good luck to all.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=4 |>\n<code>", "  # Split string into array of words\n  split_s = s.split('\
    \ ')\n  # Use Hash to create new words and keep their order\n  word_order = Hash.new\n\
    \  for i in split_s\n    word = i.chomp\n    word_order[word] = word\n  end\n\
    \  # Loop through hash items and replace each one with its key\n  for i in word_order.keys\n\
    \    split_s[0] = i\n    break\n  end\n  new_s = ''\n  for i in split_s\n    new_s\
    \ += word_order[i] + \" \"\n  end\n  new_s.chomp!\n  return new_s\nend", "  return\
    \ s.split(' ').sort_by{|x| x.bytes.to_a.sort_by{|x| x[0].chr}.join}\nend", " \
    \ s.downcase!\n  s.gsub!(/\\s+/, ' ')\n  s.split.sort\n  s.gsub!(/\\s+/, ' ')\n\
    \  s\nend", "    s.split(' ').sort! do |a, b|\n        # Split each string into\
    \ a word and an extra empty array\n        a_w, a_e = a.split('')\n        b_w,\
    \ b_e = b.split('')", "  new_s = \"\"\n  i = 0\n  word_list = s.split(\" \") #\
    \ Splits the sentence into individual words\n  new_word_list = word_list.clone\
    \ # Clones the original words in word_list to avoid side effects\n  new_word_list.sort_by\
    \ { |word| word.ord.to_s } # Sorts them in ascending order based on their ascii\
    \ value\n  new_word_list.each do |word| # Iterates over each word in the sentence\n\
    \    new_word_list[i] = new_word_list.shift # Removes first element from new_word_list\
    \ to replace it\n    new_s << word # Adds the word to new_s\n    i += 1 # Adds\
    \ 1 to i because we removed one word each time\n  end\n  return new_s\nend", " \
    \ s.split(\" \").sort.join(\" \")\nend\n</cell>\n<code language=julia-1.4>\nanti_shuffle(\"\
    Anti Shuffle\")\n</cell>\n<code language=julia-1.4>\n@test anti_shuffle(\"Anti\
    \ Shuffle\") == \"Anti Shuffle\"\n</cell>\n<code language=julia-1.4>", "    s.split(\"\
    \ \").sort.join(\" \")\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\nHere's\
    \ a solution that I came up with that uses regex and includes no methods:\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
