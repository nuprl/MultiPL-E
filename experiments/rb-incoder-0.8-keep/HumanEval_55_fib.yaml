name: HumanEval_55_fib
language: rb
prompt: "# Return n-th Fibonacci number.\n# >>> fib(10)\n# 55\n# >>> fib(1)\n# 1\n\
  # >>> fib(8)\n# 21\ndef fib(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib\n\
  \    candidate = method(:fib)\n    assert_equal(55, candidate.call(10))\n    assert_equal(1,\
  \ candidate.call(1))\n    assert_equal(21, candidate.call(8))\n    assert_equal(89,\
  \ candidate.call(11))\n    assert_equal(144, candidate.call(12))\n  end\nend\n"
completions: ["    return n if n < 2 else fib(n-1) + fib(n-2)\n</code>\n<|/ a tags=functional-programming,recursion,fibonacci,ruby\
    \ dscore=2 |>\n<| a dscore=2 |>\nHere is my solution for iterative version:\n\
    <code>", "  if n<2:\n    return n\n  return fib(n-1)+fib(n-2)\nend", "  return\
    \ n < 2 ? n : fib(n-1) + fib(n-2)\nend", "    return n < 2 ? n : fib(n-2) + fib(n-1)\n\
    end", "    return n if n < 2 else fib(n-1) + fib(n-2)\nend", "  # Initialize our\
    \ result to the first Fibonacci number.\n  a, b = 0, 1\n  while b < n:\n    a,\
    \ b = b, a+b\n  return a\nend\n</cell>\n<code language=julia-1.5>\nfib(0)\n</cell>\n\
    <code language=julia-1.5>\nfib(1)\n</cell>\n<code language=julia-1.5>\nfib(10)\n\
    </cell>\n<code language=julia-1.5>\nfib(100)\n</cell>\n<code language=julia-1.5>\n\
    fib(1000)\n</cell>\n<code language=julia-1.5>\n@time fib(100)\n</cell>\n<code\
    \ language=julia-1.5>\n@time fib(1000)\n</cell>\n<code language=julia-1.5>\n@time\
    \ fib(1000)\n</cell>\n<code language=julia-1.5>\n@time fib(1000)\n</cell>\n<code\
    \ language=julia-1.5>\n@time fib(1000)\n</cell>\n<text>\nExercises", "    if n\
    \ <= 1: return 1\n    return fib(n-2) + fib(n-1)", "  a = b = nil\n  until n >\
    \ 2 do\n    a, b = b, a+b\n    n -= 1\n  end\n  a\nend\n</cell>\n<text>\nNow we\
    \ can get the Fibonacci number for n=10:", "  return n if n < 2 else fib(n-1)\
    \ + fib(n-2)\nend", "  if n < 2\n    return n\n  a = fib(n-1) + fib(n-2)\n  return\
    \ a\nend", "    if n < 0\n        0\n    else\n        if n == 0\n           \
    \ 1\n        else\n            fib(n-1) + fib(n-2)\nend", "  return n < 2 ? n\
    \ : fib(n-2) + fib(n-1)\nend", "  return 1 if n <= 1 else fib(n-2) + fib(n-1)\n\
    end", "  return 0 if n <= 1 then 1 else fib(n - 1) + fib(n - 2)\nend", "\ta,b\
    \ = 1,1\n\twhile n > 0\n\t\ta,b = b,a+b\n\t\tn = n-1\n\tend\n\ta\nend", "  a,\
    \ b = 0, 1\n  while n >= 0\n  \ta, b = b, a + b\n  \tn -= 1\n  end\n  return a\n\
    end", "  a, b = 0, 1\n  while b < n\n    a, b = b, a+b\n  end\n  a\nend", "  if\
    \ n == 0\n    return 0\n  if n == 1\n    return 1\n  return fib(n-1) + fib(n-2)\n\
    end", "  @_fib.call n, @fib\nend\nfib(n) = case n of\n  0           -> 0\n  1\
    \           -> 1\n  2           -> 1\n  else        -> fib(n - 1) + fib(n - 2)\n\
    end", "\tif n == 0 or n == 1\n\t\t1\n\telse\n\t\tfib(n-1) + fib(n-2)\nend", " \
    \ return n if n < 3 else fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert fib(0) == 1\n@assert fib(1) == 1\n@assert fib(2) == 2\n@assert fib(7)\
    \ == 13\n@assert fib(8) == 21\n@assert fib(10) == 55\n@assert fib(15) == 89\n\
    @assert fib(16) == 144\n@assert fib(21) == 233\n@assert fib(22) == None\n@assert\
    \ fib(23) == None\n@assert fib(24) == None\n@assert fib(25) == None\n@assert fib(35)\
    \ == None\n@assert fib(36) == None\n@assert fib(37) == None\n@assert fib(38) ==\
    \ None\n@assert fib(39) == None\n@assert fib(40) == None\n@assert fib(41) == None\n\
    @assert fib(42) == None\n@assert fib(43) == None\n@assert fib(44) == None\n@assert\
    \ fib(45) == None\n@assert fib(46) == None\n@assert fib(47) == None\n@assert fib(48)\
    \ == None\n@assert fib(49) == None\n@assert fib(50) == None\n@assert fib(51) ==\
    \ None\n@assert fib(52) == None\n@assert fib(53) == None\n@assert fib(54) == None\n\
    @assert fib(55) == None\n</cell>\n<text>\nProblem 1c: Fibonacci numbers\nDefine\
    \ a function, fibonacci(n), that calculates the nth Fibonacci number. If n is\
    \ greater than $50$, return $None$.", "  if n < 0\n    puts \"The fib() function\
    \ requires an integer >= 0\"\n    exit 1\n  end\n  if n == 0 || n == 1\n    return\
    \ n\n  end\n  return fib(n - 1) + fib(n - 2)\nend", "  return n == 0 || n == 1\
    \ ? n : fib(n-1) + fib(n-2)\nend", "    a, b = 0, 1\n    while a < n\n      a,\
    \ b = b, a+b\n    end\n    return a\nend", '    return 1 if n < 2 else fib(n-1)
    + fib(n-2)', "  if n < 2\n    n = 1\n  else\n    last, cur, pre = 1, 1, 0\n  \
    \  while pre < n\n      cur, pre = cur + last, pre\n      last, cur = cur, cur\
    \ - last\n    end\n  end\n  cur\nend", "  return n if n < 3 else fib(n-1) + fib(n-2)\n\
    end", "  # check if n is prime\n  return (n<2)?1:fib(n-1) + fib(n-2)\nend", " \
    \ a, b = 0, 1\n  (n.times.map { |i| a, b = b, a + b }).last\nend\n</pre>", " \
    \ if n < 2\n    fib(1)\n  else\n    fib(n-1) + fib(n-2)\n  end\nend", "    if\
    \ n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)", "\tif n == 0\n\t\
    \treturn 0\n\tif n == 1\n\t\treturn 1\n\treturn fib(n-1) + fib(n-2)\nend", " \
    \   if n < 2:\n        return 1\n    return fib(n-1) + fib(n-2)", "  return n\
    \ > 0 and fib(n-1) + fib(n-2) or n\nend", "  if n == 0 then\n    return 0\n  else\n\
    \    local x = fib(n - 1)\n    local y = fib(n - 2)\n    return x + y\n  end\n\
    end\n</cell>\n<text>\nWe can use this function to implement the Fibonacci sequence\
    \ in a single line of code.", "  a, b = 0, 1\n  while n > 0\n    a, b = b, a+b\n\
    \    n -= 1\n  end\n  a\nend", "  a, b = 0, 1\n  while a < n\n    a, b = b, a\
    \ + b\n  end\n  a\nend", "  if n == 0 or n == 1 then\n    return n\n  else\n \
    \   return fib(n-1) + fib(n-2)\n  end\nend", "\ta, b = 0, 1\n\twhile n > 0\n\t\
    \ta, b = b, a+b\n\t\tn -= 1\n\tend\n\treturn a\nend\n\t", "  return n if n <=\
    \ 1 then 1 else fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.1>\n\
    function factorial(n)\n  return 1 if n <= 1 then 1 else n * factorial(n - 1)\n\
    end\n</cell>\n<code language=julia-1.1>\nfactorial(3)\n</cell>\n<text>\nRecursive\
    \ Functions\nA recursive function calls itself. When a recursive function calls\
    \ itself, the function stops and returns what it was given as its return value.",
  '    return n if n < 2 else fib(n-2) + fib(n-1)', "    return ((fib(n-1) + fib(n-2))/2)\n\
    end\nend\n</code>\n<|/ a tags=fibonacci,ruby dscore=3 |>\n<| c |>\nThis is also\
    \ very nice. Thank you very much. I see my mistake now. :-)\n<|/ c |>\n<| a |>\n\
    My recursive answer. \n<code>", "  return n if n <= 1 else fib(n-1) + fib(n-2)\n\
    end", "  return n if n < 2 else fib(n-1) + fib(n-2)\nend", "  if n < 0 or n >\
    \ 20\n    puts \"Fibonacci number doesn't exists.\"\n    return -1\n  else\n \
    \   return fib(n-1) + fib(n-2)\n  end\nend", "  return 1 if n < 2 else fib(n-1)\
    \ + fib(n-2)\nend", '    return memo[n] if n in memo else fib(n-1) + fib(n-2)',
  "    if n == 0: return 0\n    elif n == 1: return 1\n    else: return fib(n - 1)\
    \ + fib(n - 2)\nend", "  if n == 0 then return 0\n  elif n == 1 then return 1\n\
    \  else return fib(n-1) + fib(n-2)\nend", "  return 1 if n < 2 then 1 else fib(n-2)\
    \ + fib(n-1)\nend\n</cell>\n<text>\nSolution 2\nWe can solve this problem using\
    \ a slightly more computationally expensive algorithm, but it will still be reasonably\
    \ fast.  To solve this problem, we use a slightly more compact recurrence relation\
    \ than the one above.  It works by breaking the problem into three parts:", " \
    \ if n < 2\n    return n\n  else\n    return (fib(n-2) + fib(n-1))\nend\n</cell>\n\
    <cell>", "\ta, b = 0, 1\n\twhile n > 2\n\t\ta, b = b, a + b\n\t\tn -= 1\n\treturn\
    \ a\nend", "  a = b = 1\n  while n > 0\n    (a, b) = (b, a+b)\n    n -= 1\n  end\n\
    \  a\nend", "    if n == 0\n        0\n    elsif n == 1\n        1\n    elsif\
    \ n > 1\n        n = (n-1).fib + (n-2).fib\n    end\nend", "  return n < 2 ? n\
    \ : fib(n-1) + fib(n-2)\nend", "  if n <= 0 then\n    n = 0\n  end\n  if n ==\
    \ 1 or n == 2 then\n    return n\n  end\n  return fib(n-1) + fib(n-2)\nend", " \
    \ return n < 2 ? n : fib(n-1) + fib(n-2)\nend", "  if n==0 or n==1 then\n    return\
    \ n\n  else\n    return fib(n-1) + fib(n-2)\n  end\nend", "  return 0 if n < 2\
    \ else fib(n-1) + fib(n-2)\nend", "    if n == 0 then return 0\n    elif n ==\
    \ 1 then return 1\n    else return fib(n-2) + fib(n-1)\n    end\nend\n</cell>\n\
    <cell>", "\tif n == 0\n\t\t1\n\telsif n == 1\n\t\t1\n\telsif n > 1\n\t\tfib(n\
    \ - 1) + fib(n - 2)\n\tend\nend", "  return n < 2? n : fib(n-1) + fib(n-2)\nend",
  "    if n == 1 or n == 2:\n        return 1\n    return fib(n-1) + fib(n-2)", "\t\n\
    \tif n <= 1\n\t\treturn n\n\telse\n\t\treturn fib(n - 1) + fib(n - 2)\n\tend\n\
    \t\nend", "  return 0 if n == 0 or n == 1 else fib(n - 1) + fib(n - 2)\nend\n\
    </cell>\n<code language=julia-1.5>\n@time fib(1_000_000)\n</cell>\n<code language=julia-1.5>",
  "  # Return the nth Fibonacci number.\n  if n <= 0\n    puts \"Usage: fib(n)\" unless\
    \ @options.silent\n    return 0\n  else\n    return @fib[n] if @fib.has_key?(n)\n\
    \    a,b = 1,1\n    while a < n\n      a,b = b,a+b\n    end\n    @fib[n] = a\n\
    \  end\nend", "\tif n < 2\n\t\treturn n\n\telse \n\t\treturn fib(n-2) + fib(n-1)\n\
    end\n</cell>\n<code language=julia-1.0>\nfunction fib(n)\n\tif n < 2\n\t\treturn\
    \ n\n\telse \n\t\treturn fib(n-2) + fib(n-1)\n\tend\nend\n</cell>\n<text>\nFunctions\
    \ with multiple output", "  return n if n < 2 else fib(n-1) + fib(n-2)\nend",
  "  if n <= 1\n    return 1\n  else\n    return fib(n - 2) + fib(n - 1)\n  end\n\
    end", "  a, b = 0, 1\n  if n <= 1\n    a = 1\n  else\n    while n >= 1\n     \
    \ a, b = b, a+b\n      n -= 1\n    end\n  end\n  return a\nend", "\tif n < 2\n\
    \t\t return n\n\telse \n\t\treturn fib(n-2) + fib(n-1)\nend", "  # Write your\
    \ code here.\n  res = 0\n  i = 2\n  while i <= n:\n    res = res + i\n    i =\
    \ i + 1\n  return res\n  ", "    if n<0: return 0\n    if n==0 or n==1: return\
    \ n\n    return fib(n - 1) + fib(n - 2)\nend\n</cell>\n<code language=julia-1.5>\n\
    fib(10)\n</cell>\n<code language=julia-1.5>\nfib(20)\n</cell>\n<code language=julia-1.5>\n\
    function fibonacci(n)\n    a,b=-1,1\n    while n>1\n        (a,b)=(b,a+b)\n  \
    \      n=n-1\n    end\n    b\nend\n</cell>\n<code language=julia-1.5>\nfibonacci(10)\n\
    </cell>\n<text>\nA bit more concise with tail-recursion", "  if n == 0\n    0\n\
    \  elsif n == 1\n    1\n  else\n    fib(n - 1) + fib(n - 2)\n  end\nend", "  return\
    \ n if n < 2 else fib(n - 1) + fib(n - 2)\nend", "  if n < 1 then raise ArgumentError(\"\
    invalid input\") end\n  if n == 0 then return 0 end\n  if n == 1 then return 1\
    \ end\n  return fib(n-1) + fib(n-2)\nend", "  if n <= 1\n    next\n  else\n  \
    \  fib(n - 1) + fib(n - 2)\n  end\nend", "  a, b = 0, 1\n  if n > 0\n    while\
    \ n > 0\n      a, b = b, a+b\n      n -= 1\n  end\n  return a\nend", "    a, b\
    \ = 0, 1\n    while b < n:\n        a, b = b, a+b\n    return a", "  a, b = 0,\
    \ 1\n  while b < n\n    a, b = b, a + b\n  end\n  b\nend", "  if n < 2\n  then\
    \ n\n  else\n    fib(n-1) + fib(n-2)\n  end\nend", "  a, b = 0, 1\n  while n >=\
    \ 2\n    a, b = b, a+b\n    n -= 1\n  end\n  return a\nend", "  return n if n\
    \ < 3 else fib(n-2) + fib(n-1)\nend", "  return 0 if n < 2 else fib(n-1) + fib(n-2)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nIf you use this method for many Fibonacci numbers,\
    \ you might want to memoize the values so that you don't have O(n^2) running time.\n\
    <|/ c |>\n<| c |>\nYeah, I know. Just a trivial example. Surely, you might want\
    \ to add some more checks to the method so you can stop when n=0, 1 or 2.\n<|/\
    \ c |>\n<| a tags=recursion,ruby,fibonacci |>\n<code>", "  a = 1\n  b = 1\n  while\
    \ n > 0\n    puts a\n    a += b\n    b += 2\n    n -= 1\n  end\n  puts b\nend\n\
    fib(ARGV[0].to_i)", "  return n if n < 2 else fib(n-1) + fib(n-2)\nend", "  return\
    \ 1 if n == 0 else fib(n-1) + fib(n-2)\nend", "  return n if n < 2 else fib(n-1)\
    \ + fib(n-2)\nend", "  return (n<2) ? 1 : fib(n-1) + fib(n-2)\nend", "\tif n <\
    \ 2\n\t\t1\n\telsif n == 2\n\t\t1\n\telse\n\t\tfib(n - 1) + fib(n - 2)\n\tend\n\
    end", "  @_fibs ||= [0]\n  @_fibs.slice!(-n) if n >= 0\n  @_fibs[n]\nend\n_fib\
    \ = Fib", "  if n < 2\n  then 1\n  else fib(n-1) + fib(n-2)\n  end\nend", "  return\
    \ n if n < 2 else fib(n-1) + fib(n-2)\nend", "    a, b = 0, 1\n    while b < n:\n\
    \        a, b = b, a + b\n    return a", "    if n < 2:\n        return n\n  \
    \  return fib(n-1) + fib(n-2)\n</cell>\n<text>\nFibonacci Sequence with Memoization\n\
    The naive recursive implementation above uses exponential memory. Let's implement\
    \ a memoized version and compare it with the previous one:", "  return 1 if n\
    \ == 0 or n == 1 else fib(n-1) + fib(n-2)\nend", "  # Calculate and return the\
    \ n-th Fibonacci number.\n  if n == 0\n    0\n  elsif n == 1\n    1\n  else\n\
    \    fib(n - 1) + fib(n - 2)\n  end\nend", "  a, b = 0, 1\n  while a < n do\n\
    \    a, b = b, a + b\n  end\n  a\nend\n</cell>\n<text>\nFibonacci numbers\nThe\
    \ Fibonacci numbers are interesting for various things, such as finding out if\
    \ an input number is prime or not, or finding the n-th Fibonacci number. There\
    \ are many ways to compute Fibonacci numbers, and these will be covered in later\
    \ courses.", "  return n if n < 2 else fib(n-1) + fib(n-2)\nend\n</cell>\n<text>\n\
    More Recursive Functions\nWe now have two recursive functions. One fib and one\
    \ fib_tail. In the fib, the recursion stops when n < 2. This is because a Fibonacci\
    \ number is a number. Each number is a sum of two previous numbers, and the first\
    \ two numbers are 0 and 1.", "  if n < 2\n    return n\n  a,b = 0,1\n  while n\
    \ > 2\n    a,b = b,a+b\n    n = n - 1\n  end\n  a\nend", "    if n < 0: raise\
    \ ValueError('n must be >= 0')\n    if n == 0:\n        return 0\n    elif n ==\
    \ 1:\n        return 1\n    else:\n        return fib(n-2) + fib(n-1)\n</code>\n\
    As you can see, it has two if statements and no loops.\nThe recursion comes because\
    \ each function call will execute the inner function until it gets to the base\
    \ case and it will then return to the original caller and continue from there\
    \ with the next iteration. Here we have fib(0) that returns 0 and fib(1) that\
    \ returns 1 and fib(2) that returns 1.\n<|/ a |>\n<| c |>\nThis is more or less\
    \ what I was writing :)\n<|/ c |>\n<| c |>\nHaha, you're welcome :). Recursion\
    \ is always fun!\n<|/ c |>\n<| a |>\n<code>", "  return n < 2 ? n : fib(n-1) +\
    \ fib(n-2)\nend", "  return 1 if n < 2 else fib(n-1) + fib(n-2)\nend\n</cell>\n\
    <code language=julia-1.5>\nfunction fib2(n)\n  a = b = n\n  while b < a\n    b\
    \ = a\n    a = b + a + b\n  end\n  return a\nend\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib2(10)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib2(8)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib2(8)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib2(10)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib2(7)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib2(15)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib2(3)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib2(6)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib2(7)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib2(15)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib2(3)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib2(3)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib2(3)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib2(3)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib2(3)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib2(3)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib2(3)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib2(3)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib2(3)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib2(3)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib2(3)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib2(3)\n</cell>\n<code language=julia-1.5>\n@code_warntype fib2(3)\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype fib2(3)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype fib2(3)\n</cell>\n<code language=", "  a, b = 0, 1\n  while n >\
    \ 0\n    a, b = b, a + b\n    n -= 1\n  end\n  a\nend", "  @@fcache ||= {}\n \
    \ @@fcache[n] ||= if n <= 1 then n else fib(n-1) + fib(n-2) # McLaren E. 1990\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nThis one is slightly different,\
    \ it uses recursion to find the nth Fibonacci number, it also has an extra argument\
    \ which it uses to return an optional value when calling it (so that it can find\
    \ the nth Fibonacci number without getting a RecursionError that other solutions\
    \ might get when trying to find a nth Fibonacci number before you have the nth\
    \ Fibonacci number).\n<code>", "  if n < 1 then return end\n  if n == 0 then return\
    \ 0 end\n  return fib(n-1) + fib(n-2) end\nend", "  if n == 0 then\n    return\
    \ 0\n  elseif n == 1 then\n    return 1\n  else\n    return fib(n-1) + fib(n-2)\n\
    \  end\nend", "    if n < 2 then\n        return n\n    end\n    return fib(n-2)\
    \ + fib(n-1)\nend", "  return 1 if n < 2 else fib(n-1) + fib(n-2)\nend", "  if\
    \ n <= 1\n    n\n  else\n    fib(n-1) + fib(n-2)\n  end\nend", "  return n if\
    \ n < 2 else fib(n-1) + fib(n-2)\nend", "  return 0 if n == 0 || n == 1 then\n\
    \    fib(n-1) + fib(n-2)\n  else\n    n\n  end\nend", "    if n < 2\n       return\
    \ n\n    a, b = 0, 1\n    while a < n\n       a, b = b, a + b\n    return b\n\
    </code>\n<|/ a |>\n<| a |>\nThis is what I'm using.\n<code>", "  if n < 0\n  \
    \  return nil\n  if n == 0\n    return 0\n  if n == 1\n    return 1\n  a = fib(n-1)\n\
    \  b = fib(n-2)\n  c =  a + b\n  return c\nend", "  a, b = 0, 1\n  (n - 1).times\
    \ do\n    a, b = b, a + b\n  end\n  a\nend\n</cell>\n<code language=julia-1.0>\n\
    @time fib(100000)\n</cell>\n<code language=julia-1.0>\n@time fib(10000)\n</cell>\n\
    <code language=julia-1.0>\n@time fib(1000)\n</cell>\n<code language=julia-1.0>\n\
    @time fib(10)\n</cell>\n<code language=julia-1.0>\n@time fib(100)\n</cell>\n<code\
    \ language=julia-1.0>\n@time fib(1000)\n</cell>\n<code language=julia-1.0>\n@time\
    \ fib(10000)\n</cell>\n<code language=julia-1.0>\n@time fib(100000)\n</cell>\n\
    <code language=julia-1.0>\n@time fib(10000000)\n</cell>\n<code language=julia-1.0>\n\
    @time fib(1000000)\n</cell>\n<code language=julia-1.0>\n@time fib(10000000)\n\
    </cell>\n<code language=julia-1.0>\n@time fib(1000000000)\n</cell>\n<code language=julia-1.0>\n\
    @time fib(100000000)\n</cell>\n<code language=julia-1.0>\n@time fib(1000000000)\n\
    </cell>\n<code language=julia-1.0>\n@time fib(10000000000)\n</cell>\n<code language=julia-1.0>\n\
    @time fib(1000000000)\n</cell>\n<text>\nProblems with BigInt and Recursion\nBigInt\
    \ arithmetic is not associative, so the order of multiplication is different than\
    \ in arithmetic\nBigInt does not preserve associativity, so the order of addition/subtraction\
    \ is different than in arithmetic\nBigInt does not preserve associativity, so\
    \ the order of multiplication is different than in arithmetic\nBigInt does not\
    \ preserve associativity, so the order of multiplication is different than in\
    \ arithmetic\nBigInt does not preserve associativity, so the order of addition/subtraction\
    \ is different than in arithmetic\nBigInt does not preserve associativity, so\
    \ the order of multiplication is different than in arithmetic\nBigInt does not\
    \ preserve associativity, so the order of addition/subtraction is different than\
    \ in arithmetic\nBigInt does not preserve associativity, so the order of multiplication\
    \ is different than in arithmetic\nBigInt does not preserve associativity, so\
    \ the order of addition/subtraction is different than in arithmetic\nBigInt does\
    \ not preserve associativity, so the order of multiplication is different than\
    \ in arithmetic\nBigInt does not preserve associativity", "    if n < 2:\n   \
    \     return n\n    return fib(n-2) + fib(n-1)\nend", "  return n if n < 3 else\
    \ fib(n-2) + fib(n-1)\nend", "  a, b = 0, 1\n  while a < n\n    a, b = b, a+b\n\
    \  end\n  a\nend", "  @memoize ||= {}\n  @fibs ||= [0,1]\n  return @fibs[n - 2]\
    \ if n <= 2\n  @fibs[n - 2] + @fibs[n - 1]\nend", "    if n < 1:\n        n =\
    \ 1\n    elif n == 2:\n        return 1\n    else:\n        return fib(n - 1)\
    \ + fib(n - 2)", "  if n < 2\n    1\n  else\n    fib(n-2) + fib(n-1)\n  end\n\
    end", "  if n < 2 then\n    return n\n  else\n    return fib(n - 1) + fib(n -\
    \ 2)\n  end\nend", "  return 0 if n == 0 || n == 1 else fib(n - 1) + fib(n - 2)\n\
    end\n</cell>\n<text>\nPython supports function definitions in several different\
    \ ways.", "  # Write your code here.\n  if n < 0\n    raise \"Fibonacci numbers\
    \ should not be negative.\"\n  else\n    return fib(n-1) + fib(n-2)\nend", " \
    \ return n if n < 2 else fib(n - 1) + fib(n - 2)\nend", "  a, b = 0, 1\n  if n\
    \ > 0\n    while n > 0\n      a, b = b, a + b\n      n -= 1\n    end\n  end\n\
    \  return a\nend", "  if n < 2 then\n    n\n  else\n    fib(n-2) + fib(n-1)\n\
    \  end\nend\n</cell>\n<cell>", "  return n == 0 ? 0 : (n % 2 == 0 ? fib(n - 1)\
    \ + fib(n - 2) : fib(n - 1) + 2)\nend", "  if n <= 1\n    next\n  else\n    fib(n-1)\
    \ + fib(n-2)\n  end\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThe code can be\
    \ simplified to `def fib(n); return n<2?1:fib(n-1)+fib(n-2); end`\n<|/ c |>\n\
    <| c |>\nHow is this answer relevant to the question? It just provides a fibonacci\
    \ number. How would this be used to solve a more complex problem, such as finding\
    \ the sum of all even fibonacci numbers up to a certain number?\n<|/ c |>\n<|\
    \ c |>\nThe question was \"How to implement fibonacci numbers?\" And this is a\
    \ solution that does that. It can easily be used as a helper function to compute\
    \ a Fibonacci sum. ", "    return n if n < 2 else fib(n-1) + fib(n-2)\n</code>\n\
    Python has some very good libraries to do these kind of things.\n<|/ a |>\n<|\
    \ c |>\nThanks, that makes sense! I'm going to try and find a python tutorial\
    \ online or somewhere else and get back to you.\n<|/ c |>\n<| a |>\nHere's another\
    \ one. Recursion will work really well here.\n<code>", "  @@n ||= 0\n  @@n ||=\
    \ 1 if n <= 1 else fib(n-1) + fib(n-2)\nend", "  if n<2:\n    return 1\n  else:\n\
    \    return fib(n - 1) + fib(n - 2)\n</cell>\n<cell>", "  return 1 if n <= 1 else\
    \ fib(n-1) + fib(n-2)\nend", '    return n if n <= 1 else fib(n-1) + fib(n-2)',
  "  if n<2\n    1\n  else\n    fib(n-1) + fib(n-2)\n  end\nend", "  return n < 2?\
    \ n : fib(n-2) + fib(n-1)\nend\n</cell>\n<text>\nIn Python, most of the code is\
    \ similar to the code above, with some minor changes.", "  if n < 0\n    raise\
    \ \"fib() arg must be non-negative integer\"\n  a, b = 0, 1\n  while n != 0\n\
    \    a, b = b, a + b\n    n -= 1\n  return a\nend", "  if n < 2\n    return n\n\
    \  return fib(n-1) + fib(n-2)\nend", "  if n < 2 then\n    n\n  else\n    fib(n\
    \ - 1) + fib(n - 2)\n  end\nend\n</cell>\n<cell>", "  return 0 unless n < 2\n\
    \  return 1 if n == 0\n  return fib(n - 1) + fib(n - 2)\nend", "  return n if\
    \ n <= 1 else fib(n-1) + fib(n-2)\nend", "  # Write your code here.\n  return\
    \ 0 if n == 1 or n == 2 else fib(n - 1) + fib(n - 2)\nend", "  # Create an array\
    \ to store the results. Initialize with empty array.\n  results = []\n  # Check\
    \ if n is zero. Return 1 if n is zero.\n  if n != 0\n    # Calculate Fibonacci\
    \ series of n. Store it in results.\n    term = fib(n - 1) + fib(n - 2)\n    #\
    \ Store the result in the results array.\n    results << term\n  else\n    # Return\
    \ 0 if n is zero.\n    results.push(0)\n  end\n  # Return the results array.\n\
    \  results\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 tags=ruby |>\n<code>",
  "  a = 0\n  b = 1\n  while b < n\n    a,b = b,a+b\n  end\n  a\nend", "  return 1\
    \ if n <= 1 else fib(n-1) + fib(n-2)\nend", "  a, b = 0, 1\n  while a < n\n  a,\
    \ b = b, a+b\n  return a\nend", "  return n if n < 2 else fib(n-1) + fib(n-2)\n\
    end", "  if n < 2\n    fibn = n\n  else\n    fibn = (fib(n-1) + fib(n-2))\n  end\n\
    \  return fibn\nend", "  if n < 0 then\n    raise ArgumentError, 'fib: n must\
    \ be non-negative'\n  elseif n == 0 then\n    return 0\n  else\n    return fib(n-1)\
    \ + fib(n-2)\n  end\nend", "    if n < 0\n        return fib(-n)\n    if n ==\
    \ 0\n        return 0\n    if n == 1\n        return 1\n    return fib(n - 1)\
    \ + fib(n - 2)", "  a = 0\n  b = 1\n  while n != 0 do\n    puts a\n    a <- (a\
    \ + b)\n    b <- b + a\n    n <- n - 1\n  end\nend", "  return fib(n-2) + fib(n-1)\n\
    end", "  a = 0\n  b = 1\n  while n >= 0\n  a, b = b, a + b\n  n -= 1\n  end \n\
    \  a \nend", "  if n < 2 then\n    n\n  else\n    fib(n-1) + fib(n-2)\n  end\n\
    end", "    return fibHelper(n - 1, n) if n > 0 else 0\nend", "  a = b = nil\n\
    \  if n > 0\n    a, b = b, a+b\n    (1..n).each do |i|\n      a, b = b, a+b\n\
    \    end\n  end\n  a\nend", "  return n < 2 ? n : fib(n-2) + fib(n-1)\nend", " \
    \ # using dynamic programming\n  if n <= 1\n    n\n  else\n    fib(n-2) + fib(n-1)\n\
    \  end\nend", "  if n < 2\n    return n\n  else\n    return fib(n-1) + fib(n-2)\n\
    \  end\nend", "    return n if n <= 1 else fib(n-1) + fib(n-2)\nend", '  @assert
    n != nil && n != 0', "    if n < 0 then return nil end\n    if n == 0 then return\
    \ 0 end\n    if n == 1 then return 1 end\n    return fib(n - 1) + fib(n - 2)\n\
    end", "  if n == 0\n    return 0\n  else\n    return fib(n-1) + fib(n-2)\n  end\n\
    end", "    return n if n < 2 else fib(n-1) + fib(n-2)\nend", "    if n == 0 or\
    \ n == 1:\n        return n\n    return fib(n - 1) + fib(n - 2)", "  n < 2 ? n\
    \ : fib(n-1) + fib(n-2)\nend", "    a, b = 0, 1\n    while n > 0\n        a, b\
    \ = b, a+b\n        n -= 1\n    return b\nend", "    if n < 0\n        puts \"\
    n < 0\"\n        return n\n    puts n\n    if n == 0\n        return n\n    if\
    \ n == 1\n        return n\n    return fib(n-1) + fib(n-2)\nend\nfib(n) = fib(n).to_i\n\
    fib(n)\n</code>\n<|/ a dscore=3 tags=functional-programming,recursion,ruby |>\n\
    <| c |>\nThanks, your answer is pretty good. Your approach also looks more elegant\
    \ to me. By the way, is it possible to write Fibonacci without recursion?\n<|/\
    \ c |>\n<| c |>\nSure, you can do it iteratively by adding the first and second\
    \ numbers to a list and then returning the last one. `def fibonacci(n)\n numbers\
    \ = [0, 1]\n while numbers.size < n\n  numbers.unshift(numbers.last+numbers[-2])\n\
    \ end\n return numbers[numbers.size-n]\nend`\n<|/ c |>\n<| a tags=functional-programming,recursion,ruby\
    \ |>\nHere is a solution that doesn't use recursion (nor does it use memoization\
    \ to save repeated calls), but uses recursion:\n<code>", "  if n == 0 then\n \
    \   return 0\n  else if n == 1 then\n    return 1\n  else\n    return fib(n-1)\
    \ + fib(n-2)\n  end\nend", "  return 1 if n < 2 else fib(n-1) + fib(n-2)\nend",
  "  a,b = 0, 1\n  while n > 0 do\n    a,b = b,a+b\n    n--\n  end\n  a\nend", " \
    \ return ( n == 0 || n == 1 ? n : fib(n-1) + fib(n-2) )\nend", "  return n < 2\
    \ ? n : fib(n-2) + fib(n-1)\nend", "  if n < 1 then return end\n  if n == 1 then\n\
    \    return 1\n  else\n    return fib(n-2) + fib(n-1)\n  end\nend", "  return\
    \ n < 2 ? n : fib(n-2) + fib(n-1)\nend\n</code>\nThe first thing you need to understand\
    \ about the Fibonacci sequence is that it's defined recursively. The recursive\
    \ definition is (I put \"function\" before the name to avoid any confusion):\n\
    <code>\nfib(n) = fib(n - 1) + fib(n - 2)\n</code>\nThe Fibonacci sequence starts\
    \ with a 0 and an 1. Let's look at a simple example, starting with n = 1:\n<code>\n\
    fib(1) = 1\nfib(2) = 1\nfib(3) = fib(1)+fib(2)\nfib(4) = fib(1)+fib(2)+fib(3)\n\
    ...\n</code>\nSo, what is the value of fib(8) and how does that relate to the\
    \ Fibonacci sequence above?\n<code>\nfib(8) = fib(7) + fib(6)\nfib(7) = fib(1)+fib(2)+fib(3)+fib(4)\n\
    fib(6) = fib(1)+fib(2)+fib(3)+fib(4)+fib(5)\n...\n</code>\nAnd so on, until you\
    \ get to a base case where you get to the original value.\nLet's look at fib(7)\
    \ first:\n<code>\nfib(7) = fib(1)+fib(2)+fib(3)+fib(4)+fib(5)\nfib(6) = fib(1)+fib(2)+fib(3)+fib(4)+fib(5)+fib(6)\n\
    fib(5) = fib(1)+fib(2)+fib(3)+fib(4)+fib(5)+fib(1)\nfib(2) = fib(1)+fib(2)+fib(3)+fib(4)+fib(1)+fib(0)\n\
    fib(1) = fib(1)+fib(2)+fib(3)+fib(4)+fib(1)+fib(0)+fib(1)\nfib(0) = fib(1)+fib(2)+fib(3)+fib(4)+fib(1)+fib(0)+fib(1)+fib(0)\n\
    fib(3) = fib(1)+fib(2)+fib(1)+fib(0)+fib(1)+fib(0)+fib(1)\nfib(2) = fib(1)+fib(2)+fib(1)+fib(1)+fib(0)+fib(1)+fib(0)\n\
    fib(1) = fib(1)+fib(2)+fib(1)+fib(0)+fib(1)+fib(1)+fib(1)\nfib(0) = fib(1)+fib(2)+fib(1)+fib(1)+fib(1)+fib(1)+fib(1)\n\
    fib(5) = fib(1)+fib(2)+fib(1)+fib(1)+fib(1)+fib(0)+fib(1)\nfib(2) = fib(1)+fib(2)+fib(1)+fib(1)+fib",
  "  @memoize\n  @case [n]\n    when 0\n      0\n    when 1\n      1\n    when 2\n\
    \      1\n    else\n      fib(n-1) + fib(n-2)\n  end\nend", "  return n < 2 ?\
    \ n : fib(n-2) + fib(n-1)\nend\n</cell>\n<code language=julia-1.0>\n@time fib(35)\n\
    </cell>\n<text>\nProblem 8\nUsing @code_warntype, write a function to calculate\
    \ the nth Fibonacci number for n > 30 using memoization.", "    a, b = 0, 1\n\
    \    while n >= 2:\n        a, b = b, a+b\n        n -= 1\n    return a\n    ",
  "  return n if n <= 1 else fib(n-1) + fib(n-2)\nend", "  f = 1 if n == 0 || n ==\
    \ 1 then n else fib(n - 1) + fib(n - 2)\nend", "  a, b = 0, 1\n  while n > 0\n\
    \    a, b = b, a+b\n    n -= 1\n  end\n  a\nend", "    a, b = 0, 1\n    while\
    \ b < n\n        a, b = b, a + b\n    end\n    return a\nend", '    return n if
    n < 2 else fib(n-1) + fib(n-2)', "  if n < 2\n    return n\n  a = 1\n  b = 0\n\
    \  while n > 0\n    a, b = b, a+b\n    n -= 1\n  end\n  return a\nend\n</cell>\n\
    <cell>\nfib(100)\n</cell>\n<text>\nWe can also write a function that will return\
    \ a Fibonacci series in an array:", "  # Initialize result with 1.\n  result =\
    \ 1\n  # If n is less than 0, return 0.\n  n.times do\n    result = result + result\n\
    \  end\n  # Return result.\n  result\nend", "    return 1 if n < 2 else fib(n-1)\
    \ + fib(n-2)\n    \n</cell>\n<text>\nExercise: Find Fibonacci number for certain\
    \ integer n", "  a, b = 0, 1\n  while b < n\n    a, b = b, a + b\n  end\n  b\n\
    end", "  @memoize\n  def f(n=n)\n    if n <= 0\n      0\n    elsif n==1\n    \
    \  1\n    elsif n==2\n      2\n    else\n      fib(n-1) + fib(n-2)\n    end\n\
    \  end\n  f\nend", "  return n if n < 2 else fib(n-1) + fib(n-2)\nend", "  return\
    \ n if n < 2 else fib(n-1) + fib(n-2)\nend", "  if n<2\n    1 \n  else\n    fib(n-1)\
    \ + fib(n-2)\n  end\nend\n</cell>\n<cell>", "  a, b = 0, 1\n  if n > 0\n    a,\
    \ b = b, a+b\n    fib(n-1)\n  end\n  return a\nend\n</cell>\n<cell>", "  @n >=\
    \ 2\n  fib_array[n] = @(fib(n-1) + fib(n-2))\n  fib_array[n]\nend", "  return\
    \ n if n < 2 else fib(n-1) + fib(n-2)\nend\n</cell>\n<code language=julia-0.5>\n\
    @show fib(10)\n@show fib(11)\n@show fib(100)\n@show fib(1000)\n@show fib(10000)\n\
    @show fib(100000)\n@show fib(1000000)\n</cell>\n<code language=julia-0.5>", " \
    \ if n < 0\n    raise \"n must be >= 0\"\n  return n if n == 0 or n == 1 \n  return\
    \ fib(n-1) + fib(n-2)\nend", "  if n < 2 then return 1\n  else return fib(n-1)\
    \ + fib(n-2)\nend\nputs \"5th Fibonacci number is #{fib(5)}\"", "  return n if\
    \ n < 2 else fib(n-2) + fib(n-1)\nend\n</cell>\n<text>\nWhen we call fib, the\
    \ argument n tells it which Fibonacci number we are asking for. The recursive\
    \ definition calls fib on the two previous numbers, adding them together.", " \
    \ return n < 2 ? n : fib(n-1) + fib(n-2)\nend", "    if n == 1 or n == 2:\n  \
    \      return 1\n    return fib(n-1) + fib(n-2)\n</cell>\n<cell>", "  # Write\
    \ your code here.\n  return ((n << 1) + n) - n\nend\n</cell>\n<text>\nExercise\
    \ 2.11\nWhat is the n-th Fibonacci number for n = 1000000?"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
