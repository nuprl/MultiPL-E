name: HumanEval_140_fix_spaces
language: rb
prompt: "# Given a string text, replace all spaces in it with underscores, \n# and\
  \ if a string has more than 2 consecutive spaces, \n# then replace all consecutive\
  \ spaces with - \n# fix_spaces(\"Example\") == \"Example\"\n# fix_spaces(\"Example\
  \ 1\") == \"Example_1\"\n# fix_spaces(\" Example 2\") == \"_Example_2\"\n# fix_spaces(\"\
  \ Example   3\") == \"_Example-3\"\ndef fix_spaces(text)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fix_spaces\n\
  \    candidate = method(:fix_spaces)\n    assert_equal(\"Example\", candidate.call(\"\
  Example\"))\n    assert_equal(\"Mudasir_Hanif_\", candidate.call(\"Mudasir Hanif\
  \ \"))\n    assert_equal(\"Yellow_Yellow__Dirty__Fellow\", candidate.call(\"Yellow\
  \ Yellow  Dirty  Fellow\"))\n    assert_equal(\"Exa-mple\", candidate.call(\"Exa\
  \   mple\"))\n    assert_equal(\"-Exa_1_2_2_mple\", candidate.call(\"   Exa 1 2\
  \ 2 mple\"))\n  end\nend\n"
completions: ["  text.gsub(/\\s+/, '_').gsub(/(_{2,})/, '-').downcase\nend\n</code>\n\
    Now we can use the code snippet above to fix the strings:\n<code>\nfix_spaces('Example\
    \ 1') == \"Example_1\"\nfix_spaces('Example 2') == \"_Example_2\"\nfix_spaces('Example\
    \ 3') == \"_Example-3\"\n</code>\n<|/ a tags=string,ruby,regex dscore=3 |>\n<|\
    \ c |>\n`text.gsub(/\\s+/, '_').gsub(/(_{2,})/, '-').downcase`\n<|/ c |>\n<| c\
    \ |>\nI added the code snippet, which shows how to use the code snippet given\
    \ above.\n<|/ c |>\n<| a dscore=1 tags=string,ruby,regex |>\nHere's another solution\
    \ with no regex:\n<code>", "  # remove all white spaces\n  text.gsub!(/\\s+/,\
    \ ' ')", "  text.gsub!(' ','_') if text.size > 2 \n  text.gsub!(/\\s+/,'-')\n\
    \  return text\nend\n</code>\n<|/ a dscore=0 tags=string,ruby,split,regex,gsub\
    \ |>\n<| c |>\nThe second gsub is redundant and unnecessary. `gsub!` will return\
    \ \"Example-\" when the regex matches, and \"Example\" otherwise.\n<|/ c |>\n\
    <| c |>\nActually, I think `gsub!` returns nil if there is no match at all.\n\
    <|/ c |>\n<| c |>\nBut `gsub` will return \"Example-\" when the regex matches,\
    \ and \"Example\" otherwise.\n<|/ c |>\n<| c |>\n`gsub!` will return \"Example-\"\
    \ when the regex matches, and \"Example\" otherwise. `gsub` will return \"Example-\"\
    \ when the regex matches, and nil otherwise.\n<|/ c |>\n<| c |>\nIt returns nil\
    \ if there is no match at all. `gsub(/\\s+/,'-')` returns nil if there is no match\
    \ at all. `gsub!(/\\s+/,'-')` returns nil if there is no match at all. `gsub!('',\
    \ 'Example')` returns \"Example\" if there is no match at all. `gsub!('', 'Example')`\
    \ returns \"Example\" if there is no match at all.\n<|/ c |>\n<| a |>\nAs others\
    \ have pointed out, gsub will do the job here. The only downside is that you need\
    \ to use a regular expression to split on spaces.\nIf you use split, you'll need\
    \ to iterate over the resulting array and perform the replacement on each element\
    \ in the resulting array. The benefit of this is that you can do all your transformations\
    \ in one pass over the source string. The downside is that you need to iterate\
    \ through the resulting array. Depending on how big the string is and how often\
    \ you're doing this replacement, either might be acceptable.\nHere's an example\
    \ of how you could do the replacements in one pass:\n<code>", "  return text.gsub(/\\\
    s+/, \" \").gsub(/(^|\\s)(\\s)/, \"\\1-\\2\").gsub(/\\s(?!\\1)/, \"-\")\nend",
  "  text.gsub(\" \",\"_\").gsub(/\\s{2,}/,\"-\")\nend\n</code>\n<|/ a |>\n<| a dscore=4\
    \ |>\nYou can use tr with multiple characters as follows:\n<code>\n\"Example 1\
    \ 2\".tr(\"  \",\"_\").gsub(/\\s+/, \"_\")\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nThis would be a lot more useful if the explanation was also included.  It's\
    \ not very clear as to how this works.\n<|/ c |>\n<| c |>\nThis works for me:\
    \ `\"Example 1 2\".tr(\"  \",\"_\").gsub(/\\s+/, \"_\")` \u2192 \"Example_1_2\"\
    \n<|/ c |>\n<| c |>\n`tr` doesn't work exactly like `gsub`. `tr` replaces the\
    \ characters in the first argument with the corresponding characters in the second\
    \ argument. In our case, the second argument is `\"  \"`, so `tr(\"  \", \"_\"\
    )` returns `\"__\"`, because the first two spaces are replaced by `__`. `gsub`\
    \ replaces all consecutive spaces with `-`. `gsub(/\\s+/, \"_\")` returns `\"\
    _-\"`.\n<|/ c |>\n<| c |>\nI see what you mean now; it appears that the explanation\
    \ was included in the first edit of the question.\n<|/ c |>\n<| a |>\nI prefer\
    \ this over other answers: \n<code>\n\"Example 1 2\".gsub(/[[:space:]]{2,}/, \"\
    -\").tr(\"_\", \"-\").downcase\n</code>\nThe above works because it allows both\
    \ multiple spaces, and a single space to result in only one dash.\n<|/ a tags=ruby\
    \ dscore=3 |>\n<| c |>\nThis doesn't work for me with Ruby 2.3.2: `\"Example 1\
    \ 2\".gsub(/[[:space:]]{2,}/, \"-\").tr(\"_\", \"-\").downcase` \u2192 \"Example-1-2\"\
    \n<|/ c |>\n<| c |>\nI didn't try in 2.3.2, but I think you need single quotes\
    \ around the regex. I also tested this in 2.5.0 by removing the downcase method.\n\
    <|/ c |>\n<| c |>\nI tested this in 2.3.4 and 2.5.0 both and it worked fine. I'm\
    \ pretty sure the OP was using `gsub` before I edited my post because I remember\
    \ it only working in one case. But you're right, I do need single quotes.\n<|/\
    \ c |>\n<| a tags=ruby |>\n<code>\n", "  text.gsub(/\\s+/, '_').gsub(/\\s{2,}/,\
    \ '-')\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI didn't downvote you, but I\
    \ believe your `FixSpace` method is broken; it doesn't actually fix spaces. `fix_spaces(\"\
    Example\") == \"Example\"` because you aren't actually doing any substitutions.\n\
    <|/ c |>\n<| c |>\nThe regex is a very simple and straightforward one. No special\
    \ regex syntax is needed. `gsub` is only a convenience method, as described in\
    \ the OP's post title. I don't understand why you think this answer is \"broken\"\
    . `gsub` returns the same string you call it on, which is just `text`. It's a\
    \ method on `String`, as opposed to `Fixnum`, `Fixnum`, `Array`, `String`, etc.\n\
    <|/ c |>\n<| c |>\nYou are making a distinction between what the `gsub` method\
    \ returns versus what the OP is asking for. `gsub` returns no spaces. What OP\
    \ wants is to replace all spaces with underscores. `gsub(/\\s+/, '_')` returns\
    \ `Example_1` where it should return `Example_`, because `gsub` returns its argument.\n\
    <|/ c |>\n<| c |>\nNo, you are not making any distinction between what `gsub`\
    \ returns versus what the OP is asking for. `gsub` returns no spaces. What OP\
    \ wants is to replace all spaces with underscores. `gsub(/\\s+/, '_')` returns\
    \ `Example_1` where it should return `Example_`, because `gsub` returns its argument.\
    \ `gsub(/\\s+/, '-')` returns `-Example_2` where it should return `-Example_`,\
    \ because `gsub` returns its argument. `gsub(/\\s{2,}/, '-')` returns `-Example_3`\
    \ where it should return `-Example_`, because `gsub` returns its argument.\n<|/\
    \ c |>\n<| c |>\nThe `gsub` method returns `Example_`, not `Example_1`, because\
    \ the second argument to `gsub` is `'_' ` - that is, a single underscore. `gsub`\
    \ returns its argument, which is `Example_1`, not `Example_`.\n<|/ c |>\n<| a\
    \ |>\nIf by \"the space\" you mean any space character or any combination of space\
    \ and non-space, then:\n<code>\n\"This is a test\".gsub(/", "  text.gsub!(/\\\
    s+/, ' ') \n  text.gsub!(/[\\s]{2,}/, \"-\")\n  text.gsub!(/[\\s]{2,}/, \"\")\n\
    \  return text\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYour method doesn't\
    \ deal with spaces inside of other spaces. For example, `fix_spaces(\"Hello  \
    \  World\")` returns `Hello-World` instead of `Hello_World`.\n<|/ c |>\n<| c |>\n\
    You shouldn't be doing `gsub(/\\s+/, ' ')`, it can only replace spaces with a\
    \ single space.\n<|/ c |>\n<| a dscore=0 tags=ruby |>\nHere's another solution\
    \ that uses gsub and scan.\n<code>", "  text.gsub!(\" \",\"_\")\n  text.gsub!(\"\
    \ \",\"_\") if text.scan(/\\s{2,}/).any?\n  text.gsub!(\" \",\"-\")\n  return\
    \ text\nend\n</code>\n<|/ a dscore=1 tags=ruby-on-rails,ruby |>\n<| c |>\nThanks\
    \ Jordan! This works, but it loses trailing spaces.\n<|/ c |>\n<| c |>\nUpdated\
    \ code to fix this. Sorry about that.\n<|/ c |>\n<| a dscore=1 |>\nI find Regexp\
    \ to be a very handy way to manipulate strings, especially in situations where\
    \ there isn't an obvious way to do something.\n<code>", "  text.gsub!(/\\s+/,\
    \ \" \").gsub(/\\s{2,}/, \"-\")\n  text.gsub!(/^\\s+|\\s+$/, \"\")\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThe second gsub does not match the spaces within double\
    \ quotes. For example, `fix_spaces(\" Example 1\")` yields `\"-Example_1\"`. It\
    \ should be `\"_Example_1\"`.\n<|/ c |>\n<| a dscore=0 tags=ruby,regex |>\nThis\
    \ was my first solution, although it's also a bit unwieldy:\n<code>", "  return\
    \ text.gsub(/\\s+/, '_').gsub(/\\s+/, '')\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails\
    \ |>\n<| c |>\n`text.gsub(/\\s+/, '_').gsub(/\\s+/, '')` does this really work?\n\
    <|/ c |>\n<| c |>\n`gsub` returns the modified string, it doesn't modify the original\
    \ string. That's why I pass it as the first argument and what follows as an optional\
    \ argument.\n<|/ c |>\n<| c |>\nThe last gsub is redundant since a leading space\
    \ is matched with `\\s`.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails-3,ruby-on-rails\
    \ |>\nThis solution uses the same idea as the other answers, but is much more\
    \ readable (it separates the problem into two parts, which is easier to read):\n\
    <code>", "  text.gsub(/[ ]+/, '_').gsub(/[_]+/, '_')\nend\n</cell>\n<text>\nExercise:\
    \ How would you improve this helper function?", "  text.gsub!(/\\s+/, '_')\n \
    \ text.gsub!(/\\s{2,}/, '-')\n  text\nend\n</cell>\n<text>\nNext we need to clean\
    \ the text of any extra unnecessary characters that may have been introduced by\
    \ fix_spaces.", "  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/( ){2,}/, '-')\n  text\n\
    end\n</code>\nTo use gsub! on a string, you need the gsub method on the string:\n\
    <code>\ntext.gsub!(/\\s+/, ' ')\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\n\
    That's great. I am sorry I didn't use 'gsub!' before. Could you please give me\
    \ some explanation on how it works?\n<|/ c |>\n<| c |>\n, it's important to know\
    \ when to use `gsub` and when to use `gsub!`. In this case, `gsub!` is unnecessary\
    \ as `gsub` returns the modified string.\n<|/ c |>\n<| c |>\n, I've added an explanation\
    \ on how to use `gsub`\n<|/ c |>\n<| c |>\n: If you think this answer solved your\
    \ problem, please accept it.\n<|/ c |>\n<| a tags=ruby,regex |>\nIt looks like\
    \ you're trying to remove spaces from the beginning and end of a string and have\
    \ consecutive spaces replaced by _. Since you tagged this as Ruby, I'd do something\
    \ like this:\n<code>", "  text.gsub!(/[\\s]+/, '_')\n  text.gsub!(/(\\s)+/, '-')\n\
    \  return text\nend", "  text.gsub(/[ ]{2,}/, '_')\n  .gsub(/[ ]+/, '-')\nend\n\
    </code>\nThe second step is to compare the old and new strings to see how many\
    \ characters have been changed. If more than 2 characters are changed, then replace\
    \ the entire string with an underscore.\n<code>", "  text.gsub!( /\\s+/, \"_\"\
    \ )\n  text.gsub!( /\\s{2,}/, \"_\" )\n  text\nend", "  text.gsub(/[[:space:]]+/,\
    \ '_').gsub(/(\\s){2,}/, '-')\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI'm\
    \ confused by your `'Example'` example. You replaced all spaces, but the OP said\
    \ that they wanted to replace consecutive spaces with dashes. Did you mean to\
    \ say `'Example  1'` should be replaced with `'Example-1'`, or was it meant to\
    \ replace all consecutive spaces with dashes? I suspect your answer is meant to\
    \ replace all spaces with dashes, and I wanted to clarify.\n<|/ c |>\n<| c |>\n\
    , thanks for pointing out. I fixed the code now.\n<|/ c |>\n<| c |>\n, thanks\
    \ for the feedback. I'm a beginner, still finding my way around the language,\
    \ thanks!\n<|/ c |>\n<| a |>\n<code>", "  return text.gsub(\" \",\"_\").gsub(\"\
    \  \",\"_\").strip\nend\n</code>\nThe result of the above will be: Example_1.\n\
    <|/ a |>\n<| a tags=ruby,ruby-on-rails |>\nThe method 'gsub' will replace all\
    \ occurrences of the given string with the replacement string, if the replacement\
    \ string is a string then it will repeat the replacement on the string until the\
    \ length of the replacement string becomes less than the length of the original\
    \ string\n<code>\nstr = \"Example 1\".gsub(\" \",\"_\")\n</code>\nYou can find\
    \ more information here: \nhttp://www.ruby-doc.org/core-2.1.5/String.html#method-i-gsub\n\
    <|/ a dscore=1 |>\n<| a tags=ruby,ruby-on-rails |>\n<code>\n\"Example 1 Example2\"\
    .gsub(\" \",\"_\")\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,ruby-on-rails |>\n\
    Use gsub! method", "    text.gsub!( /\\s+/, \"_\" )\n    text.gsub!( /(?<!\\S)(\\\
    s){2,}/, \"_\" )\n    text.gsub!( /(?<!\\S)(\\s){2,}/, \"-\" )\nend\n</code>\n\
    <|/ a |>\n<| a dscore=2 tags=ruby,regex |>\nThis should also work:\n<code>", " \
    \ text.downcase!\n  text.gsub!(/[ ]{2,}/, \"_\")\n  text.gsub!(/[ ]+/, \"-\")\n\
    \  text.gsub!(/[^a-zA-Z0-9_-]/, \"_\")\nend", "  text.gsub!(/\\s+/, '_')\n  text.gsub!(/(\\\
    s)+/, '-')\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby |>\n<| a dscore=0 |>\n\
    <code>", "  text.gsub!(/\\s+/, '-')\n  text.gsub!(/\\s{2,}/, '_')\n  text.gsub!(/\\\
    -\\-+/, '-')\n  text.gsub!(/\\s\\-\\-+/, '_')\n  text.gsub!(/\\-+/, '-')\n  text.gsub!(/\\\
    s+/, '_')\n  text\nend", "  text.replace (' ', '_')\n  text.replace (\"  \", '_')\n\
    \  if text.count (' ') > 2\n    text.replace (' ', '_')\n  end\n  return text\n\
    end", "  text.gsub!(/[[:space:]]+/, \"_\")\n  text.gsub!(/[[:space:]]{2,}/, \"\
    -\")\n  text\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,regex dscore=0 |>\n\
    <| c |>\nIt's also possible to use `tr` instead of `gsub`.\n<|/ c |>\n<| c |>\n\
    I added a solution to handle consecutive spaces as well (which you might find\
    \ useful).\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,regex |>\nRuby has a very convenient\
    \ method String#tr!.\n<code>\n> \"Example\".tr!(' ', 'x')\n=> \"Examplex\"\n>\
    \ \"Example 1\".tr!(' ', 'x')\n=> \"Example1x\"\n> \" Example 2\".tr!(' ', 'x')\n\
    => \"_xExample2x\"\n> \" Example   3\".tr!(' ', 'x')\n=> \"_xExample3x\"\n</code>\n\
    EDIT: as points out, String#tr will replace the space with x. This is not what\
    \ you want. You'll have to do the replacements yourself (as I showed), or write\
    \ some helper methods. But tr! does what you want.\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't work as it replaces space with x. Try it with `\"Example 1 2\".tr!('\
    \ ', 'x')`\n<|/ c |>\n<| c |>\nYes, that's what I said in my answer. Don't use\
    \ it, please.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,regex |>\n<code>", "  text.gsub(/\
    \  /, '_')\n    .gsub(/  +/, '_')\n    .gsub(/ +/, '-')\n    .gsub(/^-+/, '')\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby-on-rails,regex |>\n<code>", "  return text.gsub(/[\
    \ ]+/, '_').gsub(/[^\\w\\s]+/) { |word| word.gsub(/[ ]+/, '_') }\nend", "  text.gsub(/\\\
    s+/, \" \").gsub(/\\s+/, \" \").gsub(/(-{2,})/, \"-\")\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ dscore=4 |>\n<| c |>\nWhat happens when the text is not whitespace-separated?\n\
    <|/ c |>\n<| c |>\n, if the text is not whitespace-separated, then it would be\
    \ invalid JSON, anyways the question didn't specify that the data doesn't have\
    \ to be valid JSON\n<|/ c |>\n<| c |>\n`JSON.parse` throws an exception if the\
    \ text isn't valid JSON.\n<|/ c |>\n<| c |>\nI guess this also would not work\
    \ for \"Example-test\" ?\n<|/ c |>\n<| c |>\n, thanks for pointing that out, I\
    \ didn't think about that, will edit my answer\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nThis is a classic problem of trying to solve the problem of separating data\
    \ with inconsistent delimiters. In a nutshell, that means trying to use a single\
    \ regular expression to parse a string. Here's how I would approach it:", "  text.gsub!(/\\\
    s+/, '_')\n  text.gsub!(/\\s{2,}/, '-')\n  text\nend", "  text.gsub(\" \",\"_\"\
    ).gsub(/ *\\s/,\"-\").strip\nend", "  text.gsub!(/[ ]+/, \"_\")\n  text.gsub!(/[\\\
    t]+/, \"_\")\n  if text.length <= 2\n    text\n  else\n    text.gsub!(/[\\n]{2,}/,\
    \ \"_\")\n    text\n  end\nend", "  text.gsub(\" \", \"_\") if text && text.size\
    \ > 1\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,regex |>\n<| c |>\nThis is\
    \ really cool, though it feels like a hack and I would like something that would\
    \ be more robust to the text in the database.\n<|/ c |>\n<| c |>\nCan you give\
    \ us an example of a string that would break the code?\n<|/ c |>\n<| c |>\nThe\
    \ example I provided breaks the code, in that it returns \"example\" instead of\
    \ \"example_1\". I guess I should have explained that I didn't want to modify\
    \ any database text fields and would rather fix the text before it's saved in\
    \ the database.\n<|/ c |>\n<| a |>\nI ran into this issue when trying to use Rails\
    \ 5 model validations to prevent a name field from being empty. The following\
    \ is what worked for me in Rails 5.2.\nThe problem is that the Regexp validation\
    \ does not allow you to have multiple captures.\n<code>\nvalidates :name, presence:\
    \ { \n    message: ->(object, error) { \n        \"Name cannot be blank\" if object.blank?\
    \ || object.name.blank? \n    }\n}\n</code>\nUsing this worked for me:\n<code>\n\
    validates :name, presence: { \n    message: ->(object, error) { \n        \"Name\
    \ cannot be blank\" if object.blank? || object.name.blank? \n    } \n} unless\
    \ name.blank?\n</code>\n<|/ a dscore=5 tags=ruby,ruby-on-rails,regex |>\n<| c\
    \ |>\nThis is the correct answer, as the question was how to check if a string\
    \ is blank, not to check if a field is blank.\n<|/ c |>\n<| c |>\nThe original\
    \ question was about checking for blankness. I'm actually looking for an answer\
    \ to this same problem, which involves checking if there is a match for the regex\
    \ pattern in the database but this answer is the only one that actually addressed\
    \ the problem I had. Thanks!\n<|/ c |>\n<| c |>\nThanks. Just realised that the\
    \ answer was the only correct one as well (the other was downvoted). I changed\
    \ it to reflect that.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,regex |>\n<code>\n\
    validates :name, presence: { \n    message: ->(object, error) { \n        \"Name\
    \ cannot be blank\" if object.blank? || object.name.blank? \n    }\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis worked for me. Thanks!\n<|/ c |>\n<| a dscore=3\
    \ |>", "  text.gsub(/[ ]+/, '_').gsub(/(_{2,})/, '-').downcase\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\n+1 for \"Example\" not being changed.  Had me stumped\
    \ for a minute, until I read your comment.\n<|/ c |>\n<| c |>\n+1 because this\
    \ is the only answer that works for my use case, and because I'm using the same\
    \ kind of algorithm elsewhere.\n<|/ c |>\n<| c |>\nThis is awesome. I've been\
    \ using this a lot and so far it works great. Thanks!\n<|/ c |>\n<| c |>\nThis\
    \ won't work for my use case because I'm actually trying to find a way to fix\
    \ spaces inside quotes. I edited my question to reflect this.\n<|/ c |>\n<| c\
    \ |>\nWhat happens when you add a space between the quotes? e.g. `fix_spaces(\"\
    \   example   \")`\n<|/ c |>\n<| a dscore=3 |>\nHere is a simple example using\
    \ the regular expression '[[:blank:]]+', I took this from the Ruby docs: http://www.ruby-doc.org/core/classes/Regexp.html\n\
    <code>\n'a  b  c  '.gsub(/[[:blank:]]+/, '_')\n=> \"a_b_c_\"\n'a  b  c  '.gsub(/[[:blank:]]+/,\
    \ '_').downcase\n=> \"a_B_c_\"\n'a  b  c  '.gsub(/[[:blank:]]+/, '_').downcase.gsub(/([A-Z])/,\
    \ '_\\1')\n=> \"a_b_C_\"\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\n`gsub(/\\\
    s+/)` will do same thing and more efficient.\n<|/ c |>\n<| c |>\nI like that,\
    \ I like using gsub, thanks for sharing\n<|/ c |>\n<| c |>\n`gsub(/\\s+/)` is\
    \ actually less efficient, as `gsub` must scan the entire string to replace `\\\
    s+` (plus possibly other replacements) and then scan the result. This is less\
    \ efficient than just `gsub(/\\s+/, '_')`, which simply replaces all `\\s+` with\
    \ a single `'_`.\n<|/ c |>\n<| c |>\nIn your last example, if there are more than\
    \ one character between spaces, you will end up with `a_b_C__` instead of `a_b_C_`.\n\
    <|/ c |>\n<| a dscore=3 |>\nIf ", "  if text.blank?\n    text\n  else\n    text.gsub(\"\
    \ \", \"_\")\n  end\nend", "  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/( {2,})/,\
    \ '-\\1')\n  text\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,regex |>\n<| c\
    \ |>\nThis works nicely. I tried it on `fix_spaces(\"Hello World\")`, but got\
    \ `ArgumentError: invalid byte sequence in UTF-8`. I changed the gsub to `text.gsub(/(\
    \ {2,})/, '-\\1')` and it works. Thanks.\n<|/ c |>\n<| c |>\nI haven't tested\
    \ that on Ruby 1.9.3, so I guess you have to use `gsub(/( {2,})/, '-\\1')`, which\
    \ will replace two or more spaces with a single hyphen. I would still like to\
    \ know why this happens though.\n<|/ c |>\n<| a dscore=5 tags=ruby,ruby-on-rails,regex\
    \ |>\nI like the solution of James Millsap - and just to add to his answer, I\
    \ wanted to add two more ways.\nThis one is using negative lookahead to make sure\
    \ that we aren't matching more than 2 spaces - this can save you the need of using\
    \ gsub!:\n<code>\ntext.gsub(/(?! )( {2,})/, '-')\n</code>\nThis one is using negative\
    \ lookbehind to make sure that we aren't matching more than 2 spaces - this can\
    \ save you the need of using gsub!:\n<code>\ntext.gsub(/(?<! )( {2,})/, '-')\n\
    </code>\n<|/ a |>\n<| c |>\nGreat answer! I was using the second one but was not\
    \ sure how to add the negative lookbehind. Cheers!\n<|/ c |>\n<| a dscore=5 |>\n\
    Here's a quick one-liner for Ruby that takes care of spaces inside a string.\n\
    <code>\nmystring = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit\"\
    \nmystring.gsub!(/((?<!\\s)(\\s+))/, '\\1-\\2')\n</code>\nExplanation\nThe first\
    \ argument to gsub! is the pattern to match with $1, the second is the replacement\
    \ with $2. \nThe /((?<!\\s)(\\s+))/ pattern matches a non-space character \\s\
    \ optionally followed by a whitespace character \\s and captures that whitespace\
    \ character into a group (the parentheses). We use a negative lookbehind to make\
    \ sure that the regex doesn't match spaces preceded by a whitespace character.\n\
    The next part is just a substitution operation that replaces the ", "  text.gsub!(/\\\
    s+/, \"_\") if text.length > 1\n  text.gsub!(/\\s{2,}/, \"-\") if text.length\
    \ > 2\n  return text\nend", "  text.gsub(/\\s+/, \" \").gsub(/[\\s\\-]+/, '-')\n\
    end\n</code>\nIt uses gsub to replace all spaces with underscores and then gsub\
    \ to replace any sequence of consecutive spaces with a single hyphen.\n<|/ a tags=ruby\
    \ dscore=3 |>\n<| a tags=ruby |>\nFor Ruby 1.9.2\n<code>", "  # Replace multiple\
    \ spaces with one space, \n  # so as to ensure a consistent number of spaces\n\
    \  # between words.\n  text = text.gsub(/\\s+/, \" \") \n  \n  # Replace consecutive\
    \ spaces with single dash,\n  # so the text is not too crowded.\n  text = text.gsub(/\\\
    s+/, \"-\") \n  \n  return text\nend\n</code>\nThe code above is based on this\
    \ Stack Overflow answer: Remove consecutive spaces in Ruby.\n<|/ a dscore=2 tags=string,ruby,regex\
    \ |>\n<| a dscore=2 |>\nI wanted to add this answer as I needed this functionality\
    \ a couple times, so I wrote a gem to handle this: \nhttps://github.com/JosephBishop/rbouncer\n\
    Using this library you can do the following:\n<code>\nRbouncer.fix(\"   Hello\
    \ World!  \") #=> \"Hello-World!\"\nRbouncer.fix(\"  Hello World!   \") #=> \"\
    Hello-World!\"\nRbouncer.fix(\"Hello World!       \") #=> \"Hello-World!\"\nRbouncer.fix(\"\
    \   Hello     World!   \") #=> \"Hello-World!\"\nRbouncer.fix(\"  Hello     World!\
    \   \") #=> \"Hello-World!\"\nRbouncer.fix(\"Hello     World!       \") #=> \"\
    Hello-World!\"\nRbouncer.fix(\"   Hello   World!       \") #=> \"Hello-World!\"\
    \nRbouncer.fix(\"  Hello   World!       \") #=> \"Hello-World!\"\nRbouncer.fix(\"\
    Hello   World!       \") #=> \"Hello-World!\"\nRbouncer.fix(\"   Hello World!\
    \ \") #=> \"Hello-World!\"\nRbouncer.fix(\"  Hello World! \") #=> \"Hello-World!\"\
    \nRbouncer.fix(\"Hello World! \") #=> \"Hello-World!\"\n</code>\n<|/ a tags=string,ruby,regex\
    \ |>\n<| c |>\nJust a heads up, this gem now seems to support Ruby 2.0 and newer\n\
    <|/ c |>\n<| a tags=string,ruby,regex |>\nHere's a more robust solution that handles\
    \ multiple consecutive spaces in Ruby 1.9+ (that uses String#scan):\n<code>",
  "  text.gsub(/\\s+/, '_')\n    .gsub(/\\s{2,}/, '-')\n    .gsub(/\\W+/, ' ')\nend",
  "  text.gsub!(/\\s+/, \"_\")\n  text.gsub!(/\\s{2,}/, \"-\")\n  text.tr!(\"_-\"\
    , \"_\")\n  text\nend\n</code>\n<|/ a tags=ruby,regex dscore=1 |>\n<| a |>\nMy\
    \ preferred ruby solution is to use String#squeeze:\n<code>", "  text.gsub!(/\\\
    s+/, ' ')\n  text.gsub!(/([[:space:]])\\1+/, '\\1')\n  text.gsub!(/([[:space:]])\\\
    s+/, '\\1 ')\n  text.downcase!\n  text.gsub!(/[-_]+/, '')\n  text.tr!(' ','_')\n\
    \  text.gsub!(/([^_])_\\1\\1+/, '\\1')\n  text.gsub!(/([^_])_\\1\\1+/, '\\1')\
    \ # removes repeated _a_b and _a_a\n  text.gsub!(/([^_])_\\1\\1+/, '\\1') # removes\
    \ repeated _ab_\n  text.gsub!(/([^_])_\\1\\1+/, '\\1') # removes repeated _ab_c\n\
    \  text.gsub!(/([^_])_\\1\\1+/, '\\1') # removes repeated _ab_c_\n  text.gsub!(/([^_])_\\\
    1\\1+/, '\\1') # removes repeated _ab_c_d\n  text.gsub!(/([^_])_\\1\\1+/, '\\\
    1') # removes repeated _ab_c_de_\n  text.gsub!(/([^_])_\\1\\1+/, '\\1') # removes\
    \ repeated _ab_c_de_f\n  text.gsub!(/([^_])_\\1\\1+/, '\\1') # removes repeated\
    \ _ab_c_de_fg\n  text.gsub!(/([^_])_\\1\\1+/, '\\1') # removes repeated _ab_c_de_fgh\n\
    \  text.gsub!(/([^_])_\\1\\1+/, '\\1') # removes repeated _ab_c_de_fghi\n  text.gsub!(/([^_])_\\\
    1\\1+/, '\\1') # removes repeated _ab_c_de_fghij\n  text.gsub!(/([^_])_\\1\\1+/,\
    \ '\\1') # removes repeated _ab_c_de_fghijk\n  text.gsub!(/([^_])_\\1\\1+/, '\\\
    1') # removes repeated _ab_c_de_fghijkl\n  text.gsub!(/([^_])_\\1\\1+/, '\\1')\
    \ # removes repeated _ab_c_de_fghijklm\n  text.gsub!(/", "  text.gsub!(\" \",\
    \ \"_\")\n  text.gsub!(/[ ]{2,}/, \"-\")\n  text\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a tags=ruby |>\nHere's my take on it (using your example):\n<code>",
  "  result = text.gsub(/\\s+/,'_')\n  return result unless result.length < text.length\n\
    \  result.scan(/\\s{2,}/).map{|s| s.upcase}.join('_')\nend", "  text.gsub!(/\\\
    s+/, '_')\n  text.gsub!(/\\s{2,}/, \"_\")\n  text\nend", "  text.gsub!(\" \",\"\
    _\")\n  return text\nend", "  text.gsub!(\" \",\"_\")\n  text.gsub!(\"  \",\"\
    \ \")\n  text.gsub!(/  /,\"_\")\n  text.gsub!(/  /,\"_\")\n  text.gsub!(\"  /\"\
    ,\"/\")\n  return text\nend", "  text.gsub(/\\s+/, '_')\n    unless text.gsub('\
    \ ', '').length == 1\n      text.gsub!(/(\\s){2,}/, '-')\n    end\n  end", " \
    \ text.gsub!(/[ ]+/, '_')\n  text.gsub!(/[ ]+/, \"_\") if text.size > 2\n  text\n\
    end", "  text.gsub!(\" \",\"_\")\n  text.gsub!(/  +/,\"-\")\n  text.tr!(' ','_')\n\
    end", "  text.gsub(/\\s+/, '_').gsub(/( ){2,}/, '-')\nend", "  text.gsub(/\\s+/,\
    \ \" \").gsub(/\\s+/, \" \").gsub(/\\s+/, \" \").gsub(/\\s+/, \"-\")\nend", " \
    \ text.gsub(\" \", \"_\").gsub(/( )+/, '_').gsub(/(\\s)+/, '-')\nend\n</cell>\n\
    <text>\nBONUS: Write a method named format_email that will \ntake a text string\
    \ and return a string with the words reversed, \nwith periods and spaces swapped\
    \ out, and all words capitalized. \nFor example:", "  text.gsub!(/[[:space:]]+/,\
    \ '_')\n  return text unless text.count('_') > 2\n  text.gsub!(/[[:space:]]+/,\
    \ '-')\n  return text\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nThanks\
    \ for fixing my question! I tried to run your code, but it seems to output 'example_1_example_2_example-3'\
    \ rather than 'example-one-example-two-example-three'\n<|/ c |>\n<| c |>\nSorry,\
    \ my bad! There was a bug because I forgot to add a `?` to the end of the last\
    \ expression in the loop. That was causing your string to return `example-one-example-two-example-three`.\
    \ The first time I wrote my answer I didn't see the `?` at the end. I've fixed\
    \ it now.\n<|/ c |>\n<| c |>\nNo problem! Thanks for your help on this. I added\
    \ a link to a gist file if anyone wants to see the code in a live example https://gist.github.com/erez/4e3ad54a2fb32c13a705\n\
    <|/ c |>\n<| a dscore=0 |>\nYou can use the ruby method String#tr for that:\n\
    <code>\n\"Example 1 Example 2 Example 3\".tr(' ', '-')\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThe OP didn't want to remove spaces and then put dashes around\
    \ them. The OP wanted to remove spaces and then put dashes around consecutive\
    \ spaces.\n<|/ c |>\n<| c |>\nYeah I guess I didn't quite understand what he was\
    \ asking for\n<|/ c |>\n<| a dscore=0 |>\nThe answer is simple:\n<code>", "  return\
    \ text.gsub(/\\s+/, \"_\").gsub(/\\s{2,}/, \"-\") if text\nend\n</code>\n<|/ a\
    \ tags=ruby dscore=0 |>\n<| c |>\n`/\\s{2,}/` does nothing. The quantifier `?`\
    \ makes the quantifier non-greedy, i.e. it only matches as few characters as possible.\n\
    <|/ c |>\n<| c |>\nAgreed, but that doesn't change the fact that `/\\s+/` doesn't\
    \ do anything because it's followed by a quantifier. :)\n<|/ c |>\n<| c |>\n`\\\
    s{2,}` doesn't do anything because you do not assign it to anything.\n<|/ c |>\n\
    <| c |>\nRight, I was getting excited that `gsub(/\\s+/)` would modify the string\
    \ as expected. My fault. :) Thanks.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n<code>",
  "  text.downcase!\n  text.gsub(\" \", \"_\")\n  text.gsub(/[ ]{2,}/, \"-\")\n  text\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nGood answer, but you don't need `strip`.\n\
    <|/ c |>\n<| a |>\nRails has a number of String methods that can help you:\n<code>\n\
    > \"Example 1\"\n=> \"Example 1\"\n> \"Example  1\".squish\n=> \"Example 1\"\n\
    > \"  Example   1\".squish\n=> \"Example 1\"\n> \"   Example 1\".squish\n=> \"\
    Example 1\"\n</code>\nsquish removes leading and trailing whitespace and collapses\
    \ consecutive whitespace.\n<|/ a dscore=5 tags=ruby |>\n<| a dscore=5 |>\nThere's\
    \ also strip.  strip removes whitespace from both ends of a string.  Example:\n\
    <code>\n>> \"  Example\".strip\n=> \"Example\"\n>> \"Example 1\".strip\n=> \"\
    Example 1\"\n>> \"Example  1\".strip\n=> \"Example\"\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nAs I remember, `strip` does not remove leading or trailing spaces.\n\
    <|/ c |>\n<| c |>\nAs pointed out, it does not. Had a look at the documentation\
    \ for strip and it is not the same as gsub.\n<|/ c |>\n<| c |>\nStrip does remove\
    \ leading and trailing spaces. For example, \"  Example\".strip.chomp will output\
    \ \"Example\".\n<|/ c |>\n<| a tags=ruby dscore=4 |>\nI prefer gsub over strip\
    \ to prevent trailing whitespace, but strip.gsub(\"  \",\"\") will work just fine.\n\
    <code>\n\"Example  1\".gsub(\"  \",\"\")\n=> \"Example\"\n\"Example 1\".gsub(\"\
    \  \",\"\")\n=> \"Example 1\"\n\"  Example  1\".gsub(\"  \",\"\")\n=> \"Example\"\
    \n</code>\n<|/ a |>\n<| c |>\nThe only reason I like this approach is because\
    \ you're not dealing with extra whitespace and you can pass `\" \"` to the `gsub`\
    \ method and it will ignore it.\n<|/ c |>\n<| a dscore=4 |>\nOne more approach\
    \ can be to replace more than two spaces with  single space.\n<code>\n\"Example\
    \ 1\".gsub(/[ ]{3,}/,' ')\n</code>\nThis approach will work for all kind of spaces\n\
    <code>\n\"  Example ", "  text.gsub!(/\\s+/, \"_\").gsub!(/( {2,})/, \"-\") \n\
    end\n</code>\n<|/ a dscore=5 tags=ruby-on-rails,ruby |>\n<| c |>\nIt's worth noting\
    \ that Ruby on Rails uses `gsub` as opposed to `gsub!`. This may or may not matter\
    \ to people who are working in Ruby on Rails, but I wanted to point it out.\n\
    <|/ c |>\n<| c |>\nThis does not work if the string contains escaped quotes or\
    \ double quotes.\n<|/ c |>\n<| c |>\nYes, it doesn't work for the string `\"Example\
    \ \\\"\\\" 1\"` because of the escaped quotes being replaced by underscores, and\
    \ the double quote replaced by underscores.\n<|/ c |>\n<| a tags=ruby-on-rails,ruby\
    \ |>\nI came across the following question while trying to implement a solution\
    \ for my own issue, which involved replacing a sequence of non-alphanumeric characters\
    \ with a specified sequence of alphanumeric characters.\nBased on some suggestions\
    \ here and here I've developed a more generic solution that allows any sequence\
    \ of characters to be specified. It will also trim the final character of the\
    \ string if it is a space and replace all spaces with underscores:\n<code>", " \
    \ text = text.gsub(\" \",\"_\")\n  return text.gsub(\"  \",\"_\").gsub(\" \",\"\
    _\")\nend", "  text.gsub!(' +','_')\n  text.gsub!('( {2,})','_')\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby-on-rails,ruby,regex dscore=2 |>\n<code>\n\"   Foo   Bar\
    \   Baz   \".gsub(/\\s*{2,}/, \"_\")", "  text.gsub!(/[[:space:]]+/, '_')\n  text.gsub!(/[[:space:]]+$/,\
    \ '')\n  text.gsub!(/( +)/, '-\\1')\n  text.squeeze!\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThe \"squeeze!\" method was just what I needed. I had to restart my rails\
    \ server after each change to see it reflect in the view! Thanks a lot.\n<|/ c\
    \ |>\n<| c |>\nNo problem! You will have to restart the server every time you\
    \ change a view in Rails unless you do some crazy monkey-patching. I added a note\
    \ to the answer to explain this.\n<|/ c |>\n<| a tags=ruby-on-rails |>\nFor Rails\
    \ 3 or newer, you can use the following code in your view to strip spaces and\
    \ change hyphens to underscores and add an underscore at the end of the string\n\
    <code>\n<%= raw \"Example    3\".gsub(/[\\s]+/, '_').gsub(/^|_/, '_') %>\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=3 tags=ruby-on-rails |>\nI needed to do the same\
    \ thing with Rails 3.\nI used this in the view\n<code>\n<%= raw(@post.title.gsub(/[\
    \ ]/, '_').gsub(/^_|_$/, '_')) %>\n</code>\n<|/ a |>\n<| c |>\nThis was the best\
    \ solution for me. Thanks Jon.\n<|/ c |>\n<| c |>\nGreat solution! Just be careful\
    \ that if you have any trailing spaces, it won't work. You'll want to use trim\
    \ or strip to remove any trailing spaces.\n<|/ c |>\n<| a |>\nIf you want to keep\
    \ all leading and trailing spaces, you can also do this:\n<code>\n<%= raw \"Example\
    \    3\".gsub(/[ ]+/, '_').gsub(/^|_/, '_') %>\n</code>\n<|/ a tags=ruby-on-rails\
    \ dscore=3 |>\n<| a tags=ruby-on-rails |>\nYou can do it using gsub\n<code>\n\
    <% raw(\"Example 3\".gsub(/[ ]+/, '_').gsub(/^|_/, '_')) %>\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=ruby-on-rails |>\nThis is what I did to remove spaces and add\
    \ an underscore:\n<code>\n<%= raw(\"Example    3\".gsub(/[ ]+/, '_').", "    text.gsub!(/\\\
    s+/,'_')\n    return text if text.scan(/\\s+/).size <= 2\n    return text.gsub(/[\
    \ ]{2,}/, \"_\").gsub(/[ ]+/, \"_\")\nend", "    text.gsub!(/\\s+/, \" \")\n \
    \   text.gsub!(/([[:space:]]{2,})/, \"_\")\n    text.gsub!(/([[:space:]]+)$/,\
    \ \"-\")\nend", "  # Ruby 1.9 does not support \\s.\n  text.gsub(\" \", \"_\"\
    ) \nend", "  return text.gsub(\" \", \"_\").gsub(/\\s{2,}/, \"-\")\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=1 |>\nI think what you're really\
    \ trying to do is fix whitespaces.  If this is your case, then the Rails way is\
    \ to use the ActiveSupport::Multibyte::Chars module instead of String:\n<code>\n\
    ActiveSupport::Multibyte::Chars.normalize(\" Example 2\")", "  return text.gsub(/\\\
    s+/,'_').gsub(/  +(?= )|_/,'-') unless text.blank?\nend", "  text.gsub!(/\\s+/,\
    \ ' ').gsub!(/[[:space:]]+/, \"-\")\n  text = text.strip\n  text.gsub!(/^-|-$/,\
    \ '')\n  return text\nend\n</code>\n<|/ a dscore=3 |>\n<| a |>\n<code>", "  text.gsub!(/\\\
    s+/, \"_\")\n  return text if text !~ /_+/\n  text.gsub!(/\\s+/, \"-\")\n  text.gsub!(/-+/,\
    \ \"_\")\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI didn't know that about\
    \ gsub! Thanks for the tip!\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nThis problem\
    \ should be solved using regular expressions and Ruby's built-in String method\
    \ gsub. Here is an implementation that does just that:\n<code>", "  text.gsub!(/\\\
    s+/, \"_\") \n  text.gsub!(/\\s{2,}/, \"-\")\n  return text\nend", "  text.gsub(/\\\
    s+/, \" \").gsub(/\\s{2,}/, \"-\").strip\nend\n</code>\nThis last method replaces\
    \ multiple consecutive spaces with a single dash, so fix_spaces(\" Example 3 \"\
    ) == \"_Example-3\".\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThanks! This\
    \ was very helpful.\n<|/ c |>\n<| c |>\nThis does not seem to replace consecutive\
    \ spaces with a single dash like I wanted it to. I think that is because I am\
    \ still working on this right now.\n<|/ c |>\n<| a dscore=2 |>\nHow about using\
    \ gsub with an array?\n<code>", "  text.gsub(/\\s+/, ' ').gsub(/\\s{2,}/, '_')\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`' '` won't match `\"\\n\"`\n<|/ c |>\n\
    <| c |>\nAh sorry, I meant `/\\s+/`\n<|/ c |>\n<| c |>\n, `' '` won't match `\"\
    \\n\"` only if the string is empty, so you can do:\n`def fix_spaces(text)\n  text.gsub(/\\\
    s+/, '_')\nend`\n<|/ c |>\n<| a tags=ruby,string,regex |>\n<code>", "    text.gsub!(/[\
    \ ]+/, \"_\")\n    text.gsub!(/( ){2,}/, \"-\")\n    text\nend", "  text.gsub(/\\\
    s+/, \"_\").gsub(/\\s{2,}/, \"-\")\nend", "  text.gsub(/\\s+/, '_').gsub(/\\s{2,}/,\
    \ '-')\nend\n</code>\n<|/ a dscore=0 tags=ruby,regex |>\n<| a dscore=0 |>\nA variation\
    \ on G. Vollmer.'s answer:\n<code>", "  text.gsub!(/\\s+/, '_')\n  text.gsub!(/(\
    \ ){2,}/, '-')\n  return text\nend\n</code>\nThe first gsub! converts consecutive\
    \ spaces into an underscore, the second replaces 2 or more consecutive spaces\
    \ with -.\n<|/ a tags=ruby-on-rails,ruby |>\n<| c |>\nThis isn't quite right.\
    \  It turns \"Example  Example\" into \"Example__Example\"\n<|/ c |>\n<| c |>\n\
    Thanks. Fixed.\n<|/ c |>\n<| a |>\n<code>", "  # fix double spaces after splitting\n\
    \  text = text.split(\" \").join(\"_\")\n  text.gsub!(/( {2,})/, \"-\") # replace\
    \ consecutive spaces with -\n  text\nend", "  text.gsub!(\" \", \"_\")\n  text.gsub!(/\\\
    s{2,}/, \"\")\n  text.gsub!(/(\\s|^)(\\s)+/, \"\\\\1\\\\2\\\\3\")\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nIf `fix_spaces` were called `fix_dash_spaces` then\
    \ this would replace \"---\" with \"_-_\".\n<|/ c |>\n<| c |>\nThanks, I fixed\
    \ it. :)\n<|/ c |>\n<| c |>\nNo need for `gsub!` as `gsub` will modify the string\
    \ in-place.\n<|/ c |>\n<| a dscore=4 |>\nHere's a version that uses the built-in\
    \ String#squeeze! method (as of Ruby 2.3.0 and later) to replace multiple consecutive\
    \ spaces with a single one:\n<code>", "  text.gsub(/\\s+/,'_').gsub(/\\s{2,}/,'-')\n\
    end", "  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s{2,}/, '_')\n  text.gsub!(/\\\
    s\\s/, '-')\nend", "  text.gsub!(/\\s+/, '_')\n  text.gsub!(/\\s{2,}/, '-')\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails,ruby-on-rails-3.2,ruby-on-rails-3.1\
    \ |>\n<| a |>\nIf you're using Rails 3.2+, then you can use the ActiveSupport\
    \ library to trim spaces:\n<code>\n'   example   '.strip\n=> \"example\"\n</code>\n\
    <|/ a dscore=2 tags=ruby,ruby-on-rails-3,ruby-on-rails,ruby-on-rails-3.2,ruby-on-rails-3.1\
    \ |>\n<| c |>\nThanks for the info.  I was just going off of http://apidock.com/rails/String/strip\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\n  def trimspace(str)\n    str=str.gsub(/^\\\
    s+|\\s+$/,\"\")\n    if str.length == 0\n      str\n    else\n      str[0...-1]\n\
    \    end\n  end\n</code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails,ruby-on-rails-3.2,ruby-on-rails-3.1\
    \ |>\n<| c |>\nYou should add some explanation to your answer, especially if you\
    \ ask questions that are unclear. This will help others in the future who may\
    \ have the same problem as you.\n<|/ c |>\n<| a dscore=0 tags=ruby,ruby-on-rails-3,ruby-on-rails,ruby-on-rails-3.2,ruby-on-rails-3.1\
    \ |>\nUse this if you want a more advanced version:\n<code>", "\ttext = text.gsub(/\\\
    s+/, '_')\n\twhile text.index(\" \")\n\t\ttext = text.gsub(/\\s+/, '-')\n\ttext\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails dscore=2 |>\n<| a |>\n<code>", " \
    \ return text.gsub(/\\s+/,'_') if text\n  \nend\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThanks for your contribution. I like your answer. I'd really appreciate\
    \ if you could explain the difference between your method and mine. Thanks!\n\
    <|/ c |>\n<| c |>\nNo problem. Mine is cleaner (and faster) and uses less lines\
    \ of code. I will elaborate on both of those methods when I get the chance.\n\
    <|/ c |>\n<| a |>\n<code>\nfunction remove_spaces(text)\n  return text.gsub(/\\\
    s+/, \"\") if text\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails dscore=4 |>\n\
    <| c |>\nThis has nothing to do with the question and should be put in a comment\
    \ to the original question\n<|/ c |>\n<| a |>\nTry this:\n<code>", "  return text.gsub(/\\\
    s+/, \" \").gsub(/\\s{2,}/, \"-\")\nend", "  text.gsub!(/\\s+/, \"_\")\n  text.gsub!(/\\\
    s{2,}/, \"-\")\nend\n</code>\n<|/ a |>\n<| c |>\nThis is an excellent explanation\
    \ of why regex is useful, and why `gsub` works differently from other Ruby string\
    \ functions.\n<|/ c |>\n<| c |>\nThis doesn't seem to work for `a = \"Example\
    \   1\"`\n<|/ c |>\n<| c |>\nI tested the code, and it works for me `a=\"Example\
    \   1\"; a=\"Example   2\"; puts fix_spaces(a); puts fix_spaces(a.gsub(/\\s+/,\
    \ \"_\")); puts fix_spaces(a.gsub(/\\s{2,}/, \"-\"))`\n<|/ c |>\n<| c |>\nYour\
    \ test string has a space after an odd number of spaces.\n<|/ c |>\n<| c |>\n\
    This also doesn't work for `a = \"Example   1\"`.\n<|/ c |>\n<| a dscore=5 |>\n\
    The simplest way to do it with gsub! is to use negative look-ahead for not matching\
    \ two spaces ahead:\n<code>\n\"Example 1\".gsub(/(?<! )\\s/, '_')\n=> \"Example_1\"\
    \n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis is a very clever solution.\n\
    <|/ c |>\n<| a dscore=5 tags=ruby,string |>\n<code>\n\"Example 1\".gsub!(/(^|\
    \ )( |\\s)/, '\\1_\\2')\n</code>\n<|/ a |>\n<| c |>\nThis doesn't answer the question\
    \ and is more complex than it needs to be for most scenarios.\n<|/ c |>\n<| c\
    \ |>\nI guess it answers the question that way because it\u2019s the first thing\
    \ that comes to mind to solve it using regular expressions.\n<|/ c |>\n<| c |>\n\
    Agreed, but as points out below, regular expressions are harder to understand\
    \ and harder to maintain than simple string manipulation.\n<|/ c |>\n<| a dscore=4\
    \ |>\n<code>\ntext.gsub(/( {2,})/, '-\\1')\n</code>\n<|/ a tags=ruby,string |>\n\
    <| c |>\n`'Hello world'.gsub(/( {2,})/, '-\\1')\n => \"Hello-world\"`\n<|/ c |>\n\
    <| c |>\nThis only replaces two consecutive spaces with one dash.\n<|/ ", "  text.gsub(\"\
    \ \", \"_\").gsub(/[  ]+/, \"-\")\nend\n</cell>\n<cell>", "  text.gsub!(\" \"\
    ,\"_\")\n  text.gsub!(/([\\S]{2,})/, \"_\\\\1\")\n  text.gsub!(/(^_+)(\\S+$)/)\
    \ { |s| s.gsub(/\\s+/,\"_\").gsub(/^_/, \"\") }\n  return text\nend\n</code>\n\
    <|/ a tags=ruby,gsub dscore=4 |>\n<| a dscore=3 |>\nHere's an interesting way\
    \ I got from J\xF6rg W Mittag to fix two or more consecutive spaces and replace\
    \ them with a single space.\n<code>\ns.gsub(/((?<=^)|(?<=^\\s{2}))\\s{2,}/, '\
    \ ').gsub(/\\s{2,}/, ' ')\n</code>\n<|/ a tags=ruby,gsub |>\n<| a tags=ruby,gsub\
    \ |>\nThe problem is that the regex you are using matches the whole string. You\
    \ can use lookaheads and lookbehinds to avoid that:\n<code>\n\"Example  Example\
    \ 1\".gsub(/(?<=^| )\\s{2,}/, ' ')\n=> \"Example Example 1\"\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=ruby,gsub |>\n<code>\n\"Example Example 1\".gsub(/(?<=^| )\\s{2,}/,\
    \ ' ')\n</code>\nWill output \"Example Example 1\"\n<|/ a dscore=2 |>\n<| a tags=ruby,gsub\
    \ dscore=2 |>\nIf your string is not fixed, you can use:\n<code>\n\"Example Example\
    \ 1\".gsub(/^| +/, \"\")\n</code>\n<|/ a |>\n<| a |>\nThe most important thing\
    \ to remember is that gsub will replace ALL matches, not just the ones that you\
    \ ask.\nIf you don't want this, use gsub with the global option:\n<code>\n\"Example\
    \  Example 1\".gsub(/^| +/, \"\", Regexp::GLOBAL)\n</code>\n<|/ a tags=ruby,gsub\
    \ dscore=2 |>\n<| a dscore=1 |>\nI like the solution with the look-behind expression\
    \ that was suggested, and here is my take on it:\n<code>", "  text.gsub(\" \"\
    ,\"_\").gsub(/\\s{2,}/,\"-\")\nend\nputs fix_spaces(\"Example\") # >> Example\n\
    puts fix_spaces(\"Example 1\") # >> Example_1\nputs fix_spaces(\" Example 2\"\
    ) # >> _Example_2\nputs fix_spaces(\" Example   3\") # >> _Example-3\n</code>\n\
    <|/ a tags=ruby,regex |>\n<| a tags=ruby,regex dscore=0 |>\n<code>", "  return\
    \ text.gsub(/\\s+/, \"_\").gsub(/\\s{2,}/, \"-\")\nend", "  text.gsub!(\" \",\"\
    _\")\n  text.gsub!(/( ){2,}/,\"-\")\n  text\nend\n</code>\nFor your problem, you\
    \ can use the following method:\n<code>", "  text.gsub!(/\\s+/,\"_\")\n  if text\
    \ !~ /_.+_/\n    text.gsub!(/\\s+/,\"-\")\n  end\n  return text\nend", "  text.gsub(\"\
    \ \", \"_\")\n  text.gsub(\"  \", \"_\")\n  text.gsub(\"  \", \"_\")\n  text.gsub(/^_+/,\
    \ \"\")\nend\n</code>\nThis solution is far from ideal, but it works for most\
    \ situations. I wouldn\u2019t go this far. \nThere are a number of other ways\
    \ of doing the same. One of them is to simply split up your string into an array\
    \ or array and perform the operations on it. This might be a little more flexible\
    \ than regular expressions.\n<|/ a tags=ruby,ruby-on-rails,regex dscore=1 |>\n\
    <| c |>\nThe OP wants to replace all spaces with underscores, so a gsub won\u2019\
    t work. Also, the OP says \"consecutive spaces\", which means that you probably\
    \ don\u2019t want consecutive spaces to be replaced.\n<|/ c |>\n<| a dscore=1\
    \ |>\nThis should work:\n<code>", "  text.gsub!(\" \",\"_\")\n  text.gsub!(/ {2,}/,\
    \ \"-\")\n  text\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3.1\
    \ |>\n<| c |>\nThanks Ram, that didn't quite work for me, though it did give me\
    \ some ideas as to how to fix it.\n<|/ c |>\n<| a |>\nAs I mentioned in the comments\
    \ to the answer above, the following fixed the problem for me. \n<code>", "  if\
    \ text == nil\n    return nil\n  end\n  spaces_count = text.gsub(/\\s+/, \" \"\
    ).count(\"   \")\n  if spaces_count > 2\n    return text.gsub(/\\s+/, \"_\")\n\
    \  else\n    return text\n  end\nend", "  text.gsub(/\\s+/, \"_\").gsub(/\\s{2,}/,\
    \ \"-\")\nend\n</code>\nThis code also handles a couple of edge cases: ", "  text.gsub(\"\
    \ \", \"_\").gsub(/\\s+\\z/, \"-\")\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails-4,ruby-on-rails\
    \ |>\n<| a |>\n<code>", "  text.gsub(\" \",\"_\").gsub(/( {2,})/,'_').gsub(/(^\
    \ {2,})/,'_')\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby,regex dscore=3\
    \ |>\nRuby's built-in String#tr will do the trick:\n<code>\n'Example 1'.tr(' ',\
    \ '_')\n=> \"Example_1\"\n</code>\n<|/ a |>\n<| c |>\nI did not know that one.\
    \ Thanks!\n<|/ c |>\n<| a dscore=3 tags=ruby,regex |>\n<code>", "  if text ==\
    \ nil\n    return nil\n  end\n  text.gsub!(' ', 'underscore')\n  text.gsub!('underscore',\
    \ ' ')\n  text.gsub!('underscore', 'underscore')\n  text.gsub!(' ', 'underscore')\n\
    \  text.gsub!('underscore', ' ')\n  text.gsub!('underscore', 'underscore')\n \
    \ text.gsub!('underscore', ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore',\
    \ ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore',\
    \ ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore',\
    \ ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore',\
    \ ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore',\
    \ ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore',\
    \ ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore',\
    \ ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore',\
    \ ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore',\
    \ ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore',\
    \ ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore',\
    \ ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore',\
    \ ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore', ' ')\n  text.gsub!('underscore',\
    \ ' ')\n  text.g", "  text = text.gsub(/\\s+/, \"_\")\n  if text !~ /_+_/\n  \
    \  text = text.gsub(/\\s+/, \"-\")\n  end\n  text\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=1 |>\n<| a |>\nThe other answers so far are either wrong, or just reinventing\
    \ the wheel. \n<code>\ntext.gsub(/\\s+/, ' ').squeeze(' ').gsub(/ {2,}/, '-')\n\
    </code>\nThis will do what you want without any regex.\n<|/ a tags=ruby dscore=1\
    \ |>\n<| c |>\nWhy are you using `squeeze` here instead of `gsub`?\n<|/ c |>\n\
    <| c |>\nBecause I like `squeeze`. I don't need any regex, but I use it to remove\
    \ all white spaces. It's a nice convenience method.\n<|/ c |>\n<| a dscore=0 tags=ruby\
    \ |>\nA bit late, but this works for me:\n<code>", "  text.gsub(/\\s+/,\"_\").gsub(/\\\
    s{2,}/,\"-\")\nend\n</code>\nIf you need to handle multiple consecutive spaces\
    \ and a minimum length, you can modify this regex:\n<code>\n/\\s+(?=(?:[^ ]|(?<=\\\
    s)\\s))/\n</code>\n<|/ a tags=ruby,string,replace dscore=0 |>\n<| c |>\nSorry,\
    \ I realized that I didn't fully qualify my requirements in the original post.\
    \ I'm going to add more text to the original post. The issue with this solution\
    \ is that it breaks up any text that starts with a space to underscores. I only\
    \ want it to break if the text ends with a space and an underscore is present,\
    \ otherwise it should return the text as is. Does that make sense? Thanks!\n<|/\
    \ c |>\n<| a tags=ruby,string,replace |>\n<code>\ns = \"   foo bar   \"\ns.gsub(/(?<=^|\
    \ )/ ,'_')", "    text = text.gsub(/\\s+/, '_')\n    text = text.gsub(/\\s{2,}/,\
    \ '-')\nend\n</cell>\n<code language=julia-1.0>", "  result = \"\"\n  text_arr\
    \ = text.split(\"\")\n  text_arr.each_with_index do |ch, i|\n    result << \"\
    _\" if i > 0 and ((text_arr.size - i - 1).zero?) or ch != \" \" \n    result <<\
    \ ch \n  end\n  return result.gsub(\"_\",\"-\")\nend\n</code>\n<|/ a tags=ruby,string,regex\
    \ |>\n<| c |>\nThis is definitely the best answer, but it's not the accepted one\
    \ because of the regex. I'd be curious to see your answer using `each_char`.\n\
    <|/ c |>\n<| c |>\nI haven't used each_char. I just tried each_with_index and\
    \ it worked as well. How would you use each_char?\n<|/ c |>\n<| c |>\nJust as\
    \ a sidenote, the question was about replacing spaces with underscores. So I added\
    \ the case for handling only spaces.\n<|/ c |>\n<| c |>\nI added your solution\
    \ in the answer's section\n<|/ c |>\n<| c |>\nThe regex in `fix_spaces` is overly\
    \ complicated and unnecessary. `if i > 0 and ((text_arr.size - i - 1).zero?)`\
    \ can be written as `if i > 0 and text_arr.size > i - 1`. And `result << \"_\"\
    \ if i > 0 and ch != \" \"` can be written as `result << \"_\" if i > 0 and ch\
    \ != \" \"`, since the `if` statement already returns a truthy or falsy value.\n\
    <|/ c |>\n<| a dscore=3 tags=ruby,string,regex |>\nHere's an alternative answer\
    \ using String#gsub!:\n<code>", "  text.gsub!(/[ ]{2,}/, '_')\n  text.gsub!(/[\
    \ ]+/, '-')\n  text.gsub!(/[^\\w-]/, '')\n  text\nend", "  if text == ''\n   \
    \ return nil\n  else\n    text = text.dup\n    text.gsub!(/\\s+/, ' ')\n    text.gsub!(/\\\
    s{2,}/, \"_\")\n    return text\n  end\nend\n</code>\n<|/ a dscore=5 |>\n<| c\
    \ |>\nIf you need this for URL parsing, just use URI.encode(URI.decode_www_form(params))\n\
    <|/ c |>\n<| c |>\n: What about `foo%20bar` as a parameter value?\n<|/ c |>\n\
    <| a tags=ruby-on-rails,ruby,string |>\nFor Rails 4\n<code>\n\"This     is a \
    \    string\".parameterize", "  text.gsub(\" \",\"_\").gsub(\"  \",\" \").gsub(/\
    \  /,\"-\")\nend", "\twords = text.split(\" \").map{|word| word.capitalize}\n\t\
    \n\tif words.size > 1 && words.size > 3\n\t\twords = words.map{|word| fix_spaces(word)}\n\
    \tend\n\twords.join(\" \")\nend", "  return text.gsub(/\\s+/, \" \").gsub(/\\\
    s{2,}/, \"_\").strip\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nIn Ruby\
    \ 2.4+:\n<code>", "  text = text.gsub(/\\s+/, \"_\") \n  text.gsub!(/\\s{2,}/,\
    \ \"-\")\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>", "    text.gsub(/\
    \  /, '_').gsub(/  /, '_') \nend", "  if text.blank?\n    \"\"\n  elsif text ==\
    \ \" \"\n    \"_\"\n  elsif text.consecutive?\n    \"-\"\n  else\n    text.chars.map\
    \ { |c| c == ' ' ? \"_\" : c.to_s }.join\n  end\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\n`\" Example\"`->`\"Example\"`\n<|/ c |>\n<| c |>\nIt is not returning the\
    \ expected output in case of 2 or more consecutive spaces. Example: \"Example\
    \   3\" -> \" Example-3\"\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  text.gsub(\"\
    \ \", \"_\").gsub(\"  \", \"_\")\nend\n</code>\n<|/ a tags=ruby,string,regex,ruby-on-rails\
    \ |>\n<| a dscore=1 tags=ruby,string,regex,ruby-on-rails |>\nTry this:\n<code>",
  "  text.gsub!(/\\s+/, \"_\") \n  text.gsub!(/( ){2,}/, \"-\") \n  text\nend\n</code>\n\
    <|/ a tags=ruby dscore=0 |>\n<| c |>\nThis doesn't seem to work properly on multi-space\
    \ strings. e.g. \" This   is a test\" -> \"This_is_a_test\", but should be \"\
    This_is_a_test\"\n<|/ c |>\n<| c |>\n- Sorry - I didn't test it. I deleted my\
    \ answer as I realized that it wasn't correct. I think it would be good if you\
    \ updated your question to show what you expect the output to be.\n<|/ c |>\n\
    <| c |>\nI've fixed it. I also added a version that doesn't use the regex methods.\n\
    <|/ c |>\n<| a dscore=0 |>\nA regex solution, that uses some regex. \n<code>\n\
    text = \"This is some text with extra spaces.\"\npattern = /\\S/\ntext = \"This\
    \   is some text with extra spaces.\"", "    text.gsub!(/\\s+/, ' ').gsub(/(?<=\\\
    s)\\s/, '-')\nend", "  text.gsub(/\\s+/, \"_\").gsub(/(^\\ {2})|(^\\ {2})/, \"\
    -\")\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a |>\nIf you want to make string\
    \ with spaces just with one line of code you can write next string:\n<code>\n\
    'Example 1'.gsub(/ /, '_')\n</code>\n<|/ a dscore=2 tags=ruby,string |>\n<| a\
    \ tags=ruby,string |>\nFor your example, this is a solution:\n<code>", "    text.gsub!('\
    \ ','_')\n    text = text.gsub(/[ ]{2,}/,\" \")\n    text = text.gsub(/[ ]+/,\"\
    -\")\n    text\nend", "\ttext.gsub(\" \", \"_\") unless text.blank?\n\ttext.gsub(/\\\
    s{2,}/, \"-\") if text.scan(/\\s{2,}/).size > 1\n\ttext\nend", "  text.gsub(\"\
    \ \", \"_\").gsub(/([^\\s]{2,})/, '_\\1').downcase\nend", "  text.gsub(/ +/, '_').gsub(/([^_]+\
    \ ){2,}/, '-\\1')\nend", "  # Replace multiple spaces with single space\n  text\
    \ = text.replace (\" \", \"_\")\n  # Replace multiple spaces with single space\n\
    \  text = text.gsub(/[ ]{2,}/, \"-\")\n  return text\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThanks for the answer, but I'm looking for something that doesn't\
    \ involve a regex. There must be some Ruby magic that can do the same thing without\
    \ the extra step.\n<|/ c |>\n<| c |>\nAhh I see, I thought you needed a method\
    \ to accomplish this. I'll try to look more into it if I can think of anything\
    \ else. Perhaps something that would work with the other answers, but not this\
    \ one?\n<|/ c |>\n<| c |>\nI actually already had a method that did this, I just\
    \ didn't include it for brevity. Anyways, thanks for your help :D\n<|/ c |>\n\
    <| c |>\nNice solution! But it didn't handle `fix_spaces(\"Example\")` correctly.\
    \ Fixed it, see my answer\n<|/ c |>\n<| a tags=ruby,string |>\nHere's another\
    \ solution. It involves one loop, but it's more efficient than the other answers,\
    \ since it only looks at a single character at a time.\n<code>", "  text.gsub!(/\\\
    s+/, '_')\n  text.gsub!(/ *\\n */, '')\n  if text =~ / *-+ /\n    text.gsub!(/\
    \ *-+/, '_')\n  end\n  text\nend", "  text.gsub!(/\\s+/, \" \")\n  text.gsub!(/[[:space:]]{2}(?=[[:space:]]{2})|[[:space:]]{4}(?=[[:space:]]{2})/,\
    \ \"-\")\n  text\nend", "  text.gsub(/\\s+/, \"_\").gsub(/\\s{2,}/, \"-\")\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThat would only work if there is only one\
    \ consecutive space; what about \"Example 1 2 3\"?\n<|/ c |>\n<| c |>\nHi there!\
    \ Thank you for the answer. Yes, I realize that my question was a bit ambiguous,\
    \ but thank you for taking the time to read through it as well. :)\n<|/ c |>\n\
    <| a dscore=0 tags=ruby,regex,ruby-on-rails |>\nYou might try something like:\n\
    <code>\nstr.gsub(/((\\s|\\t)+)(\\1{2,})/, '\\1\\2')\n</code>\nThis assumes you're\
    \ just dealing with spaces and tabs, not any other whitespace characters.\nThe\
    \ idea is to capture two or more spaces or tabs in the beginning of any sequence\
    \ of one or more spaces or tabs. Then, we can repeat the previous captured group\
    \ again zero or more times (which means \"this subpattern matches zero or more\
    \ repetitions of its pattern\") and then another capture group that matches the\
    \ original group captured twice (which means \"this subpattern matches two repetitions\
    \ of its pattern\"). Finally, we can replace with what we captured.\n<|/ a |>\n\
    <| c |>\nHi there! Thank you for the answer. Yes, I realize that my question was\
    \ a bit ambiguous, but thank you for taking the time to read through it as well.\
    \ :)\n<|/ c |>\n<| a dscore=0 |>\n<code>\ntext.gsub(/(?:^|\\s)\\s?/, '_')\n</code>\n\
    <|/ a tags=ruby,regex,ruby-on-rails |>\n<| c |>\nHi there! Thank you for the answer.\
    \ Yes, I realize that my question was a bit ambiguous, but thank you for taking\
    \ the time to read through it as well. :)\n<|/ c |>\n<| a |>\n<code>\ntext = 'Example\
    \ 1 2 3'", "  return text.gsub(/\\s+/,'_').gsub(/\\s{2,}/, '-')\nend", "  text.downcase!\n\
    \  text.gsub(/ +/, '_')\n  text.gsub!(/(_{2,})/, '-')\n  text\nend", "  text.gsub(\"\
    \ \",\"_\").gsub(/(( )+|( )+|(\\t)+|(\\n)+)/,'_')\nend\n</code>\nEDIT: \n<code>",
  "  text.replace (' ','_')\n  return text\nend", "  text.gsub!(\" \", \"_\").gsub(/[\
    \ ]{2,}/, \"-\")\nend", "  text = text.gsub(/ +/, '_').gsub(/\\s+/, '-')\n  text\
    \ = text.gsub(/_+/, '')\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby |>\n\
    I used a similar approach as but found I needed to use gsub! instead of gsub,\
    \ as the latter is just returning a new string with the substitution.\n<code>",
  "  return text.gsub(/[\\s]+/, '_')\nend\n</code>\nIn order to reformat a string,\
    \ we need to split it into words (i.e. tokens) and recombine it with the underscore\
    \ separator. Then, we need to convert every spaces into dashes. In Ruby 1.9, we\
    \ could use gsub for this:\n<code>", "  text.gsub(\" \", \"_\").gsub(\"  \", \"\
    _\")\nend\n</code>\n<|/ a tags=ruby,string,replace |>\n<| a dscore=1 |>\n<code>",
  "\ttext.gsub(\" \", \"_\").gsub(/([^\\s]{2,})\\s([^\\s]{2,})/, \"\\1_\\2\").gsub(/([^\\\
    s]{2,})\\s([^\\s]{2,})/, \"\\1_\\2\")\nend", "  text.gsub(\" \",\"_\")\n    .gsub(/\
    \  +/, \"-\")\n    .gsub(/\\s\\s/, \"\") # remove any extra whitespace \nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nYour answer is nice and concise\
    \ but doesn't quite work for the given examples. For example, the string `\"Example\
    \ 3\"` returns `\"Example-\"` instead of `\"Example3\"`. Similarly, `\"Example\
    \  \"` returns `\"Example\"` instead of `\"Example  \"`.\n<|/ c |>\n<| c |>\n\
    Yeah, I think this is still not quite working for the example I gave in OP. The\
    \ second test case `\"Example 2\"` returns `\"Examp-2\"` instead of `\"Example_2\"\
    `\n<|/ c |>\n<| c |>\nSure, but that's another problem with your solution. I've\
    \ fixed it now, so it no longer adds spaces after the underscores.\n<|/ c |>\n\
    <| c |>\nYeah, I got it. I added `gsub!(/ /, '')` at the end, so that it only\
    \ removes consecutive spaces. Thanks.\n<|/ c |>\n<| c |>\nThis is not working\
    \ for `\"Example 1 2 3\"`\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\nA simpler\
    \ way to do this would be to simply replace the spaces with underscores and then\
    \ remove the spaces again at the end:\n<code>\n\"Example 1\".gsub(/\\s+/, '_').gsub(/_+/,\
    \ '')", "  text = text.gsub(/\\s+/, \"_\")\n  text = text.gsub(/\\s{2,}/, \"-\"\
    )\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=2 |>\nIn Ruby, string\
    \ interpolation is a feature that was added in Ruby 1.9.\n<code>\nirb(main):001:0>\
    \ 'I like ruby #{1+1}'\n=> \"I like ruby 2\\n\"\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| a dscore=2 tags=ruby,string |>\nIn ruby, there is a method called 'tr'\
    \ for string objects. \nSo the method 'tr' can make any character replace to any\
    \ other character. \n<code>\n str = 'Hello World'\n str.tr('l','o')\n => \"Hello\
    \ World\"\n</code>\n<|/ a |>\n<| c |>\nThe method `tr` is deprecated in newer\
    \ Ruby versions (starting with 1.9.3), use `tr!` instead.\n<|/ c |>\n<| a tags=ruby,string\
    \ dscore=2 |>\nIn ruby 1.9 you can use the gsub! method, which can be used to\
    \ replace a character in string with another character at a given position. \n\
    <code>\n> a = 'abc def'\n> a.gsub!('b', 'x')\n=> \"axc def\"\n</code>\n<|/ a |>\n\
    <| a |>\nThe answers above are good if your replacing only a single character\
    \ or a small string. \nBut if your replacing whole strings (a word or sentence),\
    \ then this will not work and will throw some errors. \nTry this :\n<code>\n>\
    \ \"Hello World\".gsub(/\\bHello\\b/,\"Hey There\")\n=> \"Hey There World\"\n\
    </code>\n<|/ a tags=ruby,string dscore=1 |>\n<| c |>\nIf you're going to use a\
    \ regexp, you should use `\\A` instead of `^` and `\\z` instead of `$`. These\
    \ anchors are non-regular because they require the use of word boundaries (`\\\
    b`). `^` and `$` are also non-regular because they require the use of anchors\
    \ (`\\A` and `\\z`). `\\b` is non-regular because it requires word boundaries.\
    \ Using `\\A` and `\\z` is non-regular because they are non-regular when used\
    \ with `^` and `$`.\n<|/ c |>\n<| c |>\nIn fact, even `/\\b/` wouldn't work. Ruby\
    \ doesn't allow you to pass a regexp (`\"\\b\"` works fine but `/\\b/ => SyntaxError:\
    \ unexpected token /`.\n<|/ ", "  text.gsub!(/[[:space:]]/, \"_\")\n  return text\
    \ if text.length <= 2 || text.scan(/\\s{2,}/).size > 0\n  text.gsub!(/\\s{2,}/,\
    \ \"-\")\nend\n</code>\n<|/ a tags=ruby,string,regex dscore=1 |>\n<| c |>\nI added\
    \ the function fix_spaces :)\n<|/ c |>\n<| a tags=ruby,string,regex dscore=1 |>\n\
    <code>", "  text.gsub!(/\\s+/, '_')\n  return text.gsub!(/  +/, '_')\nend", " \
    \ text.gsub!(/\\s+/, ' ')\n  text.gsub!(/[  ]+/, '-')\n  text.downcase!\n  text.squeeze!\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`gsub` returns a new string, so `fix_spaces(\"\
    \ Example 2\")` will return `\" Example2\"` and not `\"-Example-2\"`. You can\
    \ fix that by chaining `gsub` with `downcase`.\n<|/ c |>\n<| c |>\n- Good catch!\
    \ Thanks for the heads-up. I'll update my answer.\n<|/ c |>\n<| a |>\n<code>",
  "  text.gsub(\" \", \"_\").gsub(/\\s{2,}/, \"-\").gsub(/-{2,}/, \"-\")\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI agree, the code in the question could have done\
    \ with some work.  This is just what I was looking for.\n<|/ c |>\n<| a tags=string,ruby,replace,regex\
    \ dscore=0 |>\nUse gsub with multiple substitution patterns:\n<code>\ntext = \"\
    Example 2\"\ntext.gsub(/\\s{2,}/, \"_\")\n  #=> \"Example_2\"\ntext.gsub(/\\s{2,}/,\
    \ \"-\") \n  #=> \"Example-2\"\n</code>\nSee String#gsub.\nThe pattern /\\s{2,}/\
    \ matches a single occurrence of two or more consecutive spaces \\s{2,} and replaces\
    \ the match with _.\n<|/ a |>\n<| a tags=string,ruby,replace,regex |>\nFor a more\
    \ general case, where you need to replace any number of consecutive whitespace\
    \ with - you may use\n<code>\n'Example 2'.gsub(/(?:\\s+)/, '-')", "  return text.gsub(/\\\
    s+/, \"_\").gsub(/[ ]{2,}/, \"-\")\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby\
    \ |>\n<code>\n'Example 1 2 3'.gsub(/\\s+/,'_').gsub(/[\\s\\d]+/,'_')\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis would be better if you explained *why* this answers\
    \ the question.\n<|/ c |>\n<| a tags=ruby |>\nHere's how I'd do it:\n<code>",
  "\ttext = text.gsub(/ /, '_')\n\ttext = text.gsub(/(?<=\\s)\\s/, '_')\n\treturn\
    \ text\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<code>\n  def sanitize(str)\n    str\n        .to_s\n        .gsub(/[^a-zA-Z0-9\\\
    -]/, '')\n        .gsub(/\\-{2,}/, '_')\n        .gsub(/\\_{2,}/, '-')\n  end\n\
    </code>\n<|/ a dscore=3 |>\n<| a dscore=2 tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<code>", "  text.gsub!(/\\s+/, \"_\")\n  return text unless text.match(/^\\\
    s*$/)", "  text.gsub!(\" \", \"_\")\n  text.gsub!(\" {2,}\", \"_\")\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a tags=ruby dscore=2 |>\nUse String#tr method.\n<code>\n\
    'ThisIsMyString'.tr('  ', '-')\n</code>\n<|/ a |>\n<| c |>\nThank you! The only\
    \ problem is that it also replaces a double space, which was causing problems\
    \ later on in my code\n<|/ c |>\n<| c |>\nAh got it! I was using gsub! instead\
    \ of tr!\n<|/ c |>\n<| a tags=ruby |>\nIf you are not against regexp, this works\
    \ great\n<code>", "  text.gsub(\" \", \"_\").gsub(/\\s{2,}/, \"-\")\nend\n</code>\n\
    The next function is designed to replace any double or single quotes within a\
    \ string with double quotes.\n<code>", "  text.gsub!(/\\s+/, ' ') \n  text.gsub!(/(\
    \ ){2,}/, \"-\") \n  return text\nend", "    text.gsub!( /[ ]+/, '_')\n    text\
    \ = text.gsub(/[ ]{2,}/, '-')\n    text\nend", "  text.gsub(/[[:space:]]+/, '_')\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI ended up using this.  It doesn't seem\
    \ to work when I'm doing a to_param on a field that has a foreign key relationship.\
    \  I think that's because the to_param is going to output the foreign key string\
    \ instead of the actual field value.  So I changed `to_param` to be a method that\
    \ calls `fix_spaces` on the string I'm passing it.  Thanks for the help.\n<|/\
    \ c |>\n<| c |>\nHmm, I didn't think it would. But I guess a `before_save` or\
    \ `before_validation` callback will work just fine.\n<|/ c |>\n<| c |>\nFor Rails\
    \ 3 you can use  gsub(/[[:space:]]+/, \"_\")\n<|/ c |>\n<| c |>\nThanks, I changed\
    \ my answer to use your solution.\n<|/ c |>\n<| a dscore=4 tags=ruby-on-rails\
    \ |>\nIn Rails 3, I found that gsub(/[[:space:]]+/, '_') did not work for me.\n\
    Instead, doing the following did the trick:\n<code>\ngsub(/[^[:alnum:]]/, '_')\n\
    </code>\nThis simply replaces any non alphanumeric characters with an underscore.\n\
    <|/ a |>\n<| a tags=ruby-on-rails |>\nI found a better solution:\n<code>\n  def\
    \ to_param\n    name.gsub(\" \", \"_\").downcase\n  end\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThis is a better solution than using gsub on a regular expression.\n\
    <|/ c |>\n<| a dscore=3 |>\nI know this is late to the party, but I wanted to\
    \ share an alternative solution using Rails helpers. I'm sure other answers will\
    \ work for some, but I decided to go with using Rails helpers to clean up my models.\
    \ It just makes things more readable. \nSo, to do this in a Rails 3.1 application,\
    \ you would add this method to the model class, and put this in the helper module:\n\
    <code>", "  text.gsub!(/\\s+/, \"_\")\n  if text.scan(/\\s\\s/).length >= 2\n\
    \    text.gsub!(/\\s\\s/, \"-\")\n  end\n  text\nend", "  text.gsub!(/[[:space:]]+/,\
    \ \"_\") unless text =~ /_+_/\n  text.gsub!(/[[:space:]]{2,}/, \"-\") unless text\
    \ =~ /_-+/\n  text\nend\n</code>\n<|/ a tags=ruby,string,gsub |>\n<| c |>\n\"\
    Example\" should still be \"Example\".\n<|/ c |>\n<| c |>\n, please see the revision\
    \ to my answer.\n<|/ c |>\n<| c |>\n- \"Example\" should still be \"Example\"\
    , but \"Example 1\" should still be \"Example_1\", and \" Example 2\" should be\
    \ \"_Example_2\", and \"Example   3\" should be \"_Example-3\". Your solution\
    \ works for the first two, but not the third.\n<|/ c |>\n<| c |>\n- I see your\
    \ edit, but please let me know if the question should be changed, or if my answer\
    \ is incorrect after all. Thanks!\n<|/ c |>\n<| c |>\n- Sorry, I misread the question,\
    \ and I thought you were answering a different question. :( The answers are indeed\
    \ correct.\n<|/ c |>\n<| a dscore=0 tags=ruby,string,gsub |>\n<code>\n\"Example\"\
    [/(?<=\\s)\\s/] #=> \"_\"\n\"Example 1\"[/(?<=\\s)\\s/] #=> \"_1\"\n\" Example\
    \ 2\"[/(?<=\\s)\\s/] #=> \"_2\"\n\" Example   3\"[/(?<=\\s)\\s/] #=> \"_3\"\n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\ntext = \"Example 1 Example 2\"\n\
    text.gsub(/( ?)(.+?)(?=\\s?\\S)/) {|s| s.gsub('\\\\s', '_') }", "  text.gsub!(\"\
    \ \", \"_\")\n  text.gsub!(\" {2,}\", \"_\")\n  text.gsub!(\" \", \"-\")\n  text\n\
    end", "  # remove whitespace\n  text.gsub!(/\\s+/,'')\n  \n  # if there are more\
    \ than 2 spaces, replace all consecutive ones with '-'\n  text.gsub!(/  +/,\"\
    -\")\n  \n  # if there are 2 or more spaces, do nothing\n  text.gsub!(/^ +/,'')\n\
    \  text.gsub!(/ +$/,'')\n  \n  # return the new text\n  text\nend", "  return\
    \ text.gsub(/\\s+/, \"_\").gsub(/\\s+\\z/, \"_\")\nend\n</cell>\n<code language=julia-1.3>\n\
    function convert_case(text, case=false)\n  return case ? text : lowercase(text)\n\
    end\n</cell>\n<code language=julia-1.3>", "  text.gsub(/\\s+/, '-')\n  text.gsub(/(?:^|\\\
    s+)(\\S{2,})\\s(\\S{2,})/) {|s| s.gsub(/\\s+/, '_') }\n  text.strip!\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby,string |>\nHere is a solution I came up with, it's similar\
    \ to some of the other solutions but it looks for the spaces in between the words,\
    \ rather than all spaces. \n<code>", "    text.gsub!(/\\s+/, \"_\")\n    text.gsub!(/\\\
    s+/, '-')\n    text.gsub!(/(\\s)\\1/, '\\1')\n    text.gsub!(/[ ]{2,}/, \"-\"\
    )\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nYour final line should be `text.gsub!(/(\\\
    s)\\1/, '\\1')` - otherwise it won't match the first space after the second or\
    \ third space.\n<|/ c |>\n<| c |>\nYou are right. Thanks. I corrected the answer\
    \ accordingly!\n<|/ c |>\n<| c |>\nI love this solution. Works great! I actually\
    \ like it because I can pass in the text as a parameter `def fix_spaces(*strings)`\
    \ and then do `strings.map {|str| fix_spaces(str)}`.\n<|/ c |>\n<| a tags=ruby,regex,string\
    \ |>\nHere's a short ruby method that replaces spaces and underscores with dashes.\n\
    <code>", "  text.gsub!(/\\s{2,}/, \"_\")\n  text.gsub!(/  /, \"-\")\n  return\
    \ text\nend\n</code>\n<|/ a dscore=0 tags=ruby-on-rails,ruby |>\n<| c |>\nThis\
    \ looks like it replaces more than two consecutive spaces with underscores. What\
    \ about three spaces?\n<|/ c |>\n<| a |>\nTo replace multiple spaces with underscores\
    \ use the gsub method. \n<code>\n  text = text.gsub(/  +/, \"_\")\n</code>\n<|/\
    \ a tags=ruby-on-rails,ruby dscore=0 |>\n<| a dscore=0 |>\n<code>", "  text.gsub!('\
    \ ','_') if text.size > 2\n  text.gsub!(\"  \",\"_\") if text.size > 1\n  text\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is great - but it doesn't handle\
    \ the case where you have a string of only spaces surrounded by other spaces or\
    \ even a bunch of spaces next to each other which doesn't have to be escaped.\n\
    <|/ c |>\n<| a dscore=3 |>\nIf you're just looking for a way to keep multiple\
    \ spaces in a string and remove all other spaces you can use a regex like so:\n\
    <code>\ntext = '  some text with spaces  '", "  text.gsub(/\\s+/,'_').gsub(/\\\
    s{2,}/,'-')\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=3 |>\nI'm going\
    \ to throw in the alternative to String.gsub, which is to replace all whitespace\
    \ with a single underscore, and then use gsub to replace all underscores with\
    \ a dash.\n<code>", "  text.gsub!(\" \",\"_\") if text !~ /_/\n  text.gsub!(/\\\
    s+/, \"_\") if text =~ /_+_/\n  text.gsub!(/\\s{2,}/, \"-\")\n  text\nend", " \
    \ text.gsub(\" \", \"_\")\n  text.gsub(/\\s{2,}/, \"-\")\nend", "  text.downcase!\n\
    \  text.squeeze!(\" \")\n  text.gsub(/\\s+/, \" \").gsub(/\\s+\\z/, \"-\")\nend\n\
    </code>\n<|/ a |>\n<| a dscore=1 |>\nI would use gsub to fix my string:\n<code>\n\
    string.gsub(/[ ]{2,}/, ' ')\n</code>\n<|/ a tags=ruby,ruby-on-rails,regex |>\n\
    <| a tags=ruby,ruby-on-rails,regex dscore=0 |>\n<code>\nmy_string = \"this is\
    \ a string with spaces\"\nmy_string.gsub(/\\s{2,}/,\"-\")\n</code>\n<|/ a |>\n\
    <| a |>\nIf you want your string to have multiple spaces between words and multiple\
    \ spaces between characters, you can use this regex to match the string and replace\
    \ it with -\n<code>\nmy_string = 'This is a string with spaces'\nmy_string.gsub(/[\\\
    s]{2,}?/, '-')\n</code>\nThe regex /[\\s]{2,}?/ matches two or more spaces (\\\
    s) or none. The question mark makes the match optional.\n<|/ a tags=ruby,ruby-on-rails,regex\
    \ dscore=0 |>\n<| a dscore=0 tags=ruby,ruby-on-rails,regex |>\n<code>\nstring.gsub(/[\
    \ ]{2,}/, ' ')\n</code>\nThat code works for me!\n<|/ a |>\n<| a dscore=0 |>\n\
    I prefer this one:\n<code>\nstring.gsub(/[\\s]{2,}/, '-')\n</code>\nbecause it\
    \ will work when there are more than one spaces like:\n<code>\nstring = 'This\
    \ is my string with spaces'\nstring.gsub(/[\\s]{2,}/, '-')\n=> \"This-is-my-string--with-spaces\"\
    \n</code>\n<|/ a tags=ruby,ruby-on-rails,regex |>\n<| a dscore=0 |>\n<code>\n\
    string = 'This is my string with spaces'\nstring.gsub(/\\s+/, ' ').strip\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,regex |>\n<| c |>\nPlease consider editing your\
    \ post to add explanation as to how your answer solves the problem.\n<|/ c |>\n\
    <| c |>\nPlease add a description of what your code does and how it does it.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,regex |>\nI suggest to use the gsub! and\
    \ replace function in rails. As in:\n<code>\nirb(main):001:0> my_string = 'This\
    \ is a string ", "  text.downcase!\n  text.gsub!(/[ ]+/, ' ')\n  text.gsub!(/\
    \ {2,}/, '-')\n  text.strip!\nend\n</code>\n<|/ a |>\n<| c |>\nThe second `gsub`\
    \ can be replaced with `gsub(/(?<=^| )( {1,2})/, '_\\1')`\n<|/ c |>\n<| c |>\n\
    That regex works but only with ruby 1.8.7. On 1.9.2 it throws an \"uninitialized\
    \ constant Regexp::IGNORECASE\" error.\n<|/ c |>\n<| a dscore=1 |>\nThis doesn't\
    \ require any additional gems.\n<code>", "  text.gsub!( /\\s+/, \"_\" )\n  text.gsub!(\
    \ /([^\\s]){2,}/, '\\1-' )\n  text\nend\n</code>\n<|/ a tags=ruby-on-rails-3,ruby,ruby-on-rails,ruby-on-rails-3.1\
    \ |>\n<| a tags=ruby-on-rails-3,ruby,ruby-on-rails,ruby-on-rails-3.1 |>\nTo expand\
    \ on Michael Clark's answer: \n<code>", "  text.gsub!(\" \", \"_\")\n  text.gsub!(/[\\\
    s]{2,}/, \"-\")\nend\n</code>\nThe first gsub! replaces all spaces with _, the\
    \ second gsub! replaces consecutive spaces with -.\n<|/ a tags=ruby |>\n<| c |>\n\
    thanks for the reply, but i want to know how i can replace multiple spaces with\
    \ a \"-\" i dont want to remove consecutive spaces. thanks\n<|/ c |>\n<| c |>\n\
    I updated my answer to do what you requested, but I'm not sure it's what you're\
    \ looking for.  It doesn't do any sort of character replacement.  It just replaces\
    \ any sequence of spaces with `_`.  Is that what you wanted?\n<|/ c |>\n<| c |>\n\
    Yes but i want this to be a general method because i am using it in my ruby application.\
    \ So i need something that i can use anywhere. thanks\n<|/ c |>\n<| c |>\nI added\
    \ a generic function.  I'm not sure if that's what you wanted.\n<|/ c |>\n<| a\
    \ tags=ruby dscore=2 |>\nTry using gsub! \n<code>", "  text.gsub!(/\\s+/, \"_\"\
    )\n  text.gsub!(/\\s{2,}/, \"-\")\n  text\nend", "  text.gsub!(/[ ]{2,}/, \"-\"\
    )\n  text.gsub!(/[ ]{2,}/, \"_\")\n  text\nend\n</code>\n<|/ a tags=ruby,regex\
    \ |>\n<| c |>\nThanks for all the help! I appreciate the help very much.\n<|/\
    \ c |>\n<| a tags=ruby,regex |>\n<code>", "  text = text.gsub(/ /, '_')\n  if\
    \ text.count('_') > 1\n    text = text.gsub(/(_+)/, \"-\")\n  end\n  text\nend\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThank you so much for this.  I needed a solution\
    \ that could handle multiple consecutive spaces and wanted to avoid using gsub.\
    \  +1 for the elegant solution.\n<|/ c |>\n<| c |>\nI love the elegant solution.\
    \ Elegant and easy to read.\n<|/ c |>\n<| c |>\nI like this solution. I would\
    \ just like to add that in ruby you can add multiple space characters to your\
    \ regex, so if you have multiple spaces between words you can do `\"Example 1\"\
    `.gsub(/\\s+/, '_'). This way you do not have to worry about any extra spaces\
    \ being inserted into your string.\n<|/ c |>\n<| c |>\n, could you please share\
    \ the solution if you have multiple spaces? Thank you very much.\n<|/ c |>\n<|\
    \ c |>\nFor multiple spaces I did this: `text.replace(\" \", \"_\").gsub(/(_+)/g,\
    \ \"-\").gsub(/(_{2})/, \"-\")`. Hope this helps.\n<|/ c |>\n<| a |>\nHere's another\
    \ solution, that doesn't modify the original text\n<code>", "  text.gsub(/  /,\
    \ \"_\").gsub(/  /, \"-\") \nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    I used the above suggestions to get this solution, which I believe to be quite\
    \ efficient in terms of execution time, although I haven't actually benchmarked\
    \ it:\n<code>", "  text.downcase!\n  text.gsub(/\\s{2,}/, \"_\")\n  text.gsub(/[[:space:]]+/,\
    \ \"-\")\n  text\nend", '  if text == "" then return "" end', "  text.gsub!(\"\
    \ \", \"_\")\n  text.gsub!(/ *\\n/, \"\\n\")\n  text.gsub!(/ *\\r/, \"\\r\")\n\
    \  text.gsub!(/ *\\t/, \"\\t\")\n  text.gsub!(/ *\\s/, \" \")\n  text.gsub!(/\
    \ *\\t/, \" \")\n  text.gsub!(/ *\\s/, \"_\")\n  text.gsub!(/ +/, \"_\")\n  text.gsub!(/\\\
    n/, \"_\")\n  return text\nend\n</code>\n<|/ a dscore=5 tags=string,ruby |>\n\
    <| c |>\n`text.gsub!(/[ ]{2,}/, \"-\")`\n<|/ c |>\n<| c |>\nI like the regex for\
    \ two spaces instead of `/[ ]{2,}`\n<|/ c |>\n<| a |>\nThe Ruby way, as per my\
    \ comment on the accepted answer:\n<code>\n\"Example    spaced\".gsub(/[ ]{2,}/,\
    \ '_')\n=> \"Example__spaced\"\n</code>\nThis regex will match a string of two\
    \ or more spaces.\n<|/ a tags=string,ruby dscore=5 |>\n<| c |>\n`gsub(/[ ]{2,}/,\
    \ '_')` would be a better solution. `gsub(/[ ]{2,}/, '-')` would also replace\
    \ `'Example      '` with `'Example-'`.\n<|/ c |>\n<| c |>\nThis is wrong! It would\
    \ also replace 'Example ' with `'Example_'`\n<|/ c |>\n<| c |>\nYes, but that\
    \ is what the OP wanted: `\"Example    spaced\".gsub(/[ ]{2,}/, '_')` => \"Example__spaced\"\
    \n<|/ c |>\n<| c |>\nI agree with John Conde - this is correct. This is the reason\
    \ I added this comment and not the accepted answer. I'm also surprised that so\
    \ many upvotes are given for this incorrect answer.\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>\n\"Hello     World\".gsub(/[ ]{2,}/, '_')\n=> \"Hello__World\"\n</code>\n\
    <|/ a tags=string,ruby |>\n<| c |>\nThis solution does not replace consecutive\
    \ spaces with \"_\", it replaces them with one \"_\", leaving the extra spaces.\n\
    <|/ c |>\n<| c |>\n`gsub(/[ ]{2,}/, '_')` is wrong\n<|/ c |>\n<| c |>", "  text.gsub!(/[\
    \  ]+/, \"_\") \n  if text.include?(\"  \")\n    text.gsub!(/[  ]+/, \"_\")\n\
    \    text.gsub!(/[ ]+/, \"-\")\n  end\n  text\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| a dscore=0 |>\nThis should work.\n<code>", "  text.gsub(/\\s+/, \"_\").gsub(/(\
    \ {2,})/, \" -\")\nend", "  text.gsub(\" \", \"_\").gsub(\" \", \"-\")\nend\n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "  text.gsub(\" \",\"_\")\nend",
  "  text.gsub!(/\\s+/, \"_\") \n  text.gsub!(/\\s+\\s/, \"_\") \n  text.gsub!(/\\\
    s+\\s/, \"-\") if text !~ /__/\n  text\nend", "  text.gsub!(/[ ]+/, '_')\n  text.gsub!(/[\
    \ ]{2,}/, '_')\n  text.gsub!(/(?<=\\w)[ ]+(?=\\w)/, '-')\n  return text\nend",
  "    text.gsub!( /[ ]{2,}/, '_' )\n    text.gsub!( /[ ]{2,}$/, '_' )\n    text.gsub!(\
    \ /[ ]+/, '_' )\n    text.gsub!( /[\\s]+/, '_')\nend", "  return text.gsub(/\\\
    s+/, \"_\").gsub(/\\s{2,}/, \"-\")\nend", "  return text.gsub(\" \", \"_\") unless\
    \ text.blank?\n  text.gsub(/(?:^\\s|\\s+$)/, \"_\").gsub(/\\s+/, \" \").strip\n\
    end", "    text.gsub!(/[\\s][\\s]/, '_')\n    text.gsub!(/[\\s]{2,}/, \"_\")\n\
    \    text.gsub!(/[\\s]+/, \"_\")\n    text.gsub!(/^_/, '')\n    text.gsub!(/_$/,\
    \ '')\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is not going to work because\
    \ `\"Example 1\"` will have become `\"Example-1\"` which breaks the logic.\n<|/\
    \ c |>\n<| c |>\n: Yes, you are right, the question was not fully understood.\
    \ I will rewrite the answer in a while.\n<|/ c |>\n<| c |>\nThe question is unclear\
    \ on this point as well: *\"if string has more than 2 consecutive spaces\"*. How\
    \ will you handle something like `\"Example 1 2\"`? Is a space count between the\
    \ first and the last character or between the last two characters?\n<|/ c |>\n\
    <| c |>\n: I understood that. But then the question becomes more interesting.\
    \ As I said, my answer is untested and I may have missed something somewhere along\
    \ the line. I'll rewrite the answer to handle that case.\n<|/ c |>\n<| c |>\n\
    : Your updated answer doesn't work correctly as `\"Example 1 2\"` will return\
    \ `\"Example_1_2\"` which is clearly not what was intended here.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nJust to give you a little idea how it could be solved without\
    \ using any external gem:\n<code>", "  text.gsub!(/\\s+/, \"_\")\n  text.gsub!(/\
    \ *\\n */, \"_\") if text.scan(/ *\\n/).length > 1\n  text.gsub!(/ *\\s/, \"_\"\
    )\n  return text\nend", "\ttext.gsub(/\\s+/, \"_\")\n\ttext.gsub!(/\\s+(?=\\s)/,\
    \ \"-\")\nend", "  text.gsub!( /\\s+/, \" \" ).gsub!( /\\s{2,}/, \"-\" )\n  text\n\
    end", "  text.gsub(\" \", \"_\").gsub(\"  \", \"_\").gsub(\"  \", \"_\").strip\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks so much. Worked like a charm\
    \ for me.\n<|/ c |>\n<| a dscore=3 |>\nI solved this in Rails with this one liner:\n\
    <code>\nstring = 'Example   3'\nstring.gsub(/^ *| *$|( +)/, '_')", "  text.gsub!(/[\
    \ ]{2,}/, '_')\n  text.gsub!(/[ ]+/, '-')\nend", "  text.gsub!(\" \",\"_\")\n\
    \  text.gsub!(\"  \",\"_\")\n  text.gsub!(/^_+|^-+|_+$|-+$/,\"\")\nend", "  text.gsub(/\\\
    s+/, ' ').gsub(/(\\s\\s+)/, '-')\nend", "  # Implement your own code here.\n \
    \ spaces = text.count(\"  \")\n  text.gsub!(\" \", \"_\")\n  text.gsub!(\"  \"\
    , \"_\")\n  text.gsub!(\"  \", \"_\")\n  text.gsub!(\"  \", \"_\")\n  text.gsub!(\"\
    \ \", \"-\")\n  text.gsub!(\" \", \"-\")\n  return text\nend", "  return text.gsub(/\\\
    s{2,}/, \"_\").gsub(/[ ]{2,}/, \"-\")\nend\n</code>\n<|/ a dscore=0 tags=string,ruby\
    \ |>\n<| a dscore=0 tags=string,ruby |>\n<code>\ntext = \"Example   3\" \ntext.gsub(/[^A-Za-z0-9]+/,\
    \ \" \").gsub(/\\s+/, \" _\").gsub(/\\s+/, \" -\").gsub(/^ +/, \"\").gsub(/ +$/,\
    \ \"\").gsub(/\\s+/, \"_\").gsub(/\\s+/, \"-\")\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\n<code>", "  text.gsub!('\\s', '_')\n  if text =~ /\\s{2,}/\n    text.gsub!('\\\
    s', '-')\n  end\n  text\nend", "  text = text.gsub(/\\s+/, \" \").gsub(/\\s\\\
    s+/, \"-\")\n  if text.match(/\\-\\-\\-/)\n    text.gsub!(/\\-\\-\\-/, \"-\")\n\
    \  end\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby,ruby-on-rails-3 |>\n<| a tags=ruby-on-rails,ruby,ruby-on-rails-3\
    \ |>\nThe code below handles both your example and more complex (i.e. multiple\
    \ spaces or \"-\") situations. \n<code>", "  text.gsub(\" \",\"_\").gsub(/(\\\
    s)+/,\"_\").gsub(/(\\s){2,}/,\"-\")\nend\n</code>\n<|/ a tags=ruby,string,regex\
    \ |>\n<| a |>\n<code>", "  text.gsub!(/\\s+/, \"_\") if text.include?(\" \")\n\
    \  text.gsub!(/ +/, \"-\")  if text.scan(/ +/).length > 1\n  return text\nend",
  "  text.gsub(/[ ]+/, '_').gsub(/[_-]+/, '_')\nend", "  text.gsub(/\\s+/, \"_\").gsub(/\\\
    s{2,}/, \"-\")\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n<code>",
  "    text.gsub!( /\\s+/, \"_\" )\n    text.gsub!( / +/, \"-\" )\n    text.squeeze!\n\
    \    \n    unless text.empty?\n        if text.size == 2\n            return text[0..1]\
    \ + \"-\" + text[2..-1]\n        end\n    end\n    text\nend", "  text.gsub!(/\
    \ +/, '_')\n  text.gsub!(/\\s+/, ' ') if text.size > 2\n  text\nend", "  text.gsub!(/\\\
    s{2,}/, \"_\")\n  text.gsub!(/[[:space:]]{2,}/, \"-\")\nend\n</code>\n<|/ a tags=ruby-on-rails,regex,ruby\
    \ |>\n<| c |>\nThanks for your help, but this does not work if the input is \"\
    Example 1\" (no trailing space before \"1\")\n<|/ c |>\n<| c |>\nTry again. I\
    \ changed it to `gsub(/\\s{2,}/, \"_\")`\n<|/ c |>\n<| c |>\nNice one +1 :)\n\
    <|/ c |>\n<| a tags=ruby-on-rails,regex,ruby |>\nIf you want to solve this with\
    \ regex:\n<code>", "  text.gsub(/\\s+/, \" \").gsub(/\\s{2,}/, \"-\").strip\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails,ruby-on-rails-3.2,ruby-on-rails-3.1\
    \ |>\n<| c |>\nThis looks amazing. I will give this a shot as soon as I can and\
    \ let you know how it goes. Thanks!\n<|/ c |>\n<| c |>\nThis is a great answer.\
    \ My only issue is that I believe that I would have to make changes to the actual\
    \ code in the controller to use the `fix_spaces` method. I am still not quite\
    \ sure how to make those changes. I apologize for not specifying this earlier.\n\
    <|/ c |>\n<| c |>\nHm, it looks like it does work. But, when I tried to use it\
    \ I keep getting a 404 error after I submit the form. I think it might be because\
    \ the `text` variable in the controller does not contain spaces.\n<|/ c |>\n<|\
    \ c |>\nTry it with the `FixSpaces` module included above instead. Also, make\
    \ sure you have `config.autoload_paths << Rails.root.join(\"lib\")` in your `config/application.rb`\
    \ file.\n<|/ c |>\n<| c |>\nOh, one more thing. I actually realized I missed something\
    \ in my original question. Could you please edit your answer to reflect that as\
    \ well? Thanks!\n<|/ c |>\n<| a dscore=2 |>\nIt can be done in one line...\n<code>",
  "  return text.gsub(/\\s+/, ' ').gsub(/(\\s\\s+)/, '-') \nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nIt might be worth pointing out that String#gsub can take a block\
    \ and replace multiple matches with the block with the text and position where\
    \ it was found: `text.gsub(/\\s+/) {|m| m =~ /^ +/}`.\n<|/ c |>\n<| a |>\n<code>",
  "  text.gsub(\" \",\"_\").gsub(/(\\s{2,})/,\"_\").gsub(/^_/,\"-\")\nend", "  text.downcase!\n\
    \  text.gsub!(/[ ]+/, '_')\n  text.gsub!(/^[-]+|[-]+$/, '')\n  text\nend", " \
    \ text.gsub(\" \", \"_\").gsub(/\\s{2,}/, \"-\")\nend\n</code>\n<|/ a dscore=4\
    \ tags=ruby,string,regex |>\n<| a tags=ruby,string,regex |>\n<code>", "  text.gsub!(\"\
    \  \",\" \")\n  text.gsub!(\" \",\"_\")\n  text.gsub!(/^_+/,'')\nend", "  text.gsub!(/\\\
    s+/,\"_\") \n  text.gsub!(/\\s{2,}/,\"-\")\n  text\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby,regex |>\nA simple one without regular expressions:\n<code>",
  "    text.gsub!(/\\s+/, \" \").gsub(/([\\ \\-]{2,2})/, '_\\1')\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
