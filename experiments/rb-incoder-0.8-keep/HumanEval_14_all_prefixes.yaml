name: HumanEval_14_all_prefixes
language: rb
prompt: "# Return list of all prefixes from shortest to longest of the input string\n\
  # >>> all_prefixes('abc')\n# ['a', 'ab', 'abc']\ndef all_prefixes(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_all_prefixes\n\
  \    candidate = method(:all_prefixes)\n    assert_equal([], candidate.call(\"\"\
  ))\n    assert_equal([\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"],\
  \ candidate.call(\"asdfgh\"))\n    assert_equal([\"W\", \"WW\", \"WWW\"], candidate.call(\"\
  WWW\"))\n  end\nend\n"
completions: ["  # create hash table for prefixes\n  prefixes = Hash.new{ |h,k| h[k]\
    \ = [] }\n  # add first character to hash table\n  prefixes.first(string.first)\n\
    \  # run through the string and add prefixes of each character to the hash table\n\
    \  string.chars.each do |char|\n    prefixes[char.first].push(char)\n  end\n \
    \ # return hash table\n  prefixes.values\nend", "  string.split(//).reduce([])\
    \ do |result, c|\n    result << c if c =~ /^./\n    result\n  end\nend", "  prefix_array\
    \ = string.split('')\n  prefix_array.reject!(&:empty?)\n  prefix_array.reverse!\n\
    \  prefix_array\nend", "  all_prefixes = []\n  prefix = nil\n  string.each_char.with_index\
    \ do |c, i|\n    if i == 0\n      prefix = c\n    else\n      all_prefixes <<\
    \ prefix\n      prefix = nil\n    end\n  end\n  all_prefixes << prefix if prefix\n\
    \  all_prefixes\nend", "    string.chars.map { |c| c.downcase }.reject { |c| c.empty?\
    \ }.map { |c| c.length }.min_by { |c| c } .reverse\nend", "  prefix_array = []\n\
    \  string.each_char do |character|\n    prefix_array << character\n    prefix_array\
    \ += all_prefixes(string) if prefix_array.last.length >= character.length\n  end\n\
    \  prefix_array\nend", "  prefix_array = []\n  prefix_array = string.split(//)\n\
    \  prefix_array.each do |prefix|\n    return prefix_array\n  end\nend\n</code>\n\
    <|/ a |>\n<| a dscore=2 tags=ruby-on-rails,ruby |>\nThis version uses only 1 method\
    \ and 1 loop\n<code>", "  return string.split('').reverse.map { |char| char.upcase\
    \ }\nend", "  prefixes = []\n  i = 0\n  while i < string.length\n    if i == 0\
    \ || !string[i..].include?(string.slice(i, i + 1))\n      break\n    end\n   \
    \ i += 1\n    prefixes << string.slice(i..)\n  end\n  prefixes\nend", "  return\
    \ string.split(string.to_s).map{|s| s[0]}\nend", "  prefixes = []\n  start = true\n\
    \  string.split(\"\").each do |char|\n    prefix << char unless start && prefixes.empty?\n\
    \    start && (prefixes << prefix)\n    prefix = \"\"\n    start = false\n  end\n\
    \  prefixes\nend", "  string.split(//).reduce( [] ) do |prefixes, character|\n\
    \    prefixes << character if character == string.chars.last\n    prefixes\n \
    \ end\nend", "  string.split('').reverse.map do |character|\n    prefixes = [character]\n\
    \    prefixes.push(*(all_prefixes(string.split(character).reverse).reverse))\n\
    \    prefixes.reverse\n  end\nend", "  result = []\n  length = 0\n  chars = string.split(//)\n\
    \  max_length = string.length\n  prefix = ''\n  while chars.any?\n    char = chars.shift\n\
    \    length+=1\n    if length > max_length\n      result.push(prefix)\n      prefix\
    \ = ''\n      length = 0\n    end\n    prefix += char\n  end\n  result.push(prefix)\n\
    \  result\nend", "  string.downcase.scan(/(.)/).to_a\nend", "  string.split(//).select{|prefix|\
    \ prefix == string}\nend", "  result = []\n  loop do\n    result << string\n \
    \   break unless string.length > 1\n    string = string[0, string.length - 1]\n\
    \  end\n  result\nend", "  prefix = []\n  loop do\n    break if string.length\
    \ > prefix.size\n    prefix << string[0..-prefix.size]\n  end\n  prefix\nend",
  "  result = []\n  i = 0\n  while i < string.length\n    if i == string.length\n\
    \      result << string\n      i += 1\n    else if i == string.length - 1 ||\n\
    \           string.substring(i + 1, i + 1).length < string.length\n      result\
    \ << string.substring(0, i + 1)\n      i += 1\n    else\n      result << string.substring(0,\
    \ i)\n      i += 1\n    end\n  end\n  result\nend", "  string.split(//).map.with_index\
    \ do |prefix, i|\n    i >= string.count(\"/\") ? prefix : prefix + \"/\" + string[0..i]\n\
    \  end\nend", "  prefixes = []\n  for i in 0..(string.length-1)\n    prefixes\
    \ << string[0..i] if string.length > i && string[0..i] == string[i]\n    prefixes\n\
    end", "  result = []\n  i = 0\n  while i < string.length\n    result = result\
    \ + string.split(string[i], 3)\n    i += 1\n  end\n  result\nend", "\tstring.scan(/[^a-z]/).map{|c|\
    \ c}\nend\nall_prefixes('abc')", "  result = []\n  prefixes = [string]\n  while\
    \ string.sub!('') do\n    string = string.sub('') \n    prefixes << string\n \
    \ end\n  prefixes.reverse!\n  result[0] = prefixes.first\n  while result[0] !=\
    \ '' do\n    string = prefixes.find { |prefix| string =~ prefix }\n    if string\
    \ != '' then\n      result[1] << string\n      prefixes.delete_at prefixes.index(string)\n\
    \    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| a dscore=2\
    \ |>\nHere's an implementation using Ruby Regexps:\n<code>", "  string.split('').select{|char|\
    \ string.start_with?(char) }\nend", "  prefixes = []\n  index = string.size-1\n\
    \  while index >= 0\n    prefixes << string[0...index]\n    index = index-1\n\
    \  end\n  prefixes\nend", "  string = string.dup.force_encoding(string.encoding)\n\
    \  return string.length.times.map { |i| string.slice!(0, i) }\nend", "  prefixes\
    \ = string.split('')\n  prefixes.reverse\n  prefixes\nend", "  result = []\n \
    \ prev_char = nil\n  string.each_char do |char|\n    result.unshift char if char\
    \ == prev_char\n    prev_char = char\n  end\n  result\nend", "\tprefix, suffix\
    \ = (\"\", string)\n\twhile suffix.start_with?(prefix)\n\t\tprefix, suffix = suffix[0,\
    \ prefix.length], suffix[1..-1]\n\tend\n\t[prefix] + all_prefixes(suffix)\nend",
  "  prefixes = []\n  i = 1\n  while i < string.length\n    prefixes << string[0..i-1]\n\
    \    i += 1\n  end\n  prefixes\nend", '  prefixes = string.split', "  return string.chars.to_a.reduce(:+).to_a\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nNice, but you should use `String#chars`\
    \ rather than `String#split` so you don't have to care about whitespace and such.\
    \ Also, use `chars` rather than `split` if you don't need those extra steps.\n\
    <|/ c |>\n<| c |>\nI was unaware of `chars`. Thanks! I'll edit the answer to add\
    \ this information also.\n<|/ c |>\n<| c |>\nNice. Ruby doesn't have a `each_prefix`\
    \ method so you have to create it.\n<|/ c |>\n<| c |>\nThis fails when the string\
    \ is `\"abcd\"`.\n<|/ c |>\n<| c |>\nThis fails when `string` is `\"abc\"`, where\
    \ `prefixes` should be `[\"a\", \"ab\", \"abc\"]`.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\nAnother way, using recursion:\n<code>", "  string.split(\"\").select { |s|\
    \ s.first == s[0] }\nend", "  prefix = []\n  prefix_set = []\n  while string !=\
    \ ''\n    prefix_set << string\n    string = string.rpartition(/[^a-zA-Z]+/)\n\
    \    prefix << string[0]\n  end\n  \n  prefix_set.each { |s| prefix << s }\n \
    \ return prefix\nend", "  length = 1\n  prefixes = []\n  while string.length >\
    \ 0\n    prefixes << string[0...length]\n    length += 1\n    string = string[length..-1]\n\
    \  end\n  prefixes\nend", "  return [string] + (string.length.times.map { string\
    \ + string }.drop(1))\nend", "  return prefix_tree(string).to_a\nend", "  return\
    \ string.scan(/./).inject([]) {|memo, s|\n    memo << s.slice(0, s.length)\n \
    \   memo\n  }\nend", "  prefix = []\n  i = -1\n  while i < string.length\n   \
    \ if i == string.length - 1\n      prefix << string[i]\n    else if string[i]\
    \ != string[i + 1]\n      prefix << string[i]\n    end\n    i += 1\n  end\n  prefix\n\
    end", "  result = []\n  result2 = []\n  string.each_char do |char|\n    result.push(char)\n\
    \    result2 << char\n  end\n  result2\nend", "    prefix = []\n    i = -1\n \
    \   l = len(string)\n    while i < (l - 1)\n        prefix.append(string[i])\n\
    \        i = i + 1\n    return prefix\nend", "  return string.gsub(/(?<=\\A)/,\
    \ '').split(//).sort_by{ |s| s.length }.reverse\nend", "  prefixes = string.split(//)\n\
    \  prefixes.flatten!\n  prefixes\nend", "  string = string.dup.chomp('\\n')\n\
    \  prefixes = Array.new\n  while string.length > 0\n    prefixes.push(string[0,\
    \ string.rindex(\"\\n\")])\n    string = string[(string.rindex(\"\\n\") + 1)..-1]\n\
    \  end\n  prefixes\nend", "  result = []\n  while string.length > 0\n    result.push\
    \ string[0..(string.index(0)).to_i]\n    string = string[(string.index(0)).to_i+1..-1]\n\
    \  end\n  result\nend", "  string.downcase!\n  prefixes = []\n  string.split(//).each\
    \ do |char|\n    prefixes << char if char.downcase == char\n  end\n  prefixes\n\
    end", "  return string.each_char.with_index.with_object([]) do |(char, i), result|\n\
    \    result << char if i < string.length\n  end\nend", "  prefixes = Array.new\n\
    \  string.each_char {|c| prefixes << c}\n  prefixes\nend", '  prefixes = []',
  "  prefixes = []\n  index = string.size\n  while index > 0\n    index = index -1\n\
    \    prefixes << string[0, index]\n  end\n  prefixes\nend", "  prefixes = []\n\
    \  string.length.times do |i|\n    prefixes << (string[0..i])\n  end\n  return\
    \ prefixes\nend", "  string.split(//).map {|e| e + \"x\"}\nend", "  string.chars.each_with_index.map\
    \ { |c, i| (i + 1).downcase + c }\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n\
    <| a tags=algorithm,ruby |>\n<code>", "    prefixes = []\n    char_count = string.length",
  "  prefixes = Array.new\n  string.each_char{|char|\n    if char == prefixes[-1]\n\
    \      prefixes << char\n    else\n      prefixes << char + prefixes[-2]\n   \
    \ end\n  }\n  prefixes.reverse\nend", "  return string.length.times.collect do\
    \ |i|\n    string.prefix(i)\n  end\nend", "  string\n  .scan(/\\w+/)\n  .map(&:first)\n\
    \  .map { |prefix| [prefix, *(0..string.length - prefix.length)].join }\n  .sort\n\
    end", "  string\n    .split(//)\n    .each_cons(2) # [['a'], ['b', 'c']]\n   \
    \ .map { |a, b| a.join(a) } # ['a', 'ab', 'abc']\nend\n</code>\n<|/ a tags=ruby,arrays,string\
    \ |>\n<| c |>\nThis doesn't produce the right result for strings like `\"abcde\"\
    `. For example, `all_prefixes(\"abcdefg\")` returns `[\"aabcdefg\", \"abcfg\"\
    , \"abcdeg\", \"abcefg\", \"abcfg\", \"abcefg\"]`, when in fact, it should return\
    \ `[\"aabc\", \"abce\", \"abcf\", \"abcg\", \"abcef\", \"abcfg\", \"abcefg\"]`.\n\
    <|/ c |>\n<| c |>\n: Please see my comment on the question for further explanation.\n\
    <|/ c |>\n<| c |>\n: I believe what I was trying to achieve is to find all permutations\
    \ of `string` prefixes of `string.length()`. This is different than the `permutations`\
    \ method which produces all permutations including empty strings and repeated\
    \ strings. Since this is a different question, let me post a separate question\
    \ for that. Thanks for your answer though.\n<|/ c |>\n<| c |>\nThank you for comments.\
    \ I updated my answer.\n<|/ c |>\n<| a tags=ruby,arrays,string |>\nI made a more\
    \ Ruby-like solution to this problem. The idea is to use recursion. This isn't\
    \ the prettiest code, but I like how it reads. To see the full version please\
    \ see below.\n<code>", "  result = []\n  i = 0\n  while i < string.length\n  \
    \  if string.chars.slice(i, i + 1) != 'a'\n      result[i] = string[i..i + 1]\n\
    \      i += 1\n    else\n      i += 1\n    end\n  end\n  result\nend", "  prefixes\
    \ = []\n  begin_index = 0\n  while begin_index <= (string.length - 1)\n    prefix\
    \ = string[begin_index..-1]\n    break if prefix.nil? || prefixes.include? prefix\n\
    \    prefixes << prefix\n    begin_index += 1\n  end\n  prefixes\nend", "  prefixes\
    \ = []\n  prefix_len = string.size.downto(1)\n  \n  while prefix_len > 0\n   \
    \ prefixes << string[0, prefix_len]\n    prefix_len -= 1\n  end\n  \n  prefixes\n\
    end", "  string.chars.reverse_each.take(string.size - 1).map { |i| string[0, i]\
    \ }.to_a\nend", "  # Add \"A\" to the list if it is not present already\n  return\
    \ [\"A\"] + string.split(\"A\").map {|i| i.capitalize}\nend", "  return string.split('').reverse.map\
    \ { |char| char.upcase + char }\nend", "  string.split(//).drop(1).map { |s| s.split('').drop_while\
    \ { |c| c.empty? }.map { |c| [c] * 2 }.flatten.uniq }\nend\n</code>\n<code>\n\
    all_prefixes(\"ABC\")\n  #=> [[\"A\", \"B\", \"C\"]]\nall_prefixes(\"AB\")\n \
    \ #=> [[\"A\", \"B\"]]\n</code>\n<code>\nprefixes = all_prefixes(\"ABCD\")\n \
    \ #=> [[\"A\", \"B\", \"C\", \"D\"]]\nprefixes.first\n  #=> [\"A\", \"B\", \"\
    C\", \"D\"]\nprefixes.last\n  #=> [\"D\"]\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>", "  result = []\n  while string.slice!(0)\n    result.pop string.slice!(0)\n\
    \  end\n  result\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nNice implementation.\
    \ I don't see a reason to use `pop`. `slice!(0)` will return the last character.\
    \ So you can change your code to: ```string[1..-1].split(//).map(&:to_s)```.\n\
    <|/ c |>\n<| c |>\n: Yes, you're right. The `pop` operation is unnecessary. I\
    \ just copied OP's code. Thanks!\n<|/ c |>\n<| a dscore=0 tags=ruby,string |>\n\
    A simple way would be to split the string by non-alphanumeric characters:\n<code>\n\
    'ABC123!?!123ABC'.split('[^a-zA-Z0-9]').map(&:capitalize)\n</code>\nThe above\
    \ code will return a string: ", "  string.split('').inject([[]]) do |prefixes,\
    \ char|\n    prefixes << char if char.upcase == char\n    prefixes\n  end\nend",
  "    string.split(//).map {|char| char.prepend}\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nYour `all_prefixes` function fails for the input `\"a\"` (i.e., `string`\
    \ does not start with a character and `char.prepend` returns `nil`).\n<|/ c |>\n\
    <| c |>\nAh. Good catch. Fixed the answer.\n<|/ c |>\n<| c |>\n: Your `all_prefixes`\
    \ function fails if `char` is `nil` -- `prepend` returns `nil` when given `nil`\
    \ as its argument. You should fix that before you try your function again. (It's\
    \ not wrong to have `nil`s here and there.)\n<|/ c |>\n<| c |>\nThank you so much\
    \ for answering so quickly.  I understand how the code works, but it looks like\
    \ a lot of extra stuff is happening here and there.  I guess my question was,\
    \ is there a way to do this without any of the extra code?  Something along the\
    \ lines of `all_prefixes('abc').map{|char| char.prepend}`, where each character\
    \ gets appended to the string until the string matches the original string.\n\
    <|/ c |>\n<| c |>\n: You're correct. My bad. Didn't realize that prepend returned\
    \ `nil` when given a nil as its argument. Thanks for pointing that out.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nYou could use each_cons(2) to get the prefixes without\
    \ having to loop through each character in the string:\n<code>", "  # Use recursion\
    \ to find all prefixes\n  all_prefixes = []\n  all_prefixes << string unless string.length\
    \ == 0\n  all_prefixes << string if string.length == 1 # Base case\n  all_prefixes.concat\
    \ all_prefixes(string[1..-1]) # Recursive case", "  string = string.downcase\n\
    \  return string == '' ?\n    [] :\n    string.scan(/[a-z]/).map { |prefix| prefix\
    \ + 'a' }\nend", "    prefix = []\n    prefix = string.split(//)\n    prefix.pop(1)\n\
    \    return prefix\nend", "    i = 0\n    prefixes = []\n    while i < string.length\n\
    \        i += 1\n        prefixes << string[0..i]\n    end\n    prefixes\nend",
  "    prefix = []\n    string_length = len(string)\n    \n    i = string_length-1\n\
    \    while i > 0\n        prefix.insert(0,string[i])\n        i -= 1\n    end\n\
    \    return prefix\nend", "  prefix = []\n  string.length.times { prefix.push\
    \ string }\n  prefix\nend", "  (0..string.length-1).collect { |i| string[0..i]\
    \ }\nend", "  prefix = []\n  string = string.dup\n  until string.empty?\n    char\
    \ = string.shift\n    if char == char.upcase\n      prefix.push(char)\n    else\n\
    \      break\n    end\n  end\n  prefix\nend", "  prefix = []\n  while string.length\
    \ != 0\n    prefix << string.slice!(0)\n  end\n  prefix\nend", "  string.each_char.with_index.map\
    \ { |c, i| string[..i] }\nend", "  string.split('').reverse.map {|c| prefix(c)\
    \ }.join\nend", "  prefixes = []\n  string.length.times { |i| prefixes << string[0,\
    \ i] }\n  prefixes.uniq\nend", "  string.downcase!\n  prefixes = []\n  string.split(\"\
    \").each do |c|\n    prefixes << c\n  end\n  prefixes.uniq!\n  prefixes\nend",
  "  result = []\n  prefix = \"\"\n  string.split(\"\").each do |c|\n    if c == string[0]\n\
    \      result << prefix\n    else\n      prefix = prefix + c\n    end\n  end\n\
    \  return result\nend", "  return string.split('').reduce([]) do |prefixes, char|\n\
    \    prefixes << char\n    prefixes << char.upcase\n    prefixes\n  end\nend",
  "    prefixes = Set.new\n    string.split(//).each do |char|\n        prefixes <<\
    \ char if char != char.capitalize\n    end\n    prefixes\nend", "    prefixes\
    \ = []\n    i = -1\n    string.split(\"\").each do |char|\n        i += 1\n  \
    \      prefixes << char if i > 1\n    end\n    return prefixes\nend", "  # Add\
    \ '' prefix to make it an empty string\n  string += '' # + 'a'\n  # For each character\
    \ in string append all the possible prefixes of that character\n  # (using all_prefixes\
    \ recursively) to results\n  results = []\n  all_prefixes('', string) do |prefix|\n\
    \    # Add prefix to results\n    results.unshift(prefix)\n    # Remove prefix\
    \ from string\n    string = string[prefix.length..-1]\n  end\n  # Return results\n\
    \  results\nend", "  \n  prefixes = nil\n  \n  string.split(\"\").each do |letter|\n\
    \    prefix = letter\n    suffixes = all_suffixes(string, letter)\n    \n    if\
    \ suffixes.count > 0\n      prefixes << prefix\n    end\n  end\n  \n  prefixes\n\
    end", "  return string.scan(/(.{1,})/g).flatten.compact\nend", '  prefixes = []',
  "  all_prefixes = []\n  (0..(string.size)).each { |i| all_prefixes << string[0,\
    \ i] }\n  all_prefixes\nend", "  i = 0\n  prefixes = []\n  while i < string.length\n\
    \    prefixes << string[i]\n    i += 1\n  end\n  prefixes.reverse\nend", "  prefixes\
    \ = []\n  i = 0\n  while i < string.length\n    prefixes << string[i..i+1]\n \
    \   i += 1\n  end\n  return prefixes\nend", "  prefix_list = []\n  prefix = string.slice(0,\
    \ 1)\n  while prefix != \"\"\n    prefix_list << prefix\n    prefix = prefix.succ\n\
    \  end\n  prefix_list << string\n  prefix_list\nend", "  prefixes = []\n  i =\
    \ 1 # Ignore first character\n  while i <= string.length\n    prefixes << string[i..-1]\n\
    \    i += 1\n  end\n  prefixes\nend", "  string.each_char.map { |c| c.to_s }\n\
    end", "  prefix = []\n  prefix_length = string.size\n  while prefix_length > 0\n\
    \    prefix << string[0, prefix_length]\n    string = string[prefix_length, string.length]\n\
    \    prefix_length = string.size\n  end\n  prefix\nend", "    prefixes = []\n\
    \    string.split(\"\").each { |i| prefixes << i if i.length > prefixes.size }\n\
    \    prefixes\nend\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| a dscore=2 |>\n<code>",
  "  return string[string.gsub(/^.(?=.{0,#{string.length - 1}}$)[^]*$/, '').length..-1]\n\
    end", "  prefix_list = []\n  prefix = nil", "    array = string.split('')\n  \
    \  i = 0\n    result = []\n    while (i < array.length)\n        result.push(array[i]\
    \ + array[i..-1].join)\n        i += 1\n    return result\nend", "  ret = []\n\
    \  prefix = \"\"\n  idx = 0\n  \n  while idx < string.length\n    if string.sub!(/[#{string[idx].ord\
    \ + (string[idx].ord - 64).chr}0-9]/, '')\n      prefix += string[idx]\n    end\n\
    \    idx += 1\n    \n    if string.length <= idx\n      ret << prefix\n    end\n\
    \  end\n  \n  ret\nend", "  string.split(//).each_cons(2).map { |s1, s2| s1.to_s\
    \ + s2 }\nend", "  strings = string.split('')\n  prefixes = []\n  index = 0\n\
    \  while index < strings.length\n    prefixes << strings[index..-1]\n    index\
    \ = index + 1\n  end\n  prefixes << strings[0..-1]\n  prefixes\nend", "  prefixes\
    \ = ''\n  string.each_char do |c|\n    prefixes << c unless c == string[-1]\n\
    \  end\n  prefixes\nend", "  result = Array.new\n  i = 0\n  while i < string.length\n\
    \    char = string[i]\n    if char == string[0]\n      result.push(char)\n   \
    \   i += 1\n      while i < string.length && string[i] == string[0]\n        i\
    \ += 1\n    end\n    i += 1\n  end\n  result\nend", "  prefixes = []\n  i = 0\n\
    \  while i < string.length\n    prefixes << string[i]\n    i += 1\n  end\n  return\
    \ prefixes\nend", "  return string.split(//).take_while{ |s| s.size < string.length\
    \ }.reverse\nend", "\tprefixes = []\n\tprefix = ''\n\tfor x in string.split\n\t\
    \tprefix = x + prefix\n\t\tprefixes.push(prefix)\n\treturn prefixes\nend", " \
    \ prefixes = []\n  prefix = nil", "  prefixes = []\n  i = -1\n  while i < string.length\n\
    \    i += 1\n    prefixes << string[0..i]\n  end\n  return prefixes\nend", " \
    \ sorted = string.downcase.split(//).sort_by { |char| char.length }.reverse\n\
    \  result = []\n  prev = nil\n  sorted.each { |char| result << char if char !=\
    \ prev }\n  result\nend", "  result = []\n  prefix = ''", "  prefixes = []\n \
    \ i = string.size\n  while i >= 0\n    prefixes << string[0, i]\n    i -= 1\n\
    \  prefixes\nend", "  prefixes = []\n  i = 1 # skip 'a'\n  while i < string.length\n\
    \    j = i - 1\n    while j >= 0\n      if string[j] == string[i]\n        prefixes\
    \ << string[j..i]\n        break\n      j -= 1\n    end\n    i += 1\n  end\n \
    \ prefixes\nend", "  result = []\n  for i in 0..(string.length-1)\n    result[(i*string.length)+1..].include?(string[i])\
    \ ? result << string[i] : nil\n  end\n  result\nend", "  prefixes = []\n  i =\
    \ 0\n  while i < string.length\n    prefix = string.slice(i, i + 1)\n    break\
    \ if i == string.length - 1\n    i += 1\n    prefixes << prefix\n    prefixes\
    \ << prefix.downcase\n  end\n  prefixes\nend", "  # return empty list if string\
    \ is empty\n  return string if string.empty? || string.empty? || string.length\
    \ <= 1", "  return string.split(/(?=[a-z])/)\nend", "    prefix = []\n    for\
    \ i in string.split('')\n        prefix.push i\n    return prefix\nend\n</cell>\n\
    <code language=julia-1.6>", "  prefixes = []\n  prefix_size = string.length\n\
    \  last_char = string.last\n  \n  (0..prefix_size).each do |i|\n    char = string[i]\n\
    \    if char == last_char # Last character doesn't need to prefix anymore\n  \
    \    break\n    end\n    prefixes << char\n    prefix_size -= i\n  end\n  prefixes\n\
    end\n</cell>\n<code language=julia-0.4>\nall_prefixes('abc')\n</cell>\n<code language=julia-0.4>",
  "  result = []\n  pos = 1\n  while pos < string.length\n    char = string[pos]\n\
    \    if char == string[0]\n      result = [char]\n    else\n      result = result\
    \ + [char] + all_prefixes(string.slice!(0..pos))\n    end\n    pos += 1\n  end\n\
    \  result\nend", "  prefixes = []\n  i = 0\n  while i < string.length\n    if\
    \ string[i] == 'a'\n      i += 1\n      prefixes << string[i]\n    else\n    \
    \  prefixes << string[i..-1]\n      break\n    end\n  end\n  return prefixes\n\
    end", "  return string.chars.map { |x| x }\nend", "  # Iterate over all character\
    \ indexes and create array of prefix prefixes\n  prefixes = Array.new\n  string.length.times\
    \ do |i|\n    # Construct prefix by removing character at current index\n    prefix\
    \ = string[0..i]\n    prefix.empty? ? prefixes << prefix : prefixes << prefix\
    \ << prefixes[-1]\n  end\n  # Return array of all prefix strings\n  prefixes\n\
    end", "    string.split(//).each_with_object([]) do |char, list|\n      list.unshift(char)\
    \ unless list.last == char\n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    <code>", "  prefix = []\n  string.split(//).each do |i|\n    prefix << i unless\
    \ prefix.include?(i)\n  end\n  prefix\nend", "    characters = []\n    string.each_char\
    \ {|c| characters << c}\n    characters.uniq\nend", "  return string.split(//).map{|x|\
    \ x.capitalize}.sort.reverse\nend", "  return string.split(//).map{|x| x.to_i}.sort.map{|x|\
    \ string[x..-1]}\nend\n</code>\n<|/ a |>\n<| c |>\nIt would probably be better\
    \ to sort this array in reverse order. This would make the code much more readable\
    \ for the user\n<|/ c |>\n<| c |>\nThank you for this. I did end up writing a\
    \ recursive function myself and that worked.\n<|/ c |>\n<| a tags=ruby,string-length,string\
    \ |>\nHere is another implementation:\n<code>", "  result = []\n  longest_prefix\
    \ = nil", "  return reduce(\n    :[],\n    (string.split('').map.with_index do\
    \ |char, index|\n      if index == 0\n        char\n      else\n        char +\
    \ string[index - 1]\n      end\n    end).reverse_each{|prefix| prefix + 'a'},\
    \ []\nend\n</code>\n<|/ a tags=string,ruby dscore=5 |>\n<| c |>\nAren't you still\
    \ creating a string with all the prefixes? Isn't that too much work? What about\
    \ reversing the string and getting the length of the string, then just iterate\
    \ through that? It seems like an easier solution to me.\n<|/ c |>\n<| c |>\nYeah,\
    \ I agree. Your solution works pretty well, and it's easy to understand. Just\
    \ wondering, how would you code this with a recursive function?\n<|/ c |>\n<|\
    \ c |>\nJust added a recursive solution.\n<|/ c |>\n<| c |>\n: You're absolutely\
    \ right, thanks for pointing that out. :-)\n<|/ c |>\n<| c |>\n: Wow, I've never\
    \ seen `reverse_each` before and it really does come in handy!\n<|/ c |>\n<| a\
    \ tags=string,ruby |>\n<code>", "  string.each_char.with_index.with_object([])\
    \ do |char, index|\n    prefix = []\n    index.times { prefix << char}\n    prefix.join\n\
    \  end\nend\n</code>\n<|/ a tags=string,ruby dscore=4 |>\n<| c |>\nThat's a cool\
    \ way to solve it by iterating through the string twice. I've always been wondering\
    \ why `string.chars` doesn't work that way.\n<|/ c |>\n<| c |>\nJust to add to\
    \ this, since it may be useful to someone in future, if I wanted to return an\
    \ array of the prefixes, but without including the prefix itself in the array,\
    \ I ended up using: `prefix.join(\"\")` rather than `prefix.join`.\n<|/ c |>\n\
    <| a |>\nThe accepted answer works, but it can be simplified slightly, by using\
    \ the chars method of the String class.\n<code>", "  return string.split(string.split().reverse().join)\n\
    end", "  string.length > 0 ? all_prefixes(string[0...-1]) + [string[0...-1]] :\
    \ []\nend", "    prefixes = Array.new\n    longest_length = -1\n    i = 0\n  \
    \  while i < string.length\n        prefix = string[0, i]\n        if longest_length\
    \ == -1\n            longest_length = i\n        i += 1\n        if longest_length\
    \ == i\n            prefixes.push(prefix)\n        end\n    end\n    prefixes\n\
    end", "  return string.scan(/^.+/).map {|s| s.first}\nend", "  return string.split(//).reduce(:+).split('')\n\
    end\n</pre>", "  prefixes = []\n  prefix = nil\n  string.each_char {|char|\n \
    \   if char.downcase == char\n      if !prefix.nil?\n        prefixes << prefix\n\
    \      end\n      prefix = char\n    elsif !prefix.nil?\n      prefix << char\n\
    \    end\n  }\n  prefixes << prefix unless prefix.nil?\n  prefixes\nend", "  return\
    \ string.scan(/\\w+/).flatten\nend", "  prefixes = string.split(\"-\")\n  prefixes.shift\n\
    \  prefixes.uniq!\n  prefixes\nend", "  # Return [] if string is empty\n  return\
    \ string unless string.length > 0\n  # Add first prefix to result\n  result =\
    \ [string[0]]\n  # Iterate through rest of string, add prefix to result if non-empty\n\
    \  rest = string[1..-1]\n  result << rest unless rest.empty?\n  # Return result\n\
    \  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nHere is my implementation\
    \ of all_prefixes using reduce and map:\n<code>", "    prefix = Array.new\n  \
    \  length = string.length\n    i = 0\n    while i < length\n      prefix = prefix\
    \ << string[i]\n      i += 1\n    end\n    prefix\nend\n</code>\nIn Ruby it would\
    \ be something like this (I didn't test it):\n<code>", "  prefixes = []\n  prefix\
    \ = ''\n  length = string.size\n  while length >= 0\n    prefix = string[0, length]\n\
    \    prefixes << prefix\n    length = length - 1\n  end\n  prefixes\nend", " \
    \ prefixes = Array.new\n  prefixes = [prefixes << string[0]]\n  string.size.times\
    \ { |i| prefixes << string[i..-1] }\n  prefixes\nend", "  prefixes = []\n  index\
    \ = 0\n  while index < string.length\n    prefix = string.slice(index, index+1)\n\
    \    prefixes << prefix\n    index += prefix.length\n  end\n  prefixes\nend",
  "  return [string]\nend", "  result = []\n  i = 0\n  while i < string.length\n \
    \   if string[i] == '#'\n      i += 1\n      result = []\n      break\n    result[result.length]\
    \ = string[i]\n    i += 1\n  result\nend", "  result = []\n  prefix = nil\n  string\
    \ = string.to_s\n  string.split('').each do |c|\n    if (prefix.nil?)\n      prefix\
    \ = c\n    elsif (prefix.is_a? String) and (c < prefix)\n      prefix = c\n  \
    \  end\n  end\n  result << prefix\n  result\nend", "  result = []\n  for i in\
    \ (0...(string.length))\n    prefix = string.substring i...i\n    break if result?\
    \ prefix\n    result << prefix\n  end\n  result\nend", "  string.length.downto(1).map\
    \ { |i| string[0..i] }\nend", "  string.split('').sort.reverse.map {|i| i}\nend",
  "  string.each_char.with_object([]) do |char,prefixes|\n    prefixes << char unless\
    \ char == prefixes.last\n  end\nend\n</code>\nThe Enumerable#with_object method\
    \ produces an enumerator for the input string. The enumerator produces objects\
    \ for each element in the original string and assigns the object to the given\
    \ variable. The variable is passed into the block to provide the value of the\
    \ object.\n<|/ a tags=algorithm,ruby |>\n<| c |>\nI like this solution; but I\
    \ don't think it's possible in Ruby to enumerate strings lazily without using\
    \ `each` or `each_char`. A `lazy` enumerator would allow you to do something like\
    \ this without having to pre-create the whole list. Sadly, I don't think there\
    \ is such a thing built into Ruby.\n<|/ c |>\n<| c |>\nI thought `Enumerator::Lazy`\
    \ was available in Ruby 2.2, but I guess it's not.\n<|/ c |>\n<| c |>\nThe `Enumerator::Lazy`\
    \ class was added in Ruby 2.3. The first part of my answer is for earlier versions\
    \ of Ruby. :)\n<|/ c |>\n<| c |>\nThis is great!  I didn't even know that Ruby\
    \ had a with_object method.\n<|/ c |>\n<| c |>\n: Yeah, I wondered if it would\
    \ be possible to emulate the `each_with_object` method with the old `each_char`\
    \ method, but I couldn't quite figure out how to do it. I posted a solution using\
    \ `each_char`, but if you have an elegant way to do it with `each_with_object`\
    \ I'd love to see it.\n<|/ c |>\n<| a tags=algorithm,ruby dscore=0 |>\nAnother\
    \ solution that doesn't use each_char\n<code>", "  string = string.dup.force_encoding(Encoding::ASCII_8BIT)\n\
    \  res = []\n  string.scan(/^(.)/) do |prefix|\n    res << prefix\n    string\
    \ = string.sub!(prefix, '')\n  end\n  res\nend", "  result = []\n  i, length =\
    \ 0, string.count('a') + string.count('b') + string.count('c')\n  while i < length\n\
    \    result << (string[0..i].to_s)\n    i += (string.count('a') + string.count('b')\
    \ + string.count('c'))\n    result\nend", "  return string.split('').reverse.reduce(&:+)\
    \ unless string.empty?\n  []\nend", "  string.split(//).each_with_object([]).with_index\
    \ do |(prefix, array), i|\n    array << prefix[0, i]\n  end\nend\n</code>\n<|/\
    \ a dscore=1 tags=ruby |>\n<| a tags=ruby |>\nHere is a short solution:\n<code>\n\
    str = 'abc'\narr = str.chars\n  #=> [\"a\", \"b\", \"c\"]\narr.map { |e| arr[0..arr.index(e)\
    \ + 1] }\n  #=> [\"a\", \"ab\", \"abc\"] \n</code>\nThe steps:\n<code>\narr =\
    \ str.chars\n  #=> [\"a\", \"b\", \"c\"]\narr.map { |e| arr[0..arr.index(e) +\
    \ 1] }\n  #=> [\"a\", \"ab\", \"abc\"] \n</code>\nThe first element of arr is\
    \ a, so the block calculates the indexes as follows:\n<code>\narr[0..arr.index('a')]\n\
    \  #=> [0, 1, 2, 3] \n</code>\nThe second element is b, so the block calculates\
    \ the indexes as follows:\n<code>\narr[0..arr.index('b')]\n  #=> [0, 1, 2, 3,\
    \ 4] \n</code>\nThe third element is c, so the block calculates the indexes as\
    \ follows:\n<code>\narr[0..arr.index('c')]\n  #=> [0, 1, 2, 3, 4, 5, 6] \n</code>\n\
    The first element of the array returned by the block should be \"a\" but that\
    \ is the result of arr[0..arr.index('a')] because the block calculates the indexes\
    \ as follows, as above:\n<code>\narr[0..arr.index('a')]\n  #=> [0, 1, 2, 3] \n\
    </code>\nThe second element of the array returned by the block should be \"ab\"\
    \ but that is the result of arr[0..arr.index('b')] because the block calculates\
    \ the indexes as follows, as above:\n<code>\narr[0..arr.index('b')]\n  #=> [0,\
    \ 1, 2, 3, 4] \n</code>\nThe third element of the array returned by the block\
    \ should be \"abc\" but that is the result of arr[0..arr.index('c')] because the\
    \ block calculates the indexes as follows, as above:\n<code>\narr[0..arr.index('c')]\n\
    \  #=> [0, 1, 2, 3, 4, 5, 6] \n</code>\nNote that arr.index('a') => 0.\n<|/ a\
    \ dscore=1 |>\n<| a tags=ruby |>\n<code>", "  prefix_array = []\n  while string.size()\
    \ > 1\n    prefix_array << string[0..(string.size - 2)]\n    string = string[(string.size\
    \ - 2)..-1]\n  end\n  prefix_array << string\n  return prefix_array\nend", " \
    \ prefix = []\n  string_length = string.size\n  for i in 0...string_length do\n\
    \    prefix.push string[0..i]\n  end\n  prefix\nend", "  prefix_list = []\n  string.split(\"\
    \").each do |char|\n    prefix_list << char unless prefix_list.include?(char)\n\
    \  end\n  prefix_list\nend", "  string_size = [string.length]\n  all_prefixes_size\
    \ = []\n  while string_size != []\n    string_size << string.length\n  end\n \
    \ all_prefixes_size << string\n  for i in 0..(string_size.length - 1)\n    string\
    \ = string.slice(0,string_size[i])\n    all_prefixes_size << string\n  end\n \
    \ return all_prefixes_size\nend\n</code>\nThe next function will remove the first\
    \ occurrence of a character from any prefix of any prefix of a string:\n<code>",
  "  # Initialize prefix array to an empty array\n  prefix_array = Array.new\n  \n\
    \  # Find longest prefix of input string\n  prefix_length = string.rindex(?a)\n\
    \  \n  # Initialize prefix to an empty string\n  prefix = \"\"\n  \n  # While\
    \ there are prefixes left to add\n  while prefix_length > 0\n    # Remove longest\
    \ prefix of input string and add to prefix array\n    prefix = string[0..prefix_length]\n\
    \    prefix_array << prefix\n    \n    # Remove longest prefix of input string\n\
    \    string = string[prefix_length..-1]\n    \n    # Find longest prefix of input\
    \ string\n    prefix_length = string.rindex(?a)\n  end\n  \n  # Return prefix\
    \ array\n  return prefix_array\nend", "  result = []\n  loop do\n    break if\
    \ result.empty?\n    break unless string[0...result.last.count] == result.last\n\
    \    result << string[0...result.last.count]\n  end\n  result\nend", "    prefixes\
    \ = Array.new\n    longest_prefix = ''\n    string_length = string.length\n  \
    \  i = 0\n    while i < string_length\n        prefix = string[i..string_length]\n\
    \        longest_prefix = prefix + longest_prefix\n        prefixes << longest_prefix\n\
    \        i += 1\n    end\n    prefixes\nend\n</code>\n<|/ a tags=ruby,string |>\n\
    <| c |>\n+1 for good code.  I am still not convinced it is better than the OP's\
    \ implementation.\n<|/ c |>\n<| c |>\n: I agree that your solution is more elegant\
    \ than mine but I thought it might be interesting for others to see both ways\
    \ of solving it :)\n<|/ c |>\n<| a dscore=2 |>\nHere is a recursive solution that\
    \ doesn't require you to remember all the prefixes (which would be very inefficient):\n\
    <code>", "  prefixes = []\n  prefixes_stack = Stack.new\n  prefixes_stack.push(string)\n\
    \  while !prefixes_stack.empty?\n    prefix = prefixes_stack.peek\n    prefixes\
    \ << prefix\n    suffixes = string.each_char.to_a.reverse.map{|c| c+prefix}\n\
    \    suffixes.each {|suffix| prefixes_stack.push(*suffix)}\n  end\n  prefixes\n\
    end", "  string = string.dup\n  string.gsub!(\"^#{prefix}\", '')\n  string.gsub!(\"\
    ^#{suffix}\", '')\n  string.gsub!(\"^#{regexp_prefix}\", '')\n  string.gsub!(\"\
    ^#{regexp_suffix}\", '')\n  return string.gsub(/(\\A|\\b)/, '').gsub(/\\b(\\A|\\\
    b)/, '')\nend", "  prefixes = []\n  loop do\n    break unless string =~ /^([^a-zA-Z]*)$/\n\
    \    prefix = $1\n    string.slice! prefix\n    prefixes << prefix\n  end\n  prefixes\n\
    end", "  return string.split('').reverse.map { |s| s[0] }.join\nend", "  string.each_char.with_index.select\
    \ do |e,i|\n    (i+1)...string.size if e == string[i]\n  end.map(&:first)\nend",
  "    prefixes = []\n    while string.length > 0\n        prefixes << string[0...]\n\
    \        string = string[1..-1]\n    end\n    prefixes\nend\n</cell>\n<code language=julia-0.5>",
  "  string = string.dup\n  result = []\n  string.length.times do\n    result << string[0...result.length]\n\
    \    break if result.last == string[0]\n  end\n  result\nend", "  prefix = []\n\
    \  prefixes = []\n  while string.length > 0\n    prefix = prefix + [0]\n    prefixes\
    \ << string\n    string = string[0,string.length-1]\n  prefixes.reverse!\n  return\
    \ prefixes + prefix\nend", "  prefixes = []\n  i = string.size", "  prefixes =\
    \ []\n  string.each_char.with_index do |char, i|\n    if i == 0 || i == string.length\n\
    \      prefixes << char\n    else\n      prefixes << char + string[i - 1, 1]\n\
    \    end\n  end\n  prefixes\nend", "  prefixes = []\n  current = ''\n  for i in\
    \ string\n    current += i\n    prefixes << current\n  end\n  prefixes\nend",
  "  result = []\n  i, j = 0, 0\n  while i < string.length\n    if i == 0\n      result.append(string.slice!(i..-1))\n\
    \      i += 1\n    else\n      if string[i] != string[i - 1]\n        result[-1]\
    \ << string[i..-1]\n      else\n        result[-1] << string[i..-1]\n        i\
    \ += 1\n      end\n    end\n  end\n  result\nend", "  prefixes = []\n  string_split\
    \ = string.split('')\n  string_split.each_with_index do |char, index|\n    prefixes\
    \ << char unless index == 0\n  end\n  prefixes\nend", "  string_length = string.size\n\
    \  prefixes = []", "  string, length = string, string.size\n  return Array.new(length)\
    \ { |i| string[0, i + 1] } if string =~ /\\p{Alpha}/ || string =~ /\\p{ASCII}/\
    \ || string =~ /\\p{Nonspacing_Mark}/ || string =~ /\\p{Mark}/ || string =~ /\\\
    p{Cc}/ || string =~ /\\p{Pc}/ || string =~ /\\p{Cf}/ || string =~ /\\p{Pf}/ ||\
    \ string =~ /\\p{Zl}/ || string =~ /\\p{Zp}/ || string =~ /\\p{Zs}/ || string\
    \ =~ /\\p{Zpz}/ || string =~ /\\p{Cs}/ || string =~ /\\p{Zs}/ || string =~ /\\\
    p{Zl}/ || string =~ /\\p{Cc}/ || string =~ /\\p{Zpz}/ || string =~ /\\p{Cs}/ ||\
    \ string =~ /\\p{Zs}/ || string =~ /\\p{Cc}/ || string =~ /\\p{Zpz}/ || string\
    \ =~ /\\p{Cs}/ || string =~ /\\p{Zs}/ || string =~ /\\p{Cc}/ || string =~ /\\\
    p{Zpz}/ || string =~ /\\p{Cs}/ || string =~ /\\p{Zs}/ || string =~ /\\p{Cc}/ ||\
    \ string =~ /\\p{Zpz}/ || string =~ /\\p{Cs}/ || string =~ /\\p{Zs}/ || string\
    \ =~ /\\p{Cc}/ || string =~ /\\p{Zpz}/ || string =~ /\\p{Cs}/ || string =~ /\\\
    p{Zs}/ || string =~ /\\p{Cc}/ || string =~ /\\p{Zpz}/ || string =~ /\\p{Cs}/ ||\
    \ string =~ /\\p{Zs}/ || string =~ /\\p{Cc}/ || string =~ /\\p{Zpz}/ || string\
    \ =~ /\\p{Cs}/ || string =~ /\\p{Zs}/ || string =~ /\\p{Cc}/ || string =~ /\\\
    p{Zpz}/ || string =~ /\\p", "\tprefix_list = Array.new\n\tprefix_list[0] = string\n\
    \twhile string.length > 0\n\t\tprefix_list << string[0, prefix_list.length-1]\n\
    \t\tstring = string[prefix_list.length-1, string.length-1]\n\tend\n\tprefix_list\n\
    end", "  prefixes = []\n  prefix = []\n  string.split(//).each do |item|\n   \
    \ item == \"\" ? prefixes.push(prefix.join(//)) : prefix.push(item)\n  end\n \
    \ prefixes.uniq!\n  return prefixes\nend", "  prefixes = []\n  length = 0\n  string_size\
    \ = string.size\n  string.length.times do |i|\n    prefix = string[0, i]\n   \
    \ length += prefix.length\n    prefixes << prefix\n  end\n  [prefixes, string_size,\
    \ length]\nend", "  prefixes = []\n  current = ''\n  i = 0\n  while i < string.length\n\
    \    char = string[i]\n    if char == current\n      prefix += char\n      i +=\
    \ 1\n    else\n      prefixes << current + char\n      current = char\n      i\
    \ += 1\n    end\n  end\n  prefixes << current\n  prefixes\nend\n</code>\nThis\
    \ should be fairly easy to follow and test. Just take it one step at a time. Test\
    \ the prefixes function to make sure it works on some simple strings. Once it\
    \ works, write a test to make sure it works on some larger strings too. Once that\
    \ works, try a longer string. Once that works, try a very large string. Once that\
    \ works, add all the prefixes together. Then try some very very very very very\
    \ very long strings. Once that works, try a very very very very very long long\
    \ string. Once that works, add all the prefixes together. Once that works, try\
    \ a very very very very long string. Once that works, add all the prefixes together.\
    \ Once that works, try a very very very long string. Once that works, add all\
    \ the prefixes together. Once that works, try a very very long string. Once that\
    \ works, add all the prefixes together. Once that works, try a very long string.\
    \ Once that works, add all the prefixes together. Once that works, try a long\
    \ string. Once that works, add all the prefixes together. Once that works, try\
    \ a string. Once that works, add all the prefixes together. Once that works, try\
    \ a very very very long long string. Once that works, add all the prefixes together.\
    \ Once that works, try a very very very long string. Once that works, add all\
    \ the prefixes together. Once that works, try a very very long string. Once that\
    \ works, add all the prefixes together. Once that works, try a very long string.\
    \ Once that works, add all the prefixes together. Once that works, try a long\
    \ string. Once that works, add all the prefixes together. Once that works, try\
    \ a string. Once that works, add all the prefixes together. Once that works, try\
    \ a very very very long long string. Once that works, add all the prefixes together.\
    \ Once that works, try a very very very long string. Once that works, add all\
    \ the prefixes together. Once that works, try a very very long string. Once that\
    \ works, add all the prefixes together. Once that works, try a very long string.\
    \ Once that works, add all the prefix", "  result = []\n  prefix = []\n  string.chars.with_index\
    \ do |c, i|\n    if i == 0\n      result << prefix\n    else\n      if c == 'a'\n\
    \        prefix << c\n      else\n        prefix << c.succ\n      end\n    end\n\
    \  end\n  result\nend", "  return all_suffixes(string).to_a\nend", "  return string.split(//).map\
    \ { |s| s[0..s.size] }\nend", "  prefix_list = []\n  string.split(//).each do\
    \ |c|\n    prefix_list << c if prefix_list.size == 0 || prefix_list.last == c\n\
    \  end\n  prefix_list\nend", "  prefix = []\n  prefix_len = 1\n  while string.gsub!(/\\\
    A(.{#{prefix_len}})/, '') do\n    prefix << $1\n    prefix_len += 1\n  end\n \
    \ prefix.reverse!\n  return prefix\nend", "  # Split string into list of characters\
    \ \n  list = string.split(//)\n  # Return list with all prefixes\n  list.map(&:sub!(''))\n\
    end", "  prefixes = Array.new\n  prev_char = nil\n  string.each_char do |c|\n\
    \    prefixes << c unless c === prev_char && !prefixes.include?(prev_char) # remove\
    \ duplicates\n    prev_char = c\n  end\n  prefixes\nend", "  string.split(//).map.with_index\
    \ { |char, index| index % string.size == 0 && char }.compact\nend", "  # find\
    \ first character of shortest string\n  min_length = string.length\n  # get first\
    \ character of the string and increment length\n  first_char = string[0]\n  first_char.length\
    \ += 1\n  # return all prefixes of the string by incrementing length\n  all_prefixes\
    \ = []\n  while string.length <= min_length\n    all_prefixes << first_char\n\
    \    string[0] = first_char\n    first_char.length += 1\n  end\n  all_prefixes\n\
    end", "  result = []\n  i = -1\n  while (i = string.rindex(?i, 1)) != nil\n  \
    \  result << string[0..i]\n  end\n  return result\nend", "  prefix = []\n  string.each_char\
    \ {|c| prefix << c }\n  prefix.uniq\nend", "  result = []\n  for i in 0...(string.length)\n\
    \    result.concat(sub_string(i, string))\n  return result\nend", "  string.split(\"\
    \").map do |c|\n    \"#{c}#{c}#{c}\".length\n  end.sort\nend", "  lengths = [string.length,\
    \ string.length]\n  prefixes = Array.new\n  i = 0\n  while i < string.length\n\
    \    lengths.each_with_index do |len, j|\n      if len < lengths[j]\n        prefixes[j]\
    \ = string[0...i]\n        lengths[j] = len\n        i = j + 1\n      end\n  \
    \  end\n  end\n  prefixes\nend", "  prefixes = []\n  current_length = string.length\n\
    \  while current_length > 1\n    current_length = current_length / 2\n    prefixes\
    \ << string.slice!(0, current_length)\n  end\n  prefixes << string\n  prefixes\n\
    end", "  array.to_a(string).map { |s| s.size }.reverse.uniq.map { |i| string[0,\
    \ i] }\nend", "  result = []\n  i = 0\n  while i < string.length\n    prefix =\
    \ string.slice!(0, i)\n    string = string.slice!(i..-1)\n    result << prefix\n\
    \    i += 1\n  end\n  result\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
