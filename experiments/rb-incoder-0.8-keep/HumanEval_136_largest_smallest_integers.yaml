name: HumanEval_136_largest_smallest_integers
language: rb
prompt: "# Create a function that returns a tuple (a, b), where 'a' is\n# the largest\
  \ of negative integers, and 'b' is the smallest\n# of positive integers in a list.\n\
  # If there is no negative or positive integers, return them as None.\n# Examples:\n\
  # largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n# largest_smallest_integers([])\
  \ == (None, None)\n# largest_smallest_integers([0]) == (None, None)\ndef largest_smallest_integers(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_smallest_integers\n\
  \    candidate = method(:largest_smallest_integers)\n    assert_equal([nil, 1],\
  \ candidate.call([2, 4, 1, 3, 5, 7]))\n    assert_equal([nil, 1], candidate.call([2,\
  \ 4, 1, 3, 5, 7, 0]))\n    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5,\
  \ 6, -2]))\n    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))\n\
  \    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))\n    assert_equal([nil,\
  \ nil], candidate.call([]))\n    assert_equal([nil, nil], candidate.call([0]))\n\
  \    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))\n    assert_equal([-1,\
  \ nil], candidate.call([-1, -3, -5, -6, 0]))\n    assert_equal([-3, 1], candidate.call([-6,\
  \ -4, -4, -3, 1]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100,\
  \ 1]))\n  end\nend\n"
completions: ["    largest_integer = nil\n    smallest_integer = nil\n    \n    #\
    \ Write your code here.\n    \n    # Don't forget to return largest_integer and\
    \ smallest_integer\nend\n</cell>\n<cell>\nlargest_integer = largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])\nlargest_integer\nsmallest_integer = largest_smallest_integers([])\n\
    smallest_integer\n</cell>\n<text>\nExercise 2\nWrite a function that takes a two-dimensional\
    \ array of positive integers as an argument\nand returns the array sorted largest\
    \ to smallest:", "  tuple = []\n  smallest, largest = nil, 0\n  lst.each do |number|\n\
    \    unless number < smallest\n      smallest = number\n    end\n    unless number\
    \ > largest\n      largest = number\n    end\n  end\n  return tuple if tuple !=\
    \ []\n  unless smallest < 0\n    return nil, 0\n  else\n    return smallest, largest\n\
    \  end\nend", "  smallest_negative = nil\n  smallest_positive = nil\n  lst.each\
    \ do |x|\n    if x > 0\n      smallest_positive = x\n    else\n      smallest_negative\
    \ = x\n    end\n  end", "  smallest_integer = nil\n  largest_integer = nil\n \
    \ \n  lst.each do |element|\n    if element < 0\n      largest_integer = element\n\
    \    elsif element > 0\n      smallest_integer = element\n    end\n  end\n  \n\
    \  return smallest_integer, largest_integer\nend", "    largest_integer = nil\n\
    \    smallest_integer = nil\n    array.each do |element|\n        smallest_integer\
    \ = element if element < smallest_integer\n        largest_integer = element if\
    \ element > largest_integer\n    end\n    return [largest_integer, smallest_integer]\n\
    end", '  lst.sort!', "  # Write your code here.\n  sorted = lst.sort\n  a = sorted[-1]\
    \ if sorted[0] < sorted[1] else None\n  b = sorted[0] if sorted[0] < sorted[1]\
    \ else None\n  return a, b\nend\n</cell>\n<text>\nWrite a function, sum_squared_integers,\
    \ that takes a list of integers and returns the sum of the squares of all the\
    \ integers in the list. For example, sum_squared_integers([4, 9, 16, 25]) should\
    \ return 385. Make sure to raise an exception if you encounter a value that is\
    \ outside the valid range of integers, such as sum_squared_integers([2, 5, 1000]).",
  "  smallest = lst[0]\n  largest = lst[0]\n  i = 0\n  while i < lst.size\n    if\
    \ smallest.negative? && lst[i].positive?\n      largest = lst[i]\n    elsif largest\
    \ == 0\n      smallest = lst[i]\n    elsif largest < smallest\n      smallest\
    \ = lst[i]\n    end\n    i += 1\n  end\n  [smallest, largest]\nend", "    smallest,\
    \ largest = lst.minmax_by(&:abs)\n    (smallest == largest and smallest.zero?\
    \ and largest.zero? or \n     smallest.nil? and largest.nil?)\nend\n</code>\n\
    This will return an optional tuple, where the first element is the largest negative\
    \ integer and the second element is the smallest positive integer (if it exists).\n\
    <code>\nlargest_smallest_integers([2, 4, 1, 3, 5, 7])", "    integers.each do\
    \ |integer|\n        smallest, largest = integer.abs, -integer.abs\n        smallest,\
    \ largest.each do |number|\n            return number, smallest if number < largest\n\
    \        end\n        return smallest if smallest < 0\n    end\n    return nil\n\
    end", "  lst.each do |int|\n    next if (int < 0)\n    next if (int > 0)\n   \
    \ return (int) if int > int\n  end\n  return nil\nend\n</code>\nAnd I hope it\
    \ helped.\n<|/ a |>\n<| a tags=arrays,ruby,functional-programming |>\n<code>",
  "  # Write your answer here.\nend", "  largest_negative_integer = 0\n  smallest_positive_integer\
    \ = 0\n  smallest_negative_integer = 1\n  largest_positive_integer = 1\n  results\
    \ = []\n  for i in lst\n    if i < 0\n      largest_negative_integer = i\n   \
    \   smallest_negative_integer = smallest_negative_integer - 1\n    elsif i > 0\
    \ \n      largest_positive_integer = i\n      smallest_positive_integer = smallest_positive_integer\
    \ + 1\n    else\n      results.push(i)\n    end\n  end\n  if results.count > 0\
    \ \n    results -= [smallest_negative_integer]\n  end\n  if results.count > 0\n\
    \    results -= [largest_positive_integer]\n  end\n  \n  if results.count > 0\n\
    \    results.first\n  else\n    results\n  end\nend", "  lst.compact.sort.reverse.map\
    \ { |i| i.is_a?(Integer) ? i : nil }\nend\n</code>\nAnd if you wanted an alternative\
    \ to the Ruby built-in sort that would work on non-integers, you could use sort_by.\n\
    <code>", "  lst.inject({}) { |result, item| result[item.abs] = item if item.is_a?\
    \ Integer }.values.find { |item| item.is_a? Integer }\nend", "  sorted = lst.sort\
    \ { |a,b| (a < b) ? -1 : 1 }\n  if sorted.first == sorted.last\n    return (None,\
    \ None)\n  else\n    first, last = sorted[0, sorted.size-1]\n    return (first,\
    \ last)\n  end\nend", "  min = -IntInf, max = IntInf\n  lst.each{|x|\n    next\
    \ if x < min\n    min = x if x < min \n    max = x if x > max\n  }\n  return min,\
    \ max\nend", "    positive, negative = [], []\n    \n    positive.concat lst.select(&:positive?)\n\
    \    negative.concat lst.select(&:negative?)\n    \n    largest_negative = negative.first\n\
    \    smallest_positive = positive.first\n    \n    if negative.empty?\n      \
    \  return smallest_positive, largest_negative\n    elsif positive.empty?\n   \
    \     return largest_negative, smallest_positive\n    end\n    \n    [smallest_positive,\
    \ largest_negative] = positive.sort_by { |x| -x }.reverse\n    [largest_negative,\
    \ smallest_positive] = negative.sort_by { |x| x }.reverse\n    \n    if smallest_positive\
    \ < largest_negative\n        smallest_positive, largest_negative = largest_negative,\
    \ smallest_positive\n    end\n    \n    [smallest_positive, largest_negative]\n\
    end\n</code>\nAnd finally, you can create a helper to do this sort of thing, by\
    \ creating a method on Array and calling the method on the instance of each element\
    \ in the list.\n<code>", "  lst.sort.reverse.map { |x| x <= 0 ? x : nil }.compact.first\n\
    end", '  sorted_lst = lst.sort', "    negative_int = 0\n    positive_int_list\
    \ = []\n    \n    positive_int_list.each do |int|\n        if int > 0\n      \
    \      positive_int_list.push(int)\n        elsif int < 0\n            negative_int\
    \ = -int\n        end\n    end\n    \n    if negative_int\n        smallest_int\
    \ = negative_int\n    elsif !negative_int_list.empty?\n        smallest_int =\
    \ negative_int_list[0]\n    else\n        smallest_int = None\n    end\n    \n\
    \    if positive_int_list.empty?\n        return (smallest_int, None)\n    end\n\
    \    \n    if smallest_int == negative_int\n        smallest_int, largest_int\
    \ = largest_smallest_integers(positive_int_list)\n    elsif largest_int == negative_int\n\
    \        smallest_int, largest_int = smallest_smallest_integers(positive_int_list)\n\
    \    else\n        smallest_int, largest_int = largest_smallest_integers(positive_int_list)\n\
    \    end\n    \n    return [smallest_int, largest_int]\nend\n</code>\n<|/ a |>\n\
    <| c |>\nYour first method was incorrect for negative numbers in some cases. Try\
    \ it on your own. It will return (1, -1) instead of (1, 0). Also, the second method\
    \ has the same issues as your first method. You should rework your code to work\
    \ for any list.\n<|/ c |>\n<| a |>\nI like 's answer (also my first thought),\
    \ but here's another one (which I believe is better than mine).\n<code>", "  lst.sort\
    \ # Sort the list\n  largest = nil # Initialize largest to nil\n  smallest = nil\
    \ # Initialize smallest to nil\n  index = 0 # Initialize index to 0\n  while index\
    \ < lst.size # Loop through list\n    if largest == nil or largest > lst[index]\
    \ # If the largest is nil or is greater than lst[index]\n      largest = lst[index]\
    \ # Assign largest to lst[index]\n    elsif smallest == nil or smallest < lst[index]\
    \ # If the smallest is nil or is smaller than lst[index]\n      smallest = lst[index]\
    \ # Assign smallest to lst[index]\n    end # end if\n    index += 1\n  end # end\
    \ while\n  return [largest, smallest] # Return the largest and smallest values\n\
    end # end def largest_smallest_integers\n</code>\nThe above method is called largest_smallest_integers.\n\
    The next method returns the largest and smallest values of a list of numbers.\
    \ If the list contains no numbers, an empty array is returned.\n<code>", "  lst.sort!\n\
    \  first = nil\n  last = nil\n  i = 0\n  while i < lst.size do\n    if lst[i]\
    \ < 0\n      first = lst[i]\n      break\n    else\n      last = lst[i]\n    \
    \  i += 1\n    end\n  end\n  if first == nil\n    return (None, None)\n  end\n\
    \  i = lst.size - 1\n  while i >= 0 do\n    if lst[i] > 0\n      last = lst[i]\n\
    \      break\n    end\n    i -= 1\n  end\n  if last == nil\n    return (first,\
    \ last)\n  end\n  return (first, last)\nend", "  min = []\n  max = []\n  lst.each\
    \ do |i|\n    if i < 0\n      min << i\n    else\n      max << i\n    end\n  end\n\
    \  return min if min.size < max.size\n  max\nend", "  largest_int = nil\n  smallest_int\
    \ = nil\n  lst.each do |x|\n    if x >= 0\n      smallest_int = x\n    else\n\
    \      largest_int = x\n    end\n  end\n  return [largest_int, smallest_int]\n\
    end", "    # Write your logic here\n  end\n</code>\n<|/ a dscore=1 tags=ruby |>\n\
    <| a tags=ruby |>\nIt is not quite clear what you are trying to do, perhaps you\
    \ can explain it better?\nI assume you are trying to find the largest or smallest\
    \ item in the list, if that's the case:\n<code>", "  smallest_int = nil\n  largest_int\
    \ = nil", "  smallest_integer = nil\n  largest_integer = nil\n  lst.each do |integer|\n\
    \    if integer < 0\n      smallest_integer = integer\n    elsif integer > 0\n\
    \      largest_integer = integer\n    end\n  end\n  if smallest_integer && largest_integer\n\
    \    (smallest_integer, largest_integer)\n  else\n    nil\n  end\nend", "  max_num\
    \ = lst.find { |e| e.is_a?(Numeric) } || nil\n  min_num = lst.find { |e| e.is_a?(Numeric)\
    \ } || nil\n  [max_num, min_num]\nend", "    smallest_int = nil\n    largest_int\
    \ = nil\n    if lst.is_a?(Array) \n        lst.each do |i|\n            if i.is_a?\
    \ Integer\n                smallest_int = i if smallest_int == nil or i < smallest_int\n\
    \                largest_int = i if largest_int == nil or i > largest_int\n  \
    \          end\n        end\n        return (smallest_int, largest_int)\n    end\n\
    \    return nil\nend\n</code>\n<|/ a tags=algorithm,ruby,arrays dscore=1 |>\n\
    <| c |>\nThe code in your answer doesn't work. For example, try it with [2,4,1,3,5,7].\
    \ It returns `(2, 7)`.\n<|/ c |>\n<| c |>\nThanks for the tip. I modified my answer\
    \ as I realized there was an error in mine.\n<|/ c |>\n<| c |>\nThanks so much\
    \ for your answer but the code you wrote returns the correct answer if the list\
    \ is [2,4,1,3,5,7] however when I change the list to [2,2,3,4,5,6], it returns\
    \ `nil` instead of `(2, 6)`. So I think it only works if the list only has one\
    \ integer. Do you have any suggestions on how to get it to work on a list of more\
    \ than one integer?\n<|/ c |>\n<| c |>\nYes, I've made a small change that makes\
    \ it work with the input you provided. If this solution works for you, can you\
    \ mark this answer as accepted please?\n<|/ c |>\n<| c |>\nYes, thank you. I marked\
    \ the answer as accepted now. Thank you so much for your help.\n<|/ c |>\n<| a\
    \ dscore=1 |>\n<code>", "  lst.sort.reverse!\n  nil, smallest = nil, nil\n  lst.each_with_index\
    \ do |val, idx|\n    if val < 0\n      if smallest == nil or val < smallest\n\
    \        smallest = val\n      end\n    else\n      if smallest != nil and val\
    \ > smallest\n        smallest = nil\n      end\n    end\n  end\n  return smallest,\
    \ nil\nend", "  smallest, largest = lst[0], lst[0]\n  for i in lst\n    if i >\
    \ largest\n      largest = i\n    if i < smallest\n      smallest = i\n  return\
    \ smallest, largest\n</cell>\n<cell>", "  lst.sort_by { |num| num.abs }\n  return\
    \ lst.last || lst.first, lst.first if lst.size <= 1\nend", "  smallest, largest\
    \ = lst.minmax\n  [smallest, largest].compact.map {|e| e.to_i }\nend\n</code>\n\
    <|/ a dscore=3 tags=ruby |>\n<| a |>\nI've had the same problem a few months ago,\
    \ but this is what I did:\n<code>", "  largest = nil\n  smallest = nil\n  lst.each\
    \ do |x|\n    if x > largest\n      largest = x\n    end\n    if x < smallest\n\
    \      smallest = x\n    end\n  end\n  return [smallest, largest]\nend", "  smallest,\
    \ largest = 0, 0\n  smaller, larger = [], []", "  largest_number = nil\n  smallest_number\
    \ = nil\n  \n  if lst.empty?\n    return (nil, nil)\n  else\n    first = lst[0]\n\
    \    \n    if first < 0\n      smallest_number = first\n    else\n      largest_number\
    \ = first\n    end\n    \n    second_number = lst[1]\n    \n    if second_number\
    \ < 0\n      smallest_number = second_number\n    else\n      largest_number =\
    \ second_number\n    end\n    \n    (smallest_number, largest_number)\n  end\n\
    end", "  if lst.all? {|x| x.to_i < 0}\n    min, max = lst.minmax\n    if max\n\
    \      max = max[0]\n      min\n    else\n      min\n    end\n  else\n    min,\
    \ max = lst.minmax\n    [min, max]\n  end\nend", "  lst.sort { |a, b| b <=> a\
    \ } # sorts in ascending order\n  return lst.sort.last if lst.count { |x| x <\
    \ 0 } == lst.count\n  return (lst.sort.first, lst.sort.last) if lst.count { |x|\
    \ x > 0 } == lst.count\n  return (lst.sort.last, None)\nend", "    smallest_integer\
    \ = nil\n    largest_integer = nil\n    \n    unless lst.empty?\n        if lst[0]\
    \ < 0\n            smallest_integer = lst.min\n        else\n            smallest_integer\
    \ = lst.max\n        end\n    end\n    \n    unless lst.empty?\n        if lst[0]\
    \ > 0\n            largest_integer = lst.max\n        else\n            largest_integer\
    \ = lst.min\n        end\n    end\n    \n    return (smallest_integer, largest_integer)\n\
    end", "  if lst.empty?\n    (nil, nil)\n  else\n    largest_positive(lst).zip(largest_negative(lst)).find\
    \ { |a,b| a < b }\n  end\nend", "  # Your code here\n  return(None, None)\nend",
  "    negative_ints = []\n    positive_ints = []\n    lst.each do |num|\n       \
    \ if num < 0\n            negative_int << num\n        else\n            positive_int\
    \ << num\n        end\n    end\n    negative_int, positive_int =\n        negative_int\
    \ ? negative_int : nil, positive_int ? positive_int\n    negative_int, positive_int\
    \ = (negative_int || []), (positive_int || [])\n    (negative_int.max_by {|x|\
    \ x}), (positive_int.min_by {|x| x})\nend\n</code>\nYou can try it out here: https://repl.it/repls/CoherentDelightfulFreshening\n\
    I hope this helps! Happy coding!\n<|/ a tags=arrays,ruby dscore=3 |>\n<| a |>\n\
    You can do it like this:\n<code>", "  n = [nil]\n  n.push lst.shift\n  while n.length\
    \ > 0\n    if n[0].nil?\n      return (n[0], n[0].zero?)\n    end\n    # find\
    \ the first negative value\n    j = n.length\n    while n.last > 0 and n[j-1].negative?\
    \ and j > 0\n      j -= 1\n    end\n    # find the smallest positive value\n \
    \   i = j\n    while n.last > 0 and n[i].positive? and i <= j\n      i += 1\n\
    \    end\n    if i > j\n      n.swap(i, j)\n    end\n  end\nend\nputs \"(#{largest_smallest_integers([-4,\
    \ -1, 0, 1, 2, 3, 5, 7])}, #{largest_smallest_integers([2, 4, 1, 3, 5, 7])})\"\
    \nputs \"(#{largest_smallest_integers([])}, #{largest_smallest_integers([nil])})\"\
    \nputs \"(#{largest_smallest_integers([0])}, #{largest_smallest_integers([nil])})\"\
    \n</cell>\n<cell>", "  \n  # Write your code here.\n  \n  # Initialize max and\
    \ min to nil\n  max = min = nil\n  \n  # For each element in the list\n  lst.each\
    \ do |i|\n  \n    # If the element is negative\n    if i < 0\n    \n      # If\
    \ the largest is not nil and is smaller than the current max\n      if max !=\
    \ nil and max < i\n        max = i\n      end\n    \n      # If the smallest is\
    \ not nil and is larger than the current min\n      if min != nil and min > i\n\
    \        min = i\n      end\n    end\n  end\n  \n  # Return max and min\n  return\
    \ max, min\nend", "  # Get the smallest and largest of the numbers in the list.\n\
    \  smallest = largest_integer(lst)\n  largest = largest_integer(lst.reverse)",
  "  smallest_integer = None\n  largest_integer = None\n  lst.each do |x|\n    if\
    \ x.is_a? Integer\n      if smallest_integer.nil? or x < smallest_integer\n  \
    \      smallest_integer = x\n      elsif x > largest_integer\n        largest_integer\
    \ = x\n      end\n    else\n      if smallest_integer.nil?\n        smallest_integer\
    \ = x\n      elsif x < smallest_integer\n        smallest_integer = x\n      elsif\
    \ x > largest_integer\n        largest_integer = x\n      end\n    end\n  end\n\
    \  [smallest_integer, largest_integer]\nend", "  # Write your code here\n  sorted\
    \ = lst.sort\n  sorted.shift if sorted.empty? || sorted.first < 0 \n  sorted.shift\
    \ if sorted.empty? || sorted.first > 0\n  [sorted.last, sorted.first]\nend", " \
    \ tuple = nil\n  smallest = nil\n  largest = nil\n  tuple = lst.find {|x| x.negative?\
    \ } || lst.find {|x| x.positive? }\n  if tuple.nil? or tuple.positive? then\n\
    \    smallest = nil\n    largest = nil\n  else\n    smallest = tuple.negative?\
    \ ? tuple.abs : tuple.abs\n    tuple = lst.find {|x| x.negative? and x.abs > largest\
    \ }\n    tuple = lst.find {|x| x.positive? and x.abs < smallest }\n    largest\
    \ = tuple.nil? ? nil : tuple.abs\n  end\n  return [largest, smallest]\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nWhat if `lst` contains no negative numbers?\n<|/\
    \ c |>\n<| c |>\n: I agree, for that case it would be better to return `nil`.\
    \  I'll add that to the answer.\n<|/ c |>\n<| c |>\nOh I see, I just thought it's\
    \ better to return `nil` instead of `[-1,nil]`.\n<|/ c |>\n<| c |>\nYes, it is\
    \ better to return `nil` explicitly.\n<|/ c |>\n<| c |>\nThanks for taking the\
    \ time to write this solution. Very helpful.\n<|/ c |>\n<| a |>\n<code>", "  return\
    \ (lst.sort { |a,b| b <=> a } .last, -lst.sort { |a,b| a <=> b }.first) if lst.any?\n\
    \  nil\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\nA more advanced solution\
    \ that would handle arrays of any size using recursion. \n<code>", "  if lst.empty?\n\
    \    return (None, None)\n  largest = lst.max\n  smallest = lst.min\n  largest_integer\
    \ = lst.max - lst.min - 1\n  smallest_integer = lst.min - 1\n  smallest_negative\
    \ = smallest - largest\n  largest = largest - smallest_integer\n  largest = largest\
    \ if largest < largest_integer else largest_integer\n  smallest = smallest if\
    \ smallest > smallest_integer else smallest_integer\n  return [largest, smallest]\
    \ if largest != smallest and largest != smallest_negative\n  largest_smallest_integers(lst[1..-1])\n\
    end", "  # Get the length of the list\n  list_length = lst.length", "  largest_value\
    \ = largest_negative_integer(lst)\n  smallest_value = smallest_positive_integer(lst)\n\
    \  return [largest_value, smallest_value] unless largest_value\nend", "  lst.sort!\n\
    \  if lst.empty?\n    return ( None, None )\n  a, b = ( lst.first - 1, lst.last\
    \ )\n  while b <= a do \n    tmp = a + 1\n    if b <= ( lst.size - 1 ) and ( lst[tmp]\
    \ < lst[b] ) then\n      a = tmp\n    else\n      b = tmp - 1\n    end\n  end\n\
    \  return ( a, b )\nend", "\tsmallest = nil\n\tlargest = nil\n\t\n\tlst.each do\
    \ |el|\n\t\tif el < smallest\n\t\t\tsmallest = el\n\t\telsif el > largest\n\t\t\
    \tlargest = el\n\t\tend\n\tend\n\t\n\treturn [smallest, largest]\nend", "  return\
    \ [x.abs # negative integers are negative.\n    .max_by { |x| x } # find the largest\
    \ negative.\n    .abs, # find the largest positive\n    -lst.min_by { |x| x }\
    \ # find the smallest negative\n  ] if lst.any? # if there are any negative or\
    \ positive integers\nend\n</code>\nAs we noted, this solution is very efficient.\
    \ If you need to process very large lists, consider using a hash table instead.\n\
    <code>\nlargest_smallest_integers = ->(lst)\n  # Create the hash table with negative\
    \ integers as keys and values 0.\n  # Hash keys are negative integers and values\
    \ are nil.\n  # Use the default value nil for nil values.\n  hsh = Hash.new(0)\n\
    \  # Process the list.\n  lst.each do |x|\n    # Set the key in the hash table\
    \ to be the absolute value of the integer.\n    hsh[x.abs] = nil\n  end\n  # Return\
    \ the first key that has a value.\n  hsh.max_by { |k,v| v }\nend\n</code>\n<|/\
    \ a dscore=4 |>\n<| c |>\nThis was a very smart use of max_by :)\n<|/ c |>\n<|\
    \ c |>\nA nice solution, I was looking for something that would work as close\
    \ to O(n) as possible, but this is the best solution for me.\n<|/ c |>\n<| a dscore=4\
    \ |>\nThis one uses no libraries (just ruby)\n<code>", "  sorted = lst.sort\n\
    \  first, last = sorted.first, sorted.last\n  if first && last\n    if first <\
    \ 0\n      if last > 0\n        return first,last\n      else\n        return\
    \ None\n    else\n      if last < 0\n        return first, last\n      else\n\
    \        return first,first\n  else\n    return None, None\nend", "  # Get the\
    \ smallest integer of the list and return it.\n  smallest_integer = lst[0]\n \
    \ # Loop over the list.\n  for i in 1..lst.length\n    # Get the next integer\
    \ and see if it's smaller.\n    next_integer = lst[i]\n    if next_integer < smallest_integer\n\
    \      smallest_integer = next_integer\n    # If the current integer is smaller\
    \ than the smallest integer,\n    # then update smallest_integer.\n    if next_integer\
    \ < smallest_integer\n      smallest_integer = next_integer\n      # Return the\
    \ smallest_integer to the calling function.\n      return smallest_integer\n \
    \ # Return the smallest integer to the calling function.\n  return smallest_integer\n\
    end\n</code>\nNow we can get the largest and smallest positive integers in one\
    \ line of code.\n<code>\nlargest_smallest_integers([-5, -4, -3, -2, -1, 0, 1,\
    \ 2, 3, 4, 5])", "  largest_number = nil\n  smallest_number = nil\n  lst.each\
    \ do |i|\n    if i > 0 && i < 1000000\n      if largest_number.nil? || i > largest_number\n\
    \        largest_number = i\n      end\n      if smallest_number.nil? || i < smallest_number\n\
    \        smallest_number = i\n      end\n    end\n  end\n  return largest_number,\
    \ smallest_number\nend", "  smallest, largest = nil, nil\n  lst.each do |element|\n\
    \    if element < smallest\n      smallest = element\n    end\n    if element\
    \ > largest\n      largest = element\n    end\n  end\n  return smallest, largest\n\
    end", "  return nil if lst.empty?\n  a = nil\n  b = nil\n  lst.each do |x|\n \
    \   if x.negative?\n      a = x.abs\n    else\n      b = x.abs\n    end\n    return\
    \ x if a.nil? || b.nil?\n    if a > b\n      a = b\n    end\n  end\n  return nil\
    \ if a.nil?\n  return a\nend", "  lst.each do |num|\n    if num < 0\n      return\
    \ (num, None)\n    end\n  end\n  lst.find do |num|\n    number > 0\n  end\nend\n\
    </code>\n<|/ a |>\n<| c |>\nI don't think this works when you have two values\
    \ in a list where one is positive, and the other negative. Try it for input: [1,\
    \ -2, 3]\n<|/ c |>\n<| c |>\nIt doesn't work. Try it for the input: [-100, -100]\n\
    <|/ c |>\n<| c |>\nI think I fixed it. I was checking the wrong element. Should\
    \ be lst.find do |num|\n    number > 0 unless num < 0\n  end\n<|/ c |>\n<| a tags=ruby\
    \ |>\nIf you can assume the list is sorted, then this will do it:\n<code>\narray\
    \ = [-1, -2, -3, 4, 5, -7, 8, 10]", "  if lst.empty?\n    return (None, None)\n\
    \  \n  max_num = max_positive(lst)\n  min_num = min_negative(lst)\n  return [max_num,\
    \ min_num]\nend", "    largest_negative = None\n    smallest_positive = None\n\
    \    \n    numbers_negative = []\n    numbers_positive = []\n    \n    numbers.each\
    \ do |number|\n        if (number < 0)\n            numbers_negative.push(number)\n\
    \        elsif (number > 0)\n            numbers_positive.push(number)\n     \
    \   end\n    end\n    \n    numbers_negative.each do |number|\n        largest_negative\
    \ = number if number > largest_negative\n    end\n    \n    numbers_positive.each\
    \ do |number|\n        smallest_positive = number if number < smallest_positive\n\
    \    end\n    \n    return (largest_negative, smallest_positive) if smallest_positive\
    \ && smallest_negative\n    \n    return (None, None)\nend", "  lst.sort.reverse\n\
    \  smallest_negative = nil\n  largest_positive = nil\n  lst.each do |num|\n  \
    \  if num < 0\n      return (num, None)\n    elsif num > 0 && num > largest_positive\n\
    \      return (None, num)\n    elsif num < smallest_negative\n      smallest_negative\
    \ = num\n    end\n    largest_positive = num if num > 0\n  end\n  return (smallest_negative,\
    \ largest_positive)\nend\n</cell>\n<cell>\nlargest_smallest_integers([2, 4, 1,\
    \ 3, 5, 7])\n</cell>\n<cell>", "  lst.sort!\n  negative_integers = lst.select\
    \ { |x| x < 0 }\n  positive_integers = lst.select { |x| x > 0 }", "    smallest_negative_integer\
    \ = None\n    smallest_positive_integer = None", "  smallest_integer = nil\n \
    \ largest_integer = nil\n  \n  lst.each do |i|\n    next unless i.is_a? Integer\n\
    \    next unless smallest_integer == nil || i < smallest_integer\n    smallest_integer\
    \ = i\n  end\n  \n  lst.each do |i|\n    next unless i.is_a? Integer\n    next\
    \ unless largest_integer == nil || i > largest_integer\n    largest_integer =\
    \ i\n  end\n  \n  (largest_integer, smallest_integer)\nend", "  int_min = -lst.min.to_i\n\
    \  int_max = -lst.min.to_i\n  int_lst = -lst.min.to_i.downto(int_max)", "  sorted\
    \ = lst.sort\n  return sorted[0], sorted[-1] if sorted.length <= 1 else None\n\
    end", "  highest_negative = nil\n  lowest_positive = nil\n  highest_positive =\
    \ nil\n  lst.each do |num|\n    if num < lowest_positive || lowest_positive ==\
    \ nil\n      lowest_positive = num\n    elsif num > highest_positive || highest_positive\
    \ == nil\n      highest_positive = num\n    else\n      if num < highest_negative\
    \ || highest_negative == nil\n        highest_negative = num\n      elsif num\
    \ > lowest_positive || lowest_positive == nil\n        lowest_positive = num\n\
    \      end\n    end\n  end\n  return (highest_negative, lowest_positive)\nend",
  "  tuples = lst.group_by{|x| x.negative?}.each{|k,v|\n    v.delete_if{|x| x.positive?}\n\
    \    v.delete_if{|x| x.negative?}\n  }\n  tuples = tuples.map{|k, v| [k, v.min]}\n\
    \  tuples = tuples.compact{|x| x[0].positive?}.compact{|x| x[0].negative?}.sort{|x,y|\
    \ y[0] <=> x[0]}\n  return tuples\nend", "  lst.each do |i|\n    if i <> 0\n \
    \     return i, i.abs\n    end\n  end\n  return nil, nil\nend\n</code>\n<|/ a\
    \ dscore=1 tags=ruby,arrays |>\n<| c |>\nIt would be more Ruby-esque to use `arr.select\
    \ { |i| i <> 0 }.max`\n<|/ c |>\n<| c |>\n: I don't think that's what OP wants\
    \ exactly.\n<|/ c |>\n<| c |>\n`arr.select(&:nonzero).max` might be a better choice\
    \ as that would return `nil` rather than `0` if there are no nonzero elements.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  if lst.empty?\n    (None, None)\n  elsif\
    \ lst.any?\n    smallest = lst.min\n    largest = lst.max\n    if smallest < 0\n\
    \      (None, None)\n    elsif largest > 0\n      (largest, smallest)\n    else\n\
    \      (None, None)\n  else\n    (None, None)\nend\n</pre>", "  positive_integers\
    \ = []\n  negative_integers = []\n  biggest = nil\n  smallest = nil\n  lst.reject!\
    \ { |x| x.zero? }\n  if lst.size < 2\n    return [None, nil]\n  end\n  lst.each\
    \ { |x| return [biggest, smallest] if x.zero? }\n  lst.each do |x|\n    if x.positive?\n\
    \      positive_integers << x\n      biggest = x.positive? if biggest.nil? ||\
    \ biggest > x\n    else\n      biggest = x.negative? if biggest.nil? || biggest\
    \ < x\n      smallest = x.negative? if smallest.nil? || smallest < x\n    end\n\
    \  end\n  return [biggest, smallest]\nend", "  smallest_integer = None\n  largest_integer\
    \ = None\n  min_integer = None\n  max_integer = None\n  i = 0\n  while i < lst.size\n\
    \    if lst[i] <= 0\n      smallest_integer = lst[i]\n      i += 1\n    elsif\
    \ lst[i] >= 0\n      largest_integer = lst[i]\n      i += 1\n    else\n      min_integer\
    \ = lst.first\n      max_integer = lst.last\n      break\n    end\n  end\n  if\
    \ min_integer.nil?\n    (smallest_integer, largest_integer)\n  elsif max_integer.nil?\n\
    \    (min_integer, largest_integer)\n  else\n    (smallest_integer, largest_integer)\n\
    \  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is really nice :) I'll\
    \ have to look into it some more to understand how it works.\n<|/ c |>\n<| c |>\n\
    I added a simpler version using only two variables and a loop. It should be more\
    \ understandable for you to understand.\n<|/ c |>\n<| a |>\n<code>", "  lst.sort!\n\
    \  a = nil\n  b = nil\n  i = 0\n  while i < lst.size\n    if i < lst.size - 1\
    \ && a.to_i < b.to_i\n      a = lst[i]\n      i += 1\n      b = lst[i]\n    elsif\
    \ i < lst.size - 1 && a.to_i == b.to_i\n      a = lst[i]\n      i += 1\n    elsif\
    \ a.to_i < b.to_i\n      b = lst[i]\n    end\n    i += 1\n  end\n  [a, b]\nend",
  "  return nil if lst.empty? or lst.any? { |x| x.to_i < 0 } or\n      lst.any? {\
    \ |x| x.to_i > 0 }", "  smallest_integer = nil\n  largest_integer = nil\n  smaller_list\
    \ = false\n  lst.each do |number|\n    if number < smallest_integer\n      smallest_integer\
    \ = number\n    elsif number > largest_integer\n      largest_integer = number\n\
    \    else\n      smaller_list = true\n    end\n  end", "  lst.sort!\n  return\
    \ nil if lst.empty?\n  smallest = nil\n  largest = nil\n  lst.each do |x|\n  \
    \  if x < 0\n      return (smallest, x) unless smallest\n      smallest = x\n\
    \    else\n      return (largest, x)  unless largest\n      largest = x\n    end\n\
    \  end\n  return (smallest, largest)\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    This is not what the question asks, I think. He wants to find the two values with\
    \ the smallest and largest values in a single array without sorting it.\n<|/ c\
    \ |>\n<| c |>\nAh, I see what you mean.\n<|/ c |>\n<| a dscore=1 |>\nYou can solve\
    \ this with O(n) time complexity, O(n) space complexity and O(n) additional space\
    \ complexity:\n<code>", "  min_val = nil\n  max_val = nil\n  lst.each_with_index\
    \ do |val, index|\n    if val < min_val\n      min_val = val\n    end\n    if\
    \ val > max_val\n      max_val = val\n    end\n  end\n  return(min_val, max_val)\n\
    end", "  # Write your function body here.\n  arr.sort.reverse_each.with_index.reduce\
    \ do |(a, b), i| \n    if i.odd?\n      a\n    else\n      b\n    end\n  end\n\
    end\nlargest_smallest_integers([0, 1, 2, 3, 4, 5, 6, 7]).should == [0, 2, 3, 4,\
    \ 5, 6, 7]\nlargest_smallest_integers([1, 4, 2]).should == [1, 2]\nlargest_smallest_integers([3,\
    \ -4, 0, 3, -2, 3, 5]).should == [-4, 2, 3]\nlargest_smallest_integers([-4, -1,\
    \ 2, 5, 3, 0]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([5, -4, -1,\
    \ 2, 5, 3, 0]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([-1, 2, 5,\
    \ 3, 4, -0]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, -4, -1, 2,\
    \ 5, 3, 0]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, 2,\
    \ 5, 3, 0]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, -2,\
    \ 5, 3, 0]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, -2,\
    \ 5, 3, -0]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, -2,\
    \ 5, 3, 1]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, -2,\
    \ 5, 3, -1]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, -2,\
    \ 5, 3, 5]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, -2,\
    \ 5, 3, -1]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, -2,\
    \ 5, 3, -0]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, -2,\
    \ 5, 3, 1]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, -2,\
    \ 5, 3, 0]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, -2,\
    \ 5, 3, 6]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, -2,\
    \ 5, 3, -2]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, -2,\
    \ 5, 3, 7]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, -2,\
    \ 5, 3, 6]).should == [-4, -1, 2, 3]\nlargest_smallest_integers([7, 4, -1, -2,\
    \ 5, 3, 1]", "  if lst.empty?\n    (nil, nil)\n  else\n    largest_smallest_integers(lst.tail)\
    \ do |a, b|\n      case a\n      when nil\n        if b < 0\n          (a, b)\n\
    \        else\n          (a, -b)\n        end\n      when Integer\n        if\
    \ b < 0\n          nil\n        else\n          (a, b)\n        end\n      else\n\
    \        if b < 0\n          a\n        else\n          b\n        end\n     \
    \ end\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| a\
    \ tags=ruby,arrays,algorithm |>\n<code>\na = [4,1,3,5,7]\np a.each_cons(2).map{|a,b|\
    \ [a,b].max }", "    # initialize variables\n    min_int = 99999999\n    max_int\
    \ = -99999999\n    # loop through the list and save the min and max values\n \
    \   for x in lst\n        if x < min_int\n            min_int = x\n        if\
    \ x > max_int\n            max_int = x\n    return (max_int, min_int)\n</cell>\n\
    <text>\nProblem 3\nBy using the function largest_smallest_integers, write a function\
    \ to sum all the integers in a list. For example, if your list was [1, 2, 3, -4,\
    \ -5, -10, 5] your function should return 190.", "  largest_integer = None\n \
    \ smallest_integer = None\n  smallest_int_index = 0\n  largest_int_index = 0\n\
    \  lst.each_with_index do |element, i|\n    if element < 0\n      smallest_integer\
    \ = element\n      smallest_int_index = i\n    elsif element > 0\n      largest_integer\
    \ = element\n      largest_int_index = i\n    end\n  end\n  return smallest_integer,\
    \ largest_integer\nend", "  smallest = nil\n  largest = nil", "  smallest = nil\n\
    \  largest = nil\n  lst.each do |el|\n    next if el.nil?\n    next if el < 0\n\
    \    next if el > largest\n    next if el > smallest\n    smallest = el\n    largest\
    \ = el\n  end\n  return (smallest, largest)\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| a |>\nI came up with two ways of doing the same thing.\n<code>", "  lst.select\
    \ { |i| i.to_i > 0 }.reduce(:<=>)\nend", "  if lst.all? { |x| x >= 0 }\n    (lst.max/lst.min,\
    \ lst.min)\n  else\n    (None, None)\n  end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 tags=algorithm,ruby,sorting,arrays |>\nHere is an answer with O(n\
    \ log n) complexity\n<code>", "  largest_integer = nil\n  smallest_integer = nil\n\
    \  \n  lst.each do |i|\n    next unless i.to_i > 0 \n    largest_integer = i if\
    \ i.to_i > largest_integer.to_i \n    smallest_integer = i if i.to_i < smallest_integer.to_i\
    \ \n  end\n  return largest_integer, smallest_integer if largest_integer && smallest_integer\
    \ \nend", "  return largest_smallest_integer(lst, 0) if lst.size > 0 \n  return\
    \ largest_smallest_integer(lst, 1) if lst.size <= 0 \n  return None, None\nend\n\
    </code>\nThe return statement checks the size of the list, then returns one of\
    \ the three values as appropriate. The largest_smallest_integer is a recursive\
    \ function which takes the original list and the smallest integer and returns\
    \ the largest or the smallest as appropriate. \nThis function is extremely inefficient\
    \ and will slow the program down, especially for large lists. To speed it up,\
    \ you should write two functions largest_smallest_integer() and largest_smallest_integer_if_none(lst,\
    \ i) that operate on the same list and the smallest integer. They should return\
    \ either the smallest or the largest integer in the list, respectively. And then\
    \ use an index variable i in the function largest_smallest_integer_if_none(lst,\
    \ i) to track the current index. Then, instead of calling largest_smallest_integer(lst),\
    \ call largest_smallest_integer_if_none(lst, i). Using this strategy will cut\
    \ down the execution time of the function largest_smallest_integer(lst) significantly.\n\
    The program should look like this:\n<code>", "  return lst.find { |x| x < 0 }\
    \ == nil ? [None, -1] : lst.find { |x| x > 0 } == nil ? [None, 1] : [largest_smallest_integers(lst.drop(largest_smallest_integers(lst).first)),\
    \ largest_smallest_integers(lst.reverse_each{ |x| x.abs }).first]\nend", "  largest_negative_integer\
    \ = nil\n  smallest_positive_integer = nil\n  lst.each do |num|\n    if num <\
    \ 0\n      largest_negative_integer = num\n    elsif num > 0\n      smallest_positive_integer\
    \ = num\n    end\n  end", "  smallest = nil\n  largest = nil\n  lst.each do |number|\n\
    \    if number < smallest then smallest = number end\n    if number > largest\
    \ then largest = number end\n  end\n  return [smallest, largest] if smallest and\
    \ largest\n  return [smallest, largest]\nend\n</code>\n<|/ a tags=ruby,sorting\
    \ |>\n<| c |>\nIt would be more idiomatic to use `min` and `max` than `each` and\
    \ then `if`. The `if` could be replaced with `return [min, max] if min` and `return\
    \ [min, max] if max`\n<|/ c |>\n<| c |>\nI prefer not to use each since it creates\
    \ lots of intermediate objects, and that seems unnecessary. Plus, if the list\
    \ is empty, min and max will still be nil, which is a valid return value.\n<|/\
    \ c |>\n<| c |>\nI do not agree with your statement that `min` and `max` will\
    \ always return nil if the list is empty. `min` and `max` will raise an error\
    \ if called on an empty array. Also, `min` and `max` are the Ruby idiomatic solution\
    \ for this problem. Perhaps you can post your own answer demonstrating the `min`\
    \ and `max` solution, since you seem to have found it first.\n<|/ c |>\n<| c |>\n\
    I did find your solution and it solves my problem. Thanks.\n<|/ c |>\n<| c |>\n\
    Thanks for your response. I was thinking of using \"min\" and \"max\" but I was\
    \ having trouble with the syntax when doing so. I ended up writing my own functions\
    \ to solve this problem.\n<|/ c |>\n<| a tags=ruby,sorting |>\n<code>", "  largest_integer\
    \ = nil\n  smallest_integer = nil\n  lst.each do |integer|\n    smallest_integer\
    \ = integer if integer < smallest_integer\n    largest_integer = integer if integer\
    \ > largest_integer\n  end\n  return largest_integer, smallest_integer\nend",
  "  min_int = nil\n  max_int = nil\n  lst.each do |i|\n    if i.to_i < min_int\n\
    \      min_int = i.to_i\n    elsif i.to_i > max_int\n      max_int = i.to_i\n\
    \    end\n  end\n  return [max_int, min_int] if max_int && min_int\nend", "  positive\
    \ = []\n  negative = []\n  lst.each do |number|\n    if number >= 0\n      positive.push(number)\n\
    \    elsif number < 0\n      negative.push(number)\n    else\n      return (None,\
    \ None)\n    end\n  end\n  return (max(positive), min(negative))\nend", "  smallest_negative\
    \ = nil\n  largest = nil\n  lst.each do |num|\n    if num < 0\n      smallest_negative\
    \ ||= num\n    elsif num > 0\n      largest ||= num\n    end\n  end\n  [smallest_negative,\
    \ largest]\nend", "  smallest_integer = nil\n  largest_integer = nil\n  if lst.empty?\n\
    \    return (nil, nil)\n  end\n  lst.each do |x|\n    if x.to_i < smallest_integer.to_i\n\
    \      smallest_integer = x\n    end\n    if x.to_i > largest_integer.to_i\n \
    \     largest_integer = x\n    end\n  end\n  return [smallest_integer, largest_integer]\n\
    end", "    \n    # Find the largest negative\n    largest_num = -lst[0]", "  \
    \  largest_positive_integer = nil\n    largest_negative_integer = nil\n    smallest_positive_integer\
    \ = nil\n    smallest_negative_integer = nil\n    lst.each do |i|\n      if i\
    \ < 0\n        largest_positive_integer = i\n      elsif i> 0\n        largest_negative_integer\
    \ = i\n      elsif i == nil\n        smallest_negative_integer = i\n      else\n\
    \        smallest_positive_integer = i\n      end\n    end\n    return largest_positive_integer,\
    \ largest_negative_integer, smallest_positive_integer, smallest_negative_integer\n\
    end", "  n = lst.max\n  min = 0\n  largest_number = nil\n  smallest_number = nil\n\
    \  largest_number, smallest_number = lst.sort do |a, b|\n    next a if a.zero?\
    \ || (a > n && b.zero?)\n    next b if b.zero? || (a > n && b.zero?)\n    if a\
    \ > n\n      a.abs\n    end\n    if b > n\n      b.abs\n    end\n    if a.abs\
    \ > b.abs\n      a\n    elsif b.abs > a.abs\n      b\n    else\n      a.abs\n\
    \    end\n  end\n  [largest_number, smallest_number]\nend", "  smallest = nil\n\
    \  largest = nil\n  lst.each do |i|\n    if i.is_a? Integer\n      if i.negative?\n\
    \        smallest = i\n      else\n        largest = i\n      end\n    else\n\
    \      return (None, None)\n    end\n  end\n  return (smallest, largest)\nend",
  "  lst.sort!\n  if lst.empty? then\n    (None, None)\n  elsif lst.min < 0 then\n\
    \    (0, lst.min)\n  else\n    (lst.max, lst.max)\n  end\nend", "  min, max =\
    \ list[0], list[0]\n  lst.each { |n|\n    min = n < min ? n : min\n    max = n\
    \ > max ? n : max\n  }\n  max = -max\n  [min, max]\nend", "    positive = []\n\
    \    negative = []\n    count = 0\n    while count < lst.count\n        if lst[count]\
    \ >= 0\n            negative << lst[count]\n        elsif lst[count] < 0\n   \
    \         positive << lst[count]\n        end\n        count += 1\n    return\
    \ negative.max, positive.min if positive != [] else None\nend", "  lst.sort!\n\
    \  first  = lst[0]\n  last = lst[-1]\n  return first, last\nend", "    # Initialize\
    \ max_val and min_val to\n    # the first elements in the lists.\n    # If the\
    \ lists are empty, return as (None, None)\n    max_val = min_val = lst[0]\n  \
    \  # Return first tuple (max_val, min_val) if list is not empty\n    return max_val,\
    \ min_val if lst.size > 0\nend", "  return lst.sort.each_cons(2).map {|a,b| a.nil?\
    \ ? (b.nil? ? nil : b) : (b ? b : a) } .first\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis is not the same as the accepted answer. Your solution will output\
    \ `[1, 7, 3, -1]` instead of `[-1, 7, 3, 1]`\n<|/ c |>\n<| c |>\nI don't see what\
    \ you're saying. If you're talking about `[-1, 7, 3, 1]`, then that's a bug in\
    \ the `largest_smallest_integers` function. According to Wikipedia, it shouldn't\
    \ return the negative integers as the first element. [Wikipedia](https://en.wikipedia.org/wiki/Largest-smallest_ordering)\n\
    <|/ c |>\n<| a tags=sorting,ruby,algorithm |>\nAnother way to do it:\n<code>",
  "  if lst.empty?\n    (None, None)\n  elsif lst.all?(&:zero?)\n    largest_smallest_integers(lst.drop(1))\n\
    \  elsif lst.any?(&:zero?)\n    largest_smallest_integers(lst.take_while { |x|\
    \ x < 0 })\n  else\n    (lst.max_by { |x| x.abs }, lst.min_by { |x| x.abs })\n\
    \  end\nend", "  lst.each_with_index { |n, i| return (n if n < 0) else (i if n\
    \ >= 0) }\nend\n</code>\nThis also uses the each_with_index method provided by\
    \ Enumerable (which Enumerable provides in Ruby 1.9 and above, Enumerable is available\
    \ in Ruby 1.8 too). When we call this method, it iterates through your list and\
    \ returns two values: the first item in the list and the index of the current\
    \ item. The return value is used to determine the condition to check whether an\
    \ item is negative or positive and return the largest or smallest one.\n<|/ a\
    \ |>\n<| c |>\nThanks for your answer. I'd like to point out that you don't need\
    \ to make two passes through the array. Your solution is O(n*2).\n<|/ c |>\n<|\
    \ c |>\nYou are right. I didn't consider that. I did change my answer to include\
    \ a better solution. I didn't think about it at first. Thanks!\n<|/ c |>\n<| a\
    \ |>\nThis is a bit more concise than Michal's, but it only works on integers,\
    \ because it doesn't use max_by or the like.\n<code>", "  min_value = nil\n  max_value\
    \ = nil\n  lst.each do |n|\n    if n < 0\n      min_value = n\n    else\n    \
    \  max_value = n\n    end\n  end\n  return min_value, max_value if min_value &&\
    \ max_value\n  return nil, nil if lst.empty?\n  raise \"No positive and no negative\
    \ integers found.\" if min_value == max_value\n  raise \"No positive and no negative\
    \ integers found.\" if min_value < 0\n  raise \"No positive and no negative integers\
    \ found.\" if max_value < 0\nend", "  # Write your code here.\n  raise NotImplementedError()\n\
    end", "  return lst.max_by {|i| ((i < 0) || (i >= 0)).to_a}\nend", "  largest\
    \ = nil\n  smallest = nil\n  lst.each_with_index do |n, index|\n    if n < 0\n\
    \      next unless index < largest.size # already searched this index\n      largest\
    \ = index\n    end\n    if n > 0\n      next unless index < smallest.size # already\
    \ searched this index\n      smallest = index\n    end\n  end\n  [smallest, largest]\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI wonder what this is going to be faster than\
    \ `largest_smallest_integers(lst.sort { |a,b| b.to_i <=> a.to_i })`\n<|/ c |>\n\
    <| c |>\nI wouldn't know how `sort` will do it, but this answer shows how to do\
    \ it without it, which is what I was asking. I don't know how to do it with sort.\n\
    <|/ c |>\n<| c |>\n`sort` would have to sort the whole list, which can be quite\
    \ slow (O(n*log(n))).\n<|/ c |>\n<| a |>\n<code>", "  smallest = nil\n  largest\
    \ = nil\n  lst.each do |item|\n    if item < smallest \n      smallest = item\n\
    \    elsif item > largest\n      largest = item\n    end\n  end\n  [smallest,\
    \ largest]\nend", "  largest_positive_integer = nil\n  smallest_negative_integer\
    \ = nil\n  lst.each_with_index do |el, i|\n    if el < 0\n      smallest_negative_integer\
    \ = i\n    else\n      largest_positive_integer = i\n    end\n  end\n  return\
    \ [smallest_negative_integer, largest_positive_integer]\nend", "  min_val = lst.min\n\
    \  max_val = lst.max\n  return [min_val, max_val] if min_val > max_val else [max_val,\
    \ min_val] if min_val == max_val else None\n  ", "    largest_integer = 0\n  \
    \  smallest_integer = None\n    largest_negative_number = 0\n    smallest_positive_number\
    \ = None\n    largest_negative_number_count = 0\n    smallest_positive_number_count\
    \ = 0\n    for value in lst\n        if value < 0 and\n            largest_negative_number\
    \ < value and\n            smallest_integer == 0 and\n            largest_negative_number_count\
    \ < 1\n        then\n            largest_negative_number = value\n           \
    \ smallest_integer = value\n            largest_negative_number_count = largest_negative_number_count\
    \ + 1\n        elsif value > 0 and\n            smallest_integer == None and\n\
    \            smallest_positive_number_count < 1\n        then\n            smallest_integer\
    \ = value\n            smallest_positive_number = value\n            smallest_positive_number_count\
    \ = smallest_positive_number_count + 1\n        end\n    end\n    return largest_integer,\
    \ smallest_integer\nend\n</code>\n<|/ a tags=ruby,algorithm,recursion |>\n<| c\
    \ |>\nWow, this is an amazing solution! Thank you so much! I'll try to adapt it\
    \ for my problem!\n<|/ c |>\n<| c |>\nOk great, let me know if you get stuck somewhere\
    \ and I'll do my best to help you out!\n<|/ c |>\n<| c |>\nI've refactored my\
    \ original solution to eliminate the `if` statements (by using a separate array\
    \ of positive numbers, as I didn't want to modify my original function and just\
    \ wanted to focus on efficiency of different approaches). Now all I have to do\
    \ is, find the greatest negative number and smallest positive number in the array\
    \ and return the result in a tuple. I added this solution to the end of my original\
    \ post. Would you mind taking a look? I really appreciate it!\n<|/ c |>\n<| c\
    \ |>\nYeah, that would work! I would definitely refactor my answer if I were you!\
    \ Glad it helped though! :)\n<|/ c |>\n<| c |>\nI've refactored my answer to include\
    \ a solution that doesn't modify the original array and that returns only a tuple\
    \ with two integers.\n<|/ c |>\n<| a |>\nI think your code is good enough. Maybe\
    \ you could use two variables for the largest negative and smallest positive number\
    \ in a given array.\n<|/ a tags=ruby,algorithm,recursion dscore=0 |>\n<| c |>\n\
    Hi, thanks for your answer! I know I can do it this way but I would really like\
    \ to know how to do it with recursion. I tried doing it by adding some extra variables\
    \ but for some reason", "  smallest, largest = nil, 0\n  lst.each do |x|\n   \
    \ smallest = nil if smallest.nil?\n    largest = 0 if largest.zero?\n    if x\
    \ < smallest\n      smallest = x\n    elsif x > largest\n      largest = x\n \
    \   end\n  end\n  [smallest, largest]\nend\n</cell>\n<cell>", "  lst.sort!\n \
    \ a, b = nil, nil\n  lst.each do |x|\n    if x.is_a?(Integer)\n      a = x if\
    \ x < 0\n      b = x if x > 0\n    else\n      (a, b) = (x, None) if x < 0\n \
    \     (a, b) = (None, x) if x > 0\n    end\n  end\n  (a, b) if a && b\nend\n</code>\n\
    <|/ a |>\n<| a |>\n<code>", "  largest_integer = nil\n  smallest_integer = nil\n\
    \  lst.each do |integer|\n    if integer < 0\n      largest_integer = integer\n\
    \    elsif integer > 0\n      smallest_integer = integer\n    end\n  end\n  return\
    \ largest_integer, smallest_integer\nend", "  positive_values = lst.select { |i|\
    \ i > 0 }\n  negative_values = lst.select { |i| i < 0 }", "  result = nil\n  if\
    \ lst.empty?\n    (result, result)\n  else\n    # Sort by descending order\n \
    \   lst = lst.sort\n    # Go through all elements\n    lst.each do |element|\n\
    \      # If the value is negative, add it to the result tuple\n      if element.negative?\n\
    \        (result, element)\n      else\n        # Otherwise, if the value is positive,\
    \ break\n        # out of the loop\n        if element.positive?\n          break\n\
    \        end\n      end\n    end\n  end\nend", "  smallest = nil\n  largest =\
    \ nil\n  lst.each do |num|\n    if num < smallest or smallest.nil?\n      smallest\
    \ = num\n    elsif num > largest or largest.nil?\n      largest = num\n    end\n\
    \  end\n  if smallest and largest\n    [smallest, largest]\n  else\n    [smallest,\
    \ largest]\n  end\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThanks, I was trying\
    \ to do it with one line :)\n<|/ c |>\n<| c |>\n, Your `else` statement is redundant.\
    \  You already checked if `largest != nil`, so if it is not `nil` you are done.\n\
    <|/ c |>\n<| c |>\n: This code also fails with an empty list.  So if you're doing\
    \ something different, you should check `if !lst.empty?`, too.\n<|/ c |>\n<| c\
    \ |>\n, Yes, I agree with you but wanted to keep it simple. Although you are right\
    \ about empty list but that's something OP can figure out and solve\n<|/ c |>\n\
    <| c |>\n: I was surprised to learn that empty lists behave like nil in Ruby 1.9.2!\
    \  I thought they didn't behave like nil in 1.8.7.  Thanks for pointing that out!\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>", "  # Write your solution here.\n  largest_negative\
    \ = nil\n  largest_positive = nil\n  smallst_negative = nil\n  smallst_positive\
    \ = nil\n  \n  lst.each_with_index do |elt, i|\n    if elt < 0 \n      if largest_negative\
    \ == nil\n        largest_negative = elt\n      else\n        largest_negative\
    \ = elt.to_i\n      end\n    end\n    if elt > 0 \n      if largest_positive ==\
    \ nil\n        largest_positive = elt\n      else\n        largest_positive =\
    \ elt.to_i\n      end\n    end\n    if elt < 0\n      if smallst_negative == nil\n\
    \        smallst_negative = elt\n      else\n        smallst_negative = elt.to_i\n\
    \      end\n    end\n    if elt > 0\n      if smallst_positive == nil\n      \
    \  smallst_positive = elt\n      else\n        smallst_positive = elt.to_i\n \
    \     end\n    end\n  end\n  return largest_negative, largest_positive unless\
    \ largest_negative == nil\n  return largest_positive, largest_negative unless\
    \ largest_positive == nil\n  return smallst_negative, smallst_positive unless\
    \ smallst_negative == nil\n  return smallst_positive, smallst_negative unless\
    \ smallst_positive == nil\nend", "  lst.each do |number|\n    if number > -number\n\
    \      return (number, -number)\n    end\n  end\n  return (None, None)\nend",
  "  if lst.empty?\n    []\n  else\n    smallest, largest = lst.minmax\n    (smallest_integer\
    \ if smallest > 0 else nil,\n     largest_integer if largest < 0 || (largest >=\
    \ 0 && (largest < smallest || largest < 0))\n    )\n  end\nend\n</code>\n<|/ a\
    \ |>\n<| a |>\nHere's my attempt at a more concise solution:\n<code>", "  # Write\
    \ your code here.\n  largest_number = nil\n  smallest_number = nil\n  lst.each\
    \ do |num|\n    if num > largest_number\n      largest_number = num\n    elsif\
    \ num < smallest_number\n      smallest_number = num\n    end\n  end\n  [largest_number,\
    \ smallest_number]\nend\n</cell>\n<text>\nNow we can use our function in other\
    \ parts of our program. For example, we can print out the largest negative integer\
    \ in the list:", "  return (lst.sort.max,lst.sort.min)\nend", "  # Your code here\n\
    \  return nil if lst.empty? # or return\n  a = lst.sort\n  if a.first < 0\n  \
    \  b = a.last\n  elsif a.last > 0\n    b = a.first\n  else\n    b = nil\n  end\n\
    \  return a, b\nend\n</code>\n<|/ a tags=ruby,arrays dscore=0 |>\n<| c |>\nI don't\
    \ think it works for the given example, it returns `[1, 7, 2, 3]` as answer: `(a:\
    \ 3, b: 2)`\n<|/ c |>\n<| c |>\nI tested it with your test cases, and the code\
    \ works as expected: `largest_smallest_integers([1, 2, 3, 4, 5, 6, 7, 8, 9]) =>\
    \ (a: 7, b: 8)`. I'm pretty sure it does work. Try it out with `[2,4,1,3,4,5]`.\n\
    <|/ c |>\n<| c |>\nMy bad, it does not work in the given test cases, my mistake.\
    \ I tested it again and you are correct. I'll fix my answer.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  lst.each do |n|\n    if n < 0\n      return (n, -lst.max)\n\
    \    elsif n > 0\n      return (-lst.min, n)\n    end\n  end\nend", "  result\
    \ = (None, None)\n  lst.each do |x|\n    if x > 0 && x < 100\n      if result[0]\
    \ && result[1] > x\n        result = (x, result[1])\n      end\n    end\n  end\n\
    \  result\nend", "  smallest_value = nil\n  largest_value = nil", "  lst.sort!\n\
    \  if lst.count < 2\n    [None, None]\n  else\n    big, small = lst.max, lst.min\n\
    \    big.nil? ? [None, small] : [small, big]\n  end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a dscore=0 tags=ruby,arrays |>\n<code>", "  return largest_smallest_integer(\
    \ lst, 0 ) if lst.size < 1 else {\n    smallest_integer( lst, 0 ) if lst[0] <\
    \ 0 else {\n      largest_integer( lst, 0 ) if lst[0] > 0 else {\n        largest_smallest_integer(\
    \ lst, 1 )\n      }\n    }\n  }\nend", "  largest_negative_integer = nil\n  smallest_positive_integer\
    \ = nil\n  smallest_negative_integer = nil\n  largest_positive_integer = nil\n\
    \  for i in lst\n    if i.negative?\n      smallest_negative_integer = i\n   \
    \ elsif i.positive?\n      largest_positive_integer = i\n    else\n      smallest_positive_integer\
    \ = i\n      largest_negative_integer = i\n    end\n  end\n  return [largest_negative_integer,\
    \ smallest_positive_integer]\nend", "  # Write your code here.\nend", "  if lst.empty?\n\
    \    (None, None)\n  else\n    positive_integer_list = lst.select { |x| x.to_i\
    \ > 0 }\n    negative_integer_list = lst.select { |x| x.to_i < 0 }", "  lst.each\
    \ do |num|\n    break if num < 0\n    break if num > 0\n  end\n  return (num <\
    \ 0 ? nil : num), num if num > 0\n  return nil, num if num < 0\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a tags=ruby |>\nThe fastest possible way is to use Enumerable#min_by.\n\
    <code>\n[1,2,3,5,8,13].min_by(5) { |n| n < 0 ? n : nil }", "  if lst.nil?\n  \
    \  (None, None)\n  elsif lst.empty?\n    (None, None)\n  else\n    max = lst.max\n\
    \    min = lst.min\n    (max, min) if min > max\n  end\nend", "  min = 1\n  max\
    \ = 0\n  lst.each do |x|\n    if x < min\n      min = x\n    elsif x > max\n \
    \     max = x\n    end\n  end\n  return (min,max)\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\n`a.max(b).min` should return `1` here when `a = [5]` and `b = [1]`\n\
    <|/ c |>\n<| c |>\nI believe this may be what you're looking for? https://stackoverflow.com/a/56569703/2433539\n\
    <|/ c |>\n<| a |>\nThis is also an interesting problem. It can certainly be solved\
    \ with recursion. \n<code>", "  smallest = nil\n  largest = nil\n  lst.each do\
    \ |i|\n    if i < 0\n      smallest = nil\n    else\n      smallest = i\n    end\n\
    \    if i > largest\n      largest = i\n    end\n  end\n  smallest, largest\n\
    end", "  biggest = smallest = nil\n  lst.each do |item|\n    if item.negative?\n\
    \      biggest = item\n    elsif item.positive?\n      smallest = item\n    else\n\
    \      break\n    end\n  end\n  return biggest, smallest if biggest && smallest\n\
    \  biggest, smallest = nil, nil\n  lst.each do |item|\n    biggest = biggest ||\
    \ item if item.negative?\n    smallest = smallest || item if item.positive?\n\
    \  end\n  return biggest, smallest if biggest && smallest\n  return nil, nil\n\
    end", "  smallest_num = nil\n  largest_num = nil", "  return [largest_integer(lst),\
    \ smallest_integer(lst)] if lst else [None, None]\nend", "    \n    smallest,largest\
    \ = lst[0],lst[0]\n    \n    for i in lst:\n        if i < largest:\n        \
    \    largest = i\n        elif i > smallest:\n            smallest = i\n    \n\
    \    return (smallest, largest) if smallest >= largest else (None, None)\n   \
    \     \nprint(largest_smallest_integers([2, 4, 1, 3, 5, 7]))\nprint(largest_smallest_integers([]))\n\
    print(largest_smallest_integers([0]))\n</cell>\n<cell>", "  return [max_negative_integer(lst),\
    \ min_positive_integer(lst)]\nend", "  if lst.empty?\n    (None, None)\n  else\n\
    \    largest_integer = lst.max\n    smallest_integer = lst.min\n    if largest_integer\
    \ <= smallest_integer\n      (largest_integer, smallest_integer)\n    else\n \
    \     (largest_integer, smallest_integer)\n    end\n  end\nend", "  lst.sort\n\
    \  if lst[-1] < 0 \n    smallest = lst.pop\n  elsif lst[0] >= 0 \n    largest\
    \ = lst.pop\n  end\n  return(smallest, largest) if lst.length > 0\nend\n</code>\n\
    A more Rubyish way to do this:\n<code>", "  if lst.empty?\n    return (None, None)\n\
    \  m = lst.max\n  m = lst.min\n  if m > -Float::INFINITY\n    a = lst.sort\n \
    \   a.find { |i| i > m }\n  else\n    a = lst.sort\n    a.find { |i| i < m }\n\
    \  end\nend\n</code>\n<|/ a dscore=4 |>\n<| a |>\nHere's a solution with O(n)\
    \ complexity and uses Ruby's builtin sort method. \n<code>", "  lst.sort!\n  smallest,\
    \ largest = lst[0], lst[-1]\n  while smallest < largest && lst.any?\n    (smallest,\
    \ largest) = lst.minmax\n  end\n  return smallest, largest\nend", "  smaller =\
    \ []\n  larger = []\n  i = nil\n  for i in lst\n    if i < 0\n      smaller[i]\
    \ = i\n    elsif i > 0 \n      larger[i] = i\n    else\n      smaller[i] = nil\n\
    \      larger[i] = nil\n    end\n  end\n  if smaller[0] == nil\n    return larger\n\
    \  elsif larger[0] == nil\n    return smaller\n  else\n    return (largest_smallest_integers(smaller),\
    \ smaller[0])\n  end\nend", "  smallest_positive = []\n  smallest_negative = []",
  "  smallest, largest = lst.minmax\n  if smallest > largest then\n    (smallest,\
    \ largest) = largest, smallest\n  end\n  if smallest == largest\n    (smallest,\
    \ largest) = (smallest, smallest)\n  end\n  return smallest, largest\nend", " \
    \ smallest_integer = nil\n  largest_integer = nil\n  largest_smallest_integers_helper([],\
    \ lst, smallest_integer, largest_integer)\n  largest_integer\nend", "  smallest\
    \ = nil\n  largest = nil\n  lst.each do |e|\n    if e.is_a?(Integer)\n      if\
    \ smallest == nil || e < smallest\n        smallest = e\n      elsif e > largest\n\
    \        largest = e\n      end\n    end\n  end\n  return [smallest, largest]\
    \ if smallest != nil and largest != nil\n  return [nil, nil] if lst.empty?\nend\n\
    </code>\n<|/ a dscore=2 tags=ruby |>\n<| a dscore=1 tags=ruby |>\nYou can do this\
    \ in O(1) time with a little bit of array logic.  First you need to define an\
    \ indexing scheme for the \"positive numbers\".  Let's say that the positive numbers\
    \ are in the first half of the array, and the negative numbers are in the second\
    \ half.  Then you can define an array of pairs whose first value is their index,\
    \ and the second value is whether or not that index is positive.  Then you can\
    \ just do an index lookup to find out whether each value is positive or negative.\n\
    <code>", "  int_list = lst.map { |x| x.to_i }\n  if int_list.all?(&:zero?)\n \
    \   [None, int_list.min]\n  elsif int_list.all?(&:positive?)\n    [int_list.max,\
    \ None]\n  else\n    [int_list.min, int_list.max]\n  end\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThe function `largest_smallest_integers` is more concise than the\
    \ `sort_by` solution.  It was also quite helpful for me to understand this answer.\n\
    <|/ c |>\n<| a dscore=2 tags=ruby,sorting,arrays |>\nThe most concise solutions\
    \ use Array#sort_by.  Here's a solution using sort_by.  The reason this works\
    \ is that sort_by works on a block that returns -1 or 1 or 0 depending on whether\
    \ the element should be in the first or second or third spot.\n<code>", "  # Sort\
    \ list into descending order of the numbers\n  lst.sort!", "  largest_number=0\n\
    \  smallest_number=Float::INFINITY\n  lst.each do |integer|\n    if integer <\
    \ 0 \n      smallest_number=integer\n    elsif integer > largest_number\n    \
    \  largest_number=integer\n    end\n  end\n  return largest_number,smallest_number\n\
    end", "  return lst.find { |x| x.to_i >= 0 } || lst.find { |x| x.to_i <= 0 } ?\
    \ [x.to_i, -x.to_i] : nil\nend", "  lst.inject({}) { |hash, e| hash.merge(e =>\
    \ [hash[e] ||= 0, e < 0 ? -hash[e] : hash[e]]) }\n  lst.map { |e| [e < 0 ? -e\
    \ : e, hash[e]] }.max_by { |e| e[1]}\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ dscore=2 |>\nHere is a generic solution:\n<code>", "    # check if there are\
    \ any integers\n    if lst.empty?\n        return None, None\n    min = max =\
    \ lst.first\n    # find max and min of the list\n    lst.each do |item|\n    \
    \    if item < min\n            min = item\n        end\n        if item > max\n\
    \            max = item\n        end\n    end\n    (a, b) = (max, min) if max\
    \ > min\n    return a, b\nend\n</code>\n<|/ a tags=algorithm,ruby,sorting,arrays,sorting\
    \ |>\n<| c |>\n`max_positive` and `max_negative` can be combined into just `max_negative`\
    \ - no need for the unnecessary extra variables :)\n<|/ c |>\n<| c |>\nNot sure\
    \ what the advantage of having a separate function over using `max_negative` would\
    \ be, but it does allow for refactoring in the future.\n<|/ c |>\n<| c |>\nI guess\
    \ this approach assumes that all numbers are positive.\n<|/ c |>\n<| a dscore=2\
    \ |>\nThe approach that works for all cases:", "  smallest = nil\n  largest =\
    \ nil", "  if lst.empty?\n    (nil, nil)\n  else\n    max = lst.first\n    min\
    \ = lst.last\n    lst.drop(1).each do |i|\n      if i.to_i < min.to_i\n      \
    \  min = i\n      end\n      if i.to_i > max.to_i\n        max = i\n      end\n\
    \    end\n    (nil, min) if min.nil?\n    (nil, max) if max.nil?\n  end\nend",
  "  max_i = nil\n  min_i = 0\n  lst.each do |i|\n    if i.negative? || i.zero?\n\
    \      return (i, nil)\n    end\n    if i.positive?\n      if i.negative? && min_i\
    \ <= 0\n        min_i = i\n      elsif min_i > 0 && max_i.positive?\n        max_i\
    \ = i\n      end\n    end\n  end\n  return [max_i, min_i]\nend", "  if lst.empty?\n\
    \    return None, None\n  largest, smallest = lst.max, lst.min\n  lst.delete_if\
    \ do |e|\n    e = e.to_i\n    largest = e if e > largest\n    smallest = e if\
    \ e < smallest\n  end\n  return smallest, largest\nend", "  if lst.empty?\n  \
    \  return None, None\n  lst.sort!\n  min, max = lst.min, lst.max\n  \n  if min\
    \ <= 0\n    min, max = (max, min) if max < 0 else None\n  elsif max > 0\n    min,\
    \ max = (max, min) if max < 0 else None\n  end\n  return min, max\nend", "  if\
    \ lst.empty?\n    (None, None)\n  elsif lst.all?\n    smallest = lst.min\n   \
    \ largest = lst.max\n    (smallest, largest)\n  else\n    largest = lst.min\n\
    \    smallest = lst.max\n    smallest.upto(largest) { |n| break if n < smallest.last\
    \ }\n    (smallest, largest)\n  end\nend", "  # Write your code here.\n  # Hint:\
    \ use min_by, max_by and sort\n  \n  lst.min_by {|x| -x}\nend", "  result = nil\n\
    \  smallest_integer = nil\n  largest_integer = nil\n  lst.each do |i|\n    if\
    \ i.negative?\n      result =(i)\n    elsif i.positive?\n      largest_integer\
    \ = i\n    else\n      if result.nil?\n        smallest_integer = i\n      else\n\
    \        if result.negative?\n          smallest_integer = i\n        else\n \
    \         smallest_integer = result\n          largest_integer = i\n        end\n\
    \      end\n    end\n  end\n  [smallest_integer, largest_integer]\nend", "  largest\
    \ = nil\n  smallest = nil\n  arr.each do |x|\n    el = x\n    if el < 0\n    \
    \  if largest == nil\n        largest = x\n      else\n        largest = nil\n\
    \        smallest = nil\n      end\n    el > 0\n      if smallest == nil\n   \
    \     smallest = x\n      else\n        smallest = nil\n        largest = nil\n\
    \      end\n    end\n  end\n  return [smallest, largest]\nend\n</cell>\n<code\
    \ language=conda-env-adventofcode-py>\nlargest_smallest_integers([2, 4, 4, 2,\
    \ 1, 3, 5, 7])\n</cell>\n<code language=conda-env-adventofcode-py>\nlargest_smallest_integers([])\n\
    </cell>\n<code language=conda-env-adventofcode-py>\nlargest_smallest_integers([0])\n\
    </cell>\n<code language=conda-env-adventofcode-py>\narr = [3, 8, 2, 6, 7]\narr.each\
    \ do |x|\n  el = x\n  if el < 0\n    if largest == nil\n      largest = x\n  \
    \  else\n      largest = nil\n      smallest = nil\n    end\n  el > 0\n    if\
    \ smallest == nil\n      smallest = x\n    else\n      smallest = nil\n      largest\
    \ = nil\n    end\n  end\nend\n</cell>\n<code language=conda-env-adventofcode-py>\n\
    [smallest, largest]\n</cell>\n<text>\nProblem 7", "  if lst.empty?\n    []\n \
    \ else\n    a = [lst.min]\n    b =  [lst.max]\n    (a[0] < b[0]) ? a.unshift(lst.min)\
    \ : b.unshift(lst.max)\n    a\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2\
    \ tags=arrays,ruby,minimum,max |>\nFor this simple case you can do:\n<code>",
  "  return (lst.find { |x| x < 0 }, lst.find { |x| x > 0 } || None)\nend", "  if\
    \ lst.empty?\n    (nil, nil)\n  else\n    largest_integers(lst).reverse.inject(:<=>)\
    \ do |max, (maxi, mini)|\n      maxi <=> mini if maxi <=> mini\n    end\n  end\n\
    end", "  # BEGIN Question 4\n  lst.each do |i|\n    if i < 0\n      a = i\n  \
    \    break\n    elsif i < 0\n      b = i\n      break\n    else\n      a = nil\n\
    \      b = i\n    end\n  end\n  # END Question 4\n  return a, b\nend", "  lst.sort\n\
    \  return (lst.last, lst.first)\nend", "  smallest, largest = lst.minmax_by(&:abs)\n\
    \  smallest_integer, = smallest.map { |n| n.to_i }\n  largest_integer, = largest.map\
    \ { |n| n.to_i }\n  [smallest_integer, largest_integer]\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby\
    \ dscore=1 |>\n<| c |>\nThank you for this very comprehensive answer. I just want\
    \ to point out that your answer doesn't take into account negative numbers, as\
    \ this was my main question, but I agree that this is probably the cleanest approach.\
    \ Thank you.\n<|/ c |>\n<| c |>\nSorry, the question was unclear about negative\
    \ numbers. The answer was updated to reflect the updated question.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  largest_integer = nil\n  smallest_integer = nil\n\
    \  largest_integer = nil\n  smallest_integer = nil\n  index = 0\n  while index\
    \ < lst.size do\n    if lst[index] > smallest_integer\n      smallest_integer\
    \ = lst[index]\n      largest_integer = nil\n      break\n    end\n    if lst[index]\
    \ < largest_integer\n      largest_integer = lst[index]\n      smallest_integer\
    \ = nil\n      break\n    end\n    index += 1\n  end\n  if smallest_integer ==\
    \ nil\n    (largest_integer, smallest_integer)\n  else\n    (largest_integer,\
    \ smallest_integer)\n  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\nThis is\
    \ my answer to the problem.\n<code>", "  if lst.empty?\n    (None, None)\n  else\n\
    \    largest_smallest_integer(lst, 0)\n  end\nend\n</code>\nTest the function\
    \ by calling it, and print the results\n<code>\nputs \"largest_smallest_integers(#{lst})\
    \ is\"\nputs \"(#{largest_smallest_integers(lst)}), where #{lst} is the list\"\
    \n</code>\nThe code returns nil if the list has no negative or positive integers.\n\
    <|/ a dscore=2 |>\n<| c |>\nI like it. I have not seen `max_by` or `min_by` before.\
    \ Looks like a new one. Thanks!\n<|/ c |>\n<| c |>\nHmm. I'm curious about the\
    \ `max_by`/`min_by` solution. Does it work if the list has more than one element?\
    \ What is the complexity of searching the whole list once you find all instances\
    \ of those two?\n<|/ c |>\n<| c |>\nIt only works if there is only one element.\
    \ But since it's in O(n) it's probably not too bad since it only needs to do it\
    \ once.\n<|/ c |>\n<| c |>\nI tested it by running it on a large list with millions\
    \ of elements, and it took less than 2 seconds to complete the calculation. I'm\
    \ wondering how efficient that is compared to a solution like mine. I think yours\
    \ is slightly more elegant.\n<|/ c |>\n<| c |>\nIn other words, `max_by` and `min_by`\
    \ should be O(n), whereas this solution runs in O(n^2) time.\n<|/ c |>\n<| a |>\n\
    You need a variable that tracks the last seen positive integer:\n<code>", "  max_integer\
    \ = lst.max_by { |x| x < 0 }\n  min_integer = lst.min_by { |x| x > 0 }\n  return\
    \ max_integer, min_integer if max_integer && min_integer\n  return None, None\n\
    end", "  # Get the largest value in `lst`\n  max_value = lst.max_by{ |x| x }\n\
    \  # If `max_value` is nil, return nil\n  return max_value.nil? ? nil : max_value.value\n\
    end\n</code>\n<|/ a tags=ruby-on-rails-3,ruby |>\n<| a dscore=1 tags=ruby-on-rails-3,ruby\
    \ |>\n<code>", "  largest_integer = nil\n  smallest_integer = nil\n  largest_integer_found\
    \ = nil\n  smallest_integer_found = nil", "  largest_integer = nil\n  smallest_integer\
    \ = nil\n  lst.each do |integer|\n    if (integer < 0 ) then\n      largest_integer\
    \ = integer\n    elsif (integer > 0 ) then\n      smallest_integer = integer\n\
    \    else\n      break\n    end\n  end\n  return [largest_integer, smallest_integer]\n\
    end", "  largest_negative = nil\n  smallest_positive = nil\n  largest_negative\
    \ ||= lst.max\n  smallest_positive ||= lst.min\n  (largest_negative, smallest_positive)\n\
    end", "  smallest_integer = nil\n  largest_integer = nil", "  largest_int = nil\n\
    \  smallest_int = nil\n  lst.each do |i|\n    unless i.is_a? Integer\n      return\
    \ (i, nil)\n    elsif i.is_a? Fixnum\n      return (i, nil)\n    end\n    # Look\
    \ for max/min integers\n    if i > largest_int\n      largest_int, smallest_int\
    \ = i, i\n    end\n    if i < smallest_int\n      smallest_int, largest_int =\
    \ i, i\n    end\n  end\n  return (nil, smallest_int)\nend", "  lst.each_with_index\
    \ do |num, index|\n    if num < 0\n      (lst - index - 1).max, lst - index\n\
    \    elsif num > 0\n      (lst - index).min, lst - index\n    end\n  end\nend",
  "    smallest, largest = -Infinity , +Infinity\n    integers.each do |integer|\n\
    \        smallest, largest = integer if integer > smallest or integer < largest\n\
    \    end\n    return smallest, largest if smallest != +Infinity and largest !=\
    \ -Infinity\n    return None, None\nend\n</code>\nAnd here's an alternative version\
    \ that does more:\n<code>", "  lst.sort\n  pos = lst.last(-1) if lst.any? && lst.last(-1).positive?\
    \ \n  neg = lst.first(-1) if lst.any? && lst.first(-1).negative?\n  \n  return\
    \ [pos, neg].compact if pos && neg \n  \n  return nil if lst.empty?\n  \n  [neg,\
    \ pos].each do |i|\n    next if i.nil?\n    break if i.negative? && i.positive?\
    \ && i\n    \n    return i \n  end\n  \n  raise StopIteration \nend", "  largest\
    \ = nil\n  smallest = nil\n  lst.each do |item|\n    if item > largest\n     \
    \ largest = item\n    elsif item < smallest\n      smallest = item\n    end\n\
    \  end\n  (largest, smallest)\nend", "  largest, smallest = nil, nil\n  arr.each\
    \ do |x|\n    if x < 0 && (largest == nil || x > largest)\n      largest = x\n\
    \    end\n    if x > 0 && (smallest == nil || x < smallest)\n      smallest =\
    \ x\n    end\n  end\n  return [largest, smallest]\nend", "  result = nil\n  lst.each\
    \ do |i|\n    if i.negative?\n      if result.nil?\n        result = i\n     \
    \ else\n        result = i.max(result) if result.nil? || result.zero?\n      end\n\
    \    else\n      if result.nil?\n        result = i\n      else\n        result\
    \ = i.min(result) if result.nil? || result.zero?\n      end\n    end\n  end\n\
    \  (result.nil? ? nil : result)\nend\n</code>\n<|/ a |>\n<| c |>\nThank you for\
    \ your response.  I am a beginner to Ruby and was looking for a way to perform\
    \ a basic set of tasks, like you pointed out.  I couldn't figure out how to implement\
    \ the code you provided.  I am new to coding so am still trying to grasp everything.\
    \  Thank you for your assistance.\n<|/ c |>\n<| c |>\nI wrote a small program\
    \ that performs the operations that you asked for.  It takes each of those functions\
    \ and writes them into a `.rb` file.  I then wrote a simple script to call those\
    \ functions and print their results.  You can see that in this [link](http://pastebin.com/eWVaWcjD).\
    \  You can put it all in one file if you want, or you can put it into different\
    \ files if you prefer.  I hope this helps.  Let me know if you have any questions\
    \ or issues.\n<|/ c |>\n<| c |>\nI am sorry for the long response but your response\
    \ was very helpful.  Thank you.  I really appreciate it.  I am new to programming\
    \ so I am still trying to figure out how everything works.  This was very helpful.\
    \  Thank you for your time.\n<|/ c |>\n<| c |>\nNo problem.  You can mark this\
    \ answer as accepted if you think it best answers your question, so that others\
    \ who find this page can know that the question has been answered.  Thanks.\n\
    <|/ c |>\n<| a dscore=0 tags=ruby,arrays |>\nThis is a fun exercise, and I did\
    \ it in Ruby 1.8.7.\nI started with a helper method that compares two items and\
    \ returns the larger or smaller item. I then just wrote a loop that compares the\
    \ two items from the beginning of the array. Because I'm new to Ruby, I used an\
    \ Array instead of an Enumerator.\n<code>", "  lst.each do |x|\n    if x > 0\n\
    \      return x, -x\n    end\n  end", "  smallest_integer = nil\n  largest_integer\
    \ = nil\n  lst.each do |element|\n    if element.to_i <= 0\n      smallest_integer\
    \ = element\n    elsif element.to_i >= 0\n      largest_integer = element\n  \
    \  end\n  end\n  smallest_integer, largest_integer\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis will return `(None, None)` for `largest_smallest_integers([0])` which\
    \ is `nil`. You need to return `smallest_integer, largest_integer`.\n<|/ c |>\n\
    <| c |>\nthanks for the feedback. Edited to take care of that.\n<|/ c |>\n<| c\
    \ |>\nThis returns `(None, None)` for empty lists, and `nil` for nil.\n<|/ c |>\n\
    <| c |>\nthanks for catching that. Edited to take care of the empty list case\
    \ and nil case.\n<|/ c |>\n<| c |>\nThis is not what the OP asked for, which is\
    \ to find the largest and smallest integers in the list. You're finding only the\
    \ smallest and largest integers in the first element of the list.\n<|/ c |>\n\
    <| a |>\nYou can get the maximum and minimum using sort_by.\n<code>\na = a.sort_by\
    \ { |e| e }.reverse\na.first # => largest number\na.last # => smallest number\n\
    </code>\n<|/ a dscore=4 tags=ruby,algorithm |>\n<| c |>\nThis returns the largest\
    \ number instead of the smallest number, as requested by the OP.\n<|/ c |>\n<|\
    \ a tags=ruby,algorithm |>\nYou can do something like this:\n<code>\na = [5,2,5,1,0]\n\
    a.find { |i| i.to_i == a.max || i.to_i == a.min }\n</code>\n<|/ a dscore=3 |>\n\
    <| a tags=ruby,algorithm |>\n<code>\na = [5, 2, 4, 1, 3, 0]\na.max.to_i", "  return\
    \ nil if lst.empty?\n  min, max = lst.minmax_by(&:abs)\n  [max, min]\nend", " \
    \ smallest, largest = nil, 0\n  lst.each do |x|\n    return nil if x.to_i < 0\n\
    \    return x if x.to_i <= largest\n    return largest if x.to_i <= smallest\n\
    \    smallest, largest = x, x.to_i\n  end\n  return nil if smallest < 0\n  return\
    \ smallest if smallest <= largest\n  return nil if smallest >= 0\n  return smallest\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nNice solution! I was thinking about\
    \ writing a recursive solution, but I decided to not because I wanted to avoid\
    \ writing new code in a new language. However, I appreciate your solution, and\
    \ will study it and modify it to suit my needs. Thank you.\n<|/ c |>\n<| a tags=functional-programming,ruby\
    \ |>\n<code>", "  smallest, largest = nil, nil\n  lst.each_with_index do |e, i|\n\
    \    if e < 0\n      if smallest == nil || smallest.nil?\n        smallest = i\n\
    \      else\n        smallest = nil\n        break\n      end\n    else\n    \
    \  if largest == nil || largest.nil?\n        largest = i\n      else\n      \
    \  largest = nil\n        break\n      end\n    end\n  end\n  smallest, largest\n\
    end", "  smallest = -Float::INFINITY\n  largest = Float::INFINITY\n  lst.each\
    \ do |x|\n    if x < smallest then smallest = x end\n    if x > largest then largest\
    \ = x end\n  end\n  [smallest, largest]\nend", "  lst.sort {|a,b| a <=> b}\n \
    \ lst.shift if lst.size < 2\n  [lst[-1], lst[0]] if lst.size > 1\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
