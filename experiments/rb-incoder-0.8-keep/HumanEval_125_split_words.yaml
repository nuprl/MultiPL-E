name: HumanEval_125_split_words
language: rb
prompt: "# Given a string of words, return a list of words split on whitespace, if\
  \ no whitespaces exists in the text you\n# should split on commas ',' if no commas\
  \ exists you should return the number of lower-case letters with odd order in the\n\
  # alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n# Examples\n# split_words(\"\
  Hello world!\") \u279E [\"Hello\", \"world!\"]\n# split_words(\"Hello,world!\")\
  \ \u279E [\"Hello\", \"world!\"]\n# split_words(\"abcdef\") == 3\ndef split_words(txt)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_split_words\n\
  \    candidate = method(:split_words)\n    assert_equal([\"Hello\", \"world!\"],\
  \ candidate.call(\"Hello world!\"))\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"\
  Hello,world!\"))\n    assert_equal([\"Hello\", \"world,!\"], candidate.call(\"Hello\
  \ world,!\"))\n    assert_equal([\"Hello,Hello,world\", \"!\"], candidate.call(\"\
  Hello,Hello,world !\"))\n    assert_equal(3, candidate.call(\"abcdef\"))\n    assert_equal(2,\
  \ candidate.call(\"aaabb\"))\n    assert_equal(1, candidate.call(\"aaaBb\"))\n \
  \   assert_equal(0, candidate.call(\"\"))\n  end\nend\n"
completions: ["  words = txt.split\n  words.each do |word|\n    puts word\n  end\n\
    end", "    array = txt.split(\" \").map(&:downcase).map(&:strip)\n    array.map!(&:empty?)\n\
    \    array.any? ? array : array.size\nend", "    txt.scan(/\\w+/).map(&:downcase).map{\
    \ |word| word.gsub(/[^a-z]+/i, '') }.uniq.map(&:split).sort\nend\n</code>\n<|/\
    \ a |>\n<| a dscore=0 |>\n<code>", "  return txt.split(' ') unless /\\s/.match(txt)\n\
    \  return txt.split(',').map {|w| w.downcase}.reduce(:+).odd? ? txt.split(',').map\
    \ {|w| w.downcase}.join(',') : txt.length.to_s\nend", "    count = 0\n    if txt.length\
    \ == 0\n        count = txt.split(', ').length\n    else\n        count = txt.split(',\
    \ ').length\n        count = count + 1\n    end\n    if count == 0\n        count\
    \ = txt.split(' ').length\n    end\n    count = count + 1\n    count\nend", " \
    \ txt = txt.downcase\n  words = txt.split(' ')\n  i = 0\n  while i < words.length\n\
    \    next_word = ''\n    word_end = i+1\n    while word_end < words.length &&\
    \ words[word_end].nil?\n      word_end += 1\n    end\n    next_word = words[word_end]\n\
    \    words[word_end] = nil if next_word.nil?\n    words[word_end].gsub!(/\\s/,\
    \ ',')\n    words[word_end] = words[word_end].split(',')\n    i += word_end -\
    \ words.length\n  end\n  words\nend", "  txt.split.each do |word|\n    word.strip!\n\
    \    if word == ''\n      word.slice!(0, 1)\n      word.slice!(0, 2)\n    end\n\
    \  end\n  txt.split.count(',')\nend", "  words = txt.split(\" \").map { |word|\
    \ word.strip }\n  if words.count == 0\n    words.map { |word| word.tr(\"A-Za-z\"\
    , \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\") }\n  else\n    words.map\
    \ { |word| word.tr(\",\", \",\") }\n  end\nend", "  word = txt.split(\" \")\n\
    \  word.select!(&:empty?)\n  word.delete_if { |word| word.length > 2 }\n  word.delete_if\
    \ { |word| word.include?(\",\") }\n  word.delete_if { |word| word.count(\",\"\
    ) }\n  word.delete_if { |word| word.count < 1 }\n  word.delete_if { |word| word.count\
    \ > 25 }\n  word.delete_if { |word| word.include?(\" \") }\n  word.delete_if {\
    \ |word| word.include?(\".\") }\n  word.delete_if { |word| word.include?(\"!\"\
    ) }\n  word.delete_if { |word| word.include?(\"?\") }\n  word.delete_if { |word|\
    \ word.include?(\"!?\") }\n  word.delete_if { |word| word.include?(\"!?\") }\n\
    \  word.delete_if { |word| word.include?(\"?!\") }\n  word.delete_if { |word|\
    \ word.include?(\"?!?\") }\n  word.delete_if { |word| word.include?(\"!?!\") }\n\
    \  word.delete_if { |word| word.include?(\"?!?!\") }\n  word.delete_if { |word|\
    \ word.include?(\"?!?!?\") }\n  word.delete_if { |word| word.include?(\"?!?!?!\"\
    ) }\n  word.delete_if { |word| word.include?(\"?!?!?!?\") }\n  word.delete_if\
    \ { |word| word.include?(\"?!?!?!?!\") }\n  word.delete_if { |word| word.include?(\"\
    ?!?!?!?!?\") }\n  word.delete_if { |word| word.include?(\"?!?!?!?!?!\") }\n  word.delete_if\
    \ { |word| word.include?(\"?!?!?!?!?!?\") }\n  word.delete_if { |word| word.include?(\"\
    ?!?!?!?!?!?!\") }\n  word.delete_if { |word| word.include?(\"?!?!?!?!?!?!?\")\
    \ }\n  word.delete_if { |word| word.include?(\"?!?!?!?!?!?!?!\") }\n  word.delete_if\
    \ { |word| word.include?", "  if txt == nil then return nil\n  txt.split(/\\W+/)\n\
    end", "  txt.scan(/\\w+/) do |word|\n    word.gsub!(/[\\W_]+/, \"\").downcase.gsub(/[^a-z]/,\"\
    \").split(\"\").select {|w| w =~ /^[a-z]/}.size\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 tags=ruby |>\nYou can use regex to do this:\n<code>", "  return\
    \ txt.split(/\\W+/)\nend", "  txt.split.map { |w| w.strip }\nend", "  txt.downcase!\n\
    \  txt.split\n  txt.join(\" \")\nend", "  # Your code here\n  words = []\n  word_count\
    \ = 0\n  txt.scan(/\\w+/) { |word| words << word }\n  if words.all?{ |word| word.include?('\
    \ ') }\n    word_count = txt.scan(/\\w+/).count { |word| word.include?(' ') }\n\
    \  end\n  return words.count, words\nend", "  # Split on spaces first\n  split_on_spaces\
    \ = txt.split(' ')", "  # Split words by whitespace and commas\n  txt = txt.split(/,|\\\
    s/)", "  return txt.split(' ').join(', ').split(',') + txt.chars.to_a.map(&:ord).group_by\
    \ { |e| e % 2 }.count { |k, v| v % 2 != 0 }\nend", "  txt.split(\" \").map { |s|\
    \ s.split(\",\") }.reduce(:+).to_a\nend", "  txt.split(/\\W+/)\nend", "  txt.downcase!\n\
    \  txt.split(?\\s+)\nend\n</code>\nOk so the above function split words by whitespace,\
    \ if we want to split by a comma, we can use the following function:\n<code>",
  "  words = txt.split(/\\W+/)\n  words.delete_if { |word| word.empty? }\n  words.delete_if\
    \ { |word| word =~ /\\d/ }\n  words.delete_if { |word| word =~ /[aeiouAEIOU]/i\
    \ }\n  return words\nend", "    words = []\n    split_on = []\n    if txt.include?('\
    \ ')\n        words = txt.split(' ')\n        words.each do |word|\n         \
    \   word.gsub!(',', '') if word =~ /,/\n            word.gsub!(/,/, '') if word\
    \ =~ /,/\n            word.gsub!(' ', ',') if word =~ /\\s/\n        end\n   \
    \ else\n        txt.each_char do |c|\n            c.gsub!(',', '') if c =~ /,/\n\
    \            c.gsub!(/,/, '') if c =~ /,/\n            c.gsub!(' ', ',') if c\
    \ =~ /\\s/\n        end\n    end", "  return txt.split(\" \") if txt.split(\"\
    \ \").length > 0 else txt.split(\",\")\nend", "    words = txt.split(/\\s+/)\n\
    \    if words.include?(\"\")\n        words = [\"a\"] + words.drop(1).map { |w|\
    \ w.split(\",\").map(&:capitalize).join(\"\") }\n    end\n    return words[0..-2]\
    \ if words[-1] == \"\"\n    words[-1] = words[-1].split(\".\").first\n    return\
    \ words[0..-2] + words[-1].split(\".\").last\nend", "  if txt.empty?\n    []\n\
    \  else\n    txt = txt.downcase\n    txt.split(/,/).map(&:strip)\n  end\nend",
  "  words = txt.scan(/\\w+/)\n  words.map! { |word| word.downcase }\n  if words.count\
    \ % 2 == 1 && !words.all?{ |word| word == word.upcase }\n    words.count / 2\n\
    \  else\n    words.count / 2\n  end\nend", "  words = txt.split.map(&:downcase).reject(&:empty?)\n\
    \  words.count { |word| word.length % 2 != 0 } < 1 ? words.join(\",\") : words.reverse.sort.join.ljust(2)\n\
    end", "  words = txt.split(' ')\n  return words.empty? ? words : words.map{|word|\
    \ word.gsub!(' ','')}\nend", "    words = txt.split(' ')\n    return words if\
    \ words.count == 1 \n    words.each_with_index do |word, index|\n        word.downcase!\
    \ if index%2 != 0\n        words.delete_at(index) if word.size == 0\n    end\n\
    \    words.join(',')\nend", "  txt.split(\" \") if txt.include?(\" \") || txt.include?(\"\
    ,\")\n  txt.split(\",\") if txt.include?(\",\")\n  txt.chars.to_a.count(&:odd).to_i\
    \ + 1\nend", "  txt.split(\"[,]\").map {|w| w.split(\"[,]\")}\nend", "  # Split\
    \ words by commas or white space\n  words = txt.split(/,|\\s/)\n  # Iterate through\
    \ each word and lowercase it\n  words.each do |word|\n    word.downcase!\n  end\n\
    \  # Return number of letters with odd order in the alphabet (assuming lowercase)\n\
    \  words.count { |word| word.index(\"a\"..\"z\") }\nend", "  # Write your code\
    \ here\nend", "  return txt.split(\"\\s|,\".gsub(/\\s+/, \"\").downcase) if txt\n\
    \  words = [txt[0].downcase]\n  words << txt.slice(1, txt.length-1).split(/[,\\\
    s!](?!.*!)/) if txt.length > 1\n  return words.uniq\nend", "  words = txt.scan(/\\\
    w+/).map(&:to_s)\n  words.count(words[0]) if words.count > 1\n  words.count(words[0])\
    \ if words.count < 1\n  words.count / 2 if words.count > 1\n  words.count / 2\
    \ if words.count < 1\n  words.map(&:downcase).count(words[0]) if (words.count\
    \ > 1) && (words.count(words[0]) % 2 == 1)\n  words.map(&:downcase).count(words[0])\
    \ if (words.count < 1) && (words.count(words[0]) % 2 == 1)\n  words.map(&:downcase).count(words[0])\
    \ if (words.count > 1) && (words.count(words[0]) % 2 == 0)\n  words.map(&:downcase).count(words[0])\
    \ if (words.count < 1) && (words.count(words[0]) % 2 == 0)\nend", "    word_counts\
    \ = {}\n    splits = txt.split(',')\n    splits.each { |s| word_counts[s.downcase]\
    \ = word_counts[s.downcase].to_i + 1 }\n    splits.delete_if{|s| word_counts[s.downcase]==0}\n\
    \    splits.delete_if{|s| word_counts[s.downcase]==1}\n    splits.delete_if{|s|\
    \ word_counts[s.downcase].odd?}\n    return splits\nend", "  return txt.split('\
    \ ') if txt != '' else txt\nend", "  words = []\n  txt = txt.downcase\n  txt.split!(',')\n\
    \  txt.each_char {|c|\n    if c.upcase == c.downcase && (c.upcase == c.downcase\
    \ || c.upcase > 'z' || c.downcase > 'z')\n      words += [c.upcase]\n    else\n\
    \      words += [c]\n    end\n  }\n  words.join(\" \")\nend", "  return txt.scan(/[\\\
    s\\S]*/).map(&:strip).reject(&:empty?)\nend", "  word = txt.downcase\n  result\
    \ = \"\"\n  char = \"\"\n  count = 0\n  while word != \"\"\n    char = word[count]\n\
    \    if char != \" \"\n      result = result + char\n      count = count + 1\n\
    \    end\n    word = word[count]\n  end\n  result\nend", "  words = txt.split(\"\
    \ \").map(&:strip)\n  words.map!(&:downcase)\n  words.compact.uniq!\n  words.length\
    \ + words[0..-2].uniq.size + words[-1..-1].uniq.count(\",\")\nend", "  txt.split.each\
    \ do |word|\n    if word.length <= 1\n      txt.split.push(word)\n    end\n  end",
  "  words = txt.split() if txt.split.size > 0\n  \n  return words unless words.size>0\n\
    \  words = words.map(&:downcase).uniq.map {|word| word.gsub(/[^a-z]+/, '')}\n\
    \  words.sort.map{|word| word.length % 2==1 ? word : word.gsub(/[a-z]/,'_')}\n\
    end", "  words = txt.downcase.strip.split\n  if words.empty?\n    words\n  else\n\
    \    words.map!(&:downcase).select{|x| x.empty? || x.include?(' ')}\n  end\nend",
  "  words = txt.split(' ')\n  words.select do |word|\n    word.blank?\n  end\n  words.reject\
    \ do |word|\n    word.blank?\n  end\n  words.reject do |word|\n    word.include?(',')\n\
    \  end\n  words.map do |word|\n    word.split(',').map {|x| x.strip}\n  end\n\
    \  words.map do |word|\n    word.split('').select {|x| x.downcase > 'a'}.count\n\
    \  end\nend", "  words = txt.split(' ')\n  if words[0].length == 0\n    words[0]\
    \ = ','\n  end\n  if words[-1].length == 0\n    words[-1] = ','\n  end\n  words.length\n\
    end", "  words = txt.split(\" \") # Split on any whitespace (including newlines)\n\
    \  words.delete(\"\\n\") # Delete newline char\n  words.delete(\",\") # Delete\
    \ comma char\n  words.length.times { |i| words[i] << i if (words[i] !~ /^[a-z]/i).any?\
    \ } # Sum up chars starting from 0 and assign to char index\n  return words\n\
    end", "    txt.scan(/^[\\s,]+/)\nend\n</cell>\n<code language=julia-0.4>", " \
    \ return txt.split(' ') if txt.include?(' ')\n  return txt.scan(/[a-z]+/i).flatten.uniq.sort_by(&:ord)\
    \ - [txt.count('a')]\nend", "  words = txt.split\n  words.shift\n  words.reverse\n\
    \  words.delete_if{|w| w =~ /\\W/ }\n  words.delete_if{|w| w =~ /\\S/ }\n  words.delete_if{|w|\
    \ w =~ /[\\d]/ }\n  words.delete_if{|w| w =~ /[!,.:?]/}\n  words.delete_if{|w|\
    \ w =~ /[-_]/}\n  words.delete_if{|w| w =~ /[(),;:\\-@'~&%\\/]/}\n  words.delete_if{|w|\
    \ w =~ /^\\p{Lu}/ }\n  words.delete_if{|w| w =~ /^\\p{L}/ }\n  words.delete_if{|w|\
    \ w =~ /[[:alpha:]]/ }\n  words.delete_if{|w| w =~ /[[:punct:]]/ }\n  words.delete_if{|w|\
    \ w =~ /[[:digit:]]/ }\n  words.delete_if{|w| w =~ /[[:upper:]]/ }\n  words.delete_if{|w|\
    \ w =~ /[[:lower:]]/ }\n  words.delete_if{|w| w =~ /[[:whitespace:]]/ }\n  words.delete_if{|w|\
    \ w =~ /[[:alnum:]]/ }\n  words.delete_if{|w| w =~ /[[:punct:]]/ }\n  words.delete_if{|w|\
    \ w =~ /[[:digit:]]/ }\n  words.delete_if{|w| w =~ /[[:upper:]]/ }\n  words.delete_if{|w|\
    \ w =~ /[[:lower:]]/ }\n  words.delete_if{|w| w =~ /[[:whitespace:]]/ }\n  words.delete_if{|w|\
    \ w =~ /[[:alnum:]]/ }\n  words.delete_if{|w| w =~ /[[:space:]]/ }\n  words.delete_if{|w|\
    \ w =~ /[[:punct:]]/ }\n  words.delete_if{|w| w =~ /[[:digit:]]/ }\n  words.delete_if{|w|\
    \ w =~ /[[:upper:]]/ }\n", "  words = txt.split(/[,]+/).map(&:strip)\n  words.select!\
    \ { |word| word }\n  return words.size\nend", "  words = txt.split /[,]+/\n  words.length\
    \ <= 1 ? words : words.map{ |word| word.split /[!,?]+/ }\nend", "  words = txt.strip.split.map\
    \ { |w| w }\n  words.select { |w| w =~ /^[a-z]+$/i }.length % 2 == 0 ? words :\
    \ words.unshift(words.first(words.count { |w| w =~ /^[a-z]+$/i }))\nend", "  return\
    \ txt.split(/[,\\s]/)\nend\n</cell>\n<code language=julia-1.0>", "  words = txt.split('\
    \ ')\n  words.map! { |w| w.split(',') }\n  words.flatten!\n  words.map! {|w| w.split(',').map\
    \ {|w| w.upcase}.flatten}\n  words.flatten!\n  words.map! { |w| w.gsub(/[^a-z]/,\
    \ \"\").downcase }\n  words.flatten!\n  words.uniq!\n  words.sort.reverse\nend",
  "  words = txt.split(' ')\n  if words.empty?\n    words\n  else\n    words.map {\
    \ |w| w.split(',').map { |s| s.split('').map { |c| c.to_i + (ord(c) < 97 ? 0 :\
    \ 1) }.compact.sum }.compact.to_a }.flatten\n  end\nend", "    words = txt.split\n\
    \    \n    return words\nend", "  txt_split = txt.split(\" \") #splits txt into\
    \ words by whitespace\n  return txt_split unless txt_split.length == 1 #no spaces\
    \ so return original txt\n  txt_split.each do |word|\n    return word if word.include?(',')\n\
    \    return word if word.include?('.')\n  end\n  return txt_split.count('a') +\
    \ txt_split.count('b') +  txt_split.count('c') +  txt_split.count('d') +  txt_split.count('e')\
    \ +\n    txt_split.count('f') + txt_split.count('g') +  txt_split.count('h') +\
    \  txt_split.count('i') +  txt_split.count('j') +\n    txt_split.count('k') +\
    \  txt_split.count('l') +  txt_split.count('m') +  txt_split.count('n') +  txt_split.count('o')\
    \ +\n    txt_split.count('p') +  txt_split.count('q') +  txt_split.count('r')\
    \ + txt_split.count('s') +  txt_split.count('t') +\n    txt_split.count('u') +\
    \ txt_split.count('v') +  txt_split.count('w') +  txt_split.count('x') +  txt_split.count('y')\
    \ +\n    txt_split.count('z')\nend", "  return txt.split(/\\s+/) if txt.include?(\"\
    \ \") && !txt.include?(\",\") && !txt.include?(\"\\n\") else txt.split(\",\").size\n\
    end", "  splits = txt.split(/[, ]+/)\n  if splits.empty?\n    return 0\n  else\n\
    \    return splits.length\n  end\nend", "  txt = txt.downcase\n  if txt.include?(\"\
    \ \") # if there are white spaces in the string we split on commas ',' instead\n\
    \    txt = txt.gsub(/,/, \",\") # replace commas with commas since we split on\
    \ commas\n    txt = txt.gsub!(/\\s/, \"\") # remove the white spaces\n  else\n\
    \    txt = txt.gsub!(/\\s/, \"\") # remove the white spaces\n    txt = txt.gsub(/,/,\
    \ \",\") # replace commas with commas since we split on commas\n  end\n  return\
    \ txt.split(\" \").map do |word|\n    word.gsub!(\" \", \"\") # remove any spaces\
    \ after the word\n  end\nend", "    words = txt.split(' ')\n    words.drop!(words.last)\n\
    \    words.each {|word| word =~ /[A-Za-z]/}\n    words.length == words.size? words\
    \ : words.length\nend", "  return txt.scan(/\\S+|[,!](?!\\s))/\nend", "  words\
    \ = txt.downcase.split(\" \").map(&:downcase)\n  return words.select { |word|\
    \ word =~ /\\p{Letter}/ }.count\nend", "  # TODO: Implement me!\nend", "  words\
    \ = txt.split(//)\n  if words.count > 1 \n    words = words.map(&:split)\n   \
    \ words = words.flatten.select{|w| w.length > 1}\n    words.sort.select{|w| w.length\
    \ % 2 == 1}.size + 1\n  else\n    words.count\n  end\nend", "  return txt.scan(/\\\
    w+/).flatten.count(\"a\") % 2 == 0\nend\nputs split_words(\"Hello world!\")\n\
    puts split_words(\"Hello,world!\")\nputs split_words(\"abcdef\") == 3\n</code>\n\
    <|/ a dscore=0 tags=ruby,ruby-on-rails,regex |>\n<| c |>\nWhat is wrong with this\
    \ code? It works perfectly on my local machine.\n<|/ c |>\n<| c |>\nI didn't downvote\
    \ your answer but it's definitely not the answer to the question \"How can I check\
    \ if a string is all lowercase letters with an even number of letters?\" as OP\
    \ requested.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,regex |>\nI like your idea\
    \ of checking the first letter, thank you.\nHere's a solution without regular\
    \ expressions:\n<code>", "  txt = txt.split(//)\n  words = txt.map { |word| word.split(//)\
    \ }\n  words.flatten.compact.sort.uniq.map { |word| word.chars.map(&:ord).sort.uniq.uniq.size\
    \ }.select { |n| n % 2 == 1 }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe question\
    \ explicitly asks for \"words\" splitting by whitespace, not by commas. Your solution\
    \ does it by commas.\n<|/ c |>\n<| c |>\nI misread the question earlier, I have\
    \ updated my answer\n<|/ c |>\n<| a tags=ruby |>\nAs you requested, I tried to\
    \ write my own answer while still keeping it short and concise.\n<code>", "  words\
    \ = txt.split(\" \").map(&:downcase)\n  if words.join(\" \").empty?\n    words.join.split(/,/)\n\
    \  else\n    words.join.split(/,/).reject(&:empty?)\n  end\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThe code in the answer has `words`, `txt`, `word` and `words`\
    \ - these are all local variables in the method. They should be `split`, `downcase`\
    \ and `reject(&:empty?)` local variables of the method `split_words`.\n<|/ c |>\n\
    <| c |>\n`words = txt.split(\" \").map(&:downcase)\n  if words.join(\" \").empty?\n\
    \    words.join.split(/,/)\n  else\n    words.join.split(/,/).reject(&:empty?)\n\
    \  end\nend`\n<|/ c |>\n<| c |>\nThat was from my IDE where all local variables\
    \ had the same name as the method. Good catch.\n<|/ c |>\n<| a |>\nAnother one:\n\
    <code>", "  word_array = txt.split\n  word_array.map {|word| word.strip}\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "  return txt.split(',')\
    \ if txt =~ /\\s/ \n  return txt.downcase.chars.with_index.select { |w,i| w =~\
    \ /[a-z]/i && (i % 2) }.map { |w| w.split(//).join.to_i }\nend\n</code>\nRuby\
    \ 2.0 solution:\n<code>", "  words = txt.split(' ')\n  return words.reject(&:blank?).count\n\
    end", "    words = txt.split(/\\s+/)\n    words[0] = words[0].split(',') if words[0]\
    \ !~ /[\\,]/\n    words[words.size - 1] = words[words.size - 1].downcase\n   \
    \ words.size.times { |i| words[i] = words[i].gsub(/^\\s+/, '').strip }\n    return\
    \ words\nend", "  words = txt.split(\" \")\n  words.each {|w| w.gsub!(/\\W+/,\
    \ \"\")}\n  words.each {|w| w.gsub!(/,/, \"\")}\n  return words\nend", "  txt.scan(/[^\
    \ \\n]+/).map(&:downcase).reject { |word| word =~ /^[a-z]/ }.map { |word| word.split('\
    \ ') }.flatten\nend\n</code>\nThe method above uses scan to scan the string for\
    \ all non-space characters. I then remove any words that do not contain letters.\
    \ The words we remove are then split on spaces.\nFor completeness, here are other\
    \ methods I could suggest:", "  txt.strip!\n  return txt.split(' ') if txt.include?('\
    \ ') else\n    if txt.include?(',')\n      txt.split(',').map { |w| w.downcase.gsub(/\\\
    s+/,'').split(',').map { |w| w.split('').map(&:upcase).join(''); } }\n    else\n\
    \      txt.downcase.gsub(/\\s+/,'').split('').map { |w| w.split('').map(&:upcase).join('')\
    \ }\n    end.count { |w| w.include?(\" \") }\nend", "  words = txt.split(/,| /)\n\
    \  words[0,1] = words[0,1].downcase\n  return words\nend", "  # Remove all whitespaces\
    \ first\n  txt.strip!", "  return txt.gsub(/[^\\w\\s]/,'').split(',').map(&:strip).map(&:downcase)\
    \ unless txt.include?(',')\n  words = txt.split(',')\n  \n  odd_words = []\n \
    \ even = words.each_with_index.reduce(0) { |sum, n, i| sum + n % 2 if i % 2 ==\
    \ 0 }\n  odd_words = words[0...even]\n  \n  odd_words.size\nend", "    words =\
    \ txt.split(' ')\n    count = words.size\n    if count > 1\n        words.shift\
    \ 0\n        words.shift 1\n    end\n    words.shift count\n    count\nend", " \
    \ txt.downcase!\n  txt = txt.split.join(',') if txt.split.count { |x| x.include?(',')\
    \ }\n  txt.split.count { |x| x.downcase % 2 == 1 }\nend", "    return txt.split\
    \ && txt.split(/[,\\s!?]+/)\nend", "  words = txt.split(' ')\n  return words.size\
    \ > 1 ? words : words[0..-2]\nend", "    words = txt.split(\" \").map(&:strip)\n\
    \    words.map!(&:downcase) unless words.all?(&:casecmp)\n    words.compact!\n\
    \    words.inject(:+)\n    words.count(&:odd?) / words.size\nend", "  words =\
    \ txt.downcase.gsub(\" \", \"\").gsub(\",\", \" \").split\n  return words.size\
    \ if words.length > 0 else words.size + words.count { |w| w.count(\"a\") } - 1\n\
    end", "    \n    return txt.split(/\\W+/)\nend", "    words = txt.split(\" \"\
    ) || [txt]\n    words = words.map(&:strip)\n    words = words.reject(&:empty?)\n\
    \    words = words.reject(&:nil?)\n    words.count\nend", "  a = txt.split(' ')\n\
    \  b = a.map { |x| x.strip }\n  c = b.select { |x| x.length > 0 }\n  d = c.select\
    \ { |x| x.match(/[a-z]/) }\n  if d.length == 0 || d.count { |x| x.to_s.upcase\
    \ }.odd? == true\n    puts \"No whitespace exists in given text\"\n  elsif d.count\
    \ == 0\n    puts \"No commas exists in given text\"\n  else\n    d.count\n  end\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nThis answer is for the following\
    \ problem in Python.", "  words = txt.split(' ')\n  return words.count ? words\
    \ : words.join(',').split(',').select { |word| !word.empty? && !word.start_with?('#')\
    \ }\nend", "  words = txt.split(' ')\n  words.delete_if { |w| w.strip == \"\"\
    \ }\n  words.delete_if { |w| w == '' }\n  words.delete_if { |w| w == nil }\n \
    \ return words.size % 2 == 0 ? words : words.reverse.map { |w| w.reverse.to_i(26).to_s(26).split('').join.rjust(26)\
    \ }\nend", "  txt.downcase!\n  words = txt.split /[^a-z0-9]+/i\n  words.delete_if\
    \ { |word| word.empty? }\n  words.delete_if { |word| word.empty? || word.length\
    \ == 0 }\n  words.delete_if { |word| word =~ /[^a-z0-9]/i }\n  words.delete_if\
    \ { |word| word =~ /\\A[^a-z]*\\z/i }\n  words.delete_if { |word| word =~ /\\\
    A\\A[a-z]+\\Z/i }\n  words.delete_if { |word| word =~ /\\A[a-z]+\\Z/i }\n  words.delete_if\
    \ { |word| word =~ /\\A[a-z]+\\Z/i }\n  words.delete_if { |word| word =~ /\\A[a-z]+\\\
    Z/i }\n  words.delete_if { |word| word =~ /\\A[a-z]+\\Z/i }\n  words.delete_if\
    \ { |word| word =~ /\\A[a-z]+\\Z/i }\n  words.delete_if { |word| word =~ /\\A[a-z]+\\\
    Z/i }\n  words.delete_if { |word| word =~ /\\A[a-z]+\\Z/i }\n  words.delete_if\
    \ { |word| word =~ /\\A[a-z]+\\Z/i }\n  words.delete_if { |word| word =~ /\\A[a-z]+\\\
    Z/i }\n  words.delete_if { |word| word =~ /\\A[a-z]+\\Z/i }\n  words.delete_if\
    \ { |word| word =~ /\\A[a-z]+\\Z/i }\n  words.delete_if { |word| word =~ /\\A[a-z]+\\\
    Z/i }\n  words.delete_if { |word| word =~ /\\A[a-z]+\\Z/i }\n  words.delete_if\
    \ { |word| word =~ /\\A[a-z]+\\Z/i }\n  words.delete_if { |word| word =~ /\\A[a-z]+\\\
    Z/i }\n  words.delete_if { |word| word =~ /\\A[a-z]+\\Z/i }\n  words.delete_if\
    \ { |word| word =~ /\\A[a-z]+\\Z/i }\n  words.delete_if { |word| word =~ /\\A[a-z]+\\\
    Z/i }\n  words.delete_if { |word| word =~ /\\A[a-z]+\\Z/i }\n  words.", "  # Split\
    \ the text on a space or a comma depending on the text you have\n  split_text\
    \ = txt.split(\" \") if txt.include?(\",\") else txt.split(\",\")\n  # Return\
    \ the number of letters in the alphabet with odd order in the alphabet\n  alphabet_size\
    \ = 26\n  alphabet_letters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\
    , \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  return alphabet_size-alphabet_letters.count{|x|\
    \ split_text.include?(x)}\nend", "    words = txt.split(' ')\n    return words.collect\
    \ { |word| word.tr('a-z','A-Z') }\nend\n</code>\n<|/ a dscore=0 tags=ruby,regex\
    \ |>\n<| c |>\nYour solution does not produce the expected output for strings\
    \ with multiple spaces in it.\n<|/ c |>\n<| c |>\nYes, you're right, I didn't\
    \ noticed that requirement, I've updated my answer.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "  words = txt.split(/\\s+/)\n  if words.empty?\n    words = [txt]\n\
    \  end\n  words.map { |word| word.split(/[,]+/).map(&:downcase) }\nend", "  txt.split(\"\
    \ \").map { |w| w.split(\",\") }.flatten.uniq.map { |w| w.to_s.downcase.split(\"\
    \").count { |w| w.length % 2 == 1 } }.min\nend", "  if txt.strip == ''\n    txt.split('')\n\
    \  else\n    txt.split(',')\n  end\nend", "  return txt.split(' ') if txt.include?('\
    \ ') then txt.split(',') else txt.downcase.chars.map(&:ord).uniq.count % 2 ==\
    \ 1 ? txt.split(' ') : txt.split(',')\nend", "  txt.downcase!\n  if txt.empty?\n\
    \    []\n  else\n    txt.split(' ') | [txt.upcase] | [txt.downcase]\n  end\nend",
  "  txt.downcase!\n  txt.split(/[,!?;:\\t]+/)\nend", "    txt.split(/ /)\nend", " \
    \ if txt.match(/\\s+/)\n    words = txt.split(/\\s+/)\n  else\n    words = txt.split(',')\n\
    \  end\n  words.length\nend", "  words = txt.split(' ')\n  words.each_with_index\
    \ do |word, i|\n    if i == 0 || words[i - 1] == ',' || words[i - 1] == ' ' then\n\
    \      words[i] = word.gsub!(/[,|\\s\\s]/, '')\n    end\n  end\n  words\nend",
  "  txt.split(\" \").map(&:strip)\nend", "  if txt.blank?\n    return []\n  txt.split(\"\
    \ \").map do |word|\n    word.split(\",\") if word.include?(\",\")\n    word.split(\"\
    -\") if word.include?(\"-\")\n    word.split(\"_\") if word.include?(\"_\")\n\
    \    word.split(\"'\") if word.include?(\"'\")\n    word.count(\"a\") % 2 == 1\n\
    \  end\nend", "  splits = txt.scan(/[^\\s,.]+/)\n  splits.flatten.map {|s| s.split(//)\
    \ }.uniq.map {|s| s.chars.uniq.sort.join}\nend", "  txt.scan(/\\w+/).map{ |w|\
    \ w.gsub(/\\s+/, '').strip }.uniq.map{ |w| w.length }.sort\nend", "  words = txt.split('\
    \ ')\n  words.map! { |word| word.split(',').map { |word| word.downcase.gsub(',',\
    \ '') } }\n  words.flatten!\n  words.compact!\n  words.compact!\n  words.uniq!\n\
    \  words.compact!\n  words.uniq.size\nend", "  return txt.split(/[,!?.]+/)\nend",
  "  result = \"\"\n  i = 0\n  while i < txt.length\n    char = txt[i]\n    if char\
    \ != ' '\n      if char != ','\n        result += char\n      end\n    end\n \
    \   i += 1\n  end\n  return result == \"\\n\" ? 1 : result.split(\",\")\nend",
  "  txt.split.map do |w|\n    w.strip unless w.empty?\n  end\nend", "  txt.gsub(/\\\
    s+/, ' ').downcase.split.map { |w| w.gsub(/,/, '').split('').select{|c| c =~ /[a-z]/i}.select{|c|\
    \ c =~ /[A-D]/i}.select{|c| c =~ /[F-Z]/i}.length % 2 != 0 }\nend", "    txt.chars.each_with_object([]).with_index\
    \ do |word, new_words| \n        if word.empty? \n            new_words << word\
    \ \n        elsif word.chars.all? { |c| c == ',' } \n            new_words <<\
    \ word \n        elsif word.chars.all? { |c| !c.match(/[a-z]/) } \n          \
    \  new_words << word \n        elsif word.chars.all? { |c| c == ' ' } \n     \
    \       new_words << word \n        elsif word.chars.all? { |c| c.match(/[a-z]/)\
    \ } \n            if c.ord('a').ord == 'z'\n                new_words << word\
    \ \n            else\n                new_words << word + word.chars.sort_by{\
    \ |c| c.ord }.join\n            end\n        else \n            new_words << word\
    \ \n        end\n    end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,string,arrays\
    \ dscore=0 |>\n<| c |>\nThe OP should also consider what happens if one word contains\
    \ multiple spaces, commas, colons, etc, or if any of these characters are in the\
    \ middle of a word.  For example, `hello, world!` is split on two spaces instead\
    \ of one and therefore the result is `\"hello\"` and `\"world!\"`.\n<|/ c |>\n\
    <| c |>\nYes, but that should be an easy fix... `word.chars.each_with_object([]).with_index\
    \ do |word, new_words| `\n<|/ c |>\n<| c |>\nYes, but that will still produce\
    \ `\"hello\"` and `\"world!\"`.  (You will end up with `\"hello\"` and `\"worl\"\
    `.)  It appears that you might want to consider `word.chars.each_with_object([]).with_index.select\
    \ { |c, a| c != ' ' }` instead, to make sure you only process characters that\
    \ are not spaces.\n<|/ c |>\n<| a dscore=0 |>\nYou could use inject to create\
    \ the array:\n<code>", "  txt.downcase! \n  txt.split.each {|x| x.strip if x.strip\
    \ !~ /\\s/}\n  txt.split.each {|x| x.strip if x.strip !~ /,/}\n  txt.split.each\
    \ {|x| puts \"#{x}\" if x.to_i.odd? }\n  txt.split.each {|x| x.to_i.odd? ? puts\
    \ \"#{x}\" : puts \"#{x.to_s}\"}\nend\n</code>\nOutput\n<code>\nHello world!\n\
    [\"Hello\", \"world!\"]\n[\"Hello\", \"world!\"]\n2\n[[\"Hello\", \"world!\"],\
    \ [\"Hello\", \"world!\"]]\n</code>\n<|/ a dscore=2 tags=string,ruby |>\n<| c\
    \ |>\n`split_words(txt)` => `txt.downcase.split.map(&:strip)` => `txt.downcase.split.map(&:strip).reject(&:empty?)`\
    \ => `txt.downcase.split.map(&:strip).map {|s| s.split(/,/).reject(&:empty?) }.map(&:map).reduce(&:<<)`\n\
    <|/ c |>\n<| c |>\n`txt.downcase.split.map(&:strip).reject(&:empty?)` => `txt.downcase.split.map(&:strip).map\
    \ {|s| s.split(/,/).reject(&:empty?) }` => `txt.downcase.split.map {|s| s.split(/,/).map(&:strip)\
    \ }` => `txt.downcase.split.map {|s| s.split(/,/).map(&:strip).map {|x| x.split(\"\
    \ \").map(&:strip)}}` => `txt.downcase.split.map {|s| s.split(/,/).map(&:strip).map\
    \ {|x| x.split(\" \").map(&:strip).reduce(&:<<)}}` => `txt.downcase.split.map\
    \ {|s| s.split(/,/).map(&:strip).map {|x| x.split(\" \").map(&:strip).map {|s|\
    \ s.split(\" \").map(&:strip)}}` => `txt.downcase.split.map {|s| s.split(/,/).map(&:strip).map\
    \ {|x| x.split(\" \").map(&:strip).map {|s| s.split(\" \").map(&:strip).reduce(&:<<)}}`\
    \ => ", "  words = txt.split(' ')\n  count = words.inject(0){ |sum,str| sum+1\
    \ if str.count(',').to_i == 0 else str.count(',').to_i }\n  return words.reject\
    \ { |w| w.count(',').to_i != 0 } if count % 2 == 0\n  words.reject { |w| w.count(',').to_i\
    \ != 0 } if count < 26\n  return words[0..count-1].map{ |w| w.gsub(',','').downcase\
    \ }\nend", "  txt.gsub(/\\s+/,'').gsub(/[^a-zA-Z\\d,]+/, ' ').scan(/[a-z][a-z\\\
    d]*|[a-z]/).compact\nend", "  ret = []\n  while txt != \"\"\n    l = txt.split\n\
    \    if l != nil\n      ret.push(l[0])\n      txt = l[1]\n    else\n      ret.push(txt.downcase)\n\
    \      txt = \"\"\n    end\n  end\n  ret\nend", "  splitted = txt.split\n  unless\
    \ txt.empty?\n    splitted = txt.split(' ')\n    unless splitted.empty?\n    \
    \  splitted.each do |word|\n        unless word.empty?\n          unless word.start_with?(\"\
    '\") or word.start_with?(\",\") or word.start_with?(\"!\")\n            if word.start_with?(\"\
    ,\")\n              return word.split(\",\")\n            else\n             \
    \ return word.split(\"!\")\n            end\n          end\n        end\n    \
    \  end\n    end\n  end\n  return 1\nend", "  return txt.split(',') if ',' in txt\
    \ else txt.split if ' ' in txt else txt.split(\"\").map(&:downcase).uniq.count(&:odd?).to_i\n\
    end", "  txt.scan(/\\w+/).map { |word| word.downcase }\nend", "  txt.downcase!\n\
    \  txt.split!(' ')\n  words = txt.map { |w| w.downcase.split(' ') }\n  words.compact!\n\
    \  words.sort!\n  words[0...-1]\nend", "  txt.downcase!\n  if txt.empty?\n   \
    \ []\n  else\n    # Replace every whitespace with commas\n    txt.gsub!(/\\s+/,\
    \ \",\")\n    words = txt.split(/,/)\n    words.map do |word|\n      word.split(\"\
    \ \").map(&:capitalize).join\n    end\n  end\nend", "  return txt.split(' ') if\
    \ txt.split(' ').count > 0\nend", "\twords = txt.split(' ')\n\twords.map! { |word|\
    \ word.gsub(/\\s+/, ' ') }\n\twords.delete_if { |word| word.empty? }\n\twords.delete_if\
    \ { |word| word =~ /\\A[a-z]+/i }\n\twords.delete_if { |word| word =~ /\\A[A-Z]+/i\
    \ }\n\twords.delete_if { |word| word =~ /\\A[0-9]+/i }\n\twords.delete_if { |word|\
    \ word =~ /\\A\\W+/ }\n\twords.map! { |word| word.downcase }\n\twords.map! { |word|\
    \ word.gsub(/\\p{IsUpper}/, '') }\n\twords\nend", "  return txt.scan(/\\w+/)\n\
    end", "    txt = txt.downcase\n    txt = txt.gsub(/\\s/,'')\n    if txt.length\
    \ == 0\n        return [0]\n    txt = txt.split(',')\n    len = txt.length\n \
    \   odds = []\n    evens = []\n    i = 0\n    begin = 0\n    end = len-1\n   \
    \ while (begin < end) do\n        if txt[begin].ord() % 2 == 1\n            evens\
    \ << txt[begin]\n        else\n            odds << txt[begin]\n        end\n \
    \       i += 1\n        begin = i+1\n        end = i\n    end\n    return [evens.length..odds.length].to_a\n\
    end", "    arr = txt.split(' ')\n    if arr.size == 1\n        arr = txt.split(',')\n\
    \    end\n    return arr\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=0\
    \ |>\n<code>", "  return txt.split(' ').map(&:strip).map {|x| x.gsub(/[,]+/, '')\
    \ if x}.uniq.map {|x| x.downcase}\nend", "  return [w.split(\" \", 2) for w in\
    \ txt.split(\"\\n\")]\nend", "  # Split words on whitespace\n  words = txt.split\n\
    \  # If no whitespace exists in the text, split on commas, return number of commas\
    \ found with even order\n  if txt.include?(\" \")\n    words = txt.split(\",\"\
    ).size\n    words += 1 if txt.include?(\",\")\n  end\n  words\nend", "  txt.split('\
    \ ').map { |s| s.split(\",\") }.flatten\nend", "  s = txt.split(\" \").map{|e|\
    \ e.split(',')}\n  s.flatten!\n  s.flatten!\n  s.map{|e| e.size}\nend", "  words\
    \ = txt.split.join(',')\n  words = words.split(',').map{|word| word.downcase}\n\
    \  return words.count('a') % 2 == 0 ? words : words.reverse\nend", "  if txt.nil?\
    \ or txt.empty?\n    raise \"Error: Invalid string passed to split_words\"\n \
    \ end\n  \n  words = txt.split(/[\\s\\,]+/)\n  words.reject! { |w| w.strip.empty?\
    \ }\n  \n  words.map! { |w| w.gsub(/[^a-z]/i, '') }\n  words.compact!\n  \n  words.inject(0)\
    \ do |total, (w)|\n    return total.succ if w.length % 2 == 1\n    \n    total\n\
    \  end\nend", "  txt.each_char.with_index.map { |char, i| char == ' ' ? nil :\
    \ \"#{char}.\" if char == ',' }.compact\nend", "  words = txt.split(',')\n  words.each\
    \ { |word| word.strip }\n  return words.count { |word| word }\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 tags=ruby,functional-programming,methods |>\n\
    I propose the following solution:\n<code>", "    word = nil\n    spaces = []\n\
    \    words = []\n    space = false\n    i = 0\n    alphabet_size = (65..90).to_a\n\
    \    alphabet_size = alphabet_size.sort_by{|a| a}\n    alphabet_size.size.times\
    \ do\n        letter = txt[i]\n        if letter == \" \"\n            space =\
    \ true\n        else\n            space = false\n        end\n        if space\n\
    \            spaces << letter\n        else\n            if alphabet_size.size\
    \ < letter\n                alphabet_size << letter\n                alphabet_size.size.times\
    \ do\n                    alphabet_size << letter\n                end\n     \
    \           alphabet_size.size.times do\n                    alphabet_size.push\
    \ letter\n                end\n                alphabet_size.size.times do\n \
    \                   alphabet_size.push letter\n                end\n         \
    \   end\n            words << letter\n        end\n        i += 1\n    end\n \
    \   words.join(' ')\nend", "    return txt.split(' ')\nend\n</cell>\n<code language=julia-0.6>",
  "\ttxt = txt.dup.split(//)\n\ttxt.each do |word|\n\t\tword = word.chomp\n\t\tif\
    \ word\n\t\t\tif word.length < 4\n\t\t\t\tputs word.upcase\n\t\t\telsif word.length\
    \ == 4\n\t\t\t\tputs word.upcase\n\t\t\t\tputs word.slice!(2,3)\n\t\t\telsif word.length\
    \ == 5\n\t\t\t\tputs word.upcase\n\t\t\t\tputs word.slice!(2,3)\n\t\t\t\tputs\
    \ word.slice!(4,5)\n\t\t\telse\n\t\t\t\tputs word.upcase\n\t\t\t\tputs word.slice!(2,3)\n\
    \t\t\t\tputs word.slice!(4,5)\n\t\t\t\tputs word.slice!(6,7)\n\t\t\tend\n\t\t\
    end\n\tend\nend", "  words = txt.split(\"\\s\") if txt && !txt.empty?\n  words\
    \ = words.join(',') if words && words.count > 1\n  words = words.split(',') if\
    \ words\n  words.map { |word| word.downcase }\nend", "  if txt.strip == ''\n \
    \   txt.split(',')\n  else\n    txt.split(' ')\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=0 |>\n<| a dscore=0 |>\nHow about this?\n<code>\nwords = text.scan(/\\\
    w+/)\neven = words.each_cons(2).find { |a,b| a % 2 == 0 && b.to_s.size % 2 ==\
    \ 0 }\nodd = words.each_cons(2).find { |a,b| a % 2 != 0 && b.to_s.size % 2 !=\
    \ 0 }\neven = even ? even[0] : odd.first\nodd = odd ? odd[0] : even.first\n</code>\n\
    <|/ a tags=ruby |>\n<| a tags=ruby |>\n<code>", "  return txt.gsub(/[ ,]+/).split.map(&:downcase).count{|w|\
    \ w % 2 == 1}\nend", "  words = txt.split(' ')\n  words.each_with_index { |word,\
    \ idx| words[idx] = word unless word.empty? }\n  words.compact!\n  words.compact!\n\
    \  words.compact!\n  words.map! { |word| word.downcase }\n  words.map! { |word|\
    \ word.scan(/[a-z]/i) }\n  words.map! { |word| word.size() }\n  words.compact.uniq.sort\n\
    end", "  # Write your code below\n  txt.split(\" \")\nend", "  txt.split(/\\s+/).map\
    \ { |w| w.split(/[,]\\s/) }\nend", "    words=txt.split\n    even=[words[0]]\n\
    \    odd=[words[1]]\n    even=even.concat(words.drop(1))\n    odd=odd.concat(words.drop(2))\n\
    \    even.concat(even.map{|word| word.count(' ')}).compact!\n    odd.concat(odd.map{|word|\
    \ word.count(' ')}).compact!\n    even.concat(odd.map{|word| word.count(' ')}).compact!\n\
    \    even.concat(even.map{|word| word.count(',')}).compact!\n    odd.concat(odd.map{|word|\
    \ word.count(',')}).compact!\n    even.concat(odd.map{|word| word.count(',')}).compact!\n\
    \    even.concat(even.map{|word| word.count('a')}).compact!\n    odd.concat(odd.map{|word|\
    \ word.count('a')}).compact!\n    even.concat(odd.map{|word| word.count('a')}).compact!\n\
    \    even.concat(even.map{|word| word.count('b')}).compact!\n    odd.concat(odd.map{|word|\
    \ word.count('b')}).compact!\n    even.concat(odd.map{|word| word.count('b')}).compact!\n\
    \    even.concat(even.map{|word| word.count('c')}).compact!\n    odd.concat(odd.map{|word|\
    \ word.count('c')}).compact!\n    even.concat(odd.map{|word| word.count('c')}).compact!\n\
    \    even.concat(even.map{|word| word.count('d')}).compact!\n    odd.concat(odd.map{|word|\
    \ word.count('d')}).compact!\n    even.concat(odd.map{|word| word.count('d')}).compact!\n\
    \    even.concat(even.map{|word| word.count('e')}).compact!\n    odd.concat(odd.map{|word|\
    \ word.count('e')}).compact!\n    even.concat(odd.map{|word| word.count('e')}).compact!\n\
    \    even.concat(even.map{|word| word.count('f')}).compact!\n    odd.concat(odd.map{|word|\
    \ word.count('f')}).compact!\n    even.concat(odd.map{|word| word.count('f')}).compact!\n\
    \    even.concat(even.map", "  return txt.split\nend", "  case txt.length\n  when\
    \ 0\n    []\n  when 1\n    [txt]\n  when 2\n    if txt[1] == \",\"\n      txt.slice(1..-1)\n\
    \    else\n      [txt]\n  end\nend", "  txt.strip.split(/\\s+/).map { |str| str.split(/,/).map(&:downcase)\
    \ }.reduce(:+)\nend", "  words = txt.downcase.scan(/[a-z]/).size\n  puts \"#{words}\
    \ letters in #{txt}\"\n  words = txt.split(',').size\n  puts \"#{words} commas\
    \ in #{txt}\"\n  words = txt.scan(/[a-z]/).count{|x| x != x.downcase}\n  puts\
    \ \"#{words} lower-case letters in #{txt}\"\n  words = txt.scan(/[A-Z]/).count{|x|\
    \ x != x.downcase}\n  puts \"#{words} upper-case letters in #{txt}\"\nend", " \
    \ txt.split.map(&:strip)\nend\n  ", "  # Write your code here.\nend\n</cell>\n\
    <text>\nTest your Code\nRun the cell below to test your code.", "  return txt.split('\
    \ ').map(&:strip).reject(&:empty?)\nend", "  txt.gsub(/\\s+/, ' ').split.map(&:downcase).map(&:strip).uniq.count\n\
    end", "  word_list = txt.split(\" \") # splits words by whitespace\n  word_list.delete(\"\
    ,\") # removes commas from a word\n  word_list.delete_if { |w| w.empty? } # removes\
    \ empty strings from array\n  word_list.delete_if { |w| w =~ /[^A-Za-z]/} # removes\
    \ words with non-alphabetic characters from a word\n  word_list.uniq.delete_if\
    \ { |w| w.size % 2 }\n  word_list.uniq.delete_if { |w| w =~ /\\d/} # removes words\
    \ with odd order from a word\n  word_list.uniq.delete_if { |w| w =~ /[A-Z]/} #\
    \ removes words with even order from a word\n  word_list.uniq.delete_if { |w|\
    \ w.size < 2 } # removes words with zero letters from a word\n  word_list.uniq.uniq.delete_if\
    \ { |w| w.size == 1 } # removes duplicate words from array\n  word_list.uniq.uniq.delete_if\
    \ { |w| w =~ /\\d/ } # removes duplicate words with odd order from a word\n  word_list.uniq.uniq.uniq.uniq.delete_if\
    \ { |w| w =~ /[A-Z]/ } # removes duplicate words with even order from a word\n\
    \  word_list\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI solved this problem\
    \ this way:", "  words = txt.split(//)\n  words.select{|x| x.include?(' ')}.size\n\
    end", "  word_list = txt.split(' ') #Split on spaces\n  word_list.each do |word|\n\
    \    if word.include?(',')\n      word_list2 = word.split(',') #Split on comma\n\
    \      word_list2.each do |word2|\n        if word2.include?(',')\n          word_list3\
    \ = word2.split(',') #Split on comma\n          word_list3.each do |word3|\n \
    \           word_list.push(word3) #Add word to new array\n          end\n    \
    \    end\n      end\n    end\n  end\n  word_list\nend", "  txt.split.map(&:strip).reduce(:merge)\n\
    end", "  \n  # Split on any whitespace\n  txt.split(' ')", "  return txt.split(\"\
    \ \") unless txt.include?(\" \")\n  txt = txt.split(\"\\n\")\n  txt.shift if txt[0].include?(\"\
    ,\")\n  txt = txt.map(&:strip).map(&:downcase).reject { |s| s.empty? }\n  txt\
    \ = txt.select { |s| s.include?(\",\") }\n  txt = txt.uniq.select { |s| s.include?(\"\
    ,\") }\n  txt.sort.length\nend", "  txt.split(\"\").map do |word|\n    word.split(\"\
    \").map { |c| c != \"a\" && c != \"e\" && c != \"i\" && c != \"o\" && c != \"\
    u\" ? c : \",\" }\n  end.reduce(:zip).map { |s| s.reduce(:zip).map { |a, e| a\
    \ + e } }\nend", "  words = txt.split(' ')\n  return words.map{|word| word.split(',').map{|x|\
    \ x.strip}.map {|x| x.downcase}}.inject([]){ |l, r| l | r }.select {|word| word\
    \ != ''}\nend", "    txt.split.each do |word|\n        word = word.tr('!,.?;:',\
    \ ' ')\n        word.split(' ').each do |letter|\n            next if letter.empty?\n\
    \            letter += 1 if letter.downcase % 2 == 1\n        end\n    end\n \
    \   txt.split.size\nend\n</cell>\n<cell>", "  words = txt.split(\" \").map{ |s|\
    \ s.strip }\n  return words.size % 2 == 0 ? words : words.reverse.dup.shuffle\n\
    end", "  txt.chars.each do |e|\n    if e.ascii_only?\n      result << e\n    elsif\
    \ e.ascii_chars.count == 1 and e.ascii_chars.first > 'z'\n      result << e.ascii_chars.first\n\
    \    end\n  end\n  return result.count\nend", "  words = txt.split(' ')\n  words.empty?\
    \ ? words.delete_if {|w| w.include?(',') } : words.delete_if {|w| w.include?(',')\
    \ }\n  words.empty? ? words.delete_if {|w| w.include?(' ').to_i == 1} : words.delete_if\
    \ {|w| w.include?(' ').to_i == 1}\n  words.delete_if {|w| w.include?(\" \") ||\
    \ w.include?(\",\")}\n  words.delete_if {|w| w.include?(\"(\") || w.include?(\"\
    )\")}\n  words.delete_if {|w| w.include?(\"'\") || w.include?('\"') }\n  words.delete_if\
    \ {|w| w.include?(\",\")}\n  words.delete_if {|w| w.include?(\":\")}\n  words.delete_if\
    \ {|w| w.include?('.')}\n  words.delete_if {|w| w.include?(\" \") || w.include?(\"\
    ,\")}\n  words.delete_if {|w| w.include?(\" \") || w.include?('.')}\n  words.delete_if\
    \ {|w| w.include?(\" \") || w.include?(',')}\n  words.delete_if {|w| w.include?(':')}\n\
    \  words.delete_if {|w| w.include?('.')}\n  words.delete_if {|w| w.include?('\"\
    ') || w.include?(\"'\")}\n  words.delete_if {|w| w.include?(\" \") || w.include?(\"\
    ,\")}\n  words.delete_if {|w| w.include?(\" \") || w.include?('.') || w.include?('\"\
    ')}\n  words.delete_if {|w| w.include?(',')}\n  words.delete_if {|w| w.include?(':')}\n\
    \  words.delete_if {|w| w.include?('.') || w.include?('\"') || w.include?(\"'\"\
    )}\n  words.delete_if {|w| w.include?(\" \") || w.include?(\".\") || w.include?(',')\
    \ || w.include?('\"') || w.include?(\"'\")}\n  words.delete_if {|w| w.include?('(')\
    \ || w.include?(')')}\n  words.delete_if {|w| w.include?(',')}\n  words.delete_if\
    \ {|w| w.include?(':') || w.include?('.')", "  words = txt.split(/\\W+/)\n  words.each_with_index\
    \ do |word,i|\n    word = word.upcase\n    word = word.gsub(/\\A[[:upper:]]+/,\
    \ \"\") if i > 0 # Removes beginning of line or whitespace if exists\n    word\
    \ = word.gsub(/\\A[[:lower:]]+\\z/, \"\") if i > 0 # Removes beginning of line\
    \ or whitespace if exists\n    words[i] = word\n  end\n  words\nend", "  # Split\
    \ on any whitespace\n  words = txt.split(\" \")\n  # Create an array from words\
    \ and remove any blanks\n  cleaned_words = words.select{ |w| w != \"\" }\n  #\
    \ Create a list of the lower-case letters\n  letters = cleaned_words.map{ |word|\
    \ word.downcase.split(\"\").map{ |w| w.to_i }}\n  # Count the number of odd letters\
    \ in the alphabet\n  odd_count = letters.select{ |a| a.odd? }.count\n  # If there\
    \ are no odd letters, return words, else return the number of words and split\
    \ on commas\n  odd_count == 0 ? cleaned_words : odd_count.to_s + \",\" + cleaned_words.map\
    \ { |w| w }.join(\",\")\nend", "  words = []\n  word = \"\"\n  letter = nil",
  "  txt.downcase!\n  txt.gsub!(/,/, \"|\") # Comma separate list items\n  txt.gsub!(/[,|]/,\
    \ \"\") # Remove commas\n  txt.gsub!(/\\W+/, \"|\") # Replace all non-alphanumeric\
    \ chars with | for splitting\n  txt.gsub!(\"|\", \"|*\") # Replace | with *\n\
    \  txt.gsub!(\"|*\", \"|\") # Replace |* with *\n  txt.gsub!(\"*\", \"|\") # Replace\
    \ * with *\n  txt.gsub!(\" \", \"|\") # Replace all spaces with |\n  txt.gsub!(\"\
    |*\", \"|*\") # Replace |* with *\n  txt.gsub!(\"|\", \"|\") # Replace | with\
    \ *\n  txt.gsub!(\"*\", \"|\") # Replace * with *\n  txt.gsub!(/\\|+/, \"|\")\
    \ # Replace all | with *\n  txt.gsub!(/\\|+/, \"|\") # Replace all | with *\n\
    \  txt.gsub!(/\\|+/, \"|\") # Replace all | with *\n  txt.gsub!(/\\|+/, \"|\"\
    ) # Replace all | with *\n  txt.gsub!(\"|*\", \"|\") # Replace |* with *\n  txt.gsub!(\"\
    |*\", \"|\") # Replace |* with *\n  txt.gsub!(\"*\", \"|\") # Replace * with *\n\
    \  txt.gsub!(/\\|+/, \"\") # Replace all | with *\n  txt.gsub!(/|/, \"\") # Remove\
    \ spaces\n  txt.gsub!(/[,|]/ , \"\") # Remove commas\n  txt.gsub!(/[a-z]/ , \"\
    \") # Remove lower-case letters\n  txt.gsub!(/[A-Z]/ , \"\") # Remove upper-case\
    \ letters\n  txt.gsub!(\"|\", \"|*\") # Replace | with *\n  txt.gsub!(\"|*\",\
    \ \"|\") # Replace |* with *\n  txt.gsub!(\"*\", \"|\") # Replace * with *\n \
    \ txt.gsub!(\" \", \"|\") # Replace all spaces with |\n  txt.gsub!(/\\|+/, \"\
    |\") # Replace all | with *\n  txt.gsub!(/\\|+/, \"|\") # Replace all | with *\n\
    \  txt.gsub!(/\\|+/, \"|\") # Replace all | with", "  txt.split(/,|\\s+/)\nend",
  "  return txt.split(' ').flatten.map(&:downcase).uniq.map(&:chars).map(&:join)\n\
    end\n</code>\n<code>", "  return txt ? txt.split(/[,\\s]+/) : nil\nend", "  arr\
    \ = txt.split(' ')\n  if arr.count == 0\n    arr = txt.split(',')\n    return\
    \ arr.count\n  end\n  arr.count\nend", "  return txt.split(\" \") if txt.include?\
    \ \" \" else txt.split(\",\")\nend", "  # Your code here\nend", "  txt.downcase!\n\
    \  txt.gsub(/\\W+/, ' ').strip.split(/\\s+/).sort_by { |w| w.length }.delete_if{\
    \ |w| w.empty? }.to_a\nend", "  # Split words by space (\" \"), commas, or tab(\"\
    \\t\").\n  # Return array of all words.\n  # Examples\n  # split_words(\"Hello\
    \ world!\") \u279E [\"Hello\", \"world!\"]\n  # split_words(\"Hello,world!\")\
    \ \u279E [\"Hello,world!\"]\n  # split_words(\"abcdef\") == 3\n  txt.split(/ |,/)\n\
    end", "    txt = txt.downcase\n    return txt.scan(/\\w+/).uniq.count{|c| c.length}\
    \ % 2 == 0 ?\n        txt.scan(/\\w+/).uniq.map {|word| word.split.join(' ')}\
    \ :\n        txt.scan(/\\w+/).uniq.map {|word| word.split.join(',')}\nend", " \
    \ if txt.length == 0 then return nil\n  if txt.include?(/\\s/) then \n    txt.split(\"\
    \ \").map(&:capitalize).flatten.uniq.sort_by(&:downcase)\n  else \n    txt.scan(/[a-z]/).count\n\
    \  end\nend", "  txt.split(\" \").map {|w| w.split(\",\").map(&:strip) if w.match(/[a-z]/)}.flatten.compact.count\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is not what I was looking for.\
    \ I want to know how many different words are in that string, not how many different\
    \ words there are in total\n<|/ c |>\n<| a dscore=0 |>\nI wrote a quick python\
    \ script:\n<code>\ntext = \"\"\"The Quick Brown Fox Jumped Over The Lazy Dog.\"\
    \"\"", "  return txt.scan(/\\w+|\\S/).flatten.compact\nend", "  return txt.split('\
    \ ') if txt.count ' '  else txt.split(',') if ',' in txt else [txt.downcase.count('a')\
    \ - 1] + txt.downcase.count('z')\nend", "  words = txt.split\n  words.each do\
    \ |word|\n    word.gsub!(\",\", \" \").gsub!(/\\s+/, \" \")\n  end\n  words.count\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a dscore=0 tags=ruby |>\nHere is\
    \ a solution you can use.\n<code>", "    txt.split() if txt.include?(' ') else\n\
    \    txt.split(/,/) if txt.include?(',')\nend\n</cell>\n<text>\nA Simple Recursive\
    \ Function\nA recursive function can be seen as a loop that calls itself over\
    \ and over again. This can get complicated fast and for loops are great for that.\
    \ Recursive functions are useful in many situations. They can help you deal with\
    \ complexity and make your code more readable. Let's make a simple recursive function.\
    \ A recursive function is a function that calls itself over and over again. The\
    \ recursive function will call itself, until the base case is met. In this example,\
    \ the base case is when your function calls itself. If you have a good base case,\
    \ you should have a good recursive function.", "  txt = txt.downcase\n  words\
    \ = txt.split(' ')\n  words.reject!(&:empty?)\n  words.reject!(&:blank?)\n  words.reject!(&:start_with?(','))\n\
    \  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n\
    \  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n\
    \  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n\
    \  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n\
    \  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n\
    \  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n\
    \  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n\
    \  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n\
    \  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n\
    \  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n\
    \  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n\
    \  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))\n  words.reject!(&:start_with?(','))",
  "  txt = txt.downcase\n  txt.gsub!(/\\s+/, ' ')\n  txt.gsub!(/,/, ' ')\n  txt.gsub!(/[\
    \ ]{2,}/, ' ')\n  txt.gsub!(/[a-z]/, '') \n  txt.gsub!(/[a-z]/) do |w|\n    w.chars.each_with_object(0)\
    \ do |c, obj|\n      obj += 1 if (c < 'a'.ord or c > 'z'.ord)\n    end\n  end\n\
    \  txt.split(' ').length\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,string\
    \ |>\nHere is an example of a solution that uses regular expressions to split\
    \ the string into individual words and then use Enumerable#each_with_object to\
    \ count each character in a word.\n<code>", '  words = []', "  return txt if txt.split().count\
    \ == 1 \n  \n  a = txt.chars\n  a.each_index do |i|\n    a = txt.split(\"\")[i]\n\
    \    a = a ? a.split(\"\") : []\n    a = a.map { |w| w.tr!('a','b') }.flatten\n\
    \    a = a.map { |w| w.count('a') }.select { |w| w%2 == 1 }\n    a = a.map(&:to_i)\n\
    \    a = a.select { |w| w >= 0 }\n    a = a.uniq.to_a\n    a -= a.min if a.max\
    \ == a.min\n    a = a.first\n    a.each {|w| a << a.pop + 1 }\n    a.each {|w|\
    \ a.insert(0,0) }\n  end\n  \n  a\nend\n</code>\n<|/ a tags=ruby,arrays dscore=0\
    \ |>\n<| c |>\n`split` removes whitespace, `gsub` doesn't. And the whole thing\
    \ could be done in one line: `txt.chars.each_with_index.map {|w, i| i == 0 ? w\
    \ : w.gsub(/[a-z]/i, 'b').gsub(/[a-z]/i, 'a')}.compact`\n<|/ c |>\n<| c |>\n,\
    \ thanks for pointing that out. I've updated the answer. Regarding `gsub`, my\
    \ approach is to replace it with something that gives the exact same output as\
    \ in the question, without having to worry about any corner cases.\n<|/ c |>\n\
    <| c |>\nYour second block is still wrong. `str.chars` is `str` and that method\
    \ gives you an enumerator that generates characters in the string. `each_with_index`\
    \ is wrong because you don't know what values will be given to `i`.\n<|/ c |>\n\
    <| c |>\n, thanks for pointing that out. I've updated the answer\n<|/ c |>\n<|\
    \ c |>\nI've updated my answer, now it should match all the cases I've checked\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\nJust for the sake of diversity:\n<code>\n\
    str.chars.each_cons(2).map { |a, b| [a,b] }\n  #=> [[\"H\", \"e\"],\n  #    [\"\
    l\", \"l\"],\n  #    [\"o\", \"o\"],\n  #    [\"w\", \"o\"],\n  #    [\"o\", \"\
    d\"],\n  #    [\"!\", \"e\"],\n  #    [\"l\", \"l\"],\n  #    [\"l\", \"l\"],\n\
    \  #    [\"o\", \"o\"],\n", "  words = txt.split(//)\n  words.reduce(:+).to_s.split(//)\n\
    end", "  letters = txt.split('')\n  letters.each do |l|\n    letters[letters.index\
    \ {|i| i.downcase == l }] = ''\n  end\n  letters.count('') + (letters.count(',')\
    \ ? (letters.count(',').even? ? 1 : 0) : letters.count(',').odd?)\nend", "  words\
    \ = txt.split(' ')\n  if words.count('') == 0 then\n    words = words.join(',')\n\
    \  end\n  words.gsub!(/[^a-z]+/,'')\n  return words.downcase\nend", "  # Write\
    \ your solution here\n  words = txt.split(/\\s+/)\n  words.each { |word| word.gsub!(/,/,\
    \ '') }\n  words.size % 2 == 1 ? words.last.split('') : words.reverse\nend\n</code>\n\
    <|/ a |>\n<| a tags=string,ruby |>\nAnother simple solution:\n<code>", "  case\
    \ txt.length\n  when 0\n    []\n  when 1\n    [txt[0]]\n  when 2\n    [txt[0],\
    \ txt[1]]\n  else\n    letters = []\n    letters_count = 0\n    letters_odd_count\
    \ = 0\n    txt.split(\"\").each do |word|\n      word.split(\" \").each do |letter|\n\
    \        letters_count += 1\n        if letters_count == 2\n          letters_odd_count\
    \ += 1\n          letters_count -= 1\n        end\n      end\n      letters <<\
    \ letter\n    end\n    if letters_count == letters_odd_count\n      letters.count(\"\
    a\") + letters.count(\"e\") + letters.count(\"i\") + letters.count(\"o\") + letters.count(\"\
    u\")\n    else\n      letters.count(\"a\") + (letters.count(\"b\") + (letters.count(\"\
    c\") + (letters.count(\"d\") + letters.count(\"e\") + letters.count(\"f\") + letters.count(\"\
    g\") + letters.count(\"h\") + letters.count(\"i\") + letters.count(\"j\") + letters.count(\"\
    k\") + letters.count(\"l\") + letters.count(\"m\") + letters.count(\"n\") + letters.count(\"\
    o\") + letters.count(\"p\") + letters.count(\"q\") + letters.count(\"r\") + letters.count(\"\
    s\") + letters.count(\"t\") + letters.count(\"u\") + letters.count(\"v\") + letters.count(\"\
    w\") + letters.count(\"x\") + letters.count(\"y\") + letters.count(\"z\"))\n \
    \   end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you for that thorough\
    \ explanation. I'm getting `undefined method '+' for nil:NilClass` on line `letters\
    \ << letter` and it highlights line `if letters_count == letters_odd_count`\n\
    <|/ c |>\n<| c |>\nTry my latest update and see if that helps. I fixed my logic\
    \ errors.\n<|/ c |>\n<| c |>\nAh it worked, I wasn't thinking about the possibility\
    \ of letters being nil, thank you so much.\n<|/ c |>\n<| a dscore=1 |>\nA short\
    \ and sweet method would be to use Enumerable#partition here like this:\n<code>",
  "  words = txt.split.map(&:downcase)\n  if words.length == 0 || words.length ==\
    \ 1\n    words\n  else\n    words.map { |word| word.count(?\\w) }\n  end\nend",
  "  words = txt.strip.scan(/[^,]+/).map(&:downcase).reject { |word| word.empty? }\n\
    \  words.empty? ? words.count : words\nend", "  return txt.split(/[\\s,]+/) if\
    \ txt.match(/[\\s,]+/) else\n    [txt.split(//)].map{|words|words[0...-1].select{|word|word.include?(',')}}.map{|words|words[0...-1].select{|word|word.include?('\
    \ ')}}.map{|words|words[0...-1].select{|word|word.include?(/[a-z]/i)}}.count\n\
    end", "  words = txt.split /\\s/\n  if words.length == 0\n    words << ','\n \
    \   words << ','\n    words << ','\n    words << ','\n    words << ','\n    words\
    \ << ','\n  end\n  return words\nend", "  ret = []\n  if txt.include?(\" \") then\n\
    \    words = txt.split(\" \").map(&:capitalize)\n    words.each_with_index do\
    \ |word, i|\n      if ret.length != 0 then\n        if ret[-1].include?(\" \"\
    ) then\n          ret[-1] = ret[-1] + \" \" + word\n        elsif ret[-1].include?(\"\
    ,\") then\n          ret[-1] = ret[-1] + \",\" + word\n        else\n        \
    \  ret[-1] = ret[-1] + \",\" + word\n        end\n      elsif word.include?(\"\
    ,\") then\n        ret[-1] = word + \",\"\n      else\n        ret[-1] = word\n\
    \      end\n    end\n  else\n    letters = txt.split(\"\").map(&:ord)\n    ret\
    \ = []\n    letters.each_with_index do |letter, i|\n      if ret.length != 0 then\n\
    \        if ret[-1].include?(\" \") then\n          ret[-1] = ret[-1] + \" \"\
    \ + letter\n        elsif ret[-1].include?(\",\") then\n          ret[-1] = ret[-1]\
    \ + \",\" + letter\n        else\n          ret[-1] = ret[-1] + \",\" + letter\n\
    \        end\n      elsif letter.include?(\",\") then\n        ret[-1] = letter\
    \ + \",\"\n      else\n        ret[-1] = letter\n      end\n    end\n  end\n \
    \ ret\nend\n</code>\n<|/ a |>\n<| c |>\nJust for curiosity, how would you solve\
    \ this problem without using `each_with_index`?\n<|/ c |>\n<| c |>\nThanks for\
    \ your reply. Could you please also explain the logic behind your code?\n<|/ c\
    \ |>\n<| c |>\nSure, I'll edit the answer, but if you could help me understand\
    \ this piece of code. I would really appreciate it.\n<|/ c |>\n<| c |>\nAlright,\
    \ it works, thanks. One more question, what do you think about my solution? It\
    \ seems quite straight forward.\n<|/ c |>\n<| c |>\nThis is not correct solution,\
    \ see [this](http://codereview.stackexchange.com/questions/171911/split-words-in-a-string),\
    \ `split` with pattern `\" \"` on `Hello,world!` returns `[\"Hell,o,w,o,r,l,d,!\"\
    ]` which is not correct\n<|/ c |>\n<| a tags=ruby dscore=3 |>\nA different approach\n\
    <code>\nwords = \"Hello world!\"\nwords = words.split\nletters = words.map { ",
  "  txt.scan(/[^\\s]/).map(&:downcase).map(&:split).map(&:sort).map(&:uniq)\nend\n\
    </code>\n<|/ a tags=ruby,string,algorithm,split |>\n<| c |>\nYour last test case\
    \ should return `[\"abc\",\"bc\",\"c\"]`, not `[\"abc\",\"b\",\"c\"]`.\n<|/ c\
    \ |>\n<| c |>\nYes, the question is unclear, your comment is right. Will edit\
    \ for correction. Thanks.\n<|/ c |>\n<| c |>\nThis isn't very Ruby-like though,\
    \ especially since `scan` returns a `string`.\n<|/ c |>\n<| a |>\nI thought of\
    \ another way this morning.\n<code>\na = \"a1b2c3d4e5f6g7h8i9j0\"\nb = a.scan(/[a-z]/).sort\n\
    b.each_cons(2) do |x|\n  puts x.join\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
