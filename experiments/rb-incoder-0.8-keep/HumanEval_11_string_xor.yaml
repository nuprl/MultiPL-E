name: HumanEval_11_string_xor
language: rb
prompt: "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform\
  \ binary XOR on these inputs and return result also as a string.\n# >>> string_xor('010',\
  \ '110')\n# '100'\ndef string_xor(a, b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n\
  \    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"\
  111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n\
  \    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"
completions: ["  c = ''\n  b.each_byte { |b| c << [b] }\n  a.each_byte { |b| c <<\
    \ [b] }\n  c\nend", "    a_str = to_binary(a)\n    b_str = to_binary(b)\n    a_str.each_byte\
    \ { |c| c_str = c.chr; c_str ^= b_str }\n    a_str.to_s\nend", "  a, b = _to_binary(a),\
    \ _to_binary(b)\n  result = ''\n  while a && b\n    result << (a ^ b)\n    a,\
    \ b = a >> 1, b >> 1\n  end\n  result\nend", "  a, b = to_binary(a), to_binary(b)\n\
    \  return a.gsub(/0+/, '').gsub(/1/, '0') + b.gsub(/0+/, '').gsub(/1/, '0')\n\
    end", "  a_bin = to_binary(a)\n  b_bin = to_binary(b)\n  result = ''\n  for i\
    \ in 0..(a_bin.size -1)\n    result << (a_bin[i] ^ b_bin[i])\n  end\n  result\n\
    end", "  a.each_byte { |byte| b << byte }\n  b.each_byte { |byte| a << byte }\n\
    \  a\nend\n</code>\nThe above function string_xor takes in two strings as parameters\
    \ and performs a bit wise XOR operation on them. The function also returns a string.\n\
    <code>", "  return a.unpack('c*') ^ b.unpack('c*')\nend", "    len = length(a)\n\
    \    bx = b.chars.map { |c| [c].pack('c').unpack('C') }\n    ax = a.chars.map\
    \ { |c| [c].pack('c').unpack('C') }\n    ax.zip(bx).map do |a,b|\n      a ^ b\n\
    \    end.join\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n<| a tags=algorithm,ruby\
    \ dscore=1 |>\nYou can do that easily with the following piece of code:\n<code>",
  "  res = []\n  a.each_char do |x|\n    res << x\n  end\n  b.each_char do |x|\n \
    \   res << x\n  end\n  res.join\nend", "  # Return input string concatenated with\
    \ XOR of two input strings.\n  # return \"#{\"#{$a}#{\"^\"}#{$b}}\" rescue nil\n\
    \  return a.to_s.gsub(\"0\", \"1\") + \"#{\"^\"}#{\"+b.to_s.gsub(\"0\", \"1\"\
    )}\" rescue nil\nend", "    a.scan(/./).map{|i| i % 2}.inject(a){|s, i| s ^ i\
    \ }\nend\n</code>\n<|/ a tags=string,binary,ruby |>\n<| c |>\nThe `i` parameter\
    \ should be an instance of `Fixnum`.\n<|/ c |>\n<| c |>\nFixnum is just an alias\
    \ for Integer, and Ruby does not allow implicit conversion from Integer to Fixnum.\
    \ That is why I said \"as is\"\n<|/ c |>\n<| c |>\nIt should be noted that `String#scan`\
    \ only returns `nil` when the pattern matches no characters. Therefore, the `each`\
    \ loop can be replaced with `each_char`. And `inject` is more idiomatic than `map`\
    \ and `inject`\n<|/ c |>\n<| a |>\nIf you just want to convert it into a binary\
    \ string, then here's a way:\n<code>\n'0101'.unpack('C*').map{|b| b.to_s(2).count('1').zero?\
    \ ? '0' : '1'}.join\n=> \"100\"\n</code>\n<|/ a tags=string,binary,ruby dscore=5\
    \ |>\n<| c |>\nThis is the only one that works for me. As soon as I remove the\
    \ `'0'` from the `map`, it stops working. But otherwise, it works beautifully!\
    \ :)\n<|/ c |>\n<| c |>\nThis one should be the answer\n<|/ c |>\n<| c |>\nI like\
    \ the unpack method. Very handy :)\n<|/ c |>\n<| c |>\nThe `count` method is more\
    \ efficient than `include?`.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  return to_s(a\
    \ ^ b)\nend", "  xor = 0\n  for i in 0..a.length\n    xor += a.chars[i] ^ b.chars[i]\n\
    \  return xor.to_s\nend", "  return a.or(b) unless a.empty? || b.empty?\n  (a.length\
    \ * b.length).to_s(2).chars.each_slice(2).map do |pair|\n    a[pair[0]].or(b[pair[1]])\n\
    \  end.join\nend", "  result = \"\"\n  for i in 0...(8*a.length)\n    result +=\
    \ (Int(a[i..(i+1)])) ^ (Int(b[i..(i+1)]))\n  end\n  result\nend", "  res = \"\"\
    \n  lena = a.length\n  lenb = b.length\n  while lena > 0\n    res = res + a[lena\
    \ - 1] if a[lena - 1] ^ b[lenb - 1]\n    lena = lena - 1\n    lenb = lenb - 1\n\
    \  end\n  return res\nend", "  c = a ^ b\n  s = ''\n  for i in 0..(size(a) - 1)\
    \ do\n    s = s + c.chr\n  end\n  return s\nend", "    bina = [int(x) for x in\
    \ a.to_s(2).split(\"\")]\n    binb = [int(x) for x in b.to_s(2).split(\"\")]\n\
    \    res = \"\"\n    for i in xrange(len(bina))\n        res += chr(bina[i]^binb[i])\n\
    \    return res\nend", "  return a ^b\nend", "  a = \"0\" * (a.size & 1) + (a\
    \ & \"0\")\n  b = \"0\" * (b.size & 1) + (b & \"0\")\n  result = []\n  a.each_byte\
    \ do |c|\n    b.each_byte do |d|\n      result << (c ^ d)\n    end\n  end\n  return\
    \ result\nend", "  return a.chars.reduce(:^) ^ b.chars.reduce(:^)\nend", "  a.to_i(2).xor(b.to_i(2)).bin\n\
    end\n</code>\n<|/ a |>\n<| c |>\n`xor` is deprecated in Ruby 2.0.0, so I suggest\
    \ to use `^`\n<|/ c |>\n<| c |>\nThanks very much! I'm currently using 2.1.2 so\
    \ this was very helpful!\n<|/ c |>\n<| a |>\nHere's my solution for Ruby 2.2+\n\
    <code>", "  c = ''\n  c[0] = a[0] ^ b[0]\n  c[1] = a[1] ^ b[1]\n  c[2] = a[2]\
    \ ^ b[2]\n  c[3] = a[3] ^ b[3]\n  c[4] = a[4] ^ b[4]\n  c[5] = a[5] ^ b[5]\n \
    \ c[6] = a[6] ^ b[6]\n  c[7] = a[7] ^ b[7]\n  c[8] = a[8] ^ b[8]\n  c[9] = a[9]\
    \ ^ b[9]\n  c[10] = a[10] ^ b[10]\n  c[11] = a[11] ^ b[11]\n  c[12] = a[12] ^\
    \ b[12]\n  c[13] = a[13] ^ b[13]\n  c[14] = a[14] ^ b[14]\n  c[15] = a[15] ^ b[15]\n\
    \  return c\nend", "  # Make a, b as binary string\n  a_bin = number_to_binary(a)\n\
    \  b_bin = number_to_binary(b)", "  return a.scan(/../).join(a&b)\nend\n</code>\n\
    In ruby, it's easy, just use & for bitwise and | for bitwise or, ~ for bitwise\
    \ negation, >> for bitwise shift, << for bitwise shift left.\n<|/ a tags=xor,ruby\
    \ |>\n<| a dscore=0 tags=xor,ruby |>\n<code>\na = \"101\"\nb = \"100\"\na_nos\
    \ = a.chars.map(&:to_i)\nb_nos = b.chars.map(&:to_i)\nresult = a_nos.zip(b_nos).map\
    \ do |x, y| x ^ y end\nputs result", "  if a.length != b.length\n    raise ArgumentError,\
    \ \"Input vectors are not of same length\"\n  end\n  a.each_index { |i| a[i] =\
    \ (a[i] ^ b[i]) }\n  a.join('')\nend", "  a = a.to_s\n  b = b.to_s\n  result =\
    \ ''\n  while a != '' and b != '' and (a.length >= 2 and b.length >= 2)\n    result\
    \ = (a[0] ^ b[0]) + result\n    a = a[2..-1]\n    b = b[2..-1]\n  end\n  return\
    \ result\nend", "    bits = a.to_s(2)\n    bits = bits.concat(b.to_s(2))\n   \
    \ bits = bits.scan(/./).map { |x| x.to_s(2) }.join(\"\")\n    return bits\nend",
  "  return a^b\nend", "    return a ^ b\nend", "  return a.xor(b)\nend", "  a = a.to_s(2)\n\
    \  b = b.to_s(2)\n  xor = a.xor(b).to_s(2)\n  while xor.len() < 4\n    xor = \"\
    0\" + xor\n  end\n  return xor\nend", "  a ^ b\nend\n</pre>", "  return a.gsub(/0/,\
    \ '0&').gsub(/1/, '1&').gsub(/&/, '0').to_s\nend", "  xor_a = a.unpack('C*').inject(0){|sum,\
    \ val| sum + val}\n  xor_b = b.unpack('C*').inject(0){|sum, val| sum + val}\n\
    \  xor_a ^ xor_b\nend", "  a = a.split(//).map{ |x| x.to_i(2) }\n  b = b.split(//).map{\
    \ |x| x.to_i(2) }\n  return a.zip(b).map{ |x, y| x.xor(y).to_s(2) }.join\nend",
  "  return ((a.to_i(2) ^ b.to_i(2)).to_s(2).rjust(a.size + b.size + 1, '0'))\nend",
  "  result = a\n  a.each_byte { |x| result += x }\n  b.each_byte { |x| result +=\
    \ x }\n  result\nend\n</pre>", "  result = \"\"\n  for i in (0...a.length)\n \
    \   result << a.charAt(i).to_i(2) ^ b.charAt(i).to_i(2) \n    result << (i % 2\
    \ == 0 ? \"\\n\" : \"\")\n  end\n  return result\nend", "  a_bin = a.to_s(2).chars.map(&:to_i)\n\
    \  b_bin = b.to_s(2).chars.map(&:to_i)\n  xor = b_bin ^ a_bin\n  result = xor.map\
    \ {|x| x % 2 ? \"1\" : \"0\"}.join\nend", "    bina = to_binary(a)\n    binb =\
    \ to_binary(b)\n    return bin(int(bina, 2) ^ int(binb, 2)).to_s(2)\nend", " \
    \ a.each_char.with_index.map {|c, i| c^b[i%b.size]}.join\nend", "  res = a ^ b\n\
    \  a_rev = a[res.size - 1]\n  b_rev = b[res.size - 1]\n  if a_rev != b_rev\n \
    \   puts a_rev\n    puts b_rev\n    puts '-'\n    puts res\n  end\n  return res\n\
    end", "  return to_binary(a) ^ to_binary(b)\nend", "\tresult = ''\n\tfor i in\
    \ 0..(b.size-1)\n\t\tresult = result + (a[i] ^ b[i])\n\treturn result\nend", " \
    \   a, b = [to_str(a), to_str(b)] unless [a, b].all? { |s| s.class == String }\n\
    \    a, b = '' if a.empty? || b.empty?\n    a.succ! unless a.empty?\n    b.succ!\
    \ unless b.empty?\n    to_str(a).chars.map{|c| c == '0' ? 0 : 1 }.inject(:^).to_s\n\
    end\n</code>\n<|/ a tags=ruby,string,xor,binary,algorithm |>\n<| c |>\nThanks,\
    \ this is what I'm looking for. \nHowever, I cannot understand how this is different\
    \ from my string_xor(string, string).\n<|/ c |>\n<| c |>\nThe way you wrote it,\
    \ a is always the XOR of the string b. I think that's not what you want.\n<|/\
    \ c |>\n<| c |>\nI thought it was an exercise in binary operations, that's why\
    \ I implemented it that way. Thanks anyway.\n<|/ c |>\n<| a |>\nHere is my solution:\n\
    <code>", "    a_int = 0\n    b_int = 0\n    a_int = a.to_i\n    b_int = b.to_i\n\
    \    binary = bin(b_int)\n    binary_string = binary[2:].gsub(/../,\"\")\n   \
    \ # print binary_string\n    binary_string.reverse!\n    binary_string.gsub!(/./,\"\
    0\")\n    # print binary_string\n    result = \"\"\n    a_int = bin(a_int ^ b_int)\n\
    \    a_int.slice!(0...1)\n    a_int.reverse!\n    a_int.gsub!(/./,\"1\")\n   \
    \ result = a_int\n    return result\nend", "  a = a.to_s\n  b = b.to_s\n  result\
    \ = 0\n  for i in 0..a.length-1\n    result = result + a.chars.at(i).to_i ^ b.chars.at(i).to_i\n\
    \    result.to_s\n  end\n  result\nend\n</cell>\n<code language=julia-1.0>", " \
    \ return [a, b].map { |e| e ^ a[0] }\nend\n</pre>\n<p>\n<pre class=\"ruby\"><span\
    \ class=\"ruby-keyword\">class</span> <span class=\"ruby-constant\">String</span>\
    \ \n  <span class=\"ruby-keyword\">def</span> <span class=\"ruby-identifier\"\
    >each_char</span>\n    <span class=\"ruby-ivar\">@str</span>.<span class=\"ruby-identifier\"\
    >each_byte</span>\n    <span class=\"ruby-keyword\">self</span>\n  <span class=\"\
    ruby-keyword\">end</span>\n  <span class=\"ruby-keyword\">def</span> <span class=\"\
    ruby-identifier\">split</span>(<span class=\"ruby-identifier\">sep</span>)\n \
    \   <span class=\"ruby-keyword\">if</span> <span class=\"ruby-identifier\">sep</span>.<span\
    \ class=\"ruby-identifier\">is_a?</span>(<span class=\"ruby-constant\">Regexp</span>)\n\
    \      <span class=\"ruby-keyword\">if</span> <span class=\"ruby-ivar\">@str</span>.<span\
    \ class=\"ruby-identifier\">size</span> <span class=\"ruby-operator\">&gt;</span>\
    \ <span class=\"ruby-identifier\">sep</span>.<span class=\"ruby-identifier\">size</span>\n\
    \        <span class=\"ruby-identifier\">raise</span> <span class=\"ruby-constant\"\
    >ArgumentError</span>, <span class=\"ruby-node\">&quot;string size #{<span class=\"\
    ruby-ivar\">@str</span>.<span class=\"ruby-identifier\">size</span>} does not\
    \ match supplied separator #{sep}&quot;</span>\n      <span class=\"ruby-keyword\"\
    >end</span>\n      <span class=\"ruby-ivar\">@str</span>.<span class=\"ruby-identifier\"\
    >split</span>(<span class=\"ruby-identifier\">sep</span>)\n    <span class=\"\
    ruby-keyword\">end</span>\n    <span class=\"ruby-keyword\">if</span> <span class=\"\
    ruby-identifier\">sep</span>.<span class=\"ruby-identifier\">is_a?</span>(<span\
    \ class=\"ruby-constant\">String</span>)\n      <span class=\"ruby-keyword\">if</span>\
    \ <span class=\"ruby-ivar\">@str</span>.<span class=\"ruby-identifier\">size</span>\
    \ <span class=\"ruby-operator\">&lt;=</span> <span class=\"ruby-identifier\">sep</span>.<span\
    \ class=\"ruby-identifier\">size</span>\n        <span class=\"ruby-identifier\"\
    >raise</span> <span class=\"ruby-constant\">ArgumentError</span>, <span class=\"\
    ruby-node\">&quot;string size #{<span class=\"ruby-ivar\">@str</span>.<span class=\"\
    ruby-identifier\">size</span>} does not match supplied separator #{sep}&quot;</span>\n\
    \      <span class=\"ruby-keyword\">end</span>\n      <span class=\"ruby-ivar\"\
    >@str</span>.<span class=\"ruby-identifier\">split</span>(<span class=\"ruby-constant\"\
    >String</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-identifier\"\
    >sep</span>))\n    <span class=\"ruby-keyword\">end</span>\n    <span class=\"\
    ruby-keyword\">self</span>\n  <span class=\"ruby-keyword\">end</span>\n  <span\
    \ class=\"ruby-keyword\">def</span> <span class=\"ruby-identifier\">join</span>(<span\
    \ class=\"ruby-", "  if a.length != b.length\n    raise 'Length mismatch'\n  xor_result\
    \ = \"\"\n  for i in (0...a.length)\n    xor_result += a[i..i+1]^b[i..i+1]\n \
    \ end\n  return xor_result\nend", "  a.each_byte { |x| b << x }\n  b.to_s\nend",
  "  res = []\n  a, b = b.to_i(2), a.to_i(2) if a.is_a?(Fixnum) then a.to_s(2) else\
    \ a.to_i(2) end\n  b, a = b.to_i(2), a.to_i(2) if b.is_a?(Fixnum) then b.to_s(2)\
    \ else b.to_i(2) end\n  while a != 0\n    res.push a.chr ^ b.chr\n    a, b = a\
    \ >> 1, b >> 1\n  end\n  res + [''] * (b.size % 2)\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThe question was about performance, not correctness. What happens if the\
    \ input is `\"10\"`?\n<|/ c |>\n<| c |>\n\"Performance is not an issue in my case\"\
    \ - and what's wrong with the result? It's not \"correct\", but it's not incorrect.\n\
    <|/ c |>\n<| c |>\nThe \"correct\" result would be \"0100\", which is indeed the\
    \ correct answer, but it's more complicated to implement.\n<|/ c |>\n<| c |>\n\
    What makes you think performance is needed?\n<|/ c |>\n<| c |>\nPerformance is\
    \ not an issue in my case. I was just looking if there was a better way to convert\
    \ a binary string to a string.\n<|/ c |>\n<| a tags=binary,ruby,string dscore=2\
    \ |>\n<code>\nbin = 10.to_s(2)\n\"0#{bin.rjust(4,'0')}\"\n</code>\n<|/ a |>\n\
    <| c |>\nThis should be `bin.to_s(2).rjust(4,'0')`, as in `bin.to_s(2).rjust(4,\
    \ '0')` returns `\"0010\"`, not `\"010\"`.\n<|/ c |>\n<| c |>\n`bin.rjust(4, '0')`\
    \ returns `\"0010\"` only if `bin.to_s(2)` is `\"10\"`.\n<|/ c |>\n<| c |>\nMy\
    \ mistake, I meant `to_s(2).rjust(4,'0')`, not `to_s(2).rjust(4, '0')`. I updated\
    \ the answer.\n<|/ c |>\n<| c |>\nI believe this will return `\"010\"` for `\"\
    110\"` because `'0'` is `\"0\"`.\n<|/ c |>\n<| c |>\n`'0'` === `\"0\"` => `'0'`\
    \ === `\"0\"` => `\"0\"`\n<|/ c |>\n<| a |>\nHere is an example using Integer#",
  "    a_to_b = [\n        [1,0],\n        [0,1],\n        [1,0],\n        [0,1],\n\
    \        [1,0],\n        [0,1],\n        [1,0],\n        [0,1],\n    ]\n    xor_a\
    \ = 0\n    xor_b = 0\n    for i in 0..(a.len-b.len)\n        xor_a += a_to_b[i][a.index(b[i])]\n\
    \        xor_b += a_to_b[i][b.index(a[i])]\n    return sprintf(\"%d\", xor_a ^\
    \ xor_b)\nend\n</cell>\n<code language=julia-0.5>", "  return a^b\nend", "  return\
    \ \"#{a[1..-1] ^ b[1..-1]}\"\nend\n</code>\nThis code is really simple. Just split\
    \ both inputs by '0' or '1' and perform XOR on them.\n<|/ a |>\n<| a |>\nIf you're\
    \ using Ruby 2.3+, you can use Array#bit_length.\n<code>", "  res = ''\n  (a +\
    \ b).each_char.with_index do |char, index|\n    res << ((char == '1') ? '0' :\
    \ '1')\n  end\n  res\nend\n</cell>\n<cell>", "  a.each_byte { |b| result = result\
    \ ^ b }\n  result\nend", "  result = a ^ b\n  result.to_s.reverse!\n  result.reverse!\n\
    \  result\nend", "    a.each_char.with_index do |x,i|\n        b.each_char.with_index\
    \ do |y,j|\n            puts \"#{x}#{y}#{x ^ y}\" if (x != y && (i % 8 == j %\
    \ 8))\n        end\n    end\nend", "  return ''.join([chr(ord(a[i]) ^ ord(b[i]))\
    \ for i in range(len(a))])\nend", "  result = a\n  a.each_char do |c|\n    result\
    \ << b if (c == '1') && (b.include?('1'))\n    result << c if (c == '0') && (b.include?('0'))\n\
    \  end\n  result\nend", "  result = ''\n  a.each_byte do |b|\n    a << b\n  end\n\
    \  a.each_byte do |b|\n    result << (b ^ a.last)\n  end\n  result\nend", "  a\
    \ ^= b\n  a ^= a >> 8\n  a ^= a >> 16\n  a ^= a >> 24\n  a ^= a >> 32\n  a ^=\
    \ a >> 40\n  a ^= a >> 48\n  a ^= a >> 56\n  a = a.to_s(2)\n  a.insert(0, 0)\n\
    \  a[-1] = 48\n  a\nend", "  a1 = a.gsub(/0/, '1')\n  b1 = b.gsub(/0/, '1')\n\
    \  s = a1 ^ b1\n  result = []\n  while s.length /= 2\n    result << s[0, s.length]\n\
    \  end\n  result.join('')\nend", "  a.each.with_index do |x,i|\n    b.each.with_index\
    \ do |y,j|\n      ret[i] = x^y if i==j\n    end\n  end\n  ret\nend", "  a_int\
    \ = to_int(a)\n  b_int = to_int(b)\n  a_char = to_char(a_int ^ b_int)\n  a_int\
    \ = to_int(a_char)\n  a_int = to_char(a_int)\n  return a_int\nend", "  return\
    \ a.xor(b).to_s\nend", "    a.to_i(2).bit_xor(b.to_i(2)).to_s(2)\nend\n</cell>\n\
    <cell>\nstring_xor('010', '110')\n</cell>\n<cell>", "    return a.to_i(2) ^ b.to_i(2)\
    \ \nend", "  a = binascii.unhexlify(a)\n  b = binascii.unhexlify(b)\n  xor = a^b\n\
    \  return xor.to_s(16)\nend", "  return ((a ^ b) ^ ('a' * a.length)).to_s\nend",
  "  xor = a.unpack('C*').map { |b| b.chr(b.ord() ^ b.ord()) }.pack('C*')\n  xor\n\
    end\n</code>\n<|/ a tags=xor,ruby,bitwise-operators,string |>\n<| a dscore=2 |>\n\
    <code>\n\"0000\".reverse.scan(/./).map(&:ord).inject('') do |acc, chr|\n  acc\
    \ + (chr&1 ? '1' : '0')\nend\n</code>\n<|/ a tags=xor,ruby,bitwise-operators,string\
    \ |>\n<| c |>\nNice and concise solution that uses the inject method.  Thanks!\n\
    <|/ c |>\n<| a tags=xor,ruby,bitwise-operators,string |>\nA solution in Ruby 1.9.\n\
    <code>\nirb(main):009:0> \"0000\".scan(/./).map(&:ord).inject(''){|acc,v| acc\
    \ + (v&1 ? '1' : '0') }\n=> \"0100\"\n</code>\n<|/ a dscore=2 |>\n<| a tags=xor,ruby,bitwise-operators,string\
    \ dscore=2 |>\nI realise this was asked a long time ago, but I came across it\
    \ today and thought I'd share the XOR-ing function I came up with. It's not as\
    \ short as it could be, but it's short and readable.\nI came up with this:\n<code>",
  "  result = ''\n  a + (b * 2).reverse.each_char.with_index { |e, i| result += e\
    \ * (i & 1).to_s }\n  result\nend", "  binary_a = string_to_bytes(a)\n  binary_b\
    \ = string_to_bytes(b)\n  xor = binary_a.xor(binary_b)\n  return bytes_to_string(xor)\n\
    end", "  a = a.to_s\n  b = b.to_s\n  a.each_byte do |x|\n    b.each_byte do |y|\n\
    \      next if x.chr == '0' && y.chr == '0'\n      xord = x.ord\n      yord =\
    \ y.ord\n      xor = xord.chr + yord.to_s\n      break if xor == '0'\n      result\
    \ = xor\n      break if xor == '1'\n    end\n  end\n  return result\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis is actually a cool solution - but only works\
    \ because `ord == '1'`. If you add more characters to `a`, this will fail.\n<|/\
    \ c |>\n<| a |>\nThis is what I ended up with (it uses recursion and passes back\
    \ the result to the caller).\n<code>", "    a.gsub!('1', '0')\n    b.gsub!('1',\
    \ '0')\n    c = a.xor(b)\n    c.to_s\nend\n</code>\nAnd now you can perform string\
    \ operations with these methods:\n<code>", "  result = \"\"\n  for i in 0..(length(a)\
    \ - length(b))\n    result << (a[i..i + length(b)]) ^ (b[i..i + length(b)]).to_s(2)\n\
    \  end\n  result\nend", "  a ^= b\n  a = a.to_s(2).reverse\n  b = b.to_s(2).reverse\n\
    \  \"#{\"%x\" % a.each_byte.inject(:^)}#{\"%x\" % b.each_byte.inject(:^)}\".unpack(\"\
    C*\").reverse.join\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI thought of this,\
    \ but I wanted to do it in pure Ruby and not require Rails. But that's a good\
    \ idea, though I guess this won't work as well.\n<|/ c |>\n<| c |>\nNo problem\
    \ -- I haven't tried it, but it looks good to me!\n<|/ c |>\n<| a tags=xor,ruby\
    \ dscore=3 |>\nHere's my simple solution. It uses XOR and XNOR to XOR the two\
    \ strings and then XORs each byte of the result with the corresponding bytes of\
    \ both strings:\n<code>", "  result = ''\n  i = 0\n  while i < b.length\n    c\
    \ = a[i]\n    d = b[i]\n    result += [c^d]\n    i += 1\n  end\n  return result\n\
    end", "  res = ''\n  a_arr = a.split(\"\")\n  b_arr = b.split(\"\")\n  a_arr.each_with_index\
    \ do |x, i|\n    res += (x ^ b_arr[i]).to_s\n  end\n  return res\nend", "  x =\
    \ a.to_i(2).to_s(2)\n  y = b.to_i(2).to_s(2)\n  x.each_char.with_index do |c,\
    \ i|\n    y + (x[i] ^ y[i])\n  end\nend", "    return bin((int(a) ^ int(b)))[2:]\n\
    end", "  result = \"\"\n  a.each_char{ |c| result << c if c == '1' } # Convert\
    \ each character to a string and append to the result string.\n  b.each_char{\
    \ |c| result << c if c == '1' } # Convert each character to a string and append\
    \ to the result string.\n  return result\nend", "  return a.xor(b).to_s\nend",
  "  c = a.gsub(/1/,'0').gsub(/0/,'1')\n  d =  b.gsub(/1/,'0').gsub(/0/,'1')\n  return\
    \ c.gsub(/1/,'0').gsub(/0/,'1') + d.gsub(/1/,'0').gsub(/0/,'1')\nend", "  return\
    \ a.unpack('C*').inject(:^).unpack('C*').join\nend", "  return a.xor(b).to_s\n\
    end", "  xor = 0\n  for x in a\n    xor |= x.ord\n  for x in b\n    xor ^= x.ord\n\
    \  return xor.to_s(2).chars.to_a\nend", "    # Write your code here.\n    \n \
    \   result = \"\"\n    \n    chars = list(a)\n    chars.extend(list(b))\n    chars.sort\n\
    \    \n    for i,c in enumerate(chars):\n        if chars[i] == '0':\n       \
    \     result += c\n        else:\n            result += '1'\n            \n  \
    \  return result", "  a.to_i(2) ^ b.to_i(2)\nend", "  return a.gsub(/./, '') -\
    \ b.gsub(/./, '').xor('0' * b.length).to_s\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nIf this is part of a class, then you should probably add `def xor(a,\
    \ b)` so people can call it on strings, instead of using it on numbers.\n<|/ c\
    \ |>\n<| c |>\nAgreed. Updated the answer to reflect this.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nI suggest you use the bitwise operators. They are very powerful and fast\
    \ (they also work across multiple processors) in Ruby:\n<code>\n>> 1 << 6\n=>\
    \ 64\n>> 64 ^ (1 << 6)\n=> 13\n</code>\nThe first operator shifts a by six bits\
    \ to the left. The second operator computes xor between two numbers (a^b) and\
    \ the result is a binary number.\n<|/ a dscore=1 |>\n<| c |>\nAs a side note,\
    \ you can use bitwise operations in your strings or integers and get something\
    \ pretty fast (`1 << 6` is actually `64` in binary).  You can still do things\
    \ like `a & b` or `a | b`.  You can even do `a & b | c & d` with two bitwise operations.\
    \  Bitwise operators are still faster than the usual string operations.\n<|/ c\
    \ |>\n<| a dscore=1 |>\nYou can do:\n<code>\na = \"11011101\"\nb = \"11011110\"\
    \na.zip(b).map(&:xor).join", "  return a.gsub(/./, '').gsub(/./, '') ^ b.gsub(/./,\
    \ '').gsub(/./, '')\nend\n</cell>\n<cell>", "  a.split('').map.with_index { |c,\
    \ i| b[i % b.size] ^ c }.join\nend\n</code>\n<code>\n[root@sandbox ~]# string_xor('010',\
    \ '110')\n => '100'\n</code>\nAnd you can even make it more generic as shown below.\n\
    <code>", "  return a.chr ^ b.chr.to_i\nend", "  result = ''\n  for i in (0...a.length)\n\
    \    result = result + ((a >> i & 1) == (b >> i & 1) ? '1' : '0')\n  end\n  return\
    \ result\nend", "  s = a.unpack('C*') + b.unpack('C*')\n  puts s.map { |x| x ^\
    \ 1 }.pack('C*')\nend", "  \n  # Convert the strings to binary.\n  a_bin = binary_to_bits(a)\n\
    \  b_bin = binary_to_bits(b)", "  if a == '' and b == ''\n    return ''\n  else\n\
    \    return a.to_i(2) ^ b.to_i(2) # Convert to binary string\n  end\nend", " \
    \ a = a.to_s\n  b = b.to_s\n  \n  result = ''\n  \n  if a.length != b.length\n\
    \    raise ArgumentError, 'Input strings are not of equal length.'\n  end\n  \n\
    \  a.each_byte { |x|\n    b.each_byte { |y|\n      result = x ^ y\n    }\n  }\n\
    \  \n  return result\nend\n  ", "  a = a.to_s\n  b = b.to_s\n  return a.chars.map\
    \ { |i| b & i }.reverse.join\nend", "  result = a\n  for i in 0..(a.length-1)\n\
    \    result << 1 if a[i] ^ b[i]\n  end\n  result\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 tags=ruby,binary,xor,string |>\nThis was a fun challenge,\
    \ so I decided to do it in Ruby. You can see it in action here.\n<code>", "  a_bits\
    \ = a.each_char.map {|x| x.ord.to_s(2)}\n  b_bits = b.each_char.map {|x| x.ord.to_s(2)}\n\
    \  xor_bits = a_bits.zip(b_bits).map {|x,y| x ^ y}\n  xor_bits.join\nend", " \
    \ a = a.to_s\n  b = b.to_s\n  length = a.length\n  result = \"\"\n  for i in (0..(length-2)).step(length)\n\
    \    result << (a[i..i+2].to_i ^ b[i..i+2].to_i)\n  end\n  return result\nend",
  "  return a ^ b\nend", "    a.chars.zip(b.chars).map { |c| c.reduce(:&) }.join\n\
    end\n</code>\n<|/ a tags=string,arrays,ruby |>\n<| c |>\nThis does not answer\
    \ the question which was \"how to perform the bitwise XOR operation on two strings\"\
    . Also, it's not very clear from the example how XOR is supposed to be performed.\n\
    <|/ c |>\n<| a |>\nIn case anyone else is looking for an XOR operation between\
    \ strings:\n<code>", "  return a.unpack('c*').map { |e| e ^ b }.pack('c*')\nend",
  "  a.each_char.map {|c| b & c}.join\nend\n</code>\n<|/ a |>\n<| c |>\nThank you\
    \ for providing this.  It has helped me understand how this can be implemented.\n\
    <|/ c |>\n<| a dscore=3 tags=string,ruby,binary,xor |>\nThis is my version of\
    \ binary xor.\n<code>", "  a = a.to_s\n  b = b.to_s\n  return a.chars.zip(b.chars).map\
    \ { |x, y| (x ^ y) }.join\nend", "  return [((x || y) and 1) for x, y in zip(a,\
    \ b)]\nend\n</code>\nTo see this in action run\n<code>\nputs string_xor('010',\
    \ '110')\n</code>\n<|/ a dscore=3 tags=string,ruby,arrays |>\n<| c |>\nThanks,\
    \ it's very helpful!\n<|/ c |>\n<| c |>\nNice answer! For a Ruby novice, I would\
    \ suggest changing the variable names a and b to something more descriptive (to\
    \ help readability and to avoid confusion with the String methods)\n<|/ c |>\n\
    <| a |>\nAn efficient way to do this without creating a new array is to just use\
    \ Array#each_index:\n<code>", "  a.each do |char|\n    b.each do |char2|\n   \
    \   if (char != char2)\n        char = a\n        break\n      end\n    end\n\
    \  end\n  return a\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nWhy are you passing\
    \ the return value of the `map` method as an argument to the `xor` method? That\
    \ method returns the original array unmodified.\n<|/ c |>\n<| c |>\nI thought\
    \ I needed to do this to return the strings as arrays, however I don't think the\
    \ map method is really necessary. Would there be a more efficient way to do this?\n\
    <|/ c |>\n<| c |>\nNo, there's no need for it.\n<|/ c |>\n<| a |>\nI came up with\
    \ a very simple answer for this. Just do the following:\n<code>", "  \n  # Initialize\
    \ variables \n  a = [a]\n  b = [b]\n  a_copy = [a]\n  b_copy = [b]\n  \n  # Add\
    \ extra zeros to a\n  while a.length < 4\n    a.push(0)\n  end\n  \n  # Add extra\
    \ zeros to b\n  while b.length < 4\n    b.push(0)\n  end\n  \n  \n  # Perform\
    \ binary XOR on a and b\n  a.each do |element|\n    b_copy.push(element)\n  end\n\
    \  b.each do |element|\n    a_copy.push(element)\n  end\n  \n  \n  # Sum up the\
    \ result\n  a_copy.each do |element|\n    a_copy.push(element)\n  end\n  b_copy.each\
    \ do |element|\n    a_copy.push(element)\n  end\n  a_copy.pop\n  b_copy.pop\n\
    \  \n  \n  a_copy.each_with_index do |element, index|\n    if index == 0\n   \
    \   element += b_copy[index + 1]\n    else\n      element += a_copy[index - 1]\n\
    \    end\n  end\n  \n  return a.join(\"\")\nend", "  result = ''\n  a.each_byte\
    \ { |b| result << b if b }.join\n  b.each_byte { |a| result << a if a }.join\n\
    \  result\nend", "    # convert binary strings to decimal strings by adding '0'\
    \ as separator\n    a_d = binary_to_dec(a + '0')\n    b_d = binary_to_dec(b +\
    \ '0')\n    # perform XOR operation on those decimal strings\n    ans = a_d ^\
    \ b_d\n    # convert decimal result back to binary string\n    ans = binary_to_bin(ans)\n\
    \    return ans\nend", "\ta_bin = to_binary(a)\n\tb_bin = to_binary(b)", "  a_int\
    \ = to_int(a)\n  b_int = to_int(b)\n  res = ''\n  while a_int.to_s.length != 0\
    \ or b_int.to_s.length != 0\n    if a_int != b_int\n      res += '0'\n    elsif\
    \ a_int.to_s.length == 0\n      res += b_int.to_s\n      break\n    elsif b_int.to_s.length\
    \ == 0\n      res += a_int.to_s\n      break\n    else\n      res += a_int.to_s.chars.zip(b_int.to_s.chars).map\
    \ { |(x, y)| x ^ y }.join\n      a_int = to_int(a_int << 1)\n      b_int = to_int(b_int\
    \ >> 1)\n    end\n  end\n  res\nend\n</code>\n<|/ a tags=algorithm,ruby,ruby-on-rails\
    \ |>\n<| a tags=algorithm,ruby,ruby-on-rails |>\nThis is a nice exercise for using\
    \ a bit shift and a bit mask. I don't know if it's the fastest solution but it's\
    \ easy to read and easy to understand.\n<code>", "  a, b = a.to_s(2), b.to_s(2)\n\
    \  a.each_byte.map { |b| b.reverse ^ b.last }.join.downcase\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nI think you meant to write `a.each_byte.map { |b| b ^ b.last\
    \ }.join.downcase`\n<|/ c |>\n<| c |>\nThank you! Yes, I meant that to write `a.reverse\
    \ ^ a.last` instead of `a.each_byte.map { |b| b.reverse ^ b.last }.join.downcase`.\
    \ I had not realized that `map` can take a block argument :)\n<|/ c |>\n<| c |>\n\
    `[a, a, a].map { |v| v ^ v[-2] }.reduce(:^)` :)\n<|/ c |>\n<| c |>\nHow would\
    \ you do this with strings of different lengths?  I mean, in `string_xor` it works\
    \ because it's always a string of length 2. But how would I do it in a more general\
    \ way?\n<|/ c |>\n<| c |>\n: What kind of generality are you expecting? The only\
    \ thing I can think of is that the first and last character are always 1 and 0,\
    \ respectively. But then you'd need to account for `nil`.\n<|/ c |>\n<| a tags=string,xor,ruby\
    \ |>\nSince you are trying to XOR the characters in pairs, the answer provided\
    \ by is perfect. Here is a Ruby method that works with strings of different lengths\
    \ including empty ones, without returning nil:\n<code>", "  return (a.length >\
    \ b.length) ? a : b.insert(b.length - a, '\\0')\nend", "  return (a.length * b.length).times.map\
    \ { |i|\n    i = a.ord(i).to_s(2) ^ b.ord(i).to_s(2)\n    i.to_s(2).rjust(4, '0')\n\
    \  }.join\nend\n</code>\n<|/ a tags=xor,cryptography,ruby dscore=4 |>\n<| a tags=xor,cryptography,ruby\
    \ |>\nI solved this problem a while back for a project I had.  I actually wrote\
    \ a gem for this that had a blog post on it, but I can't find the link now.\n\
    So here's my solution:\n<code>", "  a.each_byte { |byte| a << (byte ^ b.byte)\
    \ }\n  a\nend", "  xor = (a.unpack('C*') ^ b.unpack('C*')).pack('C*')\n  return\
    \ xor\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the answer.  I actually need\
    \ this for a homework assignment, but I'll definitely look into this!\n<|/ c |>\n\
    <| c |>\n, what do you mean by \"homework assignment\"? It's not a standard question,\
    \ can you provide a reference?\n<|/ c |>\n<| c |>\nI mean a homework assignment\
    \ that I have to complete using what I've learned.\n<|/ c |>\n<| c |>\n, sorry,\
    \ don't know what to call it, but I'm guessing it's related to [homework assignment](http://meta.stackexchange.com/questions/10811/how-do-i-ask-and-answer-homework-questions).\
    \ :)\n<|/ c |>\n<| c |>\nI ended up going with a different solution, but this\
    \ was very helpful in helping me understand the algorithm better.  Thanks!\n<|/\
    \ c |>\n<| a dscore=0 |>\nI used the answer from above but did some modifications\
    \ to it for my use. I needed a checksum so I used the above solution but changed\
    \ the '0' to '1' and '1' to '0' before and after converting to binary and added\
    \ the binary values together. Here is an example of the modifications:\n<code>\n\
    checksum = (string_xor(string_to_binary(a), string_to_binary(b)) + (string_to_binary(a)\
    \ ^ string_to_binary(b)))\n</code>\n<|/ a tags=string,binary,xor,ruby |>\n<| a\
    \ tags=string,binary,xor,ruby |>\nYou can convert the string to a binary array\
    \ using each_char and then use Array#sum to combine all binary values into one\
    \ number:\n<code>\n\"010\".hex.to_i(2) # => 5\n\"110\".hex.to_i(2) # => 4\n\"\
    010\".hex.to_i(2).to_s(2) # => \"100\"\n\"110\".hex.to_i(2).to_s(2) # => \"110\"\
    \n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for the answer!  I tried implementing\
    \ this but am getting an error saying \"undefined method 'sum' for 10:Fixnum\"\
    .\n<|/ c |>\n<| c |>\nThat's odd. I don't get any such error. Which version of\
    \ Ruby are you using?\n<|/ c |>\n<| a tags=string,binary,xor,ruby |>\nIf anyone\
    \ wants some speed for X", "  if a.length != b.length\n    throw :invalid_length\n\
    \  result = '\\0'\n  (0..(a.length()-1)).each do |i|\n    result << (a[i..i+1]^b[i..i+1])\n\
    \  end\n  result\nend", "  binxor_a = a.to_s(2) ^ b.to_s(2)\n  return binxor_a.to_s(2)\n\
    end", "  a = a.to_s(2)\n  b = b.to_s(2)\n  return ((a || b) ^ ((a && b) == 0))\n\
    end", "  result = a ^ b\n  binary = result.to_s(2)\n  binary_int = binary.to_i(2).to_s(2)\
    \ # Convert to binary string and convert to integer\n  return binary_int\nend",
  "  a ^ b\nend", "  xor = [0, 0]\n  for i in 0..a.length-1\n    xor[0] += (a[i] ==\
    \ b[i]) ? 0 : 1 # xor[0] = xor of a[i] and b[i]\n    xor[1] += (a[i] == b[i])\
    \ ? 1 : 0 # xor[1] = xor of a[i] and b[i]\n  return [xor[0] >> 1, xor[1] >> 1].join\n\
    end", "  return a.gsub(/1|0/) do |x|\n    x.size == 1 ? x[0] : '0' + x\n  end\n\
    end", "  result = nil\n  for i in 0..(a.length-1)\n    result = (result*2)+a[i].to_i.xor(b[i].to_i).to_s\n\
    \  end\n  return result\nend", "  xor = a.chars.zip(b.chars).map { |x,y| x ^ y\
    \ }.pack('C*')\n  xor = xor.byteswap.unpack('U*').map { |x| x.to_s(2) }.join\n\
    \  return xor\nend\n</code>\n<|/ a |>\n<| c |>\nThat is amazing, and a great example\
    \ to learn from. Nice and easy!\n<|/ c |>\n<| c |>\nI appreciate your answer but\
    \ I believe it's still incorrect. Can you please provide a correct solution?\n\
    <|/ c |>\n<| c |>\nThe XOR algorithm is incorrect for large inputs. See [my answer](http://stackoverflow.com/a/41634094/849891).\n\
    <|/ c |>\n<| a dscore=4 tags=ruby,string |>\nHere is a simple solution (no benchmarks\
    \ though): \n<code>\nstr = \"010\"\nnum = \"110\"", "  a = a.to_s\n  b = b.to_s\n\
    \  a = a.each_char.with_index.map { |x, i| x ^ b[i%b.length].to_s }.join\n  return\
    \ a\nend", "  a_str = a.to_s(2)\n  b_str = b.to_s(2)\n  return a_str[-b_str.size..-1]\
    \ + b_str[-a_str.size..-1]\nend", "  xor_result = a.unpack('C*').reverse.map {\
    \ |x| x ^ b.unpack('C*').first }.join(\"\")\n  return [xor_result, xor_result.reverse].pack('C*')\n\
    end\n</code>\n<|/ a tags=string,ruby |>\n<| c |>\nI did not know you could do\
    \ that with the `unpack` method. Learn something new everyday!\n<|/ c |>\n<| c\
    \ |>\n`unpack` has some quirky behaviour for strings with more than 255 characters,\
    \ though, so if there are a lot of trailing zeros, it might be a good idea to\
    \ add a `.reverse` after `pack`.\n<|/ c |>\n<| c |>\n.D. I agree, I'll add the\
    \ `reverse` call asap. By the way, do you think you could help me with [this question](http://stackoverflow.com/questions/42497594/how-to-check-if-string-is-all-zeros-in-ruby)?\n\
    <|/ c |>\n<| a tags=string,ruby |>\nA way in pure ruby:\n<code>", "  a = a.to_s\n\
    \  b = b.to_s\n  result = ''\n  while a.length <= b.length\n    temp = a\n   \
    \ a = b\n    b = temp\n  end\n  a_index = 0\n  b_index = 0\n  while a_index <=\
    \ a.length - 1 && b_index <= b.length - 1\n    if a[a_index] == b[b_index]\n \
    \     result << a_index\n      a_index += 1\n      b_index += 1\n    else\n  \
    \    if a_index < a.length - 1\n        result << a_index\n        a_index +=\
    \ 1\n      end\n      if b_index < b.length - 1\n        result << b_index\n \
    \       b_index += 1\n      end\n    end\n  end\n  if a_index < a.length - 1\n\
    \    result << a_index\n  end\n  if b_index < b.length - 1\n    result << b_index\n\
    \  end\n  result\nend", "    a, b = a.to_s(2), b.to_s(2)\n    result = \"\"\n\
    \    a.each_byte {|x| result << x ^ b.shift }\n    result\nend", "\ta = [a]\n\t\
    b = [b]\n\treturn ((a.map {|b| b ^ b } + b.map {|a| a ^ a }).reduce(:^))\nend",
  "  a_bin = binary_string(a)\n  b_bin = binary_string(b)\n  return binary_string(binascii.unhexlify(a_bin\
    \ ^ b_bin))\nend", "  binary = string_of_int(a) ^ string_of_int(b)\n  binary.to_s(2)\n\
    end\n</code>\nAnd we can test this as below:\n<code>\nputs string_xor('100', '101')",
  "  return a.xor(b).to_s\nend", "  a = [a, b].map { |i| i.to_s(2) }\n  a.join('').reverse.chars.map{|i|\
    \ i.chr}.join\nend", "  x = 0\n  c = 0\n  x = 0\n  while c <= a.length\n    if\
    \ a.chars[c] == b.chars[c]\n      x << 1\n      x += 1\n      c += 1\n    end\n\
    \    c += 1\n  end\n  return x\nend", "  binary_xor = a.bytes * b.bytes == 0\n\
    \  return binary_xor ? a.to_s(2) + b.to_s(2) : nil\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| a |>\nI came across this problem recently, and here is my solution which\
    \ also works for arrays and is more efficient. I think it's a little easier to\
    \ read than the previous examples. \n<code>", "  s = a\n  s += b if a < b else\
    \ b if a > b else a if a.eql?(b)\n  s.reverse\nend", "  a_bin = binary_string(a)\n\
    \  b_bin = binary_string(b)\n  xor = a_bin ^ b_bin\n  return to_binary(xor)\n\
    end", "  result = \"\"\n  a = a.to_s\n  b = b.to_s\n  result = (a.to_i(2) ^ b.to_i(2)).to_s(2)\n\
    \  return result\nend\n</cell>\n<code language=julia-1.5>\nusing BenchmarkTools\n\
    </cell>\n<code language=julia-1.5>\n@benchmark string_xor(\"010\", \"110\")\n\
    </cell>\n<code language=julia-1.5>\nfunction string_xor2(a, b)\n    result = \"\
    \"\n    a = a.to_s\n    b = b.to_s\n    result = (a ^ b).to_s(2)\n    return result\n\
    end\n</cell>\n<code language=julia-1.5>\n@benchmark string_xor2(\"010\", \"110\"\
    )\n</cell>\n<text>\nExercise", "    binx = bin(a)\n    biny = bin(b)\n    sum\
    \ = 0\n    for i in binx:\n        sum += int(i) * int(biny[i])\n    return str(sum\
    \ % 2)\n</cell>\n<cell>\nstring_xor('1001', '1101')\n</cell>\n<cell>\nstring_xor('1001',\
    \ '1110')\n</cell>\n<cell>", "  a.unpack('C*').pack('C*') ^ b.unpack('C*').pack('C*')\n\
    end\n</code>\nThe second method uses the BitArray class, which handles bit operations\
    \ on strings. This method is faster, but requires RubyGems to be installed.\n\
    <code>", "  a1 = to_binary(a)\n  b1 = to_binary(b)\n  a2 = []\n  b2 = []\n  a.split(\"\
    \").each do |x|\n    a2.push(x)\n  end\n  b.split(\"\").each do |x|\n    b2.push(x)\n\
    \  end\n  a2.zip(b2).each do |x, y|\n    xor = xor.chr + y\n  end\n  xor\nend",
  "  a.each_byte { |b| a = a.chr ^ b.chr if a.ord > 0 }\n  a.chr && a\nend", "  a\
    \ = string_to_int_array(a)\n  b = string_to_int_array(b)\n  x = int_xor(a[0],\
    \ b[0])\n  y = int_xor(a[1], b[1])\n  z = int_xor(a[2], b[2])\n  return int_to_string(x,\
    \ y, z)\nend", "  a.each_char.with_index do |x, i|\n    b.each_char.with_index\
    \ do |y, j|\n      x = x.chr if x.ord < 0 || x.ord > 255\n      y = y.chr if y.ord\
    \ < 0 || y.ord > 255\n      a[i..-1] = a[i..-1].chars.reverse_each.each.with_index.map\
    \ { |l, i| l ^ y[i] }.reverse.join + a[i..-1]\n    end\n  end\nend", "  result\
    \ = nil\n  a.each_char do |x|\n    result << x ^ b.at(a.index x) if b.at(a.index\
    \ x)\n  end\n  return result\nend\n</pre>", "  # Write your code here\n  return\
    \ a[-b.size..-1] + a[-1..-b.size].to_s + b[-b.size..-1] + b[-1..-b.size].to_s\n\
    end", "  binary = a.to_s(2) + b.to_s(2)\n  xor_result = binary.scan(/../).reduce(:^)\n\
    \  xor_result.to_s(2)\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=encryption,perl,python\
    \ |>\n<code>", "  (a = a.reverse).chars.reduce(:xor) ^ b.chars.reduce(:xor)\n\
    \  a.reverse << (b - a).reverse\nend\n</cell>\n<text>\nThe '^' operator performs\
    \ a bitwise XOR operation between two (binary and decimal) numbers.", "  a_bin\
    \ = base62_to_bin(a)\n  b_bin = base62_to_bin(b)\n  xor = xor(a_bin, b_bin)\n\
    \  return bin62_to_base62(xor)\nend", "    \"\"\n    a_int = [0 for i in a]\n\
    \    b_int = [0 for i in b]\n    for i in a\n        a_int[i] = ord(i) ^ ord(b)\n\
    \    for i in b\n        b_int[i] = ord(i) ^ ord(a)\n    a_str = \"\"\n    for\
    \ i in a_int\n        a_str += \"#{i.chr}\"\n    return a_str\nend", "  a = a.to_s\n\
    \  b = b.to_s\n  a_array = a.chars.to_a\n  b_array = b.chars.to_a\n  result =\
    \ \"\"\n  a_array.each_with_index do |e, i|\n    result << (e ^ b_array[i])\n\
    \  end\n  result\nend", "  a.xor_b(b).to_s\nend\n</pre>\n    </td>\n  </tr>\n\
    </table>", "  return a.to_s(2) ^ b.to_s(2)\nend", "  a_bits = binary_to_list(string_to_bits(a))\n\
    \  b_bits = binary_to_list(string_to_bits(b))\n  a_bits.map!{|s| s.xor(b_bits)}\n\
    \  return list_to_binary(a_bits)\nend", "  a_bytes = a.to_s(2).chars.map(&:hex)\n\
    \  b_bytes = b.to_s(2).chars.map(&:hex)\n  a_bytes.zip(b_bytes).map { |ab| ab[0]\
    \ ^ ab[1] }.join\nend", "    \n    result = \"\"\n    \n    for a_char, b in zip(list(a),\
    \ list(b))\n        if a_char == \"1\" or b_char == \"1\"\n            result\
    \ = \"1\" + result\n        else\n            result = \"0\" + result\n      \
    \  end\n    end\n    \n    return result\nend", "  a = a.to_s\n  b = b.to_s\n\
    \  a.each_byte do |x|\n    b.each_byte do |y|\n      puts x.chr + y.chr if (x\
    \ ^ y)\n    end\n  end\nend\n</cell>\n<cell>", "  s = ''\n  a.each_char do |char|\
    \ s += char if char == '1' end\n  b.each_char do |char| s += char if char == '1'\
    \ end\n  s.gsub!(/1$/, '')\n  s.gsub!(/0$/, '')\n  s.to_i(2).xor(a.to_i(2)).to_s(2).rjust(8,\
    \ '0')\nend", "  return a.to_s ^ b.to_s\nend", "  ret = a.dup\n  ret == b.dup\
    \ and ret or ret.gsub!(/1/, '0')\n  ret and ret.gsub!(/0/, '1')\nend", "  return\
    \ a + b.tr('0'*(a.length+b.length), '1'*(a.length+b.length))\nend", "  a.to_i(2)\
    \ ^ b.to_i(2)\nend", "  return a.or(b)\nend", "  xor = a.unpack('C*').zip(b).map{|x,y|\
    \ x ^ y}.pack('C*')\n  xor.reverse.each_byte{|b| puts b.chr}\n  xor\nend", " \
    \ a.each_byte { |c| c ^= b }\n  a.to_s\nend", "  xor = \"\"\n  a.each_byte do\
    \ |x|\n    xor += (x ^ b.to_i)\n  end\n  xor\nend", "  result = \"\"\n  a.each_byte\
    \ { |b| result << [b ^ a].pack(\"c\") }\n  result\nend", "  result = ''\n  i =\
    \ 0\n  while i < a.length && i < b.length\n    result << (a[i] ^ b[i])\n    i\
    \ += 1\n  end\n  result\nend", "    bin(a ^ b).rjust(16, '0')\nend", "  a = a.to_s\n\
    \  b = b.to_s\n  a.each_byte { |c| a << (a ^ b) if c }\n  a.join ''\nend", " \
    \ return [a, b].product(a).xor(b).to_s\nend", "  return b.gsub(/../) {|s| a.gsub(/../)\
    \ {|t| t == s ? '1' : '0'}}\nend\n</cell>\n<code language=conda-root-py>", " \
    \ result = ''\n  for i in 0...a.length\n    result << a[i] ^ b[i]\n  end\n  return\
    \ result\nend", "  xor = a.unpack('C*').map { |e| e ^ b }.pack('C*')\n  result\
    \ = xor\n  result[2..-1] = result[2..-1] + xor[0, 2]\n  result\nend", "  return\
    \ a^b\nend\n</code>\nI hope this helps you understand why this happened. The reason\
    \ is that there are binary numbers that don't have a binary representation in\
    \ base-2 (like '010' and '110'). The number will always be expressed in base-2\
    \ (even if your input comes from a different base) because this is how you represent\
    \ numbers in computers.\n<|/ a tags=ruby dscore=1 |>\n<| c |>\n\"There are binary\
    \ numbers that don't have a binary representation in base-2\". Binary numbers\
    \ are represented by a sequence consisting of bits (0/1) which can be encoded\
    \ in base 2 using just one letter '0' and '1'.\n<|/ c |>\n<| a tags=ruby dscore=0\
    \ |>\nThis is a bit of an unusual problem. You have a binary string where you\
    \ are treating it as a decimal number. To do this, you need to convert it from\
    \ a binary string to a decimal number. You do that using to_i. Like this:\n<code>\n\
    \"101\"\n.to_i(2)", "\tl = a.length\n\tr = b.length\n\t\n\ts = \"\"\n\t\n\tfor\
    \ i in 0...l\n\t\ts += (a[i]^b[i])\n\t\n\treturn s\nend\n</cell>\n<code language=julia-1.1>",
  "  a = [a] * 3\n  b = [b] * 3\n  c = [0, 0, 0]\n  for x in (0...3)\n    for y in\
    \ (0...3)\n      c[x] ^= a[y][x]\n    end\n  end\n  c\nend", "  return x.xor(a,\
    \ b).to_s\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nCan you please help me to\
    \ understand this line of the code: def xor(a, n, b)\n  a_bytes = [a.bytesize,\
    \ a.unpack('C*')]\n  b_bytes = [b.bytesize, b.unpack('C*')]\n  c = b_bytes.zip(a_bytes).map\
    \ { |x, y| x ^ y }\n  return c.pack('C*')\nend\n<|/ c |>\n<| c |>\nHow do you\
    \ read a byte array as a single number?\n<|/ c |>\n<| c |>\nbytesize is the number\
    \ of bytes of the array, so it is 8 in this example\n<|/ c |>\n<| c |>\nI'm a\
    \ little confused about the unpack portion of the code above. Does that unpack\
    \ the input bytes as single integers? Or is it because we're working with strings?\n\
    <|/ c |>\n<| c |>\nIt unpacks the input bytes as single integers\n<|/ c |>\n<|\
    \ a dscore=5 |>\nThe answers above are great. I want to expand on them with two\
    \ minor tweaks that could help someone else.\nThe first tweak is that Ruby doesn't\
    \ have a binary operator, which is where this answer was based from. This can\
    \ be remedied in two ways:", "  return a.gsub(/./, '&') * b.gsub(/./, '&')\nend\n\
    </cell>\n<code language=julia-1.5>", "  raise 'not implemented'\nend", "  c =\
    \ ''\n  a.each_byte {|x| c += ((b & x) ^ a) }\n  c\nend", "  x = binary_to_number(a)\n\
    \  y = binary_to_number(b)\n  x ^ y\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Thanks for the solution. \nBut how would you print out the result from here? \n\
    I'm guessing it would be something like:\nresult = string_xor(a,b)\nputs result\n\
    <|/ c |>\n<| c |>\nYou can print it using `puts string_xor('010', '110')` if you\
    \ want to print it in your method.\n<|/ c |>\n<| a dscore=1 tags=ruby,bit-manipulation\
    \ |>\nTo print the result in Ruby you can do:\n<code>", "  result = []\n  a.each_byte\
    \ { |bit| result << ((b & bit) ? 1 : 0) }\n  return result.to_s(2)\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x ^ y }.join\nend\n</pre>\n</div>", "  xor = ''\n  a.each_byte { |c|\
    \ xor << c[1..-1].chr }\n  b.each_byte { |c| xor << c[1..-1].chr }\n  xor\nend",
  "  a = a[0].to_i(2).to_s(2)\n  b = b[0].to_i(2).to_s(2)\n  c = (a ^ b).to_s(2).to_i(2).to_s(2)\n\
    \  c\nend", "  a.each_char { |c| c ^ b.shift }.to_s\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThank you for teaching me the XOR operation!\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\nSince I didn't want to use any functions from ruby core or string#gsub I\
    \ wrote my own\n<code>", "  result = ''\n  for i in (0..(a.length.to_f / b.length.to_f).floor)\n\
    \    result << a.slice(i * b.length, (i + 1) * b.length)\n  end\n  result\nend",
  "    a.unpack('C*').reverse\n    b.unpack('C*').reverse\n    \n    c = a.map {|x|\
    \ x ^ b}\n    c.pack('C*')\nend", "  return a.to_s(2) ^ b.to_s(2)\nend", "   \
    \ a.each_char.with_object(\"\") do |char, i|\n        result << (i%2 == 0 ? char\
    \ : char.next)\n    end\nend", "  return (\"0\"*(a.length + b.length)).ljust(a.length\
    \ + b.length, \"0\") + a[-a.length] + b[-b.length]\nend", "  a ^ b\nend", "  return\
    \ a.unpack('C*') ^ b.unpack('C*')\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
