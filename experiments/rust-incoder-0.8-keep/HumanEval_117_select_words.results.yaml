name: HumanEval_117_select_words
language: rust
results:
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    for i in\
    \ s.chars().filter_map(|c| c.is_letter()) {\n        let is_contained = &s[..i]\
    \ == &*i + &*i.chars().filter(|c| c.is_letter());\n        if is_contained ==\
    \ Some(true) {\n            words.push(&s[i..]);\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpmva3i6ue.rs:14:41\n   |\n14 |     for i in s.chars().filter_map(|c|\
    \ c.is_letter()) {\n   |                                         ^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0614]: type `usize` cannot be dereferenced\n \
    \ --> /tmp/tmpmva3i6ue.rs:15:40\n   |\n15 |         let is_contained = &s[..i]\
    \ == &*i + &*i.chars().filter(|c| c.is_letter());\n   |                      \
    \                  ^^\n\nerror[E0599]: no method named `chars` found for type\
    \ `usize` in the current scope\n  --> /tmp/tmpmva3i6ue.rs:15:49\n   |\n15 |  \
    \       let is_contained = &s[..i] == &*i + &*i.chars().filter(|c| c.is_letter());\n\
    \   |                                                 ^^^^^ method not found in\
    \ `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmva3i6ue.rs:16:28\n\
    \   |\n16 |         if is_contained == Some(true) {\n   |                    \
    \        ^^^^^^^^^^ expected `bool`, found enum `Option`\n   |\n   = note: expected\
    \ type `bool`\n              found enum `Option<bool>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmva3i6ue.rs:20:5\n   |\n12 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n20 |     words\n   |   \
    \  ^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<&str>`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    return vec![]\n}\n\nfn main() {\n  \
    \  let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp8t568unz.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = vec![];\n    \n    fn\
    \ dfs(s: &String, current: &String) -> Vec<String> {\n        if current.contains(\"\
    n\") && current.contains(\"s\") {\n            list.push(current);\n        }\n\
    \        \n        for c in s.chars() {\n            if c.is_alpha() && c.is_ascii()\
    \ {\n                if current.contains(c) && current.chars().count() == n {\n\
    \                    dfs(c, current);\n                }\n            }\n    \
    \    }\n        \n        return list;\n    }\n    \n    select_words_helper(s,\
    \ \"\", \"\", &mut list);\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmp8kztt7b3.rs:17:13\n\
    \   |\n17 |             list.push(current);\n   |             ^^^^\n   |\n   =\
    \ help: use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture\
    \ dynamic environment in a fn item\n  --> /tmp/tmp8kztt7b3.rs:22:70\n   |\n22\
    \ |                 if current.contains(c) && current.chars().count() == n {\n\
    \   |                                                                      ^\n\
    \   |\n   = help: use the `|| { ... }` closure form instead\n\nerror[E0434]: can't\
    \ capture dynamic environment in a fn item\n  --> /tmp/tmp8kztt7b3.rs:28:16\n\
    \   |\n28 |         return list;\n   |                ^^^^\n   |\n   = help: use\
    \ the `|| { ... }` closure form instead\n\nerror[E0425]: cannot find function\
    \ `select_words_helper` in this scope\n  --> /tmp/tmp8kztt7b3.rs:31:5\n   |\n\
    31 |     select_words_helper(s, \"\", \"\", &mut list);\n   |     ^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `is_alpha` found for\
    \ type `char` in the current scope\n  --> /tmp/tmp8kztt7b3.rs:21:18\n   |\n21\
    \ |             if c.is_alpha() && c.is_ascii() {\n   |                  ^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_alphabetic`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8kztt7b3.rs:23:25\n   |\n23 |\
    \                     dfs(c, current);\n   |                         ^ expected\
    \ `&String`, found `char`\n\nerror: aborting due to 6 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425, E0434, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n    \n    let mut result = vec![];\n\n    // Create a set of consonants\n\
    \    let mut consonants = HashSet::new();\n    for con in &\"bcdfghjklmnpqrstvwxyz\"\
    .to_string()[1..] {\n        consonants.insert(con);\n    }\n\n    // Iterate\
    \ through each letter\n    for i in s.chars() {\n        // If this letter does\
    \ not occur n times, skip it\n        if !consonants.contains(&i) {\n        \
    \    continue;\n        }\n        // Add the letter to the list of words that\
    \ contain this letter\n        result.push(s.to_string().chars().skip(1).find(|&i|\
    \ i == i).unwrap().unwrap());\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpz1nhhont.rs:20:26\n   |\n20 |     let mut consonants = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]:\
    \ `&str` is not an iterator\n  --> /tmp/tmpz1nhhont.rs:21:16\n   |\n21 |     for\
    \ con in &\"bcdfghjklmnpqrstvwxyz\".to_string()[1..] {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `&str` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   =\
    \ help: the trait `Iterator` is not implemented for `&str`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `&str`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmpz1nhhont.rs:32:78\n\
    \   |\n32 |         result.push(s.to_string().chars().skip(1).find(|&i| i == i).unwrap().unwrap());\n\
    \   |                                                                        \
    \      ^^^^^^ method not found in `char`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0433, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpdpdrw8z3.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut letters = s.chars();\n    let\
    \ mut result: Vec<String> = vec![];\n    loop {\n        let mut cur = letters.next();\n\
    \        let letter = cur?.unwrap();\n        if n == 0 {\n            break;\n\
    \        }\n        if letter == ' ' {\n            result.pop();\n        } else\
    \ {\n            if let Some(ref mut rest) = letters {\n                if let\
    \ Some(ref mut rest) = rest {\n                    if letter != rest.unwrap()\
    \ {\n                        return result;\n                    }\n         \
    \           result.push(rest.unwrap());\n                    letters = rest;\n\
    \                }\n            } else {\n                result.push(letter);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the `?` operator can only be used in a function that returns\
    \ `Result` or `Option` (or another type that implements `FromResidual`)\n  -->\
    \ /tmp/tmpfr025i78.rs:17:25\n   |\n12 | / fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n13 | |     let mut letters = s.chars();\n14 | |     let mut\
    \ result: Vec<String> = vec![];\n15 | |     loop {\n16 | |         let mut cur\
    \ = letters.next();\n17 | |         let letter = cur?.unwrap();\n   | |      \
    \                   ^ cannot use the `?` operator in a function that returns `Vec<String>`\n\
    ...  |\n37 | |     result\n38 | | }\n   | |_- this function should return `Result`\
    \ or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<Option<Infallible>>`\
    \ is not implemented for `Vec<String>`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpfr025i78.rs:17:27\n\
    \   |\n17 |         let letter = cur?.unwrap();\n   |                        \
    \   ^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfr025i78.rs:24:20\n   |\n24 |             if let Some(ref mut rest)\
    \ = letters {\n   |                    ^^^^^^^^^^^^^^^^^^   ------- this expression\
    \ has type `Chars<'_>`\n   |                    |\n   |                    expected\
    \ struct `Chars`, found enum `Option`\n   |\n   = note: expected struct `Chars<'_>`\n\
    \                found enum `Option<_>`\n\nerror[E0277]: can't compare `String`\
    \ with `char`\n  --> /tmp/tmpfr025i78.rs:21:19\n   |\n21 |         if letter ==\
    \ ' ' {\n   |                   ^^ no implementation for `String == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut consonants = Consonants::new();\n    let mut last_consonant_count = -1;\n\
    \    let mut word_index = 0;\n\n    for _ in 0..n {\n        if s.chars().next().unwrap().is_lowercase()\
    \ {\n            let mut word = String::new();\n            consonants.advance(&mut\
    \ last_consonant_count); // Advance the consonant count.\n            word.push(s.chars().next().unwrap());\n\
    \            list.append(word);\n        }\n    }\n\n    list\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Consonants`\n\
    \  --> /tmp/tmpcj5x7lpo.rs:14:26\n   |\n14 |     let mut consonants = Consonants::new();\n\
    \   |                          ^^^^^^^^^^ use of undeclared type `Consonants`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcj5x7lpo.rs:23:25\n   |\n23 |\
    \             list.append(word);\n   |                         ^^^^ expected `&mut\
    \ Vec<_>`, found struct `String`\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                         found struct `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut s = s;\n    if s.is_empty()\
    \ {\n        return Vec::new();\n    }\n    let mut list: Vec<String> = Vec::new();\n\
    \    let mut index = s.len() - 1;\n    for _i in 0..n {\n        if s[index] ==\
    \ 'M' || s[index] == 'm' || s[index] == 'S' || s[index] == 's' {\n           \
    \ index = index - 1;\n            list.push(s.split_whitespace()[index].to_string());\n\
    \        } else {\n            break;\n        }\n    }\n    list\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgcn9g6na.rs:20:12\n\
    \   |\n20 |         if s[index] == 'M' || s[index] == 'm' || s[index] == 'S' ||\
    \ s[index] == 's' {\n   |            ^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgcn9g6na.rs:20:31\n   |\n20 |         if s[index] == 'M' || s[index]\
    \ == 'm' || s[index] == 'S' || s[index] == 's' {\n   |                       \
    \        ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgcn9g6na.rs:20:50\n   |\n20 |         if s[index] == 'M' || s[index]\
    \ == 'm' || s[index] == 'S' || s[index] == 's' {\n   |                       \
    \                           ^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        let word = s.split_whitespace()[i];\n\
    \        for c in word.chars() {\n            if !c == 'a' && !c == 'e' && !c\
    \ == 'i' && !c == 'o' && !c == 'u' {\n                if i == words.len() {\n\
    \                    words.push((c));\n                } else {\n            \
    \        words.push(c.to_string());\n                }\n                i += 1;\n\
    \                break;\n            }\n        }\n        if i == s.len() {\n\
    \            words.push((\"\"));\n        }\n    }\n    words\n        .iter()\n\
    \        .filter(|&x| x.chars().count() == n)\n        .cloned()\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpd7noehwo.rs:20:32\n\
    \   |\n20 |                     words.push((c));\n   |                       \
    \         ^ ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n20 -                     words.push((c));\n\
    20 +                     words.push(c);\n   | \n\nwarning: unnecessary parentheses\
    \ around method argument\n  --> /tmp/tmpd7noehwo.rs:29:24\n   |\n29 |        \
    \     words.push((\"\"));\n   |                        ^  ^\n   |\nhelp: remove\
    \ these parentheses\n   |\n29 -             words.push((\"\"));\n29 +        \
    \     words.push(\"\");\n   | \n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmpd7noehwo.rs:16:20\n   |\n16 |         let\
    \ word = s.split_whitespace()[i];\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd7noehwo.rs:34:43\n   |\n34 |\
    \         .filter(|&x| x.chars().count() == n)\n   |                         \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    34 |         .filter(|&x| x.chars().count() == n.try_into().unwrap())\n   |  \
    \                                          ++++++++++++++++++++\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&str`\n    --> /tmp/tmpd7noehwo.rs:36:10\n     |\n36   |         .collect()\n\
    \     |          ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors; 2 warnings\
    \ emitted\n\nSome errors have detailed explanations: E0277, E0308, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    \n    //\
    \ TODO: implement the meat of the function\n    \n    return words;\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpkwyymvyo.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut s = s;\n    let mut words: Vec<String>\
    \ = Vec::new();\n    while !s.is_empty() {\n        let mut index = s.find(|c|\
    \ !c.is_alphanumeric());\n        while index != s.end() && s.chars().all(|c|\
    \ c.is_alphanumeric()) {\n            index = s.find(|c| !c.is_alphanumeric(),\
    \ index);\n        }\n        if index == s.end() || s.len() - index != n {\n\
    \            break;\n        }\n        words.push(s.split_whitespace()[0].to_string());\n\
    \        s = &s[(index + n) as usize..];\n    }\n    words\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpyagb9pzz.rs:16:33\n\
    \   |\n16 |         let mut index = s.find(|c| !c.is_alphanumeric());\n   |  \
    \                               ^ consider giving this closure parameter a type\n\
    \   |\n   = note: type must be known at this point\n\nerror[E0599]: no method\
    \ named `end` found for struct `String` in the current scope\n  --> /tmp/tmpyagb9pzz.rs:17:26\n\
    \   |\n17 |         while index != s.end() && s.chars().all(|c| c.is_alphanumeric())\
    \ {\n   |                          ^^^ method not found in `String`\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpyagb9pzz.rs:18:23\n\
    \     |\n18   |             index = s.find(|c| !c.is_alphanumeric(), index);\n\
    \     |                       ^^^^ ------------------------  ----- supplied 2\
    \ arguments\n     |                       |\n     |                       expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0599]:\
    \ no method named `end` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpyagb9pzz.rs:20:23\n   |\n20 |         if index == s.end() || s.len()\
    \ - index != n {\n   |                       ^^^ method not found in `String`\n\
    \nerror[E0277]: cannot subtract `Option<usize>` from `usize`\n  --> /tmp/tmpyagb9pzz.rs:20:40\n\
    \   |\n20 |         if index == s.end() || s.len() - index != n {\n   |      \
    \                                  ^ no implementation for `usize - Option<usize>`\n\
    \   |\n   = help: the trait `Sub<Option<usize>>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0608]:\
    \ cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpyagb9pzz.rs:23:20\n\
    \   |\n23 |         words.push(s.split_whitespace()[0].to_string());\n   |"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut ans = Vec::new();\n    let mut\
    \ n = s.len();\n    while n > 0 {\n        ans.push(s.split_whitespace()[0]);\n\
    \        n--;\n    }\n    ans\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpls_08ui_.rs:17:12\n\
    \   |\n17 |         n--;\n   |            ^ expected expression\n\nerror[E0608]:\
    \ cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpls_08ui_.rs:16:18\n\
    \   |\n16 |         ans.push(s.split_whitespace()[0]);\n   |                 \
    \ ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0608`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    if s.is_empty()\
    \ {\n        return list;\n    }\n    \n    for &ch in s.chars() {\n        if\
    \ ch.is_consonant() && n != 0 {\n            list.push(&ch);\n            n--;\n\
    \        }\n    }\n    \n    return list;\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpgqggqx7_.rs:21:16\n\
    \   |\n21 |             n--;\n   |                ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgqggqx7_.rs:18:9\n   |\n18 |     for &ch in\
    \ s.chars() {\n   |         ^^^    --------- this expression has type `Option<char>`\n\
    \   |         |\n   |         expected `char`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `ch`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list_words = vec![];\n    let\
    \ mut i = 0;\n    let mut k = 0;\n\n    while i < s.len() {\n        let j = i\
    \ + 1;\n        let mut contador = 0;\n        \n        for m in 0..n-1 {\n \
    \           if s[k] == s[(j+m)]{\n                contador += 1;\n           \
    \ }\n        }\n        if (contador == n){\n            list_words.push(&s[i..j]);\n\
    \            i += n;\n            contador = 0;\n            k = 0;\n        }\n\
    \        else {\n            i += 1;\n        }\n    }\n    list_words\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpenuhxd5g.rs:26:12\n\
    \   |\n26 |         if (contador == n){\n   |            ^             ^\n   |\n\
    \   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n26 -         if (contador == n){\n26 +         if contador == n {\n   |\
    \ \n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpenuhxd5g.rs:22:16\n   |\n22 |             if s[k] == s[(j+m)]{\n   |\
    \                ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpenuhxd5g.rs:22:29\n   |\n22 |             if\
    \ s[k] == s[(j+m)]{\n   |                             ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpenuhxd5g.rs:22:28\n\
    \   |\n22 |             if s[k] == s[(j+m)]{\n   |                           \
    \ ^ no implementation for `usize + isize`\n   |\n   = help: the trait `Add<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpenuhxd5g.rs:22:24\n   |\n22 |             if s[k] ==\
    \ s[(j+m)]{\n   |                        ^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the t"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut res = vec![];\n    let mut cur_len = 0;\n    for char in\
    \ s.chars() {\n        if cur_len == n {\n            res.push(s.to_string());\n\
    \            cur_len = 0;\n        } else {\n            cur_len += 1;\n     \
    \   }\n    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n \
    \   assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary had a little lamb\", \"Mary had a little lamb\", \"Mary had a little\
    \ lamb\", \"Mary had a little lamb\"]`,\n right: `[\"little\"]`', /tmp/tmp31hlx7v9.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // Write your solution here\n    let\
    \ mut words = vec![];\n    for word in s.split_whitespace() {\n        if word.chars().take(n).count()\
    \ == n {\n            words.push(word);\n        }\n    }\n    words\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyvs7ldxw.rs:16:30\n   |\n\
    16 |         if word.chars().take(n).count() == n {\n   |                    \
    \          ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n16 |      \
    \   if word.chars().take(n.try_into().unwrap()).count() == n {\n   |         \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpyvs7ldxw.rs:16:44\n   |\n16 |         if word.chars().take(n).count()\
    \ == n {\n   |                                            ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n16 |         if word.chars().take(n).count()\
    \ == n.try_into().unwrap() {\n   |                                           \
    \  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyvs7ldxw.rs:20:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n20 |     words\n   |     ^^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ i = 1;\n    while i <= s.len() {\n        if s.chars().all(|c| c != ' ') {\n\
    \            if s.chars().filter(|c| c != 'a' || c != 'e' || c != 'i' || \n  \
    \              c != 'o' || c != 'u').count() == n {\n                words.push(&s[i\
    \ - 1 : i + 1]);\n                i += 1;\n            }\n        }\n        i\
    \ += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0573]: expected type, found local variable `i`\n  --> /tmp/tmpngde6_rz.rs:19:39\n\
    \   |\n19 |                 words.push(&s[i - 1 : i + 1]);\n   |             \
    \                          ^ expecting a type here because of type ascription\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpngde6_rz.rs:17:39\n\
    \   |\n17 |             if s.chars().filter(|c| c != 'a' || c != 'e' || c != 'i'\
    \ || \n   |                                       ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpngde6_rz.rs:17:51\n   |\n17\
    \ |             if s.chars().filter(|c| c != 'a' || c != 'e' || c != 'i' || \n\
    \   |                                                   ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpngde6_rz.rs:17:63\n\
    \   |\n17 |             if s.chars().filter(|c| c != 'a' || c != 'e' || c != 'i'\
    \ || \n   |                                                               ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpngde6_rz.rs:18:19\n\
    \   |\n18 |                 c != 'o' || c != 'u').count() == n {\n   |       \
    \            ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpngde6_rz.rs:18:31\n   |\n18 |                 c != 'o' || c !=\
    \ 'u').count() == n {\n   |                               ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut pos = 0;\n    while pos < s.len() {\n        if s[pos] == \"a\" || s[pos]\
    \ == \"e\" || s[pos] == \"i\" || s[pos] == \"o\" || s[pos] == \"u\"\n        \
    \    || s[pos] == \"A\" || s[pos] == \"E\" || s[pos] == \"I\" || s[pos] == \"\
    O\" || s[pos] == \"U\"\n        {\n            while pos + 1 < s.len() && s[pos\
    \ + 1] != \" \" {\n                pos += 1;\n            }\n            if pos\
    \ + 1 < s.len() && s[pos + 1] == \" \" {\n                pos += 1;\n        \
    \    }\n            while pos + 1 < s.len() && s[pos + 1] != \" \" && s[pos +\
    \ 1] != \"a\" && s[pos + 1] != \"e\"\n                && s[pos + 1] != \"i\" &&\
    \ s[pos + 1] != \"o\" && s[pos + 1] != \"u\" {\n                pos += 1;\n  \
    \          }\n            list.push(&s[pos..(pos + n)]);\n        }\n        pos\
    \ += 1;\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp45gczcf1.rs:16:12\n\
    \   |\n16 |         if s[pos] == \"a\" || s[pos] == \"e\" || s[pos] == \"i\" ||\
    \ s[pos] == \"o\" || s[pos] == \"u\"\n   |            ^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp45gczcf1.rs:16:29\n   |\n16 |         if s[pos] == \"a\" || s[pos]\
    \ == \"e\" || s[pos] == \"i\" || s[pos] == \"o\" || s[pos] == \"u\"\n   |    \
    \                         ^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp45gczcf1.rs:16:46\n\
    \   |\n16 |         if s[pos] == \"a\" || s[pos] == \"e\" || s[pos] == \"i\" ||\
    \ s[pos] == \"o\" || s[pos] == \"u\"\n   |                                   \
    \           ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n    let mut word_vec: Vec<String> = vec![];\n    let mut counter: usize\
    \ = 0;\n    for c in s.chars() {\n        if c == ' ' || c == '\\t' || c == '\\\
    n' || c == '\\r' || c == '\\0' {\n            if counter == n {\n            \
    \    word_vec.push(s.to_string());\n            }\n            counter = 0;\n\
    \        } else {\n            counter += 1;\n        }\n    }\n    word_vec\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcd7xtt4g.rs:20:27\n   |\n\
    20 |             if counter == n {\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n20 |             if counter\
    \ == n.try_into().unwrap() {\n   |                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut v: Vec<String> = vec![];\n \
    \   let mut last_n = 0;\n    \n    for c in s.chars() {\n        if c != ' ' &&\
    \ c != '\\n' && c != '\\t' {\n            if c == ' ' || c == '\\n' || c == '\\\
    t' {\n                v.push(s.split_whitespace().nth(last_n).unwrap().to_string());\n\
    \                last_n += 1;\n            }\n        }\n    }\n    \n    if v.is_empty()\
    \ {\n        vec![]\n    } else {\n        v\n    }\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpwgqppv2u.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut output = Vec::new();\n    if\
    \ s.is_empty() {\n        return output;\n    }\n    let mut count = 0;\n    let\
    \ mut next_char = s.chars().next();\n    loop {\n        if next_char == Some(&'\
    \ ') {\n            next_char = s.chars().next();\n            if count == n {\n\
    \                break;\n            }\n            else {\n                count++;\n\
    \            }\n        }\n        \n        // only append the word if it contains\
    \ n\n        if next_char == Some(&'a') && count == n {\n            output.push(s.to_string());\n\
    \        }\n        \n        // only append words if the count is exactly n\n\
    \        if count == n {\n            output.push(s.to_string());\n          \
    \  count = 0;\n        }\n        \n        next_char = s.chars().next();\n  \
    \  }\n    output\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpxtzkespa.rs:26:22\n\
    \   |\n26 |                 count++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n26 |               \
    \  { let tmp = count; count += 1; tmp };\n   |                 +++++++++++   \
    \   ~~~~~~~~~~~~~~~~~~~\n26 -                 count++;\n26 +                 count\
    \ += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxtzkespa.rs:20:30\n\
    \   |\n20 |         if next_char == Some(&' ') {\n   |                       \
    \       ^^^^ expected `char`, found `&char`\n   |\nhelp: consider removing the\
    \ borrow\n   |\n20 -         if next_char == Some(&' ') {\n20 +         if next_char\
    \ == Some(' ') {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxtzkespa.rs:31:30\n\
    \   |\n31 |         if next_char == Some(&'a') && count == n {\n   |         \
    \                     ^^^^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ removing the borrow\n   |\n31 -         if next_char == Some(&'a') && count\
    \ == n {\n31 +         if next_char == Some('a') && count == n {\n   | \n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut s = String::from(s);\n    s.push_str(&\"\
    \ \");\n    s.push_str(&\"X\");\n    s.push_str(&\"X\");\n    s.push_str(&\"X\"\
    );\n    let mut count = 0;\n    let mut s = String::from(s);\n    let mut chars\
    \ = s.chars();\n    loop {\n        if chars.next().unwrap() == ' ' {\n      \
    \      if count == 0 {\n                continue;\n            }\n           \
    \ chars.next();\n            count--;\n        } else {\n            count +=\
    \ 1;\n        }\n        if count == n {\n            break;\n        }\n    }\n\
    \    let mut list = vec![];\n    let mut s = String::from(s);\n    let mut chars\
    \ = s.chars();\n    while chars.next().unwrap() != ' ' {\n        list.push(s.clone());\n\
    \        match chars.next() {\n            Some(next) => s.push_str(&next.to_string()),\n\
    \            None => break,\n        }\n    }\n    list\n}\n\nfn main() {\n  \
    \  let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpxpqdy2nd.rs:27:20\n\
    \   |\n27 |             count--;\n   |                    ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut s = String::from(s);\n    let\
    \ mut count = HashSet::new();\n\n    while n > 0 {\n        if !s.contains(|c|\
    \ *c != 'a'  && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u') {\n        \
    \    s.push_str(c);\n            count.insert((s.clone(), c));\n        }\n  \
    \      else {\n            n -= 1;\n        }\n    }\n\n    count.values().clone().into_iter().map(|(_,\
    \ cs)| cs).collect()\n}\n\nfn main() {\n    let candidate = select_words;\n  \
    \  assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpmheufflr.rs:14:21\n   |\n14 |     let mut count = HashSet::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `c` in this scope\n  --> /tmp/tmpmheufflr.rs:18:24\n   |\n\
    18 |             s.push_str(c);\n   |                        ^ help: a local variable\
    \ with a similar name exists: `n`\n\nerror[E0425]: cannot find value `c` in this\
    \ scope\n  --> /tmp/tmpmheufflr.rs:19:38\n   |\n19 |             count.insert((s.clone(),\
    \ c));\n   |                                      ^ help: a local variable with\
    \ a similar name exists: `n`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    let mut\
    \ s = String::from_utf8(s).unwrap();\n    let mut count = Vec::new();\n    let\
    \ mut n = n as usize;\n\n    while s.len() > 0 {\n        let mut index = s.find::<u8,\
    \ usize>(b'u');\n        let mut index = s.find::<u8, usize>(b'l');\n        let\
    \ mut index = s.find::<u8, usize>(b'e');\n\n        if index == Some(0) {\n  \
    \          index = s.find::<u8, usize>(b'h');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b'o');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b'w');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b'd');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b'e');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b's');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b'm');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b'a');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b'p');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b'o');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b's');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b'i');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b'n');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b'a');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b'm');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b'e');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b't');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b's');\n            count = Vec::new();\n\
    \            index = s.find::<u8, usize>(b'g');\n            \n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7uzsr6jf.rs:73:3\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n18\
    \ |     while s.len() > 0 {\n   |                       - unclosed delimiter\n\
    ...\n23 |         if index == Some(0) {\n   |                             - this\
    \ delimiter might not be properly closed...\n...\n62 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n73 | }\n   |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7uzsr6jf.rs:14:35\n   |\n14 |     let mut s\
    \ = String::from_utf8(s).unwrap();\n   |                                   ^ expected\
    \ struct `Vec`, found struct `String`\n   |\n   = note: expected struct `Vec<u8>`\n\
    \              found struct `String`\n\nerror[E0107]: this associated function\
    \ takes 1 generic argument but 2 generic arguments were supplied\n  --> /tmp/tmp7uzsr6jf.rs:19:27\n\
    \   |\n19 |         let mut index = s.find::<u8, usize>(b'u');\n   |         \
    \                  ^^^^       ----- help: remove this generic argument\n   | \
    \                          |\n   |                           expected 1 generic\
    \ argument\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `u8`\n\
    \    --> /tmp/tmp7uzsr6jf.rs:19:45\n     |\n19   |         let mut index = s.find::<u8,\
    \ usize>(b'u');\n     |                           ----              ^^^^ expected\
    \ an `FnMut<(char,)>` closure, found `u8`\n     |                           |\n\
    \     |                           required by a bound introduced by this call\n\
    \     |\n     = help: the trait `FnMut<(char,)>` is not implemented for `u8`\n\
    \     = help: the following other types implement trait `Pattern<'a>`:\n     \
    \          &'b String\n               &'b [char; N]\n               &'b [char]\n\
    \               &'b str\n               &'c &'b str\n               [char; N]\n\
    \               char\n               pattern::MultiCharEqPattern<C>\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `u8`\n\
    note: required by a bound in `core::str::<"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut vowels = \"aeiou\";\n    let\
    \ mut result: Vec<String> = vec![];\n    for ch in s.chars() {\n        if vowels.contains(ch)\
    \ {\n            result.push(format!(\"{}\", ch));\n            vowels = &vowels[..].to_owned();\n\
    \            continue;\n        }\n        if n == 0 {\n            break;\n \
    \       }\n        if n % 2 == 0 {\n            for j in 1..3 {\n            \
    \    if let Some(j) = (ch as u32).pow(j) {\n                    result.push(format!(\"\
    {}\", j));\n                    break;\n                }\n            }\n   \
    \     } else {\n            for j in 1..4 {\n                if let Some(j) =\
    \ (ch as u32).pow(j) {\n                    result.push(format!(\"{}\", j));\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiy72e8ot.rs:26:24\n   |\n\
    26 |                 if let Some(j) = (ch as u32).pow(j) {\n   |             \
    \           ^^^^^^^   ------------------ this expression has type `u32`\n   |\
    \                        |\n   |                        expected `u32`, found\
    \ enum `Option`\n   |\n   = note: expected type `u32`\n              found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiy72e8ot.rs:33:24\n\
    \   |\n33 |                 if let Some(j) = (ch as u32).pow(j) {\n   |      \
    \                  ^^^^^^^   ------------------ this expression has type `u32`\n\
    \   |                        |\n   |                        expected `u32`, found\
    \ enum `Option`\n   |\n   = note: expected type `u32`\n              found enum\
    \ `Option<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n\n    if\
    \ s.is_empty() {\n        return words;\n    }\n\n    for c in s.chars() {\n \
    \       if c == ' ' {\n            if n == 0 {\n                break;\n     \
    \       }\n            continue;\n        }\n\n        if c.is_consonant() {\n\
    \            match words.last() {\n                Some(word) if n == 0 => (),\n\
    \                Some(word) if word == c => (),\n                Some(word) =>\
    \ {\n                    if word.len() > n {\n                        words.push(word.to_string());\n\
    \                    }\n                }\n            }\n        }\n    }\n\n\
    \    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpb2jlwxeg.rs:27:14\n   |\n27 |         if c.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0277]:\
    \ can't compare `&String` with `char`\n  --> /tmp/tmpb2jlwxeg.rs:30:36\n   |\n\
    30 |                 Some(word) if word == c => (),\n   |                    \
    \                ^^ no implementation for `&String == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb2jlwxeg.rs:32:37\n   |\n32 |                     if word.len()\
    \ > n {\n   |                                     ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n32 |                     if word.len() > n.try_into().unwrap()\
    \ {\n   |                                      ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    s.split(\"\").map(|&x| x.chars().take_while(\
    \ |&c| !c.is_vowel()).collect()).filter(|x| x == n).collect()\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpkgsg0a_f.rs:13:23\n   |\n13 |     s.split(\"\").map(|&x|\
    \ x.chars().take_while( |&c| !c.is_vowel()).collect()).filter(|x| x == n).collect()\n\
    \   |                       ^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\n\nerror[E0599]: no method named `is_vowel` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpkgsg0a_f.rs:13:56\n   |\n13\
    \ |     s.split(\"\").map(|&x| x.chars().take_while( |&c| !c.is_vowel()).collect()).filter(|x|\
    \ x == n).collect()\n   |                                                    \
    \    ^^^^^^^^ method not found in `char`\n\nerror[E0277]: can't compare `&_` with\
    \ `isize`\n  --> /tmp/tmpkgsg0a_f.rs:13:92\n   |\n13 |     s.split(\"\").map(|&x|\
    \ x.chars().take_while( |&c| !c.is_vowel()).collect()).filter(|x| x == n).collect()\n\
    \   |                                                                        \
    \                    ^^ no implementation for `&_ == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut index = Vec::new();\n    let mut index_length = Vec::new();\n    let mut\
    \ cur_word = String::new();\n    let mut next_word = String::new();\n\n    //\
    \ First we split the string into words based on spaces\n    let mut words = s.split_whitespace();\n\
    \n    // We want to loop through each word to find out if they contain the correct\
    \ number of consonants\n    for word in words {\n        index = word.chars().enumerate().filter(|(&i,\
    \ &c)| {\n            // Since we only care about finding out the number of consonants\n\
    \            // if we find a consonant in the word, we skip this iteration\n \
    \           if c == 'c' || c == 'd' || c == 'h' || c == 'l' || c == 'm' || c ==\
    \ 's' || c == 'x' {\n                true\n            } else {\n            \
    \    false\n            }\n        }).collect::<Vec<(isize, char)>>();\n\n   \
    \     index_length = index.len();\n        // We need to check to make sure each\
    \ index is a valid index for our string\n        // Since we will be looping through\
    \ each index to get the word, \n        // we can check to make sure the index\
    \ exists in the string\n        if index < 0 || index >= index_length {\n    \
    \        continue;\n        }\n\n        // Now we will get the current word we\
    \ are working on\n        cur_word = &words[index.iter().next().unwrap()];\n\n\
    \        // The next word we will be working on\n        next_word = &words[index.iter().next().unwrap()];\n\
    \n        // Now we will check if the number of consonants is correct\n      \
    \  if cur_word.chars().count() == n {\n            list.push(cur_word);\n    \
    \    } else {\n            continue;\n        }\n\n        // We have to check\
    \ to make sure we dont find any word\n        // If the number of consonants we\
    \ found does not equal our \n        // number then we need to move onto the next\
    \ word\n        // Since we will be looping through each index to get the word,\
    \ \n        // we can check to make sure the index exists in the string\n    \
    \    if cur_word.chars().count() != n {\n            continue;\n        }\n\n\
    \        // Now we will get the next word we are working on\n        next_word\
    \ = &words[index.iter().next().unwrap()];\n\n        // Now we will check if the\
    \ number of consonants is correct\n        if next_word.chars().count() == n {\n\
    \            list.push(next_word);\n        } else {\n            continue;\n\
    \        }\n    }\n\n    // If the string is empty, we still want to return a\
    \ list but an empty list\n    if words.len() == 0 {\n        vec![]\n    } else\
    \ {\n        list\n    }\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy2v6nka3.rs:24:51\n   |\n\
    24 |         index = word.chars().enumerate().filter(|(&i, &c)| {\n   |      \
    \                                             ^^    - expected due to this\n \
    \  |                                                   |\n   |               \
    \                                    expected `usize`, found reference\n   | \
    \                                                  help: you can probably remove\
    \ the explicit borrow: `i`\n   |\n   = note:   expected type `usize`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy2v6nka3.rs:24:55\n\
    \   |\n24 |         index = word.chars().enumerate().filter(|(&i, &c)| {\n   |\
    \                                                       ^^- expected due to this\n\
    \   |                                                       |\n   |          \
    \                                             expected `char`, found reference\n\
    \   |                                                       help: you can probably\
    \ remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror[E0277]: a value of type `Vec<(isize,\
    \ char)>` cannot be built from an iterator over elements of type `(usize, char)`\n\
    \    --> /tmp/tmpy2v6nka3.rs:32:12\n     |\n32   |         }).collect::<Vec<(isize,\
    \ char)>>();\n     |            ^^^^^^^ value of type `Vec<(isize, char)>` cannot\
    \ be built from `std::iter::Iterator<Item=(usize, char)>`\n     |\n     = help:\
    \ the trait `FromIterator<(usize, char)>` is not implemented for `Vec<(isize,\
    \ char)>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpy2v6nka3.rs:34:24\n   |\n15 |     let mut index_length = Vec::new();\n\
    \   |                            ---------- expected due to this value\n...\n\
    34 |         index_length = index.len();\n   |                        ^^^^^^^^^^^\
    \ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<_>`\n\
    \                found type `usize`\n\nerror[E0308]"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n    let mut vowels: Vec<String> = vec![];\n    let mut consonants: Vec<String>\
    \ = vec![];\n    for i in s.chars() {\n        if i.is_vowel() {\n           \
    \ vowels.push(i);\n        } else {\n            consonants.push(i);\n       \
    \ }\n    }\n    let mut ans = vec![];\n    for i in 0..vowels.len() {\n      \
    \  if vowels[i].len() == n {\n            ans.push(vowels[i]);\n        }\n  \
    \  }\n    for i in 0..consonants.len() {\n        if consonants[i].len() == n\
    \ {\n            ans.push(consonants[i]);\n        }\n    }\n    ans\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpvrmx7wxn.rs:19:14\n   |\n19 |         if i.is_vowel() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvrmx7wxn.rs:20:25\n   |\n20 |             vowels.push(i);\n\
    \   |                         ^- help: try using a conversion method: `.to_string()`\n\
    \   |                         |\n   |                         expected struct\
    \ `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvrmx7wxn.rs:22:29\n\
    \   |\n22 |             consonants.push(i);\n   |                            \
    \ ^- help: try using a conversion method: `.to_string()`\n   |               \
    \              |\n   |                             expected struct `String`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvrmx7wxn.rs:27:31\n\
    \   |\n27 |         if vowels[i].len() == n {\n   |                          \
    \     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n27 |      \
    \   if vowels[i].len() == n.try_into().unwrap() {\n   |                      \
    \          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvrmx7wxn.rs:32:35\n\
    \   |\n32 |         if consonants[i].len() == n {\n   |                      \
    \             ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n32\
    \ |         if consonants[i].len() == n.try_into().unwrap() {\n   |          \
    \                          ++++++++++++++++++++\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = vec![];\n    let mut\
    \ j = 0;\n    while j < s.len() {\n        if s.chars().nth(j + n).count() !=\
    \ n {\n            list.push(s.substring(j..j + n).to_string());\n           \
    \ j += n;\n        } else {\n            j = j + 1;\n        }\n    }\n    list\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzwkabyq9.rs:16:30\n   |\n\
    16 |         if s.chars().nth(j + n).count() != n {\n   |                    \
    \          ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `isize`\
    \ to `usize`\n  --> /tmp/tmpzwkabyq9.rs:16:28\n   |\n16 |         if s.chars().nth(j\
    \ + n).count() != n {\n   |                            ^ no implementation for\
    \ `usize + isize`\n   |\n   = help: the trait `Add<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror[E0599]: `Option<char>` is not an iterator\n   --> /tmp/tmpzwkabyq9.rs:16:33\n\
    \    |\n16  |           if s.chars().nth(j + n).count() != n {\n    |        \
    \                           ^^^^^ `Option<char>` is not an iterator\n    |\n \
    \   = note: the following trait bounds were not satisfied:\n            `Option<char>:\
    \ Iterator`\n            which is required by `&mut Option<char>: Iterator`\n\n\
    error[E0599]: no method named `substring` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpzwkabyq9.rs:17:25\n   |\n17 |             list.push(s.substring(j..j\
    \ + n).to_string());\n   |                         ^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzwkabyq9.rs:17:42\n\
    \   |\n17 |             list.push(s.substring(j..j + n).to_string());\n   |  \
    \                                        ^ expected `usize`, found `isize`\n\n\
    error[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpzwkabyq9.rs:17:40\n\
    \   |\n17 |             list.push(s.substring(j..j + n).to_string());\n   |  \
    \                                      ^ no implementation for `usize + isize`\n\
    \   |\n   = help: the trait `Add<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n    let mut res = vec![];\n    let mut i = 1;\n    let mut c = 0;\n  \
    \  while i != n {\n        if s.chars().all(|&c| c.is_consonant() == true) {\n\
    \            res.push(s.split_whitespace().next().unwrap());\n            c =\
    \ 0;\n        }\n        i += 1;\n    }\n    return res;\n}\n\nfn main() {\n \
    \   let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp00o8ponu.rs:20:27\n   |\n\
    20 |         if s.chars().all(|&c| c.is_consonant() == true) {\n   |         \
    \                  ^--\n   |                           ||\n   |              \
    \             |expected due to this\n   |                           expected `char`,\
    \ found reference\n   |                           help: did you mean `c`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp00o8ponu.rs:26:12\n   |\n12 | fn\
    \ select_words(s: String, n: isize) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n26 |     return res;\n   |            ^^^ expected struct `String`, found\
    \ `&str`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = vec![];\n    if s.is_empty()\
    \ {\n        return list;\n    }\n    let mut i = 0;\n    while i < (s.len() -\
    \ n) {\n        let word = s.to_string()[i..i + n].to_string();\n        list.push(word);\n\
    \        i += n;\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpufjbk463.rs:18:26\n   |\n\
    18 |     while i < (s.len() - n) {\n   |                          ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpufjbk463.rs:18:24\n\
    \   |\n18 |     while i < (s.len() - n) {\n   |                        ^ no implementation\
    \ for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpufjbk463.rs:19:41\n\
    \   |\n19 |         let word = s.to_string()[i..i + n].to_string();\n   |    \
    \                                     ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add `isize` to `usize`\n  --> /tmp/tmpufjbk463.rs:19:39\n   |\n19 | \
    \        let word = s.to_string()[i..i + n].to_string();\n   |               \
    \                        ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpufjbk463.rs:21:14\n   |\n21 |         i += n;\n   |   \
    \           ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmpufjbk463.rs:21:11\n   |\n21 |         i +=\
    \ n;\n   |           ^^ no implementation for `usize += isize`\n   |\n   = help:\
    \ the trait `AddAssign<isize>` is not imple"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut chars = String::new();\n   \
    \ chars.extend_from_slice(s);\n    let mut counter = 0;\n    while counter < chars.len()\
    \ {\n        if chars[counter] != 'a' &&\n            chars[counter] != 'e' &&\n\
    \            chars[counter] != 'i' &&\n            chars[counter] != 'o' &&\n\
    \            chars[counter] != 'u' &&\n            chars[counter] != 'A' &&\n\
    \            chars[counter] != 'E' &&\n            chars[counter] != 'I' &&\n\
    \            chars[counter] != 'O' &&\n            chars[counter] != 'U' &&\n\
    \            chars[counter] != 'e' &&\n            chars[counter] != 'i' &&\n\
    \            chars[counter] != 'o' &&\n            chars[counter] != 'u'\n   \
    \     {\n            chars.truncate(counter);\n        }\n        counter += 1;\n\
    \    }\n\n    let mut result = Vec::new();\n    let mut counter = 1;\n    while\
    \ counter <= chars.len() {\n        if chars[counter] == 'a' &&\n            chars[counter\
    \ + 1] == 'l' &&\n            chars[counter + 2] == 'l' &&\n            chars[counter\
    \ + 3] == 'a' &&\n            chars[counter + 4] == 'r' &&\n            chars[counter\
    \ + 5] == 'y' &&\n            chars[counter + 6] == 'e' &&\n            chars[counter\
    \ + 7] == 's' &&\n            chars[counter + 8] == 'p' &&\n            chars[counter\
    \ + 9] == 'e' &&\n            chars[counter + 10] == 's' &&\n            chars[counter\
    \ + 11] == 'p' &&\n            chars[counter + 12] == 's'\n        {\n       \
    \     result.push(&chars[counter..counter + 13]);\n            counter += 13;\n\
    \        }\n        counter += 1;\n    }\n    if chars.len() == 0 {\n        result\n\
    \    } else {\n        result\n    }\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `extend_from_slice` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp3pej5r3c.rs:14:11\n   |\n14 |     chars.extend_from_slice(s);\n\
    \   |           ^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3pej5r3c.rs:17:12\n\
    \   |\n17 |         if chars[counter] != 'a' &&\n   |            ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3pej5r3c.rs:18:13\n   |\n18 |             chars[counter] != 'e'\
    \ &&\n   |             ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3pej5r3c.rs:19:13\n   |\n19 |             chars[counter] != 'i'\
    \ &&\n   |             ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \     "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut l = String::new();\n    let\
    \ mut i = 1;\n    let mut consonants = 0;\n    let mut j = 0;\n    while i < s.len()\
    \ {\n        let c = s.chars().nth(i);\n        if c.is_uppercase() {\n      \
    \      i += 1;\n            continue;\n        }\n        if consonants == n {\n\
    \            l.push_str(&s[..i]);\n        }\n        i += 1;\n        consonants\
    \ += 1;\n    }\n    l.to_owned()\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uppercase` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmp3ihyo7li.rs:19:14\n   |\n19 |         if c.is_uppercase()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `Option<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3ihyo7li.rs:29:5\n   |\n12 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \      ----------- expected `Vec<String>` because of return type\n...\n29 |  \
    \   l.to_owned()\n   |     ^^^^^^^^^^^^ expected struct `Vec`, found struct `String`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ words = s.split_whitespace();\n    let mut i = 0;\n    while i + n <= words\
    \ {\n        let tmp = words.split_whitespace()[i..(i + n)].collect::<Vec<_>>();\n\
    \        for i in tmp {\n            result.push(i)\n        }\n        i = i\
    \ + n;\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp13hjhft6.rs:16:20\n   |\n\
    16 |     while i + n <= words {\n   |                    ^^^^^ expected `isize`,\
    \ found struct `SplitWhitespace`\n\nerror[E0599]: no method named `split_whitespace`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmp13hjhft6.rs:17:25\n\
    \   |\n17 |         let tmp = words.split_whitespace()[i..(i + n)].collect::<Vec<_>>();\n\
    \   |                         ^^^^^^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut consonants: Vec<&str> = vec![];\n    let mut vowels: Vec<&str> = vec![];\n\
    \n    for i in s.chars().skip_while(|&c| c <= 'z') {\n        if c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u'\n            || c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U' {\n            vowels.push(i);\n   \
    \     }\n        else {\n            consonants.push(i);\n        }\n    }\n\n\
    \    let mut i = 0;\n    while consonants.len() > n {\n        let word = &consonants[i..].join(\"\
    \");\n        if words.iter().any(|&x| x.contains(&word)) {\n            i +=\
    \ word.len();\n        }\n        else {\n            words.push(word);\n    \
    \        i += word.len();\n        }\n    }\n\n    while vowels.len() > n {\n\
    \        let word = &vowels[i..].join(\"\");\n        if words.iter().any(|&x|\
    \ x.contains(&word)) {\n            i += word.len();\n        }\n        else\
    \ {\n            words.push(word);\n            i += word.len();\n        }\n\
    \    }\n\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpwovf3ki7.rs:18:12\n\
    \   |\n18 |         if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n\
    \   |            ^ help: a local variable with a similar name exists: `i`\n\n\
    error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpwovf3ki7.rs:18:24\n\
    \   |\n18 |         if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n\
    \   |                        ^ help: a local variable with a similar name exists:\
    \ `i`\n\nerror[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpwovf3ki7.rs:18:36\n\
    \   |\n18 |         if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n\
    \   |                                    ^ help: a local variable with a similar\
    \ name exists: `i`\n\nerror[E0425]: cannot find value `c` in this scope\n  -->\
    \ /tmp/tmpwovf3ki7.rs:18:48\n   |\n18 |         if c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u'\n   |                                          \
    \      ^ help: a local variable with a similar name exists: `i`\n\nerror[E0425]:\
    \ cannot find value `c` in this scope\n  --> /tmp/tmpwovf3ki7.rs:18:60\n   |\n\
    18 |         if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n   |\
    \                                                            ^ help: a local variable\
    \ with a similar name exists: `i`\n\nerror[E0425]: cannot find value `c` in this\
    \ scope\n  --> /tmp/tmpwovf3ki7.rs:19:16\n   |\n19 |             || c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n   |                ^ help:\
    \ a local variable with a similar name exists: `i`\n\nerror[E0425]: cannot find\
    \ value `c` in this scope\n  --> /tmp/tmpwovf3ki7.rs:19:28\n   |\n19 |       \
    \      || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n   |   \
    \                         ^ help: a local variable with a similar name exists:\
    \ `i`\n\nerror[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpwovf3ki7.rs:19:40\n\
    \   |\n19 |             || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c ==\
    \ 'U' {\n   |                                        ^ help: a local variable\
    \ with a similar name exi"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ words = s.split_whitespace();\n    let vowels = \"AEIOU\".to_vec();\n\n    let\
    \ mut pos = 0;\n    loop {\n        let mut i = pos;\n        while i <= s.len()\
    \ {\n            let c = s[i];\n            if vowels.contains(&c) {\n       \
    \         i += 1;\n                continue loop;\n            }\n           \
    \ if n == 0 || c != s[i as usize] {\n                break;\n            }\n \
    \           i += 1;\n        }\n        result.push(words[pos..i].join(\" \"));\n\
    \        pos = i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `loop`\n  --> /tmp/tmperd0kf0t.rs:24:26\n   |\n24 |                 continue\
    \ loop;\n   |                          ^^^^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror[E0599]: no method named `to_vec` found for reference\
    \ `&'static str` in the current scope\n  --> /tmp/tmperd0kf0t.rs:15:26\n   |\n\
    15 |     let vowels = \"AEIOU\".to_vec();\n   |                          ^^^^^^\
    \ method not found in `&'static str`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmperd0kf0t.rs:21:21\n   |\n21 |         \
    \    let c = s[i];\n   |                     ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmperd0kf0t.rs:26:31\n   |\n26 |             if n == 0 || c != s[i\
    \ as usize] {\n   |                               ^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmperd0kf0t.rs:31:21\n   |\n31 |         result.push(words[pos..i].join(\"\
    \ \"));\n   |                  "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = vec![String::new()];\n\
    \    let mut index = 0;\n    while index < s.len() {\n        if s.chars().take(n).count(|x|\
    \ *x == ' ') == n {\n            list.push(s.subslice(index, index + n));\n  \
    \          index = index + n;\n        }\n        index += 1;\n    }\n    list\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyvx09lew.rs:16:27\n   |\n\
    16 |         if s.chars().take(n).count(|x| *x == ' ') == n {\n   |          \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    16 |         if s.chars().take(n.try_into().unwrap()).count(|x| *x == ' ') ==\
    \ n {\n   |                            ++++++++++++++++++++\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpyvx09lew.rs:16:30\n\
    \    |\n16  |         if s.chars().take(n).count(|x| *x == ' ') == n {\n    |\
    \                              ^^^^^ ------------- supplied 1 argument\n    |\
    \                              |\n    |                              expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyvx09lew.rs:16:54\n   |\n16 |         if s.chars().take(n).count(|x|\
    \ *x == ' ') == n {\n   |                                                    \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n16 |         if\
    \ s.chars().take(n).count(|x| *x == ' ') == n.try_into().unwrap() {\n   |    \
    \                                                   ++++++++++++++++++++\n\nerror[E0599]:\
    \ no method named `subslice` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpyvx09lew.rs:17:25\n   |\n17 |             list.push(s.subslice(index,\
    \ index + n));\n   |                         ^^^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyvx09lew.rs:17:49\n   |\n17 |\
    \             list.push(s.subslice(index, index + n));\n   |                 \
    \                                ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add `isize` to `usize`\n  --> /tmp/tmpyvx09lew.rs:17:47\n   |\n17 | \
    \            list.push(s.subslice(index, index + n));\n   |                  \
    \                             ^ no implementation for `usize + isize`\n   |\n\
    \   = help: the trait `Add<isize>` is not"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvmciogob.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    s.split(\" \").filter(|x| x.chars().filter(|c|\
    \ *c > 'a' && *c < 'z').count() == n).collect()\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4qsrwlnl.rs:13:83\n   |\n\
    13 |     s.split(\" \").filter(|x| x.chars().filter(|c| *c > 'a' && *c < 'z').count()\
    \ == n).collect()\n   |                                                      \
    \                             ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n13 |     s.split(\" \").filter(|x| x.chars().filter(|c| *c > 'a'\
    \ && *c < 'z').count() == n.try_into().unwrap()).collect()\n   |             \
    \                                                                       ++++++++++++++++++++\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp4qsrwlnl.rs:13:86\n     |\n13\
    \   |     s.split(\" \").filter(|x| x.chars().filter(|c| *c > 'a' && *c < 'z').count()\
    \ == n).collect()\n     |                                                    \
    \                                  ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = vec![];\n    let len =\
    \ s.len();\n    for (_, w) in s.split_whitespace() {\n        if w.is_consonant()\
    \ && w.len() == n {\n            res.push(w);\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvynb26dq.rs:15:9\n   |\n\
    15 |     for (_, w) in s.split_whitespace() {\n   |         ^^^^^^    --------------------\
    \ this expression has type `Option<&str>`\n   |         |\n   |         expected\
    \ `str`, found tuple\n   |\n   = note: expected type `str`\n             found\
    \ tuple `(_, _)`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = vec![\"\".to_string()];\n\
    \n    for i in 0..s.len() {\n        let s = &s[..i];\n        if s.chars().all(|&c|\
    \ c.is_ascii_word()) {\n            let mut cur_word = vec![s[0]];\n         \
    \   for i in 1..s.len() {\n                let c = &s[i..];\n                if\
    \ c.chars().all(|&cc| cc.is_ascii_word()) && \n                    cur_word.last().unwrap().is_ascii_word()\
    \ {\n                    cur_word.push(c[0]);\n                } else {\n    \
    \                res.push(cur_word.join(\"\"));\n                    cur_word.clear();\n\
    \                }\n            }\n            res.push(cur_word.join(\"\"));\n\
    \        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsdktqbhf.rs:17:27\n   |\n\
    17 |         if s.chars().all(|&c| c.is_ascii_word()) {\n   |                \
    \           ^--\n   |                           ||\n   |                     \
    \      |expected due to this\n   |                           expected `char`,\
    \ found reference\n   |                           help: did you mean `c`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpsdktqbhf.rs:18:37\n\
    \   |\n18 |             let mut cur_word = vec![s[0]];\n   |                 \
    \                    ^^^^ string indices are ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<str>` is not implemented for `{integer}`\n   = note: you\
    \ can use `.chars().nth()` or `.bytes().nth()`\n           for more information,\
    \ see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsdktqbhf.rs:21:35\n   |\n21 |\
    \                 if c.chars().all(|&cc| cc.is_ascii_word()) && \n   |       \
    \                            ^---\n   |                                   ||\n\
    \   |                                   |expected due to this\n   |          \
    \                         expected `char`, found reference\n   |             \
    \                      help: did you mean `cc`: `&char`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror[E0277]: the type `str`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmpsdktqbhf.rs:23:35\n   |\n23\
    \ |                     cur_word.push(c[0]);\n   |                           \
    \        ^^^^ string indices are ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<str>` is not implemented for `{integer}`\n   = note: you can use\
    \ `.chars().nth()` or `.bytes().nth()`\n           for more information, see chapter\
    \ 8 in The Book: <https://doc.ru"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut chars = s.chars();\n    let\
    \ mut list = Vec::new();\n    \n    for _ in 0..n {\n        if chars.next().is_none()\
    \ {\n            break;\n        }\n        let mut char = chars.next().unwrap();\n\
    \        while !char.is_space() {\n            char = chars.next().unwrap();\n\
    \        }\n        list.push(char);\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_space` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp_60zqgz6.rs:21:21\n   |\n21 |         while !char.is_space()\
    \ {\n   |                     ^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_whitespace`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_60zqgz6.rs:26:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n26 |     list\n   |     ^^^^ expected struct `String`,\
    \ found `char`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe3gj5409.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n    let mut list = vec![];\n    \n\
    \    for c in s.chars() {\n        if c.is_whitespace() {\n            if list.len()\
    \ == n {\n                return list;\n            }\n        } else {\n    \
    \        if list.len() == n {\n                list.push(c);\n            }\n\
    \        }\n    }\n    \n    return list;\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps45uglpl.rs:18:30\n   |\n\
    18 |             if list.len() == n {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |             if list.len()\
    \ == n.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmps45uglpl.rs:22:30\n   |\n22 |\
    \             if list.len() == n {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n22 |             if list.len()\
    \ == n.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmps45uglpl.rs:23:27\n   |\n23 |\
    \                 list.push(c);\n   |                           ^- help: try using\
    \ a conversion method: `.to_string()`\n   |                           |\n   |\
    \                           expected struct `String`, found `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut i = 1;\n    let mut j = 0;\n    let mut words = vec![];\n\
    \    let mut count = HashMap::new();\n\n    while i <= s.len() {\n        let\
    \ current_char = s[i as usize].chars().next().unwrap();\n        if !count.contains_key(&current_char)\
    \ {\n            count\n                .entry(current_char)\n               \
    \ .or_insert(0)\n                .into_iter()\n                .collect::<Vec<_>>()\n\
    \                .push(s.chars().skip(i).take(n).collect::<String>());\n     \
    \       j += 1;\n            i += 1;\n        } else {\n            i += 1;\n\
    \        }\n    }\n\n    count.iter().filter(|(_, count)| count <= n).map(|(_,\
    \ count)| {\n        let mut new_str = String::from(\"[\");\n        for word\
    \ in &count[..] {\n            new_str.push_str(word);\n        }\n        new_str.push(']');\n\
    \        new_str\n    }).collect()\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpepgrfi2_.rs:20:21\n   |\n20 |     let mut count = HashMap::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpepgrfi2_.rs:23:28\n\
    \   |\n23 |         let current_char = s[i as usize].chars().next().unwrap();\n\
    \   |                            ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepgrfi2_.rs:30:46\n\
    \   |\n30 |                 .push(s.chars().skip(i).take(n).collect::<String>());\n\
    \   |                                              ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n30 |                 .push(s.chars().skip(i).take(n.try_into().unwrap()).collect::<String>());\n\
    \   |                                               ++++++++++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    select_words(s, n, s.chars().collect::<Vec<_>>(),\
    \ Vec::new())\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 2 arguments but 4 arguments were supplied\n\
    \  --> /tmp/tmpsjobquik.rs:13:5\n   |\n13 |     select_words(s, n, s.chars().collect::<Vec<_>>(),\
    \ Vec::new())\n   |     ^^^^^^^^^^^^ -  -  -----------------------------  ----------\
    \ supplied 4 arguments\n   |     |\n   |     expected 2 arguments\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmpsjobquik.rs:12:4\n   |\n12 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |    ^^^^^^^^^^^^ ---------  --------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc8ar7o9o.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return Vec::new();\n\
    \    }\n\n    // Complete this function\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0317]: `if` may be missing an `else` clause\n  --> /tmp/tmpne2nme9u.rs:13:5\n\
    \   |\n12 |   fn select_words(s: String, n: isize) -> Vec<String> {\n   |    \
    \                                       ----------- expected `Vec<String>` because\
    \ of this return type\n13 | /     if s.is_empty() {\n14 | |         return Vec::new();\n\
    15 | |     }\n   | |_____^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n   = note: `if`\
    \ expressions without `else` evaluate to `()`\n   = help: consider adding an `else`\
    \ block that evaluates to the expected type\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0317`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgo_on6f5.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    for\
    \ c in s.chars() {\n        if c.is_consonant() && result.len() < n {\n      \
    \      result.push(c); \n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp019l10qg.rs:15:14\n   |\n15 |         if c.is_consonant()\
    \ && result.len() < n {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp019l10qg.rs:15:47\n   |\n15 |\
    \         if c.is_consonant() && result.len() < n {\n   |                    \
    \                           ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n15 |         if c.is_consonant() && result.len() < n.try_into().unwrap()\
    \ {\n   |                                                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp019l10qg.rs:19:5\n   |\n12 | fn\
    \ select_words(s: String, n: isize) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n19 |     result\n   |     ^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut letters = String::new();\n \
    \   let mut pos = 0;\n    while pos < s.len() {\n        for c in s.chars() {\n\
    \            if c.chars().any(|&c| *c != c) {\n                letters.push_str(&s[pos]);\n\
    \                break;\n            }\n            pos += 1;\n        }\n   \
    \ }\n    return letters.split_whitespace().take(n).collect();\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpbhuk4lpy.rs:17:18\n   |\n17 |             if c.chars().any(|&c|\
    \ *c != c) {\n   |                  ^^^^^ method not found in `char`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbhuk4lpy.rs:18:35\n\
    \   |\n18 |                 letters.push_str(&s[pos]);\n   |                 \
    \                  ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbhuk4lpy.rs:24:44\n\
    \   |\n24 |     return letters.split_whitespace().take(n).collect();\n   |   \
    \                                         ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n24 |     return letters.split_whitespace().take(n.try_into().unwrap()).collect();\n\
    \   |                                             ++++++++++++++++++++\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&str`\n    --> /tmp/tmpbhuk4lpy.rs:24:47\n     |\n24   |     return\
    \ letters.split_whitespace().take(n).collect();\n     |                      \
    \                         ^^^^^^^ value of type `Vec<String>` cannot be built\
    \ from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait `FromIterator<&str>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599."
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut prev_char:\
    \ Vec<&str> = Vec::new();\n    let mut first_char: Vec<&str> = Vec::new();\n \
    \   let mut first_char = first_char.into_iter().cloned();\n    let mut prev_char\
    \ = prev_char.into_iter().cloned();\n    let mut current_char: Vec<&str> = Vec::new();\n\
    \    let mut current_char = current_char.into_iter().cloned();\n    let mut prev_char\
    \ = prev_char.into_iter().cloned();\n    let mut current_char = current_char.into_iter().cloned();\n\
    \    let mut first_char = first_char.into_iter().cloned();\n\n    for c in s.chars()\
    \ {\n        if vowels.iter().any(|vowel| {\n            match c.chars().any(|c|\
    \ vowel == *c) {\n                true => true,\n                false => false,\n\
    \            }\n        }) {\n            first_char.push(&*c);\n        }\n \
    \       if current_char == first_char {\n            prev_char.push(&*c);\n  \
    \      } else {\n            if current_char != first_char {\n               \
    \ if prev_char != first_char {\n                    if prev_char.iter().any(|vowel|\
    \ {\n                        match c.chars().any(|c| vowel == *c) {\n        \
    \                    true => true,\n                            false => false,\n\
    \                        }\n                    }) {\n                       \
    \ let result = prev_char.iter()\n                            .cloned()\n     \
    \                       .chain(current_char.iter().cloned())\n               \
    \             .cloned()\n                            .filter(|c| c != \"a\" &&\
    \ c != \"e\" && c != \"i\" && c != \"o\" && c != \"u\")\n                    \
    \        .collect::<Vec<_>>();\n                        result.sort_unstable();\n\
    \                        result.sort_unstable();\n                        result.sort_unstable();\n\
    \                        result.push(&*(result.iter().next().unwrap()));\n   \
    \                 }\n                }\n            }\n            prev_char.push(&*c);\n\
    \            current_char.push(&*c);\n        }\n    }\n    prev_char.sort_unstable();\n\
    \    current_char.sort_unstable();\n    prev_char.sort_unstable();\n    current_char.sort_unstable();\n\
    \    prev_char.sort_unstable();\n    current_char.sort_unstable();\n    prev_char.sort_unstable();\n\
    \    current_char.sort_unstable();\n    prev_char.sort_unstable();\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `str: Clone` is not satisfied\n    --> /tmp/tmp0q36zdhp.rs:17:49\n\
    \     |\n17   |     let mut first_char = first_char.into_iter().cloned();\n  \
    \   |                                                 ^^^^^^ the trait `Clone`\
    \ is not implemented for `str`\n     |\n     = help: the trait `Clone` is implemented\
    \ for `String`\nnote: required by a bound in `cloned`\n\nerror[E0277]: the trait\
    \ bound `str: Clone` is not satisfied\n    --> /tmp/tmp0q36zdhp.rs:18:47\n   \
    \  |\n18   |     let mut prev_char = prev_char.into_iter().cloned();\n     | \
    \                                              ^^^^^^ the trait `Clone` is not\
    \ implemented for `str`\n     |\n     = help: the trait `Clone` is implemented\
    \ for `String`\nnote: required by a bound in `cloned`\n\nerror[E0277]: the trait\
    \ bound `str: Clone` is not satisfied\n    --> /tmp/tmp0q36zdhp.rs:20:53\n   \
    \  |\n20   |     let mut current_char = current_char.into_iter().cloned();\n \
    \    |                                                     ^^^^^^ the trait `Clone`\
    \ is not implemented for `str`\n     |\n     = help: the trait `Clone` is implemented\
    \ for `String`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method\
    \ `into_iter` exists for struct `Cloned<std::vec::IntoIter<&str>>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmp0q36zdhp.rs:21:35\n   |\n21 |     \
    \  let mut prev_char = prev_char.into_iter().cloned();\n   |                 \
    \                    ^^^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<&str>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `Cloned<std::vec::IntoIter<&str>>: Iterator`\n\
    \           which is required by `Cloned<std::vec::IntoIter<&str>>: IntoIterator`\n\
    \           `&Cloned<std::vec::IntoIter<&str>>: Iterator`\n           which is\
    \ required by `&Cloned<std::vec::IntoIter<&str>>: IntoIterator`\n           `&mut\
    \ Cloned<std::vec::IntoIter<&str>>: Iterator`\n           which is required by\
    \ `&mut Cloned<std::vec::IntoIter<&str>>: IntoIterator`\n\nerror[E0599]: the method\
    \ `into_iter` exis"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    select_words_helper(s, n, 0, \"\")\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `select_words_helper` in this scope\n\
    \  --> /tmp/tmpgga0c0dt.rs:13:5\n   |\n13 |     select_words_helper(s, n, 0, \"\
    \")\n   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    return unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpgftrkg5e.rs:13:12\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return Vec::new();\n\
    \    }\n    // write your code here\n    return vec![\n        &s[..n].to_string().chars().filter(|&x|\
    \ x != ' ').collect(),\n    ];\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<isize>`\n\
    \  --> /tmp/tmplnd3ymea.rs:18:10\n   |\n18 |         &s[..n].to_string().chars().filter(|&x|\
    \ x != ' ').collect(),\n   |          ^^^^^^ `String` cannot be indexed by `RangeTo<isize>`\n\
    \   |\n   = help: the trait `Index<RangeTo<isize>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ vowels = \"AEIOU\";\n\n    for word in s.split_whitespace() {\n        let mut\
    \ pos = 0;\n        let mut cont = false;\n        let mut vowel_counter = 0;\n\
    \        for c in word.chars() {\n            if vowels.contains(&c.to_ascii_lowercase())\
    \ {\n                vowel_counter++;\n            }\n            pos += 1;\n\n\
    \            if cont == false && pos == n {\n                cont = true;\n  \
    \          }\n        }\n\n        if cont == true {\n            result.push(word);\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp7lwkk__f.rs:22:30\n\
    \   |\n22 |                 vowel_counter++;\n   |                           \
    \   ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n22\
    \ |                 { let tmp = vowel_counter; vowel_counter += 1; tmp };\n  \
    \ |                 +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n22 -\
    \                 vowel_counter++;\n22 +                 vowel_counter += 1;\n\
    \   | \n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    -->\
    \ /tmp/tmp7lwkk__f.rs:21:32\n     |\n21   |             if vowels.contains(&c.to_ascii_lowercase())\
    \ {\n     |                       -------- ^^^^^^^^^^^^^^^^^^^^^^^ expected an\
    \ `Fn<(char,)>` closure, found `char`\n     |                       |\n     |\
    \                       required by a bound introduced by this call\n     |\n\
    \     = help: the trait `Fn<(char,)>` is not implemented for `char`\n     = note:\
    \ required because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n21   |             if vowels.contains(*&c.to_ascii_lowercase())\
    \ {\n     |                                +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7lwkk__f.rs:36:5\n   |\n12 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n36 |     result\n   |     ^^^^^^\
    \ expected struct `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = s.replace(\" \", \"\");\n    let mut word = String::new();\n    let\
    \ mut consonants = 0;\n    for ch in s.chars() {\n        if ch == ' ' {\n   \
    \         consonants++;\n            if consonants == n {\n                list.push(word.clone());\n\
    \                word.clear();\n                consonants = 0;\n            }\n\
    \        } else {\n            word.push(ch);\n        }\n    }\n    list.push(word.clone());\n\
    \    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp_v7g46i7.rs:19:23\n\
    \   |\n19 |             consonants++;\n   |                       ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n19 |             { let\
    \ tmp = consonants; consonants += 1; tmp };\n   |             +++++++++++    \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~\n19 -             consonants++;\n19 +       \
    \      consonants += 1;\n   | \n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() { return Vec::new();\
    \ }\n    let mut result = vec![];\n    let mut s = &s;\n    let mut n = &n;\n\
    \    while n != 0 {\n        if let Some(found) = find_first_matching(&mut s,\
    \ &n) {\n            result += found;\n            n -= 1;\n        } else {\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_first_matching` in this scope\n\
    \  --> /tmp/tmpw071wld0.rs:18:30\n   |\n18 |         if let Some(found) = find_first_matching(&mut\
    \ s, &n) {\n   |                              ^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpw071wld0.rs:17:13\n\
    \   |\n17 |     while n != 0 {\n   |             ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0368]: binary assignment operation `+=` cannot be\
    \ applied to type `Vec<_>`\n  --> /tmp/tmpw071wld0.rs:19:13\n   |\n19 |      \
    \       result += found;\n   |             ------^^^^^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `Vec<_>`\n\nerror[E0368]: binary assignment\
    \ operation `-=` cannot be applied to type `&isize`\n  --> /tmp/tmpw071wld0.rs:20:13\n\
    \   |\n20 |             n -= 1;\n   |             -^^^^^\n   |             |\n\
    \   |             cannot use `-=` on type `&isize`\n   |\nhelp: `-=` can be used\
    \ on `isize`, you can dereference `n`\n   |\n20 |             *n -= 1;\n   | \
    \            +\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0368, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ current_word = \"\";\n    let mut vowels = vec![\"A\", \"E\", \"I\", \"O\",\
    \ \"U\"];\n\n    for _ in 0..(s.len() / n) {\n        if s.len() % n != 0 {\n\
    \            current_word = s.split_whitespace()[0];\n        }\n\n        if\
    \ current_word.contains(&vowels) {\n            result.push(current_word);\n \
    \       }\n        current_word = \"\";\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpip1811ky.rs:17:28\n   |\n\
    17 |     for _ in 0..(s.len() / n) {\n   |                            ^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot divide `usize` by `isize`\n \
    \ --> /tmp/tmpip1811ky.rs:17:26\n   |\n17 |     for _ in 0..(s.len() / n) {\n\
    \   |                          ^ no implementation for `usize / isize`\n   |\n\
    \   = help: the trait `Div<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Div<Rhs>`:\n             <&'a f32\
    \ as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128 as\
    \ Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n\
    \             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n      \
    \       <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpip1811ky.rs:18:22\n   |\n18 |         if s.len() % n !=\
    \ 0 {\n   |                      ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot mod `usize` by `isize`\n  --> /tmp/tmpip1811ky.rs:18:20\n   |\n18 | \
    \        if s.len() % n != 0 {\n   |                    ^ no implementation for\
    \ `usize % isize`\n   |\n   = help: the trait `Rem<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpip1811ky.rs:19:28\n   |\n19 |             current_word = s.split_whitespace()[0];\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `Vec<&str>`\n    --> /tmp/tmpip1811ky.rs:22:34\n\
    \     |\n22   |         if current_word.contains(&vowels) {\n     |          \
    \               -------- ^^^^^^^ expected an `Fn<(char,)>"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut ret = Vec::new();\n    for i\
    \ in s.chars() {\n        let j = i.as_str().chars().count(|&b| b == b);\n   \
    \     if j == n {\n            ret.append(i.to_string());\n        }\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_str` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpexq2rr0m.rs:15:19\n   |\n15 |         let j = i.as_str().chars().count(|&b|\
    \ b == b);\n   |                   ^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpexq2rr0m.rs:17:24\n   |\n17 |             ret.append(i.to_string());\n\
    \   |                        ^^^^^^^^^^^^^ expected `&mut Vec<_>`, found struct\
    \ `String`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n      \
    \                   found struct `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut result = vec![];\n    let mut consonants = vec![];\n\n \
    \   for x in s.chars() {\n        if x.is_vowel() {\n            result.push(x);\n\
    \        }\n\n        if x.is_consonant() {\n            consonants.push(x);\n\
    \        }\n    }\n\n    if consonants.len() == n {\n        return result;\n\
    \    }\n\n    select_words(&consonants[..], n).push(&consonants[..]);\n    select_words(&result[..],\
    \ n).push(&result[..]);\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpgte_kxy9.rs:21:14\n   |\n21 |         if x.is_vowel() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `is_consonant` found for type `char` in the current scope\n  --> /tmp/tmpgte_kxy9.rs:25:14\n\
    \   |\n25 |         if x.is_consonant() {\n   |              ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgte_kxy9.rs:30:28\n\
    \   |\n30 |     if consonants.len() == n {\n   |                            ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n30 |     if consonants.len()\
    \ == n.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgte_kxy9.rs:31:16\n   |\n12 |\
    \ fn select_words(s: String, n: isize) -> Vec<String> {\n   |                \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n31 |         return result;\n   |                ^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<char>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgte_kxy9.rs:34:18\n   |\n34 |     select_words(&consonants[..], n).push(&consonants[..]);\n\
    \   |                  ^^^^^^^^^^^^^^^ expected struct `String`, found `&[char]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgte_kxy9.rs:34:43\n   |\n34 |\
    \     select_words(&consonants[..], n).push(&consonants[..]);\n   |          \
    \                                 ^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&[char]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgte_kxy9.rs:35:18\n\
    \   |\n35 |     select_words(&result[..], n).push(&result[..]);\n   |        \
    \          ^^^^^^^^^^^ expected struct `String`, found `&[char]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgte_kxy9.rs:35:39\n   |\n35 |     select_words(&result[..],\
    \ n).push(&result[..]);\n   |                                       ^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut s = String::from(s);\n    let\
    \ mut list = vec![];\n    for w in s.split_whitespace() {\n        let mut count\
    \ = String::from(\"0\");\n        for c in w.chars() {\n            if count ==\
    \ n.to_string() {\n                list.push(w);\n            }\n            if\
    \ c.is_consonant() {\n                count = count.clone();\n            }\n\
    \        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmppm5yw5e1.rs:21:18\n   |\n21 |             if c.is_consonant()\
    \ {\n   |                  ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppm5yw5e1.rs:26:5\n   |\n12 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \      ----------- expected `Vec<String>` because of return type\n...\n26 |  \
    \   list\n   |     ^^^^ expected struct `String`, found `&str`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s == \"\" {\n        return vec![];\n\
    \    }\n    \n    select_words_with_helper(s, n, 0, 0, 0)\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `select_words_with_helper` in this scope\n\
    \  --> /tmp/tmpaqsrqva3.rs:17:5\n   |\n17 |     select_words_with_helper(s, n,\
    \ 0, 0, 0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // TODO\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdohlrgtu.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n\
    \    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut consonants\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let mut spaces: Vec<String> = vec![\"\\\"\", \" \", \".\", \"!\", \"?\"\
    ];\n    let mut numbers: Vec<String> = vec![\"0\", \"1\", \"2\", \"3\", \"4\"\
    , \"5\", \"6\", \"7\", \"8\", \"9\"];\n    let mut caps: Vec<String> = vec![\"\
    A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"\
    L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"\
    W\", \"X\", \"Y\", \"Z\"];\n\n    let letter: String = s.chars().filter(|c| c.is_letter()).collect();\n\
    \    let space: String = s.chars().filter(|c| c.is_whitespace()).collect();\n\
    \    let number: String = s.chars().filter(|c| c.is_digit()).collect();\n    let\
    \ cap: String = s.chars().filter(|c| c.is_uppercase()).collect();\n\n    let mut\
    \ strings: Vec<String> = vec![];\n\n    if letter == vec![] && space == vec![]\
    \ && number == vec![] && cap == vec![] {\n        strings.push_back(s);\n    }\
    \ else {\n        let mut word: String = String::from(\"\");\n\n        for i\
    \ in 0..(n - 1) {\n            for j in 0..(letter.length - 1) {\n           \
    \     let mut c: String;\n\n                if letter[j] == cap[j] {\n       \
    \             c = String::from(&cap[j..j + 1].to_lowercase());\n             \
    \   } else if letter[j] == number[j] {\n                    c = String::from(&number[j..j\
    \ + 1].to_lowercase());\n                } else {\n                    c = String::from(&letter[j..j\
    \ + 1].to_lowercase());\n                }\n\n                if word.is_empty()\
    \ {\n                    word = String::from(&consonants[0..c].join(\"\"));\n\
    \                } else {\n                    word = String::from(&consonants[0..c].join(\"\
    \") + &vowels[0..vowels.len()].join(\"\") + &consonants[c + 1].to_lowercase()\
    \ + &vowels[c + 1].to_lowercase() + &space[..spaces.len()].join(\"\"));\n    \
    \            }\n\n                if word.ends_with(\"-\") {\n               \
    \     strings.push_back(\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpcdn2nvza.rs:63:3\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n29\
    \ |     } else {\n   |            - unclosed delimiter\n...\n32 |         for\
    \ i in 0..(n - 1) {\n   |                             - unclosed delimiter\n33\
    \ |             for j in 0..(letter.length - 1) {\n   |                      \
    \                       - unclosed delimiter\n...\n50 |                 if word.ends_with(\"\
    -\") {\n   |                                        - this delimiter might not\
    \ be properly closed...\n51 |                     strings.push_back(\n52 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n63 | }\n\
    \   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpcdn2nvza.rs:51:38\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - closing delimiter possibly meant\
    \ for this\n...\n51 |                     strings.push_back(\n   |           \
    \                           ^ unclosed delimiter\n52 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcdn2nvza.rs:16:40\n\
    \   |\n16 |     let mut spaces: Vec<String> = vec![\"\\\"\", \" \", \".\", \"\
    !\", \"?\"];\n   |                                        ^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  \
    \      |\n   |                                        expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcdn2nvza.rs:17:41\n\
    \   |\n17 |     let mut numbers: Vec<String> = vec![\"0\", \"1\", \"2\", \"3\"\
    , \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"];\n   |                           \
    \              ^^^- help: try using a conversion method: `.to_string()`\n   |\
    \                                         |\n   |                            \
    \             expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcdn2nvza.rs:18:38\n   |\n18 |     let mut caps: Vec<String>\
    \ = vec![\"A\", "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // BEGIN Question 4\n    if s.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut words = vec![];\n    let mut\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut vowels_pos = 0;\n    let\
    \ mut vowels_pos_end = 0;\n    let mut consonants = 0;\n    let mut consonants_end\
    \ = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut i = 0;\n    let mut\
    \ found = false;\n    let mut j = 0;\n\n    while i != s.len() {\n        while\
    \ !found && vowels.contains(s[i]) {\n            vowels_pos = j;\n           \
    \ vowels_pos_end = j + vowels.len();\n            vowels_pos_end += vowels_pos\
    \ - vowels_pos_end + 1;\n\n            consonants = 0;\n            consonants_end\
    \ = 0;\n\n            j = vowels_pos + 1;\n\n            for k in 0 .. consonants_end\
    \ {\n                while !found && vowels.contains(s[j + consonants]) {\n  \
    \                  consonants++;\n                    consonants_end += consonants\
    \ - consonants_end + 1;\n                }\n\n                if consonants_end\
    \ == n {\n                    found = true;\n                }\n            }\n\
    \n            words.insert(words[words.size() - 1].to_string() + s[vowels_pos\
    \ + 1].to_string(), ());\n            i += 1;\n        }\n\n        while !found\
    \ && consonants.contains(s[i]) {\n            consonants_end = j;\n          \
    \  consonants += 1;\n            consonants_end += consonants - consonants_end\
    \ + 1;\n\n            j = consonants_end;\n            words.insert(words[words.size()\
    \ - 1].to_string() + s[consonants_end].to_string(), ());\n            i += 1;\n\
    \        }\n\n        i += 1;\n    }\n\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpd6hub0in.rs:43:31\n\
    \   |\n43 |                     consonants++;\n   |                          \
    \     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    43 |                     { let tmp = consonants; consonants += 1; tmp };\n   |\
    \                     +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n43 -   \
    \                  consonants++;\n43 +                     consonants += 1;\n\
    \   | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpd6hub0in.rs:31:41\n   |\n31 |         while !found && vowels.contains(s[i])\
    \ {\n   |                                         ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpd6hub0in.rs:42:49\n   |\n42 |                 while !found && vowels.contains(s[j\
    \ + consonants]) {\n   |                                                 ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `size` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmpd6hub0in.rs:52:38\n   |\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    vec![String::from(\"\")]\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\"]`,\n right: `[\"little\"]`', /tmp/tmpe_idpiqy.rs:18:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut output = Vec::new();\n\n   \
    \ for word in s.split_whitespace() {\n        if word.chars().count() == n {\n\
    \            output.push(word);\n        }\n    }\n\n    return output;\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqzh6qwj9.rs:16:36\n   |\n\
    16 |         if word.chars().count() == n {\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n16 |      \
    \   if word.chars().count() == n.try_into().unwrap() {\n   |                 \
    \                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqzh6qwj9.rs:21:12\n   |\n12 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n21 |     return output;\n   |   \
    \         ^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<&str>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut vec: Vec<String> = vec![];\n\
    \    for i in s.chars().filter(|&x| x != '-').take(n) {\n        vec.push(&s[i..]);\n\
    \    }\n    return vec;\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp13aagvjq.rs:14:51\n   |\n\
    14 |     for i in s.chars().filter(|&x| x != '-').take(n) {\n   |            \
    \                                       ^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     for i in s.chars().filter(|&x| x != '-').take(n.try_into().unwrap())\
    \ {\n   |                                                    ++++++++++++++++++++\n\
    \nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<char>`\n  -->\
    \ /tmp/tmp13aagvjq.rs:15:19\n   |\n15 |         vec.push(&s[i..]);\n   |     \
    \              ^^^^^^ `String` cannot be indexed by `RangeFrom<char>`\n   |\n\
    \   = help: the trait `Index<RangeFrom<char>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp13aagvjq.rs:15:18\n\
    \   |\n15 |         vec.push(&s[i..]);\n   |                  ^^^^^^^ expected\
    \ struct `String`, found reference\n   |\n   = note: expected struct `String`\n\
    \           found reference `&_`\nhelp: consider removing the borrow\n   |\n15\
    \ -         vec.push(&s[i..]);\n15 +         vec.push(s[i..]);\n   | \n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg2200917.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut word = String::new();\n    let\
    \ mut cnt = 0;\n    let mut s = String::from(s);\n    while cnt < n {\n      \
    \  let pos = s.find(' ', 0);\n        let mut found = false;\n        if let Some(pos)\
    \ = pos {\n            word.clear();\n            for (start, end) in s.split_at(pos)\
    \ {\n                if let Some(end) = end {\n                    word.push_str(&s[start..end]);\n\
    \                    found = true;\n                    break;\n             \
    \   }\n            }\n        }\n        if found {\n            cnt += 1;\n \
    \       } else {\n            word.push_str(&s[..pos]);\n            cnt = 0;\n\
    \        }\n        s = String::from(&s[pos + 1..]);\n    }\n    let mut result\
    \ = Vec::new();\n    result.push(word);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp6rutkbvl.rs:17:21\n     |\n17   |         let pos = s.find('\
    \ ', 0);\n     |                     ^^^^ ---  - supplied 2 arguments\n     |\
    \                     |\n     |                     expected 1 argument\n    \
    \ |\nnote: associated function defined here\n\nerror[E0277]: `(&str, &str)` is\
    \ not an iterator\n  --> /tmp/tmp6rutkbvl.rs:21:33\n   |\n21 |             for\
    \ (start, end) in s.split_at(pos) {\n   |                                 ^^^^^^^^^^^^^^^\
    \ `(&str, &str)` is not an iterator\n   |\n   = help: the trait `Iterator` is\
    \ not implemented for `(&str, &str)`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `(&str, &str)`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `RangeTo<Option<usize>>`\n  --> /tmp/tmp6rutkbvl.rs:32:28\n\
    \   |\n32 |             word.push_str(&s[..pos]);\n   |                      \
    \      ^^^^^^^^ `String` cannot be indexed by `RangeTo<Option<usize>>`\n   |\n\
    \   = help: the trait `Index<RangeTo<Option<usize>>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  -->\
    \ /tmp/tmp6rutkbvl.rs:35:33\n   |\n35 |         s = String::from(&s[pos + 1..]);\n\
    \   |                             --- ^ - {integer}\n   |                    \
    \         |\n   |                             Option<usize>\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0277,\
    \ E0369.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut vowels = \"aeiouAEIOU\";\n \
    \   vowels.clear();\n    vowels.insert((&*s as &str).chars().collect::<Vec<_>>().filter(|&x|\
    \ x == ' '));\n    vowels.sort_unstable();\n\n    let mut index = vowels.len();\n\
    \n    let mut words: Vec<String> = vec![];\n\n    loop {\n        if index ==\
    \ n {\n            words.push(String::from(\"_\"));\n            break;\n    \
    \    }\n\n        let mut i = index;\n        let mut c = s.chars().nth(i).unwrap();\n\
    \        while vowels.contains(&c) {\n            i += 1;\n            c = s.chars().nth(i).unwrap();\n\
    \        }\n        words.push(s.chars().rev().nth(i).unwrap().to_string());\n\
    \        i += 1;\n        index = i;\n    }\n\n    words\n}\n\nfn main() {\n \
    \   let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `clear` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmp3jptbouk.rs:14:12\n   |\n14 |     vowels.clear();\n\
    \   |            ^^^^^ method not found in `&str`\n\nerror[E0599]: no method named\
    \ `insert` found for reference `&str` in the current scope\n  --> /tmp/tmp3jptbouk.rs:15:12\n\
    \   |\n15 |     vowels.insert((&*s as &str).chars().collect::<Vec<_>>().filter(|&x|\
    \ x == ' '));\n   |            ^^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ `Vec<char>` is not an iterator\n   --> /tmp/tmp3jptbouk.rs:15:61\n    |\n15\
    \  |       vowels.insert((&*s as &str).chars().collect::<Vec<_>>().filter(|&x|\
    \ x == ' '));\n    |                                                         \
    \      ^^^^^^ `Vec<char>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<char>: Iterator`\n      \
    \      which is required by `&mut Vec<char>: Iterator`\n            `[char]: Iterator`\n\
    \            which is required by `&mut [char]: Iterator`\n\nerror[E0599]: no\
    \ method named `sort_unstable` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmp3jptbouk.rs:16:12\n   |\n16 |     vowels.sort_unstable();\n   |\
    \            ^^^^^^^^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3jptbouk.rs:23:21\n   |\n23 |         if index == n {\n\
    \   |                     ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n23 |         if index == n.try_into().unwrap() {\n   |                \
    \      ++++++++++++++++++++\n\nerror[E0277]: expected a `Fn<(char,)>` closure,\
    \ found `char`\n    --> /tmp/tmp3jptbouk.rs:30:31\n     |\n30   |         while\
    \ vowels.contains(&c) {\n     |                      -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                      |\n     |               \
    \       required by a bound introduced by this call\n     |\n     = help: the\
    \ trait `Fn<(char,)>` is not implemented for `char`\n     = note: required because\
    \ of the requirements on the impl of `FnOnc"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    trace!(\"select_words(\\\"{}\\\", {})\"\
    , s, n);\n    let mut ret = vec![];\n    let mut pat = vec![0usize; 26usize];\n\
    \    for ch in s.chars() {\n        if let Some(i) = pat[ch as usize] {\n    \
    \        ret[i as usize] = ch;\n        } else {\n            pat[ch as usize]\
    \ = ch.is_ascii() ? 0usize : 1usize;\n            ret.push(s);\n        }\n  \
    \  }\n    if ret.len() == 0 {\n        ret.push(s);\n    }\n    if n == 0 {\n\
    \        ret\n    } else {\n        let mut last = 0;\n        let mut has_consonant\
    \ = 0;\n        for ch in ret[0].chars() {\n            if let Some(i) = pat[ch\
    \ as usize] {\n                last = i;\n            } else {\n             \
    \   if !has_consonant {\n                    if n == 1 {\n                   \
    \     return ret\n                    } else {\n                        return\
    \ ret[0..last]\n                    }\n                } else {\n            \
    \        let start = last + 1;\n                    let end = start + n;\n   \
    \                 if end > ret.len() {\n                        end = ret.len();\n\
    \                    }\n                    return ret.iter().cloned().take(end).collect();\n\
    \                }\n            }\n            has_consonant = ch as usize !=\
    \ 32;\n        }\n        if n == 1 {\n            return ret\n        } else\
    \ {\n            return ret[0..last]\n        }\n    }\n}\n\nfn main() {\n   \
    \ let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `0usize`\n\
    \  --> /tmp/tmpk9rnm864.rs:20:48\n   |\n20 |             pat[ch as usize] = ch.is_ascii()\
    \ ? 0usize : 1usize;\n   |                                                ^^^^^^\
    \ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: cannot find macro\
    \ `trace` in this scope\n  --> /tmp/tmpk9rnm864.rs:13:5\n   |\n13 |     trace!(\"\
    select_words(\\\"{}\\\", {})\", s, n);\n   |     ^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk9rnm864.rs:17:16\n   |\n17 |         if let Some(i) =\
    \ pat[ch as usize] {\n   |                ^^^^^^^   ---------------- this expression\
    \ has type `usize`\n   |                |\n   |                expected `usize`,\
    \ found enum `Option`\n   |\n   = note: expected type `usize`\n              found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk9rnm864.rs:25:18\n\
    \   |\n25 |         ret.push(s);\n   |                  ^ expected `char`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk9rnm864.rs:28:9\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n28 |         ret\n   |         ^^^ expected struct `String`,\
    \ found `char`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<char>`\n\nerror[E0599]: no method named `chars` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpk9rnm864.rs:32:26\n   |\n32\
    \ |         for ch in ret[0].chars() {\n   |                          ^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk9rnm864.rs:33:20\n\
    \   |\n33 |             if let Some(i) = pat[ch as usize] {\n   |            \
    \        ^^^^^^^   ---------------- this expression has type `usize`\n   |   \
    \                 |\n   |                    expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk9rnm864.rs:36:20\n   |\n36 |\
    \                 if !has_consonant {\n   |"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut word_vec = Vec::new();\n   \
    \ let mut char_vec = Vec::new();\n\n    // Check whether number of letters is\
    \ valid\n    if s.chars().count() != n {\n        return Vec::new();\n    }\n\n\
    \    // Count the number of word\n    let mut word_cnt = 0;\n    for (i, char)\
    \ in s.chars().enumerate() {\n        if char == ' ' {\n            word_cnt +=\
    \ 1;\n        }\n\n        if char_vec.len() >= n {\n            break;\n    \
    \    }\n\n        char_vec.push(char);\n    }\n\n    if char_vec.len() == n {\n\
    \        word_cnt += 1;\n    }\n\n    let mut s = &s[..char_vec.len()];\n\n  \
    \  // Find all the words that match the criteria\n    for word_cnt in 0..word_cnt\
    \ {\n        let mut word = \"\";\n\n        // Find the next word\n        for\
    \ (i, char) in s.chars().enumerate() {\n            if char == ' ' {\n       \
    \         word_cnt += 1;\n                if word_cnt == n {\n               \
    \     break;\n                }\n                word_cnt -= 1;\n            \
    \    let mut s = &s[..i];\n            } else {\n                word += char;\n\
    \            }\n        }\n\n        // Add the word to the word list\n      \
    \  word_vec.push(word);\n    }\n\n    return word_vec;\n}\n\nfn main() {\n   \
    \ let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvqjvo5g7.rs:17:29\n   |\n\
    17 |     if s.chars().count() != n {\n   |                             ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |     if s.chars().count()\
    \ != n.try_into().unwrap() {\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvqjvo5g7.rs:28:30\n   |\n28 |\
    \         if char_vec.len() >= n {\n   |                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n28 |         if char_vec.len()\
    \ >= n.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvqjvo5g7.rs:35:26\n   |\n35 |\
    \     if char_vec.len() == n {\n   |                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n35 |     if char_vec.len() == n.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpvqjvo5g7.rs:55:17\n\
    \   |\n55 |                 word += char;\n   |                 ----^^^^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvqjvo5g7.rs:63:12\n   |\n12 |\
    \ fn select_words(s: String, n: isize) -> Vec<String> {\n   |                \
    \                         ----------- expected `Vec<String>` because of return\
    \ type\n...\n63 |     return word_vec;\n   |            ^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n   \
    \           found struct `Vec<&str>`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut s = String::from(s);\n    \n    while let Some(mut char)s = s.find(&\"a\"\
    ) {\n        if char == Some(s.len()) {\n            break;\n        }\n\n   \
    \     match s.chars().next() {\n            Some(x) => result.push(\"a\".to_string()),\n\
    \            None => {}\n        }\n        s = s.replace(\"a\", \"\").to_string();\n\
    \    }\n    \n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected one of `=` or `|`, found `s`\n  --> /tmp/tmpud36enjo.rs:16:29\n\
    \   |\n16 |     while let Some(mut char)s = s.find(&\"a\") {\n   |     ----- \
    \                  ^ expected one of `=` or `|`\n   |     |\n   |     while parsing\
    \ the condition of this `while` expression\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n    \n    let mut s = s.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut len: isize = 0;\n    let mut word = Vec::new();\n    \n    for i\
    \ in 0..s.len() {\n        let cur = s.len() - i - 1;\n        let word = s.split_at_mut(cur);\n\
    \        if word.len() == n {\n            words.push(&mut word[0]);\n       \
    \ }\n    }\n    return words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `words` in this scope\n  --> /tmp/tmpxevm1xma.rs:23:13\n\
    \   |\n23 |             words.push(&mut word[0]);\n   |             ^^^^^ help:\
    \ a local variable with a similar name exists: `word`\n\nerror[E0425]: cannot\
    \ find value `words` in this scope\n  --> /tmp/tmpxevm1xma.rs:26:12\n   |\n26\
    \ |     return words\n   |            ^^^^^ help: a local variable with a similar\
    \ name exists: `word`\n\nerror[E0599]: no method named `len` found for tuple `(&mut\
    \ [char], &mut [char])` in the current scope\n  --> /tmp/tmpxevm1xma.rs:22:17\n\
    \   |\n22 |         if word.len() == n {\n   |                 ^^^ method not\
    \ found in `(&mut [char], &mut [char])`\n\nerror[E0608]: cannot index into a value\
    \ of type `(&mut [char], &mut [char])`\n  --> /tmp/tmpxevm1xma.rs:23:29\n   |\n\
    23 |             words.push(&mut word[0]);\n   |                             ^^^^^^^\
    \ help: to access tuple elements, use: `word.0`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk3h3gqf1.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut a = vec![];\n    for word in\
    \ s.split_whitespace() {\n        if a.len() == n {\n            return a;\n \
    \       }\n        if word.chars().filter(|&x| x == '#' || x == '?' || x == '!'\
    \ || x == '.' || x == '-' || x == '(').count() > n {\n            a.push(word);\n\
    \        }\n    }\n    a.clone_owned()\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp08uzvknl.rs:15:23\n   |\n\
    15 |         if a.len() == n {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n15 |         if a.len() == n.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp08uzvknl.rs:18:117\n   |\n18 |         if word.chars().filter(|&x|\
    \ x == '#' || x == '?' || x == '!' || x == '.' || x == '-' || x == '(').count()\
    \ > n {\n   |                                                                \
    \                                                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |         if word.chars().filter(|&x|\
    \ x == '#' || x == '?' || x == '!' || x == '.' || x == '-' || x == '(').count()\
    \ > n.try_into().unwrap() {\n   |                                            \
    \                                                                          ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp08uzvknl.rs:19:20\n   |\n19 |\
    \             a.push(word);\n   |                    ^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `&str`\n\nerror[E0599]: no method named `clone_owned`\
    \ found for struct `Vec<String>` in the current scope\n  --> /tmp/tmp08uzvknl.rs:22:7\n\
    \   |\n22 |     a.clone_owned()\n   |       ^^^^^^^^^^^ method not found in `Vec<String>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n    let mut words = Vec::new();\n\
    \    let mut last_word = \"\";\n    let mut current_consonant = false;\n    \n\
    \    for c in s.chars() {\n        \n        if c == '_' {\n            \n   \
    \         if last_word.len() != 0 {\n                \n                words.push(last_word);\n\
    \                \n            }\n            \n            last_word = \"\";\n\
    \            \n            current_consonant = false;\n            \n        }\
    \ else if !current_consonant {\n            \n            if c == ' ' {\n    \
    \            \n                words.push(last_word);\n                \n    \
    \            last_word = \"\";\n                \n            } else {\n     \
    \           \n                current_consonant = true;\n                \n  \
    \              last_word += c;\n                \n            }\n            \n\
    \        } else {\n            \n            if c != ' ' {\n                \n\
    \                current_consonant = false;\n                \n              \
    \  last_word += c;\n                \n            }\n            \n        }\n\
    \        \n    }\n    \n    if last_word.len() != 0 {\n        \n        words.push(last_word);\n\
    \        \n    }\n    \n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmpphc1vju7.rs:44:17\n   |\n44 |                 last_word\
    \ += c;\n   |                 ---------^^^^^\n   |                 |\n   |   \
    \              cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpphc1vju7.rs:54:17\n\
    \   |\n54 |                 last_word += c;\n   |                 ---------^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpphc1vju7.rs:68:5\n   |\n12 | fn\
    \ select_words(s: String, n: isize) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n68 |     words\n   |     ^^^^^ expected struct `String`, found `&str`\n \
    \  |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut words = vec![];\n    let mut counter: usize = 0;\n\n   \
    \ for (idx, c) in s.chars().enumerate() {\n        if counter == n {\n       \
    \     break;\n        }\n        if c == ' ' || c == '\\t' || c == '\\n' || c\
    \ == '\\r' {\n            counter = 0;\n        } else {\n            counter\
    \ += 1;\n        }\n        words.push(s.chars()[idx as usize].to_string());\n\
    \    }\n\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpioa00pac.rs:21:23\n   |\n\
    21 |         if counter == n {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         if counter == n.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0608]: cannot\
    \ index into a value of type `Chars<'_>`\n  --> /tmp/tmpioa00pac.rs:29:20\n  \
    \ |\n29 |         words.push(s.chars()[idx as usize].to_string());\n   |     \
    \               ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    match s.len() {\n        0 => vec![],\n\
    \        _ => s.chars().filter_map(|c| {\n            if c.is_ascii_digit() {\n\
    \                Some(c.to_ascii_digit())\n            } else if c.is_lowercase()\
    \ {\n                Some(c.to_ascii_lowercase())\n            } else if c.is_uppercase()\
    \ {\n                Some(c.to_ascii_uppercase())\n            } else if c.is_whitespace()\
    \ {\n                Some(c.to_ascii_whitespace())\n            } else if c.is_punctuation()\
    \ {\n                Some(c.to_ascii_punctuation())\n            } else {\n  \
    \              None\n            }\n        }).take(n).collect(),\n    }\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_ascii_digit` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpdy242lp8.rs:17:24\n   |\n17 |             \
    \    Some(c.to_ascii_digit())\n   |                        ^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_digit`\n\nerror[E0599]:\
    \ no method named `to_ascii_whitespace` found for type `char` in the current scope\n\
    \  --> /tmp/tmpdy242lp8.rs:23:24\n   |\n23 |                 Some(c.to_ascii_whitespace())\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii_whitespace`\n\nerror[E0599]: no method\
    \ named `is_punctuation` found for type `char` in the current scope\n  --> /tmp/tmpdy242lp8.rs:24:25\n\
    \   |\n24 |             } else if c.is_punctuation() {\n   |                 \
    \        ^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii_punctuation`\n\nerror[E0599]: no method named `to_ascii_punctuation`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpdy242lp8.rs:25:24\n\
    \   |\n25 |                 Some(c.to_ascii_punctuation())\n   |             \
    \           ^^^^^^^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_ascii_punctuation`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdy242lp8.rs:29:17\n   |\n29 |         }).take(n).collect(),\n   |  \
    \               ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    29 |         }).take(n.try_into().unwrap()).collect(),\n   |                 \
    \ ++++++++++++++++++++\n\nerror[E0277]: a value of type `Vec<String>` cannot be\
    \ built from an iterator over elements of type `char`\n    --> /tmp/tmpdy242lp8.rs:29:20\n\
    \     |\n29   |         }).take(n).collect(),\n     |                    ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // COMPLETE\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvm52t4ic.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s == \"\" {\n        return vec![];\n\
    \    }\n    let mut words: Vec<String> = vec![];\n    let mut current_length:\
    \ usize = 0;\n    \n    for x in s.chars() {\n        if x == ' ' {\n        \
    \    current_length += 1;\n            words.push(\"\");\n        } else {\n \
    \           if current_length == n {\n                words.push(s.chars());\n\
    \                current_length += 1;\n            } else if current_length ==\
    \ 0 {\n                current_length += 1;\n                words.push(s.chars());\n\
    \            }\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dltuaot.rs:22:24\n   |\n\
    22 |             words.push(\"\");\n   |                        ^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1dltuaot.rs:24:34\n   |\n24 |             if\
    \ current_length == n {\n   |                                  ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n24 |             if current_length\
    \ == n.try_into().unwrap() {\n   |                                   ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1dltuaot.rs:25:28\n   |\n25 |\
    \                 words.push(s.chars());\n   |                            ^^^^^^^^^\
    \ expected struct `String`, found struct `Chars`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1dltuaot.rs:29:28\n   |\n29 |                 words.push(s.chars());\n\
    \   |                            ^^^^^^^^^ expected struct `String`, found struct\
    \ `Chars`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut l = String::new();\n    let\
    \ mut s = String::from(s);\n    while s.len() > 0 {\n        if s.chars().count(|&x|\
    \ *x == ' ') > n {\n            l.push_str(s.as_str().to_string());\n        }\n\
    \        s = s.trim();\n    }\n    l.push_str(s.as_str().to_string());\n    l\n\
    \        .split_whitespace()\n        .filter(|&x| x == \" \")\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&_`\n  --> /tmp/tmpi_mx_si5.rs:16:29\n\
    \   |\n16 |         if s.chars().count(|&x| *x == ' ') > n {\n   |           \
    \                  ^^ consider giving this closure parameter the explicit type\
    \ `&_`, with the type parameters specified\n   |\n   = note: type must be known\
    \ at this point\n\nerror[E0061]: this function takes 0 arguments but 1 argument\
    \ was supplied\n   --> /tmp/tmpi_mx_si5.rs:16:22\n    |\n16  |         if s.chars().count(|&x|\
    \ *x == ' ') > n {\n    |                      ^^^^^ -------------- supplied 1\
    \ argument\n    |                      |\n    |                      expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi_mx_si5.rs:16:46\n   |\n16 |         if s.chars().count(|&x|\
    \ *x == ' ') > n {\n   |                                              ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n16 |         if s.chars().count(|&x|\
    \ *x == ' ') > n.try_into().unwrap() {\n   |                                 \
    \              ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi_mx_si5.rs:17:24\n\
    \   |\n17 |             l.push_str(s.as_str().to_string());\n   |            \
    \            ^^^^^^^^^^^^^^^^^^^^^^\n   |                        |\n   |     \
    \                   expected `&str`, found struct `String`\n   |             \
    \           help: consider borrowing here: `&s.as_str().to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi_mx_si5.rs:19:13\n   |\n14 |     let mut s\
    \ = String::from(s);\n   |                 --------------- expected due to this\
    \ value\n...\n19 |         s = s.trim();\n   |             ^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |             |\n   |        \
    \     expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi_mx_si5.rs:21:16\n   |\n21 |     l.push_str(s.as_str().to_string());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^\n   |                |\n   |     \
    \           expe"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    \n \
    \   for (i, ch) in s.chars().enumerate().filter(|(_, i2)| i > 0\n        .and(s.chars().nth(i2).count(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') != 0)).enumerate().filter(|(_,\
    \ i2)| i < s.len()) {\n        let mut word: String = \"\";\n        if s.len()\
    \ > i {\n            if s.chars().nth(i).count('a') > n {\n                word\
    \ = \"\";\n            } else {\n                word = s.chars().nth(i).to_string();\n\
    \            }\n        }\n        list.append(word);\n    }\n    list\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp92imnqdd.rs:15:59\n\
    \   |\n15 |     for (i, ch) in s.chars().enumerate().filter(|(_, i2)| i > 0\n\
    \   |                                                           ^ help: a local\
    \ variable with a similar name exists: `i2`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmp92imnqdd.rs:16:136\n   |\n16 | ...) != 0)).enumerate().filter(|(_,\
    \ i2)| i < s.len()) {\n   |                                          ^ help: a\
    \ local variable with a similar name exists: `i2`\n\nerror[E0689]: can't call\
    \ method `and` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp92imnqdd.rs:16:10\n\
    \   |\n16 | ...   .and(s.chars().nth(i2).count(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') != 0)).enumerate().filter(|(_, i2)| i < ...\n \
    \  |        ^^^\n   |\nhelp: you must specify a concrete type for this numeric\
    \ value, like `i32`\n   |\n15 |     for (i, ch) in s.chars().enumerate().filter(|(_,\
    \ i2)| i > 0_i32\n   |                                                       \
    \        ~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp92imnqdd.rs:16:28\n\
    \   |\n16 | ...   .and(s.chars().nth(i2).count(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') != 0)).enumerate().filter(|(_, i2)| i < ...\n \
    \  |                          ^^ expected `usize`, found `&char`\n\nerror[E0599]:\
    \ `Option<char>` is not an iterator\n   --> /tmp/tmp92imnqdd.rs:16:32\n    |\n\
    16  |   ...   .and(s.chars().nth(i2).count(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u') != 0)).enumerate().filter(|(_, i2)| i < ...\n    |\
    \                                ^^^^^ `Option<char>` is not an iterator\n   \
    \ |\n    = note: the following trait bounds were not satisfied:\n            `Option<char>:\
    \ Iterator`\n            which is required by `&mut Option<char>: Iterator`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp92imnqdd.rs:17:32\n   |\n17 |  \
    \       let mut word: String = \"\";\n   |                       ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \     |        |\n   |         "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s == \"\" {\n        return Vec::new();\n\
    \    }\n    let mut s = s;\n    let mut count = 0;\n    while count < n {\n  \
    \      let index = s.find(' ');\n        if index == s.len() {\n            break;\n\
    \        }\n        let word = &s[..index];\n        let rest = &s[index..];\n\
    \        if !rest.chars().all(|&c| c == 'a'..'z' || c == 'A'..'Z') {\n       \
    \     count += 1;\n        }\n        s = rest;\n    }\n    \n    s.chars().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjio4iyq7.rs:20:21\n   |\n\
    20 |         if index == s.len() {\n   |                     ^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 |         if index == Some(s.len()) {\n   |                     +++++\
    \       +\n\nerror[E0277]: the type `String` cannot be indexed by `RangeTo<Option<usize>>`\n\
    \  --> /tmp/tmpjio4iyq7.rs:23:21\n   |\n23 |         let word = &s[..index];\n\
    \   |                     ^^^^^^^^^^ `String` cannot be indexed by `RangeTo<Option<usize>>`\n\
    \   |\n   = help: the trait `Index<RangeTo<Option<usize>>>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \  --> /tmp/tmpjio4iyq7.rs:24:21\n   |\n24 |         let rest = &s[index..];\n\
    \   |                     ^^^^^^^^^^ `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjio4iyq7.rs:25:45\n\
    \   |\n25 |         if !rest.chars().all(|&c| c == 'a'..'z' || c == 'A'..'Z')\
    \ {\n   |                                            "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut count = String::new();\n   \
    \ for &c in s.chars() {\n        if c == 'z' || c == 'Z' {\n            if c.to_digit()\
    \ > 9 {\n                return vec![];\n            }\n            count.push(c);\n\
    \        } else {\n            count.push(c);\n        }\n    }\n    \n    let\
    \ mut index = count.len() - 1;\n    let mut arr = vec![];\n    while index >=\
    \ 0 {\n        if count.chars().nth(index).unwrap().to_digit() == n {\n      \
    \      arr.push(s.chars().nth(index).unwrap());\n            index -= 1;\n   \
    \     }\n        index -= 1;\n    }\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm8jtzfaz.rs:14:9\n   |\n\
    14 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpm8jtzfaz.rs:28:46\n\
    \    |\n28  |         if count.chars().nth(index).unwrap().to_digit() == n {\n\
    \    |                                              ^^^^^^^^- supplied 0 arguments\n\
    \    |                                              |\n    |                 \
    \                             expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm8jtzfaz.rs:28:60\n\
    \   |\n28 |         if count.chars().nth(index).unwrap().to_digit() == n {\n \
    \  |                                                            ^ expected enum\
    \ `Option`, found `isize`\n   |\n   = note: expected enum `Option<u32>`\n    \
    \          found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm8jtzfaz.rs:34:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n34 |     arr\n   |     ^^^ expected struct `String`, found\
    \ `char`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<char>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // TODO\n    return vec![];\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp6drvdsc5.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut\
    \ words = s.split_whitespace();\n  let mut current_word = String::new();\n\n \
    \ while words.len() > 0 {\n    let mut count = 0;\n    let mut current_char =\
    \ String::new();\n\n    for (index, char) in words.split_whitespace().iter().enumerate()\
    \ {\n      if char == ' ' {\n        result.push(current_word);\n        if count\
    \ > n {\n          break;\n        }\n        count = count + 1;\n        current_word.clear();\n\
    \        current_char = char;\n      }\n      else {\n        if char == current_char\
    \ {\n          count = count + 1;\n        }\n        else {\n          current_char.push_str(&char);\n\
    \          current_word.push_str(&current_char);\n          current_char = char;\n\
    \          count = count + 1;\n        }\n      }\n    }\n\n    if count > n {\n\
    \      result.push(current_word);\n    }\n\n    words = words.split_whitespace();\n\
    \  }\n\n  result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmplelfqnf8.rs:17:15\n   |\n17 |   while words.len()\
    \ > 0 {\n   |               ^^^ method not found in `SplitWhitespace<'_>`\n\n\
    error[E0599]: no method named `split_whitespace` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmplelfqnf8.rs:21:32\n   |\n21 |     for (index,\
    \ char) in words.split_whitespace().iter().enumerate() {\n   |               \
    \                 ^^^^^^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmplelfqnf8.rs:22:15\n\
    \   |\n22 |       if char == ' ' {\n   |               ^^ no implementation for\
    \ `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0599]: no method\
    \ named `split_whitespace` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmplelfqnf8.rs:48:19\n   |\n48 |     words = words.split_whitespace();\n\
    \   |                   ^^^^^^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // BEGIN YOUR CODE\n    // Write your\
    \ solution here\n    // END YOUR CODE\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnb19noe4.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut i = 0;\n    while i < s.size() {\n        let mut current_word = s.to_string();\n\
    \        if current_word.len() > i {\n            if current_word.chars().nth(i)\
    \ == Some('\\'') {\n                current_word = current_word.chars().nth(i\
    \ + 1)\n                    .expect(\"string contains only letters\");\n     \
    \           i += 2;\n            }\n            current_word.chars()\n       \
    \         .take_while(|c| c != '\\''.to_char() && c != ' '.to_char())\n      \
    \          .take(n)\n                .for_each(|c| {\n                    result.push(c+current_word);\n\
    \                });\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpcruw9_vr.rs:15:17\n   |\n15 |     while i < s.size() {\n\
    \   |                 ^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcruw9_vr.rs:19:32\n   |\n16 |           let mut current_word\
    \ = s.to_string();\n   |                                  ------------- expected\
    \ due to this value\n...\n19 |                   current_word = current_word.chars().nth(i\
    \ + 1)\n   |  ________________________________^\n20 | |                     .expect(\"\
    string contains only letters\");\n   | |                                     \
    \                      ^- help: try using a conversion method: `.to_string()`\n\
    \   | |___________________________________________________________|\n   |    \
    \                                                         expected struct `String`,\
    \ found `char`\n\nerror[E0599]: no method named `to_char` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpcruw9_vr.rs:24:43\n   |\n24 |          \
    \       .take_while(|c| c != '\\''.to_char() && c != ' '.to_char())\n   |    \
    \                                       ^^^^^^^ method not found in `char`\n\n\
    error[E0599]: no method named `to_char` found for type `char` in the current scope\n\
    \  --> /tmp/tmpcruw9_vr.rs:24:65\n   |\n24 |                 .take_while(|c| c\
    \ != '\\''.to_char() && c != ' '.to_char())\n   |                            \
    \                                     ^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcruw9_vr.rs:25:23\n   |\n25 |              \
    \   .take(n)\n   |                       ^ expected `usize`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |                 .take(n.try_into().unwrap())\n\
    \   |                        ++++++++++++++++++++\n\nerror[E0369]: cannot add\
    \ `String` to `char`\n  --> /tmp/tmpcruw9_vr.rs:27:34\n   |\n27 |            \
    \         result.push(c+current_word);\n   |                                 -^------------\
    \ String\n   |                     "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // Your code here\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyzh2nrry.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return Vec::new();\n\
    \    }\n    \n    let mut words = Vec::new();\n    \n    let mut i = 0;\n    let\
    \ mut j = 0;\n    \n    while i < s.len() {\n        let mut l = s.chars().enumerate().filter(|&(c,\
    \ _)| c < i && c <= i + n).count();\n        while l == 0 {\n            i +=\
    \ 1;\n            l = s.chars().enumerate().filter(|&(c, _)| c < i && c <= i +\
    \ n).count();\n        }\n        \n        if l > 0 {\n            i += l - 1;\n\
    \        }\n        \n        words.push(s.chars().get_mut(i).unwrap());\n   \
    \ }\n    \n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp__5535nc.rs:23:78\n   |\n\
    23 |         let mut l = s.chars().enumerate().filter(|&(c, _)| c < i && c <=\
    \ i + n).count();\n   |                                                      \
    \                        ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add `isize` to `usize`\n  --> /tmp/tmp__5535nc.rs:23:76\n   |\n23 |        \
    \ let mut l = s.chars().enumerate().filter(|&(c, _)| c < i && c <= i + n).count();\n\
    \   |                                                                        \
    \    ^ no implementation for `usize + isize`\n   |\n   = help: the trait `Add<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp__5535nc.rs:26:74\n\
    \   |\n26 |             l = s.chars().enumerate().filter(|&(c, _)| c < i && c\
    \ <= i + n).count();\n   |                                                   \
    \                       ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add `isize` to `usize`\n  --> /tmp/tmp__5535nc.rs:26:72\n   |\n26 |        \
    \     l = s.chars().enumerate().filter(|&(c, _)| c < i && c <= i + n).count();\n\
    \   |                                                                        ^\
    \ no implementation for `usize + isize`\n   |\n   = help: the trait `Add<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror[E0599]: no method na"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppb2w33b1.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    s \n        .split_whitespace() \n \
    \       .filter(|&w| w.len() == n)\n        .collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8obkexbe.rs:15:33\n   |\n\
    15 |         .filter(|&w| w.len() == n)\n   |                                \
    \ ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n15 |         .filter(|&w|\
    \ w.len() == n.try_into().unwrap())\n   |                                  ++++++++++++++++++++\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp8obkexbe.rs:16:10\n     |\n16\
    \   |         .collect::<Vec<String>>()\n     |          ^^^^^^^ value of type\
    \ `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n\
    \     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ count = 0;\n    let mut cur = 0;\n    for c in s.chars() {\n        if c.is_letter()\
    \ {\n            count += 1;\n            if count == n {\n                words.push(s.to_string().chars().take(cur).collect::<String>());\n\
    \                cur += 1;\n                count = 0;\n            }\n      \
    \  } else {\n            count = 0;\n        }\n    }\n    if count > 0 {\n  \
    \      words.push(s.to_string().chars().take(cur).collect::<String>());\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpw9_qrq5o.rs:17:14\n   |\n17 |         if c.is_letter()\
    \ {\n   |              ^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n\
    \    if s.is_empty() {\n        return result;\n    }\n    let mut i = 0;\n  \
    \  let mut j = 0;\n    let mut consonant_count: usize = 0;\n    let mut vowel_count:\
    \ usize = 0;\n    while i < s.len() {\n        if s[i] == ' ' {\n            i\
    \ += 1;\n        } else if s[i] == 'e' {\n            i += 1;\n        } else\
    \ if s[i] == 'i' {\n            i += 1;\n        } else if s[i] == 'o' {\n   \
    \         i += 1;\n        } else if s[i] == 'u' {\n            i += 1;\n    \
    \    } else if s[i] == 'y' {\n            i += 1;\n        } else if s[i] == 'a'\
    \ {\n            i += 1;\n        } else {\n            consonant_count += 1;\n\
    \        }\n\n        if j == n {\n            i += 1;\n            break;\n \
    \       }\n        if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o'\
    \ || s[i] == 'u' || s[i] == 'y' {\n            vowel_count += 1;\n        }\n\
    \        i += 1;\n        j += 1\n    }\n    if consonant_count == n {\n     \
    \   for (i) in s.chars() {\n            if i != ' ' && i != ',' && i != '.' &&\
    \ i != ';' && i != ':' && i != ';' && i != ':' && i != ',' {\n               \
    \ result.push(i);\n            }\n        }\n    } else if consonant_count ==\
    \ n+1 && vowel_count == n {\n        for (i) in s.chars() {\n            if i\
    \ != ' ' && i != ',' && i != '.' && i != ';' && i != ':' && i != ';' && i != ':'\
    \ && i != ',' {\n                result.push(i);\n            }\n        }\n \
    \   } else {\n        for (i) in s.chars() {\n            if i != ' ' && i !=\
    \ ',' && i != '.' && i != ';' && i != ':' && i != ';' && i != ':' && i != ','\
    \ {\n                result.push(i);\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around pattern\n  --> /tmp/tmp_iv7ksn0.rs:51:13\n\
    \   |\n51 |         for (i) in s.chars() {\n   |             ^ ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    51 -         for (i) in s.chars() {\n51 +         for i in s.chars() {\n   | \n\
    \nwarning: unnecessary parentheses around pattern\n  --> /tmp/tmp_iv7ksn0.rs:57:13\n\
    \   |\n57 |         for (i) in s.chars() {\n   |             ^ ^\n   |\nhelp:\
    \ remove these parentheses\n   |\n57 -         for (i) in s.chars() {\n57 +  \
    \       for i in s.chars() {\n   | \n\nwarning: unnecessary parentheses around\
    \ pattern\n  --> /tmp/tmp_iv7ksn0.rs:63:13\n   |\n63 |         for (i) in s.chars()\
    \ {\n   |             ^ ^\n   |\nhelp: remove these parentheses\n   |\n63 -  \
    \       for (i) in s.chars() {\n63 +         for i in s.chars() {\n   | \n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_iv7ksn0.rs:22:12\n\
    \   |\n22 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_iv7ksn0.rs:24:19\n   |\n24 |         } else if s[i] == 'e' {\n\
    \   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut count = 0;\n    let mut words\
    \ = Vec::new();\n    for c in s.chars() {\n        if c == ' ' || c.is_ascii()\
    \ {\n            if count == n {\n                break;\n            } else {\n\
    \                count += 1;\n            }\n        } else {\n            words.push(c.to_string());\n\
    \        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpzbvoxymj.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n\n    for\
    \ letter in s.chars() {\n        if letter == ' ' {\n            words.push('\
    \ ');\n        } else {\n            for consonant in consonants() {\n       \
    \         if consonant.contains(letter) {\n                    if let Some(pos)\
    \ = find_index(&s.to_string(), consonant) {\n                        words.push(s.to_string()[..pos]);\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n        }\n    }\n\n    words.dedup();\n    words\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `consonants` in this scope\n  --> /tmp/tmptbgw0pan.rs:19:30\n\
    \   |\n19 |             for consonant in consonants() {\n   |                \
    \              ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `find_index` in this scope\n  --> /tmp/tmptbgw0pan.rs:21:40\n   |\n\
    21 |                     if let Some(pos) = find_index(&s.to_string(), consonant)\
    \ {\n   |                                        ^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptbgw0pan.rs:22:36\n \
    \  |\n22 |                         words.push(s.to_string()[..pos]);\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptbgw0pan.rs:31:5\n  \
    \ |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |        \
    \                                 ----------- expected `Vec<String>` because of\
    \ return type\n...\n31 |     words\n   |     ^^^^^ expected struct `String`, found\
    \ `char`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<char>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut s = s; // Create a copy of the\
    \ string so that we don't mutate it.\n    let mut list: Vec<String> = Vec::new();\n\
    \    \n    for &c in s.chars() {\n        if c.is_consonant() {\n            if\
    \ c.is_vowel() {\n                list.push(c)\n            } else {\n       \
    \         list.repeat_with(1, |i|\n                    list.repeat_with(1, |j|\n\
    \                        list.repeat_with(1, |k|\n                           \
    \ list.push(c.repeat(i, j, k))\n                        )\n                  \
    \  )\n                )\n            }\n        }\n    }\n    \n    list.take(n\
    \ as usize)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8zhva4hv.rs:16:9\n   |\n\
    16 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `repeat_with` found for struct `Vec<String>` in the current\
    \ scope\n  --> /tmp/tmp8zhva4hv.rs:21:22\n   |\n21 |                 list.repeat_with(1,\
    \ |i|\n   |                      ^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `repeat`\n\nerror[E0599]: no method named `repeat_with`\
    \ found for struct `Vec<String>` in the current scope\n  --> /tmp/tmp8zhva4hv.rs:22:26\n\
    \   |\n22 |                     list.repeat_with(1, |j|\n   |                \
    \          ^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `repeat`\n\nerror[E0599]: no method named `repeat_with` found for struct `Vec<String>`\
    \ in the current scope\n  --> /tmp/tmp8zhva4hv.rs:23:30\n   |\n23 |          \
    \               list.repeat_with(1, |k|\n   |                              ^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `repeat`\n\nerror[E0599]:\
    \ `Vec<String>` is not an iterator\n   --> /tmp/tmp8zhva4hv.rs:32:10\n    |\n\
    32  |       list.take(n as usize)\n    |            ^^^^ `Vec<String>` is not\
    \ an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<String>: Iterator`\n            which is required by `&mut Vec<String>:\
    \ Iterator`\n            `[String]: Iterator`\n            which is required by\
    \ `&mut [String]: Iterator`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let\
    \ mut count = 0;\n    for word in s.split() {\n        if word.chars().count()\
    \ > n {\n            result.push(word);\n            count += 1;\n           \
    \ if count == n {\n                break;\n            }\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpwd6ybo60.rs:15:19\n     |\n15   |     for word in s.split() {\n\
    \     |                   ^^^^^- supplied 0 arguments\n     |                \
    \   |\n     |                   expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwd6ybo60.rs:16:35\n\
    \   |\n16 |         if word.chars().count() > n {\n   |                      \
    \             ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n16\
    \ |         if word.chars().count() > n.try_into().unwrap() {\n   |          \
    \                          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwd6ybo60.rs:24:5\n   |\n12 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n24 |     result\n   |     ^^^^^^\
    \ expected struct `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    if\
    \ s.is_empty() {\n        return result;\n    }\n\n    let mut current_index =\
    \ 0;\n    let mut current_char = s.chars().next();\n    while current_char.is_some()\
    \ {\n        if current_char.as_str() == &current_char.unwrap()[current_index..]\
    \ {\n            result.push(s.chars().take(current_index).collect::<String>());\n\
    \            current_index += 1;\n        }\n\n        current_char = s.chars().next();\n\
    \    }\n\n    let mut current_char_vec = Vec::new();\n    current_char_vec.push(&current_char.unwrap()[..]);\n\
    \    current_char_vec.push(&s.chars().next().unwrap()[..]);\n\n    while current_index\
    \ != n {\n        current_char_vec.push(&current_char.unwrap()[..]);\n       \
    \ current_char_vec.push(&s.chars().next().unwrap()[..]);\n        current_index\
    \ = 1;\n    }\n\n    result.push(current_char_vec.clone());\n    result\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_str` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpuc1ne0ge.rs:21:25\n   |\n21 |         if current_char.as_str()\
    \ == &current_char.unwrap()[current_index..] {\n   |                         ^^^^^^\
    \ method not found in `Option<char>`\n\nerror[E0608]: cannot index into a value\
    \ of type `char`\n  --> /tmp/tmpuc1ne0ge.rs:21:38\n   |\n21 |         if current_char.as_str()\
    \ == &current_char.unwrap()[current_index..] {\n   |                         \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `char`\n  --> /tmp/tmpuc1ne0ge.rs:30:28\n   |\n30 |   \
    \  current_char_vec.push(&current_char.unwrap()[..]);\n   |                  \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `char`\n  --> /tmp/tmpuc1ne0ge.rs:31:28\n   |\n31 |     current_char_vec.push(&s.chars().next().unwrap()[..]);\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuc1ne0ge.rs:33:28\n   |\n33 |     while current_index\
    \ != n {\n   |                            ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n33 |     while current_index != n.try_into().unwrap()\
    \ {\n   |                             ++++++++++++++++++++\n\nerror[E0608]: cannot\
    \ index into a value of type `char`\n  --> /tmp/tmpuc1ne0ge.rs:34:32\n   |\n34\
    \ |         current_char_vec.push(&current_char.unwrap()[..]);\n   |         \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `char`\n  --> /tmp/tmpuc1ne0ge.rs:35:32\n   |\n35 |   \
    \      current_char_vec.push(&s.chars().next().unwrap()[..]);\n   |          \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuc1ne0ge.rs:39:17\n   |\n39 |     result.push(current_char_vec.clone());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `String`\n         "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut count = HashSet::new();\n  \
    \  let mut s = s\n        .split_whitespace()\n        .iter()\n        .filter(|&x|\
    \ !x.is_empty() && x.chars().any(|&x| x.is_consonant()))\n        .collect::<Vec<_>>();\n\
    \    for &word in s.iter() {\n        if count.contains(&word) {\n           \
    \ count.remove(word);\n        } else {\n            count.insert(word);\n   \
    \     }\n    }\n    count\n        .into_iter()\n        .take_while(|&word| n\
    \ == 0 || word.length == n)\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp9yrlzwiz.rs:13:21\n   |\n13 |     let mut count = HashSet::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0599]:\
    \ no method named `iter` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmp9yrlzwiz.rs:16:10\n   |\n16 |         .iter()\n   |          ^^^^\
    \ method not found in `SplitWhitespace<'_>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = vec![];\n    let mut\
    \ cursor = String::new();\n    for (i, c) in s.chars().enumerate() {\n       \
    \ if c == ' ' {\n            cursor = String::from(&s[i..i+1]);\n        }\n \
    \       list.push(cursor);\n        if i == n {\n            break;\n        }\n\
    \    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpitu1w9iy.rs:20:17\n   |\n\
    20 |         if i == n {\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |         if i == n.try_into().unwrap() {\n   |\
    \                  ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut idx = 0;\n    while idx < s.len() {\n        let c = s[idx].to_string();\n\
    \        if c.chars().count(|c| *c == 'a'..='z')>=n {\n            list.push(&s[idx..idx+n].to_string());\n\
    \            idx += n;\n        }\n        idx += 1;\n    }\n    list\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptfv_uoic.rs:16:17\n\
    \   |\n16 |         let c = s[idx].to_string();\n   |                 ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptfv_uoic.rs:17:44\n\
    \   |\n17 |         if c.chars().count(|c| *c == 'a'..='z')>=n {\n   |       \
    \                                     ^^^ expected `bool`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptfv_uoic.rs:18:35\n   |\n18 |             list.push(&s[idx..idx+n].to_string());\n\
    \   |                                   ^ expected `usize`, found `isize`\n\n\
    error[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmptfv_uoic.rs:18:34\n\
    \   |\n18 |             list.push(&s[idx..idx+n].to_string());\n   |         \
    \                         ^ no implementation for `usize + isize`\n   |\n   =\
    \ help: the trait `Add<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `Add<Rhs>`:\n             <&'a f32 as\
    \ Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n\
    \             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n    \
    \         <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n          \
    \   <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptfv_uoic.rs:19:20\n   |\n19 |             idx += n;\n \
    \  |                    ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add-assign `isize` to `usize`\n  --> /tmp/tmptfv_uoic.rs:19:17\n   |\n19 | \
    \            idx += n;\n   |                 ^^ no imple"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n\n    for\
    \ i in 0..s.len() {\n        let j = i + n;\n\n        for c in s.chars().skip(i).take(j).collect::<Vec<char>>()\
    \ {\n            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                words.push((s.to_string() + &c).to_string());\n            }\n\
    \        }\n    }\n\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzpr2nhtj.rs:16:21\n   |\n\
    16 |         let j = i + n;\n   |                     ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpzpr2nhtj.rs:16:19\n\
    \   |\n16 |         let j = i + n;\n   |                   ^ no implementation\
    \ for `usize + isize`\n   |\n   = help: the trait `Add<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzpr2nhtj.rs:20:45\n\
    \   |\n20 |                 words.push((s.to_string() + &c).to_string());\n  \
    \ |                                             ^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    assert!(n >= 0);\n    let mut words\
    \ = Vec::new();\n    let mut counter = 0;\n    for c in s {\n        if c != \"\
    \ \" {\n            counter = counter + 1;\n        }\n        if counter == n\
    \ {\n            words.push(c.to_string());\n            counter = 0;\n      \
    \  }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp_rlhsk4m.rs:16:14\n\
    \   |\n16 |     for c in s {\n   |              ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    return Vec::new();\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpj1yu6luz.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    todo!()\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not yet implemented', /tmp/tmpmahde7ny.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut arr = Vec::new();\n    for w\
    \ in s.split() {\n        if w.len() == n && w.is_lowercase() {\n            arr.push(w);\n\
    \        }\n    }\n    return arr;\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpq9cp2uho.rs:14:16\n     |\n14   |     for w in s.split() {\n\
    \     |                ^^^^^- supplied 0 arguments\n     |                |\n\
    \     |                expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq9cp2uho.rs:15:23\n\
    \   |\n15 |         if w.len() == n && w.is_lowercase() {\n   |              \
    \         ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n15 |      \
    \   if w.len() == n.try_into().unwrap() && w.is_lowercase() {\n   |          \
    \              ++++++++++++++++++++\n\nerror[E0599]: no method named `is_lowercase`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpq9cp2uho.rs:15:30\n\
    \   |\n15 |         if w.len() == n && w.is_lowercase() {\n   |              \
    \                ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq9cp2uho.rs:19:12\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n19 |     return arr;\n   |            ^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n   \
    \           found struct `Vec<&str>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut l = Vec::new();\n    let mut\
    \ consonants: Vec<isize> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let\
    \ mut vowels: Vec<isize> = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n    let mut\
    \ counter = vec![0; 10];\n    let mut pos = 0;\n\n    for c in s.chars() {\n \
    \       if !consonants.contains(c) {\n            if counter[c - 'a'] == n {\n\
    \                l.push(s.to_string() + c.to_string());\n                counter[c\
    \ - 'a'] += 1;\n            }\n        }\n        else {\n            consonants.remove(c);\
    \ // move the consonant to the end of the vector\n            pos += 1;\n    \
    \        if counter[c - 'a'] == n {\n                l.push(s.to_string() + c.to_string());\n\
    \                counter[c - 'a'] += 1;\n            }\n        }\n    }\n\n \
    \   for c in s.chars() {\n        if !vowels.contains(c) {\n            if counter[c\
    \ - 'a'] == n {\n                l.push(s.to_string() + c.to_string());\n    \
    \            counter[c - 'a'] += 1;\n            }\n        }\n    }\n    return\
    \ l;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy7nhte3p.rs:20:33\n   |\n\
    20 |         if !consonants.contains(c) {\n   |                              \
    \   ^ expected `&isize`, found `char`\n\nerror[E0369]: cannot subtract `char`\
    \ from `char`\n  --> /tmp/tmpy7nhte3p.rs:21:26\n   |\n21 |             if counter[c\
    \ - 'a'] == n {\n   |                        - ^ --- char\n   |              \
    \          |\n   |                        char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpy7nhte3p.rs:22:40\n   |\n22 |                 l.push(s.to_string()\
    \ + c.to_string());\n   |                                        ^^^^^^^^^^^^^\n\
    \   |                                        |\n   |                         \
    \               expected `&str`, found struct `String`\n   |                 \
    \                       help: consider borrowing here: `&c.to_string()`\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmpy7nhte3p.rs:23:27\n   |\n\
    23 |                 counter[c - 'a'] += 1;\n   |                         - ^\
    \ --- char\n   |                         |\n   |                         char\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy7nhte3p.rs:27:31\n   |\n27 |\
    \             consonants.remove(c); // move the consonant to the end of the vector\n\
    \   |                               ^ expected `usize`, found `char`\n\nerror[E0369]:\
    \ cannot subtract `char` from `char`\n  --> /tmp/tmpy7nhte3p.rs:29:26\n   |\n\
    29 |             if counter[c - 'a'] == n {\n   |                        - ^ ---\
    \ char\n   |                        |\n   |                        char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy7nhte3p.rs:30:40\n   |\n30 |              \
    \   l.push(s.to_string() + c.to_string());\n   |                             \
    \           ^^^^^^^^^^^^^\n   |                                        |\n   |\
    \                                        expected `&str`, found struct `String`\n\
    \   |                                        help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpy7nhte3p.rs:31:27\n\
    \   |\n31 |                 counter[c - "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ idx = 0;\n    \n    // The current character in the string is one past the index\
    \ that we \n    // are looking at with the current word we're considering\n  \
    \  let mut curr_idx = s.len() - 1; \n    \n    // If the string s is empty then\
    \ the function should return an empty list.\n    if s.len() == 0 {\n        return\
    \ vec![];\n    }\n    \n    // Go through all the characters in the string and\
    \ add them to a \n    // string if they match the current character in the string\n\
    \    for i in 0..(s.len() - 1) {\n        \n        // If the character at our\
    \ current index is equal to the current\n        // character in the string then\
    \ we are at the end of the string so\n        // continue to the next character\
    \ in the string\n        if s[idx] == s[i] {\n            curr_idx = i + 1;\n\
    \        }\n        \n        // If the character at our current index matches\
    \ the current\n        // character in the string then we are continuing in the\
    \ current word\n        // so add it to the word we're considering.\n        if\
    \ s[idx] == s[i] {\n            words.push(&s[curr_idx - idx..curr_idx - 1]);\n\
    \            curr_idx = i + 1;\n        }\n    }\n    \n    // Go through all\
    \ the words in the vector and if the current word \n    // matches the criteria\
    \ for the last word in the vector then add it to the\n    // vector list\n   \
    \ for w in words {\n        if w == &s[curr_idx - 1..curr_idx - 1] {\n       \
    \     words.push(&s[curr_idx - 1..curr_idx - 1]);\n            break;\n      \
    \  }\n    }\n    \n    // Remove any empty words from the list\n    let mut i\
    \ = 0;\n    for w in words {\n        if w.len() == 0 {\n            words.remove(i);\n\
    \        }\n        else {\n            i += 1;\n        }\n    }\n    \n    //\
    \ If the string s contains no words then return an empty vector\n    if words\
    \ == vec![] {\n        return vec![];\n    }\n    \n    // Otherwise return the\
    \ vector list\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmprxfalarw.rs:32:12\n   |\n32 |         if s[idx] == s[i] {\n   |    \
    \        ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the\
    \ trait `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprxfalarw.rs:32:22\n   |\n32 |         if s[idx] == s[i] {\n   |\
    \                      ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmprxfalarw.rs:39:12\n\
    \   |\n39 |         if s[idx] == s[i] {\n   |            ^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: t"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s == \"\" {\n        return vec![];\n\
    \    }\n    let mut result = vec![];\n    let mut pos = 0;\n    while pos < s.len()\
    \ {\n        let mut current = s.to_string();\n        let mut j = 0;\n      \
    \  while j < current.len() {\n            let mut char = current[j].to_string();\n\
    \            loop {\n                if char == &'a' as char {\n             \
    \       if n == 0 {\n                        return vec![];\n                \
    \    }\n                    j++;\n                    if j == current.len() {\n\
    \                        break;\n                    }\n                    char\
    \ = current[j].to_string();\n                } else {\n                    if\
    \ n == 0 {\n                        break;\n                    }\n          \
    \          j += 1;\n                    if j == current.len() {\n            \
    \            return vec![];\n                    }\n                    char =\
    \ current[j].to_string();\n                }\n            }\n        }\n     \
    \   result.push(current);\n        pos += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp86fuuu_0.rs:28:22\n\
    \   |\n28 |                     j++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n28 |               \
    \      { let tmp = j; j += 1; tmp };\n   |                     +++++++++++  ~~~~~~~~~~~~~~~\n\
    28 -                     j++;\n28 +                     j += 1;\n   | \n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp86fuuu_0.rs:22:28\n\
    \   |\n22 |             let mut char = current[j].to_string();\n   |         \
    \                   ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp86fuuu_0.rs:41:28\n\
    \   |\n41 |                     char = current[j].to_string();\n   |         \
    \                   ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0606]:\
    \ casting `&char` as `char` is invalid\n  --> /tmp/tmp86fuuu_0.rs:24:28\n   |\n\
    24 |                 if char == &'a' as char {\n   |                         \
    \   ^^^^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ det"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfbgft10r.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // TODO: Use a hash map to store all\
    \ words\n    \n    return vec![]\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp20rgnjyr.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj4wpfar5.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n\
    \    let mut index = s.len();\n    while index >= 0 {\n        let word = s.split_at_mut(index).take(n\
    \ as usize).collect::<Vec<_>>();\n        if word.len() == n {\n            words.push(word);\n\
    \        }\n        index -= word.len();\n    }\n    words\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `(&mut str, &mut str)` is not an iterator\n  --> /tmp/tmpp1t5hrr5.rs:16:42\n\
    \   |\n16 |         let word = s.split_at_mut(index).take(n as usize).collect::<Vec<_>>();\n\
    \   |                                          ^^^^ `(&mut str, &mut str)` is\
    \ not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(&mut str, &mut str): Iterator`\n           which is required by\
    \ `&mut (&mut str, &mut str): Iterator`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n    let mut count = 0;\n    let mut words = vec![];\n    let mut i = s.len();\n\
    \    while i >= 0 {\n        if s[i] == ' ' {\n            count += 1;\n     \
    \       if count == n {\n                count -= 1;\n            }\n        }\
    \ else {\n            count = -1;\n        }\n        if count == n {\n      \
    \      words.push_back(s[i - 1..i + 1]);\n        }\n        i -= 1;\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpl_l8v8p7.rs:20:12\n\
    \   |\n20 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmpl_l8v8p7.rs:29:19\n   |\n29 |          \
    \   words.push_back(s[i - 1..i + 1]);\n   |                   ^^^^^^^^^ method\
    \ not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n\n    if s.is_empty()\
    \ {\n        return result;\n    }\n\n    let mut consonants = String::new();\n\
    \    for c in s.chars() {\n        if c.is_ascii_uppercase() {\n            consonants.push_str(c);\n\
    \        } else {\n            if consonants.is_empty() {\n                continue;\n\
    \            }\n            let mut count = 0;\n            let mut index = consonants.len();\n\
    \            while count < n && index > 0 {\n                let c = consonants[..index];\n\
    \                if c.chars().any(|c| !c.is_ascii_uppercase()) {\n           \
    \         count += 1;\n                }\n                index -= 1;\n      \
    \      }\n            if count == n {\n                result.push(consonants.clone());\n\
    \            }\n            consonants.clear();\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf12neljj.rs:22:33\n   |\n\
    22 |             consonants.push_str(c);\n   |                               \
    \  ^ expected `&str`, found `char`\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n  --> /tmp/tmpf12neljj.rs:30:21\n\
    \   |\n30 |                 let c = consonants[..index];\n   |               \
    \      ^ doesn't have a size known at compile-time\n   |\n   = help: the trait\
    \ `Sized` is not implemented for `str`\n   = note: all local variables must have\
    \ a statically known size\n   = help: unsized locals are gated as an unstable\
    \ feature\nhelp: consider borrowing here\n   |\n30 |                 let c = &consonants[..index];\n\
    \   |                         +\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // Your code here\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3orlzuuk.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n    let mut word_list = Vec::new();\n\
    \    \n    for word in s.split_whitespace() {\n        if word.len() == n {\n\
    \            word_list.push(word);\n        }\n    }\n    \n    return word_list;\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplwrwng90.rs:17:26\n   |\n\
    17 |         if word.len() == n {\n   |                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |         if word.len() == n.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplwrwng90.rs:22:12\n   |\n12 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n22 |     return word_list;\n\
    \   |            ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    match s.chars() {\n        s => \n \
    \       let mut v = Vec::new();\n        let mut cnt = 0;\n        for c in s\
    \ {\n            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                cnt+=1;\n            } else if cnt == n {\n                v.push(s);\n\
    \                cnt+=1;\n            }\n        }\n        v\n    }\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `let`\n  --> /tmp/tmpv7wxsk5v.rs:16:9\n\
    \   |\n16 |         let mut cnt = 0;\n   |         ^^^ expected identifier, found\
    \ keyword\n\nerror: expected identifier, found keyword `for`\n  --> /tmp/tmpv7wxsk5v.rs:17:9\n\
    \   |\n17 |         for c in s {\n   |         ^^^ expected identifier, found\
    \ keyword\n\nerror: `match` arm body without braces\n  --> /tmp/tmpv7wxsk5v.rs:15:9\n\
    \   |\n14 |           s => \n   |             -- while parsing the `match` arm\
    \ starting here\n15 | /         let mut v = Vec::new();\n16 | |         let mut\
    \ cnt = 0;\n17 | |         for c in s {\n18 | |             if c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' {\n...  |\n24 | |         }\n25 | |\
    \         v\n   | |_________^ these statements are not surrounded by a body\n\
    \   |\nhelp: surround the statements with a body\n   |\n15 ~         { let mut\
    \ v = Vec::new();\n16 |         let mut cnt = 0;\n17 |         for c in s {\n\
    18 |             if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    19 |                 cnt+=1;\n20 |             } else if cnt == n {\n ...\n\n\
    error[E0658]: `let` expressions in this position are unstable\n  --> /tmp/tmpv7wxsk5v.rs:15:9\n\
    \   |\n15 |         let mut v = Vec::new();\n   |         ^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667>\
    \ for more information\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0658`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n    let mut ans = vec![];\n    let mut cons = String::new();\n    let\
    \ mut nums = String::new();\n    for (i, c) in s.chars().enumerate() {\n     \
    \   if i >= n {\n            break;\n        }\n        cons += c;\n        if\
    \ c.is_vowel() {\n            nums += c;\n        }\n    }\n    if nums.len()\
    \ == 0 {\n        return vec![];\n    }\n    for _ in 0..s.len() {\n        ans.push(cons);\n\
    \        cons.clear();\n    }\n    return ans;\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4jmsu138.rs:20:17\n   |\n\
    20 |         if i >= n {\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |         if i >= n.try_into().unwrap() {\n   |\
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4jmsu138.rs:23:17\n   |\n23 |         cons += c;\n   |             \
    \    ^ expected `&str`, found `char`\n\nerror[E0599]: no method named `is_vowel`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp4jmsu138.rs:24:14\n\
    \   |\n24 |         if c.is_vowel() {\n   |              ^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4jmsu138.rs:25:21\n\
    \   |\n25 |             nums += c;\n   |                     ^ expected `&str`,\
    \ found `char`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ consonants = String::new();\n    let mut vowels = String::new();\n    let mut\
    \ vowel_index = String::new();\n\n    if s.is_empty() {\n        return words;\n\
    \    }\n\n    words.clear();\n    consonants.clear();\n    vowels.clear();\n \
    \   vowel_index.clear();\n\n    for i in s.chars().enumerate() {\n        match\
    \ i {\n            (i, c) if c.is_uppercase() => consonants += *c,\n         \
    \   (i, c) if c.is_lowercase() => vowels += *c,\n            (i, c) => vowel_index\
    \ += *c,\n            _ => (),\n        }\n    }\n\n    let mut vowel_count =\
    \ vowels.chars().count();\n    words.clear();\n    for i in s.chars().enumerate()\
    \ {\n        match i {\n            (i, c) if vowel_count == n => words.push(&s[i..]),\n\
    \            _ => (),\n        }\n    }\n\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpuil4opnt.rs:29:57\n\
    \   |\n29 |             (i, c) if c.is_uppercase() => consonants += *c,\n   |\
    \                                                         ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpuil4opnt.rs:30:53\n   |\n\
    30 |             (i, c) if c.is_lowercase() => vowels += *c,\n   |           \
    \                                          ^^\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmpuil4opnt.rs:31:38\n   |\n31 |             (i,\
    \ c) => vowel_index += *c,\n   |                                      ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuil4opnt.rs:40:38\n   |\n40 |             (i,\
    \ c) if vowel_count == n => words.push(&s[i..]),\n   |                       \
    \               ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    40 |             (i, c) if vowel_count == n.try_into().unwrap() => words.push(&s[i..]),\n\
    \   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuil4opnt.rs:40:54\n   |\n40 |             (i,\
    \ c) if vowel_count == n => words.push(&s[i..]),\n   |                       \
    \                               ^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n40 |             (i, c) if vowel_count\
    \ == n => words.push((&s[i..]).to_string()),\n   |                           \
    \                           +       +++++++++++++\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = vec![];\n    let mut\
    \ n = n;\n    let mut cur_word = String::new();\n\n    for c in s.chars() {\n\
    \        if c.is_consonant() {\n            if n == 0 || (n == 1 && c.is_vowel())\
    \ {\n                list.push(cur_word);\n                cur_word = String::new();\n\
    \            }\n        }\n        else {\n            cur_word.push(c);\n   \
    \         n -= 1;\n        }\n    }\n\n    if cur_word.len() != 0 {\n        list.push(cur_word);\n\
    \    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpxz3834x8.rs:18:14\n   |\n18 |         if c.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `is_vowel` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpxz3834x8.rs:19:39\n   |\n19 |             if n == 0 || (n == 1 && c.is_vowel())\
    \ {\n   |                                       ^^^^^^^^ method not found in `char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut v = Vec::new();\n    for i in\
    \ s.chars() {\n        if i.is_vowel() {\n            continue;\n        }\n \
    \       if n == 0 || i.is_consonant() {\n            v.push(i.to_string());\n\
    \        }\n    }\n    v\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpr4xse7wo.rs:15:14\n   |\n15 |         if i.is_vowel() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `is_consonant` found for type `char` in the current scope\n  --> /tmp/tmpr4xse7wo.rs:18:24\n\
    \   |\n18 |         if n == 0 || i.is_consonant() {\n   |                    \
    \    ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    if s.len()\
    \ == 0 {\n        return res;\n    }\n\n    for c in s.chars() {\n        if c.is_consonant()\
    \ && c != ' ' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c\
    \ != 'y' && c != '\xE1' && c != '\xE9' && c != '\xED' && c != '\xF3' && c != '\xFA\
    ' && c != '\xF1' && c != '\xD1' {\n            res.push(c.to_ascii_lowercase());\n\
    \        }\n        if res.len() >= n {\n            break;\n        }\n    }\n\
    \n    return res\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpvmz8fv8b.rs:19:14\n   |\n19 | ...   if c.is_consonant()\
    \ && c != ' ' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c\
    \ != 'y' && c != '\xE1' && c != '\xE9' && ...\n   |            ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvmz8fv8b.rs:20:22\n\
    \   |\n20 |             res.push(c.to_ascii_lowercase());\n   |              \
    \        ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                      |\n   |                      expected struct `String`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvmz8fv8b.rs:22:25\n\
    \   |\n22 |         if res.len() >= n {\n   |                         ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n22 |         if res.len()\
    \ >= n.try_into().unwrap() {\n   |                          ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n\
    \    let mut str: String = s;\n\n    loop {\n        str = str.chars().filter(|&x|\
    \ x != ' ').collect();\n        if str.len() <= n {\n            words.push(str);\n\
    \        }\n\n        if str.len() == 0 {\n            break;\n        }\n\n \
    \       str = str.chars().filter(|&x| x == ' ').collect();\n    }\n\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf6ozaox0.rs:18:25\n   |\n\
    18 |         if str.len() <= n {\n   |                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |         if str.len() <= n.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    for\
    \ (i, w) in s.split_whitespace().enumerate() {\n        if w.len() == n {\n  \
    \          list.push(w)\n        }\n    }\n    list\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ktcr7q2.rs:15:23\n   |\n\
    15 |         if w.len() == n {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n15 |         if w.len() == n.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4ktcr7q2.rs:19:5\n   |\n12 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n19 |     list\n   |    \
    \ ^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<&str>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut letters = vec![];\n    let mut\
    \ word_count = 0;\n    for i in s.chars() {\n        if i.is_vowel() {\n     \
    \       continue;\n        }\n        for j in i.chars() {\n            if j.is_consonant()\
    \ {\n                break;\n            }\n            word_count += 1;\n   \
    \     }\n        if word_count == n {\n            letters.push(s);\n        \
    \    word_count = 0;\n        }\n    }\n    letters\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp73ng0iqj.rs:16:14\n   |\n16 |         if i.is_vowel() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmp73ng0iqj.rs:19:20\n\
    \   |\n19 |         for j in i.chars() {\n   |                    ^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ counter = 0;\n    for i in s.chars() {\n        if i.is_whitespace() {\n   \
    \         counter = 0;\n        } else {\n            counter += 1;\n        }\n\
    \        if counter == n {\n            words.push(String::from(i));\n       \
    \     counter = 0;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"y\", \"t\", \"b\"]`,\n right: `[\"little\"]`', /tmp/tmpeow0g84p.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut consonants = String::new();\n\n    // Iterate over each letter of the string\n\
    \    for char in s.chars() {\n        // If current letter is a letter and is\
    \ not the first letter\n        if char >= 'a' && char <= 'z' && !char.starts_with('_')\
    \ {\n            // Update consonants string\n            consonants += char;\n\
    \        }\n\n        // If the consonants string is equal to the number of consonants\n\
    \        // that we are looking for\n        if consonants.chars().count() ==\
    \ n {\n            // Add this word to the list\n            list.push(s);\n \
    \       }\n\n        // Reset consonants string\n        consonants.clear();\n\
    \    }\n\n    return list;\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `starts_with` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp6ac4g_it.rs:19:48\n   |\n19 |         if char >=\
    \ 'a' && char <= 'z' && !char.starts_with('_') {\n   |                       \
    \                         ^^^^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6ac4g_it.rs:21:27\n   |\n21 |             consonants\
    \ += char;\n   |                           ^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6ac4g_it.rs:26:42\n   |\n26 |\
    \         if consonants.chars().count() == n {\n   |                         \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    26 |         if consonants.chars().count() == n.try_into().unwrap() {\n   |  \
    \                                         ++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut s = s;\n    let mut list = Vec::new();\n\
    \    while !s.is_empty() {\n        let mut pos = 0;\n        while pos < s.len()\
    \ {\n            if s[pos] == 'a' {\n                pos = s.find('a', pos + 1);\n\
    \            } else if s[pos] == 'e' {\n                pos = s.find('e', pos\
    \ + 1);\n            } else if s[pos] == 'i' {\n                pos = s.find('i',\
    \ pos + 1);\n            } else if s[pos] == 'o' {\n                pos = s.find('o',\
    \ pos + 1);\n            } else if s[pos] == 'u' {\n                pos = s.find('u',\
    \ pos + 1);\n            } else if s[pos] == 'y' {\n                pos = s.find('y',\
    \ pos + 1);\n            }\n        }\n        if pos == s.len() {\n         \
    \   list.push(s);\n        } else {\n            list.push(\"*\");\n        }\n\
    \        s = &s[pos..];\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpba90652o.rs:18:16\n\
    \   |\n18 |             if s[pos] == 'a' {\n   |                ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0061]: this function takes 1 argument but 2 arguments were\
    \ supplied\n    --> /tmp/tmpba90652o.rs:19:25\n     |\n19   |                \
    \ pos = s.find('a', pos + 1);\n     |                         ^^^^ ---  -------\
    \ supplied 2 arguments\n     |                         |\n     |             \
    \            expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpba90652o.rs:19:23\n   |\n16 |\
    \         let mut pos = 0;\n   |                       - expected due to this\
    \ value\n...\n19 |                 pos = s.find('a', pos + 1);\n   |         \
    \              ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found enum `Option`\n  \
    \ |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpba90652o.rs:20:23\n\
    \   |\n20 |             } else if s[pos] == 'e' {\n   |                      \
    \ ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<st"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut count = 0;\n    let mut words\
    \ = Vec::new();\n    \n    for (i, c) in s.chars().enumerate() {\n        if c.is_ascii()\
    \ {\n            if count == n {\n                words.push(s.to_string().chars().filter(|c|\
    \ !c.is_ascii()).collect::<Vec<String>>());\n                count = 0;\n    \
    \        }\n            count = count + 1;\n        } else {\n            if count\
    \ == n {\n                break;\n            }\n            count = 0;\n    \
    \    }\n    }\n    \n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp4scmoomh.rs:19:76\n     |\n19\
    \   |                 words.push(s.to_string().chars().filter(|c| !c.is_ascii()).collect::<Vec<String>>());\n\
    \     |                                                                      \
    \      ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4scmoomh.rs:31:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n31 |     words\n   |     ^^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<String>`\n       \
    \       found struct `Vec<Vec<String>>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    \n \
    \   let mut s_iter = s.chars().enumerate();\n    \n    let mut current_word =\
    \ String::new();\n    \n    for index in s_iter {\n        \n        if index\
    \ != s_iter.next() {\n            current_word.push_str(&s[index.0].to_string());\n\
    \            list.push(current_word);\n            current_word = String::new();\n\
    \        }\n        \n        if index.0 == n {\n            list.push(current_word);\n\
    \            current_word = String::new();\n        }\n        \n        if index.0\
    \ == n - 1 {\n            list.push(current_word);\n        }\n        \n    }\n\
    \    \n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt_yq_b3z.rs:21:21\n   |\n\
    21 |         if index != s_iter.next() {\n   |                     ^^^^^^^^^^^^^\
    \ expected tuple, found enum `Option`\n   |\n   = note: expected tuple `(usize,\
    \ char)`\n               found enum `Option<(usize, char)>`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpt_yq_b3z.rs:22:36\n\
    \   |\n22 |             current_word.push_str(&s[index.0].to_string());\n   |\
    \                                    ^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_yq_b3z.rs:27:23\n\
    \   |\n27 |         if index.0 == n {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n27 |         if index.0 == n.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt_yq_b3z.rs:32:23\n   |\n32 |         if index.0 == n -\
    \ 1 {\n   |                       ^^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n32 |         if index.0 == (n - 1).try_into().unwrap() {\n\
    \   |                       +     +++++++++++++++++++++\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut vec = Vec::new();\n\n    let\
    \ mut index = 0;\n    while index < s.len() {\n        let letter = &s[index];\n\
    \n        if letter.is_ascii_letter() && \n            (index - 1) < s.len() &&\
    \ \n            s[index - 1].is_ascii_letter() && \n            s[index - 2].is_ascii_letter()\
    \ && \n            s[index - 3].is_ascii_letter() {\n\n            let mut count\
    \ = 0;\n            match letter {\n                'a' => { count = n; },\n \
    \               'b' => { count = n; },\n                'c' => { count = n; },\n\
    \                'd' => { count = n; },\n                'e' => { count = n; },\n\
    \                'f' => { count = n; },\n                'g' => { count = n; },\n\
    \                'h' => { count = n; },\n                'i' => { count = n; },\n\
    \                'j' => { count = n; },\n                'k' => { count = n; },\n\
    \                'l' => { count = n; },\n                'm' => { count = n; },\n\
    \                'n' => { count = n; },\n                'o' => { count = n; },\n\
    \                'p' => { count = n; },\n                'q' => { count = n; },\n\
    \                'r' => { count = n; },\n                's' => { count = n; },\n\
    \                't' => { count = n; },\n                'u' => { count = n; },\n\
    \                'v' => { count = n; },\n                'w' => { count = n; },\n\
    \                'x' => { count = n; },\n                'y' => { count = n; },\n\
    \                'z' => { count = n; },\n                _ => {}\n           \
    \ }\n\n            while count > 0 && index > 0 && s[index - count as usize] ==\
    \ 'a' {\n                count -= 1;\n                index -= count as usize;\n\
    \            }\n\n            if index == 0 || index == s.len() - 1 {\n      \
    \          vec.push(&s[index..]);\n            } else {\n                vec.push(&s[index..index]);\n\
    \            }\n        } else {\n            vec.push(&s[index..]);\n       \
    \ }\n        \n        index += 1;\n    }\n    \n    vec\n}\n\nfn main() {\n \
    \   let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzcj9eent.rs:17:23\n\
    \   |\n17 |         let letter = &s[index];\n   |                       ^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzcj9eent.rs:21:13\n   |\n21 |             s[index - 1].is_ascii_letter()\
    \ && \n   |             ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzcj9eent.rs:22:13\n   |\n22 |             s[index - 2].is_ascii_letter()\
    \ && \n   |             ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n          "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    for i\
    \ in 0..s.len() {\n        let mut count = 0;\n        let mut start = 0;\n  \
    \      while count != n {\n            if s[i + start] == 'a' || s[i + start]\
    \ == 'e' || s[i + start] == 'i' ||\n                s[i + start] == 'o' || s[i\
    \ + start] == 'u' {\n                count += 1\n            }\n            else\
    \ {\n                start = start + 1;\n                count = 0;\n        \
    \    }\n        }\n        result.push(s.slice(i, i + start));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphs45nhz4.rs:18:16\n\
    \   |\n18 |             if s[i + start] == 'a' || s[i + start] == 'e' || s[i +\
    \ start] == 'i' ||\n   |                ^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphs45nhz4.rs:18:39\n   |\n18 |             if s[i + start] == 'a'\
    \ || s[i + start] == 'e' || s[i + start] == 'i' ||\n   |                     \
    \                  ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphs45nhz4.rs:18:62\n\
    \   |\n18 |             if s[i + start] == 'a' || s[i + start] == 'e' || s[i +\
    \ start] == 'i' ||\n   |                                                     \
    \         ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut s = String::from(s);\n    let mut n = n as isize;\n    let mut c = 0;\n\
    \    let mut cur = 0;\n\n    while n > 0 {\n        if s.is_empty() {\n      \
    \      list = Vec::new();\n            break;\n        }\n\n        list.push(s.split_whitespace()[cur].to_string());\n\
    \n        if n == 1 {\n            list.push(s.split_whitespace()[cur].to_string());\n\
    \            break;\n        }\n\n        n -= 1;\n        c += 1;\n\n       \
    \ if c.trunc_quot() > 1 {\n            if n >= 2 {\n                cur += 1;\n\
    \                n -= 1;\n            }\n        }\n    }\n    return list\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpp689jdr7.rs:25:19\n   |\n25 |         list.push(s.split_whitespace()[cur].to_string());\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpp689jdr7.rs:28:23\n\
    \   |\n28 |             list.push(s.split_whitespace()[cur].to_string());\n  \
    \ |                       ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method\
    \ named `trunc_quot` found for type `{integer}` in the current scope\n  --> /tmp/tmpp689jdr7.rs:35:14\n\
    \   |\n35 |         if c.trunc_quot() > 1 {\n   |              ^^^^^^^^^^ method\
    \ not found in `{integer}`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n\n    if\
    \ s.is_empty() {\n        return list;\n    }\n\n    list = s.chars().map(|c|\
    \ char(c)).collect();\n\n    let mut vowels: Vec<String> = vec![\"a\", \"e\",\
    \ \"i\", \"o\", \"u\", \"y\"];\n\n    for i in 0..n-1 {\n        for j in i+1..n-1\
    \ {\n            if vowels.contains(&list[j]) {\n                list.swap(i,\
    \ j);\n            }\n        }\n    }\n\n    let mut consonants: Vec<String>\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n\n    for j in 0i..n-1 {\n        if consonants.contains(&list[j]) {\n   \
    \         list.swap(i, j);\n        }\n    }\n\n    list\n}\n\nfn main() {\n \
    \   let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: invalid suffix `i` for number literal\n  --> /tmp/tmpwzno5bke.rs:33:14\n\
    \   |\n33 |     for j in 0i..n-1 {\n   |              ^^ invalid suffix `i`\n\
    \   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`,\
    \ `f32`, etc.)\n\nerror[E0423]: expected function, found builtin type `char`\n\
    \  --> /tmp/tmpwzno5bke.rs:19:30\n   |\n19 |     list = s.chars().map(|c| char(c)).collect();\n\
    \   |                              ^^^^ not a function\n\nerror[E0425]: cannot\
    \ find value `i` in this scope\n  --> /tmp/tmpwzno5bke.rs:35:23\n   |\n35 |  \
    \           list.swap(i, j);\n   |                       ^ help: a local variable\
    \ with a similar name exists: `j`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwzno5bke.rs:21:40\n\
    \   |\n21 |     let mut vowels: Vec<String> = vec![\"a\", \"e\", \"i\", \"o\"\
    , \"u\", \"y\"];\n   |                                        ^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  \
    \      |\n   |                                        expected struct `String`,\
    \ found `&str`\n\nerror[E0277]: the type `[String]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpwzno5bke.rs:25:33\n   |\n25 |             if vowels.contains(&list[j])\
    \ {\n   |                                 ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwzno5bke.rs:26:27\n\
    \   |\n26 |                 list.swap(i, j);\n   |                           ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n26 |           \
    \      list.swap(i.try_into().unwrap(), j);\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwzno5bke.rs:26:30\n   |\n26 |\
    \                 list.swap(i, j);\n   |                              ^ expec"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut counts = HashMap::new();\n\n\
    \    s.chars().for_each(|c|{\n        counts.entry(c).or_insert(0) += 1;\n   \
    \ });\n\n    \n    let mut res = Vec::new();\n    for c in s.chars() {\n     \
    \   if counts.entry(c).unwrap().clone() == n {\n            res.push(c); \n  \
    \      }\n    }\n    \n    if res.is_empty() {\n        return Vec::new();\n \
    \   }\n    \n    res\n}\n\nfn main() {\n    let candidate = select_words;\n  \
    \  assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp51u53tg0.rs:13:22\n   |\n13 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp51u53tg0.rs:16:38\n   |\n\
    16 |         counts.entry(c).or_insert(0) += 1;\n   |         ----------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp51u53tg0.rs:31:5\n   |\n12 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \      ----------- expected `Vec<String>` because of return type\n...\n31 |  \
    \   res\n   |     ^^^ expected struct `String`, found `char`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<char>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut vowels: Vec<&str> = vec![];\n    for i in 0..s.len() {\n\
    \        if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] ==\
    \ 'u'\n            || s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O'\
    \ || s[i] == 'U' {\n            vowels.push(&s[i]);\n        }\n    }\n\n    let\
    \ mut result: Vec<String> = vec![];\n    for i in vowels.iter().rev() {\n    \
    \    let mut current_word: Vec<String> = vec![];\n        let mut counter = 0;\n\
    \        for j in 0..s.len() {\n            if s[i] == j {\n                current_word.push(&s[j]);\n\
    \                counter += 1;\n                if counter == n {\n          \
    \          break;\n                }\n            }\n        }\n        result.push(current_word.join(''));\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n  \
    \  assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpowgx2cyn.rs:38:40\n   |\n\
    38 |         result.push(current_word.join(''));\n   |                       \
    \                 ^ empty character literal\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpowgx2cyn.rs:19:12\n   |\n19 |  \
    \       if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] ==\
    \ 'u'\n   |            ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpowgx2cyn.rs:19:27\n\
    \   |\n19 |         if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o'\
    \ || s[i] == 'u'\n   |                           ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpowgx2cyn.rs:19:42\n   |\n19 |         if s[i] == 'a' || s[i] ==\
    \ 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n   |                     \
    \                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Ind"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    match n {\n        0 => Vec::new(),\n\
    \        1 => s.split(' ').collect(),\n        _ => s.split(' ').iter().filter(|w|\
    \ {\n            w.chars().count(|c| c.is_uppercase() || c.is_lowercase()) ==\
    \ n\n        }).collect()\n    }\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpza82i15c.rs:15:27\n     |\n15\
    \   |         1 => s.split(' ').collect(),\n     |                           ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `iter` found for struct\
    \ `std::str::Split` in the current scope\n  --> /tmp/tmpza82i15c.rs:16:27\n  \
    \ |\n16 |         _ => s.split(' ').iter().filter(|w| {\n   |                \
    \           ^^^^ method not found in `std::str::Split<'_, char>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut counter = 0;\n    let mut words\
    \ = Vec::new();\n\n    if n == 0 {\n        return Vec::new();\n    }\n\n    for\
    \ letter in s.chars().filter(|&x| {\n        x == ' ' || x == '.' || x == '?'\
    \ || x == '!' || x == '-'\n    }) {\n        if counter == n {\n            words.push(s.split_whitespace().first());\n\
    \        }\n\n        if letter != ' ' {\n            counter += 1;\n        }\n\
    \    }\n\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `first` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmphjoiqet_.rs:24:45\n   |\n24 |          \
    \   words.push(s.split_whitespace().first());\n   |                          \
    \                   ^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return Vec::new();\n\
    \    }\n    // use std::collections::HashMap::new;\n    let mut map = HashMap::new();\n\
    \    let mut res = Vec::new();\n    let mut str = String::from(\"Mary had a little\
    \ lamb\");\n    for ch in str {\n        if map.contains_key(&ch) {\n        \
    \    if let Some(item) = map.get(&ch) {\n                if item.to_string().contains(&\"\
    n\") {\n                    continue;\n                }\n                res.push(item.to_string());\n\
    \                map.remove(&ch);\n            } else {\n                let item\
    \ = String::from(\"n\" + ch);\n                res.push(item);\n             \
    \   map.insert(ch, item);\n            }\n        } else {\n            let item\
    \ = String::from(ch + \"n\");\n            res.push(item);\n            map.insert(ch,\
    \ item);\n        }\n    }\n    return res.into_iter().filter(|x| x.contains(&n)).collect();\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpoco8f0zk.rs:17:19\n   |\n17 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmpoco8f0zk.rs:20:15\n   |\n20 |   \
    \  for ch in str {\n   |               ^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `String`\n\nerror[E0369]: cannot add `_` to `&str`\n  -->\
    \ /tmp/tmpoco8f0zk.rs:29:45\n   |\n29 |                 let item = String::from(\"\
    n\" + ch);\n   |                                         --- ^ -- _\n   |    \
    \                                     |\n   |                                \
    \         &str\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `isize`\n\
    \    --> /tmp/tmpoco8f0zk.rs:39:50\n     |\n39   |     return res.into_iter().filter(|x|\
    \ x.contains(&n)).collect();\n     |                                         --------\
    \ ^^ expected an `Fn<(char,)>` closure, found `isize`\n     |                \
    \                         |\n     |                                         required\
    \ by a bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `isize`\n     = help: the following other types implement\
    \ trait `Pattern<'a>`:\n               &'b String\n               &'b [char; N]\n\
    \               &'b [char]\n               &'b str\n               &'c &'b str\n\
    \               [char; N]\n               char\n               pattern::MultiCharEqPattern<C>\n\
    \     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&isize`\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `&isize`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    let mut\
    \ buffer = vec![String::new(); s.len()];\n    let mut i = 0;\n    let mut j =\
    \ 0;\n    while i < s.len() {\n        buffer[i] = &s[i..];\n        while j +\
    \ n <= s.len() {\n            if let Some(key) = buffer[j..j + n].iter().filter(|&x|\
    \ x != 'i' && x != 'e' && x != 'a' && x != 'o' && x != 'u') {\n              \
    \  result.append(&key);\n            }\n            j += n;\n        }\n     \
    \   i += n;\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvplansta.rs:18:21\n   |\n\
    18 |         buffer[i] = &s[i..];\n   |         ---------   ^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |         |\n   |         expected due to the type\
    \ of this binding\n   |\nhelp: try using a conversion method\n   |\n18 |     \
    \    buffer[i] = (&s[i..]).to_string();\n   |                     +       +++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvplansta.rs:19:24\n   |\n19 |\
    \         while j + n <= s.len() {\n   |                        ^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |         while j + n\
    \ <= s.len().try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0277]: the type `[String]` cannot be indexed by `std::ops::Range<isize>`\n\
    \  --> /tmp/tmpvplansta.rs:20:32\n   |\n20 |             if let Some(key) = buffer[j..j\
    \ + n].iter().filter(|&x| x != 'i' && x != 'e' && x != 'a' && x != 'o' && x !=\
    \ 'u') {\n   |                                ^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `std::ops::Range<isize>`\n   = help: the following other\
    \ types implement trait `SliceIndex<T>`:\n             <std::ops::Range<usize>\
    \ as SliceIndex<[T]>>\n             <std::ops::Range<usize> as SliceIndex<str>>\n\
    \   = note: required because of the requirements on the impl of `Index<std::ops::Range<isize>>`\
    \ for `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvplansta.rs:21:31\n\
    \   |\n21 |                 result.append(&key);\n   |                       \
    \        ^^^^ types differ in mutability\n   |\n   = note: expected mutable reference\
    \ `&mut Vec<_>`\n                      found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvplansta.rs:25:14\n   |\n25 |         i += n;\n   |   \
    \           ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmpvplansta.rs:25:11\n   |\n25 |         "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    if\
    \ s.is_empty() {\n        return result;\n    }\n    let mut current_word = String::new();\n\
    \    let mut current_word_len = 1;\n    for char in &s[..] {\n        current_word\
    \ = current_word.to_string() + char;\n        current_word_len += 1;\n       \
    \ if current_word_len == n {\n            result.push(current_word);\n       \
    \     current_word_len = 1;\n            current_word = String::new();\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&str` is not an iterator\n  --> /tmp/tmpuzwf31rk.rs:19:17\n\
    \   |\n19 |     for char in &s[..] {\n   |                 ^^^^^^ `&str` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&str`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `&str`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    Vec::new()\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmp9cv105p2.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut s = s;\n\n    // Iterate over\
    \ the string until it becomes empty\n    while !s.is_empty() {\n        // Start\
    \ a new list and add all the words that contain `n` consonants\n        let mut\
    \ l: Vec<String> = vec![];\n\n        // Iterate over the string and add words\
    \ that match the condition into the list\n        for ch in s.chars() {\n    \
    \        // Check if the current character is in the string\n            if ch\
    \ >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' {\n                if ch >= 'a'\
    \ && ch <= 'z' || ch >= 'A' && ch <= 'Z' {\n                    l.push((&s[..ch\
    \ - 'a']).to_string());\n                } else {\n                    l.push((&s[ch\
    \ - 'A']).to_string());\n                }\n            } else {\n           \
    \     // This is not one of the accepted characters, ignore it.\n            }\n\
    \        }\n\n        // If there are `n` consonants in the string then return\
    \ them\n        if l.len() == n {\n            return l;\n        }\n\n      \
    \  // If the current string does not contain `n` consonants then add the string\
    \ to the list\n        s = &s[s.len() - 1];\n    }\n\n    // If the string has\
    \ been empty then return an empty list\n    vec![]\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpz4dxzy8f.rs:25:37\n\
    \   |\n25 |                     l.push((&s[..ch - 'a']).to_string());\n   |  \
    \                                -- ^ --- char\n   |                         \
    \         |\n   |                                  char\n\nerror[E0369]: cannot\
    \ subtract `char` from `char`\n  --> /tmp/tmpz4dxzy8f.rs:27:35\n   |\n27 |   \
    \                  l.push((&s[ch - 'A']).to_string());\n   |                 \
    \               -- ^ --- char\n   |                                |\n   |   \
    \                             char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz4dxzy8f.rs:35:23\n\
    \   |\n35 |         if l.len() == n {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n35 |         if l.len() == n.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpz4dxzy8f.rs:40:14\n   |\n\
    40 |         s = &s[s.len() - 1];\n   |              ^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz4dxzy8f.rs:40:13\n\
    \   |\n13 |     let mut s = s;\n   |                 - expected due to this value\n\
    ...\n40 |         s = &s[s.len() - 1];\n   |             ^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found reference\n   |\n   = note: expected struct `String`\n\
    \           found reference `&_`\nhelp: consider removing the borrow\n   |\n40\
    \ -         s = &s[s.len() - 1];\n40 +         s = s[s.len() - 1];\n   | \n\n\
    erro"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s == \"\" {\n        return vec![];\n\
    \    }\n\n    let mut list = vec![];\n\n    let mut index = n - 1;\n\n    while\
    \ index >= 0 {\n        if s[index].is_uppercase() {\n            list.push(&s[index..(index\
    \ + n)]);\n            index -= 1;\n        }\n\n        index -= 1;\n    }\n\n\
    \    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `isize`\n  --> /tmp/tmp86uzh3b8.rs:22:12\n\
    \   |\n22 |         if s[index].is_uppercase() {\n   |            ^^^^^^^^ `String`\
    \ cannot be indexed by `isize`\n   |\n   = help: the trait `Index<isize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `std::ops::Range<isize>`\n\
    \  --> /tmp/tmp86uzh3b8.rs:23:24\n   |\n23 |             list.push(&s[index..(index\
    \ + n)]);\n   |                        ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `std::ops::Range<isize>`\n   |\n   = help: the trait `Index<std::ops::Range<isize>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp86uzh3b8.rs:30:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n30 |     list\n   |     ^^^^ expected struct `String`,\
    \ found reference\n   |\n   = note: expected struct `Vec<String>`\n          \
    \    found struct `Vec<&_>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    while i < s.size() {\n\
    \        j = s.len() - i;\n        if j == n {\n            list.push(s.subslice(i,\
    \ j + i + 1));\n            i += 1;\n            k += 1;\n        }\n        if\
    \ j > n {\n            j = 0;\n            i += 1;\n        }\n    }\n    list\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp45pd461c.rs:17:17\n   |\n17 |     while i < s.size() {\n\
    \   |                 ^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp45pd461c.rs:19:17\n   |\n19 |         if j == n {\n   |\
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if j == n.try_into().unwrap() {\n   |                  ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `subslice` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp45pd461c.rs:20:25\n   |\n20 |             list.push(s.subslice(i,\
    \ j + i + 1));\n   |                         ^^^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp45pd461c.rs:24:16\n   |\n24 |\
    \         if j > n {\n   |                ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n24 |         if j > n.try_into().unwrap() {\n   | \
    \                ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    \n   \
    \ for i in 0..length(s) {\n        // If the string contains 'i' consonants and\
    \ the index 'i' is less than n, \n        // then append the string to the result.\n\
    \        if s.chars().any(|&x| x.to_ascii_lowercase() != 'i' && x != s[i]) {\n\
    \            result.push(&s[i]);\n        }\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `length` in this scope\n  --> /tmp/tmppj36zhy7.rs:15:17\n\
    \   |\n15 |     for i in 0..length(s) {\n   |                 ^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppj36zhy7.rs:18:27\n\
    \   |\n18 |         if s.chars().any(|&x| x.to_ascii_lowercase() != 'i' && x !=\
    \ s[i]) {\n   |                           ^--\n   |                          \
    \ ||\n   |                           |expected due to this\n   |             \
    \              expected `char`, found reference\n   |                        \
    \   help: did you mean `x`: `&char`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmppj36zhy7.rs:18:69\n   |\n18 |        \
    \ if s.chars().any(|&x| x.to_ascii_lowercase() != 'i' && x != s[i]) {\n   |  \
    \                                                                   ^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmppj36zhy7.rs:19:26\n   |\n19 |             result.push(&s[i]);\n\
    \   |                          ^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \       "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return Vec::new();\n\
    \    }\n\n    let mut s = String::from(\"A\");\n    s.push('A');\n\n    let mut\
    \ letters = Vec::new();\n    \n    for c in s.chars() {\n        if c == ' ' {\n\
    \            s.push('A');\n        } else {\n            let mut found = false;\n\
    \            letters.iter().for_each(|&mut c|{\n                if c == c {\n\
    \                    found = true;\n                }\n            });\n     \
    \       if found {\n                continue;\n            } else {\n        \
    \        s.push(c);\n                letters.push(c.to_string());\n          \
    \  }\n        }\n        if letters.len() == n {\n            return letters;\n\
    \        }\n    }\n\n    letters.len()\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpld1qd5nf.rs:27:38\n   |\n\
    27 |             letters.iter().for_each(|&mut c|{\n   |                     \
    \                 ^^^^^--\n   |                                      |    |\n\
    \   |                                      |    expected due to this\n   |   \
    \                                   types differ in mutability\n   |         \
    \                             help: did you mean `c`: `&&_`\n   |\n   = note:\
    \      expected reference `&_`\n           found mutable reference `&mut _`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpld1qd5nf.rs:39:29\n   |\n39 |  \
    \       if letters.len() == n {\n   |                             ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n39 |         if letters.len() == n.try_into().unwrap()\
    \ {\n   |                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpld1qd5nf.rs:44:5\n   |\n12 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n44 |     letters.len()\n\
    \   |     ^^^^^^^^^^^^^ expected struct `Vec`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n                found type `usize`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n}\n\n/// Given a string, s you have been\
    \ tasked to return a count of how many \n/// characters are contained in s including\
    \ duplicates. \n/// If the string s is empty then the function should return 0.\n\
    /// Note: you may assume the input string contains only letters.\n/// Examples:\n\
    /// count_letters(\"Mary had a little lamb\") ==> 5\n/// count_letters(\"simple\
    \ white space\") ==> 3\nfn count_letters(s: String) -> isize {\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp60jp_ks9.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp60jp_ks9.rs:22:32\n   |\n22 |\
    \ fn count_letters(s: String) -> isize {\n   |    -------------              \
    \ ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    select_words_impl(s, n)\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `select_words_impl` in this scope\n\
    \  --> /tmp/tmpxgx_eroq.rs:13:5\n   |\n13 |     select_words_impl(s, n)\n   |\
    \     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n    let mut list: Vec<String> = Vec::new();\n\
    \    \n    \n    if s == \"\" {\n        return list;\n    }\n    \n    \n   \
    \ \n    for c in s.chars() {\n        \n        if c != \"a\" && c != \"e\" &&\
    \ c != \"i\" && c != \"o\" && c != \"u\" && c != \"y\" && c != \"a\" && c != \"\
    e\" && c != \"i\" && c != \"o\" && c != \"u\" && c != \"y\" {\n            list.push(c)\n\
    \        }\n    }\n    \n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphtfa_zgq.rs:25:17\n   |\n\
    25 | ...   if c != \"a\" && c != \"e\" && c != \"i\" && c != \"o\" && c != \"\
    u\" && c != \"y\" && c != \"a\" && c != \"e\" && c != \"i\" && c != \"o\" && c\
    \ != \"u\"...\n   |               ^^^ expected `char`, found `&str`\n   |\nhelp:\
    \ if you meant to write a `char` literal, use single quotes\n   |\n25 |      \
    \   if c != 'a' && c != \"e\" && c != \"i\" && c != \"o\" && c != \"u\" && c !=\
    \ \"y\" && c != \"a\" && c != \"e\" && c != \"i\" && c != \"o\" && c != \"u\"\
    \ && c != \"y\" {\n   |                 ~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphtfa_zgq.rs:25:29\n   |\n25 | ...   if c != \"a\" && c != \"e\"\
    \ && c != \"i\" && c != \"o\" && c != \"u\" && c != \"y\" && c != \"a\" && c !=\
    \ \"e\" && c != \"i\" && c != \"o\" && c != \"u\"...\n   |                   \
    \        ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write\
    \ a `char` literal, use single quotes\n   |\n25 |         if c != \"a\" && c !=\
    \ 'e' && c != \"i\" && c != \"o\" && c != \"u\" && c != \"y\" && c != \"a\" &&\
    \ c != \"e\" && c != \"i\" && c != \"o\" && c != \"u\" && c != \"y\" {\n   | \
    \                            ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphtfa_zgq.rs:25:41\n\
    \   |\n25 | ...   if c != \"a\" && c != \"e\" && c != \"i\" && c != \"o\" && c\
    \ != \"u\" && c != \"y\" && c != \"a\" && c != \"e\" && c != \"i\" && c != \"\
    o\" && c != \"u\"...\n   |                                       ^^^ expected\
    \ `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal, use\
    \ single quotes\n   |\n25 |         if c != \"a\" && c != \"e\" && c != 'i' &&\
    \ c != \"o\" && c != \"u\" && c != \"y\" && c != \"a\" && c != \"e\" && c != \"\
    i\" && c != \"o\" && c != \"u\" && c != \"y\" {\n   |                        \
    \                 ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphtfa_zgq.rs:25:53\n\
    \   |\n25 | ...   if c != \"a\" && c != \"e\" && c != \"i\" && c != \"o\" && c\
    \ != \"u\" && c != \"y\" && c != \"a\" && c != \"e\" && c != \"i\" && c != \"\
    o\" && c != \"u\"...\n   |                                                   ^^^\
    \ expected `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal,\
    \ use single quotes\n   |\n25 |         if c != "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n    // TODO\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0317]: `if` may be missing an `else` clause\n  --> /tmp/tmpsms3xqvj.rs:13:5\n\
    \   |\n12 |   fn select_words(s: String, n: isize) -> Vec<String> {\n   |    \
    \                                       ----------- expected `Vec<String>` because\
    \ of this return type\n13 | /     if s.is_empty() {\n14 | |         return vec![];\n\
    15 | |     }\n   | |_____^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n   = note: `if`\
    \ expressions without `else` evaluate to `()`\n   = help: consider adding an `else`\
    \ block that evaluates to the expected type\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0317`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ cur = String::new();\n    \n    for c in s.chars() {\n        if !is_consonant(c)\
    \ {\n            cur += &c;\n        } else {\n            if cur.len() == n {\n\
    \                words.push(cur);\n                cur = String::new();\n    \
    \        } else {\n                cur += &c;\n            }\n        }\n    }\n\
    \    words.push(cur);\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpeueqc5zj.rs:17:13\n   |\n17 |         if !is_consonant(c) {\n   |  \
    \           ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpeueqc5zj.rs:18:20\n   |\n18 |             cur += &c;\n   |    \
    \                ^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpeueqc5zj.rs:20:29\n   |\n20 |             if cur.len() == n {\n\
    \   |                             ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n20 |             if cur.len() == n.try_into().unwrap() {\n   |  \
    \                            ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeueqc5zj.rs:24:24\n   |\n24 |                 cur += &c;\n\
    \   |                        ^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    match s.len() {\n        0 => vec![],\n\
    \        1 => vec![&s[0..n]],\n        _ => count_matches(s, n)\n            .iter()\n\
    \            .filter(|&(_, count)| count == n)\n            .collect(),\n    }\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_matches` in this scope\n  -->\
    \ /tmp/tmppodt8_1k.rs:16:14\n   |\n16 |         _ => count_matches(s, n)\n   |\
    \              ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `std::ops::Range<isize>`\n  --> /tmp/tmppodt8_1k.rs:15:20\n\
    \   |\n15 |         1 => vec![&s[0..n]],\n   |                    ^^^^^^^ `String`\
    \ cannot be indexed by `std::ops::Range<isize>`\n   |\n   = help: the trait `Index<std::ops::Range<isize>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppodt8_1k.rs:15:19\n\
    \   |\n15 |         1 => vec![&s[0..n]],\n   |                   ^^^^^^^^ expected\
    \ struct `String`, found reference\n   |\n   = note: expected struct `String`\n\
    \           found reference `&_`\nhelp: consider removing the borrow\n   |\n15\
    \ -         1 => vec![&s[0..n]],\n15 +         1 => vec![s[0..n]],\n   | \n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n  let mut res = Vec::new();\n  if s.is_empty()\
    \ {\n    return res.clone();\n  }\n  let mut m = String::new();\n  for c in s.chars()\
    \ {\n    if c.is_ascii() {\n      m.push(c);\n      if m.len() >= n {\n      \
    \  break;\n      }\n    }\n  }\n  res.push(m);\n  for _ in s.chars().rev() {\n\
    \    if m.is_empty() {\n      break;\n    }\n    m.pop();\n    if m.is_empty()\
    \ {\n      res.push(m);\n    }\n  }\n  res\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9c5z8z5n.rs:21:21\n   |\n\
    21 |       if m.len() >= n {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |       if m.len() >= n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = vec![];\n    if s.is_empty()\
    \ {\n        return result;\n    }\n\n    let mut last_consonant_index = s.chars().skip_while(|&c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').last().unwrap();\n\
    \n    for i in s.chars().rev().skip_while(|&c| c != ' ') {\n        if i.to_string().chars().count(|&c|\
    \ c == last_consonant_index) == n {\n            result.push(i.to_string());\n\
    \        }\n        last_consonant_index = i;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpo07_8vsx.rs:21:34\n    |\n21  |         if i.to_string().chars().count(|&c|\
    \ c == last_consonant_index) == n {\n    |                                  ^^^^^\
    \ ------------------------------ supplied 1 argument\n    |                  \
    \                |\n    |                                  expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo07_8vsx.rs:21:75\n   |\n21 |         if i.to_string().chars().count(|&c|\
    \ c == last_consonant_index) == n {\n   |                                    \
    \                                       ^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |         if i.to_string().chars().count(|&c| c\
    \ == last_consonant_index) == n.try_into().unwrap() {\n   |                  \
    \                                                          ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut s = s.as_ref().to_owned();\n\
    \    let mut res = vec![];\n    match n {\n        0 => return vec![],\n     \
    \   _ => match s.chars().take(n).collect::<Vec<_>>() {\n            s => res.append(&s),\n\
    \            s => res.append(&s.to_owned()),\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpntlnqlhy.rs:13:19\n\
    \   |\n13 |     let mut s = s.as_ref().to_owned();\n   |                 --^^^^^^--\n\
    \   |                 | |\n   |                 | cannot infer type for type parameter\
    \ `T` declared on the trait `AsRef`\n   |                 this method call resolves\
    \ to `&T`\n   |\n   = note: type must be known at this point\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // TODO: implement the body of the function\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0x1w_9t0.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = Vec::new();\n    s.split_whitespace().for_each(|w|\
    \ {\n        for (c1, c2) in w.chars().zip(w.chars().skip(1)) {\n            if\
    \ c1 == c2 && (c1 as u32) < n {\n                res.push(w);\n            }\n\
    \        }\n    });\n    return res;\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx51nvhns.rs:16:42\n   |\n\
    16 |             if c1 == c2 && (c1 as u32) < n {\n   |                      \
    \                    ^ expected `u32`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `u32` and panic if the converted value doesn't fit\n   |\n16\
    \ |             if c1 == c2 && (c1 as u32) < n.try_into().unwrap() {\n   |   \
    \                                        ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx51nvhns.rs:21:12\n   |\n12 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \      ----------- expected `Vec<String>` because of return type\n...\n21 |  \
    \   return res;\n   |            ^^^ expected struct `String`, found `&str`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    match s {\n        \"\" => vec![],\n\
    \        x => x\n            .split_whitespace()\n            .filter(|word| contains_exact_ncons(word,\
    \ n))\n            .collect::<Vec<String>>()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `contains_exact_ncons` in this scope\n\
    \  --> /tmp/tmpr370n2wa.rs:17:28\n   |\n17 |             .filter(|word| contains_exact_ncons(word,\
    \ n))\n   |                            ^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr370n2wa.rs:14:9\n  \
    \ |\n13 |     match s {\n   |           - this expression has type `String`\n\
    14 |         \"\" => vec![],\n   |         ^^ expected struct `String`, found\
    \ `&str`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built from an\
    \ iterator over elements of type `&str`\n    --> /tmp/tmpr370n2wa.rs:18:14\n \
    \    |\n18   |             .collect::<Vec<String>>()\n     |              ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut pos = 0;\n    let mut word_list = vec![];\n\n    while pos\
    \ < s.len() {\n        let mut word = String::with_capacity(s.len() - pos + 1);\n\
    \        let mut vowels = false; // Flag to determine whether we select a vowel\
    \ or not.\n\n        while pos < s.len() && s[pos] != '\\0'{ // Check whether\
    \ there are enough characters to construct the word.\n            // Construct\
    \ the word, and add it to the list\n            if s[pos] == 'e' {\n         \
    \       word.append(\"e\");\n            } else if s[pos] == 'i' {\n         \
    \       word.append(\"i\");\n            } else if s[pos] == 'o' {\n         \
    \       word.append(\"o\");\n            } else if s[pos] == 'u' {\n         \
    \       word.append(\"u\");\n            } else if s[pos] == 'a' {\n         \
    \       word.append(\"a\");\n            } else if s[pos] == 'y' {\n         \
    \       word.append(\"y\");\n            } else {\n                word.append(s[pos]);\n\
    \            }\n\n            pos += 1;\n        }\n\n        // If we have enough\
    \ characters to construct the word, add the word to the list\n        if pos <\
    \ s.len() {\n            word_list.push(word);\n        }\n\n        // Check\
    \ if we have to select a vowel\n        if word_list.len() > n {\n           \
    \ vowels = true;\n        }\n\n        // Move to the next character in the string\n\
    \        pos = s.len() - 1;\n    }\n\n    // Return an empty list if we have no\
    \ words containing exactly n consonants\n    if word_list.len() == 0 {\n     \
    \   return vec![];\n    }\n\n    // Otherwise, if the number of selected words\
    \ is not equal to n\n    // then we return an additional empty list\n    if word_list.len()\
    \ != n {\n        return vec![];\n    }\n\n    // Otherwise, if we have to select\
    \ a vowel\n    if vowels == true {\n        word_list.push(\"a\");\n    }\n\n\
    \    // Return our list of words\n    return word_list;\n}\n\nfn main() {\n  \
    \  let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmp67364e54.rs:71:8\n\
    \   |\n71 |     if vowels == true {\n   |        ^^^^^^ not found in this scope\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp67364e54.rs:24:32\n\
    \   |\n24 |         while pos < s.len() && s[pos] != '\\0'{ // Check whether there\
    \ are enough characters to construct the word.\n   |                         \
    \       ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp67364e54.rs:26:16\n   |\n26 |             if s[pos] == 'e' {\n\
    \   |                ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp67364e54.rs:27:22\n   |\n27 |                 word.append(\"e\");\n\
    \   |                      ^^^^^^ method not found in `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp67364e54.rs:28:23\n\
    \   |\n28 |             } else if s[pos] == 'i' {\n   |                      \
    \ ^^^^^^ `String` cannot be indexed by `usize"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut res = vec![];\n    let mut counter\
    \ = 1;\n    let mut current_letter = s[0] as char;\n    \n    for letter in s.chars()\
    \ {\n        if letter == current_letter {\n            counter += 1;\n      \
    \      if counter == n {\n                counter = 1;\n                current_letter\
    \ = letter;\n            }\n        } else {\n            counter = 1;\n     \
    \       current_letter = letter;\n        }\n        res.push(String::from(current_letter));\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpe6b7sno1.rs:15:30\n   |\n15 |     let mut current_letter = s[0] as char;\n\
    \   |                              ^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ cur_letter = s[0];\n    let mut cur_pos = 0;\n    let mut next_letter = s[1];\n\
    \    let mut next_pos = 1;\n    \n    let mut in_word = false;\n    \n    while\
    \ cur_pos < s.len() {\n        if cur_letter == next_letter {\n            in_word\
    \ = true;\n            cur_pos += 1;\n            next_pos +=1;\n            if\
    \ cur_pos >= s.len() {\n                if next_letter == s[1] {\n           \
    \         words.push_back(s[cur_pos..]);\n                }\n            }\n \
    \       } else {\n            if in_word {\n                words.push_back(s[cur_pos..]);\n\
    \            }\n            in_word = false;\n            cur_letter = next_letter;\n\
    \            cur_pos = next_pos;\n            next_letter = s[1];\n          \
    \  next_pos = 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmppzo1iooj.rs:14:26\n   |\n14 |     let mut cur_letter = s[0];\n   | \
    \                         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmppzo1iooj.rs:16:27\n   |\n16 |     let mut next_letter = s[1];\n\
    \   |                           ^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmppzo1iooj.rs:27:35\n   |\n27 |                 if next_letter ==\
    \ s[1] {\n   |                                   ^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<st"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    match n {\n        0 => vec![],\n  \
    \      1 => vec![s],\n        _ => s.chars().collect::<Vec<_>>().filter(|&c| c\
    \ != 'a' || c != 'e' || c != 'i' || c != 'o' || c != 'u').take(n).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Vec<char>` is not an iterator\n   --> /tmp/tmp5capqpvp.rs:16:44\n\
    \    |\n16  |           _ => s.chars().collect::<Vec<_>>().filter(|&c| c != 'a'\
    \ || c != 'e' || c != 'i' || c != 'o' || c != 'u').take(n).collect()\n    |  \
    \                                            ^^^^^^ `Vec<char>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<char>: Iterator`\n            which is required by `&mut Vec<char>: Iterator`\n\
    \            `[char]: Iterator`\n            which is required by `&mut [char]:\
    \ Iterator`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() { return vec![] }\n\
    \    let mut list = vec![];\n    let mut i = 0;\n    let mut j = -1;\n    while\
    \ i != s.size() {\n        if s[i] == ' ' || s[i] == '\\n' || s[i] == '\\t' {\n\
    \            list.push(s.to_string().remove(i, 1).to_string());\n            i\
    \ += 1;\n            continue;\n        }\n        j = i;\n        while i !=\
    \ s.size() && s[i] != ' ' && s[i] != ';' && s[i] != '\\n' && s[i] != '\\t' {\n\
    \            i += 1;\n        }\n        if j == i || i != s.size() && s[i - 1..j].iter().all(|&x|\
    \ x == s[i..j]) {\n            list.push(s.to_string().remove(i, 1).to_string());\n\
    \            i += 1;\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpo2vhny2u.rs:17:18\n   |\n17 |     while i != s.size() {\n\
    \   |                  ^^^^ method not found in `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpo2vhny2u.rs:18:12\n\
    \   |\n18 |         if s[i] == ' ' || s[i] == '\\n' || s[i] == '\\t' {\n   | \
    \           ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the\
    \ trait `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpo2vhny2u.rs:18:27\n   |\n18 |         if s[i] == ' ' || s[i] ==\
    \ '\\n' || s[i] == '\\t' {\n   |                           ^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpo2vhny2u.rs:18:43\n   |\n18 |         if s[i] == ' ' || s[i] ==\
    \ '\\n' || s[i] == '\\t' {\n   |                                           ^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n          "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    for\
    \ i in s.chars().enumerate().skip(1).take(n) {\n        if i[1].unwrap() == 's'\
    \ {\n            list.push(i[0].to_string());\n        }\n    }\n    return list\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpokhsmi8r.rs:14:49\n   |\n\
    14 |     for i in s.chars().enumerate().skip(1).take(n) {\n   |              \
    \                                   ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n14 |     for i in s.chars().enumerate().skip(1).take(n.try_into().unwrap())\
    \ {\n   |                                                  ++++++++++++++++++++\n\
    \nerror[E0608]: cannot index into a value of type `(usize, char)`\n  --> /tmp/tmpokhsmi8r.rs:15:12\n\
    \   |\n15 |         if i[1].unwrap() == 's' {\n   |            ^^^^ help: to access\
    \ tuple elements, use: `i.1`\n\nerror[E0608]: cannot index into a value of type\
    \ `(usize, char)`\n  --> /tmp/tmpokhsmi8r.rs:16:23\n   |\n16 |             list.push(i[0].to_string());\n\
    \   |                       ^^^^ help: to access tuple elements, use: `i.0`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut word = vec![];\n    let mut\
    \ index = 0;\n    while index != s.len() {\n        if s[index] == '\\0' {\n \
    \           break;\n        }\n        let mut flag = 0;\n        for j in 0..index\
    \ {\n            if s[index] == '\\0' {\n                break;\n            }\n\
    \            if s[index] == s[j] {\n                flag = 1;\n              \
    \  break;\n            }\n        }\n        if flag == 0 {\n            word.push(s[index]);\n\
    \        }\n        index += 1;\n    }\n    word\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzxcz4o0k.rs:16:12\n\
    \   |\n16 |         if s[index] == '\\0' {\n   |            ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzxcz4o0k.rs:21:16\n   |\n21 |             if s[index] == '\\0'\
    \ {\n   |                ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzxcz4o0k.rs:24:16\n\
    \   |\n24 |             if s[index] == s[j] {\n   |                ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the t"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ j = 0;\n\n    while j < s.len() {\n        let mut consonant = 0;\n        let\
    \ mut chars = s[j..].chars();\n        while chars.any(|&c| c.is_consonant())\
    \ {\n            consonant += 1;\n            chars = chars.skip(1);\n       \
    \ }\n\n        if consonant == n {\n            words.push(s.substring(j, j +\
    \ chars.len()));\n            j += chars.len();\n        }\n    }\n\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo8dh4kro.rs:19:26\n   |\n\
    19 |         while chars.any(|&c| c.is_consonant()) {\n   |                  \
    \        ^--\n   |                          ||\n   |                         \
    \ |expected due to this\n   |                          expected `char`, found\
    \ reference\n   |                          help: did you mean `c`: `&char`\n \
    \  |\n   = note:   expected type `char`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo8dh4kro.rs:21:21\n   |\n18 |         let mut\
    \ chars = s[j..].chars();\n   |                         -------------- expected\
    \ due to this value\n...\n21 |             chars = chars.skip(1);\n   |      \
    \               ^^^^^^^^^^^^^ expected struct `Chars`, found struct `Skip`\n \
    \  |\n   = note: expected struct `Chars<'_>`\n              found struct `Skip<Chars<'_>>`\n\
    \nerror[E0599]: no method named `substring` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpo8dh4kro.rs:25:26\n   |\n25 |             words.push(s.substring(j,\
    \ j + chars.len()));\n   |                          ^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `len` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpo8dh4kro.rs:25:49\n   |\n25 |          \
    \   words.push(s.substring(j, j + chars.len()));\n   |                       \
    \                          ^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmpo8dh4kro.rs:26:24\n\
    \   |\n26 |             j += chars.len();\n   |                        ^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n    // Your code here\n    \n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxkd6b8sb.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // todo\n    let mut vowels = 'aeiou';\n\
    \    let mut consonants = &mut vowels[..];\n    let mut consonant_count = 0;\n\
    \    let mut vowel_count = 0;\n    let mut vowels = Vec::new();\n    for i in\
    \ s.chars() {\n        if i.is_vowel() {\n            if consonant_count == n\
    \ {\n                vowels.push_back(s);\n                break;\n          \
    \  }\n            consonant_count += 1;\n        } else {\n            if vowel_count\
    \ == n {\n                vowels.push_back(s);\n                break;\n     \
    \       }\n            vowel_count += 1;\n        }\n        consonants = consonants.chain(i.as_consonants());\n\
    \    }\n    vowels\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpgj0fkmfu.rs:14:22\n\
    \   |\n14 |     let mut vowels = 'aeiou';\n   |                      ^^^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    14 |     let mut vowels = \"aeiou\";\n   |                      ~~~~~~~\n\nerror[E0599]:\
    \ no method named `is_vowel` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpgj0fkmfu.rs:20:14\n   |\n20 |         if i.is_vowel() {\n   |      \
    \        ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgj0fkmfu.rs:22:24\n\
    \   |\n22 |                 vowels.push_back(s);\n   |                       \
    \ ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgj0fkmfu.rs:28:24\n\
    \   |\n28 |                 vowels.push_back(s);\n   |                       \
    \ ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `as_consonants`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpgj0fkmfu.rs:33:41\n\
    \   |\n33 |         consonants = consonants.chain(i.as_consonants());\n   |  \
    \                                       ^^^^^^^^^^^^^ method not found in `char`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    \n    fn\
    \ is_consonant(c: char) -> bool {\n        match c {\n            'A'...'Z' =>\
    \ true,\n            'a'...'z' => true,\n            _ => false\n        }\n \
    \   }\n    \n    for c in s.chars() {\n        if is_consonant(c) {\n        \
    \    if n == 1 {\n                words.push(s);\n            } else {\n     \
    \           let idx = s.find(c).unwrap();\n                words.push(s.split_at(idx));\n\
    \            }\n        }\n    }\n    \n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmphee_q_nv.rs:17:16\n\
    \   |\n17 |             'A'...'Z' => true,\n   |                ^^^ help: use\
    \ `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmphee_q_nv.rs:18:16\n\
    \   |\n18 |             'a'...'z' => true,\n   |                ^^^ help: use\
    \ `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current\
    \ edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information,\
    \ see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphee_q_nv.rs:29:28\n   |\n29 |\
    \                 words.push(s.split_at(idx));\n   |                         \
    \   ^^^^^^^^^^^^^^^ expected struct `String`, found tuple\n   |\n   = note: expected\
    \ struct `String`\n               found tuple `(&str, &str)`\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo4qatgp6.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n    \n    let mut words = vec![];\n    let mut count = 0;\n    let mut\
    \ last = 0;\n    for i in s.chars() {\n        if i.is_consonant() {\n       \
    \     if last != i {\n                words.push(s.split_whitespace()[last..i].clone());\n\
    \                last = i;\n            }\n            count += 1;\n        }\n\
    \    }\n    if n == count {\n        words.push_back(s.split_whitespace()[last..].clone());\n\
    \    }\n    return words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpey2ogdcw.rs:21:14\n   |\n21 |         if i.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpey2ogdcw.rs:22:24\n   |\n22 |             if\
    \ last != i {\n   |                        ^ expected integer, found `char`\n\n\
    error[E0277]: can't compare `{integer}` with `char`\n  --> /tmp/tmpey2ogdcw.rs:22:21\n\
    \   |\n22 |             if last != i {\n   |                     ^^ no implementation\
    \ for `{integer} == char`\n   |\n   = help: the trait `PartialEq<char>` is not\
    \ implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpey2ogdcw.rs:23:55\n   |\n23 |                 words.push(s.split_whitespace()[last..i].clone());\n\
    \   |                                                       ^ expected integer,\
    \ found `char`\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpey2ogdcw.rs:23:28\n   |\n23 |                 words.push(s.split_whitespace()[last..i].clone());\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpey2ogdcw.rs:24:24\n   |\n19 |     let mut last\
    \ = 0;\n   |                    - expected due to this value\n...\n24 |      \
    \           last = i;\n   |                        ^ expected integer, found `char`\n\
    \nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current\
    \ scope\n  --> /tmp/tmpey2ogdcw.rs:30:15\n   |\n30 |         words.push_back(s.split_whitespace()[last..].clone());\n\
    \   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0608]: cannot\
    \ index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpey2ogdcw.rs:30:25\n\
    \   |\n30 |         words.push_back(s.split_whitespace()[last..].clone());\n \
    \  |           "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut index = 0;\n    while index < s.len() {\n        let word = s.to_string();\n\
    \        if n == 1 {\n            list.push(word);\n        } else {\n       \
    \     let index2 = index as usize;\n            if index2 < word.len() && word[index2]\
    \ == word[index2 + 1] {\n                list.push(word);\n            }\n   \
    \     }\n        index += 1;\n    }\n    return list;\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmdoh3la0.rs:21:39\n\
    \   |\n21 |             if index2 < word.len() && word[index2] == word[index2\
    \ + 1] {\n   |                                       ^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmdoh3la0.rs:21:55\n   |\n21 |             if index2 < word.len()\
    \ && word[index2] == word[index2 + 1] {\n   |                                \
    \                       ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    s.split(\" \").filter(|x| x.chars().filter(|c|\
    \ c.is_ascii()).count() == n).collect()\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplnpanf4p.rs:13:75\n   |\n\
    13 |     s.split(\" \").filter(|x| x.chars().filter(|c| c.is_ascii()).count()\
    \ == n).collect()\n   |                                                      \
    \                     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    13 |     s.split(\" \").filter(|x| x.chars().filter(|c| c.is_ascii()).count()\
    \ == n.try_into().unwrap()).collect()\n   |                                  \
    \                                          ++++++++++++++++++++\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&str`\n    --> /tmp/tmplnpanf4p.rs:13:78\n     |\n13   |     s.split(\"\
    \ \").filter(|x| x.chars().filter(|c| c.is_ascii()).count() == n).collect()\n\
    \     |                                                                      \
    \        ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    \n    let\
    \ mut s = String::from(s);\n    \n    while s.len() > n {\n        let mut index\
    \ = s.find(|&c| c != 'a');\n        \n        if index == None {\n           \
    \ s.push(&s[0]);\n            index = 0;\n        }\n        \n        let mut\
    \ consonant_count = 0;\n        \n        for char in s.chars() {\n          \
    \  if char != s[index] {\n                consonant_count += 1;\n            }\n\
    \        }\n        \n        if consonant_count == n {\n            words.push(&s[index..]);\n\
    \        }\n        \n        index = s.find(|&c| c != 'a');\n        s = &s[1..];\n\
    \    }\n    \n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp1j9ifca.rs:17:21\n   |\n\
    17 |     while s.len() > n {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n17 |     while s.len() > n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0631]: type mismatch\
    \ in closure arguments\n    --> /tmp/tmpp1j9ifca.rs:18:27\n     |\n18   |    \
    \     let mut index = s.find(|&c| c != 'a');\n     |                         \
    \  ^^^^ ------------- found signature of `fn(&_) -> _`\n     |               \
    \            |\n     |                           expected signature of `fn(char)\
    \ -> _`\n     |\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `[closure@/tmp/tmpp1j9ifca.rs:18:32: 18:45]`\nnote: required\
    \ by a bound in `core::str::<impl str>::find`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmpp1j9ifca.rs:21:21\n   |\n21\
    \ |             s.push(&s[0]);\n   |                     ^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp1j9ifca.rs:21:20\n\
    \   |\n21 |             s.push(&s[0]);\n   |                    ^^^^^ expected\
    \ `char`, found reference\n   |\n   = note:   expected type `char`\n         \
    \  found reference `&_`\nhelp: consider removing the borrow\n   |\n21 -      \
    \       s.push(&s[0]);\n21 +             s.push(s[0]);\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp1j9ifca.rs:22:21\n   |\n18 |         let mut\
    \ index = s.find(|&c| c != 'a');\n   |           "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    return vec![\"\"];\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp89b90qv2.rs:13:17\n   |\n\
    13 |     return vec![\"\"];\n   |                 ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                 |\n   |                 expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // Your code here\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwcwei3ph.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = vec![];\n    let mut\
    \ count = 0;\n    let mut last = 0;\n    \n    for ch in s.chars() {\n       \
    \ if count >= n {\n            break;\n        }\n        if ch.is_space() {\n\
    \            count += 1;\n            continue;\n        }\n        if ch.is_consonant()\
    \ {\n            count += 1;\n            \n            // If the previous letter\
    \ was a consonant,\n            // but we haven't seen it yet, add it\n      \
    \      if last != 0 {\n                words.push(s[last..]);\n              \
    \  last = last;\n                count = 1;\n            } else {\n          \
    \      words.push(ch);\n                last = 0;\n                count = 1;\n\
    \            }\n        } else {\n            count += 1;\n            last =\
    \ last;\n            count = 1;\n        }\n    }\n    if last != 0 {\n      \
    \  words.push(s[last..]);\n    }\n    return words;\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_space` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpjh6i1l0d.rs:21:15\n   |\n21 |         if ch.is_space()\
    \ {\n   |               ^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_whitespace`\n\nerror[E0599]: no method named `is_consonant`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpjh6i1l0d.rs:25:15\n\
    \   |\n25 |         if ch.is_consonant() {\n   |               ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmpjh6i1l0d.rs:31:28\n    |\n31  |\
    \                 words.push(s[last..]);\n    |                       ---- ^^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |                       |\n \
    \   |                       required by a bound introduced by this call\n    |\n\
    \    = help: the trait `Sized` is not implemented for `str`\nnote: required by\
    \ a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n   --> /tmp/tmpjh6i1l0d.rs:13:21\n\
    \    |\n13  |     let mut words = vec![];\n    |                     ^^^^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Vec::<T>::new`\n    = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n   --> /tmp/tmpjh6i1l0d.rs:13:21\n    |\n13  |  \
    \   let mut words = vec![];\n    |                     ^^^^^^ doesn't have a size\
    \ known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `Vec`\n    = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0599]: the method `push` exists for struct `Vec<str>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmpjh6i1l0d.rs:35:23\n   |\n35 |\
    \                 words.push(ch);\n   |            "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = vec![];\n\
    \    let mut last = 0;\n    let mut current_char = 0;\n    let mut i = 0;\n  \
    \  while i < s.len() {\n        if i < n {\n            if s[i] == ' ' {\n   \
    \             current_char += 1;\n            }\n            else if s[i] == '\
    \ ' && current_char == n {\n                i += 1;\n                let word\
    \ = s[last..i].to_string();\n                last = i;\n                words.push(word);\n\
    \                current_char = 1;\n            }\n            else {\n      \
    \          current_char += 1\n            }\n        } else {\n            let\
    \ word = s[last..i].to_string();\n            last = i;\n            words.push(word);\n\
    \            current_char = 1;\n        }\n        i += 1;\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz9n5ia_8.rs:18:16\n   |\n\
    18 |         if i < n {\n   |                ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |         if i < n.try_into().unwrap() {\n   | \
    \                ++++++++++++++++++++\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpz9n5ia_8.rs:19:16\n   |\n19 |         \
    \    if s[i] == ' ' {\n   |                ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz9n5ia_8.rs:22:21\n   |\n22 |             else if s[i] == ' ' &&\
    \ current_char == n {\n   |                     ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbsph4fzu.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut chars = s.chars();\n    chars.skip(n);\n\
    \    let mut res = vec![];\n    loop {\n        res.push(chars.collect::<String>());\n\
    \        if chars.peek() == Some(' ') {\n            chars.next();\n         \
    \   break;\n        }\n        chars.next();\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmlzvp1zd.rs:14:16\n   |\n\
    14 |     chars.skip(n);\n   |                ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     chars.skip(n.try_into().unwrap());\n   | \
    \                ++++++++++++++++++++\n\nerror[E0599]: no method named `peek`\
    \ found for struct `Chars` in the current scope\n  --> /tmp/tmpmlzvp1zd.rs:18:18\n\
    \   |\n18 |         if chars.peek() == Some(' ') {\n   |                  ^^^^\
    \ method not found in `Chars<'_>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    let\
    \ mut index = 0;\n\n    loop {\n        match s.chars().nth(index).unwrap() {\n\
    \            ' ' => break,\n            _ if index == n => list.push(s.to_owned()),\n\
    \            _ => {\n                if !s.chars().any(|c| *c == c && c != ' ')\
    \ {\n                    list.push(s.to_owned());\n                }\n       \
    \         index += 1;\n            }\n        }\n    }\n    list\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyg30el5v.rs:19:27\n   |\n\
    19 |             _ if index == n => list.push(s.to_owned()),\n   |           \
    \                ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    19 |             _ if index == n.try_into().unwrap() => list.push(s.to_owned()),\n\
    \   |                            ++++++++++++++++++++\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpyg30el5v.rs:21:39\n   |\n21 |        \
    \         if !s.chars().any(|c| *c == c && c != ' ') {\n   |                 \
    \                      ^^\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return Vec::new();\n\
    \    }\n    let mut list = vec![];\n    let mut index = 0;\n    for c in s.chars()\
    \ {\n        let mut current_index = 0;\n        if c.is_upper() {\n         \
    \   current_index = 1;\n        }\n        match current_index {\n           \
    \ 1 => if c == ' ' { list.push(\"_\"); },\n            _ => if c.is_lower() ||\
    \ c != 'A' || c != 'E' || c != 'I' || c != 'O' || c != 'U' {\n               \
    \ list.push(s.to_string()[index..(index + c.len_utf8())]);\n                index\
    \ += c.len_utf8();\n            }\n        }\n    }\n    list\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_upper` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpuwpnbeqf.rs:20:14\n   |\n20 |         if c.is_upper() {\n\
    \   |              ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_uppercase`\n\nerror[E0599]: no method named `is_lower` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpuwpnbeqf.rs:25:23\n   |\n25 |   \
    \          _ => if c.is_lower() || c != 'A' || c != 'E' || c != 'I' || c != 'O'\
    \ || c != 'U' {\n   |                       ^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_lowercase`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpuwpnbeqf.rs:26:27\n   |\n26 |                 list.push(s.to_string()[index..(index\
    \ + c.len_utf8())]);\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                           |\n   |                           expected `&str`,\
    \ found `str`\n   |                           help: consider borrowing here: `&s.to_string()[index..(index\
    \ + c.len_utf8())]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuwpnbeqf.rs:31:5\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n31 |     list\n   |     ^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<&str>`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp992fyoeh.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut s = s;\n    let mut words =\
    \ vec![];\n    while !s.is_empty() {\n        let mut word = '';\n        let\
    \ mut index = s.find(|c| {\n            c != 'A' && c != 'E' && c != 'I' && c\
    \ != 'O' && c != 'U' && c != 'Y' && c != 'a'\n            && c != 'e' && c !=\
    \ 'i' && c != 'o' && c != 'u' && c != 'y'\n        })\n        .unwrap();\n  \
    \      while index < s.len() {\n            word.push(s[index]);\n           \
    \ index = s.find(|c| {\n                c != 'A' && c != 'E' && c != 'I' && c\
    \ != 'O' && c != 'U' && c != 'Y' && c != 'a'\n                && c != 'e' && c\
    \ != 'i' && c != 'o' && c != 'u' && c != 'y'\n            })\n            .unwrap();\n\
    \        }\n        if word.is_empty() || word == s {\n            break;\n  \
    \      }\n        words.push_back(word);\n        s = s.split_whitespace()\n \
    \   }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpyvqu9q0g.rs:16:25\n   |\n\
    16 |         let mut word = '';\n   |                         ^ empty character\
    \ literal\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpyvqu9q0g.rs:23:23\n   |\n23 |             word.push(s[index]);\n   |\
    \                       ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]:\
    \ no method named `push_back` found for struct `Vec<_>` in the current scope\n\
    \  --> /tmp/tmpyvqu9q0g.rs:33:15\n   |\n33 |         words.push_back(word);\n\
    \   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyvqu9q0g.rs:34:13\n   |\n13 |     let mut s = s;\n   |\
    \                 - expected due to this value\n...\n34 |         s = s.split_whitespace()\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found struct\
    \ `SplitWhitespace`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // your code here\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphtgyc8_k.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut n = n as usize;\n    let mut s = s as String;\n    while n > 0 {\n     \
    \   if s.is_empty() {\n            break;\n        }\n        for char in s.chars()\
    \ {\n            if char == ' ' {\n                continue;\n            }\n\
    \            if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char\
    \ == 'u' {\n                words.push( s.to_string() );\n                break;\n\
    \            }\n        }\n        s.truncate(0);\n        n = n - 1;\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary had a little lamb\"]`,\n right: `[\"little\"]`', /tmp/tmp6avnull6.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut list = Vec::new();\n    for\
    \ c in s.chars() {\n        if c.is_consonant() && c != ' ' {\n            list.push(c);\n\
    \        }\n        if c.is_space() {\n            break;\n        }\n    }\n\
    \    return list;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpo4waupjw.rs:15:14\n   |\n15 |         if c.is_consonant()\
    \ && c != ' ' {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\n\
    error[E0599]: no method named `is_space` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpo4waupjw.rs:18:14\n   |\n18 |         if c.is_space() {\n\
    \   |              ^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_whitespace`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4waupjw.rs:22:12\n\
    \   |\n12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n22 |     return list;\n   |            ^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n   \
    \           found struct `Vec<char>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = vec![];\n\
    \    for ch in s.chars() {\n        if let Some(c) = ch == ' ' {\n           \
    \ continue;\n        }\n        if let Some(c) = (ch.to_digit(10).unwrap() % 11).unwrap()\
    \ {\n            continue;\n        }\n        if let Some(c) = (ch.to_digit(10).unwrap()\
    \ % 11).unwrap() {\n            continue;\n        }\n        if let Some(c) =\
    \ (ch.to_digit(10).unwrap() % 11).unwrap() {\n            continue;\n        }\n\
    \        if let Some(c) = (ch.to_digit(10).unwrap() % 11).unwrap() {\n       \
    \     continue;\n        }\n        words.push(s.clone());\n        break;\n \
    \   }\n    if words.len() == 0 || words.len() > n {\n        return vec![];\n\
    \    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsnd9mevs.rs:15:16\n   |\n\
    15 |         if let Some(c) = ch == ' ' {\n   |                ^^^^^^^   ---------\
    \ this expression has type `bool`\n   |                |\n   |               \
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<_>`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `u32` in the current scope\n  --> /tmp/tmpsnd9mevs.rs:18:58\n\
    \   |\n18 |         if let Some(c) = (ch.to_digit(10).unwrap() % 11).unwrap()\
    \ {\n   |                                                          ^^^^^^ method\
    \ not found in `u32`\n\nerror[E0599]: no method named `unwrap` found for type\
    \ `u32` in the current scope\n  --> /tmp/tmpsnd9mevs.rs:21:58\n   |\n21 |    \
    \     if let Some(c) = (ch.to_digit(10).unwrap() % 11).unwrap() {\n   |      \
    \                                                    ^^^^^^ method not found in\
    \ `u32`\n\nerror[E0599]: no method named `unwrap` found for type `u32` in the\
    \ current scope\n  --> /tmp/tmpsnd9mevs.rs:24:58\n   |\n24 |         if let Some(c)\
    \ = (ch.to_digit(10).unwrap() % 11).unwrap() {\n   |                         \
    \                                 ^^^^^^ method not found in `u32`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `u32` in the current scope\n  --> /tmp/tmpsnd9mevs.rs:27:58\n\
    \   |\n27 |         if let Some(c) = (ch.to_digit(10).unwrap() % 11).unwrap()\
    \ {\n   |                                                          ^^^^^^ method\
    \ not found in `u32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsnd9mevs.rs:33:42\n\
    \   |\n33 |     if words.len() == 0 || words.len() > n {\n   |               \
    \                           ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n33 |     if words.len() == 0 || words.len() > n.try_into().unwrap()\
    \ {\n   |                                           ++++++++++++++++++++\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut vowels: Vec<&str> = vec![];\n\n    for c in s.chars() {\n\
    \        if c.is_vowel() {\n            vowels.push(c);\n        }\n    }\n\n\
    \    if vowels.len() < n {\n        return vec![];\n    }\n\n    let mut found:\
    \ Vec<String> = vec![];\n\n    for (i, &c) in s.chars().enumerate() {\n      \
    \  if i == 0 {\n            found.push(&s[0..c]);\n            continue;\n   \
    \     }\n\n        if c == ' ' {\n            continue;\n        }\n\n       \
    \ if vowels.iter().any(|v| *v == c) {\n            continue;\n        }\n\n  \
    \      if i != 0 {\n            let s = &s[0..i];\n            found.push(s);\n\
    \        }\n    }\n\n    found\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpqphg1fp0.rs:20:14\n   |\n20 |         if c.is_vowel() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqphg1fp0.rs:21:25\n   |\n21 |             vowels.push(c);\n\
    \   |                         ^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqphg1fp0.rs:25:23\n   |\n25 |     if vowels.len()\
    \ < n {\n   |                       ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n25 |     if vowels.len() < n.try_into().unwrap() {\n   |\
    \                        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqphg1fp0.rs:31:13\n   |\n31 |     for (i, &c) in s.chars().enumerate()\
    \ {\n   |             ^^     --------------------- this expression has type `Option<(usize,\
    \ char)>`\n   |             |\n   |             expected `char`, found reference\n\
    \   |             help: you can probably remove the explicit borrow: `c`\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqphg1fp0.rs:33:24\n   |\n33 |             found.push(&s[0..c]);\n\
    \   |                        ^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n33 |             found.push((&s[0..c]).to_string());\n\
    \   |                        +        +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqphg1fp0.rs:37:17\n   |\n37 |         if c == ' ' {\n \
    \  |                 ^^^ expected `usize`, found `char`\n\nerror[E0277]: can't\
    \ compare `&str` with `usize`\n  --> /tmp/tmpqphg1fp0.rs:41:37\n   |\n41 |   \
    \      if vowels.iter().any(|v| *v == c) {\n   |                             \
    \        ^^ no implementation for `&str == usize`\n   |\n   = help: the trait\
    \ `PartialEq<usize>` is not implemented for `&str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // Convert string to vector of chars\n\
    \    let chars_str = s.chars();\n    let mut chars_vec : Vec<char> = Vec::new();\n\
    \    for char in chars_str {\n        chars_vec.push(char);\n    }\n    \n   \
    \ // Iterate through vector and count consonants\n    let mut num_consonants :\
    \ usize = 0;\n    for character in chars_vec {\n        if character == 'a' ||\
    \ character == 'e' || character == 'i' || \n            character == 'o' || character\
    \ == 'u' {\n            num_consonants++;\n        }\n    }\n    \n    // Find\
    \ first character that has n consonants\n    let mut index : usize = 0;\n    \n\
    \    for character in chars_vec {\n        if character == 'a' || character ==\
    \ 'e' || character == 'i' || \n            character == 'o' || character == 'u'\
    \ {\n            index = chars_vec.iter().position(|x| x == character);\n    \
    \        break;\n        }\n    }\n    \n    let mut result = Vec::new();\n  \
    \  \n    // Iterate through vector and pull out those that have n consonants\n\
    \    for character in chars_vec {\n        if character == 'a' || character ==\
    \ 'e' || character == 'i' || \n            character == 'o' || character == 'u'\
    \ {\n            if chars_vec.len() >= index + 1 {\n                result.push(chars_vec[index\
    \ + 1]);\n            }\n        }\n    }\n    \n    result\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpgykp_uis.rs:25:27\n\
    \   |\n25 |             num_consonants++;\n   |                           ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n25 |       \
    \      { let tmp = num_consonants; num_consonants += 1; tmp };\n   |         \
    \    +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n25 -            \
    \ num_consonants++;\n25 +             num_consonants += 1;\n   | \n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpgykp_uis.rs:35:53\n   |\n35\
    \ |             index = chars_vec.iter().position(|x| x == character);\n   | \
    \                                                    ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgykp_uis.rs:35:21\n   |\n30 |  \
    \   let mut index : usize = 0;\n   |                     ----- expected due to\
    \ this type\n...\n35 |             index = chars_vec.iter().position(|x| x ==\
    \ character);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgykp_uis.rs:52:5\n   |\n12 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n52 |     result\n   |     ^^^^^^\
    \ expected struct `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<char>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let\
    \ mut last_pos = 0;\n    while last_pos < s.len() {\n        let mut i = 0;\n\
    \        let mut j = last_pos + 1;\n        while j < s.len() && j > last_pos\
    \ {\n            if s[i].is_lowercase() && s[j].is_lowercase() && j > i {\n  \
    \              if s[i] == s[j] {\n                    i += 1;\n              \
    \      j += 1;\n                } else {\n                    i += 1;\n      \
    \          }\n            } else {\n                i += 1;\n            }\n \
    \       }\n        if j == s.len() || j > last_pos {\n            words = words.into_iter().take(words.size()\
    \ + 1).collect();\n            last_pos = j;\n        }\n    }\n    words\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpeb5aewb9.rs:19:16\n   |\n19 |             if s[i].is_lowercase() &&\
    \ s[j].is_lowercase() && j > i {\n   |                ^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpeb5aewb9.rs:19:39\n   |\n19 |             if s[i].is_lowercase()\
    \ && s[j].is_lowercase() && j > i {\n   |                                    \
    \   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpeb5aewb9.rs:20:20\n   |\n20 |                 if s[i] == s[j] {\n\
    \   |                    ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n "
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    // Your code here\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcnnt9qk3.rs:12:41\n   |\n\
    12 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    \n    let mut s = s;\n    \n    while\
    \ s.len() > n {\n        s = s.to_lowercase();\n        \n        let mut index\
    \ = 0;\n        let mut flag = false;\n        \n        while index < s.len()\
    \ {\n            let mut c = s[index];\n            if c.is_uppercase() {\n  \
    \              flag = true;\n                break;\n            } else if c.is_lowercase()\
    \ {\n                break;\n            } else if c == ' ' {\n              \
    \  break;\n            }\n            \n            index += 1; \n        }\n\
    \        \n        if flag == true {\n            s = s.to_lowercase();\n    \
    \    }\n    }\n    \n    if s.len() > n {\n        return vec![s]\n    }\n   \
    \ else {\n        return vec![]\n    }\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbpcooy9s.rs:16:21\n   |\n\
    16 |     while s.len() > n {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n16 |     while s.len() > n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpbpcooy9s.rs:23:25\n   |\n\
    23 |             let mut c = s[index];\n   |                         ^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbpcooy9s.rs:41:18\n\
    \   |\n41 |     if s.len() > n {\n   |                  ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n41 |     if s.len() > n.try_into().unwrap()\
    \ {\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
