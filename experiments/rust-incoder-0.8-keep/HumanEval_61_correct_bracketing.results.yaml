name: HumanEval_61_correct_bracketing
language: rust
results:
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets == String::from(\"(\") && brackets.len() > 1\
    \ ||\n    brackets == String::from(\"[\") && brackets.len() > 1 ||\n    brackets\
    \ == String::from(\"{\") && brackets.len() > 1 ||\n    brackets == String::from(\"\
    (\") && brackets.len() == 1 ||\n    brackets == String::from(\"[\") && brackets.len()\
    \ == 1 ||\n    brackets == String::from(\"{\") && brackets.len() == 1 ||\n   \
    \ brackets == String::from(\"(\") && brackets.len() == 1 && brackets[0] == String::from(\"\
    )\") ||\n    brackets == String::from(\"[\") && brackets.len() == 1 && brackets[0]\
    \ == String::from(\"]\") ||\n    brackets == String::from(\"{\") && brackets.len()\
    \ == 1 && brackets[0] == String::from(\"}\") ||\n    brackets == String::from(\"\
    (\") && brackets.len() == 1 && brackets[0] == String::from(\")\") &&\n    brackets.slice(1,\
    \ 2).len() == 1 && brackets[0] == String::from(\")\") ||\n    brackets == String::from(\"\
    [\") && brackets.len() == 1 && brackets[0] == String::from(\"]\") ||\n    brackets\
    \ == String::from(\"{\") && brackets.len() == 1 && brackets[0] == String::from(\"\
    }\")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpzikqgmjf.rs:18:61\n   |\n18 |     brackets == String::from(\"(\") &&\
    \ brackets.len() == 1 && brackets[0] == String::from(\")\") ||\n   |         \
    \                                                    ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpzikqgmjf.rs:19:61\n   |\n19 |     brackets == String::from(\"[\"\
    ) && brackets.len() == 1 && brackets[0] == String::from(\"]\") ||\n   |      \
    \                                                       ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpzikqgmjf.rs:20:61\n   |\n20 |     brackets == String::from(\"{\"\
    ) && brackets.len() == 1 && brackets[0] == String::from(\"}\") ||\n   |      \
    \                                                       ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<String> = vec![];\n    for c in &brackets\
    \ {\n        if c == \")\" {\n            if !stack.is_empty() {\n           \
    \     stack.pop();\n            } else {\n                return false;\n    \
    \        }\n        } else if c == \"(\" {\n            stack.push(c);\n     \
    \   }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpvm_2obtw.rs:13:14\n\
    \   |\n13 |     for c in &brackets {\n   |              ^^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket_positions = brackets.chars().collect::<HashSet<usize>>();\n\
    \    bracket_positions.remove(0);\n    bracket_positions.remove(1);\n    if bracket_positions.iter().any(|x|\
    \ x != 0) {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp4t3bhpsv.rs:12:60\n\
    \   |\n12 |     let mut bracket_positions = brackets.chars().collect::<HashSet<usize>>();\n\
    \   |                                                            ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket = brackets.as_str();\n    while bracket.len()\
    \ > 1 {\n        let mut found = false;\n        for ch in bracket.chars() {\n\
    \            if ch == bracket[0] {\n                bracket = &bracket[1..];\n\
    \                found = true;\n            }\n        }\n        if !found {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmp88tnazt9.rs:16:22\n\
    \   |\n16 |             if ch == bracket[0] {\n   |                      ^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `{integer}`\n   = note: you can use `.chars().nth()`\
    \ or `.bytes().nth()`\n           for more information, see chapter 8 in The Book:\
    \ <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<&str> = Vec::new();\n    for ch in\
    \ brackets {\n        if ch == '(' || ch == ')' {\n            if stack.len()\
    \ > 0 {\n                if stack.last().unwrap() != ch {\n                  \
    \  return false;\n                }\n            } else {\n                stack.push(ch);\n\
    \            }\n        } else {\n            if stack.len() > 0 {\n         \
    \       if stack.last().unwrap() != ch {\n                    return false;\n\
    \                }\n            } else {\n                stack.push(ch);\n  \
    \          }\n        }\n    }\n    if stack.len() == 0 {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmptq7rhdue.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmptq7rhdue.rs:14:15\n   |\n14\
    \ |         if ch == '(' || ch == ')' {\n   |               ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmptq7rhdue.rs:14:28\n   |\n14 |         if ch\
    \ == '(' || ch == ')' {\n   |                            ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `str`\n  --> /tmp/tmptq7rhdue.rs:16:42\n   |\n16 |             \
    \    if stack.last().unwrap() != ch {\n   |                                  \
    \        ^^ no implementation for `&str == str`\n   |\n   = help: the trait `Partia"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for bracket_char in brackets.chars()\
    \ {\n        if stack.len() == 0 {\n            stack.unpush(bracket_char);\n\
    \        } else {\n            let mut last = stack.pop();\n            if last\
    \ == bracket_char {\n                continue;\n            }\n            stack.push(bracket_char);\n\
    \        }\n        if stack.len() == 0 {\n            return false;\n       \
    \ }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unpush` found for struct `Vec<_>` in the\
    \ current scope\n  --> /tmp/tmpbbk1p_0y.rs:15:19\n   |\n15 |             stack.unpush(bracket_char);\n\
    \   |                   ^^^^^^ help: there is an associated function with a similar\
    \ name: `push`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbbk1p_0y.rs:18:24\n\
    \   |\n18 |             if last == bracket_char {\n   |                      \
    \  ^^^^^^^^^^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<_>`\n              found type `char`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n18 |             if last == Some(bracket_char) {\n   |    \
    \                    +++++            +\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.find(\"(\") != brackets.find(\")\")\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpj4y4pgwv.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut paren_count = 0;\n    let mut bracket_count =\
    \ 0;\n    let mut depth = 0;\n    let mut open_brackets = String::new();\n\n \
    \   for bracket_index in brackets.char_indices().rev() {\n        let mut found_open_bracket\
    \ = false;\n\n        if bracket_index.1 > 0 && depth == 0 {\n            let\
    \ mut previous_open_bracket = open_brackets.clone();\n\n            while depth\
    \ == 0 && previous_open_bracket.len() > 0 {\n                open_brackets.push(previous_open_bracket);\n\
    \                previous_open_bracket = open_brackets.clone().pop();\n      \
    \      }\n        }\n\n        open_brackets.push(bracket_index.0);\n        depth++;\n\
    \n        for _ in 0..(depth - 1) {\n            if open_brackets.ends_with(\"\
    (\") {\n                paren_count++;\n                found_open_bracket = true;\n\
    \            } else {\n                bracket_count++;\n            }\n     \
    \   }\n\n        for _ in 0..(depth - 1) {\n            if open_brackets.ends_with(\"\
    )\") {\n                paren_count--;\n                found_open_bracket = true;\n\
    \            } else {\n                bracket_count--;\n            }\n     \
    \   }\n\n        if !found_open_bracket {\n            bracket_count++;\n    \
    \    }\n\n        if bracket_count != 0 && paren_count == 0 {\n            return\
    \ false;\n        }\n    }\n\n    paren_count == 0 && bracket_count == 0\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp15edz_n4.rs:30:14\n\
    \   |\n30 |         depth++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n30 |         { let tmp = depth; depth +=\
    \ 1; tmp };\n   |         +++++++++++      ~~~~~~~~~~~~~~~~~~~\n30 -         depth++;\n\
    30 +         depth += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp15edz_n4.rs:20:30\n\
    \   |\n20 |         if bracket_index.1 > 0 && depth == 0 {\n   |             \
    \                 ^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp15edz_n4.rs:24:36\n   |\n24 |                 open_brackets.push(previous_open_bracket);\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp15edz_n4.rs:25:41\n\
    \   |\n21 |             let mut previous_open_bracket = open_brackets.clone();\n\
    \   |                                             --------------------- expected\
    \ due to this value\n...\n25 |                 previous_open_bracket = open_brackets.clone().pop();\n\
    \   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp15edz_n4.rs:29:28\n   |\n29 |         open_brackets.push(bracket_index.0);\n\
    \   |                            ^^^^^^^^^^^^^^^ expected `char`, found `usize`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.contains(\"(\") && brackets.contains(\")\")\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptvgog3lx.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| {\n        if c == '(' || c\
    \ == '[' || c == '{' || c == '<' || c == '(' {\n            false\n        } else\
    \ if c == '[' || c == '{' || c == '<' || c == '(' {\n            true\n      \
    \  } else {\n            false\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkze763qi.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().any(|c| c.is_opening_bracket())\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_opening_bracket` found for type `char`\
    \ in the current scope\n  --> /tmp/tmprwq7f92y.rs:12:32\n   |\n12 |     brackets.chars().any(|c|\
    \ c.is_opening_bracket())\n   |                                ^^^^^^^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| *c != '(' || !(*c == ')'))\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpn19v12ki.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c != '(' || !(*c == ')'))\n   |    \
    \                          ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpn19v12ki.rs:12:45\n   |\n12 |     brackets.chars().all(|c| *c !=\
    \ '(' || !(*c == ')'))\n   |                                             ^^\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut iter = brackets.char_indices().peekable();\n\
    \    let mut stack: Vec<(char, char)> = Vec::new();\n    while let Some((index,\
    \ char)) = iter.next() {\n        if index != 0 && stack.last().is_none() {\n\
    \            stack.push((char, '('));\n        }\n        if index != 0 && stack.last().is_some()\
    \ {\n            if stack.last().unwrap() != ('(', char) {\n                stack.push((char,\
    \ '('));\n            }\n        }\n        if index != brackets.len() - 1 &&\
    \ stack.last().is_none() {\n            stack.push((char, ')'));\n        }\n\
    \        if index != brackets.len() - 1 && stack.last().is_some() {\n        \
    \    if stack.last().unwrap() != (')', char) {\n                stack.push((char,\
    \ ')'));\n            }\n        }\n    }\n    stack.len() == 0 && false\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&(char, char)` with `(char, char)`\n  -->\
    \ /tmp/tmp73tm6za8.rs:19:38\n   |\n19 |             if stack.last().unwrap() !=\
    \ ('(', char) {\n   |                                      ^^ no implementation\
    \ for `&(char, char) == (char, char)`\n   |\n   = help: the trait `PartialEq<(char,\
    \ char)>` is not implemented for `&(char, char)`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             ()\n             (A, B,\
    \ C, D, E, F, G, H, I, J, K, L)\n             (B, C, D, E, F, G, H, I, J, K, L)\n\
    \             (C, D, E, F, G, H, I, J, K, L)\n             (D, E, F, G, H, I,\
    \ J, K, L)\n             (E, F, G, H, I, J, K, L)\n             (F, G, H, I, J,\
    \ K, L)\n             (G, H, I, J, K, L)\n           and 5 others\n\nerror[E0277]:\
    \ can't compare `&(char, char)` with `(char, char)`\n  --> /tmp/tmp73tm6za8.rs:27:38\n\
    \   |\n27 |             if stack.last().unwrap() != (')', char) {\n   |      \
    \                                ^^ no implementation for `&(char, char) == (char,\
    \ char)`\n   |\n   = help: the trait `PartialEq<(char, char)>` is not implemented\
    \ for `&(char, char)`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             ()\n             (A, B, C, D, E, F, G, H, I, J, K, L)\n        \
    \     (B, C, D, E, F, G, H, I, J, K, L)\n             (C, D, E, F, G, H, I, J,\
    \ K, L)\n             (D, E, F, G, H, I, J, K, L)\n             (E, F, G, H, I,\
    \ J, K, L)\n             (F, G, H, I, J, K, L)\n             (G, H, I, J, K, L)\n\
    \           and 5 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // We have at most 2 brackets so this won't get out of\
    \ bounds for larger input\n    for char in brackets.chars().take(2) {\n      \
    \  let index = brackets.chars().skip(1).position(|c| *c == char).unwrap();\n \
    \       if index == 0 {\n            return true;\n        }\n        if index\
    \ == 1 {\n            return false;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp04v2xvgb.rs:14:59\n\
    \   |\n14 |         let index = brackets.chars().skip(1).position(|c| *c == char).unwrap();\n\
    \   |                                                           ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracketing = false;\n    let mut current = 1;\n\
    \    for c in &brackets[..] {\n        if c == '(' { bracketing = true; current\
    \ += 1 } else if c == '[' { bracketing = false; current += 1 } else if c == '{'\
    \ { bracketing = true; current += 1 } else if c == '}' { bracketing = false; current\
    \ += 1 } else {\n            current += 1;\n        }\n        if current == brackets.len()\
    \ {\n            bracketing = false;\n        }\n    }\n    bracketing\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&str` is not an iterator\n  --> /tmp/tmp_ipmt4re.rs:14:14\n\
    \   |\n14 |     for c in &brackets[..] {\n   |              ^^^^^^^^^^^^^ `&str`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `&str`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `&str`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut openings = String::new();\n    let mut closings\
    \ = String::new();\n    for i in brackets.char_indices() {\n        if *i == b'('\
    \ {\n            openings.push('(');\n        } else if *i == b']' {\n       \
    \     closings.push(']');\n        } else if *i == b'[' {\n            openings.push('[');\n\
    \        }\n    }\n    openings == closings\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `(usize, char)` cannot be dereferenced\n  --> /tmp/tmp_eb9_dks.rs:15:12\n\
    \   |\n15 |         if *i == b'(' {\n   |            ^^\n\nerror[E0614]: type\
    \ `(usize, char)` cannot be dereferenced\n  --> /tmp/tmp_eb9_dks.rs:17:19\n  \
    \ |\n17 |         } else if *i == b']' {\n   |                   ^^\n\nerror[E0614]:\
    \ type `(usize, char)` cannot be dereferenced\n  --> /tmp/tmp_eb9_dks.rs:19:19\n\
    \   |\n19 |         } else if *i == b'[' {\n   |                   ^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().filter(|c| *c == ' ' || c == '(' ||\
    \ c == '[' || c == ']' || c == '{' || c == '}').count() == brackets.len() - 3\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgjx6pxt3.rs:12:48\n\
    \   |\n12 |     brackets.chars().filter(|c| *c == ' ' || c == '(' || c == '['\
    \ || c == ']' || c == '{' || c == '}').count() == brackets.len() - 3\n   |   \
    \                                             ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpgjx6pxt3.rs:12:60\n   |\n12\
    \ |     brackets.chars().filter(|c| *c == ' ' || c == '(' || c == '[' || c ==\
    \ ']' || c == '{' || c == '}').count() == brackets.len() - 3\n   |           \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpgjx6pxt3.rs:12:72\n   |\n12\
    \ |     brackets.chars().filter(|c| *c == ' ' || c == '(' || c == '[' || c ==\
    \ ']' || c == '{' || c == '}').count() == brackets.len() - 3\n   |           \
    \                                                             ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgjx6pxt3.rs:12:84\n\
    \   |\n12 |     brackets.chars().filter(|c| *c == ' ' || c == '(' || c == '['\
    \ || c == ']' || c == '{' || c == '}').count() == brackets.len() - 3\n   |   \
    \                                                                            \
    \     ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgjx6pxt3.rs:12:96\n\
    \   |\n12 |     brackets.chars().filter(|c| *c == ' ' || c == '(' || c == '['\
    \ || c == ']' || c"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| *c == ')' || *c == '(')\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpuh9f9do5.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c == ')' || *c == '(')\n   |       \
    \                       ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpuh9f9do5.rs:12:43\n   |\n12 |     brackets.chars().all(|c| *c ==\
    \ ')' || *c == '(')\n   |                                           ^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all_matches(|c| *c == '(' || '*' ==\
    \ c)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `all_matches` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmp9sd4ayr2.rs:12:22\n   |\n12 |     brackets.chars().all_matches(|c|\
    \ *c == '(' || '*' == c)\n   |                      ^^^^^^^^^^^ method not found\
    \ in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        stack.push(c);\n        if stack.len() == 2 {\n            let mut\
    \ first = stack.pop();\n            let mut second = stack.pop();\n          \
    \  if *first == *second {\n                continue;\n            }\n        \
    \    if first == ')' {\n                stack.push(*first);\n            } else\
    \ {\n                stack.push(*second);\n            }\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `Option<char>` cannot be dereferenced\n  --> /tmp/tmpmrktkm1p.rs:18:16\n\
    \   |\n18 |             if *first == *second {\n   |                ^^^^^^\n\n\
    error[E0614]: type `Option<char>` cannot be dereferenced\n  --> /tmp/tmpmrktkm1p.rs:18:26\n\
    \   |\n18 |             if *first == *second {\n   |                         \
    \ ^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmrktkm1p.rs:21:25\n\
    \   |\n21 |             if first == ')' {\n   |                         ^^^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n\
    \              found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n21 |             if first == Some(')') {\n   |                        \
    \ +++++   +\n\nerror[E0614]: type `Option<char>` cannot be dereferenced\n  -->\
    \ /tmp/tmpmrktkm1p.rs:22:28\n   |\n22 |                 stack.push(*first);\n\
    \   |                            ^^^^^^\n\nerror[E0614]: type `Option<char>` cannot\
    \ be dereferenced\n  --> /tmp/tmpmrktkm1p.rs:24:28\n   |\n24 |               \
    \  stack.push(*second);\n   |                            ^^^^^^^\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    for ch in brackets {\n        if ch == '(' {\n       \
    \     open_brackets.push('(');\n        } else {\n            open_brackets.push(')');\n\
    \        }\n    }\n    let mut open_brackets_length = open_brackets.len();\n \
    \   for ch in open_brackets {\n        if ch == ')' {\n            closed_brackets.push(ch);\n\
    \        } else {\n            closed_brackets.push('(');\n        }\n    }\n\
    \    let mut closed_brackets_length = closed_brackets.len();\n    let mut i =\
    \ 0;\n    while i < closed_brackets_length {\n        if closed_brackets[i] !=\
    \ open_brackets[i] {\n            return false;\n        }\n        i += 1;\n\
    \    }\n    open_brackets_length == closed_brackets_length\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp0nwk7qlc.rs:14:15\n\
    \   |\n14 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmp0nwk7qlc.rs:22:15\n   |\n22 |   \
    \  for ch in open_brackets {\n   |               ^^^^^^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0nwk7qlc.rs:32:12\n\
    \   |\n32 |         if closed_brackets[i] != open_brackets[i] {\n   |        \
    \    ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0nwk7qlc.rs:32:34\n   |\n32 |         if closed_brackets[i] !=\
    \ open_brackets[i] {\n   |                                  ^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Ind"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut current = brackets.chars();\n\n    let mut open_count\
    \ = 0;\n    let mut close_count = 0;\n    let mut has_open = false;\n    let mut\
    \ has_close = false;\n\n    for ch in current.clone() {\n        match ch {\n\
    \            '(' if has_open => close_count += 1,\n            ')' if has_close\
    \ => open_count += 1,\n            _ => {}\n        }\n\n        if open_count\
    \ == close_count {\n            has_open += 1;\n            has_close += 1;\n\
    \        }\n    }\n\n    has_open && has_close\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `bool`\n  --> /tmp/tmp6dym1prg.rs:27:13\n   |\n27 |             has_open +=\
    \ 1;\n   |             --------^^^^^\n   |             |\n   |             cannot\
    \ use `+=` on type `bool`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `bool`\n  --> /tmp/tmp6dym1prg.rs:28:13\n   |\n28 |     \
    \        has_close += 1;\n   |             ---------^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `bool`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0368`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut has_pair = false;\n    let mut has_brackets =\
    \ false;\n    for char in brackets {\n        match char {\n            '(' |\
    \ ')' => has_pair = true,\n            '{' | '}' => has_brackets = true,\n   \
    \         c => return false,\n        }\n    }\n    has_pair && has_brackets\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpcdfzyfvi.rs:14:17\n\
    \   |\n14 |     for char in brackets {\n   |                 ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.len() == 0 && false\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi70hyhy8.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.chars().all(|c| *c == '(') {\n        brackets.iter().all(|c|\
    \ *c == ')')\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmphreerqo8.rs:12:33\n\
    \   |\n12 |     if brackets.chars().all(|c| *c == '(') {\n   |               \
    \                  ^^\n\nerror[E0599]: no method named `iter` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmphreerqo8.rs:13:18\n   |\n13 | \
    \        brackets.iter().all(|c| *c == ')')\n   |                  ^^^^ method\
    \ not found in `String`\n   |\nhelp: because of the in-memory representation of\
    \ `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \   |\n13 |         brackets.chars().all(|c| *c == ')')\n   |                \
    \  ~~~~~\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = [brackets[0]];\n    let mut in_bracket\
    \ = false;\n    for c in &brackets[1..] {\n        if c == '(' {\n           \
    \ in_bracket = true;\n        } else if c == ')' {\n            if !in_bracket\
    \ {\n                return false;\n            }\n            in_bracket = false;\n\
    \        } else if in_bracket {\n            stack.push(c);\n        } else {\n\
    \            if stack.is_empty() {\n                return false;\n          \
    \  }\n            stack.pop();\n        }\n    }\n    if stack.is_empty() {\n\
    \        false\n    } else {\n        true\n    }\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpqehlkk3e.rs:12:22\n   |\n12 |     let mut stack = [brackets[0]];\n \
    \  |                      ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: `&str` is not an iterator\n  --> /tmp/tmpqehlkk3e.rs:14:14\n\
    \   |\n14 |     for c in &brackets[1..] {\n   |              ^^^^^^^^^^^^^^ `&str`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `&str`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `&str`\n\nerror[E0599]:\
    \ no method named `push` found for array `[_; 1]` in the current scope\n  -->\
    \ /tmp/tmpqehlkk3e.rs:23:19\n   |\n23 |             stack.push(c);\n   |     \
    \              ^^^^ method not found in `[_; 1]`\n\nerror[E0599]: no method named\
    \ `pop` found for array `[_; 1]` in the current scope\n  --> /tmp/tmpqehlkk3e.rs:28:19\n\
    \   |\n28 |             stack.pop();\n   |                   ^^^ method not found\
    \ in `[_; 1]`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '(' || c == ')')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp16y27lge.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = CharacterStack::new();\n    let mut open\
    \ = Character::new('(', 0);\n    let mut close = Character::new(')', 0);\n   \
    \ for c in brackets {\n        if c == open.get_character() {\n            stack.push(open);\n\
    \            open = Character::new(c, stack.len());\n        } else {\n      \
    \      match stack.peek() {\n                Some(open) => match close {\n   \
    \                 Some(close) => c == close.get_character() || c == open.get_character()\
    \ || close.get_character() == open.get_character() ? stack.drop() : None,\n  \
    \                  None => stack.push(c),\n                },\n              \
    \  None => None,\n            }\n        }\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `stack`\n\
    \  --> /tmp/tmp3y5rffgn.rs:22:143\n   |\n22 | ...close) => c == close.get_character()\
    \ || c == open.get_character() || close.get_character() == open.get_character()\
    \ ? stack.drop() : None,\n   |           -- while parsing the `match` arm starting\
    \ here                                                                ^^^^^ expected\
    \ one of `,`, `.`, `?`, `}`, or an operator\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `CharacterStack`\n  --> /tmp/tmp3y5rffgn.rs:12:21\n \
    \  |\n12 |     let mut stack = CharacterStack::new();\n   |                  \
    \   ^^^^^^^^^^^^^^ use of undeclared type `CharacterStack`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Character`\n  --> /tmp/tmp3y5rffgn.rs:13:20\n\
    \   |\n13 |     let mut open = Character::new('(', 0);\n   |                 \
    \   ^^^^^^^^^ use of undeclared type `Character`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Character`\n  --> /tmp/tmp3y5rffgn.rs:14:21\n   |\n\
    14 |     let mut close = Character::new(')', 0);\n   |                     ^^^^^^^^^\
    \ use of undeclared type `Character`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Character`\n  --> /tmp/tmp3y5rffgn.rs:18:20\n   |\n18 |   \
    \          open = Character::new(c, stack.len());\n   |                    ^^^^^^^^^\
    \ use of undeclared type `Character`\n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmp3y5rffgn.rs:15:14\n   |\n15 |     for c in brackets {\n   |   \
    \           ^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3y5rffgn.rs:25:25\n   |\n16 |\
    \ /         if c == open.get_character() {\n17 | |             stack.push(open);\n\
    18 | |             open = Character::new(c, stack.len());\n19 | |         } else\
    \ {\n...  |\n25 | |                 None => None,\n   | |                    \
    \     ^^^^ expected `()`, "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.len() == 2 && brackets.chars().count(|x| x ==\
    \ ')') == brackets.chars().count(|x| x == '(')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp9tn2fig8.rs:12:45\n    |\n12  |     brackets.len() == 2 && brackets.chars().count(|x|\
    \ x == ')') == brackets.chars().count(|x| x == '(')\n    |                   \
    \                          ^^^^^ ------------ supplied 1 argument\n    |     \
    \                                        |\n    |                            \
    \                 expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp9tn2fig8.rs:12:85\n    |\n12  |     brackets.len() == 2 && brackets.chars().count(|x|\
    \ x == ')') == brackets.chars().count(|x| x == '(')\n    |                   \
    \                                                                  ^^^^^ ------------\
    \ supplied 1 argument\n    |                                                 \
    \                                    |\n    |                                \
    \                                                     expected 0 arguments\n \
    \   |\nnote: associated function defined here\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.len() == 0 {\n        return false;\n   \
    \ }\n\n    let mut opened = false;\n    let mut closed = false;\n    let mut i\
    \ = 0;\n\n    while i < brackets.len() {\n        let c = &brackets[i as usize];\n\
    \        if c == ')' {\n            closed = true;\n        } else if c == '('\
    \ {\n            opened = true;\n        } else if opened && closed {\n      \
    \      return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpr3dfb9pw.rs:21:18\n\
    \   |\n21 |         let c = &brackets[i as usize];\n   |                  ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpr3dfb9pw.rs:22:14\n\
    \   |\n22 |         if c == ')' {\n   |              ^^ no implementation for\
    \ `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpr3dfb9pw.rs:24:21\n\
    \   |\n24 |         } else if c == '(' {\n   |                     ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = CharacterStack::new();\n    for c in\
    \ brackets {\n        if c == ')' {\n            assert!(stack.is_empty());\n\
    \        } else if c == '(' {\n            stack.push(c);\n        } else {\n\
    \            assert!(!stack.is_empty());\n            stack.pop();\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `CharacterStack`\n\
    \  --> /tmp/tmp0cw50xs_.rs:12:21\n   |\n12 |     let mut stack = CharacterStack::new();\n\
    \   |                     ^^^^^^^^^^^^^^ use of undeclared type `CharacterStack`\n\
    \nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp0cw50xs_.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '(' || c == '{' || c ==\
    \ '[')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfeizu60t.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // This implementation is simpler than the one in parentheses.\n\
    \    // In particular, this implementation is correct for brackets containing\n\
    \    // no parentheses at all: e.g. (().\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    for char in brackets {\n      \
    \  match char {\n            '(' -> {\n                open_brackets.push(char);\n\
    \            }\n            ')' -> {\n                close_brackets.push(char);\n\
    \            }\n            _ => {\n                // This is not a \"(\" or\
    \ \"(\"; try opening again.\n                if open_brackets.len() > 0 {\n  \
    \                  open_brackets.pop();\n                } else {\n          \
    \          // This is not a \")\" or \"(\"; try closing again.\n             \
    \       if close_brackets.len() > 0 {\n                        close_brackets.pop();\n\
    \                    } else {\n                        panic!(\"Unbalanced brackets\
    \ in string: {}\", brackets);\n                    }\n                }\n    \
    \        }\n        }\n    }\n    open_brackets.len() + close_brackets.len() ==\
    \ brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found `->`\n\
    \  --> /tmp/tmpzz5bkwsg.rs:19:17\n   |\n19 |             '(' -> {\n   |      \
    \           ^^\n   |                 |\n   |                 expected one of `...`,\
    \ `..=`, `..`, `=>`, `if`, or `|`\n   |                 help: try using a fat\
    \ arrow here: `=>`\n\nerror: expected one of `...`, `..=`, `..`, `=>`, `if`, or\
    \ `|`, found `->`\n  --> /tmp/tmpzz5bkwsg.rs:22:17\n   |\n22 |             ')'\
    \ -> {\n   |                 ^^\n   |                 |\n   |                \
    \ expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`\n   |               \
    \  help: try using a fat arrow here: `=>`\n\nerror[E0277]: `String` is not an\
    \ iterator\n  --> /tmp/tmpzz5bkwsg.rs:17:17\n   |\n17 |     for char in brackets\
    \ {\n   |                 ^^^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut last_closing_bracket = String::new();\n    let\
    \ mut last_opening_bracket = String::new();\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '(' {\n            last_opening_bracket = bracket;\n\
    \        } else if bracket == ')' {\n            if last_opening_bracket.len()\
    \ > 0 {\n                last_opening_bracket.clear();\n            } else {\n\
    \                return false;\n            }\n        } else {\n            last_closing_bracket\
    \ = bracket;\n        }\n    }\n    last_opening_bracket.len() == 0 || last_opening_bracket.chars().any(|c|\
    \ *c != ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7eaciqd0.rs:16:36\n   |\n\
    13 |     let mut last_opening_bracket = String::new();\n   |                 \
    \                   ------------- expected due to this value\n...\n16 |      \
    \       last_opening_bracket = bracket;\n   |                                \
    \    ^^^^^^^- help: try using a conversion method: `.to_string()`\n   |      \
    \                              |\n   |                                    expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7eaciqd0.rs:24:36\n\
    \   |\n12 |     let mut last_closing_bracket = String::new();\n   |          \
    \                          ------------- expected due to this value\n...\n24 |\
    \             last_closing_bracket = bracket;\n   |                          \
    \          ^^^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \                                    |\n   |                                 \
    \   expected struct `String`, found `char`\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmp7eaciqd0.rs:27:77\n   |\n27 |     last_opening_bracket.len()\
    \ == 0 || last_opening_bracket.chars().any(|c| *c != ')')\n   |              \
    \                                                               ^^\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut close = brackets.clone();\n    close.truncate(1);\n\
    \    let open = brackets.clone();\n    open.truncate(1);\n    let mut index =\
    \ brackets.char_indices();\n    while let Some(index) = (index as Option<usize>).map(|index|\
    \ *index) {\n        if let Some(item) = open.get(index) {\n            if item\
    \ != ')' {\n                let mut i = index;\n                let mut opening\
    \ = brackets.get_mut(i);\n                let mut closing = brackets.get_mut(i);\n\
    \                *opening = '(';\n                *closing = ')';\n          \
    \  }\n        }\n        index += 1;\n    }\n    close.chars().all(|c| !open.get(c))\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpyj2wv99k.rs:17:66\n\
    \   |\n17 |     while let Some(index) = (index as Option<usize>).map(|index| *index)\
    \ {\n   |                                                                  ^^^^^^\n\
    \nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpyj2wv99k.rs:19:21\n\
    \   |\n19 |             if item != ')' {\n   |                     ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0614]: type `Option<&mut _>` cannot be dereferenced\n  -->\
    \ /tmp/tmpyj2wv99k.rs:23:17\n   |\n23 |                 *opening = '(';\n   |\
    \                 ^^^^^^^^\n\nerror[E0614]: type `Option<&mut _>` cannot be dereferenced\n\
    \  --> /tmp/tmpyj2wv99k.rs:24:17\n   |\n24 |                 *closing = ')';\n\
    \   |                 ^^^^^^^^\n\nerror[E0277]: the type `str` cannot be indexed\
    \ by `char`\n   --> /tmp/tmpyj2wv99k.rs:29:37\n    |\n29  |     close.chars().all(|c|\
    \ !open.get(c))\n    |                                 --- ^ string indices are\
    \ ranges of `usize`\n    |                                 |\n    |          \
    \                       required by a bound introduced by this call\n    |\n \
    \   = help: the trait `SliceIndex<str>` is not implemented for `char`\nnote: required\
    \ by a bound in `core::str::<impl str>::get`\n\nerror[E0600]: cannot apply unary\
    \ operator `!` to type `Option<&_>`\n  --> /tmp/tmpyj2wv99k.rs:29:27\n   |\n29\
    \ |     close.chars().all(|c| !open.get(c))\n   |                           ^^^^^^^^^^^^\
    \ cannot apply unary operator `!`\n\nerror[E0605]: non-primitive cast: `CharIndices<'_>`\
    \ as `Option<usize>`\n  --> /tmp/tmpyj2wv99k.rs:17:29\n   |\n17 |     while let\
    \ Some(index) = (index as Option<usize>).map(|index| *index) {\n   |         \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used\
    \ to convert between primitive types or to coerce to a specific trait object\n\
    \nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600, E0605, E0614.\nFor more information about an error, try `rustc\
    \ -"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Check every opening bracket has an opening bracket\n\
    \    let mut opening_brackets = String::new();\n    let mut opening_bracket =\
    \ String::new();\n    brackets.chars().for_each(|b| {\n        if opening_brackets.is_empty()\
    \ {\n            opening_bracket = String::from(b);\n        } else {\n      \
    \      opening_bracket = String::from_str(&format!(\"({})\", opening_bracket))\n\
    \                .unwrap();\n            if b != opening_bracket.chars().next().unwrap()\
    \ {\n                return false;\n            }\n            opening_brackets.clear();\n\
    \        }\n        opening_brackets.push_str(&opening_bracket);\n    });\n  \
    \  !opening_brackets.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `from_str` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpumr14o1h.rs:19:39\n   |\n\
    19 |             opening_bracket = String::from_str(&format!(\"({})\", opening_bracket))\n\
    \   |                                       ^^^^^^^^ function or associated item\
    \ not found in `String`\n   |\n   = help: items from traits can only be used if\
    \ the trait is in scope\nhelp: the following trait is implemented but not in scope;\
    \ perhaps add a `use` for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpumr14o1h.rs:22:24\n   |\n22 |              \
    \   return false;\n   |                        ^^^^^ expected `()`, found `bool`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.is_empty() || brackets[..1] == brackets[1..].to_chars().next()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_chars` found for type `str` in the current\
    \ scope\n  --> /tmp/tmpqvr3xs2c.rs:12:59\n   |\n12 |     brackets.is_empty() ||\
    \ brackets[..1] == brackets[1..].to_chars().next()\n   |                     \
    \                                      ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `chars`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets_iter = brackets.chars().nth(0).unwrap();\n\
    \    let mut brackets_end = brackets_iter.next();\n    let mut found_closing_bracket\
    \ = false;\n\n    while !brackets_end.unwrap().is_none() {\n        if brackets_end.unwrap().unwrap()\
    \ == ')' {\n            found_closing_bracket = true;\n        }\n        brackets_end.unwrap().next().unwrap().unwrap();\n\
    \    }\n\n    found_closing_bracket\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `next` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpvr4vc7ij.rs:13:42\n   |\n13 |     let mut brackets_end\
    \ = brackets_iter.next();\n   |                                          ^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == ')' || c == '(')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpz8v8zoit.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = brackets.chars();\n    let mut\
    \ closed_brackets = Vec::new();\n    let mut open_bracket = open_brackets.next();\n\
    \    while open_bracket != None {\n        if open_bracket.unwrap() == '(' {\n\
    \            closed_brackets.push(open_bracket.unwrap());\n            open_bracket\
    \ = open_brackets.next();\n        } else {\n            if closed_brackets.len()\
    \ == 0 {\n                return false;\n            }\n            let next_closing_bracket\
    \ = closed_brackets.last();\n            if open_bracket.unwrap() == ')' {\n \
    \               closed_brackets.pop();\n            } else {\n               \
    \ closed_brackets.push(next_closing_bracket);\n            }\n            open_bracket\
    \ = open_brackets.next();\n        }\n    }\n    closed_brackets.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpckf_l46u.rs:27:38\n   |\n\
    27 |                 closed_brackets.push(next_closing_bracket);\n   |       \
    \                               ^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum\
    \ `Option`\n   |\n   = note: expected type `char`\n              found enum `Option<&char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.len() != 2 {\n        return false;\n   \
    \ }\n    for char in brackets {\n        if char != '(' && char != ')' {\n   \
    \         return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpmu8i1x7x.rs:15:17\n\
    \   |\n15 |     for char in brackets {\n   |                 ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closed_brackets = String::new();\n    brackets.chars().for_each(|c| {\n    \
    \    if opening_brackets.len() == 0 {\n            if c == '(' || c == '[' ||\
    \ c == '{' || c == '<' || c == '>' || c == '\\'' {\n                opening_brackets.push(c);\n\
    \            } else if c == '}' || c == ']' || c == ']' || c == ']' || c == '>'\
    \ || c == ']' || c == '\\'' {\n                closed_brackets.push(c);\n    \
    \        } else {\n                return false;\n            }\n        } else\
    \ if c == '(' {\n            opening_brackets.push(c);\n        } else if c ==\
    \ ')' {\n            if closed_brackets.len() == 0 {\n                closed_brackets.push(c);\n\
    \            } else {\n                opening_brackets.pop();\n             \
    \   closed_brackets.pop();\n            }\n        } else if c == '[' {\n    \
    \        opening_brackets.push(c);\n        } else if c == ']' {\n           \
    \ if closed_brackets.len() == 0 {\n                closed_brackets.push(c);\n\
    \            } else {\n                opening_brackets.pop();\n             \
    \   closed_brackets.pop();\n            }\n        } else if c == '{' {\n    \
    \        opening_brackets.push(c);\n        } else if c == '}' {\n           \
    \ if closed_brackets.len() == 0 {\n                closed_brackets.push(c);\n\
    \            } else {\n                opening_brackets.pop();\n             \
    \   closed_brackets.pop();\n            }\n        } else if c == '<' {\n    \
    \        opening_brackets.push(c);\n        } else if c == '>' {\n           \
    \ if closed_brackets.len() == 0 {\n                closed_brackets.push(c);\n\
    \            } else {\n                opening_brackets.pop();\n             \
    \   closed_brackets.pop();\n            }\n        } else {\n            return\
    \ false;\n        }\n    });\n\n    if opening_brackets.len() != 0 {\n       \
    \ return false;\n    }\n    if closed_brackets.len() != 0 {\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpojl1qjxr.rs:21:24\n   |\n\
    21 |                 return false;\n   |                        ^^^^^ expected\
    \ `()`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut current = String::new();\n    for ch in brackets\
    \ {\n        if ch == '(' {\n            current += \"(\";\n        } else if\
    \ ch == ')' {\n            current += \")\";\n        } else if !current.is_empty()\
    \ {\n            // if we are still opening a bracket in the middle of a string\n\
    \            // then we have an error.\n            return false;\n        }\n\
    \    }\n    !current.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpsuga61ou.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c.is_digit(10))\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvwff0j0a.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.chars().count() != 0 {\n        brackets.chars().filter(|c|\
    \ c == '(' || c == '[' || c == '{').count() == brackets.len()\n    } else {\n\
    \        false\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpv7jy7ku1.rs:13:39\n\
    \   |\n13 |         brackets.chars().filter(|c| c == '(' || c == '[' || c == '{').count()\
    \ == brackets.len()\n   |                                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpv7jy7ku1.rs:13:51\n\
    \   |\n13 |         brackets.chars().filter(|c| c == '(' || c == '[' || c == '{').count()\
    \ == brackets.len()\n   |                                                   ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpv7jy7ku1.rs:13:63\n\
    \   |\n13 |         brackets.chars().filter(|c| c == '(' || c == '[' || c == '{').count()\
    \ == brackets.len()\n   |                                                    \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket_stack = vec!['b'];\n    let mut parentheses_open:\
    \ i32 = 0;\n    let mut parentheses_close: i32 = 0;\n\n    let mut open_brackets\
    \ = brackets.split_whitespace();\n    let mut close_brackets = open_brackets.clone();\n\
    \n    while bracket_stack.len() > 0 {\n        if close_brackets.len() == 0 {\n\
    \            // we hit an open bracket with no corresponding closing bracket\n\
    \            return false;\n        }\n\n        if open_brackets.len() == 0 {\n\
    \            // we have hit the closing bracket of the last bracket we've looked\
    \ at\n            bracket_stack.pop();\n            close_brackets.pop();\n  \
    \          parentheses_close += 1;\n        }\n\n        if open_brackets.len()\
    \ > 0 && close_brackets.len() == 0 {\n            // we have hit a closing bracket\
    \ without an opening bracket\n            bracket_stack.pop();\n            parentheses_open\
    \ += 1;\n        }\n\n        if open_brackets.len() == 1 && close_brackets.len()\
    \ == 1 {\n            // we have hit an opening bracket and closed a bracket\n\
    \            bracket_stack.pop();\n            close_brackets.pop();\n       \
    \     parentheses_close += 1;\n        }\n\n        // we have a pair of brackets\
    \ open/close\n        let open_bracket = open_brackets.next().unwrap();\n    \
    \    let close_bracket = close_brackets.next().unwrap();\n\n        if close_bracket\
    \ == open_bracket.chars().next().unwrap() {\n            // we have hit the same\
    \ opening bracket twice\n            close_brackets.pop();\n            bracket_stack.push(close_bracket);\n\
    \            parentheses_close += 1;\n        } else {\n            // we have\
    \ hit an opening bracket and a matching closing bracket\n            bracket_stack.push(close_bracket);\n\
    \            parentheses_close += 1;\n        }\n    }\n\n    parentheses_open\
    \ > 0 && parentheses_close == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpjczxslrb.rs:20:27\n   |\n20 |         if\
    \ close_brackets.len() == 0 {\n   |                           ^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `len` found for struct\
    \ `SplitWhitespace` in the current scope\n  --> /tmp/tmpjczxslrb.rs:25:26\n  \
    \ |\n25 |         if open_brackets.len() == 0 {\n   |                        \
    \  ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named\
    \ `pop` found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpjczxslrb.rs:28:28\n\
    \   |\n28 |             close_brackets.pop();\n   |                          \
    \  ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named\
    \ `len` found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpjczxslrb.rs:32:26\n\
    \   |\n32 |         if open_brackets.len() > 0 && close_brackets.len() == 0 {\n\
    \   |                          ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpjczxslrb.rs:32:54\n   |\n32 |         if open_brackets.len()\
    \ > 0 && close_brackets.len() == 0 {\n   |                                   \
    \                   ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpjczxslrb.rs:38:26\n   |\n38 |         if open_brackets.len() ==\
    \ 1 && close_brackets.len() == 1 {\n   |                          ^^^ method not\
    \ found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `len` found\
    \ for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpjczxslrb.rs:38:55\n\
    \   |\n38 |         if open_brackets.len() == 1 && close_brackets.len() == 1 {\n\
    \   |                                                       ^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `pop` found for struct\
    \ `SplitWhitespace` in the current scope\n  --> /tmp/tmpjczxslrb.rs:41:28\n  \
    \ |\n41 | "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.contains('(') && brackets.contains(')')\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpijhwcdjf.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n\n    open_brackets.push_str(brackets);\n    close_brackets.push_str(\"\
    )\");\n\n    for index in 0..brackets.len() {\n        let open = open_brackets.chars().next().unwrap();\n\
    \        let close = close_brackets.chars().next().unwrap();\n\n        if open\
    \ != close {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplro74syz.rs:15:28\n   |\n\
    15 |     open_brackets.push_str(brackets);\n   |                            ^^^^^^^^\n\
    \   |                            |\n   |                            expected `&str`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&brackets`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n\n    for ch in &brackets {\n        if ch == '(' {\n    \
    \        open_brackets.push('(');\n            close_brackets.push(')');\n   \
    \     }\n        if ch == ')' {\n            open_brackets.push(')');\n      \
    \      close_brackets.push('(');\n        }\n    }\n\n    open_brackets.len()\
    \ = close_brackets.len();\n    open_brackets.chars().all(|c| close_brackets.contains(c))\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmphnys9o5n.rs:15:15\n\
    \   |\n15 |     for ch in &brackets {\n   |               ^^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror[E0070]: invalid left-hand side of assignment\n\
    \  --> /tmp/tmphnys9o5n.rs:26:25\n   |\n26 |     open_brackets.len() = close_brackets.len();\n\
    \   |     ------------------- ^\n   |     |\n   |     cannot assign to this expression\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0070, E0277.\nFor more information about an error, try `rustc --explain E0070`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut has_unpaired_parentheses = false;\n    for char\
    \ in &brackets {\n        if char == '(' {\n            if !has_unpaired_parentheses\
    \ {\n                has_unpaired_parentheses = true;\n            }\n       \
    \ }\n        if char == ')' {\n            if has_unpaired_parentheses {\n   \
    \             has_unpaired_parentheses = false;\n            }\n        }\n  \
    \  }\n    has_unpaired_parentheses\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpzwvjl_yb.rs:13:17\n\
    \   |\n13 |     for char in &brackets {\n   |                 ^^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| *c == '(')\n        && brackets.chars().all(|c|\
    \ *c == ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp9m3eafwz.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c == '(')\n   |                    \
    \          ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp9m3eafwz.rs:13:37\n\
    \   |\n13 |         && brackets.chars().all(|c| *c == ')')\n   |             \
    \                        ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut it = brackets.char_indices().map(|(idx, _)| idx).collect::<Vec<_>>();\n\
    \    let mut close_bracket = 0;\n    let mut open_bracket = 0;\n\n    for idx\
    \ in 0..it.len() {\n        if it[idx] == '(' {\n            open_bracket = idx;\n\
    \        }\n        if it[idx + 1] == ')' {\n            close_bracket = idx;\n\
    \        }\n        if open_bracket > close_bracket {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl6mo78_d.rs:17:23\n   |\n\
    17 |         if it[idx] == '(' {\n   |                       ^^^ expected `usize`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl6mo78_d.rs:20:27\n\
    \   |\n20 |         if it[idx + 1] == ')' {\n   |                           ^^^\
    \ expected `usize`, found `char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.is_empty() {\n        false\n    } else if\
    \ brackets.chars().any(|c| c == ',') {\n        false\n    } else {\n        let\
    \ mut open_brackets = brackets.chars();\n        let mut close_brackets = brackets.chars();\n\
    \        open_brackets.next().unwrap(); // eat up first bracket\n        close_brackets.next().unwrap();\
    \ // eat up first bracket\n        loop {\n            let mut cur = open_brackets.next();\n\
    \            if cur == None {\n                return false;\n            }\n\
    \            let mut next = close_brackets.next();\n            if next == None\
    \ {\n                // We have a complete match.\n                open_brackets\
    \ = open_brackets.chain(next);\n                close_brackets = close_brackets.chain(cur);\n\
    \                continue;\n            }\n            if cur == None || next\
    \ == None || cur == next {\n                // We don't have a complete match.\
    \ Eat up both brackets.\n                open_brackets = open_brackets.chain(next);\n\
    \                close_brackets = close_brackets.chain(cur);\n               \
    \ continue;\n            }\n            if cur == ','.into() && next == ')'.into()\
    \ {\n                // We have a complete match but both brackets are open. Eat\
    \ up only one.\n                open_brackets = open_brackets.chain(next);\n \
    \               continue;\n            }\n            // We have a complete match.\n\
    \            if open_brackets == close_brackets {\n                // We have\
    \ a complete match but both brackets are close. Eat up only one.\n           \
    \     close_brackets = close_brackets.chain(cur);\n                continue;\n\
    \            }\n            if open_brackets.is_empty() || close_brackets.is_empty()\
    \ {\n                // We didn't have a complete match. Eat up both brackets.\n\
    \                open_brackets = open_brackets.chain(next);\n                close_brackets\
    \ = close_brackets.chain(cur);\n                continue;\n            }\n   \
    \         if open_brackets.next() == None || close_brackets.next() == None {\n\
    \                // We didn't have a complete match. Eat up both brackets.\n \
    \               open_brackets = open_brackets.chain(next);\n                close_brackets\
    \ = close_brackets.chain(cur);\n                continue;\n            }\n   \
    \         if open_brackets.next() == Some(')') && close_brackets.next() == Some(')')\
    \ {\n\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzzi4hkd5.rs:80:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n16 |     }\
    \ else {\n   |            - unclosed delimiter\n...\n21 |         loop {\n   |\
    \              - unclosed delimiter\n...\n62 |             if open_brackets.next()\
    \ == Some(')') && close_brackets.next() == Some(')') {\n   |                 \
    \                                                                       - this\
    \ delimiter might not be properly closed...\n63 | \n64 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n80 | }\n   |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzzi4hkd5.rs:29:33\n   |\n17 |         let mut\
    \ open_brackets = brackets.chars();\n   |                                 ----------------\
    \ expected due to this value\n...\n29 |                 open_brackets = open_brackets.chain(next);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Chars`, found struct `std::iter::Chain`\n   |\n   = note: expected struct `Chars<'_>`\n\
    \              found struct `std::iter::Chain<Chars<'_>, std::option::IntoIter<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzzi4hkd5.rs:30:34\n   |\n18 |\
    \         let mut close_brackets = brackets.chars();\n   |                   \
    \               ---------------- expected due to this value\n...\n30 |       \
    \          close_brackets = close_brackets.chain(cur);\n   |                 \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Chars`, found struct\
    \ `std::iter::Chain`\n   |\n   = note: expected struct `Chars<'_>`\n         \
    \     found struct `std::iter::Chain<Chars<'_>, std::option::IntoIter<char>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzzi4hkd5.rs:35:33\n   |\n17 |\
    \         let mut open_brackets = brackets.chars();\n   |                    \
    \             ---------------- expected due to this value\n...\n35 |         \
    \        open_brackets = open_brackets.chain(next);\n   |                    \
    \             ^^^^^^^^^^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut current_count = 1;\n    let mut brackets = brackets;\n\
    \    loop {\n        if let Some(b) = brackets.find('(') {\n            if let\
    \ Some(e) = brackets.find(')') {\n                if b > e {\n               \
    \     current_count += 1;\n                    brackets = String::from(\")\" +\
    \ brackets[b..]);\n                }\n            } else {\n                if\
    \ b >= 0 {\n                    current_count += 1;\n                    brackets\
    \ = String::from(\"(\" + brackets[b..]);\n                }\n            }\n \
    \       }\n        if brackets.is_empty() {\n            break;\n        }\n \
    \   }\n    current_count == 1\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `str` to `&str`\n  --> /tmp/tmpy38oxgq_.rs:19:49\n\
    \   |\n19 |                     brackets = String::from(\")\" + brackets[b..]);\n\
    \   |                                             --- ^ ------------- str\n  \
    \ |                                             |\n   |                      \
    \                       &str\n\nerror[E0369]: cannot add `str` to `&str`\n  -->\
    \ /tmp/tmpy38oxgq_.rs:24:49\n   |\n24 |                     brackets = String::from(\"\
    (\" + brackets[b..]);\n   |                                             --- ^\
    \ ------------- str\n   |                                             |\n   |\
    \                                             &str\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![true; 1];\n    for i in 1..brackets.len()\
    \ {\n        if !stack[stack.length - 1] && brackets[i] == '(' {\n           \
    \ stack[stack.length - 1] = true;\n        }\n        if stack[stack.length -\
    \ 1] && brackets[i] == ')' {\n            stack[stack.length - 1] = false;\n \
    \       }\n    }\n    stack[0]\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0609]: no field `length` on type `Vec<bool>`\n  --> /tmp/tmprz8frghr.rs:14:25\n\
    \   |\n14 |         if !stack[stack.length - 1] && brackets[i] == '(' {\n   |\
    \                         ^^^^^^ unknown field\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmprz8frghr.rs:14:40\n   |\n14 |  \
    \       if !stack[stack.length - 1] && brackets[i] == '(' {\n   |            \
    \                            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0609]: no field `length` on type `Vec<bool>`\n  --> /tmp/tmprz8frghr.rs:15:25\n\
    \   |\n15 |             stack[stack.length - 1] = true;\n   |                \
    \         ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type `Vec<bool>`\n\
    \  --> /tmp/tmprz8frghr.rs:17:24\n   |\n17 |         if stack[stack.length - 1]\
    \ && brackets[i] == ')' {\n   |                        ^^^^^^ unknown field\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprz8frghr.rs:17:39\n\
    \   |\n17 |         if stack[stack.length - 1] && brackets[i] == ')' {\n   | \
    \                                      ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    stack.resize(brackets.len(),\
    \ -1);\n\n    for paren in brackets {\n        stack[paren.chars().next().unwrap()\
    \ as usize] = paren;\n        if paren != ')' {\n            return false;\n \
    \       }\n        if paren != '(' {\n            return true;\n        }\n\n\
    \        if !stack.iter().all(|x| stack[x] == paren) {\n            return false;\n\
    \        }\n\n    }\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpd0rossbg.rs:13:34\n\
    \   |\n13 |     stack.resize(brackets.len(), -1);\n   |                      \
    \            ^^\n   |                                  |\n   |               \
    \                   cannot apply unary operator `-`\n   |                    \
    \              help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmpd0rossbg.rs:15:18\n   |\n15 |     for paren\
    \ in brackets {\n   |                  ^^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not\
    \ implemented for `String`\n   = note: required because of the requirements on\
    \ the impl of `IntoIterator` for `String`\n\nerror[E0277]: the type `[usize]`\
    \ cannot be indexed by `&usize`\n  --> /tmp/tmpd0rossbg.rs:24:34\n   |\n24 | \
    \        if !stack.iter().all(|x| stack[x] == paren) {\n   |                 \
    \                 ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[usize]>` is not implemented for `&usize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&usize>` for `Vec<usize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut char_set = String::new();\n    char_set.push('#');\n\
    \    char_set.push('(');\n    char_set.push(')');\n    char_set.push('[');\n \
    \   char_set.push(']');\n    char_set.push('{');\n    char_set.push(\"}\");\n\
    \    for c in &brackets {\n        if char_set.contains(c) {\n            char_set.push(c);\n\
    \        } else {\n            char_set.push('[');\n        }\n    }\n    char_set.push_str(\"\
    ]\");\n    char_set.contains_slice(&brackets)\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptb3vmwz2.rs:19:19\n   |\n\
    19 |     char_set.push(\"}\");\n   |                   ^^^ expected `char`, found\
    \ `&str`\n   |\nhelp: if you meant to write a `char` literal, use single quotes\n\
    \   |\n19 |     char_set.push('}');\n   |                   ~~~\n\nerror[E0277]:\
    \ `&String` is not an iterator\n  --> /tmp/tmptb3vmwz2.rs:20:14\n   |\n20 |  \
    \   for c in &brackets {\n   |              ^^^^^^^^^ `&String` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&String`\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `&String`\n\nerror[E0599]: no method named `contains_slice` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmptb3vmwz2.rs:28:14\n   |\n28 | \
    \    char_set.contains_slice(&brackets)\n   |              ^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `contains`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets;\n    while !brackets.is_empty()\
    \ {\n        let bracket = brackets.chars().next().unwrap();\n        let next_char\
    \ = brackets.chars().next().unwrap();\n        if next_char == bracket {\n   \
    \         if bracket == '(' {\n                // closing brackets can't have\
    \ opening brackets inside them\n                brackets = brackets.replace(\"\
    )\", \"\").trim();\n            } else if bracket == ')' {\n                brackets\
    \ = brackets.replace(\"(\", \"\").trim();\n            } else {\n            \
    \    return false;\n            }\n        } else {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0dn4li64.rs:19:28\n   |\n\
    12 |     let mut brackets = brackets;\n   |                        -------- expected\
    \ due to this value\n...\n19 |                 brackets = brackets.replace(\"\
    )\", \"\").trim();\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \          |\n   |                            expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0dn4li64.rs:21:28\n\
    \   |\n12 |     let mut brackets = brackets;\n   |                        --------\
    \ expected due to this value\n...\n21 |                 brackets = brackets.replace(\"\
    (\", \"\").trim();\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \          |\n   |                            expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut openings: Vec<_> = brackets.split_whitespace().collect();\n\
    \    openings.sort_unstable();\n    let mut closings: Vec<_> = brackets.split_whitespace().collect();\n\
    \    closings.sort_unstable();\n    while openings.len() != 0 || closings.len()\
    \ != 0 {\n        if openings.len() == 0 && (closings.len() == 0 || closings[0]\
    \ == openings[0]) {\n            openings.pop();\n        } else if closings.len()\
    \ == 0 {\n            closings.pop();\n        } else {\n            if closings[0]\
    \ == openings[0] {\n                openings.pop();\n                closings.pop();\n\
    \            } else {\n                openings.push(openings[0]);\n         \
    \       closings.push(closings[0]);\n                openings.pop();\n       \
    \         closings.pop();\n            }\n        }\n    }\n    !openings.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8remb__l.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n\n    for bracket in brackets.chars().filter_map(|c|\
    \ match c {\n        c if c == '(' || c == '[' => {\n            opening_brackets.push(c);\n\
    \            Some(true)\n        }\n        c if c == ')' || c == ']' => {\n \
    \           closing_brackets.push(c);\n            Some(true)\n        }\n   \
    \     _ => None,\n    }) {\n        if opening_brackets.len() != closing_brackets.len()\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `bracket`\n  --> /tmp/tmpq2ygpdw9.rs:15:9\n \
    \  |\n15 |     for bracket in brackets.chars().filter_map(|c| match c {\n   |\
    \         ^^^^^^^ help: if this is intentional, prefix it with an underscore:\
    \ `_bracket`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0502]:\
    \ cannot borrow `opening_brackets` as immutable because it is also borrowed as\
    \ mutable\n  --> /tmp/tmpq2ygpdw9.rs:26:12\n   |\n15 |       for bracket in brackets.chars().filter_map(|c|\
    \ match c {\n   |                      -                           --- mutable\
    \ borrow occurs here\n   |  ____________________|\n   | |\n16 | |         c if\
    \ c == '(' || c == '[' => {\n17 | |             opening_brackets.push(c);\n  \
    \ | |             ---------------- first borrow occurs due to use of `opening_brackets`\
    \ in closure\n18 | |             Some(true)\n...  |\n24 | |         _ => None,\n\
    25 | |     }) {\n   | |______- mutable borrow later used here\n26 |          \
    \ if opening_brackets.len() != closing_brackets.len() {\n   |              ^^^^^^^^^^^^^^^^^^^^^^\
    \ immutable borrow occurs here\n\nerror[E0502]: cannot borrow `closing_brackets`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpq2ygpdw9.rs:26:38\n\
    \   |\n15 |       for bracket in brackets.chars().filter_map(|c| match c {\n \
    \  |                      -                           --- mutable borrow occurs\
    \ here\n   |  ____________________|\n   | |\n16 | |         c if c == '(' || c\
    \ == '[' => {\n17 | |             opening_brackets.push(c);\n18 | |          \
    \   Some(true)\n...  |\n21 | |             closing_brackets.push(c);\n   | | \
    \            ---------------- first borrow occurs due to use of `closing_brackets`\
    \ in closure\n...  |\n24 | |         _ => None,\n25 | |     }) {\n   | |______-\
    \ mutable borrow later used here\n26 |           if opening_brackets.len() !=\
    \ closing_brackets.len() {\n   |                                        ^^^^^^^^^^^^^^^^^^^^^^\
    \ immutable borrow occurs here\n\nerror: aborting due to 2 previous errors; 1\
    \ warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec!['('];\n    let mut open_brackets\
    \ = 0;\n    for c in brackets.chars() {\n        if c == '(' {\n            stack.push('(');\n\
    \            open_brackets += 1;\n        }\n        if c == ')' {\n         \
    \   if open_brackets == 0 {\n                return false;\n            }\n  \
    \          stack.pop();\n            open_brackets -= 1;\n        }\n    }\n \
    \   stack.len() == 0 && open_brackets == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdpa037qv.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets_stack = vec![String::new(); 1];\n  \
    \  let mut opening_count = 1;\n\n    for bracket in brackets.chars() {\n     \
    \   if bracket == '(' {\n            opening_count += 1;\n            brackets_stack.push(bracket);\n\
    \        } else if bracket == ')' {\n            if opening_count > 0 {\n    \
    \            opening_count -= 1;\n                if opening_count == 0 {\n  \
    \                  brackets_stack.pop();\n                }\n            }\n \
    \       } else if opening_count == 0 {\n            return false;\n        }\n\
    \    }\n\n    opening_count == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp996v9iis.rs:18:33\n   |\n\
    18 |             brackets_stack.push(bracket);\n   |                         \
    \        ^^^^^^^- help: try using a conversion method: `.to_string()`\n   |  \
    \                               |\n   |                                 expected\
    \ struct `String`, found `char`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().enumerate().any(|(idx, c)| {\n     \
    \   c != '(' && c != ')'\n    })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzfk76boh.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().any(|c| c == b'(' || c == b'[')\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp30hh8nhn.rs:12:35\n   |\n\
    12 |     brackets.chars().any(|c| c == b'(' || c == b'[')\n   |              \
    \                     ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp30hh8nhn.rs:12:48\n   |\n12 |     brackets.chars().any(|c|\
    \ c == b'(' || c == b'[')\n   |                                              \
    \  ^^^^ expected `char`, found `u8`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut s = brackets;\n    while !s.is_empty() {\n  \
    \      if s.starts_with(\"(\") {\n            if s.ends_with(\")\")\n        \
    \        || s.ends_with(\"]\") || s.ends_with(\")\")\n            {\n        \
    \        return true;\n            }\n        }\n        if s.starts_with(\"[\"\
    ) {\n            if s.ends_with(\"]\") || s.ends_with(\"]\")\n               \
    \ || s.ends_with(\"]\")\n                || s.ends_with(\"[\")\n            {\n\
    \                return true;\n            }\n        }\n        s = s.trim();\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp39usvhe5.rs:29:13\n   |\n\
    12 |     let mut s = brackets;\n   |                 -------- expected due to\
    \ this value\n...\n29 |         s = s.trim();\n   |             ^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |             |\n   |    \
    \         expected struct `String`, found `&str`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().any(|c| *c == ')')\n        && brackets.chars().all(|c|\
    \ *c != '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpfe7oimll.rs:12:30\n\
    \   |\n12 |     brackets.chars().any(|c| *c == ')')\n   |                    \
    \          ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpfe7oimll.rs:13:37\n\
    \   |\n13 |         && brackets.chars().all(|c| *c != '(')\n   |             \
    \                        ^^\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<&str> = vec![];\n    for bracket in\
    \ brackets.chars() {\n        if bracket == '(' || bracket == '[' || bracket ==\
    \ '<' {\n            stack.push(bracket);\n        } else if bracket == ')' ||\
    \ bracket == ']' || bracket == '>' {\n            if !stack.is_empty() && &stack[stack.len()\
    \ - 1] == bracket {\n                stack.pop();\n            } else {\n    \
    \            return false;\n            }\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt_0d1p25.rs:15:24\n   |\n\
    15 |             stack.push(bracket);\n   |                        ^^^^^^^ expected\
    \ `&str`, found `char`\n\nerror[E0277]: can't compare `&&str` with `char`\n  -->\
    \ /tmp/tmpt_0d1p25.rs:17:61\n   |\n17 |             if !stack.is_empty() && &stack[stack.len()\
    \ - 1] == bracket {\n   |                                                    \
    \         ^^ no implementation for `&&str == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&&str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == ')' || c == '(')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvwnljodu.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.len() != 0 &&\n        brackets.chars().all(|c|\
    \ c == '(' || c == '[')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp08a5i91_.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '(' || c == ')')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzhrk9m9c.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '(' || c == '[' || c ==\
    \ '{')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9yifviaj.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<_> = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == ')' {\n            if stack.is_empty() {\n             \
    \   return false;\n            }\n            stack.pop();\n        } else if\
    \ ch == '(' {\n            stack.push((ch, &brackets));\n        } else {\n  \
    \          return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1952tcks.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening = false\n    let mut closing = false\n\
    \    for c in brackets {\n        if opening.is_none() && closing\n          \
    \  && c == ')'\n            && brackets.len() == opening.as_ref().unwrap().as_ref().len()\n\
    \        {\n            closing = false\n        } else if opening.is_some() &&\
    \ closing\n            && c == '('\n            && brackets.len() == opening.as_ref().unwrap().as_ref().len()\n\
    \        {\n            closing = false\n        } else {\n            opening\
    \ += c == '('\n            closing += c == ')'\n        }\n    }\n    !opening.is_none()\
    \ && !closing\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n   \
    \ assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpcla52xnu.rs:12:28\n\
    \   |\n12 |     let mut opening = false\n   |                            ^ help:\
    \ add `;` here\n13 |     let mut closing = false\n   |     --- unexpected token\n\
    \nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpcla52xnu.rs:13:28\n\
    \   |\n13 |     let mut closing = false\n   |                            ^ help:\
    \ add `;` here\n14 |     for c in brackets {\n   |     --- unexpected token\n\n\
    error: expected `;`, found `closing`\n  --> /tmp/tmpcla52xnu.rs:26:32\n   |\n\
    26 |             opening += c == '('\n   |                                ^ help:\
    \ add `;` here\n27 |             closing += c == ')'\n   |             -------\
    \ unexpected token\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpcla52xnu.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]: no\
    \ method named `is_none` found for type `bool` in the current scope\n  --> /tmp/tmpcla52xnu.rs:15:20\n\
    \   |\n15 |         if opening.is_none() && closing\n   |                    ^^^^^^^\
    \ method not found in `bool`\n\nerror[E0599]: no method named `as_ref` found for\
    \ type `bool` in the current scope\n  --> /tmp/tmpcla52xnu.rs:17:42\n   |\n17\
    \ |             && brackets.len() == opening.as_ref().unwrap().as_ref().len()\n\
    \   |                                          ^^^^^^ method not found in `bool`\n\
    \nerror[E0599]: no method named `is_some` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmpcla52xnu.rs:20:27\n   |\n20 |         } else if opening.is_some()\
    \ && closing\n   |                           ^^^^^^^ method not found in `bool`\n\
    \nerror[E0599]: no method named `as_ref` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmpcla52xnu.rs:22:42\n   |\n22 |             && brackets.len()\
    \ == opening.as_ref().unwrap().as_ref().len()\n   |                          \
    \               "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Special case: If brackets is empty, return false.\n\
    \    if brackets == \"\" {\n        return false;\n    }\n\n    let mut last_opening_bracket\
    \ = false;\n\n    for c in brackets.chars().cloned() {\n        if c == '(' {\n\
    \            last_opening_bracket = true;\n        } else if c == '[' {\n    \
    \        last_opening_bracket = true;\n        } else if c == '{' {\n        \
    \    last_opening_bracket = true;\n        } else if c == '>' {\n            last_opening_bracket\
    \ = true;\n        } else if c == '<' {\n            last_opening_bracket = true;\n\
    \        } else if c == ')' {\n            last_opening_bracket = false;\n   \
    \     } else if c == ']' {\n            last_opening_bracket = false;\n      \
    \  } else if c == '}' {\n            last_opening_bracket = false;\n        }\
    \ else if c == '#' {\n            last_opening_bracket = false;\n        } else\
    \ if c == '%' {\n            last_opening_bracket = false;\n        } else if\
    \ c == '<' {\n            last_opening_bracket = false;\n        } else if c ==\
    \ '>' {\n            last_opening_bracket = false;\n        } else if c == '='\
    \ {\n            last_opening_bracket = false;\n        } else {\n           \
    \ last_opening_bracket = false;\n        }\n    }\n    return !last_opening_bracket;\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpnhbvjct4.rs:19:31\n     |\n19   |     for c in brackets.chars().cloned()\
    \ {\n     |                               ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpnhbvjct4.rs:19:14\n\
    \   |\n19 |     for c in brackets.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpnhbvjct4.rs:19:14\n   |\n19 |     for c in brackets.chars().cloned()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n    for char in brackets {\n        if char == ('(') {\n \
    \           open_brackets.push_str(\"(\");\n        } else if char == (')') {\n\
    \            close_brackets.push_str(\")\");\n        } else {\n            return\
    \ false;\n        }\n    }\n    if open_brackets == close_brackets {\n       \
    \ return true;\n    }\n    else {\n        return false;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpb_3x3cey.rs:14:17\n\
    \   |\n14 |     for char in brackets {\n   |                 ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut seen_brackets = false;\n    let mut brackets\
    \ = brackets.to_string();\n    while brackets.len() > 2 {\n        if brackets.starts_with(\"\
    (\") {\n            seen_brackets = true;\n        }\n        brackets = brackets.replace(\"\
    )\", \"\");\n        brackets = brackets.replace(\"(\", \"\");\n    }\n    seen_brackets\
    \ == true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxbc3jt4s.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = brackets.chars().filter(|c|\
    \ c != '(').collect::<Vec<_>>();\n    let mut closing_brackets = brackets.chars().filter(|c|\
    \ c != ')').collect::<Vec<_>>();\n    opening_brackets.reverse();\n    closing_brackets.reverse();\n\
    \    if opening_brackets.len() != closing_brackets.len() {\n        return false;\n\
    \    }\n    for i in 0..opening_brackets.len() {\n        if opening_brackets[i]\
    \ != closing_brackets[i] + 1 {\n            return false;\n        }\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpdanej2wc.rs:12:62\n\
    \   |\n12 |     let mut opening_brackets = brackets.chars().filter(|c| c != '(').collect::<Vec<_>>();\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpdanej2wc.rs:13:62\n\
    \   |\n13 |     let mut closing_brackets = brackets.chars().filter(|c| c != ')').collect::<Vec<_>>();\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmpdanej2wc.rs:20:55\n\
    \   |\n20 |         if opening_brackets[i] != closing_brackets[i] + 1 {\n   |\
    \                                   ------------------- ^ - {integer}\n   |  \
    \                                 |\n   |                                   char\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut last_open_bracket: Option<usize> = None;\n  \
    \  brackets.chars().for_each(|c|\n        if c == ')' {\n            last_open_bracket\
    \ = Some(last_open_bracket.unwrap() + 1);\n        } else if c == '(' {\n    \
    \        if let Some(last_open) = last_open_bracket {\n                if last_open\
    \ > c {\n                    last_open_bracket = Some(last_open + 1);\n      \
    \          }\n            }\n        }\n    );\n\n    !last_open_bracket.is_none()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi1399jp6.rs:18:32\n   |\n\
    18 |                 if last_open > c {\n   |                                ^\
    \ expected `usize`, found `char`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<&str> = brackets.chars().collect();\n\
    \    loop {\n        if stack.is_empty() {\n            break;\n        }\n  \
    \      let head = stack.last().unwrap();\n        let mut current = &stack.last().unwrap();\n\
    \        while !current.contains('(') && !current.contains('[') && !current.contains('{')\
    \ {\n            stack.pop();\n            current = &stack[stack.len() - 1];\n\
    \        }\n        if current.contains('(') {\n            stack.push(\")\");\n\
    \        }\n        if current.contains('[') {\n            stack.push(\"]\");\n\
    \        }\n        if current.contains('{') {\n            stack.push(\"}\");\n\
    \        }\n    }\n    stack.len() == 1 && stack[0] == \"\"\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp61oyg9am.rs:12:49\n     |\n12\
    \   |     let mut stack: Vec<&str> = brackets.chars().collect();\n     |     \
    \                                            ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp61oyg9am.rs:21:23\n\
    \   |\n18 |         let mut current = &stack.last().unwrap();\n   |          \
    \                 ---------------------- expected due to this value\n...\n21 |\
    \             current = &stack[stack.len() - 1];\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `str`\n   |\n   = note: expected reference `&&&str`\n\
    \              found reference `&&str`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().any(|c| *c == ')' && c != '(')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpy1akgc5n.rs:12:30\n\
    \   |\n12 |     brackets.chars().any(|c| *c == ')' && c != '(')\n   |        \
    \                      ^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.is_empty() {\n        return false;\n   \
    \ }\n\n    // The first character must be an open bracket.\n    let open_bracket\
    \ = brackets[0];\n    if !open_bracket.is_ascii_ascii_lower() {\n        return\
    \ false;\n    }\n    if open_bracket != '(' || open_bracket != '[' {\n       \
    \ return false;\n    }\n    // If there are more open brackets, we have an extra\
    \ closing bracket.\n    let open_brackets = &brackets[1..];\n    if open_brackets.is_empty()\
    \ {\n        return false;\n    }\n\n    // If we encounter a closing bracket,\
    \ the brackets must be balanced.\n    let closing_char = &open_brackets[open_brackets.len()\
    \ - 1];\n    if closing_char != ')' && closing_char != ']' {\n        return false;\n\
    \    }\n\n    // If we encounter a closing bracket with a different character\
    \ than a closing\n    // bracket, the brackets must be balanced.\n    if open_brackets.len()\
    \ != 2 {\n        return false;\n    }\n\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpuamy9spm.rs:17:24\n   |\n17 |     let open_bracket = brackets[0];\n\
    \   |                        ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpuamy9spm.rs:31:25\n   |\n31 |     let closing_char = &open_brackets[open_brackets.len()\
    \ - 1];\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: can't compare `&_` with `char`\n \
    \ --> /tmp/tmpuamy9spm.rs:32:21\n   |\n32 |     if closing_char != ')' && closing_char\
    \ != ']' {\n   |                     ^^ no implementation for `&_ == char`\n \
    \  |\n   = help: the trait `PartialEq<char>` is not implemented for `&_`\n\nerror[E0277]:\
    \ can't compare `&_` with `char`\n  --> /tmp/tmpuamy9spm.rs:32:44\n   |\n32 |\
    \     if closing_char != ')' && closing_char != ']' {\n   |                  \
    \                          ^^ no implementation for `&_ == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&_`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Empty string returns False\n    if brackets.is_empty()\
    \ {\n        return false;\n    }\n\n    // This char tells us which parentheses\
    \ we have already found\n    let mut found_opening = false;\n\n    // This char\
    \ tells us whether the current character is `)` or `)`.\n    // It starts as True,\
    \ because the initial character is `(`.\n    let mut is_right = true;\n\n    //\
    \ The index of parentheses we are currently looking at\n    let mut pos = 0;\n\
    \n    // Iterate through the string checking all the opening brackets\n    for\
    \ ch in brackets.chars() {\n        if ch == ')' {\n            if found_opening\
    \ {\n                // If we had a matching parentheses, then we have a complete\
    \ match\n                return is_right;\n            }\n            is_right\
    \ = true;\n            found_opening = true;\n            pos = 0;\n        }\
    \ else {\n            if ch == '(' && pos > 0 {\n                // If we had\
    \ an open bracket and we haven't already found a closing one,\n              \
    \  // then we match them\n                if !found_opening {\n              \
    \      return is_right;\n                }\n            } else {\n           \
    \     // If we encounter a closing bracket, we'll have to check whether it is\n\
    \                // the correct one by checking whether we have enclosed it correctly\
    \ already\n                if ch == ')' {\n                    if found_opening\
    \ {\n                        found_opening = false;\n                    }\n \
    \               } else {\n                    // If this isn't the closing bracket\
    \ we're looking for, set is_right to False\n                    is_right = false;\n\
    \                }\n            }\n        }\n        pos++;\n    }\n\n    //\
    \ If we finished iterating through the string, we didn't match everything\n  \
    \  // and it wasn't the correct one\n    return !found_opening || is_right;\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpb7xgig1i.rs:57:12\n\
    \   |\n57 |         pos++;\n   |            ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n57 |         { let tmp = pos; pos += 1;\
    \ tmp };\n   |         +++++++++++    ~~~~~~~~~~~~~~~~~\n57 -         pos++;\n\
    57 +         pos += 1;\n   | \n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut openings = String::new();\n    let mut closings\
    \ = String::new();\n    for c in brackets {\n        if c == '(' {\n         \
    \   openings.push(c);\n        } else if c == ')' {\n            closings.push(c);\n\
    \        } else {\n            Ok(true)\n        }\n    }\n\n    openings.chars().all(|c|\
    \ closings.chars().any(|cc| cc == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp98ho80ck.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp98ho80ck.rs:20:13\n   |\n17 |           } else if c ==\
    \ ')' {\n   |  ________________-\n18 | |             closings.push(c);\n19 | |\
    \         } else {\n20 | |             Ok(true)\n   | |             ^^^^^^^^ expected\
    \ `()`, found enum `Result`\n21 | |         }\n   | |_________- expected this\
    \ to be `()`\n   |\n   = note: expected unit type `()`\n                   found\
    \ enum `Result<bool, _>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.contains('(') && brackets.contains(')')\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8v2ar3p3.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.is_empty() || brackets.chars().all(|c| c ==\
    \ '(' || c == ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpw0095h2k.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n    for bracket\
    \ in brackets.chars().filter_map(|c| {\n        match c {\n            '(' =>\
    \ stack.pop(),\n            ')' => stack.push(stack.len()),\n            _ =>\
    \ Ok(c),\n        }\n    }) {\n        Ok(_) => false,\n        Err(_) => true,\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n\
    \  --> /tmp/tmp83nmoq6v.rs:20:15\n   |\n20 |         Ok(_) => false,\n   |   \
    \            ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]:\
    \ `match` arms have incompatible types\n  --> /tmp/tmp83nmoq6v.rs:16:20\n   |\n\
    14 | /         match c {\n15 | |             '(' => stack.pop(),\n   | |     \
    \               ----------- this is found to be of type `Option<usize>`\n16 |\
    \ |             ')' => stack.push(stack.len()),\n   | |                    ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `()`\n17 | |             _ => Ok(c),\n18 | | \
    \        }\n   | |_________- `match` arms have incompatible types\n   |\n   =\
    \ note:   expected enum `Option<usize>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = 0;\n    let mut open_brackets_idx\
    \ = 0;\n    let mut closed_brackets = 0;\n    let mut closed_brackets_idx = 0;\n\
    \    for idx in 0..brackets.len() {\n        match brackets[idx] {\n         \
    \   '(' | ')' => {\n                open_brackets += 1;\n                open_brackets_idx\
    \ += 1;\n            }\n            _ => {\n                closed_brackets +=\
    \ 1;\n                closed_brackets_idx += 1;\n            }\n        }\n  \
    \  }\n    open_brackets > 0 && open_brackets_idx == brackets.len() - open_brackets\n\
    \        && closed_brackets == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2154ifsf.rs:17:15\n\
    \   |\n17 |         match brackets[idx] {\n   |               ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c|\n        c == '(' || c == '['\
    \ || c == '{' || c == '<' || c == '{'\n    )\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu0xvt_bj.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.contains(\"(\") && brackets.contains(\")\")\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmelol6b5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    for c in brackets.chars().cloned() {\n        if c ==\
    \ '(' {\n            open_brackets.push(c);\n        }\n        if c == ')' {\n\
    \            closed_brackets.push(c);\n        }\n    }\n    closed_brackets.len()\
    \ == open_brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpz4rmzjps.rs:14:31\n     |\n14   |     for c in brackets.chars().cloned()\
    \ {\n     |                               ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpz4rmzjps.rs:14:14\n\
    \   |\n14 |     for c in brackets.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpz4rmzjps.rs:14:14\n   |\n14 |     for c in brackets.chars().cloned()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| *c != '(' && '*' != c)\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmphapyk4oo.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c != '(' && '*' != c)\n   |        \
    \                      ^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n\n    for b in brackets {\n        if b == ')' {\n       \
    \     close_brackets.push_str(&b.to_string());\n        } else {\n           \
    \ open_brackets.push_str(&b.to_string());\n        }\n    }\n\n    open_brackets\
    \ == close_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpcud1pnvj.rs:15:14\n\
    \   |\n15 |     for b in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets.len() != 2 {\n        return false;\n   \
    \ }\n    let mut open_position = 0;\n    let mut close_position = 0;\n    for\
    \ i in 0..brackets.len() {\n        let open = &brackets[open_position..i];\n\
    \        let close = &brackets[i..close_position];\n        if open != close {\n\
    \            return false;\n        }\n        open_position = i + 1;\n      \
    \  close_position = i;\n    }\n    true\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'begin <= end (1 <= 0) when slicing `()`', library/core/src/str/mod.rs:111:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = String::new();\n    let mut closed_brackets\
    \ = String::new();\n    for char in brackets.chars() {\n        if char == '('\
    \ {\n            open_brackets.push('(');\n        } else if char == ')' {\n \
    \           open_brackets.push(')');\n        } else if char == '[' {\n      \
    \      open_brackets.push('[');\n        } else if char == ']' {\n           \
    \ open_brackets.push(']');\n        } else {\n            closed_brackets.push(char);\n\
    \        }\n    }\n    closed_brackets.chars().all(|c| open_brackets.contains(&c))\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpfvirgp83.rs:27:60\n\
    \     |\n27   |     closed_brackets.chars().all(|c| open_brackets.contains(&c))\n\
    \     |                                                   -------- ^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n     |                             \
    \                      |\n     |                                             \
    \      required by a bound introduced by this call\n     |\n     = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n     = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    note: required by a bound in `core::str::<impl str>::contains`\nhelp: consider\
    \ dereferencing here\n     |\n27   |     closed_brackets.chars().all(|c| open_brackets.contains(*&c))\n\
    \     |                                                            +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![String::new(); brackets.len()];\n\
    \    for pos in 0..brackets.len() {\n        if pos == 0 || !stack[pos - 1].contains(&brackets[pos\
    \ - 1]) {\n            stack[pos] = brackets[pos];\n        } else {\n       \
    \     stack[pos] = stack[pos - 1];\n        }\n    }\n    stack.iter().all(|c|\
    \ !c.contains('(') && !c.contains(')'))\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkkhltx9i.rs:14:50\n\
    \   |\n14 |         if pos == 0 || !stack[pos - 1].contains(&brackets[pos - 1])\
    \ {\n   |                                                  ^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkkhltx9i.rs:15:26\n   |\n15 |             stack[pos] = brackets[pos];\n\
    \   |                          ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // If any opening brackets are not paired with a closing\
    \ bracket, this\n    // is not correct.\n    let mut opening_brackets = brackets.split('(');\n\
    \    for (i, b) in opening_brackets.iter().enumerate() {\n        if i == opening_brackets.len()\
    \ - 1 {\n            return false;\n        }\n        let next: &str = opening_brackets[i\
    \ + 1];\n        if b != next {\n            return false;\n        }\n    }\n\
    \n    // If we made it this far, this means we're correctly bracketing\n    //\
    \ brackets.\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmpcsp2mdvl.rs:15:36\n   |\n15 |     for (i,\
    \ b) in opening_brackets.iter().enumerate() {\n   |                          \
    \          ^^^^ method not found in `std::str::Split<'_, char>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `std::str::Split` in the current scope\n\
    \  --> /tmp/tmpcsp2mdvl.rs:16:34\n   |\n16 |         if i == opening_brackets.len()\
    \ - 1 {\n   |                                  ^^^ method not found in `std::str::Split<'_,\
    \ char>`\n\nerror[E0608]: cannot index into a value of type `std::str::Split<'_,\
    \ char>`\n  --> /tmp/tmpcsp2mdvl.rs:19:26\n   |\n19 |         let next: &str =\
    \ opening_brackets[i + 1];\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().filter_map(|c| {\n        if *c != ')'\
    \ && *c != '(' {\n            Some(false)\n        } else {\n            Some(true)\n\
    \        }\n    }).count() == brackets.len()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpciiw8mc2.rs:13:12\n\
    \   |\n13 |         if *c != ')' && *c != '(' {\n   |            ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpciiw8mc2.rs:13:25\n   |\n\
    13 |         if *c != ')' && *c != '(' {\n   |                         ^^\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut s = String::new();\n    brackets.chars().for_each(|b|\
    \ {\n        if b == ')' {\n            s.push('(');\n        } else if b == '('\
    \ {\n            s.push(b);\n        } else {\n            s.push(b);\n      \
    \  }\n    });\n    s == brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8pg5_gby.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets {\n\
    \        if c == '(' {\n            stack.push(c);\n        } else if c == ')'\
    \ {\n            if stack.is_empty() {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if !stack.is_empty()\
    \ && stack.last().unwrap() == '(' {\n                stack.last_mut().unwrap()\
    \ = ')';\n            }\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpzwf7xhyv.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0070]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpzwf7xhyv.rs:23:43\n   |\n23 |  \
    \               stack.last_mut().unwrap() = ')';\n   |                 -------------------------\
    \ ^\n   |                 |\n   |                 cannot assign to this expression\n\
    \nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpzwf7xhyv.rs:22:59\n\
    \   |\n22 |             if !stack.is_empty() && stack.last().unwrap() == '(' {\n\
    \   |                                                           ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0070, E0277.\nFor more information about an error, try `rustc\
    \ --explain E0070`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut parens = String::new();\n    let mut index =\
    \ 0;\n\n    // go through every opening bracket\n    while index < brackets.len()\
    \ {\n        let c = brackets[index];\n        if !is_opening(c) {\n         \
    \   index += 1;\n            continue;\n        }\n\n        // if we see the\
    \ closing bracket, rewind and return\n        if index == brackets.len() - 1 {\n\
    \            index += 1;\n            return false;\n        }\n\n        if brackets[index\
    \ + 1] == ')' {\n            // we are at the close paren\n            // increment\
    \ the counter\n            parens += \")\";\n            index += 1;\n       \
    \ } else {\n            // increment the counter\n            parens += \"(\"\
    ;\n            index += 1;\n        }\n    }\n\n    // if we get to here then\
    \ all the opening brackets are closed\n    parens.len() > 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_opening` in this scope\n  --> /tmp/tmphwupogxk.rs:18:13\n\
    \   |\n18 |         if !is_opening(c) {\n   |             ^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphwupogxk.rs:17:17\n   |\n17 |         let c = brackets[index];\n\
    \   |                 ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphwupogxk.rs:29:12\n   |\n29 |         if brackets[index + 1] ==\
    \ ')' {\n   |            ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.replace(\"(\", \"[\").split(\",\")\n       \
    \ .filter(|s| !s.is_empty())\n        .all(|s| s.replace(\"[\", \"(\").replace(\"\
    \ ]\", \")\") == brackets)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfbjefce_.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for (i, c) in brackets.chars().enumerate()\
    \ {\n        if c == '(' {\n            stack.push(i);\n        } else if c ==\
    \ ')' {\n            if let Some(idx) = (stack.pop())?.clone() {\n           \
    \     stack[stack.len() - 1].unwrap().unwrap() = idx;\n            }\n       \
    \ }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the `?` operator can only be used in a function that returns\
    \ `Result` or `Option` (or another type that implements `FromResidual`)\n  -->\
    \ /tmp/tmpchb4pqmy.rs:17:45\n   |\n11 | / fn correct_bracketing(brackets: String)\
    \ -> bool {\n12 | |     let mut stack = Vec::new();\n13 | |     for (i, c) in\
    \ brackets.chars().enumerate() {\n14 | |         if c == '(' {\n...  |\n17 | |\
    \             if let Some(idx) = (stack.pop())?.clone() {\n   | |            \
    \                                 ^ cannot use the `?` operator in a function\
    \ that returns `bool`\n...  |\n22 | |     stack.is_empty()\n23 | | }\n   | |_-\
    \ this function should return `Result` or `Option` to accept `?`\n   |\n   = help:\
    \ the trait `FromResidual<Option<Infallible>>` is not implemented for `bool`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpchb4pqmy.rs:17:20\n   |\n17 |\
    \             if let Some(idx) = (stack.pop())?.clone() {\n   |              \
    \      ^^^^^^^^^   ---------------------- this expression has type `usize`\n \
    \  |                    |\n   |                    expected `usize`, found enum\
    \ `Option`\n   |\n   = note: expected type `usize`\n              found enum `Option<_>`\n\
    \nerror[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmpchb4pqmy.rs:18:58\n\
    \   |\n18 |                 stack[stack.len() - 1].unwrap().unwrap() = idx;\n\
    \   |                 ---------------------------------------- ^\n   |       \
    \          |\n   |                 cannot assign to this expression\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmpchb4pqmy.rs:18:40\n   |\n18 |                 stack[stack.len() - 1].unwrap().unwrap()\
    \ = idx;\n   |                                        ^^^^^^ method not found\
    \ in `usize`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0070, E0277, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0070`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec!['('];\n    for ch in brackets {\n\
    \        if ch == '(' {\n            stack.push('(');\n        } else if ch ==\
    \ ')' {\n            if stack.is_empty() {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else if ch == '(' || ch == ')'\
    \ {\n            return false;\n        }\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp5j7ojvza.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in brackets.chars().cloned()\
    \ {\n        if ch == '(' {\n            stack.push('(');\n        } else if ch\
    \ == ')' {\n            match stack.pop() {\n                '(' => return false,\n\
    \                ')' => return true,\n                _ => (),\n            }\n\
    \        } else {\n            stack.push(ch);\n        }\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpin0dq7o0.rs:13:32\n     |\n13   |     for ch in brackets.chars().cloned()\
    \ {\n     |                                ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpin0dq7o0.rs:13:15\n\
    \   |\n13 |     for ch in brackets.chars().cloned() {\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpin0dq7o0.rs:13:15\n   |\n13 |     for ch in brackets.chars().cloned()\
    \ {\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpin0dq7o0.rs:18:17\n   |\n17 |\
    \             match stack.pop() {\n   |                   ----------- this expression\
    \ has type `Option<char>`\n18 |                 '(' => return false,\n   |   \
    \              ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<char>`\n              found type `char`\nhelp: try wrapping the\
    \ pattern in `Some`\n   |\n18 |                 Some('(') => return false,\n \
    \  |                 +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpin0dq7o0.rs:19:17\n\
    \   |\n17 |             match stack.pop() {\n   |                   -----------\
    \ this expression has type `Option<char>`\n18 |                 '(' => return\
    \ false,\n19 |                 ')' => return true,\n   |          "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<_> = vec![String::new(); brackets.chars().take(1).collect()];\n\
    \    let mut last = 0;\n    for c in brackets.chars() {\n        last = stack.len();\n\
    \        stack[last].push(c);\n    }\n    let mut open = false;\n    let mut last\
    \ = 0;\n    for &s in stack[last..] {\n        let s = s[..];\n        if !open\
    \ {\n            if s == \")\" {\n                open = true;\n            }\n\
    \        } else {\n            if s != \"(\" {\n                return false;\n\
    \            }\n        }\n    }\n    open\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `usize` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpfltml50u.rs:12:74\n     |\n12\
    \   |     let mut stack: Vec<_> = vec![String::new(); brackets.chars().take(1).collect()];\n\
    \     |                                                                      \
    \    ^^^^^^^ value of type `usize` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `usize`\n\
    note: required by a bound in `collect`\n\nerror[E0277]: the size for values of\
    \ type `[String]` cannot be known at compilation time\n  --> /tmp/tmpfltml50u.rs:20:15\n\
    \   |\n20 |     for &s in stack[last..] {\n   |               ^^^^^^^^^^^^^ expected\
    \ an implementor of trait `IntoIterator`\n   |\n   = note: the trait bound `[String]:\
    \ IntoIterator` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `[String]`\nhelp: consider borrowing here\n\
    \   |\n20 |     for &s in &stack[last..] {\n   |               +\n20 |     for\
    \ &s in &mut stack[last..] {\n   |               ++++\n\nerror[E0277]: `[String]`\
    \ is not an iterator\n  --> /tmp/tmpfltml50u.rs:20:15\n   |\n20 |     for &s in\
    \ stack[last..] {\n   |               ^^^^^^^^^^^^^ expected an implementor of\
    \ trait `IntoIterator`\n   |\n   = note: the trait bound `[String]: IntoIterator`\
    \ is not satisfied\n   = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `[String]`\nhelp: consider borrowing here\n   |\n20 |\
    \     for &s in &stack[last..] {\n   |               +\n20 |     for &s in &mut\
    \ stack[last..] {\n   |               ++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut s = String::from(brackets);\n    s.remove_suffix(s.len()\
    \ - 1);\n    s.chars().all(|c| *c == '(' || c == ')')\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `remove_suffix` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpyh9mxigm.rs:13:7\n   |\n13 |     s.remove_suffix(s.len()\
    \ - 1);\n   |       ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpyh9mxigm.rs:14:23\n   |\n\
    14 |     s.chars().all(|c| *c == '(' || c == ')')\n   |                      \
    \ ^^\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = [Character::Brack];\n    let mut characters\
    \ = String::new();\n    characters += \"()\"; // open bracket\n    characters\
    \ += \"{}\"; // close bracket\n    characters += \"[]\"; // open square bracket\n\
    \    characters += \"{}\"; // close square bracket\n    characters += \"()\";\
    \ // open parenthesis\n    characters += \"{}\"; // close parenthesis\n    characters\
    \ += \")\"; // close parenthesis if not empty\n    characters += \"(\";  // close\
    \ square bracket if not empty\n    characters += \"[\";  // close square bracket\
    \ if not empty\n    for char in characters.chars().filter(|c| *c == Character::Bracket)\
    \ {\n        match stack.pop() {\n            Some(Character::Brack) => {\n  \
    \              match char {\n                    '(' | ')' | ']' => {\n      \
    \                  stack.push(Character::Brack);\n                    }\n    \
    \                _ => {\n                        return false;\n             \
    \       }\n                }\n            }\n            Some(Character::Bracket)\
    \ => {\n                match char {\n                    '(' | ')' | ']' | '{'\
    \ | '}' => {\n                        stack.push(Character::Bracket);\n      \
    \              }\n                    _ => {\n                        return false;\n\
    \                    }\n                }\n            }\n            Some(Character::Parenthesis)\
    \ => {\n                match char {\n                    '(' | ')' | ']' | '{'\
    \ | '}' => {\n                        stack.push(Character::Parenthesis);\n  \
    \                  }\n                    _ => {\n                        return\
    \ false;\n                    }\n                }\n            }\n          \
    \  _ => {\n                return false;\n            }\n        }\n    }\n\n\
    \    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Character`\n \
    \ --> /tmp/tmp6mhq7ugq.rs:12:22\n   |\n12 |     let mut stack = [Character::Brack];\n\
    \   |                      ^^^^^^^^^ use of undeclared type `Character`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Character`\n  --> /tmp/tmp6mhq7ugq.rs:23:53\n\
    \   |\n23 |     for char in characters.chars().filter(|c| *c == Character::Bracket)\
    \ {\n   |                                                     ^^^^^^^^^ use of\
    \ undeclared type `Character`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Character`\n  --> /tmp/tmp6mhq7ugq.rs:25:18\n   |\n25 |             Some(Character::Brack)\
    \ => {\n   |                  ^^^^^^^^^ use of undeclared type `Character`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Character`\n  --> /tmp/tmp6mhq7ugq.rs:28:36\n\
    \   |\n28 |                         stack.push(Character::Brack);\n   |      \
    \                              ^^^^^^^^^ use of undeclared type `Character`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Character`\n  --> /tmp/tmp6mhq7ugq.rs:35:18\n\
    \   |\n35 |             Some(Character::Bracket) => {\n   |                  ^^^^^^^^^\
    \ use of undeclared type `Character`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Character`\n  --> /tmp/tmp6mhq7ugq.rs:38:36\n   |\n38 |   \
    \                      stack.push(Character::Bracket);\n   |                 \
    \                   ^^^^^^^^^ use of undeclared type `Character`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Character`\n  --> /tmp/tmp6mhq7ugq.rs:45:18\n\
    \   |\n45 |             Some(Character::Parenthesis) => {\n   |              \
    \    ^^^^^^^^^ use of undeclared type `Character`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Character`\n  --> /tmp/tmp6mhq7ugq.rs:48:36\n   |\n\
    48 |                         stack.push(Character::Parenthesis);\n   |       \
    \                             ^^^^^^^^^ use of undeclared type `Character`\n\n\
    error: aborting due to 8 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = brackets.to_string();\n  \
    \  opening_brackets.replace(\"(\", \"\");\n    opening_brackets.replace(\")\"\
    , \"\");\n\n    let mut closing_brackets = opening_brackets.to_string();\n   \
    \ closing_brackets.replace(\", \", \"\");\n    closing_brackets.replace(\")\"\
    , \"\");\n\n    opening_brackets.chars().all(|c| c == Some('(')) &&\n    closing_brackets.chars().all(|c|\
    \ c == Some(')'))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp03v4nv85.rs:20:43\n   |\n\
    20 |     opening_brackets.chars().all(|c| c == Some('(')) &&\n   |           \
    \                                ^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp03v4nv85.rs:21:43\n   |\n21 |\
    \     closing_brackets.chars().all(|c| c == Some(')'))\n   |                 \
    \                          ^^^^^^^^^ expected `char`, found enum `Option`\n  \
    \ |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut count = 0;\n    for c in brackets {\n       \
    \ if c == '(' {\n            count += 1;\n        } else if c == ')' {\n     \
    \       count -= 1;\n        } else {\n            count = 0;\n        }\n   \
    \     if count != 0 {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpvkvo_0x3.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut s = brackets;\n    while let Some(next) = s.find('(')\
    \ {\n        let mut end = s.find(')', next);\n        if end == s.len() {\n \
    \           // all brackets are closed\n            break;\n        }\n      \
    \  s = &s[..end];\n    }\n    s != brackets\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpath4yv99.rs:14:25\n     |\n14   |         let mut end = s.find(')',\
    \ next);\n     |                         ^^^^ ---  ---- supplied 2 arguments\n\
    \     |                         |\n     |                         expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpath4yv99.rs:15:19\n   |\n15 |         if end == s.len() {\n   |\
    \                   ^^^^^^^ expected enum `Option`, found `usize`\n   |\n   =\
    \ note: expected enum `Option<usize>`\n              found type `usize`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n15 |         if end == Some(s.len())\
    \ {\n   |                   +++++       +\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `RangeTo<Option<usize>>`\n  --> /tmp/tmpath4yv99.rs:19:14\n  \
    \ |\n19 |         s = &s[..end];\n   |              ^^^^^^^^ `String` cannot be\
    \ indexed by `RangeTo<Option<usize>>`\n   |\n   = help: the trait `Index<RangeTo<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpath4yv99.rs:19:13\n\
    \   |\n12 |     let mut s = brackets;\n   |                 -------- expected\
    \ due to this value\n...\n19 |         s = &s[..end];\n   |             ^^^^^^^^^\
    \ expected struct `String`, found reference\n   |\n   = note: expected struct\
    \ `String`\n           found reference `&_`\nhelp: consider removing the borrow\n\
    \   |\n19 -         s = &s[..end];\n19 +         s = s[..end];\n   | \n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain\
    \ E"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut index = 0;\n    while index < brackets.len()\
    \ {\n        if brackets[index] == '(' { index += 1 } else { index += 2 }\n  \
    \  }\n    index == brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph138w2kr.rs:14:12\n\
    \   |\n14 |         if brackets[index] == '(' { index += 1 } else { index += 2\
    \ }\n   |            ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    while let\
    \ Some(b) = brackets.find('(') {\n        if let Some(e) = brackets.find(')',\
    \ b) {\n            brackets.push_str(&mut String::new());\n            brackets.push_str(&mut\
    \ brackets[..b]);\n            brackets.push_str(&mut brackets[b+1..e]);\n   \
    \     }\n    }\n    brackets.len() == 0 || brackets.chars().any(|c| c == '(' ||\
    \ c == ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp7vs_xyvp.rs:14:35\n     |\n14   |         if let Some(e) = brackets.find(')',\
    \ b) {\n     |                                   ^^^^ ---  - supplied 2 arguments\n\
    \     |                                   |\n     |                          \
    \         expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut iter = brackets.char_indices();\n\n    loop {\n\
    \        if let Some((_, idx)) = iter.next() {\n            if idx > 0 {\n   \
    \             if *iter.get().unwrap() > iter.get().unwrap() - 1 {\n          \
    \          return false;\n                }\n            }\n        }\n\n    \
    \    if iter.is_empty() {\n            return true;\n        }\n    }\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiga68k3a.rs:16:22\n   |\n\
    16 |             if idx > 0 {\n   |                      ^ expected `char`, found\
    \ `u8`\n\nerror[E0599]: no method named `get` found for struct `CharIndices` in\
    \ the current scope\n  --> /tmp/tmpiga68k3a.rs:17:26\n   |\n17 |             \
    \    if *iter.get().unwrap() > iter.get().unwrap() - 1 {\n   |               \
    \           ^^^ method not found in `CharIndices<'_>`\n\nerror[E0599]: no method\
    \ named `get` found for struct `CharIndices` in the current scope\n  --> /tmp/tmpiga68k3a.rs:17:48\n\
    \   |\n17 |                 if *iter.get().unwrap() > iter.get().unwrap() - 1\
    \ {\n   |                                                ^^^ method not found\
    \ in `CharIndices<'_>`\n\nerror[E0599]: no method named `is_empty` found for struct\
    \ `CharIndices` in the current scope\n  --> /tmp/tmpiga68k3a.rs:23:17\n   |\n\
    23 |         if iter.is_empty() {\n   |                 ^^^^^^^^ method not found\
    \ in `CharIndices<'_>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = 0;\n    let mut closed_brackets\
    \ = 0;\n    let mut chars = String::new();\n\n    for ch in brackets {\n     \
    \   chars.push((*ch).to_string());\n    }\n\n    for ch in chars.chars() {\n \
    \       if ch == ('(') {\n            opening_brackets += 1;\n        } else if\
    \ ch == (')') {\n            closed_brackets += 1;\n        } else {\n       \
    \     // Any non-bracketing character should be considered a\n            // mismatch,\
    \ so break out of the loop.\n            return false;\n        }\n    }\n\n \
    \   // If we made it this far, every opening bracket has a corresponding\n   \
    \ // closing bracket.\n    opening_brackets == closed_brackets\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp4midp2y6.rs:16:15\n\
    \   |\n16 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening: usize = 0;\n    let mut closing: usize\
    \ = 0;\n    for c in brackets.chars() {\n        if c == '(' {\n            opening++;\n\
    \        } else if c == ')' {\n            closing++;\n        } else if opening\
    \ > 0 && closing > 0 {\n            if opening != closing {\n                return\
    \ false;\n            }\n            opening = 0;\n            closing = 0;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp06eltwaz.rs:16:20\n\
    \   |\n16 |             opening++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n16 |             { let tmp =\
    \ opening; opening += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    16 -             opening++;\n16 +             opening += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmp06eltwaz.rs:18:20\n   |\n18\
    \ |             closing++;\n   |                    ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n18 |             { let tmp = closing; closing\
    \ += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n18\
    \ -             closing++;\n18 +             closing += 1;\n   | \n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket_pairs = HashSet::new();\n    for (i,\
    \ c) in brackets.chars().enumerate() {\n        if c == '(' || c == ')' {\n  \
    \          if bracket_pairs.insert(i).is_err() {\n                return false;\n\
    \            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpnlufddpd.rs:12:29\n   |\n12 |     let mut bracket_pairs = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = HashMap::new();\n    let mut\
    \ closed_brackets = HashMap::new();\n    for char in brackets.chars().cloned()\
    \ {\n        if open_brackets.contains_key(char) {\n            open_brackets.insert(char,\
    \ open_brackets.get_mut(char).unwrap() + 1);\n        } else {\n            open_brackets.insert(char,\
    \ 1);\n        }\n        if closed_brackets.contains_key(char) {\n          \
    \  closed_brackets.insert(char, closed_brackets.get_mut(char).unwrap() - 1);\n\
    \        } else {\n            closed_brackets.insert(char, 0);\n        }\n \
    \   }\n    let empty_open = open_brackets.is_empty();\n    let empty_closed =\
    \ closed_brackets.is_empty();\n    let same = empty_open && !empty_closed;\n \
    \   let equal = empty_open && empty_closed;\n    !equal && !same\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp533tmtgd.rs:12:29\n   |\n12 |     let mut open_brackets = HashMap::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp533tmtgd.rs:13:31\n   |\n13 |     let mut closed_brackets = HashMap::new();\n\
    \   |                               ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmp533tmtgd.rs:14:34\n     |\n14   |     for char in brackets.chars().cloned()\
    \ {\n     |                                  ^^^^^^ expected reference, found\
    \ `char`\n     |\n     = note: expected reference `&_`\n                     found\
    \ type `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmp533tmtgd.rs:14:17\n\
    \   |\n14 |     for char in brackets.chars().cloned() {\n   |                \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n   = note:\
    \   expected type `char`\n           found reference `&_`\n   = note: required\
    \ because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmp533tmtgd.rs:14:17\n   |\n14 |     for\
    \ char in brackets.chars().cloned() {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0271, E0433.\n\
    For more information about an error, try"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.parse().unwrap().trim() == \"()\"\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpjglvt4ww.rs:12:22\n\
    \   |\n12 |     brackets.parse().unwrap().trim() == \"()\"\n   |             \
    \         ^^^^^^ cannot infer type for type parameter `T`\n   |\n   = note: type\
    \ must be known at this point\nhelp: consider specifying the type argument in\
    \ the method call\n   |\n12 |     brackets.parse::<F>().unwrap().trim() == \"\
    ()\"\n   |                   +++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c != ')' &&\n              \
    \  c != '(' && c != '[' && c != ']' && c != '{' && c != '}')\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1erkcrkz.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets_copy = String::new();\n    let mut depth\
    \ = 0;\n    for bracket_char in &brackets {\n        if bracket_char == '(' {\n\
    \            depth += 1;\n        }\n        if bracket_char == ')' {\n      \
    \      depth -= 1;\n        }\n\n        if depth == 0 {\n            brackets_copy\
    \ += bracket_char;\n        }\n    }\n\n    brackets_copy == brackets\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmp8fk0y0_f.rs:14:25\n\
    \   |\n14 |     for bracket_char in &brackets {\n   |                        \
    \ ^^^^^^^^^ `&String` is not an iterator\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `&String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&String`\n\nerror[E0277]: can't compare `&str`\
    \ with `char`\n  --> /tmp/tmp8fk0y0_f.rs:15:25\n   |\n15 |         if bracket_char\
    \ == '(' {\n   |                         ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmp8fk0y0_f.rs:18:25\n   |\n18 |         if bracket_char\
    \ == ')' {\n   |                         ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| match c {\n        '(' => false,\n\
    \        '[' => true,\n        '{' => true,\n        _ => false,\n    })\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpawr6x8of.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_string();\n    brackets.replace(\"\
    (\", \"( \").replace(\")\", \" )\").replace(\"[\", \"[ \").replace(\n        \"\
    ]\", \"  ]\"\n    );\n    brackets == brackets.replace(\"  \", \" \")\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpm8_78p00.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n    let mut\
    \ found = false;\n    let mut opening_bracket: Option<usize> = None;\n    let\
    \ mut closing_bracket: Option<usize> = None;\n    for c in brackets {\n      \
    \  if c.is_digit(10) {\n            if found {\n                // a closing bracket\
    \ is expected if we have not seen an opening one\n                break;\n   \
    \         }\n            stack.push(c - '0');\n        } else if c == '{' {\n\
    \            stack.push(1);\n            opening_bracket = Some(stack.len());\n\
    \        } else if c == '}' {\n            if opening_bracket.is_some() {\n  \
    \              // found an opening bracket\n                let opening = opening_bracket.unwrap();\n\
    \                // get the corresponding closing bracket\n                closing_bracket\
    \ = stack\n                    .get_mut(opening)\n                    .and_then(|s|\
    \ s.pop())\n                    .and_then(|_| Ok(s));\n                // we found\
    \ the corresponding closing bracket\n                found = true;\n         \
    \   } else {\n                // we did not find an opening bracket\n        \
    \        break;\n            }\n        }\n    }\n    found && closing_bracket.is_some()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `s` in this scope\n  --> /tmp/tmpkx9h18ht.rs:34:38\n\
    \   |\n34 |                     .and_then(|_| Ok(s));\n   |                  \
    \                    ^ help: a local variable with a similar name exists: `c`\n\
    \nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpkx9h18ht.rs:16:14\n\
    \   |\n16 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]: no\
    \ method named `pop` found for mutable reference `&mut usize` in the current scope\n\
    \  --> /tmp/tmpkx9h18ht.rs:33:37\n   |\n33 |                     .and_then(|s|\
    \ s.pop())\n   |                                     ^^^ help: there is an associated\
    \ function with a similar name: `pow`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkx9h18ht.rs:34:35\n   |\n34 |                     .and_then(|_| Ok(s));\n\
    \   |                                   ^^^^^ expected enum `Option`, found enum\
    \ `Result`\n   |\n   = note: expected enum `Option<_>`\n              found enum\
    \ `Result<_, _>`\nhelp: try wrapping the expression in `Some`\n   |\n34 |    \
    \                 .and_then(|_| Some(Ok(s)));\n   |                          \
    \         +++++     +\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut s = brackets;\n    s.replace(\")\", \", \").replace(\"\
    (\", \" (\").replace(\" (\", \" (\");\n    let mut brackets = s.char_indices();\n\
    \    let mut open_brackets = Vec::new();\n    for ((i, c), &b) in &mut brackets\
    \ {\n        if b == ' ' {\n            open_brackets.push(i as usize);\n    \
    \    }\n    }\n    let mut found_brackets = Vec::new();\n    let mut current_pos\
    \ = 0;\n    let mut prev_pos;\n    for (i, _) in &mut brackets {\n        if open_brackets.contains(i\
    \ as usize) {\n            found_brackets.push(i as usize);\n            if i\
    \ == 0 {\n                current_pos = prev_pos;\n            } else {\n    \
    \            current_pos += 1;\n            }\n        }\n        if i == 0 {\n\
    \            prev_pos = 0;\n        } else {\n            prev_pos += 1;\n   \
    \     }\n    }\n    // TODO: fix this for large brackets\n    found_brackets.len()\
    \ == open_brackets.len() && found_brackets.len() == brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm5x3ac73.rs:16:10\n   |\n\
    16 |     for ((i, c), &b) in &mut brackets {\n   |          ^^^^^^         -------------\
    \ this expression has type `Option<(usize, char)>`\n   |          |\n   |    \
    \      expected `usize`, found tuple\n   |\n   = note: expected type `usize`\n\
    \             found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm5x3ac73.rs:16:18\n\
    \   |\n16 |     for ((i, c), &b) in &mut brackets {\n   |                  ^^\
    \     ------------- this expression has type `Option<(usize, char)>`\n   |   \
    \               |\n   |                  expected `char`, found reference\n  \
    \ |                  help: you can probably remove the explicit borrow: `b`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpm5x3ac73.rs:25:35\n   |\n25 |  \
    \       if open_brackets.contains(i as usize) {\n   |                        \
    \           ^^^^^^^^^^\n   |                                   |\n   |       \
    \                            expected reference, found `usize`\n   |         \
    \                          help: consider borrowing here: `&(i as usize)`\n  \
    \ |\n   = note: expected reference `&_`\n                   found type `usize`\n\
    \nerror[E0599]: no method named `len` found for struct `CharIndices` in the current\
    \ scope\n  --> /tmp/tmpm5x3ac73.rs:40:85\n   |\n40 |     found_brackets.len()\
    \ == open_brackets.len() && found_brackets.len() == brackets.len()\n   |     \
    \                                                                            \
    \    ^^^ method not found in `CharIndices<'_>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().any(|c| c == '(' || c == ')')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkdkvgaws.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Find the left side of the brackets.\n    let mut left\
    \ = String::new();\n    for c in brackets {\n        if c == '(' {\n         \
    \   left.push(c);\n        } else {\n            if left.len() == 0 {\n      \
    \          return false;\n            }\n            left.pop();\n        }\n\
    \    }\n    if left.len() > 0 {\n        return false;\n    }\n    // Find the\
    \ right side of the brackets.\n    let mut right = String::new();\n    for c in\
    \ brackets {\n        if c == ')' {\n            right.push(c);\n        } else\
    \ {\n            if right.len() == 0 {\n                return false;\n      \
    \      }\n            right.pop();\n        }\n    }\n    if right.len() > 0 {\n\
    \        return false;\n    }\n    // If we made it here, the brackets are balanced.\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpb6wt2gyy.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmpb6wt2gyy.rs:29:14\n   |\n29 |     for c in\
    \ brackets {\n   |              ^^^^^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if ch == '(' {\n            stack.push(ch);\n        } else if ch\
    \ == ')' {\n            stack.pop();\n            if !stack.is_empty() {\n   \
    \             return false;\n            }\n        } else {\n            return\
    \ false;\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_i1vktu4.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_tokens = String::new();\n\n    // Record the opening brackets.\n   \
    \ for (i, character) in brackets.chars().enumerate() {\n        if character ==\
    \ '(' {\n            opening_brackets.push_str(\"(\");\n        } else if character\
    \ == ')' {\n            closing_tokens.push_str(\")\");\n        }\n    }\n  \
    \  closing_tokens.reverse();\n\n    // Check that all the opening brackets have\
    \ a corresponding closing bracket.\n    let mut opening_brackets_iter = opening_brackets.chars().enumerate().rev();\n\
    \    loop {\n        let opening_bracket = opening_brackets_iter.next().unwrap();\n\
    \        let closing_token = closing_tokens.chars().nth(opening_bracket.1).unwrap();\n\
    \n        if opening_bracket.1 == closing_token {\n            return true;\n\
    \        }\n\n        opening_brackets_iter.next();\n        opening_brackets_iter.next();\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpu212slns.rs:23:20\n   |\n23 |     closing_tokens.reverse();\n\
    \   |                    ^^^^^^^ help: there is an associated function with a\
    \ similar name: `reserve`\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n    --> /tmp/tmpu212slns.rs:26:74\n     |\n26   |     let\
    \ mut opening_brackets_iter = opening_brackets.chars().enumerate().rev();\n  \
    \   |                                                                        \
    \  ^^^ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n    \
    \ |\n     = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\nnote: required\
    \ by a bound in `rev`\n\nerror[E0599]: the method `next` exists for struct `Rev<Enumerate<Chars<'_>>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpu212slns.rs:28:53\n \
    \  |\n28 |           let opening_bracket = opening_brackets_iter.next().unwrap();\n\
    \   |                                                       ^^^^ method cannot\
    \ be called on `Rev<Enumerate<Chars<'_>>>` due to unsatisfied trait bounds\n \
    \  |\n   = note: the following trait bounds were not satisfied:\n           `Enumerate<Chars<'_>>:\
    \ DoubleEndedIterator`\n           which is required by `Rev<Enumerate<Chars<'_>>>:\
    \ Iterator`\n\nerror[E0599]: the method `next` exists for struct `Rev<Enumerate<Chars<'_>>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpu212slns.rs:35:31\n \
    \  |\n35 |           opening_brackets_iter.next();\n   |                     \
    \            ^^^^ method cannot be called on `Rev<Enumerate<Chars<'_>>>` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = vec![0usize];\n    let mut\
    \ bracket_counts: HashMap<usize, usize> = HashMap::new();\n    for idx in 0..brackets.len()\
    \ {\n        match brackets[idx] {\n            \"(\" => {\n                stack.push(idx);\n\
    \            }\n            \")\" => {\n                bracket_counts.entry(stack.pop()).or_insert(0usize)\
    \ += 1;\n            }\n            _ => {\n                return false;\n  \
    \          }\n        }\n    }\n    for value in bracket_counts.keys() {\n   \
    \     if value % 2 == 1 {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpohkhs9ri.rs:13:29\n\
    \   |\n13 |     let mut bracket_counts: HashMap<usize, usize> = HashMap::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpohkhs9ri.rs:13:53\n   |\n13 |     let mut bracket_counts: HashMap<usize,\
    \ usize> = HashMap::new();\n   |                                             \
    \        ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpohkhs9ri.rs:15:15\n\
    \   |\n15 |         match brackets[idx] {\n   |               ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpohkhs9ri.rs:20:69\n\
    \   |\n20 |                 bracket_counts.entry(stack.pop()).or_insert(0usize)\
    \ += 1;\n   |                 ---------------------------------------------------\
    \ ^^\n   |                 |\n   |                 cannot assign to this expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0277, E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0067`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // The algorithm we use in python is slightly different\
    \ than the algorithm\n    // we use in Rust. So we implement a slightly different\
    \ algorithm in Rust and\n    // call the python function with it.\n    // We use\
    \ the following algorithm to find the correct brackets:\n    // For each open\
    \ bracket, push it onto a stack and pop a matching close bracket\n    // from\
    \ the stack. If it matches then all brackets in the brackets string\n    // were\
    \ correctly matched. If it doesn't match, then the brackets string\n    // was\
    \ not correctly matched. For example, if the brackets string were \"()\",\n  \
    \  // then after the first opening bracket, the stack would contain an empty string.\n\
    \    // After the first close bracket, the stack would contain the opening bracket\n\
    \    // again and so on until we run out of open brackets and then a matching\n\
    \    // close bracket or run out of brackets. At the end of the string, brackets\
    \ were\n    // correctly matched if we had a matching open bracket for every close\
    \ bracket.\n    brackets\n        .chars()\n        .filter(|c| !c.is_ascii_alphabetic())\n\
    \        .all(|c| {\n            if c == ')' {\n                let len = brackets.len();\n\
    \                let mut stack = Vec::new();\n                let mut close_bracket\
    \ = false;\n\n                let mut open_brackets = Vec::new();\n          \
    \      for i in 0..len {\n                    if brackets[..i+1] == \"(\" {\n\
    \                        open_brackets.push(i);\n                    } else {\n\
    \                        close_bracket = true;\n                    }\n      \
    \          }\n\n                while !close_bracket {\n                    let\
    \ open_open = open_brackets.pop();\n                    let open = &brackets[..open_open];\n\
    \                    let close = &brackets[open_open+1 .. len];\n            \
    \        if close == \"(\" || close == \")\" {\n                        stack.push(open);\n\
    \                    } else {\n                        close_bracket = true;\n\
    \                    }\n                }\n                stack.clear();\n  \
    \              stack.push(brackets);\n                close_bracket\n        \
    \    } else {\n                let len = brackets.len();\n                let\
    \ mut stack = Vec::new();\n                let mut close_bracket = false;\n\n\
    \                let mut open_brackets = Vec::new();\n                for i in\
    \ 0..len {\n                    if brackets[..i+1] == \"(\" {\n              \
    \          open_brackets.push(i);\n                    } else {\n            \
    \            close_bracket = true;\n                    }\n                }\n\
    \n                while !close_bracket {\n                    let open_open =\
    \ open_brackets.pop();\n                    let open = &brackets[..open_open\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpkk_tf40f.rs:89:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n28 |      \
    \   .all(|c| {\n   |             -    - unclosed delimiter\n   |             |\n\
    \   |             unclosed delimiter\n...\n56 |             } else {\n   |   \
    \                 - unclosed delimiter\n...\n70 |                 while !close_bracket\
    \ {\n   |                                      - this delimiter might not be properly\
    \ closed...\n...\n73 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n89 | }\n   |   ^\n\nerror: expected one of `.`, `;`, `?`, `else`, or an operator,\
    \ found `}`\n  --> /tmp/tmpkk_tf40f.rs:73:1\n   |\n73 | }\n   | ^ expected one\
    \ of `.`, `;`, `?`, `else`, or an operator\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpkk_tf40f.rs:72:41\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                                 - closing\
    \ delimiter possibly meant for this\n...\n72 |                     let open =\
    \ &brackets[..open_open\n   |                                         ^ unclosed\
    \ delimiter\n73 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: can't\
    \ compare `str` with `&str`\n  --> /tmp/tmpkk_tf40f.rs:36:40\n   |\n36 |     \
    \                if brackets[..i+1] == \"(\" {\n   |                         \
    \               ^^ no implementation for `str == &str`\n   |\n   = help: the trait\
    \ `PartialEq<&str>` is not implemented for `str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `RangeTo<Option<usize>>`\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = 0;\n    let mut closing_brackets\
    \ = 0;\n\n    for ch in &brackets {\n        if ch == '(' {\n            opening_brackets\
    \ += 1;\n        } else if ch == ')' {\n            closing_brackets += 1;\n \
    \       }\n    }\n\n    opening_brackets == closing_brackets\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmp46x5qwmh.rs:15:15\n\
    \   |\n15 |     for ch in &brackets {\n   |               ^^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| *c != ')')\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpt0lvpzk7.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c != ')')\n   |                    \
    \          ^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut iter = brackets.chars().enumerate().peekable();\n\
    \    while let Some((i, ch)) = iter.next() {\n        let next_ch = iter.peek();\n\
    \        if next_ch.is_none() {\n            return false;\n        }\n      \
    \  if ch == '(' && next_ch.unwrap() == '(' {\n            iter.next();\n     \
    \   } else if ch == ')' && next_ch.unwrap() == ')' {\n            iter.next();\n\
    \        } else {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&(usize, char)` with `char`\n  --> /tmp/tmphfq6qxzm.rs:18:42\n\
    \   |\n18 |         if ch == '(' && next_ch.unwrap() == '(' {\n   |          \
    \                                ^^ no implementation for `&(usize, char) == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&(usize,\
    \ char)`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             ()\n             (A, B, C, D, E, F, G, H, I, J, K, L)\n        \
    \     (B, C, D, E, F, G, H, I, J, K, L)\n             (C, D, E, F, G, H, I, J,\
    \ K, L)\n             (D, E, F, G, H, I, J, K, L)\n             (E, F, G, H, I,\
    \ J, K, L)\n             (F, G, H, I, J, K, L)\n             (G, H, I, J, K, L)\n\
    \           and 5 others\n\nerror[E0277]: can't compare `&(usize, char)` with\
    \ `char`\n  --> /tmp/tmphfq6qxzm.rs:20:49\n   |\n20 |         } else if ch ==\
    \ ')' && next_ch.unwrap() == ')' {\n   |                                     \
    \            ^^ no implementation for `&(usize, char) == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&(usize, char)`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             ()\n\
    \             (A, B, C, D, E, F, G, H, I, J, K, L)\n             (B, C, D, E,\
    \ F, G, H, I, J, K, L)\n             (C, D, E, F, G, H, I, J, K, L)\n        \
    \     (D, E, F, G, H, I, J, K, L)\n             (E, F, G, H, I, J, K, L)\n   \
    \          (F, G, H, I, J, K, L)\n             (G, H, I, J, K, L)\n          \
    \ and 5 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut pos = 0;\n    let mut open_brackets = brackets.chars().filter(|c|\
    \ *c == ' ').count();\n    let mut close_brackets = brackets.chars().filter(|c|\
    \ *c == ' ').count();\n    let mut open_brackets_found = false;\n    let mut close_brackets_found\
    \ = false;\n\n    while pos < brackets.len() {\n        match brackets[pos] {\n\
    \            '(' => { open_brackets++; open_brackets_found = true; },\n      \
    \      ')' => { close_brackets++; close_brackets_found = true; },\n          \
    \  _ => {}\n        }\n        pos++;\n    }\n\n    if open_brackets == 0 || !open_brackets_found\
    \ || close_brackets == 0 || !close_brackets_found {\n        return false;\n \
    \   }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n \
    \   assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpos178nzt.rs:20:35\n\
    \   |\n20 |             '(' => { open_brackets++; open_brackets_found = true;\
    \ },\n   |                                   ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n20 |             '(' => { { let tmp = open_brackets;\
    \ open_brackets += 1; tmp }; open_brackets_found = true; },\n   |            \
    \          +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n20 -        \
    \     '(' => { open_brackets++; open_brackets_found = true; },\n20 +         \
    \    '(' => { open_brackets += 1; open_brackets_found = true; },\n   | \n\nerror:\
    \ Rust has no postfix increment operator\n  --> /tmp/tmpos178nzt.rs:21:36\n  \
    \ |\n21 |             ')' => { close_brackets++; close_brackets_found = true;\
    \ },\n   |                                    ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n21 |             ')' => { { let tmp = close_brackets;\
    \ close_brackets += 1; tmp }; close_brackets_found = true; },\n   |          \
    \            +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n21 -    \
    \         ')' => { close_brackets++; close_brackets_found = true; },\n21 +   \
    \          ')' => { close_brackets += 1; close_brackets_found = true; },\n   |\
    \ \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpos178nzt.rs:24:12\n\
    \   |\n24 |         pos++;\n   |            ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n24 |         { let tmp = pos; pos += 1;\
    \ tmp };\n   |         +++++++++++    ~~~~~~~~~~~~~~~~~\n24 -         pos++;\n\
    24 +         pos += 1;\n   | \n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpos178nzt.rs:19:15\n   |\n19 |         match brackets[pos]\
    \ {\n   |               ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut s = String::new();\n    for ch in brackets.chars()\
    \ {\n        s.push(char2byte(ch));\n    }\n\n    let mut is_balanced = false;\n\
    \    for (i, ch) in s.char_indices() {\n        if *ch == '(' {\n            is_balanced\
    \ = true;\n        }\n\n        if *ch == ')' {\n            if is_balanced {\n\
    \                is_balanced = false;\n                continue;\n           \
    \ }\n            is_balanced = false;\n        }\n\n        if is_balanced {\n\
    \            is_balanced = false;\n            continue;\n        }\n\n      \
    \  return false;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `char2byte` in this scope\n  --> /tmp/tmp65375zyy.rs:14:16\n\
    \   |\n14 |         s.push(char2byte(ch));\n   |                ^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0614]: type `char` cannot be dereferenced\n  -->\
    \ /tmp/tmp65375zyy.rs:19:12\n   |\n19 |         if *ch == '(' {\n   |        \
    \    ^^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp65375zyy.rs:23:12\n\
    \   |\n23 |         if *ch == ')' {\n   |            ^^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0614.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n\n    for bracket in brackets {\n       \
    \ if bracket == '(' {\n            opening_brackets.push_str(\"(\");\n       \
    \ } else if bracket == ')' {\n            closing_brackets.push_str(\")\");\n\
    \        } else {\n            opening_brackets.push_str(\"(\");\n           \
    \ closing_brackets.push_str(\")\");\n        }\n    }\n\n    if opening_brackets\
    \ != closing_brackets {\n        return false;\n    }\n\n    let mut opening_brackets_iter\
    \ = opening_brackets.char_indices();\n    let mut closing_brackets_iter = closing_brackets.char_indices();\n\
    \    let mut opening_brackets_end = opening_brackets_iter.next();\n    let mut\
    \ closing_brackets_end = closing_brackets_iter.next();\n\n    while let Some(opening_bracket)\
    \ = opening_brackets_end {\n        let closing_bracket = closing_brackets_end.unwrap();\n\
    \        if opening_brackets_iter.next() != Some(closing_bracket) {\n        \
    \    return false;\n        }\n        opening_brackets_end = opening_brackets_iter.next();\n\
    \        closing_brackets_end = closing_brackets_iter.next();\n    }\n\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpkk950li7.rs:15:20\n\
    \   |\n15 |     for bracket in brackets {\n   |                    ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_lowercase();\n    brackets\
    \ = brackets.replace('(', ' ');\n    brackets = brackets.replace(')', ' ');\n\
    \    brackets = brackets.replace(' ', '');\n    let mut count = 0;\n    for ch\
    \ in brackets.chars().cloned() {\n        if *ch == '(' {\n            count +=\
    \ 1;\n        } else if *ch == ')' {\n            count -= 1;\n        }\n   \
    \     if count < 0 {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpawoijyc8.rs:15:39\n   |\n\
    15 |     brackets = brackets.replace(' ', '');\n   |                         \
    \              ^ empty character literal\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpawoijyc8.rs:13:38\n   |\n13 |     brackets = brackets.replace('(',\
    \ ' ');\n   |                                      ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n13 |     brackets = brackets.replace('(', \" \");\n   |               \
    \                       ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpawoijyc8.rs:14:38\n\
    \   |\n14 |     brackets = brackets.replace(')', ' ');\n   |                 \
    \                     ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n14 |     brackets = brackets.replace(')',\
    \ \" \");\n   |                                      ~~~\n\nerror[E0271]: type\
    \ mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpawoijyc8.rs:17:32\n\
    \     |\n17   |     for ch in brackets.chars().cloned() {\n     |            \
    \                    ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `char`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmpawoijyc8.rs:17:15\n   |\n17 |     for\
    \ ch in brackets.chars().cloned() {\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpawoijyc8.rs:17:15\n   |\n17 |     for ch in brackets.chars().cloned()\
    \ {\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected ty"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().enumerate().all(|(idx, c)| {\n     \
    \   let closing_bracket = char::from(')').unwrap();\n        let closing_bracket\
    \ = closing_bracket.cmp(&c).unwrap();\n        closing_bracket == 0 || idx > 1\n\
    \    })\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpkeh80nyc.rs:13:47\n   |\n13 |         let closing_bracket\
    \ = char::from(')').unwrap();\n   |                                          \
    \     ^^^^^^ method not found in `char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.len() == brackets.chars().filter_map(|c| {\n\
    \        if c == '(' || c == '[' || c == '{' {\n            Some(')')\n      \
    \  } else {\n            None\n        }\n    }).count() == brackets.len()\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpxhxt7q7u.rs:12:20\n\
    \   |\n12 |     brackets.len() == brackets.chars().filter_map(|c| {\n   |    \
    \                ^^\n...\n18 |     }).count() == brackets.len()\n   |        \
    \        ^^\n   |\nhelp: split the comparison into two\n   |\n18 ~     }).count()\
    \ && brackets.chars().filter_map(|c| {\n19 +         if c == '(' || c == '[' ||\
    \ c == '{' {\n20 +             Some(')')\n21 +         } else {\n22 +        \
    \     None\n23 +         }\n ...\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxhxt7q7u.rs:18:19\n\
    \   |\n18 |     }).count() == brackets.len()\n   |                   ^^^^^^^^^^^^^^\
    \ expected `bool`, found `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // count the number of open brackets, and\n    // the\
    \ number of closing brackets\n    let open_brackets = brackets.chars().filter(|x|\
    \ x == '(').count();\n    let close_brackets = brackets.chars().filter(|x| x ==\
    \ ')').count();\n    open_brackets == close_brackets\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgjl1pwul.rs:14:55\n\
    \   |\n14 |     let open_brackets = brackets.chars().filter(|x| x == '(').count();\n\
    \   |                                                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgjl1pwul.rs:15:56\n\
    \   |\n15 |     let close_brackets = brackets.chars().filter(|x| x == ')').count();\n\
    \   |                                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut position = 0;\n    let mut brackets_reversed\
    \ = brackets.chars().fold(String::new(), |mut s, c| {\n        if s == '(' {\n\
    \            s.push(c);\n        } else if s == '{' {\n            s.push(c);\n\
    \        } else if s == '}' {\n            s.push(c);\n        } else if s ==\
    \ ')' {\n            if s.len() == 3 {\n                s.push_str(\")(\");\n\
    \            } else {\n                s.push(c);\n            }\n        }\n\
    \        s;\n    });\n    while position < brackets_reversed.len() {\n       \
    \ let opening = brackets_reversed.chars().skip_while(|c| c != ')').take_while(|c|\
    \ c != '(').next();\n        let closing = brackets_reversed.chars().skip_while(|c|\
    \ c != ')').take_while(|c| c != '(').next();\n        if closing == Some(opening)\
    \ {\n            // This bracket is correctly closed\n            position +=\
    \ 1;\n        } else if opening == Some(closing) {\n            // This bracket\
    \ is correctly opened\n            position += 1;\n        } else if opening !=\
    \ None {\n            // The opening bracket doesn't have a corresponding closing\
    \ bracket\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpmxo1_afv.rs:14:14\n\
    \   |\n14 |         if s == '(' {\n   |              ^^ no implementation for\
    \ `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmpmxo1_afv.rs:16:21\n   |\n16 |         }\
    \ else if s == '{' {\n   |                     ^^ no implementation for `String\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmpmxo1_afv.rs:18:21\n   |\n18 |         }\
    \ else if s == '}' {\n   |                     ^^ no implementation for `String\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as Parti"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| *c != '(' && '*' != c)\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp437hvdab.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c != '(' && '*' != c)\n   |        \
    \                      ^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    for ch in &brackets {\n\
    \        if ch == '(' {\n            stack.push('(');\n        } else if ch ==\
    \ ')' {\n            if stack.is_empty() {\n                return false;\n  \
    \          } else {\n                stack.pop();\n            }\n        } else\
    \ if ch == '[' {\n            stack.push('[');\n        } else if ch == ']' {\n\
    \            if stack.is_empty() {\n                return false;\n          \
    \  } else {\n                stack.pop();\n            }\n        } else if ch\
    \ == '{' {\n            stack.push('{');\n        } else if ch == '}' {\n    \
    \        if stack.is_empty() {\n                return false;\n            } else\
    \ {\n                stack.pop();\n            }\n        } else {\n         \
    \   // Ignore all other brackets.\n        }\n    }\n    stack.is_empty()\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpglnf4euf.rs:13:15\n\
    \   |\n13 |     for ch in &brackets {\n   |               ^^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_brackets = 0;\n    let mut closed_brackets\
    \ = 0;\n    for ch in brackets.chars() {\n        if ch == '(' { open_brackets++\
    \ } else if ch == ')' { closed_brackets++ }\n        } else if ch == ')' {\n \
    \           if open_brackets == 0 {\n                return false;\n         \
    \   }\n            open_brackets--;\n        } else if ch == '(' {\n         \
    \   if closed_brackets == 0 {\n                return false;\n            }\n\
    \            closed_brackets--;\n        }\n    }\n\n    open_brackets == closed_brackets\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpo_yy2eob.rs:30:1\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - this opening brace...\n...\n27 |   \
    \  }\n   |     - ...matches this closing brace\n...\n30 | }\n   | ^ unexpected\
    \ closing delimiter\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut current = String::new();\n    let mut next =\
    \ [String::new()];\n    for ch in brackets {\n        match ch {\n           \
    \ '(' | ')' | ' ' | '\\n' | '\\t' => {\n                let mut last = current.len();\n\
    \                next[0].clear();\n                while last < next.len() {\n\
    \                    let chr = next[last].chars().next();\n                  \
    \  match chr {\n                        Some('(') | (Some(')')) | (Some(' '))\
    \ |\n                            (Some('\\n') | (Some('\\t'))) => {\n        \
    \                    break;\n                        }\n                     \
    \   Some(c) => {\n                            if chr == Some('(') {\n        \
    \                        next[last].push(c);\n                            } else\
    \ {\n                                next[last].push(c);\n                   \
    \         }\n                            break;\n                        }\n \
    \                   }\n                    last += 1;\n                }\n   \
    \             if current.len() != last.clone() {\n                    return false;\n\
    \                }\n            }\n            c => {\n                current.push_str(&c);\n\
    \                next.push(String::new());\n            }\n        }\n    }\n\
    \    current.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around pattern\n  --> /tmp/tmpadqhfa8n.rs:22:37\n\
    \   |\n22 |                         Some('(') | (Some(')')) | (Some(' ')) |\n\
    \   |                                     ^         ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n22 -                  \
    \       Some('(') | (Some(')')) | (Some(' ')) |\n22 +                        \
    \ Some('(') | Some(')') | (Some(' ')) |\n   | \n\nwarning: unnecessary parentheses\
    \ around pattern\n  --> /tmp/tmpadqhfa8n.rs:22:51\n   |\n22 |                \
    \         Some('(') | (Some(')')) | (Some(' ')) |\n   |                      \
    \                             ^         ^\n   |\nhelp: remove these parentheses\n\
    \   |\n22 -                         Some('(') | (Some(')')) | (Some(' ')) |\n\
    22 +                         Some('(') | (Some(')')) | Some(' ') |\n   | \n\n\
    warning: unnecessary parentheses around pattern\n  --> /tmp/tmpadqhfa8n.rs:23:29\n\
    \   |\n23 | ...                   (Some('\\n') | (Some('\\t'))) => {\n   |   \
    \                    ^                         ^\n   |\nhelp: remove these parentheses\n\
    \   |\n23 -                             (Some('\\n') | (Some('\\t'))) => {\n23\
    \ +                             Some('\\n') | (Some('\\t')) => {\n   | \n\nwarning:\
    \ unnecessary parentheses around pattern\n  --> /tmp/tmpadqhfa8n.rs:23:43\n  \
    \ |\n23 | ...                   (Some('\\n') | (Some('\\t'))) => {\n   |     \
    \                                ^          ^\n   |\nhelp: remove these parentheses\n\
    \   |\n23 -                             (Some('\\n') | (Some('\\t'))) => {\n23\
    \ +                             (Some('\\n') | Some('\\t')) => {\n   | \n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmpadqhfa8n.rs:14:15\n   |\n14 |   \
    \  for ch in brackets {\n   |               ^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nwarning: unreachable statement\n\
    \  --> /tmp/tmpadqhfa8n.rs:35:21\n   |\n21 | /         "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut cur_bracket = String::new();\n    let mut last_bracket\
    \ = String::new();\n    for b in brackets.chars() {\n        if b == '(' {\n \
    \           cur_bracket = String::new();\n            last_bracket = String::new();\n\
    \        }\n        if b == ')' {\n            if !cur_bracket.is_empty() || !last_bracket.is_empty()\
    \ {\n                return false;\n            }\n        }\n        if !cur_bracket.is_empty()\
    \ || !last_bracket.is_empty() {\n            last_bracket.push_str(&cur_bracket);\n\
    \            last_bracket = String::new();\n        }\n        cur_bracket.push_str(&b);\n\
    \    }\n    if !last_bracket.is_empty() {\n        return false;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqwo7u3kr.rs:28:30\n   |\n\
    28 |         cur_bracket.push_str(&b);\n   |                              ^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // We use a Set to hold the unmatched closing brackets.\n\
    \    let mut unmatched = std::collections::HashSet::new();\n    // Our state is\
    \ \"open\" or \"closed\".\n    let mut state = \"open\";\n    // We use two iterators\
    \ to process each character.\n    let mut left = brackets.chars().nth(0).unwrap();\n\
    \    let mut right = brackets.chars().nth(1).unwrap();\n    while !left.is_none()\
    \ && left.unwrap_or('(') != right.unwrap_or(')') {\n        // If the previous\
    \ character was a close, set state to \"closed\" and\n        // set the unmatched\
    \ closing brackets.\n        if state == \"close\" {\n            state = \"open\"\
    ;\n            unmatched = std::collections::HashSet::new();\n        }\n    \
    \    // If the previous character was an open, do nothing.\n        if state ==\
    \ \"open\" {\n            // If the previous character is ')', set state to \"\
    open\" and\n            // add the closing bracket to the unmatched closing brackets.\n\
    \            if left.unwrap_or(')') != ')' {\n                state = \"open\"\
    ;\n                unmatched.insert(right.unwrap_or(')'));\n            }\n  \
    \          // If the previous character is ')', set state to \"closed\" and\n\
    \            // add the opening bracket to the unmatched opening brackets.\n \
    \           else if left.unwrap_or(')') == '(' {\n                state = \"closed\"\
    ;\n                unmatched.insert(left.unwrap_or('('));\n            }\n   \
    \         // If the previous character is ')', set state to \"closed\" and\n \
    \           // add the previous character to the unmatched opening brackets.\n\
    \            // This happens when the two characters are the same.\n         \
    \   else\n                state = \"open\";\n        }\n        // Advance the\
    \ left iterator one character at a time.\n        left = left.chars().nth(1).unwrap();\n\
    \        // Advance the right iterator one character at a time.\n        right\
    \ = right.chars().nth(1).unwrap();\n    }\n    state == \"closed\" && unmatched.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `state`\n  --> /tmp/tmpgr536vpo.rs:44:17\n \
    \  |\n44 |                 state = \"open\";\n   |                 ^^^^^ expected\
    \ `{`\n   |\nhelp: try placing this code inside a block\n   |\n44 |          \
    \       { state = \"open\"; }\n   |                 +                 +\n\nerror[E0599]:\
    \ no method named `is_none` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpgr536vpo.rs:19:17\n   |\n19 |     while !left.is_none() && left.unwrap_or('(')\
    \ != right.unwrap_or(')') {\n   |                 ^^^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `unwrap_or` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpgr536vpo.rs:19:35\n   |\n19 |     while !left.is_none()\
    \ && left.unwrap_or('(') != right.unwrap_or(')') {\n   |                     \
    \              ^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `unwrap_or` found for type `char` in the current scope\n  --> /tmp/tmpgr536vpo.rs:19:59\n\
    \   |\n19 |     while !left.is_none() && left.unwrap_or('(') != right.unwrap_or(')')\
    \ {\n   |                                                           ^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `chars` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpgr536vpo.rs:47:21\n   |\n47\
    \ |         left = left.chars().nth(1).unwrap();\n   |                     ^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `chars` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpgr536vpo.rs:49:23\n   |\n49\
    \ |         right = right.chars().nth(1).unwrap();\n   |                     \
    \  ^^^^^ method not found in `char`\n\nerror: aborting due to 6 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '(' || c == ')')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpaql1ki1w.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![];\n    stack.push(brackets);\n\
    \    while !stack.is_empty() {\n        let brackets = stack.pop();\n        if\
    \ brackets == \"\" {\n            continue;\n        }\n        if let Some(index)\
    \ = brackets.find(\"(\") {\n            if brackets[index + 1: brackets.len()]\
    \ != \")\" {\n                return false;\n            }\n        }\n      \
    \  if let Some(index) = brackets.find(\")\") {\n            if brackets[index\
    \ + 1: brackets.len()] != \")\" {\n                return false;\n           \
    \ }\n        }\n        if let Some(index) = brackets.find(\"{\") {\n        \
    \    if brackets[index + 1: brackets.len()] != \"}\" {\n                return\
    \ false;\n            }\n        }\n        if let Some(index) = brackets.find(\"\
    }\") {\n            if brackets[index + 1: brackets.len()] != \"}\" {\n      \
    \          return false;\n            }\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpi1edvano.rs:20:33\n\
    \   |\n20 |             if brackets[index + 1: brackets.len()] != \")\" {\n  \
    \ |                                 ^----------\n   |                        \
    \          |\n   |                                  help: remove the type ascription\n\
    \nerror: casts cannot be followed by a method call\n  --> /tmp/tmpi1edvano.rs:25:33\n\
    \   |\n25 |             if brackets[index + 1: brackets.len()] != \")\" {\n  \
    \ |                                 ^----------\n   |                        \
    \          |\n   |                                  help: remove the type ascription\n\
    \nerror: casts cannot be followed by a method call\n  --> /tmp/tmpi1edvano.rs:30:33\n\
    \   |\n30 |             if brackets[index + 1: brackets.len()] != \"}\" {\n  \
    \ |                                 ^----------\n   |                        \
    \          |\n   |                                  help: remove the type ascription\n\
    \nerror: casts cannot be followed by a method call\n  --> /tmp/tmpi1edvano.rs:35:33\n\
    \   |\n35 |             if brackets[index + 1: brackets.len()] != \"}\" {\n  \
    \ |                                 ^----------\n   |                        \
    \          |\n   |                                  help: remove the type ascription\n\
    \nerror[E0573]: expected type, found local variable `brackets`\n  --> /tmp/tmpi1edvano.rs:20:36\n\
    \   |\n20 |             if brackets[index + 1: brackets.len()] != \")\" {\n  \
    \ |                                    ^^^^^^^^\n   |                        \
    \            |\n   |                                    not a type\n   |     \
    \                               help: maybe you meant to write an assignment here:\
    \ `let brackets`\n\nerror[E0573]: expected type, found local variable `brackets`\n\
    \  --> /tmp/tmpi1edvano.rs:25:36\n   |\n25 |             if brackets[index + 1:\
    \ brackets.len()] != \")\" {\n   |                                    ^^^^^^^^\n\
    \   |                                    |\n   |                             \
    \       not a type\n   |                                    help: maybe you meant\
    \ to write an assignmen"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().count(|c| c == '(') == 0\n        &&\
    \ brackets.chars().count(|c| c == ')') == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpp9abmktj.rs:12:22\n    |\n12  |     brackets.chars().count(|c|\
    \ c == '(') == 0\n    |                      ^^^^^ ------------ supplied 1 argument\n\
    \    |                      |\n    |                      expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpp9abmktj.rs:13:29\n\
    \    |\n13  |         && brackets.chars().count(|c| c == ')') == 0\n    |    \
    \                         ^^^^^ ------------ supplied 1 argument\n    |      \
    \                       |\n    |                             expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut i = 0;\n    while i < brackets.len() {\n    \
    \    if brackets[i] != brackets[i + 1] {\n            return false;\n        }\n\
    \        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp27lb_lic.rs:14:12\n\
    \   |\n14 |         if brackets[i] != brackets[i + 1] {\n   |            ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp27lb_lic.rs:14:27\n   |\n14 |         if brackets[i] != brackets[i\
    \ + 1] {\n   |                           ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().any(|c| *c != '(' && c != ')')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp06exhpn7.rs:12:30\n\
    \   |\n12 |     brackets.chars().any(|c| *c != '(' && c != ')')\n   |        \
    \                      ^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets == brackets.replace(\"(\", \"(\").replace(\"\
    )\", \")\").to_string()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpl7dy7kng.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_bracket = 0;\n    let mut close_bracket\
    \ = 0;\n    for c in brackets.chars() {\n        if c == '(' {\n            open_bracket++;\n\
    \        } else if c == '(' as char {\n            open_bracket++;\n        }\
    \ else if c == ')' {\n            close_bracket++;\n        } else if c == ')'\
    \ as char {\n            close_bracket++;\n        }\n\n        if open_bracket\
    \ == close_bracket {\n            // No closing bracket - no chance of correct\
    \ bracketing.\n            return false;\n        }\n    }\n    // If open_bracket,\
    \ close_bracket and brackets match, it means brackets are good.\n    return true;\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpi6619dwm.rs:16:25\n\
    \   |\n16 |             open_bracket++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n16 |         \
    \    { let tmp = open_bracket; open_bracket += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n16 -             open_bracket++;\n16\
    \ +             open_bracket += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpi6619dwm.rs:18:25\n   |\n18 |             open_bracket++;\n\
    \   |                         ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n18 |             { let tmp = open_bracket; open_bracket\
    \ += 1; tmp };\n   |             +++++++++++             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    18 -             open_bracket++;\n18 +             open_bracket += 1;\n   | \n\
    \nerror: Rust has no postfix increment operator\n  --> /tmp/tmpi6619dwm.rs:20:26\n\
    \   |\n20 |             close_bracket++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n20 |       \
    \      { let tmp = close_bracket; close_bracket += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n20 -             close_bracket++;\n\
    20 +             close_bracket += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpi6619dwm.rs:22:26\n   |\n22 |             close_bracket++;\n\
    \   |                          ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n22 |             { let tmp = close_bracket; close_bracket\
    \ += 1; tmp };\n   |             +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    22 -             close_bracket++;\n22 +             close_bracket += 1;\n   |\
    \ \n\nerror: aborting due to 4 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Stack::new();\n    stack.push(-1);\n\n\
    \    for ch in brackets.chars() {\n        let mut depth = 0;\n        let mut\
    \ open = ch as usize;\n        let mut close = open as usize;\n        while let\
    \ Some(index) = (stack.last_mut().unwrap()).pop() {\n            match index {\n\
    \                -1 => return false,\n                i if i >= open => {\n  \
    \                  let mut new_depth = i - open;\n                    new_depth\
    \ += depth;\n                    stack.push(new_depth);\n                    open\
    \ = i;\n                    close = i;\n                }\n                _ =>\
    \ depth = i,\n            }\n        }\n        stack.push(depth);\n        stack.push(open);\n\
    \        stack.push(close);\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmp_t8eb7a7.rs:12:21\n   |\n12 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmp_t8eb7a7.rs:29:30\n   |\n\
    29 |                 _ => depth = i,\n   |                              ^ not\
    \ found in this scope\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmp_t8eb7a7.rs:21:17\n   |\n21 |                 -1 => return false,\n\
    \   |                 ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // TODO: This could be optimized by keeping track of\
    \ all the brackets\n    // seen, so we can check if each opening bracket has a\
    \ corresponding closing bracket.\n\n    // TODO: Refactor to improve readability\n\
    \n    let mut seen_open_brackets = HashMap::new();\n\n    for open_bracket in\
    \ brackets.chars().filter_map(|c| {\n        match c {\n            ')' => false,\n\
    \            '('  => true,\n            _   => false\n        }\n    }) {\n  \
    \      // TODO: Refactor to improve readability\n        match open_bracket {\n\
    \            ')' => seen_open_brackets.remove(&open_bracket),\n            '('\
    \  => seen_open_brackets.insert(&open_bracket, false),\n            _   => {}\n\
    \        }\n    }\n    seen_open_brackets.is_empty()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp5p5ee75q.rs:17:34\n   |\n17 |     let mut seen_open_brackets = HashMap::new();\n\
    \   |                                  ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5p5ee75q.rs:21:20\n   |\n\
    21 |             ')' => false,\n   |                    ^^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n21 |       \
    \      ')' => Some(false),\n   |                    +++++     +\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut curr = 1;\n    let mut prev = 0;\n    let mut\
    \ brackets_iter = brackets.chars().enumerate();\n\n    while let Some((idx, c))\
    \ = brackets_iter.next() {\n        let next = idx + 1;\n        if c != brackets[idx]\
    \ {\n            return false;\n        }\n\n        let mut new_curr = curr;\n\
    \        let mut new_prev = prev;\n\n        if idx == 0 {\n            new_curr\
    \ += 1;\n            new_prev -= 1;\n        }\n\n        let bracket = brackets[idx];\n\
    \n        if next == 0 {\n            new_curr += 1;\n        }\n\n        if\
    \ bracket.len() != 1 {\n            return false;\n        }\n\n        if bracket.chars().count(|c|\
    \ *c != c) == 0 {\n            return false;\n        }\n\n        prev = new_prev;\n\
    \        curr = new_curr;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpokgxhck3.rs:18:17\n\
    \   |\n18 |         if c != brackets[idx] {\n   |                 ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpokgxhck3.rs:30:23\n   |\n30 |         let bracket = brackets[idx];\n\
    \   |                       ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.is_empty() || brackets.len() == 1 || brackets[0]\
    \ == '(' && brackets[1] == ')'\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmplc0uspjp.rs:12:51\n   |\n12 |     brackets.is_empty() || brackets.len()\
    \ == 1 || brackets[0] == '(' && brackets[1] == ')'\n   |                     \
    \                              ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmplc0uspjp.rs:12:73\n   |\n12 |     brackets.is_empty() || brackets.len()\
    \ == 1 || brackets[0] == '(' && brackets[1] == ')'\n   |                     \
    \                                                    ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut chars = String::new();\n    chars.push_str(brackets);\n\
    \    chars.push_str(\")\");\n    chars.push_str(\"(\");\n    for c in chars.chars()\
    \ {\n        match c {\n            '(' | ')' => {\n                println!(\"\
    {}\", c);\n                return false;\n            }\n            _ => (),\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpia_su3wm.rs:13:20\n   |\n\
    13 |     chars.push_str(brackets);\n   |                    ^^^^^^^^\n   |   \
    \                 |\n   |                    expected `&str`, found struct `String`\n\
    \   |                    help: consider borrowing here: `&brackets`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for ch in brackets.chars()\
    \ {\n        if !is_open_bracket(ch, &mut stack) {\n            return false;\n\
    \        }\n    }\n    if stack.len() == 0 {\n        return true;\n    }\n  \
    \  let mut last = stack.pop().unwrap();\n    let mut current = last;\n    for\
    \ ch in brackets.chars() {\n        if ch == current {\n            continue;\n\
    \        }\n        let next = if let Some(next) = stack.pop() {\n           \
    \ next\n        } else {\n            last\n        };\n        stack.push(next);\n\
    \        last = ch;\n        current = ch;\n    }\n    stack.push(last);\n   \
    \ false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_open_bracket` in this scope\n  -->\
    \ /tmp/tmpx9t603jc.rs:14:13\n   |\n14 |         if !is_open_bracket(ch, &mut stack)\
    \ {\n   |             ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut open_count = 1;\n    let mut close_count = 1;\n\
    \    let mut last_open = 0;\n    let mut last_close = 0;\n    for i in brackets.chars().cloned()\
    \ {\n        if *i == ' ' {\n            open_count += 1;\n            last_open\
    \ = i;\n        }\n        if *i == '(' {\n            open_count += 1;\n    \
    \        last_open = i;\n        }\n        if *i == ')' {\n            if open_count\
    \ > close_count {\n                return false;\n            }\n            open_count\
    \ -= 1;\n            last_close = i;\n        }\n        if *i == ']' {\n    \
    \        if open_count > close_count {\n                return false;\n      \
    \      }\n            open_count -= 1;\n            last_close = i;\n        }\n\
    \        if *i == '[' {\n            if open_count > close_count {\n         \
    \       return false;\n            }\n            open_count -= 1;\n         \
    \   last_close = i;\n        }\n    }\n    if open_count != close_count {\n  \
    \      return false;\n    }\n    if last_open != last_close {\n        return\
    \ false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp1j60_h07.rs:16:31\n     |\n16   |     for i in brackets.chars().cloned()\
    \ {\n     |                               ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmp1j60_h07.rs:16:14\n\
    \   |\n16 |     for i in brackets.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmp1j60_h07.rs:16:14\n   |\n16 |     for i in brackets.chars().cloned()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        if c == ')' {\n            if !stack.is_empty() {\n             \
    \   stack.last_mut().unwrap().push(1);\n            }\n        } else {\n    \
    \        match stack.last_mut() {\n                Some(last_bracket_depth) =>\n\
    \                    last_bracket_depth.push(1),\n                None => stack.push(vec![1]),\n\
    \            }\n        }\n    }\n    let mut stack_depth = stack.len();\n   \
    \ let mut last_depth = stack.last_mut().unwrap().len();\n    while stack_depth\
    \ > 0 {\n        if stack.last()[stack_depth - last_depth] == 0 {\n          \
    \  stack_depth -= 1;\n        } else {\n            last_depth -= 1;\n       \
    \ }\n    }\n    stack_depth <= last_depth\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpvpoy70kz.rs:16:23\n\
    \   |\n12 |     let mut stack = Vec::new();\n   |         --------- consider giving\
    \ `stack` the explicit type `Vec<T>`, where the type parameter `T` is specified\n\
    ...\n16 |                 stack.last_mut().unwrap().push(1);\n   |           \
    \            ^^^^^^^^ cannot infer type for type parameter `T`\n   |\n   = note:\
    \ type must be known at this point\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().any(|c| match c {\n        '(' => false,\n\
    \        '[' => true,\n        '{' => true,\n        _ => false,\n    })\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwmw898cd.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.replace(\"(\", \"\").replace(\")\", \"\") ==\
    \ \"\"\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9l21_6r5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    if brackets == \"(\" || brackets == \"{\" || brackets\
    \ == \"[\" {\n        true\n    } else {\n        false\n    }\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqzx14uvp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut brackets = brackets.to_owned();\n    while brackets.len()\
    \ > 0 {\n        let first = brackets.chars().nth(0).unwrap();\n        let mut\
    \ second = brackets.chars().nth(1).unwrap();\n\n        if first != second {\n\
    \            if first == '(' && second == ')' {\n                brackets = brackets.to_string().split_at_mut(2).collect::<Vec<_>>();\n\
    \            } else {\n                return false;\n            }\n        }\
    \ else {\n            brackets = &brackets[2..];\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: `(&mut str, &mut str)` is not an iterator\n  --> /tmp/tmpsiummm1p.rs:19:65\n\
    \   |\n19 |                 brackets = brackets.to_string().split_at_mut(2).collect::<Vec<_>>();\n\
    \   |                                                                 ^^^^^^^\
    \ `(&mut str, &mut str)` is not an iterator\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `(&mut str, &mut str): Iterator`\n  \
    \         which is required by `&mut (&mut str, &mut str): Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsiummm1p.rs:24:24\n   |\n12 |     let mut brackets\
    \ = brackets.to_owned();\n   |                        ------------------- expected\
    \ due to this value\n...\n24 |             brackets = &brackets[2..];\n   |  \
    \                      ^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n24 |             brackets =\
    \ (&brackets[2..]).to_string();\n   |                        +              +++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.len() == brackets.chars().filter(|&c| c == '('\
    \ || c == '[').count() + brackets.chars().filter(|&c| c == '(' || c == '{').count()\
    \ + brackets.chars().filter(|&c| c == '[' || c == '(').count() + brackets.chars().filter(|&c|\
    \ c == '[' || c == '{').count()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdzaugeje.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut chars = brackets.chars();\n    loop {\n     \
    \   if let Some(open) = chars.next() {\n            if !chars.next().is_some()\
    \ {\n                return open == ')';\n            }\n        } else {\n  \
    \          break;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprv1qwltr.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| *c == ')')\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpln3rfomp.rs:12:30\n\
    \   |\n12 |     brackets.chars().all(|c| *c == ')')\n   |                    \
    \          ^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.is_empty() || brackets.chars().all(|c| c ==\
    \ '(' || c == ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_a1a0rb_.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == ')')\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe4dz4icd.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == '(' || c == '[' || c ==\
    \ '{')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpitu1owrw.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all_but(|c| *c == ')')\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `all_but` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpnl5w34x_.rs:12:22\n   |\n12 |     brackets.chars().all_but(|c|\
    \ *c == ')')\n   |                      ^^^^^^^ method not found in `Chars<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c.is_ascii_letter() || c ==\
    \ '(' || c == ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmplizhprmr.rs:12:32\n   |\n12 |     brackets.chars().all(|c|\
    \ c.is_ascii_letter() || c == '(' || c == ')')\n   |                         \
    \       ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.chars().all(|c| c == ')' || c == '(')\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9s7s_8of.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.len() >= 2 && brackets.chars().all(b => b ==\
    \ '(' || b == ')')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator,\
    \ found `=>`\n  --> /tmp/tmpnx9q3839.rs:12:51\n   |\n12 |     brackets.len() >=\
    \ 2 && brackets.chars().all(b => b == '(' || b == ')')\n   |                 \
    \                                  ^^ expected one of 8 possible tokens\n\nerror:\
    \ aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut iter = brackets.chars().enumerate();\n    iter.next().unwrap().1\
    \ == ')' && iter.next().unwrap().0 == ')' &&\n        iter.next().unwrap().0 ==\
    \ ')' &&\n        iter.next().unwrap().1 == ')' && iter.next().unwrap().0 == ')'\
    \ &&\n        iter.next().unwrap().0 == ')' && iter.next().unwrap().0 == ')'\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp74d_s_zo.rs:13:64\n   |\n\
    13 |     iter.next().unwrap().1 == ')' && iter.next().unwrap().0 == ')' &&\n \
    \  |                                                                ^^^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp74d_s_zo.rs:14:35\n\
    \   |\n14 |         iter.next().unwrap().0 == ')' &&\n   |                   \
    \                ^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp74d_s_zo.rs:15:68\n   |\n15 |         iter.next().unwrap().1\
    \ == ')' && iter.next().unwrap().0 == ')' &&\n   |                           \
    \                                         ^^^ expected `usize`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp74d_s_zo.rs:16:35\n   |\n16 |\
    \         iter.next().unwrap().0 == ')' && iter.next().unwrap().0 == ')'\n   |\
    \                                   ^^^ expected `usize`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp74d_s_zo.rs:16:68\n   |\n16 |         iter.next().unwrap().0\
    \ == ')' && iter.next().unwrap().0 == ')'\n   |                              \
    \                                      ^^^ expected `usize`, found `char`\n\n\
    error: aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut cur = 0;\n    let mut next = brackets.len();\n\
    \    let mut found = false;\n\n    while next != 0 && cur < brackets.len() {\n\
    \        let open_cur = brackets[cur];\n        let close_cur = brackets[next];\n\
    \n        if open_cur == close_cur {\n            cur += 1;\n            next\
    \ += 1;\n            continue;\n        }\n\n        if open_cur == '(' && close_cur\
    \ == ')' {\n            found |= next_token(&brackets, cur + 1).is_some();\n \
    \           cur += 1;\n            next += 1;\n            continue;\n       \
    \ }\n\n        if open_cur == '[' && close_cur == ']' {\n            found |=\
    \ next_token(&brackets, cur + 1).is_some();\n            cur += 1;\n         \
    \   next += 1;\n            continue;\n        }\n\n        if open_cur == '{'\
    \ && close_cur == '}' {\n            found |= next_token(&brackets, cur + 1).is_some();\n\
    \            cur += 1;\n            next += 1;\n            continue;\n      \
    \  }\n\n        if open_cur == '<' && close_cur == '>' {\n            found |=\
    \ next_token(&brackets, cur + 1).is_some();\n            cur += 1;\n         \
    \   next += 1;\n            continue;\n        }\n\n        found = false;\n \
    \       cur += 1;\n        next += 1;\n    }\n\n    found\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `next_token` in this scope\n  --> /tmp/tmpw_dbeld8.rs:27:22\n\
    \   |\n27 |             found |= next_token(&brackets, cur + 1).is_some();\n \
    \  |                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `next_token` in this scope\n  --> /tmp/tmpw_dbeld8.rs:34:22\n\
    \   |\n34 |             found |= next_token(&brackets, cur + 1).is_some();\n \
    \  |                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `next_token` in this scope\n  --> /tmp/tmpw_dbeld8.rs:41:22\n\
    \   |\n41 |             found |= next_token(&brackets, cur + 1).is_some();\n \
    \  |                      ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `next_token` in this scope\n  --> /tmp/tmpw_dbeld8.rs:48:22\n\
    \   |\n48 |             found |= next_token(&brackets, cur + 1).is_some();\n \
    \  |                      ^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw_dbeld8.rs:17:24\n\
    \   |\n17 |         let open_cur = brackets[cur];\n   |                      \
    \  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpw_dbeld8.rs:18:25\n   |\n18 |         let close_cur = brackets[next];\n\
    \   |                         ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String a"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.contains(\"(\") && brackets.contains(\")\")\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0phly7pi.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n    stack.push(0);\n\
    \    for i in 0..brackets.len() - 1 {\n        if stack.is_empty() {\n       \
    \     return false;\n        }\n        let top = stack.pop().unwrap();\n    \
    \    if top > i {\n            return false;\n        }\n        if brackets[i]\
    \ == '(' {\n            stack.push(i + 1);\n        }\n        else if brackets[i]\
    \ == ')' {\n            if let Some(top) = stack.pop() {\n                if top\
    \ != i + 1 {\n                    return false;\n                }\n         \
    \   }\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpi65at2_o.rs:22:12\n\
    \   |\n22 |         if brackets[i] == '(' {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpi65at2_o.rs:25:17\n   |\n25 |         else if brackets[i] == ')'\
    \ {\n   |                 ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<&str> = vec![\"(\"];\n\n    for ch\
    \ in brackets {\n        if ch == '(' {\n            if stack.is_empty() {\n \
    \               return false;\n            }\n            stack.pop().unwrap();\n\
    \        } else {\n            stack.push(ch);\n        }\n    }\n\n    if stack.len()\
    \ != 0 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpmdn3lk48.rs:14:15\n\
    \   |\n14 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmpmdn3lk48.rs:15:15\n   |\n15\
    \ |         if ch == '(' {\n   |               ^^ no implementation for `&str\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = Vec::with_capacity(brackets.len() - 1);\n\
    \    for &c in &brackets {\n        if c == '(' { stack.push('('); }\n       \
    \ if c == ')' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpoduq0ef5.rs:13:15\n\
    \   |\n13 |     for &c in &brackets {\n   |               ^^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut index = 0;\n    let mut closed = HashSet::new();\n\
    \    while index < brackets.len() {\n        match brackets[index] {\n       \
    \     '(' => closed.insert(index),\n            ')' => closed.remove(index),\n\
    \            _ => {\n                index += 1;\n            }\n        }\n \
    \   }\n    closed.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp235341tm.rs:13:22\n   |\n13 |     let mut closed = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp235341tm.rs:15:15\n\
    \   |\n15 |         match brackets[index] {\n   |               ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut state = BracketState::Open;\n    let mut current_pos\
    \ = 0;\n    while current_pos < brackets.len() {\n        if brackets[current_pos]\
    \ == '(' {\n            state = BracketState::Open;\n        } else if brackets[current_pos]\
    \ == ')' {\n            if state == BracketState::Open {\n                state\
    \ = BracketState::Closing;\n            } else {\n                return false;\n\
    \            }\n        } else {\n            return false;\n        }\n     \
    \   current_pos += 1;\n    }\n    state == BracketState::Closing\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BracketState`\n\
    \  --> /tmp/tmpkaliv1kh.rs:12:21\n   |\n12 |     let mut state = BracketState::Open;\n\
    \   |                     ^^^^^^^^^^^^ use of undeclared type `BracketState`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `BracketState`\n  -->\
    \ /tmp/tmpkaliv1kh.rs:16:21\n   |\n16 |             state = BracketState::Open;\n\
    \   |                     ^^^^^^^^^^^^ use of undeclared type `BracketState`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `BracketState`\n  -->\
    \ /tmp/tmpkaliv1kh.rs:18:25\n   |\n18 |             if state == BracketState::Open\
    \ {\n   |                         ^^^^^^^^^^^^ use of undeclared type `BracketState`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `BracketState`\n  -->\
    \ /tmp/tmpkaliv1kh.rs:19:25\n   |\n19 |                 state = BracketState::Closing;\n\
    \   |                         ^^^^^^^^^^^^ use of undeclared type `BracketState`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `BracketState`\n  -->\
    \ /tmp/tmpkaliv1kh.rs:28:14\n   |\n28 |     state == BracketState::Closing\n \
    \  |              ^^^^^^^^^^^^ use of undeclared type `BracketState`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkaliv1kh.rs:15:12\n\
    \   |\n15 |         if brackets[current_pos] == '(' {\n   |            ^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkaliv1kh.rs:17:19\n   |\n17 |         } else if brackets[current_pos]\
    \ == ')' {\n   |                   ^^^^^^^^^^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut iter = brackets.char_indices();\n    let mut\
    \ opening_brackets_seen: Vec<(usize, char)> = Vec::new();\n    let mut closing_brackets_seen:\
    \ Vec<(usize, char)> = Vec::new();\n    for (i, char) in iter.next() {\n     \
    \   if char == '(' {\n            if opening_brackets_seen.len() == 0 {\n    \
    \            opening_brackets_seen.push((i, char));\n            } else {\n  \
    \              assert_eq!(opening_brackets_seen.last().unwrap(), (i, char));\n\
    \            }\n        } else if char == ')' {\n            if closing_brackets_seen.len()\
    \ == 0 {\n                closing_brackets_seen.push((i, char));\n           \
    \ } else {\n                assert_eq!(closing_brackets_seen.last().unwrap(),\
    \ (i, char));\n            }\n        }\n    }\n    assert_eq!(opening_brackets_seen.len(),\
    \ closing_brackets_seen.len());\n    opening_brackets_seen.is_subset(closing_brackets_seen)\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&(usize, char)` with `(usize, char)`\n  -->\
    \ /tmp/tmpkikpsouj.rs:20:17\n   |\n20 |                 assert_eq!(opening_brackets_seen.last().unwrap(),\
    \ (i, char));\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ no implementation for `&(usize, char) == (usize, char)`\n   |\n   = help: the\
    \ trait `PartialEq<(usize, char)>` is not implemented for `&(usize, char)`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        ()\n             (A, B, C, D, E, F, G, H, I, J, K, L)\n             (B,\
    \ C, D, E, F, G, H, I, J, K, L)\n             (C, D, E, F, G, H, I, J, K, L)\n\
    \             (D, E, F, G, H, I, J, K, L)\n             (E, F, G, H, I, J, K,\
    \ L)\n             (F, G, H, I, J, K, L)\n             (G, H, I, J, K, L)\n  \
    \         and 5 others\n   = note: this error originates in the macro `assert_eq`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]:\
    \ can't compare `&(usize, char)` with `(usize, char)`\n  --> /tmp/tmpkikpsouj.rs:26:17\n\
    \   |\n26 |                 assert_eq!(closing_brackets_seen.last().unwrap(),\
    \ (i, char));\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ no implementation for `&(usize, char) == (usize, char)`\n   |\n   = help: the\
    \ trait `PartialEq<(usize, char)>` is not implemented for `&(usize, char)`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        ()\n             (A, B, C, D, E, F, G, H, I, J, K, L)\n             (B,\
    \ C, D, E, F, G, H, I, J, K, L)\n             (C, D, E, F, G, H, I, J, K, L)\n\
    \             (D, E, F, G, H, I, J, K, L)\n             (E, F, G, H, I, J, K,\
    \ L)\n             (F, G, H, I, J, K, L)\n             (G, H, I, J, K, L)\n  \
    \         and 5 others\n   = note: this error originates in the macro `assert_eq`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]:\
    \ no method named `is_subset` found for struct `Vec<(usize, char)>` in the current\
    \ scope\n  --> /tmp/tmpkikpsouj.rs:31:27\n   |\n31 |     opening_brackets_seen.is_su"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets.contains(\"(\") && brackets.contains(\")\")\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfsl_9mdq.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut i = 0;\n    while i < brackets.len() {\n    \
    \    if brackets[i] == '(' && brackets[i + 1] != ')' {\n            return false;\n\
    \        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa4f7yyo9.rs:14:12\n\
    \   |\n14 |         if brackets[i] == '(' && brackets[i + 1] != ')' {\n   |  \
    \          ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpa4f7yyo9.rs:14:34\n   |\n14 |         if brackets[i] == '(' &&\
    \ brackets[i + 1] != ')' {\n   |                                  ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Special case for empty brackets, where there are no\
    \ open/close brackets\n    if brackets == \"\" {\n        return true;\n    }\n\
    \n    // Special case for the last character, which needs to be checked with a\n\
    \    // different method.\n    if !brackets.is_empty() && brackets.len() == 1\
    \ && brackets[0] == '(' {\n        return !correct_bracketing(brackets[1:]);\n\
    \    }\n\n    let mut open_brackets = [0; 256];\n    let mut close_brackets =\
    \ [0; 256];\n    let mut i = 0;\n    let mut open_count = 1;\n    for c in brackets\
    \ {\n        match c {\n            '(' => {\n                open_brackets[open_count]\
    \ += 1;\n                open_count += 1;\n            }\n            '(' => {\n\
    \                close_brackets[open_count] += 1;\n            }\n           \
    \ ')' => {},\n            _ => panic!(\"Bug in `correct_bracketing`\"),\n    \
    \    }\n        i += 1;\n    }\n\n    for open in 0..open_count {\n        if\
    \ close_brackets[open] != open_brackets[open + 1] {\n            return false;\n\
    \        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected type, found `]`\n  --> /tmp/tmpo3cmuqss.rs:20:47\n   |\n\
    20 |         return !correct_bracketing(brackets[1:]);\n   |                 \
    \                             -^ expected type\n   |                         \
    \                     |\n   |                                              tried\
    \ to parse a type due to this\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpo3cmuqss.rs:19:55\n   |\n19 |     if !brackets.is_empty()\
    \ && brackets.len() == 1 && brackets[0] == '(' {\n   |                       \
    \                                ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpo3cmuqss.rs:27:14\n\
    \   |\n27 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut i = 0;\n    for ch in brackets {\n        if\
    \ ch == ')' {\n            i += 1;\n        } else if ch == '(' {\n          \
    \  i -= 1;\n        }\n        if i == 0 {\n            return false;\n      \
    \  }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp6aquwj2_.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut closed = false;\n    let mut open_brackets =\
    \ 0;\n    for ch in brackets.chars() {\n        if ch == '(' {\n            open_brackets\
    \ += 1;\n        }\n        if ch == ')' {\n            closed = true;\n     \
    \   }\n        if closed {\n            open_brackets -= 1;\n        }\n     \
    \   if open_brackets == 0 {\n            return false;\n        }\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp8z29ox1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut bracket_stack: Vec<_> = brackets.chars().collect();\n\
    \    let mut has_opening_brackets: bool = false;\n    while bracket_stack.len()\
    \ > 0 {\n        match bracket_stack.pop() {\n            '(' => {\n         \
    \       has_opening_brackets = true;\n            }\n            ')' => {\n  \
    \              if !has_opening_brackets {\n                    return false;\n\
    \                }\n            }\n            _ => (),\n        }\n    }\n  \
    \  true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp30oze9yg.rs:16:13\n   |\n\
    15 |         match bracket_stack.pop() {\n   |               -------------------\
    \ this expression has type `Option<char>`\n16 |             '(' => {\n   |   \
    \          ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<char>`\n              found type `char`\nhelp: try wrapping the\
    \ pattern in `Some`\n   |\n16 |             Some('(') => {\n   |             +++++\
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp30oze9yg.rs:19:13\n   |\n\
    15 |         match bracket_stack.pop() {\n   |               -------------------\
    \ this expression has type `Option<char>`\n...\n19 |             ')' => {\n  \
    \ |             ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<char>`\n              found type `char`\nhelp: try wrapping the\
    \ pattern in `Some`\n   |\n19 |             Some(')') => {\n   |             +++++\
    \   +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    // Start by counting the number of \"(\" and \")\".\n\
    \    let mut nparens = 0;\n    for ch in brackets {\n        if ch == ('(') {\n\
    \            nparens += 1;\n        }\n        if ch == (')') {\n            nparens\
    \ -= 1;\n        }\n    }\n    // If there are no \"(\", then the brackets are\
    \ correct.\n    if nparens == 0 {\n        return true;\n    }\n    // Otherwise,\
    \ try removing any \"(\" and \")\" until we only have \"(\" and \")\".\n    let\
    \ mut nbrackets = nparens;\n    while nbrackets > 0 {\n        if nbrackets ==\
    \ nparens {\n            // There are no \"(\", so we can't have any \")\".\n\
    \            return false;\n        }\n        if brackets[nbrackets-1] == ('(')\
    \ {\n            nbrackets -= 1;\n        } else {\n            nbrackets += 1;\n\
    \        }\n    }\n    // If all brackets were removed, then they're all correct.\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpb_p2b5mp.rs:14:15\n\
    \   |\n14 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpb_p2b5mp.rs:33:12\n\
    \   |\n33 |         if brackets[nbrackets-1] == ('(') {\n   |            ^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut state = Token::NONE;\n    let mut open_brackets\
    \ = Vec::new();\n    for ch in brackets.chars() {\n        match ch {\n      \
    \      '(' | '[' | '{'\n            | ')' | ']' | '}' => state |= Token::OpenBracket,\n\
    \            '[' | '{' | ']' | '}'\n            | '(' | ')' | '[' | '{'\n    \
    \        | ')' | ']' | '}' => state |= Token::CloseBracket,\n            _ =>\
    \ (),\n        }\n        open_brackets.push(ch);\n    }\n    open_brackets.len()\
    \ == brackets.chars().count()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Token`\n  -->\
    \ /tmp/tmpe7xvdlum.rs:12:21\n   |\n12 |     let mut state = Token::NONE;\n   |\
    \                     ^^^^^ use of undeclared type `Token`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Token`\n  --> /tmp/tmpe7xvdlum.rs:17:43\n\
    \   |\n17 |             | ')' | ']' | '}' => state |= Token::OpenBracket,\n  \
    \ |                                           ^^^^^ use of undeclared type `Token`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Token`\n  --> /tmp/tmpe7xvdlum.rs:20:43\n\
    \   |\n20 |             | ')' | ']' | '}' => state |= Token::CloseBracket,\n \
    \  |                                           ^^^^^ use of undeclared type `Token`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut opening_brackets: Vec<String> = brackets.chars().map(|x|\
    \ x.to_string()).collect();\n    opening_brackets.sort_by_key(|x| x.len());\n\n\
    \    let mut closing_brackets: Vec<String> = opening_brackets.clone();\n    closing_brackets.sort_by(|a,\
    \ b| a.cmp(b));\n    closing_brackets.reverse();\n    let mut opening_brackets_size:\
    \ usize = 0;\n    let mut closing_brackets_size: usize = 0;\n    for opening_bracket\
    \ in opening_brackets {\n        opening_brackets_size += opening_bracket.len();\n\
    \        for closing_bracket in closing_brackets {\n            closing_brackets_size\
    \ += closing_bracket.len();\n            if closing_bracket.starts_with(opening_bracket)\
    \ {\n                opening_brackets.remove(&opening_bracket);\n            \
    \    closing_brackets.remove(&closing_bracket);\n                opening_brackets_size\
    \ -= opening_bracket.len();\n                closing_brackets_size -= closing_bracket.len();\n\
    \            }\n            if closing_brackets_size >= opening_brackets_size\
    \ {\n                return false;\n            }\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpzagrx8xa.rs:24:44\n     |\n24   |             if closing_bracket.starts_with(opening_bracket)\
    \ {\n     |                                ----------- ^^^^^^^^^^^^^^^ expected\
    \ an implementor of trait `Pattern<'_>`\n     |                              \
    \  |\n     |                                required by a bound introduced by\
    \ this call\n     |\n     = note: the trait bound `String: Pattern<'_>` is not\
    \ satisfied\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl str>::starts_with`\n\
    help: consider borrowing here\n     |\n24   |             if closing_bracket.starts_with(&opening_bracket)\
    \ {\n     |                                            +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzagrx8xa.rs:25:41\n   |\n25 |                 opening_brackets.remove(&opening_bracket);\n\
    \   |                                         ^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzagrx8xa.rs:26:41\n\
    \   |\n26 |                 closing_brackets.remove(&closing_bracket);\n   | \
    \                                        ^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ `&String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut s = brackets.to_string();\n    let mut bracket\
    \ = false;\n    for i in 0..s.len() {\n        if s.charAt(i) == '(' {\n     \
    \       bracket = true;\n        } else if s.charAt(i) == ')' {\n            bracket\
    \ = false;\n        } else {\n            continue;\n        }\n        if !bracket\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `charAt` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpjt65_yv3.rs:15:14\n   |\n15 |         if s.charAt(i)\
    \ == '(' {\n   |              ^^^^^^ help: there is an associated function with\
    \ a similar name: `chars`\n\nerror[E0599]: no method named `charAt` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpjt65_yv3.rs:17:21\n   |\n\
    17 |         } else if s.charAt(i) == ')' {\n   |                     ^^^^^^ help:\
    \ there is an associated function with a similar name: `chars`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack: Vec<char> = vec!['('];\n    for c in &brackets[..]\
    \ {\n        if stack.is_empty() {\n            stack.push(c);\n            continue;\n\
    \        }\n        assert!(stack.is_empty(), \"stack is empty and must be empty\
    \ to continue\");\n        if c == '(' {\n            stack.push(c);\n       \
    \ } else if c == ')' {\n            if stack.len() > 0 {\n                stack.pop();\n\
    \            }\n        } else {\n            return false;\n        }\n    }\n\
    \    for c in &brackets[..] {\n        if stack.len() == 0 {\n            return\
    \ false;\n        }\n        if c == ')' {\n            stack.pop();\n       \
    \ }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `&str` is not an iterator\n  --> /tmp/tmpl0me36aw.rs:13:14\n\
    \   |\n13 |     for c in &brackets[..] {\n   |              ^^^^^^^^^^^^^ `&str`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `&str`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `&str`\n\nerror[E0277]:\
    \ `&str` is not an iterator\n  --> /tmp/tmpl0me36aw.rs:29:14\n   |\n29 |     for\
    \ c in &brackets[..] {\n   |              ^^^^^^^^^^^^^ `&str` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `&str`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&str`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    brackets\n        .chars()\n        .filter_map(|c| match\
    \ c {\n            '(', ')' => Some('('),\n            _ => None,\n        })\n\
    \        .any(|(_, )| !brackets.chars().any(|c| c == c.to_ascii_lowercase()))\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: unexpected `,` in pattern\n  --> /tmp/tmpis6jp_4g.rs:15:16\n   |\n\
    15 |             '(', ')' => Some('('),\n   |                ^\n   |\nhelp: try\
    \ adding parentheses to match on a tuple...\n   |\n15 |             ('(', ')')\
    \ => Some('('),\n   |             +        +\nhelp: ...or a vertical bar to match\
    \ on multiple alternatives\n   |\n15 |             '(' | ')' => Some('('),\n \
    \  |             ~~~~~~~~~\n\nerror[E0282]: type annotations needed for `(_,)`\n\
    \  --> /tmp/tmpis6jp_4g.rs:18:15\n   |\n18 |         .any(|(_, )| !brackets.chars().any(|c|\
    \ c == c.to_ascii_lowercase()))\n   |               ^^^^^ consider giving this\
    \ closure parameter the explicit type `(_,)`, with the type parameters specified\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut position = 0;\n    let mut found = false;\n \
    \   let mut stack = Vec::new();\n    loop {\n        if position >= brackets.len()\
    \ {\n            break;\n        }\n        stack.push(brackets[position]);\n\
    \        if brackets[position] == ')' {\n            found = true;\n        }\n\
    \        position += 1;\n    }\n    stack.reverse();\n    let mut found = false;\n\
    \    for ch in stack.iter() {\n        if ch == ')' {\n            found = true;\n\
    \        }\n    }\n    !found\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxyi1evsk.rs:19:20\n\
    \   |\n19 |         stack.push(brackets[position]);\n   |                    ^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxyi1evsk.rs:20:12\n   |\n20 |         if brackets[position] ==\
    \ ')' {\n   |            ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpxyi1evsk.rs:28:15\n\
    \   |\n28 |         if ch == ')' {\n   |               ^^ no implementation for\
    \ `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut stack = vec![false; 2];\n    for i in brackets.chars().rev()\
    \ {\n        if stack.pop() {\n            stack.pop();\n            stack.pop();\n\
    \        } else {\n            stack.push(i);\n        }\n    }\n    stack.pop()\
    \ == false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkkjzwemm.rs:14:12\n   |\n\
    14 |         if stack.pop() {\n   |            ^^^^^^^^^^^ expected `bool`, found\
    \ enum `Option`\n   |\n   = note: expected type `bool`\n              found enum\
    \ `Option<bool>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkkjzwemm.rs:18:24\n\
    \   |\n18 |             stack.push(i);\n   |                        ^ expected\
    \ `bool`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkkjzwemm.rs:21:20\n\
    \   |\n21 |     stack.pop() == false\n   |                    ^^^^^ expected enum\
    \ `Option`, found `bool`\n   |\n   = note: expected enum `Option<bool>`\n    \
    \          found type `bool`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n21 |     stack.pop() == Some(false)\n   |                    +++++     +\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"\
    (\")\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
    (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
    \ String) -> bool {\n    let mut pos = 0; // current position\n    let mut brackets_found\
    \ = false;\n    while pos < brackets.len() {\n        if brackets[pos] == '('\
    \ { // found opening bracket\n            brackets_found = true;\n           \
    \ if pos == brackets.len() - 1 { // found the closing bracket\n              \
    \  return true;\n            }\n            pos += 1;\n        } else if brackets[pos]\
    \ == ')' { // found closing bracket\n            brackets_found = false;\n   \
    \         pos += 1;\n        } else if brackets_found { // current character belongs\
    \ to an opening bracket\n            pos += 1;\n        } else {\n           \
    \ return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsul8m7s0.rs:15:12\n\
    \   |\n15 |         if brackets[pos] == '(' { // found opening bracket\n   | \
    \           ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsul8m7s0.rs:21:19\n   |\n21 |         } else if brackets[pos] ==\
    \ ')' { // found closing bracket\n   |                   ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
