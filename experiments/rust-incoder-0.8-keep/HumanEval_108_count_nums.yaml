name: HumanEval_108_count_nums
language: rust
prompt: "/// Write a function count_nums which takes an array of integers and returns\n\
  /// the number of elements which has a sum of digits > 0.\n/// If a number is negative,\
  \ then its first signed digit will be negative:\n/// e.g. -123 has signed digits\
  \ -1, 2, and 3.\n/// >>> count_nums([]) == 0\n/// >>> count_nums([-1, 11, -11])\
  \ == 1\n/// >>> count_nums([1, 1, 2]) == 3\nfn count_nums(arr: Vec<isize>) -> isize\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1,\
  \ 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]),\
  \ 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12,\
  \ 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]),\
  \ 1);\n}\n"
completions: ["    let mut sum = 0;\n    for num in arr {\n        if num < 0 {\n\
    \            num = -num;\n        }\n        sum += num;\n    }\n    sum", '    arr.iter().filter(|n|
    n > 0).count()', "    if arr.is_empty() {\n        return 0;\n    }\n\n    let\
    \ mut nums = vec![0];\n    for x in arr.iter().rev() {\n        if x < 0 {\n \
    \           x += 10;\n            nums.insert(0, 1);\n        }\n        if nums.len()\
    \ >= 10 {\n            return nums.iter().filter(|&i| i >= 0).count();\n     \
    \   }\n        if x > 0 {\n            x += 1;\n            nums.insert(0, x);\n\
    \        }\n    }\n    nums.iter().filter(|&i| i >= 0).count()", "    arr.iter()\n\
    \        .map(|x| if x >= 0 { x - x.digits() } else { -x })\n        .filter(|x|\
    \ x > 0)\n        .count()", "    let mut result = 1;\n    for num in arr {\n\
    \        // We cannot use mod since this is not a positive number\n        for\
    \ _ in 0..num {\n            result *= 10;\n        }\n        result *= num;\n\
    \    }\n    result", "    let mut sum = 0;\n    for num in arr {\n        sum\
    \ += num;\n        if sum > 0 {\n            return 1;\n        }\n    }\n   \
    \ 0", "    arr.iter()\n        .filter(|&num| num > 0)\n        .count()", " \
    \   debug_assert!(arr.is_empty() || arr.len() > 0);\n    let mut cnt = 0;\n  \
    \  for i in arr {\n        if i >= 0 {\n            cnt += i as usize;\n     \
    \   } else {\n            cnt -= i as usize;\n        }\n    }\n    cnt", "  \
    \  arr.iter().fold(0, |sum, number| {\n        sum += match number {\n       \
    \     -number => number.checked_sub(1).unwrap(),\n            _ => 0,\n      \
    \  };\n        sum\n    })", "    let mut n = 0;\n    let mut sum = 0;\n    for\
    \ &i in arr {\n        sum += i;\n        if sum > 0 { n += 1 };\n    }\n    n",
  "    arr.iter()\n        .map(|x| *x % 10)\n        .filter(|&x| x > 0)\n      \
    \  .count()", "    arr.iter()\n        .filter(|n| n > 0)\n        .filter(|n|\
    \ n % 10 > 0)\n        .count()", "    let mut cnt = 0;\n    for &x in arr {\n\
    \        if x < 0 {\n            cnt += 1 + count_nums(&[x, -x]);\n        } else\
    \ {\n            cnt += 1;\n        }\n    }\n    cnt", "    let mut sum = 0;\n\
    \    for x in arr {\n        sum += x;\n    }\n    sum", "    if arr.is_empty()\
    \ {\n        return 0\n    }\n\n    let mut sum_of_digits = arr.iter().cloned().filter(|&x|\
    \ x != 0).sum();\n    if sum_of_digits < 0 {\n        sum_of_digits *= -1;\n \
    \       arr[0] *= -1;\n    }\n    let mut count = 1;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        let n = sum_of_digits % 10;\n        if n == x {\n            count\
    \ += 1;\n        }\n        sum_of_digits /= 10;\n    }\n    count", "    let\
    \ mut count = 0;\n    let mut max_digit = 0;\n    for n in arr {\n        max_digit\
    \ = match n {\n            0 => max_digit,\n            _ => {\n             \
    \   if *n >= 0 {\n                    *n -= (10 ** (max_digit - 1));\n       \
    \             max_digit -= 1;\n                } else {\n                    *n\
    \ += (10 ** (max_digit - 1));\n                    max_digit -= 1;\n         \
    \       }\n            }\n        };\n        count += *n as isize;\n    }\n \
    \   count", '    arr.iter().filter(|&n| n > 0).count().unwrap()', "    let mut\
    \ cnt = 0;\n    let mut carry = 0;\n\n    for i in arr {\n        if i >= 0 {\n\
    \            cnt += 1;\n            carry += 1;\n        } else {\n          \
    \  cnt += 1;\n            if carry == 0 {\n                carry = 1;\n      \
    \      }\n        }\n\n        if carry != 0 {\n            cnt += 1;\n      \
    \  }\n    }\n\n    cnt", "    let mut n = 0;\n    let mut d = 10;\n    for &n\
    \ in arr {\n        n %= d;\n        n += ((&n * d) - (&n * d)) % d;\n       \
    \ d *= 10;\n    }\n    n", "    if arr.is_empty() {\n        return 0;\n    }\n\
    \    let mut sum = 0;\n    for x in arr {\n        if x < 0 {\n            sum\
    \ += x.to_digit(10);\n        } else {\n            sum += x;\n        }\n   \
    \ }\n    sum", '    arr.iter().filter(|x| x > 0).count()', "    let mut cnt: isize\
    \ = 0;\n    let mut i = arr.len() - 1;\n    while i >= 0 && arr[i] > 0 {\n   \
    \     if cnt > 0 {\n            cnt += 1;\n        }\n        i -= 1;\n    }\n\
    \    cnt", "    if arr.is_empty() {\n        return 0;\n    }\n    let mut num_sum\
    \ = 0;\n    let mut n = 0;\n    for i in arr {\n        if i >= 0 {\n        \
    \    n += 1;\n            num_sum += i;\n        } else {\n            let mut\
    \ d = i as isize;\n            while d > 0 {\n                if d % 10 == 0 {\n\
    \                    num_sum += d;\n                    break;\n             \
    \   } else {\n                    d /= 10;\n                }\n            }\n\
    \        }\n    }\n    if num_sum > 0 {\n        num_sum -= num_sum % 10;\n  \
    \  }\n    n", "    if arr.is_empty() {\n        return 0;\n    }\n    let mut\
    \ i = 0;\n    for v in arr {\n        if v < 0 {\n            i += v;\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    i", "    let mut n = 0;\n\
    \    for i in arr {\n        if i != 0 {\n            n += 1;\n        }\n   \
    \     if i < 0 {\n            n += 1;\n        }\n    }\n    n", "    let mut\
    \ n = 0;\n    let mut d = -arr[0];\n    for &i in arr.iter() {\n        n += i\
    \ as isize;\n        d += i as isize;\n    }\n    if n < 0 {\n        n = (-n)\
    \ + 1;\n    }\n    let mut digits = vec![];\n    while d >= 10 {\n        digits.push(d\
    \ % 10);\n        d /= 10;\n    }\n    digits.push(d as u8);\n    if digits.iter().any(|&d|\
    \ d == 0) {\n        return 0;\n    }\n    let mut cnt = 0;\n    for i in digits.iter()\
    \ {\n        if i >= 10 {\n            cnt += 1;\n        }\n    }\n    cnt +\
    \ n", "    arr.iter().map(|&x| {\n        let s = x.to_string();\n        if s.len()\
    \ > 1 {\n            x.checked_add(s.parse().unwrap()).unwrap()\n        } else\
    \ {\n            x\n        }\n    }).filter(|&x| x > 0).count()", "    if arr.is_empty()\
    \ {\n        return 0;\n    }\n\n    let mut count = 0;\n    let mut s = arr[0]\
    \ as isize;\n    for el in arr.iter().skip(1) {\n        let d = el as isize -\
    \ s;\n        if d > 0 {\n            count += d;\n        }\n        s += d;\n\
    \    }\n\n    count", "    if arr.is_empty() {\n        return 0;\n    }\n\n \
    \   if arr.len() < 2 {\n        return arr.len();\n    }\n\n    let mut num_sum\
    \ = 0;\n    let mut num: isize = 0;\n\n    for &i in arr.iter() {\n        if\
    \ i > 0 {\n            num_sum += i - num;\n            num += i;\n        }\n\
    \    }\n\n    num_sum", "    if arr.is_empty() {\n        return 0;\n    }\n\n\
    \    let mut count = 0;\n    let mut carry = 0;\n    for i in arr {\n        count\
    \ += i;\n        carry += count as isize;\n        count -= carry as isize;\n\
    \    }\n\n    if carry > 0 {\n        count += 1;\n    }\n\n    count", "    if\
    \ arr.is_empty() {\n        return 0;\n    }\n\n    let mut sum = 0;\n    let\
    \ mut n = 0;\n    for v in arr.iter() {\n        let mut digit = *v as isize;\n\
    \        if digit < 0 {\n            digit *= -1;\n        }\n        sum += digit;\n\
    \    }\n    sum += n;\n\n    if sum < 10 {\n        return 0;\n    }\n    let\
    \ mut sum: usize = 0;\n    for v in arr.iter() {\n        let digit = *v as usize;\n\
    \        sum += digit;\n    }\n\n    if sum < 10 {\n        return 0;\n    }\n\
    \    return 1 + count_nums(&arr[0..arr.len() - 1]);", "    let mut sum = 0;\n\
    \    for num in arr {\n        if num > 0 {\n            sum += num;\n       \
    \ }\n    }\n    sum", '    arr.iter().filter(|&i| i >= 0).count()', "    if arr.is_empty()\
    \ {\n        0\n    } else {\n        if let Some(first_negative) = arr.iter().find(|&x|\
    \ x < 0) {\n            let first_negative = first_negative.unwrap();\n      \
    \      let mut digits = first_negative;\n            while let Some(negative_digit)\
    \ = arr.iter_mut().find(|&x| x < 0) {\n                *negative_digit = digits;\n\
    \                digits -= x;\n            }\n        }\n        arr.iter().filter(|&x|\
    \ x > 0).count()\n    }", '    arr.iter().filter(|n| n > 0).count()', "    //\
    \ We are looking at digits in the order that they occur in the input array.\n\
    \    // To do this, we first compute the absolute value of the first digit.\n\
    \    let mut digits = arr.iter().map(|v| |v| *v).collect::<Vec<_>>();\n    let\
    \ abs1 = digits.iter().map(|v| |v| *v).sum::<isize>();\n\n    // Now we can compute\
    \ the absolute value of the last digit.\n    let abs2 = digits.iter().rev().map(|v|\
    \ |v| *v).sum::<isize>();\n\n    let mut n = std::cmp::min(abs1, abs2);\n\n  \
    \  // We can't use std::cmp::max or std::cmp::min because we can't make the\n\
    \    // second digit negative with std::cmp::min or std::cmp::max, which are\n\
    \    // not defined to allow negative numbers.\n    n += std::cmp::min(digits.iter().rev().map(|v|\
    \ |v| *v).sum::<isize>(), 0);\n\n    n += std::cmp::max(digits.iter().map(|v|\
    \ |v| *v).sum::<isize>(), 0);\n\n    n", "    // Get number of digits from first\
    \ element (which is always positive).\n    let n = arr.len() as isize;\n    let\
    \ mut cnt = 0;\n    while n >= 10 {\n        cnt += n % 10;\n        n /= 10;\n\
    \    }\n    cnt", "    let mut n = 0;\n    for x in arr {\n        if x >= 0 {\n\
    \            n += x;\n        }\n    }\n    return n;", '    arr.iter().filter(|x|
    x >= 0).count()', "    let mut sum = 0;\n    for x in arr {\n        let digit\
    \ = x.to_digit(10);\n        if digit > 0 {\n            sum += digit;\n     \
    \   }\n    }\n    sum", "    let mut n = 0;\n    for i in arr {\n        if i\
    \ >= 0 {\n            i += i / 10;\n            n += 1;\n        } else {\n  \
    \          i -= i / 10;\n            n += 1;\n        }\n    }\n    n", "    if\
    \ arr.is_empty() {\n        return 0\n    }\n    let mut count: usize = 0;\n \
    \   let mut cur_digit: usize = 0;\n    for &d in arr {\n        if d < 0 {\n \
    \           d *= -1;\n            cur_digit *= -1;\n        }\n        cur_digit\
    \ += d;\n        if cur_digit > 10 {\n            count += 1;\n            cur_digit\
    \ = 0;\n        }\n    }\n    count", "    let mut num_sum = 0;\n    let mut negative\
    \ = false;\n    for val in arr {\n        if val < 0 {\n            negative =\
    \ true;\n            val = val * -1;\n        }\n        let digit = val % 10;\n\
    \        if digit > 0 {\n            num_sum += digit;\n        }\n    }\n   \
    \ if negative {\n        num_sum -= 1;\n    }\n    num_sum", "    let mut total\
    \ = 0;\n    for x in arr {\n        total += x;\n    }\n    if total < 0 {\n \
    \       total -= 1;\n    }\n    total", "    if arr.is_empty() {\n        return\
    \ 0;\n    }\n\n    let mut count = 1;\n    let mut cur = 0;\n    let mut is_negative\
    \ = false;\n    for &x in arr {\n        cur += x;\n        is_negative = if cur\
    \ < 0 { is_negative = true }\n        count += cur / 10;\n        cur %= 10;\n\
    \    }\n\n    if is_negative {\n        return -count;\n    } else {\n       \
    \ return count;\n    }", "    let mut sum = 0;\n    for i in arr {\n        if\
    \ i >= 0 {\n            sum += i as isize;\n        }\n    }\n    sum", "    let\
    \ mut nums: usize = 0;\n    let mut digits = 1;\n    let mut negative = false;\n\
    \    for i in arr.iter() {\n        let mut tmp = i;\n        tmp.checked_add(digits).checked_sub(*&digits);\n\
    \        if tmp.len() < 0 {\n            digits.mul_add(-*tmp);\n        } else\
    \ {\n            digits += *tmp;\n        }\n        if digits < 0 {\n       \
    \     negative = true;\n            nums += digits;\n            digits = 1;\n\
    \        }\n    }\n    if negative {\n        nums -= digits;\n        digits++;\n\
    \    }\n    nums", "    if arr.is_empty() {\n        return 0;\n    }\n    let\
    \ mut n = 0;\n    let mut i = 0;\n    while i < arr.len() {\n        let nd =\
    \ arr[i] - 97;\n        if nd > 0 {\n            n += nd as isize;\n        }\n\
    \        i += 1;\n    }\n    n", "    let mut sum = 0;\n    for i in arr {\n \
    \       if i >= 0 {\n            sum += i;\n        } else {\n            sum\
    \ += i * -1; // negative sign of first digit\n        }\n    }\n    sum", '    arr.iter().filter(|n|
    n > 0).count()', "    let mut result = 0;\n    for x in arr {\n        if x.is_positive()\
    \ {\n            result += x;\n        }\n        else {\n            result +=\
    \ x.leading_sign();\n        }\n    }\n    result", "    if arr.is_empty() {\n\
    \        return 0;\n    }\n\n    let mut first_negative = false;\n    let mut\
    \ counter = 0;\n    let mut last_digit = arr[0];\n    for &n in arr.iter().rev()\
    \ {\n        let digit = n % 10;\n        if digit > 0 {\n            if last_digit\
    \ < digit {\n                counter = counter + 1;\n            }\n\n       \
    \     if digit < 0 {\n                first_negative = true;\n            } else\
    \ {\n                last_digit = digit;\n            }\n        } else {\n  \
    \          counter = counter - 1;\n        }\n    }\n\n    if first_negative {\n\
    \        counter = counter + isize::from(-1);\n    }\n\n    counter", '    count_nums_helper(arr,
    0)', '    arr.iter().filter(|x| x > 0).count()', "    let mut cnt = 0;\n    let\
    \ mut digits = 0;\n    let mut negative = false;\n    for n in arr {\n       \
    \ if n < 0 {\n            n += 10;\n            digits -= 1;\n            negative\
    \ = true;\n        } else {\n            digits += 1;\n        }\n        cnt\
    \ += n;\n    }\n    if digits == 0 {\n        return 0;\n    }\n    if negative\
    \ {\n        cnt -= 1;\n    }\n    cnt", "    let mut n: isize = 0;\n    for i\
    \ in arr {\n        // We don't worry about negative numbers here\n        //\
    \ because that doesn't affect the result\n        if i >= 0 {\n            n +=\
    \ (i/10).floor() as isize;\n        }\n    }\n    n", "    arr.iter()\n      \
    \  .map(|i| if i < 0 {\n            -i\n        } else {\n            i + 0\n\
    \        })\n        .filter(|&i| i >= 0)\n        .count()", "    let mut count\
    \ = 0 as isize;\n    let mut sum = 0;\n    let mut negative = false;\n    for\
    \ &i in arr {\n        sum += i;\n        if sum < 0 {\n            sum += 10;\n\
    \            negative = true;\n        }\n    }\n    if negative {\n        sum\
    \ += -sum as isize;\n    }\n    count += 1;\n    count", "    let mut n = 0;\n\
    \    for i in arr {\n        match i {\n            i if i >= 0 => n += 1,\n \
    \           _ => return 0,\n        }\n    }\n    n", "    arr.iter()\n      \
    \  .map(|x| if x.is_sub(-10) {\n            -x.digits()\n        } else {\n  \
    \          x\n        })\n        .filter(|x| x.is_digit())\n        .count()",
  "    // This is O(n^2) but it is correct to do this in O(n)\n    // and we don't\
    \ need to worry about sorting as all elements\n    // are in the order of the\
    \ digits in base 10.\n    let mut sum = 0;\n    let mut idx = 0;\n    while idx\
    \ < arr.len() {\n        let d = &arr[idx];\n        sum += d;\n        if sum\
    \ > 0 {\n            idx += 1;\n            sum -= d;\n        } else {\n    \
    \        break;\n        }\n    }\n    idx", "    arr.iter()\n        .map(|x|\
    \ x.checked_mul(x.checked_add(-x.checked_add(1)))\n                .ok_or(IndexError::new(x.to_string(),\
    \ \"no sum > 0\"))\n                .ok())\n        .filter(|x| x.is_ok())\n \
    \       .count()", "    // The sum of the digits is the sum of the digits\n  \
    \  let mut sum = 0;\n    for &i in arr {\n        if i < 0 {\n            i +=\
    \ 10;\n        }\n        sum += i;\n    }\n    sum", "    if arr.is_empty() {\n\
    \        return 0;\n    }\n\n    let mut count = 0;\n    let mut sum_of_digits\
    \ = &arr[0] + &arr[1] + &arr[2] +\n                          &arr[3];\n    let\
    \ mut first_digit_negative = false;\n    for val in arr.iter().rev() {\n     \
    \   if val < 0 {\n            count += 1;\n            first_digit_negative =\
    \ true;\n        } else {\n            count += sum_of_digits.is_positive();\n\
    \        }\n        sum_of_digits -= val;\n    }\n\n    if first_digit_negative\
    \ {\n        // The first signed digit is negative. Need to add one.\n       \
    \ count += 1\n    }\n\n    count", "    if arr.is_empty() {\n        return 0;\n\
    \    }\n    let mut num_zero = arr.iter().filter(|&n| n == 0).count();\n    let\
    \ mut num_nonzero = arr.iter().filter(|&n| n != 0).count();\n    loop {\n    \
    \    if num_zero > num_nonzero {\n            return num_zero;\n        }\n  \
    \      if num_zero == num_nonzero {\n            num_zero += 1;\n        }\n \
    \       let next = arr.iter().enumerate().find(|&(index, elem)| elem != 0);\n\
    \        match next {\n            Some((index, elem)) if index > num_zero =>\
    \ *elem -= 1;\n            Some((index, elem)) if index == num_zero => break,\n\
    \            None => num_nonzero += 1,\n        }\n    }\n    num_nonzero", '    arr.iter().filter(|x|
    x > 0).count()', "    let mut total = 0;\n    for num in arr {\n        let digits\
    \ = num % 10;\n        if num < 0 {\n            total -= digits;\n        } else\
    \ {\n            total += digits;\n        }\n    }\n    total", "    if arr.is_empty()\
    \ {\n        return 0;\n    }\n    let mut sum = 0;\n    let mut digits = 0;\n\
    \    let mut i = arr.len() - 1;\n    while i >= 0 {\n        sum += arr[i];\n\
    \        digits += 1;\n        i--;\n    }\n    digits", "    let mut count =\
    \ 0;\n    for a in arr.iter().rev() {\n        let mut b = a;\n        if a <\
    \ 0 {\n            b = -a * 10 % 10;\n        }\n        if b % 10 == 0 {\n  \
    \          count += 1;\n        }\n    }\n    count", "    let mut sum = 0;\n\
    \    for i in arr {\n        sum += i as isize % 10;\n        if sum < 0 {\n \
    \           sum += 10;\n        }\n    }\n    sum", "    arr.iter()\n        .filter(|num|\
    \ num > 0)\n        .fold(0, |mut sum, i| {\n            if i == 0 { sum += 1\
    \ }\n            sum * 10 + i % 10\n        })", "    let mut cnt = 0;\n    for\
    \ d in arr.iter_mut() {\n        *d += if *d > 0 { 1 } else { -1 };\n        if\
    \ *d < 0 { cnt += 1; }\n    }\n    cnt", "    if arr.is_empty() {\n        return\
    \ 0;\n    }\n\n    let mut sum = 0;\n    let mut nums = 0;\n    let mut neg_sign\
    \ = false;\n    let first = arr.iter().next().unwrap();\n    if first < 0 {\n\
    \        neg_sign = true;\n        first = first.wrapping_sub(1);\n    }\n\n \
    \   for i in arr.iter() {\n        if i >= first {\n            sum += i;\n  \
    \          nums += 1;\n        } else {\n            sum += i - first;\n     \
    \   }\n    }\n    if sum < 0 {\n        sum += first;\n        nums += 1;\n  \
    \  }\n    if nums == 0 {\n        nums = 1;\n    }\n    if neg_sign && sum >=\
    \ 0 {\n        sum -= first;\n        nums += 1;\n    }\n    nums", "    arr.iter()\n\
    \        .enumerate()\n        .filter(|(idx, _)| arr[idx] >= 0)\n        .filter(|(idx,\
    \ _)| idx < arr.len())\n        .filter(|(idx, _)| arr[idx] % 10 > 0)\n      \
    \  .count()", "    let mut nums = arr.to_vec();\n    let mut count = 0;\n    let\
    \ mut i = -1;\n    while i >= 0 && nums[i].is_some() {\n        i += 1;\n    \
    \    count += 1;\n    }\n    count", "    let mut counts: Vec<isize> = arr.into_iter().map(|x|\
    \ {\n        if x % 2 == 0 {\n            x.powf(2)\n        } else {\n      \
    \      x.powf(2).floor()\n        }\n    }).collect();\n\n    counts.iter().filter(|x|\
    \ x > 0).count();", "    let mut sum = 0;\n    for n in arr.iter() {\n       \
    \ sum += *n as isize;\n    }\n    sum", "    arr.iter().filter_map(|x| {\n   \
    \     let mut ret = 0;\n        while x > 0 {\n            ret += (x % 10).wrapping_mul(10);\n\
    \            x /= 10;\n        }\n        ret\n    }).sum()", "    if arr.is_empty()\
    \ {\n        return 0;\n    }\n    let mut count = 0;\n    let mut last_digits\
    \ = Vec::new();\n    for v in arr.iter() {\n        if v < 0 {\n            count\
    \ += 1;\n            last_digits.push(v);\n        } else {\n            count\
    \ += last_digits[v.abs() - 1];\n        }\n    }\n    count += arr.len() - last_digits[arr.len()\
    \ - 1];\n    count", "    let mut nums = 0;\n    for i in arr {\n        if i\
    \ % 10 == 0 {\n            nums += 1;\n        }\n    }\n    nums", "    let mut\
    \ count = 0;\n    let mut digits = arr.iter().map(|&d| {\n        if d < 0 {\n\
    \            d.checked_sub(10).unwrap()\n        } else {\n            d\n   \
    \     }\n    }).collect::<Vec<_>>();\n    let mut current = -1;\n\n    for digit\
    \ in digits {\n        current += digit;\n        if current > 0 {\n         \
    \   count += 1;\n        }\n        current = -1;\n    }\n\n    count", "    arr.iter().fold(0,\
    \ |acc, x| {\n        if x % 10 == 0 {\n            acc + 1;\n        } else {\n\
    \            acc\n        }\n    })", "    let mut sum = 0;\n    let mut sign\
    \ = 1;\n    for x in arr.iter() {\n        sum += x * sign;\n        sign = -sign;\n\
    \    }\n    sum", "    let mut count = 0;\n    for num in arr {\n        if num\
    \ < 0 {\n            count += (-num as isize);\n        } else {\n           \
    \ count += num as isize;\n        }\n    }\n    count", '    arr.iter().filter(|&num|
    num > 0).count()', "    if arr.is_empty() {\n        0\n    } else {\n       \
    \ let mut num = 0;\n        arr.sort_unstable();\n        let mut prev_digit =\
    \ 0;\n        for digit in arr {\n            num |= digit as isize ^ (prev_digit\
    \ as isize) << 1;\n            prev_digit = digit;\n        }\n        num\n \
    \   }", "    if arr.is_empty() {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    for n in arr {\n        if n < 0 {\n            let mut sign = 1;\n\
    \            while n > 0 {\n                n >>= 1;\n                sign *=\
    \ -1;\n            }\n            count += sign;\n        } else {\n         \
    \   count += n;\n        }\n    }\n    count", '    arr.iter().filter(|&i| i >
    0).count()', '    arr.iter().filter(|i| i >= 0).count()', "    arr.iter()\n  \
    \      .filter(|&x| x >= 0)\n        .filter(|&x| x.checked_add(0, |x| x.digit()\
    \ >= 0))\n        .filter(|&x| x.checked_add(0, |x| x.digit() >= 0))\n       \
    \ .count()", "    let mut count: usize = 0;\n    for num in arr {\n        if\
    \ num > 0 {\n            count += num as isize;\n        }\n    }\n    count",
  "    let mut sum = 0;\n    for elt in arr.iter() {\n        sum += elt;\n    }\n\
    \    sum", "    let mut n = 0;\n    for x in arr {\n        if x > 0 {\n     \
    \       n += x;\n        }\n    }\n    n", '    arr.iter().filter(|&x| x > 0).count()',
  "    let mut ans = isize::MAX;\n    for x in arr.iter() {\n        let mut count\
    \ = 0;\n        while x >= 10 {\n            x /= 10;\n            count += 1;\n\
    \        }\n        if x != 0 {\n            ans = min(ans, count);\n        }\n\
    \    }\n    ans", "    let mut n = 0;\n    let mut last_sign = false;\n    for\
    \ d in &arr {\n        if d < 0 {\n            last_sign = true;\n           \
    \ continue;\n        }\n        let sign = last_sign;\n        let d = d.abs();\n\
    \        if d > 0 {\n            n += sign * (d % 10);\n        }\n        last_sign\
    \ = false;\n    }\n    n", '    arr.iter().filter(|n| n > 0).count()', "    if\
    \ arr.is_empty() {\n        return 0;\n    }\n    let mut c = 0;\n    let mut\
    \ digits = arr.iter().map(|&x| x.clone()).collect::<Vec<_>>();\n    let mut prev_digit\
    \ = digits[0];\n    let mut last_digit = digits[0].clone() as isize;\n    for\
    \ &i in &digits[1..] {\n        if !prev_digit == 0 && (i as isize) < 0 {\n  \
    \          c -= 1;\n        }\n        last_digit += i;\n        if last_digit\
    \ % 10 == 0 {\n            c += 1;\n            last_digit /= 10;\n        }\n\
    \        prev_digit = i;\n    }\n    if c > 0 {\n        c += 1;\n    }\n    c",
  "    let mut count = 0isize;\n    for &num in arr {\n        count += count_nums(num);\n\
    \    }\n    count", "    let mut num_signs: isize = 0;\n    let mut num_neg: isize\
    \ = 0;\n    let mut num_total: isize = 0;\n    for i in arr {\n        if i <\
    \ 0 {\n            num_neg += 1;\n        } else {\n            num_signs += 1;\n\
    \            num_total += i;\n        }\n    }\n    if num_total == 0 {\n    \
    \    return 0;\n    }\n    num_signs - num_neg + num_total", "    arr.iter().filter_map(|e|\
    \ {\n        if e < 0 {\n            Some(e - isize::from(10) + 1)\n        }\
    \ else {\n            None\n        }\n    }).sum()", "    let mut res = 0;\n\
    \    let mut negative = false;\n\n    for v in arr {\n        if v < 0 {\n   \
    \         negative = true;\n            v *= -1;\n        }\n\n        res +=\
    \ v;\n    }\n\n    if negative {\n        res = -res;\n    }\n\n    res", "  \
    \  let mut sum = 0;\n    for x in arr.iter() {\n        if x < 0 {\n         \
    \   x -= 1;\n        }\n        sum += x;\n    }\n    sum", "    let mut digit_sum\
    \ = 0;\n    let mut negative = false;\n\n    for num in arr {\n        if num\
    \ < 0 {\n            negative = true;\n            num *= -1;\n        }\n   \
    \     digit_sum += num;\n    }\n    digit_sum", "    let mut n = arr.len();\n\
    \    for &x in arr {\n        n += x % 10;\n        x /= 10;\n    }\n    n", '    arr.iter().filter(|&x|
    x > 0).count()', "    if arr.is_empty() {\n        return 0;\n    }\n\n    if\
    \ arr.len() == 1 {\n        if arr[0] >= 0 {\n            return 1;\n        }\n\
    \        return 0;\n    }\n\n    let mut digits = 0;\n    let mut sign = 1;\n\
    \    let mut neg = false;\n\n    for i in 0..arr.len() {\n        if arr[i] <\
    \ 0 {\n            sign = -1;\n            neg = true;\n        }\n\n        if\
    \ arr[i] == 0 {\n            digits += 1;\n        } else {\n            if arr[i]\
    \ > 0 {\n                let mut carry = 0;\n                while arr[i] >= 10\
    \ {\n                    carry += 1;\n                    digits += 1;\n     \
    \               arr[i] -= 10;\n                }\n                while carry\
    \ > 0 {\n                    digits += 1;\n                    carry -= 10;\n\
    \                }\n            }\n        }\n    }\n\n    if neg {\n        sign\
    \ = -1;\n    }\n\n    sign * digits", "    let mut count = 0;\n    let mut last_digit\
    \ = 0;\n\n    for digit in &arr {\n        if *digit < 0 {\n            last_digit\
    \ = *digit;\n        } else {\n            count += 1;\n            last_digit\
    \ = 0;\n        }\n    }\n\n    count", "    let mut cnt = 0;\n    for n in arr\
    \ {\n        if n >= 0 {\n            cnt += n;\n        } else {\n          \
    \  if n >= -n {\n                cnt += n + 1;\n            }\n        }\n   \
    \ }\n    cnt", "    if arr.is_empty() {\n        return 0;\n    }\n\n    let mut\
    \ sum_of_digits = 0;\n    let mut num_negative = false;\n\n    // Compute sum\
    \ of digits\n    for n in arr {\n        if n < 0 {\n            num_negative\
    \ = true;\n            n -= n;\n        }\n        sum_of_digits += n;\n    }\n\
    \n    let num_positive = arr.len() - sum_of_digits;\n    let num_negative = num_negative\
    \ * -1;\n\n    match sum_of_digits % 10 {\n        0 => return 0,\n        1 =>\
    \ return 1,\n        _ => {\n            // This means we have multiple 1's in\
    \ the array => we need to remove\n            // the first 1 before we can compute\
    \ the next sum\n            let mut cur_sum = sum_of_digits;\n            while\
    \ cur_sum > 0 {\n                cur_sum -= cur_sum mod 10;\n            }\n \
    \           return cur_sum + num_negative + num_positive;\n        }\n    }",
  "    let mut count = 0isize;\n    let mut last: isize = 0;\n    for el in arr {\n\
    \        if el < 0 {\n            el = el * -1;\n        }\n        el = el %\
    \ 10;\n        count += el > last;\n        last = el;\n    }\n    count", " \
    \   if arr.is_empty() {\n        return 0;\n    }\n    if arr.len() == 1 {\n \
    \       return arr.iter().cloned().filter(|e| e > 0).count();\n    }\n    if arr.len()\
    \ == 2 {\n        let first = arr.iter().cloned().filter(|e| e > 0).collect();\n\
    \        if first.len() == 1 {\n            return first.iter().cloned().filter(|e|\
    \ e > 0).count();\n        }\n    }\n    let mut sum = 0;\n    for &n in arr {\n\
    \        if n > 0 {\n            sum += 1;\n        }\n    }\n    sum", "    if\
    \ arr.is_empty() {\n        return 0;\n    }\n    let mut n = 0;\n    for &i in\
    \ arr {\n        if i >= 0 {\n            i += 10;\n        }\n        if i >>\
    \ 0 < 10 {\n            i += 1;\n            n += 1;\n        }\n    }\n    n",
  "    let mut cnt = 0;\n    let mut sum = 0;\n    let mut i = 1;\n    for i in arr\
    \ {\n        sum += i;\n        if sum > 0 {\n            cnt += 1;\n        }\n\
    \    }\n    cnt", "    // Calculate the number of elements which are positive.\n\
    \    let mut n = 0;\n    for num in arr.iter() {\n        match num {\n      \
    \      0 => {},\n            n => panic!(\"Negative numbers are not allowed.\"\
    ),\n            n => {}\n        }\n        n += 1;\n    }\n\n    // Sum the digits\
    \ of each element.\n    for num in arr.iter() {\n        if num < 0 {\n      \
    \      n *= -1;\n            num += 1;\n        }\n\n        match num {\n   \
    \         n => panic!(\"Sum of digits is greater than the digits of the element.\"\
    ),\n            0 => {}\n            n => {}\n        }\n    }\n    n", '    arr.iter().filter(|x|
    x >= 0).count()', '    arr.iter().cloned().filter(|&x| x >= 0).count()', "   \
    \ let mut accum: isize = 0;\n\n    for &i in arr {\n        if i > 0\n       \
    \     && !(i == -(i - 1))\n            && !(i == -i + 1)\n            && !(i ==\
    \ -i + 2)\n            && !(i == -i + 3)\n        {\n            accum += 1;\n\
    \        }\n    }\n\n    accum", "    if arr.is_empty() {\n        return 0;\n\
    \    }\n    let mut sum = 0;\n    let mut count = 1;\n    let mut last_digit =\
    \ -1;\n    for num in arr.iter() {\n        if last_digit < 0 {\n            last_digit\
    \ = num % 10;\n            continue;\n        }\n        let digit = num % 10\
    \ - last_digit;\n        last_digit = num % 10;\n        sum += digit;\n     \
    \   count += 1;\n    }\n    if count > 1 {\n        sum -= count as isize;\n \
    \   }\n    sum", "    let mut sum: isize = 0;\n    let mut prev_val: isize = 0;\n\
    \    for e in arr.iter() {\n        sum += e;\n        if sum > 0 {\n        \
    \    sum += prev_val - e + 1;\n        }\n        prev_val = e;\n    }\n    sum",
  '    arr.iter().filter(|&x| x > 0).count()', "    let mut sum = 0;\n    for el in\
    \ arr {\n        if el < 0 {\n            el += 10;\n        }\n        sum +=\
    \ el;\n    }\n    sum", "    arr.iter()\n        .zip(arr.iter().cloned())\n \
    \       .filter(|(&x, &y)| {\n            x.checked_add(-y).is_positive()\n  \
    \      })\n        .count()", '    arr.iter().filter(|x| x > 0).count()', '    arr.iter().filter(|x|
    *x >= 0).count()', "    if arr.is_empty() {\n        return 0\n    }\n    let\
    \ mut n = 0;\n    let mut digits = Vec::with_capacity(arr.len() + 1);\n    digits.push(0);\n\
    \    for i in arr.iter() {\n        if i >= 0 {\n            digits.push(i / 10);\n\
    \        }\n    }\n    for d in digits.iter() {\n        if d > 0 {\n        \
    \    n += 1;\n        }\n    }\n    n - arr.len() as isize", "    let mut n_negative\
    \ = arr\n        .iter()\n        .filter(|x| x < 0)\n        .count();\n    if\
    \ n_negative > 0 { n_negative = -n_negative }\n    arr.iter().filter(|x| x >=\
    \ 0).count() - n_negative", "    debug_assert!(arr.len() == 0 || arr[0] >= 0);\n\
    \n    if arr.len() == 0 {\n        return 0;\n    }\n\n    let mut sum = 0;\n\
    \    let mut carry = 0;\n    for &num in arr {\n        sum += num;\n        carry\
    \ = 1;\n        while sum >= 10 {\n            sum += carry % 10;\n          \
    \  carry /= 10;\n        }\n    }\n    if sum > 0 {\n        sum += carry;\n \
    \   }\n    sum", '    arr.iter().filter(|x| x > 0).count()', "    let mut count:\
    \ isize = 0;\n    for i in arr {\n        // The first number with a negative\
    \ sign is considered to be a special case\n        // because its first digit\
    \ is a negative sign\n        let c = i.abs();\n        if c < 0 {\n         \
    \   count -= 1;\n        } else {\n            count += 1;\n        }\n    }\n\
    \    count", "    let mut count = 0;\n    let mut digit_sums = arr\n        .iter()\n\
    \        .map(|x| if x > 0 {\n            (x * 2).abs().floor() as isize\n   \
    \     } else {\n            -x\n        })\n        .collect::<Vec<_>>();\n  \
    \  for (i, digit_sum) in digit_sums.iter().enumerate() {\n        if digit_sum\
    \ > 0 {\n            count = i + 1;\n            break;\n        }\n    }\n  \
    \  count", "    let mut res = 0;\n    for (i, num) in arr.iter().enumerate() {\n\
    \        if num < 0 {\n            num *= -1;\n        }\n        if num % 10\
    \ == 0 {\n            res += 1;\n        }\n    }\n    res", "    let mut nums\
    \ = 0;\n    for e in arr.iter() {\n        let mut cur = *e + 1;\n        while\
    \ cur >= 10 {\n            cur /= 10;\n            nums += 1;\n        }\n   \
    \     *e = *e + cur;\n    }\n    nums", "    if arr.is_empty() {\n        return\
    \ 0;\n    }\n\n    let mut sum = 0;\n    let mut cnt = 0;\n    let mut cur = 0;\n\
    \    let mut carry = 0;\n\n    for n in arr {\n        sum += n.abs() as i32;\n\
    \        cur += (n as i32).abs() as i32;\n        cnt += 1;\n\n        if sum\
    \ == 0 {\n            sum += carry;\n            carry = 1;\n        } else if\
    \ sum > 0 {\n            sum += carry;\n            carry = 1;\n        } else\
    \ {\n            sum -= carry;\n            carry = 1;\n        }\n    }\n\n \
    \   cnt", "    if arr.is_empty() {\n        return 0;\n    }\n\n    if arr.iter().any(|n|\
    \ n < 0 as isize) {\n        return -1;\n    }\n\n    let mut count = 0;\n   \
    \ let mut sum = 0;\n    let mut max_digit = 0;\n\n    for i in arr.iter().rev()\
    \ {\n        sum += *i;\n        if sum < 0 {\n            sum += 10 as isize;\n\
    \        }\n        max_digit = std::cmp::max(max_digit, sum);\n    }\n\n    for\
    \ i in arr.iter().rev() {\n        if *i < 0 {\n            sum += 10 as isize;\n\
    \        } else {\n            sum += *i;\n        }\n        if sum < 0 {\n \
    \           sum += 10 as isize;\n        }\n        if sum == 0 {\n          \
    \  count++;\n        }\n        max_digit = std::cmp::max(max_digit, sum);\n \
    \   }\n\n    if max_digit > 0 { // max_digit > 0 means at least one negative number\
    \ exist\n        count += 1 - (max_digit as usize) / 10 + 1;\n    }\n\n    count",
  "    arr.iter()\n        .filter(|n| n >= 0)\n        .filter(|n| n >= 0)\n    \
    \    .filter(|n| n % 10 > 0)\n        .filter(|n| n % 10 > 0)\n        .count()",
  "    let mut c = 0;\n    for &num in arr {\n        if num > 0 {\n            c\
    \ += num;\n        }\n    }\n    c", "    let mut digits = arr.len();\n    if\
    \ digits.is_empty() {\n        return 0;\n    }\n    let mut num_negative = 0;\n\
    \    let mut num_positive = 0;\n    let mut digit = arr[0];\n    for d in &arr\
    \ {\n        if d < 0 {\n            digit -= d;\n            num_negative++;\n\
    \        } else {\n            digit += d;\n            num_positive++;\n    \
    \    }\n    }\n    if num_negative > num_positive {\n        num_negative\n  \
    \  } else {\n        num_positive\n    }", "    let mut sum = 0;\n    for el in\
    \ arr {\n        if el > 0 {\n            sum += el;\n        }\n    }\n    if\
    \ sum > 0 {\n        1\n    } else {\n        0\n    }", "    let mut cnt = 0;\n\
    \    let mut sum = 0;\n    for x in arr {\n        if x < 0 {\n            sum\
    \ += x;\n        } else {\n            sum += x / 10;\n            cnt += 1;\n\
    \        }\n    }\n    cnt", "    let mut i = 0;\n    while i < arr.len() {\n\
    \        if arr[i] > 0 {\n            i += 1;\n        } else {\n            if\
    \ arr[i] < 0 {\n                i += 1;\n            } else {\n              \
    \  i += 2;\n            }\n        }\n    }\n    i + 1", "    let mut count =\
    \ 0;\n    for &i in arr {\n        if i > 0\n            && i > -count_nums(&arr.iter().skip(i).take(1).collect())\n\
    \        {\n            count += 1;\n        }\n    }\n    count", "    let mut\
    \ sum = 0;\n    let mut digit_sum = 0;\n    for num in arr.iter() {\n        sum\
    \ += num;\n        if sum > 0 {\n            digit_sum += num as isize;\n    \
    \    }\n    }\n    if sum < 0 {\n        sum += (-sum) as isize;\n        digit_sum\
    \ -= -sum as isize;\n    }\n    digit_sum", "    let mut sum = 0;\n    for i in\
    \ arr {\n        sum += i;\n        if sum > 0 {\n            return 1;\n    \
    \    }\n    }\n    0;", "    let mut n = 0;\n    for &n in arr.iter() {\n    \
    \    let mut d = n;\n        d *= 10;\n        d += *n % 10;\n        *n /= 10;\n\
    \        n -= d;\n    }\n    n", "    arr.iter()\n        .cloned()\n        .filter(|&x|\
    \ x >= 0)\n        .filter(|x| x > 0)\n        .count(|&x| {\n            std::mem::replace(&x,\
    \ x>=0).checked_add(0).unwrap().is_positive()\n        })", "    let mut cnt =\
    \ 0;\n    for v in arr {\n        if v < 0 {\n            cnt -= v;\n        }\
    \ else {\n            cnt += v % 10;\n        }\n    }\n    cnt", "    let mut\
    \ sum = 0;\n    for &i in arr.iter() {\n        let mut dig = i;\n        if i\
    \ < 0 {\n            dig = -i;\n        }\n        sum += dig;\n    }\n    sum",
  '    arr.iter().filter(|&x| x > 0).count()', "    if arr.is_empty() {\n        return\
    \ 0;\n    }\n\n    let mut total = 0;\n    let mut current_sign = 1;\n\n    for\
    \ &x in arr {\n        let mut digits = x.to_digits();\n        let mut last_digit\
    \ = digits.last_mut();\n        match last_digit {\n            Some(d) => digits\
    \ -= d,\n            None => break,\n        };\n\n        let digit = *last_digit;\n\
    \n        if digit < 0 {\n            digit = -digit;\n            current_sign\
    \ = -1;\n        }\n\n        let mut carry = false;\n\n        for i in 0..digits.len()\
    \ {\n            let digit = digits.nth(i);\n            total += digit * current_sign;\n\
    \n            if i == digits.len() - 1 {\n                total += digit;\n  \
    \              carry = true;\n            }\n        }\n\n        if carry {\n\
    \            total += 1;\n        }\n    }\n\n    total", "    let mut cnt = 0;\n\
    \    for x in arr.iter() {\n        if x >= 0 {\n            cnt += x;\n     \
    \   }\n        else {\n            cnt += x * 10;\n        }\n    }\n    cnt",
  '    arr.iter().filter(|x| x >= 0).count()', '    arr.iter().cloned().filter(|&x|
    x >= 0).count()', "    let mut counter = 0;\n    for n in arr {\n        if n\
    \ >= 0 {\n            counter += n.leading_sign();\n        } else {\n       \
    \     counter -= n.leading_sign();\n        }\n    }\n    counter", "    let mut\
    \ sum = 0;\n    for i in arr {\n        if i < 0 {\n            sum += -i * 10;\n\
    \        } else {\n            sum += i;\n        }\n    }\n    sum", '    arr.iter().map(|x|
    x / 10).fold(0, |acc, x| acc + x).unwrap()', "    if arr.is_empty() {\n      \
    \  return 0;\n    }\n\n    // Find the number of negative numbers.\n    let mut\
    \ negative_numbers = 0;\n    let mut i = 0;\n    while i < arr.len() {\n     \
    \   if arr[i] < 0 {\n            negative_numbers += 1;\n        } else {\n  \
    \          break;\n        }\n        i += 1;\n    }\n    if negative_numbers\
    \ == 0 {\n        return arr.len();\n    }\n\n    // Start with 1.\n    let mut\
    \ sum = 1;\n    // Calculate the number of sums of each digit in arr[0..i-1].\n\
    \    for i in 0 .. negative_numbers {\n        sum += digit_sum_of_digits(&arr[i..]);\n\
    \    }\n    // Divide this sum by the number of sums of each digit in arr[0..i-1].\n\
    \    for i in 0 .. negative_numbers {\n        sum += digit_sum_of_digits(&arr[i..])\n\
    \            / digit_sum_of_digits(&arr[i..negative_numbers]);\n    }\n    sum",
  '    arr.iter().filter(|&x| x > 0).count()', "    let mut num = 0;\n    for (i,\
    \ n) in arr.iter().enumerate() {\n        if n >= 0 {\n            num += i;\n\
    \        } else {\n            num += -i;\n        }\n    }\n    num", '    arr.iter().filter(|i|
    i >= 0).count()', '    arr.iter().filter(|x| x > 0).count()', "    if arr.is_empty()\
    \ {\n        return 0\n    }\n    let mut cnt = 0;\n    for i in arr.iter().rev()\
    \ {\n        if i >= 0 {\n            cnt += i;\n        }\n    }\n    cnt", " \
    \   if arr.is_empty() {\n        return 0;\n    }\n\n    let mut n_digits = arr\n\
    \        .iter()\n        .map(|x| x.checked_add(-x))\n        .filter(|x| x.is_positive())\n\
    \        .count();\n\n    // if any number has zero or negative first digit, then\
    \ add the\n    // number of remaining digits to it\n    arr.iter().any(|x| x.checked_add(-x)\
    \ != 0).unwrap();\n    n_digits += arr.iter().filter(|x| x.checked_add(-x) !=\
    \ 0).count();\n    n_digits", "    if arr.is_empty() {\n        return 0;\n  \
    \  }\n    let mut sum = 0;\n    let mut num = 0;\n    for x in arr {\n       \
    \ if x >= 0 {\n            sum += x;\n            num += 1;\n        } else if\
    \ x < 0 {\n            sum += x;\n            num -= 1;\n        } else {\n  \
    \          if sum >= 10 {\n                return num;\n            }\n      \
    \      sum -= x;\n        }\n    }\n    return num;", "    if arr.is_empty() {\n\
    \        return 0\n    }\n\n    let mut digit_sums = vec![0; 10];\n    let mut\
    \ digit_sums_clone = vec![0; 10];\n\n    for &n in arr {\n        if n >= 0 {\n\
    \            digit_sums[n] -= 1;\n        }\n\n        if n%10 == 0 {\n      \
    \      digit_sums_clone[n%10] += 1;\n        }\n    }\n\n    let mut sum = 0;\n\
    \    for i in 0..10 {\n        if digit_sums_clone[i] > 0 && digit_sums[i] > 0\
    \ {\n            sum += digit_sums_clone[i] / digit_sums[i];\n        }\n    }\n\
    \n    sum", "    if arr.is_empty() {\n        return 0;\n    }\n    let mut cnt\
    \ = 0;\n    let mut first = 0;\n    let mut last = 0;\n    for x in arr.iter().rev()\
    \ {\n        if x % 10 == 0 {\n            cnt += 1;\n        } else {\n     \
    \       cnt += 1;\n            if cnt > 1 {\n                break;\n        \
    \    }\n        }\n        if x < 0 {\n            if first < 0 {\n          \
    \      first = x;\n            }\n        } else {\n            if last < 0 {\n\
    \                last = x;\n            }\n        }\n    }\n    if first < 0\
    \ || last < 0 {\n        return 0;\n    }\n    if last < first {\n        cnt\
    \ += 1;\n    }\n    cnt", "    // If there is no even number of numbers, no numbers\
    \ will have signed digits\n    if arr.len() % 2 == 0 {\n        return 0;\n  \
    \  }\n\n    let mut count = 0;\n\n    for &i in arr {\n        count += count_digits(i);\n\
    \    }\n\n    count", "    if arr.is_empty() {\n        return 0;\n    }\n   \
    \ let mut i = 0;\n    let mut cnt = 0;\n    let mut neg = false;\n    for &x in\
    \ arr {\n        if x < 0 {\n            if neg {\n                i += 1;\n \
    \           }\n            neg = true;\n            x = -x;\n        }\n     \
    \   let digit = x/10;\n        if digit > 0 {\n            i += digit as isize;\n\
    \        } else {\n            cnt += digit as isize;\n        }\n    }\n    cnt\
    \ * 10", "    if arr.is_empty() {\n        return 0;\n    }\n    let mut total_nums\
    \ = 0;\n    let mut last_is_neg = true;\n    for num in arr {\n        if last_is_neg\
    \ {\n            last_is_neg = num < 0;\n        } else {\n            last_is_neg\
    \ = false;\n        }\n        total_nums += (last_is_neg ? -num : num).count_digits()\
    \ + 1;\n    }\n    total_nums", "    // First convert arr to ints, because we\
    \ want to iterate over it.\n    let mut ints: Vec<isize> = arr.iter().map(|&x|\
    \ x as isize).collect();\n\n    // Check each pair of adjacent ints\n    for (a,\
    \ b) in ints.iter_mut().skip(1) {\n        // Check if a is positive\n       \
    \ if a < 0 {\n            // Convert to a negative int\n            a -= 1;\n\
    \        }\n\n        // Check if b is positive\n        if b < 0 {\n        \
    \    // Convert to a negative int\n            b -= 1;\n        }\n\n        //\
    \ If a + b >= 10, then this number has a sum of digits > 0\n        if a + b >=\
    \ 10 {\n            // Increment the number of nums\n            *b += 1;\n  \
    \      } else {\n            // Otherwise this number has no sum greater than\
    \ 0\n            *a = *a;\n        }\n    }\n\n    // Return the number of nums\n\
    \    ints.iter().filter(|&x| x > 0).count()", "    let mut cnt = 0;\n    for num\
    \ in arr {\n        if num > 0 {\n            cnt += num as isize;\n        }\n\
    \    }\n    cnt", '    count_digits(&arr, |n| if n < 0 { -n % 10 } else { n })',
  "    let mut total = 0;\n    for i in arr {\n        if !is_positive(i) {\n    \
    \        total += -i;\n        } else {\n            total += i;\n        }\n\
    \    }\n    total", '    arr.iter().filter(|&x| x > 0).count()', "    let mut\
    \ res = 0;\n    for num in arr {\n        let digits = num / 10_isize;\n     \
    \   if num % 10_isize != 0 {\n            digits = -digits;\n        }\n     \
    \   res += digits;\n    }\n    res", "    let mut n = 0;\n    let mut neg = false;\n\
    \n    for x in arr {\n        if x < 0 {\n            if !neg {\n            \
    \    n = -(n + x);\n            } else {\n                n = -(n + -x);\n   \
    \         }\n        } else {\n            if !neg {\n                n += x;\n\
    \            } else {\n                n += -x;\n            }\n        }\n\n\
    \        neg = !neg;\n    }\n\n    n", "    if arr.is_empty() {\n        return\
    \ 0;\n    }\n    if arr.len() == 1 {\n        if arr[0] < 0 {\n            return\
    \ 0;\n        }\n        return 1;\n    }\n\n    // Use map to count the digits\
    \ of each number, then sum the digits\n    // of each number.\n    arr.iter().map(|n|\
    \ if n < 10 { Some(0) } else { None }).fold(0, |sum, v| {\n        if let Some(v)\
    \ = (*v).unwrap() {\n            *sum += v;\n        }\n        sum\n    });",
  '    arr.iter().filter(|&x| x >= 0).count()', "    arr.iter()\n        .cloned()\n\
    \        .enumerate()\n        .filter(|(i, d)| d > 0)\n        .count()", " \
    \   if arr.is_empty() {\n        return 0;\n    }\n\n    let mut sum = 0;\n  \
    \  let mut carry = 0;\n    for (i, &num) in arr.iter().enumerate() {\n       \
    \ let mut next = num;\n        while next > 0 {\n            sum += 1;\n     \
    \       next %= 10;\n            carry += 1;\n        }\n        if carry > 0\
    \ {\n            sum += 1;\n        }\n    }\n\n    sum", '    arr.iter().filter(|&n|
    n > 0).count()', "    // Count the non-negative numbers in the array.\n    let\
    \ mut cnt = 0;\n    for elt in arr {\n        if elt > 0 {\n            cnt +=\
    \ 1;\n        }\n    }\n    cnt", "    let mut count = 1;\n    for &n in arr {\n\
    \        if n >= 0 {\n            count += count_nums(vec![n]);\n        } else\
    \ {\n            count += 1;\n        }\n    }\n    count", "    if arr.is_empty()\
    \ {\n        return 0\n    }\n    if arr.len() == 1 {\n        if arr.len() ==\
    \ 1 && arr[0] < 0 {\n            return 1\n        }\n        return arr.len()\n\
    \    }\n    let mut count = 0\n    let mut digits = arr.iter().map(|x| x % 10).collect::<Vec<_>>();\n\
    \    match &digits[..] {\n        vec![9, 8, 7, 6, 5, 4, 3, 2, 1, 0] | vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9] => {\n            for &d in &digits[..] {\n        \
    \        if d < 0 {\n                    count += 1;\n                }\n    \
    \        }\n        }\n        _ => {\n            for &d in &digits[..] {\n \
    \               if d < 2 {\n                    count += 1;\n                }\n\
    \            }\n        }\n    }\n    count", "    if arr.is_empty() {\n     \
    \   return 0;\n    }\n\n    let mut sum = 0;\n    let mut cur_sum = 0;\n    for\
    \ &x in arr.iter() {\n        if x == -x.wrapping_add(cur_sum) {\n           \
    \ continue;\n        }\n        sum += x;\n        cur_sum += x;\n    }\n\n  \
    \  if sum % 10 == 0 {\n        1\n    } else {\n        0\n    }", '    arr.iter().filter(|&i|
    i >= 0).filter(|&i| i % 10 != 0).count()', '    arr.iter().filter(|x| x > 0).count()',
  '    arr.iter().filter(|&i| i >= 0).count() as isize', "    // If all the numbers\
    \ are 0 or negative, then 0 is returned.\n    if arr.iter().filter(|&n| n < 0).count()\
    \ == arr.len() {\n        return 0;\n    }\n    // Initialize a counter starting\
    \ at 1, so that if we find the first non-zero digit,\n    // it will be the total\
    \ number of digits, not the length of the array.\n    let mut counter = 1;\n \
    \   for n in arr.iter().filter(|&n| n >= 0) {\n        // If this digit is non-zero,\
    \ add it to the counter.\n        if n != 0 {\n            counter += n / 10;\n\
    \        }\n        // If this digit is 0, then the next digit must be 0, too.\n\
    \        // Otherwise, if the next digit is non-zero, then it must be the total\
    \ length\n        // minus the current number of digits.\n        if n % 10 ==\
    \ 0 {\n            counter += arr.len() - counter;\n        }\n    }\n    counter",
  "    let mut sum = 0;\n    let mut nums = vec![0; arr.len()];\n    let mut carry\
    \ = 0;\n    for &n in &nums {\n        sum += n;\n        carry += sum as isize\
    \ % 10;\n        sum = sum / 10;\n    }\n    if carry > 0 {\n        sum += carry;\n\
    \    }\n    sum as isize", "    arr.iter()\n        .map(|num| {\n           \
    \ if *num < 0 {\n                -num\n            } else {\n                *num\n\
    \            }\n        })\n        .filter(|num| num.is_positive())\n       \
    \ .count()", '    arr.iter().filter(|&x| x > 0).count()', "    let mut n = arr\n\
    \        .iter()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .map(|n| if n > 0 { *n } else { -n })\n        .sum();\n    n.checked_add(-(arr[0]\
    \ as isize)).unwrap()", "    if arr.is_empty() {\n        return 0;\n    }\n \
    \   let mut i = 1;\n    let mut c = 1;\n    for x in arr.iter().cloned() {\n \
    \       i += x;\n        if i >= 0 {\n            c++;\n        }\n    }\n   \
    \ c", "    let mut cnt: isize = 0;\n    let mut sum = 0;\n    for num in arr.iter()\
    \ {\n        if sum + num > 0 {\n            sum += num;\n            cnt += 1;\n\
    \        }\n    }\n    cnt", "    if arr.is_empty() {\n        return 0;\n   \
    \ }\n\n    // Convert numbers to their sign-magnitude representation so we can\
    \ use bit-manipulation\n    // to efficiently count the number of positive summands.\n\
    \    let mut sign = -1;\n    let mut magnitude = 0;\n    for &i in arr {\n   \
    \     if i >= 0 {\n            magnitude += i;\n        } else {\n           \
    \ sign = -sign;\n            magnitude += i;\n        }\n    }\n\n    if magnitude\
    \ == 0 {\n        return 0;\n    }\n\n    // Count the number of positive summands\n\
    \    let mut pos_sum = 0;\n    for &i in arr {\n        match i {\n          \
    \  1 => pos_sum,\n            -1 => pos_sum,\n            _ => {\n           \
    \     if sign == -1 {\n                    pos_sum -= i;\n                } else\
    \ {\n                    pos_sum += i;\n                }\n            }\n   \
    \     }\n    }\n\n    pos_sum", '    arr.iter().filter(|&i| i >= 0).count(|i|
    i as usize - i % 10).unwrap()', "    arr\n        .iter()\n        .filter(|&n|\
    \ n > 0)\n        .filter_map(|n| {\n            if n <= 0 {\n               \
    \ Some(-n)\n            } else {\n                Some(n.digits().first().unwrap())\n\
    \            }\n        })\n        .count()", "    if arr.is_empty() {\n    \
    \    return 0;\n    }\n\n    let mut first_negative = arr[0] < 0;\n    let mut\
    \ sum = arr[0] as isize;\n\n    for x in arr.iter().skip(1) {\n        sum +=\
    \ x;\n        if sum < 0 {\n            first_negative = !first_negative;\n  \
    \          sum += first_negative as isize;\n        }\n    }\n\n    if sum ==\
    \ 0 {\n        return 0;\n    }\n\n    sum", "    let mut count = 0;\n    for\
    \ i in arr {\n        if i > 0 {\n            count += i; \n        }\n    }\n\
    \    count"]
stop_tokens:
- "\n}"
