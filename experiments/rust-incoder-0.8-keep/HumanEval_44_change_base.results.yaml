name: HumanEval_44_change_base
language: rust
results:
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut digits = vec![];\n    let mut base = base;\n    while x >= base\
    \ {\n        digits.push((x % base).to_string());\n        x = x / base;\n   \
    \ }\n    digits.push((x).to_string());\n    digits.reverse()\n        .iter()\n\
    \        .fold(String::new(), |mut acc, digit| {\n            acc.push_str(digit);\n\
    \            acc.push('0');\n            acc\n        })\n}\n\nfn main() {\n \
    \   let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmponz6ljr8.rs:19:10\n   |\n19 |         .iter()\n   |   \
    \       ^^^^ method not found in `()`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut tmp = 0;\n    let mut base10\
    \ = 1;\n    let mut tmp10 = 0;\n    while base10 < base {\n        tmp = x.pow(base10).unwrap();\n\
    \        tmp10 = tmp % base10;\n        s = s.concat(tmp10 + '0');\n        base10\
    \ *= base;\n    }\n    if x.pow(base).unwrap() != x {\n        s = s.concat('1');\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppeoxe4bf.rs:16:21\n   |\n\
    16 |         tmp = x.pow(base10).unwrap();\n   |                     ^^^^^^ expected\
    \ `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and\
    \ panic if the converted value doesn't fit\n   |\n16 |         tmp = x.pow(base10.try_into().unwrap()).unwrap();\n\
    \   |                           ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `isize` in the current scope\n  --> /tmp/tmppeoxe4bf.rs:16:29\n\
    \   |\n16 |         tmp = x.pow(base10).unwrap();\n   |                      \
    \       ^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named `concat`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmppeoxe4bf.rs:18:15\n\
    \   |\n18 |         s = s.concat(tmp10 + '0');\n   |               ^^^^^^ method\
    \ not found in `String`\n\nerror[E0277]: cannot add `char` to `isize`\n  --> /tmp/tmppeoxe4bf.rs:18:28\n\
    \   |\n18 |         s = s.concat(tmp10 + '0');\n   |                         \
    \   ^ no implementation for `isize + char`\n   |\n   = help: the trait `Add<char>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppeoxe4bf.rs:21:14\n\
    \   |\n21 |     if x.pow(base).unwrap() != x {\n   |              ^^^^ expected\
    \ `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and\
    \ panic if the converted value doesn't fit\n   |\n21 |     if x.pow(base.try_into().unwrap()).unwrap()\
    \ != x {\n   |                  ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `isize` in the current scope\n  --> /tmp/tmppeoxe4bf.rs:21:20\n\
    \   |\n21 |     if x.pow(base).unwrap() != x {\n   |                    ^^^^^^\
    \ method not found in"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut digits = x.to_digits();\n    digits.reverse();\n    for i in\
    \ 0..digits.get(base) {\n        digits.insert(i, base);\n    }\n    String::from_digits(digits,\
    \ base).to_string()\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpwi4lrd9c.rs:11:24\n   |\n11 |     let mut digits\
    \ = x.to_digits();\n   |                        ^^^^^^^^^ method not found in\
    \ `isize`\n\nerror[E0599]: no function or associated item named `from_digits`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpwi4lrd9c.rs:16:13\n\
    \   |\n16 |     String::from_digits(digits, base).to_string()\n   |          \
    \   ^^^^^^^^^^^ function or associated item not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut counter = 1;\n    let mut\
    \ digits = (0..x).collect::<Vec<_>>();\n    for digit in &digits {\n        let\
    \ mut remainder = (*digit).mod(base);\n        digit = match remainder {\n   \
    \         0 => digit,\n            1 => base,\n            2 => base / 2,\n  \
    \          _ => base,\n        };\n        if digit != 0 {\n            if remainder\
    \ == 1 {\n                result.push((*digit).to_string());\n            } else\
    \ {\n                result.push((*digit).to_string());\n                result.push((*remainder).to_string());\n\
    \            }\n            counter += 1;\n        }\n    }\n    if counter ==\
    \ 0 {\n        result.push((*x).to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `mod`\n  --> /tmp/tmpsk7rlfwp.rs:15:38\n\
    \   |\n15 |         let mut remainder = (*digit).mod(base);\n   |            \
    \                          ^^^ expected identifier, found keyword\n   |\nhelp:\
    \ escape `mod` to use it as an identifier\n   |\n15 |         let mut remainder\
    \ = (*digit).r#mod(base);\n   |                                      ++\n\nerror[E0599]:\
    \ no method named `r#mod` found for type `isize` in the current scope\n  --> /tmp/tmpsk7rlfwp.rs:15:38\n\
    \   |\n15 |         let mut remainder = (*digit).mod(base);\n   |            \
    \                          ^^^ method not found in `isize`\n\nerror[E0308]: `match`\
    \ arms have incompatible types\n  --> /tmp/tmpsk7rlfwp.rs:18:18\n   |\n16 |  \
    \         digit = match remainder {\n   |  _________________-\n17 | |        \
    \     0 => digit,\n   | |                  ----- this is found to be of type `&isize`\n\
    18 | |             1 => base,\n   | |                  ^^^^\n   | |          \
    \        |\n   | |                  expected `&isize`, found `isize`\n   | | \
    \                 help: consider borrowing here: `&base`\n19 | |             2\
    \ => base / 2,\n20 | |             _ => base,\n21 | |         };\n   | |_________-\
    \ `match` arms have incompatible types\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpsk7rlfwp.rs:22:18\n   |\n22 |         if digit\
    \ != 0 {\n   |                  ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsk7rlfwp.rs:24:29\n\
    \   |\n24 |                 result.push((*digit).to_string());\n   |         \
    \                    ^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsk7rlfwp.rs:26:29\n   |\n26 |\
    \                 result.push((*digit)"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut base = base;\n\n    while x >\
    \ 0 {\n        let tmp = x % base;\n        s += String::from(\"0123456789abcdef\"\
    .chars()[tmp].to_string());\n        x = x / base;\n        base = base * 10;\n\
    \    }\n    if base > 10 {\n        let tmp = x % base;\n        s += String::from(\"\
    0123456789abcdef\".chars()[tmp].to_string());\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpsfdtqruf.rs:16:27\n\
    \   |\n16 |         s += String::from(\"0123456789abcdef\".chars()[tmp].to_string());\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsfdtqruf.rs:16:14\n   |\n16 |         s += String::from(\"\
    0123456789abcdef\".chars()[tmp].to_string());\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |              |\n   |              expected `&str`, found struct `String`\n\
    \   |              help: consider borrowing here: `&String::from(\"0123456789abcdef\"\
    .chars()[tmp].to_string())`\n\nerror[E0608]: cannot index into a value of type\
    \ `Chars<'_>`\n  --> /tmp/tmpsfdtqruf.rs:22:27\n   |\n22 |         s += String::from(\"\
    0123456789abcdef\".chars()[tmp].to_string());\n   |                          \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsfdtqruf.rs:22:14\n\
    \   |\n22 |         s += String::from(\"0123456789abcdef\".chars()[tmp].to_string());\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |              |\n   |              expected `&str`, found struct `String`\n\
    \   |              help: consider borrowing here: `&String::from(\"0123456789abcdef\"\
    .chars()[tmp].to_string())`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut x = x.to_digits(base, 10);\n    x.reverse();\n    let mut result\
    \ = String::new();\n    for i in x {\n        result.append(&i + '0');\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp62pj52x2.rs:11:19\n   |\n11 |     let mut x = x.to_digits(base,\
    \ 10);\n   |                   ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp62pj52x2.rs:15:16\n   |\n15 |         result.append(&i + '0');\n   |\
    \                ^^^^^^ method not found in `String`\n\nerror[E0277]: cannot add\
    \ `char` to `&_`\n  --> /tmp/tmp62pj52x2.rs:15:26\n   |\n15 |         result.append(&i\
    \ + '0');\n   |                          ^ no implementation for `&_ + char`\n\
    \   |\n   = help: the trait `Add<char>` is not implemented for `&_`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut digits = String::new();\n    while x > 0 {\n        let digit\
    \ = x % base;\n        x = x / base;\n        if digits != \"0\".to_owned() +\
    \ &digit + &digits[1..] {\n            digits += &digit;\n        }\n    }\n \
    \   return digits.to_string();\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_utxmsr4.rs:15:39\n   |\n\
    15 |         if digits != \"0\".to_owned() + &digit + &digits[1..] {\n   |   \
    \                                    ^^^^^^ expected `str`, found `isize`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_utxmsr4.rs:16:23\n   |\n16 |\
    \             digits += &digit;\n   |                       ^^^^^^ expected `str`,\
    \ found `isize`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    while x >= base {\n        res.insert(0,\
    \ &x.to_string().rjust(base, '0'));\n        x = x / base;\n    }\n    res.insert(0,\
    \ &x.to_string());\n    res\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rjust` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp387p6otc.rs:13:38\n   |\n13 |         res.insert(0,\
    \ &x.to_string().rjust(base, '0'));\n   |                                    \
    \  ^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp387p6otc.rs:16:19\n   |\n16 |     res.insert(0, &x.to_string());\n \
    \  |                   ^^^^^^^^^^^^^^ expected `char`, found `&String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut y = x;\n    let mut base: char;\n\n    // Check that the base\
    \ is indeed valid for this number\n    assert!(base >= 2 && base <= 10);\n\n \
    \   // Convert from base to radix\n    base = base as char;\n\n    // Check for\
    \ overflow\n    if y > i32::MAX as isize {\n        y = i32::MAX as isize;\n \
    \       base += 'a' - '0';\n    }\n\n    // Convert to binary\n    let mut bin:\
    \ String;\n    if base == 10 {\n        bin = format!(\"{:b}\", y);\n    } else\
    \ if base == 8 {\n        bin = format!(\"{:o}\", y);\n    } else if base == 5\
    \ {\n        bin = format!(\"{:x}\", y);\n    } else {\n        bin = format!(\"\
    {:#o}\", y);\n    }\n    // Add prefix if necessary\n    let mut prefix: String;\n\
    \    let mut prefix_len = 1;\n\n    // Count leading zeros\n    let mut leading_zeros:\
    \ usize = 0;\n    while y < i32::MAX as usize {\n        leading_zeros += 1;\n\
    \        y /= base;\n    }\n    // Prefix leading zeros\n    let mut prefix =\
    \ String::new();\n    for _ in 0..leading_zeros {\n        prefix.push(0);\n \
    \   }\n    // Add radix char\n    prefix.push(base);\n\n    // Add prefix, if\
    \ needed\n    if prefix.len() > prefix_len {\n        bin = prefix + bin;\n  \
    \  }\n    // Convert to string\n    bin.to_string()\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmykm6k6r.rs:15:21\n   |\n\
    15 |     assert!(base >= 2 && base <= 10);\n   |                     ^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmykm6k6r.rs:15:34\n\
    \   |\n15 |     assert!(base >= 2 && base <= 10);\n   |                      \
    \            ^^ expected `char`, found `u8`\n\nerror[E0369]: cannot subtract `char`\
    \ from `char`\n  --> /tmp/tmpmykm6k6r.rs:23:21\n   |\n23 |         base += 'a'\
    \ - '0';\n   |                 --- ^ --- char\n   |                 |\n   |  \
    \               char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmykm6k6r.rs:28:16\n\
    \   |\n28 |     if base == 10 {\n   |                ^^ expected `char`, found\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmykm6k6r.rs:30:23\n  \
    \ |\n30 |     } else if base == 8 {\n   |                       ^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmykm6k6r.rs:32:23\n\
    \   |\n32 |     } else if base == 5 {\n   |                       ^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmykm6k6r.rs:43:15\n\
    \   |\n43 |     while y < i32::MAX as usize {\n   |               ^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n43 |     while y\
    \ < (i32::MAX as usize).try_into().unwrap() {\n   |               +          \
    \       +++++++++++++++++++++\n\nerror[E0277]: cannot divide-assign `isize` by\
    \ `char`\n  --> /tmp/tmpmykm6k6r.rs:45:11\n   |\n45 |         y /= base;\n   |\
    \           ^^ no implementation for `isize /= char`\n   |\n   = help: the trait\
    \ `DivAssign<char>` is not implemented for `isize`\n   = help: the following other\
    \ types implement trait `DivAssign<Rhs>`:\n             <f32 as DivAssign<&f32>>\n\
    \             <f32 as DivAssign>\n             <f64 as DivAssign<&f64>>\n    \
    \         <f64 as DivAssign>\n             <i128 as DivAssign<&i128>>\n      \
    \       <i128 as DivAssign>\n             <i16 as DivAssign<&i16>>\n         \
    \    <i16 as DivAssign>\n           and 20 others\n\nerror[E0308]: "
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base > 10 {\n        Err(format!(\"Invalid base: {}.\", base))\n \
    \   } else if base < 2 {\n        Err(format!(\"Invalid base: {}.\", base))\n\
    \    } else {\n        let mut xs: Vec<String> = x.to_string().chars().map(|c|\
    \ c.to_string()).collect();\n        xs[x.len() - 1] += match xs[x.len() - 1]\
    \ {\n            \"0\" => \"i\",\n            \"1\" => \"j\",\n            \"\
    2\" => \"k\",\n            _ => panic!(\"Invalid base\"),\n        };\n      \
    \  xs.into_iter().fold(String::new(), |mut acc, x| {\n            acc.push_str(x);\n\
    \            acc.push_str(&mut x[x.len() - 1]);\n            acc\n        })\n\
    \    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprk347sde.rs:12:9\n   |\n\
    10 | fn change_base(x: isize, base: isize) -> String {\n   |                 \
    \                         ------ expected `String` because of return type\n11\
    \ |     if base > 10 {\n12 |         Err(format!(\"Invalid base: {}.\", base))\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Result`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Result<_, String>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprk347sde.rs:14:9\n   |\n10 | fn change_base(x: isize, base: isize) ->\
    \ String {\n   |                                          ------ expected `String`\
    \ because of return type\n...\n14 |         Err(format!(\"Invalid base: {}.\"\
    , base))\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Result`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Result<_, String>`\n\nerror[E0599]: no method named\
    \ `len` found for type `isize` in the current scope\n  --> /tmp/tmprk347sde.rs:17:14\n\
    \   |\n17 |         xs[x.len() - 1] += match xs[x.len() - 1] {\n   |         \
    \     ^^^ method not found in `isize`\n\nerror[E0599]: no method named `len` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmprk347sde.rs:17:39\n   |\n\
    17 |         xs[x.len() - 1] += match xs[x.len() - 1] {\n   |                \
    \                       ^^^ method not found in `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprk347sde.rs:24:26\n   |\n24 |             acc.push_str(x);\n\
    \   |                          ^\n   |                          |\n   |      \
    \                    expected `&str`, found struct `String`\n   |            \
    \              help: consider borrowing here: `&x`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmprk347sde.rs:25:31\n   |\n25 |  \
    \           acc.push_str(&mut x[x.len() - 1]);\n   |                         \
    \      ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the follo"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    format!(\"{}\", x.to_digits(base).unwrap().to_digits(base).unwrap())\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp344635e5.rs:11:21\n   |\n11 |     format!(\"{}\"\
    , x.to_digits(base).unwrap().to_digits(base).unwrap())\n   |                 \
    \    ^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut x = x;\n    let mut base = base;\n    if x <= 10 {\n        base\
    \ = base * 10 + x;\n        x = x;\n    }\n    let mut str = \"\";\n    for &n\
    \ in &x {\n        let mut x = n;\n        for &b in &base {\n            x =\
    \ x * b;\n        }\n        str += &n.to_string();\n    }\n    str\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `&isize` is not an iterator\n  --> /tmp/tmp3z6bqc9b.rs:18:15\n\
    \   |\n18 |     for &n in &x {\n   |               ^^ `&isize` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&isize`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&isize`\n\
    \nerror[E0277]: `&isize` is not an iterator\n  --> /tmp/tmp3z6bqc9b.rs:20:19\n\
    \   |\n20 |         for &b in &base {\n   |                   ^^^^^ `&isize` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&isize`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3z6bqc9b.rs:25:5\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n25 |     str\n   |     ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut num_str = x.to_string();\n\
    \    while num_str.len() >= base {\n        num_str = num_str[..base].to_string();\n\
    \        res.insert(0, &num_str);\n    }\n    \n    return res.to_string();\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkp7e86_w.rs:13:28\n   |\n\
    13 |     while num_str.len() >= base {\n   |                            ^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n13 |     while num_str.len()\
    \ >= base.try_into().unwrap() {\n   |                                ++++++++++++++++++++\n\
    \nerror[E0277]: the type `String` cannot be indexed by `RangeTo<isize>`\n  -->\
    \ /tmp/tmpkp7e86_w.rs:14:19\n   |\n14 |         num_str = num_str[..base].to_string();\n\
    \   |                   ^^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<isize>`\n\
    \   |\n   = help: the trait `Index<RangeTo<isize>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkp7e86_w.rs:15:23\n\
    \   |\n15 |         res.insert(0, &num_str);\n   |                       ^^^^^^^^\
    \ expected `char`, found `&String`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 1 || base > 10 {\n        panic!(\"invalid base\")\n    }\n\
    \    let mut digits: Vec<String> = vec![];\n    let mut divisor = base;\n    while\
    \ divisor > 0 {\n        digits.insert(0, x % divisor);\n        divisor /= base;\n\
    \    }\n    digits.reverse();\n    digits.join(\"0\")\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptojbn17r.rs:17:26\n   |\n\
    17 |         digits.insert(0, x % divisor);\n   |                          ^^^^^^^^^^^\
    \ expected struct `String`, found `isize`\n   |\nhelp: try using a conversion\
    \ method\n   |\n17 |         digits.insert(0, (x % divisor).to_string());\n  \
    \ |                          +           +++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    match base {\n        2 => {\n            if x == 0 {\n             \
    \   \"0\"\n            } else {\n                format!(\"{:0>3}\", x / base)\n\
    \            }\n        }\n        3 => {\n            if x == 0 {\n         \
    \       \"0\"\n            } else {\n                format!(\"{:0>5}\", x / base)\n\
    \            }\n        }\n        4 => {\n            if x == 0 {\n         \
    \       \"0\"\n            } else {\n                format!(\"{:0>7}\", x / base)\n\
    \            }\n        }\n        _ => format!(\"{:#0>#}\", x, base),\n    }\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: invalid format string: expected `'}'`, found `'>'`\n  --> /tmp/tmpighvcpx9.rs:33:27\n\
    \   |\n33 |         _ => format!(\"{:#0>#}\", x, base),\n   |                \
    \       -   ^ expected `}` in format string\n   |                       |\n  \
    \ |                       because of this opening brace\n   |\n   = note: if you\
    \ intended to print `{`, you can escape it using `{{`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpighvcpx9.rs:14:17\n   |\n10 | fn change_base(x: isize,\
    \ base: isize) -> String {\n   |                                          ------\
    \ expected `String` because of return type\n...\n14 |                 \"0\"\n\
    \   |                 ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                 |\n   |                 expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpighvcpx9.rs:21:17\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n21 |                 \"0\"\n   |                 ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                 |\n   |                 expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpighvcpx9.rs:28:17\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n28 |                 \"0\"\n   |                 ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                 |\n   |                 expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    use num_traits::FromPrimitive;\n    let number = FromPrimitive::from_i64(x);\n\
    \    let mut result = String::new();\n    let mut i = 0;\n    let mut rem = number;\n\
    \    while rem != 0 {\n        rem /= base;\n        if i == 0 {\n           \
    \ result.resize(i, 0);\n        }\n        result[i] += char::from_integer(rem\
    \ % base);\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0432]: unresolved import `num_traits`\n  --> /tmp/tmpeoekxd_n.rs:11:9\n\
    \   |\n11 |     use num_traits::FromPrimitive;\n   |         ^^^^^^^^^^ maybe\
    \ a missing crate `num_traits`?\n\nerror[E0599]: no method named `resize` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpeoekxd_n.rs:19:20\n\
    \   |\n19 |             result.resize(i, 0);\n   |                    ^^^^^^ method\
    \ not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `{integer}`\n  --> /tmp/tmpeoekxd_n.rs:21:9\n   |\n21 |         result[i] +=\
    \ char::from_integer(rem % base);\n   |         ^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no function or associated item named `from_integer`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpeoekxd_n.rs:21:28\n\
    \   |\n21 |         result[i] += char::from_integer(rem % base);\n   |       \
    \                     ^^^^^^^^^^^^ function or associated item not found in `char`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0432, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut buf = [0isize; 5];\n    let mut b = [1isize; 5];\n    let mut\
    \ x = x as usize;\n    loop {\n        buf[base as usize + 1] = x\n          \
    \  & b[base as usize]\n            as usize\n            .checked_mul(base)\n\
    \            .unwrap();\n        buf[base as usize] = x >> (base as usize);\n\
    \        x = x;\n        base = base.checked_add(1);\n        if base == 5 {\n\
    \            break;\n        }\n    }\n    format!(\"{}\", buf[base as usize].to_le_bytes())\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpknj6egq7.rs:16:15\n\
    \   |\n16 |               & b[base as usize]\n   |  _______________^\n17 | | \
    \            as usize\n   | |____________________^\n   |\nhelp: try surrounding\
    \ the expression in parentheses\n   |\n16 ~             & (b[base as usize]\n\
    17 ~             as usize)\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpknj6egq7.rs:18:26\n\
    \   |\n18 |             .checked_mul(base)\n   |                          ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n18 |           \
    \  .checked_mul(base.try_into().unwrap())\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpknj6egq7.rs:15:34\n   |\n15 |\
    \           buf[base as usize + 1] = x\n   |  _________----------------------___^\n\
    \   | |         |\n   | |         expected due to the type of this binding\n16\
    \ | |             & b[base as usize]\n17 | |             as usize\n18 | |    \
    \         .checked_mul(base)\n19 | |             .unwrap();\n   | |_____________________^\
    \ expected `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpknj6egq7.rs:20:30\n\
    \   |\n20 |         buf[base as usize] = x >> (base as usize);\n   |         ------------------\
    \   ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |         |\n   |\
    \         expected due to the type of this binding\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpknj6egq7.rs:22:16\n   |\n10 | fn change_base(x: isize,\
    \ base: isize) -> String {\n   |                                ----- expected\
    \ due to this parameter type\n...\n22 |         base = base.checked_add(1);\n\
    \   |                ^^^^^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0277]: `[u8; 8]` doesn't implement `std::fmt::Display`\n  --> /tmp/tmpknj6egq7.rs:27:19\n\
    \   |\n27 |     format!(\"{}\", buf[base as usize].to_le_bytes())\n   |      \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `[u8; 8]` c"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut b = base;\n    while b >= 10\
    \ {\n        *s.push_str(&format!(\"{}\", x%b));\n        s +=\n            to_base(&x,\
    \ b as usize).to_string();\n        x /= b;\n        b *= base;\n    }\n    *s.push_str(&format!(\"\
    {}\", x))\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_base` in this scope\n  --> /tmp/tmpcykbi0h8.rs:16:13\n\
    \   |\n16 |             to_base(&x, b as usize).to_string();\n   |           \
    \  ^^^^^^^ not found in this scope\n\nerror[E0614]: type `()` cannot be dereferenced\n\
    \  --> /tmp/tmpcykbi0h8.rs:14:9\n   |\n14 |         *s.push_str(&format!(\"{}\"\
    , x%b));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type\
    \ `()` cannot be dereferenced\n  --> /tmp/tmpcykbi0h8.rs:20:5\n   |\n20 |    \
    \ *s.push_str(&format!(\"{}\", x))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\nhelp: parentheses are required to parse this as an expression\n   |\n13\
    \ ~     (while b >= 10 {\n14 |         *s.push_str(&format!(\"{}\", x%b));\n15\
    \ |         s +=\n16 |             to_base(&x, b as usize).to_string();\n17 |\
    \         x /= b;\n18 |         b *= base;\n ...\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut number = x;\n    while number\
    \ != 0 {\n        if number % base == 0 {\n            s.push('0');\n        }\n\
    \        s.push('1');\n        number /= base;\n    }\n    s[s.len() - 1].to_string()\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy_3l8knw.rs:20:5\n\
    \   |\n20 |     s[s.len() - 1].to_string()\n   |     ^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = format!(\"{}\", x);\n    match base {\n        10 | 2 | 8\
    \ => s.chars().collect::<Vec<_>>().to_owned(),\n        _ => {\n            let\
    \ mut i = 0;\n            for c in s.chars().collect::<Vec<_>>() {\n         \
    \       i <<= 1;\n                i |= c - '0';\n            }\n            i\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr3bcaxam.rs:13:23\n   |\n\
    10 | fn change_base(x: isize, base: isize) -> String {\n   |                 \
    \                         ------ expected `String` because of return type\n...\n\
    13 |         10 | 2 | 8 => s.chars().collect::<Vec<_>>().to_owned(),\n   |   \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `String`\n  \
    \            found struct `Vec<char>`\n\nerror[E0369]: cannot subtract `char`\
    \ from `char`\n  --> /tmp/tmpr3bcaxam.rs:18:24\n   |\n18 |                 i |=\
    \ c - '0';\n   |                      - ^ --- char\n   |                     \
    \ |\n   |                      char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3bcaxam.rs:20:13\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n20 |             i\n   |             ^- help: try using a conversion method:\
    \ `.to_string()`\n   |             |\n   |             expected struct `String`,\
    \ found integer\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    match base {\n        2 => String::from_str(x.to_string(), \"base2\"\
    ).unwrap().to_string(),\n        3 => String::from_str(x.to_string(), \"base3\"\
    ).unwrap().to_string(),\n        4 => String::from_str(x.to_string(), \"base4\"\
    ).unwrap().to_string(),\n        5 => String::from_str(x.to_string(), \"base5\"\
    ).unwrap().to_string(),\n        6 => String::from_str(x.to_string(), \"base6\"\
    ).unwrap().to_string(),\n        7 => String::from_str(x.to_string(), \"base7\"\
    ).unwrap().to_string(),\n        _ => panic!(\"Unsupported base.\"),\n    }\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `from_str` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmphfrmx9g5.rs:12:22\n   |\n\
    12 |         2 => String::from_str(x.to_string(), \"base2\").unwrap().to_string(),\n\
    \   |                      ^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0599]: no function\
    \ or associated item named `from_str` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmphfrmx9g5.rs:13:22\n   |\n13 |         3 => String::from_str(x.to_string(),\
    \ \"base3\").unwrap().to_string(),\n   |                      ^^^^^^^^ function\
    \ or associated item not found in `String`\n   |\n   = help: items from traits\
    \ can only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::str::FromStr;\n\
    \   |\n\nerror[E0599]: no function or associated item named `from_str` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmphfrmx9g5.rs:14:22\n   |\n\
    14 |         4 => String::from_str(x.to_string(), \"base4\").unwrap().to_string(),\n\
    \   |                      ^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0599]: no function\
    \ or associated item named `from_str` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmphfrmx9g5.rs:15:22\n   |\n15 |         5 => String::from_str(x.to_string(),\
    \ \"base5\").unwrap().to_string(),\n   |                      ^^^^^^^^ function\
    \ or associated item not found in `String`\n   |\n   = help: items from traits\
    \ can only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::str::FromStr"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result: String = String::new();\n    let mut digits = vec![0;\
    \ base];\n    let mut x: isize = x;\n    let mut base: isize = base;\n    let\
    \ mut remainder: isize = 0;\n    while x >= base {\n        remainder = x % base;\n\
    \        digits[base] = remainder;\n        x = x / base;\n        base = base\
    \ * 10;\n    }\n    digits[base] = x;\n    digits.reverse();\n    for digit in\
    \ digits {\n        result = format!(\"{}\", result) + format!(\"{}\", digit);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp26fi6lco.rs:12:30\n   |\n\
    12 |     let mut digits = vec![0; base];\n   |                              ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ digits = vec![0; base.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp26fi6lco.rs:18:9\n   |\n18 |         digits[base]\
    \ = remainder;\n   |         ^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp26fi6lco.rs:22:5\n   |\n22 |   \
    \  digits[base] = x;\n   |     ^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp26fi6lco.rs:25:42\n   |\n25 |         result = format!(\"{}\", result)\
    \ + format!(\"{}\", digit);\n   |                                          ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut buff = String::new();\n    let mut tmp = x;\n    let mut bpow\
    \ = 1;\n    while tmp >= base {\n        tmp = tmp / base;\n        bpow = *bpow\
    \ * base;\n    }\n    while tmp > 0 {\n        buff.push(format!(\"{:?}\", tmp\
    \ % base));\n        tmp = tmp / base;\n    }\n    buff.push(bpow);\n    buff\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpoqgywd_q.rs:16:16\n\
    \   |\n16 |         bpow = *bpow * base;\n   |                ^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoqgywd_q.rs:19:19\n   |\n19 |         buff.push(format!(\"\
    {:?}\", tmp % base));\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n   |\n   = note: this error originates in the\
    \ macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoqgywd_q.rs:22:15\n   |\n22 |\
    \     buff.push(bpow);\n   |               ^^^^ expected `char`, found integer\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = x;\n    while digits\
    \ > 0 {\n        let next = digits % base;\n        res.insert(0, digits_table[next].to_string());\n\
    \        digits /= base;\n    }\n    res.insert(0, digits_table[x].to_string());\n\
    \    res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `digits_table` in this scope\n  --> /tmp/tmplkvitpoo.rs:15:23\n\
    \   |\n15 |         res.insert(0, digits_table[next].to_string());\n   |     \
    \                  ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `digits_table` in this scope\n  --> /tmp/tmplkvitpoo.rs:18:19\n \
    \  |\n18 |     res.insert(0, digits_table[x].to_string());\n   |             \
    \      ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut digits: Vec<usize> = vec![];\n    let mut digits_digits: Vec<usize>\
    \ = vec![];\n    loop {\n        let y = x % base;\n        digits.push(y);\n\
    \        x = x / base;\n        let digit = digits.last().unwrap();\n        digits_digits.push(digit);\n\
    \        if x == 0 {\n            break;\n        }\n    }\n    let mut digits_digits_len\
    \ = digits_digits_digits.len();\n    let mut digits_len = digits.len();\n    let\
    \ mut result = String::with_capacity(digits_digits.len() * 2);\n    if base >\
    \ 10 {\n        for &digit in &digits_digits {\n            if digit < 10 {\n\
    \                result.push_str(&to_string(*digit).as_str());\n             \
    \   result.push_str(&to_string(digit).as_str());\n            } else {\n     \
    \           result.push_str(&to_string(digit % 10).as_str());\n              \
    \  result.push_str(&to_string(digit / 10).as_str());\n            }\n        }\n\
    \        result.push_str(&to_string(digits_len).as_str());\n        result.push_str(&to_string(digits_digits_len).as_str());\n\
    \    } else {\n        for &digit in &digits_digits {\n            result.push_str(&to_string(digit\
    \ as i32).as_str());\n            result.push_str(&to_string(digit % 10).as_str());\n\
    \        }\n        result.push_str(&to_string(digits_len).as_str());\n      \
    \  result.push_str(&to_string(digits_digits_len).as_str());\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `digits_digits_digits` in this scope\n\
    \  --> /tmp/tmp6cb1ccsy.rs:23:33\n   |\n23 |     let mut digits_digits_len = digits_digits_digits.len();\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmp6cb1ccsy.rs:29:34\n\
    \   |\n29 |                 result.push_str(&to_string(*digit).as_str());\n  \
    \ |                                  ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `to_string` in this scope\n  --> /tmp/tmp6cb1ccsy.rs:30:34\n\
    \   |\n30 |                 result.push_str(&to_string(digit).as_str());\n   |\
    \                                  ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `to_string` in this scope\n  --> /tmp/tmp6cb1ccsy.rs:32:34\n\
    \   |\n32 |                 result.push_str(&to_string(digit % 10).as_str());\n\
    \   |                                  ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `to_string` in this scope\n  --> /tmp/tmp6cb1ccsy.rs:33:34\n\
    \   |\n33 |                 result.push_str(&to_string(digit / 10).as_str());\n\
    \   |                                  ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `to_string` in this scope\n  --> /tmp/tmp6cb1ccsy.rs:36:26\n\
    \   |\n36 |         result.push_str(&to_string(digits_len).as_str());\n   |  \
    \                        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `to_string` in this scope\n  --> /tmp/tmp6cb1ccsy.rs:37:26\n \
    \  |\n37 |         result.push_str(&to_string(digits_digits_len).as_str());\n\
    \   |                          ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `to_string` in this scope\n  --> /tmp/tmp6cb1ccsy.rs:40:30\n\
    \   |\n40 |             result.push_str(&to_string(digit as i32).as_str());\n\
    \   |                              ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `to_string` in this scope\n  --> /tmp/tmp6cb1ccsy.rs:41:30\n\
    \   |\n41 |             result.push_str(&to_strin"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut base = BASES[base];\n    if base == 0 {\n        panic!(\"invalid\
    \ base\");\n    }\n    let mut val = x;\n    let mut digits = 1;\n    while val\
    \ > base {\n        val /= base;\n        digits += 1;\n    }\n    while val >\
    \ 1 {\n        val /= 10;\n        digits += 1;\n    }\n    let mut result = String::new();\n\
    \    while digits > 0 {\n        let next = val % (base * 10);\n        result.push(BASES[base].to_string());\n\
    \        val /= base;\n        digits -= 1;\n    }\n    result.reverse();\n  \
    \  result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `BASES` in this scope\n  --> /tmp/tmpxj_rd62j.rs:11:20\n\
    \   |\n11 |     let mut base = BASES[base];\n   |                    ^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `BASES` in this scope\n\
    \  --> /tmp/tmpxj_rd62j.rs:28:21\n   |\n28 |         result.push(BASES[base].to_string());\n\
    \   |                     ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `reverse` found for struct `String` in the current scope\n  --> /tmp/tmpxj_rd62j.rs:32:12\n\
    \   |\n32 |     result.reverse();\n   |            ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    use std::fmt::{Display, Formatter};\n    let mut num_str = format!(\"\
    {}\", x);\n    let mut base_str = format!(\"{}\", base);\n    while base_str.len()\
    \ <= 3 {\n        base_str += base_str.len() > 2 ? base - base_str.len() + 1 :\
    \ base;\n    }\n    base_str.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `base`\n\
    \  --> /tmp/tmp580sel23.rs:15:42\n   |\n15 |         base_str += base_str.len()\
    \ > 2 ? base - base_str.len() + 1 : base;\n   |                              \
    \            ^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nwarning:\
    \ unused imports: `Display`, `Formatter`\n  --> /tmp/tmp580sel23.rs:11:20\n  \
    \ |\n11 |     use std::fmt::{Display, Formatter};\n   |                    ^^^^^^^\
    \  ^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    for i in 0..base.pow(x.as_u128() %\
    \ base.pow(base).unwrap()) {\n        if i > 0 {\n            res.insert(0, ('0'\
    \ + i));\n        } else {\n            res.insert(0, i.to_string());\n      \
    \  }\n    }\n    res\n}\n\nfn main() {\n    let candidate = change_base;\n   \
    \ assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpcfntzn6l.rs:14:27\n\
    \   |\n14 |             res.insert(0, ('0' + i));\n   |                      \
    \     ^       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n14 -             res.insert(0, ('0' + i));\n\
    14 +             res.insert(0, '0' + i);\n   | \n\nerror[E0599]: no method named\
    \ `as_u128` found for type `isize` in the current scope\n  --> /tmp/tmpcfntzn6l.rs:12:28\n\
    \   |\n12 |     for i in 0..base.pow(x.as_u128() % base.pow(base).unwrap()) {\n\
    \   |                            ^^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcfntzn6l.rs:12:49\n   |\n12 |     for i in 0..base.pow(x.as_u128()\
    \ % base.pow(base).unwrap()) {\n   |                                         \
    \        ^^^^ expected `u32`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `u32` and panic if the converted value doesn't fit\n   |\n12 |     for\
    \ i in 0..base.pow(x.as_u128() % base.pow(base.try_into().unwrap()).unwrap())\
    \ {\n   |                                                     ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpcfntzn6l.rs:12:55\n   |\n12 |     for i in 0..base.pow(x.as_u128()\
    \ % base.pow(base).unwrap()) {\n   |                                         \
    \              ^^^^^^ method not found in `isize`\n\nerror[E0369]: cannot add\
    \ `isize` to `char`\n  --> /tmp/tmpcfntzn6l.rs:14:32\n   |\n14 |             res.insert(0,\
    \ ('0' + i));\n   |                            --- ^ - isize\n   |           \
    \                 |\n   |                            char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcfntzn6l.rs:16:27\n   |\n16 |             res.insert(0,\
    \ i.to_string());\n   |                           ^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 5 previous errors; 1 warning\
    \ emitted\n\nSome errors have detailed explanations: E0308, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::with_capacity(x.to_string(base).len());\n    x.to_string_into(base).for_each(|v|\
    \ s.push_str(&v.to_string()));\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpsdxmml0t.rs:11:41\n     |\n11   |     let mut s = String::with_capacity(x.to_string(base).len());\n\
    \     |                                         ^^^^^^^^^ ---- supplied 1 argument\n\
    \     |                                         |\n     |                    \
    \                     expected 0 arguments\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `to_string_into` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpsdxmml0t.rs:12:7\n   |\n12 |   \
    \  x.to_string_into(base).for_each(|v| s.push_str(&v.to_string()));\n   |    \
    \   ^^^^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut string: String = \"\".to_string();\n    let mut numerator = x::to_digits(base);\n\
    \    let mut denominator: isize = 10::to_digits(base);\n\n    numerator.iter().take(numerator.len()\
    \ % base).for_each(|x| {\n        string += &x.to_string();\n    });\n\n    numerator.iter().take(numerator.len()\
    \ / base).for_each(|x| {\n        *string += &x.to_string();\n    });\n\n    denominator\
    \ = numerator.len() / base;\n\n    for d in numerator.iter().take(denominator)\
    \ {\n        string += &d.to_string();\n    }\n\n    string\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `::`\n\
    \  --> /tmp/tmpgzzcgasz.rs:13:36\n   |\n13 |     let mut denominator: isize =\
    \ 10::to_digits(base);\n   |                                    ^^ expected one\
    \ of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `x`\n  --> /tmp/tmpgzzcgasz.rs:12:25\n   |\n\
    12 |     let mut numerator = x::to_digits(base);\n   |                       \
    \  ^ use of undeclared crate or module `x`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    for i in x.digits() {\n        let mut\
    \ b = i / base;\n        let mut e = i as usize / base;\n        if e != 0 {\n\
    \            *b += 1;\n        }\n        s.append(&format!(\"{}\", b));\n   \
    \ }\n    s[s.len() - 1]\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `digits` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpd2trdafk.rs:12:16\n   |\n12 |     for i in x.digits() {\n\
    \   |                ^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd2trdafk.rs:14:34\n   |\n14 |         let mut e = i as\
    \ usize / base;\n   |                                  ^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot divide `usize` by `isize`\n  --> /tmp/tmpd2trdafk.rs:14:32\n\
    \   |\n14 |         let mut e = i as usize / base;\n   |                     \
    \           ^ no implementation for `usize / isize`\n   |\n   = help: the trait\
    \ `Div<isize>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n    \
    \         <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n      \
    \       <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n          \
    \   <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a\
    \ isize as Div<isize>>\n           and 54 others\n\nerror[E0599]: no method named\
    \ `append` found for struct `String` in the current scope\n  --> /tmp/tmpd2trdafk.rs:18:11\n\
    \   |\n18 |         s.append(&format!(\"{}\", b));\n   |           ^^^^^^ method\
    \ not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpd2trdafk.rs:20:5\n   |\n20 |     s[s.len() - 1]\n   |\
    \     ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut counter = 0;\n    while\
    \ counter < x {\n        if let Some(ref b) = bases[base] {\n            result\
    \ += \"0123456789abcdefghijklmnopqrstuvwxyz\".to_chars().nth(b as usize + 1).unwrap();\n\
    \        } else {\n            panic!(\"invalid base number: {}\", base);\n  \
    \      }\n        counter += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `bases` in this scope\n  --> /tmp/tmp3a75pbq7.rs:14:30\n\
    \   |\n14 |         if let Some(ref b) = bases[base] {\n   |                 \
    \             ^^^^^ help: a local variable with a similar name exists: `base`\n\
    \nerror[E0599]: no method named `to_chars` found for reference `&'static str`\
    \ in the current scope\n  --> /tmp/tmp3a75pbq7.rs:15:62\n   |\n15 |          \
    \   result += \"0123456789abcdefghijklmnopqrstuvwxyz\".to_chars().nth(b as usize\
    \ + 1).unwrap();\n   |                                                       \
    \       ^^^^^^^^ help: there is an associated function with a similar name: `chars`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    match x {\n        1 => \"1\",\n        2 => \"10\",\n        3 => \"\
    100\",\n        4 => \"1000\",\n        5 => \"10000\",\n        6 => \"100000\"\
    ,\n        7 => \"1000000\",\n        8 => \"10000000\",\n        _ => String::from_str(&format!(\"\
    {}{}\", x / base, base_digits[base]) * base).unwrap(),\n    }\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `base_digits` in this scope\n  --> /tmp/tmpghzh3m3w.rs:20:58\n\
    \   |\n20 |         _ => String::from_str(&format!(\"{}{}\", x / base, base_digits[base])\
    \ * base).unwrap(),\n   |                                                    \
    \      ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpghzh3m3w.rs:12:14\n   |\n10 | fn change_base(x: isize, base: isize)\
    \ -> String {\n   |                                          ------ expected `String`\
    \ because of return type\n11 |     match x {\n12 |         1 => \"1\",\n   | \
    \             ^^^- help: try using a conversion method: `.to_string()`\n   | \
    \             |\n   |              expected struct `String`, found `&str`\n\n\
    error[E0599]: no function or associated item named `from_str` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpghzh3m3w.rs:20:22\n   |\n20 | \
    \        _ => String::from_str(&format!(\"{}{}\", x / base, base_digits[base])\
    \ * base).unwrap(),\n   |                      ^^^^^^^^ function or associated\
    \ item not found in `String`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::str::FromStr;\n   |\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 2 {\n        panic!(\"Changing base to less than 2 from {:?}\"\
    , base);\n    }\n    if base < 10 {\n        return format!(\"{}\", x as i32 /\
    \ base) as String;\n    }\n    // base is greater than 10\n    let mut x = x as\
    \ i32;\n    let mut x_div = x / base;\n    let mut res = String::new();\n    while\
    \ x_div > 0 {\n        res.push_str(&x_div % base);\n        x_div = x_div / base;\n\
    \    }\n    x.to_string().to_string().pad(base, ' ').push_str(&res);\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp6_r_6t9.rs:15:41\n   |\n\
    15 |         return format!(\"{}\", x as i32 / base) as String;\n   |        \
    \                                 ^^^^ expected `i32`, found `isize`\n\nerror[E0277]:\
    \ cannot divide `i32` by `isize`\n  --> /tmp/tmpp6_r_6t9.rs:15:39\n   |\n15 |\
    \         return format!(\"{}\", x as i32 / base) as String;\n   |           \
    \                            ^ no implementation for `i32 / isize`\n   |\n   =\
    \ help: the trait `Div<isize>` is not implemented for `i32`\n   = help: the following\
    \ other types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n\
    \             <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n  \
    \           <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n      \
    \       <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n            \
    \ <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp6_r_6t9.rs:19:25\n   |\n19 |     let mut x_div = x / base;\n\
    \   |                         ^^^^ expected `i32`, found `isize`\n\nerror[E0277]:\
    \ cannot divide `i32` by `isize`\n  --> /tmp/tmpp6_r_6t9.rs:19:23\n   |\n19 |\
    \     let mut x_div = x / base;\n   |                       ^ no implementation\
    \ for `i32 / isize`\n   |\n   = help: the trait `Div<isize>` is not implemented\
    \ for `i32`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n    \
    \         <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n      \
    \       <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n          \
    \   <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp6_r_6t9.rs:22:31\n\
    \   |\n22 |         res.push_str(&x_div % base);\n   |                       \
    \        ^^^^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp6_r_6t9.rs:22:22\n   |\n22 |         res.push_str(&x_div % base);\n\
    \   |                      ^^^^^^^^^^^^^ expected `&str`, found `i32`\n\nerror[E0277]:\
    \ c"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut base10 = base10.to_string(10);\n    if base == 10 {\n       \
    \ base10.pop();\n    }\n    let mut result = format!(\"{}{}\", x, base10);\n \
    \   if base < 10 {\n        result = result.chars().collect::<String>().reverse().join('');\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: empty character literal\n  --> /tmp/tmpc2knap3k.rs:17:69\n   |\n\
    17 |         result = result.chars().collect::<String>().reverse().join('');\n\
    \   |                                                                     ^ empty\
    \ character literal\n\nerror[E0425]: cannot find value `base10` in this scope\n\
    \  --> /tmp/tmpc2knap3k.rs:11:22\n   |\n11 |     let mut base10 = base10.to_string(10);\n\
    \   |                      ^^^^^^ help: a local variable with a similar name exists:\
    \ `base`\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpc2knap3k.rs:17:53\n   |\n17 |         result\
    \ = result.chars().collect::<String>().reverse().join('');\n   |             \
    \                                        ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::from(\"0\");\n    while x != 0 {\n        let\
    \ remainder = x % base;\n        result += '0' + remainder;\n        x /= base;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `isize` to `char`\n  --> /tmp/tmp2zhuu02f.rs:14:23\n\
    \   |\n14 |         result += '0' + remainder;\n   |                   --- ^ ---------\
    \ isize\n   |                   |\n   |                   char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    x.checked_mul(base).expect(\"invalid number\")\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps5s4q_if.rs:11:5\n   |\n\
    10 | fn change_base(x: isize, base: isize) -> String {\n   |                 \
    \                         ------ expected `String` because of return type\n11\
    \ |     x.checked_mul(base).expect(\"invalid number\")\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if x > base || base < 10 {\n        return format!(\"{}\", x);\n    }\n\
    \n    let mut tmp = x as isize;\n    let mut carry = 0;\n\n    while tmp > 0 {\n\
    \        let tmp = tmp / base;\n        carry = tmp as usize;\n        tmp -=\
    \ carry * base;\n    }\n\n    if carry > 0 {\n        &format!(\"{}{}\", x, base).to_string()\n\
    \    } else {\n        format!(\"{}\", x).to_string()\n    }\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9wim5jex.rs:21:24\n   |\n\
    21 |         tmp -= carry * base;\n   |                        ^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot multiply `usize` by `isize`\n  --> /tmp/tmp9wim5jex.rs:21:22\n\
    \   |\n21 |         tmp -= carry * base;\n   |                      ^ no implementation\
    \ for `usize * isize`\n   |\n   = help: the trait `Mul<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9wim5jex.rs:21:16\n\
    \   |\n21 |         tmp -= carry * base;\n   |                ^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot subtract-assign `usize` from\
    \ `isize`\n  --> /tmp/tmp9wim5jex.rs:21:13\n   |\n21 |         tmp -= carry *\
    \ base;\n   |             ^^ no implementation for `isize -= usize`\n   |\n  \
    \ = help: the trait `SubAssign<usize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `SubAssign<Rhs>`:\n             <f32\
    \ as SubAssign<&f32>>\n             <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n\
    \             <f64 as SubAssign>\n             <i128 as SubAssign<&i128>>\n  \
    \           <i128 as SubAssign>\n             <i16 as SubAssign<&i16>>\n     \
    \        <i16 as SubAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9wim5jex.rs:25:9\n   |\n10 | fn change_base(x: isize, base:\
    \ isize) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n...\n25 |         &format!(\"{}{}\", x, base).to_string()\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&String`\n   |\nhelp: consider removing the borrow\n   |\n25 -      \
    \   &format!(\"{}{}\""
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    res.push_str(x.to_digits(base).collect::<Vec<_>>().to_owned());\n\
    \    res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpsan35hmp.rs:12:20\n   |\n12 |     res.push_str(x.to_digits(base).collect::<Vec<_>>().to_owned());\n\
    \   |                    ^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut x = x as usize;\n    while\
    \ x > base as usize {\n        result.push((x - base as usize) as char);\n   \
    \     x = x / base as usize;\n    }\n    result.push((x - base as usize) as char);\n\
    \    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `usize`\n  --> /tmp/tmp8oqsknu1.rs:14:21\n\
    \   |\n14 |         result.push((x - base as usize) as char);\n   |          \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmp8oqsknu1.rs:14:21\n   |\n14 |         result.push((x\
    \ - base as usize) as char);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0604]: only `u8` can be cast as `char`, not `usize`\n  --> /tmp/tmp8oqsknu1.rs:17:17\n\
    \   |\n17 |     result.push((x - base as usize) as char);\n   |              \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmp8oqsknu1.rs:17:17\n   |\n17 |     result.push((x\
    \ - base as usize) as char);\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0604`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::with_capacity(x.to_string().len() * 2);\n  \
    \  let mut remainder = x;\n    for _ in 0..(base as usize) {\n        match remainder\
    \ % base {\n            0 => result.push_str(&mut format!(\"{}\", remainder /\
    \ base) as String),\n            d | d > base => {\n                result.push_str(&mut\
    \ format!(\"{}{}\", remainder / base, d as char) as String);\n               \
    \ remainder %= base;\n            },\n        };\n    }\n    result.push_str(&mut\
    \ format!(\"{}\", remainder) as String);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `=>`, `@`, `if`, or `|`, found `>`\n  --> /tmp/tmpz7xloxj6.rs:16:19\n\
    \   |\n16 |             d | d > base => {\n   |                   ^ expected one\
    \ of `=>`, `@`, `if`, or `|`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz7xloxj6.rs:15:34\n\
    \   |\n15 |             0 => result.push_str(&mut format!(\"{}\", remainder /\
    \ base) as String),\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                  |\n   |                               \
    \   expected `&str`, found struct `String`\n   |                             \
    \     help: consider borrowing here: `&(&mut format!(\"{}\", remainder / base)\
    \ as String)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz7xloxj6.rs:22:21\n\
    \   |\n22 |     result.push_str(&mut format!(\"{}\", remainder) as String);\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |      \
    \               |\n   |                     expected `&str`, found struct `String`\n\
    \   |                     help: consider borrowing here: `&(&mut format!(\"{}\"\
    , remainder) as String)`\n\nerror[E0605]: non-primitive cast: `&mut String` as\
    \ `String`\n  --> /tmp/tmpz7xloxj6.rs:15:34\n   |\n15 |             0 => result.push_str(&mut\
    \ format!(\"{}\", remainder / base) as String),\n   |                        \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can\
    \ only be used to convert between primitive types or to coerce to a specific trait\
    \ object\n\nerror[E0605]: non-primitive cast: `&mut String` as `String`\n  -->\
    \ /tmp/tmpz7xloxj6.rs:22:21\n   |\n22 |     result.push_str(&mut format!(\"{}\"\
    , remainder) as String);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0605.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    loop {\n        let n = x * base\
    \ % 10;\n        result.push_str(n.to_string());\n        if x == 0 {\n      \
    \      break;\n        }\n        x /= base;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7r8oplkz.rs:14:25\n   |\n\
    14 |         result.push_str(n.to_string());\n   |                         ^^^^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&str`,\
    \ found struct `String`\n   |                         help: consider borrowing\
    \ here: `&n.to_string()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    for i in 0..x {\n        s += (i % base)\
    \ as char;\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqjbvbuz5.rs:13:14\n   |\n\
    13 |         s += (i % base) as char;\n   |              ^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found `char`\n\nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n\
    \  --> /tmp/tmpqjbvbuz5.rs:13:14\n   |\n13 |         s += (i % base) as char;\n\
    \   |              ^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmpqjbvbuz5.rs:13:14\n   |\n13 |         s\
    \ += (i % base) as char;\n   |              ^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0604.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut buf = [0u8; 3];\n    let mut digits = x;\n    let mut new_digits\
    \ = x;\n    let mut base = base - 1;\n    while new_digits > 0 {\n        // Get\
    \ last digit in the right base.\n        let digit = digits;\n        if base\
    \ > 0 {\n            digit = digit / base;\n        }\n\n        // Keep last\
    \ digit and add it to the next digit.\n        digits = (digit % base) + digits;\n\
    \n        // Set last digit to the new base.\n        // If the last digit was\
    \ in base 10 and the new base is 10^k, then the new digit\n        // will be\
    \ k*10^(k-1).\n        let mut k = digits % base;\n        if base == 10 {\n \
    \           if k > 1 {\n                k = k - 1;\n            }\n        } else\
    \ {\n            if k > 2 {\n                k = k - 2;\n            }\n     \
    \   }\n        let digit = k + 10;\n        buf[0] = digit;\n        buf[1] =\
    \ (digits % base) as u8;\n        buf[2] = digit as u8;\n\n        // If last\
    \ digit was in base 10, then multiply by the new base.\n        let last_digit\
    \ = buf[1..2];\n        if base == 10 {\n            new_digits *= base;\n   \
    \     }\n\n        // Divide last digit by new base.\n        new_digits /= base;\n\
    \n        // If last digit was in base 10, then subtract it from the new digits.\n\
    \        if base == 10 {\n            new_digits -= last_digit;\n        }\n \
    \   }\n    String::from_utf8(buf).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr35hfjst.rs:39:18\n   |\n\
    39 |         buf[0] = digit;\n   |         ------   ^^^^^ expected `u8`, found\
    \ `isize`\n   |         |\n   |         expected due to the type of this binding\n\
    \nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation\
    \ time\n  --> /tmp/tmpr35hfjst.rs:44:13\n   |\n44 |         let last_digit = buf[1..2];\n\
    \   |             ^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `[u8]`\n   = note: all local\
    \ variables must have a statically known size\n   = help: unsized locals are gated\
    \ as an unstable feature\nhelp: consider borrowing here\n   |\n44 |         let\
    \ last_digit = &buf[1..2];\n   |                          +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr35hfjst.rs:57:23\n   |\n57 |     String::from_utf8(buf).unwrap()\n\
    \   |                       ^^^- help: try using a conversion method: `.to_vec()`\n\
    \   |                       |\n   |                       expected struct `Vec`,\
    \ found array `[u8; 3]`\n   |\n   = note: expected struct `Vec<u8>`\n        \
    \       found array `[u8; 3]`\n\nerror[E0277]: the size for values of type `[u8]`\
    \ cannot be known at compilation time\n  --> /tmp/tmpr35hfjst.rs:54:24\n   |\n\
    54 |             new_digits -= last_digit;\n   |                        ^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `[u8]`\n\nerror[E0277]: cannot subtract-assign `[u8]` from `isize`\n\
    \  --> /tmp/tmpr35hfjst.rs:54:24\n   |\n54 |             new_digits -= last_digit;\n\
    \   |                        ^^ no implementation for `isize -= [u8]`\n   |\n\
    \   = help: the trait `SubAssign<[u8]>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `SubAssign<Rhs>`:\n             <f32\
    \ as SubAssign<&f32>>\n             <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n\
    \             <f64 as SubAssign>\n             <i128 as SubAssign<&i128>>\n  \
    \           <i128 as SubAssign>\n             <i16 as SubAssign<&i16>>\n     \
    \        <i1"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    use std::cmp::Ordering;\n\n    let x = to_uint(x as isize);\n    let\
    \ base = to_uint(base as isize);\n\n    if base > 10 {\n        panic!(format!(\"\
    Invalid base number for {} value!\", base));\n    }\n\n    if x == 0 {\n     \
    \   return String::new();\n    }\n\n    if x > base {\n        panic!(\"Invalid\
    \ base number!\");\n    }\n\n    let mut num = x;\n    let mut digit = base.clone();\n\
    \n    while num != 0 {\n        digit--;\n        num = num / base;\n    }\n\n\
    \    let mut string = String::new();\n\n    for i in 0..digit {\n        string.push(&format!(\"\
    {:0{}b}\", i).chars().collect::<Vec<_>>().to_string());\n    }\n\n    string +=\
    \ format!(\"{:0{}b}\", num, digit);\n\n    string\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpmuwvaw59.rs:32:16\n\
    \   |\n32 |         digit--;\n   |                ^ expected expression\n\nerror:\
    \ invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpmuwvaw59.rs:39:34\n\
    \   |\n39 |         string.push(&format!(\"{:0{}b}\", i).chars().collect::<Vec<_>>().to_string());\n\
    \   |                               -  ^ expected `}` in format string\n   | \
    \                              |\n   |                               because of\
    \ this opening brace\n   |\n   = note: if you intended to print `{`, you can escape\
    \ it using `{{`\n\nerror: invalid format string: expected `'}'`, found `'{'`\n\
    \  --> /tmp/tmpmuwvaw59.rs:42:27\n   |\n42 |     string += format!(\"{:0{}b}\"\
    , num, digit);\n   |                        -  ^ expected `}` in format string\n\
    \   |                        |\n   |                        because of this opening\
    \ brace\n   |\n   = note: if you intended to print `{`, you can escape it using\
    \ `{{`\n\nerror[E0425]: cannot find function `to_uint` in this scope\n  --> /tmp/tmpmuwvaw59.rs:13:13\n\
    \   |\n13 |     let x = to_uint(x as isize);\n   |             ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `to_uint` in this scope\n\
    \  --> /tmp/tmpmuwvaw59.rs:14:16\n   |\n14 |     let base = to_uint(base as isize);\n\
    \   |                ^^^^^^^ not found in this scope\n\nwarning: unused import:\
    \ `std::cmp::Ordering`\n  --> /tmp/tmpmuwvaw59.rs:11:9\n   |\n11 |     use std::cmp::Ordering;\n\
    \   |         ^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on\
    \ by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmuwvaw59.rs:42:15\n\
    \   |\n42 |     string += format!(\"{:0{}b}\", num, digit);\n   |            \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found struct `String`\n  \
    \ |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 6 previous\
    \ errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut digits = String::new();\n    let mut ten_power = base as isize;\n\
    \    while x > 0 {\n        let mut remaining = x % ten_power;\n        digits.push_str(&format!(\"\
    {}\", remaining));\n        x /= ten_power;\n        ten_power /= base;\n    }\n\
    \    digits\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpepdi7tzr.rs:14:13\n\
    \   |\n14 |         let mut remaining = x % ten_power;\n   |             ----^^^^^^^^^\n\
    \   |             |\n   |             help: remove this `mut`\n   |\n   = note:\
    \ `#[warn(unused_mut)]` on by default\n\nerror[E0384]: cannot assign to immutable\
    \ argument `x`\n  --> /tmp/tmpepdi7tzr.rs:16:9\n   |\n10 | fn change_base(x: isize,\
    \ base: isize) -> String {\n   |                - help: consider making this binding\
    \ mutable: `mut x`\n...\n16 |         x /= ten_power;\n   |         ^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    assert!(base < 10);\n    let mut xs = to_string(x);\n    let mut ans\
    \ = String::new();\n    while xs.len() > 0 {\n        let mut last_digit = xs.chars().nth(-1).unwrap();\n\
    \        let mut digit = 1;\n        let mut carry = 0;\n        while digit <\
    \ base {\n            let digit = last_digit * 10 + digit;\n            ans.push_str(&to_string(digit\
    \ + carry));\n            digit += 1;\n            carry = digit / base;\n   \
    \         digit = digit % base;\n        }\n        if carry > 0 {\n         \
    \   ans.push_str(&to_string(digit + carry));\n        }\n        xs = &xs[..xs.len()\
    \ - 1];\n    }\n    ans\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpfsxxe_v6.rs:12:18\n\
    \   |\n12 |     let mut xs = to_string(x);\n   |                  ^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `to_string` in this\
    \ scope\n  --> /tmp/tmpfsxxe_v6.rs:20:27\n   |\n20 |             ans.push_str(&to_string(digit\
    \ + carry));\n   |                           ^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpfsxxe_v6.rs:26:27\n\
    \   |\n26 |             ans.push_str(&to_string(digit + carry));\n   |       \
    \                    ^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut base10 = base::pow(10).unwrap();\n\
    \n    for i in x.0..(x.0 as usize) {\n        let b = i as usize;\n        let\
    \ n = base10.trunc(b as u64);\n\n        s.push('0' + n);\n        base10 = base10\
    \ / base;\n    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `base`\n\
    \  --> /tmp/tmpvsk0aca1.rs:12:22\n   |\n12 |     let mut base10 = base::pow(10).unwrap();\n\
    \   |                      ^^^^ use of undeclared crate or module `base`\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpvsk0aca1.rs:14:16\n\
    \   |\n14 |     for i in x.0..(x.0 as usize) {\n   |                ^\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpvsk0aca1.rs:14:22\n\
    \   |\n14 |     for i in x.0..(x.0 as usize) {\n   |                      ^\n\n\
    error[E0369]: cannot add `_` to `char`\n  --> /tmp/tmpvsk0aca1.rs:18:20\n   |\n\
    18 |         s.push('0' + n);\n   |                --- ^ - _\n   |           \
    \     |\n   |                char\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0369, E0433, E0610.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    // TODO: Add tests for valid input\n    if base == 10 {\n        let\
    \ mut res = String::new();\n        for x in 0..x {\n            res.push_str(format!(\"\
    {:#}\", x as u32));\n        }\n        res\n    } else {\n        let mut res\
    \ = String::new();\n        for x in 0..x {\n            res.push_str(format!(\"\
    {:#}\", x as i64 as u64 / base));\n        }\n        res\n    }\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4hxe3st8.rs:15:26\n   |\n\
    15 |             res.push_str(format!(\"{:#}\", x as u32));\n   |            \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4hxe3st8.rs:21:60\n   |\n21 |             res.push_str(format!(\"\
    {:#}\", x as i64 as u64 / base));\n   |                                      \
    \                      ^^^^ expected `u64`, found `isize`\n\nerror[E0277]: cannot\
    \ divide `u64` by `isize`\n  --> /tmp/tmp4hxe3st8.rs:21:58\n   |\n21 |       \
    \      res.push_str(format!(\"{:#}\", x as i64 as u64 / base));\n   |        \
    \                                                  ^ no implementation for `u64\
    \ / isize`\n   |\n   = help: the trait `Div<isize>` is not implemented for `u64`\n\
    \   = help: the following other types implement trait `Div<Rhs>`:\n          \
    \   <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a\
    \ i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32\
    \ as Div<i32>>\n             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n\
    \             <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4hxe3st8.rs:21:26\n   |\n21 |             res.push_str(format!(\"\
    {:#}\", x as i64 as u64 / base));\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    use std::cmp::Ordering;\n    use std::str::FromStr;\n\n    use biguint::*;\n\
    \n    let mut x = BigUint::parse_bytes(&x, base)\n        .expect(\"cannot parse\
    \ big int\");\n    let y = x.into();\n    x.divmodq(base);\n    let z = x.into();\n\
    \    let y = y.add(&z).divq(base);\n    let y = y.into_bytes();\n    x.copy_bytes(&y);\n\
    \    x.to_string()\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0432]: unresolved import `biguint`\n  --> /tmp/tmpun9j3m71.rs:14:9\n\
    \   |\n14 |     use biguint::*;\n   |         ^^^^^^^ maybe a missing crate `biguint`?\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `BigUint`\n  --> /tmp/tmpun9j3m71.rs:16:17\n\
    \   |\n16 |     let mut x = BigUint::parse_bytes(&x, base)\n   |             \
    \    ^^^^^^^ use of undeclared type `BigUint`\n\nwarning: unused import: `std::cmp::Ordering`\n\
    \  --> /tmp/tmpun9j3m71.rs:11:9\n   |\n11 |     use std::cmp::Ordering;\n   |\
    \         ^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by\
    \ default\n\nwarning: unused import: `std::str::FromStr`\n  --> /tmp/tmpun9j3m71.rs:12:9\n\
    \   |\n12 |     use std::str::FromStr;\n   |         ^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed\
    \ explanations: E0432, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0432`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res: Vec<String> = vec![];\n    while x != 0 {\n        let mut\
    \ div = x % base;\n        res.push(div.to_string());\n        x /= base;\n  \
    \  }\n    if res.len() == 0 {\n        res.push(\"\".to_string());\n    }\n  \
    \  res.reverse();\n    format!(\"{}\", res.join(\"\"))\n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpeogetlbj.rs:13:13\n\
    \   |\n13 |         let mut div = x % base;\n   |             ----^^^\n   |  \
    \           |\n   |             help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `x`\n  -->\
    \ /tmp/tmpeogetlbj.rs:15:9\n   |\n10 | fn change_base(x: isize, base: isize) ->\
    \ String {\n   |                - help: consider making this binding mutable:\
    \ `mut x`\n...\n15 |         x /= base;\n   |         ^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut num = x % base;\n    let mut out = [0u8; base.pow3()];\n    while\
    \ num > 0 {\n        out.push(num % base);\n        num /= base;\n    }\n    out.reverse();\n\
    \    let mut s = String::new();\n    for i in out {\n        s.push(i.to_string());\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmp4fbtnyvg.rs:12:25\n   |\n10 | fn change_base(x: isize, base: isize)\
    \ -> String {\n   |                          ---- this would need to be a `const`\n\
    11 |     let mut num = x % base;\n12 |     let mut out = [0u8; base.pow3()];\n\
    \   |                         ^^^^\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0435`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    while x != 0 {\n        let digit =\
    \ x % base;\n        res.push_str(&digit.to_string());\n        x /= base;\n \
    \   }\n    if res == \"\" {\n        res.push_str(\"0\");\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpcy3egt5y.rs:15:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n15 |      \
    \   x /= base;\n   |         ^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::with_capacity(2 * base);\n    let mut num: isize\
    \ = x;\n    for _ in 0..base {\n        res.push_str(num.to_string());\n     \
    \   num /= base;\n    }\n    res.push_str(num.to_string());\n    res\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2qi0twg0.rs:11:41\n   |\n\
    11 |     let mut res = String::with_capacity(2 * base);\n   |                \
    \                         ^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n11 |     let mut res = String::with_capacity((2 * base).try_into().unwrap());\n\
    \   |                                         +        +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2qi0twg0.rs:14:22\n   |\n14 |\
    \         res.push_str(num.to_string());\n   |                      ^^^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&str`, found\
    \ struct `String`\n   |                      help: consider borrowing here: `&num.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2qi0twg0.rs:17:18\n   |\n17 |\
    \     res.push_str(num.to_string());\n   |                  ^^^^^^^^^^^^^^^\n\
    \   |                  |\n   |                  expected `&str`, found struct\
    \ `String`\n   |                  help: consider borrowing here: `&num.to_string()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut v = x.to_string();\n    let mut digits: Vec<usize> = v.chars().map(|c|\
    \ c as usize).collect();\n    let mut new_base: isize = 1;\n    let mut quotient:\
    \ isize = 0;\n    let mut remainder: isize = 0;\n    while quotient < 10 {\n \
    \       let new_digit = (digits.last() + remainder) % 10;\n        remainder =\
    \ digits.last() + new_digit;\n        digits.last_mut().unwrap() = new_digit;\n\
    \        quotient += 1;\n    }\n    if remainder > 0 {\n        let new_digit\
    \ = (digits.last() + remainder) % 10;\n        digits.last_mut().unwrap() = new_digit;\n\
    \        quotient += 1;\n    }\n    if quotient > base {\n        while quotient\
    \ > base {\n            let remainder = digits.last().unwrap() % base;\n     \
    \       digits.last_mut().unwrap() = remainder;\n            quotient -= 1;\n\
    \        }\n        digits.last_mut().unwrap() = (digits.last().unwrap() + quotient)\
    \ % base;\n    }\n    digits.iter().map(|c| char::from_u32(*c)).collect()\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `isize` to `Option<&usize>`\n  --> /tmp/tmpliurdngs.rs:17:40\n\
    \   |\n17 |         let new_digit = (digits.last() + remainder) % 10;\n   |  \
    \                        ------------- ^ --------- isize\n   |               \
    \           |\n   |                          Option<&usize>\n\nerror[E0369]: cannot\
    \ add `_` to `Option<&usize>`\n  --> /tmp/tmpliurdngs.rs:18:35\n   |\n18 |   \
    \      remainder = digits.last() + new_digit;\n   |                     -------------\
    \ ^ --------- _\n   |                     |\n   |                     Option<&usize>\n\
    \nerror[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmpliurdngs.rs:19:36\n\
    \   |\n19 |         digits.last_mut().unwrap() = new_digit;\n   |         --------------------------\
    \ ^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0369]:\
    \ cannot add `isize` to `Option<&usize>`\n  --> /tmp/tmpliurdngs.rs:23:40\n  \
    \ |\n23 |         let new_digit = (digits.last() + remainder) % 10;\n   |    \
    \                      ------------- ^ --------- isize\n   |                 \
    \         |\n   |                          Option<&usize>\n\nerror[E0070]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpliurdngs.rs:24:36\n   |\n24 |  \
    \       digits.last_mut().unwrap() = new_digit;\n   |         --------------------------\
    \ ^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpliurdngs.rs:29:54\n   |\n29 |             let\
    \ remainder = digits.last().unwrap() % base;\n   |                           \
    \                           ^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot mod `&usize` by `isize`\n  --> /tmp/tmpliurdngs.rs:29:52\n   |\n29 |\
    \             let remainder = digits.last().unwrap() % base;\n   |           \
    \                                         ^ no implementation for `&usize % isize`\n\
    \   |\n   = help: the trait `Rem<isize>` is not implemented for `&usize`\n   =\
    \ help: the following other types implement trait `Rem<Rhs>`:\n             <&'a\
    \ f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128\
    \ as Rem<i128>>"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut string: String = \"\".to_string();\n    for i in x.checked_mul(base.checked_div(10).unwrap()).unwrap().checked_digits(base)\
    \ {\n        string = format!(\"{}{}\", string, i);\n    }\n    string\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `checked_digits` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpkte2935t.rs:12:68\n   |\n12 |     for i in\
    \ x.checked_mul(base.checked_div(10).unwrap()).unwrap().checked_digits(base) {\n\
    \   |                                                                    ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `checked_div`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    format!(\"{}\", x / base)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"2\"`,\n right: `\"22\"`', /tmp/tmpi_eorm36.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if x >= base {\n        unimplemented!()\n    }\n\n    if base == 10\
    \ {\n        format!(\"{}\", x)\n    } else {\n        let mut v = x;\n      \
    \  let mut base = base;\n        let mut i = 1;\n\n        while v % base != 0\
    \ {\n            v /= base;\n            i += 1;\n        }\n\n        format!(\"\
    {}{}\", i, change_base(v as usize, base))\n    }\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiis3tua1.rs:27:40\n   |\n\
    27 |         format!(\"{}{}\", i, change_base(v as usize, base))\n   |       \
    \                                 ^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n27 |         format!(\"{}{}\", i, change_base((v as\
    \ usize).try_into().unwrap(), base))\n   |                                   \
    \     +          +++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut n = 0;\n    while n > 0 {\n \
    \       let rem = x % base;\n        if rem < 10 {\n            s.push(rem.to_string());\n\
    \        } else {\n            s.push((rem / 10 + 1).to_string());\n        }\n\
    \        x = x / base;\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpakmda1hl.rs:16:20\n   |\n\
    16 |             s.push(rem.to_string());\n   |                    ^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpakmda1hl.rs:18:20\n   |\n18 |             s.push((rem / 10 + 1).to_string());\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut exp = base;\n    while exp >\
    \ 0 {\n        // shift right the given number by exp\n        let mut x = x >>\
    \ exp;\n        // convert the given number into string\n        match x {\n \
    \           0 => s.push_str(\"0\"),\n            _ => s.push_str(char::from_u32(x)?),\n\
    \        }\n        // decrement the given number\n        exp = exp >> 1;\n \
    \   }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3ue4cd38.rs:19:44\n   |\n\
    19 |             _ => s.push_str(char::from_u32(x)?),\n   |                  \
    \                          ^ expected `u32`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `u32` and panic if the converted value doesn't fit\n\
    \   |\n19 |             _ => s.push_str(char::from_u32(x.try_into().unwrap())?),\n\
    \   |                                             ++++++++++++++++++++\n\nerror[E0308]:\
    \ `?` operator has incompatible types\n  --> /tmp/tmp3ue4cd38.rs:19:29\n   |\n\
    19 |             _ => s.push_str(char::from_u32(x)?),\n   |                  \
    \           ^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n   |\n   = note:\
    \ `?` operator cannot convert from `char` to `&str`\n\nerror[E0277]: the `?` operator\
    \ can only be used in a function that returns `Result` or `Option` (or another\
    \ type that implements `FromResidual`)\n  --> /tmp/tmp3ue4cd38.rs:19:46\n   |\n\
    10 | / fn change_base(x: isize, base: isize) -> String {\n11 | |     let mut s\
    \ = String::new();\n12 | |     let mut exp = base;\n13 | |     while exp > 0 {\n\
    ...  |\n19 | |             _ => s.push_str(char::from_u32(x)?),\n   | |      \
    \                                        ^ cannot use the `?` operator in a function\
    \ that returns `String`\n...  |\n24 | |     s\n25 | | }\n   | |_- this function\
    \ should return `Result` or `Option` to accept `?`\n   |\n   = help: the trait\
    \ `FromResidual<Option<Infallible>>` is not implemented for `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::from(\"0\");\n    fn inc(x: isize) -> isize {\n\
    \        let mut i = 0;\n        let mut y = x;\n        while y < 10 {\n    \
    \        i += 1;\n            y = y * base + x;\n        }\n        y\n    }\n\
    \    if x > base {\n        for i in 0..((x + base) / base) {\n            res.push_str(&i.to_string());\n\
    \        }\n        for i in (x - base..x).rev() {\n            res.push_str(&i.to_string());\n\
    \        }\n    } else {\n        res.push_str(&x.to_string());\n    }\n    res.push_str(&base);\n\
    \    res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmp5fmzq6hv.rs:17:21\n\
    \   |\n17 |             y = y * base + x;\n   |                     ^^^^\n   |\n\
    \   = help: use the `|| { ... }` closure form instead\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5fmzq6hv.rs:31:18\n   |\n31 |     res.push_str(&base);\n\
    \   |                  ^^^^^ expected `str`, found `isize`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0434.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = x.to_digits();\n\
    \    let mut base = base.to_digits();\n    for &d in &digits {\n        result.append(format!(\"\
    {}\", base[&d as usize]));\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpj9chul5v.rs:12:24\n   |\n12 |     let mut digits\
    \ = x.to_digits();\n   |                        ^^^^^^^^^ method not found in\
    \ `isize`\n\nerror[E0599]: no method named `to_digits` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpj9chul5v.rs:13:25\n   |\n13 |     let mut\
    \ base = base.to_digits();\n   |                         ^^^^^^^^^ method not\
    \ found in `isize`\n\nerror[E0599]: no method named `append` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpj9chul5v.rs:15:16\n   |\n15 | \
    \        result.append(format!(\"{}\", base[&d as usize]));\n   |            \
    \    ^^^^^^ method not found in `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut digits = Vec::new();\n\n    while x != 0 {\n        let remainder\
    \ = x % base;\n        digits.push(base);\n        x = x / base;\n    }\n\n  \
    \  digits.reverse();\n    digits.join(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: the method `join` exists for struct `Vec<isize>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmpy6aoktjs.rs:20:12\n   |\n20 |\
    \     digits.join(\"\")\n   |            ^^^^ method cannot be called on `Vec<isize>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `[isize]: Join<_>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut x: isize = x.into();\n    let mut base: isize = base.into();\n\
    \    let mut y: String = \"\";\n    let mut pow: isize = base;\n    while x >=\
    \ 10 {\n        x = x / 10;\n        base = base - 1;\n        pow = pow * 10;\n\
    \    }\n    y += to_digit(x as u8) * pow;\n    if base > 0 {\n        y += to_digit(base\
    \ as u8) * pow;\n    }\n    y\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_digit` in this scope\n  --> /tmp/tmprcd2wh3c.rs:20:10\n\
    \   |\n20 |     y += to_digit(x as u8) * pow;\n   |          ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `to_digit` in this scope\n\
    \  --> /tmp/tmprcd2wh3c.rs:22:14\n   |\n22 |         y += to_digit(base as u8)\
    \ * pow;\n   |              ^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprcd2wh3c.rs:13:25\n   |\n13 |     let mut y:\
    \ String = \"\";\n   |                ------   ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |        |\n   |               \
    \ |        expected struct `String`, found `&str`\n   |                expected\
    \ due to this\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result: String = \"\".to_string();\n    let mut digits = x.to_string();\n\
    \    while digits.len() > base {\n        digits = &digits[..base];\n        result\
    \ += '0'.repeat(base - digits.len());\n    }\n    result += digits;\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpybxsein4.rs:13:26\n   |\n\
    13 |     while digits.len() > base {\n   |                          ^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n13 |     while digits.len()\
    \ > base.try_into().unwrap() {\n   |                              ++++++++++++++++++++\n\
    \nerror[E0277]: the type `String` cannot be indexed by `RangeTo<isize>`\n  -->\
    \ /tmp/tmpybxsein4.rs:14:19\n   |\n14 |         digits = &digits[..base];\n  \
    \ |                   ^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<isize>`\n\
    \   |\n   = help: the trait `Index<RangeTo<isize>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpybxsein4.rs:14:18\n\
    \   |\n12 |     let mut digits = x.to_string();\n   |                      -------------\
    \ expected due to this value\n13 |     while digits.len() > base {\n14 |     \
    \    digits = &digits[..base];\n   |                  ^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found reference\n   |\n   = note: expected struct `String`\n\
    \           found reference `&_`\nhelp: consider removing the borrow\n   |\n14\
    \ -         digits = &digits[..base];\n14 +         digits = digits[..base];\n\
    \   | \n\nerror[E0599]: no method named `repeat` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpybxsein4.rs:15:23\n   |\n15 |         result +=\
    \ '0'.repeat(base - digits.len());\n   |                       ^^^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpybxsein4.rs:15:37\n\
    \   |\n15 |         result += '0'.repeat(base - digits.len());\n   |         \
    \                            ^^^^^^^^^^^^ exp"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    while x >= base {\n        res.append(x%base);\n\
    \        x = x/base;\n    }\n    res.reverse();\n    res.push_str(&*x);\n    return\
    \ res;\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp76sh5lo8.rs:13:13\n   |\n13 |         res.append(x%base);\n\
    \   |             ^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `reverse` found for struct `String` in the current scope\n  --> /tmp/tmp76sh5lo8.rs:16:9\n\
    \   |\n16 |     res.reverse();\n   |         ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmp76sh5lo8.rs:17:19\n   |\n17 |     res.push_str(&*x);\n\
    \   |                   ^^\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 2 {\n        let mut result = format!(\"{}\", x);\n       \
    \ if base < 10 {\n            while result.len() < base.to_string().len() {\n\
    \                result = &format!(\"0{}\", result);\n            }\n        }\
    \ else {\n            while result.len() > base.to_string().len() {\n        \
    \        result = &result[..(base.to_string().len() - 1)] + \"0\";\n         \
    \   }\n        }\n        result\n    } else {\n        let mut result = x.to_string();\n\
    \        if base < 10 {\n            if base == 2 {\n                while result.len()\
    \ > 2 {\n                    result = &result[2..] + \"0\";\n                }\n\
    \            } else {\n                while result.len() > base.to_string().len()\
    \ {\n                    result = &result[..(base.to_string().len() - 1)] + \"\
    0\";\n                }\n            }\n        } else {\n            if base\
    \ == 2 {\n                while result.len() > 2 {\n                    result\
    \ = &result[2..] + \"0\";\n                }\n            } else {\n         \
    \       while result.len() > base.to_string().len() {\n                    result\
    \ = &result[..(base.to_string().len() - 1)] + \"0\";\n                }\n    \
    \        }\n        }\n        result\n    }\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt3z891vw.rs:15:26\n   |\n\
    12 |         let mut result = format!(\"{}\", x);\n   |             ----------\
    \   ---------------- expected due to this value\n   |             |\n   |    \
    \         expected due to the type of this binding\n...\n15 |                \
    \ result = &format!(\"0{}\", result);\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\nhelp: consider removing the\
    \ borrow\n   |\n15 -                 result = &format!(\"0{}\", result);\n15 +\
    \                 result = format!(\"0{}\", result);\n   | \n\nerror[E0369]: cannot\
    \ add `&str` to `&str`\n  --> /tmp/tmpt3z891vw.rs:19:66\n   |\n19 |          \
    \       result = &result[..(base.to_string().len() - 1)] + \"0\";\n   |      \
    \                    --------------------------------------- ^ --- &str\n   |\
    \                          |                                       |\n   |   \
    \                       |                                       `+` cannot be\
    \ used to concatenate two `&str` strings\n   |                          &str\n\
    \   |\n   = note: string concatenation requires an owned `String` on the left\n\
    help: remove the borrow to obtain an owned `String`\n   |\n19 -              \
    \   result = &result[..(base.to_string().len() - 1)] + \"0\";\n19 +          \
    \       result = result[..(base.to_string().len() - 1)] + \"0\";\n   | \n\nerror[E0369]:\
    \ cannot add `&str` to `&str`\n  --> /tmp/tmpt3z891vw.rs:28:43\n   |\n28 |   \
    \                  result = &result[2..] + \"0\";\n   |                      \
    \        ------------ ^ --- &str\n   |                              |        \
    \    |\n   |                              |            `+` cannot be used to concatenate\
    \ two `&str` strings\n   |                              &str\n   |\n   = note:\
    \ string concatenation requires an owned `String` on the left\nhelp: remove the\
    \ borrow to obtain an owned `String`\n   |\n28 -                     result =\
    \ &result[2..] + \"0\";\n28 +                     result = result[2..] + \"0\"\
    ;\n   | \n\nerror[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmpt3z891vw.rs:32:70\n\
    \   |\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    for digit in x.to_string().chars() {\n\
    \        let d = digit as char;\n        if base == 10 {\n            if d ==\
    \ '0';\n            else if d == '1';\n            else {\n                s.push_str(&d);\n\
    \                continue;\n            }\n        }\n        let base = digit_to_base_digit(digit,\
    \ base);\n        let mut new = s.clone();\n        if base != 1 {\n         \
    \   new.push_str(&base.to_string());\n        }\n        new.push_str(&d);\n \
    \       s = new;\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `;`\n  --> /tmp/tmp9jagtufy.rs:15:24\n   |\n\
    15 |             if d == '0';\n   |             --         ^ expected `{`\n  \
    \ |             |\n   |             this `if` expression has a condition, but\
    \ no block\n\nerror[E0425]: cannot find function `digit_to_base_digit` in this\
    \ scope\n  --> /tmp/tmp9jagtufy.rs:22:20\n   |\n22 |         let base = digit_to_base_digit(digit,\
    \ base);\n   |                    ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9jagtufy.rs:27:22\n   |\n27 |\
    \         new.push_str(&d);\n   |                      ^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    format!(\"{:0{}b}\", x, base)\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpnzx4z68q.rs:11:17\n\
    \   |\n11 |     format!(\"{:0{}b}\", x, base)\n   |              -  ^ expected\
    \ `}` in format string\n   |              |\n   |              because of this\
    \ opening brace\n   |\n   = note: if you intended to print `{`, you can escape\
    \ it using `{{`\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 2 {\n        if base < 10 {\n            let mut s = format!(\"\
    {}\", x);\n            s = s.parse::<usize>().unwrap();\n            format!(\"\
    {}\", s * base)\n        } else {\n            format!(\"{}\", x * base)\n   \
    \     }\n    } else {\n        String::from(\"0\") // base < 2\n    }\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptf51n5z5.rs:14:17\n   |\n\
    13 |             let mut s = format!(\"{}\", x);\n   |                 ----- \
    \  ---------------- expected due to this value\n   |                 |\n   | \
    \                expected due to the type of this binding\n14 |             s\
    \ = s.parse::<usize>().unwrap();\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                 |\n\
    \   |                 expected struct `String`, found `usize`\n\nerror[E0369]:\
    \ cannot multiply `String` by `isize`\n  --> /tmp/tmptf51n5z5.rs:15:29\n   |\n\
    15 |             format!(\"{}\", s * base)\n   |                           - ^\
    \ ---- isize\n   |                           |\n   |                         \
    \  String\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::with_capacity(x as usize * base);\n    for i in\
    \ 0..x {\n        let mut s = String::new();\n        for j in 0..base {\n   \
    \         if i == 0 {\n                s.push('0');\n            }\n         \
    \   s.push('1');\n        }\n        res.push_str(&s);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp76i5hvp.rs:11:54\n   |\n\
    11 |     let mut res = String::with_capacity(x as usize * base);\n   |       \
    \                                               ^^^^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot multiply `usize` by `isize`\n  --> /tmp/tmpp76i5hvp.rs:11:41\n\
    \   |\n11 |     let mut res = String::with_capacity(x as usize * base);\n   |\
    \                   --------------------- ^^^^^^^^^^^^^^^^^ no implementation\
    \ for `usize * isize`\n   |                   |\n   |                   required\
    \ by a bound introduced by this call\n   |\n   = help: the trait `Mul<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 10 {\n        String::from(format!(\"{}\", x / base))\n   \
    \ } else {\n        let mut ret: Vec<u8> = vec![0; base];\n        let mut quotient\
    \ = x;\n        let mut counter = 0;\n        while counter < base.len() {\n \
    \           quotient = quotient / base;\n            for b in &mut ret[counter..].iter_mut()\
    \ {\n                if quotient < 0 {\n                    *b = (quotient % base)\
    \ as u8;\n                } else {\n                    *b = quotient % base as\
    \ u8;\n                }\n            }\n            counter = counter + 1;\n\
    \        }\n        String::from_utf8(ret).unwrap()\n    }\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpal4gtj9w.rs:14:40\n   |\n\
    14 |         let mut ret: Vec<u8> = vec![0; base];\n   |                     \
    \                   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n14 |         let mut ret: Vec<u8> = vec![0; base.try_into().unwrap()];\n\
    \   |                                            ++++++++++++++++++++\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmpal4gtj9w.rs:17:30\n\
    \   |\n17 |         while counter < base.len() {\n   |                       \
    \       ^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpal4gtj9w.rs:23:37\n   |\n23 |                     *b = quotient % base\
    \ as u8;\n   |                                     ^^^^^^^^^^ expected `isize`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpal4gtj9w.rs:23:26\n\
    \   |\n23 |                     *b = quotient % base as u8;\n   |            \
    \         --   ^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found `isize`\n   |      \
    \               |\n   |                     expected due to the type of this binding\n\
    \nerror[E0277]: cannot mod `isize` by `u8`\n  --> /tmp/tmpal4gtj9w.rs:23:35\n\
    \   |\n23 |                     *b = quotient % base as u8;\n   |            \
    \                       ^ no implementation for `isize % u8`\n   |\n   = help:\
    \ the trait `Rem<u8>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base == 1 {\n        return format!(\"{:b}\", x);\n    }\n    let\
    \ mut num = x;\n    let mut remain = base;\n    let mut result = String::new();\n\
    \    while remain > 0 {\n        let quotient = num % base;\n        remain =\
    \ remain - base;\n        result = format!(\"{}{}\", result, (quotient as char).to_string());\n\
    \        num = num / base;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpnm3459bs.rs:20:42\n\
    \   |\n20 |         result = format!(\"{}{}\", result, (quotient as char).to_string());\n\
    \   |                                          ^^^^^^^^^^^^^^^^^^ invalid cast\n\
    \   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpnm3459bs.rs:20:42\n\
    \   |\n20 |         result = format!(\"{}{}\", result, (quotient as char).to_string());\n\
    \   |                                          ^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0604`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    x.to_digits(base, 10).to_string()\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpgzkm8pne.rs:11:7\n   |\n11 |     x.to_digits(base,\
    \ 10).to_string()\n   |       ^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 10 {\n        return format!(\"{}\", x);\n    }\n    let mut\
    \ result: String = \"\";\n    let mut digits = [0; base];\n    for &digit in x.to_digits().iter()\
    \ {\n        let mut digit = *digit - '0'; // digit := digit - '0'\n        if\
    \ digit < 0 {\n            digit += base;\n        }\n        digits[digits.len()\
    \ - 1 + digit] |= 1 << (digit as usize);\n    }\n    for i in (0..digits.len()\
    \ - 1).rev() {\n        result += format!(\"{}\", digits[i]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmp_hvwoqhv.rs:15:26\n   |\n10 | fn change_base(x: isize, base: isize)\
    \ -> String {\n   |                          ---- this would need to be a `const`\n\
    ...\n15 |     let mut digits = [0; base];\n   |                          ^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_hvwoqhv.rs:14:30\n   |\n14 |\
    \     let mut result: String = \"\";\n   |                     ------   ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                     |  \
    \      |\n   |                     |        expected struct `String`, found `&str`\n\
    \   |                     expected due to this\n\nerror[E0599]: no method named\
    \ `to_digits` found for type `isize` in the current scope\n  --> /tmp/tmp_hvwoqhv.rs:16:21\n\
    \   |\n16 |     for &digit in x.to_digits().iter() {\n   |                   \
    \  ^^^^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp_hvwoqhv.rs:24:19\n   |\n24 |         result += format!(\"{}\",\
    \ digits[i]);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found struct `String`\n   |\n   = note: this error originates in the macro `format`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0435,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    x.to_string().parse::<isize>().unwrap().pow(base).to_string()\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpie987gmv.rs:11:49\n   |\n\
    11 |     x.to_string().parse::<isize>().unwrap().pow(base).to_string()\n   | \
    \                                                ^^^^ expected `u32`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `u32` and panic if the converted\
    \ value doesn't fit\n   |\n11 |     x.to_string().parse::<isize>().unwrap().pow(base.try_into().unwrap()).to_string()\n\
    \   |                                                     ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    for i in 0..x {\n        let base =\
    \ itoa(base);\n        let x = itoa(i);\n        res += x.split_ascii_lowercase().filter(|c|\
    \ c != 'a').join();\n        res += base.split_ascii_lowercase().filter(|c| c\
    \ != 'a').join();\n    }\n    res\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `itoa` in this scope\n  --> /tmp/tmp4q3f4g7g.rs:13:20\n\
    \   |\n13 |         let base = itoa(base);\n   |                    ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `itoa` in this scope\n \
    \ --> /tmp/tmp4q3f4g7g.rs:14:17\n   |\n14 |         let x = itoa(i);\n   |   \
    \              ^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut buffer = String::new();\n    let mut remainder = 0;\n    buffer.push_str(&to_string(x\
    \ / base));\n\n    while x % base > 0 {\n        buffer.push('_');\n        x\
    \ %= base;\n        remainder += 1;\n    }\n    buffer.push('_');\n    buffer.push_str(&to_string(remainder));\n\
    \    buffer\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpopx8dmfq.rs:13:22\n\
    \   |\n13 |     buffer.push_str(&to_string(x / base));\n   |                 \
    \     ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `to_string` in this scope\n  --> /tmp/tmpopx8dmfq.rs:21:22\n   |\n21 |     buffer.push_str(&to_string(remainder));\n\
    \   |                      ^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = \"0\";\n    while x > 0 {\n        if x % base == 0 {\n\
    \            res.insert(0, base.to_string());\n            x /= base;\n      \
    \  }\n        else {\n            res.insert(0, x.to_string());\n            break;\n\
    \        }\n    }\n    res.trim_end();\n    res\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `insert` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpde5jeppd.rs:14:17\n   |\n14 |             res.insert(0,\
    \ base.to_string());\n   |                 ^^^^^^ method not found in `&str`\n\
    \nerror[E0599]: no method named `insert` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmpde5jeppd.rs:18:17\n   |\n18 |             res.insert(0,\
    \ x.to_string());\n   |                 ^^^^^^ method not found in `&str`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpde5jeppd.rs:23:5\n   |\n10 | fn\
    \ change_base(x: isize, base: isize) -> String {\n   |                       \
    \                   ------ expected `String` because of return type\n...\n23 |\
    \     res\n   |     ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result: String = String::new();\n    let mut digits: Vec<isize>\
    \ = vec![0; base + 1];\n    let mut remainder: isize = 0;\n    while let Some(digit)\
    \ = x.to_digit(base) {\n        remainder += digit;\n        digits.insert((base\
    \ - remainder) as usize, digit);\n    }\n    for i in 0..digits.len() {\n    \
    \    let digit = digits[i];\n        if i < digits.len() - 1 {\n            result.push_str(&format!(\"\
    {:0{}}\", digit, i));\n        } else {\n            result.push_str(&format!(\"\
    {}\", digit));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpv56z_155.rs:21:42\n\
    \   |\n21 |             result.push_str(&format!(\"{:0{}}\", digit, i));\n   |\
    \                                       -  ^ expected `}` in format string\n \
    \  |                                       |\n   |                           \
    \            because of this opening brace\n   |\n   = note: if you intended to\
    \ print `{`, you can escape it using `{{`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv56z_155.rs:12:42\n   |\n12 |     let mut digits: Vec<isize> =\
    \ vec![0; base + 1];\n   |                                          ^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n12 |     let mut digits:\
    \ Vec<isize> = vec![0; (base + 1).try_into().unwrap()];\n   |                \
    \                          +        +++++++++++++++++++++\n\nerror[E0599]: no\
    \ method named `to_digit` found for type `isize` in the current scope\n  --> /tmp/tmpv56z_155.rs:14:31\n\
    \   |\n14 |     while let Some(digit) = x.to_digit(base) {\n   |             \
    \                  ^^^^^^^^ method not found in `isize`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base == 0 {\n        return String::from(x);\n    }\n\n    let mut\
    \ x = x as u64;\n    let mut base = 10_u32.pow((base as i32).checked_div(10).unwrap());\n\
    \    let mut x = x as u64;\n    loop {\n        let ret = format!(\"{}\", x /\
    \ base);\n        if *ret < '0' || *ret > '9' {\n            break;\n        }\n\
    \        x = x.checked_mul(base).unwrap() as isize;\n        base = base as usize;\n\
    \    }\n    format!(\"{}\", x)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `String: From<isize>` is not satisfied\n\
    \  --> /tmp/tmp2glvs4bp.rs:12:16\n   |\n12 |         return String::from(x);\n\
    \   |                ^^^^^^^^^^^^ the trait `From<isize>` is not implemented for\
    \ `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2glvs4bp.rs:16:31\n   |\n16 |\
    \     let mut base = 10_u32.pow((base as i32).checked_div(10).unwrap());\n   |\
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `u32`, found `i32`\n   |\nhelp: you can convert an `i32` to a `u32` and panic\
    \ if the converted value doesn't fit\n   |\n16 |     let mut base = 10_u32.pow((base\
    \ as i32).checked_div(10).unwrap().try_into().unwrap());\n   |               \
    \                                                      ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2glvs4bp.rs:19:37\n   |\n19 |  \
    \       let ret = format!(\"{}\", x / base);\n   |                           \
    \          ^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot divide `u64`\
    \ by `u32`\n  --> /tmp/tmp2glvs4bp.rs:19:35\n   |\n19 |         let ret = format!(\"\
    {}\", x / base);\n   |                                   ^ no implementation for\
    \ `u64 / u32`\n   |\n   = help: the trait `Div<u32>` is not implemented for `u64`\n\
    \   = help: the following other types implement trait `Div<Rhs>`:\n          \
    \   <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a\
    \ i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32\
    \ as Div<i32>>\n             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n\
    \             <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2glvs4bp.rs:20:19\n   |\n20 |         if *ret\
    \ < '0' || *ret > '9' {\n   |                   ^^^ expe"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    if base < 2 {\n        for i in x.to_digits().unwrap()\
    \ {\n            if base == 10 {\n                s.push(i);\n               \
    \ break;\n            }\n            if i < (base as usize) as usize {\n     \
    \           s.push((*i as char).to_string());\n            } else {\n        \
    \        s.push(format!(\"0{}\", i).to_string());\n            }\n        }\n\
    \    } else {\n        let mut b = base as usize;\n        let mut i = 0;\n  \
    \      for i in x.to_digits().unwrap().rev() {\n            if base == 10 {\n\
    \                s.push(i);\n                break;\n            }\n         \
    \   let mut v = b as usize;\n            v -= i as usize;\n            if v ==\
    \ 0 {\n                s.push((*i as char).to_string());\n            } else {\n\
    \                s.push(format!(\"0{}\", v).to_string());\n            }\n   \
    \         i += 1;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpcm90pxlq.rs:13:20\n   |\n13 |         for i in\
    \ x.to_digits().unwrap() {\n   |                    ^^^^^^^^^ method not found\
    \ in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcm90pxlq.rs:18:20\n\
    \   |\n18 |             if i < (base as usize) as usize {\n   |              \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `usize`\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpcm90pxlq.rs:19:25\n   |\n\
    19 |                 s.push((*i as char).to_string());\n   |                 \
    \        ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcm90pxlq.rs:21:24\n\
    \   |\n21 |                 s.push(format!(\"0{}\", i).to_string());\n   |   \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0599]: no method named `to_digits` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpcm90pxlq.rs:27:20\n   |\n27 |         for\
    \ i in x.to_digits().unwrap().rev() {\n   |                    ^^^^^^^^^ method\
    \ not found in `isize`\n\nerror[E0614]: type `char` cannot be dereferenced\n \
    \ --> /tmp/tmpcm90pxlq.rs:35:25\n   |\n35 |                 s.push((*i as char).to_string());\n\
    \   |                         ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcm90pxlq.rs:37:24\n\
    \   |\n37 |                 s.push(format!(\"0{}\", v).to_string());\n   |   \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmpcm90pxlq.rs:39:13\n   |\n39 |             i +=\
    \ 1;\n   |             -^^^^^\n   |             |\n   |             cannot use\
    \ `+=` on type `char`\n\nerror: aborting due to 8 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0368, E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut y = x.to_digits();\n    let mut z = base;\n    for v in y.iter_mut()\
    \ {\n        *v = *z % 10;\n        z /= 10;\n    }\n    format!(\"{}\", y)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpxyuilcp7.rs:11:19\n   |\n11 |     let mut y = x.to_digits();\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpxyuilcp7.rs:14:14\n   |\n\
    14 |         *v = *z % 10;\n   |              ^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 2 {\n        return format!(\"{}\", x).to_string();\n    }\n\
    \n    let mut out = String::new();\n    let mut digits: Vec<usize> = vec![];\n\
    \    let mut counter = x;\n    let mut i = 0;\n    while counter > 0 {\n     \
    \   let digit = counter % base;\n        digits.push(digit);\n        counter\
    \ /= base;\n        i += 1;\n    }\n    let (sign, digit) = if x < 0 { (-1, 0)\
    \ } else if x == 0 { (0, 1) } else { (1, 0) };\n    out += &digits[digits.len()\
    \ - i - 1].to_string();\n    for digit in digits {\n        out.push('-');\n \
    \       out.push(digit.to_string());\n    }\n    out += &format!(\"{}\", digit);\n\
    \    out.push_str(sign);\n    out\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa5fdkysg.rs:21:21\n   |\n\
    21 |         digits.push(digit);\n   |                     ^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         digits.push(digit.try_into().unwrap());\n\
    \   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa5fdkysg.rs:29:18\n   |\n29 |         out.push(digit.to_string());\n\
    \   |                  ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa5fdkysg.rs:32:18\n   |\n32 |\
    \     out.push_str(sign);\n   |                  ^^^^ expected `&str`, found integer\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 2 {\n        return format!(\"{}\", x);\n    }\n    let mut\
    \ x = x;\n    let mut i = 0;\n    while x <= base * base {\n        i += 1;\n\
    \        x = (x / base).powf(2);\n    }\n    let mut result = x.to_string();\n\
    \    if i == 0 {\n        result = result.to_string();\n    }\n    for i in 1..(i\
    \ - 1).rev() {\n        let mut n = result.to_string();\n        if n[..1] ==\
    \ '0' {\n            n = &n[1..];\n        }\n        let mut n = n.to_string();\n\
    \        if i == 0 {\n            n = '0' + n;\n        } else {\n           \
    \ n = '1' + n;\n        }\n        result = &n[..];\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `powf` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmptxn7xbtt.rs:18:24\n   |\n18 |         x = (x / base).powf(2);\n\
    \   |                        ^^^^ help: there is an associated function with a\
    \ similar name: `pow`\n\nerror[E0689]: can't call method `rev` on ambiguous numeric\
    \ type `{integer}`\n  --> /tmp/tmptxn7xbtt.rs:24:25\n   |\n24 |     for i in 1..(i\
    \ - 1).rev() {\n   |                         ^^^\n\nerror[E0277]: can't compare\
    \ `str` with `char`\n  --> /tmp/tmptxn7xbtt.rs:26:19\n   |\n26 |         if n[..1]\
    \ == '0' {\n   |                   ^^ no implementation for `str == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `str`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptxn7xbtt.rs:27:17\n   |\n25 |         let mut n = result.to_string();\n\
    \   |                     ------------------ expected due to this value\n26 |\
    \         if n[..1] == '0' {\n27 |             n = &n[1..];\n   |            \
    \     ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using a\
    \ conversion method\n   |\n27 |             n = (&n[1..]).to_string();\n   | \
    \                +       +++++++++++++\n\nerror[E0369]: cannot add `String` to\
    \ `char`\n  --> /tmp/tmptxn7xbtt.rs:31:21\n   |\n31 |             n = '0' + n;\n\
    \   |                 --- ^ - String\n   |                 |\n   |           \
    \      char\n\nerror[E0369]: cannot add `String` to `char`\n  --> /tmp/tmptxn7xbtt.rs:33:21\n\
    \   |\n33 |             n = '1' + n;\n   |                 --- ^ - String\n  \
    \ |                 |\n   |                 char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptxn7xbtt.rs:35:18\n   |\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    use std::mem;\n\n    let mut new_base = base;\n    let mut string = \"\
    \".to_string();\n    loop {\n        let rem = x % base;\n        if rem == 0\
    \ {\n            string += &format!(\"{}\", new_base);\n            break;\n \
    \       }\n        new_base += 1;\n        string += &format!(\"{}\", rem);\n\
    \        x = x;\n    }\n    return string;\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::mem`\n  --> /tmp/tmpcbpqft5d.rs:11:9\n  \
    \ |\n11 |     use std::mem;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `x`\n  -->\
    \ /tmp/tmpcbpqft5d.rs:23:9\n   |\n10 | fn change_base(x: isize, base: isize) ->\
    \ String {\n   |                - help: consider making this binding mutable:\
    \ `mut x`\n...\n23 |         x = x;\n   |         ^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    s.push_str(x.to_string());\n    let mut\
    \ base = base.to_string();\n    while base.len() < x.len() {\n        base.push('_');\n\
    \    }\n    while base.len() < s.len() {\n        s.push_str(base.clone());\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ktkgjj8.rs:12:16\n   |\n\
    12 |     s.push_str(x.to_string());\n   |                ^^^^^^^^^^^^^\n   | \
    \               |\n   |                expected `&str`, found struct `String`\n\
    \   |                help: consider borrowing here: `&x.to_string()`\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmp5ktkgjj8.rs:14:26\n\
    \   |\n14 |     while base.len() < x.len() {\n   |                          ^^^\
    \ method not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5ktkgjj8.rs:18:20\n\
    \   |\n18 |         s.push_str(base.clone());\n   |                    ^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&str`, found struct\
    \ `String`\n   |                    help: consider borrowing here: `&base`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    for i in x.to_string().chars().rev()\
    \ {\n        let mut c = i;\n        if base == 2 {\n            c /= base;\n\
    \        }\n        let digit = if c >= 10 && c < 100 {\n            c\n     \
    \   } else {\n            base * c.checked_add(10).unwrap()\n        };\n    \
    \    s.push(cchar::to_string(digit).unwrap());\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cchar`\n\
    \  --> /tmp/tmpyw_s91lj.rs:22:16\n   |\n22 |         s.push(cchar::to_string(digit).unwrap());\n\
    \   |                ^^^^^ use of undeclared crate or module `cchar`\n\nerror[E0368]:\
    \ binary assignment operation `/=` cannot be applied to type `char`\n  --> /tmp/tmpyw_s91lj.rs:15:13\n\
    \   |\n15 |             c /= base;\n   |             -^^^^^^^^\n   |         \
    \    |\n   |             cannot use `/=` on type `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyw_s91lj.rs:17:29\n   |\n17 |         let digit = if c\
    \ >= 10 && c < 100 {\n   |                             ^^ expected `char`, found\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyw_s91lj.rs:17:39\n  \
    \ |\n17 |         let digit = if c >= 10 && c < 100 {\n   |                  \
    \                     ^^^ expected `char`, found `u8`\n\nerror[E0599]: no method\
    \ named `checked_add` found for type `char` in the current scope\n  --> /tmp/tmpyw_s91lj.rs:20:22\n\
    \   |\n20 |             base * c.checked_add(10).unwrap()\n   |              \
    \        ^^^^^^^^^^^ method not found in `char`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0368, E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut num = x.to_string();\n    if num.len() < base.to_string().len()\
    \ {\n        num.resize(base.to_string().len(), '0');\n    }\n    num.swap_to_string(base);\n\
    \    num\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `resize` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpmxqtojat.rs:13:13\n   |\n13 |         num.resize(base.to_string().len(),\
    \ '0');\n   |             ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `swap_to_string` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpmxqtojat.rs:15:9\n   |\n15 |     num.swap_to_string(base);\n  \
    \ |         ^^^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut str = String::new();\n    let mut carry = 0;\n    for &c in str\
    \ {\n        match x {\n            0 => break,\n            n => {\n        \
    \        let mut rem = x.to_digits() + base;\n                let mut i = rem;\n\
    \                let mut b = (rem[0] as usize) as usize;\n                while\
    \ i < base {\n                    if i < base {\n                        i +=\
    \ 1;\n                        rem -= 1;\n                    } else {\n      \
    \                  i += 2;\n                        rem -= 2;\n              \
    \      }\n                    *c = i as char;\n                    b += 1;\n \
    \                   carry = 0;\n                }\n                *c = i as char;\n\
    \                *c = if b < base { base as char } else { 0 };\n            }\n\
    \        }\n    }\n    str\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpbh43pk91.rs:13:15\n\
    \   |\n13 |     for &c in str {\n   |               ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0599]: no method named\
    \ `to_digits` found for type `isize` in the current scope\n  --> /tmp/tmpbh43pk91.rs:17:33\n\
    \   |\n17 |                 let mut rem = x.to_digits() + base;\n   |        \
    \                         ^^^^^^^^^ method not found in `isize`\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpbh43pk91.rs:33:36\n\
    \   |\n33 |                 *c = if b < base { base as char } else { 0 };\n  \
    \ |                                    ^^^^^^^^^^^^ invalid cast\n   |\nhelp:\
    \ try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpbh43pk91.rs:33:36\n\
    \   |\n33 |                 *c = if b < base { base as char } else { 0 };\n  \
    \ |                                    ^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599, E0604.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut i = 0;\n    for digit in x.to_string().chars().filter(|c|\
    \ c >= '0' && c <= '9') {\n        if digit == char::from_u32(*i).unwrap() {\n\
    \            continue;\n        }\n        if digit > char::from_u32(*i).unwrap()\
    \ {\n            i += 1;\n        }\n        else {\n            let digit = char::to_u32(*i).unwrap();\n\
    \            i += 1;\n            s.push_str(&digit % base);\n        }\n    }\n\
    \    if i == x.to_string().len() {\n        String::from(\"\")\n    } else {\n\
    \        s + '0'\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdk0crz7l.rs:13:56\n   |\n\
    13 |     for digit in x.to_string().chars().filter(|c| c >= '0' && c <= '9') {\n\
    \   |                                                        ^^^\n   |       \
    \                                                 |\n   |                    \
    \                                    expected `&char`, found `char`\n   |    \
    \                                                    help: consider borrowing\
    \ here: `&'0'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdk0crz7l.rs:13:68\n\
    \   |\n13 |     for digit in x.to_string().chars().filter(|c| c >= '0' && c <=\
    \ '9') {\n   |                                                               \
    \     ^^^\n   |                                                              \
    \      |\n   |                                                               \
    \     expected `&char`, found `char`\n   |                                   \
    \                                 help: consider borrowing here: `&'9'`\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmpdk0crz7l.rs:14:36\n \
    \  |\n14 |         if digit == char::from_u32(*i).unwrap() {\n   |           \
    \                         ^^\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n\
    \  --> /tmp/tmpdk0crz7l.rs:17:35\n   |\n17 |         if digit > char::from_u32(*i).unwrap()\
    \ {\n   |                                   ^^\n\nerror[E0599]: no function or\
    \ associated item named `to_u32` found for type `char` in the current scope\n\
    \  --> /tmp/tmpdk0crz7l.rs:21:31\n   |\n21 |             let digit = char::to_u32(*i).unwrap();\n\
    \   |                               ^^^^^^\n   |                             \
    \  |\n   |                               function or associated item not found\
    \ in `char`\n   |                               help: there is an associated function\
    \ with a similar name: `from_u32`\n\nerror[E0614]: type `{integer}` cannot be\
    \ dereferenced\n  --> /tmp/tmpdk0crz7l.rs:21:38\n   |\n21 |             let digit\
    \ = char::to_u32(*i).unwrap();\n   |                                      ^^\n\
    \nerror[E0308]: mismatched types\n  --> /t"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 2 {\n        String::from(\"\".to_string())\n    } else {\n\
    \        let mut num: isize = x;\n        let mut result = String::from(\"\".to_string());\n\
    \        while num > 0 {\n            result = (num % base).to_string().append(result);\n\
    \            num /= base;\n        }\n        result\n    }\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpyzfudu32.rs:17:47\n   |\n17 |             result\
    \ = (num % base).to_string().append(result);\n   |                           \
    \                    ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = x.to_digits();\n    s[..base] = s[..base].map(|x| match x\
    \ {\n        0 => \"0\",\n        1 => \"1\",\n        _ => String::from(\"0\"\
    ),\n    });\n    s.to_owned()\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpba322q11.rs:11:19\n   |\n11 |     let mut s = x.to_digits();\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ `match` arms have incompatible types\n  --> /tmp/tmpba322q11.rs:15:14\n   |\n\
    12 |       s[..base] = s[..base].map(|x| match x {\n   |  ___________________________________-\n\
    13 | |         0 => \"0\",\n   | |              --- this is found to be of type\
    \ `&str`\n14 | |         1 => \"1\",\n   | |              --- this is found to\
    \ be of type `&str`\n15 | |         _ => String::from(\"0\"),\n   | |        \
    \      ^^^^^^^^^^^^^^^^^\n   | |              |\n   | |              expected\
    \ `&str`, found struct `String`\n   | |              help: consider borrowing\
    \ here: `&String::from(\"0\")`\n16 | |     });\n   | |_____- `match` arms have\
    \ incompatible types\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut x = x.to_string();\n    let mut base = base.to_string();\n  \
    \  base = format!(\"{}\", base);\n    let mut power = base;\n    let mut ret:\
    \ String;\n    let mut digits: Vec<isize>;\n    loop {\n        power = power.remove(1);\n\
    \        let digit = x.remove(0);\n        if digit < base {\n            break;\n\
    \        }\n        let num = digit - base;\n        ret += num.to_string() +\
    \ power;\n    }\n    ret = ret.remove(0);\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplxiup62c.rs:18:17\n   |\n\
    14 |     let mut power = base;\n   |                     ---- expected due to\
    \ this value\n...\n18 |         power = power.remove(1);\n   |               \
    \  ^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \                 |\n   |                 expected struct `String`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplxiup62c.rs:20:20\n   |\n20 |\
    \         if digit < base {\n   |                    ^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0369]: cannot subtract `String` from `char`\n  -->\
    \ /tmp/tmplxiup62c.rs:23:25\n   |\n23 |         let num = digit - base;\n   |\
    \                   ----- ^ ---- String\n   |                   |\n   |      \
    \             char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplxiup62c.rs:26:11\n\
    \   |\n15 |     let mut ret: String;\n   |                  ------ expected due\
    \ to this type\n...\n26 |     ret = ret.remove(0);\n   |           ^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |           |\n   |\
    \           expected struct `String`, found `char`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    loop {\n        if base < 2 {\n\
    \            result.push('-');\n            base -= 1;\n        }\n        result.push_str(num2str(x\
    \ / base).to_string());\n        if x > 0 {\n            x /= base;\n        }\
    \ else {\n            return result;\n        }\n    }\n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `num2str` in this scope\n  --> /tmp/tmpphpusrhm.rs:17:25\n\
    \   |\n17 |         result.push_str(num2str(x / base).to_string());\n   |    \
    \                     ^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::with_capacity(x);\n    loop {\n        if x >=\
    \ base {\n            res.push_str(&format!(\"{}\", x % base));\n            x\
    \ /= base;\n        } else {\n            res.push_str(&format!(\"{}\", x));\n\
    \            break;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqv_u64f4.rs:11:41\n   |\n\
    11 |     let mut res = String::with_capacity(x);\n   |                       \
    \                  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    11 |     let mut res = String::with_capacity(x.try_into().unwrap());\n   |   \
    \                                       ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 2 {\n        return String::from(\"0\".to_string());\n    }\n\
    \    let mut s = String::from(\"0\".to_string());\n    let mut xdigits = &mut\
    \ s[1..];\n    let mut remain = x;\n    while remain > 0 {\n        let mut digit\
    \ = remain;\n        remain = remain/base;\n        if remain < base {\n     \
    \       digit = base;\n        }\n        xdigits = &mut xdigits[digit..];\n \
    \   }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `str` cannot be indexed by `RangeFrom<isize>`\n\
    \  --> /tmp/tmpmy9ii76_.rs:23:24\n   |\n23 |         xdigits = &mut xdigits[digit..];\n\
    \   |                        ^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<str>` is not implemented for `RangeFrom<isize>`\n\
    \   = help: the following other types implement trait `SliceIndex<T>`:\n     \
    \        <RangeFrom<usize> as SliceIndex<[T]>>\n             <RangeFrom<usize>\
    \ as SliceIndex<str>>\n   = note: required because of the requirements on the\
    \ impl of `Index<RangeFrom<isize>>` for `str`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut y = String::new();\n    let mut num = x as isize;\n    let mut\
    \ place = base as isize;\n    while num >= base as isize {\n        num = num\
    \ - place as isize;\n        y.push(num % base as char);\n    }\n    y.push(num\
    \ % base as char);\n    y\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `isize` by `char`\n  --> /tmp/tmp8avhb7tl.rs:16:20\n\
    \   |\n16 |         y.push(num % base as char);\n   |                    ^ no\
    \ implementation for `isize % char`\n   |\n   = help: the trait `Rem<char>` is\
    \ not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror[E0277]: cannot mod `isize` by `char`\n  --> /tmp/tmp8avhb7tl.rs:18:16\n\
    \   |\n18 |     y.push(num % base as char);\n   |                ^ no implementation\
    \ for `isize % char`\n   |\n   = help: the trait `Rem<char>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n  -->\
    \ /tmp/tmp8avhb7tl.rs:16:22\n   |\n16 |         y.push(num % base as char);\n\
    \   |                      ^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmp8avhb7tl.rs:16:22\n   |\n16 |         y.push(num\
    \ % base as char);\n   |                      ^^^^^^^^^^^^\n\nerror[E0604]: only\
    \ `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmp8avhb7tl.rs:18:18\n \
    \  |\n18 |     y.push(num % base as char);\n   |                  ^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmp8avhb7tl.rs:18:18\n   |\n18 |     y.push(num % base as char);\n   |\
    \                  ^^^^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0604"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    // let mut bases_len = bases.len();\n    let mut result = String::new();\n\
    \    loop {\n        let mut current_digit = x * (base as usize) as usize;\n \
    \       if current_digit < 0 {\n            current_digit = -current_digit;\n\
    \        }\n        if current_digit == 0 {\n            break;\n        }\n \
    \       match base_digit(current_digit as usize) {\n            None => {}\n \
    \           Some(digit) => {\n                result.push((digit as char).to_string());\n\
    \            }\n        }\n        current_digit /= base;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `base_digit` in this scope\n  --> /tmp/tmpf3cl7_mr.rs:21:15\n\
    \   |\n21 |         match base_digit(current_digit as usize) {\n   |         \
    \      ^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpf3cl7_mr.rs:14:37\n   |\n14 |         let mut current_digit = x\
    \ * (base as usize) as usize;\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot multiply `isize` by\
    \ `usize`\n  --> /tmp/tmpf3cl7_mr.rs:14:35\n   |\n14 |         let mut current_digit\
    \ = x * (base as usize) as usize;\n   |                                   ^ no\
    \ implementation for `isize * usize`\n   |\n   = help: the trait `Mul<usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf3cl7_mr.rs:24:29\n\
    \   |\n24 |                 result.push((digit as char).to_string());\n   |  \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    format!(\"{:0>{base}}\", x, base=base)\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmp4k0t6ak7.rs:11:18\n\
    \   |\n11 |     format!(\"{:0>{base}}\", x, base=base)\n   |              -  \
    \ ^ expected `}` in format string\n   |              |\n   |              because\
    \ of this opening brace\n   |\n   = note: if you intended to print `{`, you can\
    \ escape it using `{{`\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut output = String::new();\n    let mut base = String::new();\n\
    \    let mut number = String::new();\n    if x == 0 {\n        return \"\";\n\
    \    }\n    if base < 10 {\n        base = &format!(\"0{}\", base);\n    }\n \
    \   while x != 0 {\n        number.push((x % base) as char);\n        x /= base;\n\
    \    }\n    output = &number[..];\n    if let Some(digit) = base {\n        output\
    \ += &digit;\n    }\n    output\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp38182jtq.rs:15:16\n   |\n\
    10 | fn change_base(x: isize, base: isize) -> String {\n   |                 \
    \                         ------ expected `String` because of return type\n...\n\
    15 |         return \"\";\n   |                ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp38182jtq.rs:17:15\n\
    \   |\n17 |     if base < 10 {\n   |               ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |               |\n   |               expected struct\
    \ `String`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp38182jtq.rs:18:16\n\
    \   |\n12 |     let mut base = String::new();\n   |                    -------------\
    \ expected due to this value\n...\n18 |         base = &format!(\"0{}\", base);\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n\
    \   |\nhelp: consider removing the borrow\n   |\n18 -         base = &format!(\"\
    0{}\", base);\n18 +         base = format!(\"0{}\", base);\n   | \n\nerror[E0277]:\
    \ cannot mod `isize` by `String`\n  --> /tmp/tmp38182jtq.rs:21:24\n   |\n21 |\
    \         number.push((x % base) as char);\n   |                        ^ no implementation\
    \ for `isize % String`\n   |\n   = help: the trait `Rem<String>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0277]: cannot divide-assign `isize` by `String`\n  --> /tmp/tmp38182jtq.rs:22:11\n\
    \   |\n22 |         x /= base;\n   |           ^^ no implementation for `isize\
    \ /= String`\n   |\n   = help: the trait `DivAssign<String>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `DivAssign"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    while x > 0 {\n        x /= base;\n \
    \       s += *b'0' + &*(b'0'.repeat(x % base));\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmpnlmcaorq.rs:14:14\n\
    \   |\n14 |         s += *b'0' + &*(b'0'.repeat(x % base));\n   |            \
    \  ^^^^^\n\nerror[E0599]: no method named `repeat` found for type `u8` in the\
    \ current scope\n  --> /tmp/tmpnlmcaorq.rs:14:30\n   |\n14 |         s += *b'0'\
    \ + &*(b'0'.repeat(x % base));\n   |                              ^^^^^^ method\
    \ not found in `u8`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut xdigits: Vec<isize> = x.to_string().chars().collect();\n    let\
    \ mut base = base;\n    loop {\n        xdigits.pop();\n        let mut digit\
    \ = xdigits.len() as isize;\n        if digit > base {\n            xdigits.resize(digit\
    \ - base);\n        }\n        if digit == 0 {\n            break;\n        }\n\
    \        xdigits[digit as usize] %= base;\n    }\n    format!(\"{}\", xdigits).to_string()\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpllkdo7hf.rs:11:57\n     |\n11\
    \   |     let mut xdigits: Vec<isize> = x.to_string().chars().collect();\n   \
    \  |                                                         ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=char>`\n  \
    \   |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0061]: this function takes 2 arguments but\
    \ 1 argument was supplied\n    --> /tmp/tmpllkdo7hf.rs:17:21\n     |\n17   | \
    \            xdigits.resize(digit - base);\n     |                     ^^^^^^\
    \ ------------ supplied 1 argument\n     |                     |\n     |     \
    \                expected 2 arguments\n     |\nnote: associated function defined\
    \ here\n\nerror[E0277]: `Vec<isize>` doesn't implement `std::fmt::Display`\n \
    \ --> /tmp/tmpllkdo7hf.rs:24:19\n   |\n24 |     format!(\"{}\", xdigits).to_string()\n\
    \   |                   ^^^^^^^ `Vec<isize>` cannot be formatted with the default\
    \ formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented\
    \ for `Vec<isize>`\n   = note: in format strings you may be able to use `{:?}`\
    \ (or {:#?} for pretty-print) instead\n   = note: this error originates in the\
    \ macro `$crate::__export::format_args` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0277.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    match base {\n        1 => \"0\".to_string(),\n        2 => \"10\".to_string(),\n\
    \        _ => panic!(\"base must be 1 or 2\"),\n    }\n    x.to_string().chars().map(|c|\
    \ if *c >= base*10 as isize { c % base } else { c + base }).collect()\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpi4y143f8.rs:14:14\n\
    \   |\n11 | /     match base {\n12 | |         1 => \"0\".to_string(),\n   | |\
    \              --------------- this is found to be of type `String`\n13 | |  \
    \       2 => \"10\".to_string(),\n   | |              ---------------- this is\
    \ found to be of type `String`\n14 | |         _ => panic!(\"base must be 1 or\
    \ 2\"),\n   | |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n15 | |     }\n   | |_____- `match` arms have incompatible types\n\
    \   |\n   = note: this error originates in the macro `$crate::panic::panic_2015`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpi4y143f8.rs:16:38\n   |\n\
    16 |     x.to_string().chars().map(|c| if *c >= base*10 as isize { c % base }\
    \ else { c + base }).collect()\n   |                                      ^^\n\
    \nerror[E0369]: cannot mod `char` by `isize`\n  --> /tmp/tmpi4y143f8.rs:16:65\n\
    \   |\n16 |     x.to_string().chars().map(|c| if *c >= base*10 as isize { c %\
    \ base } else { c + base }).collect()\n   |                                  \
    \                             - ^ ---- isize\n   |                           \
    \                                    |\n   |                                 \
    \                              char\n\nerror[E0369]: cannot add `isize` to `char`\n\
    \  --> /tmp/tmpi4y143f8.rs:16:83\n   |\n16 |     x.to_string().chars().map(|c|\
    \ if *c >= base*10 as isize { c % base } else { c + base }).collect()\n   |  \
    \                                                                            \
    \   - ^ ---- isize\n   |                                                     \
    \                            |\n   |                                         \
    \                                        char\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    if x > 0 {\n        if base < 10 {\n\
    \            s.push_str(&format!(\"{:0{}}\", x, base));\n        } else {\n  \
    \          s.push_str(&format!(\"{:0{}b}\", x, base));\n        }\n    } else\
    \ {\n        if base < 10 {\n            s.push_str(&format!(\"{:0{}}\", x, base));\n\
    \        } else {\n            s.push_str(&format!(\"{:0{}b}\", x, base));\n \
    \       }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmppfenuver.rs:14:37\n\
    \   |\n14 |             s.push_str(&format!(\"{:0{}}\", x, base));\n   |     \
    \                             -  ^ expected `}` in format string\n   |       \
    \                           |\n   |                                  because of\
    \ this opening brace\n   |\n   = note: if you intended to print `{`, you can escape\
    \ it using `{{`\n\nerror: invalid format string: expected `'}'`, found `'{'`\n\
    \  --> /tmp/tmppfenuver.rs:16:37\n   |\n16 |             s.push_str(&format!(\"\
    {:0{}b}\", x, base));\n   |                                  -  ^ expected `}`\
    \ in format string\n   |                                  |\n   |            \
    \                      because of this opening brace\n   |\n   = note: if you\
    \ intended to print `{`, you can escape it using `{{`\n\nerror: invalid format\
    \ string: expected `'}'`, found `'{'`\n  --> /tmp/tmppfenuver.rs:20:37\n   |\n\
    20 |             s.push_str(&format!(\"{:0{}}\", x, base));\n   |            \
    \                      -  ^ expected `}` in format string\n   |              \
    \                    |\n   |                                  because of this\
    \ opening brace\n   |\n   = note: if you intended to print `{`, you can escape\
    \ it using `{{`\n\nerror: invalid format string: expected `'}'`, found `'{'`\n\
    \  --> /tmp/tmppfenuver.rs:22:37\n   |\n22 |             s.push_str(&format!(\"\
    {:0{}b}\", x, base));\n   |                                  -  ^ expected `}`\
    \ in format string\n   |                                  |\n   |            \
    \                      because of this opening brace\n   |\n   = note: if you\
    \ intended to print `{`, you can escape it using `{{`\n\nerror: aborting due to\
    \ 4 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result: String = format!(\"{}\", x);\n\n    while result.len()\
    \ > base {\n        let div = result.len() - base;\n        result[..div].parse::<usize>().unwrap()\n\
    \            .to_string()\n            .chars().nth(div).cloned()\n          \
    \  .join(\"\")?;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpki1olv94.rs:13:26\n   |\n\
    13 |     while result.len() > base {\n   |                          ^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n13 |     while result.len()\
    \ > base.try_into().unwrap() {\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpki1olv94.rs:14:34\n   |\n14 |\
    \         let div = result.len() - base;\n   |                               \
    \   ^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize`\
    \ from `usize`\n  --> /tmp/tmpki1olv94.rs:14:32\n   |\n14 |         let div =\
    \ result.len() - base;\n   |                                ^ no implementation\
    \ for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0599]: `Option<char>` is not an iterator\n   --> /tmp/tmpki1olv94.rs:17:31\n\
    \    |\n17  |               .chars().nth(div).cloned()\n    |                \
    \                 ^^^^^^ `Option<char>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Option<char>: Iterator`\n\
    \            which is required by `&mut Option<char>: Iterator`\n\nerror[E0277]:\
    \ the `?` operator can only be used in a function that returns `Result` or `Option`\
    \ (or another type that implements `FromResidual`)\n  --> /tmp/tmpki1olv94.rs:18:22\n\
    \   |\n10 | / fn change_base(x: isize, base: isize) -> String {\n11 | |     let\
    \ mut result: String = format!(\"{}\", x);\n12 | |\n13 | |     while result.len()\
    \ > base {\n...  |\n18 | |             .join(\"\")?;\n   | |                 \
    \     ^ cannot use the `?` operator in a fu"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    x.to_string().parse::<usize>().unwrap() % base + 1\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb48nc9z5.rs:11:47\n   |\n\
    11 |     x.to_string().parse::<usize>().unwrap() % base + 1\n   |            \
    \                                   ^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot mod `usize` by `isize`\n  --> /tmp/tmpb48nc9z5.rs:11:45\n   |\n11 | \
    \    x.to_string().parse::<usize>().unwrap() % base + 1\n   |                \
    \                             ^ no implementation for `usize % isize`\n   |\n\
    \   = help: the trait `Rem<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Rem<Rhs>`:\n             <&'a f32\
    \ as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128 as\
    \ Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n\
    \             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n      \
    \       <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb48nc9z5.rs:11:5\n   |\n10 | fn change_base(x: isize, base:\
    \ isize) -> String {\n   |                                          ------ expected\
    \ `String` because of return type\n11 |     x.to_string().parse::<usize>().unwrap()\
    \ % base + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `usize`\n   |\nhelp: try using a conversion method\n\
    \   |\n11 |     (x.to_string().parse::<usize>().unwrap() % base + 1).to_string()\n\
    \   |     +                                                  +++++++++++++\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = x.to_string();\n    for n in &[10, 100, 1000, 10000]\
    \ {\n        let mut i = result.to_string() + base.to_string();\n        if n\
    \ != 2 {\n            i = i.to_string().chars().enumerate().filter(|(_, c)| *c\
    \ <= base).map(|(_, c)| c as isize).sum();\n        }\n        result = String::from(i);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq4idihli.rs:13:42\n   |\n\
    13 |         let mut i = result.to_string() + base.to_string();\n   |        \
    \                                  ^^^^^^^^^^^^^^^^\n   |                    \
    \                      |\n   |                                          expected\
    \ `&str`, found struct `String`\n   |                                        \
    \  help: consider borrowing here: `&base.to_string()`\n\nerror[E0277]: can't compare\
    \ `&{integer}` with `{integer}`\n  --> /tmp/tmpq4idihli.rs:14:14\n   |\n14 | \
    \        if n != 2 {\n   |              ^^ no implementation for `&{integer} ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq4idihli.rs:15:73\n\
    \   |\n15 |             i = i.to_string().chars().enumerate().filter(|(_, c)|\
    \ *c <= base).map(|(_, c)| c as isize).sum();\n   |                          \
    \                                               ^^^^ expected `char`, found `isize`\n\
    \nerror[E0277]: the trait bound `String: Sum<isize>` is not satisfied\n    -->\
    \ /tmp/tmpq4idihli.rs:15:104\n     |\n15   |             i = i.to_string().chars().enumerate().filter(|(_,\
    \ c)| *c <= base).map(|(_, c)| c as isize).sum();\n     |                    \
    \                                                                            \
    \        ^^^ the trait `Sum<isize>` is not implemented for `String`\n     |\n\
    \     = help: the following other types implement trait `Sum<A>`:\n          \
    \     <Duration as Sum<&'a Duration>>\n               <Duration as Sum>\n    \
    \           <Option<T> as Sum<Option<U>>>\n               <Result<T, E> as Sum<Result<U,\
    \ E>>>\n               <Simd<f32, LANES> as Sum<&'a Simd<f32, LANES>>>\n     \
    \          <Simd<f32, LANES> as Sum>\n               <Simd<f64, LANES> as Sum<&'a\
    \ Simd<f64, LANES>>>\n      "
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 10 {\n        let mut s = String::with_capacity(x);\n     \
    \   for i in 0..x {\n            s.push_str(&base.to_string());\n        }\n \
    \       s\n    } else {\n        let mut s = String::with_capacity(x * 10 + base);\n\
    \        for i in 0..x {\n            s.push_str(&base.to_string());\n       \
    \ }\n        s\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n  \
    \  assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqhaz60iv.rs:12:43\n   |\n\
    12 |         let mut s = String::with_capacity(x);\n   |                     \
    \                      ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n12 |         let mut s = String::with_capacity(x.try_into().unwrap());\n\
    \   |                                            ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqhaz60iv.rs:18:43\n   |\n18 |         let mut\
    \ s = String::with_capacity(x * 10 + base);\n   |                            \
    \               ^^^^^^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n18 |         let mut s = String::with_capacity((x * 10 + base).try_into().unwrap());\n\
    \   |                                           +             +++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    use std::cmp::Ordering;\n    let mut x = x as isize;\n    let mut r =\
    \ String::new();\n    while x != 0 {\n        r = &format!(\"{}{}\", base[(x %\
    \ base) as usize], r).to_string();\n        x /= base;\n    }\n    r.reverse()\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmp68faudw6.rs:11:9\n\
    \   |\n11 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0608]: cannot index\
    \ into a value of type `isize`\n  --> /tmp/tmp68faudw6.rs:15:30\n   |\n15 |  \
    \       r = &format!(\"{}{}\", base[(x % base) as usize], r).to_string();\n  \
    \ |                              ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no\
    \ method named `reverse` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp68faudw6.rs:18:7\n   |\n18 |     r.reverse()\n   |       ^^^^^^^ help:\
    \ there is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut r = String::with_capacity(x as isize);\n    while x > 0 {\n \
    \       let next = if x % base == 0 {\n            x /= base;\n            String::from(\"\
    \")\n        } else {\n            String::from(\"\")\n        };\n        r +=\
    \ next;\n    }\n    r\n}\n\nfn main() {\n    let candidate = change_base;\n  \
    \  assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn46wpbjv.rs:11:39\n   |\n\
    11 |     let mut r = String::with_capacity(x as isize);\n   |                \
    \                       ^^^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n11 |     let mut r = String::with_capacity((x as isize).try_into().unwrap());\n\
    \   |                                       +          +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn46wpbjv.rs:19:14\n   |\n19 |\
    \         r += next;\n   |              ^^^^\n   |              |\n   |      \
    \        expected `&str`, found struct `String`\n   |              help: consider\
    \ borrowing here: `&next`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut y = x.to_digits().to_base10();\n    let mut z = y.clone();\n\
    \    let mut x = base.to_digits().to_base10();\n    z.truncate(x);\n    String::from_digits(&z[..],\
    \ base.digits())\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpc05fb520.rs:11:19\n   |\n11 |     let mut y = x.to_digits().to_base10();\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpc05fb520.rs:13:22\n   |\n13 |     let mut x = base.to_digits().to_base10();\n\
    \   |                      ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no function or associated item named `from_digits` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpc05fb520.rs:15:13\n   |\n15 |     String::from_digits(&z[..],\
    \ base.digits())\n   |             ^^^^^^^^^^^ function or associated item not\
    \ found in `String`\n\nerror[E0599]: no method named `digits` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpc05fb520.rs:15:38\n   |\n15 |     String::from_digits(&z[..],\
    \ base.digits())\n   |                                      ^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    use num_bigint::*;\n    use num_traits::ToPrimitive;\n\n    if base <\
    \ 10 {\n        return format!(\"{}\", num::to_digits(x, base));\n    }\n\n  \
    \  let mut res = num::BigInt::new_unsigned_digits(&[]).unwrap();\n    let mut\
    \ i = 0;\n    let mut base = num::DIGITS.iter().take(base).rev().collect::<Vec<_>>();\n\
    \    while i < x.len() {\n        let mut digits = num::DIGITS.iter().take(base).rev().collect::<Vec<_>>();\n\
    \        let digit = if i >= x.len() {\n            digits.last()\n        } else\
    \ {\n            digits[i]\n        };\n        let digit = if digit >= '0' &&\
    \ digit <= '9' {\n            digit - '0'\n        } else {\n            digit\
    \ - 'A' + 10\n        };\n        res.insert(i, digit);\n        i += 1;\n   \
    \ }\n    num::BigInt::from_digits(&res, base)\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0432]: unresolved import `num_bigint`\n  --> /tmp/tmpou49973e.rs:11:9\n\
    \   |\n11 |     use num_bigint::*;\n   |         ^^^^^^^^^^ maybe a missing crate\
    \ `num_bigint`?\n\nerror[E0432]: unresolved import `num_traits`\n  --> /tmp/tmpou49973e.rs:12:9\n\
    \   |\n12 |     use num_traits::ToPrimitive;\n   |         ^^^^^^^^^^ maybe a\
    \ missing crate `num_traits`?\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `num`\n  --> /tmp/tmpou49973e.rs:15:30\n   |\n15 |         return\
    \ format!(\"{}\", num::to_digits(x, base));\n   |                            \
    \  ^^^ use of undeclared crate or module `num`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `num`\n  --> /tmp/tmpou49973e.rs:18:19\n \
    \  |\n18 |     let mut res = num::BigInt::new_unsigned_digits(&[]).unwrap();\n\
    \   |                   ^^^ use of undeclared crate or module `num`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `num`\n  --> /tmp/tmpou49973e.rs:20:20\n\
    \   |\n20 |     let mut base = num::DIGITS.iter().take(base).rev().collect::<Vec<_>>();\n\
    \   |                    ^^^ use of undeclared crate or module `num`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `num`\n  --> /tmp/tmpou49973e.rs:22:26\n\
    \   |\n22 |         let mut digits = num::DIGITS.iter().take(base).rev().collect::<Vec<_>>();\n\
    \   |                          ^^^ use of undeclared crate or module `num`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `num`\n  -->\
    \ /tmp/tmpou49973e.rs:36:5\n   |\n36 |     num::BigInt::from_digits(&res, base)\n\
    \   |     ^^^ use of undeclared crate or module `num`\n\nerror[E0599]: no method\
    \ named `len` found for type `isize` in the current scope\n  --> /tmp/tmpou49973e.rs:21:17\n\
    \   |\n21 |     while i < x.len() {\n   |                 ^^^ method not found\
    \ in `isize`\n\nerror[E0599]: no method named `len` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpou49973e.rs:23:31\n   |\n23 |         let digit\
    \ = if i >= x.len() {\n   |                               ^^^ method not found\
    \ in `isize`\n\nerror: aborting due to 9 previo"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    // Convert to string, convert to integer and convert to string using\
    \ base given.\n    String::from_integer(x as u32).to_string(base)\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `from_integer` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpzxiilr5v.rs:12:13\n\
    \   |\n12 |     String::from_integer(x as u32).to_string(base)\n   |         \
    \    ^^^^^^^^^^^^ function or associated item not found in `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if x < base {\n        match x {\n            0 => \"0\",\n         \
    \   i if i > base - 1 => \"10\".to_string(),\n            i if i > base - 2 else\
    \ \"0\".to_string() => i.to_string(),\n            _ => panic!(\"input number\
    \ must be bigger than 0\"),\n        }\n    } else {\n        match x {\n    \
    \        i if i > base - 1 => \"10\".to_string(),\n            i if i > base -\
    \ 2 else \"0\".to_string() => i.to_string(),\n            _ => x.to_string(),\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `=>`, `?`, or an operator, found keyword `else`\n\
    \  --> /tmp/tmpnys0njrs.rs:15:31\n   |\n15 |             i if i > base - 2 else\
    \ \"0\".to_string() => i.to_string(),\n   |                               ^^^^\
    \ expected one of `.`, `=>`, `?`, or an operator\n\nerror: expected one of `.`,\
    \ `=>`, `?`, or an operator, found keyword `else`\n  --> /tmp/tmpnys0njrs.rs:21:31\n\
    \   |\n21 |             i if i > base - 2 else \"0\".to_string() => i.to_string(),\n\
    \   |                               ^^^^ expected one of `.`, `=>`, `?`, or an\
    \ operator\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnys0njrs.rs:13:18\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n13 |             0 => \"0\",\n   |                  ^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                  |\n   |         \
    \         expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut num = x;\n    while num > 0\
    \ {\n        let digit = num % base;\n        res.insert(digit.to_string(), digit.to_string().chars().nth(digit).unwrap());\n\
    \        num /= base;\n    }\n    res.reverse().to_string()\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvodqduxo.rs:15:20\n   |\n\
    15 |         res.insert(digit.to_string(), digit.to_string().chars().nth(digit).unwrap());\n\
    \   |                    ^^^^^^^^^^^^^^^^^ expected `usize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvodqduxo.rs:15:69\n   |\n15 |\
    \         res.insert(digit.to_string(), digit.to_string().chars().nth(digit).unwrap());\n\
    \   |                                                                     ^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n15 |         res.insert(digit.to_string(),\
    \ digit.to_string().chars().nth(digit.try_into().unwrap()).unwrap());\n   |  \
    \                                                                        ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpvodqduxo.rs:18:9\n   |\n18 |     res.reverse().to_string()\n\
    \   |         ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    match x {\n        x if x % base == 0 => x.to_string(),\n        x if\
    \ base > 10 => format!(\"{}\", x).to_string(),\n        x if base < 10 => format!(\"\
    {}{}\", x, base).to_string(),\n        x => format!(\"{:?}\", x).to_string(),\n\
    \    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"83\"`,\n right: `\"22\"`', /tmp/tmpije0gc1q.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut digits = x.to_string();\n    for &d in &mut digits[..base] {\n\
    \        if d == '0' {\n            digits.remove(d);\n        } else {\n    \
    \        digits[base] = d.to_ascii_lowercase();\n        }\n    }\n    digits\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<isize>`\n\
    \  --> /tmp/tmpix2qjmnz.rs:12:20\n   |\n12 |     for &d in &mut digits[..base]\
    \ {\n   |                    ^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<isize>`\n\
    \   |\n   = help: the trait `Index<RangeTo<isize>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `usize` with `char`\n  --> /tmp/tmpix2qjmnz.rs:13:14\n\
    \   |\n13 |         if d == '0' {\n   |              ^^ no implementation for\
    \ `usize == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0599]: no method named `to_ascii_lowercase` found\
    \ for type `usize` in the current scope\n  --> /tmp/tmpix2qjmnz.rs:16:30\n   |\n\
    16 |             digits[base] = d.to_ascii_lowercase();\n   |                \
    \              ^^^^^^^^^^^^^^^^^^ method not found in `usize`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `isize`\n  --> /tmp/tmpix2qjmnz.rs:16:13\n\
    \   |\n16 |             digits[base] = d.to_ascii_lowercase();\n   |         \
    \    ^^^^^^^^^^^^ `String` cannot be indexed by `isize`\n   |\n   = help: the\
    \ trait `Index<isize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as In"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = x;\n    for i in 0..base {\n        result = result\
    \ / base;\n    }\n    format!(\"{}\", result)\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"0\"`,\n right: `\"22\"`', /tmp/tmpax3ch3qk.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut buff = String::new();\n    let mut pow = base;\n    loop {\n\
    \        if pow == 0 {\n            buff.push(0);\n            break;\n      \
    \  }\n        buff.push(x % pow);\n        x = x / pow;\n        pow /= base;\n\
    \    }\n    buff\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa8lljvt1.rs:15:23\n   |\n\
    15 |             buff.push(0);\n   |                       ^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa8lljvt1.rs:18:19\n\
    \   |\n18 |         buff.push(x % pow);\n   |                   ^^^^^^^ expected\
    \ `char`, found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s: String = String::new();\n    loop {\n        if x % base ==\
    \ 0 {\n            s.push('0');\n            x = x / base;\n        } else {\n\
    \            s.push('1');\n            x = (x % base) + base;\n        }\n   \
    \ }\n    String::from(s)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "warning: unreachable expression\n  --> /tmp/tmpdnwlfi4y.rs:21:5\n   |\n\
    12 | /     loop {\n13 | |         if x % base == 0 {\n14 | |             s.push('0');\n\
    15 | |             x = x / base;\n...  |\n19 | |         }\n20 | |     }\n   |\
    \ |_____- any code following this expression is unreachable\n21 |       String::from(s)\n\
    \   |       ^^^^^^^^^^^^^^^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `x`\n  -->\
    \ /tmp/tmpdnwlfi4y.rs:15:13\n   |\n10 | fn change_base(x: isize, base: isize)\
    \ -> String {\n   |                - help: consider making this binding mutable:\
    \ `mut x`\n...\n15 |             x = x / base;\n   |             ^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror[E0384]: cannot assign to immutable\
    \ argument `x`\n  --> /tmp/tmpdnwlfi4y.rs:18:13\n   |\n10 | fn change_base(x:\
    \ isize, base: isize) -> String {\n   |                - help: consider making\
    \ this binding mutable: `mut x`\n...\n18 |             x = (x % base) + base;\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    while x > 0 {\n        if x % base\
    \ == 0 {\n            result += &format!(\"{}\", base);\n        } else {\n  \
    \          result += &format!(\"{}\", x / base);\n        }\n        x /= base;\n\
    \    }\n    result.into_owned()\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `into_owned` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpqt2h4gva.rs:20:12\n   |\n20 |     result.into_owned()\n\
    \   |            ^^^^^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut quotient = x;\n    while\
    \ quotient > 0 {\n        quotient /= base;\n        result.push((quotient % base)\
    \ as char);\n    }\n    result.reverse();\n    result\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmprg598bc6.rs:17:12\n   |\n17 |     result.reverse();\n\
    \   |            ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n\
    \  --> /tmp/tmprg598bc6.rs:15:21\n   |\n15 |         result.push((quotient % base)\
    \ as char);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^ invalid cast\n\
    \   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmprg598bc6.rs:15:21\n\
    \   |\n15 |         result.push((quotient % base) as char);\n   |            \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0604.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 2 {\n        use std::num::One;\n        use std::ops::{Add,\
    \ Sub};\n        (x + One::one()) * (base ** 2)\n            .checked_add((One::one()\
    \ * base).unwrap())\n            .unwrap()\n            .to_string()\n    } else\
    \ {\n        let mut x = x.to_digits(base);\n        x.normalize();\n        x.reverse();\n\
    \        x.join(\"\").to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0432]: unresolved import `std::num::One`\n  --> /tmp/tmp0u0xtnyt.rs:12:13\n\
    \   |\n12 |         use std::num::One;\n   |             ^^^^^^^^^^^^^ no `One`\
    \ in `num`\n\nwarning: unused imports: `Add`, `Sub`\n  --> /tmp/tmp0u0xtnyt.rs:13:24\n\
    \   |\n13 |         use std::ops::{Add, Sub};\n   |                        ^^^\
    \  ^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmp0u0xtnyt.rs:14:35\n \
    \  |\n14 |         (x + One::one()) * (base ** 2)\n   |                      \
    \             ^^^\n\nerror[E0277]: cannot multiply `isize` by `String`\n  -->\
    \ /tmp/tmp0u0xtnyt.rs:14:26\n   |\n14 |         (x + One::one()) * (base ** 2)\n\
    \   |                          ^ no implementation for `isize * String`\n   |\n\
    \   = help: the trait `Mul<String>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Mul<Rhs>`:\n             <&'a f32\
    \ as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as\
    \ Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n\
    \             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n      \
    \       <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0599]: no\
    \ method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp0u0xtnyt.rs:19:23\n   |\n19 |         let mut x = x.to_digits(base);\n\
    \   |                       ^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0277, E0432, E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut rep = String::new();\n    loop {\n        rep.push_str(&x.to_string().chars().map(|c|\
    \ match c {\n            '0'...'9' => (c - base) as char,\n            'a'...'z'\
    \ => (c - base + 10) as char,\n            _ => c.to_string()\n        }).collect());\n\
    \        if x < base {\n            return rep;\n        }\n        rep.push(\"\
    0\".to_string());\n        x /= base;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmp8lj0str8.rs:14:16\n\
    \   |\n14 |             '0'...'9' => (c - base) as char,\n   |               \
    \ ^^^ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmp8lj0str8.rs:15:16\n\
    \   |\n15 |             'a'...'z' => (c - base + 10) as char,\n   |          \
    \      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is\
    \ accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n\
    \   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0369]: cannot subtract `isize` from `char`\n  --> /tmp/tmp8lj0str8.rs:14:29\n\
    \   |\n14 |             '0'...'9' => (c - base) as char,\n   |               \
    \            - ^ ---- isize\n   |                           |\n   |          \
    \                 char\n\nerror[E0369]: cannot subtract `isize` from `char`\n\
    \  --> /tmp/tmp8lj0str8.rs:15:29\n   |\n15 |             'a'...'z' => (c - base\
    \ + 10) as char,\n   |                           - ^ ---- isize\n   |        \
    \                   |\n   |                           char\n\nerror[E0277]: a\
    \ value of type `str` cannot be built from an iterator over elements of type `_`\n\
    \    --> /tmp/tmp8lj0str8.rs:17:12\n     |\n17   |         }).collect());\n  \
    \   |            ^^^^^^^ value of type `str` cannot be built from `std::iter::Iterator<Item=_>`\n\
    \     |\n     = help: the trait `FromIterator<_>` is not implemented for `str`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    use std::fmt::{self, Display};\n    if x <= base {\n        String::from(\"\
    0\")\n    } else {\n        let mut result = String::from(\"0\");\n        for\
    \ i in 1..base.abs() {\n            result += &x.pow(base-i).to_string();\n  \
    \      }\n        result\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "warning: unused imports: `Display`, `self`\n  --> /tmp/tmpql3yexg6.rs:11:20\n\
    \   |\n11 |     use std::fmt::{self, Display};\n   |                    ^^^^ \
    \ ^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpql3yexg6.rs:17:30\n   |\n17 |             result\
    \ += &x.pow(base-i).to_string();\n   |                              ^^^^^^ expected\
    \ `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and\
    \ panic if the converted value doesn't fit\n   |\n17 |             result += &x.pow((base-i).try_into().unwrap()).to_string();\n\
    \   |                              +      +++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut x: String = x.to_string();\n    let mut s = vec![];\n    while\
    \ x.len() > 0 {\n        let mut idx = x.len() - 1;\n        if idx == 0 {\n \
    \           let mut s = vec![];\n            s.append(x.chars().nth(x.len() -\
    \ 1));\n            break;\n        }\n        let mut c = x.chars().nth(idx).unwrap();\n\
    \        if c == '1' {\n            s.remove(&c);\n            s.append(&c.to_string()\
    \ + &\"0\");\n        } else if c != '0' {\n            s.append(&c);\n      \
    \      break;\n        }\n        idx -= 1;\n        if idx < 0 {\n          \
    \  let mut s = vec![];\n            s.append(&x.chars().nth(idx).unwrap());\n\
    \            break;\n        }\n        let mut c = x.chars().nth(idx).unwrap();\n\
    \        if c == '0' {\n            s.remove(&c);\n            s.append(&c.to_string()\
    \ + &\"1\");\n        } else if c != '1' {\n            s.append(&c);\n      \
    \      break;\n        }\n        idx -= 1;\n        if idx < 0 {\n          \
    \  let mut s = vec![];\n            s.append(&x.chars().nth(idx).unwrap());\n\
    \            break;\n        }\n        let mut c = x.chars().nth(idx).unwrap();\n\
    \        if c == '0' {\n            s.remove(&c);\n            s.append(&c.to_string()\
    \ + &\"0\");\n        } else if c != '1' {\n            s.append(&c);\n      \
    \      break;\n        }\n        idx -= 1;\n        if idx < 0 {\n          \
    \  let mut s = vec![];\n            s.append(&x.chars().nth(idx).unwrap());\n\
    \            break;\n        }\n        let mut c = x.chars().nth(idx).unwrap();\n\
    \        if c == '0' {\n            s.remove(&c);\n            s.append(&c.to_string()\
    \ + &\"1\");\n        } else if c != '1' {\n            s.append(&c);\n      \
    \      break;\n        }\n        idx -= 1;\n        if idx < 0 {\n          \
    \  let mut s = vec![];\n            s.append(&x.chars().nth(idx).unwrap());\n\
    \            break;\n        }\n        let mut c = x.chars().nth(idx).unwrap();\n\
    \        if c == '0' {\n            s.remove(&c);\n            s.append(&c.to_string()\
    \ + &\"1\");\n        } else if c != '1' {\n            s.append(&c);\n      \
    \      break;\n        }\n        idx -= 1;\n        if idx < 0 {\n          \
    \  let mut s = vec![];\n            s.append(&x.chars().nth(idx).unwrap());\n\
    \            break;\n        }\n        let mut c = x.char\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxugh7yub.rs:107:3\n\
    \    |\n10  | fn change_base(x: isize, base: isize) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n13  |  \
    \   while x.len() > 0 {\n    |                       - this delimiter might not\
    \ be properly closed...\n...\n91  | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n107 | }\n    |   ^\n\nerror: expected `;`, found\
    \ `}`\n  --> /tmp/tmpxugh7yub.rs:90:27\n   |\n90 |         let mut c = x.char\n\
    \   |                           ^ help: add `;` here\n91 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxugh7yub.rs:17:22\n \
    \  |\n17 |             s.append(x.chars().nth(x.len() - 1));\n   |           \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&mut Vec<_>`, found enum `Option`\n\
    \   |\n   = note: expected mutable reference `&mut Vec<_>`\n                 \
    \          found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxugh7yub.rs:22:22\n   |\n22 |             s.remove(&c);\n   |      \
    \                ^^ expected `usize`, found `&char`\n\nerror[E0369]: cannot add\
    \ `&&str` to `&String`\n  --> /tmp/tmpxugh7yub.rs:23:37\n   |\n23 |          \
    \   s.append(&c.to_string() + &\"0\");\n   |                      --------------\
    \ ^ ---- &&str\n   |                      |              |\n   |             \
    \         |              `+` cannot be used to concatenate two `&str` strings\n\
    \   |                      &String\n   |\n   = note: string concatenation requires\
    \ an owned `String` on the left\nhelp: remove the borrow to obtain an owned `String`\n\
    \   |\n23 -             s.append(&c.to_string() + &\"0\");\n23 +             s.append(c.to_string()\
    \ + &\"0\");\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxugh7yub.rs:25:22\n\
    \   |\n25 |             s.append(&c);\n   |                      ^^ types differ\
    \ in mutability\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n \
    \                     found reference `&char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxugh7yub.rs:31:22\n   |\n31 |             s.ap"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut x = x.to_string();\n    if x >= base {\n        let mut x = x;\n\
    \        let mut base = base;\n        while x >= base {\n            x -= base;\n\
    \            base = base_digits[base];\n        }\n        x.to_string() + &base;\n\
    \    } else {\n        let mut base = base;\n        let mut x = x;\n        while\
    \ x <= base {\n            x += base;\n            base = base_digits[base];\n\
    \        }\n        x.to_string() + &base;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `base_digits` in this scope\n  --> /tmp/tmpen2pq7si.rs:17:20\n\
    \   |\n17 |             base = base_digits[base];\n   |                    ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `base_digits` in\
    \ this scope\n  --> /tmp/tmpen2pq7si.rs:25:20\n   |\n25 |             base = base_digits[base];\n\
    \   |                    ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpen2pq7si.rs:12:13\n   |\n12 |     if x >= base\
    \ {\n   |             ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |             |\n   |             expected struct `String`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpen2pq7si.rs:15:20\n   |\n15 |\
    \         while x >= base {\n   |                    ^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `isize`\n\nerror[E0368]: binary assignment operation\
    \ `-=` cannot be applied to type `String`\n  --> /tmp/tmpen2pq7si.rs:16:13\n \
    \  |\n16 |             x -= base;\n   |             -^^^^^^^^\n   |          \
    \   |\n   |             cannot use `-=` on type `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpen2pq7si.rs:19:25\n   |\n19 |         x.to_string() + &base;\n\
    \   |                         ^^^^^ expected `str`, found `isize`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpen2pq7si.rs:12:18\n   |\n12 |  \
    \     if x >= base {\n   |  __________________^\n13 | |         let mut x = x;\n\
    14 | |         let mut base = base;\n15 | |         while x >= base {\n...  |\n\
    19 | |         x.to_string() + &base;\n   | |                              - help:\
    \ remove this semicolon\n20 | |     } else {\n   | |_____^ expected struct `String`,\
    \ found `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpen2pq7si.rs:23:20\n\
    \   |\n23 |         while x <= base {\n   |                    ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                    |\n   | \
    \                   exp"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut digits = vec![0; base::digits().len()];\n\
    \    while x >= base {\n        res.extend(&digits[(x % base)..]);\n        x\
    \ /= base;\n    }\n    res.extend(&digits[0..]);\n    res.to_string()\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `base`\n\
    \  --> /tmp/tmpkfd5cdt7.rs:12:30\n   |\n12 |     let mut digits = vec![0; base::digits().len()];\n\
    \   |                              ^^^^ use of undeclared crate or module `base`\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `RangeFrom<isize>`\n\
    \  --> /tmp/tmpkfd5cdt7.rs:14:21\n   |\n14 |         res.extend(&digits[(x % base)..]);\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `RangeFrom<isize>`\n   = help: the following other types\
    \ implement trait `SliceIndex<T>`:\n             <RangeFrom<usize> as SliceIndex<[T]>>\n\
    \             <RangeFrom<usize> as SliceIndex<str>>\n   = note: required because\
    \ of the requirements on the impl of `Index<RangeFrom<isize>>` for `Vec<{integer}>`\n\
    \nerror[E0277]: the trait bound `String: Extend<&{integer}>` is not satisfied\n\
    \  --> /tmp/tmpkfd5cdt7.rs:17:9\n   |\n17 |     res.extend(&digits[0..]);\n  \
    \ |         ^^^^^^ the trait `Extend<&{integer}>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `Extend<A>`:\n   \
    \          <String as Extend<&'a char>>\n             <String as Extend<&'a str>>\n\
    \             <String as Extend<Box<str>>>\n             <String as Extend<Cow<'a,\
    \ str>>>\n             <String as Extend<String>>\n             <String as Extend<char>>\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    match base {\n        2 => String::from(\"1000\".to_string()),\n    \
    \    3 => String::from(\"1111\".to_string()),\n        4 => String::from(\"10000\"\
    .to_string()),\n        5 => String::from(\"100000\".to_string()),\n        _\
    \ => {\n            let mut s = String::new();\n            for digit in x.to_string().chars().skip(base.to_string().len()\
    \ + 1) {\n                s.push_str(digit.to_string());\n            }\n    \
    \        String::from(s)\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpurvbjh7x.rs:19:28\n   |\n\
    19 |                 s.push_str(digit.to_string());\n   |                    \
    \        ^^^^^^^^^^^^^^^^^\n   |                            |\n   |          \
    \                  expected `&str`, found struct `String`\n   |              \
    \              help: consider borrowing here: `&digit.to_string()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    match x.checked_mul(base) {\n        Some(x) => x.to_string(),\n    \
    \    None => \"\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"24\"`,\n right: `\"22\"`', /tmp/tmp04tewf5u.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    s.push_str(&x.to_string_radix(base));\n\
    \    s.chars().for_each(|c| {\n        if c >= base {\n            s.push('1');\n\
    \        } else {\n            s.push('0');\n        }\n    });\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_string_radix` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpevxv8a_i.rs:12:19\n   |\n12 |     s.push_str(&x.to_string_radix(base));\n\
    \   |                   ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpevxv8a_i.rs:14:17\n   |\n14 |         if c >=\
    \ base {\n   |                 ^^^^ expected `char`, found `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut x = x * base as u64;\n    let mut ret: String = String::new();\n\
    \    while x >= 10 {\n        ret += &format!(\"{}\", x % 10);\n        x /= 10;\n\
    \    }\n    ret += &format!(\"{}\", x);\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpchoh5vdr.rs:11:21\n   |\n\
    11 |     let mut x = x * base as u64;\n   |                     ^^^^^^^^^^^ expected\
    \ `isize`, found `u64`\n\nerror[E0277]: cannot multiply `isize` by `u64`\n  -->\
    \ /tmp/tmpchoh5vdr.rs:11:19\n   |\n11 |     let mut x = x * base as u64;\n   |\
    \                   ^ no implementation for `isize * u64`\n   |\n   = help: the\
    \ trait `Mul<u64>` is not implemented for `isize`\n   = help: the following other\
    \ types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n    \
    \         <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n      \
    \       <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n          \
    \   <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n             <&'a\
    \ isize as Mul<isize>>\n           and 49 others\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 2 {\n        panic!(\"Invalid base\");\n    }\n\n    let mut\
    \ ret: String = \"\";\n    while x != 0 {\n        if base == 10 {\n         \
    \   ret += &x[..1].to_ascii_lowercase()[0];\n            break;\n        }\n\n\
    \        let rem = (x / base) as usize;\n        let mul = &x[..rem].to_ascii_lowercase();\n\
    \        ret += &mul[..1].to_ascii_lowercase()[0];\n        x -= rem * base;\n\
    \    }\n\n    ret\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp43iwuip1.rs:15:27\n   |\n\
    15 |     let mut ret: String = \"\";\n   |                  ------   ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                  |     \
    \   |\n   |                  |        expected struct `String`, found `&str`\n\
    \   |                  expected due to this\n\nerror[E0608]: cannot index into\
    \ a value of type `isize`\n  --> /tmp/tmp43iwuip1.rs:18:21\n   |\n18 |       \
    \      ret += &x[..1].to_ascii_lowercase()[0];\n   |                     ^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmp43iwuip1.rs:23:20\n\
    \   |\n23 |         let mul = &x[..rem].to_ascii_lowercase();\n   |          \
    \          ^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43iwuip1.rs:25:20\n\
    \   |\n25 |         x -= rem * base;\n   |                    ^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot multiply `usize` by `isize`\n  --> /tmp/tmp43iwuip1.rs:25:18\n\
    \   |\n25 |         x -= rem * base;\n   |                  ^ no implementation\
    \ for `usize * isize`\n   |\n   = help: the trait `Mul<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43iwuip1.rs:25:14\n\
    \   |\n25 |         x -= rem * base;\n   |              ^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot subtract-assign `usize` from `isize`\n\
    \  --> /tmp/tmp43iwuip1.rs:25:11\n   |\n25 |         x -= rem * base;\n   |  \
    \         ^^ no implementation for `isize -= usize`\n   |\n   = help: the trait\
    \ `SubAssign<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n\
    \             <f32 as SubAssign>\n    "
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    s.push_str(&x.to_str_radix(base).to_string());\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_str_radix` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpv38wf72o.rs:12:19\n   |\n12 |     s.push_str(&x.to_str_radix(base).to_string());\n\
    \   |                   ^^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    // Find difference between base and number base\n    let mut num_base\
    \ = base;\n    let mut diff = num_base - x;\n\n    // Loop for converting to other\
    \ number base\n    while diff > 0 {\n        x = x * num_base + x;\n        diff\
    \ -= 1;\n    }\n\n    // Return string representation\n    format!(\"{}\", x)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp_z8xwzza.rs:12:9\n\
    \   |\n12 |     let mut num_base = base;\n   |         ----^^^^^^^^\n   |    \
    \     |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `x`\n  -->\
    \ /tmp/tmp_z8xwzza.rs:17:9\n   |\n10 | fn change_base(x: isize, base: isize) ->\
    \ String {\n   |                - help: consider making this binding mutable:\
    \ `mut x`\n...\n17 |         x = x * num_base + x;\n   |         ^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut buff = String::new();\n    let mut result = x;\n    let mut remainder\
    \ = 0;\n    while result != 0 {\n        remainder = (result % base);\n      \
    \  result = result / base;\n        buff.push((remainder + '0').to_string());\n\
    \    }\n    buff\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp5wj23t4x.rs:15:21\n\
    \   |\n15 |         remainder = (result % base);\n   |                     ^ \
    \            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n15 -         remainder = (result % base);\n\
    15 +         remainder = result % base;\n   | \n\nerror[E0277]: cannot add `char`\
    \ to `isize`\n  --> /tmp/tmp5wj23t4x.rs:17:30\n   |\n17 |         buff.push((remainder\
    \ + '0').to_string());\n   |                              ^ no implementation\
    \ for `isize + char`\n   |\n   = help: the trait `Add<char>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    use std::fmt;\n    use std::str::FromStr;\n\n    let mut digits = vec![];\n\
    \    let mut carry = false;\n    let mut digits_iter = x.abs();\n    for i in\
    \ digits_iter.cloned() {\n        let d = i as usize;\n        if d < base {\n\
    \            if carry {\n                digits.insert(0, 1);\n            } else\
    \ {\n                digits.push(d);\n            }\n        } else {\n      \
    \      let mut digit = d - base;\n            digit = digit % base;\n        \
    \    if carry {\n                digits.insert(0, digit);\n            } else\
    \ {\n                digits.push(digit);\n            }\n            carry = true;\n\
    \        }\n    }\n    digits.insert(0, 1);\n\n    let mut res = String::new();\n\
    \    for i in digits {\n        if i >= 10 {\n            res.push_str(&format!(\"\
    {}\", i / 10.0));\n        } else {\n            res.push_str(&format!(\"{}\"\
    , i));\n        }\n    }\n    if res == \"\" {\n        res.push_str(\"0\");\n\
    \    }\n    if res.len() < 2 {\n        res.push_str(&format!(\"0{}\", res[1..]));\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::fmt`\n  --> /tmp/tmp738rthut.rs:11:9\n  \
    \ |\n11 |     use std::fmt;\n   |         ^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nwarning: unused import: `std::str::FromStr`\n  --> /tmp/tmp738rthut.rs:12:9\n\
    \   |\n12 |     use std::str::FromStr;\n   |         ^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ `isize` is not an iterator\n  --> /tmp/tmp738rthut.rs:17:26\n   |\n17 |    \
    \ for i in digits_iter.cloned() {\n   |                          ^^^^^^ `isize`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `isize: Iterator`\n           which is required by `&mut isize: Iterator`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp738rthut.rs:19:16\n   |\n19 |\
    \         if d < base {\n   |                ^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if d < base.try_into().unwrap() {\n  \
    \ |                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp738rthut.rs:26:33\n   |\n26 |             let mut digit = d - base;\n\
    \   |                                 ^^^^ expected `usize`, found `isize`\n\n\
    error[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmp738rthut.rs:26:31\n\
    \   |\n26 |             let mut digit = d - base;\n   |                      \
    \         ^ no implementation for `usize - isize`\n   |\n   = help: the trait\
    \ `Sub<isize>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n    \
    \         <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n      \
    \       <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n          \
    \   <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a\
    \ isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp738rthut.rs:27:29\n   |\n27 |             digit = digit % base;\n\
    \   |                             ^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot mod `usize` by `is"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    for i in x.checked_div(base).unwrap()\
    \ {\n        if i > '9' {\n            s += '0';\n        }\n        s += char::from(*i).unwrap();\n\
    \    }\n    if base > 10 && x.checked_mod(base).unwrap() > 0 {\n        if s ==\
    \ '0' {\n            s = '1';\n        } else if s.is_empty() {\n            s\
    \ = \"1\";\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: `isize` is not an iterator\n  --> /tmp/tmpf433x53w.rs:12:14\n\
    \   |\n12 |     for i in x.checked_div(base).unwrap() {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `isize` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `isize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf433x53w.rs:14:18\n\
    \   |\n14 |             s += '0';\n   |                  ^^^ expected `&str`,\
    \ found `char`\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n14 |             s += \"0\";\n   |                  ~~~\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmpf433x53w.rs:16:29\n\
    \   |\n16 |         s += char::from(*i).unwrap();\n   |                      \
    \       ^^^^^^ method not found in `char`\n\nerror[E0599]: no method named `checked_mod`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpf433x53w.rs:18:23\n\
    \   |\n18 |     if base > 10 && x.checked_mod(base).unwrap() > 0 {\n   |     \
    \                  ^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `checked_add`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf433x53w.rs:20:17\n\
    \   |\n11 |     let mut s = String::new();\n   |                 -------------\
    \ expected due to this value\n...\n20 |             s = '1';\n   |           \
    \      ^^^- help: try using a conversion method: `.to_string()`\n   |        \
    \         |\n   |                 expected struct `String`, found `char`\n\nerror[E0277]:\
    \ can't compare `String` with `char`\n  --> /tmp/tmpf433x53w.rs:19:14\n   |\n\
    19 |         if s == '0' {\n   |              ^^ no implementation for `String\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    match base {\n        2 => x.to_string(),\n        3 => x.to_string()\
    \ + &\"11\",\n        _ => match x.checked_mul(base) {\n            Some(m) =>\
    \ m.to_string(),\n            None => x.to_string(),\n        },\n    }\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"811\"`,\n right: `\"22\"`', /tmp/tmpy5yzcy86.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut remainder = x;\n    let mut i\
    \ = 1;\n    while remainder >= base {\n        remainder -= base;\n        i +=\
    \ 1;\n    }\n    s += i.to_string();\n    while remainder > 0 {\n        remainder\
    \ -= base;\n        i += 1;\n        s += i.to_string();\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplrr_w6u5.rs:18:10\n   |\n\
    18 |     s += i.to_string();\n   |          ^^^^^^^^^^^^^\n   |          |\n \
    \  |          expected `&str`, found struct `String`\n   |          help: consider\
    \ borrowing here: `&i.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplrr_w6u5.rs:22:14\n\
    \   |\n22 |         s += i.to_string();\n   |              ^^^^^^^^^^^^^\n   |\
    \              |\n   |              expected `&str`, found struct `String`\n \
    \  |              help: consider borrowing here: `&i.to_string()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut base = [0u8; 16];\n    base[base]\
    \ = 1;\n    for &b in &base {\n        if b & 1 != 0 {\n            res.push_str(&format!(\"\
    {}\", x));\n            return res;\n        }\n        res.push_str(&format!(\"\
    {}\", x * b));\n    }\n    res.push_str(&format!(\"{}\", x));\n    return res;\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[u8]` cannot be indexed by `[u8; 16]`\n  --> /tmp/tmpch1bjcz3.rs:13:5\n\
    \   |\n13 |     base[base] = 1;\n   |     ^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>`\
    \ is not implemented for `[u8; 16]`\n   = note: required because of the requirements\
    \ on the impl of `Index<[u8; 16]>` for `[u8]`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpch1bjcz3.rs:19:41\n   |\n19 |         res.push_str(&format!(\"\
    {}\", x * b));\n   |                                         ^ expected `isize`,\
    \ found `u8`\n\nerror[E0277]: cannot multiply `isize` by `u8`\n  --> /tmp/tmpch1bjcz3.rs:19:39\n\
    \   |\n19 |         res.push_str(&format!(\"{}\", x * b));\n   |             \
    \                          ^ no implementation for `isize * u8`\n   |\n   = help:\
    \ the trait `Mul<u8>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n\
    \             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n  \
    \           <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n      \
    \       <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n            \
    \ <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut buff = String::new();\n    let mut num = x as isize;\n    let\
    \ mut base: i32 = base as i32;\n    while num > 0 {\n        buff.push(num % base\
    \ as char);\n        num /= base;\n    }\n    buff\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `isize` by `char`\n  --> /tmp/tmpz77345rs.rs:15:23\n\
    \   |\n15 |         buff.push(num % base as char);\n   |                     \
    \  ^ no implementation for `isize % char`\n   |\n   = help: the trait `Rem<char>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz77345rs.rs:16:16\n\
    \   |\n16 |         num /= base;\n   |                ^^^^ expected `isize`, found\
    \ `i32`\n\nerror[E0277]: cannot divide-assign `isize` by `i32`\n  --> /tmp/tmpz77345rs.rs:16:13\n\
    \   |\n16 |         num /= base;\n   |             ^^ no implementation for `isize\
    \ /= i32`\n   |\n   = help: the trait `DivAssign<i32>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `DivAssign<Rhs>`:\n\
    \             <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n    \
    \         <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n        \
    \     <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n         \
    \    <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and\
    \ 20 others\n\nerror[E0604]: only `u8` can be cast as `char`, not `i32`\n  -->\
    \ /tmp/tmpz77345rs.rs:15:25\n   |\n15 |         buff.push(num % base as char);\n\
    \   |                         ^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmpz77345rs.rs:15:25\n   |\n15 |         buff.push(num\
    \ % base as char);\n   |                         ^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0604.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 2 {\n        format!(\"{}\", x)\n    } else {\n        let\
    \ mut s = format!(\"{}\", x);\n        if s.len() <= base {\n            return\
    \ s;\n        }\n\n        let mut base10 = String::new();\n        base10.push_str(\"\
    0\".to_string());\n        base10.push_str(&s[..base]);\n\n        let mut digits\
    \ = String::new();\n        while let Some(digit) = base10.chars().nth(0) {\n\
    \            let d = base10.chars().nth(1).unwrap();\n            if let Some(d)\
    \ = d {\n                if digit > d {\n                    digits.push_str(&digits[..d\
    \ - digit]);\n                    break;\n                } else {\n         \
    \           digits.push_str(&digits[..digit - d]);\n                }\n      \
    \      }\n        }\n        digits.push_str(&base10.chars().nth(base).unwrap());\n\
    \n        s\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3qhq8y3g.rs:15:23\n   |\n\
    15 |         if s.len() <= base {\n   |                       ^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n15 |         if s.len() <= base.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3qhq8y3g.rs:20:25\n   |\n20 |         base10.push_str(\"\
    0\".to_string());\n   |                         ^^^^^^^^^^^^^^^\n   |        \
    \                 |\n   |                         expected `&str`, found struct\
    \ `String`\n   |                         help: consider borrowing here: `&\"0\"\
    .to_string()`\n\nerror[E0277]: the type `String` cannot be indexed by `RangeTo<isize>`\n\
    \  --> /tmp/tmp3qhq8y3g.rs:21:26\n   |\n21 |         base10.push_str(&s[..base]);\n\
    \   |                          ^^^^^^^^^ `String` cannot be indexed by `RangeTo<isize>`\n\
    \   |\n   = help: the trait `Index<RangeTo<isize>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3qhq8y3g.rs:26:20\n\
    \   |\n26 |             if let Some(d) = d {\n   |                    ^^^^^^^\
    \   - this expression has type `char`\n   |                    |\n   |       \
    \             expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<_>`\n\nerror[E0369]: cannot subtract\
    \ `char` from `char`\n  --> /tmp/tmp3qhq8y3g.rs:28:49\n   |\n28 |            \
    \         digits.push_str(&digits[..d - digit]);\n   |                       \
    \                        - ^ ----- char\n   |                                \
    \               |\n   |      "
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut carry = 0;\n    let mut cur_base\
    \ = 1;\n    for &c in x.to_string().chars() {\n        let num = c as u32;\n \
    \       let digit = num / cur_base;\n        res.push_str(digit.to_string());\n\
    \        res.push_str(\"0123456789ABCDEF\".chars()[digit % base].to_string());\n\
    \        cur_base *= base;\n        carry += cur_base;\n    }\n    if carry >\
    \ 0 {\n        res.push_str(\"1\".chars()[carry % base].to_string());\n    }\n\
    \    res.trim()\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpov3s6nzl.rs:14:9\n   |\n\
    14 |     for &c in x.to_string().chars() {\n   |         ^^    ---------------------\
    \ this expression has type `Option<char>`\n   |         |\n   |         expected\
    \ `char`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `c`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpov3s6nzl.rs:17:22\n  \
    \ |\n17 |         res.push_str(digit.to_string());\n   |                     \
    \ ^^^^^^^^^^^^^^^^^\n   |                      |\n   |                      expected\
    \ `&str`, found struct `String`\n   |                      help: consider borrowing\
    \ here: `&digit.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpov3s6nzl.rs:18:57\n\
    \   |\n18 |         res.push_str(\"0123456789ABCDEF\".chars()[digit % base].to_string());\n\
    \   |                                                         ^^^^ expected `u32`,\
    \ found `isize`\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n\
    \  --> /tmp/tmpov3s6nzl.rs:18:22\n   |\n18 |         res.push_str(\"0123456789ABCDEF\"\
    .chars()[digit % base].to_string());\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0277]: cannot mod `u32` by `isize`\n  --> /tmp/tmpov3s6nzl.rs:18:55\n\
    \   |\n18 |         res.push_str(\"0123456789ABCDEF\".chars()[digit % base].to_string());\n\
    \   |                                                       ^ no implementation\
    \ for `u32 % isize`\n   |\n   = help: the trait `Rem<isize>` is not implemented\
    \ for `u32`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpov3s6nzl.rs:19:21\n\
    \   |\n19 |         cur_base *= base;\n   |                     ^^^^ expec"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    x.to_string(base)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpp94wo5a0.rs:11:7\n     |\n11   |     x.to_string(base)\n    \
    \ |       ^^^^^^^^^ ---- supplied 1 argument\n     |       |\n     |       expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut xs = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ xs_len = xs.len();\n    for i in 1..base {\n        xs_len -= i;\n        xs.truncate(xs_len);\n\
    \    }\n    let mut xs_str = xs.iter().map(|x| format!(\"{:0>{}}\", x, i).to_string()).collect::<String>();\n\
    \    xs_str.push(xs.last().unwrap());\n    xs_str.push('0');\n    xs_str.push('0');\n\
    \    xs_str.push('1');\n    let mut xs_str_result = String::new();\n    xs_str_result.push_str(&xs_str);\n\
    \    xs_str_result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpkon7dyyh.rs:17:53\n\
    \   |\n17 |     let mut xs_str = xs.iter().map(|x| format!(\"{:0>{}}\", x, i).to_string()).collect::<String>();\n\
    \   |                                                 -   ^ expected `}` in format\
    \ string\n   |                                                 |\n   |       \
    \                                          because of this opening brace\n   |\n\
    \   = note: if you intended to print `{`, you can escape it using `{{`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkon7dyyh.rs:14:19\n   |\n14 |         xs_len\
    \ -= i;\n   |                   ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot subtract-assign `isize` from `usize`\n  --> /tmp/tmpkon7dyyh.rs:14:16\n\
    \   |\n14 |         xs_len -= i;\n   |                ^^ no implementation for\
    \ `usize -= isize`\n   |\n   = help: the trait `SubAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `SubAssign<Rhs>`:\n\
    \             <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n    \
    \         <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n        \
    \     <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n         \
    \    <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkon7dyyh.rs:18:17\n\
    \   |\n18 |     xs_str.push(xs.last().unwrap());\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n18 |     xs_str.push(*xs.last().unwrap());\n   |                 +\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut num: isize = x;\n    let mut power: isize = 1;\n    while num\
    \ > 0 {\n        let mod = num % base;\n        num = (num - mod) / base;\n  \
    \      power *= base;\n    }\n    let mut result = [0; base + 1];\n    for _ in\
    \ 0..base {\n        result[result.len() - 1] = (num % base) as u8;\n        num\
    \ /= base;\n    }\n    if base < 2 {\n        for _ in 0..(base - 1) {\n     \
    \       result.push(0);\n        }\n    }\n    format!(\"{}\", &result[base..]).to_string()\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `mod`\n  --> /tmp/tmp2idn53tu.rs:14:13\n\
    \   |\n14 |         let mod = num % base;\n   |             ^^^ expected identifier,\
    \ found keyword\n   |\nhelp: escape `mod` to use it as an identifier\n   |\n14\
    \ |         let r#mod = num % base;\n   |             ++\n\nerror: expected expression,\
    \ found keyword `mod`\n  --> /tmp/tmp2idn53tu.rs:15:22\n   |\n15 |         num\
    \ = (num - mod) / base;\n   |                      ^^^ expected expression\n\n\
    error[E0435]: attempt to use a non-constant value in a constant\n  --> /tmp/tmp2idn53tu.rs:18:26\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                ---- this would need to be a `const`\n...\n18 |     let mut result\
    \ = [0; base + 1];\n   |                          ^^^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0435`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut x = x;\n    let mut base = 10;\n\n    while x >= base {\n   \
    \     x -= base;\n    }\n\n    while x >= 10 {\n        x /= 10;\n        x +=\
    \ 1;\n    }\n\n    let mut y = x;\n    while y > base {\n        y -= base;\n\
    \    }\n\n    format!(\"{}\", y)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"8\"`,\n right: `\"22\"`', /tmp/tmptf75v3c9.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 10 {\n        format!(\"{:0>3o}\", x * base).to_string()\n\
    \    } else {\n        format!(\"{:0>4o}\", x).to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"030\"`,\n right: `\"22\"`', /tmp/tmpmr7ji5x_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut i = x;\n\n    while i >\
    \ 0 {\n        result += format!(\"{}\", i / base);\n        i %= base;\n    }\n\
    \n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzsj7ikxq.rs:15:19\n   |\n\
    15 |         result += format!(\"{}\", i / base);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    fn to_base(base: isize, num: isize)\
    \ -> String {\n        let mut s = String::new();\n        let mut n = num;\n\
    \        loop {\n            if n == 0 {\n                break;\n           \
    \ }\n            s.push_str(&(n % base).to_string());\n            n /= base;\n\
    \        }\n        s\n    }\n    while x > 0 {\n        let mut s = to_base(base,\
    \ x);\n        res.push_str(&s);\n        x /= base;\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpyj622ile.rs:25:13\n\
    \   |\n25 |         let mut s = to_base(base, x);\n   |             ----^\n  \
    \ |             |\n   |             help: remove this `mut`\n   |\n   = note:\
    \ `#[warn(unused_mut)]` on by default\n\nerror[E0384]: cannot assign to immutable\
    \ argument `x`\n  --> /tmp/tmpyj622ile.rs:27:9\n   |\n10 | fn change_base(x: isize,\
    \ base: isize) -> String {\n   |                - help: consider making this binding\
    \ mutable: `mut x`\n...\n27 |         x /= base;\n   |         ^^^^^^^^^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut remaining = x;\n\n    while\
    \ remaining > 0 {\n        if remaining >= base {\n            res += &format!(\"\
    {}\", remaining / base);\n            res += &format!(\"{}\", remaining % base);\n\
    \            res += &format!(\".\");\n        } else {\n            res += &format!(\"\
    {}\", remaining);\n        }\n\n        remaining -= base;\n    }\n\n    res\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"22.12.2\"`,\n right: `\"22\"`', /tmp/tmpsl8th5mg.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut temp = 1;\n    while x >\
    \ 0 {\n        let digit = x % base;\n        temp = temp * base + digit;\n  \
    \      x = x / base;\n        result.push(digit as char);\n    }\n    result.push((temp\
    \ % base) as char);\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpk0tewix0.rs:17:21\n\
    \   |\n17 |         result.push(digit as char);\n   |                     ^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpk0tewix0.rs:17:21\n   |\n17 |         result.push(digit as char);\n\
    \   |                     ^^^^^^^^^^^^^\n\nerror[E0604]: only `u8` can be cast\
    \ as `char`, not `isize`\n  --> /tmp/tmpk0tewix0.rs:19:17\n   |\n19 |     result.push((temp\
    \ % base) as char);\n   |                 ^^^^^^^^^^^^^^^^^^^^^ invalid cast\n\
    \   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpk0tewix0.rs:19:17\n\
    \   |\n19 |     result.push((temp % base) as char);\n   |                 ^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0604`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 10 {\n        return format!(\"{}\", x%base) as String;\n \
    \   }\n\n    let mut digits = Vec::new();\n    digits.reserve(10);\n    for digit\
    \ in base..10 {\n        let mut remainder = x % digit;\n        if remainder\
    \ > 0 {\n            digits.insert(0, remainder);\n        }\n        x = x /\
    \ digit;\n    }\n    if x != 0 {\n        digits.insert(0, x);\n    }\n    digits.into_iter().map(|x|\
    \ format!(\"{}\", x)).collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpa1mxti3m.rs:18:13\n\
    \   |\n18 |         let mut remainder = x % digit;\n   |             ----^^^^^^^^^\n\
    \   |             |\n   |             help: remove this `mut`\n   |\n   = note:\
    \ `#[warn(unused_mut)]` on by default\n\nerror[E0384]: cannot assign to immutable\
    \ argument `x`\n  --> /tmp/tmpa1mxti3m.rs:22:9\n   |\n10 | fn change_base(x: isize,\
    \ base: isize) -> String {\n   |                - help: consider making this binding\
    \ mutable: `mut x`\n...\n22 |         x = x / digit;\n   |         ^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut number = x;\n    let mut\
    \ base = 10;\n    while number > 0 {\n        let digit = number % base;\n   \
    \     number /= base;\n        result.push((digit + '0') as char);\n    }\n  \
    \  if number < base {\n        let mut digits = base.to_string();\n        digits.push(digits[digits.len()\
    \ - 1] + '1');\n        result.push_str(&digits[..]);\n    } else {\n        result.push_str(&'0');\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add `char` to `isize`\n  --> /tmp/tmpvdzgoy2v.rs:17:28\n\
    \   |\n17 |         result.push((digit + '0') as char);\n   |                \
    \            ^ no implementation for `isize + char`\n   |\n   = help: the trait\
    \ `Add<char>` is not implemented for `isize`\n   = help: the following other types\
    \ implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n          \
    \   <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n            \
    \ <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a\
    \ i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n             <&'a isize\
    \ as Add<isize>>\n           and 48 others\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpvdzgoy2v.rs:21:21\n   |\n21 |  \
    \       digits.push(digits[digits.len() - 1] + '1');\n   |                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvdzgoy2v.rs:24:25\n   |\n24 |         result.push_str(&'0');\n\
    \   |                         ^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut base = base;\n    let mut\
    \ x = x; // don't mutate x in case it needs more digits\n    loop {\n        if\
    \ x >= base {\n            result.push((base as char).to_string());\n        \
    \    base += 1;\n            x = x / base;\n        } else {\n            result.push((x\
    \ % base as char).to_string());\n            x = x;\n        }\n        if x ==\
    \ 0 {\n            break;\n        }\n    }\n    result.reverse();\n    result.to_string()\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpot1mzmda.rs:16:25\n   |\n\
    16 |             result.push((base as char).to_string());\n   |              \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0277]: cannot mod `isize` by `char`\n  --> /tmp/tmpot1mzmda.rs:20:28\n\
    \   |\n20 |             result.push((x % base as char).to_string());\n   |   \
    \                         ^ no implementation for `isize % char`\n   |\n   = help:\
    \ the trait `Rem<char>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0599]: no method\
    \ named `reverse` found for struct `String` in the current scope\n  --> /tmp/tmpot1mzmda.rs:27:12\n\
    \   |\n27 |     result.reverse();\n   |            ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror[E0604]: only `u8` can be cast\
    \ as `char`, not `isize`\n  --> /tmp/tmpot1mzmda.rs:16:25\n   |\n16 |        \
    \     result.push((base as char).to_string());\n   |                         ^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpot1mzmda.rs:16:25\n   |\n16 |             result.push((base as char).to_string());\n\
    \   |                         ^^^^^^^^^^^^^^\n\nerror[E0604]: only `u8` can be\
    \ cast as `char`, not `isize`\n  --> /tmp/tmpot1mzmda.rs:20:30\n   |\n20 |   \
    \          result.push((x % base as char).to_string());\n   |                \
    \              ^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32` instead\
    \ (via a `u32`)\n  --> /tmp/tmpot1mzmda.rs:20:30\n   |\n20 |             result.push((x\
    \ % base as char).to_string());\n   |                              ^^^^^^^^^^^^\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E059"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if x != 0 && base > 9 {\n        panic!(\"change base must not exceed\
    \ base 9\");\n    }\n\n    let mut result: String = String::new();\n    let mut\
    \ xdigits = x % base;\n\n    // Loop to build up result string\n    while xdigits\
    \ != 0 {\n        if xdigits >= base {\n            result.push((xdigits as u8)\
    \ + base);\n            xdigits = xdigits - base;\n        } else {\n        \
    \    result.push(xdigits);\n        }\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3atg2e6y.rs:21:43\n   |\n\
    21 |             result.push((xdigits as u8) + base);\n   |                  \
    \                         ^^^^ expected `u8`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3atg2e6y.rs:21:25\n   |\n21 |             result.push((xdigits\
    \ as u8) + base);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0277]: cannot add `isize` to `u8`\n  --> /tmp/tmp3atg2e6y.rs:21:41\n\
    \   |\n21 |             result.push((xdigits as u8) + base);\n   |           \
    \                              ^ no implementation for `u8 + isize`\n   |\n  \
    \ = help: the trait `Add<isize>` is not implemented for `u8`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3atg2e6y.rs:24:25\n   |\n24 |             result.push(xdigits);\n\
    \   |                         ^^^^^^^ expected `char`, found `isize`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    assert!((base < 10) && (base > 0));\n    let mut res = String::new();\n\
    \    while x > 0 {\n        if x % base == 0 {\n            res += '0';\n    \
    \    } else {\n            res += '1';\n        }\n        x /= base;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvakgbzhs.rs:15:20\n   |\n\
    15 |             res += '0';\n   |                    ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n15 |             res += \"0\";\n   |                    ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvakgbzhs.rs:17:20\n   |\n17 |             res\
    \ += '1';\n   |                    ^^^ expected `&str`, found `char`\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n17 |       \
    \      res += \"1\";\n   |                    ~~~\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if x > 10 {\n        convert_base(x, base)\n    } else {\n        x.to_base().to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `convert_base` in this scope\n  -->\
    \ /tmp/tmp6tpaxt19.rs:12:9\n   |\n12 |         convert_base(x, base)\n   |   \
    \      ^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_base`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmp6tpaxt19.rs:14:11\n\
    \   |\n14 |         x.to_base().to_string()\n   |           ^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_be`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut base_str = &[base.to_string()[..]];\n\
    \    let mut x = x;\n    while x.is_positive() {\n        let r = base_str.chars().nth(x\
    \ as usize).unwrap();\n        if r != '.' {\n            result = result\n  \
    \              .to_string()\n                .to_string()\n                .insert(x\
    \ as usize, r);\n        }\n        x = x * base as isize;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for reference `&[str; 1]` in\
    \ the current scope\n  --> /tmp/tmp6lsksayg.rs:15:26\n   |\n15 |         let r\
    \ = base_str.chars().nth(x as usize).unwrap();\n   |                         \
    \ ^^^^^ method not found in `&[str; 1]`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6lsksayg.rs:17:22\n   |\n11 |       let mut result = String::new();\n\
    \   |                        ------------- expected due to this value\n...\n17\
    \ |               result = result\n   |  ______________________^\n18 | |     \
    \            .to_string()\n19 | |                 .to_string()\n20 | |       \
    \          .insert(x as usize, r);\n   | |______________________________________^\
    \ expected struct `String`, found `()`\n   |\nnote: method `insert` modifies its\
    \ receiver in-place\n  --> /tmp/tmp6lsksayg.rs:20:18\n   |\n17 |             \
    \  result = result\n   |  ______________________-\n18 | |                 .to_string()\n\
    19 | |                 .to_string()\n   | |____________________________- you probably\
    \ want to use this value after calling the method...\n20 |                   .insert(x\
    \ as usize, r);\n   |                    ^^^^^^ this call modifies its receiver\
    \ in-place\n   = note: ...instead of the `()` output of method `insert`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    // check base is between 2 and 10\n    let mut result = (x as u64 / (10\
    \ as u64)) as String;\n\n    // if base is smaller than 2 then append zeroes on\
    \ right\n    if base < 2 {\n        result = format!(\"{}0\", &result);\n    }\n\
    \n    // convert base to string and append character by character\n    let mut\
    \ basestr = String::new();\n    basestr.push_str(&base);\n\n    let mut result\
    \ = String::new();\n    while !result.is_empty() {\n        if result.len() <\
    \ basestr.len() {\n            result.push_str(&basestr);\n        } else {\n\
    \            result.push_str(&result[..basestr.len()]);\n            break;\n\
    \        }\n    }\n\n    // return result\n    result\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsytf5iby.rs:21:22\n   |\n\
    21 |     basestr.push_str(&base);\n   |                      ^^^^^ expected `str`,\
    \ found `isize`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&isize`\n\nerror[E0605]: non-primitive cast: `u64` as `String`\n\
    \  --> /tmp/tmpsytf5iby.rs:12:22\n   |\n12 |     let mut result = (x as u64 /\
    \ (10 as u64)) as String;\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ an `as` expression can only be used to convert between primitive types or to\
    \ coerce to a specific trait object\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0605.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    for i in base.touclen() {\n    \
    \    if i as usize == 0 {\n            break;\n        }\n        let mut digit\
    \ = x\n            % base\n            .pow(i as usize - 1);\n        x /= base;\n\
    \        result.push(digit.to_string());\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `touclen` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpvsa9_d7y.rs:12:19\n   |\n12 |     for i in base.touclen()\
    \ {\n   |                   ^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_le`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvsa9_d7y.rs:18:18\n\
    \   |\n18 |             .pow(i as usize - 1);\n   |                  ^^^^^^^^^^^^^^\
    \ expected `u32`, found `usize`\n   |\nhelp: you can convert a `usize` to a `u32`\
    \ and panic if the converted value doesn't fit\n   |\n18 |             .pow((i\
    \ as usize - 1).try_into().unwrap());\n   |                  +              +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvsa9_d7y.rs:20:21\n   |\n20 |\
    \         result.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = '0';\n    let mut digits = String::new();\n    let mut\
    \ num = 1;\n    let mut pos = 0;\n    while num > 0 {\n        while num % base\
    \ == 0 && pos < digits.size() {\n            result[pos] = '0';\n            pos\
    \ += 1;\n        }\n        if num % base != 0 {\n            result[pos] = char::from_u32(num\
    \ % base).unwrap();\n            pos += 1;\n        }\n        num /= base;\n\
    \    }\n    while pos < digits.size() {\n        result[pos] = '0';\n        pos\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpqa8sfhgt.rs:16:47\n   |\n16 |         while num % base\
    \ == 0 && pos < digits.size() {\n   |                                        \
    \       ^^^^ method not found in `String`\n\nerror[E0608]: cannot index into a\
    \ value of type `char`\n  --> /tmp/tmpqa8sfhgt.rs:17:13\n   |\n17 |          \
    \   result[pos] = '0';\n   |             ^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `char`\n  --> /tmp/tmpqa8sfhgt.rs:21:13\n   |\n21 |   \
    \          result[pos] = char::from_u32(num % base).unwrap();\n   |          \
    \   ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa8sfhgt.rs:21:42\n\
    \   |\n21 |             result[pos] = char::from_u32(num % base).unwrap();\n \
    \  |                                          ^^^^^^^^^^ expected `u32`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if the\
    \ converted value doesn't fit\n   |\n21 |             result[pos] = char::from_u32((num\
    \ % base).try_into().unwrap()).unwrap();\n   |                               \
    \           +          +++++++++++++++++++++\n\nerror[E0599]: no method named\
    \ `size` found for struct `String` in the current scope\n  --> /tmp/tmpqa8sfhgt.rs:26:24\n\
    \   |\n26 |     while pos < digits.size() {\n   |                        ^^^^\
    \ method not found in `String`\n\nerror[E0608]: cannot index into a value of type\
    \ `char`\n  --> /tmp/tmpqa8sfhgt.rs:27:9\n   |\n27 |         result[pos] = '0';\n\
    \   |         ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqa8sfhgt.rs:30:5\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n30 |     result\n   |     ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `char`\n\nerror: aborting\
    \ due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut pow = x.pow(base);\n\n    for\
    \ _ in 0..(pow/x) {\n        res.insert(0, ('0' + x.mod_pow(base, &mut pow).unwrap()));\n\
    \        pow = pow.mod_mul(&base, &pow).unwrap();\n    }\n    res.insert(0, x.mod_pow(base,\
    \ &mut pow).unwrap());\n    res\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmp8cnvd6bv.rs:15:23\n\
    \   |\n15 |         res.insert(0, ('0' + x.mod_pow(base, &mut pow).unwrap()));\n\
    \   |                       ^                                        ^\n   |\n\
    \   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n15 -         res.insert(0, ('0' + x.mod_pow(base, &mut pow).unwrap()));\n\
    15 +         res.insert(0, '0' + x.mod_pow(base, &mut pow).unwrap());\n   | \n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8cnvd6bv.rs:12:25\n   |\n12 |\
    \     let mut pow = x.pow(base);\n   |                         ^^^^ expected `u32`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if\
    \ the converted value doesn't fit\n   |\n12 |     let mut pow = x.pow(base.try_into().unwrap());\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `mod_pow` found for type `isize` in the current scope\n  --> /tmp/tmp8cnvd6bv.rs:15:32\n\
    \   |\n15 |         res.insert(0, ('0' + x.mod_pow(base, &mut pow).unwrap()));\n\
    \   |                                ^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `mod_mul` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp8cnvd6bv.rs:16:19\n   |\n16 |         pow = pow.mod_mul(&base, &pow).unwrap();\n\
    \   |                   ^^^^^^^ method not found in `isize`\n\nerror[E0599]: no\
    \ method named `mod_pow` found for type `isize` in the current scope\n  --> /tmp/tmp8cnvd6bv.rs:18:21\n\
    \   |\n18 |     res.insert(0, x.mod_pow(base, &mut pow).unwrap());\n   |     \
    \                ^^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut y = x.to_dec().unwrap();\n    if base > 10 {\n        y /= base;\n\
    \    }\n    String::from_dec(x).unwrap() * &base + &y\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_dec` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp_dop7tos.rs:11:19\n   |\n11 |     let mut y = x.to_dec().unwrap();\n\
    \   |                   ^^^^^^ help: there is an associated function with a similar\
    \ name: `to_be`\n\nerror[E0599]: no function or associated item named `from_dec`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp_dop7tos.rs:15:13\n\
    \   |\n15 |     String::from_dec(x).unwrap() * &base + &y\n   |             ^^^^^^^^\
    \ function or associated item not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    format!(\"{}{}\", &x.to_digits(base).collect::<Vec<String>>().join(\"\
    \"), &base)\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmps28y_kd_.rs:11:24\n   |\n11 |     format!(\"{}{}\"\
    , &x.to_digits(base).collect::<Vec<String>>().join(\"\"), &base)\n   |       \
    \                 ^^^^^^^^^ method not found in `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::new();\n    let mut digits = Vec::new();\n \
    \   for i in x.to_digits(base).rev() {\n        if i > 0 {\n            result.append(&digits[i\
    \ - 1]);\n        }\n        result.append(&i.to_string());\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpqwvcqay3.rs:13:16\n   |\n13 |     for i in x.to_digits(base).rev()\
    \ {\n   |                ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpqwvcqay3.rs:15:20\n   |\n15 |             result.append(&digits[i -\
    \ 1]);\n   |                    ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpqwvcqay3.rs:17:16\n   |\n17 |         result.append(&i.to_string());\n\
    \   |                ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::from(\"0\");\n\n    for i in 1..base {\n   \
    \     result = format!(\"{}{}\", result.clone(), x.to_string());\n    }\n\n  \
    \  result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"088\"`,\n right: `\"22\"`', /tmp/tmpapx0h9me.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut string = \"\";\n    let mut remainder = x;\n    let mut new_remainder\
    \ = 0;\n    let mut power = 1;\n    while remainder != 0 {\n        new_remainder\
    \ *= base;\n        new_remainder += remainder % base;\n        remainder = (remainder\
    \ / base).into();\n        power = 1;\n        while power < base {\n        \
    \    string.append(&format!(\"{}\", new_remainder));\n            new_remainder\
    \ *= base;\n            power = power + 1;\n        }\n    }\n    string\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmp4qjzlwfv.rs:21:20\n   |\n21 |             string.append(&format!(\"\
    {}\", new_remainder));\n   |                    ^^^^^^ method not found in `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4qjzlwfv.rs:26:5\n   |\n10 | fn\
    \ change_base(x: isize, base: isize) -> String {\n   |                       \
    \                   ------ expected `String` because of return type\n...\n26 |\
    \     string\n   |     ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    let mut v = x;\n    loop {\n        if\
    \ v == 0 { break; }\n        match v % base {\n            0 => s += &'0',\n \
    \           1 => s += &'1',\n            _ => {\n                let i = v / base;\n\
    \                v = v;\n                s += &(i as isize).to_string();\n   \
    \         }\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnzyqct2k.rs:16:23\n   |\n\
    16 |             0 => s += &'0',\n   |                       ^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnzyqct2k.rs:17:23\n\
    \   |\n17 |             1 => s += &'1',\n   |                       ^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut result = String::with_capacity(x.to_string().len() * base.to_string().len());\n\
    \    let mut i = x.to_digits();\n    let mut j = base.to_digits();\n\n    while\
    \ i.len() > 0 && j.len() > 0 {\n        if i.pop() > j.pop() {\n            result\
    \ += &base[j.len() - 1];\n        } else {\n            result += &base[i.len()\
    \ - 1];\n        }\n    }\n\n    for i in i {\n        result += &base[i];\n \
    \   }\n\n    result.to_owned()\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpawzl6b16.rs:12:19\n   |\n12 |     let mut i = x.to_digits();\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpawzl6b16.rs:13:22\n   |\n13 |     let mut j = base.to_digits();\n  \
    \ |                      ^^^^^^^^^ method not found in `isize`\n\nerror[E0608]:\
    \ cannot index into a value of type `isize`\n  --> /tmp/tmpawzl6b16.rs:24:20\n\
    \   |\n24 |         result += &base[i];\n   |                    ^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    for i in x.iter() {\n        if i ==\
    \ 0 {\n            s += \"0\";\n        } else {\n            match i {\n    \
    \            0 => s += \"0\",\n                1 => s += \"1\",\n            \
    \    _ => s += String::from_str(&format!(\"{:?}\", i).as_str()).unwrap().to_uppercase(),\n\
    \            }\n        }\n    }\n    &s[..]\n        .to_string(base)\n     \
    \   .to_string()\n        .replacen(\n            &s[..],\n            \"0\",\n\
    \            &format!(\"{:?}\", x).as_str(),\n            |m| m.chars().next().unwrap().to_string(),\n\
    \        );\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp5yta7f5w.rs:12:16\n   |\n12 |     for i in x.iter() {\n\
    \   |                ^^^^ method not found in `isize`\n\nerror[E0599]: no function\
    \ or associated item named `from_str` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp5yta7f5w.rs:19:35\n   |\n19 |                 _ => s +=\
    \ String::from_str(&format!(\"{:?}\", i).as_str()).unwrap().to_uppercase(),\n\
    \   |                                   ^^^^^^^^ function or associated item not\
    \ found in `String`\n   |\n   = help: items from traits can only be used if the\
    \ trait is in scope\nhelp: the following trait is implemented but not in scope;\
    \ perhaps add a `use` for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmp5yta7f5w.rs:24:10\n\
    \     |\n24   |         .to_string(base)\n     |          ^^^^^^^^^ ---- supplied\
    \ 1 argument\n     |          |\n     |          expected 0 arguments\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 3\
    \ arguments but 4 arguments were supplied\n   --> /tmp/tmp5yta7f5w.rs:26:10\n\
    \    |\n26  |         .replacen(\n    |          ^^^^^^^^ expected 3 arguments\n\
    27  |             &s[..],\n    |             ------\n28  |             \"0\",\n\
    \    |             ---\n29  |             &format!(\"{:?}\", x).as_str(),\n  \
    \  |             ----------------------------\n30  |             |m| m.chars().next().unwrap().to_string(),\n\
    \    |             ----------------------------------------- supplied 4 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5yta7f5w.rs:10:42\n   |\n10 | fn change_base(x: isize, base: isize)\
    \ -> String {\n   |    -----------                           ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information\
    \ about a"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::from(\"0\");\n    for i in 0..base {\n        let\
    \ n = x % base;\n        res.insert(0, char::from_u32(n).unwrap().to_string());\n\
    \        x = x / base;\n    }\n    res.insert(0, x);\n    res\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptf3lmvyj.rs:14:38\n   |\n\
    14 |         res.insert(0, char::from_u32(n).unwrap().to_string());\n   |    \
    \                                  ^ expected `u32`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `u32` and panic if the converted value doesn't\
    \ fit\n   |\n14 |         res.insert(0, char::from_u32(n.try_into().unwrap()).unwrap().to_string());\n\
    \   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptf3lmvyj.rs:14:23\n   |\n14 |         res.insert(0,\
    \ char::from_u32(n).unwrap().to_string());\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmptf3lmvyj.rs:17:19\n   |\n17 |     res.insert(0, x);\n   |      \
    \             ^ expected `char`, found `isize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::new();\n    let mut cur = x;\n    let mut tmp =\
    \ base as isize;\n    while tmp > 0 {\n        res.push_str(&to_base(&cur, &tmp));\n\
    \        cur /= tmp;\n        tmp = base as isize;\n    }\n    res.push_str(&to_base(&cur,\
    \ &tmp));\n    res\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_base` in this scope\n  --> /tmp/tmp47u1y6yv.rs:15:23\n\
    \   |\n15 |         res.push_str(&to_base(&cur, &tmp));\n   |                \
    \       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `to_base` in this scope\n  --> /tmp/tmp47u1y6yv.rs:19:19\n   |\n19 |     res.push_str(&to_base(&cur,\
    \ &tmp));\n   |                   ^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::from(\"0\");\n    let mut num_x = x;\n    let mut\
    \ num_base = base;\n    while num_x > 0 {\n        if num_base < 10 {\n      \
    \      res[res.len()-num_base.clone() as usize] = '0' + num_base.to_digit(10).unwrap();\n\
    \        } else {\n            res[res.len()-num_base.clone() as usize] = '0'\
    \ + num_base.to_digit(10).unwrap();\n        }\n        num_x -= num_base;\n \
    \       num_base /= base;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6xbuunun.rs:16:13\n\
    \   |\n16 |             res[res.len()-num_base.clone() as usize] = '0' + num_base.to_digit(10).unwrap();\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `to_digit` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp6xbuunun.rs:16:71\n   |\n16 |          \
    \   res[res.len()-num_base.clone() as usize] = '0' + num_base.to_digit(10).unwrap();\n\
    \   |                                                                       ^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp6xbuunun.rs:18:13\n   |\n18 |             res[res.len()-num_base.clone()\
    \ as usize] = '0' + num_base.to_digit(10).unwrap();\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `to_digit` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp6xbuunun.rs:18:71\n   |\n18 |          \
    \   res[res.len()-num_base.clone() as usize] ="
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    while x > 0 {\n        s.push((x % base).to_string());\n\
    \        x /= base;\n    }\n    s.push((x % base).to_string());\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_q9h9oox.rs:13:16\n   |\n\
    13 |         s.push((x % base).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp_q9h9oox.rs:16:12\n   |\n16 |     s.push((x % base).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut res = String::with_capacity(x.to_string().len() * base.to_string().len());\n\
    \    for x in x.to_string().chars().iter() {\n        if *x != '0' {\n       \
    \     match res {\n                Some(ref mut res) => res += *x,\n         \
    \       None => res += *x,\n            }\n        } else {\n            if base\
    \ > 2 {\n                match res {\n                    Some(ref mut res) =>\
    \ res += '0',\n                    None => res += '0',\n                }\n  \
    \          } else {\n                match res {\n                    Some(ref\
    \ mut res) => res += '1',\n                    None => res += '1',\n         \
    \       }\n            }\n        }\n    }\n    if base > 2 {\n        res\n \
    \   } else {\n        res.reverse()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmplbe9co2e.rs:12:36\n   |\n12 |     for x in x.to_string().chars().iter()\
    \ {\n   |                                    ^^^^ private field, not a method\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplbe9co2e.rs:15:17\n   |\n14 |\
    \             match res {\n   |                   --- this expression has type\
    \ `String`\n15 |                 Some(ref mut res) => res += *x,\n   |       \
    \          ^^^^^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n \
    \  |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplbe9co2e.rs:16:17\n   |\n14 |\
    \             match res {\n   |                   --- this expression has type\
    \ `String`\n15 |                 Some(ref mut res) => res += *x,\n16 |       \
    \          None => res += *x,\n   |                 ^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplbe9co2e.rs:21:21\n\
    \   |\n20 |                 match res {\n   |                       --- this expression\
    \ has type `String`\n21 |                     Some(ref mut res) => res += '0',\n\
    \   |                     ^^^^^^^^^^^^^^^^^ expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplbe9co2e.rs:22:21\n\
    \   |\n20 |                 match res {\n   |                       --- this expression\
    \ has type `String`\n21 |                     Some(ref mut res) => res += '0',\n\
    22 |                     None => res += '0',\n   |                     ^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<_>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut _`\n  --> /tmp/tmplbe9co2e.rs:21:42\n \
    \  |\n21 |                     Some(ref mut res) => res += '0',\n   |        \
    \               "
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 2 {\n        \"\".to_string()\n    } else {\n        let mut\
    \ buff = String::new();\n        let mut tmp = x;\n        let mut i = 0; // offset\
    \ of next digit\n        // Loop for every digit (except last) to be converted.\n\
    \        while i != base {\n            tmp = tmp / base;\n            buff.push(String::from_utf8_lossy(&(tmp\
    \ % base)).unwrap());\n            i += 1;\n        }\n        // add last digit\n\
    \        buff.push(String::from_utf8_lossy(&tmp).unwrap());\n        buff\n  \
    \  }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1_wdbmv2.rs:20:47\n   |\n\
    20 |             buff.push(String::from_utf8_lossy(&(tmp % base)).unwrap());\n\
    \   |                                               ^^^^^^^^^^^^^ expected slice\
    \ `[u8]`, found `isize`\n   |\n   = note: expected reference `&[u8]`\n       \
    \       found reference `&isize`\n\nerror[E0599]: no method named `unwrap` found\
    \ for enum `Cow<'_, str>` in the current scope\n  --> /tmp/tmp1_wdbmv2.rs:20:62\n\
    \   |\n20 |             buff.push(String::from_utf8_lossy(&(tmp % base)).unwrap());\n\
    \   |                                                              ^^^^^^ method\
    \ not found in `Cow<'_, str>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1_wdbmv2.rs:24:43\n\
    \   |\n24 |         buff.push(String::from_utf8_lossy(&tmp).unwrap());\n   | \
    \                                          ^^^^ expected slice `[u8]`, found `isize`\n\
    \   |\n   = note: expected reference `&[u8]`\n              found reference `&isize`\n\
    \nerror[E0599]: no method named `unwrap` found for enum `Cow<'_, str>` in the\
    \ current scope\n  --> /tmp/tmp1_wdbmv2.rs:24:49\n   |\n24 |         buff.push(String::from_utf8_lossy(&tmp).unwrap());\n\
    \   |                                                 ^^^^^^ method not found\
    \ in `Cow<'_, str>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if x < base {\n        let mut buff = String::new();\n        let mut\
    \ digits: Vec<String> = vec![\"\".to_string()];\n        while x >= base {\n \
    \           digits.push(format!(\"{}\", x / base).to_string());\n            x\
    \ -= base;\n        }\n        for (i, d) in digits.iter().enumerate() {\n   \
    \         buff.push(d);\n            if i < digits.len() - 1 {\n             \
    \   buff.push('-');\n            }\n        }\n        buff.push(\"0\".to_string());\n\
    \        return buff;\n    }\n    let mut buff = String::new();\n    let mut digits:\
    \ Vec<String> = vec![\"\".to_string()];\n    let mut rem = x;\n    while rem >\
    \ 0 {\n        digits.push(rem % base);\n        rem = rem / base;\n    }\n  \
    \  for (i, d) in digits.iter().enumerate() {\n        buff.push(d);\n        if\
    \ i < digits.len() - 1 {\n            buff.push('-');\n        }\n    }\n    buff.push(\"\
    0\".to_string());\n    return buff;\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3l0sbaky.rs:19:23\n   |\n\
    19 |             buff.push(d);\n   |                       ^ expected `char`,\
    \ found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3l0sbaky.rs:24:19\n\
    \   |\n24 |         buff.push(\"0\".to_string());\n   |                   ^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp3l0sbaky.rs:31:21\n   |\n31 |         digits.push(rem % base);\n\
    \   |                     ^^^^^^^^^^ expected struct `String`, found `isize`\n\
    \   |\nhelp: try using a conversion method\n   |\n31 |         digits.push((rem\
    \ % base).to_string());\n   |                     +          +++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3l0sbaky.rs:35:19\n   |\n35 |  \
    \       buff.push(d);\n   |                   ^ expected `char`, found `&String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3l0sbaky.rs:40:15\n   |\n40 |\
    \     buff.push(\"0\".to_string());\n   |               ^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 5 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 2 {\n        0..=base\n            .pow(base)\n           \
    \ .to_string()\n            .chars()\n            .map(|i| '0' + i as char).collect::<String>()\n\
    \    } else {\n        x.to_string().chars().map(|i| '0' + i as char).collect::<String>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaxsz7xv6.rs:13:18\n   |\n\
    13 |             .pow(base)\n   |                  ^^^^ expected `u32`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if the\
    \ converted value doesn't fit\n   |\n13 |             .pow(base.try_into().unwrap())\n\
    \   |                      ++++++++++++++++++++\n\nerror[E0369]: cannot add `char`\
    \ to `char`\n  --> /tmp/tmpaxsz7xv6.rs:16:26\n   |\n16 |             .map(|i|\
    \ '0' + i as char).collect::<String>()\n   |                      --- ^ ---------\
    \ char\n   |                      |\n   |                      char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaxsz7xv6.rs:12:13\n   |\n12 |           0..=base\n\
    \   |  _____________^\n13 | |             .pow(base)\n14 | |             .to_string()\n\
    15 | |             .chars()\n16 | |             .map(|i| '0' + i as char).collect::<String>()\n\
    \   | |_________________________________________________________^ expected integer,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaxsz7xv6.rs:12:9\n\
    \   |\n10 |   fn change_base(x: isize, base: isize) -> String {\n   |        \
    \                                    ------ expected `String` because of return\
    \ type\n11 |       if base < 2 {\n12 | /         0..=base\n13 | |            \
    \ .pow(base)\n14 | |             .to_string()\n15 | |             .chars()\n16\
    \ | |             .map(|i| '0' + i as char).collect::<String>()\n   | |_________________________________________________________^\
    \ expected struct `String`, found struct `RangeInclusive`\n   |\n   = note: expected\
    \ struct `String`\n              found struct `RangeInclusive<{integer}>`\n\n\
    error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpaxsz7xv6.rs:18:43\n \
    \  |\n18 |         x.to_string().chars().map(|i| '0' + i as char).collect::<String>()\n\
    \   |                                       --- ^ --------- char\n   |       \
    \                                |\n   |                                     \
    \  char\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information a"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut buf = [0u8; 32];\n    let mut v = x;\n    buf[base] = v;\n  \
    \  for digit in &buf[1..base.trunc_div()] {\n        v = (v * base) % 11;\n  \
    \      buf[digit as usize] = v;\n    }\n    let digits: Vec<&'static str> = buf.iter().map(|x|\
    \ x.to_string()).collect();\n    digits.reverse();\n    String::from_utf8(digits.as_slice()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[u8]` cannot be indexed by `isize`\n  --> /tmp/tmp54wl3j09.rs:13:5\n\
    \   |\n13 |     buf[base] = v;\n   |     ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `[u8]`\n\nerror[E0599]: no method named `trunc_div` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp54wl3j09.rs:14:31\n   |\n14 |     for digit\
    \ in &buf[1..base.trunc_div()] {\n   |                               ^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp54wl3j09.rs:16:31\n\
    \   |\n16 |         buf[digit as usize] = v;\n   |         -------------------\
    \   ^ expected `u8`, found `isize`\n   |         |\n   |         expected due\
    \ to the type of this binding\n\nerror[E0277]: a value of type `Vec<&str>` cannot\
    \ be built from an iterator over elements of type `String`\n    --> /tmp/tmp54wl3j09.rs:18:71\n\
    \     |\n18   |     let digits: Vec<&'static str> = buf.iter().map(|x| x.to_string()).collect();\n\
    \     |                                                                      \
    \ ^^^^^^^ value of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=String>`\n\
    \     |\n     = help: the trait `FromIterator<String>` is not implemented for\
    \ `Vec<&str>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp54wl3j09.rs:20:23\n   |\n20 |     String::from_utf8(digits.as_slice()).unwrap()\n\
    \   |                       ^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `&[&str]`\n\
    \   |\n   = note: expected struct `Vec<u8>`\n           found reference `&[&str]`\n\
    \nerror[E0606]: casting `&u8` as `usize` is invalid\n  --> /tmp/tmp54wl3j09.rs:16:13\n\
    \   |\n16 |         buf[digit as usize] = v;\n   |             -----^^^^^^^^^\n\
    \   |             |\n   |             cannot cast `&u8` as `usize`\n   |     \
    \        help: der"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    use self::Num::*;\n    let mut res = String::with_capacity(x);\n    while\
    \ x != 0 {\n        let remain = x % base;\n        res.insert(0, base.chars().nth(remain\
    \ as usize).unwrap());\n        x /= base;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0432]: unresolved import `self::Num`\n  --> /tmp/tmp9ldzea3j.rs:11:15\n\
    \   |\n11 |     use self::Num::*;\n   |               ^^^ maybe a missing crate\
    \ `Num`?\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ldzea3j.rs:12:41\n\
    \   |\n12 |     let mut res = String::with_capacity(x);\n   |                \
    \                         ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n12 |     let mut res = String::with_capacity(x.try_into().unwrap());\n\
    \   |                                          ++++++++++++++++++++\n\nerror[E0599]:\
    \ no method named `chars` found for type `isize` in the current scope\n  --> /tmp/tmp9ldzea3j.rs:15:28\n\
    \   |\n15 |         res.insert(0, base.chars().nth(remain as usize).unwrap());\n\
    \   |                            ^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0432,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    assert!(base > 0 && base < 10);\n    String::from_utf8(x.to_bytes(x.bits()\
    \ * base, LittleEndian))\n        .unwrap()\n        .to_string(base)\n      \
    \  .unwrap()\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `LittleEndian` in this scope\n  --> /tmp/tmpcou76blu.rs:12:51\n\
    \   |\n12 |     String::from_utf8(x.to_bytes(x.bits() * base, LittleEndian))\n\
    \   |                                                   ^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `to_bytes` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpcou76blu.rs:12:25\n   |\n12 |     String::from_utf8(x.to_bytes(x.bits()\
    \ * base, LittleEndian))\n   |                         ^^^^^^^^ help: there is\
    \ an associated function with a similar name: `to_be`\n\nerror[E0599]: no method\
    \ named `bits` found for type `isize` in the current scope\n  --> /tmp/tmpcou76blu.rs:12:36\n\
    \   |\n12 |     String::from_utf8(x.to_bytes(x.bits() * base, LittleEndian))\n\
    \   |                                    ^^^^ method not found in `isize`\n\n\
    error[E0061]: this function takes 0 arguments but 1 argument was supplied\n  \
    \  --> /tmp/tmpcou76blu.rs:14:10\n     |\n14   |         .to_string(base)\n  \
    \   |          ^^^^^^^^^ ---- supplied 1 argument\n     |          |\n     | \
    \         expected 0 arguments\n     |\nnote: associated function defined here\n\
    \nerror[E0599]: no method named `unwrap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpcou76blu.rs:15:10\n   |\n15 |         .unwrap()\n   | \
    \         ^^^^^^ method not found in `String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    format!(\"{}\", x / (base ** 2))\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpxniybfct.rs:11:30\n\
    \   |\n11 |     format!(\"{}\", x / (base ** 2))\n   |                       \
    \       ^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut xnum = x as isize;\n    let mut bnum = base;\n    while xnum\
    \ / bnum >= 10 {\n        xnum = (xnum / bnum) as isize;\n        bnum *= base;\n\
    \    }\n    format!(\"{}\", xnum / bnum as u64.to_string())\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpr7k129ix.rs:17:26\n\
    \   |\n17 |     format!(\"{}\", xnum / bnum as u64.to_string())\n   |        \
    \                  ^^^^^^^^^^^\n   |\nhelp: try surrounding the expression in\
    \ parentheses\n   |\n17 |     format!(\"{}\", xnum / (bnum as u64).to_string())\n\
    \   |                          +           +\n\nerror[E0277]: cannot divide `isize`\
    \ by `String`\n  --> /tmp/tmpr7k129ix.rs:17:24\n   |\n17 |     format!(\"{}\"\
    , xnum / bnum as u64.to_string())\n   |                        ^ no implementation\
    \ for `isize / String`\n   |\n   = help: the trait `Div<String>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n    \
    \         <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n      \
    \       <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n          \
    \   <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    // base cannot be 0\n    let base_digits = base::digits() - 1;\n    //\
    \ calculate x modulo base\n    let x_digits = x::digits() - 1;\n    let x_mod10\
    \ = x\n        .div_rem(base::from(base_digits))\n        .unwrap_or(Some(x));\n\
    \    // calculate y modulo base\n    let mut x_mod10_remainder = x_mod10.clone();\
    \ // start off with same value\n    x_mod10_remainder\n        .mod_exp(base::from(base_digits),\
    \ &base::from(x_digits))\n        .unwrap()\n        .ok_or(Error::BaseConversion(format!(\"\
    {}\", base), format!(\"{}\", x)))\n        .and_then(|y| y.checked_mul(base::from(base_digits)).ok_or(Error::BaseConversion(format!(\"\
    {}\", base), format!(\"{}\", x))));\n    // calculate remainder after multiplying\
    \ by base\n    let x_mod10_remainder = x_mod10_remainder.checked_add(&x_mod10).unwrap();\n\
    \    // if the remainder is 0, subtract 1 from x and convert to string using base\
    \ 10\n    if x_mod10_remainder.is_zero() {\n        // subtract 1 from x, convert\
    \ to string using base 10, then add 1 to base to get new base\n        let new_base\
    \ = base::from(base_digits) - 1 + base::from(x_digits);\n        x_mod10_remainder.checked_add(&base::from(x_digits)).ok_or(Error::BaseConversion(format!(\"\
    {}\", base), format!(\"{}\", x)))\n            .and_then(|remainder| remainder.checked_mul(base::from(new_base)).ok_or(Error::BaseConversion(format!(\"\
    {}\", base), format!(\"{}\", x))));\n    }\n    x_mod10_remainder.to_string()\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `base`\n\
    \  --> /tmp/tmpkzew07zb.rs:12:23\n   |\n12 |     let base_digits = base::digits()\
    \ - 1;\n   |                       ^^^^ use of undeclared crate or module `base`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `x`\n  -->\
    \ /tmp/tmpkzew07zb.rs:14:20\n   |\n14 |     let x_digits = x::digits() - 1;\n\
    \   |                    ^ use of undeclared crate or module `x`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `base`\n  --> /tmp/tmpkzew07zb.rs:16:18\n\
    \   |\n16 |         .div_rem(base::from(base_digits))\n   |                  ^^^^\
    \ use of undeclared crate or module `base`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `base`\n  --> /tmp/tmpkzew07zb.rs:21:18\n\
    \   |\n21 |         .mod_exp(base::from(base_digits), &base::from(x_digits))\n\
    \   |                  ^^^^ use of undeclared crate or module `base`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `base`\n  --> /tmp/tmpkzew07zb.rs:21:44\n\
    \   |\n21 |         .mod_exp(base::from(base_digits), &base::from(x_digits))\n\
    \   |                                            ^^^^ use of undeclared crate\
    \ or module `base`\n\nerror[E0433]: failed to resolve: use of undeclared crate\
    \ or module `base`\n  --> /tmp/tmpkzew07zb.rs:24:37\n   |\n24 |         .and_then(|y|\
    \ y.checked_mul(base::from(base_digits)).ok_or(Error::BaseConversion(format!(\"\
    {}\", base), format!(\"{}\", x))));\n   |                                    \
    \ ^^^^ use of undeclared crate or module `base`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `base`\n  --> /tmp/tmpkzew07zb.rs:30:24\n\
    \   |\n30 |         let new_base = base::from(base_digits) - 1 + base::from(x_digits);\n\
    \   |                        ^^^^ use of undeclared crate or module `base`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `base`\n  -->\
    \ /tmp/tmpkzew07zb.rs:30:54\n   |\n30 |         let new_base = base::from(base_digits)\
    \ - 1 + base::from(x_digits);\n   |                                          \
    \           "
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    use std::cmp::Ordering;\n    if base < 2 || base > 10 {\n        panic!(\"\
    Invalid base number: {}\", base);\n    }\n    if x <= 0 {\n        format!(\"\
    {}\", x)\n    } else {\n        let mut new_string = String::new();\n        let\
    \ mut digits = String::new();\n        let mut base = base;\n        let mut x\
    \ = x;\n        while x >= base {\n            digits.push_str(&x.to_string()[..]);\n\
    \            x /= base;\n        }\n        if x > 0 {\n            new_string.push_str(&format!(\"\
    {}\", x));\n        } else {\n            while x >= 10 {\n                new_string.push_str(&format!(\"\
    {}\", x));\n                x /= 10;\n            }\n            new_string.push_str(&digits.to_string());\n\
    \        }\n        new_string\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"2\"`,\n right: `\"22\"`', /tmp/tmpscd7rywz.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut new_base = base;\n    let mut digits = String::new();\n    while\
    \ x >= base {\n        x = x / base;\n        new_base += 1;\n    }\n    while\
    \ x < base {\n        digits.push(format!(\"{}\", x%base));\n        x = x / base;\n\
    \    }\n    if new_base == base {\n        digits\n    } else {\n        digits.push(format!(\"\
    {}\", x%base))\n    }\n}\n\nfn main() {\n    let candidate = change_base;\n  \
    \  assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprlts8en6.rs:18:21\n   |\n\
    18 |         digits.push(format!(\"{}\", x%base));\n   |                     ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n   |\n   = note: this error originates\
    \ in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprlts8en6.rs:24:21\n \
    \  |\n24 |         digits.push(format!(\"{}\", x%base))\n   |                \
    \     ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n   =\
    \ note: this error originates in the macro `format` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprlts8en6.rs:24:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                ------ expected `String` because of return type\n\
    ...\n24 |         digits.push(format!(\"{}\", x%base))\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push` modifies its\
    \ receiver in-place\n  --> /tmp/tmprlts8en6.rs:24:16\n   |\n24 |         digits.push(format!(\"\
    {}\", x%base))\n   |         ------ ^^^^ this call modifies `digits` in-place\n\
    \   |         |\n   |         you probably want to use this value after calling\
    \ the method...\n   = note: ...instead of the `()` output of method `push`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    // convert from binary to decimal and divide by base\n    let mut result\
    \ = String::from(\"\".to_string());\n    while x != 0 {\n        let rem = x %\
    \ base;\n        result = format!(\"{:0>5}\", rem) + &result;\n        x = x /\
    \ base;\n    }\n\n    if base == 10 {\n        result = format!(\"{}\", x)\n \
    \   } else {\n        result = format!(\"{}b\", x)\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmprvwdnrmz.rs:16:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n16 |      \
    \   x = x / base;\n   |         ^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    match base {\n        2 => {\n            let mut res = String::new();\n\
    \            while x < 10 {\n                res.push((x / 10).to_string());\n\
    \                x = x % 10;\n            }\n            if x > 0 {\n        \
    \        res.push((x / 10).to_string());\n                res.push((x % 10).to_string());\n\
    \            } else {\n                res.push((x % 10).to_string());\n     \
    \       }\n            res\n        }\n        3 | 5 => format!(\"{}{:b}\", x\
    \ / 10.0, x / 10.0 % 10.0, x % 10),\n        7 | 9 => format!(\"{}{:b}\", x /\
    \ 10.0, (x % 10) * (x / 10.0 % 10.0)),\n        _ => format!(\"{}{:b}\", x / 10.0,\
    \ (x % 10) * (x / 10.0 % 10.0))\n    }\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: argument never used\n  --> /tmp/tmppyfag95u.rs:26:63\n   |\n26 |\
    \         3 | 5 => format!(\"{}{:b}\", x / 10.0, x / 10.0 % 10.0, x % 10),\n \
    \  |                          --------                             ^^^^^^ argument\
    \ never used\n   |                          |\n   |                          formatting\
    \ specifier missing\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppyfag95u.rs:15:26\n\
    \   |\n15 |                 res.push((x / 10).to_string());\n   |            \
    \              ^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmppyfag95u.rs:19:26\n   |\n19 |  \
    \               res.push((x / 10).to_string());\n   |                        \
    \  ^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppyfag95u.rs:20:26\n   |\n20 |              \
    \   res.push((x % 10).to_string());\n   |                          ^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmppyfag95u.rs:22:26\n   |\n22 |                 res.push((x % 10).to_string());\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0277]: cannot divide `isize` by `{float}`\n  --> /tmp/tmppyfag95u.rs:26:38\n\
    \   |\n26 |         3 | 5 => format!(\"{}{:b}\", x / 10.0, x / 10.0 % 10.0, x\
    \ % 10),\n   |                                      ^ no implementation for `isize\
    \ / {float}`\n   |\n   = help: the trait `Div<{float}>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n    \
    \         <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n      \
    \       <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n          \
    \   <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\n\nerror[E0277]: cannot divide `isize` by `{float}`\n  --> /tmp/tmppyfag95u.rs:26:48\n\
    \   |\n26 |         3 | 5 => format!(\"{}{:b}\", x / 10.0, x / 10.0 % 10.0, x\
    \ % 10),\n   |               "
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    if x < 10 {\n        s.push_str(&format!(\"\
    {:0>2}\", x));\n    } else {\n        match base {\n            0 => {\n     \
    \           s.push_str(&format!(\"{:0>5}\", x));\n            }\n            1\
    \ => {\n                s.push_str(&format!(\"{:0>5}\", x / 10));\n          \
    \      s.push_str(&format!(\"{:0>5}\", x % 10));\n            }\n            2\
    \ => {\n                s.push_str(&format!(\"{:0>5}\", x / 100));\n         \
    \       s.push_str(&format!(\"{:0>5}\", x % 100));\n                s.push_str(&format!(\"\
    {:0>5}\", x % 10));\n            }\n            3 => {\n                s.push_str(&format!(\"\
    {:0>5}\", x / 1000));\n                s.push_str(&format!(\"{:0>5}\", x % 1000));\n\
    \                s.push_str(&format!(\"{:0>5}\", x % 100));\n                s.push_str(&format!(\"\
    {:0>5}\", x % 10));\n            }\n            4 => {\n                s.push_str(&format!(\"\
    {:0>5}\", x / 10000));\n                s.push_str(&format!(\"{:0>5}\", x % 10000));\n\
    \                s.push_str(&format!(\"{:0>5}\", x % 1000));\n               \
    \ s.push_str(&format!(\"{:0>5}\", x % 100));\n                s.push_str(&format!(\"\
    {:0>5}\", x % 10));\n            }\n            5 => {\n                s.push_str(&format!(\"\
    {:0>5}\", x / 100000));\n                s.push_str(&format!(\"{:0>5}\", x % 100000));\n\
    \                s.push_str(&format!(\"{:0>5}\", x % 10000));\n              \
    \  s.push_str(&format!(\"{:0>5}\", x % 1000));\n                s.push_str(&format!(\"\
    {:0>5}\", x % 100));\n                s.push_str(&format!(\"{:0>5}\", x % 10));\n\
    \            }\n            6 => {\n                s.push_str(&format!(\"{:0>5}\"\
    , x / 1000000));\n                s.push_str(&format!(\"{:0>5}\", x % 1000000));\n\
    \                s.push_str(&format!(\"{:0>5}\", x % 100000));\n             \
    \   s.push_str(&format!(\"{:0>5\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp6w1eqzqg.rs:69:48\n\
    \   |\n69 |       assert_eq!(candidate(7, 8), String::from(\"7\"));\n   |  ________________________________________________^\n\
    70 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    if base < 10 {\n        return format!(\"{}\", x).to_string();\n    }\n\
    \    let mut num: usize = 0;\n    let mut rem = x;\n    loop {\n        if rem\
    \ < base {\n            num += 1;\n            rem /= base;\n        } else {\n\
    \            num %= base;\n            rem -= base;\n        }\n        if num\
    \ == 0 {\n            return format!(\"{}\", rem).to_string();\n        }\n  \
    \  }\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq_qflw6w.rs:21:20\n   |\n\
    21 |             num %= base;\n   |                    ^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot mod-assign `usize` by `isize``\n  -->\
    \ /tmp/tmpq_qflw6w.rs:21:17\n   |\n21 |             num %= base;\n   |       \
    \          ^^ no implementation for `usize %= isize`\n   |\n   = help: the trait\
    \ `RemAssign<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `RemAssign<Rhs>`:\n             <f32 as RemAssign<&f32>>\n\
    \             <f32 as RemAssign>\n             <f64 as RemAssign<&f64>>\n    \
    \         <f64 as RemAssign>\n             <i128 as RemAssign<&i128>>\n      \
    \       <i128 as RemAssign>\n             <i16 as RemAssign<&i16>>\n         \
    \    <i16 as RemAssign>\n           and 20 others\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    match (base.to_digits() as u8).cmp(&base) {\n        Ordering::Less =>\
    \ {\n            match (x.to_digits() as u8).cmp(&base) {\n                Ordering::Less\
    \ => {\n                    let mut res = String::with_capacity(x.to_digits()\
    \ * base.to_digits() + 1);\n                    while x.to_digits() > 0 {\n  \
    \                      if x % base == 0 {\n                            res +=\
    \ &base;\n                        } else {\n                            res +=\
    \ &x;\n                            x /= base;\n                        }\n   \
    \                 }\n                    res\n                }\n            \
    \    Ordering::Greater => panic!(\"base must not be larger than the highest digit\"\
    ),\n                Ordering::Equal => panic!(\"base must not be equal to any\
    \ digit\"),\n            }\n        }\n        Ordering::Greater => panic!(\"\
    base must not be larger than the highest digit\"),\n        Ordering::Equal =>\
    \ panic!(\"base must not be equal to any digit\"),\n    }\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp03v8sj38.rs:12:9\n   |\n12 |         Ordering::Less => {\n   |     \
    \    ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmp03v8sj38.rs:14:17\n   |\n14\
    \ |                 Ordering::Less => {\n   |                 ^^^^^^^^ use of\
    \ undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmp03v8sj38.rs:26:17\n   |\n26 |               \
    \  Ordering::Greater => panic!(\"base must not be larger than the highest digit\"\
    ),\n   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp03v8sj38.rs:27:17\n\
    \   |\n27 |                 Ordering::Equal => panic!(\"base must not be equal\
    \ to any digit\"),\n   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp03v8sj38.rs:30:9\n\
    \   |\n30 |         Ordering::Greater => panic!(\"base must not be larger than\
    \ the highest digit\"),\n   |         ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp03v8sj38.rs:31:9\n\
    \   |\n31 |         Ordering::Equal => panic!(\"base must not be equal to any\
    \ digit\"),\n   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp03v8sj38.rs:11:17\n   |\n11 |     match (base.to_digits() as u8).cmp(&base)\
    \ {\n   |                 ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp03v8sj38.rs:13:22\n   |\n13 |             match (x.to_digits() as u8).cmp(&base)\
    \ {\n   |                      ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp03v8sj38.rs:15:59\n   |\n15 |                    "
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    use num_bigint::BigInt;\n    let mut r = BigInt::new(0);\n    let mut\
    \ x_n = BigInt::new(x);\n    while x_n.is_power_of_two() {\n        let b = x_n.clone();\n\
    \        let r = r.mul(base);\n        if r.is_power_of_two() {\n            r.add(b);\n\
    \        } else {\n            r.add(&b[..]);\n        }\n        x_n = r.clone()\
    \ % base;\n    }\n    r.to_string(base)\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error[E0432]: unresolved import `num_bigint`\n  --> /tmp/tmpu06zqoh0.rs:11:9\n\
    \   |\n11 |     use num_bigint::BigInt;\n   |         ^^^^^^^^^^ maybe a missing\
    \ crate `num_bigint`?\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0432`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut x = x.to_digits();\n    let mut base = 10;\n    while *x <= base\
    \ {\n        *x = *x + base;\n        base = base * 10;\n    }\n    x.to_ascii_uppercase()\n\
    \        .collect::<Vec<_>>()\n        .join(\"\".to_string())\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp22u5us6u.rs:11:19\n   |\n11 |     let mut x = x.to_digits();\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s = String::new();\n    if base < 10 {\n        s.push_str(&to_base(x,\
    \ base));\n    } else {\n        // base is greater than 10\n        let mut num\
    \ = 1;\n        for digit in to_base(x, base) {\n            num *= base;\n  \
    \          s.push_str(&to_base(num, base));\n            num += digit;\n     \
    \   }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_base` in this scope\n  --> /tmp/tmpkf44b05g.rs:13:21\n\
    \   |\n13 |         s.push_str(&to_base(x, base));\n   |                     ^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `to_base` in this\
    \ scope\n  --> /tmp/tmpkf44b05g.rs:17:22\n   |\n17 |         for digit in to_base(x,\
    \ base) {\n   |                      ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `to_base` in this scope\n  --> /tmp/tmpkf44b05g.rs:19:25\n\
    \   |\n19 |             s.push_str(&to_base(num, base));\n   |               \
    \          ^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut numer = x / base;\n    let remainder = x % base;\n    if remainder\
    \ != 0 {\n        numer = numer + 1;\n    }\n\n    let mut result = String::new();\n\
    \    for i in &[numer...] {\n        result.push(i);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `...`\n  --> /tmp/tmp35c_5rhf.rs:18:21\n   |\n\
    18 |     for i in &[numer...] {\n   |                     ^^^\n   |\nhelp: use\
    \ `..` for an exclusive range\n   |\n18 |     for i in &[numer..] {\n   |    \
    \                 ~~\nhelp: or `..=` for an inclusive range\n   |\n18 |     for\
    \ i in &[numer..=] {\n   |                     ~~~\n\nerror[E0586]: inclusive\
    \ range with no end\n  --> /tmp/tmp35c_5rhf.rs:18:21\n   |\n18 |     for i in\
    \ &[numer...] {\n   |                     ^^^ help: use `..` instead\n   |\n \
    \  = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0586`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    // Convert number to string representation in base base\n    let mut\
    \ string_representation = String::new();\n    let mut remainder = x as i32;\n\
    \    for i in 0..base.abs() {\n        let mut remainder_new = remainder;\n  \
    \      if i as i32 >= base as i32 {\n            remainder_new /= base as i32;\n\
    \        } else {\n            remainder_new *= base as i32;\n        }\n    \
    \    string_representation.push_str(&format!(\"{:0{}b}\", remainder_new, base));\n\
    \        remainder -= remainder_new;\n    }\n    if remainder != 0 {\n       \
    \ let mut remainder_new = remainder;\n        string_representation.push_str(&format!(\"\
    {:0{}b}\", remainder_new, base));\n    }\n    return string_representation;\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmprd20zqil.rs:21:53\n\
    \   |\n21 |         string_representation.push_str(&format!(\"{:0{}b}\", remainder_new,\
    \ base));\n   |                                                  -  ^ expected\
    \ `}` in format string\n   |                                                 \
    \ |\n   |                                                  because of this opening\
    \ brace\n   |\n   = note: if you intended to print `{`, you can escape it using\
    \ `{{`\n\nerror: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmprd20zqil.rs:26:53\n\
    \   |\n26 |         string_representation.push_str(&format!(\"{:0{}b}\", remainder_new,\
    \ base));\n   |                                                  -  ^ expected\
    \ `}` in format string\n   |                                                 \
    \ |\n   |                                                  because of this opening\
    \ brace\n   |\n   = note: if you intended to print `{`, you can escape it using\
    \ `{{`\n\nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n///\
    \ >>> change_base(7, 2)\n/// '111'\nfn change_base(x: isize, base: isize) -> String\
    \ {\n    let mut s: Vec<u8> = Vec::new();\n    let mut i = 0;\n    let mut carry\
    \ = 0;\n\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n  \
    \  for &digit in digits {\n        let base10 = digit as isize;\n        if base10\
    \ >= base {\n            let mut next_digit = digit as usize;\n            while\
    \ carry++ < base10 {\n                next_digit += carry;\n            }\n  \
    \          i += next_digit as u8;\n        }\n        i += digit as i8;\n    }\n\
    \    String::from_utf8(s.as_slice()).to_string()\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp573nenz7.rs:20:24\n\
    \   |\n20 |             while carry++ < base10 {\n   |             -----     \
    \ ^^ not a valid postfix operator\n   |             |\n   |             while\
    \ parsing the condition of this `while` expression\n   |\nhelp: use `+= 1` instead\n\
    \   |\n20 |             while { let tmp = carry; carry += 1; tmp } < base10 {\n\
    \   |                   +++++++++++      ~~~~~~~~~~~~~~~~~~~\n20 -           \
    \  while carry++ < base10 {\n20 +             while carry += 1 < base10 {\n  \
    \ | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp573nenz7.rs:16:9\n   |\n\
    16 |     for &digit in digits {\n   |         ^^^^^^    ------ this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `digit`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp573nenz7.rs:27:23\n   |\n27 |  \
    \   String::from_utf8(s.as_slice()).to_string()\n   |                       ^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_vec()`\n   |                     \
    \  |\n   |                       expected struct `Vec`, found `&[u8]`\n   |\n\
    \   = note: expected struct `Vec<u8>`\n           found reference `&[u8]`\n\n\
    error[E0599]: `Result<String, FromUtf8Error>` doesn't implement `std::fmt::Display`\n\
    \   --> /tmp/tmp573nenz7.rs:27:37\n    |\n27  |       String::from_utf8(s.as_slice()).to_string()\n\
    \    |                                       ^^^^^^^^^ `Result<String, FromUtf8Error>`\
    \ cannot be formatted with the default formatter\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Result<String, FromUtf8Error>:\
    \ std::fmt::Display`\n            which is required by `Result<String, FromUtf8Error>:\
    \ ToString`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
